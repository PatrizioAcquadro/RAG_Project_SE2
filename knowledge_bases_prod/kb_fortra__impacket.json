[
  "def read(fname):\n    return open(os.path.join(os.path.dirname(__file__), fname)).read()",
  "class REG_REGF(Structure):\n    structure = (\n        ('Magic','\"regf'),\n        ('Unknown','<L=0'),\n        ('Unknown2','<L=0'),\n        ('lastChange','<Q=0'),\n        ('MajorVersion','<L=0'),\n        ('MinorVersion','<L=0'),\n        ('0','<L=0'),\n        ('11','<L=0'),\n        ('OffsetFirstRecord','<L=0'),\n        ('DataSize','<L=0'),\n        ('1111','<L=0'),\n        ('Name','48s=\"\"'),\n        ('Remaining1','411s=b\"\"'),\n        ('CheckSum','<L=0xffffffff'), # Sum of all DWORDs from 0x0 to 0x1FB\n        ('Remaining2','3585s=b\"\"'),\n    )",
  "class REG_HBIN(Structure):\n    structure = (\n        ('Magic','\"hbin'),\n        ('OffsetFirstHBin','<L=0'),\n        ('OffsetNextHBin','<L=0'),\n        ('BlockSize','<L=0'),\n    )",
  "class REG_HBINBLOCK(Structure):\n    structure = (\n        ('DataBlockSize','<l=0'),\n        ('_Data','_-Data','self[\"DataBlockSize\"]*(-1)-4'),\n        ('Data',':'),\n    )",
  "class REG_NK(Structure):\n    structure = (\n        ('Magic','\"nk'),\n        ('Type','<H=0'),\n        ('lastChange','<Q=0'),\n        ('Unknown','<L=0'),\n        ('OffsetParent','<l=0'),\n        ('NumSubKeys','<L=0'),\n        ('Unknown2','<L=0'),\n        ('OffsetSubKeyLf','<l=0'),\n        ('Unknown3','<L=0'),\n        ('NumValues','<L=0'),\n        ('OffsetValueList','<l=0'),\n        ('OffsetSkRecord','<l=0'),\n        ('OffsetClassName','<l=0'),\n        ('UnUsed','20s=b\"\"'),\n        ('NameLength','<H=0'),\n        ('ClassNameLength','<H=0'),\n        ('_KeyName','_-KeyName','self[\"NameLength\"]'),\n        ('KeyName',':'),\n    )",
  "class REG_VK(Structure):\n    structure = (\n        ('Magic','\"vk'),\n        ('NameLength','<H=0'),\n        ('DataLen','<l=0'),\n        ('OffsetData','<L=0'),\n        ('ValueType','<L=0'),\n        ('Flag','<H=0'),\n        ('UnUsed','<H=0'),\n        ('_Name','_-Name','self[\"NameLength\"]'),\n        ('Name',':'),\n    )",
  "class REG_LF(Structure):\n    structure = (\n        ('Magic','\"lf'),\n        ('NumKeys','<H=0'),\n        ('HashRecords',':'),\n    )",
  "class REG_LH(Structure):\n    structure = (\n        ('Magic','\"lh'),\n        ('NumKeys','<H=0'),\n        ('HashRecords',':'),\n    )",
  "class REG_RI(Structure):\n    structure = (\n        ('Magic','\"ri'),\n        ('NumKeys','<H=0'),\n        ('HashRecords',':'),\n    )",
  "class REG_SK(Structure):\n    structure = (\n        ('Magic','\"sk'),\n        ('UnUsed','<H=0'),\n        ('OffsetPreviousSk','<l=0'),\n        ('OffsetNextSk','<l=0'),\n        ('UsageCounter','<L=0'),\n        ('SizeSk','<L=0'),\n        ('Data',':'),\n    )",
  "class REG_HASH(Structure):\n    structure = (\n        ('OffsetNk','<L=0'),\n        ('KeyName','4s=b\"\"'),\n    )",
  "class Registry:\n    def __init__(self, hive, isRemote = False):\n        self.__hive = hive\n        if isRemote is True:\n            self.fd = self.__hive\n            self.__hive.open()\n        else:\n            self.fd = open(hive,'rb')\n        data = self.fd.read(4096)\n        self.__regf = REG_REGF(data)\n        self.indent = ''\n        self.rootKey = self.__findRootKey()\n        if self.rootKey is None:\n            LOG.error(\"Can't find root key!\")\n        elif self.__regf['MajorVersion'] != 1 and self.__regf['MinorVersion'] > 5:\n            LOG.warning(\"Unsupported version (%d.%d) - things might not work!\" % (self.__regf['MajorVersion'], self.__regf['MinorVersion']))\n\n    def close(self):\n        self.fd.close()\n\n    def __del__(self):\n        self.close()\n\n    def __findRootKey(self):\n        self.fd.seek(0,0)\n        data = self.fd.read(4096)\n        while len(data) > 0:\n            try:\n                hbin = REG_HBIN(data[:0x20])\n                # Read the remaining bytes for this hbin\n                data += self.fd.read(hbin['OffsetNextHBin']-4096)\n                data = data[0x20:]\n                blocks = self.__processDataBlocks(data)\n                for block in blocks:\n                    if isinstance(block, REG_NK):\n                        if block['Type'] == ROOT_KEY:\n                            return block\n            except Exception as e:\n                pass\n            data = self.fd.read(4096)\n\n        return None\n\n\n    def __getBlock(self, offset):\n        self.fd.seek(4096+offset,0)\n        sizeBytes = self.fd.read(4)\n        data = sizeBytes + self.fd.read(unpack('<l',sizeBytes)[0]*-1-4)\n        if len(data) == 0:\n            return None\n        else:\n            block = REG_HBINBLOCK(data)\n            if block['Data'][:2] in StructMappings:\n                return StructMappings[block['Data'][:2]](block['Data'])\n            else:\n                LOG.debug(\"Unknown type 0x%s\" % block['Data'][:2])\n                return block\n            return None\n\n    def __getValueBlocks(self, offset, count):\n        valueList = []\n        res = []\n        self.fd.seek(4096+offset,0)\n        for i in range(count):\n            valueList.append(unpack('<l',self.fd.read(4))[0])\n\n        for valueOffset in valueList:\n            if valueOffset > 0:\n                block = self.__getBlock(valueOffset)\n                res.append(block)\n        return res\n\n    def __getData(self, offset, count):\n        self.fd.seek(4096+offset, 0)\n        return self.fd.read(count)[4:]\n\n    def __processDataBlocks(self,data):\n        res = []\n        while len(data) > 0:\n            #blockSize = unpack('<l',data[:calcsize('l')])[0]\n            blockSize = unpack('<l',data[:4])[0]\n            block = REG_HBINBLOCK()\n            if blockSize > 0:\n                tmpList = list(block.structure)\n                tmpList[1] = ('_Data','_-Data','self[\"DataBlockSize\"]-4')\n                block.structure =  tuple(tmpList)\n\n            block.fromString(data)\n            blockLen = len(block)\n\n            if block['Data'][:2] in StructMappings:\n                block = StructMappings[block['Data'][:2]](block['Data'])\n\n            res.append(block)\n            data = data[blockLen:]\n        return res\n\n    def __getValueData(self, rec):\n        # We should receive a VK record\n        if rec['DataLen'] == 0:\n            return ''\n        if rec['DataLen'] < 0:\n            # if DataLen < 5 the value itself is stored in the Offset field\n            return rec['OffsetData']\n        else:\n            return self.__getData(rec['OffsetData'], rec['DataLen']+4)\n\n    def __getLhHash(self, key):\n        res = 0\n        for bb in key.upper():\n            res *= 37\n            res += ord(bb)\n        return res % 0x100000000\n\n    def __compareHash(self, magic, hashData, key):\n        if magic == 'lf':\n            hashRec = REG_HASH(hashData)\n            if hashRec['KeyName'].strip(b'\\x00') == b(key[:4]):\n                return hashRec['OffsetNk']\n        elif magic == 'lh':\n            hashRec = REG_HASH(hashData)\n            if unpack('<L',hashRec['KeyName'])[0] == self.__getLhHash(key):\n                return hashRec['OffsetNk']\n        elif magic == 'ri':\n            # Special case here, don't know exactly why, an ri pointing to a NK :-o\n            offset = unpack('<L', hashData[:4])[0]\n            nk = self.__getBlock(offset)\n            if nk['KeyName'] == key:\n                return offset\n        else:\n            LOG.critical(\"UNKNOWN Magic %s\" % magic)\n            sys.exit(1)\n\n        return None\n\n    def __findSubKey(self, parentKey, subKey):\n        lf = self.__getBlock(parentKey['OffsetSubKeyLf'])\n        if lf is not None:\n            data = lf['HashRecords']\n            # Let's search the hash records for the name\n            if lf['Magic'] == 'ri':\n                # ri points to lf/lh records, so we must parse them before\n                records = b''\n                for i in range(lf['NumKeys']):\n                    offset = unpack('<L', data[:4])[0]\n                    l = self.__getBlock(offset)\n                    records = records + l['HashRecords'][:l['NumKeys']*8]\n                    data = data[4:]\n                data = records\n\n            #for record in range(lf['NumKeys']):\n            for record in range(parentKey['NumSubKeys']):\n                hashRec = data[:8]\n                res = self.__compareHash(lf['Magic'], hashRec, subKey)\n                if res is not None:\n                    # We have a match, now let's check the whole record\n                    nk = self.__getBlock(res)\n                    if nk['KeyName'].decode('utf-8') == subKey:\n                        return nk\n                data = data[8:]\n\n        return None\n\n    def __walkSubNodes(self, rec):\n        nk = self.__getBlock(rec['OffsetNk'])\n        if isinstance(nk, REG_NK):\n            print(\"%s%s\" % (self.indent, nk['KeyName'].decode('utf-8')))\n            self.indent += '  '\n            if nk['OffsetSubKeyLf'] < 0:\n                self.indent = self.indent[:-2]\n                return\n            lf = self.__getBlock(nk['OffsetSubKeyLf'])\n        else:\n            lf = nk\n\n        data = lf['HashRecords']\n\n        if lf['Magic'] == 'ri':\n            # ri points to lf/lh records, so we must parse them before\n            records = ''\n            for i in range(lf['NumKeys']):\n                offset = unpack('<L', data[:4])[0]\n                l = self.__getBlock(offset)\n                records = records + l['HashRecords'][:l['NumKeys']*8]\n                data = data[4:]\n            data = records\n\n        for key in range(lf['NumKeys']):\n            hashRec = REG_HASH(data[:8])\n            self.__walkSubNodes(hashRec)\n            data = data[8:]\n\n        if isinstance(nk, REG_NK):\n            self.indent = self.indent[:-2]\n\n    def walk(self, parentKey):\n        key = self.findKey(parentKey)\n\n        if key is None or key['OffsetSubKeyLf'] < 0:\n            return\n\n        lf = self.__getBlock(key['OffsetSubKeyLf'])\n        data = lf['HashRecords']\n        for record in range(lf['NumKeys']):\n            hashRec = REG_HASH(data[:8])\n            self.__walkSubNodes(hashRec)\n            data = data[8:]\n\n    def findKey(self, key):\n        # Let's strip '\\' from the beginning, except for the case of\n        # only asking for the root node\n        if key[0] == '\\\\' and len(key) > 1:\n            key = key[1:]\n\n        parentKey = self.rootKey\n        if len(key) > 0 and key[0]!='\\\\':\n            for subKey in key.split('\\\\'):\n                res = self.__findSubKey(parentKey, subKey)\n                if res is not None:\n                    parentKey = res\n                else:\n                    #LOG.error(\"Key %s not found!\" % key)\n                    return None\n\n        return parentKey\n\n    def printValue(self, valueType, valueData):\n        if valueType in [REG_SZ, REG_EXPAND_SZ, REG_MULTISZ]:\n            if isinstance(valueData, int):\n                print('NULL')\n            else:\n                print(\"%s\" % (valueData.decode('utf-16le')))\n        elif valueType == REG_BINARY:\n            print('')\n            hexdump(valueData, self.indent)\n        elif valueType == REG_DWORD:\n            print(\"%d\" % valueData)\n        elif valueType == REG_QWORD:\n            print(\"%d\" % (unpack('<Q',valueData)[0]))\n        elif valueType == REG_NONE:\n            try:\n                if len(valueData) > 1:\n                    print('')\n                    hexdump(valueData, self.indent)\n                else:\n                    print(\" NULL\")\n            except:\n                print(\" NULL\")\n        else:\n            print(\"Unknown Type 0x%x!\" % valueType)\n            hexdump(valueData)\n\n    def enumKey(self, parentKey):\n        res = []\n        # If we're here.. we have a valid NK record for the key\n        # Now let's searcht the subkeys\n        if parentKey['NumSubKeys'] > 0:\n            lf = self.__getBlock(parentKey['OffsetSubKeyLf'])\n            data = lf['HashRecords']\n\n            if lf['Magic'] == 'ri':\n                # ri points to lf/lh records, so we must parse them before\n                records = ''\n                for i in range(lf['NumKeys']):\n                    offset = unpack('<L', data[:4])[0]\n                    l = self.__getBlock(offset)\n                    records = records + l['HashRecords'][:l['NumKeys']*8]\n                    data = data[4:]\n                data = records\n\n            for i in range(parentKey['NumSubKeys']):\n                hashRec = REG_HASH(data[:8])\n                nk = self.__getBlock(hashRec['OffsetNk'])\n                data = data[8:]\n                res.append('%s'%nk['KeyName'].decode('utf-8'))\n        return res\n\n    def enumValues(self,key):\n        # If we're here.. we have a valid NK record for the key\n        # Now let's search its values\n        resp = []\n        if key['NumValues'] > 0:\n            valueList = self.__getValueBlocks(key['OffsetValueList'], key['NumValues']+1)\n\n            for value in valueList:\n                if value['Flag'] > 0:\n                    resp.append(value['Name'])\n                else:\n                    resp.append(b'default')\n\n        return resp\n\n    def getValue(self, keyValue):\n        # returns a tuple with (ValueType, ValueData) for the requested keyValue\n        regKey = ntpath.dirname(keyValue)\n        regValue = ntpath.basename(keyValue)\n\n        key = self.findKey(regKey)\n\n        if key is None:\n            return None\n\n        if key['NumValues'] > 0:\n            valueList = self.__getValueBlocks(key['OffsetValueList'], key['NumValues']+1)\n\n            for value in valueList:\n                if value['Name'] == b(regValue):\n                    return value['ValueType'], self.__getValueData(value)\n                elif regValue == 'default' and value['Flag'] <=0:\n                    return value['ValueType'], self.__getValueData(value)\n\n        return None\n\n    def getClass(self, className):\n\n        key = self.findKey(className)\n\n        if key is None:\n            return None\n\n        #print key.dump()\n        if key['OffsetClassName'] > 0:\n            value = self.__getBlock(key['OffsetClassName'])\n            return value['Data']",
  "def __init__(self, hive, isRemote = False):\n        self.__hive = hive\n        if isRemote is True:\n            self.fd = self.__hive\n            self.__hive.open()\n        else:\n            self.fd = open(hive,'rb')\n        data = self.fd.read(4096)\n        self.__regf = REG_REGF(data)\n        self.indent = ''\n        self.rootKey = self.__findRootKey()\n        if self.rootKey is None:\n            LOG.error(\"Can't find root key!\")\n        elif self.__regf['MajorVersion'] != 1 and self.__regf['MinorVersion'] > 5:\n            LOG.warning(\"Unsupported version (%d.%d) - things might not work!\" % (self.__regf['MajorVersion'], self.__regf['MinorVersion']))",
  "def close(self):\n        self.fd.close()",
  "def __del__(self):\n        self.close()",
  "def __findRootKey(self):\n        self.fd.seek(0,0)\n        data = self.fd.read(4096)\n        while len(data) > 0:\n            try:\n                hbin = REG_HBIN(data[:0x20])\n                # Read the remaining bytes for this hbin\n                data += self.fd.read(hbin['OffsetNextHBin']-4096)\n                data = data[0x20:]\n                blocks = self.__processDataBlocks(data)\n                for block in blocks:\n                    if isinstance(block, REG_NK):\n                        if block['Type'] == ROOT_KEY:\n                            return block\n            except Exception as e:\n                pass\n            data = self.fd.read(4096)\n\n        return None",
  "def __getBlock(self, offset):\n        self.fd.seek(4096+offset,0)\n        sizeBytes = self.fd.read(4)\n        data = sizeBytes + self.fd.read(unpack('<l',sizeBytes)[0]*-1-4)\n        if len(data) == 0:\n            return None\n        else:\n            block = REG_HBINBLOCK(data)\n            if block['Data'][:2] in StructMappings:\n                return StructMappings[block['Data'][:2]](block['Data'])\n            else:\n                LOG.debug(\"Unknown type 0x%s\" % block['Data'][:2])\n                return block\n            return None",
  "def __getValueBlocks(self, offset, count):\n        valueList = []\n        res = []\n        self.fd.seek(4096+offset,0)\n        for i in range(count):\n            valueList.append(unpack('<l',self.fd.read(4))[0])\n\n        for valueOffset in valueList:\n            if valueOffset > 0:\n                block = self.__getBlock(valueOffset)\n                res.append(block)\n        return res",
  "def __getData(self, offset, count):\n        self.fd.seek(4096+offset, 0)\n        return self.fd.read(count)[4:]",
  "def __processDataBlocks(self,data):\n        res = []\n        while len(data) > 0:\n            #blockSize = unpack('<l',data[:calcsize('l')])[0]\n            blockSize = unpack('<l',data[:4])[0]\n            block = REG_HBINBLOCK()\n            if blockSize > 0:\n                tmpList = list(block.structure)\n                tmpList[1] = ('_Data','_-Data','self[\"DataBlockSize\"]-4')\n                block.structure =  tuple(tmpList)\n\n            block.fromString(data)\n            blockLen = len(block)\n\n            if block['Data'][:2] in StructMappings:\n                block = StructMappings[block['Data'][:2]](block['Data'])\n\n            res.append(block)\n            data = data[blockLen:]\n        return res",
  "def __getValueData(self, rec):\n        # We should receive a VK record\n        if rec['DataLen'] == 0:\n            return ''\n        if rec['DataLen'] < 0:\n            # if DataLen < 5 the value itself is stored in the Offset field\n            return rec['OffsetData']\n        else:\n            return self.__getData(rec['OffsetData'], rec['DataLen']+4)",
  "def __getLhHash(self, key):\n        res = 0\n        for bb in key.upper():\n            res *= 37\n            res += ord(bb)\n        return res % 0x100000000",
  "def __compareHash(self, magic, hashData, key):\n        if magic == 'lf':\n            hashRec = REG_HASH(hashData)\n            if hashRec['KeyName'].strip(b'\\x00') == b(key[:4]):\n                return hashRec['OffsetNk']\n        elif magic == 'lh':\n            hashRec = REG_HASH(hashData)\n            if unpack('<L',hashRec['KeyName'])[0] == self.__getLhHash(key):\n                return hashRec['OffsetNk']\n        elif magic == 'ri':\n            # Special case here, don't know exactly why, an ri pointing to a NK :-o\n            offset = unpack('<L', hashData[:4])[0]\n            nk = self.__getBlock(offset)\n            if nk['KeyName'] == key:\n                return offset\n        else:\n            LOG.critical(\"UNKNOWN Magic %s\" % magic)\n            sys.exit(1)\n\n        return None",
  "def __findSubKey(self, parentKey, subKey):\n        lf = self.__getBlock(parentKey['OffsetSubKeyLf'])\n        if lf is not None:\n            data = lf['HashRecords']\n            # Let's search the hash records for the name\n            if lf['Magic'] == 'ri':\n                # ri points to lf/lh records, so we must parse them before\n                records = b''\n                for i in range(lf['NumKeys']):\n                    offset = unpack('<L', data[:4])[0]\n                    l = self.__getBlock(offset)\n                    records = records + l['HashRecords'][:l['NumKeys']*8]\n                    data = data[4:]\n                data = records\n\n            #for record in range(lf['NumKeys']):\n            for record in range(parentKey['NumSubKeys']):\n                hashRec = data[:8]\n                res = self.__compareHash(lf['Magic'], hashRec, subKey)\n                if res is not None:\n                    # We have a match, now let's check the whole record\n                    nk = self.__getBlock(res)\n                    if nk['KeyName'].decode('utf-8') == subKey:\n                        return nk\n                data = data[8:]\n\n        return None",
  "def __walkSubNodes(self, rec):\n        nk = self.__getBlock(rec['OffsetNk'])\n        if isinstance(nk, REG_NK):\n            print(\"%s%s\" % (self.indent, nk['KeyName'].decode('utf-8')))\n            self.indent += '  '\n            if nk['OffsetSubKeyLf'] < 0:\n                self.indent = self.indent[:-2]\n                return\n            lf = self.__getBlock(nk['OffsetSubKeyLf'])\n        else:\n            lf = nk\n\n        data = lf['HashRecords']\n\n        if lf['Magic'] == 'ri':\n            # ri points to lf/lh records, so we must parse them before\n            records = ''\n            for i in range(lf['NumKeys']):\n                offset = unpack('<L', data[:4])[0]\n                l = self.__getBlock(offset)\n                records = records + l['HashRecords'][:l['NumKeys']*8]\n                data = data[4:]\n            data = records\n\n        for key in range(lf['NumKeys']):\n            hashRec = REG_HASH(data[:8])\n            self.__walkSubNodes(hashRec)\n            data = data[8:]\n\n        if isinstance(nk, REG_NK):\n            self.indent = self.indent[:-2]",
  "def walk(self, parentKey):\n        key = self.findKey(parentKey)\n\n        if key is None or key['OffsetSubKeyLf'] < 0:\n            return\n\n        lf = self.__getBlock(key['OffsetSubKeyLf'])\n        data = lf['HashRecords']\n        for record in range(lf['NumKeys']):\n            hashRec = REG_HASH(data[:8])\n            self.__walkSubNodes(hashRec)\n            data = data[8:]",
  "def findKey(self, key):\n        # Let's strip '\\' from the beginning, except for the case of\n        # only asking for the root node\n        if key[0] == '\\\\' and len(key) > 1:\n            key = key[1:]\n\n        parentKey = self.rootKey\n        if len(key) > 0 and key[0]!='\\\\':\n            for subKey in key.split('\\\\'):\n                res = self.__findSubKey(parentKey, subKey)\n                if res is not None:\n                    parentKey = res\n                else:\n                    #LOG.error(\"Key %s not found!\" % key)\n                    return None\n\n        return parentKey",
  "def printValue(self, valueType, valueData):\n        if valueType in [REG_SZ, REG_EXPAND_SZ, REG_MULTISZ]:\n            if isinstance(valueData, int):\n                print('NULL')\n            else:\n                print(\"%s\" % (valueData.decode('utf-16le')))\n        elif valueType == REG_BINARY:\n            print('')\n            hexdump(valueData, self.indent)\n        elif valueType == REG_DWORD:\n            print(\"%d\" % valueData)\n        elif valueType == REG_QWORD:\n            print(\"%d\" % (unpack('<Q',valueData)[0]))\n        elif valueType == REG_NONE:\n            try:\n                if len(valueData) > 1:\n                    print('')\n                    hexdump(valueData, self.indent)\n                else:\n                    print(\" NULL\")\n            except:\n                print(\" NULL\")\n        else:\n            print(\"Unknown Type 0x%x!\" % valueType)\n            hexdump(valueData)",
  "def enumKey(self, parentKey):\n        res = []\n        # If we're here.. we have a valid NK record for the key\n        # Now let's searcht the subkeys\n        if parentKey['NumSubKeys'] > 0:\n            lf = self.__getBlock(parentKey['OffsetSubKeyLf'])\n            data = lf['HashRecords']\n\n            if lf['Magic'] == 'ri':\n                # ri points to lf/lh records, so we must parse them before\n                records = ''\n                for i in range(lf['NumKeys']):\n                    offset = unpack('<L', data[:4])[0]\n                    l = self.__getBlock(offset)\n                    records = records + l['HashRecords'][:l['NumKeys']*8]\n                    data = data[4:]\n                data = records\n\n            for i in range(parentKey['NumSubKeys']):\n                hashRec = REG_HASH(data[:8])\n                nk = self.__getBlock(hashRec['OffsetNk'])\n                data = data[8:]\n                res.append('%s'%nk['KeyName'].decode('utf-8'))\n        return res",
  "def enumValues(self,key):\n        # If we're here.. we have a valid NK record for the key\n        # Now let's search its values\n        resp = []\n        if key['NumValues'] > 0:\n            valueList = self.__getValueBlocks(key['OffsetValueList'], key['NumValues']+1)\n\n            for value in valueList:\n                if value['Flag'] > 0:\n                    resp.append(value['Name'])\n                else:\n                    resp.append(b'default')\n\n        return resp",
  "def getValue(self, keyValue):\n        # returns a tuple with (ValueType, ValueData) for the requested keyValue\n        regKey = ntpath.dirname(keyValue)\n        regValue = ntpath.basename(keyValue)\n\n        key = self.findKey(regKey)\n\n        if key is None:\n            return None\n\n        if key['NumValues'] > 0:\n            valueList = self.__getValueBlocks(key['OffsetValueList'], key['NumValues']+1)\n\n            for value in valueList:\n                if value['Name'] == b(regValue):\n                    return value['ValueType'], self.__getValueData(value)\n                elif regValue == 'default' and value['Flag'] <=0:\n                    return value['ValueType'], self.__getValueData(value)\n\n        return None",
  "def getClass(self, className):\n\n        key = self.findKey(className)\n\n        if key is None:\n            return None\n\n        #print key.dump()\n        if key['OffsetClassName'] > 0:\n            value = self.__getBlock(key['OffsetClassName'])\n            return value['Data']",
  "def computeResponse(flags, serverChallenge, clientChallenge, serverName, domain, user, password, lmhash='', nthash='',\n                    use_ntlmv2=USE_NTLMv2):\n    if use_ntlmv2:\n        return computeResponseNTLMv2(flags, serverChallenge, clientChallenge, serverName, domain, user, password,\n                                     lmhash, nthash, use_ntlmv2=use_ntlmv2)\n    else:\n        return computeResponseNTLMv1(flags, serverChallenge, clientChallenge, serverName, domain, user, password,\n                                     lmhash, nthash, use_ntlmv2=use_ntlmv2)",
  "class AV_PAIRS:\n    def __init__(self, data = None):\n        self.fields = {}\n        if data is not None:\n            self.fromString(data)\n\n    def __setitem__(self,key,value):\n        self.fields[key] = (len(value),value)\n\n    def __getitem__(self, key):\n        if key in self.fields:\n           return self.fields[key]\n        return None\n\n    def __delitem__(self, key):\n        del self.fields[key]\n\n    def __len__(self):\n        return len(self.getData())\n\n    def __str__(self):\n        return len(self.getData())\n\n    def fromString(self, data):\n        tInfo = data\n        fType = 0xff\n        while fType is not NTLMSSP_AV_EOL:\n            fType = struct.unpack('<H',tInfo[:struct.calcsize('<H')])[0]\n            tInfo = tInfo[struct.calcsize('<H'):]\n            length = struct.unpack('<H',tInfo[:struct.calcsize('<H')])[0]\n            tInfo = tInfo[struct.calcsize('<H'):]\n            content = tInfo[:length]\n            self.fields[fType]=(length,content)\n            tInfo = tInfo[length:]\n\n    def dump(self):\n        for i in list(self.fields.keys()):\n            print(\"%s: {%r}\" % (i,self[i]))\n\n    def getData(self):\n        if NTLMSSP_AV_EOL in self.fields:\n            del self.fields[NTLMSSP_AV_EOL]\n        ans = b''\n        for i in list(self.fields.keys()):\n            ans+= struct.pack('<HH', i, self[i][0])\n            ans+= self[i][1]\n \n        # end with a NTLMSSP_AV_EOL\n        ans += struct.pack('<HH', NTLMSSP_AV_EOL, 0)\n\n        return ans",
  "class VERSION(Structure):\n    NTLMSSP_REVISION_W2K3 = 0x0F\n\n    structure = (\n        ('ProductMajorVersion', '<B=0'),\n        ('ProductMinorVersion', '<B=0'),\n        ('ProductBuild', '<H=0'),\n        ('Reserved', '3s=\"\"'),\n        ('NTLMRevisionCurrent', '<B=self.NTLMSSP_REVISION_W2K3'),\n    )",
  "class NTLMAuthNegotiate(Structure):\n\n    structure = (\n        ('','\"NTLMSSP\\x00'),\n        ('message_type','<L=1'),\n        ('flags','<L'),\n        ('domain_len','<H-domain_name'),\n        ('domain_max_len','<H-domain_name'),\n        ('domain_offset','<L=0'),\n        ('host_len','<H-host_name'),\n        ('host_maxlen','<H-host_name'),\n        ('host_offset','<L=0'),\n        ('os_version',':'),\n        ('host_name',':'),\n        ('domain_name',':'))\n                                                                                \n    def __init__(self):\n        Structure.__init__(self)\n        self['flags']= (\n               NTLMSSP_NEGOTIATE_128     |\n               NTLMSSP_NEGOTIATE_KEY_EXCH|\n               # NTLMSSP_LM_KEY      |\n               NTLMSSP_NEGOTIATE_NTLM    |\n               NTLMSSP_NEGOTIATE_UNICODE     |\n               # NTLMSSP_ALWAYS_SIGN |\n               NTLMSSP_NEGOTIATE_SIGN        |\n               NTLMSSP_NEGOTIATE_SEAL        |\n               # NTLMSSP_TARGET      |\n               0)\n        self['host_name']=''\n        self['domain_name']=''\n        self['os_version']=''\n        self._workstation = ''\n\n    def setWorkstation(self, workstation):\n        self._workstation = workstation\n\n    def getWorkstation(self):\n        return self._workstation\n\n    def __hasNegotiateVersion(self):\n        return (self['flags'] & NTLMSSP_NEGOTIATE_VERSION) == NTLMSSP_NEGOTIATE_VERSION\n\n    def getData(self):\n        if len(self.fields['host_name']) > 0:\n            self['flags'] |= NTLMSSP_NEGOTIATE_OEM_WORKSTATION_SUPPLIED\n        if len(self.fields['domain_name']) > 0:\n            self['flags'] |= NTLMSSP_NEGOTIATE_OEM_DOMAIN_SUPPLIED\n        version_len = len(self.fields['os_version'])\n        if version_len > 0:\n            self['flags'] |= NTLMSSP_NEGOTIATE_VERSION\n        elif self.__hasNegotiateVersion():\n            raise Exception('Must provide the os_version field if the NTLMSSP_NEGOTIATE_VERSION flag is set')\n        if (self['flags'] & NTLMSSP_NEGOTIATE_OEM_WORKSTATION_SUPPLIED) == NTLMSSP_NEGOTIATE_OEM_WORKSTATION_SUPPLIED:\n            self['host_offset']=32 + version_len\n        if (self['flags'] & NTLMSSP_NEGOTIATE_OEM_DOMAIN_SUPPLIED) == NTLMSSP_NEGOTIATE_OEM_DOMAIN_SUPPLIED:\n            self['domain_offset']=32+len(self['host_name']) + version_len\n        return Structure.getData(self)\n\n    def fromString(self,data):\n        Structure.fromString(self,data)\n\n        domain_offset = self['domain_offset']\n        domain_end    = self['domain_len'] + domain_offset\n        self['domain_name'] = data[ domain_offset : domain_end ]\n\n        host_offset = self['host_offset']\n        host_end    = self['host_len'] + host_offset\n        self['host_name'] = data[ host_offset : host_end ]\n\n        if len(data) >= 36 and self.__hasNegotiateVersion():\n            self['os_version'] = VERSION(data[32:])\n        else:\n            self['os_version'] = ''",
  "class NTLMAuthChallenge(Structure):\n\n    structure = (\n        ('','\"NTLMSSP\\x00'),\n        ('message_type','<L=2'),\n        ('domain_len','<H-domain_name'),\n        ('domain_max_len','<H-domain_name'),\n        ('domain_offset','<L=40'),\n        ('flags','<L=0'),\n        ('challenge','8s'),\n        ('reserved','8s=\"\"'),\n        ('TargetInfoFields_len','<H-TargetInfoFields'),\n        ('TargetInfoFields_max_len','<H-TargetInfoFields'),\n        ('TargetInfoFields_offset','<L'),\n        ('VersionLen','_-Version','self.checkVersion(self[\"flags\"])'), \n        ('Version',':'),\n        ('domain_name',':'),\n        ('TargetInfoFields',':'))\n\n    @staticmethod\n    def checkVersion(flags):\n        if flags is not None:\n           if flags & NTLMSSP_NEGOTIATE_VERSION == 0:\n              return 0\n        return 8\n\n    def getData(self):\n        if self['TargetInfoFields'] is not None and type(self['TargetInfoFields']) is not bytes:\n            raw_av_fields = self['TargetInfoFields'].getData()\n            self['TargetInfoFields'] = raw_av_fields\n        return Structure.getData(self)\n\n    def fromString(self,data):\n        Structure.fromString(self,data)\n        self['domain_name'] = data[self['domain_offset']:][:self['domain_len']]\n        self['TargetInfoFields'] = data[self['TargetInfoFields_offset']:][:self['TargetInfoFields_len']]\n        return self",
  "class NTLMAuthChallengeResponse(Structure):\n\n    structure = (\n        ('','\"NTLMSSP\\x00'),\n        ('message_type','<L=3'),\n        ('lanman_len','<H-lanman'),\n        ('lanman_max_len','<H-lanman'),\n        ('lanman_offset','<L'),\n        ('ntlm_len','<H-ntlm'),\n        ('ntlm_max_len','<H-ntlm'),\n        ('ntlm_offset','<L'),\n        ('domain_len','<H-domain_name'),\n        ('domain_max_len','<H-domain_name'),\n        ('domain_offset','<L'),\n        ('user_len','<H-user_name'),\n        ('user_max_len','<H-user_name'),\n        ('user_offset','<L'),\n        ('host_len','<H-host_name'),\n        ('host_max_len','<H-host_name'),\n        ('host_offset','<L'),\n        ('session_key_len','<H-session_key'),\n        ('session_key_max_len','<H-session_key'),\n        ('session_key_offset','<L'),\n        ('flags','<L'),\n        ('VersionLen','_-Version','self.checkVersion(self[\"flags\"])'), \n        ('Version',':=\"\"'),\n        ('MICLen','_-MIC','self.checkMIC(self[\"flags\"])'),\n        ('MIC',':=\"\"'),\n        ('domain_name',':'),\n        ('user_name',':'),\n        ('host_name',':'),\n        ('lanman',':'),\n        ('ntlm',':'),\n        ('session_key',':'))\n\n    def __init__(self, username = '', password = '', challenge = '', lmhash = '', nthash = '', flags = 0):\n        Structure.__init__(self)\n        self['session_key']=''\n        self['user_name']=username.encode('utf-16le')\n        self['domain_name']='' #\"CLON\".encode('utf-16le')\n        self['host_name']='' #\"BETS\".encode('utf-16le')\n        self['flags'] = (   #authResp['flags']\n            # we think (beto & gera) that his flags force a memory conten leakage when a windows 2000 answers using\n            # uninitializaed verifiers\n           NTLMSSP_NEGOTIATE_128     |\n           NTLMSSP_NEGOTIATE_KEY_EXCH|\n           # NTLMSSP_LM_KEY      |\n           NTLMSSP_NEGOTIATE_NTLM    |\n           NTLMSSP_NEGOTIATE_UNICODE     |\n           # NTLMSSP_ALWAYS_SIGN |\n           NTLMSSP_NEGOTIATE_SIGN        |\n           NTLMSSP_NEGOTIATE_SEAL        |\n           # NTLMSSP_TARGET      |\n           0)\n        # Here we do the stuff\n        if username and ( lmhash != '' or nthash != ''):            \n            self['lanman'] = get_ntlmv1_response(lmhash, challenge)\n            self['ntlm'] = get_ntlmv1_response(nthash, challenge)\n        elif username and password:\n            lmhash = compute_lmhash(password)\n            nthash = compute_nthash(password)\n            self['lanman']=get_ntlmv1_response(lmhash, challenge)\n            self['ntlm']=get_ntlmv1_response(nthash, challenge)    # This is not used for LM_KEY nor NTLM_KEY\n        else:\n            self['lanman'] = ''\n            self['ntlm'] = ''\n            if not self['host_name']:\n                self['host_name'] = 'NULL'.encode('utf-16le')      # for NULL session there must be a hostname\n\n    @staticmethod\n    def checkVersion(flags):\n        if flags is not None:\n           if flags & NTLMSSP_NEGOTIATE_VERSION == 0:\n              return 0\n        return 8\n\n    @staticmethod\n    def checkMIC(flags):\n        # TODO: Find a proper way to check the MIC is in there\n        if flags is not None:\n           if flags & NTLMSSP_NEGOTIATE_VERSION == 0:\n              return 0\n        return 16\n                                                                                \n    def getData(self):\n        self['domain_offset']=64+self.checkMIC(self[\"flags\"])+self.checkVersion(self[\"flags\"])\n        self['user_offset']=64+self.checkMIC(self[\"flags\"])+self.checkVersion(self[\"flags\"])+len(self['domain_name'])\n        self['host_offset']=self['user_offset']+len(self['user_name'])\n        self['lanman_offset']=self['host_offset']+len(self['host_name'])\n        self['ntlm_offset']=self['lanman_offset']+len(self['lanman'])\n        self['session_key_offset']=self['ntlm_offset']+len(self['ntlm'])\n        return Structure.getData(self)\n\n    def fromString(self,data):\n        Structure.fromString(self,data)\n        # [MS-NLMP] page 27\n        # Payload data can be present in any order within the Payload field, \n        # with variable-length padding before or after the data\n\n        domain_offset = self['domain_offset']\n        domain_end = self['domain_len'] + domain_offset\n        self['domain_name'] = data[ domain_offset : domain_end ]\n\n        host_offset = self['host_offset']\n        host_end    = self['host_len'] + host_offset\n        self['host_name'] = data[ host_offset: host_end ]\n\n        user_offset = self['user_offset']\n        user_end    = self['user_len'] + user_offset\n        self['user_name'] = data[ user_offset: user_end ]\n\n        ntlm_offset = self['ntlm_offset'] \n        ntlm_end    = self['ntlm_len'] + ntlm_offset \n        self['ntlm'] = data[ ntlm_offset : ntlm_end ]\n\n        lanman_offset = self['lanman_offset'] \n        lanman_end    = self['lanman_len'] + lanman_offset\n        self['lanman'] = data[ lanman_offset : lanman_end]",
  "class ImpacketStructure(Structure):\n    def set_parent(self, other):\n        self.parent = other\n\n    def get_packet(self):\n        return str(self)\n\n    def get_size(self):\n        return len(self)",
  "class ExtendedOrNotMessageSignature(Structure):\n    def __init__(self, flags = 0, **kargs):\n        if flags & NTLMSSP_NEGOTIATE_EXTENDED_SESSIONSECURITY:\n            self.structure = self.extendedMessageSignature\n        else:\n            self.structure = self.MessageSignature\n        return Structure.__init__(self, **kargs)",
  "class NTLMMessageSignature(ExtendedOrNotMessageSignature):\n      extendedMessageSignature = (\n          ('Version','<L=1'),\n          ('Checksum','<q'),\n          ('SeqNum','<I'),\n      )\n\n      MessageSignature = (\n          ('Version','<L=1'),\n          ('RandomPad','<I=0'),\n          ('Checksum','<I'),\n          ('SeqNum','<I'),\n      )",
  "def __expand_DES_key(key):\n    # Expand the key from a 7-byte password key into a 8-byte DES key\n    if not isinstance(key, bytes):\n        key = bytes(key)\n    key  = bytearray(key[:7]).ljust(7, b'\\x00')\n    s = bytearray()\n    s.append(((key[0] >> 1) & 0x7f) << 1)\n    s.append(((key[0] & 0x01) << 6 | ((key[1] >> 2) & 0x3f)) << 1)\n    s.append(((key[1] & 0x03) << 5 | ((key[2] >> 3) & 0x1f)) << 1)\n    s.append(((key[2] & 0x07) << 4 | ((key[3] >> 4) & 0x0f)) << 1)\n    s.append(((key[3] & 0x0f) << 3 | ((key[4] >> 5) & 0x07)) << 1)\n    s.append(((key[4] & 0x1f) << 2 | ((key[5] >> 6) & 0x03)) << 1)\n    s.append(((key[5] & 0x3f) << 1 | ((key[6] >> 7) & 0x01)) << 1)\n    s.append((key[6] & 0x7f) << 1)\n    return bytes(s)",
  "def __DES_block(key, msg):\n    cipher = DES.new(__expand_DES_key(key),DES.MODE_ECB)\n    return cipher.encrypt(msg)",
  "def ntlmssp_DES_encrypt(key, challenge):\n    answer  = __DES_block(key[:7], challenge)\n    answer += __DES_block(key[7:14], challenge)\n    answer += __DES_block(key[14:], challenge)\n    return answer",
  "def getNTLMSSPType1(workstation='', domain='', signingRequired = False, use_ntlmv2 = USE_NTLMv2):\n    # Let's do some encoding checks before moving on. Kind of dirty, but found effective when dealing with\n    # international characters.\n    import sys\n    encoding = sys.getfilesystemencoding()\n    if encoding is not None:\n        try:\n            workstation.encode('utf-16le')\n        except:\n            workstation = workstation.decode(encoding)\n        try:\n            domain.encode('utf-16le')\n        except:\n            domain = domain.decode(encoding)\n\n    # Let's prepare a Type 1 NTLMSSP Message\n    auth = NTLMAuthNegotiate()\n    auth['flags']=0\n    if signingRequired:\n       auth['flags'] = NTLMSSP_NEGOTIATE_KEY_EXCH | NTLMSSP_NEGOTIATE_SIGN | NTLMSSP_NEGOTIATE_ALWAYS_SIGN | \\\n                       NTLMSSP_NEGOTIATE_SEAL\n    if use_ntlmv2:\n       auth['flags'] |= NTLMSSP_NEGOTIATE_TARGET_INFO\n    auth['flags'] |= NTLMSSP_NEGOTIATE_NTLM | NTLMSSP_NEGOTIATE_EXTENDED_SESSIONSECURITY | NTLMSSP_NEGOTIATE_UNICODE | \\\n                     NTLMSSP_REQUEST_TARGET |  NTLMSSP_NEGOTIATE_128 | NTLMSSP_NEGOTIATE_56\n\n    # We're not adding workstation / domain fields this time. Normally Windows clients don't add such information but,\n    # we will save the workstation name to be used later.\n    auth.setWorkstation(workstation)\n\n    return auth",
  "def getNTLMSSPType3(type1, type2, user, password, domain, lmhash = '', nthash = '', use_ntlmv2 = USE_NTLMv2):\n\n    # Safety check in case somebody sent password = None.. That's not allowed. Setting it to '' and hope for the best.\n    if password is None:\n        password = ''\n\n    # Let's do some encoding checks before moving on. Kind of dirty, but found effective when dealing with\n    # international characters.\n    import sys\n    encoding = sys.getfilesystemencoding()\n    if encoding is not None:\n        try:\n            user.encode('utf-16le')\n        except:\n            user = user.decode(encoding)\n        try:\n            password.encode('utf-16le')\n        except:\n            password = password.decode(encoding)\n        try:\n            domain.encode('utf-16le')\n        except:\n            domain = user.decode(encoding)\n\n    ntlmChallenge = NTLMAuthChallenge(type2)\n\n    # Let's start with the original flags sent in the type1 message\n    responseFlags = type1['flags']\n\n    # Token received and parsed. Depending on the authentication \n    # method we will create a valid ChallengeResponse\n    ntlmChallengeResponse = NTLMAuthChallengeResponse(user, password, ntlmChallenge['challenge'])\n\n    clientChallenge = b(\"\".join([random.choice(string.digits+string.ascii_letters) for _ in range(8)]))\n\n    serverName = ntlmChallenge['TargetInfoFields']\n\n    ntResponse, lmResponse, sessionBaseKey = computeResponse(ntlmChallenge['flags'], ntlmChallenge['challenge'],\n                                                             clientChallenge, serverName, domain, user, password,\n                                                             lmhash, nthash, use_ntlmv2)\n\n    # Let's check the return flags\n    if (ntlmChallenge['flags'] & NTLMSSP_NEGOTIATE_EXTENDED_SESSIONSECURITY) == 0:\n        # No extended session security, taking it out\n        responseFlags &= 0xffffffff ^ NTLMSSP_NEGOTIATE_EXTENDED_SESSIONSECURITY\n    if (ntlmChallenge['flags'] & NTLMSSP_NEGOTIATE_128 ) == 0:\n        # No support for 128 key len, taking it out\n        responseFlags &= 0xffffffff ^ NTLMSSP_NEGOTIATE_128\n    if (ntlmChallenge['flags'] & NTLMSSP_NEGOTIATE_KEY_EXCH) == 0:\n        # No key exchange supported, taking it out\n        responseFlags &= 0xffffffff ^ NTLMSSP_NEGOTIATE_KEY_EXCH\n    if (ntlmChallenge['flags'] & NTLMSSP_NEGOTIATE_SEAL) == 0:\n        # No sign available, taking it out\n        responseFlags &= 0xffffffff ^ NTLMSSP_NEGOTIATE_SEAL\n    if (ntlmChallenge['flags'] & NTLMSSP_NEGOTIATE_SIGN) == 0:\n        # No sign available, taking it out\n        responseFlags &= 0xffffffff ^ NTLMSSP_NEGOTIATE_SIGN\n    if (ntlmChallenge['flags'] & NTLMSSP_NEGOTIATE_ALWAYS_SIGN) == 0:\n        # No sign available, taking it out\n        responseFlags &= 0xffffffff ^ NTLMSSP_NEGOTIATE_ALWAYS_SIGN\n\n    keyExchangeKey = KXKEY(ntlmChallenge['flags'], sessionBaseKey, lmResponse, ntlmChallenge['challenge'], password,\n                           lmhash, nthash, use_ntlmv2)\n\n    # Special case for anonymous login\n    if user == '' and password == '' and lmhash == '' and nthash == '':\n      keyExchangeKey = b'\\x00'*16\n\n    # If we set up key exchange, let's fill the right variables\n    if ntlmChallenge['flags'] & NTLMSSP_NEGOTIATE_KEY_EXCH:\n       # not exactly what I call random tho :\\\n       # exportedSessionKey = this is the key we should use to sign\n       exportedSessionKey = b(\"\".join([random.choice(string.digits+string.ascii_letters) for _ in range(16)]))\n       #exportedSessionKey = \"A\"*16\n       #print \"keyExchangeKey %r\" % keyExchangeKey\n       # Let's generate the right session key based on the challenge flags\n       #if responseFlags & NTLMSSP_NTLM2_KEY:\n           # Extended session security enabled\n       #    if responseFlags & NTLMSSP_KEY_128:\n               # Full key\n       #        exportedSessionKey = exportedSessionKey\n       #    elif responseFlags & NTLMSSP_KEY_56:\n               # Only 56-bit key\n       #        exportedSessionKey = exportedSessionKey[:7]\n       #    else:\n       #        exportedSessionKey = exportedSessionKey[:5]\n       #elif responseFlags & NTLMSSP_KEY_56:\n           # No extended session security, just 56 bits key\n       #    exportedSessionKey = exportedSessionKey[:7] + '\\xa0'\n       #else:\n       #    exportedSessionKey = exportedSessionKey[:5] + '\\xe5\\x38\\xb0'\n\n       encryptedRandomSessionKey = generateEncryptedSessionKey(keyExchangeKey, exportedSessionKey)\n    else:\n       encryptedRandomSessionKey = None\n       # [MS-NLMP] page 46\n       exportedSessionKey        = keyExchangeKey\n\n    ntlmChallengeResponse['flags'] = responseFlags\n    ntlmChallengeResponse['domain_name'] = domain.encode('utf-16le')\n    ntlmChallengeResponse['host_name'] = type1.getWorkstation().encode('utf-16le')\n    if lmResponse == '':\n        ntlmChallengeResponse['lanman'] = b'\\x00'\n    else:\n        ntlmChallengeResponse['lanman'] = lmResponse\n    ntlmChallengeResponse['ntlm'] = ntResponse\n    if encryptedRandomSessionKey is not None: \n        ntlmChallengeResponse['session_key'] = encryptedRandomSessionKey\n\n    return ntlmChallengeResponse, exportedSessionKey",
  "def generateSessionKeyV1(password, lmhash, nthash):\n    hash = MD4.new()\n    hash.update(NTOWFv1(password, lmhash, nthash))\n    return hash.digest()",
  "def computeResponseNTLMv1(flags, serverChallenge, clientChallenge, serverName, domain, user, password, lmhash='',\n                          nthash='', use_ntlmv2=USE_NTLMv2):\n    if user == '' and password == '':\n        # Special case for anonymous authentication\n        lmResponse = ''\n        ntResponse = ''\n    else:\n        lmhash = LMOWFv1(password, lmhash, nthash)\n        nthash = NTOWFv1(password, lmhash, nthash)\n        if flags & NTLMSSP_NEGOTIATE_LM_KEY:\n           ntResponse = ''\n           lmResponse = get_ntlmv1_response(lmhash, serverChallenge)\n        elif flags & NTLMSSP_NEGOTIATE_EXTENDED_SESSIONSECURITY:\n           md5 = hashlib.new('md5')\n           chall = (serverChallenge + clientChallenge)\n           md5.update(chall)\n           ntResponse = ntlmssp_DES_encrypt(nthash, md5.digest()[:8])\n           lmResponse = clientChallenge + b'\\x00'*16\n        else:\n           ntResponse = get_ntlmv1_response(nthash,serverChallenge)\n           lmResponse = get_ntlmv1_response(lmhash, serverChallenge)\n   \n    sessionBaseKey = generateSessionKeyV1(password, lmhash, nthash)\n    return ntResponse, lmResponse, sessionBaseKey",
  "def compute_lmhash(password):\n    # This is done according to Samba's encryption specification (docs/html/ENCRYPTION.html)\n    password = password.upper()\n    lmhash  = __DES_block(b(password[:7]), KNOWN_DES_INPUT)\n    lmhash += __DES_block(b(password[7:14]), KNOWN_DES_INPUT)\n    return lmhash",
  "def NTOWFv1(password, lmhash = '', nthash=''):\n    if nthash != '':\n       return nthash\n    return compute_nthash(password)",
  "def LMOWFv1(password, lmhash = '', nthash=''):\n    if lmhash != '':\n       return lmhash\n    return compute_lmhash(password)",
  "def compute_nthash(password):\n    # This is done according to Samba's encryption specification (docs/html/ENCRYPTION.html)\n    try:\n        password = str(password).encode('utf_16le')\n    except UnicodeDecodeError:\n        import sys\n        password = password.decode(sys.getfilesystemencoding()).encode('utf_16le')\n\n    hash = MD4.new()\n    hash.update(password)\n    return hash.digest()",
  "def get_ntlmv1_response(key, challenge):\n    return ntlmssp_DES_encrypt(key, challenge)",
  "def MAC(flags, handle, signingKey, seqNum, message):\n   # [MS-NLMP] Section 3.4.4\n   # Returns the right messageSignature depending on the flags\n   messageSignature = NTLMMessageSignature(flags)\n   if flags & NTLMSSP_NEGOTIATE_EXTENDED_SESSIONSECURITY:\n       if flags & NTLMSSP_NEGOTIATE_KEY_EXCH:\n           messageSignature['Version'] = 1\n           messageSignature['Checksum'] = \\\n           struct.unpack('<q', handle(hmac_md5(signingKey, struct.pack('<i', seqNum) + message)[:8]))[0]\n           messageSignature['SeqNum'] = seqNum\n           seqNum += 1\n       else:\n           messageSignature['Version'] = 1\n           messageSignature['Checksum'] = struct.unpack('<q',hmac_md5(signingKey, struct.pack('<i',seqNum)+message)[:8])[0]\n           messageSignature['SeqNum'] = seqNum\n           seqNum += 1\n   else:\n       messageSignature['Version'] = 1\n       messageSignature['Checksum'] = struct.pack('<I',binascii.crc32(message)& 0xFFFFFFFF)\n       messageSignature['RandomPad'] = 0\n       messageSignature['RandomPad'] = handle(struct.pack('<I',messageSignature['RandomPad']))\n       messageSignature['Checksum'] = struct.unpack('<I',handle(messageSignature['Checksum']))[0]\n       messageSignature['SeqNum'] = handle(b'\\x00\\x00\\x00\\x00')\n       messageSignature['SeqNum'] = struct.unpack('<I',messageSignature['SeqNum'])[0] ^ seqNum\n       messageSignature['RandomPad'] = 0\n       \n   return messageSignature",
  "def SEAL(flags, signingKey, sealingKey, messageToSign, messageToEncrypt, seqNum, handle):\n   sealedMessage = handle(messageToEncrypt)\n   signature = MAC(flags, handle, signingKey, seqNum, messageToSign)\n   return sealedMessage, signature",
  "def SIGN(flags, signingKey, message, seqNum, handle):\n   return MAC(flags, handle, signingKey, seqNum, message)",
  "def SIGNKEY(flags, randomSessionKey, mode = 'Client'):\n   if flags & NTLMSSP_NEGOTIATE_EXTENDED_SESSIONSECURITY:\n       if mode == 'Client':\n           md5 = hashlib.new('md5')\n           md5.update(randomSessionKey + b\"session key to client-to-server signing key magic constant\\x00\")\n           signKey = md5.digest()\n       else:\n           md5 = hashlib.new('md5')\n           md5.update(randomSessionKey + b\"session key to server-to-client signing key magic constant\\x00\")\n           signKey = md5.digest()\n   else:\n       signKey = None\n   return signKey",
  "def SEALKEY(flags, randomSessionKey, mode = 'Client'):\n   if flags & NTLMSSP_NEGOTIATE_EXTENDED_SESSIONSECURITY:\n       if flags & NTLMSSP_NEGOTIATE_128:\n           sealKey = randomSessionKey\n       elif flags & NTLMSSP_NEGOTIATE_56:\n           sealKey = randomSessionKey[:7]\n       else:\n           sealKey = randomSessionKey[:5]\n\n       if mode == 'Client':\n               md5 = hashlib.new('md5')\n               md5.update(sealKey + b'session key to client-to-server sealing key magic constant\\x00')\n               sealKey = md5.digest()\n       else:\n               md5 = hashlib.new('md5')\n               md5.update(sealKey + b'session key to server-to-client sealing key magic constant\\x00')\n               sealKey = md5.digest()\n\n   elif flags & NTLMSSP_NEGOTIATE_56:\n       sealKey = randomSessionKey[:7] + b'\\xa0'\n   else:\n       sealKey = randomSessionKey[:5] + b'\\xe5\\x38\\xb0'\n\n   return sealKey",
  "def generateEncryptedSessionKey(keyExchangeKey, exportedSessionKey):\n   cipher = ARC4.new(keyExchangeKey)\n   cipher_encrypt = cipher.encrypt\n\n   sessionKey = cipher_encrypt(exportedSessionKey)\n   return sessionKey",
  "def KXKEY(flags, sessionBaseKey, lmChallengeResponse, serverChallenge, password, lmhash, nthash, use_ntlmv2 = USE_NTLMv2):\n   if use_ntlmv2:\n       return sessionBaseKey\n\n   if flags & NTLMSSP_NEGOTIATE_EXTENDED_SESSIONSECURITY:\n       if flags & NTLMSSP_NEGOTIATE_NTLM:\n          keyExchangeKey = hmac_md5(sessionBaseKey, serverChallenge + lmChallengeResponse[:8])\n       else:\n          keyExchangeKey = sessionBaseKey\n   elif flags & NTLMSSP_NEGOTIATE_NTLM:\n       if flags & NTLMSSP_NEGOTIATE_LM_KEY:\n           keyExchangeKey = __DES_block(LMOWFv1(password, lmhash)[:7], lmChallengeResponse[:8]) + __DES_block(\n               LMOWFv1(password, lmhash)[7] + b'\\xBD\\xBD\\xBD\\xBD\\xBD\\xBD', lmChallengeResponse[:8])\n       elif flags & NTLMSSP_REQUEST_NON_NT_SESSION_KEY:\n          keyExchangeKey = LMOWFv1(password,lmhash)[:8] + b'\\x00'*8\n       else:\n          keyExchangeKey = sessionBaseKey\n   else:\n       raise Exception(\"Can't create a valid KXKEY!\")\n\n   return keyExchangeKey",
  "def hmac_md5(key, data):\n    import hmac\n    h = hmac.new(key, digestmod=hashlib.md5)\n    h.update(data)\n    return h.digest()",
  "def NTOWFv2( user, password, domain, hash = ''):\n    if hash != '':\n       theHash = hash \n    else:\n       theHash = compute_nthash(password)\n    return hmac_md5(theHash, user.upper().encode('utf-16le') + domain.encode('utf-16le'))",
  "def LMOWFv2( user, password, domain, lmhash = ''):\n    return NTOWFv2( user, password, domain, lmhash)",
  "def computeResponseNTLMv2(flags, serverChallenge, clientChallenge, serverName, domain, user, password, lmhash='',\n                          nthash='', use_ntlmv2=USE_NTLMv2):\n\n    responseServerVersion = b'\\x01'\n    hiResponseServerVersion = b'\\x01'\n    responseKeyNT = NTOWFv2(user, password, domain, nthash)\n\n    av_pairs = AV_PAIRS(serverName)\n    # In order to support SPN target name validation, we have to add this to the serverName av_pairs. Otherwise we will\n    # get access denied\n    # This is set at Local Security Policy -> Local Policies -> Security Options -> Server SPN target name validation\n    # level\n    if TEST_CASE is False:\n        av_pairs[NTLMSSP_AV_TARGET_NAME] = 'cifs/'.encode('utf-16le') + av_pairs[NTLMSSP_AV_HOSTNAME][1]\n        if av_pairs[NTLMSSP_AV_TIME] is not None:\n           aTime = av_pairs[NTLMSSP_AV_TIME][1]\n        else:\n           aTime = struct.pack('<q', (116444736000000000 + calendar.timegm(time.gmtime()) * 10000000) )\n           av_pairs[NTLMSSP_AV_TIME] = aTime\n        serverName = av_pairs.getData()\n    else:\n        aTime = b'\\x00'*8\n\n    temp = responseServerVersion + hiResponseServerVersion + b'\\x00' * 6 + aTime + clientChallenge + b'\\x00' * 4 + \\\n           serverName + b'\\x00' * 4\n\n    ntProofStr = hmac_md5(responseKeyNT, serverChallenge + temp)\n\n    ntChallengeResponse = ntProofStr + temp\n    lmChallengeResponse = hmac_md5(responseKeyNT, serverChallenge + clientChallenge) + clientChallenge\n    sessionBaseKey = hmac_md5(responseKeyNT, ntProofStr)\n\n    if user == '' and password == '':\n        # Special case for anonymous authentication\n        ntChallengeResponse = ''\n        lmChallengeResponse = ''\n\n    return ntChallengeResponse, lmChallengeResponse, sessionBaseKey",
  "class NTLM_HTTP(object):\n    # Parent class for NTLM HTTP classes.\n    MSG_TYPE = None\n\n    @classmethod\n    def get_instance(cls,msg_64):\n        msg = None\n        msg_type = 0\n        if msg_64 != '':\n            msg = base64.b64decode(msg_64[5:]) # Remove the 'NTLM '\n            msg_type = ord(msg[8])\n    \n        for _cls in NTLM_HTTP.__subclasses__():\n            if msg_type == _cls.MSG_TYPE:\n                instance = _cls()\n                instance.fromString(msg)\n                return instance",
  "class NTLM_HTTP_AuthRequired(NTLM_HTTP):\n    commonHdr = ()\n    # Message 0 means the first HTTP request e.g. 'GET /bla.png'\n    MSG_TYPE = 0\n\n    def fromString(self,data): \n        pass",
  "class NTLM_HTTP_AuthNegotiate(NTLM_HTTP, NTLMAuthNegotiate):\n    commonHdr = ()\n    MSG_TYPE = 1\n\n    def __init__(self):\n        NTLMAuthNegotiate.__init__(self)",
  "class NTLM_HTTP_AuthChallengeResponse(NTLM_HTTP, NTLMAuthChallengeResponse):\n    commonHdr = ()\n    MSG_TYPE = 3\n\n    def __init__(self):\n        NTLMAuthChallengeResponse.__init__(self)",
  "def __init__(self, data = None):\n        self.fields = {}\n        if data is not None:\n            self.fromString(data)",
  "def __setitem__(self,key,value):\n        self.fields[key] = (len(value),value)",
  "def __getitem__(self, key):\n        if key in self.fields:\n           return self.fields[key]\n        return None",
  "def __delitem__(self, key):\n        del self.fields[key]",
  "def __len__(self):\n        return len(self.getData())",
  "def __str__(self):\n        return len(self.getData())",
  "def fromString(self, data):\n        tInfo = data\n        fType = 0xff\n        while fType is not NTLMSSP_AV_EOL:\n            fType = struct.unpack('<H',tInfo[:struct.calcsize('<H')])[0]\n            tInfo = tInfo[struct.calcsize('<H'):]\n            length = struct.unpack('<H',tInfo[:struct.calcsize('<H')])[0]\n            tInfo = tInfo[struct.calcsize('<H'):]\n            content = tInfo[:length]\n            self.fields[fType]=(length,content)\n            tInfo = tInfo[length:]",
  "def dump(self):\n        for i in list(self.fields.keys()):\n            print(\"%s: {%r}\" % (i,self[i]))",
  "def getData(self):\n        if NTLMSSP_AV_EOL in self.fields:\n            del self.fields[NTLMSSP_AV_EOL]\n        ans = b''\n        for i in list(self.fields.keys()):\n            ans+= struct.pack('<HH', i, self[i][0])\n            ans+= self[i][1]\n \n        # end with a NTLMSSP_AV_EOL\n        ans += struct.pack('<HH', NTLMSSP_AV_EOL, 0)\n\n        return ans",
  "def __init__(self):\n        Structure.__init__(self)\n        self['flags']= (\n               NTLMSSP_NEGOTIATE_128     |\n               NTLMSSP_NEGOTIATE_KEY_EXCH|\n               # NTLMSSP_LM_KEY      |\n               NTLMSSP_NEGOTIATE_NTLM    |\n               NTLMSSP_NEGOTIATE_UNICODE     |\n               # NTLMSSP_ALWAYS_SIGN |\n               NTLMSSP_NEGOTIATE_SIGN        |\n               NTLMSSP_NEGOTIATE_SEAL        |\n               # NTLMSSP_TARGET      |\n               0)\n        self['host_name']=''\n        self['domain_name']=''\n        self['os_version']=''\n        self._workstation = ''",
  "def setWorkstation(self, workstation):\n        self._workstation = workstation",
  "def getWorkstation(self):\n        return self._workstation",
  "def __hasNegotiateVersion(self):\n        return (self['flags'] & NTLMSSP_NEGOTIATE_VERSION) == NTLMSSP_NEGOTIATE_VERSION",
  "def getData(self):\n        if len(self.fields['host_name']) > 0:\n            self['flags'] |= NTLMSSP_NEGOTIATE_OEM_WORKSTATION_SUPPLIED\n        if len(self.fields['domain_name']) > 0:\n            self['flags'] |= NTLMSSP_NEGOTIATE_OEM_DOMAIN_SUPPLIED\n        version_len = len(self.fields['os_version'])\n        if version_len > 0:\n            self['flags'] |= NTLMSSP_NEGOTIATE_VERSION\n        elif self.__hasNegotiateVersion():\n            raise Exception('Must provide the os_version field if the NTLMSSP_NEGOTIATE_VERSION flag is set')\n        if (self['flags'] & NTLMSSP_NEGOTIATE_OEM_WORKSTATION_SUPPLIED) == NTLMSSP_NEGOTIATE_OEM_WORKSTATION_SUPPLIED:\n            self['host_offset']=32 + version_len\n        if (self['flags'] & NTLMSSP_NEGOTIATE_OEM_DOMAIN_SUPPLIED) == NTLMSSP_NEGOTIATE_OEM_DOMAIN_SUPPLIED:\n            self['domain_offset']=32+len(self['host_name']) + version_len\n        return Structure.getData(self)",
  "def fromString(self,data):\n        Structure.fromString(self,data)\n\n        domain_offset = self['domain_offset']\n        domain_end    = self['domain_len'] + domain_offset\n        self['domain_name'] = data[ domain_offset : domain_end ]\n\n        host_offset = self['host_offset']\n        host_end    = self['host_len'] + host_offset\n        self['host_name'] = data[ host_offset : host_end ]\n\n        if len(data) >= 36 and self.__hasNegotiateVersion():\n            self['os_version'] = VERSION(data[32:])\n        else:\n            self['os_version'] = ''",
  "def checkVersion(flags):\n        if flags is not None:\n           if flags & NTLMSSP_NEGOTIATE_VERSION == 0:\n              return 0\n        return 8",
  "def getData(self):\n        if self['TargetInfoFields'] is not None and type(self['TargetInfoFields']) is not bytes:\n            raw_av_fields = self['TargetInfoFields'].getData()\n            self['TargetInfoFields'] = raw_av_fields\n        return Structure.getData(self)",
  "def fromString(self,data):\n        Structure.fromString(self,data)\n        self['domain_name'] = data[self['domain_offset']:][:self['domain_len']]\n        self['TargetInfoFields'] = data[self['TargetInfoFields_offset']:][:self['TargetInfoFields_len']]\n        return self",
  "def __init__(self, username = '', password = '', challenge = '', lmhash = '', nthash = '', flags = 0):\n        Structure.__init__(self)\n        self['session_key']=''\n        self['user_name']=username.encode('utf-16le')\n        self['domain_name']='' #\"CLON\".encode('utf-16le')\n        self['host_name']='' #\"BETS\".encode('utf-16le')\n        self['flags'] = (   #authResp['flags']\n            # we think (beto & gera) that his flags force a memory conten leakage when a windows 2000 answers using\n            # uninitializaed verifiers\n           NTLMSSP_NEGOTIATE_128     |\n           NTLMSSP_NEGOTIATE_KEY_EXCH|\n           # NTLMSSP_LM_KEY      |\n           NTLMSSP_NEGOTIATE_NTLM    |\n           NTLMSSP_NEGOTIATE_UNICODE     |\n           # NTLMSSP_ALWAYS_SIGN |\n           NTLMSSP_NEGOTIATE_SIGN        |\n           NTLMSSP_NEGOTIATE_SEAL        |\n           # NTLMSSP_TARGET      |\n           0)\n        # Here we do the stuff\n        if username and ( lmhash != '' or nthash != ''):            \n            self['lanman'] = get_ntlmv1_response(lmhash, challenge)\n            self['ntlm'] = get_ntlmv1_response(nthash, challenge)\n        elif username and password:\n            lmhash = compute_lmhash(password)\n            nthash = compute_nthash(password)\n            self['lanman']=get_ntlmv1_response(lmhash, challenge)\n            self['ntlm']=get_ntlmv1_response(nthash, challenge)    # This is not used for LM_KEY nor NTLM_KEY\n        else:\n            self['lanman'] = ''\n            self['ntlm'] = ''\n            if not self['host_name']:\n                self['host_name'] = 'NULL'.encode('utf-16le')",
  "def checkVersion(flags):\n        if flags is not None:\n           if flags & NTLMSSP_NEGOTIATE_VERSION == 0:\n              return 0\n        return 8",
  "def checkMIC(flags):\n        # TODO: Find a proper way to check the MIC is in there\n        if flags is not None:\n           if flags & NTLMSSP_NEGOTIATE_VERSION == 0:\n              return 0\n        return 16",
  "def getData(self):\n        self['domain_offset']=64+self.checkMIC(self[\"flags\"])+self.checkVersion(self[\"flags\"])\n        self['user_offset']=64+self.checkMIC(self[\"flags\"])+self.checkVersion(self[\"flags\"])+len(self['domain_name'])\n        self['host_offset']=self['user_offset']+len(self['user_name'])\n        self['lanman_offset']=self['host_offset']+len(self['host_name'])\n        self['ntlm_offset']=self['lanman_offset']+len(self['lanman'])\n        self['session_key_offset']=self['ntlm_offset']+len(self['ntlm'])\n        return Structure.getData(self)",
  "def fromString(self,data):\n        Structure.fromString(self,data)\n        # [MS-NLMP] page 27\n        # Payload data can be present in any order within the Payload field, \n        # with variable-length padding before or after the data\n\n        domain_offset = self['domain_offset']\n        domain_end = self['domain_len'] + domain_offset\n        self['domain_name'] = data[ domain_offset : domain_end ]\n\n        host_offset = self['host_offset']\n        host_end    = self['host_len'] + host_offset\n        self['host_name'] = data[ host_offset: host_end ]\n\n        user_offset = self['user_offset']\n        user_end    = self['user_len'] + user_offset\n        self['user_name'] = data[ user_offset: user_end ]\n\n        ntlm_offset = self['ntlm_offset'] \n        ntlm_end    = self['ntlm_len'] + ntlm_offset \n        self['ntlm'] = data[ ntlm_offset : ntlm_end ]\n\n        lanman_offset = self['lanman_offset'] \n        lanman_end    = self['lanman_len'] + lanman_offset\n        self['lanman'] = data[ lanman_offset : lanman_end]",
  "def set_parent(self, other):\n        self.parent = other",
  "def get_packet(self):\n        return str(self)",
  "def get_size(self):\n        return len(self)",
  "def __init__(self, flags = 0, **kargs):\n        if flags & NTLMSSP_NEGOTIATE_EXTENDED_SESSIONSECURITY:\n            self.structure = self.extendedMessageSignature\n        else:\n            self.structure = self.MessageSignature\n        return Structure.__init__(self, **kargs)",
  "def get_instance(cls,msg_64):\n        msg = None\n        msg_type = 0\n        if msg_64 != '':\n            msg = base64.b64decode(msg_64[5:]) # Remove the 'NTLM '\n            msg_type = ord(msg[8])\n    \n        for _cls in NTLM_HTTP.__subclasses__():\n            if msg_type == _cls.MSG_TYPE:\n                instance = _cls()\n                instance.fromString(msg)\n                return instance",
  "def fromString(self,data): \n        pass",
  "def __init__(self):\n        NTLMAuthNegotiate.__init__(self)",
  "def __init__(self):\n        NTLMAuthChallengeResponse.__init__(self)",
  "class Dot11ManagementCapabilities():\n    #\n    # Capability Information\n    #   0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F\n    # +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n    # | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |\n    # +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n    #   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |\n    #   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |---+-- Reserved\n    #   |   |   |   |   |   |   |   |   |   |   |   |   |   |\n    #   |   |   |   |   |   |   |   |   |   |   |   |   |   |---------- DSSS-OFDM\n    #   |   |   |   |   |   |   |   |   |   |   |   |   |\n    #   |   |   |   |   |   |   |   |   |   |   |   |---+-------------- Reserved\n    #   |   |   |   |   |   |   |   |   |   |   |\n    #   |   |   |   |   |   |   |   |   |   |   |---------------------- Short slot time\n    #   |   |   |   |   |   |   |   |   |   |\n    #   |   |   |   |   |   |   |   |   |---+-------------------------- Reserved\n    #   |   |   |   |   |   |   |   |\n    #   |   |   |   |   |   |   |   |---------------------------------- Channel agility (802.11b)\n    #   |   |   |   |   |   |   |\n    #   |   |   |   |   |   |   |-------------------------------------- PBCC (802.11b)\n    #   |   |   |   |   |   |\n    #   |   |   |   |   |   |------------------------------------------ Short preamble (802.11b)\n    #   |   |   |   |   |\n    #   |   |   |   |   |---------------------------------------------- Privacy\n    #   |   |   |   |\n    #   |   |   |   |-------------------------------------------------- CF-Poll request\n    #   |   |   |\n    #   |   |   |------------------------------------------------------ CF-Pollable\n    #   |   |\n    #   |   |---------------------------------------------------------- IBSS\n    #   |\n    #   |-------------------------------------------------------------- ESS\n    #\n    CAPABILITY_RESERVED_1      = int(\"1000000000000000\", 2)\n    CAPABILITY_RESERVED_2      = int(\"0100000000000000\", 2)\n    CAPABILITY_DSSS_OFDM       = int(\"0010000000000000\", 2)\n    CAPABILITY_RESERVED_3      = int(\"0001000000000000\", 2)\n    CAPABILITY_RESERVED_4      = int(\"0000100000000000\", 2)\n    CAPABILITY_SHORT_SLOT_TIME = int(\"0000010000000000\", 2)\n    CAPABILITY_RESERVED_5      = int(\"0000001000000000\", 2)\n    CAPABILITY_RESERVED_6      = int(\"0000000100000000\", 2)\n    CAPABILITY_CH_AGILITY      = int(\"0000000010000000\", 2)\n    CAPABILITY_PBCC            = int(\"0000000001000000\", 2)\n    CAPABILITY_SHORT_PREAMBLE  = int(\"0000000000100000\", 2)\n    CAPABILITY_PRIVACY         = int(\"0000000000010000\", 2)\n    CAPABILITY_CF_POLL_REQ     = int(\"0000000000001000\", 2)\n    CAPABILITY_CF_POLLABLE     = int(\"0000000000000100\", 2)\n    CAPABILITY_IBSS            = int(\"0000000000000010\", 2)\n    CAPABILITY_ESS             = int(\"0000000000000001\", 2)",
  "class Dot11Types():\n    # Management Types/SubTypes\n    DOT11_TYPE_MANAGEMENT                           = int(\"00\",2)\n    DOT11_SUBTYPE_MANAGEMENT_ASSOCIATION_REQUEST    = int(\"0000\",2)\n    DOT11_SUBTYPE_MANAGEMENT_ASSOCIATION_RESPONSE   = int(\"0001\",2)\n    DOT11_SUBTYPE_MANAGEMENT_REASSOCIATION_REQUEST  = int(\"0010\",2)\n    DOT11_SUBTYPE_MANAGEMENT_REASSOCIATION_RESPONSE = int(\"0011\",2)\n    DOT11_SUBTYPE_MANAGEMENT_PROBE_REQUEST          = int(\"0100\",2)\n    DOT11_SUBTYPE_MANAGEMENT_PROBE_RESPONSE         = int(\"0101\",2)\n    DOT11_SUBTYPE_MANAGEMENT_RESERVED1              = int(\"0110\",2)\n    DOT11_SUBTYPE_MANAGEMENT_RESERVED2              = int(\"0111\",2)\n    DOT11_SUBTYPE_MANAGEMENT_BEACON                 = int(\"1000\",2)\n    DOT11_SUBTYPE_MANAGEMENT_ATIM                   = int(\"1001\",2)\n    DOT11_SUBTYPE_MANAGEMENT_DISASSOCIATION         = int(\"1010\",2)\n    DOT11_SUBTYPE_MANAGEMENT_AUTHENTICATION         = int(\"1011\",2)\n    DOT11_SUBTYPE_MANAGEMENT_DEAUTHENTICATION       = int(\"1100\",2)\n    DOT11_SUBTYPE_MANAGEMENT_ACTION                 = int(\"1101\",2)\n    DOT11_SUBTYPE_MANAGEMENT_RESERVED3              = int(\"1110\",2)\n    DOT11_SUBTYPE_MANAGEMENT_RESERVED4              = int(\"1111\",2)\n\n    DOT11_TYPE_MANAGEMENT_SUBTYPE_ASSOCIATION_REQUEST = \\\n        DOT11_TYPE_MANAGEMENT|DOT11_SUBTYPE_MANAGEMENT_ASSOCIATION_REQUEST<<2\n    DOT11_TYPE_MANAGEMENT_SUBTYPE_ASSOCIATION_RESPONSE = \\\n        DOT11_TYPE_MANAGEMENT|DOT11_SUBTYPE_MANAGEMENT_ASSOCIATION_RESPONSE<<2\n    DOT11_TYPE_MANAGEMENT_SUBTYPE_REASSOCIATION_REQUEST = \\\n        DOT11_TYPE_MANAGEMENT|DOT11_SUBTYPE_MANAGEMENT_REASSOCIATION_REQUEST<<2\n    DOT11_TYPE_MANAGEMENT_SUBTYPE_REASSOCIATION_RESPONSE = \\\n        DOT11_TYPE_MANAGEMENT|DOT11_SUBTYPE_MANAGEMENT_REASSOCIATION_RESPONSE<<2\n    DOT11_TYPE_MANAGEMENT_SUBTYPE_PROBE_REQUEST = \\\n        DOT11_TYPE_MANAGEMENT|DOT11_SUBTYPE_MANAGEMENT_PROBE_REQUEST<<2\n    DOT11_TYPE_MANAGEMENT_SUBTYPE_PROBE_RESPONSE = \\\n        DOT11_TYPE_MANAGEMENT|DOT11_SUBTYPE_MANAGEMENT_PROBE_RESPONSE<<2\n    DOT11_TYPE_MANAGEMENT_SUBTYPE_RESERVED1 = \\\n        DOT11_TYPE_MANAGEMENT|DOT11_SUBTYPE_MANAGEMENT_RESERVED1<<2\n    DOT11_TYPE_MANAGEMENT_SUBTYPE_RESERVED2 = \\\n        DOT11_TYPE_MANAGEMENT|DOT11_SUBTYPE_MANAGEMENT_RESERVED2<<2\n    DOT11_TYPE_MANAGEMENT_SUBTYPE_BEACON = \\\n        DOT11_TYPE_MANAGEMENT|DOT11_SUBTYPE_MANAGEMENT_BEACON<<2\n    DOT11_TYPE_MANAGEMENT_SUBTYPE_ATIM = \\\n        DOT11_TYPE_MANAGEMENT|DOT11_SUBTYPE_MANAGEMENT_ATIM<<2\n    DOT11_TYPE_MANAGEMENT_SUBTYPE_DISASSOCIATION = \\\n        DOT11_TYPE_MANAGEMENT|DOT11_SUBTYPE_MANAGEMENT_DISASSOCIATION<<2\n    DOT11_TYPE_MANAGEMENT_SUBTYPE_AUTHENTICATION = \\\n        DOT11_TYPE_MANAGEMENT|DOT11_SUBTYPE_MANAGEMENT_AUTHENTICATION<<2\n    DOT11_TYPE_MANAGEMENT_SUBTYPE_DEAUTHENTICATION = \\\n        DOT11_TYPE_MANAGEMENT|DOT11_SUBTYPE_MANAGEMENT_DEAUTHENTICATION<<2\n    DOT11_TYPE_MANAGEMENT_SUBTYPE_ACTION = \\\n        DOT11_TYPE_MANAGEMENT|DOT11_SUBTYPE_MANAGEMENT_ACTION<<2\n    DOT11_TYPE_MANAGEMENT_SUBTYPE_RESERVED3 = \\\n        DOT11_TYPE_MANAGEMENT|DOT11_SUBTYPE_MANAGEMENT_RESERVED3<<2\n    DOT11_TYPE_MANAGEMENT_SUBTYPE_RESERVED4 = \\\n        DOT11_TYPE_MANAGEMENT|DOT11_SUBTYPE_MANAGEMENT_RESERVED4<<2\n    \n    # Control Types/SubTypes\n    DOT11_TYPE_CONTROL                              = int(\"01\",2)\n    DOT11_SUBTYPE_CONTROL_RESERVED1                 = int(\"0000\",2)\n    DOT11_SUBTYPE_CONTROL_RESERVED2                 = int(\"0001\",2)\n    DOT11_SUBTYPE_CONTROL_RESERVED3                 = int(\"0010\",2)\n    DOT11_SUBTYPE_CONTROL_RESERVED4                 = int(\"0011\",2)\n    DOT11_SUBTYPE_CONTROL_RESERVED5                 = int(\"0100\",2)\n    DOT11_SUBTYPE_CONTROL_RESERVED6                 = int(\"0101\",2)\n    DOT11_SUBTYPE_CONTROL_RESERVED7                 = int(\"0110\",2)\n    DOT11_SUBTYPE_CONTROL_RESERVED8                 = int(\"0111\",2)\n    DOT11_SUBTYPE_CONTROL_BLOCK_ACK_REQUEST         = int(\"1000\",2)\n    DOT11_SUBTYPE_CONTROL_BLOCK_ACK                 = int(\"1001\",2)\n    DOT11_SUBTYPE_CONTROL_POWERSAVE_POLL            = int(\"1010\",2)\n    DOT11_SUBTYPE_CONTROL_REQUEST_TO_SEND           = int(\"1011\",2)\n    DOT11_SUBTYPE_CONTROL_CLEAR_TO_SEND             = int(\"1100\",2)\n    DOT11_SUBTYPE_CONTROL_ACKNOWLEDGMENT            = int(\"1101\",2)\n    DOT11_SUBTYPE_CONTROL_CF_END                    = int(\"1110\",2)\n    DOT11_SUBTYPE_CONTROL_CF_END_CF_ACK             = int(\"1111\",2)\n\n    DOT11_TYPE_CONTROL_SUBTYPE_RESERVED1 = \\\n        DOT11_TYPE_CONTROL|DOT11_SUBTYPE_CONTROL_RESERVED1<<2\n    DOT11_TYPE_CONTROL_SUBTYPE_RESERVED2 = \\\n        DOT11_TYPE_CONTROL|DOT11_SUBTYPE_CONTROL_RESERVED2<<2\n    DOT11_TYPE_CONTROL_SUBTYPE_RESERVED3 = \\\n        DOT11_TYPE_CONTROL|DOT11_SUBTYPE_CONTROL_RESERVED3<<2\n    DOT11_TYPE_CONTROL_SUBTYPE_RESERVED4 = \\\n        DOT11_TYPE_CONTROL|DOT11_SUBTYPE_CONTROL_RESERVED4<<2\n    DOT11_TYPE_CONTROL_SUBTYPE_RESERVED5 = \\\n        DOT11_TYPE_CONTROL|DOT11_SUBTYPE_CONTROL_RESERVED5<<2\n    DOT11_TYPE_CONTROL_SUBTYPE_RESERVED6 = \\\n        DOT11_TYPE_CONTROL|DOT11_SUBTYPE_CONTROL_RESERVED6<<2\n    DOT11_TYPE_CONTROL_SUBTYPE_RESERVED7 = \\\n        DOT11_TYPE_CONTROL|DOT11_SUBTYPE_CONTROL_RESERVED7<<2\n    DOT11_TYPE_CONTROL_SUBTYPE_BLOCK_ACK_REQUEST = \\\n        DOT11_TYPE_CONTROL|DOT11_SUBTYPE_CONTROL_BLOCK_ACK_REQUEST<<2\n    DOT11_TYPE_CONTROL_SUBTYPE_BLOCK_ACK = \\\n        DOT11_TYPE_CONTROL|DOT11_SUBTYPE_CONTROL_BLOCK_ACK<<2\n    DOT11_TYPE_CONTROL_SUBTYPE_POWERSAVE_POLL = \\\n        DOT11_TYPE_CONTROL|DOT11_SUBTYPE_CONTROL_POWERSAVE_POLL<<2\n    DOT11_TYPE_CONTROL_SUBTYPE_REQUEST_TO_SEND = \\\n        DOT11_TYPE_CONTROL|DOT11_SUBTYPE_CONTROL_REQUEST_TO_SEND<<2\n    DOT11_TYPE_CONTROL_SUBTYPE_CLEAR_TO_SEND = \\\n        DOT11_TYPE_CONTROL|DOT11_SUBTYPE_CONTROL_CLEAR_TO_SEND<<2\n    DOT11_TYPE_CONTROL_SUBTYPE_ACKNOWLEDGMENT = \\\n        DOT11_TYPE_CONTROL|DOT11_SUBTYPE_CONTROL_ACKNOWLEDGMENT<<2\n    DOT11_TYPE_CONTROL_SUBTYPE_CF_END = \\\n        DOT11_TYPE_CONTROL|DOT11_SUBTYPE_CONTROL_CF_END<<2\n    DOT11_TYPE_CONTROL_SUBTYPE_CF_END_CF_ACK = \\\n        DOT11_TYPE_CONTROL|DOT11_SUBTYPE_CONTROL_CF_END_CF_ACK<<2\n\n    # Data Types/SubTypes\n    DOT11_TYPE_DATA                                = int(\"10\",2)\n    DOT11_SUBTYPE_DATA                             = int(\"0000\",2)\n    DOT11_SUBTYPE_DATA_CF_ACK                      = int(\"0001\",2)\n    DOT11_SUBTYPE_DATA_CF_POLL                     = int(\"0010\",2)\n    DOT11_SUBTYPE_DATA_CF_ACK_CF_POLL              = int(\"0011\",2)\n    DOT11_SUBTYPE_DATA_NULL_NO_DATA                = int(\"0100\",2)\n    DOT11_SUBTYPE_DATA_CF_ACK_NO_DATA              = int(\"0101\",2)\n    DOT11_SUBTYPE_DATA_CF_POLL_NO_DATA             = int(\"0110\",2)\n    DOT11_SUBTYPE_DATA_CF_ACK_CF_POLL_NO_DATA      = int(\"0111\",2)\n    DOT11_SUBTYPE_DATA_QOS_DATA                    = int(\"1000\",2)\n    DOT11_SUBTYPE_DATA_QOS_DATA_CF_ACK             = int(\"1001\",2)\n    DOT11_SUBTYPE_DATA_QOS_DATA_CF_POLL            = int(\"1010\",2)\n    DOT11_SUBTYPE_DATA_QOS_DATA_CF_ACK_CF_POLL     = int(\"1011\",2)\n    DOT11_SUBTYPE_DATA_QOS_NULL_NO_DATA            = int(\"1100\",2)\n    DOT11_SUBTYPE_DATA_RESERVED1                   = int(\"1101\",2)\n    DOT11_SUBTYPE_DATA_QOS_CF_POLL_NO_DATA         = int(\"1110\",2)\n    DOT11_SUBTYPE_DATA_QOS_CF_ACK_CF_POLL_NO_DATA  = int(\"1111\",2)\n\n    DOT11_TYPE_DATA_SUBTYPE_DATA = \\\n        DOT11_TYPE_DATA|DOT11_SUBTYPE_DATA<<2\n    DOT11_TYPE_DATA_SUBTYPE_CF_ACK = \\\n        DOT11_TYPE_DATA|DOT11_SUBTYPE_DATA_CF_ACK<<2\n    DOT11_TYPE_DATA_SUBTYPE_CF_POLL = \\\n        DOT11_TYPE_DATA|DOT11_SUBTYPE_DATA_CF_POLL<<2\n    DOT11_TYPE_DATA_SUBTYPE_CF_ACK_CF_POLL = \\\n        DOT11_TYPE_DATA|DOT11_SUBTYPE_DATA_CF_ACK_CF_POLL<<2\n    DOT11_TYPE_DATA_SUBTYPE_NULL_NO_DATA = \\\n        DOT11_TYPE_DATA|DOT11_SUBTYPE_DATA_NULL_NO_DATA<<2\n    DOT11_TYPE_DATA_SUBTYPE_CF_ACK_NO_DATA = \\\n        DOT11_TYPE_DATA|DOT11_SUBTYPE_DATA_CF_POLL_NO_DATA<<2\n    DOT11_TYPE_DATA_SUBTYPE_CF_ACK_CF_POLL_NO_DATA = \\\n        DOT11_TYPE_DATA|DOT11_SUBTYPE_DATA_CF_ACK_CF_POLL_NO_DATA<<2\n    DOT11_TYPE_DATA_SUBTYPE_QOS_DATA = \\\n        DOT11_TYPE_DATA|DOT11_SUBTYPE_DATA_QOS_DATA<<2\n    DOT11_TYPE_DATA_SUBTYPE_QOS_DATA_CF_ACK = \\\n        DOT11_TYPE_DATA|DOT11_SUBTYPE_DATA_QOS_DATA_CF_ACK<<2\n    DOT11_TYPE_DATA_SUBTYPE_QOS_DATA_CF_POLL = \\\n        DOT11_TYPE_DATA|DOT11_SUBTYPE_DATA_QOS_DATA_CF_POLL<<2\n    DOT11_TYPE_DATA_SUBTYPE_QOS_DATA_CF_ACK_CF_POLL = \\\n        DOT11_TYPE_DATA|DOT11_SUBTYPE_DATA_QOS_DATA_CF_ACK_CF_POLL<<2\n    DOT11_TYPE_DATA_SUBTYPE_QOS_NULL_NO_DATA = \\\n        DOT11_TYPE_DATA|DOT11_SUBTYPE_DATA_QOS_NULL_NO_DATA<<2\n    DOT11_TYPE_DATA_SUBTYPE_RESERVED1 = \\\n        DOT11_TYPE_DATA|DOT11_SUBTYPE_DATA_RESERVED1<<2\n    DOT11_TYPE_DATA_SUBTYPE_QOS_CF_POLL_NO_DATA = \\\n        DOT11_TYPE_DATA|DOT11_SUBTYPE_DATA_QOS_CF_POLL_NO_DATA<<2\n    DOT11_TYPE_DATA_SUBTYPE_QOS_CF_ACK_CF_POLL_NO_DATA = \\\n        DOT11_TYPE_DATA|DOT11_SUBTYPE_DATA_QOS_CF_ACK_CF_POLL_NO_DATA<<2\n\n    # Reserved Types/SubTypes\n    DOT11_TYPE_RESERVED = int(\"11\",2)\n    DOT11_SUBTYPE_RESERVED_RESERVED1               = int(\"0000\",2)\n    DOT11_SUBTYPE_RESERVED_RESERVED2               = int(\"0001\",2)\n    DOT11_SUBTYPE_RESERVED_RESERVED3               = int(\"0010\",2)\n    DOT11_SUBTYPE_RESERVED_RESERVED4               = int(\"0011\",2)\n    DOT11_SUBTYPE_RESERVED_RESERVED5               = int(\"0100\",2)\n    DOT11_SUBTYPE_RESERVED_RESERVED6               = int(\"0101\",2)\n    DOT11_SUBTYPE_RESERVED_RESERVED7               = int(\"0110\",2)\n    DOT11_SUBTYPE_RESERVED_RESERVED8               = int(\"0111\",2)\n    DOT11_SUBTYPE_RESERVED_RESERVED9               = int(\"1000\",2)\n    DOT11_SUBTYPE_RESERVED_RESERVED10              = int(\"1001\",2)\n    DOT11_SUBTYPE_RESERVED_RESERVED11              = int(\"1010\",2)\n    DOT11_SUBTYPE_RESERVED_RESERVED12              = int(\"1011\",2)\n    DOT11_SUBTYPE_RESERVED_RESERVED13              = int(\"1100\",2)\n    DOT11_SUBTYPE_RESERVED_RESERVED14              = int(\"1101\",2)\n    DOT11_SUBTYPE_RESERVED_RESERVED15              = int(\"1110\",2)\n    DOT11_SUBTYPE_RESERVED_RESERVED16              = int(\"1111\",2)\n\n    DOT11_TYPE_RESERVED_SUBTYPE_RESERVED1 = \\\n        DOT11_TYPE_RESERVED|DOT11_SUBTYPE_RESERVED_RESERVED1<<2\n    DOT11_TYPE_RESERVED_SUBTYPE_RESERVED2 = \\\n        DOT11_TYPE_RESERVED|DOT11_SUBTYPE_RESERVED_RESERVED2<<2\n    DOT11_TYPE_RESERVED_SUBTYPE_RESERVED3 = \\\n        DOT11_TYPE_RESERVED|DOT11_SUBTYPE_RESERVED_RESERVED3<<2\n    DOT11_TYPE_RESERVED_SUBTYPE_RESERVED4 = \\\n        DOT11_TYPE_RESERVED|DOT11_SUBTYPE_RESERVED_RESERVED4<<2\n    DOT11_TYPE_RESERVED_SUBTYPE_RESERVED5 = \\\n        DOT11_TYPE_RESERVED|DOT11_SUBTYPE_RESERVED_RESERVED5<<2\n    DOT11_TYPE_RESERVED_SUBTYPE_RESERVED6 = \\\n        DOT11_TYPE_RESERVED|DOT11_SUBTYPE_RESERVED_RESERVED6<<2\n    DOT11_TYPE_RESERVED_SUBTYPE_RESERVED7 = \\\n        DOT11_TYPE_RESERVED|DOT11_SUBTYPE_RESERVED_RESERVED7<<2\n    DOT11_TYPE_RESERVED_SUBTYPE_RESERVED8 = \\\n        DOT11_TYPE_RESERVED|DOT11_SUBTYPE_RESERVED_RESERVED8<<2\n    DOT11_TYPE_RESERVED_SUBTYPE_RESERVED9 = \\\n        DOT11_TYPE_RESERVED|DOT11_SUBTYPE_RESERVED_RESERVED9<<2\n    DOT11_TYPE_RESERVED_SUBTYPE_RESERVED10 = \\\n        DOT11_TYPE_RESERVED|DOT11_SUBTYPE_RESERVED_RESERVED10<<2\n    DOT11_TYPE_RESERVED_SUBTYPE_RESERVED11 = \\\n        DOT11_TYPE_RESERVED|DOT11_SUBTYPE_RESERVED_RESERVED11<<2\n    DOT11_TYPE_RESERVED_SUBTYPE_RESERVED12 = \\\n        DOT11_TYPE_RESERVED|DOT11_SUBTYPE_RESERVED_RESERVED12<<2\n    DOT11_TYPE_RESERVED_SUBTYPE_RESERVED13 = \\\n        DOT11_TYPE_RESERVED|DOT11_SUBTYPE_RESERVED_RESERVED13<<2\n    DOT11_TYPE_RESERVED_SUBTYPE_RESERVED14 = \\\n        DOT11_TYPE_RESERVED|DOT11_SUBTYPE_RESERVED_RESERVED14<<2\n    DOT11_TYPE_RESERVED_SUBTYPE_RESERVED15 = \\\n        DOT11_TYPE_RESERVED|DOT11_SUBTYPE_RESERVED_RESERVED15<<2\n    DOT11_TYPE_RESERVED_SUBTYPE_RESERVED16 = \\\n        DOT11_TYPE_RESERVED|DOT11_SUBTYPE_RESERVED_RESERVED16<<2",
  "class Dot11(ProtocolPacket):    \n    def __init__(self, aBuffer = None, FCS_at_end = True):\n        header_size = 2\n        self.__FCS_at_end=not not FCS_at_end # Is Boolean\n        if self.__FCS_at_end:\n            tail_size = 4\n        else:\n            tail_size = 0\n            \n        ProtocolPacket.__init__(self, header_size,tail_size)\n        if(aBuffer):\n            self.load_packet(aBuffer)\n        \n    def get_order(self):\n        \"Return 802.11 frame 'Order' field\"\n        b = self.header.get_byte(1)\n        return ((b >> 7) & 0x01)\n\n    def set_order(self, value):\n        \"Set 802.11 frame 'Order' field\"\n        # clear the bits\n        mask = (~0x80) & 0xFF\n        masked = self.header.get_byte(1) & mask\n        # set the bits\n        nb = masked | ((value & 0x01) << 7)\n        self.header.set_byte(1, nb)\n\n    def get_protectedFrame(self):\n        \"Return 802.11 frame 'Protected' field\"\n        b = self.header.get_byte(1)\n        return ((b >> 6) & 0x01)\n\n    def set_protectedFrame(self, value):\n        \"Set 802.11 frame 'Protected Frame' field\"\n        # clear the bits\n        mask = (~0x40) & 0xFF\n        masked = self.header.get_byte(1) & mask\n        # set the bits\n        nb = masked | ((value & 0x01) << 6)\n        self.header.set_byte(1, nb)\n\n    def get_moreData(self):\n        \"Return 802.11 frame 'More Data' field\"\n        b = self.header.get_byte(1)\n        return ((b >> 5) & 0x01)\n\n    def set_moreData(self, value):\n        \"Set 802.11 frame 'More Data' field\"\n        # clear the bits\n        mask = (~0x20) & 0xFF\n        masked = self.header.get_byte(1) & mask\n        # set the bits\n        nb = masked | ((value & 0x01) << 5)\n        self.header.set_byte(1, nb)\n        \n    def get_powerManagement(self):\n        \"Return 802.11 frame 'Power Management' field\"\n        b = self.header.get_byte(1)\n        return ((b >> 4) & 0x01)\n\n    def set_powerManagement(self, value):\n        \"Set 802.11 frame 'Power Management' field\"\n        # clear the bits\n        mask = (~0x10) & 0xFF\n        masked = self.header.get_byte(1) & mask\n        # set the bits\n        nb = masked | ((value & 0x01) << 4)\n        self.header.set_byte(1, nb)\n  \n    def get_retry(self):\n        \"Return 802.11 frame 'Retry' field\"\n        b = self.header.get_byte(1)\n        return ((b >> 3) & 0x01)\n\n    def set_retry(self, value):\n        \"Set 802.11 frame 'Retry' field\"\n        # clear the bits\n        mask = (~0x08) & 0xFF\n        masked = self.header.get_byte(1) & mask\n        # set the bits\n        nb = masked | ((value & 0x01) << 3)\n        self.header.set_byte(1, nb)   \n        \n    def get_moreFrag(self):\n        \"Return 802.11 frame 'More Fragments' field\"\n        b = self.header.get_byte(1)\n        return ((b >> 2) & 0x01)\n\n    def set_moreFrag(self, value):\n        \"Set 802.11 frame 'More Fragments' field\"\n        # clear the bits\n        mask = (~0x04) & 0xFF\n        masked = self.header.get_byte(1) & mask\n        # set the bits\n        nb = masked | ((value & 0x01) << 2)\n        self.header.set_byte(1, nb)  \n               \n    def get_fromDS(self):\n        \"Return 802.11 frame 'from DS' field\"\n        b = self.header.get_byte(1)\n        return ((b >> 1) & 0x01)\n\n    def set_fromDS(self, value):\n        \"Set 802.11 frame 'from DS' field\"\n        # clear the bits\n        mask = (~0x02) & 0xFF\n        masked = self.header.get_byte(1) & mask\n        # set the bits\n        nb = masked | ((value & 0x01) << 1)\n        self.header.set_byte(1, nb)\n         \n    def get_toDS(self):\n        \"Return 802.11 frame 'to DS' field\"\n        b = self.header.get_byte(1)\n        return (b & 0x01)\n\n    def set_toDS(self, value):\n        \"Set 802.11 frame 'to DS' field\"\n        # clear the bits\n        mask = (~0x01) & 0xFF\n        masked = self.header.get_byte(1) & mask\n        # set the bits\n        nb = masked | (value & 0x01) \n        self.header.set_byte(1, nb)    \n        \n    def get_subtype(self):\n        \"Return 802.11 frame 'subtype' field\"\n        b = self.header.get_byte(0)\n        return ((b >> 4) & 0x0F)\n\n    def set_subtype(self, value):\n        \"Set 802.11 frame 'subtype' field\"\n        # clear the bits\n        mask = (~0xF0)&0xFF \n        masked = self.header.get_byte(0) & mask \n        # set the bits\n        nb = masked | ((value << 4) & 0xF0)\n        self.header.set_byte(0, nb)\n        \n    def get_type(self):\n        \"Return 802.11 frame 'type' field\"\n        b = self.header.get_byte(0)\n        return ((b >> 2) & 0x03)\n\n    def set_type(self, value):\n        \"Set 802.11 frame 'type' field\"\n        # clear the bits\n        mask = (~0x0C)&0xFF \n        masked = self.header.get_byte(0) & mask \n        # set the bits\n        nb = masked | ((value << 2) & 0x0C)\n        self.header.set_byte(0, nb)\n\n    def get_type_n_subtype(self):\n        \"Return 802.11 frame 'Type and Subtype' field\"\n        b = self.header.get_byte(0)\n        return ((b >> 2) & 0x3F)\n\n    def set_type_n_subtype(self, value):\n        \"Set 802.11 frame 'Type and Subtype' field\"\n        # clear the bits\n        mask = (~0xFC)&0xFF \n        masked = self.header.get_byte(0) & mask \n        # set the bits\n        nb = masked | ((value << 2) & 0xFC)\n        self.header.set_byte(0, nb)\n\n    def get_version(self):\n        \"Return 802.11 frame control 'Protocol version' field\"\n        b = self.header.get_byte(0)\n        return (b & 0x03)\n\n    def set_version(self, value):\n        \"Set the 802.11 frame control 'Protocol version' field\"\n        # clear the bits\n        mask = (~0x03)&0xFF \n        masked = self.header.get_byte(0) & mask \n        # set the bits\n        nb = masked | (value & 0x03)\n        self.header.set_byte(0, nb)\n        \n    def compute_checksum(self,bytes):\n        crcle=crc32(bytes)&0xffffffff\n        # ggrr this crc32 is in little endian, convert it to big endian \n        crc=struct.pack('<L', crcle)\n         # Convert to long\n        (crc_long,) = struct.unpack('!L', crc)\n        return crc_long\n\n    def is_QoS_frame(self):\n        \"Return 'True' if is an QoS data frame type\"\n        \n        b = self.header.get_byte(0)\n        return (b & 0x80) and True        \n\n    def is_no_framebody_frame(self):\n        \"Return 'True' if it frame contain no Frame Body\"\n        \n        b = self.header.get_byte(0)\n        return (b & 0x40) and True\n\n    def is_cf_poll_frame(self):\n        \"Return 'True' if it frame is a CF_POLL frame\"\n        \n        b = self.header.get_byte(0)\n        return (b & 0x20) and True\n\n    def is_cf_ack_frame(self):\n        \"Return 'True' if it frame is a CF_ACK frame\"\n        \n        b = self.header.get_byte(0)\n        return (b & 0x10) and True\n    \n    def get_fcs(self):\n        \"Return 802.11 'FCS' field\"\n        \n        if not self.__FCS_at_end:\n            return None   \n\n        b = self.tail.get_long(-4, \">\")\n        return b \n\n    def set_fcs(self, value = None):\n        \"Set the 802.11 CTS control frame 'FCS' field. If value is None, is auto_checksum\"\n\n        if not self.__FCS_at_end:   \n            return\n        \n        # calculate the FCS\n        if value is None:\n            payload = self.get_body_as_string()\n            crc32=self.compute_checksum(payload)            \n            value=crc32\n\n        # set the bits\n        nb = value & 0xFFFFFFFF\n        self.tail.set_long(-4, nb)",
  "class Dot11ControlFrameCTS(ProtocolPacket):\n    \"802.11 Clear-To-Send Control Frame\"\n    \n    def __init__(self, aBuffer = None):\n        header_size = 8\n        tail_size = 0\n\n        ProtocolPacket.__init__(self, header_size, tail_size)\n        if(aBuffer):\n            self.load_packet(aBuffer)\n            \n    def get_duration(self):\n        \"Return 802.11 CTS control frame 'Duration' field\"\n        b = self.header.get_word(0, \"<\")\n        return b \n\n    def set_duration(self, value):\n        \"Set the 802.11 CTS control frame 'Duration' field\" \n        # set the bits\n        nb = value & 0xFFFF\n        self.header.set_word(0, nb, \"<\")\n        \n    def get_ra(self):\n        \"Return 802.11 CTS control frame 48 bit 'Receiver Address' field as a 6 bytes array\"\n        return self.header.get_bytes()[2:8]\n\n    def set_ra(self, value):\n        \"Set 802.11 CTS control frame 48 bit 'Receiver Address' field as a 6 bytes array\"\n        for i in range(0, 6):\n            self.header.set_byte(2+i, value[i])",
  "class Dot11ControlFrameACK(ProtocolPacket):\n    \"802.11 Acknowledgement Control Frame\"\n        \n    def __init__(self, aBuffer = None):\n        header_size = 8\n        tail_size = 0\n\n        ProtocolPacket.__init__(self, header_size, tail_size)\n        if(aBuffer):\n            self.load_packet(aBuffer)\n            \n    def get_duration(self):\n        \"Return 802.11 ACK control frame 'Duration' field\"\n        b = self.header.get_word(0, \"<\")\n        return b \n\n    def set_duration(self, value):\n        \"Set the 802.11 ACK control frame 'Duration' field\" \n        # set the bits\n        nb = value & 0xFFFF\n        self.header.set_word(0, nb, \"<\")\n        \n    def get_ra(self):\n        \"Return 802.11 ACK control frame 48 bit 'Receiver Address' field as a 6 bytes array\"\n        return self.header.get_bytes()[2:8]\n\n    def set_ra(self, value):\n        \"Set 802.11 ACK control frame 48 bit 'Receiver Address' field as a 6 bytes array\"\n        for i in range(0, 6):\n            self.header.set_byte(2+i, value[i])",
  "class Dot11ControlFrameRTS(ProtocolPacket):\n    \"802.11 Request-To-Send Control Frame\"\n        \n    def __init__(self, aBuffer = None):\n        header_size = 14\n        tail_size = 0\n\n        ProtocolPacket.__init__(self, header_size, tail_size)\n        if(aBuffer):\n            self.load_packet(aBuffer)\n    \n    def get_duration(self):\n        \"Return 802.11 RTS control frame 'Duration' field\"\n        b = self.header.get_word(0, \"<\")\n        return b \n\n    def set_duration(self, value):\n        \"Set the 802.11 RTS control frame 'Duration' field\" \n        # set the bits\n        nb = value & 0xFFFF\n        self.header.set_word(0, nb, \"<\")\n        \n    def get_ra(self):\n        \"Return 802.11 RTS control frame 48 bit 'Receiver Address' field as a 6 bytes array\"\n        return self.header.get_bytes()[2:8]\n\n    def set_ra(self, value):\n        \"Set 802.11 RTS control frame 48 bit 'Receiver Address' field as a 6 bytes array\"\n        for i in range(0, 6):\n            self.header.set_byte(2+i, value[i])\n\n    def get_ta(self):\n        \"Return 802.11 RTS control frame 48 bit 'Transmitter Address' field as a 6 bytes array\"\n        return self.header.get_bytes()[8:14]\n\n    def set_ta(self, value):\n        \"Set 802.11 RTS control frame 48 bit 'Transmitter Address' field as a 6 bytes array\"\n        for i in range(0, 6):\n            self.header.set_byte(8+i, value[i])",
  "class Dot11ControlFramePSPoll(ProtocolPacket):\n    \"802.11 Power-Save Poll Control Frame\"\n    \n    def __init__(self, aBuffer = None):\n        header_size = 14\n        tail_size = 0\n        \n        ProtocolPacket.__init__(self, header_size, tail_size)\n        if(aBuffer):\n            self.load_packet(aBuffer)\n\n    def get_aid(self):\n        \"Return 802.11 PSPoll control frame 'AID' field\"\n        # the spec says \"The AID value always has its two MSBs each set to 1.\"\n        # TODO: Should we do check/modify it? Wireshark shows the only MSB to 0\n        b = self.header.get_word(0, \"<\")\n        return b \n\n    def set_aid(self, value):\n        \"Set the 802.11 PSPoll control frame 'AID' field\" \n        # set the bits\n        nb = value & 0xFFFF\n        # the spec says \"The AID value always has its two MSBs each set to 1.\"\n        # TODO: Should we do check/modify it? Wireshark shows the only MSB to 0\n        self.header.set_word(0, nb, \"<\")\n        \n    def get_bssid(self):\n        \"Return 802.11 PSPoll control frame 48 bit 'BSS ID' field as a 6 bytes array\"\n        return self.header.get_bytes()[2:8]\n\n    def set_bssid(self, value):\n        \"Set 802.11 PSPoll control frame 48 bit 'BSS ID' field as a 6 bytes array\"\n        for i in range(0, 6):\n            self.header.set_byte(2+i, value[i])\n\n    def get_ta(self):\n        \"Return 802.11 PSPoll control frame 48 bit 'Transmitter Address' field as a 6 bytes array\"\n        return self.header.get_bytes()[8:14]\n\n    def set_ta(self, value):\n        \"Set 802.11 PSPoll control frame 48 bit 'Transmitter Address' field as a 6 bytes array\"\n        for i in range(0, 6):\n            self.header.set_byte(8+i, value[i])",
  "class Dot11ControlFrameCFEnd(ProtocolPacket):\n    \"802.11 'Contention Free End' Control Frame\"\n    \n    def __init__(self, aBuffer = None):\n        header_size = 14\n        tail_size = 0\n    \n        ProtocolPacket.__init__(self, header_size, tail_size)\n        if(aBuffer):\n            self.load_packet(aBuffer)\n\n    def get_duration(self):\n        \"Return 802.11 CF-End control frame 'Duration' field\"\n        b = self.header.get_word(0, \"<\")\n        return b \n\n    def set_duration(self, value):\n        \"Set the 802.11 CF-End control frame 'Duration' field\" \n        # set the bits\n        nb = value & 0xFFFF\n        self.header.set_word(0, nb, \"<\")\n        \n    def get_ra(self):\n        \"Return 802.11 CF-End control frame 48 bit 'Receiver Address' field as a 6 bytes array\"\n        return self.header.get_bytes()[2:8]\n\n    def set_ra(self, value):\n        \"Set 802.11 CF-End control frame 48 bit 'Receiver Address' field as a 6 bytes array\"\n        for i in range(0, 6):\n            self.header.set_byte(2+i, value[i])\n\n    def get_bssid(self):\n        \"Return 802.11 CF-End control frame 48 bit 'BSS ID' field as a 6 bytes array\"\n        return self.header.get_bytes()[8:14]\n\n    def set_bssid(self, value):\n        \"Set 802.11 CF-End control frame 48 bit 'BSS ID' field as a 6 bytes array\"\n        for i in range(0, 6):\n            self.header.set_byte(8+i, value[i])",
  "class Dot11ControlFrameCFEndCFACK(ProtocolPacket):\n    '802.11 \\'CF-End + CF-ACK\\' Control Frame'\n        \n    def __init__(self, aBuffer = None):\n        header_size = 14\n        tail_size = 0\n\n        ProtocolPacket.__init__(self, header_size, tail_size)\n        if(aBuffer):\n            self.load_packet(aBuffer)\n\n    def get_duration(self):\n        'Return 802.11 \\'CF-End+CF-ACK\\' control frame \\'Duration\\' field'\n        b = self.header.get_word(0, \"<\")\n        return b \n\n    def set_duration(self, value):\n        'Set the 802.11 \\'CF-End+CF-ACK\\' control frame \\'Duration\\' field' \n        # set the bits\n        nb = value & 0xFFFF\n        self.header.set_word(0, nb, \"<\")\n        \n    def get_ra(self):\n        'Return 802.11 \\'CF-End+CF-ACK\\' control frame 48 bit \\'Receiver Address\\' field as a 6 bytes array'\n        return self.header.get_bytes()[2:8]\n\n    def set_ra(self, value):\n        'Set 802.11 \\'CF-End+CF-ACK\\' control frame 48 bit \\'Receiver Address\\' field as a 6 bytes array'\n        for i in range(0, 6):\n            self.header.set_byte(2+i, value[i])\n\n    def get_bssid(self):\n        'Return 802.11 \\'CF-End+CF-ACK\\' control frame 48 bit \\'BSS ID\\' field as a 6 bytes array'\n        return self.header.get_bytes()[8:16]\n\n    def set_bssid(self, value):\n        'Set 802.11 \\'CF-End+CF-ACK\\' control frame 48 bit \\'BSS ID\\' field as a 6 bytes array'\n        for i in range(0, 6):\n            self.header.set_byte(8+i, value[i])",
  "class Dot11DataFrame(ProtocolPacket):\n    '802.11 Data Frame'\n    \n    def __init__(self, aBuffer = None):\n        header_size = 22\n        tail_size = 0\n\n        ProtocolPacket.__init__(self, header_size, tail_size)\n        if(aBuffer):\n            self.load_packet(aBuffer)\n        \n    def get_duration(self):\n        'Return 802.11 \\'Data\\' data frame \\'Duration\\' field'\n        b = self.header.get_word(0, \"<\")\n        return b \n\n    def set_duration(self, value):\n        'Set the 802.11 \\'Data\\' data frame \\'Duration\\' field' \n        # set the bits\n        nb = value & 0xFFFF\n        self.header.set_word(0, nb, \"<\")\n        \n    def get_address1(self):\n        'Return 802.11 \\'Data\\' data frame 48 bit \\'Address1\\' field as a 6 bytes array'\n        return self.header.get_bytes()[2:8]\n\n    def set_address1(self, value):\n        'Set 802.11 \\'Data\\' data frame 48 bit \\'Address1\\' field as a 6 bytes array'\n        for i in range(0, 6):\n            self.header.set_byte(2+i, value[i])\n\n    def get_address2(self):\n        'Return 802.11 \\'Data\\' data frame 48 bit \\'Address2\\' field as a 6 bytes array'\n        return self.header.get_bytes()[8:14]\n\n    def set_address2(self, value):\n        'Set 802.11 \\'Data\\' data frame 48 bit \\'Address2\\' field as a 6 bytes array'\n        for i in range(0, 6):\n            self.header.set_byte(8+i, value[i])\n            \n    def get_address3(self):\n        'Return 802.11 \\'Data\\' data frame 48 bit \\'Address3\\' field as a 6 bytes array'\n        return self.header.get_bytes()[14: 20]\n\n    def set_address3(self, value):\n        'Set 802.11 \\'Data\\' data frame 48 bit \\'Address3\\' field as a 6 bytes array'\n        for i in range(0, 6):\n            self.header.set_byte(14+i, value[i])\n\n    def get_sequence_control(self):\n        'Return 802.11 \\'Data\\' data frame \\'Sequence Control\\' field'\n        b = self.header.get_word(20, \"<\")\n        return b \n\n    def set_sequence_control(self, value):\n        'Set the 802.11 \\'Data\\' data frame \\'Sequence Control\\' field' \n        # set the bits\n        nb = value & 0xFFFF\n        self.header.set_word(20, nb, \"<\")\n\n    def get_fragment_number(self):\n        'Return 802.11 \\'Data\\' data frame \\'Fragment Number\\' subfield'\n\n        b = self.header.get_word(20, \"<\")\n        return (b&0x000F) \n\n    def set_fragment_number(self, value):\n        'Set the 802.11 \\'Data\\' data frame \\'Fragment Number\\' subfield' \n        # clear the bits\n        mask = (~0x000F) & 0xFFFF\n        masked = self.header.get_word(20, \"<\") & mask\n        # set the bits \n        nb = masked | (value & 0x000F)\n        self.header.set_word(20, nb, \"<\")\n        \n    def get_sequence_number(self):\n        'Return 802.11 \\'Data\\' data frame \\'Sequence Number\\' subfield'\n        \n        b = self.header.get_word(20, \"<\")\n        return ((b>>4) & 0xFFF) \n    \n    def set_sequence_number(self, value):\n        'Set the 802.11 \\'Data\\' data frame \\'Sequence Number\\' subfield' \n        # clear the bits\n        mask = (~0xFFF0) & 0xFFFF\n        masked = self.header.get_word(20, \"<\") & mask\n        # set the bits \n        nb = masked | ((value & 0x0FFF ) << 4 ) \n        self.header.set_word(20, nb, \"<\")\n\n    def get_frame_body(self):\n        'Return 802.11 \\'Data\\' data frame \\'Frame Body\\' field'\n        \n        return self.get_body_as_string()\n\n    def set_frame_body(self, data):\n        'Set 802.11 \\'Data\\' data frame \\'Frame Body\\' field'\n        \n        self.load_body(data)",
  "class Dot11DataQoSFrame(Dot11DataFrame):\n    '802.11 Data QoS Frame'\n    \n    def __init__(self, aBuffer = None):\n        header_size = 24\n        tail_size = 0\n\n        ProtocolPacket.__init__(self, header_size, tail_size)\n        if(aBuffer):\n            self.load_packet(aBuffer)\n\n    def get_QoS(self):\n        'Return 802.11 \\'Data\\' data frame \\'QoS\\' field'\n        b = self.header.get_word(22, \"<\")\n        return b \n\n    def set_QoS(self, value):\n        'Set the 802.11 \\'Data\\' data frame \\'QoS\\' field' \n        # set the bits\n        nb = value & 0xFFFF\n        self.header.set_word(22, nb, \"<\")",
  "class Dot11DataAddr4Frame(Dot11DataFrame):\n    '802.11 Data With ToDS From DS Flags (With Addr 4) Frame'\n\n    def __init__(self, aBuffer = None):\n        header_size = 28\n        tail_size = 0\n\n        ProtocolPacket.__init__(self, header_size, tail_size)\n        if(aBuffer):\n            self.load_packet(aBuffer)\n    \n    def get_address4(self):\n        'Return 802.11 \\'Data\\' data frame 48 bit \\'Address4\\' field as a 6 bytes array'\n        return self.header.get_bytes()[22:28]\n        \n    def set_address4(self, value):\n        'Set 802.11 \\'Data\\' data frame 48 bit \\'Address4\\' field as a 6 bytes array'\n        for i in range(0, 6):\n            self.header.set_byte(22+i, value[i])",
  "class Dot11DataAddr4QoSFrame(Dot11DataAddr4Frame):\n    '802.11 Data With ToDS From DS Flags (With Addr 4) and QoS Frame'\n\n    def __init__(self, aBuffer = None):\n        header_size = 30\n        tail_size = 0\n\n        ProtocolPacket.__init__(self, header_size, tail_size)\n        if(aBuffer):\n            self.load_packet(aBuffer)\n    \n    def get_QoS(self):\n        'Return 802.11 \\'Data\\' data frame \\'QoS\\' field'\n        b = self.header.get_word(28, \"<\")\n        return b \n\n    def set_QoS(self, value):\n        'Set the 802.11 \\'Data\\' data frame \\'QoS\\' field' \n        # set the bits\n        nb = value & 0xFFFF\n        self.header.set_word(28, nb, \"<\")",
  "class SAPTypes():\n    NULL            = 0x00\n    LLC_SLMGMT      = 0x02\n    SNA_PATHCTRL    = 0x04\n    IP              = 0x06\n    SNA1            = 0x08\n    SNA2            = 0x0C\n    PROWAY_NM_INIT  = 0x0E\n    NETWARE1        = 0x10\n    OSINL1          = 0x14\n    TI              = 0x18\n    OSINL2          = 0x20\n    OSINL3          = 0x34\n    SNA3            = 0x40\n    BPDU            = 0x42\n    RS511           = 0x4E\n    OSINL4          = 0x54\n    X25             = 0x7E\n    XNS             = 0x80\n    BACNET          = 0x82\n    NESTAR          = 0x86\n    PROWAY_ASLM     = 0x8E\n    ARP             = 0x98\n    SNAP            = 0xAA\n    HPJD            = 0xB4\n    VINES1          = 0xBA\n    VINES2          = 0xBC\n    NETWARE2        = 0xE0\n    NETBIOS         = 0xF0\n    IBMNM           = 0xF4\n    HPEXT           = 0xF8\n    UB              = 0xFA\n    RPL             = 0xFC\n    OSINL5          = 0xFE\n    GLOBAL          = 0xFF",
  "class LLC(ProtocolPacket):\n    '802.2 Logical Link Control (LLC) Frame'\n    \n    DLC_UNNUMBERED_FRAMES = 0x03\n\n    def __init__(self, aBuffer = None):\n        header_size = 3\n        tail_size = 0\n\n        ProtocolPacket.__init__(self, header_size, tail_size)\n        if(aBuffer):\n            self.load_packet(aBuffer)\n\n    def get_DSAP(self):\n        \"Get the Destination Service Access Point (SAP) from LLC frame\"\n        return self.header.get_byte(0)\n\n    def set_DSAP(self, value):\n        \"Set the Destination Service Access Point (SAP) of LLC frame\"\n        self.header.set_byte(0, value)\n\n    def get_SSAP(self):\n        \"Get the Source Service Access Point (SAP) from LLC frame\"\n        return self.header.get_byte(1)\n\n    def set_SSAP(self, value):\n        \"Set the Source Service Access Point (SAP) of LLC frame\"\n        self.header.set_byte(1, value)\n    \n    def get_control(self):\n        \"Get the Control field from LLC frame\"\n        return self.header.get_byte(2)\n\n    def set_control(self, value):\n        \"Set the Control field of LLC frame\"\n        self.header.set_byte(2, value)",
  "class SNAP(ProtocolPacket):\n    '802.2 SubNetwork Access Protocol (SNAP) Frame'\n\n    def __init__(self, aBuffer = None):\n        header_size = 5\n        tail_size = 0\n\n        ProtocolPacket.__init__(self, header_size, tail_size)\n        if(aBuffer):\n            self.load_packet(aBuffer)\n\n    def get_OUI(self):\n        \"Get the three-octet Organizationally Unique Identifier (OUI) SNAP frame\"\n        b = array_tobytes(self.header.get_bytes()[0:3])\n        #unpack requires a string argument of length 4 and b is 3 bytes long\n        (oui,) = struct.unpack('!L', b'\\x00'+b)\n        return oui\n\n    def set_OUI(self, value):\n        \"Set the three-octet Organizationally Unique Identifier (OUI) SNAP frame\"\n        # clear the bits\n        mask = ((~0xFFFFFF00) & 0xFF)\n        masked = self.header.get_long(0, \">\") & mask\n        # set the bits \n        nb = masked | ((value & 0x00FFFFFF) << 8)\n        self.header.set_long(0, nb)\n\n    def get_protoID(self):\n        \"Get the two-octet Protocol Identifier (PID) SNAP field\"\n        return self.header.get_word(3, \">\")\n\n    def set_protoID(self, value):\n        \"Set the two-octet Protocol Identifier (PID) SNAP field\"\n        self.header.set_word(3, value, \">\")",
  "class Dot11WEP(ProtocolPacket):\n    '802.11 WEP'\n\n    def __init__(self, aBuffer = None):\n        header_size = 4\n        tail_size = 0\n\n        ProtocolPacket.__init__(self, header_size, tail_size)\n        if(aBuffer):\n            self.load_packet(aBuffer)\n        \n    def is_WEP(self):\n        'Return True if it\\'s a WEP'\n        # We already know that it's private.\n        # Now we must differentiate between WEP and WPA/WPA2\n        # WPA/WPA2 have the ExtIV (Bit 5) enaled and WEP disabled\n        b = self.header.get_byte(3)\n        return not (b & 0x20)\n            \n    def get_iv(self):\n        'Return the \\'WEP IV\\' field'\n        b = array_tobytes(self.header.get_bytes()[0:3])\n        #unpack requires a string argument of length 4 and b is 3 bytes long\n        (iv,) = struct.unpack('!L', b'\\x00'+b)\n        return iv\n\n    def set_iv(self, value):\n        'Set the \\'WEP IV\\' field.'\n        # clear the bits\n        mask = ((~0xFFFFFF00) & 0xFF)\n        masked = self.header.get_long(0, \">\") & mask\n        # set the bits \n        nb = masked | ((value & 0x00FFFFFF) << 8)\n        self.header.set_long(0, nb)\n\n    def get_keyid(self):\n        'Return the \\'WEP KEY ID\\' field'\n        b = self.header.get_byte(3)\n        return ((b>>6) & 0x03)\n\n    def set_keyid(self, value):\n        'Set the \\'WEP KEY ID\\' field'\n        # clear the bits\n        mask = (~0xC0) & 0xFF\n        masked = self.header.get_byte(3) & mask\n        # set the bits\n        nb = masked | ((value & 0x03) << 6)\n        self.header.set_byte(3, nb)\n    \n    def get_decrypted_data(self, key_string):\n        'Return \\'WEP Data\\' field decrypted'\n\n        # Needs to be at least 8 bytes of payload \n        if len(self.body_string)<8:\n            return self.body_string\n        \n        # initialize the first bytes of the key from the IV \n        # and copy rest of the WEP key (the secret part) \n        \n        # Convert IV to 3 bytes long string\n        iv=struct.pack('>L',self.get_iv())[-3:]\n        key=iv+key_string\n        rc4=RC4(key)\n        decrypted_data=rc4.decrypt(self.body_string)\n        \n        return decrypted_data\n    \n    def get_encrypted_data(self, key_string):\n        # RC4 is symmetric\n        return self.get_decrypted_data(key_string)\n    \n    def encrypt_frame(self, key_string):\n        enc = self.get_encrypted_data(key_string)\n        self.load_body(enc)",
  "class Dot11WEPData(ProtocolPacket):\n    '802.11 WEP Data Part'\n\n    def __init__(self, aBuffer = None):\n        header_size = 0\n        tail_size = 4\n\n        ProtocolPacket.__init__(self, header_size, tail_size)\n        if(aBuffer):\n            self.load_packet(aBuffer)\n        \n    def get_icv(self):\n        \"Return 'WEP ICV' field\"\n            \n        b = self.tail.get_long(-4, \">\")\n        return b \n\n    def set_icv(self, value = None):\n        \"Set 'WEP ICV' field\"\n\n        # Compute the WEP ICV\n        if value is None:\n            value=self.get_computed_icv()\n\n        # set the bits\n        nb = value & 0xFFFFFFFF\n        self.tail.set_long(-4, nb)\n    \n    def get_computed_icv(self):\n        crcle=crc32(self.body_string)&0xffffffff\n        # This crc32 is in little endian, convert it to big endian \n        crc=struct.pack('<L', crcle)\n         # Convert to long\n        (crc_long,) = struct.unpack('!L', crc)\n        return crc_long\n    \n    def check_icv(self):\n        computed_icv=self.get_computed_icv()\n        current_icv=self.get_icv()\n        if computed_icv==current_icv:\n            return True\n        else:\n            return False",
  "class Dot11WPA(ProtocolPacket):\n    '802.11 WPA'\n\n    def __init__(self, aBuffer = None):\n        header_size = 8\n        tail_size = 0\n\n        ProtocolPacket.__init__(self, header_size, tail_size)\n        if(aBuffer):\n            self.load_packet(aBuffer)\n        \n    def is_WPA(self):\n        'Return True if it\\'s a WPA'\n        # Now we must differentiate between WPA and WPA2\n        # In WPA WEPSeed is set to (TSC1 | 0x20) & 0x7f.\n        b = self.get_WEPSeed() == ((self.get_TSC1() | 0x20 ) & 0x7f)\n        return (b and self.get_extIV())\n        \n    def get_keyid(self):\n        'Return the \\'WPA KEY ID\\' field'\n        b = self.header.get_byte(3)\n        return ((b>>6) & 0x03)\n\n    def set_keyid(self, value):\n        'Set the \\'WPA KEY ID\\' field'\n        # clear the bits\n        mask = (~0xC0) & 0xFF\n        masked = self.header.get_byte(3) & mask\n        # set the bits\n        nb = masked | ((value & 0x03) << 6)\n        self.header.set_byte(3, nb)\n\n    def get_decrypted_data(self):\n        'Return \\'WPA Data\\' field decrypted'\n        # TODO: Replace it with the decoded string\n        return self.body_string\n    \n    def get_TSC1(self):\n        'Return the \\'WPA TSC1\\' field'\n        b = self.header.get_byte(0)\n        return (b & 0xFF)\n    \n    def set_TSC1(self, value):\n        'Set the \\'WPA TSC1\\' field'\n        # set the bits\n        nb = (value & 0xFF)\n        self.header.set_byte(0, nb)\n        \n    def get_WEPSeed(self):\n        'Return the \\'WPA WEPSeed\\' field'\n        b = self.header.get_byte(1)\n        return (b & 0xFF)\n    \n    def set_WEPSeed(self, value):\n        'Set the \\'WPA WEPSeed\\' field'\n        # set the bits\n        nb = (value & 0xFF)\n        self.header.set_byte(1, nb)\n\n    def get_TSC0(self):\n        'Return the \\'WPA TSC0\\' field'\n        b = self.header.get_byte(2)\n        return (b & 0xFF)\n    \n    def set_TSC0(self, value):\n        'Set the \\'WPA TSC0\\' field'\n        # set the bits\n        nb = (value & 0xFF)\n        self.header.set_byte(2, nb)\n\n    def get_extIV(self):\n        'Return the \\'WPA extID\\' field'\n        b = self.header.get_byte(3)\n        return ((b>>5) & 0x1)\n\n    def set_extIV(self, value):\n        'Set the \\'WPA extID\\' field'\n        # clear the bits\n        mask = (~0x20) & 0xFF\n        masked = self.header.get_byte(3) & mask\n        # set the bits\n        nb = masked | ((value & 0x01) << 5)\n        self.header.set_byte(3, nb)\n        \n    def get_TSC2(self):\n        'Return the \\'WPA TSC2\\' field'\n        b = self.header.get_byte(4)\n        return (b & 0xFF)\n    \n    def set_TSC2(self, value):\n        'Set the \\'WPA TSC2\\' field'\n        # set the bits\n        nb = (value & 0xFF)\n        self.header.set_byte(4, nb)\n\n    def get_TSC3(self):\n        'Return the \\'WPA TSC3\\' field'\n        b = self.header.get_byte(5)\n        return (b & 0xFF)\n    \n    def set_TSC3(self, value):\n        'Set the \\'WPA TSC3\\' field'\n        # set the bits\n        nb = (value & 0xFF)\n        self.header.set_byte(5, nb)\n\n    def get_TSC4(self):\n        'Return the \\'WPA TSC4\\' field'\n        b = self.header.get_byte(6)\n        return (b & 0xFF)\n    \n    def set_TSC4(self, value):\n        'Set the \\'WPA TSC4\\' field'\n        # set the bits\n        nb = (value & 0xFF)\n        self.header.set_byte(6, nb)\n\n    def get_TSC5(self):\n        'Return the \\'WPA TSC5\\' field'\n        b = self.header.get_byte(7)\n        return (b & 0xFF)\n    \n    def set_TSC5(self, value):\n        'Set the \\'WPA TSC5\\' field'\n        # set the bits\n        nb = (value & 0xFF)\n        self.header.set_byte(7, nb)",
  "class Dot11WPAData(ProtocolPacket):\n    '802.11 WPA Data Part'\n\n    def __init__(self, aBuffer = None):\n        header_size = 0\n        tail_size = 12\n\n        ProtocolPacket.__init__(self, header_size, tail_size)\n        if(aBuffer):\n            self.load_packet(aBuffer)\n        \n    def get_icv(self):\n        \"Return 'WPA ICV' field\"\n            \n        b = self.tail.get_long(-4, \">\")\n        return b \n\n    def set_icv(self, value = None):\n        \"Set 'WPA ICV' field\"\n\n        # calculate the FCS\n        if value is None:\n            value=self.compute_checksum(self.body_string)\n\n        # set the bits\n        nb = value & 0xFFFFFFFF\n        self.tail.set_long(-4, nb)\n    \n    def get_MIC(self):\n        'Return the \\'WPA2Data MIC\\' field'\n        return self.get_tail_as_string()[:8]\n\n    def set_MIC(self, value):\n        'Set the \\'WPA2Data MIC\\' field'\n        #Padding to 8 bytes with 0x00's \n        value.ljust(8,b'\\x00')\n        #Stripping to 8 bytes\n        value=value[:8]\n        icv=self.tail.get_buffer_as_string()[-4:] \n        self.tail.set_bytes_from_string(value+icv)",
  "class Dot11WPA2(ProtocolPacket):\n    '802.11 WPA2'\n\n    def __init__(self, aBuffer = None):\n        header_size = 8\n        tail_size = 0\n\n        ProtocolPacket.__init__(self, header_size, tail_size)\n        if(aBuffer):\n            self.load_packet(aBuffer)\n        \n    def is_WPA2(self):\n        'Return True if it\\'s a WPA2'\n        # Now we must differentiate between WPA and WPA2\n        # In WPA WEPSeed is set to (TSC1 | 0x20) & 0x7f.\n        # In WPA2 WEPSeed=PN1 and TSC1=PN0\n        b = self.get_PN1() == ((self.get_PN0() | 0x20 ) & 0x7f)\n        return (not b and self.get_extIV())\n\n    def get_extIV(self):\n        'Return the \\'WPA2 extID\\' field'\n        b = self.header.get_byte(3)\n        return ((b>>5) & 0x1)\n    \n    def set_extIV(self, value):\n        'Set the \\'WPA2 extID\\' field'\n        # clear the bits\n        mask = (~0x20) & 0xFF\n        masked = self.header.get_byte(3) & mask\n        # set the bits\n        nb = masked | ((value & 0x01) << 5)\n        self.header.set_byte(3, nb)\n        \n    def get_keyid(self):\n        'Return the \\'WPA2 KEY ID\\' field'\n        b = self.header.get_byte(3)\n        return ((b>>6) & 0x03)\n\n    def set_keyid(self, value):\n        'Set the \\'WPA2 KEY ID\\' field'\n        # clear the bits\n        mask = (~0xC0) & 0xFF\n        masked = self.header.get_byte(3) & mask\n        # set the bits\n        nb = masked | ((value & 0x03) << 6)\n        self.header.set_byte(3, nb)\n\n    def get_decrypted_data(self):\n        'Return \\'WPA2 Data\\' field decrypted'\n        # TODO: Replace it with the decoded string\n        return self.body_string\n    \n    def get_PN0(self):\n        'Return the \\'WPA2 PN0\\' field'\n        b = self.header.get_byte(0)\n        return (b & 0xFF)\n    \n    def set_PN0(self, value):\n        'Set the \\'WPA2 PN0\\' field'\n        # set the bits\n        nb = (value & 0xFF)\n        self.header.set_byte(0, nb)\n        \n    def get_PN1(self):\n        'Return the \\'WPA2 PN1\\' field'\n        b = self.header.get_byte(1)\n        return (b & 0xFF)\n    \n    def set_PN1(self, value):\n        'Set the \\'WPA2 PN1\\' field'\n        # set the bits\n        nb = (value & 0xFF)\n        self.header.set_byte(1, nb)\n\n    def get_PN2(self):\n        'Return the \\'WPA2 PN2\\' field'\n        b = self.header.get_byte(4)\n        return (b & 0xFF)\n    \n    def set_PN2(self, value):\n        'Set the \\'WPA2 PN2\\' field'\n        # set the bits\n        nb = (value & 0xFF)\n        self.header.set_byte(4, nb)\n\n    def get_PN3(self):\n        'Return the \\'WPA2 PN3\\' field'\n        b = self.header.get_byte(5)\n        return (b & 0xFF)\n    \n    def set_PN3(self, value):\n        'Set the \\'WPA2 PN3\\' field'\n        # set the bits\n        nb = (value & 0xFF)\n        self.header.set_byte(5, nb)\n\n    def get_PN4(self):\n        'Return the \\'WPA2 PN4\\' field'\n        b = self.header.get_byte(6)\n        return (b & 0xFF)\n    \n    def set_PN4(self, value):\n        'Set the \\'WPA2 PN4\\' field'\n        # set the bits\n        nb = (value & 0xFF)\n        self.header.set_byte(6, nb)\n\n    def get_PN5(self):\n        'Return the \\'WPA2 PN5\\' field'\n        b = self.header.get_byte(7)\n        return (b & 0xFF)\n    \n    def set_PN5(self, value):\n        'Set the \\'WPA2 PN5\\' field'\n        # set the bits\n        nb = (value & 0xFF)\n        self.header.set_byte(7, nb)",
  "class Dot11WPA2Data(ProtocolPacket):\n    '802.11 WPA2 Data Part'\n\n    def __init__(self, aBuffer = None):\n        header_size = 0\n        tail_size = 8\n\n        ProtocolPacket.__init__(self, header_size, tail_size)\n        if(aBuffer):\n            self.load_packet(aBuffer)\n            \n    def get_MIC(self):\n        'Return the \\'WPA2Data MIC\\' field'\n        return self.get_tail_as_string()\n\n    def set_MIC(self, value):\n        'Set the \\'WPA2Data MIC\\' field'\n        #Padding to 8 bytes with 0x00's \n        value.ljust(8,b'\\x00')\n        #Stripping to 8 bytes\n        value=value[:8]\n        self.tail.set_bytes_from_string(value)",
  "class RadioTap(ProtocolPacket):\n    __HEADER_BASE_SIZE = 8  # minimal header size\n    _PRESENT_FLAGS_SIZE = 4\n    _BASE_PRESENT_FLAGS_OFFSET = 4\n\n    class __RadioTapField(object):\n        ALIGNMENT = 1\n\n        def __str__( self ):\n            return str( self.__class__.__name__ )\n\n    class RTF_TSFT(__RadioTapField):\n        BIT_NUMBER = 0\n        STRUCTURE = \"<Q\"\n        ALIGNMENT = 8\n\n    class RTF_FLAGS(__RadioTapField):\n        BIT_NUMBER = 1\n        STRUCTURE = \"<B\"\n\n        # https://web.archive.org/web/20160423125307/www.radiotap.org/defined-fields/Flags\n        PROPERTY_CFP            = 0x01 #sent/received during CFP\n        PROPERTY_SHORTPREAMBLE  = 0x02 #sent/received with short preamble\n        PROPERTY_WEP            = 0x04 #sent/received with WEP encryption\n        PROPERTY_FRAGMENTATION  = 0x08 #sent/received with fragmentation\n        PROPERTY_FCS_AT_END     = 0x10 #frame includes FCS\n        PROPERTY_PAYLOAD_PADDING= 0x20 #frame has padding between 802.11 header and payload (to 32-bit boundary)\n        PROPERTY_BAD_FCS        = 0x40 #does not pass FCS check\n        PROPERTY_SHORT_GI       = 0x80 #frame used short guard interval (HT). Unspecified but used:\n\n    class RTF_RATE(__RadioTapField):\n        BIT_NUMBER = 2\n        STRUCTURE = \"<B\"\n\n    class RTF_CHANNEL(__RadioTapField):\n        BIT_NUMBER = 3\n        STRUCTURE = \"<HH\"\n        ALIGNMENT = 2\n\n    class RTF_FHSS(__RadioTapField):\n        BIT_NUMBER = 4\n        STRUCTURE = \"<BB\"\n\n    class RTF_DBM_ANTSIGNAL(__RadioTapField):\n        BIT_NUMBER = 5\n        STRUCTURE = \"<B\"\n\n    class RTF_DBM_ANTNOISE(__RadioTapField):\n        BIT_NUMBER = 6\n        STRUCTURE = \"<B\"\n\n    class RTF_LOCK_QUALITY(__RadioTapField):\n        BIT_NUMBER = 7\n        STRUCTURE = \"<H\"\n        ALIGNMENT = 2\n\n    class RTF_TX_ATTENUATION(__RadioTapField):\n        BIT_NUMBER = 8\n        STRUCTURE = \"<H\"\n        ALIGNMENT = 2\n\n    class RTF_DB_TX_ATTENUATION(__RadioTapField):\n        BIT_NUMBER = 9\n        STRUCTURE = \"<H\"\n        ALIGNMENT = 2\n\n    class RTF_DBM_TX_POWER(__RadioTapField):\n        BIT_NUMBER = 10\n        STRUCTURE = \"<b\"\n        ALIGNMENT = 2\n\n    class RTF_ANTENNA(__RadioTapField):\n        BIT_NUMBER = 11\n        STRUCTURE = \"<B\"\n\n    class RTF_DB_ANTSIGNAL(__RadioTapField):\n        BIT_NUMBER = 12\n        STRUCTURE = \"<B\"\n\n    class RTF_DB_ANTNOISE(__RadioTapField):\n        BIT_NUMBER = 13\n        STRUCTURE = \"<B\"\n\n##    # official assignment, clashes with RTF_FCS_IN_HEADER\n##    class RTF_RX_FLAGS(__RadioTapField):\n##        BIT_NUMBER = 14\n##        STRUCTURE = \"<H\"\n##        ALIGNMENT = 2\n\n    # clashes with RTF_RX_FLAGS\n    class RTF_FCS_IN_HEADER(__RadioTapField):\n        BIT_NUMBER = 14\n        STRUCTURE = \"<L\"\n        ALIGNMENT = 4   \n\n    # clashes with HARDWARE_QUEUE\n    class RTF_TX_FLAGS(__RadioTapField):\n        BIT_NUMBER = 15\n        STRUCTURE = \"<H\"\n        ALIGNMENT = 2\n\n##    # clashes with TX_FLAGS\n##    class RTF_HARDWARE_QUEUE(__RadioTapField):\n##        BIT_NUMBER = 15\n##        STRUCTURE = \"<B\"\n##        ALIGNMENT = 1\n\n    # clashes with RSSI\n    class RTF_RTS_RETRIES(__RadioTapField):\n        BIT_NUMBER = 16\n        STRUCTURE = \"<B\"\n\n##    # clashes with RTS_RETRIES \n##    class RTF_RSSI(__RadioTapField):\n##        BIT_NUMBER = 16\n##        STRUCTURE = \"<H\"\n##        ALIGNMENT = 1\n\n    class RTF_DATA_RETRIES(__RadioTapField):\n        BIT_NUMBER = 17\n        STRUCTURE = \"<B\"\n\n    class RTF_XCHANNEL(__RadioTapField):\n        BIT_NUMBER = 18\n        STRUCTURE = \"<LHBB\"\n        ALIGNMENT = 4\n\n    class RTF_EXT(__RadioTapField):\n        BIT_NUMBER = 31\n        STRUCTURE = []\n    \n    # Sort the list so the 'for' statement walk the list in the right order\n    radiotap_fields = __RadioTapField.__subclasses__()\n    radiotap_fields.sort(key= lambda x: x.BIT_NUMBER)\n\n    def __init__(self, aBuffer = None):\n        header_size = self.__HEADER_BASE_SIZE \n        tail_size = 0\n        \n        if aBuffer:\n            length = struct.unpack('<H', aBuffer[2:4])[0]\n            header_size=length\n                    \n            ProtocolPacket.__init__(self, header_size, tail_size)\n            self.load_packet(aBuffer)\n        else:\n            ProtocolPacket.__init__(self, header_size, tail_size)\n            self.set_version(0)\n            self.__set_present(0x00000000)\n            \n    def get_header_length(self):\n        'Return the RadioTap header \\'length\\' field'\n        self.__update_header_length()        \n        return self.header.get_word(2, \"<\")\n            \n    def get_version(self):\n        'Return the \\'version\\' field'\n        b = self.header.get_byte(0)\n        return b\n    \n    def set_version(self, value):\n        'Set the \\'version\\' field'\n        nb = (value & 0xFF)\n        self.header.set_byte(0, nb)\n        \n        nb = (value & 0xFF)\n        \n    def get_present(self, offset=_BASE_PRESENT_FLAGS_OFFSET):\n        \"Return RadioTap present bitmap field\"\n        present = self.header.get_long(offset, \"<\")\n        return present\n\n    def __set_present(self, value):\n        \"Set RadioTap present field bit\"\n        self.header.set_long(4, value)\n\n    def get_present_bit(self, field, offset=4):\n        'Get a \\'present\\' field bit'\n        present=self.get_present(offset)\n        return not not (2**field.BIT_NUMBER & present)\n\n    def __set_present_bit(self, field):\n        'Set a \\'present\\' field bit'\n        npresent=2**field.BIT_NUMBER | self.get_present()\n        self.header.set_long(4, npresent,'<')\n\n    def __unset_present_bit(self, field):\n        'Unset a \\'present\\' field bit'\n        npresent=~(2**field.BIT_NUMBER) & self.get_present()\n        self.header.set_long(4, npresent,'<')\n        \n    def __align(self, val, align):\n        return ( (((val) + ((align) - 1)) & ~((align) - 1)) - val )\n\n    def __get_field_position(self, field):\n\n        offset = RadioTap._BASE_PRESENT_FLAGS_OFFSET\n        extra_present_flags_count = 0\n        while self.get_present_bit(RadioTap.RTF_EXT, offset):\n            offset += RadioTap._PRESENT_FLAGS_SIZE\n            extra_present_flags_count += 1\n\n        field_position = self.__HEADER_BASE_SIZE + (RadioTap._BASE_PRESENT_FLAGS_OFFSET * extra_present_flags_count)\n\n        for f in self.radiotap_fields:\n            field_position += self.__align(field_position, f.ALIGNMENT)\n            if f == field:\n                return field_position\n\n            if self.get_present_bit(f):\n                total_length = struct.calcsize(f.STRUCTURE)\n                field_position += total_length\n\n        return None\n\n    def unset_field( self, field):\n        is_present=self.get_present_bit(field)\n        if is_present is False:\n            return False\n                \n        byte_pos=self.__get_field_position(field)\n        if not byte_pos:\n            return False\n\n        self.__unset_present_bit(field)\n\n        header=self.get_header_as_string()\n        total_length = struct.calcsize(field.STRUCTURE)\n        header=header[:byte_pos]+header[byte_pos+total_length:]\n        \n        self.load_header(header)\n\n    def __get_field_values( self, field ):\n        is_present=self.get_present_bit(field)\n        if is_present is False:\n            return None\n        \n        byte_pos=self.__get_field_position(field)\n        header=self.get_header_as_string()\n        total_length=struct.calcsize(field.STRUCTURE)\n        v=header[ byte_pos:byte_pos+total_length ]\n        \n        field_values = struct.unpack(field.STRUCTURE, v)\n        \n        return field_values\n\n    def __set_field_values( self, field, values ):\n        if not hasattr(values,'__iter__'):\n            raise Exception(\"arg 'values' is not iterable\")\n        \n        # It's for to known the qty of argument of a structure\n        num_fields=len(''.join(c for c in field.STRUCTURE if c not in '=@!<>'))\n\n        if len(values)!=num_fields:\n            raise Exception(\"Field %s has exactly %d items\"%(str(field),struct.calcsize(field.STRUCTURE)))\n        \n        is_present=self.get_present_bit(field)\n        if is_present is False:\n            self.__set_present_bit(field)\n        \n        byte_pos=self.__get_field_position(field)\n        header=self.get_header_as_string()\n        total_length=struct.calcsize(field.STRUCTURE)\n\n        new_str = struct.pack(field.STRUCTURE, *values)\n\n        if is_present is True:\n            header=header[:byte_pos]+new_str+header[byte_pos+total_length:]\n        else:\n            header=header[:byte_pos]+new_str+header[byte_pos:]\n        self.load_header(header)\n\n            \n    def set_tsft( self, nvalue ):\n        \"Set the Value in microseconds of the MAC's 64-bit 802.11 \"\\\n        \"Time Synchronization Function timer when the first bit of \"\\\n        \"the MPDU arrived at the MAC\"\n        self.__set_field_values(RadioTap.RTF_TSFT, [nvalue])\n        \n    def get_tsft( self ):\n        \"Get the Value in microseconds of the MAC's 64-bit 802.11 \"\\\n        \"Time Synchronization Function timer when the first bit of \"\\\n        \"the MPDU arrived at the MAC\"\n        \n        values=self.__get_field_values(RadioTap.RTF_TSFT)\n        if not values:\n            return None\n        return values[0]\n\n    def set_flags( self, nvalue ):\n        \"Set the properties of transmitted and received frames.\"\n        self.__set_field_values(self.RTF_FLAGS, [nvalue])\n   \n    def get_flags( self ):\n        \"Get the properties of transmitted and received frames.\"\n        values=self.__get_field_values(self.RTF_FLAGS)\n        if not values:\n            return None\n        return values[0]\n   \n    def set_rate( self, nvalue ):\n        \"Set the TX/RX data rate in 500 Kbps units\" \n        \n        self.__set_field_values(self.RTF_RATE, [nvalue])\n   \n    def get_rate( self ):\n        \"Get the TX/RX data rate in 500 Kbps units\" \n\n        values=self.__get_field_values(self.RTF_RATE)\n        if not values:\n            return None\n        return values[0]\n\n    def set_channel( self, freq, flags ):\n        \"Set the channel Tx/Rx frequency in MHz and the channel flags\" \n\n        self.__set_field_values(self.RTF_CHANNEL, [freq, flags])\n   \n    def get_channel( self ):\n        \"Get the TX/RX data rate in 500 Kbps units\" \n\n        values=self.__get_field_values(self.RTF_CHANNEL)\n\n        return values\n\n    def set_FHSS( self, hop_set, hop_pattern ):\n        \"Set the hop set and pattern for frequency-hopping radios\" \n\n        self.__set_field_values(self.RTF_FHSS, [hop_set, hop_pattern])\n   \n    def get_FHSS( self ):\n        \"Get the hop set and pattern for frequency-hopping radios\" \n\n        values=self.__get_field_values(self.RTF_FHSS)\n\n        return values\n\n    def set_dBm_ant_signal( self, signal ):\n        \"Set the RF signal power at the antenna, decibel difference from an \"\\\n        \"arbitrary, fixed reference.\" \n\n        self.__set_field_values(self.RTF_DBM_ANTSIGNAL, [signal])\n   \n    def get_dBm_ant_signal( self ):\n        \"Get the RF signal power at the antenna, decibel difference from an \"\\\n        \"arbitrary, fixed reference.\" \n\n        values=self.__get_field_values(self.RTF_DBM_ANTSIGNAL)\n        if not values:\n            return None\n        return values[0]\n\n    def set_dBm_ant_noise( self, signal ):\n        \"Set the RF noise power at the antenna, decibel difference from an \"\\\n        \"arbitrary, fixed reference.\"\n\n        self.__set_field_values(self.RTF_DBM_ANTNOISE, [signal])\n   \n    def get_dBm_ant_noise( self ):\n        \"Get the RF noise power at the antenna, decibel difference from an \"\\\n        \"arbitrary, fixed reference.\"\n\n        values=self.__get_field_values(self.RTF_DBM_ANTNOISE)\n        if not values:\n            return None\n        return values[0]\n\n    def set_lock_quality( self, quality ):\n        \"Set the quality of Barker code lock. \"\\\n        \"Called 'Signal Quality' in datasheets. \"\n\n        self.__set_field_values(self.RTF_LOCK_QUALITY, [quality])\n   \n    def get_lock_quality( self ):\n        \"Get the quality of Barker code lock. \"\\\n        \"Called 'Signal Quality' in datasheets. \"\n        \n        values=self.__get_field_values(self.RTF_LOCK_QUALITY)\n        if not values:\n            return None\n        return values[0]\n\n    def set_tx_attenuation( self, power ):\n        \"Set the transmit power expressed as unitless distance from max power \"\\\n        \"set at factory calibration. 0 is max power.\"\n\n        self.__set_field_values(self.RTF_TX_ATTENUATION, [power])\n   \n    def get_tx_attenuation( self ):\n        \"Set the transmit power expressed as unitless distance from max power \"\\\n        \"set at factory calibration. 0 is max power.\"\n        \n        values=self.__get_field_values(self.RTF_TX_ATTENUATION)\n        if not values:\n            return None\n        return values[0]\n\n    def set_dB_tx_attenuation( self, power ):\n        \"Set the transmit power expressed as decibel distance from max power \"\\\n        \"set at factory calibration. 0 is max power. \"\n\n        self.__set_field_values(self.RTF_DB_TX_ATTENUATION, [power])\n   \n    def get_dB_tx_attenuation( self ):\n        \"Set the transmit power expressed as decibel distance from max power \"\\\n        \"set at factory calibration. 0 is max power. \"\n        \n        values=self.__get_field_values(self.RTF_DB_TX_ATTENUATION)\n        if not values:\n            return None\n        return values[0]\n\n    def set_dBm_tx_power( self, power ):\n        \"Set the transmit power expressed as dBm (decibels from a 1 milliwatt\"\\\n        \" reference). This is the absolute power level measured at the \"\\\n        \"antenna port.\"\n        \n        self.__set_field_values(self.RTF_DBM_TX_POWER, [power])\n   \n    def get_dBm_tx_power( self ):\n        \"Get the transmit power expressed as dBm (decibels from a 1 milliwatt\"\\\n        \" reference). This is the absolute power level measured at the \"\\\n        \"antenna port.\"\n        \n        values=self.__get_field_values(self.RTF_DBM_TX_POWER)\n        if not values:\n            return None\n        return values[0]\n\n    def set_antenna( self, antenna_index ):\n        \"Set Rx/Tx antenna index for this packet. \"\\\n        \"The first antenna is antenna 0. \"\\\n        \n        self.__set_field_values(self.RTF_ANTENNA, [antenna_index])\n   \n    def get_antenna( self ):\n        \"Set Rx/Tx antenna index for this packet. \"\\\n        \"The first antenna is antenna 0. \"\\\n        \n        values=self.__get_field_values(self.RTF_ANTENNA)\n        if not values:\n            return None\n        return values[0]\n\n    def set_dB_ant_signal( self, signal ):\n        \"Set the RF signal power at the antenna, decibel difference from an \"\\\n        \"arbitrary, fixed reference.\" \n\n        self.__set_field_values(self.RTF_DB_ANTSIGNAL, [signal])\n   \n    def get_dB_ant_signal( self ):\n        \"Get the RF signal power at the antenna, decibel difference from an \"\\\n        \"arbitrary, fixed reference.\" \n\n        values=self.__get_field_values(self.RTF_DB_ANTSIGNAL)\n        if not values:\n            return None\n        return values[0]\n\n    def set_dB_ant_noise( self, signal ):\n        \"Set the RF noise power at the antenna, decibel difference from an \"\\\n        \"arbitrary, fixed reference.\" \n\n        self.__set_field_values(self.RTF_DB_ANTNOISE, [signal])\n   \n    def get_dB_ant_noise( self ):\n        \"Get the RF noise power at the antenna, decibel difference from an \"\\\n        \"arbitrary, fixed reference.\" \n\n        values=self.__get_field_values(self.RTF_DB_ANTNOISE)\n        if not values:\n            return None\n        return values[0]\n\n##    def set_rx_flags( self, flags ):\n##        \"Set the properties of received frames.\" \n##\n##        self.__set_field_values(self.RTF_RX_FLAGS, [flags])\n##   \n##    def get_rx_flags( self ):\n##        \"Get the properties of received frames.\" \n##\n##        values=self.__get_field_values(self.RTF_RX_FLAGS)\n##        if not values:\n##            return None\n##        return values[0]\n\n    def set_FCS_in_header( self, fcs ):\n        \"Set the Field containing the FCS of the frame (instead of it being \"\\\n        \"appended to the frame as it would appear on the air.) \" \n\n        self.__set_field_values(self.RTF_FCS_IN_HEADER, [fcs])\n   \n    def get_FCS_in_header( self ):\n        \"Get the Field containing the FCS of the frame (instead of it being \"\\\n        \"appended to the frame as it would appear on the air.) \" \n\n        values=self.__get_field_values(self.RTF_FCS_IN_HEADER)\n        if not values:\n            return None\n        return values[0]\n\n##    def set_RSSI( self, rssi, max_rssi ):\n##        \"Set the received signal strength and the maximum for the hardware.\" \n##        \n##        self.__set_field_values(self.RTF_RSSI, [rssi, max_rssi])\n##   \n##    def get_RSSI( self ):\n##        \"Get the received signal strength and the maximum for the hardware.\" \n##        \n##        values=self.__get_field_values(self.RTF_RSSI)\n##        \n##        return values\n\n    def set_RTS_retries( self, retries):\n        \"Set the number of RTS retries a transmitted frame used.\" \n        \n        self.__set_field_values(self.RTF_RTS_RETRIES, [retries])\n   \n    def get_RTS_retries( self ):\n        \"Get the number of RTS retries a transmitted frame used.\" \n        \n        values=self.__get_field_values(self.RTF_RTS_RETRIES)\n        if not values:\n            return None\n        return values[0]\n\n    def set_tx_flags( self, flags ):\n        \"Set the properties of transmitted frames.\" \n\n        self.__set_field_values(self.RTF_TX_FLAGS, [flags])\n   \n    def get_tx_flags( self ):\n        \"Get the properties of transmitted frames.\" \n\n        values=self.__get_field_values(self.RTF_TX_FLAGS)\n        if not values:\n            return None\n        return values[0]\n\n    def set_xchannel( self, flags, freq, channel, maxpower ):\n        \"Set extended channel information: flags, freq, channel and maxpower\" \n        \n        self.__set_field_values(self.RTF_XCHANNEL, [flags, freq, channel, maxpower] )\n   \n    def get_xchannel( self ):\n        \"Get extended channel information: flags, freq, channel and maxpower\" \n        \n        values=self.__get_field_values(field=self.RTF_XCHANNEL)\n\n        return values\n\n    def set_data_retries( self, retries ):\n        \"Set the number of data retries a transmitted frame used.\" \n\n        self.__set_field_values(self.RTF_DATA_RETRIES, [retries])\n   \n    def get_data_retries( self ):\n        \"Get the number of data retries a transmitted frame used.\" \n\n        values=self.__get_field_values(self.RTF_DATA_RETRIES)\n        if not values:\n            return None\n        return values[0]\n\n    def set_hardware_queue( self, queue ):\n        \"Set the hardware queue to send the frame on.\" \n\n        self.__set_field_values(self.RTF_HARDWARE_QUEUE, [queue])\n   \n##    def get_hardware_queue( self ):\n##        \"Get the hardware queue to send the frame on.\" \n##\n##        values=self.__get_field_values(self.RTF_HARDWARE_QUEUE)\n##        if not values:\n##            return None\n##        return values[0]\n\n    def __update_header_length(self):\n        'Update the RadioTap header length field with the real size'\n        self.header.set_word(2, self.get_header_size(), \"<\")\n\n    def get_packet(self):\n        self.__update_header_length()\n        return ProtocolPacket.get_packet(self)",
  "class Dot11ManagementFrame(ProtocolPacket):\n    '802.11 Management Frame'\n    \n    def __init__(self, aBuffer = None):\n        header_size = 22\n        tail_size = 0\n\n        ProtocolPacket.__init__(self, header_size, tail_size)\n        if(aBuffer):\n            self.load_packet(aBuffer)\n\n    def get_duration(self):\n        'Return 802.11 Management frame \\'Duration\\' field'\n        b = self.header.get_word(0, \"<\")\n        return b \n\n    def set_duration(self, value):\n        'Set the 802.11 Management frame \\'Duration\\' field' \n        # set the bits\n        nb = value & 0xFFFF\n        self.header.set_word(0, nb, \"<\")\n        \n    def get_destination_address(self):\n        'Return 802.11 Management frame \\'Destination Address\\' field as a 6 bytes array'\n        return self.header.get_bytes()[2:8]\n\n    def set_destination_address(self, value):\n        'Set 802.11 Management frame \\'Destination Address\\' field as a 6 bytes array'\n        for i in range(0, 6):\n            self.header.set_byte(2+i, value[i])\n\n    def get_source_address(self):\n        'Return 802.11 Management frame \\'Source Address\\' field as a 6 bytes array'\n        return self.header.get_bytes()[8:14]\n\n    def set_source_address(self, value):\n        'Set 802.11 Management frame \\'Source Address\\' field as a 6 bytes array'\n        for i in range(0, 6):\n            self.header.set_byte(8+i, value[i])\n            \n    def get_bssid(self):\n        'Return 802.11 Management frame \\'BSSID\\' field as a 6 bytes array'\n        return self.header.get_bytes()[14: 20]\n\n    def set_bssid(self, value):\n        'Set 802.11 Management frame \\'BSSID\\' field as a 6 bytes array'\n        for i in range(0, 6):\n            self.header.set_byte(14+i, value[i])\n\n    def get_sequence_control(self):\n        'Return 802.11 Management frame \\'Sequence Control\\' field'\n        b = self.header.get_word(20, \"<\")\n        return b \n\n    def set_sequence_control(self, value):\n        'Set the 802.11 Management frame \\'Sequence Control\\' field' \n        # set the bits\n        nb = value & 0xFFFF\n        self.header.set_word(20, nb, \"<\")\n\n    def get_fragment_number(self):\n        'Return 802.11 Management frame \\'Fragment Number\\' subfield'\n\n        b = self.get_sequence_control()\n        return (b&0x000F) \n\n    def set_fragment_number(self, value):\n        'Set the 802.11 Management frame \\'Fragment Number\\' subfield' \n        # clear the bits\n        mask = (~0x000F) & 0xFFFF\n        masked = self.header.get_word(20, \"<\") & mask\n        # set the bits \n        nb = masked | (value & 0x000F)\n        self.header.set_word(20, nb, \"<\")\n        \n    def get_sequence_number(self):\n        'Return 802.11 Management frame \\'Sequence Number\\' subfield'\n        \n        b = self.get_sequence_control()\n        return ((b>>4) & 0xFFF) \n    \n    def set_sequence_number(self, value):\n        'Set the 802.11 Management frame \\'Sequence Number\\' subfield' \n        # clear the bits\n        mask = (~0xFFF0) & 0xFFFF\n        masked = self.header.get_word(20, \"<\") & mask\n        # set the bits \n        nb = masked | ((value & 0x0FFF ) << 4 ) \n        self.header.set_word(20, nb, \"<\")\n\n    def get_frame_body(self):\n        'Return 802.11 Management frame \\'Frame Body\\' field'\n        \n        return self.get_body_as_string()\n\n    def set_frame_body(self, data):\n        'Set 802.11 Management frame \\'Frame Body\\' field'\n        \n        self.load_body(data)",
  "class DOT11_MANAGEMENT_ELEMENTS():\n    SSID                    =  0\n    SUPPORTED_RATES         =  1\n    FH_PARAMETER_SET        =  2\n    DS_PARAMETER_SET        =  3\n    CF_PARAMETER_SET        =  4\n    TIM                     =  5\n    IBSS_PARAMETER_SET      =  6\n    COUNTRY                 =  7\n    HOPPING_PARAMETER       =  8\n    HOPPING_TABLE           =  9\n    REQUEST                 = 10\n    BSS_LOAD                = 11\n    EDCA_PARAMETER_SET      = 12\n    TSPEC                   = 13\n    TCLAS                   = 14\n    SCHEDULE                = 15\n    CHALLENGE_TEXT          = 16\n    # RESERVED                17-31 \n    POWER_CONSTRAINT        = 32\n    POWER_CAPABILITY        = 33\n    TPC_REQUEST             = 34\n    TPC_REPORT              = 35\n    SUPPORTED_CHANNELS      = 36\n    CHANNEL_SWITCH_ANN      = 37\n    MEASURE_REQ             = 38\n    MEASURE_REP             = 39\n    QUIET                   = 40\n    IBSS_DFS                = 41\n    ERP_INFO                = 42\n    TS_DELAY                = 43\n    TCLAS_PROCESSING        = 44\n    #RESERVED                 45  # See: IEEE 802.11n\n    QOS_CAPABILITY          = 46\n    #RESERVED                 47  # See: IEEE 802.11g\n    RSN                     = 48\n    #RESERVED                 49\n    EXT_SUPPORTED_RATES     = 50\n    #RESERVED                 51-126\n    EXTENDED_CAPABILITIES   = 127\n    #RESERVED                 128-220\n    VENDOR_SPECIFIC         = 221",
  "class Dot11ManagementHelper(ProtocolPacket):\n        \n    def __init__(self, header_size, tail_size, aBuffer = None):\n        self.__HEADER_BASE_SIZE=header_size\n        \n        if aBuffer:\n            elements_length=self.__calculate_elements_length(aBuffer[self.__HEADER_BASE_SIZE:])\n            header_size+=elements_length\n            \n            ProtocolPacket.__init__(self, header_size, tail_size)\n            self.load_packet(aBuffer)\n        else:\n            ProtocolPacket.__init__(self, header_size, tail_size)\n\n    def _find_element(self, elements, element_id ):\n        remaining=len(elements)\n        \n        offset=0\n        while remaining > 0:\n            (id,length)=struct.unpack(\"!BB\",elements[offset:offset+2])\n            if element_id is None:\n                pass # through the whole list returning the length\n            elif id==element_id:\n                yield (0,offset,length+2)    # ==\n            length+=2 #id+length\n            offset+=length\n            if length>remaining:\n                # Error!!\n                length = remaining\n            remaining-=length\n        # < Not found\n        yield (-1, offset, None)\n\n    def __calculate_elements_length(self, elements):\n        gen_tp=self._find_element(elements, None )\n        (match,offset,length)=next(gen_tp)\n        if match != -1:\n            # element_id is None, then __find_tagged_parameter must return -1\n            raise Exception(\"Internal Error %s\"%match)\n        return offset\n        \n    def _get_elements_generator(self, element_id):\n        elements=self.get_header_as_string()[self.__HEADER_BASE_SIZE:]\n        gen_tp=self._find_element(elements, element_id )\n        while True:\n            (match,offset,length)=next(gen_tp)\n            if match != 0:\n                return\n            value_offset=offset+2\n            value_end=offset+length\n            value=elements[value_offset:value_end]\n            yield value\n        \n    def _get_element(self, element_id):\n        gen_get_element=self._get_elements_generator(element_id)\n        try:\n            s=next(gen_get_element)\n            \n            if s is None:\n                raise Exception(\"gen_get_element salio con None in _get_element!!!\")\n            \n            return s\n        except StopIteration:\n            pass\n            \n        return None\n\n    def delete_element(self, element_id, multiple = False):\n        header=self.get_header_as_string()\n        elements=header[self.__HEADER_BASE_SIZE:]\n        gen_tp=self._find_element(elements, element_id )\n        found=False\n        while True:\n            (match,offset,length)=next(gen_tp)\n            if match != 0:\n                break\n            start=self.__HEADER_BASE_SIZE+offset\n            header=header[:start]+header[start+length:]\n            found=True\n            if multiple is False:\n                break\n            \n        if not found:\n            return  False\n        \n        self.load_header(header)\n        return True\n    \n    def _set_element(self, element_id, value, replace = True):\n        parameter=struct.pack('BB%ds'%len(value),element_id,len(value),value)\n        \n        header=self.get_header_as_string()\n        elements=header[self.__HEADER_BASE_SIZE:]\n        gen_tp=self._find_element(elements, element_id )\n        found=False\n        while True:\n            (match,offset,length)=next(gen_tp)\n            start=self.__HEADER_BASE_SIZE+offset\n            if match == 0 and replace:\n                # Replace\n                header=header[:start]+parameter+header[start+length:]\n                found=True\n                break\n            elif match > 0:\n                # Add\n                header=header[:start]+parameter+header[start:]\n                found=True\n                break\n            else:\n                break\n        if not found:\n            # Append (found<0 Not found)\n            header=header+parameter        \n        self.load_header(header)",
  "class Dot11ManagementBeacon(Dot11ManagementHelper):\n    '802.11 Management Beacon Frame'\n        \n    __HEADER_BASE_SIZE = 12 # minimal header size\n\n    def __init__(self, aBuffer = None):\n        header_size = self.__HEADER_BASE_SIZE\n        tail_size = 0\n        Dot11ManagementHelper.__init__(self, header_size, tail_size, aBuffer)\n\n    def get_timestamp(self):\n        'Return the 802.11 Management Beacon frame \\'Timestamp\\' field' \n        b = self.header.get_long_long(0, \"<\")\n        return b \n\n    def set_timestamp(self, value):\n        'Set the 802.11 Management Beacon frame \\'Timestamp\\' field' \n        # set the bits\n        nb = value & 0xFFFFFFFFFFFFFFFF\n        self.header.set_long_long(0, nb, \"<\")\n\n    def get_beacon_interval(self):\n        'Return the 802.11 Management Beacon frame \\'Beacon Interval\\' field' \\\n        'To convert it to seconds =>  secs = Beacon_Interval*1024/1000000'\n\n        b = self.header.get_word(8, \"<\")\n        return b \n\n    def set_beacon_interval(self, value):\n        'Set the 802.11 Management Beacon frame \\'Beacon Interval\\' field' \n        # set the bits\n        nb = value & 0xFFFF\n        self.header.set_word(8, nb, \"<\")\n\n    def get_capabilities(self):\n        'Return the 802.11 Management Beacon frame \\'Capability information\\' field. '\n        \n        b = self.header.get_word(10, \"<\")\n        return b \n\n    def set_capabilities(self, value):\n        'Set the 802.11 Management Beacon frame \\'Capability Information\\' field' \n        # set the bits\n        nb = value & 0xFFFF\n        self.header.set_word(10, nb, \"<\")\n        \n    def get_ssid(self):\n        \"Get the 802.11 Management SSID element. \"\\\n        \"The SSID element indicates the identity of an ESS or IBSS.\"\n        return self._get_element(DOT11_MANAGEMENT_ELEMENTS.SSID)\n\n    def set_ssid(self, ssid):\n        self._set_element(DOT11_MANAGEMENT_ELEMENTS.SSID,ssid)\n\n    def get_supported_rates(self, human_readable=False):\n        \"Get the 802.11 Management Supported Rates element. \"\\\n        \"Specifies up to eight rates, then an Extended Supported Rate element \"\\\n        \"shall be generated to specify the remaining supported rates.\"\\\n        \"If human_readable is True, the rates are returned in Mbit/sec\"\n        s=self._get_element(DOT11_MANAGEMENT_ELEMENTS.SUPPORTED_RATES)\n        if s is None:\n            return None\n        \n        rates=struct.unpack('%dB'%len(s),s)\n        if not human_readable:\n            return rates\n            \n        rates_Mbs=tuple([(x&0x7F)*0.5 for x in rates])\n        return rates_Mbs\n\n    def set_supported_rates(self, rates):\n        \"Set the 802.11 Management Supported Rates element. \"\\\n        \"Specifies a tuple or list with up to eight rates, then an \"\\\n        \"Extended Supported Rate element shall be generated to specify \"\\\n        \"the remaining supported rates.\"\n        qty_rates=len(rates)\n        if qty_rates>8:\n            raise Exception(\"requires up to eight rates\")\n        rates_string=struct.pack('B'*qty_rates,*rates)\n        self._set_element(DOT11_MANAGEMENT_ELEMENTS.SUPPORTED_RATES,rates_string)\n\n    def get_ds_parameter_set(self):\n        \"Get the 802.11 Management DS Parameter set element. \"\\\n        \"Contains information to allow channel number identification for \"\\\n        \"STAs using a DSSS PHY.\"\n        s=self._get_element(DOT11_MANAGEMENT_ELEMENTS.DS_PARAMETER_SET)\n        if s is None:\n            return None\n        \n        (ch,)=struct.unpack('B',s)\n\n        return ch\n\n    def set_ds_parameter_set(self, channel):\n        \"Set the 802.11 Management DS Parameter set element. \"\\\n        \"Contains information to allow channel number identification for \"\\\n        \"STAs using a DSSS PHY.\"\n        channel_string=struct.pack('B',channel)\n        self._set_element(DOT11_MANAGEMENT_ELEMENTS.DS_PARAMETER_SET,channel_string)\n\n    def get_rsn(self):\n        \"Get the 802.11 Management Robust Security Network element.\"\n        s = self._get_element(DOT11_MANAGEMENT_ELEMENTS.RSN)\n        if s is None:\n            return None\n        return s\n\n    def set_rsn(self, data):\n        \"Set the 802.11 Management Robust Security Network element.\"\n        self._set_element(DOT11_MANAGEMENT_ELEMENTS.RSN, data)\n\n    def get_erp(self):\n        \"Get the 802.11 Management ERP (extended rate PHY) Information element.\"\n        s = self._get_element(DOT11_MANAGEMENT_ELEMENTS.ERP_INFO)\n        if s is None:\n            return None\n\n        (erp,) = struct.unpack('B',s)\n        \n        return erp\n\n    def set_erp(self, erp):\n        \"Set the 802.11 Management ERP (extended rate PHY) Inforamation \"\\\n        \"element.\"\n        erp_string = struct.pack('B',erp)\n        self._set_element(DOT11_MANAGEMENT_ELEMENTS.ERP_INFO, erp_string)\n\n    def get_country(self):\n        \"Get the 802.11 Management Country element.\" \\\n        \"Returns a tuple containing Country code, first channel number, \"\\\n        \"number of channels and maximum transmit power level\"\n        s = self._get_element(DOT11_MANAGEMENT_ELEMENTS.COUNTRY)\n        if s is None:\n            return None\n\n        code, first, num, max = struct.unpack('3sBBB',s)\n        code = code.strip(' ')\n        return code, first, num, max\n\n    def set_country(self, code, first_channel, number_of_channels, max_power):\n        \"Set the 802.11 Management Country element.\"\n        if len(code) > 3:\n            raise Exception(\"Country code must be up to 3 bytes long\")\n\n        #Padding the country code\n        code += ' ' * (3-len(code))\n\n        country_string = struct.pack('3sBBB', code, first_channel,\n                number_of_channels, max_power)\n        self._set_element(DOT11_MANAGEMENT_ELEMENTS.COUNTRY, country_string)\n\n    def get_vendor_specific(self):\n        \"Get the 802.11 Management Vendor Specific elements \"\\\n        \"as a list of tuples.\"\n        \"The Vendor Specific information element is used to carry \"\\\n        \"information not defined in the standard within a single \"\\\n        \"defined format\"\n        \n        vs=[]\n        gen_get_element=self._get_elements_generator(DOT11_MANAGEMENT_ELEMENTS.VENDOR_SPECIFIC)\n        try:\n            while 1:\n                s=next(gen_get_element)\n                \n                if s is None:\n                    raise Exception(\"gen_get_element salio con None!!!\")\n                \n                # OUI is 3 bytes\n                oui=s[:3]\n                data=s[3:]\n                vs.append((oui,data))\n        except StopIteration:\n            pass\n            \n        return vs\n\n    def add_vendor_specific(self, oui, data):\n        \"Set the 802.11 Management Vendor Specific element. \"\\\n        \"The Vendor Specific information element is used to carry \"\\\n        \"information not defined in the standard within a single \"\\\n        \"defined format\"\n        \n        # 3 is the OUI length\n        max_data_len=255-3\n        data_len=len(data)\n\n        if data_len>max_data_len:\n            raise Exception(\"data allow up to %d bytes long\" % max_data_len)\n        if len(oui) > 3:\n            raise Exception(\"oui is three bytes long\")\n        \n        self._set_element(DOT11_MANAGEMENT_ELEMENTS.VENDOR_SPECIFIC,oui+data, replace=False)",
  "class Dot11ManagementProbeRequest(Dot11ManagementHelper):\n    '802.11 Management Probe Request Frame'\n        \n    def __init__(self, aBuffer = None):\n        header_size = 0\n        tail_size = 0\n        Dot11ManagementHelper.__init__(self, header_size, tail_size, aBuffer)\n\n    def get_ssid(self):\n        \"Get the 802.11 Management SSID element. \"\\\n        \"The SSID element indicates the identity of an ESS or IBSS.\"\n        return self._get_element(DOT11_MANAGEMENT_ELEMENTS.SSID)\n\n    def set_ssid(self, ssid):\n        self._set_element(DOT11_MANAGEMENT_ELEMENTS.SSID,ssid)\n\n    def get_supported_rates(self, human_readable=False):\n        \"Get the 802.11 Management Supported Rates element. \"\\\n        \"Specifies up to eight rates, then an Extended Supported Rate element \"\\\n        \"shall be generated to specify the remaining supported rates.\"\\\n        \"If human_readable is True, the rates are returned in Mbit/sec\"\n        s=self._get_element(DOT11_MANAGEMENT_ELEMENTS.SUPPORTED_RATES)\n        if s is None:\n            return None\n        \n        rates=struct.unpack('%dB'%len(s),s)\n        if not human_readable:\n            return rates\n            \n        rates_Mbs=tuple([(x&0x7F)*0.5 for x in rates])\n        return rates_Mbs\n\n    def set_supported_rates(self, rates):\n        \"Set the 802.11 Management Supported Rates element. \"\\\n        \"Specifies a tuple or list with up to eight rates, then an \"\\\n        \"Extended Supported Rate element shall be generated to specify \"\\\n        \"the remaining supported rates.\"\n        qty_rates=len(rates)\n        if qty_rates>8:\n            raise Exception(\"requires up to eight rates\")\n        rates_string=struct.pack('B'*qty_rates,*rates)\n        self._set_element(DOT11_MANAGEMENT_ELEMENTS.SUPPORTED_RATES,rates_string)",
  "class Dot11ManagementProbeResponse(Dot11ManagementBeacon):\n    '802.11 Management Probe Response Frame'\n\n    def __init__(self, aBuffer = None):\n        Dot11ManagementBeacon.__init__(self, aBuffer)",
  "class DOT11_REASON_CODES():\n    # RESERVED                                         = 0\n    UNSPECIFIED_REASON                                 = 1\n    PREV_AUTH_NO_LONGER_VALID                          = 2\n    DEAUTH_STA_IS_LEAVING                              = 3\n    DISASS_DUE_TO_INACTIVITY                           = 4\n    DISASS_AP_UNABLE_HANDLE_ALL_STA                    = 5\n    C2_FRAME_FROM_NONAUTHENTICATED_STA                 = 6\n    C3_FRAME_FROM_NONASSOCIATED_STA                    = 7\n    DISSASS_STA_IS_LEAVING                             = 8\n    STA_REQ_NOT_AUTH_STA                               = 9\n    DISASS_POWER_CAP_IE_UNNACCEPTABLE                  = 10\n    DISASS_SUP_CH_IE_UNNACCEPTABLE                     = 11\n    # RESERVED                                         = 12\n    INVALID_IE                                         = 13\n    MIC_FAILURE                                        = 14\n    FOUR_WAY_HANDSHAKE_TIMEOUT                         = 15\n    GROUP_KEY_HANDSHAKE_TIMEOUT                        = 16\n    IE_FOUR_WAY_HANDSHAKE_DIFFERENT                    = 17\n    INVALID_GROUP_CIPHER                               = 18\n    INVALID_PAIRWISE_CIPHER                            = 19\n    INVALID_AKMP                                       = 20\n    UNSUPPORTED_RSN_IE_VERSION                         = 21\n    INVALID_RSN_IE_CAP                                 = 22\n    X_AUTH_FAILED                                      = 23\n    CIPHER_SUITE_REJECTED_SECURITY_POLICY              = 24\n    # RESERVED                                         = 25 - 31\n    DISASS_QOS_RELATED_REASON                          = 32\n    DISASS_QOS_UNSUFFICIENT_BANDWIDTH                  = 33\n    DISASS_EXCESSIVE_FRAMES_WITHOUT_ACK                = 34\n    DISASS_STA_TX_OUTSIDE_TXOPS                        = 35\n    REQ_STA_LEAVING                                    = 36\n    REQ_STA_NOT_WANT_MECHANISM                         = 37\n    REQ_STA_RECV_FRAMES_WHICH_SETUP_REQ                = 38\n    REQ_STA_DUE_TIMEOUT                                = 39\n    STA_NOT_SUPPORT_CIPHER_SUITE                       = 45",
  "class Dot11ManagementDeauthentication(ProtocolPacket):\n    '802.11 Management Deauthentication Frame'\n\n    def __init__(self, aBuffer = None):\n        header_size = 2\n        tail_size = 0\n        if aBuffer:\n            ProtocolPacket.__init__(self, header_size, tail_size)\n            self.load_packet(aBuffer)\n        else:\n            ProtocolPacket.__init__(self, header_size, tail_size)\n\n    def get_reason_code(self):\n        \"Get the 802.11 Management Deauthentication or Disassociation Code.\"\n        return self.header.get_word(0, \"<\")\n\n    def set_reason_code(self, rc):\n        self.header.set_word(0, rc, \"<\")",
  "class DOT11_AUTH_ALGORITHMS():\n    OPEN       = 0\n    SHARED_KEY = 1",
  "class DOT11_AUTH_STATUS_CODES():\n    SUCCESSFUL                                         = 0\n    UNSPECIFIED_FAILURE                                = 1\n    # RESERVED                                         = 2 - 9\n    CAP_REQ_UNSUPPORTED                                = 10\n    REASS_DENIED_CANNOT_CONFIRM_ASS_EXISTS             = 11\n    ASS_DENIED_REASON_OUTSIDE_SCOPE_STANDARD           = 12\n    STA_NOT_SUPPORT_AUTH_ALGORITHM                     = 13\n    AUTH_SEQ_OUT_OF_EXPECTED                           = 14\n    AUTH_REJECTED_CHALLENGE_FAILURE                    = 15\n    AUTH_REJECTED_TIMEOUT                              = 16\n    ASS_DENIED_AP_UNABLE_HANDLE_MORE_STA               = 17\n    ASS_DENIED_STA_NOT_SUPPORTING_DATA_RATES           = 18\n    ASS_DENIED_STA_NOT_SUPPORTING_SHORT_PREAMBLE       = 19\n    ASS_DENIED_STA_NOT_SUPPORTING_PBCC_MODULATION      = 20\n    ASS_DENIED_STA_NOT_SUPPORTING_CHANNEL_AGILITY      = 21\n    ASS_REQUEST_REJECTED_SPACTRUM_MGT_CAP              = 22\n    ASS_REQUEST_REJECTED_POWER_CAP_IE_UNNACCEPTABLE    = 23\n    ASS_REQUEST_REJECTED_SUP_CH_IE_UNNACCEPTABLE       = 24\n    ASS_DENIED_STA_NOT_SUPPORTING_SHORT_SLOT_TIME      = 25\n    ASS_DENIED_STA_NOT_SUPPORTING_DSSS_OFDM            = 26\n    # RESERVED                                         = 27 - 31\n    UNSPECIFIED_QOS                                    = 32\n    ASS_DENIED_QOS_UNSUFFICIENT_BANDWIDTH              = 33\n    ASS_DENIED_EXCESSIVE_FRAME_LOST                    = 34\n    ASS_DENIED_STA_NOT_SUPPORT_QOS                     = 35\n    # RESERVED                                         = 36\n    REQ_HAS_BEEN_DECLINED                              = 37\n    REQ_NOT_SUCCESSFUL_PARAM_INVALID_VALUE             = 38\n    TSPEC                                              = 39\n    INVALID_IE                                         = 40\n    INVALID_GROUP_CIPHER                               = 41\n    INVALID_PAIRWISE_CIPHER                            = 42\n    INVALID_AKMP                                       = 43\n    UNSUPPORTED_RSN_IE_VERSION                         = 44\n    INVALID_RSN_IE_CAP                                 = 45\n    CIPHER_SUITE_REJECTED_SECURITY_POLICY              = 46\n    TS_NOT_CREATED                                     = 47\n    DIRECT_LINK_NOT_ALLOWED_BSS_POLICY                 = 48\n    DST_STA_NOT_PRESENT_IN_BSS                         = 49\n    DST_STA_NOT_QOS_STA                                = 50\n    ASS_DENIED_LISTEN_INTERVAL_TOO_LARGE               = 51",
  "class Dot11ManagementAuthentication(Dot11ManagementHelper):\n    '802.11 Management Authentication Frame'\n\n    __HEADER_BASE_SIZE = 6 # minimal header size\n\n    def __init__(self, aBuffer = None):\n        header_size = self.__HEADER_BASE_SIZE\n        tail_size = 0\n        Dot11ManagementHelper.__init__(self, header_size, tail_size, aBuffer)\n\n    def get_authentication_algorithm(self):\n        \"Get the 802.11 Management Authentication Algorithm.\"\n        return self.header.get_word(0, \"<\")\n\n    def set_authentication_algorithm(self, algorithm):\n        \"Set the 802.11 Management Authentication Algorithm.\"\n        self.header.set_word(0, algorithm, \"<\")\n\n    def get_authentication_sequence(self):\n        \"Get the 802.11 Management Authentication Sequence.\"\n        return self.header.get_word(2, \"<\")\n\n    def set_authentication_sequence(self, seq):\n        \"Set the 802.11 Management Authentication Sequence.\"\n        self.header.set_word(2, seq, \"<\")\n\n    def get_authentication_status(self):\n        \"Get the 802.11 Management Authentication Status.\"\n        return self.header.get_word(4, \"<\")\n\n    def set_authentication_status(self, status):\n        \"Set the 802.11 Management Authentication Status.\"\n        self.header.set_word(4, status, \"<\")\n\n    def get_challenge_text(self):\n        return self._get_element(DOT11_MANAGEMENT_ELEMENTS.CHALLENGE_TEXT)\n\n    def set_challenge_text(self, challenge):\n        self._set_element(DOT11_MANAGEMENT_ELEMENTS.CHALLENGE_TEXT, challenge)\n\n    def get_vendor_specific(self):\n        \"Get the 802.11 Management Vendor Specific elements \"\\\n        \"as a list of tuples.\"\n        \"The Vendor Specific information element is used to carry \"\\\n        \"information not defined in the standard within a single \"\\\n        \"defined format\"\n        \n        vs=[]\n        gen_get_element=self._get_elements_generator(DOT11_MANAGEMENT_ELEMENTS.VENDOR_SPECIFIC)\n        try:\n            while 1:\n                s=next(gen_get_element)\n                \n                if s is None:\n                    raise Exception(\"gen_get_element salio con None!!!\")\n                \n                # OUI is 3 bytes\n                oui=s[:3]\n                data=s[3:]\n                vs.append((oui,data))\n        except StopIteration:\n            pass\n            \n        return vs\n\n    def add_vendor_specific(self, oui, data):\n        \"Set the 802.11 Management Vendor Specific element. \"\\\n        \"The Vendor Specific information element is used to carry \"\\\n        \"information not defined in the standard within a single \"\\\n        \"defined format\"\n        \n        # 3 is the OUI length\n        max_data_len=255-3\n        data_len=len(data)\n\n        if data_len>max_data_len:\n            raise Exception(\"data allow up to %d bytes long\" % max_data_len)\n        if len(oui) > 3:\n            raise Exception(\"oui is three bytes long\")\n        \n        self._set_element(DOT11_MANAGEMENT_ELEMENTS.VENDOR_SPECIFIC,oui+data, replace=False)",
  "class Dot11ManagementDisassociation(Dot11ManagementDeauthentication):\n    '802.11 Management Disassociation Frame'\n\n    def __init__(self, aBuffer = None):\n        Dot11ManagementDeauthentication.__init__(self, aBuffer)",
  "class Dot11ManagementAssociationRequest(Dot11ManagementHelper):\n    '802.11 Management Association Request Frame'\n        \n    __HEADER_BASE_SIZE = 4 # minimal header size\n\n    def __init__(self, aBuffer = None):\n        header_size = self.__HEADER_BASE_SIZE\n        tail_size = 0\n        Dot11ManagementHelper.__init__(self, header_size, tail_size, aBuffer)\n\n    def get_capabilities(self):\n        'Return the 802.11 Management Association Request Frame \\'Capability information\\' field. '\n        b = self.header.get_word(0, \"<\")\n        return b \n\n    def set_capabilities(self, value):\n        'Set the 802.11 Management Association Request Frame \\'Capability Information\\' field' \n        # set the bits\n        nb = value & 0xFFFF\n        self.header.set_word(0, nb, \"<\")\n        \n    def get_listen_interval(self):\n        'Return the 802.11 Management Association Request Frame \\'Listen Interval\\' field. '\n        b = self.header.get_word(2, \"<\")\n        return b \n\n    def set_listen_interval(self, value):\n        'Set the 802.11 Management Association Request Frame \\'Listen Interval\\' field' \n        self.header.set_word(2, value, \"<\")\n        \n    def get_ssid(self):\n        \"Get the 802.11 Management SSID element. \"\\\n        \"The SSID element indicates the identity of an ESS or IBSS.\"\n        return self._get_element(DOT11_MANAGEMENT_ELEMENTS.SSID)\n\n    def set_ssid(self, ssid):\n        self._set_element(DOT11_MANAGEMENT_ELEMENTS.SSID,ssid)\n\n    def get_supported_rates(self, human_readable=False):\n        \"Get the 802.11 Management Supported Rates element. \"\\\n        \"Specifies up to eight rates, then an Extended Supported Rate element \"\\\n        \"shall be generated to specify the remaining supported rates.\"\\\n        \"If human_readable is True, the rates are returned in Mbit/sec\"\n        s=self._get_element(DOT11_MANAGEMENT_ELEMENTS.SUPPORTED_RATES)\n        if s is None:\n            return None\n        \n        rates=struct.unpack('%dB'%len(s),s)\n        if not human_readable:\n            return rates\n            \n        rates_Mbs=tuple([(x&0x7F)*0.5 for x in rates])\n        return rates_Mbs\n\n    def set_supported_rates(self, rates):\n        \"Set the 802.11 Management Supported Rates element. \"\\\n        \"Specifies a tuple or list with up to eight rates, then an \"\\\n        \"Extended Supported Rate element shall be generated to specify \"\\\n        \"the remaining supported rates.\"\n        qty_rates=len(rates)\n        if qty_rates>8:\n            raise Exception(\"requires up to eight rates\")\n        rates_string=struct.pack('B'*qty_rates,*rates)\n        self._set_element(DOT11_MANAGEMENT_ELEMENTS.SUPPORTED_RATES,rates_string)\n\n    def get_rsn(self):\n        \"Get the 802.11 Management Robust Security Network element.\"\n        s = self._get_element(DOT11_MANAGEMENT_ELEMENTS.RSN)\n        if s is None:\n            return None\n        return s\n\n    def set_rsn(self, data):\n        \"Set the 802.11 Management Robust Security Network element.\"\n        self._set_element(DOT11_MANAGEMENT_ELEMENTS.RSN, data)\n\n    def get_vendor_specific(self):\n        \"Get the 802.11 Management Vendor Specific elements \"\\\n        \"as a list of tuples.\"\n        \"The Vendor Specific information element is used to carry \"\\\n        \"information not defined in the standard within a single \"\\\n        \"defined format\"\n        \n        vs=[]\n        gen_get_element=self._get_elements_generator(DOT11_MANAGEMENT_ELEMENTS.VENDOR_SPECIFIC)\n        try:\n            while 1:\n                s=next(gen_get_element)\n                \n                if s is None:\n                    raise Exception(\"gen_get_element salio con None!!!\")\n                \n                # OUI is 3 bytes\n                oui=s[:3]\n                data=s[3:]\n                vs.append((oui,data))\n        except StopIteration:\n            pass\n            \n        return vs\n\n    def add_vendor_specific(self, oui, data):\n        \"Set the 802.11 Management Vendor Specific element. \"\\\n        \"The Vendor Specific information element is used to carry \"\\\n        \"information not defined in the standard within a single \"\\\n        \"defined format\"\n        \n        # 3 is the OUI length\n        max_data_len=255-3\n        data_len=len(data)\n\n        if data_len>max_data_len:\n            raise Exception(\"data allow up to %d bytes long\" % max_data_len)\n        if len(oui) > 3:\n            raise Exception(\"oui is three bytes long\")\n        \n        self._set_element(DOT11_MANAGEMENT_ELEMENTS.VENDOR_SPECIFIC,oui+data, replace=False)",
  "class Dot11ManagementAssociationResponse(Dot11ManagementHelper):\n    '802.11 Management Association Response Frame'\n        \n    __HEADER_BASE_SIZE = 6 # minimal header size\n\n    def __init__(self, aBuffer = None):\n        header_size = self.__HEADER_BASE_SIZE\n        tail_size = 0\n        Dot11ManagementHelper.__init__(self, header_size, tail_size, aBuffer)\n\n    def get_capabilities(self):\n        'Return the 802.11 Management Association Response Frame \\'Capability information\\' field. '\n        b = self.header.get_word(0, \"<\")\n        return b \n\n    def set_capabilities(self, value):\n        'Set the 802.11 Management Association Response Frame \\'Capability Information\\' field' \n        # set the bits\n        nb = value & 0xFFFF\n        self.header.set_word(0, nb, \"<\")\n        \n    def get_status_code(self):\n        'Return the 802.11 Management Association Response Frame \\'Status Code\\' field. '\n        b = self.header.get_word(2, \"<\")\n        return b \n\n    def set_status_code(self, value):\n        'Set the 802.11 Management Association Response Frame \\'Status Code\\' field' \n        self.header.set_word(2, value, \"<\")\n\n    def get_association_id(self):\n        'Return the 802.11 Management Association Response Frame \\'Association Id\\' field. '\n        b = self.header.get_word(4, \"<\")\n        return b \n\n    def set_association_id(self, value):\n        'Set the 802.11 Management Association Response Frame \\'Association Id\\' field' \n        self.header.set_word(4, value, \"<\")\n\n    def get_supported_rates(self, human_readable=False):\n        \"Get the 802.11 Management Supported Rates element. \"\\\n        \"Specifies up to eight rates, then an Extended Supported Rate element \"\\\n        \"shall be generated to specify the remaining supported rates.\"\\\n        \"If human_readable is True, the rates are returned in Mbit/sec\"\n        s=self._get_element(DOT11_MANAGEMENT_ELEMENTS.SUPPORTED_RATES)\n        if s is None:\n            return None\n        \n        rates=struct.unpack('%dB'%len(s),s)\n        if not human_readable:\n            return rates\n            \n        rates_Mbs=tuple([(x&0x7F)*0.5 for x in rates])\n        return rates_Mbs\n\n    def set_supported_rates(self, rates):\n        \"Set the 802.11 Management Supported Rates element. \"\\\n        \"Specifies a tuple or list with up to eight rates, then an \"\\\n        \"Extended Supported Rate element shall be generated to specify \"\\\n        \"the remaining supported rates.\"\n        qty_rates=len(rates)\n        if qty_rates>8:\n            raise Exception(\"requires up to eight rates\")\n        rates_string=struct.pack('B'*qty_rates,*rates)\n        self._set_element(DOT11_MANAGEMENT_ELEMENTS.SUPPORTED_RATES,rates_string)\n\n    def get_vendor_specific(self):\n        \"Get the 802.11 Management Vendor Specific elements \"\\\n        \"as a list of tuples.\"\n        \"The Vendor Specific information element is used to carry \"\\\n        \"information not defined in the standard within a single \"\\\n        \"defined format\"\n        \n        vs=[]\n        gen_get_element=self._get_elements_generator(DOT11_MANAGEMENT_ELEMENTS.VENDOR_SPECIFIC)\n        try:\n            while 1:\n                s=next(gen_get_element)\n                \n                if s is None:\n                    raise Exception(\"gen_get_element salio con None!!!\")\n                \n                # OUI is 3 bytes\n                oui=s[:3]\n                data=s[3:]\n                vs.append((oui,data))\n        except StopIteration:\n            pass\n            \n        return vs\n\n    def add_vendor_specific(self, oui, data):\n        \"Set the 802.11 Management Vendor Specific element. \"\\\n        \"The Vendor Specific information element is used to carry \"\\\n        \"information not defined in the standard within a single \"\\\n        \"defined format\"\n        \n        # 3 is the OUI length\n        max_data_len=255-3\n        data_len=len(data)\n        if data_len>max_data_len:\n            raise Exception(\"data allow up to %d bytes long\" % max_data_len)\n        if len(oui) > 3:\n            raise Exception(\"oui is three bytes long\")\n        \n        self._set_element(DOT11_MANAGEMENT_ELEMENTS.VENDOR_SPECIFIC,oui+data, replace=False)",
  "class Dot11ManagementReassociationRequest(Dot11ManagementHelper):\n    '802.11 Management Reassociation Request Frame'\n        \n    __HEADER_BASE_SIZE = 10 # minimal header size\n\n    def __init__(self, aBuffer = None):\n        header_size = self.__HEADER_BASE_SIZE\n        tail_size = 0\n        Dot11ManagementHelper.__init__(self, header_size, tail_size, aBuffer)\n\n    def get_capabilities(self):\n        'Return the 802.11 Management Reassociation Request Frame \\'Capability information\\' field. '\n        b = self.header.get_word(0, \"<\")\n        return b \n\n    def set_capabilities(self, value):\n        'Set the 802.11 Management Reassociation Request Frame \\'Capability Information\\' field' \n        # set the bits\n        nb = value & 0xFFFF\n        self.header.set_word(0, nb, \"<\")\n\n    def get_listen_interval(self):\n        'Return the 802.11 Management Reassociation Request Frame \\'Listen Interval\\' field. '\n        b = self.header.get_word(2, \"<\")\n        return b \n\n    def set_listen_interval(self, value):\n        'Set the 802.11 Management Reassociation Request Frame \\'Listen Interval\\' field' \n        self.header.set_word(2, value, \"<\")\n\n    def get_current_ap(self):\n        'Return the 802.11 Management Reassociation Request Frame \\'Current AP\\' field.'\n        return self.header.get_bytes()[4:10]\n\n    def set_current_ap(self, value):\n        'Set the 802.11 Management Reassociation Request Frame \\'Current AP\\' field'\n        for i in range(0, 6):\n            self.header.set_byte(4+i, value[i])\n\n    def get_ssid(self):\n        \"Get the 802.11 Management SSID element. \"\\\n        \"The SSID element indicates the identity of an ESS or IBSS.\"\n        return self._get_element(DOT11_MANAGEMENT_ELEMENTS.SSID)\n\n    def set_ssid(self, ssid):\n        self._set_element(DOT11_MANAGEMENT_ELEMENTS.SSID,ssid)\n\n    def get_supported_rates(self, human_readable=False):\n        \"Get the 802.11 Management Supported Rates element. \"\\\n        \"Specifies up to eight rates, then an Extended Supported Rate element \"\\\n        \"shall be generated to specify the remaining supported rates.\"\\\n        \"If human_readable is True, the rates are returned in Mbit/sec\"\n        s=self._get_element(DOT11_MANAGEMENT_ELEMENTS.SUPPORTED_RATES)\n        if s is None:\n            return None\n        \n        rates=struct.unpack('%dB'%len(s),s)\n        if not human_readable:\n            return rates\n            \n        rates_Mbs=tuple([(x&0x7F)*0.5 for x in rates])\n        return rates_Mbs\n\n    def set_supported_rates(self, rates):\n        \"Set the 802.11 Management Supported Rates element. \"\\\n        \"Specifies a tuple or list with up to eight rates, then an \"\\\n        \"Extended Supported Rate element shall be generated to specify \"\\\n        \"the remaining supported rates.\"\n        qty_rates=len(rates)\n        if qty_rates>8:\n            raise Exception(\"requires up to eight rates\")\n        rates_string=struct.pack('B'*qty_rates,*rates)\n        self._set_element(DOT11_MANAGEMENT_ELEMENTS.SUPPORTED_RATES,rates_string)\n\n    def get_rsn(self):\n        \"Get the 802.11 Management Robust Security Network element.\"\n        s = self._get_element(DOT11_MANAGEMENT_ELEMENTS.RSN)\n        if s is None:\n            return None\n        return s\n\n    def set_rsn(self, data):\n        \"Set the 802.11 Management Robust Security Network element.\"\n        self._set_element(DOT11_MANAGEMENT_ELEMENTS.RSN, data)\n\n    def get_vendor_specific(self):\n        \"Get the 802.11 Management Vendor Specific elements \"\\\n        \"as a list of tuples.\"\n        \"The Vendor Specific information element is used to carry \"\\\n        \"information not defined in the standard within a single \"\\\n        \"defined format\"\n        \n        vs=[]\n        gen_get_element=self._get_elements_generator(DOT11_MANAGEMENT_ELEMENTS.VENDOR_SPECIFIC)\n        try:\n            while 1:\n                s=next(gen_get_element)\n                \n                if s is None:\n                    raise Exception(\"gen_get_element salio con None!!!\")\n                \n                # OUI is 3 bytes\n                oui=s[:3]\n                data=s[3:]\n                vs.append((oui,data))\n        except StopIteration:\n            pass\n            \n        return vs\n\n    def add_vendor_specific(self, oui, data):\n        \"Set the 802.11 Management Vendor Specific element. \"\\\n        \"The Vendor Specific information element is used to carry \"\\\n        \"information not defined in the standard within a single \"\\\n        \"defined format\"\n        \n        # 3 is the OUI length\n        max_data_len=255-3\n        data_len=len(data)\n\n        if data_len>max_data_len:\n            raise Exception(\"data allow up to %d bytes long\" % max_data_len)\n        if len(oui) > 3:\n            raise Exception(\"oui is three bytes long\")\n        \n        self._set_element(DOT11_MANAGEMENT_ELEMENTS.VENDOR_SPECIFIC,oui+data, replace=False)",
  "class Dot11ManagementReassociationResponse(Dot11ManagementAssociationResponse):\n    '802.11 Management Reassociation Response Frame'\n\n    def __init__(self, aBuffer = None):\n        Dot11ManagementAssociationResponse.__init__(self, aBuffer)",
  "def __init__(self, aBuffer = None, FCS_at_end = True):\n        header_size = 2\n        self.__FCS_at_end=not not FCS_at_end # Is Boolean\n        if self.__FCS_at_end:\n            tail_size = 4\n        else:\n            tail_size = 0\n            \n        ProtocolPacket.__init__(self, header_size,tail_size)\n        if(aBuffer):\n            self.load_packet(aBuffer)",
  "def get_order(self):\n        \"Return 802.11 frame 'Order' field\"\n        b = self.header.get_byte(1)\n        return ((b >> 7) & 0x01)",
  "def set_order(self, value):\n        \"Set 802.11 frame 'Order' field\"\n        # clear the bits\n        mask = (~0x80) & 0xFF\n        masked = self.header.get_byte(1) & mask\n        # set the bits\n        nb = masked | ((value & 0x01) << 7)\n        self.header.set_byte(1, nb)",
  "def get_protectedFrame(self):\n        \"Return 802.11 frame 'Protected' field\"\n        b = self.header.get_byte(1)\n        return ((b >> 6) & 0x01)",
  "def set_protectedFrame(self, value):\n        \"Set 802.11 frame 'Protected Frame' field\"\n        # clear the bits\n        mask = (~0x40) & 0xFF\n        masked = self.header.get_byte(1) & mask\n        # set the bits\n        nb = masked | ((value & 0x01) << 6)\n        self.header.set_byte(1, nb)",
  "def get_moreData(self):\n        \"Return 802.11 frame 'More Data' field\"\n        b = self.header.get_byte(1)\n        return ((b >> 5) & 0x01)",
  "def set_moreData(self, value):\n        \"Set 802.11 frame 'More Data' field\"\n        # clear the bits\n        mask = (~0x20) & 0xFF\n        masked = self.header.get_byte(1) & mask\n        # set the bits\n        nb = masked | ((value & 0x01) << 5)\n        self.header.set_byte(1, nb)",
  "def get_powerManagement(self):\n        \"Return 802.11 frame 'Power Management' field\"\n        b = self.header.get_byte(1)\n        return ((b >> 4) & 0x01)",
  "def set_powerManagement(self, value):\n        \"Set 802.11 frame 'Power Management' field\"\n        # clear the bits\n        mask = (~0x10) & 0xFF\n        masked = self.header.get_byte(1) & mask\n        # set the bits\n        nb = masked | ((value & 0x01) << 4)\n        self.header.set_byte(1, nb)",
  "def get_retry(self):\n        \"Return 802.11 frame 'Retry' field\"\n        b = self.header.get_byte(1)\n        return ((b >> 3) & 0x01)",
  "def set_retry(self, value):\n        \"Set 802.11 frame 'Retry' field\"\n        # clear the bits\n        mask = (~0x08) & 0xFF\n        masked = self.header.get_byte(1) & mask\n        # set the bits\n        nb = masked | ((value & 0x01) << 3)\n        self.header.set_byte(1, nb)",
  "def get_moreFrag(self):\n        \"Return 802.11 frame 'More Fragments' field\"\n        b = self.header.get_byte(1)\n        return ((b >> 2) & 0x01)",
  "def set_moreFrag(self, value):\n        \"Set 802.11 frame 'More Fragments' field\"\n        # clear the bits\n        mask = (~0x04) & 0xFF\n        masked = self.header.get_byte(1) & mask\n        # set the bits\n        nb = masked | ((value & 0x01) << 2)\n        self.header.set_byte(1, nb)",
  "def get_fromDS(self):\n        \"Return 802.11 frame 'from DS' field\"\n        b = self.header.get_byte(1)\n        return ((b >> 1) & 0x01)",
  "def set_fromDS(self, value):\n        \"Set 802.11 frame 'from DS' field\"\n        # clear the bits\n        mask = (~0x02) & 0xFF\n        masked = self.header.get_byte(1) & mask\n        # set the bits\n        nb = masked | ((value & 0x01) << 1)\n        self.header.set_byte(1, nb)",
  "def get_toDS(self):\n        \"Return 802.11 frame 'to DS' field\"\n        b = self.header.get_byte(1)\n        return (b & 0x01)",
  "def set_toDS(self, value):\n        \"Set 802.11 frame 'to DS' field\"\n        # clear the bits\n        mask = (~0x01) & 0xFF\n        masked = self.header.get_byte(1) & mask\n        # set the bits\n        nb = masked | (value & 0x01) \n        self.header.set_byte(1, nb)",
  "def get_subtype(self):\n        \"Return 802.11 frame 'subtype' field\"\n        b = self.header.get_byte(0)\n        return ((b >> 4) & 0x0F)",
  "def set_subtype(self, value):\n        \"Set 802.11 frame 'subtype' field\"\n        # clear the bits\n        mask = (~0xF0)&0xFF \n        masked = self.header.get_byte(0) & mask \n        # set the bits\n        nb = masked | ((value << 4) & 0xF0)\n        self.header.set_byte(0, nb)",
  "def get_type(self):\n        \"Return 802.11 frame 'type' field\"\n        b = self.header.get_byte(0)\n        return ((b >> 2) & 0x03)",
  "def set_type(self, value):\n        \"Set 802.11 frame 'type' field\"\n        # clear the bits\n        mask = (~0x0C)&0xFF \n        masked = self.header.get_byte(0) & mask \n        # set the bits\n        nb = masked | ((value << 2) & 0x0C)\n        self.header.set_byte(0, nb)",
  "def get_type_n_subtype(self):\n        \"Return 802.11 frame 'Type and Subtype' field\"\n        b = self.header.get_byte(0)\n        return ((b >> 2) & 0x3F)",
  "def set_type_n_subtype(self, value):\n        \"Set 802.11 frame 'Type and Subtype' field\"\n        # clear the bits\n        mask = (~0xFC)&0xFF \n        masked = self.header.get_byte(0) & mask \n        # set the bits\n        nb = masked | ((value << 2) & 0xFC)\n        self.header.set_byte(0, nb)",
  "def get_version(self):\n        \"Return 802.11 frame control 'Protocol version' field\"\n        b = self.header.get_byte(0)\n        return (b & 0x03)",
  "def set_version(self, value):\n        \"Set the 802.11 frame control 'Protocol version' field\"\n        # clear the bits\n        mask = (~0x03)&0xFF \n        masked = self.header.get_byte(0) & mask \n        # set the bits\n        nb = masked | (value & 0x03)\n        self.header.set_byte(0, nb)",
  "def compute_checksum(self,bytes):\n        crcle=crc32(bytes)&0xffffffff\n        # ggrr this crc32 is in little endian, convert it to big endian \n        crc=struct.pack('<L', crcle)\n         # Convert to long\n        (crc_long,) = struct.unpack('!L', crc)\n        return crc_long",
  "def is_QoS_frame(self):\n        \"Return 'True' if is an QoS data frame type\"\n        \n        b = self.header.get_byte(0)\n        return (b & 0x80) and True",
  "def is_no_framebody_frame(self):\n        \"Return 'True' if it frame contain no Frame Body\"\n        \n        b = self.header.get_byte(0)\n        return (b & 0x40) and True",
  "def is_cf_poll_frame(self):\n        \"Return 'True' if it frame is a CF_POLL frame\"\n        \n        b = self.header.get_byte(0)\n        return (b & 0x20) and True",
  "def is_cf_ack_frame(self):\n        \"Return 'True' if it frame is a CF_ACK frame\"\n        \n        b = self.header.get_byte(0)\n        return (b & 0x10) and True",
  "def get_fcs(self):\n        \"Return 802.11 'FCS' field\"\n        \n        if not self.__FCS_at_end:\n            return None   \n\n        b = self.tail.get_long(-4, \">\")\n        return b",
  "def set_fcs(self, value = None):\n        \"Set the 802.11 CTS control frame 'FCS' field. If value is None, is auto_checksum\"\n\n        if not self.__FCS_at_end:   \n            return\n        \n        # calculate the FCS\n        if value is None:\n            payload = self.get_body_as_string()\n            crc32=self.compute_checksum(payload)            \n            value=crc32\n\n        # set the bits\n        nb = value & 0xFFFFFFFF\n        self.tail.set_long(-4, nb)",
  "def __init__(self, aBuffer = None):\n        header_size = 8\n        tail_size = 0\n\n        ProtocolPacket.__init__(self, header_size, tail_size)\n        if(aBuffer):\n            self.load_packet(aBuffer)",
  "def get_duration(self):\n        \"Return 802.11 CTS control frame 'Duration' field\"\n        b = self.header.get_word(0, \"<\")\n        return b",
  "def set_duration(self, value):\n        \"Set the 802.11 CTS control frame 'Duration' field\" \n        # set the bits\n        nb = value & 0xFFFF\n        self.header.set_word(0, nb, \"<\")",
  "def get_ra(self):\n        \"Return 802.11 CTS control frame 48 bit 'Receiver Address' field as a 6 bytes array\"\n        return self.header.get_bytes()[2:8]",
  "def set_ra(self, value):\n        \"Set 802.11 CTS control frame 48 bit 'Receiver Address' field as a 6 bytes array\"\n        for i in range(0, 6):\n            self.header.set_byte(2+i, value[i])",
  "def __init__(self, aBuffer = None):\n        header_size = 8\n        tail_size = 0\n\n        ProtocolPacket.__init__(self, header_size, tail_size)\n        if(aBuffer):\n            self.load_packet(aBuffer)",
  "def get_duration(self):\n        \"Return 802.11 ACK control frame 'Duration' field\"\n        b = self.header.get_word(0, \"<\")\n        return b",
  "def set_duration(self, value):\n        \"Set the 802.11 ACK control frame 'Duration' field\" \n        # set the bits\n        nb = value & 0xFFFF\n        self.header.set_word(0, nb, \"<\")",
  "def get_ra(self):\n        \"Return 802.11 ACK control frame 48 bit 'Receiver Address' field as a 6 bytes array\"\n        return self.header.get_bytes()[2:8]",
  "def set_ra(self, value):\n        \"Set 802.11 ACK control frame 48 bit 'Receiver Address' field as a 6 bytes array\"\n        for i in range(0, 6):\n            self.header.set_byte(2+i, value[i])",
  "def __init__(self, aBuffer = None):\n        header_size = 14\n        tail_size = 0\n\n        ProtocolPacket.__init__(self, header_size, tail_size)\n        if(aBuffer):\n            self.load_packet(aBuffer)",
  "def get_duration(self):\n        \"Return 802.11 RTS control frame 'Duration' field\"\n        b = self.header.get_word(0, \"<\")\n        return b",
  "def set_duration(self, value):\n        \"Set the 802.11 RTS control frame 'Duration' field\" \n        # set the bits\n        nb = value & 0xFFFF\n        self.header.set_word(0, nb, \"<\")",
  "def get_ra(self):\n        \"Return 802.11 RTS control frame 48 bit 'Receiver Address' field as a 6 bytes array\"\n        return self.header.get_bytes()[2:8]",
  "def set_ra(self, value):\n        \"Set 802.11 RTS control frame 48 bit 'Receiver Address' field as a 6 bytes array\"\n        for i in range(0, 6):\n            self.header.set_byte(2+i, value[i])",
  "def get_ta(self):\n        \"Return 802.11 RTS control frame 48 bit 'Transmitter Address' field as a 6 bytes array\"\n        return self.header.get_bytes()[8:14]",
  "def set_ta(self, value):\n        \"Set 802.11 RTS control frame 48 bit 'Transmitter Address' field as a 6 bytes array\"\n        for i in range(0, 6):\n            self.header.set_byte(8+i, value[i])",
  "def __init__(self, aBuffer = None):\n        header_size = 14\n        tail_size = 0\n        \n        ProtocolPacket.__init__(self, header_size, tail_size)\n        if(aBuffer):\n            self.load_packet(aBuffer)",
  "def get_aid(self):\n        \"Return 802.11 PSPoll control frame 'AID' field\"\n        # the spec says \"The AID value always has its two MSBs each set to 1.\"\n        # TODO: Should we do check/modify it? Wireshark shows the only MSB to 0\n        b = self.header.get_word(0, \"<\")\n        return b",
  "def set_aid(self, value):\n        \"Set the 802.11 PSPoll control frame 'AID' field\" \n        # set the bits\n        nb = value & 0xFFFF\n        # the spec says \"The AID value always has its two MSBs each set to 1.\"\n        # TODO: Should we do check/modify it? Wireshark shows the only MSB to 0\n        self.header.set_word(0, nb, \"<\")",
  "def get_bssid(self):\n        \"Return 802.11 PSPoll control frame 48 bit 'BSS ID' field as a 6 bytes array\"\n        return self.header.get_bytes()[2:8]",
  "def set_bssid(self, value):\n        \"Set 802.11 PSPoll control frame 48 bit 'BSS ID' field as a 6 bytes array\"\n        for i in range(0, 6):\n            self.header.set_byte(2+i, value[i])",
  "def get_ta(self):\n        \"Return 802.11 PSPoll control frame 48 bit 'Transmitter Address' field as a 6 bytes array\"\n        return self.header.get_bytes()[8:14]",
  "def set_ta(self, value):\n        \"Set 802.11 PSPoll control frame 48 bit 'Transmitter Address' field as a 6 bytes array\"\n        for i in range(0, 6):\n            self.header.set_byte(8+i, value[i])",
  "def __init__(self, aBuffer = None):\n        header_size = 14\n        tail_size = 0\n    \n        ProtocolPacket.__init__(self, header_size, tail_size)\n        if(aBuffer):\n            self.load_packet(aBuffer)",
  "def get_duration(self):\n        \"Return 802.11 CF-End control frame 'Duration' field\"\n        b = self.header.get_word(0, \"<\")\n        return b",
  "def set_duration(self, value):\n        \"Set the 802.11 CF-End control frame 'Duration' field\" \n        # set the bits\n        nb = value & 0xFFFF\n        self.header.set_word(0, nb, \"<\")",
  "def get_ra(self):\n        \"Return 802.11 CF-End control frame 48 bit 'Receiver Address' field as a 6 bytes array\"\n        return self.header.get_bytes()[2:8]",
  "def set_ra(self, value):\n        \"Set 802.11 CF-End control frame 48 bit 'Receiver Address' field as a 6 bytes array\"\n        for i in range(0, 6):\n            self.header.set_byte(2+i, value[i])",
  "def get_bssid(self):\n        \"Return 802.11 CF-End control frame 48 bit 'BSS ID' field as a 6 bytes array\"\n        return self.header.get_bytes()[8:14]",
  "def set_bssid(self, value):\n        \"Set 802.11 CF-End control frame 48 bit 'BSS ID' field as a 6 bytes array\"\n        for i in range(0, 6):\n            self.header.set_byte(8+i, value[i])",
  "def __init__(self, aBuffer = None):\n        header_size = 14\n        tail_size = 0\n\n        ProtocolPacket.__init__(self, header_size, tail_size)\n        if(aBuffer):\n            self.load_packet(aBuffer)",
  "def get_duration(self):\n        'Return 802.11 \\'CF-End+CF-ACK\\' control frame \\'Duration\\' field'\n        b = self.header.get_word(0, \"<\")\n        return b",
  "def set_duration(self, value):\n        'Set the 802.11 \\'CF-End+CF-ACK\\' control frame \\'Duration\\' field' \n        # set the bits\n        nb = value & 0xFFFF\n        self.header.set_word(0, nb, \"<\")",
  "def get_ra(self):\n        'Return 802.11 \\'CF-End+CF-ACK\\' control frame 48 bit \\'Receiver Address\\' field as a 6 bytes array'\n        return self.header.get_bytes()[2:8]",
  "def set_ra(self, value):\n        'Set 802.11 \\'CF-End+CF-ACK\\' control frame 48 bit \\'Receiver Address\\' field as a 6 bytes array'\n        for i in range(0, 6):\n            self.header.set_byte(2+i, value[i])",
  "def get_bssid(self):\n        'Return 802.11 \\'CF-End+CF-ACK\\' control frame 48 bit \\'BSS ID\\' field as a 6 bytes array'\n        return self.header.get_bytes()[8:16]",
  "def set_bssid(self, value):\n        'Set 802.11 \\'CF-End+CF-ACK\\' control frame 48 bit \\'BSS ID\\' field as a 6 bytes array'\n        for i in range(0, 6):\n            self.header.set_byte(8+i, value[i])",
  "def __init__(self, aBuffer = None):\n        header_size = 22\n        tail_size = 0\n\n        ProtocolPacket.__init__(self, header_size, tail_size)\n        if(aBuffer):\n            self.load_packet(aBuffer)",
  "def get_duration(self):\n        'Return 802.11 \\'Data\\' data frame \\'Duration\\' field'\n        b = self.header.get_word(0, \"<\")\n        return b",
  "def set_duration(self, value):\n        'Set the 802.11 \\'Data\\' data frame \\'Duration\\' field' \n        # set the bits\n        nb = value & 0xFFFF\n        self.header.set_word(0, nb, \"<\")",
  "def get_address1(self):\n        'Return 802.11 \\'Data\\' data frame 48 bit \\'Address1\\' field as a 6 bytes array'\n        return self.header.get_bytes()[2:8]",
  "def set_address1(self, value):\n        'Set 802.11 \\'Data\\' data frame 48 bit \\'Address1\\' field as a 6 bytes array'\n        for i in range(0, 6):\n            self.header.set_byte(2+i, value[i])",
  "def get_address2(self):\n        'Return 802.11 \\'Data\\' data frame 48 bit \\'Address2\\' field as a 6 bytes array'\n        return self.header.get_bytes()[8:14]",
  "def set_address2(self, value):\n        'Set 802.11 \\'Data\\' data frame 48 bit \\'Address2\\' field as a 6 bytes array'\n        for i in range(0, 6):\n            self.header.set_byte(8+i, value[i])",
  "def get_address3(self):\n        'Return 802.11 \\'Data\\' data frame 48 bit \\'Address3\\' field as a 6 bytes array'\n        return self.header.get_bytes()[14: 20]",
  "def set_address3(self, value):\n        'Set 802.11 \\'Data\\' data frame 48 bit \\'Address3\\' field as a 6 bytes array'\n        for i in range(0, 6):\n            self.header.set_byte(14+i, value[i])",
  "def get_sequence_control(self):\n        'Return 802.11 \\'Data\\' data frame \\'Sequence Control\\' field'\n        b = self.header.get_word(20, \"<\")\n        return b",
  "def set_sequence_control(self, value):\n        'Set the 802.11 \\'Data\\' data frame \\'Sequence Control\\' field' \n        # set the bits\n        nb = value & 0xFFFF\n        self.header.set_word(20, nb, \"<\")",
  "def get_fragment_number(self):\n        'Return 802.11 \\'Data\\' data frame \\'Fragment Number\\' subfield'\n\n        b = self.header.get_word(20, \"<\")\n        return (b&0x000F)",
  "def set_fragment_number(self, value):\n        'Set the 802.11 \\'Data\\' data frame \\'Fragment Number\\' subfield' \n        # clear the bits\n        mask = (~0x000F) & 0xFFFF\n        masked = self.header.get_word(20, \"<\") & mask\n        # set the bits \n        nb = masked | (value & 0x000F)\n        self.header.set_word(20, nb, \"<\")",
  "def get_sequence_number(self):\n        'Return 802.11 \\'Data\\' data frame \\'Sequence Number\\' subfield'\n        \n        b = self.header.get_word(20, \"<\")\n        return ((b>>4) & 0xFFF)",
  "def set_sequence_number(self, value):\n        'Set the 802.11 \\'Data\\' data frame \\'Sequence Number\\' subfield' \n        # clear the bits\n        mask = (~0xFFF0) & 0xFFFF\n        masked = self.header.get_word(20, \"<\") & mask\n        # set the bits \n        nb = masked | ((value & 0x0FFF ) << 4 ) \n        self.header.set_word(20, nb, \"<\")",
  "def get_frame_body(self):\n        'Return 802.11 \\'Data\\' data frame \\'Frame Body\\' field'\n        \n        return self.get_body_as_string()",
  "def set_frame_body(self, data):\n        'Set 802.11 \\'Data\\' data frame \\'Frame Body\\' field'\n        \n        self.load_body(data)",
  "def __init__(self, aBuffer = None):\n        header_size = 24\n        tail_size = 0\n\n        ProtocolPacket.__init__(self, header_size, tail_size)\n        if(aBuffer):\n            self.load_packet(aBuffer)",
  "def get_QoS(self):\n        'Return 802.11 \\'Data\\' data frame \\'QoS\\' field'\n        b = self.header.get_word(22, \"<\")\n        return b",
  "def set_QoS(self, value):\n        'Set the 802.11 \\'Data\\' data frame \\'QoS\\' field' \n        # set the bits\n        nb = value & 0xFFFF\n        self.header.set_word(22, nb, \"<\")",
  "def __init__(self, aBuffer = None):\n        header_size = 28\n        tail_size = 0\n\n        ProtocolPacket.__init__(self, header_size, tail_size)\n        if(aBuffer):\n            self.load_packet(aBuffer)",
  "def get_address4(self):\n        'Return 802.11 \\'Data\\' data frame 48 bit \\'Address4\\' field as a 6 bytes array'\n        return self.header.get_bytes()[22:28]",
  "def set_address4(self, value):\n        'Set 802.11 \\'Data\\' data frame 48 bit \\'Address4\\' field as a 6 bytes array'\n        for i in range(0, 6):\n            self.header.set_byte(22+i, value[i])",
  "def __init__(self, aBuffer = None):\n        header_size = 30\n        tail_size = 0\n\n        ProtocolPacket.__init__(self, header_size, tail_size)\n        if(aBuffer):\n            self.load_packet(aBuffer)",
  "def get_QoS(self):\n        'Return 802.11 \\'Data\\' data frame \\'QoS\\' field'\n        b = self.header.get_word(28, \"<\")\n        return b",
  "def set_QoS(self, value):\n        'Set the 802.11 \\'Data\\' data frame \\'QoS\\' field' \n        # set the bits\n        nb = value & 0xFFFF\n        self.header.set_word(28, nb, \"<\")",
  "def __init__(self, aBuffer = None):\n        header_size = 3\n        tail_size = 0\n\n        ProtocolPacket.__init__(self, header_size, tail_size)\n        if(aBuffer):\n            self.load_packet(aBuffer)",
  "def get_DSAP(self):\n        \"Get the Destination Service Access Point (SAP) from LLC frame\"\n        return self.header.get_byte(0)",
  "def set_DSAP(self, value):\n        \"Set the Destination Service Access Point (SAP) of LLC frame\"\n        self.header.set_byte(0, value)",
  "def get_SSAP(self):\n        \"Get the Source Service Access Point (SAP) from LLC frame\"\n        return self.header.get_byte(1)",
  "def set_SSAP(self, value):\n        \"Set the Source Service Access Point (SAP) of LLC frame\"\n        self.header.set_byte(1, value)",
  "def get_control(self):\n        \"Get the Control field from LLC frame\"\n        return self.header.get_byte(2)",
  "def set_control(self, value):\n        \"Set the Control field of LLC frame\"\n        self.header.set_byte(2, value)",
  "def __init__(self, aBuffer = None):\n        header_size = 5\n        tail_size = 0\n\n        ProtocolPacket.__init__(self, header_size, tail_size)\n        if(aBuffer):\n            self.load_packet(aBuffer)",
  "def get_OUI(self):\n        \"Get the three-octet Organizationally Unique Identifier (OUI) SNAP frame\"\n        b = array_tobytes(self.header.get_bytes()[0:3])\n        #unpack requires a string argument of length 4 and b is 3 bytes long\n        (oui,) = struct.unpack('!L', b'\\x00'+b)\n        return oui",
  "def set_OUI(self, value):\n        \"Set the three-octet Organizationally Unique Identifier (OUI) SNAP frame\"\n        # clear the bits\n        mask = ((~0xFFFFFF00) & 0xFF)\n        masked = self.header.get_long(0, \">\") & mask\n        # set the bits \n        nb = masked | ((value & 0x00FFFFFF) << 8)\n        self.header.set_long(0, nb)",
  "def get_protoID(self):\n        \"Get the two-octet Protocol Identifier (PID) SNAP field\"\n        return self.header.get_word(3, \">\")",
  "def set_protoID(self, value):\n        \"Set the two-octet Protocol Identifier (PID) SNAP field\"\n        self.header.set_word(3, value, \">\")",
  "def __init__(self, aBuffer = None):\n        header_size = 4\n        tail_size = 0\n\n        ProtocolPacket.__init__(self, header_size, tail_size)\n        if(aBuffer):\n            self.load_packet(aBuffer)",
  "def is_WEP(self):\n        'Return True if it\\'s a WEP'\n        # We already know that it's private.\n        # Now we must differentiate between WEP and WPA/WPA2\n        # WPA/WPA2 have the ExtIV (Bit 5) enaled and WEP disabled\n        b = self.header.get_byte(3)\n        return not (b & 0x20)",
  "def get_iv(self):\n        'Return the \\'WEP IV\\' field'\n        b = array_tobytes(self.header.get_bytes()[0:3])\n        #unpack requires a string argument of length 4 and b is 3 bytes long\n        (iv,) = struct.unpack('!L', b'\\x00'+b)\n        return iv",
  "def set_iv(self, value):\n        'Set the \\'WEP IV\\' field.'\n        # clear the bits\n        mask = ((~0xFFFFFF00) & 0xFF)\n        masked = self.header.get_long(0, \">\") & mask\n        # set the bits \n        nb = masked | ((value & 0x00FFFFFF) << 8)\n        self.header.set_long(0, nb)",
  "def get_keyid(self):\n        'Return the \\'WEP KEY ID\\' field'\n        b = self.header.get_byte(3)\n        return ((b>>6) & 0x03)",
  "def set_keyid(self, value):\n        'Set the \\'WEP KEY ID\\' field'\n        # clear the bits\n        mask = (~0xC0) & 0xFF\n        masked = self.header.get_byte(3) & mask\n        # set the bits\n        nb = masked | ((value & 0x03) << 6)\n        self.header.set_byte(3, nb)",
  "def get_decrypted_data(self, key_string):\n        'Return \\'WEP Data\\' field decrypted'\n\n        # Needs to be at least 8 bytes of payload \n        if len(self.body_string)<8:\n            return self.body_string\n        \n        # initialize the first bytes of the key from the IV \n        # and copy rest of the WEP key (the secret part) \n        \n        # Convert IV to 3 bytes long string\n        iv=struct.pack('>L',self.get_iv())[-3:]\n        key=iv+key_string\n        rc4=RC4(key)\n        decrypted_data=rc4.decrypt(self.body_string)\n        \n        return decrypted_data",
  "def get_encrypted_data(self, key_string):\n        # RC4 is symmetric\n        return self.get_decrypted_data(key_string)",
  "def encrypt_frame(self, key_string):\n        enc = self.get_encrypted_data(key_string)\n        self.load_body(enc)",
  "def __init__(self, aBuffer = None):\n        header_size = 0\n        tail_size = 4\n\n        ProtocolPacket.__init__(self, header_size, tail_size)\n        if(aBuffer):\n            self.load_packet(aBuffer)",
  "def get_icv(self):\n        \"Return 'WEP ICV' field\"\n            \n        b = self.tail.get_long(-4, \">\")\n        return b",
  "def set_icv(self, value = None):\n        \"Set 'WEP ICV' field\"\n\n        # Compute the WEP ICV\n        if value is None:\n            value=self.get_computed_icv()\n\n        # set the bits\n        nb = value & 0xFFFFFFFF\n        self.tail.set_long(-4, nb)",
  "def get_computed_icv(self):\n        crcle=crc32(self.body_string)&0xffffffff\n        # This crc32 is in little endian, convert it to big endian \n        crc=struct.pack('<L', crcle)\n         # Convert to long\n        (crc_long,) = struct.unpack('!L', crc)\n        return crc_long",
  "def check_icv(self):\n        computed_icv=self.get_computed_icv()\n        current_icv=self.get_icv()\n        if computed_icv==current_icv:\n            return True\n        else:\n            return False",
  "def __init__(self, aBuffer = None):\n        header_size = 8\n        tail_size = 0\n\n        ProtocolPacket.__init__(self, header_size, tail_size)\n        if(aBuffer):\n            self.load_packet(aBuffer)",
  "def is_WPA(self):\n        'Return True if it\\'s a WPA'\n        # Now we must differentiate between WPA and WPA2\n        # In WPA WEPSeed is set to (TSC1 | 0x20) & 0x7f.\n        b = self.get_WEPSeed() == ((self.get_TSC1() | 0x20 ) & 0x7f)\n        return (b and self.get_extIV())",
  "def get_keyid(self):\n        'Return the \\'WPA KEY ID\\' field'\n        b = self.header.get_byte(3)\n        return ((b>>6) & 0x03)",
  "def set_keyid(self, value):\n        'Set the \\'WPA KEY ID\\' field'\n        # clear the bits\n        mask = (~0xC0) & 0xFF\n        masked = self.header.get_byte(3) & mask\n        # set the bits\n        nb = masked | ((value & 0x03) << 6)\n        self.header.set_byte(3, nb)",
  "def get_decrypted_data(self):\n        'Return \\'WPA Data\\' field decrypted'\n        # TODO: Replace it with the decoded string\n        return self.body_string",
  "def get_TSC1(self):\n        'Return the \\'WPA TSC1\\' field'\n        b = self.header.get_byte(0)\n        return (b & 0xFF)",
  "def set_TSC1(self, value):\n        'Set the \\'WPA TSC1\\' field'\n        # set the bits\n        nb = (value & 0xFF)\n        self.header.set_byte(0, nb)",
  "def get_WEPSeed(self):\n        'Return the \\'WPA WEPSeed\\' field'\n        b = self.header.get_byte(1)\n        return (b & 0xFF)",
  "def set_WEPSeed(self, value):\n        'Set the \\'WPA WEPSeed\\' field'\n        # set the bits\n        nb = (value & 0xFF)\n        self.header.set_byte(1, nb)",
  "def get_TSC0(self):\n        'Return the \\'WPA TSC0\\' field'\n        b = self.header.get_byte(2)\n        return (b & 0xFF)",
  "def set_TSC0(self, value):\n        'Set the \\'WPA TSC0\\' field'\n        # set the bits\n        nb = (value & 0xFF)\n        self.header.set_byte(2, nb)",
  "def get_extIV(self):\n        'Return the \\'WPA extID\\' field'\n        b = self.header.get_byte(3)\n        return ((b>>5) & 0x1)",
  "def set_extIV(self, value):\n        'Set the \\'WPA extID\\' field'\n        # clear the bits\n        mask = (~0x20) & 0xFF\n        masked = self.header.get_byte(3) & mask\n        # set the bits\n        nb = masked | ((value & 0x01) << 5)\n        self.header.set_byte(3, nb)",
  "def get_TSC2(self):\n        'Return the \\'WPA TSC2\\' field'\n        b = self.header.get_byte(4)\n        return (b & 0xFF)",
  "def set_TSC2(self, value):\n        'Set the \\'WPA TSC2\\' field'\n        # set the bits\n        nb = (value & 0xFF)\n        self.header.set_byte(4, nb)",
  "def get_TSC3(self):\n        'Return the \\'WPA TSC3\\' field'\n        b = self.header.get_byte(5)\n        return (b & 0xFF)",
  "def set_TSC3(self, value):\n        'Set the \\'WPA TSC3\\' field'\n        # set the bits\n        nb = (value & 0xFF)\n        self.header.set_byte(5, nb)",
  "def get_TSC4(self):\n        'Return the \\'WPA TSC4\\' field'\n        b = self.header.get_byte(6)\n        return (b & 0xFF)",
  "def set_TSC4(self, value):\n        'Set the \\'WPA TSC4\\' field'\n        # set the bits\n        nb = (value & 0xFF)\n        self.header.set_byte(6, nb)",
  "def get_TSC5(self):\n        'Return the \\'WPA TSC5\\' field'\n        b = self.header.get_byte(7)\n        return (b & 0xFF)",
  "def set_TSC5(self, value):\n        'Set the \\'WPA TSC5\\' field'\n        # set the bits\n        nb = (value & 0xFF)\n        self.header.set_byte(7, nb)",
  "def __init__(self, aBuffer = None):\n        header_size = 0\n        tail_size = 12\n\n        ProtocolPacket.__init__(self, header_size, tail_size)\n        if(aBuffer):\n            self.load_packet(aBuffer)",
  "def get_icv(self):\n        \"Return 'WPA ICV' field\"\n            \n        b = self.tail.get_long(-4, \">\")\n        return b",
  "def set_icv(self, value = None):\n        \"Set 'WPA ICV' field\"\n\n        # calculate the FCS\n        if value is None:\n            value=self.compute_checksum(self.body_string)\n\n        # set the bits\n        nb = value & 0xFFFFFFFF\n        self.tail.set_long(-4, nb)",
  "def get_MIC(self):\n        'Return the \\'WPA2Data MIC\\' field'\n        return self.get_tail_as_string()[:8]",
  "def set_MIC(self, value):\n        'Set the \\'WPA2Data MIC\\' field'\n        #Padding to 8 bytes with 0x00's \n        value.ljust(8,b'\\x00')\n        #Stripping to 8 bytes\n        value=value[:8]\n        icv=self.tail.get_buffer_as_string()[-4:] \n        self.tail.set_bytes_from_string(value+icv)",
  "def __init__(self, aBuffer = None):\n        header_size = 8\n        tail_size = 0\n\n        ProtocolPacket.__init__(self, header_size, tail_size)\n        if(aBuffer):\n            self.load_packet(aBuffer)",
  "def is_WPA2(self):\n        'Return True if it\\'s a WPA2'\n        # Now we must differentiate between WPA and WPA2\n        # In WPA WEPSeed is set to (TSC1 | 0x20) & 0x7f.\n        # In WPA2 WEPSeed=PN1 and TSC1=PN0\n        b = self.get_PN1() == ((self.get_PN0() | 0x20 ) & 0x7f)\n        return (not b and self.get_extIV())",
  "def get_extIV(self):\n        'Return the \\'WPA2 extID\\' field'\n        b = self.header.get_byte(3)\n        return ((b>>5) & 0x1)",
  "def set_extIV(self, value):\n        'Set the \\'WPA2 extID\\' field'\n        # clear the bits\n        mask = (~0x20) & 0xFF\n        masked = self.header.get_byte(3) & mask\n        # set the bits\n        nb = masked | ((value & 0x01) << 5)\n        self.header.set_byte(3, nb)",
  "def get_keyid(self):\n        'Return the \\'WPA2 KEY ID\\' field'\n        b = self.header.get_byte(3)\n        return ((b>>6) & 0x03)",
  "def set_keyid(self, value):\n        'Set the \\'WPA2 KEY ID\\' field'\n        # clear the bits\n        mask = (~0xC0) & 0xFF\n        masked = self.header.get_byte(3) & mask\n        # set the bits\n        nb = masked | ((value & 0x03) << 6)\n        self.header.set_byte(3, nb)",
  "def get_decrypted_data(self):\n        'Return \\'WPA2 Data\\' field decrypted'\n        # TODO: Replace it with the decoded string\n        return self.body_string",
  "def get_PN0(self):\n        'Return the \\'WPA2 PN0\\' field'\n        b = self.header.get_byte(0)\n        return (b & 0xFF)",
  "def set_PN0(self, value):\n        'Set the \\'WPA2 PN0\\' field'\n        # set the bits\n        nb = (value & 0xFF)\n        self.header.set_byte(0, nb)",
  "def get_PN1(self):\n        'Return the \\'WPA2 PN1\\' field'\n        b = self.header.get_byte(1)\n        return (b & 0xFF)",
  "def set_PN1(self, value):\n        'Set the \\'WPA2 PN1\\' field'\n        # set the bits\n        nb = (value & 0xFF)\n        self.header.set_byte(1, nb)",
  "def get_PN2(self):\n        'Return the \\'WPA2 PN2\\' field'\n        b = self.header.get_byte(4)\n        return (b & 0xFF)",
  "def set_PN2(self, value):\n        'Set the \\'WPA2 PN2\\' field'\n        # set the bits\n        nb = (value & 0xFF)\n        self.header.set_byte(4, nb)",
  "def get_PN3(self):\n        'Return the \\'WPA2 PN3\\' field'\n        b = self.header.get_byte(5)\n        return (b & 0xFF)",
  "def set_PN3(self, value):\n        'Set the \\'WPA2 PN3\\' field'\n        # set the bits\n        nb = (value & 0xFF)\n        self.header.set_byte(5, nb)",
  "def get_PN4(self):\n        'Return the \\'WPA2 PN4\\' field'\n        b = self.header.get_byte(6)\n        return (b & 0xFF)",
  "def set_PN4(self, value):\n        'Set the \\'WPA2 PN4\\' field'\n        # set the bits\n        nb = (value & 0xFF)\n        self.header.set_byte(6, nb)",
  "def get_PN5(self):\n        'Return the \\'WPA2 PN5\\' field'\n        b = self.header.get_byte(7)\n        return (b & 0xFF)",
  "def set_PN5(self, value):\n        'Set the \\'WPA2 PN5\\' field'\n        # set the bits\n        nb = (value & 0xFF)\n        self.header.set_byte(7, nb)",
  "def __init__(self, aBuffer = None):\n        header_size = 0\n        tail_size = 8\n\n        ProtocolPacket.__init__(self, header_size, tail_size)\n        if(aBuffer):\n            self.load_packet(aBuffer)",
  "def get_MIC(self):\n        'Return the \\'WPA2Data MIC\\' field'\n        return self.get_tail_as_string()",
  "def set_MIC(self, value):\n        'Set the \\'WPA2Data MIC\\' field'\n        #Padding to 8 bytes with 0x00's \n        value.ljust(8,b'\\x00')\n        #Stripping to 8 bytes\n        value=value[:8]\n        self.tail.set_bytes_from_string(value)",
  "class __RadioTapField(object):\n        ALIGNMENT = 1\n\n        def __str__( self ):\n            return str( self.__class__.__name__ )",
  "class RTF_TSFT(__RadioTapField):\n        BIT_NUMBER = 0\n        STRUCTURE = \"<Q\"\n        ALIGNMENT = 8",
  "class RTF_FLAGS(__RadioTapField):\n        BIT_NUMBER = 1\n        STRUCTURE = \"<B\"\n\n        # https://web.archive.org/web/20160423125307/www.radiotap.org/defined-fields/Flags\n        PROPERTY_CFP            = 0x01 #sent/received during CFP\n        PROPERTY_SHORTPREAMBLE  = 0x02 #sent/received with short preamble\n        PROPERTY_WEP            = 0x04 #sent/received with WEP encryption\n        PROPERTY_FRAGMENTATION  = 0x08 #sent/received with fragmentation\n        PROPERTY_FCS_AT_END     = 0x10 #frame includes FCS\n        PROPERTY_PAYLOAD_PADDING= 0x20 #frame has padding between 802.11 header and payload (to 32-bit boundary)\n        PROPERTY_BAD_FCS        = 0x40 #does not pass FCS check\n        PROPERTY_SHORT_GI       = 0x80",
  "class RTF_RATE(__RadioTapField):\n        BIT_NUMBER = 2\n        STRUCTURE = \"<B\"",
  "class RTF_CHANNEL(__RadioTapField):\n        BIT_NUMBER = 3\n        STRUCTURE = \"<HH\"\n        ALIGNMENT = 2",
  "class RTF_FHSS(__RadioTapField):\n        BIT_NUMBER = 4\n        STRUCTURE = \"<BB\"",
  "class RTF_DBM_ANTSIGNAL(__RadioTapField):\n        BIT_NUMBER = 5\n        STRUCTURE = \"<B\"",
  "class RTF_DBM_ANTNOISE(__RadioTapField):\n        BIT_NUMBER = 6\n        STRUCTURE = \"<B\"",
  "class RTF_LOCK_QUALITY(__RadioTapField):\n        BIT_NUMBER = 7\n        STRUCTURE = \"<H\"\n        ALIGNMENT = 2",
  "class RTF_TX_ATTENUATION(__RadioTapField):\n        BIT_NUMBER = 8\n        STRUCTURE = \"<H\"\n        ALIGNMENT = 2",
  "class RTF_DB_TX_ATTENUATION(__RadioTapField):\n        BIT_NUMBER = 9\n        STRUCTURE = \"<H\"\n        ALIGNMENT = 2",
  "class RTF_DBM_TX_POWER(__RadioTapField):\n        BIT_NUMBER = 10\n        STRUCTURE = \"<b\"\n        ALIGNMENT = 2",
  "class RTF_ANTENNA(__RadioTapField):\n        BIT_NUMBER = 11\n        STRUCTURE = \"<B\"",
  "class RTF_DB_ANTSIGNAL(__RadioTapField):\n        BIT_NUMBER = 12\n        STRUCTURE = \"<B\"",
  "class RTF_DB_ANTNOISE(__RadioTapField):\n        BIT_NUMBER = 13\n        STRUCTURE = \"<B\"",
  "class RTF_FCS_IN_HEADER(__RadioTapField):\n        BIT_NUMBER = 14\n        STRUCTURE = \"<L\"\n        ALIGNMENT = 4",
  "class RTF_TX_FLAGS(__RadioTapField):\n        BIT_NUMBER = 15\n        STRUCTURE = \"<H\"\n        ALIGNMENT = 2",
  "class RTF_RTS_RETRIES(__RadioTapField):\n        BIT_NUMBER = 16\n        STRUCTURE = \"<B\"",
  "class RTF_DATA_RETRIES(__RadioTapField):\n        BIT_NUMBER = 17\n        STRUCTURE = \"<B\"",
  "class RTF_XCHANNEL(__RadioTapField):\n        BIT_NUMBER = 18\n        STRUCTURE = \"<LHBB\"\n        ALIGNMENT = 4",
  "class RTF_EXT(__RadioTapField):\n        BIT_NUMBER = 31\n        STRUCTURE = []",
  "def __init__(self, aBuffer = None):\n        header_size = self.__HEADER_BASE_SIZE \n        tail_size = 0\n        \n        if aBuffer:\n            length = struct.unpack('<H', aBuffer[2:4])[0]\n            header_size=length\n                    \n            ProtocolPacket.__init__(self, header_size, tail_size)\n            self.load_packet(aBuffer)\n        else:\n            ProtocolPacket.__init__(self, header_size, tail_size)\n            self.set_version(0)\n            self.__set_present(0x00000000)",
  "def get_header_length(self):\n        'Return the RadioTap header \\'length\\' field'\n        self.__update_header_length()        \n        return self.header.get_word(2, \"<\")",
  "def get_version(self):\n        'Return the \\'version\\' field'\n        b = self.header.get_byte(0)\n        return b",
  "def set_version(self, value):\n        'Set the \\'version\\' field'\n        nb = (value & 0xFF)\n        self.header.set_byte(0, nb)\n        \n        nb = (value & 0xFF)",
  "def get_present(self, offset=_BASE_PRESENT_FLAGS_OFFSET):\n        \"Return RadioTap present bitmap field\"\n        present = self.header.get_long(offset, \"<\")\n        return present",
  "def __set_present(self, value):\n        \"Set RadioTap present field bit\"\n        self.header.set_long(4, value)",
  "def get_present_bit(self, field, offset=4):\n        'Get a \\'present\\' field bit'\n        present=self.get_present(offset)\n        return not not (2**field.BIT_NUMBER & present)",
  "def __set_present_bit(self, field):\n        'Set a \\'present\\' field bit'\n        npresent=2**field.BIT_NUMBER | self.get_present()\n        self.header.set_long(4, npresent,'<')",
  "def __unset_present_bit(self, field):\n        'Unset a \\'present\\' field bit'\n        npresent=~(2**field.BIT_NUMBER) & self.get_present()\n        self.header.set_long(4, npresent,'<')",
  "def __align(self, val, align):\n        return ( (((val) + ((align) - 1)) & ~((align) - 1)) - val )",
  "def __get_field_position(self, field):\n\n        offset = RadioTap._BASE_PRESENT_FLAGS_OFFSET\n        extra_present_flags_count = 0\n        while self.get_present_bit(RadioTap.RTF_EXT, offset):\n            offset += RadioTap._PRESENT_FLAGS_SIZE\n            extra_present_flags_count += 1\n\n        field_position = self.__HEADER_BASE_SIZE + (RadioTap._BASE_PRESENT_FLAGS_OFFSET * extra_present_flags_count)\n\n        for f in self.radiotap_fields:\n            field_position += self.__align(field_position, f.ALIGNMENT)\n            if f == field:\n                return field_position\n\n            if self.get_present_bit(f):\n                total_length = struct.calcsize(f.STRUCTURE)\n                field_position += total_length\n\n        return None",
  "def unset_field( self, field):\n        is_present=self.get_present_bit(field)\n        if is_present is False:\n            return False\n                \n        byte_pos=self.__get_field_position(field)\n        if not byte_pos:\n            return False\n\n        self.__unset_present_bit(field)\n\n        header=self.get_header_as_string()\n        total_length = struct.calcsize(field.STRUCTURE)\n        header=header[:byte_pos]+header[byte_pos+total_length:]\n        \n        self.load_header(header)",
  "def __get_field_values( self, field ):\n        is_present=self.get_present_bit(field)\n        if is_present is False:\n            return None\n        \n        byte_pos=self.__get_field_position(field)\n        header=self.get_header_as_string()\n        total_length=struct.calcsize(field.STRUCTURE)\n        v=header[ byte_pos:byte_pos+total_length ]\n        \n        field_values = struct.unpack(field.STRUCTURE, v)\n        \n        return field_values",
  "def __set_field_values( self, field, values ):\n        if not hasattr(values,'__iter__'):\n            raise Exception(\"arg 'values' is not iterable\")\n        \n        # It's for to known the qty of argument of a structure\n        num_fields=len(''.join(c for c in field.STRUCTURE if c not in '=@!<>'))\n\n        if len(values)!=num_fields:\n            raise Exception(\"Field %s has exactly %d items\"%(str(field),struct.calcsize(field.STRUCTURE)))\n        \n        is_present=self.get_present_bit(field)\n        if is_present is False:\n            self.__set_present_bit(field)\n        \n        byte_pos=self.__get_field_position(field)\n        header=self.get_header_as_string()\n        total_length=struct.calcsize(field.STRUCTURE)\n\n        new_str = struct.pack(field.STRUCTURE, *values)\n\n        if is_present is True:\n            header=header[:byte_pos]+new_str+header[byte_pos+total_length:]\n        else:\n            header=header[:byte_pos]+new_str+header[byte_pos:]\n        self.load_header(header)",
  "def set_tsft( self, nvalue ):\n        \"Set the Value in microseconds of the MAC's 64-bit 802.11 \"\\\n        \"Time Synchronization Function timer when the first bit of \"\\\n        \"the MPDU arrived at the MAC\"\n        self.__set_field_values(RadioTap.RTF_TSFT, [nvalue])",
  "def get_tsft( self ):\n        \"Get the Value in microseconds of the MAC's 64-bit 802.11 \"\\\n        \"Time Synchronization Function timer when the first bit of \"\\\n        \"the MPDU arrived at the MAC\"\n        \n        values=self.__get_field_values(RadioTap.RTF_TSFT)\n        if not values:\n            return None\n        return values[0]",
  "def set_flags( self, nvalue ):\n        \"Set the properties of transmitted and received frames.\"\n        self.__set_field_values(self.RTF_FLAGS, [nvalue])",
  "def get_flags( self ):\n        \"Get the properties of transmitted and received frames.\"\n        values=self.__get_field_values(self.RTF_FLAGS)\n        if not values:\n            return None\n        return values[0]",
  "def set_rate( self, nvalue ):\n        \"Set the TX/RX data rate in 500 Kbps units\" \n        \n        self.__set_field_values(self.RTF_RATE, [nvalue])",
  "def get_rate( self ):\n        \"Get the TX/RX data rate in 500 Kbps units\" \n\n        values=self.__get_field_values(self.RTF_RATE)\n        if not values:\n            return None\n        return values[0]",
  "def set_channel( self, freq, flags ):\n        \"Set the channel Tx/Rx frequency in MHz and the channel flags\" \n\n        self.__set_field_values(self.RTF_CHANNEL, [freq, flags])",
  "def get_channel( self ):\n        \"Get the TX/RX data rate in 500 Kbps units\" \n\n        values=self.__get_field_values(self.RTF_CHANNEL)\n\n        return values",
  "def set_FHSS( self, hop_set, hop_pattern ):\n        \"Set the hop set and pattern for frequency-hopping radios\" \n\n        self.__set_field_values(self.RTF_FHSS, [hop_set, hop_pattern])",
  "def get_FHSS( self ):\n        \"Get the hop set and pattern for frequency-hopping radios\" \n\n        values=self.__get_field_values(self.RTF_FHSS)\n\n        return values",
  "def set_dBm_ant_signal( self, signal ):\n        \"Set the RF signal power at the antenna, decibel difference from an \"\\\n        \"arbitrary, fixed reference.\" \n\n        self.__set_field_values(self.RTF_DBM_ANTSIGNAL, [signal])",
  "def get_dBm_ant_signal( self ):\n        \"Get the RF signal power at the antenna, decibel difference from an \"\\\n        \"arbitrary, fixed reference.\" \n\n        values=self.__get_field_values(self.RTF_DBM_ANTSIGNAL)\n        if not values:\n            return None\n        return values[0]",
  "def set_dBm_ant_noise( self, signal ):\n        \"Set the RF noise power at the antenna, decibel difference from an \"\\\n        \"arbitrary, fixed reference.\"\n\n        self.__set_field_values(self.RTF_DBM_ANTNOISE, [signal])",
  "def get_dBm_ant_noise( self ):\n        \"Get the RF noise power at the antenna, decibel difference from an \"\\\n        \"arbitrary, fixed reference.\"\n\n        values=self.__get_field_values(self.RTF_DBM_ANTNOISE)\n        if not values:\n            return None\n        return values[0]",
  "def set_lock_quality( self, quality ):\n        \"Set the quality of Barker code lock. \"\\\n        \"Called 'Signal Quality' in datasheets. \"\n\n        self.__set_field_values(self.RTF_LOCK_QUALITY, [quality])",
  "def get_lock_quality( self ):\n        \"Get the quality of Barker code lock. \"\\\n        \"Called 'Signal Quality' in datasheets. \"\n        \n        values=self.__get_field_values(self.RTF_LOCK_QUALITY)\n        if not values:\n            return None\n        return values[0]",
  "def set_tx_attenuation( self, power ):\n        \"Set the transmit power expressed as unitless distance from max power \"\\\n        \"set at factory calibration. 0 is max power.\"\n\n        self.__set_field_values(self.RTF_TX_ATTENUATION, [power])",
  "def get_tx_attenuation( self ):\n        \"Set the transmit power expressed as unitless distance from max power \"\\\n        \"set at factory calibration. 0 is max power.\"\n        \n        values=self.__get_field_values(self.RTF_TX_ATTENUATION)\n        if not values:\n            return None\n        return values[0]",
  "def set_dB_tx_attenuation( self, power ):\n        \"Set the transmit power expressed as decibel distance from max power \"\\\n        \"set at factory calibration. 0 is max power. \"\n\n        self.__set_field_values(self.RTF_DB_TX_ATTENUATION, [power])",
  "def get_dB_tx_attenuation( self ):\n        \"Set the transmit power expressed as decibel distance from max power \"\\\n        \"set at factory calibration. 0 is max power. \"\n        \n        values=self.__get_field_values(self.RTF_DB_TX_ATTENUATION)\n        if not values:\n            return None\n        return values[0]",
  "def set_dBm_tx_power( self, power ):\n        \"Set the transmit power expressed as dBm (decibels from a 1 milliwatt\"\\\n        \" reference). This is the absolute power level measured at the \"\\\n        \"antenna port.\"\n        \n        self.__set_field_values(self.RTF_DBM_TX_POWER, [power])",
  "def get_dBm_tx_power( self ):\n        \"Get the transmit power expressed as dBm (decibels from a 1 milliwatt\"\\\n        \" reference). This is the absolute power level measured at the \"\\\n        \"antenna port.\"\n        \n        values=self.__get_field_values(self.RTF_DBM_TX_POWER)\n        if not values:\n            return None\n        return values[0]",
  "def set_antenna( self, antenna_index ):\n        \"Set Rx/Tx antenna index for this packet. \"\\\n        \"The first antenna is antenna 0. \"\\\n        \n        self.__set_field_values(self.RTF_ANTENNA, [antenna_index])",
  "def get_antenna( self ):\n        \"Set Rx/Tx antenna index for this packet. \"\\\n        \"The first antenna is antenna 0. \"\\\n        \n        values=self.__get_field_values(self.RTF_ANTENNA)\n        if not values:\n            return None\n        return values[0]",
  "def set_dB_ant_signal( self, signal ):\n        \"Set the RF signal power at the antenna, decibel difference from an \"\\\n        \"arbitrary, fixed reference.\" \n\n        self.__set_field_values(self.RTF_DB_ANTSIGNAL, [signal])",
  "def get_dB_ant_signal( self ):\n        \"Get the RF signal power at the antenna, decibel difference from an \"\\\n        \"arbitrary, fixed reference.\" \n\n        values=self.__get_field_values(self.RTF_DB_ANTSIGNAL)\n        if not values:\n            return None\n        return values[0]",
  "def set_dB_ant_noise( self, signal ):\n        \"Set the RF noise power at the antenna, decibel difference from an \"\\\n        \"arbitrary, fixed reference.\" \n\n        self.__set_field_values(self.RTF_DB_ANTNOISE, [signal])",
  "def get_dB_ant_noise( self ):\n        \"Get the RF noise power at the antenna, decibel difference from an \"\\\n        \"arbitrary, fixed reference.\" \n\n        values=self.__get_field_values(self.RTF_DB_ANTNOISE)\n        if not values:\n            return None\n        return values[0]",
  "def set_FCS_in_header( self, fcs ):\n        \"Set the Field containing the FCS of the frame (instead of it being \"\\\n        \"appended to the frame as it would appear on the air.) \" \n\n        self.__set_field_values(self.RTF_FCS_IN_HEADER, [fcs])",
  "def get_FCS_in_header( self ):\n        \"Get the Field containing the FCS of the frame (instead of it being \"\\\n        \"appended to the frame as it would appear on the air.) \" \n\n        values=self.__get_field_values(self.RTF_FCS_IN_HEADER)\n        if not values:\n            return None\n        return values[0]",
  "def set_RTS_retries( self, retries):\n        \"Set the number of RTS retries a transmitted frame used.\" \n        \n        self.__set_field_values(self.RTF_RTS_RETRIES, [retries])",
  "def get_RTS_retries( self ):\n        \"Get the number of RTS retries a transmitted frame used.\" \n        \n        values=self.__get_field_values(self.RTF_RTS_RETRIES)\n        if not values:\n            return None\n        return values[0]",
  "def set_tx_flags( self, flags ):\n        \"Set the properties of transmitted frames.\" \n\n        self.__set_field_values(self.RTF_TX_FLAGS, [flags])",
  "def get_tx_flags( self ):\n        \"Get the properties of transmitted frames.\" \n\n        values=self.__get_field_values(self.RTF_TX_FLAGS)\n        if not values:\n            return None\n        return values[0]",
  "def set_xchannel( self, flags, freq, channel, maxpower ):\n        \"Set extended channel information: flags, freq, channel and maxpower\" \n        \n        self.__set_field_values(self.RTF_XCHANNEL, [flags, freq, channel, maxpower] )",
  "def get_xchannel( self ):\n        \"Get extended channel information: flags, freq, channel and maxpower\" \n        \n        values=self.__get_field_values(field=self.RTF_XCHANNEL)\n\n        return values",
  "def set_data_retries( self, retries ):\n        \"Set the number of data retries a transmitted frame used.\" \n\n        self.__set_field_values(self.RTF_DATA_RETRIES, [retries])",
  "def get_data_retries( self ):\n        \"Get the number of data retries a transmitted frame used.\" \n\n        values=self.__get_field_values(self.RTF_DATA_RETRIES)\n        if not values:\n            return None\n        return values[0]",
  "def set_hardware_queue( self, queue ):\n        \"Set the hardware queue to send the frame on.\" \n\n        self.__set_field_values(self.RTF_HARDWARE_QUEUE, [queue])",
  "def __update_header_length(self):\n        'Update the RadioTap header length field with the real size'\n        self.header.set_word(2, self.get_header_size(), \"<\")",
  "def get_packet(self):\n        self.__update_header_length()\n        return ProtocolPacket.get_packet(self)",
  "def __init__(self, aBuffer = None):\n        header_size = 22\n        tail_size = 0\n\n        ProtocolPacket.__init__(self, header_size, tail_size)\n        if(aBuffer):\n            self.load_packet(aBuffer)",
  "def get_duration(self):\n        'Return 802.11 Management frame \\'Duration\\' field'\n        b = self.header.get_word(0, \"<\")\n        return b",
  "def set_duration(self, value):\n        'Set the 802.11 Management frame \\'Duration\\' field' \n        # set the bits\n        nb = value & 0xFFFF\n        self.header.set_word(0, nb, \"<\")",
  "def get_destination_address(self):\n        'Return 802.11 Management frame \\'Destination Address\\' field as a 6 bytes array'\n        return self.header.get_bytes()[2:8]",
  "def set_destination_address(self, value):\n        'Set 802.11 Management frame \\'Destination Address\\' field as a 6 bytes array'\n        for i in range(0, 6):\n            self.header.set_byte(2+i, value[i])",
  "def get_source_address(self):\n        'Return 802.11 Management frame \\'Source Address\\' field as a 6 bytes array'\n        return self.header.get_bytes()[8:14]",
  "def set_source_address(self, value):\n        'Set 802.11 Management frame \\'Source Address\\' field as a 6 bytes array'\n        for i in range(0, 6):\n            self.header.set_byte(8+i, value[i])",
  "def get_bssid(self):\n        'Return 802.11 Management frame \\'BSSID\\' field as a 6 bytes array'\n        return self.header.get_bytes()[14: 20]",
  "def set_bssid(self, value):\n        'Set 802.11 Management frame \\'BSSID\\' field as a 6 bytes array'\n        for i in range(0, 6):\n            self.header.set_byte(14+i, value[i])",
  "def get_sequence_control(self):\n        'Return 802.11 Management frame \\'Sequence Control\\' field'\n        b = self.header.get_word(20, \"<\")\n        return b",
  "def set_sequence_control(self, value):\n        'Set the 802.11 Management frame \\'Sequence Control\\' field' \n        # set the bits\n        nb = value & 0xFFFF\n        self.header.set_word(20, nb, \"<\")",
  "def get_fragment_number(self):\n        'Return 802.11 Management frame \\'Fragment Number\\' subfield'\n\n        b = self.get_sequence_control()\n        return (b&0x000F)",
  "def set_fragment_number(self, value):\n        'Set the 802.11 Management frame \\'Fragment Number\\' subfield' \n        # clear the bits\n        mask = (~0x000F) & 0xFFFF\n        masked = self.header.get_word(20, \"<\") & mask\n        # set the bits \n        nb = masked | (value & 0x000F)\n        self.header.set_word(20, nb, \"<\")",
  "def get_sequence_number(self):\n        'Return 802.11 Management frame \\'Sequence Number\\' subfield'\n        \n        b = self.get_sequence_control()\n        return ((b>>4) & 0xFFF)",
  "def set_sequence_number(self, value):\n        'Set the 802.11 Management frame \\'Sequence Number\\' subfield' \n        # clear the bits\n        mask = (~0xFFF0) & 0xFFFF\n        masked = self.header.get_word(20, \"<\") & mask\n        # set the bits \n        nb = masked | ((value & 0x0FFF ) << 4 ) \n        self.header.set_word(20, nb, \"<\")",
  "def get_frame_body(self):\n        'Return 802.11 Management frame \\'Frame Body\\' field'\n        \n        return self.get_body_as_string()",
  "def set_frame_body(self, data):\n        'Set 802.11 Management frame \\'Frame Body\\' field'\n        \n        self.load_body(data)",
  "def __init__(self, header_size, tail_size, aBuffer = None):\n        self.__HEADER_BASE_SIZE=header_size\n        \n        if aBuffer:\n            elements_length=self.__calculate_elements_length(aBuffer[self.__HEADER_BASE_SIZE:])\n            header_size+=elements_length\n            \n            ProtocolPacket.__init__(self, header_size, tail_size)\n            self.load_packet(aBuffer)\n        else:\n            ProtocolPacket.__init__(self, header_size, tail_size)",
  "def _find_element(self, elements, element_id ):\n        remaining=len(elements)\n        \n        offset=0\n        while remaining > 0:\n            (id,length)=struct.unpack(\"!BB\",elements[offset:offset+2])\n            if element_id is None:\n                pass # through the whole list returning the length\n            elif id==element_id:\n                yield (0,offset,length+2)    # ==\n            length+=2 #id+length\n            offset+=length\n            if length>remaining:\n                # Error!!\n                length = remaining\n            remaining-=length\n        # < Not found\n        yield (-1, offset, None)",
  "def __calculate_elements_length(self, elements):\n        gen_tp=self._find_element(elements, None )\n        (match,offset,length)=next(gen_tp)\n        if match != -1:\n            # element_id is None, then __find_tagged_parameter must return -1\n            raise Exception(\"Internal Error %s\"%match)\n        return offset",
  "def _get_elements_generator(self, element_id):\n        elements=self.get_header_as_string()[self.__HEADER_BASE_SIZE:]\n        gen_tp=self._find_element(elements, element_id )\n        while True:\n            (match,offset,length)=next(gen_tp)\n            if match != 0:\n                return\n            value_offset=offset+2\n            value_end=offset+length\n            value=elements[value_offset:value_end]\n            yield value",
  "def _get_element(self, element_id):\n        gen_get_element=self._get_elements_generator(element_id)\n        try:\n            s=next(gen_get_element)\n            \n            if s is None:\n                raise Exception(\"gen_get_element salio con None in _get_element!!!\")\n            \n            return s\n        except StopIteration:\n            pass\n            \n        return None",
  "def delete_element(self, element_id, multiple = False):\n        header=self.get_header_as_string()\n        elements=header[self.__HEADER_BASE_SIZE:]\n        gen_tp=self._find_element(elements, element_id )\n        found=False\n        while True:\n            (match,offset,length)=next(gen_tp)\n            if match != 0:\n                break\n            start=self.__HEADER_BASE_SIZE+offset\n            header=header[:start]+header[start+length:]\n            found=True\n            if multiple is False:\n                break\n            \n        if not found:\n            return  False\n        \n        self.load_header(header)\n        return True",
  "def _set_element(self, element_id, value, replace = True):\n        parameter=struct.pack('BB%ds'%len(value),element_id,len(value),value)\n        \n        header=self.get_header_as_string()\n        elements=header[self.__HEADER_BASE_SIZE:]\n        gen_tp=self._find_element(elements, element_id )\n        found=False\n        while True:\n            (match,offset,length)=next(gen_tp)\n            start=self.__HEADER_BASE_SIZE+offset\n            if match == 0 and replace:\n                # Replace\n                header=header[:start]+parameter+header[start+length:]\n                found=True\n                break\n            elif match > 0:\n                # Add\n                header=header[:start]+parameter+header[start:]\n                found=True\n                break\n            else:\n                break\n        if not found:\n            # Append (found<0 Not found)\n            header=header+parameter        \n        self.load_header(header)",
  "def __init__(self, aBuffer = None):\n        header_size = self.__HEADER_BASE_SIZE\n        tail_size = 0\n        Dot11ManagementHelper.__init__(self, header_size, tail_size, aBuffer)",
  "def get_timestamp(self):\n        'Return the 802.11 Management Beacon frame \\'Timestamp\\' field' \n        b = self.header.get_long_long(0, \"<\")\n        return b",
  "def set_timestamp(self, value):\n        'Set the 802.11 Management Beacon frame \\'Timestamp\\' field' \n        # set the bits\n        nb = value & 0xFFFFFFFFFFFFFFFF\n        self.header.set_long_long(0, nb, \"<\")",
  "def get_beacon_interval(self):\n        'Return the 802.11 Management Beacon frame \\'Beacon Interval\\' field' \\\n        'To convert it to seconds =>  secs = Beacon_Interval*1024/1000000'\n\n        b = self.header.get_word(8, \"<\")\n        return b",
  "def set_beacon_interval(self, value):\n        'Set the 802.11 Management Beacon frame \\'Beacon Interval\\' field' \n        # set the bits\n        nb = value & 0xFFFF\n        self.header.set_word(8, nb, \"<\")",
  "def get_capabilities(self):\n        'Return the 802.11 Management Beacon frame \\'Capability information\\' field. '\n        \n        b = self.header.get_word(10, \"<\")\n        return b",
  "def set_capabilities(self, value):\n        'Set the 802.11 Management Beacon frame \\'Capability Information\\' field' \n        # set the bits\n        nb = value & 0xFFFF\n        self.header.set_word(10, nb, \"<\")",
  "def get_ssid(self):\n        \"Get the 802.11 Management SSID element. \"\\\n        \"The SSID element indicates the identity of an ESS or IBSS.\"\n        return self._get_element(DOT11_MANAGEMENT_ELEMENTS.SSID)",
  "def set_ssid(self, ssid):\n        self._set_element(DOT11_MANAGEMENT_ELEMENTS.SSID,ssid)",
  "def get_supported_rates(self, human_readable=False):\n        \"Get the 802.11 Management Supported Rates element. \"\\\n        \"Specifies up to eight rates, then an Extended Supported Rate element \"\\\n        \"shall be generated to specify the remaining supported rates.\"\\\n        \"If human_readable is True, the rates are returned in Mbit/sec\"\n        s=self._get_element(DOT11_MANAGEMENT_ELEMENTS.SUPPORTED_RATES)\n        if s is None:\n            return None\n        \n        rates=struct.unpack('%dB'%len(s),s)\n        if not human_readable:\n            return rates\n            \n        rates_Mbs=tuple([(x&0x7F)*0.5 for x in rates])\n        return rates_Mbs",
  "def set_supported_rates(self, rates):\n        \"Set the 802.11 Management Supported Rates element. \"\\\n        \"Specifies a tuple or list with up to eight rates, then an \"\\\n        \"Extended Supported Rate element shall be generated to specify \"\\\n        \"the remaining supported rates.\"\n        qty_rates=len(rates)\n        if qty_rates>8:\n            raise Exception(\"requires up to eight rates\")\n        rates_string=struct.pack('B'*qty_rates,*rates)\n        self._set_element(DOT11_MANAGEMENT_ELEMENTS.SUPPORTED_RATES,rates_string)",
  "def get_ds_parameter_set(self):\n        \"Get the 802.11 Management DS Parameter set element. \"\\\n        \"Contains information to allow channel number identification for \"\\\n        \"STAs using a DSSS PHY.\"\n        s=self._get_element(DOT11_MANAGEMENT_ELEMENTS.DS_PARAMETER_SET)\n        if s is None:\n            return None\n        \n        (ch,)=struct.unpack('B',s)\n\n        return ch",
  "def set_ds_parameter_set(self, channel):\n        \"Set the 802.11 Management DS Parameter set element. \"\\\n        \"Contains information to allow channel number identification for \"\\\n        \"STAs using a DSSS PHY.\"\n        channel_string=struct.pack('B',channel)\n        self._set_element(DOT11_MANAGEMENT_ELEMENTS.DS_PARAMETER_SET,channel_string)",
  "def get_rsn(self):\n        \"Get the 802.11 Management Robust Security Network element.\"\n        s = self._get_element(DOT11_MANAGEMENT_ELEMENTS.RSN)\n        if s is None:\n            return None\n        return s",
  "def set_rsn(self, data):\n        \"Set the 802.11 Management Robust Security Network element.\"\n        self._set_element(DOT11_MANAGEMENT_ELEMENTS.RSN, data)",
  "def get_erp(self):\n        \"Get the 802.11 Management ERP (extended rate PHY) Information element.\"\n        s = self._get_element(DOT11_MANAGEMENT_ELEMENTS.ERP_INFO)\n        if s is None:\n            return None\n\n        (erp,) = struct.unpack('B',s)\n        \n        return erp",
  "def set_erp(self, erp):\n        \"Set the 802.11 Management ERP (extended rate PHY) Inforamation \"\\\n        \"element.\"\n        erp_string = struct.pack('B',erp)\n        self._set_element(DOT11_MANAGEMENT_ELEMENTS.ERP_INFO, erp_string)",
  "def get_country(self):\n        \"Get the 802.11 Management Country element.\" \\\n        \"Returns a tuple containing Country code, first channel number, \"\\\n        \"number of channels and maximum transmit power level\"\n        s = self._get_element(DOT11_MANAGEMENT_ELEMENTS.COUNTRY)\n        if s is None:\n            return None\n\n        code, first, num, max = struct.unpack('3sBBB',s)\n        code = code.strip(' ')\n        return code, first, num, max",
  "def set_country(self, code, first_channel, number_of_channels, max_power):\n        \"Set the 802.11 Management Country element.\"\n        if len(code) > 3:\n            raise Exception(\"Country code must be up to 3 bytes long\")\n\n        #Padding the country code\n        code += ' ' * (3-len(code))\n\n        country_string = struct.pack('3sBBB', code, first_channel,\n                number_of_channels, max_power)\n        self._set_element(DOT11_MANAGEMENT_ELEMENTS.COUNTRY, country_string)",
  "def get_vendor_specific(self):\n        \"Get the 802.11 Management Vendor Specific elements \"\\\n        \"as a list of tuples.\"\n        \"The Vendor Specific information element is used to carry \"\\\n        \"information not defined in the standard within a single \"\\\n        \"defined format\"\n        \n        vs=[]\n        gen_get_element=self._get_elements_generator(DOT11_MANAGEMENT_ELEMENTS.VENDOR_SPECIFIC)\n        try:\n            while 1:\n                s=next(gen_get_element)\n                \n                if s is None:\n                    raise Exception(\"gen_get_element salio con None!!!\")\n                \n                # OUI is 3 bytes\n                oui=s[:3]\n                data=s[3:]\n                vs.append((oui,data))\n        except StopIteration:\n            pass\n            \n        return vs",
  "def add_vendor_specific(self, oui, data):\n        \"Set the 802.11 Management Vendor Specific element. \"\\\n        \"The Vendor Specific information element is used to carry \"\\\n        \"information not defined in the standard within a single \"\\\n        \"defined format\"\n        \n        # 3 is the OUI length\n        max_data_len=255-3\n        data_len=len(data)\n\n        if data_len>max_data_len:\n            raise Exception(\"data allow up to %d bytes long\" % max_data_len)\n        if len(oui) > 3:\n            raise Exception(\"oui is three bytes long\")\n        \n        self._set_element(DOT11_MANAGEMENT_ELEMENTS.VENDOR_SPECIFIC,oui+data, replace=False)",
  "def __init__(self, aBuffer = None):\n        header_size = 0\n        tail_size = 0\n        Dot11ManagementHelper.__init__(self, header_size, tail_size, aBuffer)",
  "def get_ssid(self):\n        \"Get the 802.11 Management SSID element. \"\\\n        \"The SSID element indicates the identity of an ESS or IBSS.\"\n        return self._get_element(DOT11_MANAGEMENT_ELEMENTS.SSID)",
  "def set_ssid(self, ssid):\n        self._set_element(DOT11_MANAGEMENT_ELEMENTS.SSID,ssid)",
  "def get_supported_rates(self, human_readable=False):\n        \"Get the 802.11 Management Supported Rates element. \"\\\n        \"Specifies up to eight rates, then an Extended Supported Rate element \"\\\n        \"shall be generated to specify the remaining supported rates.\"\\\n        \"If human_readable is True, the rates are returned in Mbit/sec\"\n        s=self._get_element(DOT11_MANAGEMENT_ELEMENTS.SUPPORTED_RATES)\n        if s is None:\n            return None\n        \n        rates=struct.unpack('%dB'%len(s),s)\n        if not human_readable:\n            return rates\n            \n        rates_Mbs=tuple([(x&0x7F)*0.5 for x in rates])\n        return rates_Mbs",
  "def set_supported_rates(self, rates):\n        \"Set the 802.11 Management Supported Rates element. \"\\\n        \"Specifies a tuple or list with up to eight rates, then an \"\\\n        \"Extended Supported Rate element shall be generated to specify \"\\\n        \"the remaining supported rates.\"\n        qty_rates=len(rates)\n        if qty_rates>8:\n            raise Exception(\"requires up to eight rates\")\n        rates_string=struct.pack('B'*qty_rates,*rates)\n        self._set_element(DOT11_MANAGEMENT_ELEMENTS.SUPPORTED_RATES,rates_string)",
  "def __init__(self, aBuffer = None):\n        Dot11ManagementBeacon.__init__(self, aBuffer)",
  "def __init__(self, aBuffer = None):\n        header_size = 2\n        tail_size = 0\n        if aBuffer:\n            ProtocolPacket.__init__(self, header_size, tail_size)\n            self.load_packet(aBuffer)\n        else:\n            ProtocolPacket.__init__(self, header_size, tail_size)",
  "def get_reason_code(self):\n        \"Get the 802.11 Management Deauthentication or Disassociation Code.\"\n        return self.header.get_word(0, \"<\")",
  "def set_reason_code(self, rc):\n        self.header.set_word(0, rc, \"<\")",
  "def __init__(self, aBuffer = None):\n        header_size = self.__HEADER_BASE_SIZE\n        tail_size = 0\n        Dot11ManagementHelper.__init__(self, header_size, tail_size, aBuffer)",
  "def get_authentication_algorithm(self):\n        \"Get the 802.11 Management Authentication Algorithm.\"\n        return self.header.get_word(0, \"<\")",
  "def set_authentication_algorithm(self, algorithm):\n        \"Set the 802.11 Management Authentication Algorithm.\"\n        self.header.set_word(0, algorithm, \"<\")",
  "def get_authentication_sequence(self):\n        \"Get the 802.11 Management Authentication Sequence.\"\n        return self.header.get_word(2, \"<\")",
  "def set_authentication_sequence(self, seq):\n        \"Set the 802.11 Management Authentication Sequence.\"\n        self.header.set_word(2, seq, \"<\")",
  "def get_authentication_status(self):\n        \"Get the 802.11 Management Authentication Status.\"\n        return self.header.get_word(4, \"<\")",
  "def set_authentication_status(self, status):\n        \"Set the 802.11 Management Authentication Status.\"\n        self.header.set_word(4, status, \"<\")",
  "def get_challenge_text(self):\n        return self._get_element(DOT11_MANAGEMENT_ELEMENTS.CHALLENGE_TEXT)",
  "def set_challenge_text(self, challenge):\n        self._set_element(DOT11_MANAGEMENT_ELEMENTS.CHALLENGE_TEXT, challenge)",
  "def get_vendor_specific(self):\n        \"Get the 802.11 Management Vendor Specific elements \"\\\n        \"as a list of tuples.\"\n        \"The Vendor Specific information element is used to carry \"\\\n        \"information not defined in the standard within a single \"\\\n        \"defined format\"\n        \n        vs=[]\n        gen_get_element=self._get_elements_generator(DOT11_MANAGEMENT_ELEMENTS.VENDOR_SPECIFIC)\n        try:\n            while 1:\n                s=next(gen_get_element)\n                \n                if s is None:\n                    raise Exception(\"gen_get_element salio con None!!!\")\n                \n                # OUI is 3 bytes\n                oui=s[:3]\n                data=s[3:]\n                vs.append((oui,data))\n        except StopIteration:\n            pass\n            \n        return vs",
  "def add_vendor_specific(self, oui, data):\n        \"Set the 802.11 Management Vendor Specific element. \"\\\n        \"The Vendor Specific information element is used to carry \"\\\n        \"information not defined in the standard within a single \"\\\n        \"defined format\"\n        \n        # 3 is the OUI length\n        max_data_len=255-3\n        data_len=len(data)\n\n        if data_len>max_data_len:\n            raise Exception(\"data allow up to %d bytes long\" % max_data_len)\n        if len(oui) > 3:\n            raise Exception(\"oui is three bytes long\")\n        \n        self._set_element(DOT11_MANAGEMENT_ELEMENTS.VENDOR_SPECIFIC,oui+data, replace=False)",
  "def __init__(self, aBuffer = None):\n        Dot11ManagementDeauthentication.__init__(self, aBuffer)",
  "def __init__(self, aBuffer = None):\n        header_size = self.__HEADER_BASE_SIZE\n        tail_size = 0\n        Dot11ManagementHelper.__init__(self, header_size, tail_size, aBuffer)",
  "def get_capabilities(self):\n        'Return the 802.11 Management Association Request Frame \\'Capability information\\' field. '\n        b = self.header.get_word(0, \"<\")\n        return b",
  "def set_capabilities(self, value):\n        'Set the 802.11 Management Association Request Frame \\'Capability Information\\' field' \n        # set the bits\n        nb = value & 0xFFFF\n        self.header.set_word(0, nb, \"<\")",
  "def get_listen_interval(self):\n        'Return the 802.11 Management Association Request Frame \\'Listen Interval\\' field. '\n        b = self.header.get_word(2, \"<\")\n        return b",
  "def set_listen_interval(self, value):\n        'Set the 802.11 Management Association Request Frame \\'Listen Interval\\' field' \n        self.header.set_word(2, value, \"<\")",
  "def get_ssid(self):\n        \"Get the 802.11 Management SSID element. \"\\\n        \"The SSID element indicates the identity of an ESS or IBSS.\"\n        return self._get_element(DOT11_MANAGEMENT_ELEMENTS.SSID)",
  "def set_ssid(self, ssid):\n        self._set_element(DOT11_MANAGEMENT_ELEMENTS.SSID,ssid)",
  "def get_supported_rates(self, human_readable=False):\n        \"Get the 802.11 Management Supported Rates element. \"\\\n        \"Specifies up to eight rates, then an Extended Supported Rate element \"\\\n        \"shall be generated to specify the remaining supported rates.\"\\\n        \"If human_readable is True, the rates are returned in Mbit/sec\"\n        s=self._get_element(DOT11_MANAGEMENT_ELEMENTS.SUPPORTED_RATES)\n        if s is None:\n            return None\n        \n        rates=struct.unpack('%dB'%len(s),s)\n        if not human_readable:\n            return rates\n            \n        rates_Mbs=tuple([(x&0x7F)*0.5 for x in rates])\n        return rates_Mbs",
  "def set_supported_rates(self, rates):\n        \"Set the 802.11 Management Supported Rates element. \"\\\n        \"Specifies a tuple or list with up to eight rates, then an \"\\\n        \"Extended Supported Rate element shall be generated to specify \"\\\n        \"the remaining supported rates.\"\n        qty_rates=len(rates)\n        if qty_rates>8:\n            raise Exception(\"requires up to eight rates\")\n        rates_string=struct.pack('B'*qty_rates,*rates)\n        self._set_element(DOT11_MANAGEMENT_ELEMENTS.SUPPORTED_RATES,rates_string)",
  "def get_rsn(self):\n        \"Get the 802.11 Management Robust Security Network element.\"\n        s = self._get_element(DOT11_MANAGEMENT_ELEMENTS.RSN)\n        if s is None:\n            return None\n        return s",
  "def set_rsn(self, data):\n        \"Set the 802.11 Management Robust Security Network element.\"\n        self._set_element(DOT11_MANAGEMENT_ELEMENTS.RSN, data)",
  "def get_vendor_specific(self):\n        \"Get the 802.11 Management Vendor Specific elements \"\\\n        \"as a list of tuples.\"\n        \"The Vendor Specific information element is used to carry \"\\\n        \"information not defined in the standard within a single \"\\\n        \"defined format\"\n        \n        vs=[]\n        gen_get_element=self._get_elements_generator(DOT11_MANAGEMENT_ELEMENTS.VENDOR_SPECIFIC)\n        try:\n            while 1:\n                s=next(gen_get_element)\n                \n                if s is None:\n                    raise Exception(\"gen_get_element salio con None!!!\")\n                \n                # OUI is 3 bytes\n                oui=s[:3]\n                data=s[3:]\n                vs.append((oui,data))\n        except StopIteration:\n            pass\n            \n        return vs",
  "def add_vendor_specific(self, oui, data):\n        \"Set the 802.11 Management Vendor Specific element. \"\\\n        \"The Vendor Specific information element is used to carry \"\\\n        \"information not defined in the standard within a single \"\\\n        \"defined format\"\n        \n        # 3 is the OUI length\n        max_data_len=255-3\n        data_len=len(data)\n\n        if data_len>max_data_len:\n            raise Exception(\"data allow up to %d bytes long\" % max_data_len)\n        if len(oui) > 3:\n            raise Exception(\"oui is three bytes long\")\n        \n        self._set_element(DOT11_MANAGEMENT_ELEMENTS.VENDOR_SPECIFIC,oui+data, replace=False)",
  "def __init__(self, aBuffer = None):\n        header_size = self.__HEADER_BASE_SIZE\n        tail_size = 0\n        Dot11ManagementHelper.__init__(self, header_size, tail_size, aBuffer)",
  "def get_capabilities(self):\n        'Return the 802.11 Management Association Response Frame \\'Capability information\\' field. '\n        b = self.header.get_word(0, \"<\")\n        return b",
  "def set_capabilities(self, value):\n        'Set the 802.11 Management Association Response Frame \\'Capability Information\\' field' \n        # set the bits\n        nb = value & 0xFFFF\n        self.header.set_word(0, nb, \"<\")",
  "def get_status_code(self):\n        'Return the 802.11 Management Association Response Frame \\'Status Code\\' field. '\n        b = self.header.get_word(2, \"<\")\n        return b",
  "def set_status_code(self, value):\n        'Set the 802.11 Management Association Response Frame \\'Status Code\\' field' \n        self.header.set_word(2, value, \"<\")",
  "def get_association_id(self):\n        'Return the 802.11 Management Association Response Frame \\'Association Id\\' field. '\n        b = self.header.get_word(4, \"<\")\n        return b",
  "def set_association_id(self, value):\n        'Set the 802.11 Management Association Response Frame \\'Association Id\\' field' \n        self.header.set_word(4, value, \"<\")",
  "def get_supported_rates(self, human_readable=False):\n        \"Get the 802.11 Management Supported Rates element. \"\\\n        \"Specifies up to eight rates, then an Extended Supported Rate element \"\\\n        \"shall be generated to specify the remaining supported rates.\"\\\n        \"If human_readable is True, the rates are returned in Mbit/sec\"\n        s=self._get_element(DOT11_MANAGEMENT_ELEMENTS.SUPPORTED_RATES)\n        if s is None:\n            return None\n        \n        rates=struct.unpack('%dB'%len(s),s)\n        if not human_readable:\n            return rates\n            \n        rates_Mbs=tuple([(x&0x7F)*0.5 for x in rates])\n        return rates_Mbs",
  "def set_supported_rates(self, rates):\n        \"Set the 802.11 Management Supported Rates element. \"\\\n        \"Specifies a tuple or list with up to eight rates, then an \"\\\n        \"Extended Supported Rate element shall be generated to specify \"\\\n        \"the remaining supported rates.\"\n        qty_rates=len(rates)\n        if qty_rates>8:\n            raise Exception(\"requires up to eight rates\")\n        rates_string=struct.pack('B'*qty_rates,*rates)\n        self._set_element(DOT11_MANAGEMENT_ELEMENTS.SUPPORTED_RATES,rates_string)",
  "def get_vendor_specific(self):\n        \"Get the 802.11 Management Vendor Specific elements \"\\\n        \"as a list of tuples.\"\n        \"The Vendor Specific information element is used to carry \"\\\n        \"information not defined in the standard within a single \"\\\n        \"defined format\"\n        \n        vs=[]\n        gen_get_element=self._get_elements_generator(DOT11_MANAGEMENT_ELEMENTS.VENDOR_SPECIFIC)\n        try:\n            while 1:\n                s=next(gen_get_element)\n                \n                if s is None:\n                    raise Exception(\"gen_get_element salio con None!!!\")\n                \n                # OUI is 3 bytes\n                oui=s[:3]\n                data=s[3:]\n                vs.append((oui,data))\n        except StopIteration:\n            pass\n            \n        return vs",
  "def add_vendor_specific(self, oui, data):\n        \"Set the 802.11 Management Vendor Specific element. \"\\\n        \"The Vendor Specific information element is used to carry \"\\\n        \"information not defined in the standard within a single \"\\\n        \"defined format\"\n        \n        # 3 is the OUI length\n        max_data_len=255-3\n        data_len=len(data)\n        if data_len>max_data_len:\n            raise Exception(\"data allow up to %d bytes long\" % max_data_len)\n        if len(oui) > 3:\n            raise Exception(\"oui is three bytes long\")\n        \n        self._set_element(DOT11_MANAGEMENT_ELEMENTS.VENDOR_SPECIFIC,oui+data, replace=False)",
  "def __init__(self, aBuffer = None):\n        header_size = self.__HEADER_BASE_SIZE\n        tail_size = 0\n        Dot11ManagementHelper.__init__(self, header_size, tail_size, aBuffer)",
  "def get_capabilities(self):\n        'Return the 802.11 Management Reassociation Request Frame \\'Capability information\\' field. '\n        b = self.header.get_word(0, \"<\")\n        return b",
  "def set_capabilities(self, value):\n        'Set the 802.11 Management Reassociation Request Frame \\'Capability Information\\' field' \n        # set the bits\n        nb = value & 0xFFFF\n        self.header.set_word(0, nb, \"<\")",
  "def get_listen_interval(self):\n        'Return the 802.11 Management Reassociation Request Frame \\'Listen Interval\\' field. '\n        b = self.header.get_word(2, \"<\")\n        return b",
  "def set_listen_interval(self, value):\n        'Set the 802.11 Management Reassociation Request Frame \\'Listen Interval\\' field' \n        self.header.set_word(2, value, \"<\")",
  "def get_current_ap(self):\n        'Return the 802.11 Management Reassociation Request Frame \\'Current AP\\' field.'\n        return self.header.get_bytes()[4:10]",
  "def set_current_ap(self, value):\n        'Set the 802.11 Management Reassociation Request Frame \\'Current AP\\' field'\n        for i in range(0, 6):\n            self.header.set_byte(4+i, value[i])",
  "def get_ssid(self):\n        \"Get the 802.11 Management SSID element. \"\\\n        \"The SSID element indicates the identity of an ESS or IBSS.\"\n        return self._get_element(DOT11_MANAGEMENT_ELEMENTS.SSID)",
  "def set_ssid(self, ssid):\n        self._set_element(DOT11_MANAGEMENT_ELEMENTS.SSID,ssid)",
  "def get_supported_rates(self, human_readable=False):\n        \"Get the 802.11 Management Supported Rates element. \"\\\n        \"Specifies up to eight rates, then an Extended Supported Rate element \"\\\n        \"shall be generated to specify the remaining supported rates.\"\\\n        \"If human_readable is True, the rates are returned in Mbit/sec\"\n        s=self._get_element(DOT11_MANAGEMENT_ELEMENTS.SUPPORTED_RATES)\n        if s is None:\n            return None\n        \n        rates=struct.unpack('%dB'%len(s),s)\n        if not human_readable:\n            return rates\n            \n        rates_Mbs=tuple([(x&0x7F)*0.5 for x in rates])\n        return rates_Mbs",
  "def set_supported_rates(self, rates):\n        \"Set the 802.11 Management Supported Rates element. \"\\\n        \"Specifies a tuple or list with up to eight rates, then an \"\\\n        \"Extended Supported Rate element shall be generated to specify \"\\\n        \"the remaining supported rates.\"\n        qty_rates=len(rates)\n        if qty_rates>8:\n            raise Exception(\"requires up to eight rates\")\n        rates_string=struct.pack('B'*qty_rates,*rates)\n        self._set_element(DOT11_MANAGEMENT_ELEMENTS.SUPPORTED_RATES,rates_string)",
  "def get_rsn(self):\n        \"Get the 802.11 Management Robust Security Network element.\"\n        s = self._get_element(DOT11_MANAGEMENT_ELEMENTS.RSN)\n        if s is None:\n            return None\n        return s",
  "def set_rsn(self, data):\n        \"Set the 802.11 Management Robust Security Network element.\"\n        self._set_element(DOT11_MANAGEMENT_ELEMENTS.RSN, data)",
  "def get_vendor_specific(self):\n        \"Get the 802.11 Management Vendor Specific elements \"\\\n        \"as a list of tuples.\"\n        \"The Vendor Specific information element is used to carry \"\\\n        \"information not defined in the standard within a single \"\\\n        \"defined format\"\n        \n        vs=[]\n        gen_get_element=self._get_elements_generator(DOT11_MANAGEMENT_ELEMENTS.VENDOR_SPECIFIC)\n        try:\n            while 1:\n                s=next(gen_get_element)\n                \n                if s is None:\n                    raise Exception(\"gen_get_element salio con None!!!\")\n                \n                # OUI is 3 bytes\n                oui=s[:3]\n                data=s[3:]\n                vs.append((oui,data))\n        except StopIteration:\n            pass\n            \n        return vs",
  "def add_vendor_specific(self, oui, data):\n        \"Set the 802.11 Management Vendor Specific element. \"\\\n        \"The Vendor Specific information element is used to carry \"\\\n        \"information not defined in the standard within a single \"\\\n        \"defined format\"\n        \n        # 3 is the OUI length\n        max_data_len=255-3\n        data_len=len(data)\n\n        if data_len>max_data_len:\n            raise Exception(\"data allow up to %d bytes long\" % max_data_len)\n        if len(oui) > 3:\n            raise Exception(\"oui is three bytes long\")\n        \n        self._set_element(DOT11_MANAGEMENT_ELEMENTS.VENDOR_SPECIFIC,oui+data, replace=False)",
  "def __init__(self, aBuffer = None):\n        Dot11ManagementAssociationResponse.__init__(self, aBuffer)",
  "def __str__( self ):\n            return str( self.__class__.__name__ )",
  "class IP6(Header):\n    #Ethertype value for IPv6\n    ethertype = 0x86DD\n    HEADER_SIZE = 40\n    IP_PROTOCOL_VERSION = 6\n    \n    def __init__(self, buffer = None):\n        Header.__init__(self, IP6.HEADER_SIZE)\n        self.set_ip_v(IP6.IP_PROTOCOL_VERSION)\n        if (buffer):\n            self.load_header(buffer)\n\n    def contains(self, aHeader):\n        Header.contains(self, aHeader)\n        if isinstance(aHeader, IP6_Extension_Header):\n            self.set_next_header(aHeader.get_header_type())\n\n    def get_header_size(self):\n        return IP6.HEADER_SIZE\n\n    def __str__(self):        \n        protocol_version = self.get_ip_v()\n        traffic_class = self.get_traffic_class()\n        flow_label = self.get_flow_label()\n        payload_length = self.get_payload_length()\n        next_header = self.get_next_header()\n        hop_limit = self.get_hop_limit()\n        source_address = self.get_ip_src()\n        destination_address = self.get_ip_dst()\n\n        s = \"Protocol version: \" + str(protocol_version) + \"\\n\"\n        s += \"Traffic class: \" + str(traffic_class) + \"\\n\"\n        s += \"Flow label: \" + str(flow_label) + \"\\n\"\n        s += \"Payload length: \" + str(payload_length) + \"\\n\"\n        s += \"Next header: \" + str(next_header) + \"\\n\"\n        s += \"Hop limit: \" + str(hop_limit) + \"\\n\"\n        s += \"Source address: \" + source_address.as_string() + \"\\n\"\n        s += \"Destination address: \" + destination_address.as_string() + \"\\n\"\n        return s\n    \n    def get_pseudo_header(self):\n        source_address = self.get_ip_src().as_bytes()\n        #FIXME - Handle Routing header special case\n        destination_address = self.get_ip_dst().as_bytes()\n        reserved_bytes = [ 0x00, 0x00, 0x00 ]\n\n        upper_layer_packet_length = self.get_payload_length()\n        upper_layer_protocol_number = self.get_next_header()\n        \n        next_header = self.child()\n        while isinstance(next_header, IP6_Extension_Header):\n            # The length used in the pseudo-header is the Payload Length from the IPv6 header, minus\n            # the length of any extension headers present between the IPv6 header and the upper-layer header\n            upper_layer_packet_length -= next_header.get_header_size()\n            \n            # If there are extension headers, fetch the correct upper-player protocol number by traversing the list\n            upper_layer_protocol_number = next_header.get_next_header()\n            \n            next_header = next_header.child()\n        \n        pseudo_header = array.array('B')        \n        pseudo_header.extend(source_address)\n        pseudo_header.extend(destination_address)\n        array_frombytes(pseudo_header, struct.pack('!L', upper_layer_packet_length))\n        pseudo_header.fromlist(reserved_bytes)\n        array_frombytes(pseudo_header, struct.pack('B', upper_layer_protocol_number))\n        return pseudo_header\n    \n############################################################################\n    def get_ip_v(self):\n        return (self.get_byte(0) & 0xF0) >> 4\n\n    def get_traffic_class(self):\n        return ((self.get_byte(0) & 0x0F) << 4) | ((self.get_byte(1) & 0xF0) >> 4)\n\n    def get_flow_label(self):\n        return (self.get_byte(1) & 0x0F) << 16 | (self.get_byte(2) << 8) | self.get_byte(3)\n\n    def get_payload_length(self):\n        return (self.get_byte(4) << 8) | self.get_byte(5)\n\n    def get_next_header(self):\n        return (self.get_byte(6))\n\n    def get_hop_limit(self):\n        return (self.get_byte(7))\n\n    def get_ip_src(self):\n        address = IP6_Address(self.get_bytes()[8:24])\n        return (address)    \n\n    def get_ip_dst(self):\n        address = IP6_Address(self.get_bytes()[24:40])\n        return (address)    \n\n############################################################################\n    def set_ip_v(self, version):\n        if (version != 6):\n            raise Exception('set_ip_v - version != 6')\n    \n        #Fetch byte, clear high nibble\n        b = self.get_byte(0) & 0x0F\n        #Store version number in high nibble\n        b |= (version << 4)\n        #Store byte in buffer\n        #This behaviour is repeated in the rest of the methods \n        self.set_byte(0, b)\n\n\n    def set_traffic_class(self, traffic_class):\n        b0 = self.get_byte(0) & 0xF0\n        b1 = self.get_byte(1) & 0x0F\n        b0 |= (traffic_class & 0xF0) >> 4\n        b1 |= (traffic_class & 0x0F) << 4\n        self.set_byte(0, b0)\n        self.set_byte(1, b1)\n    \n\n    def set_flow_label(self, flow_label):\n        b1 = self.get_byte(1) & 0xF0\n        b1 |= (flow_label & 0xF0000) >> 16\n        self.set_byte(1, b1)\n        self.set_byte(2, (flow_label & 0x0FF00) >> 8)\n        self.set_byte(3, (flow_label & 0x000FF))\n \n\n    def set_payload_length(self, payload_length):\n        self.set_byte(4, (payload_length & 0xFF00) >> 8)\n        self.set_byte(5, (payload_length & 0x00FF))\n    \n\n    def set_next_header(self, next_header):\n        self.set_byte(6, next_header)\n    \n    def set_hop_limit(self, hop_limit):\n        self.set_byte(7, hop_limit)\n    \n    def set_ip_src(self, source_address):\n        address = IP6_Address(source_address)\n        bytes = self.get_bytes()\n        bytes[8:24] = address.as_bytes()\n        self.set_bytes(bytes)\n\n    def set_ip_dst(self, destination_address):\n        address = IP6_Address(destination_address)\n        bytes = self.get_bytes()\n        bytes[24:40] = address.as_bytes()\n        self.set_bytes(bytes)\n        \n    def get_protocol_version(self):\n        LOG.warning('deprecated soon')\n        return self.get_ip_v()    \n    \n    def get_source_address(self):\n        LOG.warning('deprecated soon')\n        return self.get_ip_src()\n    \n    def get_destination_address(self):\n        LOG.warning('deprecated soon')\n        return self.get_ip_dst()\n    \n    def set_protocol_version(self, version):\n        LOG.warning('deprecated soon')\n        self.set_ip_v(version)\n    \n    def set_source_address(self, source_address):\n        LOG.warning('deprecated soon')\n        self.set_ip_src(source_address)\n    \n    def set_destination_address(self, destination_address):\n        LOG.warning('deprecated soon')\n        self.set_ip_dst(destination_address)",
  "def __init__(self, buffer = None):\n        Header.__init__(self, IP6.HEADER_SIZE)\n        self.set_ip_v(IP6.IP_PROTOCOL_VERSION)\n        if (buffer):\n            self.load_header(buffer)",
  "def contains(self, aHeader):\n        Header.contains(self, aHeader)\n        if isinstance(aHeader, IP6_Extension_Header):\n            self.set_next_header(aHeader.get_header_type())",
  "def get_header_size(self):\n        return IP6.HEADER_SIZE",
  "def __str__(self):        \n        protocol_version = self.get_ip_v()\n        traffic_class = self.get_traffic_class()\n        flow_label = self.get_flow_label()\n        payload_length = self.get_payload_length()\n        next_header = self.get_next_header()\n        hop_limit = self.get_hop_limit()\n        source_address = self.get_ip_src()\n        destination_address = self.get_ip_dst()\n\n        s = \"Protocol version: \" + str(protocol_version) + \"\\n\"\n        s += \"Traffic class: \" + str(traffic_class) + \"\\n\"\n        s += \"Flow label: \" + str(flow_label) + \"\\n\"\n        s += \"Payload length: \" + str(payload_length) + \"\\n\"\n        s += \"Next header: \" + str(next_header) + \"\\n\"\n        s += \"Hop limit: \" + str(hop_limit) + \"\\n\"\n        s += \"Source address: \" + source_address.as_string() + \"\\n\"\n        s += \"Destination address: \" + destination_address.as_string() + \"\\n\"\n        return s",
  "def get_pseudo_header(self):\n        source_address = self.get_ip_src().as_bytes()\n        #FIXME - Handle Routing header special case\n        destination_address = self.get_ip_dst().as_bytes()\n        reserved_bytes = [ 0x00, 0x00, 0x00 ]\n\n        upper_layer_packet_length = self.get_payload_length()\n        upper_layer_protocol_number = self.get_next_header()\n        \n        next_header = self.child()\n        while isinstance(next_header, IP6_Extension_Header):\n            # The length used in the pseudo-header is the Payload Length from the IPv6 header, minus\n            # the length of any extension headers present between the IPv6 header and the upper-layer header\n            upper_layer_packet_length -= next_header.get_header_size()\n            \n            # If there are extension headers, fetch the correct upper-player protocol number by traversing the list\n            upper_layer_protocol_number = next_header.get_next_header()\n            \n            next_header = next_header.child()\n        \n        pseudo_header = array.array('B')        \n        pseudo_header.extend(source_address)\n        pseudo_header.extend(destination_address)\n        array_frombytes(pseudo_header, struct.pack('!L', upper_layer_packet_length))\n        pseudo_header.fromlist(reserved_bytes)\n        array_frombytes(pseudo_header, struct.pack('B', upper_layer_protocol_number))\n        return pseudo_header",
  "def get_ip_v(self):\n        return (self.get_byte(0) & 0xF0) >> 4",
  "def get_traffic_class(self):\n        return ((self.get_byte(0) & 0x0F) << 4) | ((self.get_byte(1) & 0xF0) >> 4)",
  "def get_flow_label(self):\n        return (self.get_byte(1) & 0x0F) << 16 | (self.get_byte(2) << 8) | self.get_byte(3)",
  "def get_payload_length(self):\n        return (self.get_byte(4) << 8) | self.get_byte(5)",
  "def get_next_header(self):\n        return (self.get_byte(6))",
  "def get_hop_limit(self):\n        return (self.get_byte(7))",
  "def get_ip_src(self):\n        address = IP6_Address(self.get_bytes()[8:24])\n        return (address)",
  "def get_ip_dst(self):\n        address = IP6_Address(self.get_bytes()[24:40])\n        return (address)",
  "def set_ip_v(self, version):\n        if (version != 6):\n            raise Exception('set_ip_v - version != 6')\n    \n        #Fetch byte, clear high nibble\n        b = self.get_byte(0) & 0x0F\n        #Store version number in high nibble\n        b |= (version << 4)\n        #Store byte in buffer\n        #This behaviour is repeated in the rest of the methods \n        self.set_byte(0, b)",
  "def set_traffic_class(self, traffic_class):\n        b0 = self.get_byte(0) & 0xF0\n        b1 = self.get_byte(1) & 0x0F\n        b0 |= (traffic_class & 0xF0) >> 4\n        b1 |= (traffic_class & 0x0F) << 4\n        self.set_byte(0, b0)\n        self.set_byte(1, b1)",
  "def set_flow_label(self, flow_label):\n        b1 = self.get_byte(1) & 0xF0\n        b1 |= (flow_label & 0xF0000) >> 16\n        self.set_byte(1, b1)\n        self.set_byte(2, (flow_label & 0x0FF00) >> 8)\n        self.set_byte(3, (flow_label & 0x000FF))",
  "def set_payload_length(self, payload_length):\n        self.set_byte(4, (payload_length & 0xFF00) >> 8)\n        self.set_byte(5, (payload_length & 0x00FF))",
  "def set_next_header(self, next_header):\n        self.set_byte(6, next_header)",
  "def set_hop_limit(self, hop_limit):\n        self.set_byte(7, hop_limit)",
  "def set_ip_src(self, source_address):\n        address = IP6_Address(source_address)\n        bytes = self.get_bytes()\n        bytes[8:24] = address.as_bytes()\n        self.set_bytes(bytes)",
  "def set_ip_dst(self, destination_address):\n        address = IP6_Address(destination_address)\n        bytes = self.get_bytes()\n        bytes[24:40] = address.as_bytes()\n        self.set_bytes(bytes)",
  "def get_protocol_version(self):\n        LOG.warning('deprecated soon')\n        return self.get_ip_v()",
  "def get_source_address(self):\n        LOG.warning('deprecated soon')\n        return self.get_ip_src()",
  "def get_destination_address(self):\n        LOG.warning('deprecated soon')\n        return self.get_ip_dst()",
  "def set_protocol_version(self, version):\n        LOG.warning('deprecated soon')\n        self.set_ip_v(version)",
  "def set_source_address(self, source_address):\n        LOG.warning('deprecated soon')\n        self.set_ip_src(source_address)",
  "def set_destination_address(self, destination_address):\n        LOG.warning('deprecated soon')\n        self.set_ip_dst(destination_address)",
  "def encode_name(name, nametype, scope):\n    # ToDo: Rewrite this simpler, we're using less than written\n    \"\"\"\n    Perform first and second level encoding of name as specified in RFC 1001 (Section 4)\n    \n    :param string name: the name to encode\n    :param integer nametype: the name type constants\n    :param string scope: the name's scope \n    \n    :return string/bytes: the encoded name.\n    \"\"\"\n    if name == '*':\n        name += '\\0' * 15\n    elif len(name) > 15:\n        name = name[:15] + chr(nametype)\n    else:\n        name = name.ljust(15) + chr(nametype)\n\n    encoded_name = chr(len(name) * 2) + re.sub('.', _do_first_level_encoding, name)\n\n    try:\n        if isinstance(encoded_name, unicode):\n            encoded_name = encoded_name.encode('utf-8')\n    except NameError:\n        pass\n    if scope:\n        encoded_scope = ''\n        for s in scope.split('.'):\n            encoded_scope = encoded_scope + chr(len(s)) + s\n\n        return b(encoded_name + encoded_scope) + b'\\0'\n    else:\n        return b(encoded_name) + b'\\0'",
  "def _do_first_level_encoding(m):\n    s = ord(m.group(0))\n    return string.ascii_uppercase[s >> 4] + string.ascii_uppercase[s & 0x0f]",
  "def decode_name(name):\n    # ToDo: Rewrite this simpler, we're using less than written\n    \"\"\"\n    Perform first and second level decoding of name as specified in RFC 1001 (Section 4)\n\n    :param string/bytes name: the name to decode\n\n    :return string: the decoded name.\n    \"\"\"\n\n    name_length = ord(name[0:1])\n    assert name_length == 32\n\n    decoded_name = re.sub('..', _do_first_level_decoding, name[1:33].decode('utf-8'))\n    if name[33:34] == b'\\0':\n        return 34, decoded_name, ''\n    else:\n        decoded_domain = ''\n        offset = 34\n        while 1:\n            domain_length = byte2int(name[offset:offset+1])\n            if domain_length == 0:\n                break\n            decoded_domain = '.' + name[offset:offset + domain_length].decode('utf-8')\n            offset += domain_length\n        return offset + 1, decoded_name, decoded_domain",
  "def _do_first_level_decoding(m):\n    s = m.group(0)\n    return chr(((ord(s[0]) - ord('A')) << 4) | (ord(s[1]) - ord('A')))",
  "class NetBIOSError(Exception):\n    def __init__(self, error_message='', error_class=None, error_code=None):\n        self.error_class = error_class\n        self.error_code = error_code\n        self.error_msg = error_message\n\n    def get_error_code(self):\n        return self.error\n\n    def getErrorCode(self):\n        return self.get_error_code()\n\n    def get_error_string(self):\n        return str(self)\n\n    def getErrorString(self):\n        return str(self)\n\n    def __str__(self):\n        if self.error_code is not None:\n            if self.error_code in QUERY_ERRORS:\n                return '%s-%s(%s)' % (self.error_msg, QUERY_ERRORS[self.error_code], self.error_code)\n            elif self.error_code in SESSION_ERRORS:\n                return '%s-%s(%s)' % (self.error_msg, SESSION_ERRORS[self.error_code], self.error_code)\n            else:\n                return '%s(%s)' % (self.error_msg, self.error_code)\n        else:\n            return '%s' % self.error_msg",
  "class NetBIOSTimeout(Exception):\n    def __init__(self, message = 'The NETBIOS connection with the remote host timed out.'):\n        Exception.__init__(self, message)",
  "class NBNSResourceRecord(Structure):\n    structure = (\n        ('RR_NAME','z=\\x00'),\n        ('RR_TYPE','>H=0'),\n        ('RR_CLASS','>H=0'),\n        ('TTL','>L=0'),\n        ('RDLENGTH','>H-RDATA'),\n        ('RDATA',':=\"\"'),\n    )",
  "class NBNodeStatusResponse(NBNSResourceRecord):\n    def __init__(self, data = 0):\n        NBNSResourceRecord.__init__(self, data)\n        self.mac = b'00-00-00-00-00-00'\n        self.num_names = unpack('B', self['RDATA'][:1])[0]\n        self.entries = list()\n        data = self['RDATA'][1:]\n        for _ in range(self.num_names):\n            entry = NODE_NAME_ENTRY(data)\n            data = data[len(entry):]\n            self.entries.append(entry)\n        self.statistics = STATISTICS(data)\n        self.set_mac_in_hexa(self.statistics['UNIT_ID'])\n\n    def set_mac_in_hexa(self, data):\n        data_aux = u''\n        for d in bytearray(data):\n            if data_aux == '':\n                data_aux = '%02x' % d\n            else:\n                data_aux += '-%02x' % d\n        self.mac = data_aux.upper()\n\n    def get_mac(self):\n        return self.mac\n\n    def rawData(self):\n        res = pack('!B', self.num_names )\n        for i in range(0, self.num_names):\n            res += self.entries[i].getData()",
  "class NBPositiveNameQueryResponse(NBNSResourceRecord):\n    def __init__(self, data = 0):\n        NBNSResourceRecord.__init__(self, data)\n        self.entries = [ ]\n        rdata = self['RDATA']\n        while len(rdata) > 0:\n            entry = ADDR_ENTRY(rdata)\n            rdata = rdata[len(entry):]\n            self.entries.append(socket.inet_ntoa(entry['NB_ADDRESS']))",
  "class NAME_SERVICE_PACKET(Structure):\n    commonHdr = (\n        ('NAME_TRN_ID','>H=0'),\n        ('FLAGS','>H=0'),\n        ('QDCOUNT','>H=0'),\n        ('ANCOUNT','>H=0'),\n        ('NSCOUNT','>H=0'),\n        ('ARCOUNT','>H=0'),\n    )\n    structure = (\n        ('ANSWERS',':'),\n    )",
  "class QUESTION_ENTRY(Structure):\n    commonHdr = (\n        ('QUESTION_NAME','z'),\n        ('QUESTION_TYPE','>H=0'),\n        ('QUESTION_CLASS','>H=0'),\n    )",
  "class RESOURCE_RECORD(Structure):\n    structure = (\n        ('RR_NAME','z=\\x00'),\n        ('RR_TYPE','>H=0'),\n        ('RR_CLASS','>H=0'),\n        ('TTL','>L=0'),\n        ('RDLENGTH','>H-RDATA'),\n        ('RDATA',':=\"\"'),\n    )",
  "class NAME_REGISTRATION_REQUEST(NAME_SERVICE_PACKET):\n    structure = (\n        ('QUESTION_NAME', ':'),\n        ('QUESTION_TYPE', '>H=0'),\n        ('QUESTION_CLASS', '>H=0'),\n        ('RR_NAME',':', ),\n        ('RR_TYPE', '>H=0'),\n        ('RR_CLASS','>H=0'),\n        ('TTL', '>L=0'),\n        ('RDLENGTH', '>H=6'),\n        ('NB_FLAGS', '>H=0'),\n        ('NB_ADDRESS', '4s=b\"\"'),\n    )\n    def __init__(self, data=None):\n        NAME_SERVICE_PACKET.__init__(self,data)\n        self['FLAGS'] = OPCODE_REQUEST | NM_FLAGS_RD | OPCODE_REGISTRATION\n        self['QDCOUNT'] = 1\n        self['ANCOUNT'] = 0\n        self['NSCOUNT'] = 0\n        self['ARCOUNT'] = 1\n\n        self['QUESTION_TYPE'] = QUESTION_TYPE_NB\n        self['QUESTION_CLASS'] = QUESTION_CLASS_IN\n\n        self['RR_TYPE'] = RR_TYPE_NB\n        self['RR_CLASS'] = RR_CLASS_IN",
  "class NAME_OVERWRITE_REQUEST(NAME_REGISTRATION_REQUEST):\n    def __init__(self, data=None):\n        NAME_REGISTRATION_REQUEST.__init__(self,data)\n        self['FLAGS'] = OPCODE_REQUEST | OPCODE_REGISTRATION\n        self['QDCOUNT'] = 1\n        self['ANCOUNT'] = 0\n        self['NSCOUNT'] = 0\n        self['ARCOUNT'] = 1",
  "class NAME_REFRESH_REQUEST(NAME_REGISTRATION_REQUEST):\n    def __init__(self, data=None):\n        NAME_REGISTRATION_REQUEST.__init__(self,data)\n        self['FLAGS'] = OPCODE_REFRESH | 0x1\n        self['QDCOUNT'] = 1\n        self['ANCOUNT'] = 0\n        self['NSCOUNT'] = 0\n        self['ARCOUNT'] = 1",
  "class NAME_REGISTRATION_RESPONSE(NAME_REGISTRATION_REQUEST):\n    def __init__(self, data=None):\n        NAME_REGISTRATION_REQUEST.__init__(self,data)",
  "class NAME_CONFLICT_DEMAND(NAME_REGISTRATION_REQUEST):\n    def __init__(self, data=None):\n        NAME_REGISTRATION_REQUEST.__init__(self,data)",
  "class NAME_QUERY_REQUEST(NAME_SERVICE_PACKET):\n    structure = (\n        ('QUESTION_NAME', ':'),\n        ('QUESTION_TYPE', '>H=0'),\n        ('QUESTION_CLASS', '>H=0'),\n    )\n    def __init__(self, data=None):\n        NAME_SERVICE_PACKET.__init__(self,data)\n        self['FLAGS'] = OPCODE_REQUEST | OPCODE_REGISTRATION | NM_FLAGS_RD\n        self['RCODE'] = 0\n        self['QDCOUNT'] = 1\n        self['ANCOUNT'] = 0\n        self['NSCOUNT'] = 0\n        self['ARCOUNT'] = 0\n\n        self['QUESTION_TYPE'] = QUESTION_TYPE_NB\n        self['QUESTION_CLASS'] = QUESTION_CLASS_IN",
  "class ADDR_ENTRY(Structure):\n    structure = (\n        ('NB_FLAGS', '>H=0'),\n        ('NB_ADDRESS', '4s=b\"\"'),\n    )",
  "class NODE_STATUS_REQUEST(NAME_QUERY_REQUEST):\n    def __init__(self, data=None):\n        NAME_QUERY_REQUEST.__init__(self,data)\n\n        self['FLAGS'] = 0\n        self['QUESTION_TYPE'] = QUESTION_TYPE_NBSTAT",
  "class NODE_NAME_ENTRY(Structure):\n    structure = (\n        ('NAME','15s=b\"\"'),\n        ('TYPE','B=0'),\n        ('NAME_FLAGS','>H'),\n    )",
  "class STATISTICS(Structure):\n    structure = (\n        ('UNIT_ID','6s=b\"\"'),\n        ('JUMPERS','B'),\n        ('TEST_RESULT','B'),\n        ('VERSION_NUMBER','>H'),\n        ('PERIOD_OF_STATISTICS','>H'),\n        ('NUMBER_OF_CRCs','>H'),\n        ('NUMBER_ALIGNMENT_ERRORS','>H'),\n        ('NUMBER_OF_COLLISIONS','>H'),\n        ('NUMBER_SEND_ABORTS','>H'),\n        ('NUMBER_GOOD_SENDS','>L'),\n        ('NUMBER_GOOD_RECEIVES','>L'),\n        ('NUMBER_RETRANSMITS','>H'),\n        ('NUMBER_NO_RESOURCE_CONDITIONS','>H'),\n        ('NUMBER_FREE_COMMAND_BLOCKS','>H'),\n        ('TOTAL_NUMBER_COMMAND_BLOCKS','>H'),\n        ('MAX_TOTAL_NUMBER_COMMAND_BLOCKS','>H'),\n        ('NUMBER_PENDING_SESSIONS','>H'),\n        ('MAX_NUMBER_PENDING_SESSIONS','>H'),\n        ('MAX_TOTAL_SESSIONS_POSSIBLE','>H'),\n        ('SESSION_DATA_PACKET_SIZE','>H'),\n    )",
  "class NetBIOS:\n    # Creates a NetBIOS instance without specifying any default NetBIOS domain nameserver.\n    # All queries will be sent through the servport.\n    def __init__(self, servport = NETBIOS_NS_PORT):\n        self.__servport = NETBIOS_NS_PORT\n        self.__nameserver = None\n        self.__broadcastaddr = BROADCAST_ADDR\n        self.mac = b'00-00-00-00-00-00'\n\n    def _setup_connection(self, dstaddr, timeout=None):\n        port = rand.randint(10000, 60000)\n        af, socktype, proto, _canonname, _sa = socket.getaddrinfo(dstaddr, port, socket.AF_INET, socket.SOCK_DGRAM)[0]\n        s = socket.socket(af, socktype, proto)\n        has_bind = 1\n        for _i in range(0, 10):\n            # We try to bind to a port for 10 tries\n            try:\n                s.bind((INADDR_ANY, rand.randint(10000, 60000)))\n                s.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)\n                has_bind = 1\n            except socket.error:\n                pass\n        if not has_bind:\n            raise NetBIOSError('Cannot bind to a good UDP port', ERRCLASS_OS, errno.EAGAIN)\n        self.__sock = s\n\n    def send(self, request, destaddr, timeout):\n        self._setup_connection(destaddr)\n\n        tries = 3\n        while 1:\n            try:\n                self.__sock.sendto(request.getData(), 0, (destaddr, self.__servport))\n                ready, _, _ = select.select([self.__sock.fileno()], [], [], timeout)\n                if not ready:\n                    if tries:\n                        # Retry again until tries == 0\n                        tries -= 1\n                    else:\n                        raise NetBIOSTimeout\n                else:\n                    try:\n                        data, _ = self.__sock.recvfrom(65536, 0)\n                    except Exception as e:\n                        raise NetBIOSError(\"recvfrom error: %s\" % str(e))\n                    self.__sock.close()\n                    res = NAME_SERVICE_PACKET(data)\n                    if res['NAME_TRN_ID'] == request['NAME_TRN_ID']:\n                        if (res['FLAGS'] & 0xf) > 0:\n                            raise NetBIOSError('Negative response', ERRCLASS_QUERY, res['FLAGS'] & 0xf)\n                        return res\n            except select.error as ex:\n                if ex.errno != errno.EINTR and ex.errno != errno.EAGAIN:\n                    raise NetBIOSError('Error occurs while waiting for response', ERRCLASS_OS, ex.errno)\n            except socket.error as ex:\n                raise NetBIOSError('Connection error: %s' % str(ex))\n\n    # Set the default NetBIOS domain nameserver.\n    def set_nameserver(self, nameserver):\n        self.__nameserver = nameserver\n\n    # Return the default NetBIOS domain nameserver, or None if none is specified.\n    def get_nameserver(self):\n        return self.__nameserver\n\n    # Set the broadcast address to be used for query.\n    def set_broadcastaddr(self, broadcastaddr):\n        self.__broadcastaddr = broadcastaddr\n\n    # Return the broadcast address to be used, or BROADCAST_ADDR if default broadcast address is used.   \n    def get_broadcastaddr(self):\n        return self.__broadcastaddr\n\n    # Returns a NBPositiveNameQueryResponse instance containing the host information for nbname.\n    # If a NetBIOS domain nameserver has been specified, it will be used for the query.\n    # Otherwise, the query is broadcasted on the broadcast address.\n    def gethostbyname(self, nbname, qtype = TYPE_WORKSTATION, scope = None, timeout = 1):\n        resp = self.name_query_request(nbname, self.__nameserver, qtype, scope, timeout)\n        return resp\n\n    # Returns a list of NBNodeEntry instances containing node status information for nbname.\n    # If destaddr contains an IP address, then this will become an unicast query on the destaddr.\n    # Raises NetBIOSTimeout if timeout (in secs) is reached.\n    # Raises NetBIOSError for other errors\n    def getnodestatus(self, nbname, destaddr = None, type = TYPE_WORKSTATION, scope = None, timeout = 1):\n        if destaddr:\n            return self.node_status_request(nbname, destaddr, type, scope, timeout)\n        else:\n            return self.node_status_request(nbname, self.__nameserver, type, scope, timeout)\n\n    def getnetbiosname(self, ip):\n        entries = self.getnodestatus('*',ip)\n        entries = [x for x in entries if x['TYPE'] == TYPE_SERVER]\n        return entries[0]['NAME'].strip().decode('latin-1')\n\n    def getmacaddress(self):\n        return self.mac\n\n    def name_registration_request(self, nbname, destaddr, qtype, scope, nb_flags=0, nb_address='0.0.0.0'):\n        netbios_name = nbname.upper()\n        qn_label = encode_name(netbios_name, qtype, scope)\n\n        p = NAME_REGISTRATION_REQUEST()\n        p['NAME_TRN_ID'] = rand.randint(1, 32000)\n        p['QUESTION_NAME'] = qn_label[:-1] + b'\\x00'\n        p['RR_NAME'] = qn_label[:-1] + b'\\x00'\n        p['TTL'] = 0xffff\n        p['NB_FLAGS'] = nb_flags\n        p['NB_ADDRESS'] = socket.inet_aton(nb_address)\n        if not destaddr:\n            p['FLAGS'] |= NM_FLAGS_BROADCAST\n            destaddr = self.__broadcastaddr\n\n        res = self.send(p, destaddr, 1)\n        return res\n\n    def name_query_request(self, nbname, destaddr = None, qtype = TYPE_SERVER, scope = None, timeout = 1):\n        netbios_name = nbname.upper()\n        qn_label = encode_name(netbios_name, qtype, scope)\n\n        p = NAME_QUERY_REQUEST()\n        p['NAME_TRN_ID'] = rand.randint(1, 32000)\n        p['QUESTION_NAME'] = qn_label[:-1] + b'\\x00'\n        p['FLAGS'] = NM_FLAGS_RD\n        if not destaddr:\n            p['FLAGS'] |= NM_FLAGS_BROADCAST\n\n            destaddr = self.__broadcastaddr\n\n        res = self.send(p, destaddr, timeout)\n        return NBPositiveNameQueryResponse(res['ANSWERS'])\n\n    def node_status_request(self, nbname, destaddr, type, scope, timeout):\n        netbios_name = nbname.upper()\n        qn_label = encode_name(netbios_name, type, scope)\n        p = NODE_STATUS_REQUEST()\n        p['NAME_TRN_ID'] = rand.randint(1, 32000)\n        p['QUESTION_NAME'] = qn_label[:-1] + b'\\x00'\n\n        if not destaddr:\n            p['FLAGS'] = NM_FLAGS_BROADCAST\n            destaddr = self.__broadcastaddr\n\n        res = self.send(p, destaddr, timeout)\n        answ = NBNodeStatusResponse(res['ANSWERS'])\n        self.mac = answ.get_mac()\n        return answ.entries",
  "class NetBIOSSessionPacket:\n    def __init__(self, data=0):\n        self.type = 0x0\n        self.flags = 0x0\n        self.length = 0x0\n        if data == 0:\n            self._trailer = b''\n        else:\n            try:\n                self.type = indexbytes(data,0)\n                if self.type == NETBIOS_SESSION_MESSAGE:\n                    self.length = indexbytes(data,1) << 16 | (unpack('!H', data[2:4])[0])\n                else:\n                    self.flags = data[1]\n                    self.length = unpack('!H', data[2:4])[0]\n\n                self._trailer = data[4:]\n            except:\n                raise NetBIOSError('Wrong packet format ')\n\n    def set_type(self, type):\n        self.type = type\n\n    def get_type(self):\n        return self.type\n\n    def rawData(self):\n        if self.type == NETBIOS_SESSION_MESSAGE:\n            data = pack('!BBH', self.type, self.length >> 16, self.length & 0xFFFF) + self._trailer\n        else:\n            data = pack('!BBH', self.type, self.flags, self.length) + self._trailer\n        return data\n\n    def set_trailer(self, data):\n        self._trailer = data\n        self.length = len(data)\n\n    def get_length(self):\n        return self.length\n\n    def get_trailer(self):\n        return self._trailer",
  "class NetBIOSSession:\n    def __init__(self, myname, remote_name, remote_host, remote_type=TYPE_SERVER, sess_port=NETBIOS_SESSION_PORT,\n                 timeout=None, local_type=TYPE_WORKSTATION, sock=None):\n        \"\"\"\n\n        :param unicode myname: My local NetBIOS name\n        :param unicode remote_name: Remote NetBIOS name\n        :param unicode remote_host: Remote IP Address\n        :param integer remote_type: NetBIOS Host type\n        :param integer sess_port: Session port to connect (139,445)\n        :param integer timeout: Timeout for connection\n        :param integer local_type: My Local Host Type\n        :param socket sock: Socket for already established connection\n        \"\"\"\n        if len(myname) > 15:\n            self.__myname = myname[:15].upper()\n        else:\n            self.__myname = myname.upper()\n        self.__local_type = local_type\n\n        assert remote_name\n        # if destination port SMB_SESSION_PORT and remote name *SMBSERVER, we're changing it to its IP address\n        # helping solving the client mistake ;)\n        if remote_name == '*SMBSERVER' and sess_port == SMB_SESSION_PORT:\n            remote_name = remote_host\n\n        # If remote name is *SMBSERVER let's try to query its name.. if can't be guessed, continue and hope for the best\n\n        if remote_name == '*SMBSERVER':\n            nb = NetBIOS()\n            try:\n                res = nb.getnetbiosname(remote_host)\n            except:\n                res = None\n                pass\n\n            if res is not None:\n                remote_name = res\n\n        if len(remote_name) > 15:\n            self.__remote_name = remote_name[:15].upper()\n        else:\n            self.__remote_name = remote_name.upper()\n        self.__remote_type = remote_type\n        self.__remote_host = remote_host\n\n        if sock is not None:\n            # We are acting as a server\n            self._sock = sock\n        else:\n            self._sock = self._setup_connection((remote_host, sess_port), timeout)\n\n        if sess_port == NETBIOS_SESSION_PORT:\n            self._request_session(remote_type, local_type, timeout)\n\n    def _request_session(self, remote_type, local_type, timeout):\n        raise NotImplementedError('Not Implemented!')\n\n    def _setup_connection(self, peer, timeout=None):\n        raise NotImplementedError('Not Implemented!')\n\n    def get_myname(self):\n        return self.__myname\n\n    def get_mytype(self):\n        return self.__local_type\n\n    def get_remote_host(self):\n        return self.__remote_host\n\n    def get_remote_name(self):\n        return self.__remote_name\n\n    def get_remote_type(self):\n        return self.__remote_type\n\n    def close(self):\n        self._sock.close()\n\n    def get_socket(self):\n        return self._sock",
  "class NetBIOSUDPSessionPacket(Structure):\n    TYPE_DIRECT_UNIQUE = 16\n    TYPE_DIRECT_GROUP  = 17\n\n    FLAGS_MORE_FRAGMENTS = 1\n    FLAGS_FIRST_FRAGMENT = 2\n    FLAGS_B_NODE         = 0\n\n    structure = (\n        ('Type','B=16'),    # Direct Unique Datagram\n        ('Flags','B=2'),    # FLAGS_FIRST_FRAGMENT\n        ('ID','<H'),\n        ('_SourceIP','>L'),\n        ('SourceIP','\"'),\n        ('SourcePort','>H=138'),\n        ('DataLegth','>H-Data'),\n        ('Offset','>H=0'),\n        ('SourceName','z'),\n        ('DestinationName','z'),\n        ('Data',':'),\n    )\n\n    def getData(self):\n        addr = self['SourceIP'].split('.')\n        addr = [int(x) for x in addr]\n        addr = (((addr[0] << 8) + addr[1] << 8) + addr[2] << 8) + addr[3]\n        self['_SourceIP'] = addr\n        return Structure.getData(self)\n\n    def get_trailer(self):\n        return self['Data']",
  "class NetBIOSUDPSession(NetBIOSSession):\n    def _setup_connection(self, peer, timeout=None):\n        af, socktype, proto, canonname, sa = socket.getaddrinfo(peer[0], peer[1], 0, socket.SOCK_DGRAM)[0]\n        sock = socket.socket(af, socktype, proto)\n        sock.connect(sa)\n\n        sock = socket.socket(af, socktype, proto)\n        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n        sock.bind((INADDR_ANY, 138))\n        self.peer = peer\n        return sock\n\n    def _request_session(self, remote_type, local_type, timeout = None):\n        pass\n\n    def next_id(self):\n        if hasattr(self, '__dgram_id'):\n            answer = self.__dgram_id\n        else:\n            self.__dgram_id = rand.randint(1,65535)\n            answer = self.__dgram_id\n        self.__dgram_id += 1\n        return answer\n\n    def send_packet(self, data):\n        # Yes... I know...\n        self._sock.connect(self.peer)\n\n        p = NetBIOSUDPSessionPacket()\n        p['ID'] = self.next_id()\n        p['SourceIP'] = self._sock.getsockname()[0]\n        p['SourceName'] = encode_name(self.get_myname(), self.get_mytype(), '')[:-1]\n        p['DestinationName'] = encode_name(self.get_remote_name(), self.get_remote_type(), '')[:-1]\n        p['Data'] = data\n\n        self._sock.sendto(str(p), self.peer)\n        self._sock.close()\n\n        self._sock = self._setup_connection(self.peer)\n\n    def recv_packet(self, timeout = None):\n        # The next loop is a workaround for a bigger problem:\n        # When data reaches higher layers, the lower headers are lost,\n        # and with them, for example, the source IP. Hence, SMB users\n        # can't know where packets are coming from... we need a better\n        # solution, right now, we will filter everything except packets\n        # coming from the remote_host specified in __init__()\n\n        while 1:\n            data, peer = self._sock.recvfrom(8192)\n#            print \"peer: %r  self.peer: %r\" % (peer, self.peer)\n            if peer == self.peer:\n                break\n\n        return NetBIOSUDPSessionPacket(data)",
  "class NetBIOSTCPSession(NetBIOSSession):\n    def __init__(self, myname, remote_name, remote_host, remote_type=TYPE_SERVER, sess_port=NETBIOS_SESSION_PORT,\n                 timeout=None, local_type=TYPE_WORKSTATION, sock=None, select_poll=False):\n        \"\"\"\n        \n        :param unicode myname: My local NetBIOS name\n        :param unicode remote_name: Remote NetBIOS name\n        :param unicode remote_host: Remote IP Address\n        :param integer remote_type: NetBIOS Host type\n        :param integer sess_port: Session port to connect (139,445)\n        :param integer timeout: Timeout for connection\n        :param integer local_type: My Local Host Type\n        :param socket sock: Socket for already established connection\n        :param boolean select_poll: Type of polling mechanism\n        \"\"\"\n        self.__select_poll = select_poll\n        if self.__select_poll:\n            self.read_function = self.polling_read\n        else:\n            self.read_function = self.non_polling_read\n        NetBIOSSession.__init__(self, myname, remote_name, remote_host, remote_type=remote_type, sess_port=sess_port,\n                                timeout=timeout, local_type=local_type, sock=sock)\n\n    def _setup_connection(self, peer, timeout=None):\n        try:\n            af, socktype, proto, canonname, sa = socket.getaddrinfo(peer[0], peer[1], 0, socket.SOCK_STREAM)[0]\n            sock = socket.socket(af, socktype, proto)\n            oldtimeout = sock.gettimeout()\n            sock.settimeout(timeout)\n            sock.connect(sa)\n            sock.settimeout(oldtimeout)\n        except socket.error as e:\n            raise socket.error(\"Connection error (%s:%s)\" % (peer[0], peer[1]), e)\n        return sock\n\n    def send_packet(self, data):\n        p = NetBIOSSessionPacket()\n        p.set_type(NETBIOS_SESSION_MESSAGE)\n        p.set_trailer(data)\n        self._sock.sendall(p.rawData())\n\n    def recv_packet(self, timeout = None):\n        data = self.__read(timeout)\n        NBSPacket = NetBIOSSessionPacket(data)\n        if NBSPacket.get_type() == NETBIOS_SESSION_KEEP_ALIVE:\n            # Discard packet\n            return self.recv_packet(timeout)\n        return NetBIOSSessionPacket(data)\n\n    def _request_session(self, remote_type, local_type, timeout = None):\n        p = NetBIOSSessionPacket()\n        remote_name = encode_name(self.get_remote_name(), remote_type, '')\n        myname = encode_name(self.get_myname(), local_type, '')\n        p.set_type(NETBIOS_SESSION_REQUEST)\n        p.set_trailer(remote_name + myname)\n\n        self._sock.sendall(p.rawData())\n        while 1:\n            p = self.recv_packet(timeout)\n            if p.get_type() == NETBIOS_SESSION_NEGATIVE_RESPONSE:\n                raise NetBIOSError('Cannot request session (Called Name:%s)' % self.get_remote_name())\n            elif p.get_type() == NETBIOS_SESSION_POSITIVE_RESPONSE:\n                break\n            else:\n                # Ignore all other messages, most probably keepalive messages\n                pass\n\n    def polling_read(self, read_length, timeout):\n        data = b''\n        if timeout is None:\n            timeout = 3600\n\n        time_left = timeout\n        CHUNK_TIME = 0.025\n        bytes_left = read_length\n\n        while bytes_left > 0:\n            try:\n                ready, _, _ = select.select([self._sock.fileno()], [], [], 0)\n\n                if not ready:\n                    if time_left <= 0:\n                        raise NetBIOSTimeout\n                    else:\n                        time.sleep(CHUNK_TIME)\n                        time_left -= CHUNK_TIME\n                        continue\n\n                received = self._sock.recv(bytes_left)\n                if len(received) == 0:\n                    raise NetBIOSError('Error while reading from remote', ERRCLASS_OS, None)\n\n                data = data + received\n                bytes_left = read_length - len(data)\n            except select.error as ex:\n                if ex.errno != errno.EINTR and ex.errno != errno.EAGAIN:\n                    raise NetBIOSError('Error occurs while reading from remote', ERRCLASS_OS, ex.errno)\n\n        return bytes(data)\n\n    def non_polling_read(self, read_length, timeout):\n        data = b''\n        if timeout is None:\n            timeout = 3600\n\n        start_time = time.time()\n        bytes_left = read_length\n\n        while bytes_left > 0:\n            self._sock.settimeout(timeout)\n            try:\n                received = self._sock.recv(bytes_left)\n            except socket.timeout:\n                raise NetBIOSTimeout\n            except Exception as ex:\n                raise NetBIOSError('Error occurs while reading from remote', ERRCLASS_OS, ex.errno)\n\n            if (time.time() - start_time) > timeout:\n                raise NetBIOSTimeout\n\n            if len(received) == 0:\n                raise NetBIOSError('Error while reading from remote', ERRCLASS_OS, None)\n\n            data = data + received\n            bytes_left = read_length - len(data)\n\n        return bytes(data)\n\n    def __read(self, timeout = None):\n        data = self.read_function(4, timeout)\n        type, flags, length = unpack('>ccH', data)\n        if ord(type) == NETBIOS_SESSION_MESSAGE:\n            length |= ord(flags) << 16\n        else:\n            if ord(flags) & 0x01:\n                length |= 0x10000\n        data2 = self.read_function(length, timeout)\n\n        return data + data2",
  "def __init__(self, error_message='', error_class=None, error_code=None):\n        self.error_class = error_class\n        self.error_code = error_code\n        self.error_msg = error_message",
  "def get_error_code(self):\n        return self.error",
  "def getErrorCode(self):\n        return self.get_error_code()",
  "def get_error_string(self):\n        return str(self)",
  "def getErrorString(self):\n        return str(self)",
  "def __str__(self):\n        if self.error_code is not None:\n            if self.error_code in QUERY_ERRORS:\n                return '%s-%s(%s)' % (self.error_msg, QUERY_ERRORS[self.error_code], self.error_code)\n            elif self.error_code in SESSION_ERRORS:\n                return '%s-%s(%s)' % (self.error_msg, SESSION_ERRORS[self.error_code], self.error_code)\n            else:\n                return '%s(%s)' % (self.error_msg, self.error_code)\n        else:\n            return '%s' % self.error_msg",
  "def __init__(self, message = 'The NETBIOS connection with the remote host timed out.'):\n        Exception.__init__(self, message)",
  "def __init__(self, data = 0):\n        NBNSResourceRecord.__init__(self, data)\n        self.mac = b'00-00-00-00-00-00'\n        self.num_names = unpack('B', self['RDATA'][:1])[0]\n        self.entries = list()\n        data = self['RDATA'][1:]\n        for _ in range(self.num_names):\n            entry = NODE_NAME_ENTRY(data)\n            data = data[len(entry):]\n            self.entries.append(entry)\n        self.statistics = STATISTICS(data)\n        self.set_mac_in_hexa(self.statistics['UNIT_ID'])",
  "def set_mac_in_hexa(self, data):\n        data_aux = u''\n        for d in bytearray(data):\n            if data_aux == '':\n                data_aux = '%02x' % d\n            else:\n                data_aux += '-%02x' % d\n        self.mac = data_aux.upper()",
  "def get_mac(self):\n        return self.mac",
  "def rawData(self):\n        res = pack('!B', self.num_names )\n        for i in range(0, self.num_names):\n            res += self.entries[i].getData()",
  "def __init__(self, data = 0):\n        NBNSResourceRecord.__init__(self, data)\n        self.entries = [ ]\n        rdata = self['RDATA']\n        while len(rdata) > 0:\n            entry = ADDR_ENTRY(rdata)\n            rdata = rdata[len(entry):]\n            self.entries.append(socket.inet_ntoa(entry['NB_ADDRESS']))",
  "def __init__(self, data=None):\n        NAME_SERVICE_PACKET.__init__(self,data)\n        self['FLAGS'] = OPCODE_REQUEST | NM_FLAGS_RD | OPCODE_REGISTRATION\n        self['QDCOUNT'] = 1\n        self['ANCOUNT'] = 0\n        self['NSCOUNT'] = 0\n        self['ARCOUNT'] = 1\n\n        self['QUESTION_TYPE'] = QUESTION_TYPE_NB\n        self['QUESTION_CLASS'] = QUESTION_CLASS_IN\n\n        self['RR_TYPE'] = RR_TYPE_NB\n        self['RR_CLASS'] = RR_CLASS_IN",
  "def __init__(self, data=None):\n        NAME_REGISTRATION_REQUEST.__init__(self,data)\n        self['FLAGS'] = OPCODE_REQUEST | OPCODE_REGISTRATION\n        self['QDCOUNT'] = 1\n        self['ANCOUNT'] = 0\n        self['NSCOUNT'] = 0\n        self['ARCOUNT'] = 1",
  "def __init__(self, data=None):\n        NAME_REGISTRATION_REQUEST.__init__(self,data)\n        self['FLAGS'] = OPCODE_REFRESH | 0x1\n        self['QDCOUNT'] = 1\n        self['ANCOUNT'] = 0\n        self['NSCOUNT'] = 0\n        self['ARCOUNT'] = 1",
  "def __init__(self, data=None):\n        NAME_REGISTRATION_REQUEST.__init__(self,data)",
  "def __init__(self, data=None):\n        NAME_REGISTRATION_REQUEST.__init__(self,data)",
  "def __init__(self, data=None):\n        NAME_SERVICE_PACKET.__init__(self,data)\n        self['FLAGS'] = OPCODE_REQUEST | OPCODE_REGISTRATION | NM_FLAGS_RD\n        self['RCODE'] = 0\n        self['QDCOUNT'] = 1\n        self['ANCOUNT'] = 0\n        self['NSCOUNT'] = 0\n        self['ARCOUNT'] = 0\n\n        self['QUESTION_TYPE'] = QUESTION_TYPE_NB\n        self['QUESTION_CLASS'] = QUESTION_CLASS_IN",
  "def __init__(self, data=None):\n        NAME_QUERY_REQUEST.__init__(self,data)\n\n        self['FLAGS'] = 0\n        self['QUESTION_TYPE'] = QUESTION_TYPE_NBSTAT",
  "def __init__(self, servport = NETBIOS_NS_PORT):\n        self.__servport = NETBIOS_NS_PORT\n        self.__nameserver = None\n        self.__broadcastaddr = BROADCAST_ADDR\n        self.mac = b'00-00-00-00-00-00'",
  "def _setup_connection(self, dstaddr, timeout=None):\n        port = rand.randint(10000, 60000)\n        af, socktype, proto, _canonname, _sa = socket.getaddrinfo(dstaddr, port, socket.AF_INET, socket.SOCK_DGRAM)[0]\n        s = socket.socket(af, socktype, proto)\n        has_bind = 1\n        for _i in range(0, 10):\n            # We try to bind to a port for 10 tries\n            try:\n                s.bind((INADDR_ANY, rand.randint(10000, 60000)))\n                s.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)\n                has_bind = 1\n            except socket.error:\n                pass\n        if not has_bind:\n            raise NetBIOSError('Cannot bind to a good UDP port', ERRCLASS_OS, errno.EAGAIN)\n        self.__sock = s",
  "def send(self, request, destaddr, timeout):\n        self._setup_connection(destaddr)\n\n        tries = 3\n        while 1:\n            try:\n                self.__sock.sendto(request.getData(), 0, (destaddr, self.__servport))\n                ready, _, _ = select.select([self.__sock.fileno()], [], [], timeout)\n                if not ready:\n                    if tries:\n                        # Retry again until tries == 0\n                        tries -= 1\n                    else:\n                        raise NetBIOSTimeout\n                else:\n                    try:\n                        data, _ = self.__sock.recvfrom(65536, 0)\n                    except Exception as e:\n                        raise NetBIOSError(\"recvfrom error: %s\" % str(e))\n                    self.__sock.close()\n                    res = NAME_SERVICE_PACKET(data)\n                    if res['NAME_TRN_ID'] == request['NAME_TRN_ID']:\n                        if (res['FLAGS'] & 0xf) > 0:\n                            raise NetBIOSError('Negative response', ERRCLASS_QUERY, res['FLAGS'] & 0xf)\n                        return res\n            except select.error as ex:\n                if ex.errno != errno.EINTR and ex.errno != errno.EAGAIN:\n                    raise NetBIOSError('Error occurs while waiting for response', ERRCLASS_OS, ex.errno)\n            except socket.error as ex:\n                raise NetBIOSError('Connection error: %s' % str(ex))",
  "def set_nameserver(self, nameserver):\n        self.__nameserver = nameserver",
  "def get_nameserver(self):\n        return self.__nameserver",
  "def set_broadcastaddr(self, broadcastaddr):\n        self.__broadcastaddr = broadcastaddr",
  "def get_broadcastaddr(self):\n        return self.__broadcastaddr",
  "def gethostbyname(self, nbname, qtype = TYPE_WORKSTATION, scope = None, timeout = 1):\n        resp = self.name_query_request(nbname, self.__nameserver, qtype, scope, timeout)\n        return resp",
  "def getnodestatus(self, nbname, destaddr = None, type = TYPE_WORKSTATION, scope = None, timeout = 1):\n        if destaddr:\n            return self.node_status_request(nbname, destaddr, type, scope, timeout)\n        else:\n            return self.node_status_request(nbname, self.__nameserver, type, scope, timeout)",
  "def getnetbiosname(self, ip):\n        entries = self.getnodestatus('*',ip)\n        entries = [x for x in entries if x['TYPE'] == TYPE_SERVER]\n        return entries[0]['NAME'].strip().decode('latin-1')",
  "def getmacaddress(self):\n        return self.mac",
  "def name_registration_request(self, nbname, destaddr, qtype, scope, nb_flags=0, nb_address='0.0.0.0'):\n        netbios_name = nbname.upper()\n        qn_label = encode_name(netbios_name, qtype, scope)\n\n        p = NAME_REGISTRATION_REQUEST()\n        p['NAME_TRN_ID'] = rand.randint(1, 32000)\n        p['QUESTION_NAME'] = qn_label[:-1] + b'\\x00'\n        p['RR_NAME'] = qn_label[:-1] + b'\\x00'\n        p['TTL'] = 0xffff\n        p['NB_FLAGS'] = nb_flags\n        p['NB_ADDRESS'] = socket.inet_aton(nb_address)\n        if not destaddr:\n            p['FLAGS'] |= NM_FLAGS_BROADCAST\n            destaddr = self.__broadcastaddr\n\n        res = self.send(p, destaddr, 1)\n        return res",
  "def name_query_request(self, nbname, destaddr = None, qtype = TYPE_SERVER, scope = None, timeout = 1):\n        netbios_name = nbname.upper()\n        qn_label = encode_name(netbios_name, qtype, scope)\n\n        p = NAME_QUERY_REQUEST()\n        p['NAME_TRN_ID'] = rand.randint(1, 32000)\n        p['QUESTION_NAME'] = qn_label[:-1] + b'\\x00'\n        p['FLAGS'] = NM_FLAGS_RD\n        if not destaddr:\n            p['FLAGS'] |= NM_FLAGS_BROADCAST\n\n            destaddr = self.__broadcastaddr\n\n        res = self.send(p, destaddr, timeout)\n        return NBPositiveNameQueryResponse(res['ANSWERS'])",
  "def node_status_request(self, nbname, destaddr, type, scope, timeout):\n        netbios_name = nbname.upper()\n        qn_label = encode_name(netbios_name, type, scope)\n        p = NODE_STATUS_REQUEST()\n        p['NAME_TRN_ID'] = rand.randint(1, 32000)\n        p['QUESTION_NAME'] = qn_label[:-1] + b'\\x00'\n\n        if not destaddr:\n            p['FLAGS'] = NM_FLAGS_BROADCAST\n            destaddr = self.__broadcastaddr\n\n        res = self.send(p, destaddr, timeout)\n        answ = NBNodeStatusResponse(res['ANSWERS'])\n        self.mac = answ.get_mac()\n        return answ.entries",
  "def __init__(self, data=0):\n        self.type = 0x0\n        self.flags = 0x0\n        self.length = 0x0\n        if data == 0:\n            self._trailer = b''\n        else:\n            try:\n                self.type = indexbytes(data,0)\n                if self.type == NETBIOS_SESSION_MESSAGE:\n                    self.length = indexbytes(data,1) << 16 | (unpack('!H', data[2:4])[0])\n                else:\n                    self.flags = data[1]\n                    self.length = unpack('!H', data[2:4])[0]\n\n                self._trailer = data[4:]\n            except:\n                raise NetBIOSError('Wrong packet format ')",
  "def set_type(self, type):\n        self.type = type",
  "def get_type(self):\n        return self.type",
  "def rawData(self):\n        if self.type == NETBIOS_SESSION_MESSAGE:\n            data = pack('!BBH', self.type, self.length >> 16, self.length & 0xFFFF) + self._trailer\n        else:\n            data = pack('!BBH', self.type, self.flags, self.length) + self._trailer\n        return data",
  "def set_trailer(self, data):\n        self._trailer = data\n        self.length = len(data)",
  "def get_length(self):\n        return self.length",
  "def get_trailer(self):\n        return self._trailer",
  "def __init__(self, myname, remote_name, remote_host, remote_type=TYPE_SERVER, sess_port=NETBIOS_SESSION_PORT,\n                 timeout=None, local_type=TYPE_WORKSTATION, sock=None):\n        \"\"\"\n\n        :param unicode myname: My local NetBIOS name\n        :param unicode remote_name: Remote NetBIOS name\n        :param unicode remote_host: Remote IP Address\n        :param integer remote_type: NetBIOS Host type\n        :param integer sess_port: Session port to connect (139,445)\n        :param integer timeout: Timeout for connection\n        :param integer local_type: My Local Host Type\n        :param socket sock: Socket for already established connection\n        \"\"\"\n        if len(myname) > 15:\n            self.__myname = myname[:15].upper()\n        else:\n            self.__myname = myname.upper()\n        self.__local_type = local_type\n\n        assert remote_name\n        # if destination port SMB_SESSION_PORT and remote name *SMBSERVER, we're changing it to its IP address\n        # helping solving the client mistake ;)\n        if remote_name == '*SMBSERVER' and sess_port == SMB_SESSION_PORT:\n            remote_name = remote_host\n\n        # If remote name is *SMBSERVER let's try to query its name.. if can't be guessed, continue and hope for the best\n\n        if remote_name == '*SMBSERVER':\n            nb = NetBIOS()\n            try:\n                res = nb.getnetbiosname(remote_host)\n            except:\n                res = None\n                pass\n\n            if res is not None:\n                remote_name = res\n\n        if len(remote_name) > 15:\n            self.__remote_name = remote_name[:15].upper()\n        else:\n            self.__remote_name = remote_name.upper()\n        self.__remote_type = remote_type\n        self.__remote_host = remote_host\n\n        if sock is not None:\n            # We are acting as a server\n            self._sock = sock\n        else:\n            self._sock = self._setup_connection((remote_host, sess_port), timeout)\n\n        if sess_port == NETBIOS_SESSION_PORT:\n            self._request_session(remote_type, local_type, timeout)",
  "def _request_session(self, remote_type, local_type, timeout):\n        raise NotImplementedError('Not Implemented!')",
  "def _setup_connection(self, peer, timeout=None):\n        raise NotImplementedError('Not Implemented!')",
  "def get_myname(self):\n        return self.__myname",
  "def get_mytype(self):\n        return self.__local_type",
  "def get_remote_host(self):\n        return self.__remote_host",
  "def get_remote_name(self):\n        return self.__remote_name",
  "def get_remote_type(self):\n        return self.__remote_type",
  "def close(self):\n        self._sock.close()",
  "def get_socket(self):\n        return self._sock",
  "def getData(self):\n        addr = self['SourceIP'].split('.')\n        addr = [int(x) for x in addr]\n        addr = (((addr[0] << 8) + addr[1] << 8) + addr[2] << 8) + addr[3]\n        self['_SourceIP'] = addr\n        return Structure.getData(self)",
  "def get_trailer(self):\n        return self['Data']",
  "def _setup_connection(self, peer, timeout=None):\n        af, socktype, proto, canonname, sa = socket.getaddrinfo(peer[0], peer[1], 0, socket.SOCK_DGRAM)[0]\n        sock = socket.socket(af, socktype, proto)\n        sock.connect(sa)\n\n        sock = socket.socket(af, socktype, proto)\n        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n        sock.bind((INADDR_ANY, 138))\n        self.peer = peer\n        return sock",
  "def _request_session(self, remote_type, local_type, timeout = None):\n        pass",
  "def next_id(self):\n        if hasattr(self, '__dgram_id'):\n            answer = self.__dgram_id\n        else:\n            self.__dgram_id = rand.randint(1,65535)\n            answer = self.__dgram_id\n        self.__dgram_id += 1\n        return answer",
  "def send_packet(self, data):\n        # Yes... I know...\n        self._sock.connect(self.peer)\n\n        p = NetBIOSUDPSessionPacket()\n        p['ID'] = self.next_id()\n        p['SourceIP'] = self._sock.getsockname()[0]\n        p['SourceName'] = encode_name(self.get_myname(), self.get_mytype(), '')[:-1]\n        p['DestinationName'] = encode_name(self.get_remote_name(), self.get_remote_type(), '')[:-1]\n        p['Data'] = data\n\n        self._sock.sendto(str(p), self.peer)\n        self._sock.close()\n\n        self._sock = self._setup_connection(self.peer)",
  "def recv_packet(self, timeout = None):\n        # The next loop is a workaround for a bigger problem:\n        # When data reaches higher layers, the lower headers are lost,\n        # and with them, for example, the source IP. Hence, SMB users\n        # can't know where packets are coming from... we need a better\n        # solution, right now, we will filter everything except packets\n        # coming from the remote_host specified in __init__()\n\n        while 1:\n            data, peer = self._sock.recvfrom(8192)\n#            print \"peer: %r  self.peer: %r\" % (peer, self.peer)\n            if peer == self.peer:\n                break\n\n        return NetBIOSUDPSessionPacket(data)",
  "def __init__(self, myname, remote_name, remote_host, remote_type=TYPE_SERVER, sess_port=NETBIOS_SESSION_PORT,\n                 timeout=None, local_type=TYPE_WORKSTATION, sock=None, select_poll=False):\n        \"\"\"\n        \n        :param unicode myname: My local NetBIOS name\n        :param unicode remote_name: Remote NetBIOS name\n        :param unicode remote_host: Remote IP Address\n        :param integer remote_type: NetBIOS Host type\n        :param integer sess_port: Session port to connect (139,445)\n        :param integer timeout: Timeout for connection\n        :param integer local_type: My Local Host Type\n        :param socket sock: Socket for already established connection\n        :param boolean select_poll: Type of polling mechanism\n        \"\"\"\n        self.__select_poll = select_poll\n        if self.__select_poll:\n            self.read_function = self.polling_read\n        else:\n            self.read_function = self.non_polling_read\n        NetBIOSSession.__init__(self, myname, remote_name, remote_host, remote_type=remote_type, sess_port=sess_port,\n                                timeout=timeout, local_type=local_type, sock=sock)",
  "def _setup_connection(self, peer, timeout=None):\n        try:\n            af, socktype, proto, canonname, sa = socket.getaddrinfo(peer[0], peer[1], 0, socket.SOCK_STREAM)[0]\n            sock = socket.socket(af, socktype, proto)\n            oldtimeout = sock.gettimeout()\n            sock.settimeout(timeout)\n            sock.connect(sa)\n            sock.settimeout(oldtimeout)\n        except socket.error as e:\n            raise socket.error(\"Connection error (%s:%s)\" % (peer[0], peer[1]), e)\n        return sock",
  "def send_packet(self, data):\n        p = NetBIOSSessionPacket()\n        p.set_type(NETBIOS_SESSION_MESSAGE)\n        p.set_trailer(data)\n        self._sock.sendall(p.rawData())",
  "def recv_packet(self, timeout = None):\n        data = self.__read(timeout)\n        NBSPacket = NetBIOSSessionPacket(data)\n        if NBSPacket.get_type() == NETBIOS_SESSION_KEEP_ALIVE:\n            # Discard packet\n            return self.recv_packet(timeout)\n        return NetBIOSSessionPacket(data)",
  "def _request_session(self, remote_type, local_type, timeout = None):\n        p = NetBIOSSessionPacket()\n        remote_name = encode_name(self.get_remote_name(), remote_type, '')\n        myname = encode_name(self.get_myname(), local_type, '')\n        p.set_type(NETBIOS_SESSION_REQUEST)\n        p.set_trailer(remote_name + myname)\n\n        self._sock.sendall(p.rawData())\n        while 1:\n            p = self.recv_packet(timeout)\n            if p.get_type() == NETBIOS_SESSION_NEGATIVE_RESPONSE:\n                raise NetBIOSError('Cannot request session (Called Name:%s)' % self.get_remote_name())\n            elif p.get_type() == NETBIOS_SESSION_POSITIVE_RESPONSE:\n                break\n            else:\n                # Ignore all other messages, most probably keepalive messages\n                pass",
  "def polling_read(self, read_length, timeout):\n        data = b''\n        if timeout is None:\n            timeout = 3600\n\n        time_left = timeout\n        CHUNK_TIME = 0.025\n        bytes_left = read_length\n\n        while bytes_left > 0:\n            try:\n                ready, _, _ = select.select([self._sock.fileno()], [], [], 0)\n\n                if not ready:\n                    if time_left <= 0:\n                        raise NetBIOSTimeout\n                    else:\n                        time.sleep(CHUNK_TIME)\n                        time_left -= CHUNK_TIME\n                        continue\n\n                received = self._sock.recv(bytes_left)\n                if len(received) == 0:\n                    raise NetBIOSError('Error while reading from remote', ERRCLASS_OS, None)\n\n                data = data + received\n                bytes_left = read_length - len(data)\n            except select.error as ex:\n                if ex.errno != errno.EINTR and ex.errno != errno.EAGAIN:\n                    raise NetBIOSError('Error occurs while reading from remote', ERRCLASS_OS, ex.errno)\n\n        return bytes(data)",
  "def non_polling_read(self, read_length, timeout):\n        data = b''\n        if timeout is None:\n            timeout = 3600\n\n        start_time = time.time()\n        bytes_left = read_length\n\n        while bytes_left > 0:\n            self._sock.settimeout(timeout)\n            try:\n                received = self._sock.recv(bytes_left)\n            except socket.timeout:\n                raise NetBIOSTimeout\n            except Exception as ex:\n                raise NetBIOSError('Error occurs while reading from remote', ERRCLASS_OS, ex.errno)\n\n            if (time.time() - start_time) > timeout:\n                raise NetBIOSTimeout\n\n            if len(received) == 0:\n                raise NetBIOSError('Error while reading from remote', ERRCLASS_OS, None)\n\n            data = data + received\n            bytes_left = read_length - len(data)\n\n        return bytes(data)",
  "def __read(self, timeout = None):\n        data = self.read_function(4, timeout)\n        type, flags, length = unpack('>ccH', data)\n        if ord(type) == NETBIOS_SESSION_MESSAGE:\n            length |= ord(flags) << 16\n        else:\n            if ord(flags) & 0x01:\n                length |= 0x10000\n        data2 = self.read_function(length, timeout)\n\n        return data + data2",
  "def asn1encode(data = ''):\n        #res = asn1.SEQUENCE(str).encode()\n        #import binascii\n        #print '\\nalex asn1encode str: %s\\n' % binascii.hexlify(str)\n        if 0 <= len(data) <= 0x7F:\n            res = pack('B', len(data)) + data\n        elif 0x80 <= len(data) <= 0xFF:\n            res = pack('BB', 0x81, len(data)) + data\n        elif 0x100 <= len(data) <= 0xFFFF:\n            res = pack('!BH', 0x82, len(data)) + data\n        elif 0x10000 <= len(data) <= 0xffffff:\n            res = pack('!BBH', 0x83, len(data) >> 16, len(data) & 0xFFFF) + data\n        elif 0x1000000 <= len(data) <= 0xffffffff:\n            res = pack('!BL', 0x84, len(data)) + data\n        else:\n            raise Exception('Error in asn1encode')\n        return res",
  "def asn1decode(data = ''):\n        len1 = unpack('B', data[:1])[0]\n        data = data[1:]\n        if len1 == 0x81:\n            pad = calcsize('B')\n            len2 = unpack('B',data[:pad])[0]\n            data = data[pad:]\n            ans = data[:len2]\n        elif len1 == 0x82:\n            pad = calcsize('H')\n            len2 = unpack('!H', data[:pad])[0]\n            data = data[pad:]\n            ans = data[:len2]\n        elif len1 == 0x83:\n            pad = calcsize('B') + calcsize('!H')\n            len2, len3 = unpack('!BH', data[:pad])\n            data = data[pad:]\n            ans = data[:len2 << 16 + len3]\n        elif len1 == 0x84:\n            pad = calcsize('!L')\n            len2 = unpack('!L', data[:pad])[0]\n            data = data[pad:]\n            ans = data[:len2]\n        # 1 byte length, string <= 0x7F\n        else:\n            pad = 0\n            ans = data[:len1]\n        return ans, len(ans)+pad+1",
  "class GSSAPI:\n# Generic GSSAPI Header Format \n    def __init__(self, data = None):\n        self.fields = {}\n        self['UUID'] = GSS_API_SPNEGO_UUID\n        if data:\n             self.fromString(data)\n        pass\n\n    def __setitem__(self,key,value):\n        self.fields[key] = value\n\n    def __getitem__(self, key):\n        return self.fields[key]\n\n    def __delitem__(self, key):\n        del self.fields[key]\n\n    def __len__(self):\n        return len(self.getData())\n\n    def __str__(self):\n        return len(self.getData())\n\n    def fromString(self, data = None):\n        # Manual parse of the GSSAPI Header Format\n        # It should be something like\n        # AID = 0x60 TAG, BER Length\n        # OID = 0x06 TAG\n        # GSSAPI OID\n        # UUID data (BER Encoded)\n        # Payload\n        next_byte = unpack('B',data[:1])[0]\n        if next_byte != ASN1_AID:\n            raise Exception('Unknown AID=%x' % next_byte)\n        data = data[1:]\n        decode_data, total_bytes = asn1decode(data) \n        # Now we should have a OID tag\n        next_byte = unpack('B',decode_data[:1])[0]\n        if next_byte !=  ASN1_OID:\n            raise Exception('OID tag not found %x' % next_byte)\n        decode_data = decode_data[1:]\n        # Now the OID contents, should be SPNEGO UUID\n        uuid, total_bytes = asn1decode(decode_data)\n        self['OID'] = uuid\n        # the rest should be the data\n        self['Payload'] = decode_data[total_bytes:]\n        #pass\n\n    def dump(self):\n        for i in list(self.fields.keys()):\n            print(\"%s: {%r}\" % (i,self[i]))\n\n    def getData(self):\n        ans = pack('B',ASN1_AID)\n        ans += asn1encode(\n               pack('B',ASN1_OID) + \n               asn1encode(self['UUID']) +\n               self['Payload'] )\n        return ans",
  "class SPNEGO_NegTokenResp:\n    # https://tools.ietf.org/html/rfc4178#page-9\n    # NegTokenResp ::= SEQUENCE {\n    #     negState       [0] ENUMERATED {\n    #         accept-completed    (0),\n    #         accept-incomplete   (1),\n    #         reject              (2),\n    #         request-mic         (3)\n    #     }                                 OPTIONAL,\n    #       -- REQUIRED in the first reply from the target\n    #     supportedMech   [1] MechType      OPTIONAL,\n    #       -- present only in the first reply from the target\n    #     responseToken   [2] OCTET STRING  OPTIONAL,\n    #     mechListMIC     [3] OCTET STRING  OPTIONAL,\n    #     ...\n    # }\n    # This structure is not prepended by a GSS generic header!\n    SPNEGO_NEG_TOKEN_RESP = 0xa1\n    SPNEGO_NEG_TOKEN_TARG = 0xa0\n\n    def __init__(self, data = None):\n        self.fields = {}\n        if data:\n             self.fromString(data)\n        pass\n\n    def __setitem__(self,key,value):\n        self.fields[key] = value\n\n    def __getitem__(self, key):\n        return self.fields[key]\n\n    def __delitem__(self, key):\n        del self.fields[key]\n\n    def __len__(self):\n        return len(self.getData())\n\n    def __str__(self):\n        return self.getData()\n\n    def fromString(self, data = 0):\n        payload = data\n        next_byte = unpack('B', payload[:1])[0]\n        if next_byte != SPNEGO_NegTokenResp.SPNEGO_NEG_TOKEN_RESP:\n            raise Exception('NegTokenResp not found %x' % next_byte)\n        payload = payload[1:]\n        decode_data, total_bytes = asn1decode(payload)\n        next_byte = unpack('B', decode_data[:1])[0]\n        if next_byte != ASN1_SEQUENCE:\n            raise Exception('SEQUENCE tag not found %x' % next_byte)\n        decode_data = decode_data[1:]\n        decode_data, total_bytes = asn1decode(decode_data)\n        next_byte = unpack('B',decode_data[:1])[0]\n\n        if next_byte != ASN1_MECH_TYPE:\n            # MechType not found, could be an AUTH answer\n            if next_byte != ASN1_RESPONSE_TOKEN:\n               raise Exception('MechType/ResponseToken tag not found %x' % next_byte)\n        else:\n            decode_data2 = decode_data[1:]\n            decode_data2, total_bytes = asn1decode(decode_data2)\n            next_byte = unpack('B', decode_data2[:1])[0]\n            if next_byte != ASN1_ENUMERATED:\n                raise Exception('Enumerated tag not found %x' % next_byte)\n            item, total_bytes2 = asn1decode(decode_data2[1:])\n            self['NegState'] = item\n            decode_data = decode_data[1:]\n            decode_data = decode_data[total_bytes:]\n\n            # Do we have more data?\n            if len(decode_data) == 0:\n                return\n\n            next_byte = unpack('B', decode_data[:1])[0]\n            if next_byte != ASN1_SUPPORTED_MECH:\n                if next_byte != ASN1_RESPONSE_TOKEN:\n                    raise Exception('Supported Mech/ResponseToken tag not found %x' % next_byte)\n            else:\n                decode_data2 = decode_data[1:]\n                decode_data2, total_bytes = asn1decode(decode_data2)\n                next_byte = unpack('B', decode_data2[:1])[0]\n                if next_byte != ASN1_OID:\n                    raise Exception('OID tag not found %x' % next_byte)\n                decode_data2 = decode_data2[1:]\n                item, total_bytes2 = asn1decode(decode_data2)\n                self['SupportedMech'] = item\n\n                decode_data = decode_data[1:]\n                decode_data = decode_data[total_bytes:]\n                next_byte = unpack('B', decode_data[:1])[0]\n                if next_byte != ASN1_RESPONSE_TOKEN:\n                    raise Exception('Response token tag not found %x' % next_byte)\n\n        decode_data = decode_data[1:]\n        decode_data, total_bytes = asn1decode(decode_data)\n        next_byte = unpack('B', decode_data[:1])[0]\n        if next_byte != ASN1_OCTET_STRING:\n            raise Exception('Octet string token tag not found %x' % next_byte)\n        decode_data = decode_data[1:]\n        decode_data, total_bytes = asn1decode(decode_data)\n        self['ResponseToken'] = decode_data\n\n    def dump(self):\n        for i in list(self.fields.keys()):\n            print(\"%s: {%r}\" % (i,self[i]))\n    def getData(self):\n        ans = pack('B',SPNEGO_NegTokenResp.SPNEGO_NEG_TOKEN_RESP)\n        if 'NegState' in self.fields and 'SupportedMech' in self.fields and 'ResponseToken' in self.fields:\n            # Server resp\n            ans += asn1encode(\n               pack('B', ASN1_SEQUENCE) +\n               asn1encode(\n               pack('B',SPNEGO_NegTokenResp.SPNEGO_NEG_TOKEN_TARG) +\n               asn1encode(\n               pack('B',ASN1_ENUMERATED) + \n               asn1encode( self['NegState'] )) +\n               pack('B',ASN1_SUPPORTED_MECH) +\n               asn1encode( \n               pack('B',ASN1_OID) +\n               asn1encode(self['SupportedMech'])) +\n               pack('B',ASN1_RESPONSE_TOKEN ) +\n               asn1encode(\n               pack('B', ASN1_OCTET_STRING) + asn1encode(self['ResponseToken']))))\n        elif 'NegState' in self.fields and 'SupportedMech' in self.fields:\n            # Server resp\n            ans += asn1encode(\n               pack('B', ASN1_SEQUENCE) +\n               asn1encode(\n               pack('B',SPNEGO_NegTokenResp.SPNEGO_NEG_TOKEN_TARG) +\n               asn1encode(\n               pack('B',ASN1_ENUMERATED) +\n               asn1encode( self['NegState'] )) +\n               pack('B',ASN1_SUPPORTED_MECH) +\n               asn1encode(\n               pack('B',ASN1_OID) +\n               asn1encode(self['SupportedMech']))))\n        elif 'NegState' in self.fields:\n            # Server resp\n            ans += asn1encode(\n               pack('B', ASN1_SEQUENCE) + \n               asn1encode(\n               pack('B', SPNEGO_NegTokenResp.SPNEGO_NEG_TOKEN_TARG) +\n               asn1encode(\n               pack('B',ASN1_ENUMERATED) +\n               asn1encode( self['NegState'] ))))\n        else:\n            # Client resp\n            ans += asn1encode(\n               pack('B', ASN1_SEQUENCE) +\n               asn1encode(\n               pack('B', ASN1_RESPONSE_TOKEN) +\n               asn1encode(\n               pack('B', ASN1_OCTET_STRING) + asn1encode(self['ResponseToken']))))\n        return ans",
  "class SPNEGO_NegTokenInit(GSSAPI):\n    # https://tools.ietf.org/html/rfc4178#page-8\n    # NegTokeInit :: = SEQUENCE {\n    #   mechTypes       [0] MechTypeList,\n    #   reqFlags        [1] ContextFlags OPTIONAL,\n    #   mechToken       [2] OCTET STRING OPTIONAL,\n    #   mechListMIC     [3] OCTET STRING OPTIONAL,\n    # }\n    SPNEGO_NEG_TOKEN_INIT = 0xa0\n    def fromString(self, data = 0):\n        GSSAPI.fromString(self, data)\n        payload = self['Payload']\n        next_byte = unpack('B', payload[:1])[0] \n        if next_byte != SPNEGO_NegTokenInit.SPNEGO_NEG_TOKEN_INIT:\n            raise Exception('NegTokenInit not found %x' % next_byte)\n        payload = payload[1:]\n        decode_data, total_bytes = asn1decode(payload)\n        # Now we should have a SEQUENCE Tag\n        next_byte = unpack('B', decode_data[:1])[0]\n        if next_byte != ASN1_SEQUENCE:\n            raise Exception('SEQUENCE tag not found %x' % next_byte)\n        decode_data = decode_data[1:]\n        decode_data, total_bytes2 = asn1decode(decode_data)\n        next_byte = unpack('B',decode_data[:1])[0]\n        if next_byte != ASN1_MECH_TYPE:\n            raise Exception('MechType tag not found %x' % next_byte)\n        decode_data = decode_data[1:]\n        remaining_data = decode_data\n        decode_data, total_bytes3 = asn1decode(decode_data)\n        next_byte = unpack('B', decode_data[:1])[0]\n        if next_byte != ASN1_SEQUENCE:\n            raise Exception('SEQUENCE tag not found %x' % next_byte)\n        decode_data = decode_data[1:]\n        decode_data, total_bytes4 = asn1decode(decode_data)\n        # And finally we should have the MechTypes\n        self['MechTypes'] = []\n        while decode_data:\n           next_byte = unpack('B', decode_data[:1])[0]\n           if next_byte != ASN1_OID:    \n             # Not a valid OID, there must be something else we won't unpack\n             break\n           decode_data = decode_data[1:]\n           item, total_bytes = asn1decode(decode_data)\n           self['MechTypes'].append(item)\n           decode_data = decode_data[total_bytes:]\n\n        # Do we have MechTokens as well?\n        decode_data = remaining_data[total_bytes3:]\n        if len(decode_data) > 0:\n            next_byte = unpack('B', decode_data[:1])[0]\n            if next_byte == ASN1_MECH_TOKEN:\n                # We have tokens in here!\n                decode_data = decode_data[1:]\n                decode_data, total_bytes = asn1decode(decode_data)\n                next_byte = unpack('B', decode_data[:1])[0]\n                if next_byte ==  ASN1_OCTET_STRING:\n                    decode_data = decode_data[1:]\n                    decode_data, total_bytes = asn1decode(decode_data)\n                    self['MechToken'] =  decode_data\n\n    def getData(self):\n        mechTypes = b''\n        for i in self['MechTypes']:\n            mechTypes += pack('B', ASN1_OID)\n            mechTypes += asn1encode(i)\n\n        mechToken = b''\n        # Do we have tokens to send?\n        if 'MechToken' in self.fields:\n            mechToken = pack('B', ASN1_MECH_TOKEN) + asn1encode(\n                pack('B', ASN1_OCTET_STRING) + asn1encode(\n                    self['MechToken']))\n\n        ans = pack('B',SPNEGO_NegTokenInit.SPNEGO_NEG_TOKEN_INIT)\n        ans += asn1encode(\n               pack('B', ASN1_SEQUENCE) +\n               asn1encode(\n               pack('B', ASN1_MECH_TYPE) +\n               asn1encode(\n               pack('B', ASN1_SEQUENCE) + \n               asn1encode(mechTypes)) + mechToken ))\n\n\n        self['Payload'] = ans\n        return GSSAPI.getData(self)",
  "def __init__(self, data = None):\n        self.fields = {}\n        self['UUID'] = GSS_API_SPNEGO_UUID\n        if data:\n             self.fromString(data)\n        pass",
  "def __setitem__(self,key,value):\n        self.fields[key] = value",
  "def __getitem__(self, key):\n        return self.fields[key]",
  "def __delitem__(self, key):\n        del self.fields[key]",
  "def __len__(self):\n        return len(self.getData())",
  "def __str__(self):\n        return len(self.getData())",
  "def fromString(self, data = None):\n        # Manual parse of the GSSAPI Header Format\n        # It should be something like\n        # AID = 0x60 TAG, BER Length\n        # OID = 0x06 TAG\n        # GSSAPI OID\n        # UUID data (BER Encoded)\n        # Payload\n        next_byte = unpack('B',data[:1])[0]\n        if next_byte != ASN1_AID:\n            raise Exception('Unknown AID=%x' % next_byte)\n        data = data[1:]\n        decode_data, total_bytes = asn1decode(data) \n        # Now we should have a OID tag\n        next_byte = unpack('B',decode_data[:1])[0]\n        if next_byte !=  ASN1_OID:\n            raise Exception('OID tag not found %x' % next_byte)\n        decode_data = decode_data[1:]\n        # Now the OID contents, should be SPNEGO UUID\n        uuid, total_bytes = asn1decode(decode_data)\n        self['OID'] = uuid\n        # the rest should be the data\n        self['Payload'] = decode_data[total_bytes:]",
  "def dump(self):\n        for i in list(self.fields.keys()):\n            print(\"%s: {%r}\" % (i,self[i]))",
  "def getData(self):\n        ans = pack('B',ASN1_AID)\n        ans += asn1encode(\n               pack('B',ASN1_OID) + \n               asn1encode(self['UUID']) +\n               self['Payload'] )\n        return ans",
  "def __init__(self, data = None):\n        self.fields = {}\n        if data:\n             self.fromString(data)\n        pass",
  "def __setitem__(self,key,value):\n        self.fields[key] = value",
  "def __getitem__(self, key):\n        return self.fields[key]",
  "def __delitem__(self, key):\n        del self.fields[key]",
  "def __len__(self):\n        return len(self.getData())",
  "def __str__(self):\n        return self.getData()",
  "def fromString(self, data = 0):\n        payload = data\n        next_byte = unpack('B', payload[:1])[0]\n        if next_byte != SPNEGO_NegTokenResp.SPNEGO_NEG_TOKEN_RESP:\n            raise Exception('NegTokenResp not found %x' % next_byte)\n        payload = payload[1:]\n        decode_data, total_bytes = asn1decode(payload)\n        next_byte = unpack('B', decode_data[:1])[0]\n        if next_byte != ASN1_SEQUENCE:\n            raise Exception('SEQUENCE tag not found %x' % next_byte)\n        decode_data = decode_data[1:]\n        decode_data, total_bytes = asn1decode(decode_data)\n        next_byte = unpack('B',decode_data[:1])[0]\n\n        if next_byte != ASN1_MECH_TYPE:\n            # MechType not found, could be an AUTH answer\n            if next_byte != ASN1_RESPONSE_TOKEN:\n               raise Exception('MechType/ResponseToken tag not found %x' % next_byte)\n        else:\n            decode_data2 = decode_data[1:]\n            decode_data2, total_bytes = asn1decode(decode_data2)\n            next_byte = unpack('B', decode_data2[:1])[0]\n            if next_byte != ASN1_ENUMERATED:\n                raise Exception('Enumerated tag not found %x' % next_byte)\n            item, total_bytes2 = asn1decode(decode_data2[1:])\n            self['NegState'] = item\n            decode_data = decode_data[1:]\n            decode_data = decode_data[total_bytes:]\n\n            # Do we have more data?\n            if len(decode_data) == 0:\n                return\n\n            next_byte = unpack('B', decode_data[:1])[0]\n            if next_byte != ASN1_SUPPORTED_MECH:\n                if next_byte != ASN1_RESPONSE_TOKEN:\n                    raise Exception('Supported Mech/ResponseToken tag not found %x' % next_byte)\n            else:\n                decode_data2 = decode_data[1:]\n                decode_data2, total_bytes = asn1decode(decode_data2)\n                next_byte = unpack('B', decode_data2[:1])[0]\n                if next_byte != ASN1_OID:\n                    raise Exception('OID tag not found %x' % next_byte)\n                decode_data2 = decode_data2[1:]\n                item, total_bytes2 = asn1decode(decode_data2)\n                self['SupportedMech'] = item\n\n                decode_data = decode_data[1:]\n                decode_data = decode_data[total_bytes:]\n                next_byte = unpack('B', decode_data[:1])[0]\n                if next_byte != ASN1_RESPONSE_TOKEN:\n                    raise Exception('Response token tag not found %x' % next_byte)\n\n        decode_data = decode_data[1:]\n        decode_data, total_bytes = asn1decode(decode_data)\n        next_byte = unpack('B', decode_data[:1])[0]\n        if next_byte != ASN1_OCTET_STRING:\n            raise Exception('Octet string token tag not found %x' % next_byte)\n        decode_data = decode_data[1:]\n        decode_data, total_bytes = asn1decode(decode_data)\n        self['ResponseToken'] = decode_data",
  "def dump(self):\n        for i in list(self.fields.keys()):\n            print(\"%s: {%r}\" % (i,self[i]))",
  "def getData(self):\n        ans = pack('B',SPNEGO_NegTokenResp.SPNEGO_NEG_TOKEN_RESP)\n        if 'NegState' in self.fields and 'SupportedMech' in self.fields and 'ResponseToken' in self.fields:\n            # Server resp\n            ans += asn1encode(\n               pack('B', ASN1_SEQUENCE) +\n               asn1encode(\n               pack('B',SPNEGO_NegTokenResp.SPNEGO_NEG_TOKEN_TARG) +\n               asn1encode(\n               pack('B',ASN1_ENUMERATED) + \n               asn1encode( self['NegState'] )) +\n               pack('B',ASN1_SUPPORTED_MECH) +\n               asn1encode( \n               pack('B',ASN1_OID) +\n               asn1encode(self['SupportedMech'])) +\n               pack('B',ASN1_RESPONSE_TOKEN ) +\n               asn1encode(\n               pack('B', ASN1_OCTET_STRING) + asn1encode(self['ResponseToken']))))\n        elif 'NegState' in self.fields and 'SupportedMech' in self.fields:\n            # Server resp\n            ans += asn1encode(\n               pack('B', ASN1_SEQUENCE) +\n               asn1encode(\n               pack('B',SPNEGO_NegTokenResp.SPNEGO_NEG_TOKEN_TARG) +\n               asn1encode(\n               pack('B',ASN1_ENUMERATED) +\n               asn1encode( self['NegState'] )) +\n               pack('B',ASN1_SUPPORTED_MECH) +\n               asn1encode(\n               pack('B',ASN1_OID) +\n               asn1encode(self['SupportedMech']))))\n        elif 'NegState' in self.fields:\n            # Server resp\n            ans += asn1encode(\n               pack('B', ASN1_SEQUENCE) + \n               asn1encode(\n               pack('B', SPNEGO_NegTokenResp.SPNEGO_NEG_TOKEN_TARG) +\n               asn1encode(\n               pack('B',ASN1_ENUMERATED) +\n               asn1encode( self['NegState'] ))))\n        else:\n            # Client resp\n            ans += asn1encode(\n               pack('B', ASN1_SEQUENCE) +\n               asn1encode(\n               pack('B', ASN1_RESPONSE_TOKEN) +\n               asn1encode(\n               pack('B', ASN1_OCTET_STRING) + asn1encode(self['ResponseToken']))))\n        return ans",
  "def fromString(self, data = 0):\n        GSSAPI.fromString(self, data)\n        payload = self['Payload']\n        next_byte = unpack('B', payload[:1])[0] \n        if next_byte != SPNEGO_NegTokenInit.SPNEGO_NEG_TOKEN_INIT:\n            raise Exception('NegTokenInit not found %x' % next_byte)\n        payload = payload[1:]\n        decode_data, total_bytes = asn1decode(payload)\n        # Now we should have a SEQUENCE Tag\n        next_byte = unpack('B', decode_data[:1])[0]\n        if next_byte != ASN1_SEQUENCE:\n            raise Exception('SEQUENCE tag not found %x' % next_byte)\n        decode_data = decode_data[1:]\n        decode_data, total_bytes2 = asn1decode(decode_data)\n        next_byte = unpack('B',decode_data[:1])[0]\n        if next_byte != ASN1_MECH_TYPE:\n            raise Exception('MechType tag not found %x' % next_byte)\n        decode_data = decode_data[1:]\n        remaining_data = decode_data\n        decode_data, total_bytes3 = asn1decode(decode_data)\n        next_byte = unpack('B', decode_data[:1])[0]\n        if next_byte != ASN1_SEQUENCE:\n            raise Exception('SEQUENCE tag not found %x' % next_byte)\n        decode_data = decode_data[1:]\n        decode_data, total_bytes4 = asn1decode(decode_data)\n        # And finally we should have the MechTypes\n        self['MechTypes'] = []\n        while decode_data:\n           next_byte = unpack('B', decode_data[:1])[0]\n           if next_byte != ASN1_OID:    \n             # Not a valid OID, there must be something else we won't unpack\n             break\n           decode_data = decode_data[1:]\n           item, total_bytes = asn1decode(decode_data)\n           self['MechTypes'].append(item)\n           decode_data = decode_data[total_bytes:]\n\n        # Do we have MechTokens as well?\n        decode_data = remaining_data[total_bytes3:]\n        if len(decode_data) > 0:\n            next_byte = unpack('B', decode_data[:1])[0]\n            if next_byte == ASN1_MECH_TOKEN:\n                # We have tokens in here!\n                decode_data = decode_data[1:]\n                decode_data, total_bytes = asn1decode(decode_data)\n                next_byte = unpack('B', decode_data[:1])[0]\n                if next_byte ==  ASN1_OCTET_STRING:\n                    decode_data = decode_data[1:]\n                    decode_data, total_bytes = asn1decode(decode_data)\n                    self['MechToken'] =  decode_data",
  "def getData(self):\n        mechTypes = b''\n        for i in self['MechTypes']:\n            mechTypes += pack('B', ASN1_OID)\n            mechTypes += asn1encode(i)\n\n        mechToken = b''\n        # Do we have tokens to send?\n        if 'MechToken' in self.fields:\n            mechToken = pack('B', ASN1_MECH_TOKEN) + asn1encode(\n                pack('B', ASN1_OCTET_STRING) + asn1encode(\n                    self['MechToken']))\n\n        ans = pack('B',SPNEGO_NegTokenInit.SPNEGO_NEG_TOKEN_INIT)\n        ans += asn1encode(\n               pack('B', ASN1_SEQUENCE) +\n               asn1encode(\n               pack('B', ASN1_MECH_TYPE) +\n               asn1encode(\n               pack('B', ASN1_SEQUENCE) + \n               asn1encode(mechTypes)) + mechToken ))\n\n\n        self['Payload'] = ans\n        return GSSAPI.getData(self)",
  "class IP6_Extension_Header(Header):\n# --------------------------------- - - - - - - -\n# | Next Header | Header Ext Len | Options\n# --------------------------------- - - - - - - -\n\n    HEADER_TYPE_VALUE = -1\n    EXTENSION_HEADER_FIELDS_SIZE = 2\n    \n    EXTENSION_HEADER_DECODER = None\n\n    def __init__(self, buffer = None):\n        Header.__init__(self, self.get_headers_field_size())\n        self._option_list = []\n        if buffer:\n            self.load_header(buffer)\n        else:\n            self.reset()\n\n    def __str__(self):\n        header_type = self.get_header_type()\n        next_header_value = self.get_next_header()\n        header_ext_length = self.get_header_extension_length()\n\n        s  = \"Header Extension Name: \" + self.__class__.HEADER_EXTENSION_DESCRIPTION + \"\\n\"\n        s += \"Header Type Value: \" + str(header_type) + \"\\n\"\n        s += \"Next Header: \" + str(next_header_value) + \"\\n\"\n        s += \"Header Extension Length: \" + str(header_ext_length) + \"\\n\"\n        s += \"Options:\\n\"\n        \n        for option in self._option_list:\n            option_str = str(option)\n            option_str = option_str.split('\\n')\n            option_str = [(' ' * 4) + s for s in option_str]\n            s += '\\n'.join(option_str) + '\\n'\n        \n        return s\n\n    def load_header(self, buffer):\n        self.set_bytes_from_string(buffer[:self.get_headers_field_size()])\n        \n        remaining_bytes = (self.get_header_extension_length() + 1) * 8\n        remaining_bytes -= self.get_headers_field_size()\n\n        buffer = array.array('B', buffer[self.get_headers_field_size():])\n        if remaining_bytes > len(buffer):\n            raise ImpactPacketException(\"Cannot load options from truncated packet\")\n\n        while remaining_bytes > 0:\n            option_type = buffer[0]\n            if option_type == Option_PAD1.OPTION_TYPE_VALUE:\n                # Pad1\n                self._option_list.append(Option_PAD1())\n                \n                remaining_bytes -= 1\n                buffer = buffer[1:]\n            else:\n                # PadN\n                # From RFC 2460: For N octets of padding, the Opt Data Len\n                # field contains the value N-2, and the Option Data consists\n                # of N-2 zero-valued octets.\n                option_length = buffer[1]\n                option_length += 2\n                \n                self._option_list.append(Option_PADN(option_length))\n\n                remaining_bytes -= option_length\n                buffer = buffer[option_length:]\n    \n    def reset(self):\n        pass\n\n    @classmethod\n    def get_header_type_value(cls):\n        return cls.HEADER_TYPE_VALUE\n    \n    @classmethod\n    def get_extension_headers(cls):\n        header_types = {}\n        for subclass in cls.__subclasses__():\n            subclass_header_types = subclass.get_extension_headers()\n            if not subclass_header_types:\n                # If the subclass did not return anything it means\n                # that it is a leaf subclass, so we take its header\n                # type value\n                header_types[subclass.get_header_type_value()] = subclass\n            else:\n                # Else we extend the list of the obtained types\n                header_types.update(subclass_header_types)\n        return header_types\n    \n    @classmethod\n    def get_decoder(cls):\n        raise RuntimeError(\"Class method %s.get_decoder must be overridden.\" % cls)\n\n    def get_header_type(self):\n        return self.__class__.get_header_type_value()\n\n    def get_headers_field_size(self):\n        return IP6_Extension_Header.EXTENSION_HEADER_FIELDS_SIZE\n\n    def get_header_size(self):\n        header_size = self.get_headers_field_size()\n        for option in self._option_list:\n            header_size += option.get_len()\n        return header_size\n\n    def get_next_header(self):\n        return self.get_byte(0)\n\n    def get_header_extension_length(self):\n        return self.get_byte(1)\n\n    def set_next_header(self, next_header):\n        self.set_byte(0, next_header & 0xFF)\n\n    def set_header_extension_length(self, header_extension_length):\n        self.set_byte(1, header_extension_length & 0xFF)\n    \n    def add_option(self, option):\n        self._option_list.append(option)\n    \n    def get_options(self):\n        return self._option_list\n\n    def get_packet(self):\n        data = self.get_data_as_string()\n\n        # Update the header length\n        self.set_header_extension_length(self.get_header_size() // 8 - 1)\n\n        # Build the entire extension header packet\n        header_bytes = self.get_buffer_as_string()\n        for option in self._option_list:\n            header_bytes += option.get_buffer_as_string()\n        \n        if data:\n            return header_bytes + data\n        else:\n            return header_bytes\n\n    def contains(self, aHeader):\n        Header.contains(self, aHeader)\n        if isinstance(aHeader, IP6_Extension_Header):\n            self.set_next_header(aHeader.get_header_type())\n    \n    def get_pseudo_header(self):\n        # The pseudo-header only contains data from the IPv6 header.\n        # So we pass the message to the parent until it reaches it.\n        return self.parent().get_pseudo_header()",
  "class Extension_Option(PacketBuffer):\n    MAX_OPTION_LEN  = 256\n    OPTION_TYPE_VALUE = -1\n\n    def __init__(self, option_type, size):\n        if size > Extension_Option.MAX_OPTION_LEN:\n            raise ImpactPacketException(\"Option size of % is greater than the maximum of %d\" % (size, Extension_Option.MAX_OPTION_LEN))\n        PacketBuffer.__init__(self, size)\n        self.set_option_type(option_type)\n\n    def __str__(self):\n        option_type = self.get_option_type()\n        option_length = self.get_option_length()\n\n        s  = \"Option Name: \" + str(self.__class__.OPTION_DESCRIPTION) + \"\\n\"\n        s += \"Option Type: \" + str(option_type) + \"\\n\"\n        s += \"Option Length: \" + str(option_length) + \"\\n\"\n        \n        return s\n\n    def set_option_type(self, option_type):\n        self.set_byte(0, option_type)\n\n    def get_option_type(self):\n        return self.get_byte(0)\n\n    def set_option_length(self, length):\n        self.set_byte(1, length)\n\n    def get_option_length(self):\n        return self.get_byte(1)\n\n    def set_data(self, data):\n        self.set_option_length(len(data))\n        option_bytes = self.get_bytes()\n        \n        option_bytes = self.get_bytes()\n        option_bytes[2:2+len(data)] = array.array('B', data)\n        self.set_bytes(option_bytes)\n\n    def get_len(self):\n        return len(self.get_bytes())",
  "class Option_PAD1(Extension_Option):\n    OPTION_TYPE_VALUE = 0x00   # Pad1 (RFC 2460)\n    OPTION_DESCRIPTION = \"Pad1 Option\"\n\n    def __init__(self):\n        Extension_Option.__init__(self, Option_PAD1.OPTION_TYPE_VALUE, 1)\n\n    def get_len(self):\n        return 1",
  "class Option_PADN(Extension_Option):\n    OPTION_TYPE_VALUE = 0x01   # Pad1 (RFC 2460)\n    OPTION_DESCRIPTION = \"PadN Option\"\n\n    def __init__(self, padding_size):\n        if padding_size < 2:\n            raise ImpactPacketException(\"PadN Extension Option must be greater than 2 bytes\")\n\n        Extension_Option.__init__(self, Option_PADN.OPTION_TYPE_VALUE, padding_size)\n        self.set_data(b'\\x00' * (padding_size - 2))",
  "class Basic_Extension_Header(IP6_Extension_Header):\n    MAX_OPTIONS_LEN = 256 * 8\n    MIN_HEADER_LEN  = 8\n    MAX_HEADER_LEN  = MIN_HEADER_LEN + MAX_OPTIONS_LEN\n\n    def __init__(self, buffer = None):\n        self.padded = False\n        IP6_Extension_Header.__init__(self, buffer)\n\n    def reset(self):\n        self.set_next_header(0)\n        self.set_header_extension_length(0)\n        self.add_padding()\n\n    def add_option(self, option):\n        if self.padded:\n            self._option_list.pop()\n            self.padded = False\n\n        IP6_Extension_Header.add_option(self, option)\n\n        self.add_padding()\n        \n    def add_padding(self):\n        required_octets = 8 - (self.get_header_size() % 8)\n        if self.get_header_size() + required_octets > Basic_Extension_Header.MAX_HEADER_LEN:\n            raise Exception(\"Not enough space for the padding\")\n\n        # Insert Pad1 or PadN to fill the necessary octets\n        if 0 < required_octets < 8:\n            if required_octets == 1:\n                self.add_option(Option_PAD1())\n            else:\n                self.add_option(Option_PADN(required_octets))\n            self.padded = True\n        else:\n            self.padded = False",
  "class Hop_By_Hop(Basic_Extension_Header):\n    HEADER_TYPE_VALUE = 0x00\n    HEADER_EXTENSION_DESCRIPTION = \"Hop By Hop Options\"\n    \n    @classmethod\n    def get_decoder(self):\n        from impacket import ImpactDecoder\n        return ImpactDecoder.HopByHopDecoder",
  "class Destination_Options(Basic_Extension_Header):\n    HEADER_TYPE_VALUE = 0x3c\n    HEADER_EXTENSION_DESCRIPTION = \"Destination Options\"\n    \n    @classmethod\n    def get_decoder(self):\n        from impacket import ImpactDecoder\n        return ImpactDecoder.DestinationOptionsDecoder",
  "class Routing_Options(IP6_Extension_Header):\n    HEADER_TYPE_VALUE = 0x2b\n    HEADER_EXTENSION_DESCRIPTION = \"Routing Options\"\n    ROUTING_OPTIONS_HEADER_FIELDS_SIZE = 8\n    \n    def reset(self):\n        self.set_next_header(0)\n        self.set_header_extension_length(0)\n        self.set_routing_type(0)\n        self.set_segments_left(0)\n\n    def __str__(self):\n        header_type = self.get_header_type()\n        next_header_value = self.get_next_header()\n        header_ext_length = self.get_header_extension_length()\n        routing_type = self.get_routing_type()\n        segments_left = self.get_segments_left()\n\n        s  = \"Header Extension Name: \" + self.__class__.HEADER_EXTENSION_DESCRIPTION + \"\\n\"\n        s += \"Header Type Value: \" + str(header_type) + \"\\n\"\n        s += \"Next Header: \" + str(next_header_value) + \"\\n\"\n        s += \"Header Extension Length: \" + str(header_ext_length) + \"\\n\"\n        s += \"Routing Type: \" + str(routing_type) + \"\\n\"\n        s += \"Segments Left: \" + str(segments_left) + \"\\n\"\n\n        return s\n        \n    @classmethod\n    def get_decoder(self):\n        from . import ImpactDecoder\n        return ImpactDecoder.RoutingOptionsDecoder\n\n    def get_headers_field_size(self):\n        return Routing_Options.ROUTING_OPTIONS_HEADER_FIELDS_SIZE\n\n    def set_routing_type(self, routing_type):\n        self.set_byte(2, routing_type)\n\n    def get_routing_type(self):\n        return self.get_byte(2)\n\n    def set_segments_left(self, segments_left):\n        self.set_byte(3, segments_left)\n\n    def get_segments_left(self):\n        return self.get_byte(3)",
  "def __init__(self, buffer = None):\n        Header.__init__(self, self.get_headers_field_size())\n        self._option_list = []\n        if buffer:\n            self.load_header(buffer)\n        else:\n            self.reset()",
  "def __str__(self):\n        header_type = self.get_header_type()\n        next_header_value = self.get_next_header()\n        header_ext_length = self.get_header_extension_length()\n\n        s  = \"Header Extension Name: \" + self.__class__.HEADER_EXTENSION_DESCRIPTION + \"\\n\"\n        s += \"Header Type Value: \" + str(header_type) + \"\\n\"\n        s += \"Next Header: \" + str(next_header_value) + \"\\n\"\n        s += \"Header Extension Length: \" + str(header_ext_length) + \"\\n\"\n        s += \"Options:\\n\"\n        \n        for option in self._option_list:\n            option_str = str(option)\n            option_str = option_str.split('\\n')\n            option_str = [(' ' * 4) + s for s in option_str]\n            s += '\\n'.join(option_str) + '\\n'\n        \n        return s",
  "def load_header(self, buffer):\n        self.set_bytes_from_string(buffer[:self.get_headers_field_size()])\n        \n        remaining_bytes = (self.get_header_extension_length() + 1) * 8\n        remaining_bytes -= self.get_headers_field_size()\n\n        buffer = array.array('B', buffer[self.get_headers_field_size():])\n        if remaining_bytes > len(buffer):\n            raise ImpactPacketException(\"Cannot load options from truncated packet\")\n\n        while remaining_bytes > 0:\n            option_type = buffer[0]\n            if option_type == Option_PAD1.OPTION_TYPE_VALUE:\n                # Pad1\n                self._option_list.append(Option_PAD1())\n                \n                remaining_bytes -= 1\n                buffer = buffer[1:]\n            else:\n                # PadN\n                # From RFC 2460: For N octets of padding, the Opt Data Len\n                # field contains the value N-2, and the Option Data consists\n                # of N-2 zero-valued octets.\n                option_length = buffer[1]\n                option_length += 2\n                \n                self._option_list.append(Option_PADN(option_length))\n\n                remaining_bytes -= option_length\n                buffer = buffer[option_length:]",
  "def reset(self):\n        pass",
  "def get_header_type_value(cls):\n        return cls.HEADER_TYPE_VALUE",
  "def get_extension_headers(cls):\n        header_types = {}\n        for subclass in cls.__subclasses__():\n            subclass_header_types = subclass.get_extension_headers()\n            if not subclass_header_types:\n                # If the subclass did not return anything it means\n                # that it is a leaf subclass, so we take its header\n                # type value\n                header_types[subclass.get_header_type_value()] = subclass\n            else:\n                # Else we extend the list of the obtained types\n                header_types.update(subclass_header_types)\n        return header_types",
  "def get_decoder(cls):\n        raise RuntimeError(\"Class method %s.get_decoder must be overridden.\" % cls)",
  "def get_header_type(self):\n        return self.__class__.get_header_type_value()",
  "def get_headers_field_size(self):\n        return IP6_Extension_Header.EXTENSION_HEADER_FIELDS_SIZE",
  "def get_header_size(self):\n        header_size = self.get_headers_field_size()\n        for option in self._option_list:\n            header_size += option.get_len()\n        return header_size",
  "def get_next_header(self):\n        return self.get_byte(0)",
  "def get_header_extension_length(self):\n        return self.get_byte(1)",
  "def set_next_header(self, next_header):\n        self.set_byte(0, next_header & 0xFF)",
  "def set_header_extension_length(self, header_extension_length):\n        self.set_byte(1, header_extension_length & 0xFF)",
  "def add_option(self, option):\n        self._option_list.append(option)",
  "def get_options(self):\n        return self._option_list",
  "def get_packet(self):\n        data = self.get_data_as_string()\n\n        # Update the header length\n        self.set_header_extension_length(self.get_header_size() // 8 - 1)\n\n        # Build the entire extension header packet\n        header_bytes = self.get_buffer_as_string()\n        for option in self._option_list:\n            header_bytes += option.get_buffer_as_string()\n        \n        if data:\n            return header_bytes + data\n        else:\n            return header_bytes",
  "def contains(self, aHeader):\n        Header.contains(self, aHeader)\n        if isinstance(aHeader, IP6_Extension_Header):\n            self.set_next_header(aHeader.get_header_type())",
  "def get_pseudo_header(self):\n        # The pseudo-header only contains data from the IPv6 header.\n        # So we pass the message to the parent until it reaches it.\n        return self.parent().get_pseudo_header()",
  "def __init__(self, option_type, size):\n        if size > Extension_Option.MAX_OPTION_LEN:\n            raise ImpactPacketException(\"Option size of % is greater than the maximum of %d\" % (size, Extension_Option.MAX_OPTION_LEN))\n        PacketBuffer.__init__(self, size)\n        self.set_option_type(option_type)",
  "def __str__(self):\n        option_type = self.get_option_type()\n        option_length = self.get_option_length()\n\n        s  = \"Option Name: \" + str(self.__class__.OPTION_DESCRIPTION) + \"\\n\"\n        s += \"Option Type: \" + str(option_type) + \"\\n\"\n        s += \"Option Length: \" + str(option_length) + \"\\n\"\n        \n        return s",
  "def set_option_type(self, option_type):\n        self.set_byte(0, option_type)",
  "def get_option_type(self):\n        return self.get_byte(0)",
  "def set_option_length(self, length):\n        self.set_byte(1, length)",
  "def get_option_length(self):\n        return self.get_byte(1)",
  "def set_data(self, data):\n        self.set_option_length(len(data))\n        option_bytes = self.get_bytes()\n        \n        option_bytes = self.get_bytes()\n        option_bytes[2:2+len(data)] = array.array('B', data)\n        self.set_bytes(option_bytes)",
  "def get_len(self):\n        return len(self.get_bytes())",
  "def __init__(self):\n        Extension_Option.__init__(self, Option_PAD1.OPTION_TYPE_VALUE, 1)",
  "def get_len(self):\n        return 1",
  "def __init__(self, padding_size):\n        if padding_size < 2:\n            raise ImpactPacketException(\"PadN Extension Option must be greater than 2 bytes\")\n\n        Extension_Option.__init__(self, Option_PADN.OPTION_TYPE_VALUE, padding_size)\n        self.set_data(b'\\x00' * (padding_size - 2))",
  "def __init__(self, buffer = None):\n        self.padded = False\n        IP6_Extension_Header.__init__(self, buffer)",
  "def reset(self):\n        self.set_next_header(0)\n        self.set_header_extension_length(0)\n        self.add_padding()",
  "def add_option(self, option):\n        if self.padded:\n            self._option_list.pop()\n            self.padded = False\n\n        IP6_Extension_Header.add_option(self, option)\n\n        self.add_padding()",
  "def add_padding(self):\n        required_octets = 8 - (self.get_header_size() % 8)\n        if self.get_header_size() + required_octets > Basic_Extension_Header.MAX_HEADER_LEN:\n            raise Exception(\"Not enough space for the padding\")\n\n        # Insert Pad1 or PadN to fill the necessary octets\n        if 0 < required_octets < 8:\n            if required_octets == 1:\n                self.add_option(Option_PAD1())\n            else:\n                self.add_option(Option_PADN(required_octets))\n            self.padded = True\n        else:\n            self.padded = False",
  "def get_decoder(self):\n        from impacket import ImpactDecoder\n        return ImpactDecoder.HopByHopDecoder",
  "def get_decoder(self):\n        from impacket import ImpactDecoder\n        return ImpactDecoder.DestinationOptionsDecoder",
  "def reset(self):\n        self.set_next_header(0)\n        self.set_header_extension_length(0)\n        self.set_routing_type(0)\n        self.set_segments_left(0)",
  "def __str__(self):\n        header_type = self.get_header_type()\n        next_header_value = self.get_next_header()\n        header_ext_length = self.get_header_extension_length()\n        routing_type = self.get_routing_type()\n        segments_left = self.get_segments_left()\n\n        s  = \"Header Extension Name: \" + self.__class__.HEADER_EXTENSION_DESCRIPTION + \"\\n\"\n        s += \"Header Type Value: \" + str(header_type) + \"\\n\"\n        s += \"Next Header: \" + str(next_header_value) + \"\\n\"\n        s += \"Header Extension Length: \" + str(header_ext_length) + \"\\n\"\n        s += \"Routing Type: \" + str(routing_type) + \"\\n\"\n        s += \"Segments Left: \" + str(segments_left) + \"\\n\"\n\n        return s",
  "def get_decoder(self):\n        from . import ImpactDecoder\n        return ImpactDecoder.RoutingOptionsDecoder",
  "def get_headers_field_size(self):\n        return Routing_Options.ROUTING_OPTIONS_HEADER_FIELDS_SIZE",
  "def set_routing_type(self, routing_type):\n        self.set_byte(2, routing_type)",
  "def get_routing_type(self):\n        return self.get_byte(2)",
  "def set_segments_left(self, segments_left):\n        self.set_byte(3, segments_left)",
  "def get_segments_left(self):\n        return self.get_byte(3)",
  "class PCapFileHeader(structure.Structure):\n    structure = (\n        ('magic', MAGIC),\n        ('versionMajor', '<H=2'),\n        ('versionMinor', '<H=4'),\n        ('GMT2localCorrection', '<l=0'),\n        ('timeAccuracy', '<L=0'),\n        ('maxLength', '<L=0xffff'),\n        ('linkType', '<L=1'),\n        ('packets','*:=[]'),\n    )",
  "class PCapFilePacket(structure.Structure):\n    structure = (\n        ('tsec', '<L=0'),\n        ('tmsec', '<L=0'),\n        ('savedLength', '<L-data'),\n        ('realLength', '<L-data'),\n        ('data',':'),\n    )\n\n    def __init__(self, *args, **kargs):\n        structure.Structure.__init__(self, *args, **kargs)\n        self['data'] = b''",
  "class PcapFile:\n    def __init__(self, fileName = None, mode = 'rb'):\n        if fileName is not None:\n           self.file = open(fileName, mode)\n        self.hdr = None\n        self.wroteHeader = False\n\n    def reset(self):\n        self.hdr = None\n        self.file.seek(0)\n\n    def close(self):\n        self.file.close()\n\n    def fileno(self):\n        return self.file.fileno()\n\n    def setFile(self, file):\n        self.file = file\n\n    def setSnapLen(self, snapLen):\n        self.createHeaderOnce()\n        self.hdr['maxLength'] = snapLen\n\n    def getSnapLen(self):\n        self.readHeaderOnce()\n        return self.hdr['maxLength']\n\n    def setLinkType(self, linkType):\n        self.createHeaderOnce()\n        self.hdr['linkType'] = linkType\n\n    def getLinkType(self):\n        self.readHeaderOnce()\n        return self.hdr['linkType']\n\n    def readHeaderOnce(self):\n        if self.hdr is None:\n           self.hdr = PCapFileHeader.fromFile(self.file)\n\n    def createHeaderOnce(self):\n        if self.hdr is None:\n           self.hdr = PCapFileHeader()\n    \n    def writeHeaderOnce(self):\n        if not self.wroteHeader:\n           self.wroteHeader = True\n           self.file.seek(0)\n           self.createHeaderOnce()\n           self.file.write(self.hdr.getData())\n\n    def read(self):\n       self.readHeaderOnce()\n       try:\n          pkt = PCapFilePacket.fromFile(self.file)\n          pkt['data'] = self.file.read(pkt['savedLength'])\n          return pkt\n       except:\n          return None\n\n    def write(self, pkt):\n        self.writeHeaderOnce()\n        self.file.write(str(pkt))\n\n    def packets(self):\n        self.reset()\n        while 1:\n           answer = self.read()\n           if answer is None:\n               break\n           yield answer",
  "def __init__(self, *args, **kargs):\n        structure.Structure.__init__(self, *args, **kargs)\n        self['data'] = b''",
  "def __init__(self, fileName = None, mode = 'rb'):\n        if fileName is not None:\n           self.file = open(fileName, mode)\n        self.hdr = None\n        self.wroteHeader = False",
  "def reset(self):\n        self.hdr = None\n        self.file.seek(0)",
  "def close(self):\n        self.file.close()",
  "def fileno(self):\n        return self.file.fileno()",
  "def setFile(self, file):\n        self.file = file",
  "def setSnapLen(self, snapLen):\n        self.createHeaderOnce()\n        self.hdr['maxLength'] = snapLen",
  "def getSnapLen(self):\n        self.readHeaderOnce()\n        return self.hdr['maxLength']",
  "def setLinkType(self, linkType):\n        self.createHeaderOnce()\n        self.hdr['linkType'] = linkType",
  "def getLinkType(self):\n        self.readHeaderOnce()\n        return self.hdr['linkType']",
  "def readHeaderOnce(self):\n        if self.hdr is None:\n           self.hdr = PCapFileHeader.fromFile(self.file)",
  "def createHeaderOnce(self):\n        if self.hdr is None:\n           self.hdr = PCapFileHeader()",
  "def writeHeaderOnce(self):\n        if not self.wroteHeader:\n           self.wroteHeader = True\n           self.file.seek(0)\n           self.createHeaderOnce()\n           self.file.write(self.hdr.getData())",
  "def read(self):\n       self.readHeaderOnce()\n       try:\n          pkt = PCapFilePacket.fromFile(self.file)\n          pkt['data'] = self.file.read(pkt['savedLength'])\n          return pkt\n       except:\n          return None",
  "def write(self, pkt):\n        self.writeHeaderOnce()\n        self.file.write(str(pkt))",
  "def packets(self):\n        self.reset()\n        while 1:\n           answer = self.read()\n           if answer is None:\n               break\n           yield answer",
  "class Decoder:\n    __decoded_protocol = None\n    def decode(self, aBuffer):\n        pass\n        \n    def set_decoded_protocol(self, protocol):\n        self.__decoded_protocol = protocol\n        \n    def get_protocol(self, aprotocol):\n        protocol = self.__decoded_protocol\n        while protocol:\n            if protocol.__class__ == aprotocol:\n                break\n            protocol=protocol.child()\n        return protocol\n    \n    def __str__(self):\n        protocol = self.__decoded_protocol\n        i=0\n        out=''\n        while protocol:\n            tabline=' '*i+'+-'+str(protocol.__class__)\n            out+=\"%s\"%tabline+'\\n'\n            protocol=protocol.child()\n            i+=1\n        return out",
  "class EthDecoder(Decoder):\n    def __init__(self):\n        pass\n\n    def decode(self, aBuffer):\n        e = ImpactPacket.Ethernet(aBuffer)\n        self.set_decoded_protocol( e )\n        off = e.get_header_size()\n        if e.get_ether_type() == ImpactPacket.IP.ethertype:\n            self.ip_decoder = IPDecoder()\n            packet = self.ip_decoder.decode(aBuffer[off:])\n        elif e.get_ether_type() == IP6.IP6.ethertype:\n            self.ip6_decoder = IP6Decoder()\n            packet = self.ip6_decoder.decode(aBuffer[off:])\n        elif e.get_ether_type() == ImpactPacket.ARP.ethertype:\n            self.arp_decoder = ARPDecoder()\n            packet = self.arp_decoder.decode(aBuffer[off:])\n        elif e.get_ether_type() == eap.DOT1X_AUTHENTICATION:\n            self.eapol_decoder = EAPOLDecoder()\n            packet = self.eapol_decoder.decode(aBuffer[off:])\n        # LLC ?\n        elif e.get_ether_type() < 1500:\n            self.llc_decoder = LLCDecoder()\n            packet = self.llc_decoder.decode(aBuffer[off:])\n        else:\n            self.data_decoder = DataDecoder()\n            packet = self.data_decoder.decode(aBuffer[off:])\n\n        e.contains(packet)\n        return e",
  "class LinuxSLLDecoder(Decoder):\n    def __init__(self):\n        pass\n\n    def decode(self, aBuffer):\n        e = ImpactPacket.LinuxSLL(aBuffer)\n        self.set_decoded_protocol( e )\n        off = 16\n        if e.get_ether_type() == ImpactPacket.IP.ethertype:\n            self.ip_decoder = IPDecoder()\n            packet = self.ip_decoder.decode(aBuffer[off:])\n        elif e.get_ether_type() == ImpactPacket.ARP.ethertype:\n            self.arp_decoder = ARPDecoder()\n            packet = self.arp_decoder.decode(aBuffer[off:])\n        elif e.get_ether_type() == eap.DOT1X_AUTHENTICATION:\n            self.eapol_decoder = EAPOLDecoder()\n            packet = self.eapol_decoder.decode(aBuffer[off:])\n        else:\n            self.data_decoder = DataDecoder()\n            packet = self.data_decoder.decode(aBuffer[off:])\n\n        e.contains(packet)\n        return e",
  "class IPDecoder(Decoder):\n    def __init__(self):\n        pass\n\n    def decode(self, aBuffer):\n        i = ImpactPacket.IP(aBuffer)\n        self.set_decoded_protocol ( i )\n        off = i.get_header_size()\n        end = i.get_ip_len()\n        # If ip_len == 0 we might be facing TCP segmentation offload, let's calculate the right len\n        if end == 0:\n            LOG.warning('IP len reported as 0, most probably because of TCP segmentation offload. Attempting to fix its size')\n            i.set_ip_len(len(aBuffer))\n            end = i.get_ip_len()\n\n        if i.get_ip_p() == ImpactPacket.UDP.protocol:\n            self.udp_decoder = UDPDecoder()\n            packet = self.udp_decoder.decode(aBuffer[off:end])\n        elif i.get_ip_p() == ImpactPacket.TCP.protocol:\n            self.tcp_decoder = TCPDecoder()\n            packet = self.tcp_decoder.decode(aBuffer[off:end])\n        elif i.get_ip_p() == ImpactPacket.ICMP.protocol:\n            self.icmp_decoder = ICMPDecoder()\n            packet = self.icmp_decoder.decode(aBuffer[off:end])\n        elif i.get_ip_p() == ImpactPacket.IGMP.protocol:\n            self.igmp_decoder = IGMPDecoder()\n            packet = self.igmp_decoder.decode(aBuffer[off:end])\n        else:\n            self.data_decoder = DataDecoder()\n            packet = self.data_decoder.decode(aBuffer[off:end])\n        i.contains(packet)\n        return i",
  "class IP6MultiProtocolDecoder(Decoder):\n    def __init__(self, a_protocol_id):\n        self.protocol_id = a_protocol_id\n\n    def decode(self, buffer):\n        if self.protocol_id == ImpactPacket.UDP.protocol:\n            self.udp_decoder = UDPDecoder()\n            packet = self.udp_decoder.decode(buffer)\n        elif self.protocol_id == ImpactPacket.TCP.protocol:\n            self.tcp_decoder = TCPDecoder()\n            packet = self.tcp_decoder.decode(buffer)\n        elif self.protocol_id == ICMP6.ICMP6.protocol:\n            self.icmp6_decoder = ICMP6Decoder()\n            packet = self.icmp6_decoder.decode(buffer)\n        else:\n            # IPv6 Extension Headers lookup\n            extension_headers = IP6_Extension_Headers.IP6_Extension_Header.get_extension_headers()\n            if buffer and self.protocol_id in extension_headers:\n                extension_header_decoder_class = extension_headers[self.protocol_id].get_decoder()\n                self.extension_header_decoder = extension_header_decoder_class()\n                packet = self.extension_header_decoder.decode(buffer)\n            else:\n                self.data_decoder = DataDecoder()\n                packet = self.data_decoder.decode(buffer)\n\n        return packet",
  "class IP6Decoder(Decoder):\n    def __init__(self):\n        pass\n\n    def decode(self, buffer):\n        ip6_packet = IP6.IP6(buffer)\n        self.set_decoded_protocol(ip6_packet)\n        start_pos = ip6_packet.get_header_size() \n        end_pos = ip6_packet.get_payload_length() + start_pos\n        contained_protocol = ip6_packet.get_next_header()\n        \n        multi_protocol_decoder = IP6MultiProtocolDecoder(contained_protocol)\n        child_packet = multi_protocol_decoder.decode(buffer[start_pos:end_pos])\n        \n        ip6_packet.contains(child_packet)\n        return ip6_packet",
  "class HopByHopDecoder(Decoder):\n    def __init__(self):\n        pass\n\n    def decode(self, buffer):\n        hop_by_hop = IP6_Extension_Headers.Hop_By_Hop(buffer)\n        self.set_decoded_protocol(hop_by_hop)\n        start_pos = hop_by_hop.get_header_size()\n        contained_protocol = hop_by_hop.get_next_header()\n\n        multi_protocol_decoder = IP6MultiProtocolDecoder(contained_protocol)\n        child_packet = multi_protocol_decoder.decode(buffer[start_pos:])\n        \n        hop_by_hop.contains(child_packet)\n        return hop_by_hop",
  "class DestinationOptionsDecoder(Decoder):\n    def __init__(self):\n        pass\n\n    def decode(self, buffer):\n        destination_options = IP6_Extension_Headers.Destination_Options(buffer)\n        self.set_decoded_protocol(destination_options)\n        start_pos = destination_options.get_header_size()\n        contained_protocol = destination_options.get_next_header()\n\n        multi_protocol_decoder = IP6MultiProtocolDecoder(contained_protocol)\n        child_packet = multi_protocol_decoder.decode(buffer[start_pos:])\n        \n        destination_options.contains(child_packet)\n        return destination_options",
  "class RoutingOptionsDecoder(Decoder):\n    def __init__(self):\n        pass\n\n    def decode(self, buffer):\n        routing_options = IP6_Extension_Headers.Routing_Options(buffer)\n        self.set_decoded_protocol(routing_options)\n        start_pos = routing_options.get_header_size()\n        contained_protocol = routing_options.get_next_header()\n\n        multi_protocol_decoder = IP6MultiProtocolDecoder(contained_protocol)\n        child_packet = multi_protocol_decoder.decode(buffer[start_pos:])\n        \n        routing_options.contains(child_packet)\n        return routing_options",
  "class ICMP6Decoder(Decoder):\n    def __init__(self):\n        pass\n\n    def decode(self, buffer):\n        icmp6_packet = ICMP6.ICMP6(buffer)\n        self.set_decoded_protocol(icmp6_packet)\n        start_pos = icmp6_packet.get_header_size() \n                \n        self.data_decoder = DataDecoder()\n        child_packet = self.data_decoder.decode(buffer[start_pos:])\n        icmp6_packet.contains(child_packet)\n        return icmp6_packet",
  "class ARPDecoder(Decoder):\n    def __init__(self):\n        pass\n\n    def decode(self, aBuffer):\n        arp = ImpactPacket.ARP(aBuffer)\n        self.set_decoded_protocol( arp )\n        off = arp.get_header_size()\n        self.data_decoder = DataDecoder()\n        packet = self.data_decoder.decode(aBuffer[off:])\n        arp.contains(packet)\n        return arp",
  "class UDPDecoder(Decoder):\n    def __init__(self):\n        pass\n\n    def decode(self, aBuffer):\n        u = ImpactPacket.UDP(aBuffer)\n        self.set_decoded_protocol( u )\n        off = u.get_header_size()\n        self.data_decoder = DataDecoder()\n        packet = self.data_decoder.decode(aBuffer[off:])\n        u.contains(packet)\n        return u",
  "class TCPDecoder(Decoder):\n    def __init__(self):\n        pass\n\n    def decode(self, aBuffer):\n        t = ImpactPacket.TCP(aBuffer)\n        self.set_decoded_protocol( t )\n        off = t.get_header_size()\n        self.data_decoder = DataDecoder()\n        packet = self.data_decoder.decode(aBuffer[off:])\n        t.contains(packet)\n        return t",
  "class IGMPDecoder(Decoder):\n    def __init__(self):\n        pass\n    def decode(self, aBuffer):\n        ig = ImpactPacket.IGMP(aBuffer)\n        off = ig.get_header_size()\n        self.data_decoder = DataDecoder()\n        packet = self.data_decoder.decode(aBuffer[off:])\n        ig.contains(packet)\n        return ig",
  "class IPDecoderForICMP(Decoder):\n    \"\"\"This class was added to parse the IP header of ICMP unreachables packets\n    If you use the \"standard\" IPDecoder, it might crash (see bug #4870) ImpactPacket.py\n    because the TCP header inside the IP header is incomplete\"\"\"    \n    def __init__(self):\n        pass\n\n    def decode(self, aBuffer):\n        i = ImpactPacket.IP(aBuffer)\n        self.set_decoded_protocol( i )\n        off = i.get_header_size()\n        if i.get_ip_p() == ImpactPacket.UDP.protocol:\n            self.udp_decoder = UDPDecoder()\n            packet = self.udp_decoder.decode(aBuffer[off:])\n        else:\n            self.data_decoder = DataDecoder()\n            packet = self.data_decoder.decode(aBuffer[off:])\n        i.contains(packet)\n        return i",
  "class ICMPDecoder(Decoder):\n    def __init__(self):\n        pass\n\n    def decode(self, aBuffer):\n        ic = ImpactPacket.ICMP(aBuffer)\n        self.set_decoded_protocol( ic )\n        off = ic.get_header_size()\n        if ic.get_icmp_type() == ImpactPacket.ICMP.ICMP_UNREACH:\n            self.ip_decoder = IPDecoderForICMP()\n            packet = self.ip_decoder.decode(aBuffer[off:])\n        else:\n            self.data_decoder = DataDecoder()\n            packet = self.data_decoder.decode(aBuffer[off:])\n        ic.contains(packet)\n        return ic",
  "class DataDecoder(Decoder):\n    def decode(self, aBuffer):\n        d = ImpactPacket.Data(aBuffer)\n        self.set_decoded_protocol( d )\n        return d",
  "class BaseDot11Decoder(Decoder):\n    def __init__(self, key_manager=None):\n        self.set_key_manager(key_manager)\n        \n    def set_key_manager(self, key_manager):\n        self.key_manager = key_manager\n        \n    def find_key(self, bssid):\n        try:\n            key = self.key_manager.get_key(bssid)\n        except:\n            return False\n        return key",
  "class RadioTapDecoder(BaseDot11Decoder):\n    def __init__(self):\n        BaseDot11Decoder.__init__(self)\n\n    def decode(self, aBuffer):\n        rt = dot11.RadioTap(aBuffer)\n        self.set_decoded_protocol( rt )\n        \n        self.do11_decoder = Dot11Decoder()\n        self.do11_decoder.set_key_manager(self.key_manager)\n        flags=rt.get_flags()\n        if flags is not None:\n            fcs=flags&dot11.RadioTap.RTF_FLAGS.PROPERTY_FCS_AT_END\n            self.do11_decoder.FCS_at_end(fcs)\n            \n        packet = self.do11_decoder.decode(rt.get_body_as_string())\n    \n        rt.contains(packet)\n        return rt",
  "class Dot11Decoder(BaseDot11Decoder):\n    def __init__(self):\n        BaseDot11Decoder.__init__(self)\n        self.__FCS_at_end = True\n        \n    def FCS_at_end(self, fcs_at_end=True):\n        self.__FCS_at_end=not not fcs_at_end \n        \n    def decode(self, aBuffer):\n        d = dot11.Dot11(aBuffer, self.__FCS_at_end)\n        self.set_decoded_protocol( d )\n        \n        type = d.get_type()\n        if type == dot11.Dot11Types.DOT11_TYPE_CONTROL:\n            dot11_control_decoder = Dot11ControlDecoder()\n            packet = dot11_control_decoder.decode(d.body_string)\n        elif type == dot11.Dot11Types.DOT11_TYPE_DATA:\n            dot11_data_decoder = Dot11DataDecoder(self.key_manager)\n            \n            dot11_data_decoder.set_dot11_hdr(d)\n            \n            packet = dot11_data_decoder.decode(d.body_string)\n        elif type == dot11.Dot11Types.DOT11_TYPE_MANAGEMENT:\n            dot11_management_decoder = Dot11ManagementDecoder()\n            dot11_management_decoder.set_subtype(d.get_subtype())\n            packet = dot11_management_decoder.decode(d.body_string)\n        else:\n            data_decoder = DataDecoder()\n            packet = data_decoder.decode(d.body_string)\n\n        d.contains(packet)\n        return d",
  "class Dot11ControlDecoder(BaseDot11Decoder):\n    def __init__(self):\n        BaseDot11Decoder.__init__(self)\n        self.__FCS_at_end = True\n\n    def FCS_at_end(self, fcs_at_end=True):\n        self.__FCS_at_end=not not fcs_at_end \n    \n    def decode(self, aBuffer):\n        d = dot11.Dot11(aBuffer, self.__FCS_at_end)\n        self.set_decoded_protocol(d)\n        \n        self.subtype = d.get_subtype()\n        if self.subtype is dot11.Dot11Types.DOT11_SUBTYPE_CONTROL_CLEAR_TO_SEND:\n            self.ctrl_cts_decoder = Dot11ControlFrameCTSDecoder()\n            packet = self.ctrl_cts_decoder.decode(d.body_string)\n        elif self.subtype is dot11.Dot11Types.DOT11_SUBTYPE_CONTROL_ACKNOWLEDGMENT:\n            self.ctrl_ack_decoder = Dot11ControlFrameACKDecoder()\n            packet = self.ctrl_ack_decoder.decode(d.body_string)\n        elif self.subtype is dot11.Dot11Types.DOT11_SUBTYPE_CONTROL_REQUEST_TO_SEND:\n            self.ctrl_rts_decoder = Dot11ControlFrameRTSDecoder()\n            packet = self.ctrl_rts_decoder.decode(d.body_string)\n        elif self.subtype is dot11.Dot11Types.DOT11_SUBTYPE_CONTROL_POWERSAVE_POLL:\n            self.ctrl_pspoll_decoder = Dot11ControlFramePSPollDecoder()\n            packet = self.ctrl_pspoll_decoder.decode(d.body_string)\n        elif self.subtype is dot11.Dot11Types.DOT11_SUBTYPE_CONTROL_CF_END:\n            self.ctrl_cfend_decoder = Dot11ControlFrameCFEndDecoder()\n            packet = self.ctrl_cfend_decoder.decode(d.body_string)\n        elif self.subtype is dot11.Dot11Types.DOT11_SUBTYPE_CONTROL_CF_END_CF_ACK:\n            self.ctrl_cfendcfack_decoder = Dot11ControlFrameCFEndCFACKDecoder()\n            packet = self.ctrl_cfendcfack_decoder.decode(d.body_string)\n        else:\n            data_decoder = DataDecoder()\n            packet = data_decoder.decode(d.body_string)\n        \n        d.contains(packet)\n        return d",
  "class Dot11ControlFrameCTSDecoder(BaseDot11Decoder):\n    def __init__(self):\n        BaseDot11Decoder.__init__(self)\n    \n    def decode(self, aBuffer):\n        p = dot11.Dot11ControlFrameCTS(aBuffer)\n        self.set_decoded_protocol(p)\n        return p",
  "class Dot11ControlFrameACKDecoder(BaseDot11Decoder):\n    def __init__(self):\n        BaseDot11Decoder.__init__(self)\n    \n    def decode(self, aBuffer):\n        p = dot11.Dot11ControlFrameACK(aBuffer)\n        self.set_decoded_protocol(p)\n        return p",
  "class Dot11ControlFrameRTSDecoder(BaseDot11Decoder):\n    def __init__(self):\n        BaseDot11Decoder.__init__(self)\n    \n    def decode(self, aBuffer):\n        p = dot11.Dot11ControlFrameRTS(aBuffer)\n        self.set_decoded_protocol(p)\n        return p",
  "class Dot11ControlFramePSPollDecoder(BaseDot11Decoder):\n    def __init__(self):\n        BaseDot11Decoder.__init__(self)\n    \n    def decode(self, aBuffer):\n        p = dot11.Dot11ControlFramePSPoll(aBuffer)\n        self.set_decoded_protocol(p)\n        return p",
  "class Dot11ControlFrameCFEndDecoder(BaseDot11Decoder):\n    def __init__(self):\n        BaseDot11Decoder.__init__(self)\n    \n    def decode(self, aBuffer):\n        p = dot11.Dot11ControlFrameCFEnd(aBuffer)\n        self.set_decoded_protocol(p)\n        return p",
  "class Dot11ControlFrameCFEndCFACKDecoder(BaseDot11Decoder):\n    def __init__(self):\n        BaseDot11Decoder.__init__(self)\n    \n    def decode(self, aBuffer):\n        p = dot11.Dot11ControlFrameCFEndCFACK(aBuffer)\n        self.set_decoded_protocol(p)\n        return p",
  "class Dot11DataDecoder(BaseDot11Decoder):\n    def __init__(self, key_manager):\n        BaseDot11Decoder.__init__(self, key_manager)\n        \n    def set_dot11_hdr(self, dot11_obj):\n        self.dot11 = dot11_obj\n        \n    def decode(self, aBuffer):\n        if self.dot11.get_fromDS() and self.dot11.get_toDS():\n            if self.dot11.is_QoS_frame():\n                p = dot11.Dot11DataAddr4QoSFrame(aBuffer)\n            else:\n                p = dot11.Dot11DataAddr4Frame(aBuffer)\n        elif self.dot11.is_QoS_frame():\n            p = dot11.Dot11DataQoSFrame(aBuffer)\n        else:\n            p = dot11.Dot11DataFrame(aBuffer)\n        self.set_decoded_protocol( p )\n        \n        if not self.dot11.get_protectedFrame():\n            self.llc_decoder = LLCDecoder()\n            packet = self.llc_decoder.decode(p.body_string)\n        else:\n            if not self.dot11.get_fromDS() and self.dot11.get_toDS():\n                bssid = p.get_address1()\n            elif self.dot11.get_fromDS() and not self.dot11.get_toDS():\n                bssid = p.get_address2()\n            elif not self.dot11.get_fromDS() and not self.dot11.get_toDS():\n                bssid = p.get_address3()\n            else:\n                # WDS, this is the RA\n                bssid = p.get_address1()\n                \n            wep_decoder = Dot11WEPDecoder(self.key_manager)\n            wep_decoder.set_bssid(bssid)\n            packet = wep_decoder.decode(p.body_string)\n            if packet is None:\n                wpa_decoder = Dot11WPADecoder()\n                packet = wpa_decoder.decode(p.body_string)\n                if packet is None:\n                    wpa2_decoder = Dot11WPA2Decoder()\n                    packet = wpa2_decoder.decode(p.body_string)\n                    if packet is None:\n                        data_decoder = DataDecoder()\n                        packet = data_decoder.decode(p.body_string)\n        \n        p.contains(packet)\n        return p",
  "class Dot11WEPDecoder(BaseDot11Decoder):\n    def __init__(self, key_manager):\n        BaseDot11Decoder.__init__(self, key_manager)\n        self.bssid = None\n        \n    def set_bssid(self, bssid):\n        self.bssid = bssid\n        \n    def decode(self, aBuffer):\n        wep = dot11.Dot11WEP(aBuffer)\n        self.set_decoded_protocol( wep )\n        \n        if wep.is_WEP() is False:\n            return None\n        \n        key = self.find_key(self.bssid)\n        if key:\n            decoded_string=wep.get_decrypted_data(key)\n            \n            wep_data = Dot11WEPDataDecoder()\n            packet = wep_data.decode(decoded_string)\n        else:\n            data_decoder = DataDecoder()\n            packet = data_decoder.decode(wep.body_string)\n        \n        wep.contains(packet)\n        \n        return wep",
  "class Dot11WEPDataDecoder(BaseDot11Decoder):\n    def __init__(self):\n        BaseDot11Decoder.__init__(self)\n\n    def decode(self, aBuffer):\n        wep_data = dot11.Dot11WEPData(aBuffer)\n\n        if not wep_data.check_icv():\n            # TODO: Do something when the icv is not correct\n            pass\n\n        self.set_decoded_protocol( wep_data )\n\n        llc_decoder = LLCDecoder()\n        packet = llc_decoder.decode(wep_data.body_string)\n\n        wep_data.contains(packet)\n\n        return wep_data",
  "class Dot11WPADecoder(BaseDot11Decoder):\n    def __init__(self):\n        BaseDot11Decoder.__init__(self)\n\n    def decode(self, aBuffer, key=None):\n        wpa = dot11.Dot11WPA(aBuffer)\n        self.set_decoded_protocol( wpa )\n\n        if wpa.is_WPA() is False:\n            return None\n\n        if key:\n            decoded_string=wpa.get_decrypted_data()\n\n            wpa_data = Dot11WPADataDecoder()\n            packet = wpa_data.decode(decoded_string)\n        else:\n            data_decoder = DataDecoder()\n            packet = data_decoder.decode(wpa.body_string)\n\n        wpa.contains(packet)\n\n        return wpa",
  "class Dot11WPADataDecoder(BaseDot11Decoder):\n    def __init__(self):\n        BaseDot11Decoder.__init__(self)\n\n    def decode(self, aBuffer):\n        wpa_data = dot11.Dot11WPAData(aBuffer)\n        self.set_decoded_protocol( wpa_data )\n\n        llc_decoder = LLCDecoder()\n        packet = self.llc_decoder.decode(wpa_data.body_string)\n\n        wpa_data.contains(packet)\n\n        return wpa_data",
  "class Dot11WPA2Decoder(BaseDot11Decoder):\n    def __init__(self):\n        BaseDot11Decoder.__init__(self)\n\n    def decode(self, aBuffer, key=None):\n        wpa2 = dot11.Dot11WPA2(aBuffer)\n        self.set_decoded_protocol( wpa2 )\n\n        if wpa2.is_WPA2() is False:\n            return None\n\n        if key:\n            decoded_string=wpa2.get_decrypted_data()\n\n            wpa2_data = Dot11WPA2DataDecoder()\n            packet = wpa2_data.decode(decoded_string)\n        else:\n            data_decoder = DataDecoder()\n            packet = data_decoder.decode(wpa2.body_string)\n\n            wpa2.contains(packet)\n\n            return wpa2",
  "class Dot11WPA2DataDecoder(BaseDot11Decoder):\n    def __init__(self):\n        BaseDot11Decoder.__init__(self)\n\n    def decode(self, aBuffer):\n        wpa2_data = dot11.Dot11WPA2Data(aBuffer)\n        self.set_decoded_protocol( wpa2_data )\n\n        llc_decoder = LLCDecoder()\n        packet = self.llc_decoder.decode(wpa2_data.body_string)\n\n        wpa2_data.contains(packet)\n\n        return wpa2_data",
  "class LLCDecoder(Decoder):\n    def __init__(self):\n        pass\n\n    def decode(self, aBuffer):\n        d = dot11.LLC(aBuffer)\n        self.set_decoded_protocol( d )\n\n        if d.get_DSAP()==dot11.SAPTypes.SNAP:\n            if d.get_SSAP()==dot11.SAPTypes.SNAP:\n                if d.get_control()==dot11.LLC.DLC_UNNUMBERED_FRAMES:\n                    snap_decoder = SNAPDecoder()\n                    packet = snap_decoder.decode(d.body_string)\n                    d.contains(packet)\n                    return d\n\n        # Only SNAP is implemented\n        data_decoder = DataDecoder()\n        packet = data_decoder.decode(d.body_string)\n        d.contains(packet)\n        return d",
  "class SNAPDecoder(Decoder):\n    def __init__(self):\n        pass\n\n    def decode(self, aBuffer):\n        s = dot11.SNAP(aBuffer)\n        self.set_decoded_protocol( s )\n        if  s.get_OUI()==CDP.OUI and s.get_protoID()==CDP.Type:\n            dec = CDPDecoder()\n            packet = dec.decode(s.body_string)\n        elif  s.get_OUI()!=0x000000:\n            # We don't know how to handle other than OUI=0x000000 (EtherType)\n            self.data_decoder = DataDecoder()\n            packet = self.data_decoder.decode(s.body_string)\n        elif s.get_protoID() == ImpactPacket.IP.ethertype:\n            self.ip_decoder = IPDecoder()\n            packet = self.ip_decoder.decode(s.body_string)\n        elif s.get_protoID() == ImpactPacket.ARP.ethertype:\n            self.arp_decoder = ARPDecoder()\n            packet = self.arp_decoder.decode(s.body_string)\n        elif s.get_protoID() == eap.DOT1X_AUTHENTICATION:\n            self.eapol_decoder = EAPOLDecoder()\n            packet = self.eapol_decoder.decode(s.body_string)\n        else:\n            self.data_decoder = DataDecoder()\n            packet = self.data_decoder.decode(s.body_string)\n\n        s.contains(packet)\n        return s",
  "class CDPDecoder(Decoder):\n\n    def __init__(self):\n        pass\n\n    def decode(self, aBuffer):\n        s = CDP(aBuffer)\n        self.set_decoded_protocol( s )\n        return s",
  "class Dot11ManagementDecoder(BaseDot11Decoder):\n    def __init__(self):\n        BaseDot11Decoder.__init__(self)\n        self.subtype = None\n\n    def set_subtype(self, subtype):\n        self.subtype=subtype\n\n    def decode(self, aBuffer):\n        p = dot11.Dot11ManagementFrame(aBuffer)\n        self.set_decoded_protocol( p )\n\n        if self.subtype is dot11.Dot11Types.DOT11_SUBTYPE_MANAGEMENT_BEACON:\n            self.mgt_beacon_decoder = Dot11ManagementBeaconDecoder()\n            packet = self.mgt_beacon_decoder.decode(p.body_string)\n        elif self.subtype is dot11.Dot11Types.DOT11_SUBTYPE_MANAGEMENT_PROBE_REQUEST:\n            self.mgt_probe_request_decoder = Dot11ManagementProbeRequestDecoder()\n            packet = self.mgt_probe_request_decoder.decode(p.body_string)\n        elif self.subtype is dot11.Dot11Types.DOT11_SUBTYPE_MANAGEMENT_PROBE_RESPONSE:\n            self.mgt_probe_response_decoder = Dot11ManagementProbeResponseDecoder()\n            packet = self.mgt_probe_response_decoder.decode(p.body_string)\n        elif self.subtype is dot11.Dot11Types.DOT11_SUBTYPE_MANAGEMENT_DEAUTHENTICATION:\n            self.mgt_deauthentication_decoder = Dot11ManagementDeauthenticationDecoder()\n            packet = self.mgt_deauthentication_decoder.decode(p.body_string)\n        elif self.subtype is dot11.Dot11Types.DOT11_SUBTYPE_MANAGEMENT_AUTHENTICATION:\n            self.mgt_Authentication_decoder = Dot11ManagementAuthenticationDecoder()\n            packet = self.mgt_Authentication_decoder.decode(p.body_string)\n        elif self.subtype is dot11.Dot11Types.DOT11_SUBTYPE_MANAGEMENT_DISASSOCIATION:\n            self.mgt_disassociation_decoder = Dot11ManagementDisassociationDecoder()\n            packet = self.mgt_disassociation_decoder.decode(p.body_string)\n        elif self.subtype is dot11.Dot11Types.DOT11_SUBTYPE_MANAGEMENT_ASSOCIATION_REQUEST:\n            self.mgt_association_request_decoder = Dot11ManagementAssociationRequestDecoder()\n            packet = self.mgt_association_request_decoder.decode(p.body_string)\n        elif self.subtype is dot11.Dot11Types.DOT11_SUBTYPE_MANAGEMENT_ASSOCIATION_RESPONSE:\n            self.mgt_association_response_decoder = Dot11ManagementAssociationResponseDecoder()\n            packet = self.mgt_association_response_decoder.decode(p.body_string)\n        elif self.subtype is dot11.Dot11Types.DOT11_SUBTYPE_MANAGEMENT_REASSOCIATION_REQUEST:\n            self.mgt_reassociation_request_decoder = Dot11ManagementReassociationRequestDecoder()\n            packet = self.mgt_reassociation_request_decoder.decode(p.body_string)\n        elif self.subtype is dot11.Dot11Types.DOT11_SUBTYPE_MANAGEMENT_REASSOCIATION_RESPONSE:\n            self.mgt_reassociation_response_decoder = Dot11ManagementReassociationResponseDecoder()\n            packet = self.mgt_reassociation_response_decoder.decode(p.body_string)\n        else:\n            data_decoder = DataDecoder()\n            packet = data_decoder.decode(p.body_string)\n\n        p.contains(packet)\n        return p",
  "class Dot11ManagementBeaconDecoder(BaseDot11Decoder):\n    def __init__(self):\n        BaseDot11Decoder.__init__(self)\n\n    def decode(self, aBuffer):\n        p = dot11.Dot11ManagementBeacon(aBuffer)\n        self.set_decoded_protocol( p )\n\n        return p",
  "class Dot11ManagementProbeRequestDecoder(BaseDot11Decoder):\n    def __init__(self):\n        BaseDot11Decoder.__init__(self)\n\n    def decode(self, aBuffer):\n        p = dot11.Dot11ManagementProbeRequest(aBuffer)\n        self.set_decoded_protocol( p )\n\n        return p",
  "class Dot11ManagementProbeResponseDecoder(BaseDot11Decoder):\n    def __init__(self):\n        BaseDot11Decoder.__init__(self)\n\n    def decode(self, aBuffer):\n        p = dot11.Dot11ManagementProbeResponse(aBuffer)\n        self.set_decoded_protocol( p )\n\n        return p",
  "class Dot11ManagementDeauthenticationDecoder(BaseDot11Decoder):\n    def __init__(self):\n        BaseDot11Decoder.__init__(self)\n\n    def decode(self, aBuffer):\n        p = dot11.Dot11ManagementDeauthentication(aBuffer)\n        self.set_decoded_protocol( p )\n\n        return p",
  "class Dot11ManagementAuthenticationDecoder(BaseDot11Decoder):\n    def __init__(self):\n        BaseDot11Decoder.__init__(self)\n\n    def decode(self, aBuffer):\n        p = dot11.Dot11ManagementAuthentication(aBuffer)\n        self.set_decoded_protocol(p)\n\n        return p",
  "class Dot11ManagementDisassociationDecoder(BaseDot11Decoder):\n    def __init__(self):\n        BaseDot11Decoder.__init__(self)\n\n    def decode(self, aBuffer):\n        p = dot11.Dot11ManagementDisassociation(aBuffer)\n        self.set_decoded_protocol(p)\n\n        return p",
  "class Dot11ManagementAssociationRequestDecoder(BaseDot11Decoder):\n    def __init__(self):\n        BaseDot11Decoder.__init__(self)\n\n    def decode(self, aBuffer):\n        p = dot11.Dot11ManagementAssociationRequest(aBuffer)\n        self.set_decoded_protocol(p)\n\n        return p",
  "class Dot11ManagementAssociationResponseDecoder(BaseDot11Decoder):\n    def __init__(self):\n        BaseDot11Decoder.__init__(self)\n\n    def decode(self, aBuffer):\n        p = dot11.Dot11ManagementAssociationResponse(aBuffer)\n        self.set_decoded_protocol(p)\n\n        return p",
  "class Dot11ManagementReassociationRequestDecoder(BaseDot11Decoder):\n    def __init__(self):\n        BaseDot11Decoder.__init__(self)\n\n    def decode(self, aBuffer):\n        p = dot11.Dot11ManagementReassociationRequest(aBuffer)\n        self.set_decoded_protocol(p)\n\n        return p",
  "class Dot11ManagementReassociationResponseDecoder(BaseDot11Decoder):\n    def __init__(self):\n        BaseDot11Decoder.__init__(self)\n\n    def decode(self, aBuffer):\n        p = dot11.Dot11ManagementReassociationResponse(aBuffer)\n        self.set_decoded_protocol(p)\n\n        return p",
  "class BaseDecoder(Decoder):\n\n    def decode(self, buff):\n\n        packet = self.klass(buff)\n        self.set_decoded_protocol(packet)\n        cd = self.child_decoders.get(self.child_key(packet), DataDecoder())\n        packet.contains(cd.decode(packet.get_body_as_string()))\n        return packet",
  "class SimpleConfigDecoder(BaseDecoder):\n\n    child_decoders = {}\n    klass = wps.SimpleConfig\n    child_key = lambda s,p: None\n\n    def decode(self, buff):\n        sc = BaseDecoder.decode(self, buff)\n        ary = array.array('B', sc.child().get_packet())\n        sc.unlink_child()\n        tlv = wps.SimpleConfig.build_tlv_container()\n        tlv.from_ary(ary)\n        sc.contains(tlv)\n\n        return sc",
  "class EAPExpandedDecoder(BaseDecoder):\n    child_decoders = {\n        (eap.EAPExpanded.WFA_SMI, eap.EAPExpanded.SIMPLE_CONFIG): SimpleConfigDecoder(),\n    }\n    klass = eap.EAPExpanded\n    child_key = lambda s,p: (p.get_vendor_id(), p.get_vendor_type())",
  "class EAPRDecoder(BaseDecoder):\n    child_decoders = {\n        eap.EAPR.EXPANDED:EAPExpandedDecoder()\n    }\n    klass = eap.EAPR\n    child_key = lambda s, p: p.get_type()",
  "class EAPDecoder(BaseDecoder):\n    child_decoders = {\n        eap.EAP.REQUEST: EAPRDecoder(),\n        eap.EAP.RESPONSE: EAPRDecoder(),\n    }\n    klass = eap.EAP\n    child_key = lambda s, p: p.get_code()",
  "class EAPOLDecoder(BaseDecoder):\n    child_decoders = {\n        eap.EAPOL.EAP_PACKET: EAPDecoder()\n    }\n    klass = eap.EAPOL\n    child_key = lambda s, p: p.get_packet_type()",
  "class BootpDecoder(Decoder):\n    def __init__(self):\n        pass\n\n    def decode(self, aBuffer):\n        d = dhcp.BootpPacket(aBuffer)\n        self.set_decoded_protocol( d )\n        off = len(d.getData())\n        if dhcp.DhcpPacket(aBuffer[off:])['cookie'] == dhcp.DhcpPacket.MAGIC_NUMBER:\n            self.data_decoder = DHCPDecoder()\n            packet = self.data_decoder.decode(aBuffer[off:])\n            d.contains(packet)\n        return d",
  "class DHCPDecoder(Decoder):\n    def __init__(self):\n        pass\n\n    def decode(self, aBuffer):\n        d = dhcp.DhcpPacket(aBuffer)\n        self.set_decoded_protocol( d )\n        return d",
  "def decode(self, aBuffer):\n        pass",
  "def set_decoded_protocol(self, protocol):\n        self.__decoded_protocol = protocol",
  "def get_protocol(self, aprotocol):\n        protocol = self.__decoded_protocol\n        while protocol:\n            if protocol.__class__ == aprotocol:\n                break\n            protocol=protocol.child()\n        return protocol",
  "def __str__(self):\n        protocol = self.__decoded_protocol\n        i=0\n        out=''\n        while protocol:\n            tabline=' '*i+'+-'+str(protocol.__class__)\n            out+=\"%s\"%tabline+'\\n'\n            protocol=protocol.child()\n            i+=1\n        return out",
  "def __init__(self):\n        pass",
  "def decode(self, aBuffer):\n        e = ImpactPacket.Ethernet(aBuffer)\n        self.set_decoded_protocol( e )\n        off = e.get_header_size()\n        if e.get_ether_type() == ImpactPacket.IP.ethertype:\n            self.ip_decoder = IPDecoder()\n            packet = self.ip_decoder.decode(aBuffer[off:])\n        elif e.get_ether_type() == IP6.IP6.ethertype:\n            self.ip6_decoder = IP6Decoder()\n            packet = self.ip6_decoder.decode(aBuffer[off:])\n        elif e.get_ether_type() == ImpactPacket.ARP.ethertype:\n            self.arp_decoder = ARPDecoder()\n            packet = self.arp_decoder.decode(aBuffer[off:])\n        elif e.get_ether_type() == eap.DOT1X_AUTHENTICATION:\n            self.eapol_decoder = EAPOLDecoder()\n            packet = self.eapol_decoder.decode(aBuffer[off:])\n        # LLC ?\n        elif e.get_ether_type() < 1500:\n            self.llc_decoder = LLCDecoder()\n            packet = self.llc_decoder.decode(aBuffer[off:])\n        else:\n            self.data_decoder = DataDecoder()\n            packet = self.data_decoder.decode(aBuffer[off:])\n\n        e.contains(packet)\n        return e",
  "def __init__(self):\n        pass",
  "def decode(self, aBuffer):\n        e = ImpactPacket.LinuxSLL(aBuffer)\n        self.set_decoded_protocol( e )\n        off = 16\n        if e.get_ether_type() == ImpactPacket.IP.ethertype:\n            self.ip_decoder = IPDecoder()\n            packet = self.ip_decoder.decode(aBuffer[off:])\n        elif e.get_ether_type() == ImpactPacket.ARP.ethertype:\n            self.arp_decoder = ARPDecoder()\n            packet = self.arp_decoder.decode(aBuffer[off:])\n        elif e.get_ether_type() == eap.DOT1X_AUTHENTICATION:\n            self.eapol_decoder = EAPOLDecoder()\n            packet = self.eapol_decoder.decode(aBuffer[off:])\n        else:\n            self.data_decoder = DataDecoder()\n            packet = self.data_decoder.decode(aBuffer[off:])\n\n        e.contains(packet)\n        return e",
  "def __init__(self):\n        pass",
  "def decode(self, aBuffer):\n        i = ImpactPacket.IP(aBuffer)\n        self.set_decoded_protocol ( i )\n        off = i.get_header_size()\n        end = i.get_ip_len()\n        # If ip_len == 0 we might be facing TCP segmentation offload, let's calculate the right len\n        if end == 0:\n            LOG.warning('IP len reported as 0, most probably because of TCP segmentation offload. Attempting to fix its size')\n            i.set_ip_len(len(aBuffer))\n            end = i.get_ip_len()\n\n        if i.get_ip_p() == ImpactPacket.UDP.protocol:\n            self.udp_decoder = UDPDecoder()\n            packet = self.udp_decoder.decode(aBuffer[off:end])\n        elif i.get_ip_p() == ImpactPacket.TCP.protocol:\n            self.tcp_decoder = TCPDecoder()\n            packet = self.tcp_decoder.decode(aBuffer[off:end])\n        elif i.get_ip_p() == ImpactPacket.ICMP.protocol:\n            self.icmp_decoder = ICMPDecoder()\n            packet = self.icmp_decoder.decode(aBuffer[off:end])\n        elif i.get_ip_p() == ImpactPacket.IGMP.protocol:\n            self.igmp_decoder = IGMPDecoder()\n            packet = self.igmp_decoder.decode(aBuffer[off:end])\n        else:\n            self.data_decoder = DataDecoder()\n            packet = self.data_decoder.decode(aBuffer[off:end])\n        i.contains(packet)\n        return i",
  "def __init__(self, a_protocol_id):\n        self.protocol_id = a_protocol_id",
  "def decode(self, buffer):\n        if self.protocol_id == ImpactPacket.UDP.protocol:\n            self.udp_decoder = UDPDecoder()\n            packet = self.udp_decoder.decode(buffer)\n        elif self.protocol_id == ImpactPacket.TCP.protocol:\n            self.tcp_decoder = TCPDecoder()\n            packet = self.tcp_decoder.decode(buffer)\n        elif self.protocol_id == ICMP6.ICMP6.protocol:\n            self.icmp6_decoder = ICMP6Decoder()\n            packet = self.icmp6_decoder.decode(buffer)\n        else:\n            # IPv6 Extension Headers lookup\n            extension_headers = IP6_Extension_Headers.IP6_Extension_Header.get_extension_headers()\n            if buffer and self.protocol_id in extension_headers:\n                extension_header_decoder_class = extension_headers[self.protocol_id].get_decoder()\n                self.extension_header_decoder = extension_header_decoder_class()\n                packet = self.extension_header_decoder.decode(buffer)\n            else:\n                self.data_decoder = DataDecoder()\n                packet = self.data_decoder.decode(buffer)\n\n        return packet",
  "def __init__(self):\n        pass",
  "def decode(self, buffer):\n        ip6_packet = IP6.IP6(buffer)\n        self.set_decoded_protocol(ip6_packet)\n        start_pos = ip6_packet.get_header_size() \n        end_pos = ip6_packet.get_payload_length() + start_pos\n        contained_protocol = ip6_packet.get_next_header()\n        \n        multi_protocol_decoder = IP6MultiProtocolDecoder(contained_protocol)\n        child_packet = multi_protocol_decoder.decode(buffer[start_pos:end_pos])\n        \n        ip6_packet.contains(child_packet)\n        return ip6_packet",
  "def __init__(self):\n        pass",
  "def decode(self, buffer):\n        hop_by_hop = IP6_Extension_Headers.Hop_By_Hop(buffer)\n        self.set_decoded_protocol(hop_by_hop)\n        start_pos = hop_by_hop.get_header_size()\n        contained_protocol = hop_by_hop.get_next_header()\n\n        multi_protocol_decoder = IP6MultiProtocolDecoder(contained_protocol)\n        child_packet = multi_protocol_decoder.decode(buffer[start_pos:])\n        \n        hop_by_hop.contains(child_packet)\n        return hop_by_hop",
  "def __init__(self):\n        pass",
  "def decode(self, buffer):\n        destination_options = IP6_Extension_Headers.Destination_Options(buffer)\n        self.set_decoded_protocol(destination_options)\n        start_pos = destination_options.get_header_size()\n        contained_protocol = destination_options.get_next_header()\n\n        multi_protocol_decoder = IP6MultiProtocolDecoder(contained_protocol)\n        child_packet = multi_protocol_decoder.decode(buffer[start_pos:])\n        \n        destination_options.contains(child_packet)\n        return destination_options",
  "def __init__(self):\n        pass",
  "def decode(self, buffer):\n        routing_options = IP6_Extension_Headers.Routing_Options(buffer)\n        self.set_decoded_protocol(routing_options)\n        start_pos = routing_options.get_header_size()\n        contained_protocol = routing_options.get_next_header()\n\n        multi_protocol_decoder = IP6MultiProtocolDecoder(contained_protocol)\n        child_packet = multi_protocol_decoder.decode(buffer[start_pos:])\n        \n        routing_options.contains(child_packet)\n        return routing_options",
  "def __init__(self):\n        pass",
  "def decode(self, buffer):\n        icmp6_packet = ICMP6.ICMP6(buffer)\n        self.set_decoded_protocol(icmp6_packet)\n        start_pos = icmp6_packet.get_header_size() \n                \n        self.data_decoder = DataDecoder()\n        child_packet = self.data_decoder.decode(buffer[start_pos:])\n        icmp6_packet.contains(child_packet)\n        return icmp6_packet",
  "def __init__(self):\n        pass",
  "def decode(self, aBuffer):\n        arp = ImpactPacket.ARP(aBuffer)\n        self.set_decoded_protocol( arp )\n        off = arp.get_header_size()\n        self.data_decoder = DataDecoder()\n        packet = self.data_decoder.decode(aBuffer[off:])\n        arp.contains(packet)\n        return arp",
  "def __init__(self):\n        pass",
  "def decode(self, aBuffer):\n        u = ImpactPacket.UDP(aBuffer)\n        self.set_decoded_protocol( u )\n        off = u.get_header_size()\n        self.data_decoder = DataDecoder()\n        packet = self.data_decoder.decode(aBuffer[off:])\n        u.contains(packet)\n        return u",
  "def __init__(self):\n        pass",
  "def decode(self, aBuffer):\n        t = ImpactPacket.TCP(aBuffer)\n        self.set_decoded_protocol( t )\n        off = t.get_header_size()\n        self.data_decoder = DataDecoder()\n        packet = self.data_decoder.decode(aBuffer[off:])\n        t.contains(packet)\n        return t",
  "def __init__(self):\n        pass",
  "def decode(self, aBuffer):\n        ig = ImpactPacket.IGMP(aBuffer)\n        off = ig.get_header_size()\n        self.data_decoder = DataDecoder()\n        packet = self.data_decoder.decode(aBuffer[off:])\n        ig.contains(packet)\n        return ig",
  "def __init__(self):\n        pass",
  "def decode(self, aBuffer):\n        i = ImpactPacket.IP(aBuffer)\n        self.set_decoded_protocol( i )\n        off = i.get_header_size()\n        if i.get_ip_p() == ImpactPacket.UDP.protocol:\n            self.udp_decoder = UDPDecoder()\n            packet = self.udp_decoder.decode(aBuffer[off:])\n        else:\n            self.data_decoder = DataDecoder()\n            packet = self.data_decoder.decode(aBuffer[off:])\n        i.contains(packet)\n        return i",
  "def __init__(self):\n        pass",
  "def decode(self, aBuffer):\n        ic = ImpactPacket.ICMP(aBuffer)\n        self.set_decoded_protocol( ic )\n        off = ic.get_header_size()\n        if ic.get_icmp_type() == ImpactPacket.ICMP.ICMP_UNREACH:\n            self.ip_decoder = IPDecoderForICMP()\n            packet = self.ip_decoder.decode(aBuffer[off:])\n        else:\n            self.data_decoder = DataDecoder()\n            packet = self.data_decoder.decode(aBuffer[off:])\n        ic.contains(packet)\n        return ic",
  "def decode(self, aBuffer):\n        d = ImpactPacket.Data(aBuffer)\n        self.set_decoded_protocol( d )\n        return d",
  "def __init__(self, key_manager=None):\n        self.set_key_manager(key_manager)",
  "def set_key_manager(self, key_manager):\n        self.key_manager = key_manager",
  "def find_key(self, bssid):\n        try:\n            key = self.key_manager.get_key(bssid)\n        except:\n            return False\n        return key",
  "def __init__(self):\n        BaseDot11Decoder.__init__(self)",
  "def decode(self, aBuffer):\n        rt = dot11.RadioTap(aBuffer)\n        self.set_decoded_protocol( rt )\n        \n        self.do11_decoder = Dot11Decoder()\n        self.do11_decoder.set_key_manager(self.key_manager)\n        flags=rt.get_flags()\n        if flags is not None:\n            fcs=flags&dot11.RadioTap.RTF_FLAGS.PROPERTY_FCS_AT_END\n            self.do11_decoder.FCS_at_end(fcs)\n            \n        packet = self.do11_decoder.decode(rt.get_body_as_string())\n    \n        rt.contains(packet)\n        return rt",
  "def __init__(self):\n        BaseDot11Decoder.__init__(self)\n        self.__FCS_at_end = True",
  "def FCS_at_end(self, fcs_at_end=True):\n        self.__FCS_at_end=not not fcs_at_end",
  "def decode(self, aBuffer):\n        d = dot11.Dot11(aBuffer, self.__FCS_at_end)\n        self.set_decoded_protocol( d )\n        \n        type = d.get_type()\n        if type == dot11.Dot11Types.DOT11_TYPE_CONTROL:\n            dot11_control_decoder = Dot11ControlDecoder()\n            packet = dot11_control_decoder.decode(d.body_string)\n        elif type == dot11.Dot11Types.DOT11_TYPE_DATA:\n            dot11_data_decoder = Dot11DataDecoder(self.key_manager)\n            \n            dot11_data_decoder.set_dot11_hdr(d)\n            \n            packet = dot11_data_decoder.decode(d.body_string)\n        elif type == dot11.Dot11Types.DOT11_TYPE_MANAGEMENT:\n            dot11_management_decoder = Dot11ManagementDecoder()\n            dot11_management_decoder.set_subtype(d.get_subtype())\n            packet = dot11_management_decoder.decode(d.body_string)\n        else:\n            data_decoder = DataDecoder()\n            packet = data_decoder.decode(d.body_string)\n\n        d.contains(packet)\n        return d",
  "def __init__(self):\n        BaseDot11Decoder.__init__(self)\n        self.__FCS_at_end = True",
  "def FCS_at_end(self, fcs_at_end=True):\n        self.__FCS_at_end=not not fcs_at_end",
  "def decode(self, aBuffer):\n        d = dot11.Dot11(aBuffer, self.__FCS_at_end)\n        self.set_decoded_protocol(d)\n        \n        self.subtype = d.get_subtype()\n        if self.subtype is dot11.Dot11Types.DOT11_SUBTYPE_CONTROL_CLEAR_TO_SEND:\n            self.ctrl_cts_decoder = Dot11ControlFrameCTSDecoder()\n            packet = self.ctrl_cts_decoder.decode(d.body_string)\n        elif self.subtype is dot11.Dot11Types.DOT11_SUBTYPE_CONTROL_ACKNOWLEDGMENT:\n            self.ctrl_ack_decoder = Dot11ControlFrameACKDecoder()\n            packet = self.ctrl_ack_decoder.decode(d.body_string)\n        elif self.subtype is dot11.Dot11Types.DOT11_SUBTYPE_CONTROL_REQUEST_TO_SEND:\n            self.ctrl_rts_decoder = Dot11ControlFrameRTSDecoder()\n            packet = self.ctrl_rts_decoder.decode(d.body_string)\n        elif self.subtype is dot11.Dot11Types.DOT11_SUBTYPE_CONTROL_POWERSAVE_POLL:\n            self.ctrl_pspoll_decoder = Dot11ControlFramePSPollDecoder()\n            packet = self.ctrl_pspoll_decoder.decode(d.body_string)\n        elif self.subtype is dot11.Dot11Types.DOT11_SUBTYPE_CONTROL_CF_END:\n            self.ctrl_cfend_decoder = Dot11ControlFrameCFEndDecoder()\n            packet = self.ctrl_cfend_decoder.decode(d.body_string)\n        elif self.subtype is dot11.Dot11Types.DOT11_SUBTYPE_CONTROL_CF_END_CF_ACK:\n            self.ctrl_cfendcfack_decoder = Dot11ControlFrameCFEndCFACKDecoder()\n            packet = self.ctrl_cfendcfack_decoder.decode(d.body_string)\n        else:\n            data_decoder = DataDecoder()\n            packet = data_decoder.decode(d.body_string)\n        \n        d.contains(packet)\n        return d",
  "def __init__(self):\n        BaseDot11Decoder.__init__(self)",
  "def decode(self, aBuffer):\n        p = dot11.Dot11ControlFrameCTS(aBuffer)\n        self.set_decoded_protocol(p)\n        return p",
  "def __init__(self):\n        BaseDot11Decoder.__init__(self)",
  "def decode(self, aBuffer):\n        p = dot11.Dot11ControlFrameACK(aBuffer)\n        self.set_decoded_protocol(p)\n        return p",
  "def __init__(self):\n        BaseDot11Decoder.__init__(self)",
  "def decode(self, aBuffer):\n        p = dot11.Dot11ControlFrameRTS(aBuffer)\n        self.set_decoded_protocol(p)\n        return p",
  "def __init__(self):\n        BaseDot11Decoder.__init__(self)",
  "def decode(self, aBuffer):\n        p = dot11.Dot11ControlFramePSPoll(aBuffer)\n        self.set_decoded_protocol(p)\n        return p",
  "def __init__(self):\n        BaseDot11Decoder.__init__(self)",
  "def decode(self, aBuffer):\n        p = dot11.Dot11ControlFrameCFEnd(aBuffer)\n        self.set_decoded_protocol(p)\n        return p",
  "def __init__(self):\n        BaseDot11Decoder.__init__(self)",
  "def decode(self, aBuffer):\n        p = dot11.Dot11ControlFrameCFEndCFACK(aBuffer)\n        self.set_decoded_protocol(p)\n        return p",
  "def __init__(self, key_manager):\n        BaseDot11Decoder.__init__(self, key_manager)",
  "def set_dot11_hdr(self, dot11_obj):\n        self.dot11 = dot11_obj",
  "def decode(self, aBuffer):\n        if self.dot11.get_fromDS() and self.dot11.get_toDS():\n            if self.dot11.is_QoS_frame():\n                p = dot11.Dot11DataAddr4QoSFrame(aBuffer)\n            else:\n                p = dot11.Dot11DataAddr4Frame(aBuffer)\n        elif self.dot11.is_QoS_frame():\n            p = dot11.Dot11DataQoSFrame(aBuffer)\n        else:\n            p = dot11.Dot11DataFrame(aBuffer)\n        self.set_decoded_protocol( p )\n        \n        if not self.dot11.get_protectedFrame():\n            self.llc_decoder = LLCDecoder()\n            packet = self.llc_decoder.decode(p.body_string)\n        else:\n            if not self.dot11.get_fromDS() and self.dot11.get_toDS():\n                bssid = p.get_address1()\n            elif self.dot11.get_fromDS() and not self.dot11.get_toDS():\n                bssid = p.get_address2()\n            elif not self.dot11.get_fromDS() and not self.dot11.get_toDS():\n                bssid = p.get_address3()\n            else:\n                # WDS, this is the RA\n                bssid = p.get_address1()\n                \n            wep_decoder = Dot11WEPDecoder(self.key_manager)\n            wep_decoder.set_bssid(bssid)\n            packet = wep_decoder.decode(p.body_string)\n            if packet is None:\n                wpa_decoder = Dot11WPADecoder()\n                packet = wpa_decoder.decode(p.body_string)\n                if packet is None:\n                    wpa2_decoder = Dot11WPA2Decoder()\n                    packet = wpa2_decoder.decode(p.body_string)\n                    if packet is None:\n                        data_decoder = DataDecoder()\n                        packet = data_decoder.decode(p.body_string)\n        \n        p.contains(packet)\n        return p",
  "def __init__(self, key_manager):\n        BaseDot11Decoder.__init__(self, key_manager)\n        self.bssid = None",
  "def set_bssid(self, bssid):\n        self.bssid = bssid",
  "def decode(self, aBuffer):\n        wep = dot11.Dot11WEP(aBuffer)\n        self.set_decoded_protocol( wep )\n        \n        if wep.is_WEP() is False:\n            return None\n        \n        key = self.find_key(self.bssid)\n        if key:\n            decoded_string=wep.get_decrypted_data(key)\n            \n            wep_data = Dot11WEPDataDecoder()\n            packet = wep_data.decode(decoded_string)\n        else:\n            data_decoder = DataDecoder()\n            packet = data_decoder.decode(wep.body_string)\n        \n        wep.contains(packet)\n        \n        return wep",
  "def __init__(self):\n        BaseDot11Decoder.__init__(self)",
  "def decode(self, aBuffer):\n        wep_data = dot11.Dot11WEPData(aBuffer)\n\n        if not wep_data.check_icv():\n            # TODO: Do something when the icv is not correct\n            pass\n\n        self.set_decoded_protocol( wep_data )\n\n        llc_decoder = LLCDecoder()\n        packet = llc_decoder.decode(wep_data.body_string)\n\n        wep_data.contains(packet)\n\n        return wep_data",
  "def __init__(self):\n        BaseDot11Decoder.__init__(self)",
  "def decode(self, aBuffer, key=None):\n        wpa = dot11.Dot11WPA(aBuffer)\n        self.set_decoded_protocol( wpa )\n\n        if wpa.is_WPA() is False:\n            return None\n\n        if key:\n            decoded_string=wpa.get_decrypted_data()\n\n            wpa_data = Dot11WPADataDecoder()\n            packet = wpa_data.decode(decoded_string)\n        else:\n            data_decoder = DataDecoder()\n            packet = data_decoder.decode(wpa.body_string)\n\n        wpa.contains(packet)\n\n        return wpa",
  "def __init__(self):\n        BaseDot11Decoder.__init__(self)",
  "def decode(self, aBuffer):\n        wpa_data = dot11.Dot11WPAData(aBuffer)\n        self.set_decoded_protocol( wpa_data )\n\n        llc_decoder = LLCDecoder()\n        packet = self.llc_decoder.decode(wpa_data.body_string)\n\n        wpa_data.contains(packet)\n\n        return wpa_data",
  "def __init__(self):\n        BaseDot11Decoder.__init__(self)",
  "def decode(self, aBuffer, key=None):\n        wpa2 = dot11.Dot11WPA2(aBuffer)\n        self.set_decoded_protocol( wpa2 )\n\n        if wpa2.is_WPA2() is False:\n            return None\n\n        if key:\n            decoded_string=wpa2.get_decrypted_data()\n\n            wpa2_data = Dot11WPA2DataDecoder()\n            packet = wpa2_data.decode(decoded_string)\n        else:\n            data_decoder = DataDecoder()\n            packet = data_decoder.decode(wpa2.body_string)\n\n            wpa2.contains(packet)\n\n            return wpa2",
  "def __init__(self):\n        BaseDot11Decoder.__init__(self)",
  "def decode(self, aBuffer):\n        wpa2_data = dot11.Dot11WPA2Data(aBuffer)\n        self.set_decoded_protocol( wpa2_data )\n\n        llc_decoder = LLCDecoder()\n        packet = self.llc_decoder.decode(wpa2_data.body_string)\n\n        wpa2_data.contains(packet)\n\n        return wpa2_data",
  "def __init__(self):\n        pass",
  "def decode(self, aBuffer):\n        d = dot11.LLC(aBuffer)\n        self.set_decoded_protocol( d )\n\n        if d.get_DSAP()==dot11.SAPTypes.SNAP:\n            if d.get_SSAP()==dot11.SAPTypes.SNAP:\n                if d.get_control()==dot11.LLC.DLC_UNNUMBERED_FRAMES:\n                    snap_decoder = SNAPDecoder()\n                    packet = snap_decoder.decode(d.body_string)\n                    d.contains(packet)\n                    return d\n\n        # Only SNAP is implemented\n        data_decoder = DataDecoder()\n        packet = data_decoder.decode(d.body_string)\n        d.contains(packet)\n        return d",
  "def __init__(self):\n        pass",
  "def decode(self, aBuffer):\n        s = dot11.SNAP(aBuffer)\n        self.set_decoded_protocol( s )\n        if  s.get_OUI()==CDP.OUI and s.get_protoID()==CDP.Type:\n            dec = CDPDecoder()\n            packet = dec.decode(s.body_string)\n        elif  s.get_OUI()!=0x000000:\n            # We don't know how to handle other than OUI=0x000000 (EtherType)\n            self.data_decoder = DataDecoder()\n            packet = self.data_decoder.decode(s.body_string)\n        elif s.get_protoID() == ImpactPacket.IP.ethertype:\n            self.ip_decoder = IPDecoder()\n            packet = self.ip_decoder.decode(s.body_string)\n        elif s.get_protoID() == ImpactPacket.ARP.ethertype:\n            self.arp_decoder = ARPDecoder()\n            packet = self.arp_decoder.decode(s.body_string)\n        elif s.get_protoID() == eap.DOT1X_AUTHENTICATION:\n            self.eapol_decoder = EAPOLDecoder()\n            packet = self.eapol_decoder.decode(s.body_string)\n        else:\n            self.data_decoder = DataDecoder()\n            packet = self.data_decoder.decode(s.body_string)\n\n        s.contains(packet)\n        return s",
  "def __init__(self):\n        pass",
  "def decode(self, aBuffer):\n        s = CDP(aBuffer)\n        self.set_decoded_protocol( s )\n        return s",
  "def __init__(self):\n        BaseDot11Decoder.__init__(self)\n        self.subtype = None",
  "def set_subtype(self, subtype):\n        self.subtype=subtype",
  "def decode(self, aBuffer):\n        p = dot11.Dot11ManagementFrame(aBuffer)\n        self.set_decoded_protocol( p )\n\n        if self.subtype is dot11.Dot11Types.DOT11_SUBTYPE_MANAGEMENT_BEACON:\n            self.mgt_beacon_decoder = Dot11ManagementBeaconDecoder()\n            packet = self.mgt_beacon_decoder.decode(p.body_string)\n        elif self.subtype is dot11.Dot11Types.DOT11_SUBTYPE_MANAGEMENT_PROBE_REQUEST:\n            self.mgt_probe_request_decoder = Dot11ManagementProbeRequestDecoder()\n            packet = self.mgt_probe_request_decoder.decode(p.body_string)\n        elif self.subtype is dot11.Dot11Types.DOT11_SUBTYPE_MANAGEMENT_PROBE_RESPONSE:\n            self.mgt_probe_response_decoder = Dot11ManagementProbeResponseDecoder()\n            packet = self.mgt_probe_response_decoder.decode(p.body_string)\n        elif self.subtype is dot11.Dot11Types.DOT11_SUBTYPE_MANAGEMENT_DEAUTHENTICATION:\n            self.mgt_deauthentication_decoder = Dot11ManagementDeauthenticationDecoder()\n            packet = self.mgt_deauthentication_decoder.decode(p.body_string)\n        elif self.subtype is dot11.Dot11Types.DOT11_SUBTYPE_MANAGEMENT_AUTHENTICATION:\n            self.mgt_Authentication_decoder = Dot11ManagementAuthenticationDecoder()\n            packet = self.mgt_Authentication_decoder.decode(p.body_string)\n        elif self.subtype is dot11.Dot11Types.DOT11_SUBTYPE_MANAGEMENT_DISASSOCIATION:\n            self.mgt_disassociation_decoder = Dot11ManagementDisassociationDecoder()\n            packet = self.mgt_disassociation_decoder.decode(p.body_string)\n        elif self.subtype is dot11.Dot11Types.DOT11_SUBTYPE_MANAGEMENT_ASSOCIATION_REQUEST:\n            self.mgt_association_request_decoder = Dot11ManagementAssociationRequestDecoder()\n            packet = self.mgt_association_request_decoder.decode(p.body_string)\n        elif self.subtype is dot11.Dot11Types.DOT11_SUBTYPE_MANAGEMENT_ASSOCIATION_RESPONSE:\n            self.mgt_association_response_decoder = Dot11ManagementAssociationResponseDecoder()\n            packet = self.mgt_association_response_decoder.decode(p.body_string)\n        elif self.subtype is dot11.Dot11Types.DOT11_SUBTYPE_MANAGEMENT_REASSOCIATION_REQUEST:\n            self.mgt_reassociation_request_decoder = Dot11ManagementReassociationRequestDecoder()\n            packet = self.mgt_reassociation_request_decoder.decode(p.body_string)\n        elif self.subtype is dot11.Dot11Types.DOT11_SUBTYPE_MANAGEMENT_REASSOCIATION_RESPONSE:\n            self.mgt_reassociation_response_decoder = Dot11ManagementReassociationResponseDecoder()\n            packet = self.mgt_reassociation_response_decoder.decode(p.body_string)\n        else:\n            data_decoder = DataDecoder()\n            packet = data_decoder.decode(p.body_string)\n\n        p.contains(packet)\n        return p",
  "def __init__(self):\n        BaseDot11Decoder.__init__(self)",
  "def decode(self, aBuffer):\n        p = dot11.Dot11ManagementBeacon(aBuffer)\n        self.set_decoded_protocol( p )\n\n        return p",
  "def __init__(self):\n        BaseDot11Decoder.__init__(self)",
  "def decode(self, aBuffer):\n        p = dot11.Dot11ManagementProbeRequest(aBuffer)\n        self.set_decoded_protocol( p )\n\n        return p",
  "def __init__(self):\n        BaseDot11Decoder.__init__(self)",
  "def decode(self, aBuffer):\n        p = dot11.Dot11ManagementProbeResponse(aBuffer)\n        self.set_decoded_protocol( p )\n\n        return p",
  "def __init__(self):\n        BaseDot11Decoder.__init__(self)",
  "def decode(self, aBuffer):\n        p = dot11.Dot11ManagementDeauthentication(aBuffer)\n        self.set_decoded_protocol( p )\n\n        return p",
  "def __init__(self):\n        BaseDot11Decoder.__init__(self)",
  "def decode(self, aBuffer):\n        p = dot11.Dot11ManagementAuthentication(aBuffer)\n        self.set_decoded_protocol(p)\n\n        return p",
  "def __init__(self):\n        BaseDot11Decoder.__init__(self)",
  "def decode(self, aBuffer):\n        p = dot11.Dot11ManagementDisassociation(aBuffer)\n        self.set_decoded_protocol(p)\n\n        return p",
  "def __init__(self):\n        BaseDot11Decoder.__init__(self)",
  "def decode(self, aBuffer):\n        p = dot11.Dot11ManagementAssociationRequest(aBuffer)\n        self.set_decoded_protocol(p)\n\n        return p",
  "def __init__(self):\n        BaseDot11Decoder.__init__(self)",
  "def decode(self, aBuffer):\n        p = dot11.Dot11ManagementAssociationResponse(aBuffer)\n        self.set_decoded_protocol(p)\n\n        return p",
  "def __init__(self):\n        BaseDot11Decoder.__init__(self)",
  "def decode(self, aBuffer):\n        p = dot11.Dot11ManagementReassociationRequest(aBuffer)\n        self.set_decoded_protocol(p)\n\n        return p",
  "def __init__(self):\n        BaseDot11Decoder.__init__(self)",
  "def decode(self, aBuffer):\n        p = dot11.Dot11ManagementReassociationResponse(aBuffer)\n        self.set_decoded_protocol(p)\n\n        return p",
  "def decode(self, buff):\n\n        packet = self.klass(buff)\n        self.set_decoded_protocol(packet)\n        cd = self.child_decoders.get(self.child_key(packet), DataDecoder())\n        packet.contains(cd.decode(packet.get_body_as_string()))\n        return packet",
  "def decode(self, buff):\n        sc = BaseDecoder.decode(self, buff)\n        ary = array.array('B', sc.child().get_packet())\n        sc.unlink_child()\n        tlv = wps.SimpleConfig.build_tlv_container()\n        tlv.from_ary(ary)\n        sc.contains(tlv)\n\n        return sc",
  "def __init__(self):\n        pass",
  "def decode(self, aBuffer):\n        d = dhcp.BootpPacket(aBuffer)\n        self.set_decoded_protocol( d )\n        off = len(d.getData())\n        if dhcp.DhcpPacket(aBuffer[off:])['cookie'] == dhcp.DhcpPacket.MAGIC_NUMBER:\n            self.data_decoder = DHCPDecoder()\n            packet = self.data_decoder.decode(aBuffer[off:])\n            d.contains(packet)\n        return d",
  "def __init__(self):\n        pass",
  "def decode(self, aBuffer):\n        d = dhcp.DhcpPacket(aBuffer)\n        self.set_decoded_protocol( d )\n        return d",
  "class ICMP6(Header):    \n    #IP Protocol number for ICMP6\n    IP_PROTOCOL_NUMBER = 58\n    protocol = IP_PROTOCOL_NUMBER   #ImpactDecoder uses the constant \"protocol\" as the IP Protocol Number\n    \n    #Size of ICMP6 header (excluding payload)\n    HEADER_SIZE = 4\n\n    #ICMP6 Message Type numbers\n    DESTINATION_UNREACHABLE = 1\n    PACKET_TOO_BIG = 2\n    TIME_EXCEEDED = 3\n    PARAMETER_PROBLEM = 4    \n    ECHO_REQUEST = 128\n    ECHO_REPLY = 129\n    ROUTER_SOLICITATION = 133\n    ROUTER_ADVERTISEMENT = 134\n    NEIGHBOR_SOLICITATION = 135\n    NEIGHBOR_ADVERTISEMENT = 136\n    REDIRECT_MESSAGE = 137\n    NODE_INFORMATION_QUERY = 139\n    NODE_INFORMATION_REPLY = 140\n    \n    #Destination Unreachable codes\n    NO_ROUTE_TO_DESTINATION = 0\n    ADMINISTRATIVELY_PROHIBITED = 1\n    BEYOND_SCOPE_OF_SOURCE_ADDRESS = 2\n    ADDRESS_UNREACHABLE = 3\n    PORT_UNREACHABLE = 4\n    SOURCE_ADDRESS_FAILED_INGRESS_EGRESS_POLICY = 5\n    REJECT_ROUTE_TO_DESTINATION = 6\n    \n    #Time Exceeded codes\n    HOP_LIMIT_EXCEEDED_IN_TRANSIT = 0\n    FRAGMENT_REASSEMBLY_TIME_EXCEEDED = 1\n    \n    #Parameter problem codes\n    ERRONEOUS_HEADER_FIELD_ENCOUNTERED = 0\n    UNRECOGNIZED_NEXT_HEADER_TYPE_ENCOUNTERED = 1\n    UNRECOGNIZED_IPV6_OPTION_ENCOUNTERED = 2\n    \n    #Node Information codes\n    NODE_INFORMATION_QUERY_IPV6 = 0\n    NODE_INFORMATION_QUERY_NAME_OR_EMPTY = 1\n    NODE_INFORMATION_QUERY_IPV4 = 2\n    NODE_INFORMATION_REPLY_SUCCESS = 0\n    NODE_INFORMATION_REPLY_REFUSED = 1\n    NODE_INFORMATION_REPLY_UNKNOWN_QTYPE = 2\n    \n    #Node Information qtypes\n    NODE_INFORMATION_QTYPE_NOOP = 0\n    NODE_INFORMATION_QTYPE_UNUSED = 1\n    NODE_INFORMATION_QTYPE_NODENAME = 2\n    NODE_INFORMATION_QTYPE_NODEADDRS = 3\n    NODE_INFORMATION_QTYPE_IPv4ADDRS = 4\n    \n    #ICMP Message semantic types (error or informational)    \n    ERROR_MESSAGE = 0\n    INFORMATIONAL_MESSAGE = 1\n    \n    #ICMP message dictionary - specifying text descriptions and valid message codes\n    #Key: ICMP message number\n    #Data: Tuple ( Message Type (error/informational), Text description, Codes dictionary (can be None) )\n    #Codes dictionary\n    #Key: Code number\n    #Data: Text description\n    \n    #ICMP message dictionary tuple indexes\n    MSG_TYPE_INDEX = 0\n    DESCRIPTION_INDEX = 1\n    CODES_INDEX = 2\n\n    icmp_messages = {\n                     DESTINATION_UNREACHABLE : (ERROR_MESSAGE, \"Destination unreachable\",\n                                                { NO_ROUTE_TO_DESTINATION : \"No route to destination\",\n                                                  ADMINISTRATIVELY_PROHIBITED : \"Administratively prohibited\",\n                                                  BEYOND_SCOPE_OF_SOURCE_ADDRESS : \"Beyond scope of source address\",\n                                                  ADDRESS_UNREACHABLE : \"Address unreachable\",\n                                                  PORT_UNREACHABLE : \"Port unreachable\",\n                                                  SOURCE_ADDRESS_FAILED_INGRESS_EGRESS_POLICY : \"Source address failed ingress/egress policy\",\n                                                  REJECT_ROUTE_TO_DESTINATION : \"Reject route to destination\"\n                                                  }),\n                     PACKET_TOO_BIG : (ERROR_MESSAGE, \"Packet too big\", None),\n                     TIME_EXCEEDED : (ERROR_MESSAGE, \"Time exceeded\",\n                                        {HOP_LIMIT_EXCEEDED_IN_TRANSIT : \"Hop limit exceeded in transit\",\n                                        FRAGMENT_REASSEMBLY_TIME_EXCEEDED : \"Fragment reassembly time exceeded\"                                      \n                                       }),\n                     PARAMETER_PROBLEM : (ERROR_MESSAGE, \"Parameter problem\",\n                                          {\n                                           ERRONEOUS_HEADER_FIELD_ENCOUNTERED : \"Erroneous header field encountered\",\n                                           UNRECOGNIZED_NEXT_HEADER_TYPE_ENCOUNTERED : \"Unrecognized Next Header type encountered\",\n                                           UNRECOGNIZED_IPV6_OPTION_ENCOUNTERED : \"Unrecognized IPv6 Option Encountered\"\n                                           }),\n                     ECHO_REQUEST : (INFORMATIONAL_MESSAGE, \"Echo request\", None),\n                     ECHO_REPLY : (INFORMATIONAL_MESSAGE, \"Echo reply\", None),\n                     ROUTER_SOLICITATION : (INFORMATIONAL_MESSAGE, \"Router Solicitation\", None),\n                     ROUTER_ADVERTISEMENT : (INFORMATIONAL_MESSAGE, \"Router Advertisement\", None),\n                     NEIGHBOR_SOLICITATION : (INFORMATIONAL_MESSAGE, \"Neighbor Solicitation\", None),\n                     NEIGHBOR_ADVERTISEMENT : (INFORMATIONAL_MESSAGE, \"Neighbor Advertisement\", None),\n                     REDIRECT_MESSAGE : (INFORMATIONAL_MESSAGE, \"Redirect Message\", None),\n                     NODE_INFORMATION_QUERY: (INFORMATIONAL_MESSAGE, \"Node Information Query\", None),\n                     NODE_INFORMATION_REPLY: (INFORMATIONAL_MESSAGE, \"Node Information Reply\", None),\n                    } \n    \n    \n    \n    \n############################################################################\n    def __init__(self, buffer = None):\n        Header.__init__(self, self.HEADER_SIZE)\n        if (buffer):\n            self.load_header(buffer)\n    \n    def get_header_size(self):\n        return self.HEADER_SIZE\n    \n    def get_ip_protocol_number(self):\n        return self.IP_PROTOCOL_NUMBER\n\n    def __str__(self):        \n        type = self.get_type()\n        code = self.get_code()\n        checksum = self.get_checksum()\n\n        s = \"ICMP6 - Type: \" + str(type) + \" - \"  + self.__get_message_description() + \"\\n\"\n        s += \"Code: \" + str(code)\n        if (self.__get_code_description() != \"\"):\n            s += \" - \" + self.__get_code_description()\n        s += \"\\n\"\n        s += \"Checksum: \" + str(checksum) + \"\\n\"\n        return s\n    \n    def __get_message_description(self):\n        return self.icmp_messages[self.get_type()][self.DESCRIPTION_INDEX]\n    \n    def __get_code_description(self):\n        code_dictionary = self.icmp_messages[self.get_type()][self.CODES_INDEX]\n        if (code_dictionary is None):\n            return \"\"\n        else:\n            return code_dictionary[self.get_code()]\n    \n############################################################################\n    def get_type(self):        \n        return (self.get_byte(0))\n    \n    def get_code(self):\n        return (self.get_byte(1))\n    \n    def get_checksum(self):\n        return (self.get_word(2))\n    \n############################################################################\n    def set_type(self, type):\n        self.set_byte(0, type)\n    \n    def set_code(self, code):\n        self.set_byte(1, code)\n    \n    def set_checksum(self, checksum):\n        self.set_word(2, checksum)\n    \n############################################################################\n    def calculate_checksum(self):        \n        #Initialize the checksum value to 0 to yield a correct calculation\n        self.set_checksum(0)        \n        #Fetch the pseudo header from the IP6 parent packet\n        pseudo_header = self.parent().get_pseudo_header()\n        #Fetch the ICMP data\n        icmp_header = self.get_bytes()\n        #Build an array of bytes concatenating the pseudo_header, the ICMP header and the ICMP data (if present)\n        checksum_array = array.array('B')\n        checksum_array.extend(pseudo_header)\n        checksum_array.extend(icmp_header)\n        if (self.child()):\n            checksum_array.extend(self.child().get_bytes())\n            \n        #Compute the checksum over that array\n        self.set_checksum(self.compute_checksum(checksum_array))\n        \n    def is_informational_message(self):\n        return self.icmp_messages[self.get_type()][self.MSG_TYPE_INDEX] == self.INFORMATIONAL_MESSAGE\n        \n    def is_error_message(self):\n        return self.icmp_messages[self.get_type()][self.MSG_TYPE_INDEX] == self.ERROR_MESSAGE\n    \n    def is_well_formed(self):\n        well_formed = True\n        \n        #Check that the message type is known\n        well_formed &= self.get_type() in self.icmp_messages.keys()\n        \n        #Check that the code is known (zero, if there are no codes defined)\n        code_dictionary = self.icmp_messages[self.get_type()][self.CODES_INDEX]\n        if (code_dictionary is None):\n            well_formed &= self.get_code() == 0\n        else:            \n            well_formed &= self.get_code() in code_dictionary.keys()\n            \n        return well_formed \n        \n############################################################################\n\n    @classmethod\n    def Echo_Request(class_object, id, sequence_number, arbitrary_data = None):\n        return class_object.__build_echo_message(ICMP6.ECHO_REQUEST, id, sequence_number, arbitrary_data)\n    \n    @classmethod\n    def Echo_Reply(class_object, id, sequence_number, arbitrary_data = None):\n        return class_object.__build_echo_message(ICMP6.ECHO_REPLY, id, sequence_number, arbitrary_data)\n    \n    @classmethod\n    def __build_echo_message(class_object, type, id, sequence_number, arbitrary_data):\n        #Build ICMP6 header\n        icmp_packet = ICMP6()\n        icmp_packet.set_type(type)\n        icmp_packet.set_code(0)\n        \n        #Pack ICMP payload\n        icmp_bytes = struct.pack('>H', id)\n        icmp_bytes += struct.pack('>H', sequence_number)\n        if (arbitrary_data is not None):\n            icmp_bytes += array_tobytes(array.array('B', arbitrary_data))\n        icmp_payload = Data()\n        icmp_payload.set_data(icmp_bytes)\n        \n        #Link payload to header\n        icmp_packet.contains(icmp_payload)\n        \n        return icmp_packet\n    \n    \n############################################################################\n    @classmethod\n    def Destination_Unreachable(class_object, code, originating_packet_data = None):\n        unused_bytes = [0x00, 0x00, 0x00, 0x00]\n        return class_object.__build_error_message(ICMP6.DESTINATION_UNREACHABLE, code, unused_bytes, originating_packet_data)\n\n    @classmethod\n    def Packet_Too_Big(class_object, MTU, originating_packet_data = None):\n        MTU_bytes = struct.pack('!L', MTU)\n        return class_object.__build_error_message(ICMP6.PACKET_TOO_BIG, 0, MTU_bytes, originating_packet_data)\n    \n    @classmethod\n    def Time_Exceeded(class_object, code, originating_packet_data = None):\n        unused_bytes = [0x00, 0x00, 0x00, 0x00]\n        return class_object.__build_error_message(ICMP6.TIME_EXCEEDED, code, unused_bytes, originating_packet_data)\n\n    @classmethod\n    def Parameter_Problem(class_object, code, pointer, originating_packet_data = None):\n        pointer_bytes = struct.pack('!L', pointer)\n        return class_object.__build_error_message(ICMP6.PARAMETER_PROBLEM, code, pointer_bytes, originating_packet_data)\n    \n    @classmethod    \n    def __build_error_message(class_object, type, code, data, originating_packet_data):\n        #Build ICMP6 header\n        icmp_packet = ICMP6()\n        icmp_packet.set_type(type)\n        icmp_packet.set_code(code)\n        \n        #Pack ICMP payload\n        icmp_bytes = array_tobytes(array.array('B', data))\n        if (originating_packet_data is not None):\n            icmp_bytes += array_tobytes(array.array('B', originating_packet_data))\n        icmp_payload = Data()\n        icmp_payload.set_data(icmp_bytes)\n        \n        #Link payload to header\n        icmp_packet.contains(icmp_payload)\n        \n        return icmp_packet\n\n############################################################################\n\n    @classmethod\n    def Neighbor_Solicitation(class_object, target_address):\n        return class_object.__build_neighbor_message(ICMP6.NEIGHBOR_SOLICITATION, target_address)\n    \n    @classmethod\n    def Neighbor_Advertisement(class_object, target_address):\n        return class_object.__build_neighbor_message(ICMP6.NEIGHBOR_ADVERTISEMENT, target_address)\n\n    @classmethod\n    def __build_neighbor_message(class_object, msg_type, target_address):\n        #Build ICMP6 header\n        icmp_packet = ICMP6()\n        icmp_packet.set_type(msg_type)\n        icmp_packet.set_code(0)\n        \n        # Flags + Reserved\n        icmp_bytes = array_tobytes(array.array('B', [0x00] * 4))\n        \n        # Target Address: The IP address of the target of the solicitation.\n        # It MUST NOT be a multicast address.\n        icmp_bytes += array_tobytes(array.array('B', IP6_Address(target_address).as_bytes()))\n        \n        icmp_payload = Data()\n        icmp_payload.set_data(icmp_bytes)\n        \n        #Link payload to header\n        icmp_packet.contains(icmp_payload)\n        \n        return icmp_packet\n\n############################################################################\n\n    def get_target_address(self):\n        return IP6_Address(self.child().get_bytes()[4:20])\n\n    def set_target_address(self, target_address):\n        address = IP6_Address(target_address)\n        payload_bytes = self.child().get_bytes()\n        payload_bytes[4:20] = address.get_bytes()\n        self.child().set_bytes(payload_bytes)\n\n    #  0 1 2 3 4 5 6 7 \n    # +-+-+-+-+-+-+-+-+\n    # |R|S|O|reserved |\n    # +-+-+-+-+-+-+-+-+\n\n    def get_neighbor_advertisement_flags(self):\n        return self.child().get_byte(0)\n\n    def set_neighbor_advertisement_flags(self, flags):\n        self.child().set_byte(0, flags)\n\n    def get_router_flag(self):\n        return (self.get_neighbor_advertisement_flags() & 0x80) != 0\n    \n    def set_router_flag(self, flag_value):\n        curr_flags = self.get_neighbor_advertisement_flags()\n        if flag_value:\n            curr_flags |= 0x80\n        else:\n            curr_flags &= ~0x80\n        self.set_neighbor_advertisement_flags(curr_flags)\n    \n    def get_solicited_flag(self):\n        return (self.get_neighbor_advertisement_flags() & 0x40) != 0\n    \n    def set_solicited_flag(self, flag_value):\n        curr_flags = self.get_neighbor_advertisement_flags()\n        if flag_value:\n            curr_flags |= 0x40\n        else:\n            curr_flags &= ~0x40\n        self.set_neighbor_advertisement_flags(curr_flags)\n    \n    def get_override_flag(self):\n        return (self.get_neighbor_advertisement_flags() & 0x20) != 0\n    \n    def set_override_flag(self, flag_value):\n        curr_flags = self.get_neighbor_advertisement_flags()\n        if flag_value:\n            curr_flags |= 0x20\n        else:\n            curr_flags &= ~0x20\n        self.set_neighbor_advertisement_flags(curr_flags)\n\n############################################################################\n    @classmethod\n    def Node_Information_Query(class_object, code, payload = None):\n        return class_object.__build_node_information_message(ICMP6.NODE_INFORMATION_QUERY, code, payload)\n\n    @classmethod\n    def Node_Information_Reply(class_object, code, payload = None):\n        return class_object.__build_node_information_message(ICMP6.NODE_INFORMATION_REPLY, code, payload)\n        \n    @classmethod\n    def __build_node_information_message(class_object, type, code, payload = None):\n        #Build ICMP6 header\n        icmp_packet = ICMP6()\n        icmp_packet.set_type(type)\n        icmp_packet.set_code(code)\n        \n        #Pack ICMP payload\n        qtype = 0\n        flags = 0\n        nonce = [0x00] * 8\n        \n        icmp_bytes = struct.pack('>H', qtype)\n        icmp_bytes += struct.pack('>H', flags)\n        icmp_bytes += array_tobytes(array.array('B', nonce))\n        \n        if payload is not None:\n            icmp_bytes += array_tobytes(array.array('B', payload))\n        \n        icmp_payload = Data()\n        icmp_payload.set_data(icmp_bytes)\n        \n        #Link payload to header\n        icmp_packet.contains(icmp_payload)\n\n        return icmp_packet\n    \n    def get_qtype(self):\n        return self.child().get_word(0)\n\n    def set_qtype(self, qtype):\n        self.child().set_word(0, qtype)\n\n    def get_nonce(self):\n        return self.child().get_bytes()[4:12]\n\n    def set_nonce(self, nonce):\n        payload_bytes = self.child().get_bytes()\n        payload_bytes[4:12] = array.array('B', nonce)\n        self.child().set_bytes(payload_bytes)\n\n    #  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\n    # +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    # |      unused       |G|S|L|C|A|T|\n    # +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\n    def get_flags(self):\n        return self.child().get_word(2)\n\n    def set_flags(self, flags):\n        self.child().set_word(2, flags)\n\n    def get_flag_T(self):\n        return (self.get_flags() & 0x0001) != 0\n    \n    def set_flag_T(self, flag_value):\n        curr_flags = self.get_flags()\n        if flag_value:\n            curr_flags |= 0x0001\n        else:\n            curr_flags &= ~0x0001\n        self.set_flags(curr_flags)\n        \n    def get_flag_A(self):\n        return (self.get_flags() & 0x0002) != 0\n    \n    def set_flag_A(self, flag_value):\n        curr_flags = self.get_flags()\n        if flag_value:\n            curr_flags |= 0x0002\n        else:\n            curr_flags &= ~0x0002\n        self.set_flags(curr_flags)\n\n    def get_flag_C(self):\n        return (self.get_flags() & 0x0004) != 0\n    \n    def set_flag_C(self, flag_value):\n        curr_flags = self.get_flags()\n        if flag_value:\n            curr_flags |= 0x0004\n        else:\n            curr_flags &= ~0x0004\n        self.set_flags(curr_flags)\n\n    def get_flag_L(self):\n        return (self.get_flags() & 0x0008) != 0\n    \n    def set_flag_L(self, flag_value):\n        curr_flags = self.get_flags()\n        if flag_value:\n            curr_flags |= 0x0008\n        else:\n            curr_flags &= ~0x0008\n        self.set_flags(curr_flags)\n\n    def get_flag_S(self):\n        return (self.get_flags() & 0x0010) != 0\n    \n    def set_flag_S(self, flag_value):\n        curr_flags = self.get_flags()\n        if flag_value:\n            curr_flags |= 0x0010\n        else:\n            curr_flags &= ~0x0010\n        self.set_flags(curr_flags)\n\n    def get_flag_G(self):\n        return (self.get_flags() & 0x0020) != 0\n    \n    def set_flag_G(self, flag_value):\n        curr_flags = self.get_flags()\n        if flag_value:\n            curr_flags |= 0x0020\n        else:\n            curr_flags &= ~0x0020\n        self.set_flags(curr_flags)\n\n    def set_node_information_data(self, data):\n        payload_bytes = self.child().get_bytes()\n        payload_bytes[12:] = array.array('B', data)\n        self.child().set_bytes(payload_bytes)\n\n    def get_note_information_data(self):\n        return self.child().get_bytes()[12:]\n\n############################################################################\n    def get_echo_id(self):\n        return self.child().get_word(0)\n    \n    def get_echo_sequence_number(self):\n        return self.child().get_word(2)\n    \n    def get_echo_arbitrary_data(self):\n        return self.child().get_bytes()[4:]\n    \n    def get_mtu(self):\n        return self.child().get_long(0)\n        \n    def get_parm_problem_pointer(self):\n        return self.child().get_long(0)\n        \n    def get_originating_packet_data(self):\n        return self.child().get_bytes()[4:]",
  "def __init__(self, buffer = None):\n        Header.__init__(self, self.HEADER_SIZE)\n        if (buffer):\n            self.load_header(buffer)",
  "def get_header_size(self):\n        return self.HEADER_SIZE",
  "def get_ip_protocol_number(self):\n        return self.IP_PROTOCOL_NUMBER",
  "def __str__(self):        \n        type = self.get_type()\n        code = self.get_code()\n        checksum = self.get_checksum()\n\n        s = \"ICMP6 - Type: \" + str(type) + \" - \"  + self.__get_message_description() + \"\\n\"\n        s += \"Code: \" + str(code)\n        if (self.__get_code_description() != \"\"):\n            s += \" - \" + self.__get_code_description()\n        s += \"\\n\"\n        s += \"Checksum: \" + str(checksum) + \"\\n\"\n        return s",
  "def __get_message_description(self):\n        return self.icmp_messages[self.get_type()][self.DESCRIPTION_INDEX]",
  "def __get_code_description(self):\n        code_dictionary = self.icmp_messages[self.get_type()][self.CODES_INDEX]\n        if (code_dictionary is None):\n            return \"\"\n        else:\n            return code_dictionary[self.get_code()]",
  "def get_type(self):        \n        return (self.get_byte(0))",
  "def get_code(self):\n        return (self.get_byte(1))",
  "def get_checksum(self):\n        return (self.get_word(2))",
  "def set_type(self, type):\n        self.set_byte(0, type)",
  "def set_code(self, code):\n        self.set_byte(1, code)",
  "def set_checksum(self, checksum):\n        self.set_word(2, checksum)",
  "def calculate_checksum(self):        \n        #Initialize the checksum value to 0 to yield a correct calculation\n        self.set_checksum(0)        \n        #Fetch the pseudo header from the IP6 parent packet\n        pseudo_header = self.parent().get_pseudo_header()\n        #Fetch the ICMP data\n        icmp_header = self.get_bytes()\n        #Build an array of bytes concatenating the pseudo_header, the ICMP header and the ICMP data (if present)\n        checksum_array = array.array('B')\n        checksum_array.extend(pseudo_header)\n        checksum_array.extend(icmp_header)\n        if (self.child()):\n            checksum_array.extend(self.child().get_bytes())\n            \n        #Compute the checksum over that array\n        self.set_checksum(self.compute_checksum(checksum_array))",
  "def is_informational_message(self):\n        return self.icmp_messages[self.get_type()][self.MSG_TYPE_INDEX] == self.INFORMATIONAL_MESSAGE",
  "def is_error_message(self):\n        return self.icmp_messages[self.get_type()][self.MSG_TYPE_INDEX] == self.ERROR_MESSAGE",
  "def is_well_formed(self):\n        well_formed = True\n        \n        #Check that the message type is known\n        well_formed &= self.get_type() in self.icmp_messages.keys()\n        \n        #Check that the code is known (zero, if there are no codes defined)\n        code_dictionary = self.icmp_messages[self.get_type()][self.CODES_INDEX]\n        if (code_dictionary is None):\n            well_formed &= self.get_code() == 0\n        else:            \n            well_formed &= self.get_code() in code_dictionary.keys()\n            \n        return well_formed",
  "def Echo_Request(class_object, id, sequence_number, arbitrary_data = None):\n        return class_object.__build_echo_message(ICMP6.ECHO_REQUEST, id, sequence_number, arbitrary_data)",
  "def Echo_Reply(class_object, id, sequence_number, arbitrary_data = None):\n        return class_object.__build_echo_message(ICMP6.ECHO_REPLY, id, sequence_number, arbitrary_data)",
  "def __build_echo_message(class_object, type, id, sequence_number, arbitrary_data):\n        #Build ICMP6 header\n        icmp_packet = ICMP6()\n        icmp_packet.set_type(type)\n        icmp_packet.set_code(0)\n        \n        #Pack ICMP payload\n        icmp_bytes = struct.pack('>H', id)\n        icmp_bytes += struct.pack('>H', sequence_number)\n        if (arbitrary_data is not None):\n            icmp_bytes += array_tobytes(array.array('B', arbitrary_data))\n        icmp_payload = Data()\n        icmp_payload.set_data(icmp_bytes)\n        \n        #Link payload to header\n        icmp_packet.contains(icmp_payload)\n        \n        return icmp_packet",
  "def Destination_Unreachable(class_object, code, originating_packet_data = None):\n        unused_bytes = [0x00, 0x00, 0x00, 0x00]\n        return class_object.__build_error_message(ICMP6.DESTINATION_UNREACHABLE, code, unused_bytes, originating_packet_data)",
  "def Packet_Too_Big(class_object, MTU, originating_packet_data = None):\n        MTU_bytes = struct.pack('!L', MTU)\n        return class_object.__build_error_message(ICMP6.PACKET_TOO_BIG, 0, MTU_bytes, originating_packet_data)",
  "def Time_Exceeded(class_object, code, originating_packet_data = None):\n        unused_bytes = [0x00, 0x00, 0x00, 0x00]\n        return class_object.__build_error_message(ICMP6.TIME_EXCEEDED, code, unused_bytes, originating_packet_data)",
  "def Parameter_Problem(class_object, code, pointer, originating_packet_data = None):\n        pointer_bytes = struct.pack('!L', pointer)\n        return class_object.__build_error_message(ICMP6.PARAMETER_PROBLEM, code, pointer_bytes, originating_packet_data)",
  "def __build_error_message(class_object, type, code, data, originating_packet_data):\n        #Build ICMP6 header\n        icmp_packet = ICMP6()\n        icmp_packet.set_type(type)\n        icmp_packet.set_code(code)\n        \n        #Pack ICMP payload\n        icmp_bytes = array_tobytes(array.array('B', data))\n        if (originating_packet_data is not None):\n            icmp_bytes += array_tobytes(array.array('B', originating_packet_data))\n        icmp_payload = Data()\n        icmp_payload.set_data(icmp_bytes)\n        \n        #Link payload to header\n        icmp_packet.contains(icmp_payload)\n        \n        return icmp_packet",
  "def Neighbor_Solicitation(class_object, target_address):\n        return class_object.__build_neighbor_message(ICMP6.NEIGHBOR_SOLICITATION, target_address)",
  "def Neighbor_Advertisement(class_object, target_address):\n        return class_object.__build_neighbor_message(ICMP6.NEIGHBOR_ADVERTISEMENT, target_address)",
  "def __build_neighbor_message(class_object, msg_type, target_address):\n        #Build ICMP6 header\n        icmp_packet = ICMP6()\n        icmp_packet.set_type(msg_type)\n        icmp_packet.set_code(0)\n        \n        # Flags + Reserved\n        icmp_bytes = array_tobytes(array.array('B', [0x00] * 4))\n        \n        # Target Address: The IP address of the target of the solicitation.\n        # It MUST NOT be a multicast address.\n        icmp_bytes += array_tobytes(array.array('B', IP6_Address(target_address).as_bytes()))\n        \n        icmp_payload = Data()\n        icmp_payload.set_data(icmp_bytes)\n        \n        #Link payload to header\n        icmp_packet.contains(icmp_payload)\n        \n        return icmp_packet",
  "def get_target_address(self):\n        return IP6_Address(self.child().get_bytes()[4:20])",
  "def set_target_address(self, target_address):\n        address = IP6_Address(target_address)\n        payload_bytes = self.child().get_bytes()\n        payload_bytes[4:20] = address.get_bytes()\n        self.child().set_bytes(payload_bytes)",
  "def get_neighbor_advertisement_flags(self):\n        return self.child().get_byte(0)",
  "def set_neighbor_advertisement_flags(self, flags):\n        self.child().set_byte(0, flags)",
  "def get_router_flag(self):\n        return (self.get_neighbor_advertisement_flags() & 0x80) != 0",
  "def set_router_flag(self, flag_value):\n        curr_flags = self.get_neighbor_advertisement_flags()\n        if flag_value:\n            curr_flags |= 0x80\n        else:\n            curr_flags &= ~0x80\n        self.set_neighbor_advertisement_flags(curr_flags)",
  "def get_solicited_flag(self):\n        return (self.get_neighbor_advertisement_flags() & 0x40) != 0",
  "def set_solicited_flag(self, flag_value):\n        curr_flags = self.get_neighbor_advertisement_flags()\n        if flag_value:\n            curr_flags |= 0x40\n        else:\n            curr_flags &= ~0x40\n        self.set_neighbor_advertisement_flags(curr_flags)",
  "def get_override_flag(self):\n        return (self.get_neighbor_advertisement_flags() & 0x20) != 0",
  "def set_override_flag(self, flag_value):\n        curr_flags = self.get_neighbor_advertisement_flags()\n        if flag_value:\n            curr_flags |= 0x20\n        else:\n            curr_flags &= ~0x20\n        self.set_neighbor_advertisement_flags(curr_flags)",
  "def Node_Information_Query(class_object, code, payload = None):\n        return class_object.__build_node_information_message(ICMP6.NODE_INFORMATION_QUERY, code, payload)",
  "def Node_Information_Reply(class_object, code, payload = None):\n        return class_object.__build_node_information_message(ICMP6.NODE_INFORMATION_REPLY, code, payload)",
  "def __build_node_information_message(class_object, type, code, payload = None):\n        #Build ICMP6 header\n        icmp_packet = ICMP6()\n        icmp_packet.set_type(type)\n        icmp_packet.set_code(code)\n        \n        #Pack ICMP payload\n        qtype = 0\n        flags = 0\n        nonce = [0x00] * 8\n        \n        icmp_bytes = struct.pack('>H', qtype)\n        icmp_bytes += struct.pack('>H', flags)\n        icmp_bytes += array_tobytes(array.array('B', nonce))\n        \n        if payload is not None:\n            icmp_bytes += array_tobytes(array.array('B', payload))\n        \n        icmp_payload = Data()\n        icmp_payload.set_data(icmp_bytes)\n        \n        #Link payload to header\n        icmp_packet.contains(icmp_payload)\n\n        return icmp_packet",
  "def get_qtype(self):\n        return self.child().get_word(0)",
  "def set_qtype(self, qtype):\n        self.child().set_word(0, qtype)",
  "def get_nonce(self):\n        return self.child().get_bytes()[4:12]",
  "def set_nonce(self, nonce):\n        payload_bytes = self.child().get_bytes()\n        payload_bytes[4:12] = array.array('B', nonce)\n        self.child().set_bytes(payload_bytes)",
  "def get_flags(self):\n        return self.child().get_word(2)",
  "def set_flags(self, flags):\n        self.child().set_word(2, flags)",
  "def get_flag_T(self):\n        return (self.get_flags() & 0x0001) != 0",
  "def set_flag_T(self, flag_value):\n        curr_flags = self.get_flags()\n        if flag_value:\n            curr_flags |= 0x0001\n        else:\n            curr_flags &= ~0x0001\n        self.set_flags(curr_flags)",
  "def get_flag_A(self):\n        return (self.get_flags() & 0x0002) != 0",
  "def set_flag_A(self, flag_value):\n        curr_flags = self.get_flags()\n        if flag_value:\n            curr_flags |= 0x0002\n        else:\n            curr_flags &= ~0x0002\n        self.set_flags(curr_flags)",
  "def get_flag_C(self):\n        return (self.get_flags() & 0x0004) != 0",
  "def set_flag_C(self, flag_value):\n        curr_flags = self.get_flags()\n        if flag_value:\n            curr_flags |= 0x0004\n        else:\n            curr_flags &= ~0x0004\n        self.set_flags(curr_flags)",
  "def get_flag_L(self):\n        return (self.get_flags() & 0x0008) != 0",
  "def set_flag_L(self, flag_value):\n        curr_flags = self.get_flags()\n        if flag_value:\n            curr_flags |= 0x0008\n        else:\n            curr_flags &= ~0x0008\n        self.set_flags(curr_flags)",
  "def get_flag_S(self):\n        return (self.get_flags() & 0x0010) != 0",
  "def set_flag_S(self, flag_value):\n        curr_flags = self.get_flags()\n        if flag_value:\n            curr_flags |= 0x0010\n        else:\n            curr_flags &= ~0x0010\n        self.set_flags(curr_flags)",
  "def get_flag_G(self):\n        return (self.get_flags() & 0x0020) != 0",
  "def set_flag_G(self, flag_value):\n        curr_flags = self.get_flags()\n        if flag_value:\n            curr_flags |= 0x0020\n        else:\n            curr_flags &= ~0x0020\n        self.set_flags(curr_flags)",
  "def set_node_information_data(self, data):\n        payload_bytes = self.child().get_bytes()\n        payload_bytes[12:] = array.array('B', data)\n        self.child().set_bytes(payload_bytes)",
  "def get_note_information_data(self):\n        return self.child().get_bytes()[12:]",
  "def get_echo_id(self):\n        return self.child().get_word(0)",
  "def get_echo_sequence_number(self):\n        return self.child().get_word(2)",
  "def get_echo_arbitrary_data(self):\n        return self.child().get_bytes()[4:]",
  "def get_mtu(self):\n        return self.child().get_long(0)",
  "def get_parm_problem_pointer(self):\n        return self.child().get_long(0)",
  "def get_originating_packet_data(self):\n        return self.child().get_bytes()[4:]",
  "class CDPTypes:\n\n    DeviceID_Type       = 1\n    Address_Type        = 2\n    PortID_Type         = 3\n    Capabilities_Type   = 4\n    SoftVersion_Type    = 5\n    Platform_Type       = 6\n    IPPrefix_Type       = 7\n    ProtocolHello_Type  = 8\n    MTU_Type            = 17\n    SystemName_Type     = 20\n    SystemObjectId_Type = 21\n    SnmpLocation        = 23",
  "class CDP(Header):\n    \n    Type = 0x2000\n    OUI =  0x00000c\n    \n    def __init__(self, aBuffer = None):\n        Header.__init__(self, 8)\n        if aBuffer:\n            self.load_header(aBuffer)\n            self._elements = self._getElements(aBuffer)\n\n    def _getElements(self, aBuffer):\n        # Remove version (1 byte), TTL (1 byte), and checksum (2 bytes)\n        buff = aBuffer[4:]\n        l = []\n        while buff:\n            elem = CDPElementFactory.create(buff)\n            l.append( elem )\n            buff = buff[ elem.get_length() : ]\n        return l\n\n    def get_header_size(self):\n        return 8\n        \n    def get_version(self):\n        return self.get_byte(0)\n        \n    def get_ttl(self):\n        return self.get_byte(1)\n        \n    def get_checksum(self):\n        return self.get_word(2)\n\n    def get_type(self):\n        return self.get_word(4)\n        \n    def get_lenght(self):      \n        return self.get_word(6)\n\n    def getElements(self):\n        return self._elements\n\n\n    def __str__(self):\n        tmp_str = 'CDP Details:\\n'\n        for element in self._elements:\n            tmp_str += \"** Type:\" + str(element.get_type()) + \" \" + str(element) + \"\\n\"\n        return tmp_str",
  "def get_byte(buffer, offset):\n    return unpack(\"!B\", buffer[offset:offset+1])[0]",
  "def get_word(buffer, offset):\n    return unpack(\"!h\", buffer[offset:offset+2])[0]",
  "def get_long(buffer, offset):\n    return unpack(\"!I\", buffer[offset:offset+4])[0]",
  "def get_bytes(buffer, offset, bytes):\n    return buffer[offset:offset + bytes]",
  "def mac_to_string(mac_bytes):\n    bytes = unpack('!BBBBBB', mac_bytes)\n    s = ''\n    for byte in bytes:\n        s += '%02x:' % byte\n    return s[0:-1]",
  "class CDPElement(Header):\n\n    def __init__(self, aBuffer = None):\n        Header.__init__(self, 8)\n        if aBuffer:\n            self._length = CDPElement.Get_length(aBuffer)\n            self.load_header( aBuffer[:self._length] )\n\n    @classmethod\n    def Get_length(cls, aBuffer):\n        return unpack('!h', aBuffer[2:4])[0]\n\n    def get_header_size(self):\n        self._length\n\n    def get_length(self):\n        return self.get_word(2)\n                \n    def get_data(self):        \n        return array_tobytes(self.get_bytes())[4:self.get_length()]\n\n    def get_ip_address(self, offset = 0, ip = None):\n        if not ip:\n            ip = array_tobytes(self.get_bytes())[offset : offset + IP_ADDRESS_LENGTH]\n        return socket.inet_ntoa( ip )",
  "class CDPDevice(CDPElement):\n    Type = 1\n    \n    def get_type(self):\n        return CDPDevice.Type\n    \n    def get_device_id(self):\n        return CDPElement.get_data(self)\n\n    def __str__(self):\n        return \"Device:\" + self.get_device_id()",
  "class Address(CDPElement):\n    Type = 2\n   \n    def __init__(self, aBuffer = None):\n        CDPElement.__init__(self, aBuffer)\n        if aBuffer:\n            data = array_tobytes(self.get_bytes())[8:]\n            self._generateAddressDetails(data)\n\n    def _generateAddressDetails(self, buff):\n        self.address_details = []\n        while buff:\n            address = AddressDetails.create(buff)\n            self.address_details.append( address )\n            buff = buff[address.get_total_length():]\n\n    def get_type(self):\n        return Address.Type\n    \n    def get_number(self):\n        return self.get_long(4)\n       \n    def get_address_details(self):\n        return self.address_details\n        \n    def __str__(self):\n        tmp_str = \"Addresses:\"\n        for address_detail in self.address_details:\n            tmp_str += \"\\n\" + str(address_detail)\n        return tmp_str",
  "class AddressDetails():        \n          \n    PROTOCOL_IP = 0xcc          \n          \n    @classmethod\n    def create(cls, buff):\n        a = AddressDetails(buff)\n        return a\n\n\n    def __init__(self, aBuffer = None):\n        if aBuffer:\n            addr_length = unpack(\"!h\", aBuffer[3:5])[0]\n            self.total_length = addr_length + 5\n            self.buffer = aBuffer[:self.total_length]\n    \n    def get_total_length(self):\n        return self.total_length\n        \n    def get_protocol_type(self):\n        return self.buffer[0:1]\n        \n    def get_protocol_length(self):\n        return get_byte( self.buffer, 1)\n\n    def get_protocol(self):\n        return get_byte( self.buffer, 2)\n        \n    def get_address_length(self):\n        return get_word( self.buffer, 3)\n        \n    def get_address(self):\n        address =  get_bytes( self.buffer, 5, self.get_address_length() )\n        if  self.get_protocol()==AddressDetails.PROTOCOL_IP:\n            return socket.inet_ntoa(address)\n        else:\n            LOG.error(\"Address not IP\")\n            return address            \n            \n    def is_protocol_IP(self):\n        return self.get_protocol()==AddressDetails.PROTOCOL_IP\n            \n    def __str__(self):\n        return \"Protocol Type:%r Protocol:%r Address Length:%r Address:%s\" % (self.get_protocol_type(), self.get_protocol(), self.get_address_length(), self.get_address())",
  "class Port(CDPElement):\n    Type = 3\n    \n    def get_type(self):\n        return Port.Type\n    \n    def get_port(self):\n        return CDPElement.get_data(self)                \n\n    def __str__(self):\n        return \"Port:\" + self.get_port()",
  "class Capabilities(CDPElement):\n    Type = 4\n    \n    def __init__(self, aBuffer = None):\n        CDPElement.__init__(self, aBuffer)\n        self._capabilities_processed = False\n        \n        self._router = False\n        self._transparent_bridge = False\n        self._source_route_bridge = False\n        self._switch = False\n        self._host = False\n        self._igmp_capable = False\n        self._repeater = False\n        self._init_capabilities()\n        \n    def get_type(self):\n        return Capabilities.Type\n    \n    def get_capabilities(self):\n        return CDPElement.get_data(self)  \n        \n    def _init_capabilities(self):\n        if self._capabilities_processed:\n            return\n        \n        capabilities = unpack(\"!L\", self.get_capabilities())[0]\n        self._router = (capabilities & 0x1) > 0\n        self._transparent_bridge = (capabilities & 0x02) > 0\n        self._source_route_bridge = (capabilities & 0x04) > 0\n        self._switch = (capabilities & 0x08) > 0\n        self._host = (capabilities & 0x10) > 0\n        self._igmp_capable = (capabilities & 0x20) > 0\n        self._repeater = (capabilities & 0x40) > 0\n\n    def is_router(self):\n        return self._router\n\n    def is_transparent_bridge(self):\n        return self._transparent_bridge\n\n    def is_source_route_bridge(self):\n        return self._source_route_bridge\n        \n    def is_switch(self):\n        return self._switch\n\n    def is_host(self):\n        return self.is_host\n\n    def is_igmp_capable(self):\n        return self._igmp_capable\n        \n    def is_repeater(self):\n        return self._repeater\n\n                 \n    def __str__(self):\n        return \"Capabilities:\" + self.get_capabilities()",
  "class SoftVersion(CDPElement):\n    Type = 5\n    \n    def get_type(self):\n        return SoftVersion.Type\n    \n    def get_version(self):\n        return CDPElement.get_data(self)\n\n    def __str__(self):\n        return \"Version:\" + self.get_version()",
  "class Platform(CDPElement):\n    Type = 6\n    \n    def get_type(self):\n        return Platform.Type\n    \n    def get_platform(self):\n        return CDPElement.get_data(self)                \n\n    def __str__(self):\n        return \"Platform:%r\" % self.get_platform()",
  "class IpPrefix(CDPElement):\n    Type = 7\n    \n    def get_type(self):\n        return IpPrefix .Type\n    \n    def get_ip_prefix(self):\n        return CDPElement.get_ip_address(self, 4)                \n\n    def get_bits(self):\n        return self.get_byte(8)        \n        \n    def __str__(self):\n        return \"IP Prefix/Gateway: %r/%d\" % (self.get_ip_prefix(), self.get_bits())",
  "class ProtocolHello(CDPElement):\n    Type = 8\n    \n    def get_type(self):\n        return ProtocolHello.Type\n\n    def get_master_ip(self):\n        return self.get_ip_address(9)\n\n    def get_version(self):\n        return self.get_byte(17)\n\n    def get_sub_version(self):\n        return self.get_byte(18)\n\n    def get_status(self):\n        return self.get_byte(19)\n\n    def get_cluster_command_mac(self):\n        return array_tobytes(self.get_bytes())[20:20+6]\n            \n    def get_switch_mac(self):\n        return array_tobytes(self.get_bytes())[28:28+6]\n            \n    def get_management_vlan(self):\n        return self.get_word(36)\n\n    def __str__(self):\n        return \"\\n\\n\\nProcolHello: Master IP:%s version:%r subversion:%r status:%r Switch's Mac:%r Management VLAN:%r\" \\\n         % (self.get_master_ip(), self.get_version(), self.get_sub_version(), self.get_status(), mac_to_string(self.get_switch_mac()), self.get_management_vlan())",
  "class VTPManagementDomain(CDPElement):\n    Type = 9\n    \n    def get_type(self):\n        return VTPManagementDomain.Type\n    \n    def get_domain(self):\n        return CDPElement.get_data(self)",
  "class Duplex(CDPElement):\n    Type = 0xb\n    \n    def get_type(self):\n        return Duplex.Type\n    \n    def get_duplex(self):\n        return CDPElement.get_data(self)                \n                \n    def is_full_duplex(self):\n        return self.get_duplex()==0x1",
  "class VLAN(CDPElement):\n    Type = 0xa\n                \n    def get_type(self):\n        return VLAN.Type\n        \n    def get_vlan_number(self):\n        return CDPElement.get_data(self)",
  "class TrustBitmap(CDPElement):\n    Type = 0x12\n    \n    def get_type(self):\n        return TrustBitmap.Type\n\n    def get_trust_bitmap(self):\n        return self.get_data()\n\n    def __str__(self):\n        return \"TrustBitmap Trust Bitmap:%r\" % self.get_trust_bitmap()",
  "class UntrustedPortCoS(CDPElement):\n    Type = 0x13\n    \n    def get_type(self):\n        return UntrustedPortCoS.Type\n\n    def get_port_CoS(self):\n        return self.get_data()\n\n    def __str__(self):\n        return \"UntrustedPortCoS port CoS %r\" % self.get_port_CoS()",
  "class ManagementAddresses(Address):\n    Type = 0x16\n    \n    def get_type(self):\n        return ManagementAddresses.Type",
  "class MTU(CDPElement):\n    Type = 0x11\n    \n    def get_type(self):\n        return MTU.Type",
  "class SystemName(CDPElement):\n    Type = 0x14\n    \n    def get_type(self):\n        return SystemName.Type",
  "class SystemObjectId(CDPElement):\n    Type = 0x15\n    \n    def get_type(self):\n        return SystemObjectId.Type",
  "class SnmpLocation(CDPElement):\n    Type = 0x17\n    \n    def get_type(self):\n        return SnmpLocation.Type",
  "class DummyCdpElement(CDPElement):\n    Type = 0x99\n\n    def get_type(self):\n        return DummyCdpElement.Type",
  "class CDPElementFactory():\n    \n    elementTypeMap = {\n                        CDPDevice.Type            : CDPDevice, \n                        Port.Type                 : Port,\n                        Capabilities.Type         : Capabilities,\n                        Address.Type              : Address, \n                        SoftVersion.Type          : SoftVersion,\n                        Platform.Type             : Platform,\n                        IpPrefix.Type             : IpPrefix,\n                        ProtocolHello.Type        : ProtocolHello,\n                        VTPManagementDomain.Type  : VTPManagementDomain,\n                        VLAN.Type                 : VLAN,\n                        Duplex.Type               : Duplex,\n                        TrustBitmap.Type          : TrustBitmap,\n                        UntrustedPortCoS.Type     : UntrustedPortCoS,\n                        ManagementAddresses.Type  : ManagementAddresses,\n                        MTU.Type                  : MTU,\n                        SystemName.Type           : SystemName,\n                        SystemObjectId.Type       : SystemObjectId,\n                        SnmpLocation.Type         : SnmpLocation\n                     }\n    \n    @classmethod\n    def create(cls, aBuffer):\n#        print \"CDPElementFactory.create aBuffer:\", repr(aBuffer)\n#        print \"CDPElementFactory.create sub_type:\", repr(aBuffer[0:2])\n        _type = unpack(\"!h\", aBuffer[0:2])[0]\n#        print \"CDPElementFactory.create _type:\", _type\n        try:\n            class_type = cls.elementTypeMap[_type]\n        except KeyError:\n            class_type = DummyCdpElement\n            #raise Exception(\"CDP Element type %s not implemented\" % _type)\n        return class_type( aBuffer )",
  "def __init__(self, aBuffer = None):\n        Header.__init__(self, 8)\n        if aBuffer:\n            self.load_header(aBuffer)\n            self._elements = self._getElements(aBuffer)",
  "def _getElements(self, aBuffer):\n        # Remove version (1 byte), TTL (1 byte), and checksum (2 bytes)\n        buff = aBuffer[4:]\n        l = []\n        while buff:\n            elem = CDPElementFactory.create(buff)\n            l.append( elem )\n            buff = buff[ elem.get_length() : ]\n        return l",
  "def get_header_size(self):\n        return 8",
  "def get_version(self):\n        return self.get_byte(0)",
  "def get_ttl(self):\n        return self.get_byte(1)",
  "def get_checksum(self):\n        return self.get_word(2)",
  "def get_type(self):\n        return self.get_word(4)",
  "def get_lenght(self):      \n        return self.get_word(6)",
  "def getElements(self):\n        return self._elements",
  "def __str__(self):\n        tmp_str = 'CDP Details:\\n'\n        for element in self._elements:\n            tmp_str += \"** Type:\" + str(element.get_type()) + \" \" + str(element) + \"\\n\"\n        return tmp_str",
  "def __init__(self, aBuffer = None):\n        Header.__init__(self, 8)\n        if aBuffer:\n            self._length = CDPElement.Get_length(aBuffer)\n            self.load_header( aBuffer[:self._length] )",
  "def Get_length(cls, aBuffer):\n        return unpack('!h', aBuffer[2:4])[0]",
  "def get_header_size(self):\n        self._length",
  "def get_length(self):\n        return self.get_word(2)",
  "def get_data(self):        \n        return array_tobytes(self.get_bytes())[4:self.get_length()]",
  "def get_ip_address(self, offset = 0, ip = None):\n        if not ip:\n            ip = array_tobytes(self.get_bytes())[offset : offset + IP_ADDRESS_LENGTH]\n        return socket.inet_ntoa( ip )",
  "def get_type(self):\n        return CDPDevice.Type",
  "def get_device_id(self):\n        return CDPElement.get_data(self)",
  "def __str__(self):\n        return \"Device:\" + self.get_device_id()",
  "def __init__(self, aBuffer = None):\n        CDPElement.__init__(self, aBuffer)\n        if aBuffer:\n            data = array_tobytes(self.get_bytes())[8:]\n            self._generateAddressDetails(data)",
  "def _generateAddressDetails(self, buff):\n        self.address_details = []\n        while buff:\n            address = AddressDetails.create(buff)\n            self.address_details.append( address )\n            buff = buff[address.get_total_length():]",
  "def get_type(self):\n        return Address.Type",
  "def get_number(self):\n        return self.get_long(4)",
  "def get_address_details(self):\n        return self.address_details",
  "def __str__(self):\n        tmp_str = \"Addresses:\"\n        for address_detail in self.address_details:\n            tmp_str += \"\\n\" + str(address_detail)\n        return tmp_str",
  "def create(cls, buff):\n        a = AddressDetails(buff)\n        return a",
  "def __init__(self, aBuffer = None):\n        if aBuffer:\n            addr_length = unpack(\"!h\", aBuffer[3:5])[0]\n            self.total_length = addr_length + 5\n            self.buffer = aBuffer[:self.total_length]",
  "def get_total_length(self):\n        return self.total_length",
  "def get_protocol_type(self):\n        return self.buffer[0:1]",
  "def get_protocol_length(self):\n        return get_byte( self.buffer, 1)",
  "def get_protocol(self):\n        return get_byte( self.buffer, 2)",
  "def get_address_length(self):\n        return get_word( self.buffer, 3)",
  "def get_address(self):\n        address =  get_bytes( self.buffer, 5, self.get_address_length() )\n        if  self.get_protocol()==AddressDetails.PROTOCOL_IP:\n            return socket.inet_ntoa(address)\n        else:\n            LOG.error(\"Address not IP\")\n            return address",
  "def is_protocol_IP(self):\n        return self.get_protocol()==AddressDetails.PROTOCOL_IP",
  "def __str__(self):\n        return \"Protocol Type:%r Protocol:%r Address Length:%r Address:%s\" % (self.get_protocol_type(), self.get_protocol(), self.get_address_length(), self.get_address())",
  "def get_type(self):\n        return Port.Type",
  "def get_port(self):\n        return CDPElement.get_data(self)",
  "def __str__(self):\n        return \"Port:\" + self.get_port()",
  "def __init__(self, aBuffer = None):\n        CDPElement.__init__(self, aBuffer)\n        self._capabilities_processed = False\n        \n        self._router = False\n        self._transparent_bridge = False\n        self._source_route_bridge = False\n        self._switch = False\n        self._host = False\n        self._igmp_capable = False\n        self._repeater = False\n        self._init_capabilities()",
  "def get_type(self):\n        return Capabilities.Type",
  "def get_capabilities(self):\n        return CDPElement.get_data(self)",
  "def _init_capabilities(self):\n        if self._capabilities_processed:\n            return\n        \n        capabilities = unpack(\"!L\", self.get_capabilities())[0]\n        self._router = (capabilities & 0x1) > 0\n        self._transparent_bridge = (capabilities & 0x02) > 0\n        self._source_route_bridge = (capabilities & 0x04) > 0\n        self._switch = (capabilities & 0x08) > 0\n        self._host = (capabilities & 0x10) > 0\n        self._igmp_capable = (capabilities & 0x20) > 0\n        self._repeater = (capabilities & 0x40) > 0",
  "def is_router(self):\n        return self._router",
  "def is_transparent_bridge(self):\n        return self._transparent_bridge",
  "def is_source_route_bridge(self):\n        return self._source_route_bridge",
  "def is_switch(self):\n        return self._switch",
  "def is_host(self):\n        return self.is_host",
  "def is_igmp_capable(self):\n        return self._igmp_capable",
  "def is_repeater(self):\n        return self._repeater",
  "def __str__(self):\n        return \"Capabilities:\" + self.get_capabilities()",
  "def get_type(self):\n        return SoftVersion.Type",
  "def get_version(self):\n        return CDPElement.get_data(self)",
  "def __str__(self):\n        return \"Version:\" + self.get_version()",
  "def get_type(self):\n        return Platform.Type",
  "def get_platform(self):\n        return CDPElement.get_data(self)",
  "def __str__(self):\n        return \"Platform:%r\" % self.get_platform()",
  "def get_type(self):\n        return IpPrefix .Type",
  "def get_ip_prefix(self):\n        return CDPElement.get_ip_address(self, 4)",
  "def get_bits(self):\n        return self.get_byte(8)",
  "def __str__(self):\n        return \"IP Prefix/Gateway: %r/%d\" % (self.get_ip_prefix(), self.get_bits())",
  "def get_type(self):\n        return ProtocolHello.Type",
  "def get_master_ip(self):\n        return self.get_ip_address(9)",
  "def get_version(self):\n        return self.get_byte(17)",
  "def get_sub_version(self):\n        return self.get_byte(18)",
  "def get_status(self):\n        return self.get_byte(19)",
  "def get_cluster_command_mac(self):\n        return array_tobytes(self.get_bytes())[20:20+6]",
  "def get_switch_mac(self):\n        return array_tobytes(self.get_bytes())[28:28+6]",
  "def get_management_vlan(self):\n        return self.get_word(36)",
  "def __str__(self):\n        return \"\\n\\n\\nProcolHello: Master IP:%s version:%r subversion:%r status:%r Switch's Mac:%r Management VLAN:%r\" \\\n         % (self.get_master_ip(), self.get_version(), self.get_sub_version(), self.get_status(), mac_to_string(self.get_switch_mac()), self.get_management_vlan())",
  "def get_type(self):\n        return VTPManagementDomain.Type",
  "def get_domain(self):\n        return CDPElement.get_data(self)",
  "def get_type(self):\n        return Duplex.Type",
  "def get_duplex(self):\n        return CDPElement.get_data(self)",
  "def is_full_duplex(self):\n        return self.get_duplex()==0x1",
  "def get_type(self):\n        return VLAN.Type",
  "def get_vlan_number(self):\n        return CDPElement.get_data(self)",
  "def get_type(self):\n        return TrustBitmap.Type",
  "def get_trust_bitmap(self):\n        return self.get_data()",
  "def __str__(self):\n        return \"TrustBitmap Trust Bitmap:%r\" % self.get_trust_bitmap()",
  "def get_type(self):\n        return UntrustedPortCoS.Type",
  "def get_port_CoS(self):\n        return self.get_data()",
  "def __str__(self):\n        return \"UntrustedPortCoS port CoS %r\" % self.get_port_CoS()",
  "def get_type(self):\n        return ManagementAddresses.Type",
  "def get_type(self):\n        return MTU.Type",
  "def get_type(self):\n        return SystemName.Type",
  "def get_type(self):\n        return SystemObjectId.Type",
  "def get_type(self):\n        return SnmpLocation.Type",
  "def get_type(self):\n        return DummyCdpElement.Type",
  "def create(cls, aBuffer):\n#        print \"CDPElementFactory.create aBuffer:\", repr(aBuffer)\n#        print \"CDPElementFactory.create sub_type:\", repr(aBuffer[0:2])\n        _type = unpack(\"!h\", aBuffer[0:2])[0]\n#        print \"CDPElementFactory.create _type:\", _type\n        try:\n            class_type = cls.elementTypeMap[_type]\n        except KeyError:\n            class_type = DummyCdpElement\n            #raise Exception(\"CDP Element type %s not implemented\" % _type)\n        return class_type( aBuffer )",
  "class Structure:\n    \"\"\" sublcasses can define commonHdr and/or structure.\n        each of them is an tuple of either two: (fieldName, format) or three: (fieldName, ':', class) fields.\n        [it can't be a dictionary, because order is important]\n        \n        where format specifies how the data in the field will be converted to/from bytes (string)\n        class is the class to use when unpacking ':' fields.\n\n        each field can only contain one value (or an array of values for *)\n           i.e. struct.pack('Hl',1,2) is valid, but format specifier 'Hl' is not (you must use 2 dfferent fields)\n\n        format specifiers:\n          specifiers from module pack can be used with the same format \n          see struct.__doc__ (pack/unpack is finally called)\n            x       [padding byte]\n            c       [character]\n            b       [signed byte]\n            B       [unsigned byte]\n            h       [signed short]\n            H       [unsigned short]\n            l       [signed long]\n            L       [unsigned long]\n            i       [signed integer]\n            I       [unsigned integer]\n            q       [signed long long (quad)]\n            Q       [unsigned long long (quad)]\n            s       [string (array of chars), must be preceded with length in format specifier, padded with zeros]\n            p       [pascal string (includes byte count), must be preceded with length in format specifier, padded with zeros]\n            f       [float]\n            d       [double]\n            =       [native byte ordering, size and alignment]\n            @       [native byte ordering, standard size and alignment]\n            !       [network byte ordering]\n            <       [little endian]\n            >       [big endian]\n\n          usual printf like specifiers can be used (if started with %) \n          [not recommended, there is no way to unpack this]\n\n            %08x    will output an 8 bytes hex\n            %s      will output a string\n            %s\\\\x00  will output a NUL terminated string\n            %d%d    will output 2 decimal digits (against the very same specification of Structure)\n            ...\n\n          some additional format specifiers:\n            :       just copy the bytes from the field into the output string (input may be string, other structure, or anything responding to __str__()) (for unpacking, all what's left is returned)\n            z       same as :, but adds a NUL byte at the end (asciiz) (for unpacking the first NUL byte is used as terminator)  [asciiz string]\n            u       same as z, but adds two NUL bytes at the end (after padding to an even size with NULs). (same for unpacking) [unicode string]\n            w       DCE-RPC/NDR string (it's a macro for [  '<L=(len(field)+1)/2','\"\\\\x00\\\\x00\\\\x00\\\\x00','<L=(len(field)+1)/2',':' ]\n            ?-field length of field named 'field', formatted as specified with ? ('?' may be '!H' for example). The input value overrides the real length\n            ?1*?2   array of elements. Each formatted as '?2', the number of elements in the array is stored as specified by '?1' (?1 is optional, or can also be a constant (number), for unpacking)\n            'xxxx   literal xxxx (field's value doesn't change the output. quotes must not be closed or escaped)\n            \"xxxx   literal xxxx (field's value doesn't change the output. quotes must not be closed or escaped)\n            _       will not pack the field. Accepts a third argument, which is an unpack code. See _Test_UnpackCode for an example\n            ?=packcode  will evaluate packcode in the context of the structure, and pack the result as specified by ?. Unpacking is made plain\n            ?&fieldname \"Address of field fieldname\".\n                        For packing it will simply pack the id() of fieldname. Or use 0 if fieldname doesn't exists.\n                        For unpacking, it's used to know weather fieldname has to be unpacked or not, i.e. by adding a & field you turn another field (fieldname) in an optional field.\n            \n    \"\"\"\n    commonHdr = ()\n    structure = ()\n    debug = 0\n\n    def __init__(self, data = None, alignment = 0):\n        if not hasattr(self, 'alignment'):\n            self.alignment = alignment\n\n        self.fields    = {}\n        self.rawData   = data\n        if data is not None:\n            self.fromString(data)\n        else:\n            self.data = None\n\n    @classmethod\n    def fromFile(self, file):\n        answer = self()\n        answer.fromString(file.read(len(answer)))\n        return answer\n\n    def setAlignment(self, alignment):\n        self.alignment = alignment\n\n    def setData(self, data):\n        self.data = data\n\n    def packField(self, fieldName, format = None):\n        if self.debug:\n            print(\"packField( %s | %s )\" % (fieldName, format))\n\n        if format is None:\n            format = self.formatForField(fieldName)\n\n        if fieldName in self.fields:\n            ans = self.pack(format, self.fields[fieldName], field = fieldName)\n        else:\n            ans = self.pack(format, None, field = fieldName)\n\n        if self.debug:\n            print(\"\\tanswer %r\" % ans)\n\n        return ans\n\n    def getData(self):\n        if self.data is not None:\n            return self.data\n        data = bytes()\n        for field in self.commonHdr+self.structure:\n            try:\n                data += self.packField(field[0], field[1])\n            except Exception as e:\n                if field[0] in self.fields:\n                    e.args += (\"When packing field '%s | %s | %r' in %s\" % (field[0], field[1], self[field[0]], self.__class__),)\n                else:\n                    e.args += (\"When packing field '%s | %s' in %s\" % (field[0], field[1], self.__class__),)\n                raise\n            if self.alignment:\n                if len(data) % self.alignment:\n                    data += (b'\\x00'*self.alignment)[:-(len(data) % self.alignment)]\n            \n        #if len(data) % self.alignment: data += ('\\x00'*self.alignment)[:-(len(data) % self.alignment)]\n        return data\n\n    def fromString(self, data):\n        self.rawData = data\n        for field in self.commonHdr+self.structure:\n            if self.debug:\n                print(\"fromString( %s | %s | %r )\" % (field[0], field[1], data))\n            size = self.calcUnpackSize(field[1], data, field[0])\n            if self.debug:\n                print(\"  size = %d\" % size)\n            dataClassOrCode = b\n            if len(field) > 2:\n                dataClassOrCode = field[2]\n            try:\n                self[field[0]] = self.unpack(field[1], data[:size], dataClassOrCode = dataClassOrCode, field = field[0])\n            except Exception as e:\n                e.args += (\"When unpacking field '%s | %s | %r[:%d]'\" % (field[0], field[1], data, size),)\n                raise\n\n            size = self.calcPackSize(field[1], self[field[0]], field[0])\n            if self.alignment and size % self.alignment:\n                size += self.alignment - (size % self.alignment)\n            data = data[size:]\n\n        return self\n        \n    def __setitem__(self, key, value):\n        self.fields[key] = value\n        self.data = None        # force recompute\n\n    def __getitem__(self, key):\n        return self.fields[key]\n\n    def __delitem__(self, key):\n        del self.fields[key]\n        \n    def __str__(self):\n        return self.getData()\n\n    def __len__(self):\n        # XXX: improve\n        return len(self.getData())\n\n    def pack(self, format, data, field = None):\n        if self.debug:\n            print(\"  pack( %s | %r | %s)\" %  (format, data, field))\n\n        if field:\n            addressField = self.findAddressFieldFor(field)\n            if (addressField is not None) and (data is None):\n                return b''\n\n        # void specifier\n        if format[:1] == '_':\n            return b''\n\n        # quote specifier\n        if format[:1] == \"'\" or format[:1] == '\"':\n            return b(format[1:])\n\n        # code specifier\n        two = format.split('=')\n        if len(two) >= 2:\n            try:\n                return self.pack(two[0], data)\n            except:\n                fields = {'self':self}\n                fields.update(self.fields)\n                return self.pack(two[0], eval(two[1], {}, fields))\n\n        # address specifier\n        two = format.split('&')\n        if len(two) == 2:\n            try:\n                return self.pack(two[0], data)\n            except:\n                if (two[1] in self.fields) and (self[two[1]] is not None):\n                    return self.pack(two[0], id(self[two[1]]) & ((1<<(calcsize(two[0])*8))-1) )\n                else:\n                    return self.pack(two[0], 0)\n\n        # length specifier\n        two = format.split('-')\n        if len(two) == 2:\n            try:\n                return self.pack(two[0],data)\n            except:\n                return self.pack(two[0], self.calcPackFieldSize(two[1]))\n\n        # array specifier\n        two = format.split('*')\n        if len(two) == 2:\n            answer = bytes()\n            for each in data:\n                answer += self.pack(two[1], each)\n            if two[0]:\n                if two[0].isdigit():\n                    if int(two[0]) != len(data):\n                        raise Exception(\"Array field has a constant size, and it doesn't match the actual value\")\n                else:\n                    return self.pack(two[0], len(data))+answer\n            return answer\n\n        # \"printf\" string specifier\n        if format[:1] == '%':\n            # format string like specifier\n            return b(format % data)\n\n        # asciiz specifier\n        if format[:1] == 'z':\n            if isinstance(data,bytes):\n                return data + b('\\0')\n            return bytes(b(data)+b('\\0'))\n\n        # unicode specifier\n        if format[:1] == 'u':\n            return bytes(data+b('\\0\\0') + (len(data) & 1 and b('\\0') or b''))\n\n        # DCE-RPC/NDR string specifier\n        if format[:1] == 'w':\n            if len(data) == 0:\n                data = b('\\0\\0')\n            elif len(data) % 2:\n                data = b(data) + b('\\0')\n            l = pack('<L', len(data)//2)\n            return b''.join([l, l, b('\\0\\0\\0\\0'), data])\n\n        if data is None:\n            raise Exception(\"Trying to pack None\")\n        \n        # literal specifier\n        if format[:1] == ':':\n            if isinstance(data, Structure):\n                return data.getData()\n            # If we have an object that can serialize itself, go ahead\n            elif hasattr(data, \"getData\"):\n                return data.getData()\n            elif isinstance(data, int):\n                return bytes(data)\n            elif isinstance(data, bytes) is not True:\n                return bytes(b(data))\n            else:\n                return data\n\n        if format[-1:] == 's':\n            # Let's be sure we send the right type\n            if isinstance(data, bytes) or isinstance(data, bytearray):\n                return pack(format, data)\n            else:\n                return pack(format, b(data))\n\n        # struct like specifier\n        return pack(format, data)\n\n    def unpack(self, format, data, dataClassOrCode = b, field = None):\n        if self.debug:\n            print(\"  unpack( %s | %r )\" %  (format, data))\n\n        if field:\n            addressField = self.findAddressFieldFor(field)\n            if addressField is not None:\n                if not self[addressField]:\n                    return\n\n        # void specifier\n        if format[:1] == '_':\n            if dataClassOrCode != b:\n                fields = {'self':self, 'inputDataLeft':data}\n                fields.update(self.fields)\n                return eval(dataClassOrCode, {}, fields)\n            else:\n                return None\n\n        # quote specifier\n        if format[:1] == \"'\" or format[:1] == '\"':\n            answer = format[1:]\n            if b(answer) != data:\n                raise Exception(\"Unpacked data doesn't match constant value '%r' should be '%r'\" % (data, answer))\n            return answer\n\n        # address specifier\n        two = format.split('&')\n        if len(two) == 2:\n            return self.unpack(two[0],data)\n\n        # code specifier\n        two = format.split('=')\n        if len(two) >= 2:\n            return self.unpack(two[0],data)\n\n        # length specifier\n        two = format.split('-')\n        if len(two) == 2:\n            return self.unpack(two[0],data)\n\n        # array specifier\n        two = format.split('*')\n        if len(two) == 2:\n            answer = []\n            sofar = 0\n            if two[0].isdigit():\n                number = int(two[0])\n            elif two[0]:\n                sofar += self.calcUnpackSize(two[0], data)\n                number = self.unpack(two[0], data[:sofar])\n            else:\n                number = -1\n\n            while number and sofar < len(data):\n                nsofar = sofar + self.calcUnpackSize(two[1],data[sofar:])\n                answer.append(self.unpack(two[1], data[sofar:nsofar], dataClassOrCode))\n                number -= 1\n                sofar = nsofar\n            return answer\n\n        # \"printf\" string specifier\n        if format[:1] == '%':\n            # format string like specifier\n            return format % data\n\n        # asciiz specifier\n        if format == 'z':\n            if data[-1:] != b('\\x00'):\n                raise Exception(\"%s 'z' field is not NUL terminated: %r\" % (field, data))\n            if PY3:\n                return data[:-1].decode('latin-1')\n            else:\n                return data[:-1]\n\n        # unicode specifier\n        if format == 'u':\n            if data[-2:] != b('\\x00\\x00'):\n                raise Exception(\"%s 'u' field is not NUL-NUL terminated: %r\" % (field, data))\n            return data[:-2] # remove trailing NUL\n\n        # DCE-RPC/NDR string specifier\n        if format == 'w':\n            l = unpack('<L', data[:4])[0]\n            return data[12:12+l*2]\n\n        # literal specifier\n        if format == ':':\n            if isinstance(data, bytes) and dataClassOrCode is b:\n                return data\n            return dataClassOrCode(data)\n\n        # struct like specifier\n        return unpack(format, data)[0]\n\n    def calcPackSize(self, format, data, field = None):\n#        # print \"  calcPackSize  %s:%r\" %  (format, data)\n        if field:\n            addressField = self.findAddressFieldFor(field)\n            if addressField is not None:\n                if not self[addressField]:\n                    return 0\n\n        # void specifier\n        if format[:1] == '_':\n            return 0\n\n        # quote specifier\n        if format[:1] == \"'\" or format[:1] == '\"':\n            return len(format)-1\n\n        # address specifier\n        two = format.split('&')\n        if len(two) == 2:\n            return self.calcPackSize(two[0], data)\n\n        # code specifier\n        two = format.split('=')\n        if len(two) >= 2:\n            return self.calcPackSize(two[0], data)\n\n        # length specifier\n        two = format.split('-')\n        if len(two) == 2:\n            return self.calcPackSize(two[0], data)\n\n        # array specifier\n        two = format.split('*')\n        if len(two) == 2:\n            answer = 0\n            if two[0].isdigit():\n                    if int(two[0]) != len(data):\n                        raise Exception(\"Array field has a constant size, and it doesn't match the actual value\")\n            elif two[0]:\n                answer += self.calcPackSize(two[0], len(data))\n\n            for each in data:\n                answer += self.calcPackSize(two[1], each)\n            return answer\n\n        # \"printf\" string specifier\n        if format[:1] == '%':\n            # format string like specifier\n            return len(format % data)\n\n        # asciiz specifier\n        if format[:1] == 'z':\n            return len(data)+1\n\n        # asciiz specifier\n        if format[:1] == 'u':\n            l = len(data)\n            return l + (l & 1 and 3 or 2)\n\n        # DCE-RPC/NDR string specifier\n        if format[:1] == 'w':\n            l = len(data)\n            return 12+l+l % 2\n\n        # literal specifier\n        if format[:1] == ':':\n            return len(data)\n\n        # struct like specifier\n        return calcsize(format)\n\n    def calcUnpackSize(self, format, data, field = None):\n        if self.debug:\n            print(\"  calcUnpackSize( %s | %s | %r)\" %  (field, format, data))\n\n        # void specifier\n        if format[:1] == '_':\n            return 0\n\n        addressField = self.findAddressFieldFor(field)\n        if addressField is not None:\n            if not self[addressField]:\n                return 0\n\n        try:\n            lengthField = self.findLengthFieldFor(field)\n            return int(self[lengthField])\n        except Exception:\n            pass\n\n        # XXX: Try to match to actual values, raise if no match\n        \n        # quote specifier\n        if format[:1] == \"'\" or format[:1] == '\"':\n            return len(format)-1\n\n        # address specifier\n        two = format.split('&')\n        if len(two) == 2:\n            return self.calcUnpackSize(two[0], data)\n\n        # code specifier\n        two = format.split('=')\n        if len(two) >= 2:\n            return self.calcUnpackSize(two[0], data)\n\n        # length specifier\n        two = format.split('-')\n        if len(two) == 2:\n            return self.calcUnpackSize(two[0], data)\n\n        # array specifier\n        two = format.split('*')\n        if len(two) == 2:\n            answer = 0\n            if two[0]:\n                if two[0].isdigit():\n                    number = int(two[0])\n                else:\n                    answer += self.calcUnpackSize(two[0], data)\n                    number = self.unpack(two[0], data[:answer])\n\n                while number:\n                    number -= 1\n                    answer += self.calcUnpackSize(two[1], data[answer:])\n            else:\n                while answer < len(data):\n                    answer += self.calcUnpackSize(two[1], data[answer:])\n            return answer\n\n        # \"printf\" string specifier\n        if format[:1] == '%':\n            raise Exception(\"Can't guess the size of a printf like specifier for unpacking\")\n\n        # asciiz specifier\n        if format[:1] == 'z':\n            return data.index(b('\\x00'))+1\n\n        # asciiz specifier\n        if format[:1] == 'u':\n            l = data.index(b('\\x00\\x00'))\n            return l + (l & 1 and 3 or 2)\n\n        # DCE-RPC/NDR string specifier\n        if format[:1] == 'w':\n            l = unpack('<L', data[:4])[0]\n            return 12+l*2\n\n        # literal specifier\n        if format[:1] == ':':\n            return len(data)\n\n        # struct like specifier\n        return calcsize(format)\n\n    def calcPackFieldSize(self, fieldName, format = None):\n        if format is None:\n            format = self.formatForField(fieldName)\n\n        return self.calcPackSize(format, self[fieldName])\n\n    def formatForField(self, fieldName):\n        for field in self.commonHdr+self.structure:\n            if field[0] == fieldName:\n                return field[1]\n        raise Exception(\"Field %s not found\" % fieldName)\n\n    def findAddressFieldFor(self, fieldName):\n        descriptor = '&%s' % fieldName\n        l = len(descriptor)\n        for field in self.commonHdr+self.structure:\n            if field[1][-l:] == descriptor:\n                return field[0]\n        return None\n        \n    def findLengthFieldFor(self, fieldName):\n        descriptor = '-%s' % fieldName\n        l = len(descriptor)\n        for field in self.commonHdr+self.structure:\n            if field[1][-l:] == descriptor:\n                return field[0]\n        return None\n        \n    def zeroValue(self, format):\n        two = format.split('*')\n        if len(two) == 2:\n            if two[0].isdigit():\n                return (self.zeroValue(two[1]),)*int(two[0])\n                        \n        if not format.find('*') == -1:\n            return ()\n        if 's' in format:\n            return b''\n        if format in ['z',':','u']:\n            return b''\n        if format == 'w':\n            return b('\\x00\\x00')\n\n        return 0\n\n    def clear(self):\n        for field in self.commonHdr + self.structure:\n            self[field[0]] = self.zeroValue(field[1])\n\n    def dump(self, msg = None, indent = 0):\n        if msg is None:\n            msg = self.__class__.__name__\n        ind = ' '*indent\n        print(\"\\n%s\" % msg)\n        fixedFields = []\n        for field in self.commonHdr+self.structure:\n            i = field[0] \n            if i in self.fields:\n                fixedFields.append(i)\n                if isinstance(self[i], Structure):\n                    self[i].dump('%s%s:{' % (ind,i), indent = indent + 4)\n                    print(\"%s}\" % ind)\n                else:\n                    print(\"%s%s: {%r}\" % (ind,i,self[i]))\n        # Do we have remaining fields not defined in the structures? let's \n        # print them\n        remainingFields = list(set(self.fields) - set(fixedFields))\n        for i in remainingFields:\n            if isinstance(self[i], Structure):\n                self[i].dump('%s%s:{' % (ind,i), indent = indent + 4)\n                print(\"%s}\" % ind)\n            else:\n                print(\"%s%s: {%r}\" % (ind,i,self[i]))",
  "def pretty_print(x):\n    if chr(x) in '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!\"#$%&\\'()*+,-./:;<=>?@[\\\\]^_`{|}~ ':\n       return chr(x)\n    else:\n       return u'.'",
  "def hexdump(data, indent = ''):\n    if data is None:\n        return\n    if isinstance(data, int):\n        data = str(data).encode('utf-8')\n    x=bytearray(data)\n    strLen = len(x)\n    i = 0\n    while i < strLen:\n        line = \" %s%04x   \" % (indent, i)\n        for j in range(16):\n            if i+j < strLen:\n                line += \"%02X \" % x[i+j]\n            else:\n                line += u\"   \"\n            if j%16 == 7:\n                line += \" \"\n        line += \"  \"\n        line += ''.join(pretty_print(x) for x in x[i:i+16] )\n        print (line)\n        i += 16",
  "def parse_bitmask(dict, value):\n    ret = ''\n    \n    for i in range(0, 31):\n        flag = 1 << i\n\n        if value & flag == 0:\n            continue\n\n        if flag in dict:\n            ret += '%s | ' % dict[flag]\n        else:\n            ret += \"0x%.8X | \" % flag\n\n    if len(ret) == 0:\n        return '0'\n    else:\n        return ret[:-3]",
  "def __init__(self, data = None, alignment = 0):\n        if not hasattr(self, 'alignment'):\n            self.alignment = alignment\n\n        self.fields    = {}\n        self.rawData   = data\n        if data is not None:\n            self.fromString(data)\n        else:\n            self.data = None",
  "def fromFile(self, file):\n        answer = self()\n        answer.fromString(file.read(len(answer)))\n        return answer",
  "def setAlignment(self, alignment):\n        self.alignment = alignment",
  "def setData(self, data):\n        self.data = data",
  "def packField(self, fieldName, format = None):\n        if self.debug:\n            print(\"packField( %s | %s )\" % (fieldName, format))\n\n        if format is None:\n            format = self.formatForField(fieldName)\n\n        if fieldName in self.fields:\n            ans = self.pack(format, self.fields[fieldName], field = fieldName)\n        else:\n            ans = self.pack(format, None, field = fieldName)\n\n        if self.debug:\n            print(\"\\tanswer %r\" % ans)\n\n        return ans",
  "def getData(self):\n        if self.data is not None:\n            return self.data\n        data = bytes()\n        for field in self.commonHdr+self.structure:\n            try:\n                data += self.packField(field[0], field[1])\n            except Exception as e:\n                if field[0] in self.fields:\n                    e.args += (\"When packing field '%s | %s | %r' in %s\" % (field[0], field[1], self[field[0]], self.__class__),)\n                else:\n                    e.args += (\"When packing field '%s | %s' in %s\" % (field[0], field[1], self.__class__),)\n                raise\n            if self.alignment:\n                if len(data) % self.alignment:\n                    data += (b'\\x00'*self.alignment)[:-(len(data) % self.alignment)]\n            \n        #if len(data) % self.alignment: data += ('\\x00'*self.alignment)[:-(len(data) % self.alignment)]\n        return data",
  "def fromString(self, data):\n        self.rawData = data\n        for field in self.commonHdr+self.structure:\n            if self.debug:\n                print(\"fromString( %s | %s | %r )\" % (field[0], field[1], data))\n            size = self.calcUnpackSize(field[1], data, field[0])\n            if self.debug:\n                print(\"  size = %d\" % size)\n            dataClassOrCode = b\n            if len(field) > 2:\n                dataClassOrCode = field[2]\n            try:\n                self[field[0]] = self.unpack(field[1], data[:size], dataClassOrCode = dataClassOrCode, field = field[0])\n            except Exception as e:\n                e.args += (\"When unpacking field '%s | %s | %r[:%d]'\" % (field[0], field[1], data, size),)\n                raise\n\n            size = self.calcPackSize(field[1], self[field[0]], field[0])\n            if self.alignment and size % self.alignment:\n                size += self.alignment - (size % self.alignment)\n            data = data[size:]\n\n        return self",
  "def __setitem__(self, key, value):\n        self.fields[key] = value\n        self.data = None",
  "def __getitem__(self, key):\n        return self.fields[key]",
  "def __delitem__(self, key):\n        del self.fields[key]",
  "def __str__(self):\n        return self.getData()",
  "def __len__(self):\n        # XXX: improve\n        return len(self.getData())",
  "def pack(self, format, data, field = None):\n        if self.debug:\n            print(\"  pack( %s | %r | %s)\" %  (format, data, field))\n\n        if field:\n            addressField = self.findAddressFieldFor(field)\n            if (addressField is not None) and (data is None):\n                return b''\n\n        # void specifier\n        if format[:1] == '_':\n            return b''\n\n        # quote specifier\n        if format[:1] == \"'\" or format[:1] == '\"':\n            return b(format[1:])\n\n        # code specifier\n        two = format.split('=')\n        if len(two) >= 2:\n            try:\n                return self.pack(two[0], data)\n            except:\n                fields = {'self':self}\n                fields.update(self.fields)\n                return self.pack(two[0], eval(two[1], {}, fields))\n\n        # address specifier\n        two = format.split('&')\n        if len(two) == 2:\n            try:\n                return self.pack(two[0], data)\n            except:\n                if (two[1] in self.fields) and (self[two[1]] is not None):\n                    return self.pack(two[0], id(self[two[1]]) & ((1<<(calcsize(two[0])*8))-1) )\n                else:\n                    return self.pack(two[0], 0)\n\n        # length specifier\n        two = format.split('-')\n        if len(two) == 2:\n            try:\n                return self.pack(two[0],data)\n            except:\n                return self.pack(two[0], self.calcPackFieldSize(two[1]))\n\n        # array specifier\n        two = format.split('*')\n        if len(two) == 2:\n            answer = bytes()\n            for each in data:\n                answer += self.pack(two[1], each)\n            if two[0]:\n                if two[0].isdigit():\n                    if int(two[0]) != len(data):\n                        raise Exception(\"Array field has a constant size, and it doesn't match the actual value\")\n                else:\n                    return self.pack(two[0], len(data))+answer\n            return answer\n\n        # \"printf\" string specifier\n        if format[:1] == '%':\n            # format string like specifier\n            return b(format % data)\n\n        # asciiz specifier\n        if format[:1] == 'z':\n            if isinstance(data,bytes):\n                return data + b('\\0')\n            return bytes(b(data)+b('\\0'))\n\n        # unicode specifier\n        if format[:1] == 'u':\n            return bytes(data+b('\\0\\0') + (len(data) & 1 and b('\\0') or b''))\n\n        # DCE-RPC/NDR string specifier\n        if format[:1] == 'w':\n            if len(data) == 0:\n                data = b('\\0\\0')\n            elif len(data) % 2:\n                data = b(data) + b('\\0')\n            l = pack('<L', len(data)//2)\n            return b''.join([l, l, b('\\0\\0\\0\\0'), data])\n\n        if data is None:\n            raise Exception(\"Trying to pack None\")\n        \n        # literal specifier\n        if format[:1] == ':':\n            if isinstance(data, Structure):\n                return data.getData()\n            # If we have an object that can serialize itself, go ahead\n            elif hasattr(data, \"getData\"):\n                return data.getData()\n            elif isinstance(data, int):\n                return bytes(data)\n            elif isinstance(data, bytes) is not True:\n                return bytes(b(data))\n            else:\n                return data\n\n        if format[-1:] == 's':\n            # Let's be sure we send the right type\n            if isinstance(data, bytes) or isinstance(data, bytearray):\n                return pack(format, data)\n            else:\n                return pack(format, b(data))\n\n        # struct like specifier\n        return pack(format, data)",
  "def unpack(self, format, data, dataClassOrCode = b, field = None):\n        if self.debug:\n            print(\"  unpack( %s | %r )\" %  (format, data))\n\n        if field:\n            addressField = self.findAddressFieldFor(field)\n            if addressField is not None:\n                if not self[addressField]:\n                    return\n\n        # void specifier\n        if format[:1] == '_':\n            if dataClassOrCode != b:\n                fields = {'self':self, 'inputDataLeft':data}\n                fields.update(self.fields)\n                return eval(dataClassOrCode, {}, fields)\n            else:\n                return None\n\n        # quote specifier\n        if format[:1] == \"'\" or format[:1] == '\"':\n            answer = format[1:]\n            if b(answer) != data:\n                raise Exception(\"Unpacked data doesn't match constant value '%r' should be '%r'\" % (data, answer))\n            return answer\n\n        # address specifier\n        two = format.split('&')\n        if len(two) == 2:\n            return self.unpack(two[0],data)\n\n        # code specifier\n        two = format.split('=')\n        if len(two) >= 2:\n            return self.unpack(two[0],data)\n\n        # length specifier\n        two = format.split('-')\n        if len(two) == 2:\n            return self.unpack(two[0],data)\n\n        # array specifier\n        two = format.split('*')\n        if len(two) == 2:\n            answer = []\n            sofar = 0\n            if two[0].isdigit():\n                number = int(two[0])\n            elif two[0]:\n                sofar += self.calcUnpackSize(two[0], data)\n                number = self.unpack(two[0], data[:sofar])\n            else:\n                number = -1\n\n            while number and sofar < len(data):\n                nsofar = sofar + self.calcUnpackSize(two[1],data[sofar:])\n                answer.append(self.unpack(two[1], data[sofar:nsofar], dataClassOrCode))\n                number -= 1\n                sofar = nsofar\n            return answer\n\n        # \"printf\" string specifier\n        if format[:1] == '%':\n            # format string like specifier\n            return format % data\n\n        # asciiz specifier\n        if format == 'z':\n            if data[-1:] != b('\\x00'):\n                raise Exception(\"%s 'z' field is not NUL terminated: %r\" % (field, data))\n            if PY3:\n                return data[:-1].decode('latin-1')\n            else:\n                return data[:-1]\n\n        # unicode specifier\n        if format == 'u':\n            if data[-2:] != b('\\x00\\x00'):\n                raise Exception(\"%s 'u' field is not NUL-NUL terminated: %r\" % (field, data))\n            return data[:-2] # remove trailing NUL\n\n        # DCE-RPC/NDR string specifier\n        if format == 'w':\n            l = unpack('<L', data[:4])[0]\n            return data[12:12+l*2]\n\n        # literal specifier\n        if format == ':':\n            if isinstance(data, bytes) and dataClassOrCode is b:\n                return data\n            return dataClassOrCode(data)\n\n        # struct like specifier\n        return unpack(format, data)[0]",
  "def calcPackSize(self, format, data, field = None):\n#        # print \"  calcPackSize  %s:%r\" %  (format, data)\n        if field:\n            addressField = self.findAddressFieldFor(field)\n            if addressField is not None:\n                if not self[addressField]:\n                    return 0\n\n        # void specifier\n        if format[:1] == '_':\n            return 0\n\n        # quote specifier\n        if format[:1] == \"'\" or format[:1] == '\"':\n            return len(format)-1\n\n        # address specifier\n        two = format.split('&')\n        if len(two) == 2:\n            return self.calcPackSize(two[0], data)\n\n        # code specifier\n        two = format.split('=')\n        if len(two) >= 2:\n            return self.calcPackSize(two[0], data)\n\n        # length specifier\n        two = format.split('-')\n        if len(two) == 2:\n            return self.calcPackSize(two[0], data)\n\n        # array specifier\n        two = format.split('*')\n        if len(two) == 2:\n            answer = 0\n            if two[0].isdigit():\n                    if int(two[0]) != len(data):\n                        raise Exception(\"Array field has a constant size, and it doesn't match the actual value\")\n            elif two[0]:\n                answer += self.calcPackSize(two[0], len(data))\n\n            for each in data:\n                answer += self.calcPackSize(two[1], each)\n            return answer\n\n        # \"printf\" string specifier\n        if format[:1] == '%':\n            # format string like specifier\n            return len(format % data)\n\n        # asciiz specifier\n        if format[:1] == 'z':\n            return len(data)+1\n\n        # asciiz specifier\n        if format[:1] == 'u':\n            l = len(data)\n            return l + (l & 1 and 3 or 2)\n\n        # DCE-RPC/NDR string specifier\n        if format[:1] == 'w':\n            l = len(data)\n            return 12+l+l % 2\n\n        # literal specifier\n        if format[:1] == ':':\n            return len(data)\n\n        # struct like specifier\n        return calcsize(format)",
  "def calcUnpackSize(self, format, data, field = None):\n        if self.debug:\n            print(\"  calcUnpackSize( %s | %s | %r)\" %  (field, format, data))\n\n        # void specifier\n        if format[:1] == '_':\n            return 0\n\n        addressField = self.findAddressFieldFor(field)\n        if addressField is not None:\n            if not self[addressField]:\n                return 0\n\n        try:\n            lengthField = self.findLengthFieldFor(field)\n            return int(self[lengthField])\n        except Exception:\n            pass\n\n        # XXX: Try to match to actual values, raise if no match\n        \n        # quote specifier\n        if format[:1] == \"'\" or format[:1] == '\"':\n            return len(format)-1\n\n        # address specifier\n        two = format.split('&')\n        if len(two) == 2:\n            return self.calcUnpackSize(two[0], data)\n\n        # code specifier\n        two = format.split('=')\n        if len(two) >= 2:\n            return self.calcUnpackSize(two[0], data)\n\n        # length specifier\n        two = format.split('-')\n        if len(two) == 2:\n            return self.calcUnpackSize(two[0], data)\n\n        # array specifier\n        two = format.split('*')\n        if len(two) == 2:\n            answer = 0\n            if two[0]:\n                if two[0].isdigit():\n                    number = int(two[0])\n                else:\n                    answer += self.calcUnpackSize(two[0], data)\n                    number = self.unpack(two[0], data[:answer])\n\n                while number:\n                    number -= 1\n                    answer += self.calcUnpackSize(two[1], data[answer:])\n            else:\n                while answer < len(data):\n                    answer += self.calcUnpackSize(two[1], data[answer:])\n            return answer\n\n        # \"printf\" string specifier\n        if format[:1] == '%':\n            raise Exception(\"Can't guess the size of a printf like specifier for unpacking\")\n\n        # asciiz specifier\n        if format[:1] == 'z':\n            return data.index(b('\\x00'))+1\n\n        # asciiz specifier\n        if format[:1] == 'u':\n            l = data.index(b('\\x00\\x00'))\n            return l + (l & 1 and 3 or 2)\n\n        # DCE-RPC/NDR string specifier\n        if format[:1] == 'w':\n            l = unpack('<L', data[:4])[0]\n            return 12+l*2\n\n        # literal specifier\n        if format[:1] == ':':\n            return len(data)\n\n        # struct like specifier\n        return calcsize(format)",
  "def calcPackFieldSize(self, fieldName, format = None):\n        if format is None:\n            format = self.formatForField(fieldName)\n\n        return self.calcPackSize(format, self[fieldName])",
  "def formatForField(self, fieldName):\n        for field in self.commonHdr+self.structure:\n            if field[0] == fieldName:\n                return field[1]\n        raise Exception(\"Field %s not found\" % fieldName)",
  "def findAddressFieldFor(self, fieldName):\n        descriptor = '&%s' % fieldName\n        l = len(descriptor)\n        for field in self.commonHdr+self.structure:\n            if field[1][-l:] == descriptor:\n                return field[0]\n        return None",
  "def findLengthFieldFor(self, fieldName):\n        descriptor = '-%s' % fieldName\n        l = len(descriptor)\n        for field in self.commonHdr+self.structure:\n            if field[1][-l:] == descriptor:\n                return field[0]\n        return None",
  "def zeroValue(self, format):\n        two = format.split('*')\n        if len(two) == 2:\n            if two[0].isdigit():\n                return (self.zeroValue(two[1]),)*int(two[0])\n                        \n        if not format.find('*') == -1:\n            return ()\n        if 's' in format:\n            return b''\n        if format in ['z',':','u']:\n            return b''\n        if format == 'w':\n            return b('\\x00\\x00')\n\n        return 0",
  "def clear(self):\n        for field in self.commonHdr + self.structure:\n            self[field[0]] = self.zeroValue(field[1])",
  "def dump(self, msg = None, indent = 0):\n        if msg is None:\n            msg = self.__class__.__name__\n        ind = ' '*indent\n        print(\"\\n%s\" % msg)\n        fixedFields = []\n        for field in self.commonHdr+self.structure:\n            i = field[0] \n            if i in self.fields:\n                fixedFields.append(i)\n                if isinstance(self[i], Structure):\n                    self[i].dump('%s%s:{' % (ind,i), indent = indent + 4)\n                    print(\"%s}\" % ind)\n                else:\n                    print(\"%s%s: {%r}\" % (ind,i,self[i]))\n        # Do we have remaining fields not defined in the structures? let's \n        # print them\n        remainingFields = list(set(self.fields) - set(fixedFields))\n        for i in remainingFields:\n            if isinstance(self[i], Structure):\n                self[i].dump('%s%s:{' % (ind,i), indent = indent + 4)\n                print(\"%s}\" % ind)\n            else:\n                print(\"%s%s: {%r}\" % (ind,i,self[i]))",
  "class SessionError(Exception):\n    def __init__( self, error = 0, packet=0):\n        Exception.__init__(self)\n        self.error = error\n        self.packet = packet\n\n    def get_error_code( self ):\n        return self.error\n\n    def get_error_packet( self ):\n        return self.packet\n\n    def __str__( self ):\n        return 'SMB SessionError: %s(%s)' % (ERROR_MESSAGES[self.error])",
  "class SMB3:\n    class HostnameValidationException(Exception):\n        pass\n\n    def __init__(self, remote_name, remote_host, my_name=None, host_type=nmb.TYPE_SERVER, sess_port=445, timeout=60,\n                 UDP=0, preferredDialect=None, session=None, negSessionResponse=None):\n\n        # [MS-SMB2] Section 3\n        self.RequireMessageSigning = False    #\n        self.ConnectionTable = {}\n        self.GlobalFileTable = {}\n        self.ClientGuid = ''.join([random.choice(string.ascii_letters) for i in range(16)])\n        # Only for SMB 3.0\n        self.EncryptionAlgorithmList = ['AES-CCM']\n        self.MaxDialect = []\n        self.RequireSecureNegotiate = False\n\n        # Per Transport Connection Data\n        self._Connection = {\n            # Indexed by SessionID\n            #'SessionTable'             : {},\n            # Indexed by MessageID\n            'OutstandingRequests'      : {},\n            'OutstandingResponses'     : {},    #\n            'SequenceWindow'           : 0,     #\n            'GSSNegotiateToken'        : '',    #\n            'MaxTransactSize'          : 0,     #\n            'MaxReadSize'              : 0,     #\n            'MaxWriteSize'             : 0,     #\n            'ServerGuid'               : '',    #\n            'RequireSigning'           : False, #\n            'ServerName'               : '',    #\n            # If the client implements the SMB 2.1 or SMB 3.0 dialects, it MUST\n            # also implement the following\n            'Dialect'                  : 0,    #\n            'SupportsFileLeasing'      : False, #\n            'SupportsMultiCredit'      : False, #\n            # If the client implements the SMB 3.0 dialect,\n            # it MUST also implement the following\n            'SupportsDirectoryLeasing' : False, #\n            'SupportsMultiChannel'     : False, #\n            'SupportsPersistentHandles': False, #\n            'SupportsEncryption'       : False, #\n            'ClientCapabilities'       : 0,\n            'ServerCapabilities'       : 0,    #\n            'ClientSecurityMode'       : 0,    #\n            'ServerSecurityMode'       : 0,    #\n            # Outside the protocol\n            'ServerIP'                 : '',    #\n            'ClientName'               : '',    #\n            #GSSoptions (MutualAuth and Delegate)\n            'GSSoptions'               : {},\n            # If the client implements the SMB 3.1.1 dialect,\n            # it MUST also implement the following\n            'PreauthIntegrityHashId': 0,\n            'PreauthIntegrityHashValue': a2b_hex(b'0'*128),\n            'CipherId' : 0\n        }\n\n        self._Session = {\n            'SessionID'                : 0,   #\n            'TreeConnectTable'         : {},    #\n            'SessionKey'               : b'',    #\n            'SigningRequired'          : False, #\n            'Connection'               : 0,     #\n            'UserCredentials'          : '',    #\n            'OpenTable'                : {},    #\n            # If the client implements the SMB 3.0 dialect,\n            # it MUST also implement the following\n            'ChannelList'              : [],\n            'ChannelSequence'          : 0,\n            #'EncryptData'              : False,\n            'EncryptData'              : True,\n            'EncryptionKey'            : '',\n            'DecryptionKey'            : '',\n            'SigningKey'               : '',\n            'ApplicationKey'           : b'',\n            # Outside the protocol\n            'SessionFlags'             : 0,     #\n            'ServerName'               : '',    #\n            'ServerDomain'             : '',    #\n            'ServerDNSDomainName'      : '',    #\n            'ServerDNSHostName'        : '',    #\n            'ServerOS'                 : '',    #\n            'SigningActivated'         : False, #\n            'PreauthIntegrityHashValue': a2b_hex(b'0'*128),\n            'CalculatePreAuthHash'     : True,\n        }\n\n        self.SMB_PACKET = SMB2Packet\n\n        self._timeout = timeout\n        self._Connection['ServerIP'] = remote_host\n        self._NetBIOSSession = None\n        self._preferredDialect = preferredDialect\n        self._doKerberos = False\n\n        # Strict host validation - off by default\n        self._strict_hostname_validation = False\n        self._validation_allow_absent = True\n        self._accepted_hostname = ''\n\n        self.__userName = ''\n        self.__password = ''\n        self.__domain   = ''\n        self.__lmhash   = ''\n        self.__nthash   = ''\n        self.__kdc      = ''\n        self.__aesKey   = ''\n        self.__TGT      = None\n        self.__TGS      = None\n\n        if sess_port == 445 and remote_name == '*SMBSERVER':\n           self._Connection['ServerName'] = remote_host\n        else:\n           self._Connection['ServerName'] = remote_name\n\n        # This is on purpose. I'm still not convinced to do a socket.gethostname() if not specified\n        if my_name is None:\n            self._Connection['ClientName'] = ''\n        else:\n            self._Connection['ClientName'] = my_name\n\n        if session is None:\n            if not my_name:\n                # If destination port is 139 yes, there's some client disclosure\n                my_name = socket.gethostname()\n                i = my_name.find('.')\n                if i > -1:\n                    my_name = my_name[:i]\n\n            if UDP:\n                self._NetBIOSSession = nmb.NetBIOSUDPSession(my_name, self._Connection['ServerName'], remote_host, host_type, sess_port, self._timeout)\n            else:\n                self._NetBIOSSession = nmb.NetBIOSTCPSession(my_name, self._Connection['ServerName'], remote_host, host_type, sess_port, self._timeout)\n\n                self.negotiateSession(preferredDialect)\n        else:\n            self._NetBIOSSession = session\n            # We should increase the SequenceWindow since a packet was already received.\n            self._Connection['SequenceWindow'] += 1\n            # Let's negotiate again if needed (or parse the existing response) using the same connection\n            self.negotiateSession(preferredDialect, negSessionResponse)\n\n    def printStatus(self):\n        print(\"CONNECTION\")\n        for i in list(self._Connection.items()):\n            print(\"%-40s : %s\" % i)\n        print()\n        print(\"SESSION\")\n        for i in list(self._Session.items()):\n            print(\"%-40s : %s\" % i)\n\n    def __UpdateConnectionPreAuthHash(self, data):\n        from Cryptodome.Hash import SHA512\n        calculatedHash =  SHA512.new()\n        calculatedHash.update(self._Connection['PreauthIntegrityHashValue'])\n        calculatedHash.update(data)\n        self._Connection['PreauthIntegrityHashValue'] = calculatedHash.digest()\n\n    def __UpdatePreAuthHash(self, data):\n        from Cryptodome.Hash import SHA512\n        calculatedHash =  SHA512.new()\n        calculatedHash.update(self._Session['PreauthIntegrityHashValue'])\n        calculatedHash.update(data)\n        self._Session['PreauthIntegrityHashValue'] = calculatedHash.digest()\n\n    def getKerberos(self):\n        return self._doKerberos\n\n    def getServerName(self):\n        return self._Session['ServerName']\n\n    def getClientName(self):\n        return self._Session['ClientName']\n\n    def getRemoteName(self):\n        if self._Session['ServerName'] == '':\n            return self._Connection['ServerName']\n        return self._Session['ServerName']\n\n    def setRemoteName(self, name):\n        self._Session['ServerName'] = name\n        return True\n\n    def getServerIP(self):\n        return self._Connection['ServerIP']\n\n    def getServerDomain(self):\n        return self._Session['ServerDomain']\n\n    def getServerDNSDomainName(self):\n        return self._Session['ServerDNSDomainName']\n\n    def getServerDNSHostName(self):\n        return self._Session['ServerDNSHostName']\n\n    def getServerOS(self):\n        return self._Session['ServerOS']\n\n    def getServerOSMajor(self):\n        return self._Session['ServerOSMajor']\n\n    def getServerOSMinor(self):\n        return self._Session['ServerOSMinor']\n\n    def getServerOSBuild(self):\n        return self._Session['ServerOSBuild']\n\n    def isGuestSession(self):\n        return self._Session['SessionFlags'] & SMB2_SESSION_FLAG_IS_GUEST\n\n    def setTimeout(self, timeout):\n        self._timeout = timeout\n\n    @contextmanager\n    def useTimeout(self, timeout):\n        prev_timeout = self.getTimeout(timeout)\n        try:\n            yield\n        finally:\n            self.setTimeout(prev_timeout)\n\n    def getDialect(self):\n        return self._Connection['Dialect']\n\n    def processContextList(self, contextCount, contextList):\n        offset = 0\n        while contextCount > 0:\n            context = SMB2NegotiateContext(contextList[offset:])\n            if context['ContextType'] == SMB2_PREAUTH_INTEGRITY_CAPABILITIES:\n                contextPreAuth = SMB2PreAuthIntegrityCapabilities(context['Data'])\n                self._Connection['PreauthIntegrityHashId'] = struct.unpack('<H', contextPreAuth['HashAlgorithms'])[0]\n            elif context['ContextType'] == SMB2_ENCRYPTION_CAPABILITIES:\n                contextEncryption = SMB2EncryptionCapabilities(context['Data'])\n                cipherId = struct.unpack('<H', contextEncryption['Ciphers'])[0]\n                self._Connection['CipherId'] = cipherId\n                if cipherId != 0:\n                    self._Connection['SupportsEncryption'] = True\n            elif context['ContextType'] == SMB2_COMPRESSION_CAPABILITIES:\n                pass\n            elif context['ContextType'] == SMB2_NETNAME_NEGOTIATE_CONTEXT_ID:\n                pass\n\n            padding = ((8 - (context['DataLength'] % 8)) % 8)\n            offset = 8 + context['DataLength'] + padding\n            contextCount -= 1\n\n    def signSMB(self, packet):\n        packet['Signature'] = '\\x00'*16\n        if self._Connection['Dialect'] == SMB2_DIALECT_21 or self._Connection['Dialect'] == SMB2_DIALECT_002:\n            if len(self._Session['SessionKey']) > 0:\n                signature = hmac.new(self._Session['SessionKey'], packet.getData(), hashlib.sha256).digest()\n                packet['Signature'] = signature[:16]\n        else:\n            if len(self._Session['SessionKey']) > 0:\n                p = packet.getData()\n                signature = crypto.AES_CMAC(self._Session['SigningKey'], p, len(p))\n                packet['Signature'] = signature\n\n    def sendSMB(self, packet):\n        # The idea here is to receive multiple/single commands and create a compound request, and send it\n        # Should return the MessageID for later retrieval. Implement compounded related requests.\n\n        # If Connection.Dialect is equal to \"3.000\" and if Connection.SupportsMultiChannel or\n        # Connection.SupportsPersistentHandles is TRUE, the client MUST set ChannelSequence in the\n        # SMB2 header to Session.ChannelSequence\n\n        # Check this is not a CANCEL request. If so, don't consume sequence numbers\n        if packet['Command'] is not SMB2_CANCEL:\n            packet['MessageID'] = self._Connection['SequenceWindow']\n            self._Connection['SequenceWindow'] += 1\n        packet['SessionID'] = self._Session['SessionID']\n\n        # Default the credit charge to 1 unless set by the caller\n        if ('CreditCharge' in packet.fields) is False:\n            packet['CreditCharge'] = 1\n\n        # Standard credit request after negotiating protocol\n        if self._Connection['SequenceWindow'] > 3:\n            packet['CreditRequestResponse'] = 127\n\n        messageId = packet['MessageID']\n\n        if self._Session['SigningActivated'] is True and self._Connection['SequenceWindow'] > 2:\n            if packet['TreeID'] > 0 and (packet['TreeID'] in self._Session['TreeConnectTable']) is True:\n                if self._Session['TreeConnectTable'][packet['TreeID']]['EncryptData'] is False:\n                    packet['Flags'] = SMB2_FLAGS_SIGNED\n                    self.signSMB(packet)\n            elif packet['TreeID'] == 0:\n                packet['Flags'] = SMB2_FLAGS_SIGNED\n                self.signSMB(packet)\n\n        if packet['Command'] is SMB2_NEGOTIATE:\n            data = packet.getData()\n            self.__UpdateConnectionPreAuthHash(data)\n            self._Session['CalculatePreAuthHash'] = False\n\n        if packet['Command'] is SMB2_SESSION_SETUP:\n            self._Session['CalculatePreAuthHash'] = True\n\n        if (self._Session['SessionFlags'] & SMB2_SESSION_FLAG_ENCRYPT_DATA) or ( packet['TreeID'] != 0 and self._Session['TreeConnectTable'][packet['TreeID']]['EncryptData'] is True):\n            plainText = packet.getData()\n            transformHeader = SMB2_TRANSFORM_HEADER()\n            transformHeader['Nonce'] = ''.join([rand.choice(string.ascii_letters) for _ in range(11)])\n            transformHeader['OriginalMessageSize'] = len(plainText)\n            transformHeader['EncryptionAlgorithm'] = SMB2_ENCRYPTION_AES128_CCM\n            transformHeader['SessionID'] = self._Session['SessionID']\n            cipher = AES.new(self._Session['EncryptionKey'], AES.MODE_CCM,  b(transformHeader['Nonce']))\n            cipher.update(transformHeader.getData()[20:])\n            cipherText = cipher.encrypt(plainText)\n            transformHeader['Signature'] = cipher.digest()\n            packet = transformHeader.getData() + cipherText\n\n            self._NetBIOSSession.send_packet(packet)\n        else:\n            data = packet.getData()\n            if self._Session['CalculatePreAuthHash'] is True:\n                self.__UpdatePreAuthHash(data)\n\n            self._NetBIOSSession.send_packet(data)\n\n        return messageId\n\n    def recvSMB(self, packetID = None):\n        # First, verify we don't have the packet already\n        if packetID in self._Connection['OutstandingResponses']:\n            return self._Connection['OutstandingResponses'].pop(packetID)\n\n        data = self._NetBIOSSession.recv_packet(self._timeout)\n\n        if data.get_trailer().startswith(b'\\xfdSMB'):\n            # Packet is encrypted\n            transformHeader = SMB2_TRANSFORM_HEADER(data.get_trailer())\n            cipher = AES.new(self._Session['DecryptionKey'], AES.MODE_CCM,  transformHeader['Nonce'][:11])\n            cipher.update(transformHeader.getData()[20:])\n            plainText = cipher.decrypt(data.get_trailer()[len(SMB2_TRANSFORM_HEADER()):])\n            #cipher.verify(transformHeader['Signature'])\n            packet = SMB2Packet(plainText)\n        else:\n            # In all SMB dialects for a response this field is interpreted as the Status field.\n            # This field can be set to any value. For a list of valid status codes,\n            # see [MS-ERREF] section 2.3.\n            packet = SMB2Packet(data.get_trailer())\n\n        # Loop while we receive pending requests\n        if packet['Status'] == STATUS_PENDING:\n            status = STATUS_PENDING\n            while status == STATUS_PENDING:\n                data = self._NetBIOSSession.recv_packet(self._timeout)\n                if data.get_trailer().startswith(b'\\xfeSMB'):\n                    packet = SMB2Packet(data.get_trailer())\n                else:\n                    # Packet is encrypted\n                    transformHeader = SMB2_TRANSFORM_HEADER(data.get_trailer())\n                    cipher = AES.new(self._Session['DecryptionKey'], AES.MODE_CCM,  transformHeader['Nonce'][:11])\n                    cipher.update(transformHeader.getData()[20:])\n                    plainText = cipher.decrypt(data.get_trailer()[len(SMB2_TRANSFORM_HEADER()):])\n                    #cipher.verify(transformHeader['Signature'])\n                    packet = SMB2Packet(plainText)\n                status = packet['Status']\n\n        if packet['MessageID'] == packetID or packetID is None:\n            # Let's update the sequenceWindow based on the CreditsCharged\n            # In the SMB 2.0.2 dialect, this field MUST NOT be used and MUST be reserved.\n            # The sender MUST set this to 0, and the receiver MUST ignore it.\n            # In all other dialects, this field indicates the number of credits that this request consumes.\n            if self._Connection['Dialect'] > SMB2_DIALECT_002:\n                self._Connection['SequenceWindow'] += (packet['CreditCharge'] - 1)\n            return packet\n        else:\n            self._Connection['OutstandingResponses'][packet['MessageID']] = packet\n            return self.recvSMB(packetID)\n\n    def negotiateSession(self, preferredDialect = None, negSessionResponse = None):\n        # Let's store some data for later use\n        self._Connection['ClientSecurityMode'] = SMB2_NEGOTIATE_SIGNING_ENABLED\n        if self.RequireMessageSigning is True:\n            self._Connection['ClientSecurityMode'] |= SMB2_NEGOTIATE_SIGNING_REQUIRED\n        self._Connection['Capabilities'] = SMB2_GLOBAL_CAP_ENCRYPTION\n        currentDialect = SMB2_DIALECT_WILDCARD\n\n        # Do we have a negSessionPacket already?\n        if negSessionResponse is not None:\n            # Yes, let's store the dialect answered back\n            negResp = SMB2Negotiate_Response(negSessionResponse['Data'])\n            currentDialect = negResp['DialectRevision']\n\n        if currentDialect == SMB2_DIALECT_WILDCARD:\n            # Still don't know the chosen dialect, let's send our options\n\n            packet = self.SMB_PACKET()\n            packet['Command'] = SMB2_NEGOTIATE\n            negSession = SMB2Negotiate()\n\n            negSession['SecurityMode'] = self._Connection['ClientSecurityMode']\n            negSession['Capabilities'] = self._Connection['Capabilities']\n            negSession['ClientGuid'] = self.ClientGuid\n            if preferredDialect is not None:\n                negSession['Dialects'] = [preferredDialect]\n                if preferredDialect == SMB2_DIALECT_311:\n                    # Build the Contexts\n                    contextData = SMB311ContextData()\n                    contextData['NegotiateContextOffset'] = 64+38+2\n                    contextData['NegotiateContextCount'] = 0\n                    # Add an SMB2_NEGOTIATE_CONTEXT with ContextType as SMB2_PREAUTH_INTEGRITY_CAPABILITIES\n                    # to the negotiate request as specified in section 2.2.3.1:\n                    negotiateContext = SMB2NegotiateContext()\n                    negotiateContext['ContextType'] = SMB2_PREAUTH_INTEGRITY_CAPABILITIES\n\n                    preAuthIntegrityCapabilities = SMB2PreAuthIntegrityCapabilities()\n                    preAuthIntegrityCapabilities['HashAlgorithmCount'] = 1\n                    preAuthIntegrityCapabilities['SaltLength'] = 32\n                    preAuthIntegrityCapabilities['HashAlgorithms'] = b'\\x01\\x00'\n                    preAuthIntegrityCapabilities['Salt'] = ''.join([rand.choice(string.ascii_letters) for _ in\n                                                                     range(preAuthIntegrityCapabilities['SaltLength'])])\n\n                    negotiateContext['Data'] = preAuthIntegrityCapabilities.getData()\n                    negotiateContext['DataLength'] = len(negotiateContext['Data'])\n                    contextData['NegotiateContextCount'] += 1\n                    pad = b'\\xFF' * ((8 - (negotiateContext['DataLength'] % 8)) % 8)\n\n                    # Add an SMB2_NEGOTIATE_CONTEXT with ContextType as SMB2_ENCRYPTION_CAPABILITIES\n                    # to the negotiate request as specified in section 2.2.3.1 and initialize\n                    # the Ciphers field with the ciphers supported by the client in the order of preference.\n\n                    negotiateContext2 = SMB2NegotiateContext()\n                    negotiateContext2['ContextType'] = SMB2_ENCRYPTION_CAPABILITIES\n\n                    encryptionCapabilities = SMB2EncryptionCapabilities()\n                    encryptionCapabilities['CipherCount'] = 1\n                    encryptionCapabilities['Ciphers'] = b'\\x01\\x00'\n\n                    negotiateContext2['Data'] = encryptionCapabilities.getData()\n                    negotiateContext2['DataLength'] = len(negotiateContext2['Data'])\n                    contextData['NegotiateContextCount'] += 1\n\n                    negSession['ClientStartTime'] = contextData.getData()\n                    negSession['Padding'] = b'\\xFF\\xFF'\n                    # Subsequent negotiate contexts MUST appear at the first 8-byte aligned offset following the\n                    # previous negotiate context.\n                    negSession['NegotiateContextList'] = negotiateContext.getData() + pad + negotiateContext2.getData()\n\n                    # Do you want to enforce encryption? Uncomment here:\n                    #self._Connection['SupportsEncryption'] = True\n\n            else:\n                negSession['Dialects'] = [SMB2_DIALECT_002, SMB2_DIALECT_21, SMB2_DIALECT_30]\n            negSession['DialectCount'] = len(negSession['Dialects'])\n            packet['Data'] = negSession\n\n            packetID = self.sendSMB(packet)\n            ans = self.recvSMB(packetID)\n            if ans.isValidAnswer(STATUS_SUCCESS):\n                negResp = SMB2Negotiate_Response(ans['Data'])\n                if negResp['DialectRevision']  == SMB2_DIALECT_311:\n                    self.__UpdateConnectionPreAuthHash(ans.rawData)\n\n        self._Connection['MaxTransactSize']   = min(0x100000,negResp['MaxTransactSize'])\n        self._Connection['MaxReadSize']       = min(0x100000,negResp['MaxReadSize'])\n        self._Connection['MaxWriteSize']      = min(0x100000,negResp['MaxWriteSize'])\n        self._Connection['ServerGuid']        = negResp['ServerGuid']\n        self._Connection['GSSNegotiateToken'] = negResp['Buffer']\n        self._Connection['Dialect']           = negResp['DialectRevision']\n\n        if (negResp['SecurityMode'] & SMB2_NEGOTIATE_SIGNING_REQUIRED) == SMB2_NEGOTIATE_SIGNING_REQUIRED or \\\n                self._Connection['Dialect'] == SMB2_DIALECT_311:\n            self._Connection['RequireSigning'] = True\n        if self._Connection['Dialect'] == SMB2_DIALECT_311:\n            # Always Sign\n            self._Connection['RequireSigning'] = True\n            negContextCount = negResp['NegotiateContextCount']\n            # Process the Contexts as specified in section 3.2.5.2\n            if negContextCount > 0:\n                self.processContextList(negContextCount, negResp['NegotiateContextList'])\n\n        if (negResp['Capabilities'] & SMB2_GLOBAL_CAP_LEASING) == SMB2_GLOBAL_CAP_LEASING:\n            self._Connection['SupportsFileLeasing'] = True\n        if (negResp['Capabilities'] & SMB2_GLOBAL_CAP_LARGE_MTU) == SMB2_GLOBAL_CAP_LARGE_MTU:\n            self._Connection['SupportsMultiCredit'] = True\n\n        if self._Connection['Dialect'] >= SMB2_DIALECT_30:\n            # Switching to the right packet format\n            self.SMB_PACKET = SMB3Packet\n            if (negResp['Capabilities'] & SMB2_GLOBAL_CAP_DIRECTORY_LEASING) == SMB2_GLOBAL_CAP_DIRECTORY_LEASING:\n                self._Connection['SupportsDirectoryLeasing'] = True\n            if (negResp['Capabilities'] & SMB2_GLOBAL_CAP_MULTI_CHANNEL) == SMB2_GLOBAL_CAP_MULTI_CHANNEL:\n                self._Connection['SupportsMultiChannel'] = True\n            if (negResp['Capabilities'] & SMB2_GLOBAL_CAP_PERSISTENT_HANDLES) == SMB2_GLOBAL_CAP_PERSISTENT_HANDLES:\n                self._Connection['SupportsPersistentHandles'] = True\n            if (negResp['Capabilities'] & SMB2_GLOBAL_CAP_ENCRYPTION) == SMB2_GLOBAL_CAP_ENCRYPTION:\n                self._Connection['SupportsEncryption'] = True\n\n            self._Connection['ServerCapabilities'] = negResp['Capabilities']\n            self._Connection['ServerSecurityMode'] = negResp['SecurityMode']\n\n    def getCredentials(self):\n        return (\n            self.__userName,\n            self.__password,\n            self.__domain,\n            self.__lmhash,\n            self.__nthash,\n            self.__aesKey,\n            self.__TGT,\n            self.__TGS)\n\n    def kerberosLogin(self, user, password, domain = '', lmhash = '', nthash = '', aesKey='', kdcHost = '', TGT=None, TGS=None, mutualAuth=False):\n        # If TGT or TGS are specified, they are in the form of:\n        # TGS['KDC_REP'] = the response from the server\n        # TGS['cipher'] = the cipher used\n        # TGS['sessionKey'] = the sessionKey\n        # If we have hashes, normalize them\n        if lmhash != '' or nthash != '':\n            if len(lmhash) % 2:     lmhash = '0%s' % lmhash\n            if len(nthash) % 2:     nthash = '0%s' % nthash\n            try: # just in case they were converted already\n                lmhash = a2b_hex(lmhash)\n                nthash = a2b_hex(nthash)\n            except:\n                pass\n\n        self.__userName = user\n        self.__password = password\n        self.__domain   = domain\n        self.__lmhash   = lmhash\n        self.__nthash   = nthash\n        self.__kdc      = kdcHost\n        self.__aesKey   = aesKey\n        self.__TGT      = TGT\n        self.__TGS      = TGS\n        self._doKerberos= True\n\n        sessionSetup = SMB2SessionSetup()\n        if self.RequireMessageSigning is True:\n           sessionSetup['SecurityMode'] = SMB2_NEGOTIATE_SIGNING_REQUIRED\n        else:\n           sessionSetup['SecurityMode'] = SMB2_NEGOTIATE_SIGNING_ENABLED\n\n        sessionSetup['Flags'] = 0\n        #sessionSetup['Capabilities'] = SMB2_GLOBAL_CAP_LARGE_MTU | SMB2_GLOBAL_CAP_LEASING | SMB2_GLOBAL_CAP_DFS\n\n        # Importing down here so pyasn1 is not required if kerberos is not used.\n        from impacket.krb5.asn1 import AP_REQ, Authenticator, TGS_REP, seq_set\n        from impacket.krb5.kerberosv5 import getKerberosTGT, getKerberosTGS\n        from impacket.krb5 import constants\n        from impacket.krb5.types import Principal, KerberosTime, Ticket\n        from pyasn1.codec.der import decoder, encoder\n        import datetime\n\n        # First of all, we need to get a TGT for the user\n        userName = Principal(user, type=constants.PrincipalNameType.NT_PRINCIPAL.value)\n        if TGT is None:\n            if TGS is None:\n                tgt, cipher, oldSessionKey, sessionKey = getKerberosTGT(userName, password, domain, lmhash, nthash, aesKey, kdcHost)\n        else:\n            tgt = TGT['KDC_REP']\n            cipher = TGT['cipher']\n            sessionKey = TGT['sessionKey']\n\n        # Save the ticket\n        # If you want, for debugging purposes\n#        from impacket.krb5.ccache import CCache\n#        ccache = CCache()\n#        try:\n#            if TGS is None:\n#                ccache.fromTGT(tgt, oldSessionKey, sessionKey)\n#            else:\n#                ccache.fromTGS(TGS['KDC_REP'], TGS['oldSessionKey'], TGS['sessionKey'] )\n#            ccache.saveFile('/tmp/ticket.bin')\n#        except Exception, e:\n#            print e\n#            pass\n\n        # Now that we have the TGT, we should ask for a TGS for cifs\n\n        if TGS is None:\n            serverName = Principal('cifs/%s' % (self._Connection['ServerName']), type=constants.PrincipalNameType.NT_SRV_INST.value)\n            tgs, cipher, oldSessionKey, sessionKey = getKerberosTGS(serverName, domain, kdcHost, tgt, cipher, sessionKey)\n        else:\n            tgs = TGS['KDC_REP']\n            cipher = TGS['cipher']\n            sessionKey = TGS['sessionKey']\n\n        # Let's build a NegTokenInit with a Kerberos REQ_AP\n\n        blob = SPNEGO_NegTokenInit()\n\n        # Kerberos\n        blob['MechTypes'] = [TypesMech['MS KRB5 - Microsoft Kerberos 5']]\n\n        # Let's extract the ticket from the TGS\n        tgs = decoder.decode(tgs, asn1Spec = TGS_REP())[0]\n        ticket = Ticket()\n        ticket.from_asn1(tgs['ticket'])\n\n        # Now let's build the AP_REQ\n        apReq = AP_REQ()\n        apReq['pvno'] = 5\n        apReq['msg-type'] = int(constants.ApplicationTagNumbers.AP_REQ.value)\n\n        #Handle mutual authentication\n        opts = list()\n\n        if mutualAuth == True:\n            from impacket.krb5.constants import APOptions\n            opts.append(constants.APOptions.mutual_required.value)\n\n        apReq['ap-options'] = constants.encodeFlags(opts)\n        seq_set(apReq,'ticket', ticket.to_asn1)\n\n        authenticator = Authenticator()\n        authenticator['authenticator-vno'] = 5\n        authenticator['crealm'] = domain\n        seq_set(authenticator, 'cname', userName.components_to_asn1)\n        now = datetime.datetime.utcnow()\n\n        authenticator['cusec'] = now.microsecond\n        authenticator['ctime'] = KerberosTime.to_asn1(now)\n\n        encodedAuthenticator = encoder.encode(authenticator)\n\n        # Key Usage 11\n        # AP-REQ Authenticator (includes application authenticator\n        # subkey), encrypted with the application session key\n        # (Section 5.5.1)\n        encryptedEncodedAuthenticator = cipher.encrypt(sessionKey, 11, encodedAuthenticator, None)\n\n        apReq['authenticator'] = noValue\n        apReq['authenticator']['etype'] = cipher.enctype\n        apReq['authenticator']['cipher'] = encryptedEncodedAuthenticator\n\n        blob['MechToken'] = struct.pack('B', ASN1_AID) + asn1encode( struct.pack('B', ASN1_OID) + asn1encode(\n            TypesMech['KRB5 - Kerberos 5'] ) + KRB5_AP_REQ + encoder.encode(apReq))\n\n        sessionSetup['SecurityBufferLength'] = len(blob)\n        sessionSetup['Buffer']               = blob.getData()\n\n        packet = self.SMB_PACKET()\n        packet['Command'] = SMB2_SESSION_SETUP\n        packet['Data']    = sessionSetup\n\n        #Initiate session preauth hash\n        self._Session['PreauthIntegrityHashValue'] = self._Connection['PreauthIntegrityHashValue']\n\n        packetID = self.sendSMB(packet)\n        ans = self.recvSMB(packetID)\n        if ans.isValidAnswer(STATUS_SUCCESS):\n            self._Session['SessionID']       = ans['SessionID']\n            self._Session['SigningRequired'] = self._Connection['RequireSigning']\n            self._Session['UserCredentials'] = (user, password, domain, lmhash, nthash)\n            self._Session['Connection']      = self._NetBIOSSession.get_socket()\n\n\n            if mutualAuth == True:\n                #Lets get the session key in the AP_REP\n                from impacket.krb5.asn1 import AP_REP, EncAPRepPart\n                from impacket.krb5.crypto import Key, _enctype_table\n                smbSessSetupResp = SMB2SessionSetup_Response(ans['Data'])\n\n                #in [KILE] 3.1.1.2:\n                #    The subkey in the EncAPRepPart of the KRB_AP_REP message is used as the session key when\n                #    MutualAuthentication is requested. (The KRB_AP_REP message and its fields are defined in [RFC4120]\n                #    section 5.5.2.) When DES and RC4 are used, the implementation is as described in [RFC1964]. With\n                #    DES and RC4, the subkey in the KRB_AP_REQ message can be used as the session key, as it is the\n                #    same as the subkey in KRB_AP_REP message; however when AES is used (see [RFC4121]), the\n                #    subkeys are different and the subkey in the KRB_AP_REP is used. (The KRB_AP_REQ message is\n                #    defined in [RFC4120] section 5.5.1).\n                negTokenResp = SPNEGO_NegTokenResp(smbSessSetupResp['Buffer'])\n\n                #TODO: Parse ResponseToken as krb5Blob depending on the supported mech indicated in the negTokenResp\n                ap_rep = decoder.decode(negTokenResp['ResponseToken'][16:], asn1Spec=AP_REP())[0]\n\n                if cipher.enctype != ap_rep['enc-part']['etype']:\n                    raise Exception('Unable to decrypt AP_REP: cipher does not match TGS session key')\n\n                # Key Usage 12\n                # AP-REP encrypted part (includes application session\n                # subkey), encrypted with the application session key\n                # (Section 5.5.2)\n                cipherText = ap_rep['enc-part']['cipher']\n                plainText = cipher.decrypt(sessionKey, 12, cipherText)\n\n                encAPRepPart = decoder.decode(plainText, asn1Spec = EncAPRepPart())[0]\n\n                apCipher = _enctype_table[int(encAPRepPart['subkey']['keytype'])]()\n                apSessionKey = Key(apCipher.enctype, encAPRepPart['subkey']['keyvalue'].asOctets())\n\n                sequenceNumber = int(encAPRepPart['seq-number'])\n                self._Session['SessionKey'] = apSessionKey.contents\n\n            else:\n                self._Session['SessionKey']  = sessionKey.contents[:16]\n\n            if self._Session['SigningRequired'] is True and self._Connection['Dialect'] >= SMB2_DIALECT_30:\n                # If Connection.Dialect is \"3.1.1\", the case-sensitive ASCII string \"SMBSigningKey\" as the label;\n                # otherwise, the case - sensitive ASCII string \"SMB2AESCMAC\" as the label.\n                # If Connection.Dialect is \"3.1.1\", Session.PreauthIntegrityHashValue as the context; otherwise,\n                # the case-sensitive ASCII string \"SmbSign\" as context for the algorithm.\n                if self._Connection['Dialect'] == SMB2_DIALECT_311:\n                    self._Session['SigningKey'] = crypto.KDF_CounterMode (self._Session['SessionKey'], b\"SMBSigningKey\\x00\",\n                                                                          self._Session['PreauthIntegrityHashValue'], 128)\n                else:\n                    self._Session['SigningKey'] = crypto.KDF_CounterMode (self._Session['SessionKey'], b\"SMB2AESCMAC\\x00\",\n                                                                          b\"SmbSign\\x00\", 128)\n\n            # Do not encrypt anonymous connections\n            if user == '' or self.isGuestSession():\n                self._Connection['SupportsEncryption'] = False\n\n            if self._Session['SigningRequired'] is True:\n                self._Session['SigningActivated'] = True\n            if self._Connection['Dialect'] >= SMB2_DIALECT_30 and self._Connection['SupportsEncryption'] is True:\n                # Encryption available. Let's enforce it if we have AES CCM available\n                self._Session['SessionFlags'] |= SMB2_SESSION_FLAG_ENCRYPT_DATA\n                # Application Key\n                # If Connection.Dialect is \"3.1.1\",the case-sensitive ASCII string \"SMBAppKey\" as the label;\n                # otherwise, the case-sensitive ASCII string \"SMB2APP\" as the label. Session.PreauthIntegrityHashValue\n                # as the context; otherwise, the case-sensitive ASCII string \"SmbRpc\" as context for the algorithm.\n                # Encryption Key\n                # If Connection.Dialect is \"3.1.1\",the case-sensitive ASCII string \"SMBC2SCipherKey\" as # the label;\n                # otherwise, the case-sensitive ASCII string \"SMB2AESCCM\" as the label. Session.PreauthIntegrityHashValue\n                # as the context; otherwise, the case-sensitive ASCII string \"ServerIn \" as context for the algorithm\n                # (note the blank space at the end)\n                # Decryption Key\n                # If Connection.Dialect is \"3.1.1\", the case-sensitive ASCII string \"SMBS2CCipherKey\" as the label;\n                # otherwise, the case-sensitive ASCII string \"SMB2AESCCM\" as the label. Session.PreauthIntegrityHashValue\n                # as the context; otherwise, the case-sensitive ASCII string \"ServerOut\" as context for the algorithm.\n                if self._Connection['Dialect'] == SMB2_DIALECT_311:\n                    self._Session['ApplicationKey'] = crypto.KDF_CounterMode (self._Session['SessionKey'], b\"SMBAppKey\\x00\",\n                                                                              self._Session['PreauthIntegrityHashValue'], 128)\n                    self._Session['EncryptionKey'] = crypto.KDF_CounterMode (self._Session['SessionKey'], b\"SMBC2SCipherKey\\x00\",\n                                                                             self._Session['PreauthIntegrityHashValue'], 128)\n                    self._Session['DecryptionKey'] = crypto.KDF_CounterMode (self._Session['SessionKey'], b\"SMBS2CCipherKey\\x00\",\n                                                                             self._Session['PreauthIntegrityHashValue'], 128)\n                else:\n                    self._Session['ApplicationKey'] = crypto.KDF_CounterMode (self._Session['SessionKey'], b\"SMB2APP\\x00\",\n                                                                              b\"SmbRpc\\x00\", 128)\n                    self._Session['EncryptionKey'] = crypto.KDF_CounterMode (self._Session['SessionKey'], b\"SMB2AESCCM\\x00\",\n                                                                             b\"ServerIn \\x00\", 128)\n                    self._Session['DecryptionKey'] = crypto.KDF_CounterMode (self._Session['SessionKey'], b\"SMB2AESCCM\\x00\",\n                                                                             b\"ServerOut\\x00\", 128)\n\n            self._Session['CalculatePreAuthHash'] = False\n            return True\n        else:\n            # We clean the stuff we used in case we want to authenticate again\n            # within the same connection\n            self._Session['UserCredentials']   = ''\n            self._Session['Connection']        = 0\n            self._Session['SessionID']         = 0\n            self._Session['SigningRequired']   = False\n            self._Session['SigningKey']        = ''\n            self._Session['SessionKey']        = ''\n            self._Session['SigningActivated']  = False\n            self._Session['CalculatePreAuthHash'] = False\n            self._Session['PreauthIntegrityHashValue'] = a2b_hex(b'0'*128)\n            raise Exception('Unsuccessful Login')\n\n\n    def login(self, user, password, domain = '', lmhash = '', nthash = ''):\n        # If we have hashes, normalize them\n        if lmhash != '' or nthash != '':\n            if len(lmhash) % 2:     lmhash = '0%s' % lmhash\n            if len(nthash) % 2:     nthash = '0%s' % nthash\n            try: # just in case they were converted already\n                lmhash = a2b_hex(lmhash)\n                nthash = a2b_hex(nthash)\n            except:\n                pass\n\n        self.__userName = user\n        self.__password = password\n        self.__domain   = domain\n        self.__lmhash   = lmhash\n        self.__nthash   = nthash\n        self.__aesKey   = ''\n        self.__TGT      = None\n        self.__TGS      = None\n\n        sessionSetup = SMB2SessionSetup()\n        if self.RequireMessageSigning is True:\n           sessionSetup['SecurityMode'] = SMB2_NEGOTIATE_SIGNING_REQUIRED\n        else:\n           sessionSetup['SecurityMode'] = SMB2_NEGOTIATE_SIGNING_ENABLED\n\n        sessionSetup['Flags'] = 0\n        #sessionSetup['Capabilities'] = SMB2_GLOBAL_CAP_LARGE_MTU | SMB2_GLOBAL_CAP_LEASING | SMB2_GLOBAL_CAP_DFS\n\n        # Let's build a NegTokenInit with the NTLMSSP\n        # TODO: In the future we should be able to choose different providers\n\n        blob = SPNEGO_NegTokenInit()\n\n        # NTLMSSP\n        blob['MechTypes'] = [TypesMech['NTLMSSP - Microsoft NTLM Security Support Provider']]\n        auth = ntlm.getNTLMSSPType1(self._Connection['ClientName'],domain, self._Connection['RequireSigning'])\n        blob['MechToken'] = auth.getData()\n\n        sessionSetup['SecurityBufferLength'] = len(blob)\n        sessionSetup['Buffer']               = blob.getData()\n\n        # ToDo:\n        # If this authentication is for establishing an alternative channel for an existing Session, as specified\n        # in section 3.2.4.1.7, the client MUST also set the following values:\n        # The SessionId field in the SMB2 header MUST be set to the Session.SessionId for the new\n        # channel being established.\n        # The SMB2_SESSION_FLAG_BINDING bit MUST be set in the Flags field.\n        # The PreviousSessionId field MUST be set to zero.\n\n        packet = self.SMB_PACKET()\n        packet['Command'] = SMB2_SESSION_SETUP\n        packet['Data']    = sessionSetup\n\n        # Initiate session preauth hash\n        self._Session['PreauthIntegrityHashValue'] = self._Connection['PreauthIntegrityHashValue']\n\n        packetID = self.sendSMB(packet)\n        ans = self.recvSMB(packetID)\n        if self._Connection['Dialect'] == SMB2_DIALECT_311:\n            self.__UpdatePreAuthHash (ans.rawData)\n\n        if ans.isValidAnswer(STATUS_MORE_PROCESSING_REQUIRED):\n            self._Session['SessionID']       = ans['SessionID']\n            self._Session['SigningRequired'] = self._Connection['RequireSigning']\n            self._Session['UserCredentials'] = (user, password, domain, lmhash, nthash)\n            self._Session['Connection']      = self._NetBIOSSession.get_socket()\n            sessionSetupResponse = SMB2SessionSetup_Response(ans['Data'])\n            respToken = SPNEGO_NegTokenResp(sessionSetupResponse['Buffer'])\n\n            # Let's parse some data and keep it to ourselves in case it is asked\n            ntlmChallenge = ntlm.NTLMAuthChallenge(respToken['ResponseToken'])\n            if ntlmChallenge['TargetInfoFields_len'] > 0:\n                av_pairs = ntlm.AV_PAIRS(ntlmChallenge['TargetInfoFields'][:ntlmChallenge['TargetInfoFields_len']])\n                if av_pairs[ntlm.NTLMSSP_AV_HOSTNAME] is not None:\n                   try:\n                       self._Session['ServerName'] = av_pairs[ntlm.NTLMSSP_AV_HOSTNAME][1].decode('utf-16le')\n                   except:\n                       # For some reason, we couldn't decode Unicode here.. silently discard the operation\n                       pass\n                if av_pairs[ntlm.NTLMSSP_AV_DOMAINNAME] is not None:\n                   try:\n                       if self._Session['ServerName'] != av_pairs[ntlm.NTLMSSP_AV_DOMAINNAME][1].decode('utf-16le'):\n                           self._Session['ServerDomain'] = av_pairs[ntlm.NTLMSSP_AV_DOMAINNAME][1].decode('utf-16le')\n                   except:\n                       # For some reason, we couldn't decode Unicode here.. silently discard the operation\n                       pass\n                if av_pairs[ntlm.NTLMSSP_AV_DNS_DOMAINNAME] is not None:\n                   try:\n                       self._Session['ServerDNSDomainName'] = av_pairs[ntlm.NTLMSSP_AV_DNS_DOMAINNAME][1].decode('utf-16le')\n                   except:\n                       # For some reason, we couldn't decode Unicode here.. silently discard the operation\n                       pass\n\n                if av_pairs[ntlm.NTLMSSP_AV_DNS_HOSTNAME] is not None:\n                   try:\n                       self._Session['ServerDNSHostName'] = av_pairs[ntlm.NTLMSSP_AV_DNS_HOSTNAME][1].decode('utf-16le')\n                   except:\n                       # For some reason, we couldn't decode Unicode here.. silently discard the operation\n                       pass\n\n                if self._strict_hostname_validation:\n                    self.perform_hostname_validation()\n\n                # Parse Version to know the target Operating system name. Not provided elsewhere anymore\n                if 'Version' in ntlmChallenge.fields:\n                    version = ntlmChallenge['Version']\n\n                    if len(version) >= 4:\n                        self._Session['ServerOS'] = \"Windows %d.%d Build %d\" % (indexbytes(version,0), indexbytes(version,1), struct.unpack('<H',version[2:4])[0])\n                        self._Session[\"ServerOSMajor\"] = indexbytes(version,0)\n                        self._Session[\"ServerOSMinor\"] = indexbytes(version,1)\n                        self._Session[\"ServerOSBuild\"] = struct.unpack('<H',version[2:4])[0]\n\n            type3, exportedSessionKey = ntlm.getNTLMSSPType3(auth, respToken['ResponseToken'], user, password, domain, lmhash, nthash)\n\n\n\n            respToken2 = SPNEGO_NegTokenResp()\n            respToken2['ResponseToken'] = type3.getData()\n\n            # Reusing the previous structure\n            sessionSetup['SecurityBufferLength'] = len(respToken2)\n            sessionSetup['Buffer']               = respToken2.getData()\n\n            packetID = self.sendSMB(packet)\n            packet = self.recvSMB(packetID)\n\n            # Let's calculate Key Materials before moving on\n            if exportedSessionKey is not None:\n                self._Session['SessionKey']  = exportedSessionKey\n                if self._Session['SigningRequired'] is True and self._Connection['Dialect'] >= SMB2_DIALECT_30:\n                    # If Connection.Dialect is \"3.1.1\", the case-sensitive ASCII string \"SMBSigningKey\" as the label;\n                    # otherwise, the case - sensitive ASCII string \"SMB2AESCMAC\" as the label.\n                    # If Connection.Dialect is \"3.1.1\", Session.PreauthIntegrityHashValue as the context; otherwise,\n                    # the case-sensitive ASCII string \"SmbSign\" as context for the algorithm.\n                    if self._Connection['Dialect'] == SMB2_DIALECT_311:\n                        self._Session['SigningKey'] = crypto.KDF_CounterMode (exportedSessionKey,\n                                                                              b\"SMBSigningKey\\x00\",\n                                                                              self._Session['PreauthIntegrityHashValue'],\n                                                                              128)\n                    else:\n                        self._Session['SigningKey'] = crypto.KDF_CounterMode (exportedSessionKey, b\"SMB2AESCMAC\\x00\",\n                                                                              b\"SmbSign\\x00\", 128)\n            try:\n                if packet.isValidAnswer(STATUS_SUCCESS):\n                    sessionSetupResponse = SMB2SessionSetup_Response(packet['Data'])\n                    self._Session['SessionFlags'] = sessionSetupResponse['SessionFlags']\n                    self._Session['SessionID']    = packet['SessionID']\n\n                    # Do not encrypt anonymous connections\n                    if user == '' or self.isGuestSession():\n                        self._Connection['SupportsEncryption'] = False\n\n                    # Calculate the key derivations for dialect 3.0\n                    if self._Session['SigningRequired'] is True:\n                        self._Session['SigningActivated'] = True\n                    if self._Connection['Dialect'] >= SMB2_DIALECT_30 and self._Connection['SupportsEncryption'] is True:\n                        # SMB 3.0. Encryption available. Let's enforce it if we have AES CCM available\n                        self._Session['SessionFlags'] |= SMB2_SESSION_FLAG_ENCRYPT_DATA\n                        # Application Key\n                        # If Connection.Dialect is \"3.1.1\",the case-sensitive ASCII string \"SMBAppKey\" as the label;\n                        # otherwise, the case-sensitive ASCII string \"SMB2APP\" as the label. Session.PreauthIntegrityHashValue\n                        # as the context; otherwise, the case-sensitive ASCII string \"SmbRpc\" as context for the algorithm.\n                        # Encryption Key\n                        # If Connection.Dialect is \"3.1.1\",the case-sensitive ASCII string \"SMBC2SCipherKey\" as # the label;\n                        # otherwise, the case-sensitive ASCII string \"SMB2AESCCM\" as the label. Session.PreauthIntegrityHashValue\n                        # as the context; otherwise, the case-sensitive ASCII string \"ServerIn \" as context for the algorithm\n                        # (note the blank space at the end)\n                        # Decryption Key\n                        # If Connection.Dialect is \"3.1.1\", the case-sensitive ASCII string \"SMBS2CCipherKey\" as the label;\n                        # otherwise, the case-sensitive ASCII string \"SMB2AESCCM\" as the label. Session.PreauthIntegrityHashValue\n                        # as the context; otherwise, the case-sensitive ASCII string \"ServerOut\" as context for the algorithm.\n                        if self._Connection['Dialect'] == SMB2_DIALECT_311:\n                            self._Session['ApplicationKey']  = crypto.KDF_CounterMode(exportedSessionKey, b\"SMBAppKey\\x00\",\n                                                                             self._Session['PreauthIntegrityHashValue'], 128)\n                            self._Session['EncryptionKey']   = crypto.KDF_CounterMode(exportedSessionKey, b\"SMBC2SCipherKey\\x00\",\n                                                                             self._Session['PreauthIntegrityHashValue'], 128)\n                            self._Session['DecryptionKey'] = crypto.KDF_CounterMode (exportedSessionKey, b\"SMBS2CCipherKey\\x00\",\n                                                                             self._Session['PreauthIntegrityHashValue'], 128)\n\n                        else:\n                            self._Session['ApplicationKey'] = crypto.KDF_CounterMode (exportedSessionKey, b\"SMB2APP\\x00\",\n                                                                                      b\"SmbRpc\\x00\", 128)\n                            self._Session['EncryptionKey'] = crypto.KDF_CounterMode (exportedSessionKey, b\"SMB2AESCCM\\x00\",\n                                                                                     b\"ServerIn \\x00\", 128)\n                            self._Session['DecryptionKey'] = crypto.KDF_CounterMode (exportedSessionKey, b\"SMB2AESCCM\\x00\",\n                                                                                     b\"ServerOut\\x00\", 128)\n                    self._Session['CalculatePreAuthHash'] = False\n                    return True\n            except:\n                # We clean the stuff we used in case we want to authenticate again\n                # within the same connection\n                self._Session['UserCredentials']   = ''\n                self._Session['Connection']        = 0\n                self._Session['SessionID']         = 0\n                self._Session['SigningRequired']   = False\n                self._Session['SigningKey']        = ''\n                self._Session['SessionKey']        = ''\n                self._Session['SigningActivated']  = False\n                self._Session['CalculatePreAuthHash'] = False\n                self._Session['PreauthIntegrityHashValue'] = a2b_hex(b'0'*128)\n                raise\n\n    def connectTree(self, share):\n\n        # Just in case this came with the full path (maybe an SMB1 client), let's just leave\n        # the sharename, we'll take care of the rest\n\n        #print self._Session['TreeConnectTable']\n        share = share.split('\\\\')[-1]\n        if share in self._Session['TreeConnectTable']:\n            # Already connected, no need to reconnect\n            treeEntry =  self._Session['TreeConnectTable'][share]\n            treeEntry['NumberOfUses'] += 1\n            self._Session['TreeConnectTable'][treeEntry['TreeConnectId']]['NumberOfUses'] += 1\n            return treeEntry['TreeConnectId']\n\n        #path = share\n        try:\n            _, _, _, _, sockaddr = socket.getaddrinfo(self._Connection['ServerIP'], 80, 0, 0, socket.IPPROTO_TCP)[0]\n            remoteHost = sockaddr[0]\n        except:\n            remoteHost = self._Connection['ServerIP']\n        path = '\\\\\\\\' + remoteHost + '\\\\' +share\n\n        treeConnect = SMB2TreeConnect()\n        treeConnect['Buffer']     = path.encode('utf-16le')\n        treeConnect['PathLength'] = len(path)*2\n\n        packet = self.SMB_PACKET()\n        packet['Command'] = SMB2_TREE_CONNECT\n        packet['Data'] = treeConnect\n        packetID = self.sendSMB(packet)\n        packet = self.recvSMB(packetID)\n        if packet.isValidAnswer(STATUS_SUCCESS):\n           treeConnectResponse = SMB2TreeConnect_Response(packet['Data'])\n           treeEntry = copy.deepcopy(TREE_CONNECT)\n           treeEntry['ShareName']     = share\n           treeEntry['TreeConnectId'] = packet['TreeID']\n           treeEntry['Session']       = packet['SessionID']\n           treeEntry['NumberOfUses'] += 1\n           if (treeConnectResponse['Capabilities'] & SMB2_SHARE_CAP_DFS) == SMB2_SHARE_CAP_DFS:\n               treeEntry['IsDfsShare'] = True\n           if (treeConnectResponse['Capabilities'] & SMB2_SHARE_CAP_CONTINUOUS_AVAILABILITY) == SMB2_SHARE_CAP_CONTINUOUS_AVAILABILITY:\n               treeEntry['IsCAShare'] = True\n\n           if self._Connection['Dialect'] >= SMB2_DIALECT_30:\n               if (self._Connection['SupportsEncryption'] is True) and ((treeConnectResponse['ShareFlags'] & SMB2_SHAREFLAG_ENCRYPT_DATA) == SMB2_SHAREFLAG_ENCRYPT_DATA):\n                   treeEntry['EncryptData'] = True\n                   # ToDo: This and what follows\n                   # If Session.EncryptData is FALSE, the client MUST then generate an encryption key, a\n                   # decryption key as specified in section 3.1.4.2, by providing the following inputs and store\n                   # them in Session.EncryptionKey and Session.DecryptionKey:\n               if (treeConnectResponse['Capabilities'] & SMB2_SHARE_CAP_SCALEOUT) == SMB2_SHARE_CAP_SCALEOUT:\n                   treeEntry['IsScaleoutShare'] = True\n\n           self._Session['TreeConnectTable'][packet['TreeID']] = treeEntry\n           self._Session['TreeConnectTable'][share]            = treeEntry\n\n           return packet['TreeID']\n\n    def disconnectTree(self, treeId):\n        if (treeId in self._Session['TreeConnectTable']) is False:\n            raise SessionError(STATUS_INVALID_PARAMETER)\n\n        if treeId in self._Session['TreeConnectTable']:\n            # More than 1 use? descrease it and return, if not, send the packet\n            if self._Session['TreeConnectTable'][treeId]['NumberOfUses'] > 1:\n                treeEntry =  self._Session['TreeConnectTable'][treeId]\n                treeEntry['NumberOfUses'] -= 1\n                self._Session['TreeConnectTable'][treeEntry['ShareName']]['NumberOfUses'] -= 1\n                return True\n\n        packet = self.SMB_PACKET()\n        packet['Command'] = SMB2_TREE_DISCONNECT\n        packet['TreeID'] = treeId\n        treeDisconnect = SMB2TreeDisconnect()\n        packet['Data'] = treeDisconnect\n        packetID = self.sendSMB(packet)\n        packet = self.recvSMB(packetID)\n        if packet.isValidAnswer(STATUS_SUCCESS):\n            shareName = self._Session['TreeConnectTable'][treeId]['ShareName']\n            del(self._Session['TreeConnectTable'][shareName])\n            del(self._Session['TreeConnectTable'][treeId])\n            filesIDToBeRemoved = []\n            for fileID in list(self._Session['OpenTable'].keys()):\n                if self._Session['OpenTable'][fileID]['TreeConnect'] == treeId:\n                    filesIDToBeRemoved.append(fileID)\n            for fileIDToBeRemoved in filesIDToBeRemoved:\n                del(self._Session['OpenTable'][fileIDToBeRemoved])\n            return True\n\n    def create(self, treeId, fileName, desiredAccess, shareMode, creationOptions, creationDisposition, fileAttributes, impersonationLevel = SMB2_IL_IMPERSONATION, securityFlags = 0, oplockLevel = SMB2_OPLOCK_LEVEL_NONE, createContexts = None):\n        if (treeId in self._Session['TreeConnectTable']) is False:\n            raise SessionError(STATUS_INVALID_PARAMETER)\n\n        fileName = fileName.replace('/', '\\\\')\n        if len(fileName) > 0:\n            fileName = ntpath.normpath(fileName)\n            if fileName[0] == '\\\\':\n                fileName = fileName[1:]\n\n        if self._Session['TreeConnectTable'][treeId]['IsDfsShare'] is True:\n            pathName = fileName\n        else:\n            pathName = '\\\\\\\\' + self._Connection['ServerName'] + '\\\\' + fileName\n\n        fileEntry = copy.deepcopy(FILE)\n        fileEntry['LeaseKey']   = uuid.generate()\n        fileEntry['LeaseState'] = SMB2_LEASE_NONE\n        self.GlobalFileTable[pathName] = fileEntry\n\n        if self._Connection['Dialect'] >= SMB2_DIALECT_30 and self._Connection['SupportsDirectoryLeasing'] is True:\n           # Is this file NOT on the root directory?\n           if len(fileName.split('\\\\')) > 2:\n               parentDir = ntpath.dirname(pathName)\n           if parentDir in self.GlobalFileTable:\n               raise Exception(\"Don't know what to do now! :-o\")\n           else:\n               parentEntry = copy.deepcopy(FILE)\n               parentEntry['LeaseKey']   = uuid.generate()\n               parentEntry['LeaseState'] = SMB2_LEASE_NONE\n               self.GlobalFileTable[parentDir] = parentEntry\n\n        packet = self.SMB_PACKET()\n        packet['Command'] = SMB2_CREATE\n        packet['TreeID']  = treeId\n        if self._Session['TreeConnectTable'][treeId]['IsDfsShare'] is True:\n            packet['Flags'] = SMB2_FLAGS_DFS_OPERATIONS\n\n        smb2Create = SMB2Create()\n        smb2Create['SecurityFlags']        = 0\n        smb2Create['RequestedOplockLevel'] = oplockLevel\n        smb2Create['ImpersonationLevel']   = impersonationLevel\n        smb2Create['DesiredAccess']        = desiredAccess\n        smb2Create['FileAttributes']       = fileAttributes\n        smb2Create['ShareAccess']          = shareMode\n        smb2Create['CreateDisposition']    = creationDisposition\n        smb2Create['CreateOptions']        = creationOptions\n\n        smb2Create['NameLength']           = len(fileName)*2\n        if fileName != '':\n            smb2Create['Buffer']           = fileName.encode('utf-16le')\n        else:\n            smb2Create['Buffer']           = b'\\x00'\n\n        if createContexts is not None:\n            contextsBuf = b''.join(x.getData() for x in createContexts)\n            smb2Create['CreateContextsOffset'] = len(SMB2Packet()) + SMB2Create.SIZE + len(smb2Create['Buffer'])\n\n            # pad offset to 8-byte align\n            if (smb2Create['CreateContextsOffset'] % 8):\n                smb2Create['Buffer'] += b'\\x00'*(8-(smb2Create['CreateContextsOffset'] % 8))\n                smb2Create['CreateContextsOffset'] = len(SMB2Packet()) + SMB2Create.SIZE + len(smb2Create['Buffer'])\n\n            smb2Create['CreateContextsLength'] = len(contextsBuf)\n            smb2Create['Buffer'] += contextsBuf\n        else:\n            smb2Create['CreateContextsOffset'] = 0\n            smb2Create['CreateContextsLength'] = 0\n\n        packet['Data'] = smb2Create\n\n        packetID = self.sendSMB(packet)\n        ans = self.recvSMB(packetID)\n        if ans.isValidAnswer(STATUS_SUCCESS):\n            createResponse = SMB2Create_Response(ans['Data'])\n\n            openFile = copy.deepcopy(OPEN)\n            openFile['FileID']      = createResponse['FileID']\n            openFile['TreeConnect'] = treeId\n            openFile['Oplocklevel'] = oplockLevel\n            openFile['Durable']     = False\n            openFile['ResilientHandle']    = False\n            openFile['LastDisconnectTime'] = 0\n            openFile['FileName'] = pathName\n\n            # ToDo: Complete the OperationBuckets\n            if self._Connection['Dialect'] >= SMB2_DIALECT_30:\n                openFile['DesiredAccess']     = oplockLevel\n                openFile['ShareMode']         = oplockLevel\n                openFile['CreateOptions']     = oplockLevel\n                openFile['FileAttributes']    = oplockLevel\n                openFile['CreateDisposition'] = oplockLevel\n\n            # ToDo: Process the contexts\n            self._Session['OpenTable'][createResponse['FileID'].getData()] = openFile\n\n            # The client MUST generate a handle for the Open, and it MUST\n            # return success and the generated handle to the calling application.\n            # In our case, str(FileID)\n            return createResponse['FileID'].getData()\n\n    def close(self, treeId, fileId):\n        if (treeId in self._Session['TreeConnectTable']) is False:\n            raise SessionError(STATUS_INVALID_PARAMETER)\n        if (fileId in self._Session['OpenTable']) is False:\n            raise SessionError(STATUS_INVALID_PARAMETER)\n\n        packet = self.SMB_PACKET()\n        packet['Command'] = SMB2_CLOSE\n        packet['TreeID']  = treeId\n\n        smbClose = SMB2Close()\n        smbClose['Flags']  = 0\n        smbClose['FileID'] = fileId\n\n        packet['Data'] = smbClose\n\n        packetID = self.sendSMB(packet)\n        ans = self.recvSMB(packetID)\n\n        if ans.isValidAnswer(STATUS_SUCCESS):\n            del(self.GlobalFileTable[self._Session['OpenTable'][fileId]['FileName']])\n            del(self._Session['OpenTable'][fileId])\n\n            # ToDo Remove stuff from GlobalFileTable\n            return True\n\n    def read(self, treeId, fileId, offset = 0, bytesToRead = 0, waitAnswer = True):\n        # IMPORTANT NOTE: As you can see, this was coded as a recursive function\n        # Hence, you can exhaust the memory pretty easy ( large bytesToRead )\n        # This function should NOT be used for reading files directly, but another higher\n        # level function should be used that will break the read into smaller pieces\n\n        if (treeId in self._Session['TreeConnectTable']) is False:\n            raise SessionError(STATUS_INVALID_PARAMETER)\n        if (fileId in self._Session['OpenTable']) is False:\n            raise SessionError(STATUS_INVALID_PARAMETER)\n\n        packet = self.SMB_PACKET()\n        packet['Command'] = SMB2_READ\n        packet['TreeID']  = treeId\n\n        if self._Connection['MaxReadSize'] < bytesToRead:\n            maxBytesToRead = self._Connection['MaxReadSize']\n        else:\n            maxBytesToRead = bytesToRead\n\n        if self._Connection['Dialect'] != SMB2_DIALECT_002 and self._Connection['SupportsMultiCredit'] is True:\n            packet['CreditCharge'] = ( 1 + (maxBytesToRead - 1) // 65536)\n        else:\n            maxBytesToRead = min(65536,bytesToRead)\n\n        smbRead = SMB2Read()\n        smbRead['Padding']  = 0x50\n        smbRead['FileID']   = fileId\n        smbRead['Length']   = maxBytesToRead\n        smbRead['Offset']   = offset\n        packet['Data'] = smbRead\n\n        packetID = self.sendSMB(packet)\n        ans = self.recvSMB(packetID)\n\n        if ans.isValidAnswer(STATUS_SUCCESS):\n            readResponse = SMB2Read_Response(ans['Data'])\n            retData = readResponse['Buffer']\n            if readResponse['DataRemaining'] > 0:\n                retData += self.read(treeId, fileId, offset+len(retData), readResponse['DataRemaining'], waitAnswer)\n            return retData\n\n    def write(self, treeId, fileId, data, offset = 0, bytesToWrite = 0, waitAnswer = True):\n        # IMPORTANT NOTE: As you can see, this was coded as a recursive function\n        # Hence, you can exhaust the memory pretty easy ( large bytesToWrite )\n        # This function should NOT be used for writing directly to files, but another higher\n        # level function should be used that will break the writes into smaller pieces\n\n        if (treeId in self._Session['TreeConnectTable']) is False:\n            raise SessionError(STATUS_INVALID_PARAMETER)\n        if (fileId in self._Session['OpenTable']) is False:\n            raise SessionError(STATUS_INVALID_PARAMETER)\n\n        packet = self.SMB_PACKET()\n        packet['Command'] = SMB2_WRITE\n        packet['TreeID']  = treeId\n\n        if self._Connection['MaxWriteSize'] < bytesToWrite:\n            maxBytesToWrite = self._Connection['MaxWriteSize']\n        else:\n            maxBytesToWrite = bytesToWrite\n\n        if self._Connection['Dialect'] != SMB2_DIALECT_002 and self._Connection['SupportsMultiCredit'] is True:\n            packet['CreditCharge'] = ( 1 + (maxBytesToWrite - 1) // 65536)\n        else:\n            maxBytesToWrite = min(65536,bytesToWrite)\n\n        smbWrite = SMB2Write()\n        smbWrite['FileID'] = fileId\n        smbWrite['Length'] = maxBytesToWrite\n        smbWrite['Offset'] = offset\n        smbWrite['WriteChannelInfoOffset'] = 0\n        smbWrite['Buffer'] = data[:maxBytesToWrite]\n        packet['Data'] = smbWrite\n\n        packetID = self.sendSMB(packet)\n        if waitAnswer is True:\n            ans = self.recvSMB(packetID)\n        else:\n            return maxBytesToWrite\n\n        if ans.isValidAnswer(STATUS_SUCCESS):\n            writeResponse = SMB2Write_Response(ans['Data'])\n            bytesWritten = writeResponse['Count']\n            if bytesWritten < bytesToWrite:\n                bytesWritten += self.write(treeId, fileId, data[bytesWritten:], offset+bytesWritten, bytesToWrite-bytesWritten, waitAnswer)\n            return bytesWritten\n\n    def queryDirectory(self, treeId, fileId, searchString = '*', resumeIndex = 0, informationClass = FILENAMES_INFORMATION, maxBufferSize = None, enumRestart = False, singleEntry = False):\n        if (treeId in self._Session['TreeConnectTable']) is False:\n            raise SessionError(STATUS_INVALID_PARAMETER)\n        if (fileId in self._Session['OpenTable']) is False:\n            raise SessionError(STATUS_INVALID_PARAMETER)\n\n        packet = self.SMB_PACKET()\n        packet['Command'] = SMB2_QUERY_DIRECTORY\n        packet['TreeID']  = treeId\n\n        queryDirectory = SMB2QueryDirectory()\n        queryDirectory['FileInformationClass'] = informationClass\n        if resumeIndex != 0 :\n            queryDirectory['Flags'] = SMB2_INDEX_SPECIFIED\n        queryDirectory['FileIndex'] = resumeIndex\n        queryDirectory['FileID']    = fileId\n        if maxBufferSize is None:\n            maxBufferSize = self._Connection['MaxReadSize']\n        queryDirectory['OutputBufferLength'] = maxBufferSize\n        queryDirectory['FileNameLength']     = len(searchString)*2\n        queryDirectory['Buffer']             = searchString.encode('utf-16le')\n\n        packet['Data'] = queryDirectory\n\n        if self._Connection['Dialect'] != SMB2_DIALECT_002 and self._Connection['SupportsMultiCredit'] is True:\n            packet['CreditCharge'] = ( 1 + (maxBufferSize - 1) // 65536)\n\n        packetID = self.sendSMB(packet)\n        ans = self.recvSMB(packetID)\n        if ans.isValidAnswer(STATUS_SUCCESS):\n            queryDirectoryResponse = SMB2QueryDirectory_Response(ans['Data'])\n            return queryDirectoryResponse['Buffer']\n\n    def echo(self):\n        packet = self.SMB_PACKET()\n        packet['Command'] = SMB2_ECHO\n        smbEcho = SMB2Echo()\n        packet['Data'] = smbEcho\n        packetID = self.sendSMB(packet)\n        ans = self.recvSMB(packetID)\n        if ans.isValidAnswer(STATUS_SUCCESS):\n            return True\n\n    def cancel(self, packetID):\n        packet = self.SMB_PACKET()\n        packet['Command']   = SMB2_CANCEL\n        packet['MessageID'] = packetID\n\n        smbCancel = SMB2Cancel()\n\n        packet['Data']      = smbCancel\n        self.sendSMB(packet)\n\n    def ioctl(self, treeId, fileId = None, ctlCode = -1, flags = 0, inputBlob = '',  maxInputResponse = None, maxOutputResponse = None, waitAnswer = 1):\n        if (treeId in self._Session['TreeConnectTable']) is False:\n            raise SessionError(STATUS_INVALID_PARAMETER)\n        if fileId is None:\n            fileId = '\\xff'*16\n        else:\n            if (fileId in self._Session['OpenTable']) is False:\n                raise SessionError(STATUS_INVALID_PARAMETER)\n\n        packet = self.SMB_PACKET()\n        packet['Command']            = SMB2_IOCTL\n        packet['TreeID']             = treeId\n\n        smbIoctl = SMB2Ioctl()\n        smbIoctl['FileID']             = fileId\n        smbIoctl['CtlCode']            = ctlCode\n        smbIoctl['MaxInputResponse']   = maxInputResponse\n        smbIoctl['MaxOutputResponse']  = maxOutputResponse\n        smbIoctl['InputCount']         = len(inputBlob)\n        if len(inputBlob) == 0:\n            smbIoctl['InputOffset'] = 0\n            smbIoctl['Buffer']      = '\\x00'\n        else:\n            smbIoctl['Buffer']             = inputBlob\n        smbIoctl['OutputOffset']       = 0\n        smbIoctl['MaxOutputResponse']  = maxOutputResponse\n        smbIoctl['Flags']              = flags\n\n        packet['Data'] = smbIoctl\n\n        packetID = self.sendSMB(packet)\n\n        if waitAnswer == 0:\n            return True\n\n        ans = self.recvSMB(packetID)\n\n        if ans.isValidAnswer(STATUS_SUCCESS):\n            smbIoctlResponse = SMB2Ioctl_Response(ans['Data'])\n            return smbIoctlResponse['Buffer']\n\n    def flush(self,treeId, fileId):\n        if (treeId in self._Session['TreeConnectTable']) is False:\n            raise SessionError(STATUS_INVALID_PARAMETER)\n        if (fileId in self._Session['OpenTable']) is False:\n            raise SessionError(STATUS_INVALID_PARAMETER)\n\n        packet = self.SMB_PACKET()\n        packet['Command'] = SMB2_FLUSH\n        packet['TreeID']  = treeId\n\n        smbFlush = SMB2Flush()\n        smbFlush['FileID'] = fileId\n\n        packet['Data'] = smbFlush\n\n        packetID = self.sendSMB(packet)\n        ans = self.recvSMB(packetID)\n\n        if ans.isValidAnswer(STATUS_SUCCESS):\n            return True\n\n    def lock(self, treeId, fileId, locks, lockSequence = 0):\n        if (treeId in self._Session['TreeConnectTable']) is False:\n            raise SessionError(STATUS_INVALID_PARAMETER)\n        if (fileId in self._Session['OpenTable']) is False:\n            raise SessionError(STATUS_INVALID_PARAMETER)\n\n        packet = self.SMB_PACKET()\n        packet['Command'] = SMB2_LOCK\n        packet['TreeID']  = treeId\n\n        smbLock = SMB2Lock()\n        smbLock['FileID']       = fileId\n        smbLock['LockCount']    = len(locks)\n        smbLock['LockSequence'] = lockSequence\n        smbLock['Locks']        = ''.join(str(x) for x in locks)\n\n        packet['Data'] = smbLock\n\n        packetID = self.sendSMB(packet)\n        ans = self.recvSMB(packetID)\n\n        if ans.isValidAnswer(STATUS_SUCCESS):\n            smbFlushResponse = SMB2Lock_Response(ans['Data'])\n            return True\n\n        # ToDo:\n        # If Open.ResilientHandle is TRUE or Connection.SupportsMultiChannel is TRUE, the client MUST\n        # do the following:\n        # The client MUST scan through Open.OperationBuckets and find an element with its Free field\n        # set to TRUE. If no such element could be found, an implementation-specific error MUST be\n        # returned to the application.\n        # Let the zero-based array index of the element chosen above be referred to as BucketIndex, and\n        # let BucketNumber = BucketIndex +1.\n        # Set Open.OperationBuckets[BucketIndex].Free = FALSE\n        # Let the SequenceNumber of the element chosen above be referred to as BucketSequence.\n        # The LockSequence field of the SMB2 lock request MUST be set to (BucketNumber<< 4) +\n        # BucketSequence.\n        # Increment the SequenceNumber of the element chosen above using MOD 16 arithmetic.\n\n    def logoff(self):\n        packet = self.SMB_PACKET()\n        packet['Command'] = SMB2_LOGOFF\n\n        smbLogoff = SMB2Logoff()\n\n        packet['Data'] = smbLogoff\n\n        packetID = self.sendSMB(packet)\n        ans = self.recvSMB(packetID)\n\n        if ans.isValidAnswer(STATUS_SUCCESS):\n            # We clean the stuff we used in case we want to authenticate again\n            # within the same connection\n            self._Session['UserCredentials']   = ''\n            self._Session['Connection']        = 0\n            self._Session['SessionID']         = 0\n            self._Session['SigningRequired']   = False\n            self._Session['SigningKey']        = ''\n            self._Session['SessionKey']        = ''\n            self._Session['SigningActivated']  = False\n            return True\n\n    def queryInfo(self, treeId, fileId, inputBlob = '', infoType = SMB2_0_INFO_FILE, fileInfoClass = SMB2_FILE_STANDARD_INFO, additionalInformation = 0, flags = 0 ):\n        if (treeId in self._Session['TreeConnectTable']) is False:\n            raise SessionError(STATUS_INVALID_PARAMETER)\n        if (fileId in self._Session['OpenTable']) is False:\n            raise SessionError(STATUS_INVALID_PARAMETER)\n\n        packet = self.SMB_PACKET()\n        packet['Command'] = SMB2_QUERY_INFO\n        packet['TreeID']  = treeId\n\n        queryInfo = SMB2QueryInfo()\n        queryInfo['FileID']                = fileId\n        queryInfo['InfoType']              = infoType\n        queryInfo['FileInfoClass']         = fileInfoClass\n        queryInfo['OutputBufferLength']    = 65535\n        queryInfo['AdditionalInformation'] = additionalInformation\n        if len(inputBlob) == 0:\n            queryInfo['InputBufferOffset'] = 0\n            queryInfo['Buffer']            = '\\x00'\n        else:\n            queryInfo['InputBufferLength'] = len(inputBlob)\n            queryInfo['Buffer']            = inputBlob\n        queryInfo['Flags']                 = flags\n\n        packet['Data'] = queryInfo\n        packetID = self.sendSMB(packet)\n        ans = self.recvSMB(packetID)\n\n        if ans.isValidAnswer(STATUS_SUCCESS):\n            queryResponse = SMB2QueryInfo_Response(ans['Data'])\n            return queryResponse['Buffer']\n\n    def setInfo(self, treeId, fileId, inputBlob = '', infoType = SMB2_0_INFO_FILE, fileInfoClass = SMB2_FILE_STANDARD_INFO, additionalInformation = 0 ):\n        if (treeId in self._Session['TreeConnectTable']) is False:\n            raise SessionError(STATUS_INVALID_PARAMETER)\n        if (fileId in self._Session['OpenTable']) is False:\n            raise SessionError(STATUS_INVALID_PARAMETER)\n\n        packet = self.SMB_PACKET()\n        packet['Command'] = SMB2_SET_INFO\n        packet['TreeID']  = treeId\n\n        setInfo = SMB2SetInfo()\n        setInfo['InfoType']              = infoType\n        setInfo['FileInfoClass']         = fileInfoClass\n        setInfo['BufferLength']          = len(inputBlob)\n        setInfo['AdditionalInformation'] = additionalInformation\n        setInfo['FileID']                = fileId\n        setInfo['Buffer']                = inputBlob\n\n        packet['Data'] = setInfo\n        packetID = self.sendSMB(packet)\n        ans = self.recvSMB(packetID)\n\n        if ans.isValidAnswer(STATUS_SUCCESS):\n            return True\n\n    def getSessionKey(self):\n        if self.getDialect() >= SMB2_DIALECT_30:\n           return self._Session['ApplicationKey']\n        else:\n           return self._Session['SessionKey']\n\n    def setSessionKey(self, key):\n        if self.getDialect() >= SMB2_DIALECT_30:\n           self._Session['ApplicationKey'] = key\n        else:\n           self._Session['SessionKey'] = key\n\n    ######################################################################\n    # Higher level functions\n\n    def rename(self, shareName, oldPath, newPath):\n        oldPath = oldPath.replace('/', '\\\\')\n        oldPath = ntpath.normpath(oldPath)\n        if len(oldPath) > 0 and oldPath[0] == '\\\\':\n            oldPath = oldPath[1:]\n\n        newPath = newPath.replace('/', '\\\\')\n        newPath = ntpath.normpath(newPath)\n        if len(newPath) > 0 and newPath[0] == '\\\\':\n            newPath = newPath[1:]\n\n        treeId = self.connectTree(shareName)\n        fileId = None\n        try:\n            fileId = self.create(treeId, oldPath, MAXIMUM_ALLOWED ,FILE_SHARE_READ | FILE_SHARE_WRITE |FILE_SHARE_DELETE, 0x200020, FILE_OPEN, 0)\n            renameReq = FILE_RENAME_INFORMATION_TYPE_2()\n            renameReq['ReplaceIfExists'] = 1\n            renameReq['RootDirectory']   = '\\x00'*8\n            renameReq['FileNameLength']  = len(newPath)*2\n            renameReq['FileName']        = newPath.encode('utf-16le')\n            self.setInfo(treeId, fileId, renameReq, infoType = SMB2_0_INFO_FILE, fileInfoClass = SMB2_FILE_RENAME_INFO)\n        finally:\n            if fileId is not None:\n                self.close(treeId, fileId)\n            self.disconnectTree(treeId)\n\n        return True\n\n    def writeFile(self, treeId, fileId, data, offset = 0):\n        finished = False\n        writeOffset = offset\n        while not finished:\n            if len(data) == 0:\n                break\n            writeData = data[:self._Connection['MaxWriteSize']]\n            data = data[self._Connection['MaxWriteSize']:]\n            written = self.write(treeId, fileId, writeData, writeOffset, len(writeData))\n            writeOffset += written\n        return writeOffset - offset\n\n    def isSnapshotRequest(self, path):\n        #TODO: use a regex here?\n        return '@GMT-' in path\n\n    def timestampForSnapshot(self, path):\n        timestamp = path[path.index(\"@GMT-\"):path.index(\"@GMT-\")+24]\n        path = path.replace(timestamp, '')\n        from datetime import datetime\n        fTime = int((datetime.strptime(timestamp, '@GMT-%Y.%m.%d-%H.%M.%S') - datetime(1970,1,1)).total_seconds())\n        fTime *= 10000000\n        fTime += 116444736000000000\n\n        token = SMB2_CREATE_TIMEWARP_TOKEN()\n        token['Timestamp'] = fTime\n\n        ctx = SMB2CreateContext()\n        ctx['Next'] = 0\n        ctx['NameOffset'] = 16\n        ctx['NameLength'] = len('TWrp')\n        ctx['DataOffset'] = 24\n        ctx['DataLength'] = 8\n        ctx['Buffer'] = b'TWrp'\n        ctx['Buffer'] += b'\\x00'*4 # 4 bytes to 8-byte align\n        ctx['Buffer'] += token.getData()\n\n        # fix-up the path\n        path = path.replace(timestamp, '').replace('\\\\\\\\', '\\\\')\n        if path == '\\\\':\n            path += '*'\n        return path, ctx\n\n    def listPath(self, shareName, path, password = None):\n        createContexts = None\n\n        if self.isSnapshotRequest(path):\n            createContexts = []\n            path, ctx = self.timestampForSnapshot(path)\n            createContexts.append(ctx)\n\n        # ToDo: Handle situations where share is password protected\n        path = path.replace('/', '\\\\')\n        path = ntpath.normpath(path)\n        if len(path) > 0 and path[0] == '\\\\':\n            path = path[1:]\n\n        treeId = self.connectTree(shareName)\n\n        fileId = None\n        try:\n            # ToDo, we're assuming it's a directory, we should check what the file type is\n            fileId = self.create(treeId, ntpath.dirname(path), FILE_READ_ATTRIBUTES | FILE_READ_DATA, FILE_SHARE_READ |\n                                 FILE_SHARE_WRITE | FILE_SHARE_DELETE,\n                                 FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT, FILE_OPEN, 0,\n                                 createContexts=createContexts)\n            res = ''\n            files = []\n            from impacket import smb\n            while True:\n                try:\n                    res = self.queryDirectory(treeId, fileId, ntpath.basename(path), maxBufferSize=65535,\n                                              informationClass=FILE_FULL_DIRECTORY_INFORMATION)\n                    nextOffset = 1\n                    while nextOffset != 0:\n                        fileInfo = smb.SMBFindFileFullDirectoryInfo(smb.SMB.FLAGS2_UNICODE)\n                        fileInfo.fromString(res)\n                        files.append(smb.SharedFile(fileInfo['CreationTime'], fileInfo['LastAccessTime'],\n                                                    fileInfo['LastChangeTime'], fileInfo['EndOfFile'],\n                                                    fileInfo['AllocationSize'], fileInfo['ExtFileAttributes'],\n                                                    fileInfo['FileName'].decode('utf-16le'),\n                                                    fileInfo['FileName'].decode('utf-16le')))\n                        nextOffset = fileInfo['NextEntryOffset']\n                        res = res[nextOffset:]\n                except SessionError as e:\n                    if (e.get_error_code()) != STATUS_NO_MORE_FILES:\n                        raise\n                    break\n                except Exception as e:\n                    print(str(e))\n                    raise\n        finally:\n            if fileId is not None:\n                self.close(treeId, fileId)\n            self.disconnectTree(treeId)\n\n        return files\n\n    def mkdir(self, shareName, pathName, password = None):\n        # ToDo: Handle situations where share is password protected\n        pathName = pathName.replace('/', '\\\\')\n        pathName = ntpath.normpath(pathName)\n        if len(pathName) > 0 and pathName[0] == '\\\\':\n            pathName = pathName[1:]\n\n        treeId = self.connectTree(shareName)\n\n        fileId = None\n        try:\n            fileId = self.create(treeId, pathName, GENERIC_ALL, FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,\n                                 FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT, FILE_CREATE, 0)\n        finally:\n            if fileId is not None:\n                self.close(treeId, fileId)\n            self.disconnectTree(treeId)\n\n        return True\n\n    def rmdir(self, shareName, pathName, password = None):\n        # ToDo: Handle situations where share is password protected\n        pathName = pathName.replace('/', '\\\\')\n        pathName = ntpath.normpath(pathName)\n        if len(pathName) > 0 and pathName[0] == '\\\\':\n            pathName = pathName[1:]\n\n        treeId = self.connectTree(shareName)\n\n        fileId = None\n        try:\n            fileId = self.create(treeId, pathName, desiredAccess=DELETE | FILE_READ_ATTRIBUTES | SYNCHRONIZE,\n                                 shareMode=FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,\n                                 creationOptions=FILE_DIRECTORY_FILE | FILE_OPEN_REPARSE_POINT,\n                                 creationDisposition=FILE_OPEN, fileAttributes=0)\n            from impacket import smb\n            delete_req = smb.SMBSetFileDispositionInfo()\n            delete_req['DeletePending'] = True\n            self.setInfo(treeId, fileId, inputBlob=delete_req, fileInfoClass=SMB2_FILE_DISPOSITION_INFO)\n        finally:\n            if fileId is not None:\n                self.close(treeId, fileId)\n            self.disconnectTree(treeId)\n\n        return True\n\n    def remove(self, shareName, pathName, password = None):\n        # ToDo: Handle situations where share is password protected\n        pathName = pathName.replace('/', '\\\\')\n        pathName = ntpath.normpath(pathName)\n        if len(pathName) > 0 and pathName[0] == '\\\\':\n            pathName = pathName[1:]\n\n        treeId = self.connectTree(shareName)\n\n        fileId = None\n        try:\n            fileId = self.create(treeId, pathName,DELETE | FILE_READ_ATTRIBUTES, FILE_SHARE_DELETE, FILE_NON_DIRECTORY_FILE | FILE_DELETE_ON_CLOSE, FILE_OPEN, 0)\n        finally:\n            if fileId is not None:\n                self.close(treeId, fileId)\n            self.disconnectTree(treeId)\n\n        return True\n\n    def retrieveFile(self, shareName, path, callback, mode = FILE_OPEN, offset = 0, password = None, shareAccessMode = FILE_SHARE_READ):\n        createContexts = None\n\n        if self.isSnapshotRequest(path):\n            createContexts = []\n            path, ctx = self.timestampForSnapshot(path)\n            createContexts.append(ctx)\n\n        # ToDo: Handle situations where share is password protected\n        path = path.replace('/', '\\\\')\n        path = ntpath.normpath(path)\n        if len(path) > 0 and path[0] == '\\\\':\n            path = path[1:]\n\n        treeId = self.connectTree(shareName)\n        fileId = None\n        from impacket import smb\n        try:\n            fileId = self.create(treeId, path, FILE_READ_DATA, shareAccessMode, FILE_NON_DIRECTORY_FILE, mode, 0, createContexts=createContexts)\n            res = self.queryInfo(treeId, fileId)\n            fileInfo = smb.SMBQueryFileStandardInfo(res)\n            fileSize = fileInfo['EndOfFile']\n            if (fileSize-offset) < self._Connection['MaxReadSize']:\n                # Skip reading 0 bytes files.\n                if (fileSize-offset) > 0:\n                    data = self.read(treeId, fileId, offset, fileSize-offset)\n                    callback(data)\n            else:\n                written = 0\n                toBeRead = fileSize-offset\n                while written < toBeRead:\n                    data = self.read(treeId, fileId, offset, self._Connection['MaxReadSize'])\n                    written += len(data)\n                    offset  += len(data)\n                    callback(data)\n        finally:\n            if fileId is not None:\n                self.close(treeId, fileId)\n            self.disconnectTree(treeId)\n\n    def storeFile(self, shareName, path, callback, mode = FILE_OVERWRITE_IF, offset = 0, password = None, shareAccessMode = FILE_SHARE_WRITE):\n        # ToDo: Handle situations where share is password protected\n        path = path.replace('/', '\\\\')\n        path = ntpath.normpath(path)\n        if len(path) > 0 and path[0] == '\\\\':\n            path = path[1:]\n\n        treeId = self.connectTree(shareName)\n        fileId = None\n        try:\n            fileId = self.create(treeId, path, FILE_WRITE_DATA, shareAccessMode, FILE_NON_DIRECTORY_FILE, mode, 0)\n            finished = False\n            writeOffset = offset\n            while not finished:\n                data = callback(self._Connection['MaxWriteSize'])\n                if len(data) == 0:\n                    break\n                written = self.write(treeId, fileId, data, writeOffset, len(data))\n                writeOffset += written\n        finally:\n            if fileId is not None:\n                self.close(treeId, fileId)\n            self.disconnectTree(treeId)\n\n    def waitNamedPipe(self, treeId, pipename, timeout = 5):\n        pipename = ntpath.basename(pipename)\n        if (treeId in self._Session['TreeConnectTable']) is False:\n            raise SessionError(STATUS_INVALID_PARAMETER)\n        if len(pipename) > 0xffff:\n            raise SessionError(STATUS_INVALID_PARAMETER)\n\n        pipeWait = FSCTL_PIPE_WAIT_STRUCTURE()\n        pipeWait['Timeout']          = timeout*100000\n        pipeWait['NameLength']       = len(pipename)*2\n        pipeWait['TimeoutSpecified'] = 1\n        pipeWait['Name']             = pipename.encode('utf-16le')\n\n        return self.ioctl(treeId, None, FSCTL_PIPE_WAIT,flags=SMB2_0_IOCTL_IS_FSCTL, inputBlob=pipeWait, maxInputResponse = 0, maxOutputResponse=0)\n\n    def getIOCapabilities(self):\n        res = dict()\n\n        res['MaxReadSize'] = self._Connection['MaxReadSize']\n        res['MaxWriteSize'] = self._Connection['MaxWriteSize']\n        return res\n\n\n    ######################################################################\n    # Backward compatibility functions and alias for SMB1 and DCE Transports\n    # NOTE: It is strongly recommended not to use these commands\n    # when implementing new client calls.\n    get_server_name            = getServerName\n    get_client_name            = getClientName\n    get_server_domain          = getServerDomain\n    get_server_dns_domain_name = getServerDNSDomainName\n    get_server_dns_host_name   = getServerDNSHostName\n    get_remote_name            = getRemoteName\n    set_remote_name            = setRemoteName\n    get_remote_host            = getServerIP\n    get_server_os              = getServerOS\n    get_server_os_major        = getServerOSMajor\n    get_server_os_minor        = getServerOSMinor\n    get_server_os_build        = getServerOSBuild\n    tree_connect_andx          = connectTree\n    tree_connect               = connectTree\n    connect_tree               = connectTree\n    disconnect_tree            = disconnectTree\n    set_timeout                = setTimeout\n    use_timeout                = useTimeout\n    stor_file                  = storeFile\n    retr_file                  = retrieveFile\n    list_path                  = listPath\n\n    def close_session(self):\n        if self._NetBIOSSession:\n            self._NetBIOSSession.close()\n            self._NetBIOSSession = None\n\n    def doesSupportNTLMv2(self):\n        # Always true :P\n        return True\n\n    def is_login_required(self):\n        # Always true :P\n        return True\n\n    def is_signing_required(self):\n        return self._Connection['RequireSigning']\n\n    def nt_create_andx(self, treeId, fileName, smb_packet=None, cmd = None):\n        if len(fileName) > 0 and fileName[0] == '\\\\':\n            fileName = fileName[1:]\n\n        if cmd is not None:\n            from impacket import smb\n            ntCreate = smb.SMBCommand(data = cmd.getData())\n            params = smb.SMBNtCreateAndX_Parameters(ntCreate['Parameters'])\n            return self.create(treeId, fileName, params['AccessMask'], params['ShareAccess'],\n                               params['CreateOptions'], params['Disposition'], params['FileAttributes'],\n                               params['Impersonation'], params['SecurityFlags'])\n\n        else:\n            return self.create(treeId, fileName,\n                    FILE_READ_DATA | FILE_WRITE_DATA | FILE_APPEND_DATA | FILE_READ_EA |\n                    FILE_WRITE_EA | FILE_WRITE_ATTRIBUTES | FILE_READ_ATTRIBUTES | READ_CONTROL,\n                    FILE_SHARE_READ | FILE_SHARE_WRITE, FILE_NON_DIRECTORY_FILE, FILE_OPEN, 0 )\n\n    def get_socket(self):\n        return self._NetBIOSSession.get_socket()\n\n\n    def write_andx(self,tid,fid,data, offset = 0, wait_answer=1, write_pipe_mode = False, smb_packet=None):\n        # ToDo: Handle the custom smb_packet situation\n        return self.write(tid, fid, data, offset, len(data))\n\n    def TransactNamedPipe(self, tid, fid, data, noAnswer = 0, waitAnswer = 1, offset = 0):\n        return self.ioctl(tid, fid, FSCTL_PIPE_TRANSCEIVE, SMB2_0_IOCTL_IS_FSCTL, data, maxOutputResponse = 65535, waitAnswer = noAnswer | waitAnswer)\n\n    def TransactNamedPipeRecv(self):\n        ans = self.recvSMB()\n\n        if ans.isValidAnswer(STATUS_SUCCESS):\n            smbIoctlResponse = SMB2Ioctl_Response(ans['Data'])\n            return smbIoctlResponse['Buffer']\n\n\n    def read_andx(self, tid, fid, offset=0, max_size = None, wait_answer=1, smb_packet=None):\n        # ToDo: Handle the custom smb_packet situation\n        if max_size is None:\n            max_size = self._Connection['MaxReadSize']\n        return self.read(tid, fid, offset, max_size, wait_answer)\n\n    def list_shared(self):\n        # In the context of SMB2/3, forget about the old LANMAN, throw NOT IMPLEMENTED\n        raise SessionError(STATUS_NOT_IMPLEMENTED)\n\n    def open_andx(self, tid, fileName, open_mode, desired_access):\n        # ToDo Return all the attributes of the file\n        if len(fileName) > 0 and fileName[0] == '\\\\':\n            fileName = fileName[1:]\n\n        fileId = self.create(tid,fileName,desired_access, open_mode, FILE_NON_DIRECTORY_FILE, open_mode, 0)\n        return fileId, 0, 0, 0, 0, 0, 0, 0, 0\n\n    def set_session_key(self, signingKey):\n        self._Session['SessionKey'] = signingKey\n        self._Session['SigningActivated'] = True\n        self._Session['SigningRequired'] = True\n\n    def set_hostname_validation(self, validate, accept_empty, hostname):\n        self._strict_hostname_validation = validate\n        self._validation_allow_absent = accept_empty\n        self._accepted_hostname = hostname\n\n    def perform_hostname_validation(self):\n        if self._Session['ServerName'] == '':\n            if not self._validation_allow_absent:\n                raise self.HostnameValidationException('Hostname was not supplied by target host and absent validation is disallowed')\n            return\n        if self._Session['ServerName'].lower() != self._accepted_hostname.lower() and self._Session['ServerDNSHostName'].lower() != self._accepted_hostname.lower():\n            raise self.HostnameValidationException('Supplied hostname %s does not match reported hostnames %s or %s' %\n                (self._accepted_hostname.lower(), self._Session['ServerName'].lower(), self._Session['ServerDNSHostName'].lower()))",
  "def __init__( self, error = 0, packet=0):\n        Exception.__init__(self)\n        self.error = error\n        self.packet = packet",
  "def get_error_code( self ):\n        return self.error",
  "def get_error_packet( self ):\n        return self.packet",
  "def __str__( self ):\n        return 'SMB SessionError: %s(%s)' % (ERROR_MESSAGES[self.error])",
  "class HostnameValidationException(Exception):\n        pass",
  "def __init__(self, remote_name, remote_host, my_name=None, host_type=nmb.TYPE_SERVER, sess_port=445, timeout=60,\n                 UDP=0, preferredDialect=None, session=None, negSessionResponse=None):\n\n        # [MS-SMB2] Section 3\n        self.RequireMessageSigning = False    #\n        self.ConnectionTable = {}\n        self.GlobalFileTable = {}\n        self.ClientGuid = ''.join([random.choice(string.ascii_letters) for i in range(16)])\n        # Only for SMB 3.0\n        self.EncryptionAlgorithmList = ['AES-CCM']\n        self.MaxDialect = []\n        self.RequireSecureNegotiate = False\n\n        # Per Transport Connection Data\n        self._Connection = {\n            # Indexed by SessionID\n            #'SessionTable'             : {},\n            # Indexed by MessageID\n            'OutstandingRequests'      : {},\n            'OutstandingResponses'     : {},    #\n            'SequenceWindow'           : 0,     #\n            'GSSNegotiateToken'        : '',    #\n            'MaxTransactSize'          : 0,     #\n            'MaxReadSize'              : 0,     #\n            'MaxWriteSize'             : 0,     #\n            'ServerGuid'               : '',    #\n            'RequireSigning'           : False, #\n            'ServerName'               : '',    #\n            # If the client implements the SMB 2.1 or SMB 3.0 dialects, it MUST\n            # also implement the following\n            'Dialect'                  : 0,    #\n            'SupportsFileLeasing'      : False, #\n            'SupportsMultiCredit'      : False, #\n            # If the client implements the SMB 3.0 dialect,\n            # it MUST also implement the following\n            'SupportsDirectoryLeasing' : False, #\n            'SupportsMultiChannel'     : False, #\n            'SupportsPersistentHandles': False, #\n            'SupportsEncryption'       : False, #\n            'ClientCapabilities'       : 0,\n            'ServerCapabilities'       : 0,    #\n            'ClientSecurityMode'       : 0,    #\n            'ServerSecurityMode'       : 0,    #\n            # Outside the protocol\n            'ServerIP'                 : '',    #\n            'ClientName'               : '',    #\n            #GSSoptions (MutualAuth and Delegate)\n            'GSSoptions'               : {},\n            # If the client implements the SMB 3.1.1 dialect,\n            # it MUST also implement the following\n            'PreauthIntegrityHashId': 0,\n            'PreauthIntegrityHashValue': a2b_hex(b'0'*128),\n            'CipherId' : 0\n        }\n\n        self._Session = {\n            'SessionID'                : 0,   #\n            'TreeConnectTable'         : {},    #\n            'SessionKey'               : b'',    #\n            'SigningRequired'          : False, #\n            'Connection'               : 0,     #\n            'UserCredentials'          : '',    #\n            'OpenTable'                : {},    #\n            # If the client implements the SMB 3.0 dialect,\n            # it MUST also implement the following\n            'ChannelList'              : [],\n            'ChannelSequence'          : 0,\n            #'EncryptData'              : False,\n            'EncryptData'              : True,\n            'EncryptionKey'            : '',\n            'DecryptionKey'            : '',\n            'SigningKey'               : '',\n            'ApplicationKey'           : b'',\n            # Outside the protocol\n            'SessionFlags'             : 0,     #\n            'ServerName'               : '',    #\n            'ServerDomain'             : '',    #\n            'ServerDNSDomainName'      : '',    #\n            'ServerDNSHostName'        : '',    #\n            'ServerOS'                 : '',    #\n            'SigningActivated'         : False, #\n            'PreauthIntegrityHashValue': a2b_hex(b'0'*128),\n            'CalculatePreAuthHash'     : True,\n        }\n\n        self.SMB_PACKET = SMB2Packet\n\n        self._timeout = timeout\n        self._Connection['ServerIP'] = remote_host\n        self._NetBIOSSession = None\n        self._preferredDialect = preferredDialect\n        self._doKerberos = False\n\n        # Strict host validation - off by default\n        self._strict_hostname_validation = False\n        self._validation_allow_absent = True\n        self._accepted_hostname = ''\n\n        self.__userName = ''\n        self.__password = ''\n        self.__domain   = ''\n        self.__lmhash   = ''\n        self.__nthash   = ''\n        self.__kdc      = ''\n        self.__aesKey   = ''\n        self.__TGT      = None\n        self.__TGS      = None\n\n        if sess_port == 445 and remote_name == '*SMBSERVER':\n           self._Connection['ServerName'] = remote_host\n        else:\n           self._Connection['ServerName'] = remote_name\n\n        # This is on purpose. I'm still not convinced to do a socket.gethostname() if not specified\n        if my_name is None:\n            self._Connection['ClientName'] = ''\n        else:\n            self._Connection['ClientName'] = my_name\n\n        if session is None:\n            if not my_name:\n                # If destination port is 139 yes, there's some client disclosure\n                my_name = socket.gethostname()\n                i = my_name.find('.')\n                if i > -1:\n                    my_name = my_name[:i]\n\n            if UDP:\n                self._NetBIOSSession = nmb.NetBIOSUDPSession(my_name, self._Connection['ServerName'], remote_host, host_type, sess_port, self._timeout)\n            else:\n                self._NetBIOSSession = nmb.NetBIOSTCPSession(my_name, self._Connection['ServerName'], remote_host, host_type, sess_port, self._timeout)\n\n                self.negotiateSession(preferredDialect)\n        else:\n            self._NetBIOSSession = session\n            # We should increase the SequenceWindow since a packet was already received.\n            self._Connection['SequenceWindow'] += 1\n            # Let's negotiate again if needed (or parse the existing response) using the same connection\n            self.negotiateSession(preferredDialect, negSessionResponse)",
  "def printStatus(self):\n        print(\"CONNECTION\")\n        for i in list(self._Connection.items()):\n            print(\"%-40s : %s\" % i)\n        print()\n        print(\"SESSION\")\n        for i in list(self._Session.items()):\n            print(\"%-40s : %s\" % i)",
  "def __UpdateConnectionPreAuthHash(self, data):\n        from Cryptodome.Hash import SHA512\n        calculatedHash =  SHA512.new()\n        calculatedHash.update(self._Connection['PreauthIntegrityHashValue'])\n        calculatedHash.update(data)\n        self._Connection['PreauthIntegrityHashValue'] = calculatedHash.digest()",
  "def __UpdatePreAuthHash(self, data):\n        from Cryptodome.Hash import SHA512\n        calculatedHash =  SHA512.new()\n        calculatedHash.update(self._Session['PreauthIntegrityHashValue'])\n        calculatedHash.update(data)\n        self._Session['PreauthIntegrityHashValue'] = calculatedHash.digest()",
  "def getKerberos(self):\n        return self._doKerberos",
  "def getServerName(self):\n        return self._Session['ServerName']",
  "def getClientName(self):\n        return self._Session['ClientName']",
  "def getRemoteName(self):\n        if self._Session['ServerName'] == '':\n            return self._Connection['ServerName']\n        return self._Session['ServerName']",
  "def setRemoteName(self, name):\n        self._Session['ServerName'] = name\n        return True",
  "def getServerIP(self):\n        return self._Connection['ServerIP']",
  "def getServerDomain(self):\n        return self._Session['ServerDomain']",
  "def getServerDNSDomainName(self):\n        return self._Session['ServerDNSDomainName']",
  "def getServerDNSHostName(self):\n        return self._Session['ServerDNSHostName']",
  "def getServerOS(self):\n        return self._Session['ServerOS']",
  "def getServerOSMajor(self):\n        return self._Session['ServerOSMajor']",
  "def getServerOSMinor(self):\n        return self._Session['ServerOSMinor']",
  "def getServerOSBuild(self):\n        return self._Session['ServerOSBuild']",
  "def isGuestSession(self):\n        return self._Session['SessionFlags'] & SMB2_SESSION_FLAG_IS_GUEST",
  "def setTimeout(self, timeout):\n        self._timeout = timeout",
  "def useTimeout(self, timeout):\n        prev_timeout = self.getTimeout(timeout)\n        try:\n            yield\n        finally:\n            self.setTimeout(prev_timeout)",
  "def getDialect(self):\n        return self._Connection['Dialect']",
  "def processContextList(self, contextCount, contextList):\n        offset = 0\n        while contextCount > 0:\n            context = SMB2NegotiateContext(contextList[offset:])\n            if context['ContextType'] == SMB2_PREAUTH_INTEGRITY_CAPABILITIES:\n                contextPreAuth = SMB2PreAuthIntegrityCapabilities(context['Data'])\n                self._Connection['PreauthIntegrityHashId'] = struct.unpack('<H', contextPreAuth['HashAlgorithms'])[0]\n            elif context['ContextType'] == SMB2_ENCRYPTION_CAPABILITIES:\n                contextEncryption = SMB2EncryptionCapabilities(context['Data'])\n                cipherId = struct.unpack('<H', contextEncryption['Ciphers'])[0]\n                self._Connection['CipherId'] = cipherId\n                if cipherId != 0:\n                    self._Connection['SupportsEncryption'] = True\n            elif context['ContextType'] == SMB2_COMPRESSION_CAPABILITIES:\n                pass\n            elif context['ContextType'] == SMB2_NETNAME_NEGOTIATE_CONTEXT_ID:\n                pass\n\n            padding = ((8 - (context['DataLength'] % 8)) % 8)\n            offset = 8 + context['DataLength'] + padding\n            contextCount -= 1",
  "def signSMB(self, packet):\n        packet['Signature'] = '\\x00'*16\n        if self._Connection['Dialect'] == SMB2_DIALECT_21 or self._Connection['Dialect'] == SMB2_DIALECT_002:\n            if len(self._Session['SessionKey']) > 0:\n                signature = hmac.new(self._Session['SessionKey'], packet.getData(), hashlib.sha256).digest()\n                packet['Signature'] = signature[:16]\n        else:\n            if len(self._Session['SessionKey']) > 0:\n                p = packet.getData()\n                signature = crypto.AES_CMAC(self._Session['SigningKey'], p, len(p))\n                packet['Signature'] = signature",
  "def sendSMB(self, packet):\n        # The idea here is to receive multiple/single commands and create a compound request, and send it\n        # Should return the MessageID for later retrieval. Implement compounded related requests.\n\n        # If Connection.Dialect is equal to \"3.000\" and if Connection.SupportsMultiChannel or\n        # Connection.SupportsPersistentHandles is TRUE, the client MUST set ChannelSequence in the\n        # SMB2 header to Session.ChannelSequence\n\n        # Check this is not a CANCEL request. If so, don't consume sequence numbers\n        if packet['Command'] is not SMB2_CANCEL:\n            packet['MessageID'] = self._Connection['SequenceWindow']\n            self._Connection['SequenceWindow'] += 1\n        packet['SessionID'] = self._Session['SessionID']\n\n        # Default the credit charge to 1 unless set by the caller\n        if ('CreditCharge' in packet.fields) is False:\n            packet['CreditCharge'] = 1\n\n        # Standard credit request after negotiating protocol\n        if self._Connection['SequenceWindow'] > 3:\n            packet['CreditRequestResponse'] = 127\n\n        messageId = packet['MessageID']\n\n        if self._Session['SigningActivated'] is True and self._Connection['SequenceWindow'] > 2:\n            if packet['TreeID'] > 0 and (packet['TreeID'] in self._Session['TreeConnectTable']) is True:\n                if self._Session['TreeConnectTable'][packet['TreeID']]['EncryptData'] is False:\n                    packet['Flags'] = SMB2_FLAGS_SIGNED\n                    self.signSMB(packet)\n            elif packet['TreeID'] == 0:\n                packet['Flags'] = SMB2_FLAGS_SIGNED\n                self.signSMB(packet)\n\n        if packet['Command'] is SMB2_NEGOTIATE:\n            data = packet.getData()\n            self.__UpdateConnectionPreAuthHash(data)\n            self._Session['CalculatePreAuthHash'] = False\n\n        if packet['Command'] is SMB2_SESSION_SETUP:\n            self._Session['CalculatePreAuthHash'] = True\n\n        if (self._Session['SessionFlags'] & SMB2_SESSION_FLAG_ENCRYPT_DATA) or ( packet['TreeID'] != 0 and self._Session['TreeConnectTable'][packet['TreeID']]['EncryptData'] is True):\n            plainText = packet.getData()\n            transformHeader = SMB2_TRANSFORM_HEADER()\n            transformHeader['Nonce'] = ''.join([rand.choice(string.ascii_letters) for _ in range(11)])\n            transformHeader['OriginalMessageSize'] = len(plainText)\n            transformHeader['EncryptionAlgorithm'] = SMB2_ENCRYPTION_AES128_CCM\n            transformHeader['SessionID'] = self._Session['SessionID']\n            cipher = AES.new(self._Session['EncryptionKey'], AES.MODE_CCM,  b(transformHeader['Nonce']))\n            cipher.update(transformHeader.getData()[20:])\n            cipherText = cipher.encrypt(plainText)\n            transformHeader['Signature'] = cipher.digest()\n            packet = transformHeader.getData() + cipherText\n\n            self._NetBIOSSession.send_packet(packet)\n        else:\n            data = packet.getData()\n            if self._Session['CalculatePreAuthHash'] is True:\n                self.__UpdatePreAuthHash(data)\n\n            self._NetBIOSSession.send_packet(data)\n\n        return messageId",
  "def recvSMB(self, packetID = None):\n        # First, verify we don't have the packet already\n        if packetID in self._Connection['OutstandingResponses']:\n            return self._Connection['OutstandingResponses'].pop(packetID)\n\n        data = self._NetBIOSSession.recv_packet(self._timeout)\n\n        if data.get_trailer().startswith(b'\\xfdSMB'):\n            # Packet is encrypted\n            transformHeader = SMB2_TRANSFORM_HEADER(data.get_trailer())\n            cipher = AES.new(self._Session['DecryptionKey'], AES.MODE_CCM,  transformHeader['Nonce'][:11])\n            cipher.update(transformHeader.getData()[20:])\n            plainText = cipher.decrypt(data.get_trailer()[len(SMB2_TRANSFORM_HEADER()):])\n            #cipher.verify(transformHeader['Signature'])\n            packet = SMB2Packet(plainText)\n        else:\n            # In all SMB dialects for a response this field is interpreted as the Status field.\n            # This field can be set to any value. For a list of valid status codes,\n            # see [MS-ERREF] section 2.3.\n            packet = SMB2Packet(data.get_trailer())\n\n        # Loop while we receive pending requests\n        if packet['Status'] == STATUS_PENDING:\n            status = STATUS_PENDING\n            while status == STATUS_PENDING:\n                data = self._NetBIOSSession.recv_packet(self._timeout)\n                if data.get_trailer().startswith(b'\\xfeSMB'):\n                    packet = SMB2Packet(data.get_trailer())\n                else:\n                    # Packet is encrypted\n                    transformHeader = SMB2_TRANSFORM_HEADER(data.get_trailer())\n                    cipher = AES.new(self._Session['DecryptionKey'], AES.MODE_CCM,  transformHeader['Nonce'][:11])\n                    cipher.update(transformHeader.getData()[20:])\n                    plainText = cipher.decrypt(data.get_trailer()[len(SMB2_TRANSFORM_HEADER()):])\n                    #cipher.verify(transformHeader['Signature'])\n                    packet = SMB2Packet(plainText)\n                status = packet['Status']\n\n        if packet['MessageID'] == packetID or packetID is None:\n            # Let's update the sequenceWindow based on the CreditsCharged\n            # In the SMB 2.0.2 dialect, this field MUST NOT be used and MUST be reserved.\n            # The sender MUST set this to 0, and the receiver MUST ignore it.\n            # In all other dialects, this field indicates the number of credits that this request consumes.\n            if self._Connection['Dialect'] > SMB2_DIALECT_002:\n                self._Connection['SequenceWindow'] += (packet['CreditCharge'] - 1)\n            return packet\n        else:\n            self._Connection['OutstandingResponses'][packet['MessageID']] = packet\n            return self.recvSMB(packetID)",
  "def negotiateSession(self, preferredDialect = None, negSessionResponse = None):\n        # Let's store some data for later use\n        self._Connection['ClientSecurityMode'] = SMB2_NEGOTIATE_SIGNING_ENABLED\n        if self.RequireMessageSigning is True:\n            self._Connection['ClientSecurityMode'] |= SMB2_NEGOTIATE_SIGNING_REQUIRED\n        self._Connection['Capabilities'] = SMB2_GLOBAL_CAP_ENCRYPTION\n        currentDialect = SMB2_DIALECT_WILDCARD\n\n        # Do we have a negSessionPacket already?\n        if negSessionResponse is not None:\n            # Yes, let's store the dialect answered back\n            negResp = SMB2Negotiate_Response(negSessionResponse['Data'])\n            currentDialect = negResp['DialectRevision']\n\n        if currentDialect == SMB2_DIALECT_WILDCARD:\n            # Still don't know the chosen dialect, let's send our options\n\n            packet = self.SMB_PACKET()\n            packet['Command'] = SMB2_NEGOTIATE\n            negSession = SMB2Negotiate()\n\n            negSession['SecurityMode'] = self._Connection['ClientSecurityMode']\n            negSession['Capabilities'] = self._Connection['Capabilities']\n            negSession['ClientGuid'] = self.ClientGuid\n            if preferredDialect is not None:\n                negSession['Dialects'] = [preferredDialect]\n                if preferredDialect == SMB2_DIALECT_311:\n                    # Build the Contexts\n                    contextData = SMB311ContextData()\n                    contextData['NegotiateContextOffset'] = 64+38+2\n                    contextData['NegotiateContextCount'] = 0\n                    # Add an SMB2_NEGOTIATE_CONTEXT with ContextType as SMB2_PREAUTH_INTEGRITY_CAPABILITIES\n                    # to the negotiate request as specified in section 2.2.3.1:\n                    negotiateContext = SMB2NegotiateContext()\n                    negotiateContext['ContextType'] = SMB2_PREAUTH_INTEGRITY_CAPABILITIES\n\n                    preAuthIntegrityCapabilities = SMB2PreAuthIntegrityCapabilities()\n                    preAuthIntegrityCapabilities['HashAlgorithmCount'] = 1\n                    preAuthIntegrityCapabilities['SaltLength'] = 32\n                    preAuthIntegrityCapabilities['HashAlgorithms'] = b'\\x01\\x00'\n                    preAuthIntegrityCapabilities['Salt'] = ''.join([rand.choice(string.ascii_letters) for _ in\n                                                                     range(preAuthIntegrityCapabilities['SaltLength'])])\n\n                    negotiateContext['Data'] = preAuthIntegrityCapabilities.getData()\n                    negotiateContext['DataLength'] = len(negotiateContext['Data'])\n                    contextData['NegotiateContextCount'] += 1\n                    pad = b'\\xFF' * ((8 - (negotiateContext['DataLength'] % 8)) % 8)\n\n                    # Add an SMB2_NEGOTIATE_CONTEXT with ContextType as SMB2_ENCRYPTION_CAPABILITIES\n                    # to the negotiate request as specified in section 2.2.3.1 and initialize\n                    # the Ciphers field with the ciphers supported by the client in the order of preference.\n\n                    negotiateContext2 = SMB2NegotiateContext()\n                    negotiateContext2['ContextType'] = SMB2_ENCRYPTION_CAPABILITIES\n\n                    encryptionCapabilities = SMB2EncryptionCapabilities()\n                    encryptionCapabilities['CipherCount'] = 1\n                    encryptionCapabilities['Ciphers'] = b'\\x01\\x00'\n\n                    negotiateContext2['Data'] = encryptionCapabilities.getData()\n                    negotiateContext2['DataLength'] = len(negotiateContext2['Data'])\n                    contextData['NegotiateContextCount'] += 1\n\n                    negSession['ClientStartTime'] = contextData.getData()\n                    negSession['Padding'] = b'\\xFF\\xFF'\n                    # Subsequent negotiate contexts MUST appear at the first 8-byte aligned offset following the\n                    # previous negotiate context.\n                    negSession['NegotiateContextList'] = negotiateContext.getData() + pad + negotiateContext2.getData()\n\n                    # Do you want to enforce encryption? Uncomment here:\n                    #self._Connection['SupportsEncryption'] = True\n\n            else:\n                negSession['Dialects'] = [SMB2_DIALECT_002, SMB2_DIALECT_21, SMB2_DIALECT_30]\n            negSession['DialectCount'] = len(negSession['Dialects'])\n            packet['Data'] = negSession\n\n            packetID = self.sendSMB(packet)\n            ans = self.recvSMB(packetID)\n            if ans.isValidAnswer(STATUS_SUCCESS):\n                negResp = SMB2Negotiate_Response(ans['Data'])\n                if negResp['DialectRevision']  == SMB2_DIALECT_311:\n                    self.__UpdateConnectionPreAuthHash(ans.rawData)\n\n        self._Connection['MaxTransactSize']   = min(0x100000,negResp['MaxTransactSize'])\n        self._Connection['MaxReadSize']       = min(0x100000,negResp['MaxReadSize'])\n        self._Connection['MaxWriteSize']      = min(0x100000,negResp['MaxWriteSize'])\n        self._Connection['ServerGuid']        = negResp['ServerGuid']\n        self._Connection['GSSNegotiateToken'] = negResp['Buffer']\n        self._Connection['Dialect']           = negResp['DialectRevision']\n\n        if (negResp['SecurityMode'] & SMB2_NEGOTIATE_SIGNING_REQUIRED) == SMB2_NEGOTIATE_SIGNING_REQUIRED or \\\n                self._Connection['Dialect'] == SMB2_DIALECT_311:\n            self._Connection['RequireSigning'] = True\n        if self._Connection['Dialect'] == SMB2_DIALECT_311:\n            # Always Sign\n            self._Connection['RequireSigning'] = True\n            negContextCount = negResp['NegotiateContextCount']\n            # Process the Contexts as specified in section 3.2.5.2\n            if negContextCount > 0:\n                self.processContextList(negContextCount, negResp['NegotiateContextList'])\n\n        if (negResp['Capabilities'] & SMB2_GLOBAL_CAP_LEASING) == SMB2_GLOBAL_CAP_LEASING:\n            self._Connection['SupportsFileLeasing'] = True\n        if (negResp['Capabilities'] & SMB2_GLOBAL_CAP_LARGE_MTU) == SMB2_GLOBAL_CAP_LARGE_MTU:\n            self._Connection['SupportsMultiCredit'] = True\n\n        if self._Connection['Dialect'] >= SMB2_DIALECT_30:\n            # Switching to the right packet format\n            self.SMB_PACKET = SMB3Packet\n            if (negResp['Capabilities'] & SMB2_GLOBAL_CAP_DIRECTORY_LEASING) == SMB2_GLOBAL_CAP_DIRECTORY_LEASING:\n                self._Connection['SupportsDirectoryLeasing'] = True\n            if (negResp['Capabilities'] & SMB2_GLOBAL_CAP_MULTI_CHANNEL) == SMB2_GLOBAL_CAP_MULTI_CHANNEL:\n                self._Connection['SupportsMultiChannel'] = True\n            if (negResp['Capabilities'] & SMB2_GLOBAL_CAP_PERSISTENT_HANDLES) == SMB2_GLOBAL_CAP_PERSISTENT_HANDLES:\n                self._Connection['SupportsPersistentHandles'] = True\n            if (negResp['Capabilities'] & SMB2_GLOBAL_CAP_ENCRYPTION) == SMB2_GLOBAL_CAP_ENCRYPTION:\n                self._Connection['SupportsEncryption'] = True\n\n            self._Connection['ServerCapabilities'] = negResp['Capabilities']\n            self._Connection['ServerSecurityMode'] = negResp['SecurityMode']",
  "def getCredentials(self):\n        return (\n            self.__userName,\n            self.__password,\n            self.__domain,\n            self.__lmhash,\n            self.__nthash,\n            self.__aesKey,\n            self.__TGT,\n            self.__TGS)",
  "def kerberosLogin(self, user, password, domain = '', lmhash = '', nthash = '', aesKey='', kdcHost = '', TGT=None, TGS=None, mutualAuth=False):\n        # If TGT or TGS are specified, they are in the form of:\n        # TGS['KDC_REP'] = the response from the server\n        # TGS['cipher'] = the cipher used\n        # TGS['sessionKey'] = the sessionKey\n        # If we have hashes, normalize them\n        if lmhash != '' or nthash != '':\n            if len(lmhash) % 2:     lmhash = '0%s' % lmhash\n            if len(nthash) % 2:     nthash = '0%s' % nthash\n            try: # just in case they were converted already\n                lmhash = a2b_hex(lmhash)\n                nthash = a2b_hex(nthash)\n            except:\n                pass\n\n        self.__userName = user\n        self.__password = password\n        self.__domain   = domain\n        self.__lmhash   = lmhash\n        self.__nthash   = nthash\n        self.__kdc      = kdcHost\n        self.__aesKey   = aesKey\n        self.__TGT      = TGT\n        self.__TGS      = TGS\n        self._doKerberos= True\n\n        sessionSetup = SMB2SessionSetup()\n        if self.RequireMessageSigning is True:\n           sessionSetup['SecurityMode'] = SMB2_NEGOTIATE_SIGNING_REQUIRED\n        else:\n           sessionSetup['SecurityMode'] = SMB2_NEGOTIATE_SIGNING_ENABLED\n\n        sessionSetup['Flags'] = 0\n        #sessionSetup['Capabilities'] = SMB2_GLOBAL_CAP_LARGE_MTU | SMB2_GLOBAL_CAP_LEASING | SMB2_GLOBAL_CAP_DFS\n\n        # Importing down here so pyasn1 is not required if kerberos is not used.\n        from impacket.krb5.asn1 import AP_REQ, Authenticator, TGS_REP, seq_set\n        from impacket.krb5.kerberosv5 import getKerberosTGT, getKerberosTGS\n        from impacket.krb5 import constants\n        from impacket.krb5.types import Principal, KerberosTime, Ticket\n        from pyasn1.codec.der import decoder, encoder\n        import datetime\n\n        # First of all, we need to get a TGT for the user\n        userName = Principal(user, type=constants.PrincipalNameType.NT_PRINCIPAL.value)\n        if TGT is None:\n            if TGS is None:\n                tgt, cipher, oldSessionKey, sessionKey = getKerberosTGT(userName, password, domain, lmhash, nthash, aesKey, kdcHost)\n        else:\n            tgt = TGT['KDC_REP']\n            cipher = TGT['cipher']\n            sessionKey = TGT['sessionKey']\n\n        # Save the ticket\n        # If you want, for debugging purposes\n#        from impacket.krb5.ccache import CCache\n#        ccache = CCache()\n#        try:\n#            if TGS is None:\n#                ccache.fromTGT(tgt, oldSessionKey, sessionKey)\n#            else:\n#                ccache.fromTGS(TGS['KDC_REP'], TGS['oldSessionKey'], TGS['sessionKey'] )\n#            ccache.saveFile('/tmp/ticket.bin')\n#        except Exception, e:\n#            print e\n#            pass\n\n        # Now that we have the TGT, we should ask for a TGS for cifs\n\n        if TGS is None:\n            serverName = Principal('cifs/%s' % (self._Connection['ServerName']), type=constants.PrincipalNameType.NT_SRV_INST.value)\n            tgs, cipher, oldSessionKey, sessionKey = getKerberosTGS(serverName, domain, kdcHost, tgt, cipher, sessionKey)\n        else:\n            tgs = TGS['KDC_REP']\n            cipher = TGS['cipher']\n            sessionKey = TGS['sessionKey']\n\n        # Let's build a NegTokenInit with a Kerberos REQ_AP\n\n        blob = SPNEGO_NegTokenInit()\n\n        # Kerberos\n        blob['MechTypes'] = [TypesMech['MS KRB5 - Microsoft Kerberos 5']]\n\n        # Let's extract the ticket from the TGS\n        tgs = decoder.decode(tgs, asn1Spec = TGS_REP())[0]\n        ticket = Ticket()\n        ticket.from_asn1(tgs['ticket'])\n\n        # Now let's build the AP_REQ\n        apReq = AP_REQ()\n        apReq['pvno'] = 5\n        apReq['msg-type'] = int(constants.ApplicationTagNumbers.AP_REQ.value)\n\n        #Handle mutual authentication\n        opts = list()\n\n        if mutualAuth == True:\n            from impacket.krb5.constants import APOptions\n            opts.append(constants.APOptions.mutual_required.value)\n\n        apReq['ap-options'] = constants.encodeFlags(opts)\n        seq_set(apReq,'ticket', ticket.to_asn1)\n\n        authenticator = Authenticator()\n        authenticator['authenticator-vno'] = 5\n        authenticator['crealm'] = domain\n        seq_set(authenticator, 'cname', userName.components_to_asn1)\n        now = datetime.datetime.utcnow()\n\n        authenticator['cusec'] = now.microsecond\n        authenticator['ctime'] = KerberosTime.to_asn1(now)\n\n        encodedAuthenticator = encoder.encode(authenticator)\n\n        # Key Usage 11\n        # AP-REQ Authenticator (includes application authenticator\n        # subkey), encrypted with the application session key\n        # (Section 5.5.1)\n        encryptedEncodedAuthenticator = cipher.encrypt(sessionKey, 11, encodedAuthenticator, None)\n\n        apReq['authenticator'] = noValue\n        apReq['authenticator']['etype'] = cipher.enctype\n        apReq['authenticator']['cipher'] = encryptedEncodedAuthenticator\n\n        blob['MechToken'] = struct.pack('B', ASN1_AID) + asn1encode( struct.pack('B', ASN1_OID) + asn1encode(\n            TypesMech['KRB5 - Kerberos 5'] ) + KRB5_AP_REQ + encoder.encode(apReq))\n\n        sessionSetup['SecurityBufferLength'] = len(blob)\n        sessionSetup['Buffer']               = blob.getData()\n\n        packet = self.SMB_PACKET()\n        packet['Command'] = SMB2_SESSION_SETUP\n        packet['Data']    = sessionSetup\n\n        #Initiate session preauth hash\n        self._Session['PreauthIntegrityHashValue'] = self._Connection['PreauthIntegrityHashValue']\n\n        packetID = self.sendSMB(packet)\n        ans = self.recvSMB(packetID)\n        if ans.isValidAnswer(STATUS_SUCCESS):\n            self._Session['SessionID']       = ans['SessionID']\n            self._Session['SigningRequired'] = self._Connection['RequireSigning']\n            self._Session['UserCredentials'] = (user, password, domain, lmhash, nthash)\n            self._Session['Connection']      = self._NetBIOSSession.get_socket()\n\n\n            if mutualAuth == True:\n                #Lets get the session key in the AP_REP\n                from impacket.krb5.asn1 import AP_REP, EncAPRepPart\n                from impacket.krb5.crypto import Key, _enctype_table\n                smbSessSetupResp = SMB2SessionSetup_Response(ans['Data'])\n\n                #in [KILE] 3.1.1.2:\n                #    The subkey in the EncAPRepPart of the KRB_AP_REP message is used as the session key when\n                #    MutualAuthentication is requested. (The KRB_AP_REP message and its fields are defined in [RFC4120]\n                #    section 5.5.2.) When DES and RC4 are used, the implementation is as described in [RFC1964]. With\n                #    DES and RC4, the subkey in the KRB_AP_REQ message can be used as the session key, as it is the\n                #    same as the subkey in KRB_AP_REP message; however when AES is used (see [RFC4121]), the\n                #    subkeys are different and the subkey in the KRB_AP_REP is used. (The KRB_AP_REQ message is\n                #    defined in [RFC4120] section 5.5.1).\n                negTokenResp = SPNEGO_NegTokenResp(smbSessSetupResp['Buffer'])\n\n                #TODO: Parse ResponseToken as krb5Blob depending on the supported mech indicated in the negTokenResp\n                ap_rep = decoder.decode(negTokenResp['ResponseToken'][16:], asn1Spec=AP_REP())[0]\n\n                if cipher.enctype != ap_rep['enc-part']['etype']:\n                    raise Exception('Unable to decrypt AP_REP: cipher does not match TGS session key')\n\n                # Key Usage 12\n                # AP-REP encrypted part (includes application session\n                # subkey), encrypted with the application session key\n                # (Section 5.5.2)\n                cipherText = ap_rep['enc-part']['cipher']\n                plainText = cipher.decrypt(sessionKey, 12, cipherText)\n\n                encAPRepPart = decoder.decode(plainText, asn1Spec = EncAPRepPart())[0]\n\n                apCipher = _enctype_table[int(encAPRepPart['subkey']['keytype'])]()\n                apSessionKey = Key(apCipher.enctype, encAPRepPart['subkey']['keyvalue'].asOctets())\n\n                sequenceNumber = int(encAPRepPart['seq-number'])\n                self._Session['SessionKey'] = apSessionKey.contents\n\n            else:\n                self._Session['SessionKey']  = sessionKey.contents[:16]\n\n            if self._Session['SigningRequired'] is True and self._Connection['Dialect'] >= SMB2_DIALECT_30:\n                # If Connection.Dialect is \"3.1.1\", the case-sensitive ASCII string \"SMBSigningKey\" as the label;\n                # otherwise, the case - sensitive ASCII string \"SMB2AESCMAC\" as the label.\n                # If Connection.Dialect is \"3.1.1\", Session.PreauthIntegrityHashValue as the context; otherwise,\n                # the case-sensitive ASCII string \"SmbSign\" as context for the algorithm.\n                if self._Connection['Dialect'] == SMB2_DIALECT_311:\n                    self._Session['SigningKey'] = crypto.KDF_CounterMode (self._Session['SessionKey'], b\"SMBSigningKey\\x00\",\n                                                                          self._Session['PreauthIntegrityHashValue'], 128)\n                else:\n                    self._Session['SigningKey'] = crypto.KDF_CounterMode (self._Session['SessionKey'], b\"SMB2AESCMAC\\x00\",\n                                                                          b\"SmbSign\\x00\", 128)\n\n            # Do not encrypt anonymous connections\n            if user == '' or self.isGuestSession():\n                self._Connection['SupportsEncryption'] = False\n\n            if self._Session['SigningRequired'] is True:\n                self._Session['SigningActivated'] = True\n            if self._Connection['Dialect'] >= SMB2_DIALECT_30 and self._Connection['SupportsEncryption'] is True:\n                # Encryption available. Let's enforce it if we have AES CCM available\n                self._Session['SessionFlags'] |= SMB2_SESSION_FLAG_ENCRYPT_DATA\n                # Application Key\n                # If Connection.Dialect is \"3.1.1\",the case-sensitive ASCII string \"SMBAppKey\" as the label;\n                # otherwise, the case-sensitive ASCII string \"SMB2APP\" as the label. Session.PreauthIntegrityHashValue\n                # as the context; otherwise, the case-sensitive ASCII string \"SmbRpc\" as context for the algorithm.\n                # Encryption Key\n                # If Connection.Dialect is \"3.1.1\",the case-sensitive ASCII string \"SMBC2SCipherKey\" as # the label;\n                # otherwise, the case-sensitive ASCII string \"SMB2AESCCM\" as the label. Session.PreauthIntegrityHashValue\n                # as the context; otherwise, the case-sensitive ASCII string \"ServerIn \" as context for the algorithm\n                # (note the blank space at the end)\n                # Decryption Key\n                # If Connection.Dialect is \"3.1.1\", the case-sensitive ASCII string \"SMBS2CCipherKey\" as the label;\n                # otherwise, the case-sensitive ASCII string \"SMB2AESCCM\" as the label. Session.PreauthIntegrityHashValue\n                # as the context; otherwise, the case-sensitive ASCII string \"ServerOut\" as context for the algorithm.\n                if self._Connection['Dialect'] == SMB2_DIALECT_311:\n                    self._Session['ApplicationKey'] = crypto.KDF_CounterMode (self._Session['SessionKey'], b\"SMBAppKey\\x00\",\n                                                                              self._Session['PreauthIntegrityHashValue'], 128)\n                    self._Session['EncryptionKey'] = crypto.KDF_CounterMode (self._Session['SessionKey'], b\"SMBC2SCipherKey\\x00\",\n                                                                             self._Session['PreauthIntegrityHashValue'], 128)\n                    self._Session['DecryptionKey'] = crypto.KDF_CounterMode (self._Session['SessionKey'], b\"SMBS2CCipherKey\\x00\",\n                                                                             self._Session['PreauthIntegrityHashValue'], 128)\n                else:\n                    self._Session['ApplicationKey'] = crypto.KDF_CounterMode (self._Session['SessionKey'], b\"SMB2APP\\x00\",\n                                                                              b\"SmbRpc\\x00\", 128)\n                    self._Session['EncryptionKey'] = crypto.KDF_CounterMode (self._Session['SessionKey'], b\"SMB2AESCCM\\x00\",\n                                                                             b\"ServerIn \\x00\", 128)\n                    self._Session['DecryptionKey'] = crypto.KDF_CounterMode (self._Session['SessionKey'], b\"SMB2AESCCM\\x00\",\n                                                                             b\"ServerOut\\x00\", 128)\n\n            self._Session['CalculatePreAuthHash'] = False\n            return True\n        else:\n            # We clean the stuff we used in case we want to authenticate again\n            # within the same connection\n            self._Session['UserCredentials']   = ''\n            self._Session['Connection']        = 0\n            self._Session['SessionID']         = 0\n            self._Session['SigningRequired']   = False\n            self._Session['SigningKey']        = ''\n            self._Session['SessionKey']        = ''\n            self._Session['SigningActivated']  = False\n            self._Session['CalculatePreAuthHash'] = False\n            self._Session['PreauthIntegrityHashValue'] = a2b_hex(b'0'*128)\n            raise Exception('Unsuccessful Login')",
  "def login(self, user, password, domain = '', lmhash = '', nthash = ''):\n        # If we have hashes, normalize them\n        if lmhash != '' or nthash != '':\n            if len(lmhash) % 2:     lmhash = '0%s' % lmhash\n            if len(nthash) % 2:     nthash = '0%s' % nthash\n            try: # just in case they were converted already\n                lmhash = a2b_hex(lmhash)\n                nthash = a2b_hex(nthash)\n            except:\n                pass\n\n        self.__userName = user\n        self.__password = password\n        self.__domain   = domain\n        self.__lmhash   = lmhash\n        self.__nthash   = nthash\n        self.__aesKey   = ''\n        self.__TGT      = None\n        self.__TGS      = None\n\n        sessionSetup = SMB2SessionSetup()\n        if self.RequireMessageSigning is True:\n           sessionSetup['SecurityMode'] = SMB2_NEGOTIATE_SIGNING_REQUIRED\n        else:\n           sessionSetup['SecurityMode'] = SMB2_NEGOTIATE_SIGNING_ENABLED\n\n        sessionSetup['Flags'] = 0\n        #sessionSetup['Capabilities'] = SMB2_GLOBAL_CAP_LARGE_MTU | SMB2_GLOBAL_CAP_LEASING | SMB2_GLOBAL_CAP_DFS\n\n        # Let's build a NegTokenInit with the NTLMSSP\n        # TODO: In the future we should be able to choose different providers\n\n        blob = SPNEGO_NegTokenInit()\n\n        # NTLMSSP\n        blob['MechTypes'] = [TypesMech['NTLMSSP - Microsoft NTLM Security Support Provider']]\n        auth = ntlm.getNTLMSSPType1(self._Connection['ClientName'],domain, self._Connection['RequireSigning'])\n        blob['MechToken'] = auth.getData()\n\n        sessionSetup['SecurityBufferLength'] = len(blob)\n        sessionSetup['Buffer']               = blob.getData()\n\n        # ToDo:\n        # If this authentication is for establishing an alternative channel for an existing Session, as specified\n        # in section 3.2.4.1.7, the client MUST also set the following values:\n        # The SessionId field in the SMB2 header MUST be set to the Session.SessionId for the new\n        # channel being established.\n        # The SMB2_SESSION_FLAG_BINDING bit MUST be set in the Flags field.\n        # The PreviousSessionId field MUST be set to zero.\n\n        packet = self.SMB_PACKET()\n        packet['Command'] = SMB2_SESSION_SETUP\n        packet['Data']    = sessionSetup\n\n        # Initiate session preauth hash\n        self._Session['PreauthIntegrityHashValue'] = self._Connection['PreauthIntegrityHashValue']\n\n        packetID = self.sendSMB(packet)\n        ans = self.recvSMB(packetID)\n        if self._Connection['Dialect'] == SMB2_DIALECT_311:\n            self.__UpdatePreAuthHash (ans.rawData)\n\n        if ans.isValidAnswer(STATUS_MORE_PROCESSING_REQUIRED):\n            self._Session['SessionID']       = ans['SessionID']\n            self._Session['SigningRequired'] = self._Connection['RequireSigning']\n            self._Session['UserCredentials'] = (user, password, domain, lmhash, nthash)\n            self._Session['Connection']      = self._NetBIOSSession.get_socket()\n            sessionSetupResponse = SMB2SessionSetup_Response(ans['Data'])\n            respToken = SPNEGO_NegTokenResp(sessionSetupResponse['Buffer'])\n\n            # Let's parse some data and keep it to ourselves in case it is asked\n            ntlmChallenge = ntlm.NTLMAuthChallenge(respToken['ResponseToken'])\n            if ntlmChallenge['TargetInfoFields_len'] > 0:\n                av_pairs = ntlm.AV_PAIRS(ntlmChallenge['TargetInfoFields'][:ntlmChallenge['TargetInfoFields_len']])\n                if av_pairs[ntlm.NTLMSSP_AV_HOSTNAME] is not None:\n                   try:\n                       self._Session['ServerName'] = av_pairs[ntlm.NTLMSSP_AV_HOSTNAME][1].decode('utf-16le')\n                   except:\n                       # For some reason, we couldn't decode Unicode here.. silently discard the operation\n                       pass\n                if av_pairs[ntlm.NTLMSSP_AV_DOMAINNAME] is not None:\n                   try:\n                       if self._Session['ServerName'] != av_pairs[ntlm.NTLMSSP_AV_DOMAINNAME][1].decode('utf-16le'):\n                           self._Session['ServerDomain'] = av_pairs[ntlm.NTLMSSP_AV_DOMAINNAME][1].decode('utf-16le')\n                   except:\n                       # For some reason, we couldn't decode Unicode here.. silently discard the operation\n                       pass\n                if av_pairs[ntlm.NTLMSSP_AV_DNS_DOMAINNAME] is not None:\n                   try:\n                       self._Session['ServerDNSDomainName'] = av_pairs[ntlm.NTLMSSP_AV_DNS_DOMAINNAME][1].decode('utf-16le')\n                   except:\n                       # For some reason, we couldn't decode Unicode here.. silently discard the operation\n                       pass\n\n                if av_pairs[ntlm.NTLMSSP_AV_DNS_HOSTNAME] is not None:\n                   try:\n                       self._Session['ServerDNSHostName'] = av_pairs[ntlm.NTLMSSP_AV_DNS_HOSTNAME][1].decode('utf-16le')\n                   except:\n                       # For some reason, we couldn't decode Unicode here.. silently discard the operation\n                       pass\n\n                if self._strict_hostname_validation:\n                    self.perform_hostname_validation()\n\n                # Parse Version to know the target Operating system name. Not provided elsewhere anymore\n                if 'Version' in ntlmChallenge.fields:\n                    version = ntlmChallenge['Version']\n\n                    if len(version) >= 4:\n                        self._Session['ServerOS'] = \"Windows %d.%d Build %d\" % (indexbytes(version,0), indexbytes(version,1), struct.unpack('<H',version[2:4])[0])\n                        self._Session[\"ServerOSMajor\"] = indexbytes(version,0)\n                        self._Session[\"ServerOSMinor\"] = indexbytes(version,1)\n                        self._Session[\"ServerOSBuild\"] = struct.unpack('<H',version[2:4])[0]\n\n            type3, exportedSessionKey = ntlm.getNTLMSSPType3(auth, respToken['ResponseToken'], user, password, domain, lmhash, nthash)\n\n\n\n            respToken2 = SPNEGO_NegTokenResp()\n            respToken2['ResponseToken'] = type3.getData()\n\n            # Reusing the previous structure\n            sessionSetup['SecurityBufferLength'] = len(respToken2)\n            sessionSetup['Buffer']               = respToken2.getData()\n\n            packetID = self.sendSMB(packet)\n            packet = self.recvSMB(packetID)\n\n            # Let's calculate Key Materials before moving on\n            if exportedSessionKey is not None:\n                self._Session['SessionKey']  = exportedSessionKey\n                if self._Session['SigningRequired'] is True and self._Connection['Dialect'] >= SMB2_DIALECT_30:\n                    # If Connection.Dialect is \"3.1.1\", the case-sensitive ASCII string \"SMBSigningKey\" as the label;\n                    # otherwise, the case - sensitive ASCII string \"SMB2AESCMAC\" as the label.\n                    # If Connection.Dialect is \"3.1.1\", Session.PreauthIntegrityHashValue as the context; otherwise,\n                    # the case-sensitive ASCII string \"SmbSign\" as context for the algorithm.\n                    if self._Connection['Dialect'] == SMB2_DIALECT_311:\n                        self._Session['SigningKey'] = crypto.KDF_CounterMode (exportedSessionKey,\n                                                                              b\"SMBSigningKey\\x00\",\n                                                                              self._Session['PreauthIntegrityHashValue'],\n                                                                              128)\n                    else:\n                        self._Session['SigningKey'] = crypto.KDF_CounterMode (exportedSessionKey, b\"SMB2AESCMAC\\x00\",\n                                                                              b\"SmbSign\\x00\", 128)\n            try:\n                if packet.isValidAnswer(STATUS_SUCCESS):\n                    sessionSetupResponse = SMB2SessionSetup_Response(packet['Data'])\n                    self._Session['SessionFlags'] = sessionSetupResponse['SessionFlags']\n                    self._Session['SessionID']    = packet['SessionID']\n\n                    # Do not encrypt anonymous connections\n                    if user == '' or self.isGuestSession():\n                        self._Connection['SupportsEncryption'] = False\n\n                    # Calculate the key derivations for dialect 3.0\n                    if self._Session['SigningRequired'] is True:\n                        self._Session['SigningActivated'] = True\n                    if self._Connection['Dialect'] >= SMB2_DIALECT_30 and self._Connection['SupportsEncryption'] is True:\n                        # SMB 3.0. Encryption available. Let's enforce it if we have AES CCM available\n                        self._Session['SessionFlags'] |= SMB2_SESSION_FLAG_ENCRYPT_DATA\n                        # Application Key\n                        # If Connection.Dialect is \"3.1.1\",the case-sensitive ASCII string \"SMBAppKey\" as the label;\n                        # otherwise, the case-sensitive ASCII string \"SMB2APP\" as the label. Session.PreauthIntegrityHashValue\n                        # as the context; otherwise, the case-sensitive ASCII string \"SmbRpc\" as context for the algorithm.\n                        # Encryption Key\n                        # If Connection.Dialect is \"3.1.1\",the case-sensitive ASCII string \"SMBC2SCipherKey\" as # the label;\n                        # otherwise, the case-sensitive ASCII string \"SMB2AESCCM\" as the label. Session.PreauthIntegrityHashValue\n                        # as the context; otherwise, the case-sensitive ASCII string \"ServerIn \" as context for the algorithm\n                        # (note the blank space at the end)\n                        # Decryption Key\n                        # If Connection.Dialect is \"3.1.1\", the case-sensitive ASCII string \"SMBS2CCipherKey\" as the label;\n                        # otherwise, the case-sensitive ASCII string \"SMB2AESCCM\" as the label. Session.PreauthIntegrityHashValue\n                        # as the context; otherwise, the case-sensitive ASCII string \"ServerOut\" as context for the algorithm.\n                        if self._Connection['Dialect'] == SMB2_DIALECT_311:\n                            self._Session['ApplicationKey']  = crypto.KDF_CounterMode(exportedSessionKey, b\"SMBAppKey\\x00\",\n                                                                             self._Session['PreauthIntegrityHashValue'], 128)\n                            self._Session['EncryptionKey']   = crypto.KDF_CounterMode(exportedSessionKey, b\"SMBC2SCipherKey\\x00\",\n                                                                             self._Session['PreauthIntegrityHashValue'], 128)\n                            self._Session['DecryptionKey'] = crypto.KDF_CounterMode (exportedSessionKey, b\"SMBS2CCipherKey\\x00\",\n                                                                             self._Session['PreauthIntegrityHashValue'], 128)\n\n                        else:\n                            self._Session['ApplicationKey'] = crypto.KDF_CounterMode (exportedSessionKey, b\"SMB2APP\\x00\",\n                                                                                      b\"SmbRpc\\x00\", 128)\n                            self._Session['EncryptionKey'] = crypto.KDF_CounterMode (exportedSessionKey, b\"SMB2AESCCM\\x00\",\n                                                                                     b\"ServerIn \\x00\", 128)\n                            self._Session['DecryptionKey'] = crypto.KDF_CounterMode (exportedSessionKey, b\"SMB2AESCCM\\x00\",\n                                                                                     b\"ServerOut\\x00\", 128)\n                    self._Session['CalculatePreAuthHash'] = False\n                    return True\n            except:\n                # We clean the stuff we used in case we want to authenticate again\n                # within the same connection\n                self._Session['UserCredentials']   = ''\n                self._Session['Connection']        = 0\n                self._Session['SessionID']         = 0\n                self._Session['SigningRequired']   = False\n                self._Session['SigningKey']        = ''\n                self._Session['SessionKey']        = ''\n                self._Session['SigningActivated']  = False\n                self._Session['CalculatePreAuthHash'] = False\n                self._Session['PreauthIntegrityHashValue'] = a2b_hex(b'0'*128)\n                raise",
  "def connectTree(self, share):\n\n        # Just in case this came with the full path (maybe an SMB1 client), let's just leave\n        # the sharename, we'll take care of the rest\n\n        #print self._Session['TreeConnectTable']\n        share = share.split('\\\\')[-1]\n        if share in self._Session['TreeConnectTable']:\n            # Already connected, no need to reconnect\n            treeEntry =  self._Session['TreeConnectTable'][share]\n            treeEntry['NumberOfUses'] += 1\n            self._Session['TreeConnectTable'][treeEntry['TreeConnectId']]['NumberOfUses'] += 1\n            return treeEntry['TreeConnectId']\n\n        #path = share\n        try:\n            _, _, _, _, sockaddr = socket.getaddrinfo(self._Connection['ServerIP'], 80, 0, 0, socket.IPPROTO_TCP)[0]\n            remoteHost = sockaddr[0]\n        except:\n            remoteHost = self._Connection['ServerIP']\n        path = '\\\\\\\\' + remoteHost + '\\\\' +share\n\n        treeConnect = SMB2TreeConnect()\n        treeConnect['Buffer']     = path.encode('utf-16le')\n        treeConnect['PathLength'] = len(path)*2\n\n        packet = self.SMB_PACKET()\n        packet['Command'] = SMB2_TREE_CONNECT\n        packet['Data'] = treeConnect\n        packetID = self.sendSMB(packet)\n        packet = self.recvSMB(packetID)\n        if packet.isValidAnswer(STATUS_SUCCESS):\n           treeConnectResponse = SMB2TreeConnect_Response(packet['Data'])\n           treeEntry = copy.deepcopy(TREE_CONNECT)\n           treeEntry['ShareName']     = share\n           treeEntry['TreeConnectId'] = packet['TreeID']\n           treeEntry['Session']       = packet['SessionID']\n           treeEntry['NumberOfUses'] += 1\n           if (treeConnectResponse['Capabilities'] & SMB2_SHARE_CAP_DFS) == SMB2_SHARE_CAP_DFS:\n               treeEntry['IsDfsShare'] = True\n           if (treeConnectResponse['Capabilities'] & SMB2_SHARE_CAP_CONTINUOUS_AVAILABILITY) == SMB2_SHARE_CAP_CONTINUOUS_AVAILABILITY:\n               treeEntry['IsCAShare'] = True\n\n           if self._Connection['Dialect'] >= SMB2_DIALECT_30:\n               if (self._Connection['SupportsEncryption'] is True) and ((treeConnectResponse['ShareFlags'] & SMB2_SHAREFLAG_ENCRYPT_DATA) == SMB2_SHAREFLAG_ENCRYPT_DATA):\n                   treeEntry['EncryptData'] = True\n                   # ToDo: This and what follows\n                   # If Session.EncryptData is FALSE, the client MUST then generate an encryption key, a\n                   # decryption key as specified in section 3.1.4.2, by providing the following inputs and store\n                   # them in Session.EncryptionKey and Session.DecryptionKey:\n               if (treeConnectResponse['Capabilities'] & SMB2_SHARE_CAP_SCALEOUT) == SMB2_SHARE_CAP_SCALEOUT:\n                   treeEntry['IsScaleoutShare'] = True\n\n           self._Session['TreeConnectTable'][packet['TreeID']] = treeEntry\n           self._Session['TreeConnectTable'][share]            = treeEntry\n\n           return packet['TreeID']",
  "def disconnectTree(self, treeId):\n        if (treeId in self._Session['TreeConnectTable']) is False:\n            raise SessionError(STATUS_INVALID_PARAMETER)\n\n        if treeId in self._Session['TreeConnectTable']:\n            # More than 1 use? descrease it and return, if not, send the packet\n            if self._Session['TreeConnectTable'][treeId]['NumberOfUses'] > 1:\n                treeEntry =  self._Session['TreeConnectTable'][treeId]\n                treeEntry['NumberOfUses'] -= 1\n                self._Session['TreeConnectTable'][treeEntry['ShareName']]['NumberOfUses'] -= 1\n                return True\n\n        packet = self.SMB_PACKET()\n        packet['Command'] = SMB2_TREE_DISCONNECT\n        packet['TreeID'] = treeId\n        treeDisconnect = SMB2TreeDisconnect()\n        packet['Data'] = treeDisconnect\n        packetID = self.sendSMB(packet)\n        packet = self.recvSMB(packetID)\n        if packet.isValidAnswer(STATUS_SUCCESS):\n            shareName = self._Session['TreeConnectTable'][treeId]['ShareName']\n            del(self._Session['TreeConnectTable'][shareName])\n            del(self._Session['TreeConnectTable'][treeId])\n            filesIDToBeRemoved = []\n            for fileID in list(self._Session['OpenTable'].keys()):\n                if self._Session['OpenTable'][fileID]['TreeConnect'] == treeId:\n                    filesIDToBeRemoved.append(fileID)\n            for fileIDToBeRemoved in filesIDToBeRemoved:\n                del(self._Session['OpenTable'][fileIDToBeRemoved])\n            return True",
  "def create(self, treeId, fileName, desiredAccess, shareMode, creationOptions, creationDisposition, fileAttributes, impersonationLevel = SMB2_IL_IMPERSONATION, securityFlags = 0, oplockLevel = SMB2_OPLOCK_LEVEL_NONE, createContexts = None):\n        if (treeId in self._Session['TreeConnectTable']) is False:\n            raise SessionError(STATUS_INVALID_PARAMETER)\n\n        fileName = fileName.replace('/', '\\\\')\n        if len(fileName) > 0:\n            fileName = ntpath.normpath(fileName)\n            if fileName[0] == '\\\\':\n                fileName = fileName[1:]\n\n        if self._Session['TreeConnectTable'][treeId]['IsDfsShare'] is True:\n            pathName = fileName\n        else:\n            pathName = '\\\\\\\\' + self._Connection['ServerName'] + '\\\\' + fileName\n\n        fileEntry = copy.deepcopy(FILE)\n        fileEntry['LeaseKey']   = uuid.generate()\n        fileEntry['LeaseState'] = SMB2_LEASE_NONE\n        self.GlobalFileTable[pathName] = fileEntry\n\n        if self._Connection['Dialect'] >= SMB2_DIALECT_30 and self._Connection['SupportsDirectoryLeasing'] is True:\n           # Is this file NOT on the root directory?\n           if len(fileName.split('\\\\')) > 2:\n               parentDir = ntpath.dirname(pathName)\n           if parentDir in self.GlobalFileTable:\n               raise Exception(\"Don't know what to do now! :-o\")\n           else:\n               parentEntry = copy.deepcopy(FILE)\n               parentEntry['LeaseKey']   = uuid.generate()\n               parentEntry['LeaseState'] = SMB2_LEASE_NONE\n               self.GlobalFileTable[parentDir] = parentEntry\n\n        packet = self.SMB_PACKET()\n        packet['Command'] = SMB2_CREATE\n        packet['TreeID']  = treeId\n        if self._Session['TreeConnectTable'][treeId]['IsDfsShare'] is True:\n            packet['Flags'] = SMB2_FLAGS_DFS_OPERATIONS\n\n        smb2Create = SMB2Create()\n        smb2Create['SecurityFlags']        = 0\n        smb2Create['RequestedOplockLevel'] = oplockLevel\n        smb2Create['ImpersonationLevel']   = impersonationLevel\n        smb2Create['DesiredAccess']        = desiredAccess\n        smb2Create['FileAttributes']       = fileAttributes\n        smb2Create['ShareAccess']          = shareMode\n        smb2Create['CreateDisposition']    = creationDisposition\n        smb2Create['CreateOptions']        = creationOptions\n\n        smb2Create['NameLength']           = len(fileName)*2\n        if fileName != '':\n            smb2Create['Buffer']           = fileName.encode('utf-16le')\n        else:\n            smb2Create['Buffer']           = b'\\x00'\n\n        if createContexts is not None:\n            contextsBuf = b''.join(x.getData() for x in createContexts)\n            smb2Create['CreateContextsOffset'] = len(SMB2Packet()) + SMB2Create.SIZE + len(smb2Create['Buffer'])\n\n            # pad offset to 8-byte align\n            if (smb2Create['CreateContextsOffset'] % 8):\n                smb2Create['Buffer'] += b'\\x00'*(8-(smb2Create['CreateContextsOffset'] % 8))\n                smb2Create['CreateContextsOffset'] = len(SMB2Packet()) + SMB2Create.SIZE + len(smb2Create['Buffer'])\n\n            smb2Create['CreateContextsLength'] = len(contextsBuf)\n            smb2Create['Buffer'] += contextsBuf\n        else:\n            smb2Create['CreateContextsOffset'] = 0\n            smb2Create['CreateContextsLength'] = 0\n\n        packet['Data'] = smb2Create\n\n        packetID = self.sendSMB(packet)\n        ans = self.recvSMB(packetID)\n        if ans.isValidAnswer(STATUS_SUCCESS):\n            createResponse = SMB2Create_Response(ans['Data'])\n\n            openFile = copy.deepcopy(OPEN)\n            openFile['FileID']      = createResponse['FileID']\n            openFile['TreeConnect'] = treeId\n            openFile['Oplocklevel'] = oplockLevel\n            openFile['Durable']     = False\n            openFile['ResilientHandle']    = False\n            openFile['LastDisconnectTime'] = 0\n            openFile['FileName'] = pathName\n\n            # ToDo: Complete the OperationBuckets\n            if self._Connection['Dialect'] >= SMB2_DIALECT_30:\n                openFile['DesiredAccess']     = oplockLevel\n                openFile['ShareMode']         = oplockLevel\n                openFile['CreateOptions']     = oplockLevel\n                openFile['FileAttributes']    = oplockLevel\n                openFile['CreateDisposition'] = oplockLevel\n\n            # ToDo: Process the contexts\n            self._Session['OpenTable'][createResponse['FileID'].getData()] = openFile\n\n            # The client MUST generate a handle for the Open, and it MUST\n            # return success and the generated handle to the calling application.\n            # In our case, str(FileID)\n            return createResponse['FileID'].getData()",
  "def close(self, treeId, fileId):\n        if (treeId in self._Session['TreeConnectTable']) is False:\n            raise SessionError(STATUS_INVALID_PARAMETER)\n        if (fileId in self._Session['OpenTable']) is False:\n            raise SessionError(STATUS_INVALID_PARAMETER)\n\n        packet = self.SMB_PACKET()\n        packet['Command'] = SMB2_CLOSE\n        packet['TreeID']  = treeId\n\n        smbClose = SMB2Close()\n        smbClose['Flags']  = 0\n        smbClose['FileID'] = fileId\n\n        packet['Data'] = smbClose\n\n        packetID = self.sendSMB(packet)\n        ans = self.recvSMB(packetID)\n\n        if ans.isValidAnswer(STATUS_SUCCESS):\n            del(self.GlobalFileTable[self._Session['OpenTable'][fileId]['FileName']])\n            del(self._Session['OpenTable'][fileId])\n\n            # ToDo Remove stuff from GlobalFileTable\n            return True",
  "def read(self, treeId, fileId, offset = 0, bytesToRead = 0, waitAnswer = True):\n        # IMPORTANT NOTE: As you can see, this was coded as a recursive function\n        # Hence, you can exhaust the memory pretty easy ( large bytesToRead )\n        # This function should NOT be used for reading files directly, but another higher\n        # level function should be used that will break the read into smaller pieces\n\n        if (treeId in self._Session['TreeConnectTable']) is False:\n            raise SessionError(STATUS_INVALID_PARAMETER)\n        if (fileId in self._Session['OpenTable']) is False:\n            raise SessionError(STATUS_INVALID_PARAMETER)\n\n        packet = self.SMB_PACKET()\n        packet['Command'] = SMB2_READ\n        packet['TreeID']  = treeId\n\n        if self._Connection['MaxReadSize'] < bytesToRead:\n            maxBytesToRead = self._Connection['MaxReadSize']\n        else:\n            maxBytesToRead = bytesToRead\n\n        if self._Connection['Dialect'] != SMB2_DIALECT_002 and self._Connection['SupportsMultiCredit'] is True:\n            packet['CreditCharge'] = ( 1 + (maxBytesToRead - 1) // 65536)\n        else:\n            maxBytesToRead = min(65536,bytesToRead)\n\n        smbRead = SMB2Read()\n        smbRead['Padding']  = 0x50\n        smbRead['FileID']   = fileId\n        smbRead['Length']   = maxBytesToRead\n        smbRead['Offset']   = offset\n        packet['Data'] = smbRead\n\n        packetID = self.sendSMB(packet)\n        ans = self.recvSMB(packetID)\n\n        if ans.isValidAnswer(STATUS_SUCCESS):\n            readResponse = SMB2Read_Response(ans['Data'])\n            retData = readResponse['Buffer']\n            if readResponse['DataRemaining'] > 0:\n                retData += self.read(treeId, fileId, offset+len(retData), readResponse['DataRemaining'], waitAnswer)\n            return retData",
  "def write(self, treeId, fileId, data, offset = 0, bytesToWrite = 0, waitAnswer = True):\n        # IMPORTANT NOTE: As you can see, this was coded as a recursive function\n        # Hence, you can exhaust the memory pretty easy ( large bytesToWrite )\n        # This function should NOT be used for writing directly to files, but another higher\n        # level function should be used that will break the writes into smaller pieces\n\n        if (treeId in self._Session['TreeConnectTable']) is False:\n            raise SessionError(STATUS_INVALID_PARAMETER)\n        if (fileId in self._Session['OpenTable']) is False:\n            raise SessionError(STATUS_INVALID_PARAMETER)\n\n        packet = self.SMB_PACKET()\n        packet['Command'] = SMB2_WRITE\n        packet['TreeID']  = treeId\n\n        if self._Connection['MaxWriteSize'] < bytesToWrite:\n            maxBytesToWrite = self._Connection['MaxWriteSize']\n        else:\n            maxBytesToWrite = bytesToWrite\n\n        if self._Connection['Dialect'] != SMB2_DIALECT_002 and self._Connection['SupportsMultiCredit'] is True:\n            packet['CreditCharge'] = ( 1 + (maxBytesToWrite - 1) // 65536)\n        else:\n            maxBytesToWrite = min(65536,bytesToWrite)\n\n        smbWrite = SMB2Write()\n        smbWrite['FileID'] = fileId\n        smbWrite['Length'] = maxBytesToWrite\n        smbWrite['Offset'] = offset\n        smbWrite['WriteChannelInfoOffset'] = 0\n        smbWrite['Buffer'] = data[:maxBytesToWrite]\n        packet['Data'] = smbWrite\n\n        packetID = self.sendSMB(packet)\n        if waitAnswer is True:\n            ans = self.recvSMB(packetID)\n        else:\n            return maxBytesToWrite\n\n        if ans.isValidAnswer(STATUS_SUCCESS):\n            writeResponse = SMB2Write_Response(ans['Data'])\n            bytesWritten = writeResponse['Count']\n            if bytesWritten < bytesToWrite:\n                bytesWritten += self.write(treeId, fileId, data[bytesWritten:], offset+bytesWritten, bytesToWrite-bytesWritten, waitAnswer)\n            return bytesWritten",
  "def queryDirectory(self, treeId, fileId, searchString = '*', resumeIndex = 0, informationClass = FILENAMES_INFORMATION, maxBufferSize = None, enumRestart = False, singleEntry = False):\n        if (treeId in self._Session['TreeConnectTable']) is False:\n            raise SessionError(STATUS_INVALID_PARAMETER)\n        if (fileId in self._Session['OpenTable']) is False:\n            raise SessionError(STATUS_INVALID_PARAMETER)\n\n        packet = self.SMB_PACKET()\n        packet['Command'] = SMB2_QUERY_DIRECTORY\n        packet['TreeID']  = treeId\n\n        queryDirectory = SMB2QueryDirectory()\n        queryDirectory['FileInformationClass'] = informationClass\n        if resumeIndex != 0 :\n            queryDirectory['Flags'] = SMB2_INDEX_SPECIFIED\n        queryDirectory['FileIndex'] = resumeIndex\n        queryDirectory['FileID']    = fileId\n        if maxBufferSize is None:\n            maxBufferSize = self._Connection['MaxReadSize']\n        queryDirectory['OutputBufferLength'] = maxBufferSize\n        queryDirectory['FileNameLength']     = len(searchString)*2\n        queryDirectory['Buffer']             = searchString.encode('utf-16le')\n\n        packet['Data'] = queryDirectory\n\n        if self._Connection['Dialect'] != SMB2_DIALECT_002 and self._Connection['SupportsMultiCredit'] is True:\n            packet['CreditCharge'] = ( 1 + (maxBufferSize - 1) // 65536)\n\n        packetID = self.sendSMB(packet)\n        ans = self.recvSMB(packetID)\n        if ans.isValidAnswer(STATUS_SUCCESS):\n            queryDirectoryResponse = SMB2QueryDirectory_Response(ans['Data'])\n            return queryDirectoryResponse['Buffer']",
  "def echo(self):\n        packet = self.SMB_PACKET()\n        packet['Command'] = SMB2_ECHO\n        smbEcho = SMB2Echo()\n        packet['Data'] = smbEcho\n        packetID = self.sendSMB(packet)\n        ans = self.recvSMB(packetID)\n        if ans.isValidAnswer(STATUS_SUCCESS):\n            return True",
  "def cancel(self, packetID):\n        packet = self.SMB_PACKET()\n        packet['Command']   = SMB2_CANCEL\n        packet['MessageID'] = packetID\n\n        smbCancel = SMB2Cancel()\n\n        packet['Data']      = smbCancel\n        self.sendSMB(packet)",
  "def ioctl(self, treeId, fileId = None, ctlCode = -1, flags = 0, inputBlob = '',  maxInputResponse = None, maxOutputResponse = None, waitAnswer = 1):\n        if (treeId in self._Session['TreeConnectTable']) is False:\n            raise SessionError(STATUS_INVALID_PARAMETER)\n        if fileId is None:\n            fileId = '\\xff'*16\n        else:\n            if (fileId in self._Session['OpenTable']) is False:\n                raise SessionError(STATUS_INVALID_PARAMETER)\n\n        packet = self.SMB_PACKET()\n        packet['Command']            = SMB2_IOCTL\n        packet['TreeID']             = treeId\n\n        smbIoctl = SMB2Ioctl()\n        smbIoctl['FileID']             = fileId\n        smbIoctl['CtlCode']            = ctlCode\n        smbIoctl['MaxInputResponse']   = maxInputResponse\n        smbIoctl['MaxOutputResponse']  = maxOutputResponse\n        smbIoctl['InputCount']         = len(inputBlob)\n        if len(inputBlob) == 0:\n            smbIoctl['InputOffset'] = 0\n            smbIoctl['Buffer']      = '\\x00'\n        else:\n            smbIoctl['Buffer']             = inputBlob\n        smbIoctl['OutputOffset']       = 0\n        smbIoctl['MaxOutputResponse']  = maxOutputResponse\n        smbIoctl['Flags']              = flags\n\n        packet['Data'] = smbIoctl\n\n        packetID = self.sendSMB(packet)\n\n        if waitAnswer == 0:\n            return True\n\n        ans = self.recvSMB(packetID)\n\n        if ans.isValidAnswer(STATUS_SUCCESS):\n            smbIoctlResponse = SMB2Ioctl_Response(ans['Data'])\n            return smbIoctlResponse['Buffer']",
  "def flush(self,treeId, fileId):\n        if (treeId in self._Session['TreeConnectTable']) is False:\n            raise SessionError(STATUS_INVALID_PARAMETER)\n        if (fileId in self._Session['OpenTable']) is False:\n            raise SessionError(STATUS_INVALID_PARAMETER)\n\n        packet = self.SMB_PACKET()\n        packet['Command'] = SMB2_FLUSH\n        packet['TreeID']  = treeId\n\n        smbFlush = SMB2Flush()\n        smbFlush['FileID'] = fileId\n\n        packet['Data'] = smbFlush\n\n        packetID = self.sendSMB(packet)\n        ans = self.recvSMB(packetID)\n\n        if ans.isValidAnswer(STATUS_SUCCESS):\n            return True",
  "def lock(self, treeId, fileId, locks, lockSequence = 0):\n        if (treeId in self._Session['TreeConnectTable']) is False:\n            raise SessionError(STATUS_INVALID_PARAMETER)\n        if (fileId in self._Session['OpenTable']) is False:\n            raise SessionError(STATUS_INVALID_PARAMETER)\n\n        packet = self.SMB_PACKET()\n        packet['Command'] = SMB2_LOCK\n        packet['TreeID']  = treeId\n\n        smbLock = SMB2Lock()\n        smbLock['FileID']       = fileId\n        smbLock['LockCount']    = len(locks)\n        smbLock['LockSequence'] = lockSequence\n        smbLock['Locks']        = ''.join(str(x) for x in locks)\n\n        packet['Data'] = smbLock\n\n        packetID = self.sendSMB(packet)\n        ans = self.recvSMB(packetID)\n\n        if ans.isValidAnswer(STATUS_SUCCESS):\n            smbFlushResponse = SMB2Lock_Response(ans['Data'])\n            return True",
  "def logoff(self):\n        packet = self.SMB_PACKET()\n        packet['Command'] = SMB2_LOGOFF\n\n        smbLogoff = SMB2Logoff()\n\n        packet['Data'] = smbLogoff\n\n        packetID = self.sendSMB(packet)\n        ans = self.recvSMB(packetID)\n\n        if ans.isValidAnswer(STATUS_SUCCESS):\n            # We clean the stuff we used in case we want to authenticate again\n            # within the same connection\n            self._Session['UserCredentials']   = ''\n            self._Session['Connection']        = 0\n            self._Session['SessionID']         = 0\n            self._Session['SigningRequired']   = False\n            self._Session['SigningKey']        = ''\n            self._Session['SessionKey']        = ''\n            self._Session['SigningActivated']  = False\n            return True",
  "def queryInfo(self, treeId, fileId, inputBlob = '', infoType = SMB2_0_INFO_FILE, fileInfoClass = SMB2_FILE_STANDARD_INFO, additionalInformation = 0, flags = 0 ):\n        if (treeId in self._Session['TreeConnectTable']) is False:\n            raise SessionError(STATUS_INVALID_PARAMETER)\n        if (fileId in self._Session['OpenTable']) is False:\n            raise SessionError(STATUS_INVALID_PARAMETER)\n\n        packet = self.SMB_PACKET()\n        packet['Command'] = SMB2_QUERY_INFO\n        packet['TreeID']  = treeId\n\n        queryInfo = SMB2QueryInfo()\n        queryInfo['FileID']                = fileId\n        queryInfo['InfoType']              = infoType\n        queryInfo['FileInfoClass']         = fileInfoClass\n        queryInfo['OutputBufferLength']    = 65535\n        queryInfo['AdditionalInformation'] = additionalInformation\n        if len(inputBlob) == 0:\n            queryInfo['InputBufferOffset'] = 0\n            queryInfo['Buffer']            = '\\x00'\n        else:\n            queryInfo['InputBufferLength'] = len(inputBlob)\n            queryInfo['Buffer']            = inputBlob\n        queryInfo['Flags']                 = flags\n\n        packet['Data'] = queryInfo\n        packetID = self.sendSMB(packet)\n        ans = self.recvSMB(packetID)\n\n        if ans.isValidAnswer(STATUS_SUCCESS):\n            queryResponse = SMB2QueryInfo_Response(ans['Data'])\n            return queryResponse['Buffer']",
  "def setInfo(self, treeId, fileId, inputBlob = '', infoType = SMB2_0_INFO_FILE, fileInfoClass = SMB2_FILE_STANDARD_INFO, additionalInformation = 0 ):\n        if (treeId in self._Session['TreeConnectTable']) is False:\n            raise SessionError(STATUS_INVALID_PARAMETER)\n        if (fileId in self._Session['OpenTable']) is False:\n            raise SessionError(STATUS_INVALID_PARAMETER)\n\n        packet = self.SMB_PACKET()\n        packet['Command'] = SMB2_SET_INFO\n        packet['TreeID']  = treeId\n\n        setInfo = SMB2SetInfo()\n        setInfo['InfoType']              = infoType\n        setInfo['FileInfoClass']         = fileInfoClass\n        setInfo['BufferLength']          = len(inputBlob)\n        setInfo['AdditionalInformation'] = additionalInformation\n        setInfo['FileID']                = fileId\n        setInfo['Buffer']                = inputBlob\n\n        packet['Data'] = setInfo\n        packetID = self.sendSMB(packet)\n        ans = self.recvSMB(packetID)\n\n        if ans.isValidAnswer(STATUS_SUCCESS):\n            return True",
  "def getSessionKey(self):\n        if self.getDialect() >= SMB2_DIALECT_30:\n           return self._Session['ApplicationKey']\n        else:\n           return self._Session['SessionKey']",
  "def setSessionKey(self, key):\n        if self.getDialect() >= SMB2_DIALECT_30:\n           self._Session['ApplicationKey'] = key\n        else:\n           self._Session['SessionKey'] = key",
  "def rename(self, shareName, oldPath, newPath):\n        oldPath = oldPath.replace('/', '\\\\')\n        oldPath = ntpath.normpath(oldPath)\n        if len(oldPath) > 0 and oldPath[0] == '\\\\':\n            oldPath = oldPath[1:]\n\n        newPath = newPath.replace('/', '\\\\')\n        newPath = ntpath.normpath(newPath)\n        if len(newPath) > 0 and newPath[0] == '\\\\':\n            newPath = newPath[1:]\n\n        treeId = self.connectTree(shareName)\n        fileId = None\n        try:\n            fileId = self.create(treeId, oldPath, MAXIMUM_ALLOWED ,FILE_SHARE_READ | FILE_SHARE_WRITE |FILE_SHARE_DELETE, 0x200020, FILE_OPEN, 0)\n            renameReq = FILE_RENAME_INFORMATION_TYPE_2()\n            renameReq['ReplaceIfExists'] = 1\n            renameReq['RootDirectory']   = '\\x00'*8\n            renameReq['FileNameLength']  = len(newPath)*2\n            renameReq['FileName']        = newPath.encode('utf-16le')\n            self.setInfo(treeId, fileId, renameReq, infoType = SMB2_0_INFO_FILE, fileInfoClass = SMB2_FILE_RENAME_INFO)\n        finally:\n            if fileId is not None:\n                self.close(treeId, fileId)\n            self.disconnectTree(treeId)\n\n        return True",
  "def writeFile(self, treeId, fileId, data, offset = 0):\n        finished = False\n        writeOffset = offset\n        while not finished:\n            if len(data) == 0:\n                break\n            writeData = data[:self._Connection['MaxWriteSize']]\n            data = data[self._Connection['MaxWriteSize']:]\n            written = self.write(treeId, fileId, writeData, writeOffset, len(writeData))\n            writeOffset += written\n        return writeOffset - offset",
  "def isSnapshotRequest(self, path):\n        #TODO: use a regex here?\n        return '@GMT-' in path",
  "def timestampForSnapshot(self, path):\n        timestamp = path[path.index(\"@GMT-\"):path.index(\"@GMT-\")+24]\n        path = path.replace(timestamp, '')\n        from datetime import datetime\n        fTime = int((datetime.strptime(timestamp, '@GMT-%Y.%m.%d-%H.%M.%S') - datetime(1970,1,1)).total_seconds())\n        fTime *= 10000000\n        fTime += 116444736000000000\n\n        token = SMB2_CREATE_TIMEWARP_TOKEN()\n        token['Timestamp'] = fTime\n\n        ctx = SMB2CreateContext()\n        ctx['Next'] = 0\n        ctx['NameOffset'] = 16\n        ctx['NameLength'] = len('TWrp')\n        ctx['DataOffset'] = 24\n        ctx['DataLength'] = 8\n        ctx['Buffer'] = b'TWrp'\n        ctx['Buffer'] += b'\\x00'*4 # 4 bytes to 8-byte align\n        ctx['Buffer'] += token.getData()\n\n        # fix-up the path\n        path = path.replace(timestamp, '').replace('\\\\\\\\', '\\\\')\n        if path == '\\\\':\n            path += '*'\n        return path, ctx",
  "def listPath(self, shareName, path, password = None):\n        createContexts = None\n\n        if self.isSnapshotRequest(path):\n            createContexts = []\n            path, ctx = self.timestampForSnapshot(path)\n            createContexts.append(ctx)\n\n        # ToDo: Handle situations where share is password protected\n        path = path.replace('/', '\\\\')\n        path = ntpath.normpath(path)\n        if len(path) > 0 and path[0] == '\\\\':\n            path = path[1:]\n\n        treeId = self.connectTree(shareName)\n\n        fileId = None\n        try:\n            # ToDo, we're assuming it's a directory, we should check what the file type is\n            fileId = self.create(treeId, ntpath.dirname(path), FILE_READ_ATTRIBUTES | FILE_READ_DATA, FILE_SHARE_READ |\n                                 FILE_SHARE_WRITE | FILE_SHARE_DELETE,\n                                 FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT, FILE_OPEN, 0,\n                                 createContexts=createContexts)\n            res = ''\n            files = []\n            from impacket import smb\n            while True:\n                try:\n                    res = self.queryDirectory(treeId, fileId, ntpath.basename(path), maxBufferSize=65535,\n                                              informationClass=FILE_FULL_DIRECTORY_INFORMATION)\n                    nextOffset = 1\n                    while nextOffset != 0:\n                        fileInfo = smb.SMBFindFileFullDirectoryInfo(smb.SMB.FLAGS2_UNICODE)\n                        fileInfo.fromString(res)\n                        files.append(smb.SharedFile(fileInfo['CreationTime'], fileInfo['LastAccessTime'],\n                                                    fileInfo['LastChangeTime'], fileInfo['EndOfFile'],\n                                                    fileInfo['AllocationSize'], fileInfo['ExtFileAttributes'],\n                                                    fileInfo['FileName'].decode('utf-16le'),\n                                                    fileInfo['FileName'].decode('utf-16le')))\n                        nextOffset = fileInfo['NextEntryOffset']\n                        res = res[nextOffset:]\n                except SessionError as e:\n                    if (e.get_error_code()) != STATUS_NO_MORE_FILES:\n                        raise\n                    break\n                except Exception as e:\n                    print(str(e))\n                    raise\n        finally:\n            if fileId is not None:\n                self.close(treeId, fileId)\n            self.disconnectTree(treeId)\n\n        return files",
  "def mkdir(self, shareName, pathName, password = None):\n        # ToDo: Handle situations where share is password protected\n        pathName = pathName.replace('/', '\\\\')\n        pathName = ntpath.normpath(pathName)\n        if len(pathName) > 0 and pathName[0] == '\\\\':\n            pathName = pathName[1:]\n\n        treeId = self.connectTree(shareName)\n\n        fileId = None\n        try:\n            fileId = self.create(treeId, pathName, GENERIC_ALL, FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,\n                                 FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT, FILE_CREATE, 0)\n        finally:\n            if fileId is not None:\n                self.close(treeId, fileId)\n            self.disconnectTree(treeId)\n\n        return True",
  "def rmdir(self, shareName, pathName, password = None):\n        # ToDo: Handle situations where share is password protected\n        pathName = pathName.replace('/', '\\\\')\n        pathName = ntpath.normpath(pathName)\n        if len(pathName) > 0 and pathName[0] == '\\\\':\n            pathName = pathName[1:]\n\n        treeId = self.connectTree(shareName)\n\n        fileId = None\n        try:\n            fileId = self.create(treeId, pathName, desiredAccess=DELETE | FILE_READ_ATTRIBUTES | SYNCHRONIZE,\n                                 shareMode=FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,\n                                 creationOptions=FILE_DIRECTORY_FILE | FILE_OPEN_REPARSE_POINT,\n                                 creationDisposition=FILE_OPEN, fileAttributes=0)\n            from impacket import smb\n            delete_req = smb.SMBSetFileDispositionInfo()\n            delete_req['DeletePending'] = True\n            self.setInfo(treeId, fileId, inputBlob=delete_req, fileInfoClass=SMB2_FILE_DISPOSITION_INFO)\n        finally:\n            if fileId is not None:\n                self.close(treeId, fileId)\n            self.disconnectTree(treeId)\n\n        return True",
  "def remove(self, shareName, pathName, password = None):\n        # ToDo: Handle situations where share is password protected\n        pathName = pathName.replace('/', '\\\\')\n        pathName = ntpath.normpath(pathName)\n        if len(pathName) > 0 and pathName[0] == '\\\\':\n            pathName = pathName[1:]\n\n        treeId = self.connectTree(shareName)\n\n        fileId = None\n        try:\n            fileId = self.create(treeId, pathName,DELETE | FILE_READ_ATTRIBUTES, FILE_SHARE_DELETE, FILE_NON_DIRECTORY_FILE | FILE_DELETE_ON_CLOSE, FILE_OPEN, 0)\n        finally:\n            if fileId is not None:\n                self.close(treeId, fileId)\n            self.disconnectTree(treeId)\n\n        return True",
  "def retrieveFile(self, shareName, path, callback, mode = FILE_OPEN, offset = 0, password = None, shareAccessMode = FILE_SHARE_READ):\n        createContexts = None\n\n        if self.isSnapshotRequest(path):\n            createContexts = []\n            path, ctx = self.timestampForSnapshot(path)\n            createContexts.append(ctx)\n\n        # ToDo: Handle situations where share is password protected\n        path = path.replace('/', '\\\\')\n        path = ntpath.normpath(path)\n        if len(path) > 0 and path[0] == '\\\\':\n            path = path[1:]\n\n        treeId = self.connectTree(shareName)\n        fileId = None\n        from impacket import smb\n        try:\n            fileId = self.create(treeId, path, FILE_READ_DATA, shareAccessMode, FILE_NON_DIRECTORY_FILE, mode, 0, createContexts=createContexts)\n            res = self.queryInfo(treeId, fileId)\n            fileInfo = smb.SMBQueryFileStandardInfo(res)\n            fileSize = fileInfo['EndOfFile']\n            if (fileSize-offset) < self._Connection['MaxReadSize']:\n                # Skip reading 0 bytes files.\n                if (fileSize-offset) > 0:\n                    data = self.read(treeId, fileId, offset, fileSize-offset)\n                    callback(data)\n            else:\n                written = 0\n                toBeRead = fileSize-offset\n                while written < toBeRead:\n                    data = self.read(treeId, fileId, offset, self._Connection['MaxReadSize'])\n                    written += len(data)\n                    offset  += len(data)\n                    callback(data)\n        finally:\n            if fileId is not None:\n                self.close(treeId, fileId)\n            self.disconnectTree(treeId)",
  "def storeFile(self, shareName, path, callback, mode = FILE_OVERWRITE_IF, offset = 0, password = None, shareAccessMode = FILE_SHARE_WRITE):\n        # ToDo: Handle situations where share is password protected\n        path = path.replace('/', '\\\\')\n        path = ntpath.normpath(path)\n        if len(path) > 0 and path[0] == '\\\\':\n            path = path[1:]\n\n        treeId = self.connectTree(shareName)\n        fileId = None\n        try:\n            fileId = self.create(treeId, path, FILE_WRITE_DATA, shareAccessMode, FILE_NON_DIRECTORY_FILE, mode, 0)\n            finished = False\n            writeOffset = offset\n            while not finished:\n                data = callback(self._Connection['MaxWriteSize'])\n                if len(data) == 0:\n                    break\n                written = self.write(treeId, fileId, data, writeOffset, len(data))\n                writeOffset += written\n        finally:\n            if fileId is not None:\n                self.close(treeId, fileId)\n            self.disconnectTree(treeId)",
  "def waitNamedPipe(self, treeId, pipename, timeout = 5):\n        pipename = ntpath.basename(pipename)\n        if (treeId in self._Session['TreeConnectTable']) is False:\n            raise SessionError(STATUS_INVALID_PARAMETER)\n        if len(pipename) > 0xffff:\n            raise SessionError(STATUS_INVALID_PARAMETER)\n\n        pipeWait = FSCTL_PIPE_WAIT_STRUCTURE()\n        pipeWait['Timeout']          = timeout*100000\n        pipeWait['NameLength']       = len(pipename)*2\n        pipeWait['TimeoutSpecified'] = 1\n        pipeWait['Name']             = pipename.encode('utf-16le')\n\n        return self.ioctl(treeId, None, FSCTL_PIPE_WAIT,flags=SMB2_0_IOCTL_IS_FSCTL, inputBlob=pipeWait, maxInputResponse = 0, maxOutputResponse=0)",
  "def getIOCapabilities(self):\n        res = dict()\n\n        res['MaxReadSize'] = self._Connection['MaxReadSize']\n        res['MaxWriteSize'] = self._Connection['MaxWriteSize']\n        return res",
  "def close_session(self):\n        if self._NetBIOSSession:\n            self._NetBIOSSession.close()\n            self._NetBIOSSession = None",
  "def doesSupportNTLMv2(self):\n        # Always true :P\n        return True",
  "def is_login_required(self):\n        # Always true :P\n        return True",
  "def is_signing_required(self):\n        return self._Connection['RequireSigning']",
  "def nt_create_andx(self, treeId, fileName, smb_packet=None, cmd = None):\n        if len(fileName) > 0 and fileName[0] == '\\\\':\n            fileName = fileName[1:]\n\n        if cmd is not None:\n            from impacket import smb\n            ntCreate = smb.SMBCommand(data = cmd.getData())\n            params = smb.SMBNtCreateAndX_Parameters(ntCreate['Parameters'])\n            return self.create(treeId, fileName, params['AccessMask'], params['ShareAccess'],\n                               params['CreateOptions'], params['Disposition'], params['FileAttributes'],\n                               params['Impersonation'], params['SecurityFlags'])\n\n        else:\n            return self.create(treeId, fileName,\n                    FILE_READ_DATA | FILE_WRITE_DATA | FILE_APPEND_DATA | FILE_READ_EA |\n                    FILE_WRITE_EA | FILE_WRITE_ATTRIBUTES | FILE_READ_ATTRIBUTES | READ_CONTROL,\n                    FILE_SHARE_READ | FILE_SHARE_WRITE, FILE_NON_DIRECTORY_FILE, FILE_OPEN, 0 )",
  "def get_socket(self):\n        return self._NetBIOSSession.get_socket()",
  "def write_andx(self,tid,fid,data, offset = 0, wait_answer=1, write_pipe_mode = False, smb_packet=None):\n        # ToDo: Handle the custom smb_packet situation\n        return self.write(tid, fid, data, offset, len(data))",
  "def TransactNamedPipe(self, tid, fid, data, noAnswer = 0, waitAnswer = 1, offset = 0):\n        return self.ioctl(tid, fid, FSCTL_PIPE_TRANSCEIVE, SMB2_0_IOCTL_IS_FSCTL, data, maxOutputResponse = 65535, waitAnswer = noAnswer | waitAnswer)",
  "def TransactNamedPipeRecv(self):\n        ans = self.recvSMB()\n\n        if ans.isValidAnswer(STATUS_SUCCESS):\n            smbIoctlResponse = SMB2Ioctl_Response(ans['Data'])\n            return smbIoctlResponse['Buffer']",
  "def read_andx(self, tid, fid, offset=0, max_size = None, wait_answer=1, smb_packet=None):\n        # ToDo: Handle the custom smb_packet situation\n        if max_size is None:\n            max_size = self._Connection['MaxReadSize']\n        return self.read(tid, fid, offset, max_size, wait_answer)",
  "def list_shared(self):\n        # In the context of SMB2/3, forget about the old LANMAN, throw NOT IMPLEMENTED\n        raise SessionError(STATUS_NOT_IMPLEMENTED)",
  "def open_andx(self, tid, fileName, open_mode, desired_access):\n        # ToDo Return all the attributes of the file\n        if len(fileName) > 0 and fileName[0] == '\\\\':\n            fileName = fileName[1:]\n\n        fileId = self.create(tid,fileName,desired_access, open_mode, FILE_NON_DIRECTORY_FILE, open_mode, 0)\n        return fileId, 0, 0, 0, 0, 0, 0, 0, 0",
  "def set_session_key(self, signingKey):\n        self._Session['SessionKey'] = signingKey\n        self._Session['SigningActivated'] = True\n        self._Session['SigningRequired'] = True",
  "def set_hostname_validation(self, validate, accept_empty, hostname):\n        self._strict_hostname_validation = validate\n        self._validation_allow_absent = accept_empty\n        self._accepted_hostname = hostname",
  "def perform_hostname_validation(self):\n        if self._Session['ServerName'] == '':\n            if not self._validation_allow_absent:\n                raise self.HostnameValidationException('Hostname was not supplied by target host and absent validation is disallowed')\n            return\n        if self._Session['ServerName'].lower() != self._accepted_hostname.lower() and self._Session['ServerDNSHostName'].lower() != self._accepted_hostname.lower():\n            raise self.HostnameValidationException('Supplied hostname %s does not match reported hostnames %s or %s' %\n                (self._accepted_hostname.lower(), self._Session['ServerName'].lower(), self._Session['ServerDNSHostName'].lower()))",
  "class HTTPClientSecurityProvider:\n    def __init__(self, auth_type=AUTH_AUTO):\n        self.__username = None\n        self.__password = None\n        self.__domain   = None\n        self.__lmhash   = ''\n        self.__nthash   = ''\n        self.__aesKey   = ''\n        self.__TGT      = None\n        self.__TGS      = None\n\n        self.__auth_type = auth_type\n\n        self.__auth_types = []\n        self.__ntlmssp_info = None\n\n    def set_auth_type(self, auth_type):\n        self.__auth_type = auth_type\n\n    def get_auth_type(self):\n        return self.__auth_type\n\n    def get_auth_types(self):\n        return self.__auth_types\n\n    def get_ntlmssp_info(self):\n        return self.__ntlmssp_info\n\n    def set_credentials(self, username, password, domain='', lmhash='', nthash='', aesKey='', TGT=None, TGS=None):\n        self.__username = username\n        self.__password = password\n        self.__domain   = domain\n\n        if lmhash != '' or nthash != '':\n            if len(lmhash) % 2:\n                lmhash = '0%s' % lmhash\n            if len(nthash) % 2:\n                nthash = '0%s' % nthash\n\n            try: # just in case they were converted already\n                self.__lmhash = binascii.unhexlify(lmhash)\n                self.__nthash = binascii.unhexlify(nthash)\n            except:\n                self.__lmhash = lmhash\n                self.__nthash = nthash\n                pass\n\n        self.__aesKey = aesKey\n        self.__TGT    = TGT\n        self.__TGS    = TGS\n\n    def parse_www_authenticate(self, header):\n        ret = []\n\n        if 'NTLM' in header:\n            ret.append(AUTH_NTLM)\n        if 'Basic' in header:\n            ret.append(AUTH_BASIC)\n        if 'Negotiate' in header:\n            ret.append(AUTH_NEGOTIATE)\n        if 'Bearer' in header:\n            ret.append(AUTH_BEARER)\n        if 'Digest' in header:\n            ret.append(AUTH_DIGEST)\n\n        return ret\n\n    def connect(self, protocol, host_L6):\n        if protocol == 'http':\n            return HTTPConnection(host_L6)\n        else:\n            try:\n                uv_context = ssl.SSLContext(ssl.PROTOCOL_SSLv23)\n                return HTTPSConnection(host_L6, context=uv_context)\n            except AttributeError:\n                return HTTPSConnection(host_L6)\n\n    def get_auth_headers(self, http_obj, method, path, headers):\n        if self.__auth_type == AUTH_BASIC:\n            return self.get_auth_headers_basic(http_obj, method, path, headers)\n        elif self.__auth_type in [AUTH_AUTO, AUTH_NTLM]:\n            return self.get_auth_headers_auto(http_obj, method, path, headers)\n        else:\n            raise Exception('%s auth type not supported' % self.__auth_type)\n\n    def get_auth_headers_basic(self, http_obj, method, path, headers):\n        if self.__lmhash != '' or self.__nthash != '' or \\\n           self.__aesKey != '' or self.__TGT != None or self.__TGS != None:\n            raise Exception('Basic authentication in HTTP connection used, '\n                            'so set a plaintext credentials to connect.')\n\n        if self.__domain == '':\n            auth_line = self.__username + ':' + self.__password\n        else:\n            auth_line = self.__domain + '\\\\' + self.__username + ':' + self.__password\n\n        auth_line_http = 'Basic %s' % base64.b64encode(auth_line.encode('UTF-8')).decode('ascii')\n\n        # Format: auth_headers, reserved, ...\n        return {'Authorization': auth_line_http}, None\n\n    # It's important that the class contains the separate method that\n    # gets NTLM Type 1 value, as this way the class can be programmed to\n    # be used in relay attacks\n    def send_ntlm_type1(self, http_obj, method, path, headers, negotiateMessage):\n        auth_headers = headers.copy()\n        auth_headers['Content-Length'] = '0'\n        auth_headers['Authorization']  = 'NTLM %s' % base64.b64encode(negotiateMessage).decode('ascii')\n        http_obj.request(method, path, headers=auth_headers)\n        res = http_obj.getresponse()\n        res.read()\n\n        if res.status != 401:\n            raise Exception('Status code returned: %d. '\n                            'Authentication does not seem required for url %s'\n                            % (res.status, path)\n                )\n\n        if res.getheader('WWW-Authenticate') is None:\n           raise Exception('No authentication requested by '\n                           'the server for url %s' % path)\n\n        if self.__auth_types == []:\n            self.__auth_types = self.parse_www_authenticate(res.getheader('WWW-Authenticate'))\n\n        if AUTH_NTLM not in self.__auth_types:\n            # NTLM auth not supported for url\n            return None, None\n\n        try:\n            serverChallengeBase64 = re.search('NTLM ([a-zA-Z0-9+/]+={0,2})',\n                                              res.getheader('WWW-Authenticate')).group(1)\n            serverChallenge = base64.b64decode(serverChallengeBase64)\n        except (IndexError, KeyError, AttributeError):\n            raise Exception('No NTLM challenge returned from server for url %s' % path)\n\n        if not self.__ntlmssp_info:\n            challenge = ntlm.NTLMAuthChallenge(serverChallenge)\n            self.__ntlmssp_info = ntlm.AV_PAIRS(challenge['TargetInfoFields'])\n\n        # Format: serverChallenge, reserved, ...\n        return serverChallenge, None\n\n    def get_auth_headers_auto(self, http_obj, method, path, headers):\n        if self.__aesKey != '' or self.__TGT != None or self.__TGS != None:\n            raise Exception('NTLM authentication in HTTP connection used, ' \\\n                            'cannot use Kerberos.')\n\n        auth = ntlm.getNTLMSSPType1(domain=self.__domain)\n        serverChallenge = self.send_ntlm_type1(http_obj, method, path, headers, auth.getData())[0]\n\n        if serverChallenge is not None:\n            self.__auth_type = AUTH_NTLM\n\n            type3, exportedSessionKey = ntlm.getNTLMSSPType3(auth, serverChallenge, self.__username,\n                                                             self.__password, self.__domain,\n                                                             self.__lmhash, self.__nthash)\n\n            auth_line_http = 'NTLM %s' % base64.b64encode(type3.getData()).decode('ascii')\n        else:\n            if self.__auth_type == AUTH_AUTO and AUTH_BASIC in self.__auth_types:\n                self.__auth_type = AUTH_BASIC\n                return self.get_auth_headers_basic(http_obj, method, path, headers)\n            else:\n                raise Exception('No supported auth offered by URL: %s' % self.__auth_types)\n\n        # Format: auth_headers, reserved, ...\n        return {'Authorization': auth_line_http}, None",
  "def __init__(self, auth_type=AUTH_AUTO):\n        self.__username = None\n        self.__password = None\n        self.__domain   = None\n        self.__lmhash   = ''\n        self.__nthash   = ''\n        self.__aesKey   = ''\n        self.__TGT      = None\n        self.__TGS      = None\n\n        self.__auth_type = auth_type\n\n        self.__auth_types = []\n        self.__ntlmssp_info = None",
  "def set_auth_type(self, auth_type):\n        self.__auth_type = auth_type",
  "def get_auth_type(self):\n        return self.__auth_type",
  "def get_auth_types(self):\n        return self.__auth_types",
  "def get_ntlmssp_info(self):\n        return self.__ntlmssp_info",
  "def set_credentials(self, username, password, domain='', lmhash='', nthash='', aesKey='', TGT=None, TGS=None):\n        self.__username = username\n        self.__password = password\n        self.__domain   = domain\n\n        if lmhash != '' or nthash != '':\n            if len(lmhash) % 2:\n                lmhash = '0%s' % lmhash\n            if len(nthash) % 2:\n                nthash = '0%s' % nthash\n\n            try: # just in case they were converted already\n                self.__lmhash = binascii.unhexlify(lmhash)\n                self.__nthash = binascii.unhexlify(nthash)\n            except:\n                self.__lmhash = lmhash\n                self.__nthash = nthash\n                pass\n\n        self.__aesKey = aesKey\n        self.__TGT    = TGT\n        self.__TGS    = TGS",
  "def parse_www_authenticate(self, header):\n        ret = []\n\n        if 'NTLM' in header:\n            ret.append(AUTH_NTLM)\n        if 'Basic' in header:\n            ret.append(AUTH_BASIC)\n        if 'Negotiate' in header:\n            ret.append(AUTH_NEGOTIATE)\n        if 'Bearer' in header:\n            ret.append(AUTH_BEARER)\n        if 'Digest' in header:\n            ret.append(AUTH_DIGEST)\n\n        return ret",
  "def connect(self, protocol, host_L6):\n        if protocol == 'http':\n            return HTTPConnection(host_L6)\n        else:\n            try:\n                uv_context = ssl.SSLContext(ssl.PROTOCOL_SSLv23)\n                return HTTPSConnection(host_L6, context=uv_context)\n            except AttributeError:\n                return HTTPSConnection(host_L6)",
  "def get_auth_headers(self, http_obj, method, path, headers):\n        if self.__auth_type == AUTH_BASIC:\n            return self.get_auth_headers_basic(http_obj, method, path, headers)\n        elif self.__auth_type in [AUTH_AUTO, AUTH_NTLM]:\n            return self.get_auth_headers_auto(http_obj, method, path, headers)\n        else:\n            raise Exception('%s auth type not supported' % self.__auth_type)",
  "def get_auth_headers_basic(self, http_obj, method, path, headers):\n        if self.__lmhash != '' or self.__nthash != '' or \\\n           self.__aesKey != '' or self.__TGT != None or self.__TGS != None:\n            raise Exception('Basic authentication in HTTP connection used, '\n                            'so set a plaintext credentials to connect.')\n\n        if self.__domain == '':\n            auth_line = self.__username + ':' + self.__password\n        else:\n            auth_line = self.__domain + '\\\\' + self.__username + ':' + self.__password\n\n        auth_line_http = 'Basic %s' % base64.b64encode(auth_line.encode('UTF-8')).decode('ascii')\n\n        # Format: auth_headers, reserved, ...\n        return {'Authorization': auth_line_http}, None",
  "def send_ntlm_type1(self, http_obj, method, path, headers, negotiateMessage):\n        auth_headers = headers.copy()\n        auth_headers['Content-Length'] = '0'\n        auth_headers['Authorization']  = 'NTLM %s' % base64.b64encode(negotiateMessage).decode('ascii')\n        http_obj.request(method, path, headers=auth_headers)\n        res = http_obj.getresponse()\n        res.read()\n\n        if res.status != 401:\n            raise Exception('Status code returned: %d. '\n                            'Authentication does not seem required for url %s'\n                            % (res.status, path)\n                )\n\n        if res.getheader('WWW-Authenticate') is None:\n           raise Exception('No authentication requested by '\n                           'the server for url %s' % path)\n\n        if self.__auth_types == []:\n            self.__auth_types = self.parse_www_authenticate(res.getheader('WWW-Authenticate'))\n\n        if AUTH_NTLM not in self.__auth_types:\n            # NTLM auth not supported for url\n            return None, None\n\n        try:\n            serverChallengeBase64 = re.search('NTLM ([a-zA-Z0-9+/]+={0,2})',\n                                              res.getheader('WWW-Authenticate')).group(1)\n            serverChallenge = base64.b64decode(serverChallengeBase64)\n        except (IndexError, KeyError, AttributeError):\n            raise Exception('No NTLM challenge returned from server for url %s' % path)\n\n        if not self.__ntlmssp_info:\n            challenge = ntlm.NTLMAuthChallenge(serverChallenge)\n            self.__ntlmssp_info = ntlm.AV_PAIRS(challenge['TargetInfoFields'])\n\n        # Format: serverChallenge, reserved, ...\n        return serverChallenge, None",
  "def get_auth_headers_auto(self, http_obj, method, path, headers):\n        if self.__aesKey != '' or self.__TGT != None or self.__TGS != None:\n            raise Exception('NTLM authentication in HTTP connection used, ' \\\n                            'cannot use Kerberos.')\n\n        auth = ntlm.getNTLMSSPType1(domain=self.__domain)\n        serverChallenge = self.send_ntlm_type1(http_obj, method, path, headers, auth.getData())[0]\n\n        if serverChallenge is not None:\n            self.__auth_type = AUTH_NTLM\n\n            type3, exportedSessionKey = ntlm.getNTLMSSPType3(auth, serverChallenge, self.__username,\n                                                             self.__password, self.__domain,\n                                                             self.__lmhash, self.__nthash)\n\n            auth_line_http = 'NTLM %s' % base64.b64encode(type3.getData()).decode('ascii')\n        else:\n            if self.__auth_type == AUTH_AUTO and AUTH_BASIC in self.__auth_types:\n                self.__auth_type = AUTH_BASIC\n                return self.get_auth_headers_basic(http_obj, method, path, headers)\n            else:\n                raise Exception('No supported auth offered by URL: %s' % self.__auth_types)\n\n        # Format: auth_headers, reserved, ...\n        return {'Authorization': auth_line_http}, None",
  "class KeyManager:\n    def __init__(self):\n        self.keys = {}\n        \n    def __get_bssid_hasheable_type(self, bssid):\n        # List is an unhashable type\n        if not isinstance(bssid, (list,tuple,array)):\n            raise Exception('BSSID datatype must be a tuple, list or array')\n        return tuple(bssid) \n\n    def add_key(self, bssid, key):\n        bssid=self.__get_bssid_hasheable_type(bssid)\n        if bssid not in self.keys:\n            self.keys[bssid] = key\n            return True\n        else:\n            return False\n        \n    def replace_key(self, bssid, key):\n        bssid=self.__get_bssid_hasheable_type(bssid)\n        self.keys[bssid] = key\n        \n        return True\n        \n    def get_key(self, bssid):\n        bssid=self.__get_bssid_hasheable_type(bssid)\n        if bssid in self.keys:\n            return self.keys[bssid]\n        else:\n            return False\n        \n    def delete_key(self, bssid):\n        bssid=self.__get_bssid_hasheable_type(bssid)\n        if not isinstance(bssid, list):\n            raise Exception('BSSID datatype must be a list')\n        \n        if bssid in self.keys:\n            del self.keys[bssid] \n            return True\n        \n        return False",
  "def __init__(self):\n        self.keys = {}",
  "def __get_bssid_hasheable_type(self, bssid):\n        # List is an unhashable type\n        if not isinstance(bssid, (list,tuple,array)):\n            raise Exception('BSSID datatype must be a tuple, list or array')\n        return tuple(bssid)",
  "def add_key(self, bssid, key):\n        bssid=self.__get_bssid_hasheable_type(bssid)\n        if bssid not in self.keys:\n            self.keys[bssid] = key\n            return True\n        else:\n            return False",
  "def replace_key(self, bssid, key):\n        bssid=self.__get_bssid_hasheable_type(bssid)\n        self.keys[bssid] = key\n        \n        return True",
  "def get_key(self, bssid):\n        bssid=self.__get_bssid_hasheable_type(bssid)\n        if bssid in self.keys:\n            return self.keys[bssid]\n        else:\n            return False",
  "def delete_key(self, bssid):\n        bssid=self.__get_bssid_hasheable_type(bssid)\n        if not isinstance(bssid, list):\n            raise Exception('BSSID datatype must be a list')\n        \n        if bssid in self.keys:\n            del self.keys[bssid] \n            return True\n        \n        return False",
  "class ArrayBuilder(object):\n\n    def from_ary(self, ary):\n        return ary\n\n    def to_ary(self, value):\n        return array.array(\"B\", value)",
  "class ByteBuilder(object):\n\n    def from_ary(self, ary):\n        return ary[0]\n    \n    def to_ary(self, value):\n        return array.array('B', [value])",
  "class StringBuilder(object):\n    def from_ary(self, ary):\n        return array_tobytes(ary)\n        \n    def to_ary(self, value):\n        return array.array('B', value)",
  "class NumBuilder(object):\n    \"\"\"Converts back and forth between arrays and numbers in network byte-order\"\"\"\n    \n    def __init__(self, size):\n        \"\"\"size: number of bytes in the field\"\"\"\n        self.size = size\n    \n    def from_ary(self, ary):\n        if len(ary) != self.size:\n            raise Exception(\"Expected %s size but got %s\" % (self.size, len(ary)))\n        return reduce( lambda ac, x: ac * 256 + x, ary, 0)\n    \n    def to_ary(self, value0):\n        value = value0\n        rv = array.array('B')\n        for _ in range(self.size):\n            value, mod = divmod(value, 256)\n            rv.append(mod)\n            \n        if value != 0:\n            raise Exception(\"%s is too big. Max size: %s\" % (value0, self.size))\n            \n        rv.reverse()\n        return rv",
  "class TLVContainer(object):\n    \n    def builder(self, kind):\n        return self.builders.get(kind, self.default_builder)\n    \n    def from_ary(self, ary):\n        i = 0\n        while i<len(ary):\n            kind = self.ary2n(ary, i)\n            length = self.ary2n(ary, i+2)\n            i+=4\n            value = ary[i:i+length]\n            self.elems.append((kind, value))\n            i += length\n            \n        return self\n                \n    def __init__(self, builders, default_builder = ArrayBuilder(), descs=None):\n        self.builders = builders\n        self.default_builder = default_builder\n        self.elems = []\n        self.descs = descs or {}\n        \n    def append(self, kind, value):\n        self.elems.append((kind, self.builder(kind).to_ary(value)))\n    \n    def __iter__(self):\n        return ((k, self.builder(k).from_ary(v)) for k,v in self.elems)\n    \n    def all(self, kind):\n        return [e[1] for e in self if e[0] == kind]\n    \n    def __contains__(self, kind):\n        return len(self.all(kind)) != 0\n    \n    def first(self, kind):\n        return self.all(kind)[0]\n    \n    def to_ary(self):\n        ary = array.array('B')\n        for k,v in self.elems:\n            ary.extend(self.n2ary(k))\n            ary.extend(self.n2ary(len(v)))\n            ary.extend(v)\n            \n        return ary\n\n    \n    def get_packet(self):\n        return array_tobytes(self.to_ary())\n    \n    def set_parent(self, my_parent):\n        self.__parent = my_parent\n        \n    def parent(self):\n        return self.__parent\n    \n    def n2ary(self, n):\n        return array.array(\"B\", struct.pack(\">H\",n))\n    \n    def ary2n(self, ary, i=0):\n        return struct.unpack(\">H\", array_tobytes(ary[i:i+2]))[0]\n    \n    def __repr__(self):\n        def desc(kind):\n            return self.descs[kind] if kind in self.descs else kind\n        \n        return \"<TLVContainer %s>\" % repr([(desc(k), self.builder(k).from_ary(v)) for (k,v) in self.elems])\n    \n    def child(self):\n        return None",
  "class SCElem(object):    \n    #Data elements as defined in section 11 of the WPS 1.0h spec.\n    \n    AP_CHANNEL = 0x1001\n    ASSOCIATION_STATE = 0x1002\n    AUTHENTICATION_TYPE = 0x1003\n    AUTHENTICATION_TYPE_FLAGS = 0x1004\n    AUTHENTICATOR = 0x1005\n    CONFIG_METHODS = 0x1008\n    CONFIGURATION_ERROR = 0x1009\n    CONFIRMATION_URL4 = 0x100A\n    CONFIRMATION_URL6 = 0x100B\n    CONNECTION_TYPE = 0X100C\n    CONNECTION_TYPE_FLAGS = 0X100D\n    CREDENTIAL = 0X100E \n    DEVICE_NAME = 0x1011\n    DEVICE_PASSWORD_ID = 0x1012\n    E_HASH1 = 0x1014\n    E_HASH2 = 0x1015\n    E_SNONCE1 = 0x1016\n    E_SNONCE2 = 0x1017\n    ENCRYPTED_SETTINGS = 0x1018 \n    ENCRYPTION_TYPE = 0X100F\n    ENCRYPTION_TYPE_FLAGS = 0x1010\n    ENROLLEE_NONCE = 0x101A\n    FEATURE_ID = 0x101B\n    IDENTITY = 0X101C\n    INDENTITY_PROOF = 0X101D \n    KEY_WRAP_AUTHENTICATOR = 0x101E\n    KEY_IDENTIFIER = 0X101F\n    MAC_ADDRESS = 0x1020\n    MANUFACTURER = 0x1021\n    MESSAGE_TYPE = 0x1022\n    MODEL_NAME = 0x1023\n    MODEL_NUMBER = 0x1024\n    NETWORK_INDEX = 0x1026\n    NETWORK_KEY = 0x1027\n    NETWORK_KEY_INDEX = 0x1028\n    NEW_DEVICE_NAME = 0x1029\n    NEW_PASSWORD = 0x102A\n    OOB_DEVICE_PASSWORD = 0X102C\n    OS_VERSION= 0X102D\n    POWER_LEVEL = 0X102F\n    PSK_CURRENT = 0x1030\n    PSK_MAX = 0x1031\n    PUBLIC_KEY = 0x1032\n    RADIO_ENABLED = 0x1033\n    REBOOT = 0x1034\n    REGISTRAR_CURRENT = 0x1035\n    REGISTRAR_ESTABLISHED = 0x1036\n    REGISTRAR_LIST = 0x1037\n    REGISTRAR_MAX = 0x1038\n    REGISTRAR_NONCE = 0x1039\n    REQUEST_TYPE = 0x103A\n    RESPONSE_TYPE = 0x103B\n    RF_BANDS = 0X103C\n    R_HASH1 = 0X103D\n    R_HASH2 = 0X103E\n    R_SNONCE1 = 0X103F\n    R_SNONCE2 = 0x1040\n    SELECTED_REGISTRAR = 0x1041\n    SERIAL_NUMBER = 0x1042\n    WPS_STATE = 0x1044\n    SSID = 0x1045\n    TOTAL_NETWORKS = 0x1046\n    UUID_E = 0x1047\n    UUID_R = 0x1048\n    VENDOR_EXTENSION = 0x1049\n    VERSION = 0x104A\n    X_509_CERTIFICATE_REQUEST = 0x104B \n    X_509_CERTIFICATE = 0x104C\n    EAP_IDENTITY = 0x104D\n    MESSAGE_COUNTER = 0x104E\n    PUBLIC_KEY_HASH = 0x104F\n    REKEY_KEY = 0x1050\n    KEY_LIFETIME = 0x1051\n    PERMITTED_CONFIG_METHODS = 0x1052\n    SELECTED_REGISTRAR_CONFIG_METHODS= 0x1053\n    PRIMARY_DEVICE_TYPE = 0x1054\n    SECONDARY_DEVICE_TYPE_LIST = 0x1055\n    PORTABLE_DEVICE = 0x1056\n    AP_SETUP_LOCKED = 0x1057\n    APPLICATION_EXTENSION = 0x1058\n    EAP_TYPE = 0x1059\n    INITIALIZATION_VECTOR = 0x1060\n    KEY_PROVIDED_AUTOMATICALLY = 0x1061\n    _802_1X_ENABLED = 0x1062\n    APP_SESSION_KEY = 0x1063\n    WEP_TRANSMIT_KEY = 0x1064",
  "class MessageType(object):\n    \"\"\"Message types according to WPS 1.0h spec, section 11\"\"\"\n    \n    BEACON = 0x01\n    PROBE_REQUEST = 0x02\n    PROBE_RESPONSE = 0x03\n    M1 = 0x04\n    M2 = 0x05\n    M2D = 0x06\n    M3 = 0x07\n    M4 = 0x08\n    M5 = 0x09\n    M6 = 0x0A\n    M7 = 0x0B\n    M8 = 0x0C\n    WSC_ACK = 0x0D\n    WSC_NACK = 0x0E\n    WSC_DONE = 0x0F",
  "class AuthTypeFlag(object):\n    OPEN = 0x0001\n    WPAPSK = 0x0002\n    SHARED = 0x0004\n    WPA = 0x0008\n    WPA2 = 0x0010\n    WPA2PSK = 0x0020",
  "class EncryptionTypeFlag(object):\n    NONE = 0x0001\n    WEP = 0x0002\n    TKIP = 0x0004\n    AES = 0x0008",
  "class ConnectionTypeFlag(object):\n    ESS = 0x01\n    IBSS = 0x02",
  "class ConfigMethod(object):\n    USBA = 0x0001\n    ETHERNET = 0x0002\n    LABEL = 0x0004\n    DISPLAY = 0x0008\n    EXT_NFC_TOKEN = 0x0010\n    INT_NFC_TOKEN = 0x0020\n    NFC_INTERFACE = 0x0040\n    PUSHBUTTON = 0x0080\n    KEYPAD = 0x0100",
  "class OpCode(object):\n    WSC_START = 0x01\n    WSC_ACK = 0x02\n    WSC_NACK = 0x03\n    WSC_MSG = 0x04\n    WSC_DONE = 0x05\n    WSC_FRAG_ACK = 0x06",
  "class AssocState(object):\n    NOT_ASSOC = 0\n    CONN_SUCCESS = 1\n    CFG_FAILURE = 2\n    FAILURE = 3,\n    IP_FAILURE = 4",
  "class ConfigError(object):\n    NO_ERROR = 0\n    OOB_IFACE_READ_ERROR = 1\n    DECRYPTION_CRC_FAILURE = 2\n    _24_CHAN_NOT_SUPPORTED = 3\n    _50_CHAN_NOT_SUPPORTED = 4\n    SIGNAL_TOO_WEAK = 5\n    NETWORK_AUTH_FAILURE = 6\n    NETWORK_ASSOC_FAILURE = 7\n    NO_DHCP_RESPONSE = 8\n    FAILED_DHCP_CONFIG = 9\n    IP_ADDR_CONFLICT = 10\n    NO_CONN_TO_REGISTRAR = 11\n    MULTIPLE_PBC_DETECTED = 12\n    ROGUE_SUSPECTED = 13\n    DEVICE_BUSY = 14\n    SETUP_LOCKED = 15\n    MSG_TIMEOUT = 16\n    REG_SESS_TIMEOUT = 17\n    DEV_PASSWORD_AUTH_FAILURE = 18",
  "class DevicePasswordId(object):\n    DEFAULT = 0x0000\n    USER_SPECIFIED = 0x0001\n    MACHINE_SPECIFIED = 0x0002\n    REKEY = 0x0003\n    PUSHBUTTON = 0x0004\n    REGISTRAR_SPECIFIED = 0x0005",
  "class WpsState(object):\n    NOT_CONFIGURED = 0x01\n    CONFIGURED = 0x02",
  "class SimpleConfig(ProtocolPacket):\n    \"For now, it supports Simple configs with the bits more_fragments and length_field not set\"\n    \n    header_size = 2\n    tail_size = 0\n\n    op_code = Byte(0)\n    flags = Byte(1)\n    more_fragments = Bit(1, 0)\n    length_field = Bit(1,1)\n    \n    BUILDERS = {\n        SCElem.CONNECTION_TYPE: ByteBuilder(),\n        SCElem.CONNECTION_TYPE_FLAGS: ByteBuilder(),\n        SCElem.VERSION: ByteBuilder(),\n        SCElem.MESSAGE_TYPE: ByteBuilder(),\n        SCElem.NETWORK_INDEX: ByteBuilder(),\n        SCElem.NETWORK_KEY_INDEX: ByteBuilder(),\n        SCElem.POWER_LEVEL: ByteBuilder(),\n        SCElem.PSK_CURRENT: ByteBuilder(),\n        SCElem.PSK_MAX: ByteBuilder(),\n        SCElem.REGISTRAR_CURRENT: ByteBuilder(),\n        SCElem.REGISTRAR_MAX: ByteBuilder(),\n        SCElem.REQUEST_TYPE: ByteBuilder(),\n        SCElem.RESPONSE_TYPE: ByteBuilder(),\n        SCElem.RF_BANDS: ByteBuilder(),\n        SCElem.WPS_STATE: ByteBuilder(),\n        SCElem.TOTAL_NETWORKS: ByteBuilder(),\n        SCElem.VERSION: ByteBuilder(),\n        SCElem.WEP_TRANSMIT_KEY: ByteBuilder(),\n        \n        SCElem.CONFIRMATION_URL4: StringBuilder(),\n        SCElem.CONFIRMATION_URL6: StringBuilder(),\n        SCElem.DEVICE_NAME: StringBuilder(),\n        SCElem.IDENTITY: StringBuilder(),\n        SCElem.MANUFACTURER: StringBuilder(),\n        SCElem.MODEL_NAME: StringBuilder(),\n        SCElem.MODEL_NUMBER: StringBuilder(),\n        SCElem.NEW_DEVICE_NAME: StringBuilder(),\n        SCElem.NEW_PASSWORD: StringBuilder(),\n        SCElem.SERIAL_NUMBER: StringBuilder(),\n        SCElem.EAP_IDENTITY: StringBuilder(),\n        SCElem.NETWORK_KEY: StringBuilder(),\n            \n        SCElem.AP_CHANNEL: NumBuilder(2),\n        SCElem.ASSOCIATION_STATE: NumBuilder(2),\n        SCElem.AUTHENTICATION_TYPE: NumBuilder(2),\n        SCElem.AUTHENTICATION_TYPE_FLAGS: NumBuilder(2),\n        SCElem.CONFIG_METHODS: NumBuilder(2),\n        SCElem.CONFIGURATION_ERROR: NumBuilder(2),\n        SCElem.DEVICE_PASSWORD_ID: NumBuilder(2),\n        SCElem.ENCRYPTION_TYPE: NumBuilder(2),\n        SCElem.ENCRYPTION_TYPE_FLAGS: NumBuilder(2),\n        SCElem.MESSAGE_COUNTER: NumBuilder(8),       \n        SCElem.KEY_LIFETIME: NumBuilder(4),\n        SCElem.PERMITTED_CONFIG_METHODS: NumBuilder(2),\n        SCElem.SELECTED_REGISTRAR_CONFIG_METHODS: NumBuilder(2),\n        SCElem.PUBLIC_KEY: NumBuilder(192),\n\n    }\n    \n    @classmethod\n    def build_tlv_container(cls):\n        return TLVContainer(\n            builders=SimpleConfig.BUILDERS, \n            descs = dict( (v,k) for (k,v) in SCElem.__dict__.items() )\n        )",
  "def from_ary(self, ary):\n        return ary",
  "def to_ary(self, value):\n        return array.array(\"B\", value)",
  "def from_ary(self, ary):\n        return ary[0]",
  "def to_ary(self, value):\n        return array.array('B', [value])",
  "def from_ary(self, ary):\n        return array_tobytes(ary)",
  "def to_ary(self, value):\n        return array.array('B', value)",
  "def __init__(self, size):\n        \"\"\"size: number of bytes in the field\"\"\"\n        self.size = size",
  "def from_ary(self, ary):\n        if len(ary) != self.size:\n            raise Exception(\"Expected %s size but got %s\" % (self.size, len(ary)))\n        return reduce( lambda ac, x: ac * 256 + x, ary, 0)",
  "def to_ary(self, value0):\n        value = value0\n        rv = array.array('B')\n        for _ in range(self.size):\n            value, mod = divmod(value, 256)\n            rv.append(mod)\n            \n        if value != 0:\n            raise Exception(\"%s is too big. Max size: %s\" % (value0, self.size))\n            \n        rv.reverse()\n        return rv",
  "def builder(self, kind):\n        return self.builders.get(kind, self.default_builder)",
  "def from_ary(self, ary):\n        i = 0\n        while i<len(ary):\n            kind = self.ary2n(ary, i)\n            length = self.ary2n(ary, i+2)\n            i+=4\n            value = ary[i:i+length]\n            self.elems.append((kind, value))\n            i += length\n            \n        return self",
  "def __init__(self, builders, default_builder = ArrayBuilder(), descs=None):\n        self.builders = builders\n        self.default_builder = default_builder\n        self.elems = []\n        self.descs = descs or {}",
  "def append(self, kind, value):\n        self.elems.append((kind, self.builder(kind).to_ary(value)))",
  "def __iter__(self):\n        return ((k, self.builder(k).from_ary(v)) for k,v in self.elems)",
  "def all(self, kind):\n        return [e[1] for e in self if e[0] == kind]",
  "def __contains__(self, kind):\n        return len(self.all(kind)) != 0",
  "def first(self, kind):\n        return self.all(kind)[0]",
  "def to_ary(self):\n        ary = array.array('B')\n        for k,v in self.elems:\n            ary.extend(self.n2ary(k))\n            ary.extend(self.n2ary(len(v)))\n            ary.extend(v)\n            \n        return ary",
  "def get_packet(self):\n        return array_tobytes(self.to_ary())",
  "def set_parent(self, my_parent):\n        self.__parent = my_parent",
  "def parent(self):\n        return self.__parent",
  "def n2ary(self, n):\n        return array.array(\"B\", struct.pack(\">H\",n))",
  "def ary2n(self, ary, i=0):\n        return struct.unpack(\">H\", array_tobytes(ary[i:i+2]))[0]",
  "def __repr__(self):\n        def desc(kind):\n            return self.descs[kind] if kind in self.descs else kind\n        \n        return \"<TLVContainer %s>\" % repr([(desc(k), self.builder(k).from_ary(v)) for (k,v) in self.elems])",
  "def child(self):\n        return None",
  "def build_tlv_container(cls):\n        return TLVContainer(\n            builders=SimpleConfig.BUILDERS, \n            descs = dict( (v,k) for (k,v) in SCElem.__dict__.items() )\n        )",
  "def desc(kind):\n            return self.descs[kind] if kind in self.descs else kind",
  "def getInstallationPath():\n    return 'Impacket Library Installation Path: {}'.format(__path__[0])",
  "class NDP(ICMP6):\n    #ICMP message type numbers\n    ROUTER_SOLICITATION = 133\n    ROUTER_ADVERTISEMENT = 134\n    NEIGHBOR_SOLICITATION = 135\n    NEIGHBOR_ADVERTISEMENT = 136\n    REDIRECT = 137\n\n############################################################################\n# Append NDP Option helper\n\n    def append_ndp_option(self, ndp_option):\n        #As NDP inherits ICMP6, it is, in fact an ICMP6 \"header\"\n        #The payload (where all NDP options should reside) is a child of the header\n        self.child().get_bytes().extend(ndp_option.get_bytes())\n                \n        \n############################################################################\n    @classmethod\n    def Router_Solicitation(class_object):\n        message_data = struct.pack('>L', 0) #Reserved bytes\n        return class_object.__build_message(NDP.ROUTER_SOLICITATION, message_data)\n\n    @classmethod\n    def Router_Advertisement(class_object, current_hop_limit, \n                             managed_flag, other_flag, \n                             router_lifetime, reachable_time, retransmission_timer):        \n        flag_byte = 0x00\n        if (managed_flag):\n            flag_byte |= 0x80\n        if (other_flag):\n            flag_byte |= 0x40\n            \n        message_data = struct.pack('>BBHLL', current_hop_limit, flag_byte, router_lifetime, reachable_time, retransmission_timer)\n        return class_object.__build_message(NDP.ROUTER_ADVERTISEMENT, message_data)\n\n    @classmethod\n    def Neighbor_Solicitation(class_object, target_address):        \n        message_data = struct.pack('>L', 0) #Reserved bytes\n        message_data += ImpactPacket.array_tobytes(target_address.as_bytes())\n        return class_object.__build_message(NDP.NEIGHBOR_SOLICITATION, message_data)\n\n\n    @classmethod\n    def Neighbor_Advertisement(class_object, router_flag, solicited_flag, override_flag, target_address):                \n        flag_byte = 0x00\n        if (router_flag):\n            flag_byte |= 0x80\n        if (solicited_flag):\n            flag_byte |= 0x40\n        if (override_flag):\n            flag_byte |= 0x20\n            \n        message_data = struct.pack('>BBBB', flag_byte, 0x00, 0x00, 0x00) #Flag byte and three reserved bytes\n        message_data += ImpactPacket.array_tobytes(target_address.as_bytes())\n        return class_object.__build_message(NDP.NEIGHBOR_ADVERTISEMENT, message_data)\n\n\n    @classmethod\n    def Redirect(class_object, target_address, destination_address):        \n        message_data = struct.pack('>L', 0)# Reserved bytes\n        message_data += ImpactPacket.array_tobytes(target_address.as_bytes())\n        message_data += ImpactPacket.array_tobytes(destination_address.as_bytes())\n        return class_object.__build_message(NDP.REDIRECT, message_data)\n\n    \n    @classmethod\n    def __build_message(class_object, type, message_data):\n        #Build NDP header\n        ndp_packet = NDP()\n        ndp_packet.set_type(type)\n        ndp_packet.set_code(0)\n        \n        #Pack payload\n        ndp_payload = ImpactPacket.Data()\n        ndp_payload.set_data(message_data)\n        ndp_packet.contains(ndp_payload)\n        \n        return ndp_packet",
  "class NDP_Option():\n    #NDP Option Type numbers\n    SOURCE_LINK_LAYER_ADDRESS = 1\n    TARGET_LINK_LAYER_ADDRESS = 2\n    PREFIX_INFORMATION = 3\n    REDIRECTED_HEADER = 4\n    MTU_OPTION = 5\n    \n############################################################################\n    @classmethod    \n    #link_layer_address must have a size that is a multiple of 8 octets\n    def Source_Link_Layer_Address(class_object, link_layer_address):\n        return class_object.__Link_Layer_Address(NDP_Option.SOURCE_LINK_LAYER_ADDRESS, link_layer_address)\n\n    @classmethod    \n    #link_layer_address must have a size that is a multiple of 8 octets\n    def Target_Link_Layer_Address(class_object, link_layer_address):\n        return class_object.__Link_Layer_Address(NDP_Option.TARGET_LINK_LAYER_ADDRESS, link_layer_address)\n\n    @classmethod    \n    #link_layer_address must have a size that is a multiple of 8 octets\n    def __Link_Layer_Address(class_object, option_type, link_layer_address):\n        option_length = (len(link_layer_address) / 8) + 1\n        option_data = ImpactPacket.array_tobytes(array.array(\"B\", link_layer_address))\n        return class_object.__build_option(option_type, option_length, option_data)\n\n    @classmethod\n    #Note: if we upgraded to Python 2.6, we could use collections.namedtuples for encapsulating the arguments\n    #ENHANCEMENT - Prefix could be an instance of IP6_Address \n    def Prefix_Information(class_object, prefix_length, on_link_flag, autonomous_flag, valid_lifetime, preferred_lifetime, prefix):\n        \n        flag_byte = 0x00\n        if (on_link_flag):\n            flag_byte |= 0x80\n        if (autonomous_flag):\n            flag_byte |= 0x40\n        \n        option_data = struct.pack('>BBLL', prefix_length, flag_byte, valid_lifetime, preferred_lifetime)\n        option_data += struct.pack('>L', 0) #Reserved bytes\n        option_data += ImpactPacket.array_tobytes(array.array(\"B\", prefix))\n        option_length = 4        \n        return class_object.__build_option(NDP_Option.PREFIX_INFORMATION, option_length, option_data)\n        \n        \n    @classmethod    \n    def Redirected_Header(class_object, original_packet):\n        option_data = struct.pack('>BBBBBB', 0x00, 0x00, 0x00, 0x00, 0x00, 0x00)# Reserved bytes\n        option_data += ImpactPacket.array_tobytes(array.array(\"B\", original_packet))\n        option_length = (len(option_data) + 4) / 8  \n        return class_object.__build_option(NDP_Option.REDIRECTED_HEADER, option_length, option_data)\n    \n    @classmethod    \n    def MTU(class_object, mtu):\n        option_data = struct.pack('>BB', 0x00, 0x00)# Reserved bytes\n        option_data += struct.pack('>L', mtu)\n        option_length = 1\n        return class_object.__build_option(NDP_Option.MTU_OPTION, option_length, option_data)\n\n\n    @classmethod\n    def __build_option(class_object, type, length, option_data):\n        #Pack data\n        data_bytes = struct.pack('>BB', type, length)\n        data_bytes += option_data\n        ndp_option = ImpactPacket.Data()\n        ndp_option.set_data(data_bytes)\n        \n        return ndp_option",
  "def append_ndp_option(self, ndp_option):\n        #As NDP inherits ICMP6, it is, in fact an ICMP6 \"header\"\n        #The payload (where all NDP options should reside) is a child of the header\n        self.child().get_bytes().extend(ndp_option.get_bytes())",
  "def Router_Solicitation(class_object):\n        message_data = struct.pack('>L', 0) #Reserved bytes\n        return class_object.__build_message(NDP.ROUTER_SOLICITATION, message_data)",
  "def Router_Advertisement(class_object, current_hop_limit, \n                             managed_flag, other_flag, \n                             router_lifetime, reachable_time, retransmission_timer):        \n        flag_byte = 0x00\n        if (managed_flag):\n            flag_byte |= 0x80\n        if (other_flag):\n            flag_byte |= 0x40\n            \n        message_data = struct.pack('>BBHLL', current_hop_limit, flag_byte, router_lifetime, reachable_time, retransmission_timer)\n        return class_object.__build_message(NDP.ROUTER_ADVERTISEMENT, message_data)",
  "def Neighbor_Solicitation(class_object, target_address):        \n        message_data = struct.pack('>L', 0) #Reserved bytes\n        message_data += ImpactPacket.array_tobytes(target_address.as_bytes())\n        return class_object.__build_message(NDP.NEIGHBOR_SOLICITATION, message_data)",
  "def Neighbor_Advertisement(class_object, router_flag, solicited_flag, override_flag, target_address):                \n        flag_byte = 0x00\n        if (router_flag):\n            flag_byte |= 0x80\n        if (solicited_flag):\n            flag_byte |= 0x40\n        if (override_flag):\n            flag_byte |= 0x20\n            \n        message_data = struct.pack('>BBBB', flag_byte, 0x00, 0x00, 0x00) #Flag byte and three reserved bytes\n        message_data += ImpactPacket.array_tobytes(target_address.as_bytes())\n        return class_object.__build_message(NDP.NEIGHBOR_ADVERTISEMENT, message_data)",
  "def Redirect(class_object, target_address, destination_address):        \n        message_data = struct.pack('>L', 0)# Reserved bytes\n        message_data += ImpactPacket.array_tobytes(target_address.as_bytes())\n        message_data += ImpactPacket.array_tobytes(destination_address.as_bytes())\n        return class_object.__build_message(NDP.REDIRECT, message_data)",
  "def __build_message(class_object, type, message_data):\n        #Build NDP header\n        ndp_packet = NDP()\n        ndp_packet.set_type(type)\n        ndp_packet.set_code(0)\n        \n        #Pack payload\n        ndp_payload = ImpactPacket.Data()\n        ndp_payload.set_data(message_data)\n        ndp_packet.contains(ndp_payload)\n        \n        return ndp_packet",
  "def Source_Link_Layer_Address(class_object, link_layer_address):\n        return class_object.__Link_Layer_Address(NDP_Option.SOURCE_LINK_LAYER_ADDRESS, link_layer_address)",
  "def Target_Link_Layer_Address(class_object, link_layer_address):\n        return class_object.__Link_Layer_Address(NDP_Option.TARGET_LINK_LAYER_ADDRESS, link_layer_address)",
  "def __Link_Layer_Address(class_object, option_type, link_layer_address):\n        option_length = (len(link_layer_address) / 8) + 1\n        option_data = ImpactPacket.array_tobytes(array.array(\"B\", link_layer_address))\n        return class_object.__build_option(option_type, option_length, option_data)",
  "def Prefix_Information(class_object, prefix_length, on_link_flag, autonomous_flag, valid_lifetime, preferred_lifetime, prefix):\n        \n        flag_byte = 0x00\n        if (on_link_flag):\n            flag_byte |= 0x80\n        if (autonomous_flag):\n            flag_byte |= 0x40\n        \n        option_data = struct.pack('>BBLL', prefix_length, flag_byte, valid_lifetime, preferred_lifetime)\n        option_data += struct.pack('>L', 0) #Reserved bytes\n        option_data += ImpactPacket.array_tobytes(array.array(\"B\", prefix))\n        option_length = 4        \n        return class_object.__build_option(NDP_Option.PREFIX_INFORMATION, option_length, option_data)",
  "def Redirected_Header(class_object, original_packet):\n        option_data = struct.pack('>BBBBBB', 0x00, 0x00, 0x00, 0x00, 0x00, 0x00)# Reserved bytes\n        option_data += ImpactPacket.array_tobytes(array.array(\"B\", original_packet))\n        option_length = (len(option_data) + 4) / 8  \n        return class_object.__build_option(NDP_Option.REDIRECTED_HEADER, option_length, option_data)",
  "def MTU(class_object, mtu):\n        option_data = struct.pack('>BB', 0x00, 0x00)# Reserved bytes\n        option_data += struct.pack('>L', mtu)\n        option_length = 1\n        return class_object.__build_option(NDP_Option.MTU_OPTION, option_length, option_data)",
  "def __build_option(class_object, type, length, option_data):\n        #Pack data\n        data_bytes = struct.pack('>BB', type, length)\n        data_bytes += option_data\n        ndp_option = ImpactPacket.Data()\n        ndp_option.set_data(data_bytes)\n        \n        return ndp_option",
  "def Generate_Subkey(K):\n\n#   +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n#   +                    Algorithm Generate_Subkey                      +\n#   +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n#   +                                                                   +\n#   +   Input    : K (128-bit key)                                      +\n#   +   Output   : K1 (128-bit first subkey)                            +\n#   +              K2 (128-bit second subkey)                           +\n#   +-------------------------------------------------------------------+\n#   +                                                                   +\n#   +   Constants: const_Zero is 0x00000000000000000000000000000000     +\n#   +              const_Rb   is 0x00000000000000000000000000000087     +\n#   +   Variables: L          for output of AES-128 applied to 0^128    +\n#   +                                                                   +\n#   +   Step 1.  L := AES-128(K, const_Zero);                           +\n#   +   Step 2.  if MSB(L) is equal to 0                                +\n#   +            then    K1 := L << 1;                                  +\n#   +            else    K1 := (L << 1) XOR const_Rb;                   +\n#   +   Step 3.  if MSB(K1) is equal to 0                               +\n#   +            then    K2 := K1 << 1;                                 +\n#   +            else    K2 := (K1 << 1) XOR const_Rb;                  +\n#   +   Step 4.  return K1, K2;                                         +\n#   +                                                                   +\n#   +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    AES_128 = AES.new(K, AES.MODE_ECB)\n\n    L = AES_128.encrypt(bytes(bytearray(16)))\n\n    LHigh = unpack('>Q',L[:8])[0]\n    LLow  = unpack('>Q',L[8:])[0]\n\n    K1High = ((LHigh << 1) | ( LLow >> 63 )) & 0xFFFFFFFFFFFFFFFF\n    K1Low  = (LLow << 1) & 0xFFFFFFFFFFFFFFFF\n\n    if (LHigh >> 63):\n        K1Low ^= 0x87\n\n    K2High = ((K1High << 1) | (K1Low >> 63)) & 0xFFFFFFFFFFFFFFFF\n    K2Low  = ((K1Low << 1)) & 0xFFFFFFFFFFFFFFFF\n\n    if (K1High >> 63):\n        K2Low ^= 0x87\n\n    K1 = bytearray(pack('>QQ', K1High, K1Low))\n    K2 = bytearray(pack('>QQ', K2High, K2Low))\n\n    return K1, K2",
  "def XOR_128(N1,N2):\n\n    J = bytearray()\n    for i in range(len(N1)):\n        #J.append(indexbytes(N1,i) ^ indexbytes(N2,i))\n        J.append(N1[i] ^ N2[i])\n    return J",
  "def PAD(N):\n    padLen = 16-len(N)\n    return  N + b'\\x80' + b'\\x00'*(padLen-1)",
  "def AES_CMAC(K, M, length):\n\n#   +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n#   +                   Algorithm AES-CMAC                              +\n#   +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n#   +                                                                   +\n#   +   Input    : K    ( 128-bit key )                                 +\n#   +            : M    ( message to be authenticated )                 +\n#   +            : len  ( length of the message in octets )             +\n#   +   Output   : T    ( message authentication code )                 +\n#   +                                                                   +\n#   +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n#   +   Constants: const_Zero is 0x00000000000000000000000000000000     +\n#   +              const_Bsize is 16                                    +\n#   +                                                                   +\n#   +   Variables: K1, K2 for 128-bit subkeys                           +\n#   +              M_i is the i-th block (i=1..ceil(len/const_Bsize))   +\n#   +              M_last is the last block xor-ed with K1 or K2        +\n#   +              n      for number of blocks to be processed          +\n#   +              r      for number of octets of last block            +\n#   +              flag   for denoting if last block is complete or not +\n#   +                                                                   +\n#   +   Step 1.  (K1,K2) := Generate_Subkey(K);                         +\n#   +   Step 2.  n := ceil(len/const_Bsize);                            +\n#   +   Step 3.  if n = 0                                               +\n#   +            then                                                   +\n#   +                 n := 1;                                           +\n#   +                 flag := false;                                    +\n#   +            else                                                   +\n#   +                 if len mod const_Bsize is 0                       +\n#   +                 then flag := true;                                +\n#   +                 else flag := false;                               +\n#   +                                                                   +\n#   +   Step 4.  if flag is true                                        +\n#   +            then M_last := M_n XOR K1;                             +\n#   +            else M_last := padding(M_n) XOR K2;                    +\n#   +   Step 5.  X := const_Zero;                                       +\n#   +   Step 6.  for i := 1 to n-1 do                                   +\n#   +                begin                                              +\n#   +                  Y := X XOR M_i;                                  +\n#   +                  X := AES-128(K,Y);                               +\n#   +                end                                                +\n#   +            Y := M_last XOR X;                                     +\n#   +            T := AES-128(K,Y);                                     +\n#   +   Step 7.  return T;                                              +\n#   +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    const_Bsize = 16\n    const_Zero  = bytearray(16)\n\n    AES_128= AES.new(K, AES.MODE_ECB)\n    M      = bytearray(M[:length])\n    K1, K2 = Generate_Subkey(K)\n    n      = len(M)//const_Bsize\n\n    if n == 0:\n        n = 1\n        flag = False\n    else:\n        if (length % const_Bsize) == 0:\n            flag = True\n        else:\n            n += 1\n            flag = False\n\n    M_n = M[(n-1)*const_Bsize:]\n    if flag is True:\n        M_last = XOR_128(M_n,K1)\n    else:\n        M_last = XOR_128(PAD(M_n),K2)\n\n    X = const_Zero\n    for i in range(n-1):\n        M_i = M[(i)*const_Bsize:][:16]\n        Y   = XOR_128(X, M_i)\n        X   = bytearray(AES_128.encrypt(bytes(Y)))\n    Y = XOR_128(M_last, X)\n    T = AES_128.encrypt(bytes(Y))\n\n    return T",
  "def AES_CMAC_PRF_128(VK, M, VKlen, Mlen):\n#   +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n#   +                        AES-CMAC-PRF-128                           +\n#   +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n#   +                                                                   +\n#   + Input  : VK (Variable-length key)                                 +\n#   +        : M (Message, i.e., the input data of the PRF)             +\n#   +        : VKlen (length of VK in octets)                           +\n#   +        : len (length of M in octets)                              +\n#   + Output : PRV (128-bit Pseudo-Random Variable)                     +\n#   +                                                                   +\n#   +-------------------------------------------------------------------+\n#   + Variable: K (128-bit key for AES-CMAC)                            +\n#   +                                                                   +\n#   + Step 1.   If VKlen is equal to 16                                 +\n#   + Step 1a.  then                                                    +\n#   +               K := VK;                                            +\n#   + Step 1b.  else                                                    +\n#   +               K := AES-CMAC(0^128, VK, VKlen);                    +\n#   + Step 2.   PRV := AES-CMAC(K, M, len);                             +\n#   +           return PRV;                                             +\n#   +                                                                   +\n#   +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n    if VKlen == 16:\n        K = VK\n    else:\n        K = AES_CMAC(bytes(bytearray(16)), VK, VKlen)\n\n    PRV = AES_CMAC(K, M, Mlen)\n\n    return PRV",
  "def KDF_CounterMode(KI, Label, Context, L):\n# Implements NIST SP 800-108 Section 5.1, with PRF HMAC-SHA256\n# https://tools.ietf.org/html/draft-irtf-cfrg-kdf-uses-00#ref-SP800-108\n# Fixed values:\n#  1. h - The length of the output of the PRF in bits, and\n#  2. r - The length of the binary representation of the counter i.\n# Input: KI, Label, Context, and L.\n# Process:\n#  1. n := [L/h]\n#  2. If n > 2r-1, then indicate an error and stop.\n#  3. result(0):= empty .\n#  4. For i = 1 to n, do\n#    a. K(i) := PRF (KI, [i]2 || Label || 0x00 || Context || [L]2)\n#    b. result(i) := result(i-1) || K(i).\n#  5. Return: KO := the leftmost L bits of result(n).\n    h = 256\n    r = 32\n\n    n = L // h\n\n    if n == 0:\n        n = 1\n\n    if n > (pow(2,r)-1):\n        raise Exception(\"Error computing KDF_CounterMode\")\n\n    result = b''\n    K      = b''\n\n    for i in range(1,n+1):\n       input = pack('>L', i) + Label + b'\\x00' + Context + pack('>L',L)\n       K = hmac.new(KI, input, hashlib.sha256).digest()\n       result = result + K\n\n    return result[:(L//8)]",
  "class LSA_SECRET_XP(Structure):\n    structure = (\n        ('Length','<L=0'),\n        ('Version','<L=0'),\n        ('_Secret','_-Secret', 'self[\"Length\"]'),\n        ('Secret', ':'),\n    )",
  "def transformKey(InputKey):\n    # Section 5.1.3\n    OutputKey = []\n    OutputKey.append( chr(ord(InputKey[0:1]) >> 0x01) )\n    OutputKey.append( chr(((ord(InputKey[0:1])&0x01)<<6) | (ord(InputKey[1:2])>>2)) )\n    OutputKey.append( chr(((ord(InputKey[1:2])&0x03)<<5) | (ord(InputKey[2:3])>>3)) )\n    OutputKey.append( chr(((ord(InputKey[2:3])&0x07)<<4) | (ord(InputKey[3:4])>>4)) )\n    OutputKey.append( chr(((ord(InputKey[3:4])&0x0F)<<3) | (ord(InputKey[4:5])>>5)) )\n    OutputKey.append( chr(((ord(InputKey[4:5])&0x1F)<<2) | (ord(InputKey[5:6])>>6)) )\n    OutputKey.append( chr(((ord(InputKey[5:6])&0x3F)<<1) | (ord(InputKey[6:7])>>7)) )\n    OutputKey.append( chr(ord(InputKey[6:7]) & 0x7F) )\n\n    for i in range(8):\n        OutputKey[i] = chr((ord(OutputKey[i]) << 1) & 0xfe)\n\n    return b(\"\".join(OutputKey))",
  "def decryptSecret(key, value):\n    # [MS-LSAD] Section 5.1.2\n    plainText = b''\n    key0 = key\n    for i in range(0, len(value), 8):\n        cipherText = value[:8]\n        tmpStrKey = key0[:7]\n        tmpKey = transformKey(tmpStrKey)\n        Crypt1 = DES.new(tmpKey, DES.MODE_ECB)\n        plainText += Crypt1.decrypt(cipherText)\n        key0 = key0[7:]\n        value = value[8:]\n        # AdvanceKey\n        if len(key0) < 7:\n            key0 = key[len(key0):]\n\n    secret = LSA_SECRET_XP(plainText)\n    return (secret['Secret'])",
  "def encryptSecret(key, value):\n    # [MS-LSAD] Section 5.1.2\n    cipherText = b''\n    key0 = key\n    value0 = pack('<LL', len(value), 1) + value\n    for i in range(0, len(value0), 8):\n        if len(value0) < 8:\n            value0 = value0 + b'\\x00'*(8-len(value0))\n        plainText = value0[:8]\n        tmpStrKey = key0[:7]\n        print(type(tmpStrKey))\n        print(tmpStrKey)\n        tmpKey = transformKey(tmpStrKey)\n        Crypt1 = DES.new(tmpKey, DES.MODE_ECB)\n        cipherText += Crypt1.encrypt(plainText)\n        key0 = key0[7:]\n        value0 = value0[8:]\n        # AdvanceKey\n        if len(key0) < 7:\n            key0 = key[len(key0):]\n\n    return cipherText",
  "def SamDecryptNTLMHash(encryptedHash, key):\n    # [MS-SAMR] Section 2.2.11.1.1\n    Block1 = encryptedHash[:8]\n    Block2 = encryptedHash[8:]\n\n    Key1 = key[:7]\n    Key1 = transformKey(Key1)\n    Key2 = key[7:14]\n    Key2 = transformKey(Key2)\n\n    Crypt1 = DES.new(Key1, DES.MODE_ECB)\n    Crypt2 = DES.new(Key2, DES.MODE_ECB)\n\n    plain1 = Crypt1.decrypt(Block1)\n    plain2 = Crypt2.decrypt(Block2)\n\n    return plain1 + plain2",
  "def SamEncryptNTLMHash(encryptedHash, key):\n    # [MS-SAMR] Section 2.2.11.1.1\n    Block1 = encryptedHash[:8]\n    Block2 = encryptedHash[8:]\n\n    Key1 = key[:7]\n    Key1 = transformKey(Key1)\n    Key2 = key[7:14]\n    Key2 = transformKey(Key2)\n\n    Crypt1 = DES.new(Key1, DES.MODE_ECB)\n    Crypt2 = DES.new(Key2, DES.MODE_ECB)\n\n    plain1 = Crypt1.encrypt(Block1)\n    plain2 = Crypt2.encrypt(Block2)\n\n    return plain1 + plain2",
  "class SMBPacketBase(Structure):\n    def addCommand(self,command):\n        # Pad to 8 bytes and put the offset of another SMBPacket\n        raise Exception('Implement This!')\n\n    def isValidAnswer(self, status):\n        if self['Status'] != status:\n            from . import smb3\n            raise smb3.SessionError(self['Status'], self)\n        return True\n\n    def __init__(self, data = None):\n        Structure.__init__(self,data)\n        if data is None:\n            self['TreeID'] = 0",
  "class SMB2PacketAsync(SMBPacketBase):\n    structure = (\n        ('ProtocolID','\"\\xfeSMB'),\n        ('StructureSize','<H=64'),\n        ('CreditCharge','<H=0'),\n        ('Status','<L=0'),\n        ('Command','<H=0'),\n        ('CreditRequestResponse','<H=0'),\n        ('Flags','<L=0'),\n        ('NextCommand','<L=0'),\n        ('MessageID','<Q=0'),\n        ('AsyncID','<Q=0'),\n        ('SessionID','<Q=0'),\n        ('Signature','16s=\"\"'),\n        ('Data',':=\"\"'),\n    )",
  "class SMB3PacketAsync(SMBPacketBase):\n    structure = (\n        ('ProtocolID','\"\\xfeSMB'),\n        ('StructureSize','<H=64'),\n        ('CreditCharge','<H=0'),\n        ('ChannelSequence','<H=0'),\n        ('Reserved','<H=0'),\n        ('Command','<H=0'),\n        ('CreditRequestResponse','<H=0'),\n        ('Flags','<L=0'),\n        ('NextCommand','<L=0'),\n        ('MessageID','<Q=0'),\n        ('AsyncID','<Q=0'),\n        ('SessionID','<Q=0'),\n        ('Signature','16s=\"\"'),\n        ('Data',':=\"\"'),\n    )",
  "class SMB2Packet(SMBPacketBase):\n    structure = (\n        ('ProtocolID','\"\\xfeSMB'),\n        ('StructureSize','<H=64'),\n        ('CreditCharge','<H=0'),\n        ('Status','<L=0'),\n        ('Command','<H=0'),\n        ('CreditRequestResponse','<H=0'),\n        ('Flags','<L=0'),\n        ('NextCommand','<L=0'),\n        ('MessageID','<Q=0'),\n        ('Reserved','<L=0'),\n        ('TreeID','<L=0'),\n        ('SessionID','<Q=0'),\n        ('Signature','16s=\"\"'),\n        ('Data',':=\"\"'),\n    )",
  "class SMB3Packet(SMBPacketBase):\n    structure = (\n        ('ProtocolID','\"\\xfeSMB'),\n        ('StructureSize','<H=64'),\n        ('CreditCharge','<H=0'),\n        ('ChannelSequence','<H=0'),\n        ('Reserved','<H=0'),\n        ('Command','<H=0'),\n        ('CreditRequestResponse','<H=0'),\n        ('Flags','<L=0'),\n        ('NextCommand','<L=0'),\n        ('MessageID','<Q=0'),\n        ('Reserved','<L=0'),\n        ('TreeID','<L=0'),\n        ('SessionID','<Q=0'),\n        ('Signature','16s=\"\"'),\n        ('Data',':=\"\"'),\n    )",
  "class SMB2Error(Structure):\n    structure = (\n        ('StructureSize','<H=9'),\n        ('Reserved','<H=0'),\n        ('ByteCount','<L=0'),\n        ('_ErrorData','_-ErrorData','self[\"ByteCount\"]'),\n        ('ErrorData','\"\\xff'),\n    )",
  "class SMB2ErrorSymbolicLink(Structure):\n    structure = (\n        ('SymLinkLength','<L=0'),\n        ('SymLinkErrorTag','<L=0'),\n        ('ReparseTag','<L=0'),\n        ('ReparseDataLenght','<H=0'),\n        ('UnparsedPathLength','<H=0'),\n        ('SubstituteNameOffset','<H=0'),\n        ('SubstituteNameLength','<H=0'),\n        ('PrintNameOffset','<H=0'),\n        ('PrintNameLength','<H=0'),\n        ('Flags','<L=0'),\n        ('PathBuffer',':'),\n    )",
  "class SMB2Negotiate(Structure):\n    structure = (\n        ('StructureSize','<H=36'),\n        ('DialectCount','<H=0'),\n        ('SecurityMode','<H=0'),\n        ('Reserved','<H=0'),\n        ('Capabilities','<L=0'),\n        ('ClientGuid','16s=\"\"'),\n        ('ClientStartTime','8s=\"\"'),  # or (NegotiateContextOffset/NegotiateContextCount/Reserved2) in SMB 3.1.1\n        ('Dialects','*<H'),\n        # SMB 3.1.1\n        ('Padding',':=\"\"'),\n        ('NegotiateContextList',':=\"\"'),\n    )",
  "class SMB311ContextData(Structure):\n    structure = (\n        ('NegotiateContextOffset','<L=0'),\n        ('NegotiateContextCount','<H=0'),\n        ('Reserved2','<H=0'),\n    )",
  "class SMB2Negotiate_Response(Structure):\n    structure = (\n        ('StructureSize','<H=65'),\n        ('SecurityMode','<H=0'),\n        ('DialectRevision','<H=0'),\n        # SMB 3.1.1 only. Otherwise Reserved\n        ('NegotiateContextCount','<H=0'),\n        ('ServerGuid','16s=\"\"'),\n        ('Capabilities','<L=0'),\n        ('MaxTransactSize','<L=0'),\n        ('MaxReadSize','<L=0'),\n        ('MaxWriteSize','<L=0'),\n        ('SystemTime','<Q=0'),\n        ('ServerStartTime','<Q=0'),\n        ('SecurityBufferOffset','<H=0'),\n        ('SecurityBufferLength','<H=0'),\n        # SMB 3.1.1 only. Otherwise Reserved\n        ('NegotiateContextOffset','<L=0'),\n        ('_AlignPad','_-AlignPad','self[\"SecurityBufferOffset\"] - (64 + self[\"StructureSize\"] - 1)'),\n        ('AlignPad',':=\"\"'),\n        ('_Buffer','_-Buffer','self[\"SecurityBufferLength\"]'),\n        ('Buffer',':'),\n        ('_Padding','_-Padding', '0 if self[\"NegotiateContextOffset\"] == 0 else (self[\"NegotiateContextOffset\"] - '\n                                 'self[\"SecurityBufferOffset\"] - self[\"SecurityBufferLength\"])'),\n        ('Padding',':=\"\"'),\n        ('_NegotiateContextList','_-NegotiateContextList', '0 if self[\"NegotiateContextOffset\"] == 0 else '\n                                                           'len(self.rawData)-self[\"NegotiateContextOffset\"]+64'),\n        ('NegotiateContextList',':=\"\"'),\n    )",
  "class SMB2NegotiateContext(Structure):\n    structure = (\n        ('ContextType','<H=0'),\n        ('DataLength','<H=0'),\n        ('Reserved','<L=0'),\n        ('_Data', '_-Data', 'self[\"DataLength\"]'),\n        ('Data',':=\"\"'),\n    )",
  "class SMB2PreAuthIntegrityCapabilities(Structure):\n    structure = (\n        ('HashAlgorithmCount','<H=0'),\n        ('SaltLength','<H=0'),\n        ('_HashAlgorithms', '_-HashAlgorithms', 'self[\"HashAlgorithmCount\"]*2'),\n        ('HashAlgorithms',':=\"\"'),\n        ('Salt',':=\"\"'),\n    )",
  "class SMB2EncryptionCapabilities(Structure):\n    structure = (\n        ('CipherCount','<H=0'),\n        ('Ciphers',':=\"\"'),\n    )",
  "class SMB2CompressionCapabilities(Structure):\n    structure = (\n        ('CompressionAlgorithmCount','<H=0'),\n        ('Padding','<H=0'),\n        ('Flags','<L=0'),\n        ('CompressionAlgorithms',':=\"\"'),\n    )",
  "class SMB2NetNameNegotiateContextID(Structure):\n    structure = (\n        ('NetName',':=\"\"'),\n    )",
  "class SMB2SessionSetup(Structure):\n    SIZE = 24\n    structure = (\n        ('StructureSize','<H=25'),\n        ('Flags','<B=0'),\n        ('SecurityMode','<B=0'),\n        ('Capabilities','<L=0'),\n        ('Channel','<L=0'),\n        ('SecurityBufferOffset','<H=(self.SIZE + 64 + len(self[\"AlignPad\"]))'),\n        ('SecurityBufferLength','<H=0'),\n        ('PreviousSessionId','<Q=0'),\n        ('_AlignPad','_-AlignPad','self[\"SecurityBufferOffset\"] - (64 + self[\"StructureSize\"] - 1)'),\n        ('AlignPad',':=\"\"'),\n        ('_Buffer','_-Buffer','self[\"SecurityBufferLength\"]'),\n        ('Buffer',':'),\n    )\n\n    def __init__(self, data = None):\n        Structure.__init__(self,data)\n        if data is None:\n            self['AlignPad'] = ''\n\n    def getData(self):\n        #self['AlignPad'] = '\\x00' * ((8 - ((24 + SMB2_PACKET_SIZE) & 7)) & 7)\n        #self['SecurityBufferOffset'] = 24 + SMB2_PACKET_SIZE +len(self['AlignPad'])\n        #self['SecurityBufferLength'] += len(self['AlignPad'])\n        return Structure.getData(self)",
  "class SMB2SessionSetup_Response(Structure):\n    structure = (\n        ('StructureSize','<H=9'),\n        ('SessionFlags','<H=0'),\n        ('SecurityBufferOffset','<H=0'),\n        ('SecurityBufferLength','<H=0'),\n        ('_AlignPad','_-AlignPad','self[\"SecurityBufferOffset\"] - (64 + self[\"StructureSize\"] - 1)'),\n        ('AlignPad',':=\"\"'),\n        ('_Buffer','_-Buffer','self[\"SecurityBufferLength\"]'),\n        ('Buffer',':'),\n    )",
  "class SMB2Logoff(Structure):\n    structure = (\n        ('StructureSize','<H=4'),\n        ('Reserved','<H=0'),\n    )",
  "class SMB2Logoff_Response(Structure):\n    structure = (\n        ('StructureSize','<H=4'),\n        ('Reserved','<H=0'),\n    )",
  "class SMB2TreeConnect(Structure):\n    SIZE = 8\n    structure = (\n        ('StructureSize','<H=9'),\n        ('Reserved','<H=0'),\n        ('PathOffset','<H=(self.SIZE + 64 + len(self[\"AlignPad\"]))'),\n        ('PathLength','<H=0'),\n        ('_AlignPad','_-AlignPad','self[\"PathOffset\"] - (64 + self.SIZE - 1)'),\n        ('AlignPad',':=\"\"'),\n        ('_Buffer','_-Buffer','self[\"PathLength\"]'),\n        ('Buffer',':'),\n    )\n    def __init__(self, data = None):\n        Structure.__init__(self,data)\n        if data is None:\n            self['AlignPad'] = ''",
  "class SMB2TreeConnect_Response(Structure):\n    structure = (\n        ('StructureSize','<H=16'),\n        ('ShareType','<B=0'),\n        ('Reserved','<B=0'),\n        ('ShareFlags','<L=0'),\n        ('Capabilities','<L=0'),\n        ('MaximalAccess','<L=0'),\n    )",
  "class SMB2TreeDisconnect(Structure):\n    structure = (\n        ('StructureSize','<H=4'),\n        ('Reserved','<H=0'),\n    )",
  "class SMB2TreeDisconnect_Response(Structure):\n    structure = (\n        ('StructureSize','<H=4'),\n        ('Reserved','<H=0'),\n    )",
  "class SMB2Create(Structure):\n    SIZE = 56\n    structure = (\n        ('StructureSize','<H=57'),\n        ('SecurityFlags','<B=0'),\n        ('RequestedOplockLevel','<B=0'),\n        ('ImpersonationLevel','<L=0'),\n        ('SmbCreateFlags','<Q=0'),\n        ('Reserved','<Q=0'),\n        ('DesiredAccess','<L=0'),\n        ('FileAttributes','<L=0'),\n        ('ShareAccess','<L=0'),\n        ('CreateDisposition','<L=0'),\n        ('CreateOptions','<L=0'),\n        ('NameOffset','<H=(self.SIZE + 64 + len(self[\"AlignPad\"]))'),\n        ('NameLength','<H=0'),\n        ('CreateContextsOffset','<L=0'),\n        ('CreateContextsLength','<L=0'),\n        ('_AlignPad','_-AlignPad','self[\"NameOffset\"] - (64 + self[\"StructureSize\"] - 1)'),\n        ('AlignPad',':=\"\"'),\n        ('_Buffer','_-Buffer','self[\"CreateContextsLength\"]+self[\"NameLength\"]'),\n        ('Buffer',':'),\n    )\n    def __init__(self, data = None):\n        Structure.__init__(self,data)\n        if data is None:\n            self['AlignPad'] = ''",
  "class SMB2CreateContext(Structure):\n     structure = (\n         ('Next','<L=0'),\n         ('NameOffset','<H=0'),\n         ('NameLength','<H=0'),\n         ('Reserved','<H=0'),\n         ('DataOffset','<H=0'),\n         ('DataLength','<L=0'),\n         ('_Buffer','_-Buffer','self[\"DataLength\"]+self[\"NameLength\"]'),\n         ('Buffer',':'),\n     )",
  "class SMB2_FILEID(Structure):\n    structure = (\n        ('Persistent','<Q=0'),\n        ('Volatile','<Q=0'),\n    )",
  "class SMB2Create_Response(Structure):\n    structure = (\n        ('StructureSize','<H=89'),\n        ('OplockLevel','<B=0'),\n        ('Flags','<B=0'),\n        ('CreateAction','<L=0'),\n        ('CreationTime','<Q=0'),\n        ('LastAccessTime','<Q=0'),\n        ('LastWriteTime','<Q=0'),\n        ('ChangeTime','<Q=0'),\n        ('AllocationSize','<Q=0'),\n        ('EndOfFile','<Q=0'),\n        ('FileAttributes','<L=0'),\n        ('Reserved2','<L=0'),\n        ('FileID',':',SMB2_FILEID),\n        ('CreateContextsOffset','<L=0'),\n        ('CreateContextsLength','<L=0'),\n        ('_AlignPad','_-AlignPad','self[\"CreateContextsOffset\"] - (64 + self[\"StructureSize\"] - 1)'),\n        ('AlignPad',':=\"\"'),\n        ('_Buffer','_-Buffer','self[\"CreateContextsLength\"]'),\n        ('Buffer',':'),\n    )",
  "class FILE_FULL_EA_INFORMATION(Structure):\n    structure = (\n        ('NextEntryOffset','<L=0'),\n        ('Flags','<B=0'),\n        ('EaNameLength','<B=0'),\n        ('EaValueLength','<H=0'),\n        ('_EaName','_-EaName','self[\"EaNameLength\"]'),\n        ('EaName',':'),\n        ('_EaValue','_-EaValue','self[\"EaValue\"]'),\n        ('EaValue',':'),\n    )",
  "class SMB2_CREATE_DURABLE_HANDLE_RECONNECT(Structure):\n    structure = (\n        ('Data',':',SMB2_FILEID),\n    )",
  "class SMB2_CREATE_DURABLE_HANDLE_REQUEST(Structure):\n    structure = (\n        ('DurableRequest','16s=\"\"'),\n    )",
  "class SMB2_CREATE_DURABLE_HANDLE_RESPONSE(Structure):\n    structure = (\n        ('Reserved','<Q=0'),\n    )",
  "class SMB2_CREATE_QUERY_MAXIMAL_ACCESS_REQUEST(Structure):\n    structure = (\n        ('Timestamp','<Q=0'),\n    )",
  "class SMB2_CREATE_QUERY_MAXIMAL_ACCESS_RESPONSE(Structure):\n    structure = (\n        ('QueryStatus','<L=0'),\n        ('MaximalAccess','<L=0'),\n    )",
  "class SMB2_CREATE_ALLOCATION_SIZE(Structure):\n    structure = (\n        ('AllocationSize','<Q=0'),\n    )",
  "class SMB2_CREATE_TIMEWARP_TOKEN(Structure):\n    structure = (\n        ('Timestamp','<Q=0'),\n    )",
  "class SMB2_CREATE_REQUEST_LEASE(Structure):\n    structure = (\n        ('LeaseKey','16s=\"\"'),\n        ('LeaseState','<L=0'),\n        ('LeaseFlags','<L=0'),\n        ('LeaseDuration','<Q=0'),\n    )",
  "class SMB2_CREATE_REQUEST_LEASE_V2(Structure):\n    structure = (\n        ('LeaseKey','16s=\"\"'),\n        ('LeaseState','<L=0'),\n        ('Flags','<L=0'),\n        ('LeaseDuration','<Q=0'),\n        ('ParentLeaseKey','16s=\"\"'),\n        ('Epoch','<H=0'),\n        ('Reserved','<H=0'),\n    )",
  "class SMB2_CREATE_DURABLE_HANDLE_REQUEST_V2(Structure):\n    structure = (\n        ('Timeout','<L=0'),\n        ('Flags','<L=0'),\n        ('Reserved','8s=\"\"'),\n        ('CreateGuid','16s=\"\"'),\n    )",
  "class SMB2_CREATE_DURABLE_HANDLE_RESPONSE_V2(Structure):\n    structure = (\n        ('Timeout','<L=0'),\n        ('Flags','<L=0'),\n    )",
  "class SMB2_CREATE_DURABLE_HANDLE_RECONNECT_V2(Structure):\n    structure = (\n        ('FileID',':', SMB2_FILEID),\n        ('CreateGuid','16s=\"\"'),\n        ('Flags','<L=0'),\n    )",
  "class SMB2_CREATE_APP_INSTANCE_ID(Structure):\n    structure = (\n        ('StructureSize','<H=0'),\n        ('Reserved','<H=0'),\n        ('AppInstanceId','16s=\"\"'),\n    )",
  "class SMB2_CREATE_QUERY_ON_DISK_ID(Structure):\n    structure = (\n        ('DiskIDBuffer','32s=\"\"'),\n    )",
  "class SMB2Close(Structure):\n    structure = (\n        ('StructureSize','<H=24'),\n        ('Flags','<H=0'),\n        ('Reserved','<L=0'),\n        ('FileID',':', SMB2_FILEID),\n    )",
  "class SMB2Close_Response(Structure):\n    structure = (\n        ('StructureSize','<H=60'),\n        ('Flags','<H=0'),\n        ('Reserved','<L=0'),\n        ('CreationTime','<Q=0'),\n        ('LastAccessTime','<Q=0'),\n        ('LastWriteTime','<Q=0'),\n        ('ChangeTime','<Q=0'),\n        ('AllocationSize','<Q=0'),\n        ('EndofFile','<Q=0'),\n        ('FileAttributes','<L=0'),\n    )",
  "class SMB2Flush(Structure):\n    structure = (\n        ('StructureSize','<H=24'),\n        ('Reserved1','<H=0'),\n        ('Reserved2','<L=0'),\n        ('FileID',':',SMB2_FILEID),\n    )",
  "class SMB2Flush_Response(Structure):\n    structure = (\n        ('StructureSize','<H=4'),\n        ('Reserved','<H=0'),\n    )",
  "class SMB2Read(Structure):\n    SIZE = 48\n    structure = (\n        ('StructureSize','<H=49'),\n        ('Padding','<B=0'),\n        ('Reserved','<B=0'),\n        ('Length','<L=0'),\n        ('Offset','<Q=0'),\n        ('FileID',':',SMB2_FILEID),\n        ('MinimumCount','<L=0'),\n        ('Channel','<L=0'),\n        ('RemainingBytes','<L=0'),\n        ('ReadChannelInfoOffset','<H=0'),\n        ('ReadChannelInfoLength','<H=0'),\n        ('_AlignPad','_-AlignPad','self[\"ReadChannelInfoOffset\"] - (64 + self[\"StructureSize\"] - 1)'),\n        ('AlignPad',':=\"\"'),\n        ('_Buffer','_-Buffer','self[\"ReadChannelInfoLength\"]'),\n        ('Buffer',':=\"0\"'),\n    )\n    def __init__(self, data = None):\n        Structure.__init__(self,data)\n        if data is None:\n            self['AlignPad'] = ''",
  "class SMB2Read_Response(Structure):\n    structure = (\n        ('StructureSize','<H=17'),\n        ('DataOffset','<B=0'),\n        ('Reserved','<B=0'),\n        ('DataLength','<L=0'),\n        ('DataRemaining','<L=0'),\n        ('Reserved2','<L=0'),\n        ('_AlignPad','_-AlignPad','self[\"DataOffset\"] - (64 + self[\"StructureSize\"] - 1)'),\n        ('AlignPad',':=\"\"'),\n        ('_Buffer','_-Buffer','self[\"DataLength\"]'),\n        ('Buffer',':'),\n    )",
  "class SMB2Write(Structure):\n    SIZE = 48\n    structure = (\n        ('StructureSize','<H=49'),\n        ('DataOffset','<H=(self.SIZE + 64 + len(self[\"AlignPad\"]))'),\n        ('Length','<L=0'),\n        ('Offset','<Q=0'),\n        ('FileID',':',SMB2_FILEID),\n        ('Channel','<L=0'),\n        ('RemainingBytes','<L=0'),\n        ('WriteChannelInfoOffset','<H=0'),\n        ('WriteChannelInfoLength','<H=0'),\n        ('_AlignPad','_-AlignPad','self[\"DataOffset\"] + self[\"WriteChannelInfoOffset\"] - (64 + self[\"StructureSize\"] - 1)'),\n        ('AlignPad',':=\"\"'),\n        ('Flags','<L=0'),\n        ('_Buffer','_-Buffer','self[\"Length\"]+self[\"WriteChannelInfoLength\"]'),\n        ('Buffer',':'),\n    )\n    def __init__(self, data = None):\n        Structure.__init__(self,data)\n        if data is None:\n            self['AlignPad'] = ''",
  "class SMB2Write_Response(Structure):\n    structure = (\n        ('StructureSize','<H=17'),\n        ('Reserved','<H=0'),\n        ('Count','<L=0'),\n        ('Remaining','<L=0'),\n        ('WriteChannelInfoOffset','<H=0'),\n        ('WriteChannelInfoLength','<H=0'),\n    )",
  "class SMB2OplockBreakNotification(Structure):\n    structure = (\n        ('StructureSize','<H=24'),\n        ('OplockLevel','<B=0'),\n        ('Reserved','<B=0'),\n        ('Reserved2','<L=0'),\n        ('FileID',':',SMB2_FILEID),\n    )",
  "class SMB2LeaseBreakNotification(Structure):\n    structure = (\n        ('StructureSize','<H=44'),\n        ('NewEpoch','<H=0'),\n        ('Flags','<L=0'),\n        ('LeaseKey','16s=\"\"'),\n        ('CurrentLeaseState','<L=0'),\n        ('NewLeaseState','<L=0'),\n        ('BreakReason','<L=0'),\n        ('AccessMaskHint','<L=0'),\n        ('ShareMaskHint','<L=0'),\n    )",
  "class SMB2LeaseBreakAcknowledgement(Structure):\n    structure = (\n        ('StructureSize','<H=36'),\n        ('Reserved','<H=0'),\n        ('Flags','<L=0'),\n        ('LeaseKey','16s=\"\"'),\n        ('LeaseState','<L=0'),\n        ('LeaseDuration','<Q=0'),\n    )",
  "class SMB2_LOCK_ELEMENT(Structure):\n    structure = (\n        ('Offset','<Q=0'),\n        ('Length','<Q=0'),\n        ('Flags','<L=0'),\n        ('Reserved','<L=0'),\n    )",
  "class SMB2Lock(Structure):\n    structure = (\n        ('StructureSize','<H=48'),\n        ('LockCount','<H=0'),\n        ('LockSequence','<L=0'),\n        ('FileID',':',SMB2_FILEID),\n        ('_Locks','_-Locks','self[\"LockCount\"]*24'),\n        ('Locks',':'),\n    )",
  "class SMB2Lock_Response(Structure):\n    structure = (\n        ('StructureSize','<H=4'),\n        ('Reserved','<H=0'),\n    )",
  "class SMB2Echo(Structure):\n    structure = (\n        ('StructureSize','<H=4'),\n        ('Reserved','<H=0'),\n    )",
  "class SMB2Cancel(Structure):\n    structure = (\n        ('StructureSize','<H=4'),\n        ('Reserved','<H=0'),\n    )",
  "class SMB2Ioctl(Structure):\n    SIZE = 56\n    structure = (\n        ('StructureSize','<H=57'),\n        ('Reserved','<H=0'),\n        ('CtlCode','<L=0'),\n        ('FileID',':',SMB2_FILEID),\n        ('InputOffset','<L=(self.SIZE + 64 + len(self[\"AlignPad\"]))'),\n        ('InputCount','<L=0'),\n        ('MaxInputResponse','<L=0'),\n        ('OutputOffset','<L=(self.SIZE + 64 + len(self[\"AlignPad\"]) + self[\"InputCount\"])'),\n        ('OutputCount','<L=0'),\n        ('MaxOutputResponse','<L=0'),\n        ('Flags','<L=0'),\n        ('Reserved2','<L=0'),\n        #('_AlignPad','_-AlignPad','self[\"InputOffset\"] + self[\"OutputOffset\"] - (64 + self[\"StructureSize\"] - 1)'),\n        #('AlignPad',':=\"\"'),\n        ('_Buffer','_-Buffer','self[\"InputCount\"]+self[\"OutputCount\"]'),\n        ('Buffer',':'),\n    )\n    def __init__(self, data = None):\n        Structure.__init__(self,data)\n        if data is None:\n            self['AlignPad'] = ''",
  "class FSCTL_PIPE_WAIT_STRUCTURE(Structure):\n    structure = (\n        ('Timeout','<q=0'),\n        ('NameLength','<L=0'),\n        ('TimeoutSpecified','<B=0'),\n        ('Padding','<B=0'),\n        ('_Name','_-Name','self[\"NameLength\"]'),\n        ('Name',':'),\n    )",
  "class SRV_COPYCHUNK_COPY(Structure):\n    structure = (\n        ('SourceKey','24s=\"\"'),\n        ('ChunkCount','<L=0'),\n        ('Reserved','<L=0'),\n        ('_Chunks','_-Chunks', 'self[\"ChunkCount\"]*len(SRV_COPYCHUNK)'),\n        ('Chunks',':'),\n    )",
  "class SRV_COPYCHUNK(Structure):\n    structure = (\n        ('SourceOffset','<Q=0'),\n        ('TargetOffset','<Q=0'),\n        ('Length','<L=0'),\n        ('Reserved','<L=0'),\n    )",
  "class SRV_COPYCHUNK_RESPONSE(Structure):\n    structure = (\n        ('ChunksWritten','<L=0'),\n        ('ChunkBytesWritten','<L=0'),\n        ('TotalBytesWritten','<L=0'),\n    )",
  "class SRV_READ_HASH(Structure):\n    structure = (\n        ('HashType','<L=0'),\n        ('HashVersion','<L=0'),\n        ('HashRetrievalType','<L=0'),\n        ('Length','<L=0'),\n        ('Offset','<Q=0'),\n    )",
  "class NETWORK_RESILIENCY_REQUEST(Structure):\n    structure = (\n        ('Timeout','<L=0'),\n        ('Reserved','<L=0'),\n    )",
  "class VALIDATE_NEGOTIATE_INFO(Structure):\n    structure = (\n        ('Capabilities','<L=0'),\n        ('Guid','16s=\"\"'),\n        ('SecurityMode','<H=0'),\n        #('DialectCount','<H=0'),\n        ('Dialects','<H*<H'),\n    )",
  "class VALIDATE_NEGOTIATE_INFO_RESPONSE(Structure):\n    structure = (\n        ('Capabilities','<L=0'),\n        ('Guid','16s=\"\"'),\n        ('SecurityMode','<H=0'),\n        ('Dialect','<H'),\n    )",
  "class SRV_SNAPSHOT_ARRAY(Structure):\n    structure = (\n        ('NumberOfSnapShots','<L=0'),\n        ('NumberOfSnapShotsReturned','<L=0'),\n        ('SnapShotArraySize','<L=0'),\n        ('_SnapShots','_-SnapShots','self[\"SnapShotArraySize\"]'),\n        ('SnapShots',':'),\n    )",
  "class SRV_REQUEST_RESUME_KEY(Structure):\n    structure = (\n        ('ResumeKey','24s=\"\"'),\n        ('ContextLength','<L=0'),\n        ('_Context','_-Context','self[\"ContextLength\"]'),\n        ('Context',':'),\n    )",
  "class HASH_HEADER(Structure):\n    structure = (\n        ('HashType','<L=0'),\n        ('HashVersion','<L=0'),\n        ('SourceFileChangeTime','<Q=0'),\n        ('SourceFileSize','<Q=0'),\n        ('HashBlobLength','<L=0'),\n        ('HashBlobOffset','<L=0'),\n        ('Dirty','<H=0'),\n        ('SourceFileNameLength','<L=0'),\n        ('_SourceFileName','_-SourceFileName','self[\"SourceFileNameLength\"]',),\n        ('SourceFileName',':'),\n    )",
  "class SRV_HASH_RETRIEVE_HASH_BASED(Structure):\n    structure = (\n        ('Offset','<Q=0'),\n        ('BufferLength','<L=0'),\n        ('Reserved','<L=0'),\n        ('_Buffer','_-Buffer','self[\"BufferLength\"]'),\n        ('Buffer',':'),\n    )",
  "class SRV_HASH_RETRIEVE_FILE_BASED(Structure):\n    structure = (\n        ('FileDataOffset','<Q=0'),\n        ('FileDataLength','<Q=0'),\n        ('BufferLength','<L=0'),\n        ('Reserved','<L=0'),\n        ('_Buffer','_-Buffer','self[\"BufferLength\"]'),\n        ('Buffer',':'),\n    )",
  "class NETWORK_INTERFACE_INFO(Structure):\n    structure = (\n        ('Next','<L=0'),\n        ('IfIndex','<L=0'),\n        ('Capability','<L=0'),\n        ('Reserved','<L=0'),\n        ('LinkSpeed','<Q=0'),\n        ('SockAddr_Storage','128s=\"\"'),\n    )",
  "class MOUNT_POINT_REPARSE_DATA_STRUCTURE(Structure):\n    structure = (\n        (\"ReparseTag\", \"<L=0xA0000003\"),\n        (\"ReparseDataLen\", \"<H=len(self['PathBuffer']) + 8\"),\n        (\"Reserved\", \"<H=0\"),\n        (\"SubstituteNameOffset\", \"<H=0\"),\n        (\"SubstituteNameLength\", \"<H=0\"),\n        (\"PrintNameOffset\", \"<H=0\"),\n        (\"PrintNameLength\", \"<H=0\"),\n        (\"PathBuffer\", \":\")\n    )",
  "class MOUNT_POINT_REPARSE_GUID_DATA_STRUCTURE(Structure):\n    structure = (\n        (\"ReparseTag\", \"<L=0xA0000003\"),\n        (\"ReparseDataLen\", \"<H=len(self['DataBuffer'])\"),\n        (\"Reserved\", \"<H=0\"),\n        (\"ReparseGuid\", \"16s=''\"),\n        (\"DataBuffer\", \":\")\n    )",
  "class SMB2Ioctl_Response(Structure):\n    structure = (\n        ('StructureSize','<H=49'),\n        ('Reserved','<H=0'),\n        ('CtlCode','<L=0'),\n        ('FileID',':',SMB2_FILEID),\n        ('InputOffset','<L=0'),\n        ('InputCount','<L=0'),\n        ('OutputOffset','<L=0'),\n        ('OutputCount','<L=0'),\n        ('Flags','<L=0'),\n        ('Reserved2','<L=0'),\n        ('_AlignPad','_-AlignPad','self[\"OutputOffset\"] - (64 + self[\"StructureSize\"] - 1)'),\n        ('AlignPad',':=\"\"'),\n        ('_Buffer','_-Buffer','self[\"InputCount\"]+self[\"OutputCount\"]'),\n        ('Buffer',':'),\n    )",
  "class SMB2QueryDirectory(Structure):\n    SIZE = 32\n    structure = (\n        ('StructureSize','<H=33'),\n        ('FileInformationClass','<B=0'),\n        ('Flags','<B=0'),\n        ('FileIndex','<L=0'),\n        ('FileID',':',SMB2_FILEID),\n        ('FileNameOffset','<H=(self.SIZE + 64 + len(self[\"AlignPad\"]))'),\n        ('FileNameLength','<H=0'),\n        ('OutputBufferLength','<L=0'),\n        ('_AlignPad','_-AlignPad','self[\"FileNameOffset\"] - (64 + self[\"StructureSize\"] - 1)'),\n        ('AlignPad',':=\"\"'),\n        ('_Buffer','_-Buffer','self[\"FileNameLength\"]'),\n        ('Buffer',':'),\n    )\n    def __init__(self, data = None):\n        Structure.__init__(self,data)\n        if data is None:\n            self['AlignPad'] = ''",
  "class SMB2QueryDirectory_Response(Structure):\n    structure = (\n        ('StructureSize','<H=9'),\n        ('OutputBufferOffset','<H=0'),\n        ('OutputBufferLength','<L=0'),\n        ('_AlignPad','_-AlignPad','self[\"OutputBufferOffset\"] - (64 + self[\"StructureSize\"] - 1)'),\n        ('AlignPad',':=\"\"'),\n        ('_Buffer','_-Buffer','self[\"OutputBufferLength\"]'),\n        ('Buffer',':'),\n    )",
  "class SMB2ChangeNotify(Structure):\n    structure = (\n        ('StructureSize','<H=32'),\n        ('Flags','<H=0'),\n        ('OutputBufferLength','<L=0'),\n        ('FileID',':',SMB2_FILEID),\n        ('CompletionFilter','<L=0'),\n        ('Reserved','<L=0'),\n    )",
  "class SMB2ChangeNotify_Response(Structure):\n    structure = (\n        ('StructureSize','<H=9'),\n        ('OutputBufferOffset','<H=0'),\n        ('OutputBufferLength','<L=0'),\n        ('_AlignPad','_-AlignPad','self[\"OutputBufferOffset\"] - (64 + self[\"StructureSize\"] - 1)'),\n        ('AlignPad',':=\"\"'),\n        ('_Buffer','_-Buffer','self[\"OutputBufferLength\"]'),\n        ('Buffer',':'),\n    )",
  "class FILE_NOTIFY_INFORMATION(Structure):\n    structure = (\n        ('NextEntryOffset','<L=0'),\n        ('Action','<L=0'),\n        ('FileNameLength','<L=0'),\n        ('_FileName','_-FileName','self[\"FileNameLength\"]',),\n        ('FileName',':'),\n    )",
  "class SMB2QueryInfo(Structure):\n    SIZE = 40\n    structure = (\n       ('StructureSize','<H=41'),\n       ('InfoType','<B=0'),\n       ('FileInfoClass','<B=0'),\n       ('OutputBufferLength','<L=0'),\n       ('InputBufferOffset','<H=(self.SIZE + 64 + len(self[\"AlignPad\"]))'),\n       ('Reserved','<H=0'),\n       ('InputBufferLength','<L=0'),\n       ('AdditionalInformation','<L=0'),\n       ('Flags','<L=0'),\n       ('FileID',':',SMB2_FILEID),\n       ('_AlignPad','_-AlignPad','self[\"InputBufferOffset\"] - (64 + self[\"StructureSize\"] - 1)'),\n       ('AlignPad',':=\"\"'),\n       ('_Buffer','_-Buffer','self[\"InputBufferLength\"]'),\n       ('Buffer',':'),\n    )\n    def __init__(self, data = None):\n        Structure.__init__(self,data)\n        if data is None:\n            self['AlignPad'] = ''",
  "class SMB2_QUERY_QUOTA_INFO(Structure):\n    structure = (\n        ('ReturnSingle','<B=0'),\n        ('RestartScan','<B=0'),\n        ('Reserved','<H=0'),\n        ('SidListLength','<L=0'),\n        ('StartSidLength','<L=0'),\n        ('StartSidOffset','<L=0'),\n        # ToDo: Check 2.2.37.1 here\n        ('SidBuffer',':'),\n    )",
  "class SMB2QueryInfo_Response(Structure):\n   structure = (\n       ('StructureSize','<H=9'),\n       ('OutputBufferOffset','<H=0'),\n       ('OutputBufferLength','<L=0'),\n       ('_AlignPad','_-AlignPad','self[\"OutputBufferOffset\"] - (64 + self[\"StructureSize\"] - 1)'),\n       ('AlignPad',':=\"\"'),\n       ('_Buffer','_-Buffer','self[\"OutputBufferLength\"]'),\n       ('Buffer',':'),\n   )",
  "class FILE_BASIC_INFORMATION (Structure):\n    structure = (\n        ('CreationTime','<q'),\n        ('LastAccessTime','<q'),\n        ('LastWriteTime','<q'),\n        ('ChangeTime','<q'),\n        ('FileAttributes','<L'),\n        ('Reserved','<L=0'),\n    )",
  "class FILE_STANDARD_INFORMATION (Structure):\n    structure = (\n        ('AllocationSize','<q'),\n        ('EndOfFile','<q'),\n        ('NumberOfLinks','<L'),\n        ('DeletePending','<B=0'),\n        ('Directory','<B'),\n        ('Reserved','<H=0'),\n    )",
  "class FILE_INTERNAL_INFORMATION (Structure):\n    structure = (\n        ('IndexNumber','<q=0'),\n    )",
  "class FILE_EA_INFORMATION (Structure):\n    structure = (\n        ('EaSize','<L'),\n    )",
  "class FILE_ACCESS_INFORMATION (Structure):\n    structure = (\n        ('AccessFlags','<L'),\n    )",
  "class FILE_POSITION_INFORMATION (Structure):\n    structure = (\n        ('CurrentByteOffset','<Q'),\n    )",
  "class FILE_MODE_INFORMATION (Structure):\n    structure = (\n        ('Mode','<L=0'),\n    )",
  "class FILE_ALIGNMENT_INFORMATION (Structure):\n    structure = (\n        ('AlignmentRequirement','<L'),\n    )",
  "class FILE_NAME_INFORMATION (Structure):\n    structure = (\n        ('FileNameLength','<L=0'),\n        ('_FileName','_-FileName', 'self[\"FileNameLength\"]'),\n        ('FileName',':'),\n    )",
  "class FILE_ALL_INFORMATION(Structure):\n    structure = (\n        ('BasicInformation',':',FILE_BASIC_INFORMATION),\n        ('StandardInformation',':',FILE_STANDARD_INFORMATION),\n        ('InternalInformation',':',FILE_INTERNAL_INFORMATION),\n        ('EaInformation',':',FILE_EA_INFORMATION),\n        ('AccessInformation',':',FILE_ACCESS_INFORMATION),\n        ('PositionInformation',':',FILE_POSITION_INFORMATION),\n        ('ModeInformation',':',FILE_MODE_INFORMATION),\n        ('AlignmentInformation',':',FILE_ALIGNMENT_INFORMATION),\n        ('NameInformation',':',FILE_NAME_INFORMATION),\n    )",
  "class SMB2SetInfo(Structure):\n    SIZE = 32\n    structure = (\n       ('StructureSize','<H=33'),\n       ('InfoType','<B=0'),\n       ('FileInfoClass','<B=0'),\n       ('BufferLength','<L=0'),\n       ('BufferOffset','<H=(self.SIZE + 64 + len(self[\"AlignPad\"]))'),\n       ('Reserved','<H=0'),\n       ('AdditionalInformation','<L=0'),\n       ('FileID',':',SMB2_FILEID),\n       ('_AlignPad','_-AlignPad','self[\"BufferOffset\"] - (64 + self[\"StructureSize\"] - 1)'),\n       ('AlignPad',':=\"\"'),\n       ('_Buffer','_-Buffer','self[\"BufferLength\"]'),\n       ('Buffer',':'),\n    )\n    def __init__(self, data = None):\n        Structure.__init__(self,data)\n        if data is None:\n            self['AlignPad'] = ''",
  "class SMB2SetInfo_Response(Structure):\n    structure = (\n       ('StructureSize','<H=2'),\n    )",
  "class FILE_RENAME_INFORMATION_TYPE_2(Structure):\n    structure = (\n        ('ReplaceIfExists','<B=0'),\n        ('Reserved','7s=\"\"'),\n        ('RootDirectory','<Q=0'),\n        ('FileNameLength','<L=0'),\n        ('_FileName','_-FileName','self[\"FileNameLength\"]'),\n        ('FileName',':'),\n    )",
  "class SMB2_TRANSFORM_HEADER(Structure):\n    structure = (\n        ('ProtocolID','\"\\xfdSMB'),\n        ('Signature','16s=\"\"'),\n        ('Nonce','16s=\"\"'),\n        ('OriginalMessageSize','<L=0'),\n        ('Reserved','<H=0'),\n        ('EncryptionAlgorithm','<H=0'),\n        ('SessionID','<Q=0'),\n    )",
  "class SMB2_COMPRESSION_TRANSFORM_HEADER(Structure):\n    structure = (\n        ('ProtocolID','<L=0'),\n        ('OriginalCompressedSegmentSize','<L=0'),\n        ('CompressionAlgorithm','<H=0'),\n        ('Flags','<H=0'),\n        ('Offset_Length','<L=0'),\n    )",
  "class SMB2_COMPRESSION_PAYLOAD_HEADER(Structure):\n    structure = (\n        ('AlgorithmId','<H=0'),\n        ('Reserved','<H=0'),\n        ('Length','<L=0'),\n    )",
  "class SMB2_COMPRESSION_PATTERN_PAYLOAD_V1(Structure):\n    structure = (\n        ('Pattern','B=0'),\n        ('Reserved1','B=0'),\n        ('Reserved2','B=0'),\n        ('Repetitions','<L=0'),\n    )",
  "class FileSecInformation(Structure):\n    structure = (\n        ('Revision','<h=1'),\n        ('Type','<h=0'),\n        ('OffsetToOwner','<I=0'),\n        ('OffsetToGroup','<I=0'),\n        ('OffsetToSACL','<I=0'),\n        ('OffsetToDACL','<I=0'),\n    )",
  "def addCommand(self,command):\n        # Pad to 8 bytes and put the offset of another SMBPacket\n        raise Exception('Implement This!')",
  "def isValidAnswer(self, status):\n        if self['Status'] != status:\n            from . import smb3\n            raise smb3.SessionError(self['Status'], self)\n        return True",
  "def __init__(self, data = None):\n        Structure.__init__(self,data)\n        if data is None:\n            self['TreeID'] = 0",
  "def __init__(self, data = None):\n        Structure.__init__(self,data)\n        if data is None:\n            self['AlignPad'] = ''",
  "def getData(self):\n        #self['AlignPad'] = '\\x00' * ((8 - ((24 + SMB2_PACKET_SIZE) & 7)) & 7)\n        #self['SecurityBufferOffset'] = 24 + SMB2_PACKET_SIZE +len(self['AlignPad'])\n        #self['SecurityBufferLength'] += len(self['AlignPad'])\n        return Structure.getData(self)",
  "def __init__(self, data = None):\n        Structure.__init__(self,data)\n        if data is None:\n            self['AlignPad'] = ''",
  "def __init__(self, data = None):\n        Structure.__init__(self,data)\n        if data is None:\n            self['AlignPad'] = ''",
  "def __init__(self, data = None):\n        Structure.__init__(self,data)\n        if data is None:\n            self['AlignPad'] = ''",
  "def __init__(self, data = None):\n        Structure.__init__(self,data)\n        if data is None:\n            self['AlignPad'] = ''",
  "def __init__(self, data = None):\n        Structure.__init__(self,data)\n        if data is None:\n            self['AlignPad'] = ''",
  "def __init__(self, data = None):\n        Structure.__init__(self,data)\n        if data is None:\n            self['AlignPad'] = ''",
  "def __init__(self, data = None):\n        Structure.__init__(self,data)\n        if data is None:\n            self['AlignPad'] = ''",
  "def __init__(self, data = None):\n        Structure.__init__(self,data)\n        if data is None:\n            self['AlignPad'] = ''",
  "class RC4():\n    def __init__(self, key):\n        bkey = bytearray(key)\n        j = 0\n        self.state = bytearray(range(256))\n        for i in range(256):\n            j = (j + self.state[i] + bkey[i % len(key)]) & 0xff\n            self.state[i],self.state[j] = self.state[j],self.state[i] # SSWAP(i,j)\n\n    def encrypt(self, data):\n        i = j = 0\n        out=bytearray()\n        for char in bytearray(data):\n            i = (i+1) & 0xff\n            j = (j+self.state[i]) & 0xff\n            self.state[i],self.state[j] = self.state[j],self.state[i] # SSWAP(i,j)\n            out.append(char ^ self.state[(self.state[i] + self.state[j]) & 0xff])\n        \n        return bytes(out)\n    \n    def decrypt(self, data):\n        # It's symmetric\n        return self.encrypt(data)",
  "def __init__(self, key):\n        bkey = bytearray(key)\n        j = 0\n        self.state = bytearray(range(256))\n        for i in range(256):\n            j = (j + self.state[i] + bkey[i % len(key)]) & 0xff\n            self.state[i],self.state[j] = self.state[j],self.state[i]",
  "def encrypt(self, data):\n        i = j = 0\n        out=bytearray()\n        for char in bytearray(data):\n            i = (i+1) & 0xff\n            j = (j+self.state[i]) & 0xff\n            self.state[i],self.state[j] = self.state[j],self.state[i] # SSWAP(i,j)\n            out.append(char ^ self.state[(self.state[i] + self.state[j]) & 0xff])\n        \n        return bytes(out)",
  "def decrypt(self, data):\n        # It's symmetric\n        return self.encrypt(data)",
  "class MQTT_Packet(Structure):\n    commonHdr= (\n        ('PacketType','B=0'),\n        ('MessageLength','<L=0'),\n    )\n    structure = (\n        ('_VariablePart', '_-VariablePart', 'self[\"MessageLength\"]'),\n        ('VariablePart', ':'),\n    )\n    def setQoS(self, QoS):\n        self['PacketType'] |= (QoS << 1)\n\n    def fromString(self, data):\n        if data is not None and len(data) > 2:\n            # Get the Length\n            index = 1\n            multiplier = 1\n            value = 0\n            encodedByte = 128\n            packetType = data[0]\n            while (encodedByte & 128) != 0:\n                encodedByte = ord(data[index])\n                value += (encodedByte & 127) * multiplier\n                multiplier *= 128\n                index += 1\n                if multiplier > 128 * 128 * 128:\n                    raise Exception('Malformed Remaining Length')\n            data = packetType + struct.pack('<L', value) + data[index:value+index]\n            return Structure.fromString(self, data)\n        raise Exception('Dont know')\n\n    def getData(self):\n        packetType = self['PacketType']\n        self.commonHdr = ()\n        packetLen = len(Structure.getData(self))\n        output = ''\n        while packetLen > 0:\n            encodedByte = packetLen % 128\n            packetLen /= 128\n            if packetLen > 0:\n                encodedByte |= 128\n            output += chr(encodedByte)\n        self.commonHdr = ( ('PacketType','B=0'), ('MessageLength',':'), )\n        self['PacketType'] = packetType\n        self['MessageLength'] = output\n        if output == '':\n            self['MessageLength'] = chr(00)\n\n        return Structure.getData(self)",
  "class MQTT_String(Structure):\n    structure = (\n        ('Length','>H-Name'),\n        ('Name',':'),\n    )",
  "class MQTT_Connect(MQTT_Packet):\n    structure = (\n        ('ProtocolName',':', MQTT_String),\n        ('Version','B=3'),\n        ('Flags','B=2'),\n        ('KeepAlive','>H=60'),\n        ('ClientID',':', MQTT_String),\n        ('Payload',':=\"\"'),\n    )\n    def __init__(self, data = None, alignment = 0):\n        MQTT_Packet.__init__(self, data, alignment)\n        if data is None:\n            self['PacketType'] = PACKET_CONNECT",
  "class MQTT_ConnectAck(MQTT_Packet):\n    structure = (\n        ('ReturnCode', '>H=0'),\n    )",
  "class MQTT_Publish(MQTT_Packet):\n    structure = (\n        ('Topic',':', MQTT_String),\n        ('Message',':'),\n    )\n    def __init__(self, data = None, alignment = 0):\n        MQTT_Packet.__init__(self, data, alignment)\n        if data is None:\n            self['PacketType'] = PACKET_PUBLISH\n\n    def getData(self):\n        if self['PacketType'] & 6 > 0:\n            # We have QoS enabled, we need to have a MessageID field\n            self.structure = (\n                ('Topic', ':', MQTT_String),\n                ('MessageID', '>H=0'),\n                ('Message', ':'),\n            )\n        return MQTT_Packet.getData(self)",
  "class MQTT_Disconnect(MQTT_Packet):\n    structure = (\n    )\n    def __init__(self, data=None, alignment=0):\n        MQTT_Packet.__init__(self, data, alignment)\n        if data is None:\n            self['PacketType'] = PACKET_DISCONNECT",
  "class MQTT_Subscribe(MQTT_Packet):\n    structure = (\n        ('MessageID','>H=1'),\n        ('Topic',':', MQTT_String),\n        ('Flags','B=0'),\n    )\n    def __init__(self, data = None, alignment = 0):\n        MQTT_Packet.__init__(self, data, alignment)\n        if data is None:\n            self['PacketType'] = PACKET_SUBSCRIBE",
  "class MQTT_SubscribeACK(MQTT_Packet):\n    structure = (\n        ('MessageID','>H=0'),\n        ('ReturnCode','B=0'),\n    )\n    def __init__(self, data = None, alignment = 0):\n        MQTT_Packet.__init__(self, data, alignment)\n        if data is None:\n            self['PacketType'] = PACKET_SUBSCRIBEACK",
  "class MQTT_UnSubscribe(MQTT_Packet):\n    structure = (\n        ('MessageID','>H=1'),\n        ('Topics',':'),\n    )\n    def __init__(self, data = None, alignment = 0):\n        MQTT_Packet.__init__(self, data, alignment)\n        if data is None:\n            self['PacketType'] = PACKET_UNSUBSCRIBE",
  "class MQTTSessionError(Exception):\n    \"\"\"\n    This is the exception every client should catch\n    \"\"\"\n\n    def __init__(self, error=0, packet=0, errorString=''):\n        Exception.__init__(self)\n        self.error = error\n        self.packet = packet\n        self.errorString = errorString\n\n    def getErrorCode(self):\n        return self.error\n\n    def getErrorPacket(self):\n        return self.packet\n\n    def getErrorString(self):\n        return self.errorString\n\n    def __str__(self):\n        return self.errorString",
  "class MQTTConnection:\n    def __init__(self, host, port, isSSL=False):\n        self._targetHost = host\n        self._targetPort = port\n        self._isSSL = isSSL\n        self._socket = None\n        self._messageId = 1\n        self.connectSocket()\n\n    def getSocket(self):\n        return self._socket\n\n    def connectSocket(self):\n        s = socket.socket()\n        s.connect((self._targetHost, int(self._targetPort)))\n\n        if self._isSSL is True:\n            ctx = SSL.Context(SSL.TLS_METHOD)\n            ctx.set_cipher_list('ALL:@SECLEVEL=0'.encode('utf-8'))\n            self._socket = SSL.Connection(ctx, s)\n            self._socket.set_connect_state()\n            self._socket.do_handshake()\n        else:\n            self._socket = s\n\n    def send(self, request):\n        return self._socket.sendall(str(request))\n\n    def sendReceive(self, request):\n        self.send(request)\n        return self.recv()\n\n    def recv(self):\n        REQUEST_SIZE = 8192\n        data = ''\n        done = False\n        while not done:\n            recvData = self._socket.recv(REQUEST_SIZE)\n            if len(recvData) < REQUEST_SIZE:\n                done = True\n            data += recvData\n\n        response = []\n        while len(data) > 0:\n            try:\n                message = MQTT_Packet(data)\n                remaining = data[len(message):]\n            except Exception:\n                # We need more data\n                remaining = data + self._socket.recv(REQUEST_SIZE)\n            else:\n               response.append(message)\n            data = remaining\n\n        self._messageId += 1\n        return response\n\n    def connect(self, clientId = ' ', username = None, password = None, protocolName = 'MQIsdp', version = 3, flags = CONNECT_CLEAN_SESSION, keepAlive = 60):\n        \"\"\"\n\n        :param clientId: Whatever cliend Id that represents you\n        :param username: if None, anonymous connection will be attempted\n        :param password: if None, anonymous connection will be attempted\n        :param protocolName: specification states default should be 'MQTT' but some brokers might expect 'MQIsdp'\n        :param version: Allowed versions are 3 or 4 (some brokers might like 4)\n        :param flags:\n        :param keepAlive: default 60\n        :return: True or MQTTSessionError if something went wrong\n        \"\"\"\n\n        # Let's build the packet\n        connectPacket = MQTT_Connect()\n        connectPacket['Version'] = version\n        connectPacket['Flags'] = flags\n        connectPacket['KeepAlive'] = keepAlive\n        connectPacket['ProtocolName'] = MQTT_String()\n        connectPacket['ProtocolName']['Name'] = protocolName\n\n        connectPacket['ClientID'] = MQTT_String()\n        connectPacket['ClientID']['Name'] = clientId\n\n        if username is not None:\n            connectPacket['Flags'] |= CONNECT_USERNAME | CONNECT_PASSWORD\n        if username is None:\n            user = ''\n        else:\n            user = username\n        if password is None:\n            pwd = ''\n        else:\n            pwd = password\n\n        username = MQTT_String()\n        username['Name'] = user\n        password = MQTT_String()\n        password['Name'] = pwd\n        connectPacket['Payload'] = str(username) + str(password)\n\n        data= self.sendReceive(connectPacket)[0]\n\n        response = MQTT_ConnectAck(str(data))\n        if response['ReturnCode'] != 0:\n            raise MQTTSessionError(error = response['ReturnCode'], errorString = CONNECT_ACK_ERROR_MSGS[response['ReturnCode']] )\n\n        return True\n\n    def subscribe(self, topic, messageID = 1, flags = 0, QoS = 1):\n        \"\"\"\n\n        :param topic: Topic name you want to subscribe to\n        :param messageID: optional messageId\n        :param flags: Message flags\n        :param QoS: define the QoS requested\n        :return: True or MQTTSessionError if something went wrong\n        \"\"\"\n        subscribePacket = MQTT_Subscribe()\n        subscribePacket['MessageID'] = messageID\n        subscribePacket['Topic'] = MQTT_String()\n        subscribePacket['Topic']['Name'] = topic\n        subscribePacket['Flags'] = flags\n        subscribePacket.setQoS(QoS)\n\n        try:\n            data = self.sendReceive(subscribePacket)[0]\n        except Exception as e:\n            raise MQTTSessionError(errorString=str(e))\n\n        subAck = MQTT_SubscribeACK(str(data))\n\n        if subAck['ReturnCode'] > 2:\n            raise MQTTSessionError(errorString = 'Failure to subscribe')\n\n        return True\n\n    def unSubscribe(self, topic, messageID = 1, QoS = 0):\n        \"\"\"\n        Unsubscribes from a topic\n\n        :param topic:\n        :param messageID:\n        :param QoS: define the QoS requested\n        :return:\n        \"\"\"\n        # ToDo: Support more than one topic\n        packet = MQTT_UnSubscribe()\n        packet['MessageID'] = messageID\n        packet['Topics'] = MQTT_String()\n        packet['Topics']['Name'] = topic\n        packet.setQoS( QoS )\n\n        return self.sendReceive(packet)\n\n    def publish(self, topic, message, messageID = 1, QoS=0):\n\n        packet = MQTT_Publish()\n        packet['Topic'] = MQTT_String()\n        packet['Topic']['Name'] = topic\n        packet['Message'] = message\n        packet['MessageID'] = messageID\n        packet.setQoS( QoS )\n\n        return self.sendReceive(packet)\n\n    def disconnect(self):\n        return self.send(str(MQTT_Disconnect()))",
  "def setQoS(self, QoS):\n        self['PacketType'] |= (QoS << 1)",
  "def fromString(self, data):\n        if data is not None and len(data) > 2:\n            # Get the Length\n            index = 1\n            multiplier = 1\n            value = 0\n            encodedByte = 128\n            packetType = data[0]\n            while (encodedByte & 128) != 0:\n                encodedByte = ord(data[index])\n                value += (encodedByte & 127) * multiplier\n                multiplier *= 128\n                index += 1\n                if multiplier > 128 * 128 * 128:\n                    raise Exception('Malformed Remaining Length')\n            data = packetType + struct.pack('<L', value) + data[index:value+index]\n            return Structure.fromString(self, data)\n        raise Exception('Dont know')",
  "def getData(self):\n        packetType = self['PacketType']\n        self.commonHdr = ()\n        packetLen = len(Structure.getData(self))\n        output = ''\n        while packetLen > 0:\n            encodedByte = packetLen % 128\n            packetLen /= 128\n            if packetLen > 0:\n                encodedByte |= 128\n            output += chr(encodedByte)\n        self.commonHdr = ( ('PacketType','B=0'), ('MessageLength',':'), )\n        self['PacketType'] = packetType\n        self['MessageLength'] = output\n        if output == '':\n            self['MessageLength'] = chr(00)\n\n        return Structure.getData(self)",
  "def __init__(self, data = None, alignment = 0):\n        MQTT_Packet.__init__(self, data, alignment)\n        if data is None:\n            self['PacketType'] = PACKET_CONNECT",
  "def __init__(self, data = None, alignment = 0):\n        MQTT_Packet.__init__(self, data, alignment)\n        if data is None:\n            self['PacketType'] = PACKET_PUBLISH",
  "def getData(self):\n        if self['PacketType'] & 6 > 0:\n            # We have QoS enabled, we need to have a MessageID field\n            self.structure = (\n                ('Topic', ':', MQTT_String),\n                ('MessageID', '>H=0'),\n                ('Message', ':'),\n            )\n        return MQTT_Packet.getData(self)",
  "def __init__(self, data=None, alignment=0):\n        MQTT_Packet.__init__(self, data, alignment)\n        if data is None:\n            self['PacketType'] = PACKET_DISCONNECT",
  "def __init__(self, data = None, alignment = 0):\n        MQTT_Packet.__init__(self, data, alignment)\n        if data is None:\n            self['PacketType'] = PACKET_SUBSCRIBE",
  "def __init__(self, data = None, alignment = 0):\n        MQTT_Packet.__init__(self, data, alignment)\n        if data is None:\n            self['PacketType'] = PACKET_SUBSCRIBEACK",
  "def __init__(self, data = None, alignment = 0):\n        MQTT_Packet.__init__(self, data, alignment)\n        if data is None:\n            self['PacketType'] = PACKET_UNSUBSCRIBE",
  "def __init__(self, error=0, packet=0, errorString=''):\n        Exception.__init__(self)\n        self.error = error\n        self.packet = packet\n        self.errorString = errorString",
  "def getErrorCode(self):\n        return self.error",
  "def getErrorPacket(self):\n        return self.packet",
  "def getErrorString(self):\n        return self.errorString",
  "def __str__(self):\n        return self.errorString",
  "def __init__(self, host, port, isSSL=False):\n        self._targetHost = host\n        self._targetPort = port\n        self._isSSL = isSSL\n        self._socket = None\n        self._messageId = 1\n        self.connectSocket()",
  "def getSocket(self):\n        return self._socket",
  "def connectSocket(self):\n        s = socket.socket()\n        s.connect((self._targetHost, int(self._targetPort)))\n\n        if self._isSSL is True:\n            ctx = SSL.Context(SSL.TLS_METHOD)\n            ctx.set_cipher_list('ALL:@SECLEVEL=0'.encode('utf-8'))\n            self._socket = SSL.Connection(ctx, s)\n            self._socket.set_connect_state()\n            self._socket.do_handshake()\n        else:\n            self._socket = s",
  "def send(self, request):\n        return self._socket.sendall(str(request))",
  "def sendReceive(self, request):\n        self.send(request)\n        return self.recv()",
  "def recv(self):\n        REQUEST_SIZE = 8192\n        data = ''\n        done = False\n        while not done:\n            recvData = self._socket.recv(REQUEST_SIZE)\n            if len(recvData) < REQUEST_SIZE:\n                done = True\n            data += recvData\n\n        response = []\n        while len(data) > 0:\n            try:\n                message = MQTT_Packet(data)\n                remaining = data[len(message):]\n            except Exception:\n                # We need more data\n                remaining = data + self._socket.recv(REQUEST_SIZE)\n            else:\n               response.append(message)\n            data = remaining\n\n        self._messageId += 1\n        return response",
  "def connect(self, clientId = ' ', username = None, password = None, protocolName = 'MQIsdp', version = 3, flags = CONNECT_CLEAN_SESSION, keepAlive = 60):\n        \"\"\"\n\n        :param clientId: Whatever cliend Id that represents you\n        :param username: if None, anonymous connection will be attempted\n        :param password: if None, anonymous connection will be attempted\n        :param protocolName: specification states default should be 'MQTT' but some brokers might expect 'MQIsdp'\n        :param version: Allowed versions are 3 or 4 (some brokers might like 4)\n        :param flags:\n        :param keepAlive: default 60\n        :return: True or MQTTSessionError if something went wrong\n        \"\"\"\n\n        # Let's build the packet\n        connectPacket = MQTT_Connect()\n        connectPacket['Version'] = version\n        connectPacket['Flags'] = flags\n        connectPacket['KeepAlive'] = keepAlive\n        connectPacket['ProtocolName'] = MQTT_String()\n        connectPacket['ProtocolName']['Name'] = protocolName\n\n        connectPacket['ClientID'] = MQTT_String()\n        connectPacket['ClientID']['Name'] = clientId\n\n        if username is not None:\n            connectPacket['Flags'] |= CONNECT_USERNAME | CONNECT_PASSWORD\n        if username is None:\n            user = ''\n        else:\n            user = username\n        if password is None:\n            pwd = ''\n        else:\n            pwd = password\n\n        username = MQTT_String()\n        username['Name'] = user\n        password = MQTT_String()\n        password['Name'] = pwd\n        connectPacket['Payload'] = str(username) + str(password)\n\n        data= self.sendReceive(connectPacket)[0]\n\n        response = MQTT_ConnectAck(str(data))\n        if response['ReturnCode'] != 0:\n            raise MQTTSessionError(error = response['ReturnCode'], errorString = CONNECT_ACK_ERROR_MSGS[response['ReturnCode']] )\n\n        return True",
  "def subscribe(self, topic, messageID = 1, flags = 0, QoS = 1):\n        \"\"\"\n\n        :param topic: Topic name you want to subscribe to\n        :param messageID: optional messageId\n        :param flags: Message flags\n        :param QoS: define the QoS requested\n        :return: True or MQTTSessionError if something went wrong\n        \"\"\"\n        subscribePacket = MQTT_Subscribe()\n        subscribePacket['MessageID'] = messageID\n        subscribePacket['Topic'] = MQTT_String()\n        subscribePacket['Topic']['Name'] = topic\n        subscribePacket['Flags'] = flags\n        subscribePacket.setQoS(QoS)\n\n        try:\n            data = self.sendReceive(subscribePacket)[0]\n        except Exception as e:\n            raise MQTTSessionError(errorString=str(e))\n\n        subAck = MQTT_SubscribeACK(str(data))\n\n        if subAck['ReturnCode'] > 2:\n            raise MQTTSessionError(errorString = 'Failure to subscribe')\n\n        return True",
  "def unSubscribe(self, topic, messageID = 1, QoS = 0):\n        \"\"\"\n        Unsubscribes from a topic\n\n        :param topic:\n        :param messageID:\n        :param QoS: define the QoS requested\n        :return:\n        \"\"\"\n        # ToDo: Support more than one topic\n        packet = MQTT_UnSubscribe()\n        packet['MessageID'] = messageID\n        packet['Topics'] = MQTT_String()\n        packet['Topics']['Name'] = topic\n        packet.setQoS( QoS )\n\n        return self.sendReceive(packet)",
  "def publish(self, topic, message, messageID = 1, QoS=0):\n\n        packet = MQTT_Publish()\n        packet['Topic'] = MQTT_String()\n        packet['Topic']['Name'] = topic\n        packet['Message'] = message\n        packet['MessageID'] = messageID\n        packet.setQoS( QoS )\n\n        return self.sendReceive(packet)",
  "def disconnect(self):\n        return self.send(str(MQTT_Disconnect()))",
  "class EAPExpanded(ProtocolPacket):\n    \"\"\"EAP expanded data according to RFC 3748, section 5.7\"\"\"\n    \n    WFA_SMI = 0x00372a\n    SIMPLE_CONFIG = 0x00000001\n\n    header_size = 7\n    tail_size = 0\n    \n    vendor_id = ThreeBytesBigEndian(0)\n    vendor_type = Long(3, \">\")",
  "class EAPR(ProtocolPacket):\n    \"\"\"It represents a request or a response in EAP (codes 1 and 2)\"\"\"\n    \n    IDENTITY = 0x01\n    EXPANDED = 0xfe\n\n    header_size = 1\n    tail_size = 0\n    \n    type = Byte(0)",
  "class EAP(ProtocolPacket):\n    REQUEST = 0x01\n    RESPONSE = 0x02\n    SUCCESS = 0x03\n    FAILURE = 0x04 \n\n    header_size = 4\n    tail_size = 0\n\n    code = Byte(0)\n    identifier = Byte(1)\n    length = Word(2, \">\")",
  "class EAPOL(ProtocolPacket):\n    EAP_PACKET = 0x00\n    EAPOL_START = 0x01\n    EAPOL_LOGOFF = 0x02\n    EAPOL_KEY = 0x03\n    EAPOL_ENCAPSULATED_ASF_ALERT = 0x04\n    \n    DOT1X_VERSION = 0x01\n\n    header_size = 4\n    tail_size = 0\n    \n    version = Byte(0)\n    packet_type = Byte(1)\n    body_length = Word(2, \">\")",
  "class DummyPrint:        \n    def logMessage(self,message):\n        if message == '\\n':\n            print(message)\n        elif message == '\\r':\n            print()\n        else:\n            print(message, end=' ')",
  "class SQLR(Structure):\n    commonHdr = (\n        ('OpCode','B'),\n    )",
  "class SQLR_UCAST_INST(SQLR):\n    structure = (\n        ('Instance',':')\n    )\n    def __init__(self, data = None):\n        SQLR.__init__(self,data)\n        if data is not None:\n            self['OpCode'] = SQLR_CLNT_UCAST_INST",
  "class SQLR_UCAST_DAC(SQLR):\n    structure = (\n        ('Protocol', 'B=1'),\n        ('Instance', ':'),\n    )\n    def __init__(self, data = None):\n        SQLR.__init__(self,data)\n        if data is not None:\n            self['OpCode'] = SQLR_CLNT_UCAST_DAC",
  "class SQLR_Response(SQLR):\n    structure = (\n        ('Size','<H'),\n        ('_Data','_-Data','self[\"Size\"]'),\n        ('Data',':'),\n    )",
  "class SQLErrorException(Exception):\n    pass",
  "class TDSPacket(Structure):\n    structure = (\n        ('Type','<B'),\n        ('Status','<B=1'),\n        ('Length','>H=8+len(Data)'),\n        ('SPID','>H=0'),\n        ('PacketID','<B=0'),\n        ('Window','<B=0'),\n        ('Data',':'),\n    )",
  "class TDS_PRELOGIN(Structure):\n    structure = (\n        ('VersionToken','>B=0'),\n        ('VersionOffset','>H'),\n        ('VersionLength','>H=len(self[\"Version\"])'),\n        ('EncryptionToken','>B=0x1'),\n        ('EncryptionOffset','>H'),\n        ('EncryptionLength','>H=1'),\n        ('InstanceToken','>B=2'),\n        ('InstanceOffset','>H'),\n        ('InstanceLength','>H=len(self[\"Instance\"])'),\n        ('ThreadIDToken','>B=3'),\n        ('ThreadIDOffset','>H'),\n        ('ThreadIDLength','>H=4'),\n        ('EndToken','>B=0xff'),\n        ('_Version','_-Version','self[\"VersionLength\"]'),\n        ('Version',':'),\n        ('Encryption','B'),\n        ('_Instance','_-Instance','self[\"InstanceLength\"]-1'),\n        ('Instance',':'),\n        ('ThreadID',':'),\n    )\n\n    def getData(self):\n        self['VersionOffset']=21\n        self['EncryptionOffset']=self['VersionOffset'] + len(self['Version'])\n        self['InstanceOffset']=self['EncryptionOffset'] + 1\n        self['ThreadIDOffset']=self['InstanceOffset'] + len(self['Instance'])\n        return Structure.getData(self)",
  "class TDS_LOGIN(Structure):\n    structure = (\n        ('Length','<L=0'),\n        ('TDSVersion','>L=0x71'),\n        ('PacketSize','<L=32764'),\n        ('ClientProgVer','>L=7'),\n        ('ClientPID','<L=0'),\n        ('ConnectionID','<L=0'),\n        ('OptionFlags1','<B=0xe0'),\n        ('OptionFlags2','<B'),\n        ('TypeFlags','<B=0'),\n        ('OptionFlags3','<B=0'),\n        ('ClientTimeZone','<L=0'),\n        ('ClientLCID','<L=0'),\n        ('HostNameOffset','<H'),\n        ('HostNameLength','<H=len(self[\"HostName\"])//2'),\n        ('UserNameOffset','<H=0'),\n        ('UserNameLength','<H=len(self[\"UserName\"])//2'),\n        ('PasswordOffset','<H=0'),\n        ('PasswordLength','<H=len(self[\"Password\"])//2'),\n        ('AppNameOffset','<H'),\n        ('AppNameLength','<H=len(self[\"AppName\"])//2'),\n        ('ServerNameOffset','<H'),\n        ('ServerNameLength','<H=len(self[\"ServerName\"])//2'),\n        ('UnusedOffset','<H=0'),\n        ('UnusedLength','<H=0'),\n        ('CltIntNameOffset','<H'),\n        ('CltIntNameLength','<H=len(self[\"CltIntName\"])//2'),\n        ('LanguageOffset','<H=0'),\n        ('LanguageLength','<H=0'),\n        ('DatabaseOffset','<H=0'),\n        ('DatabaseLength','<H=len(self[\"Database\"])//2'),\n        ('ClientID','6s=b\"\\x01\\x02\\x03\\x04\\x05\\x06\"'),\n        ('SSPIOffset','<H'),\n        ('SSPILength','<H=len(self[\"SSPI\"])'),\n        ('AtchDBFileOffset','<H'),\n        ('AtchDBFileLength','<H=len(self[\"AtchDBFile\"])//2'),\n        ('HostName',':'),\n        ('UserName',':'),\n        ('Password',':'),\n        ('AppName',':'),\n        ('ServerName',':'),\n        ('CltIntName',':'),\n        ('Database',':'),\n        ('SSPI',':'),\n        ('AtchDBFile',':'),\n    )\n    def __init__(self,data=None):\n        Structure.__init__(self,data)\n        if data is None:\n            self['UserName'] = ''\n            self['Password'] = ''\n            self['Database'] = ''\n            self['AtchDBFile'] = ''\n\n    def fromString(self, data):\n        Structure.fromString(self, data)\n        if self['HostNameLength'] > 0:\n            self['HostName'] = data[self['HostNameOffset']:][:self['HostNameLength']*2]\n\n        if self['UserNameLength'] > 0:\n            self['UserName'] = data[self['UserNameOffset']:][:self['UserNameLength']*2]\n\n        if self['PasswordLength'] > 0:\n            self['Password'] = data[self['PasswordOffset']:][:self['PasswordLength']*2]\n\n        if self['AppNameLength'] > 0:\n            self['AppName'] = data[self['AppNameOffset']:][:self['AppNameLength']*2]\n\n        if self['ServerNameLength'] > 0:\n            self['ServerName'] = data[self['ServerNameOffset']:][:self['ServerNameLength']*2]\n\n        if self['CltIntNameLength'] > 0:\n            self['CltIntName'] = data[self['CltIntNameOffset']:][:self['CltIntNameLength']*2]\n\n        if self['DatabaseLength'] > 0:\n            self['Database'] = data[self['DatabaseOffset']:][:self['DatabaseLength']*2]\n\n        if self['SSPILength'] > 0:\n            self['SSPI'] = data[self['SSPIOffset']:][:self['SSPILength']*2]\n\n        if self['AtchDBFileLength'] > 0:\n            self['AtchDBFile'] = data[self['AtchDBFileOffset']:][:self['AtchDBFileLength']*2]\n\n    def getData(self):\n        index = 36+50\n        self['HostNameOffset']= index\n\n        index += len(self['HostName'])\n\n        if self['UserName'] != '':\n            self['UserNameOffset'] = index\n        else:\n            self['UserNameOffset'] = 0\n\n        index += len(self['UserName'])\n\n        if self['Password'] != '':\n            self['PasswordOffset'] = index\n        else:\n            self['PasswordOffset'] = 0\n\n        index += len(self['Password'])\n\n        self['AppNameOffset']= index\n        self['ServerNameOffset']=self['AppNameOffset'] + len(self['AppName'])\n        self['CltIntNameOffset']=self['ServerNameOffset'] + len(self['ServerName'])\n        self['LanguageOffset']=self['CltIntNameOffset'] + len(self['CltIntName'])\n        self['DatabaseOffset']=self['LanguageOffset'] \n        self['SSPIOffset']=self['DatabaseOffset'] + len(self['Database'])\n        self['AtchDBFileOffset']=self['SSPIOffset'] + len(self['SSPI'])\n        return Structure.getData(self)",
  "class TDS_LOGIN_ACK(Structure):\n    structure = (\n        ('TokenType','<B'),\n        ('Length','<H'),\n        ('Interface','<B'),\n        ('TDSVersion','<L'),\n        ('ProgNameLen','<B'),\n        ('_ProgNameLen','_-ProgName','self[\"ProgNameLen\"]*2'),\n        ('ProgName',':'),\n        ('MajorVer','<B'),\n        ('MinorVer','<B'),\n        ('BuildNumHi','<B'),\n        ('BuildNumLow','<B'),\n    )",
  "class TDS_RETURNSTATUS(Structure):\n    structure = (\n        ('TokenType','<B'),\n        ('Value','<L'),\n    )",
  "class TDS_INFO_ERROR(Structure):\n    structure = (\n        ('TokenType','<B'),\n        ('Length','<H'),\n        ('Number','<L'),\n        ('State','<B'),\n        ('Class','<B'),\n        ('MsgTextLen','<H'),\n        ('_MsgTextLen','_-MsgText','self[\"MsgTextLen\"]*2'),\n        ('MsgText',':'),\n        ('ServerNameLen','<B'),\n        ('_ServerNameLen','_-ServerName','self[\"ServerNameLen\"]*2'),\n        ('ServerName',':'),\n        ('ProcNameLen','<B'),\n        ('_ProcNameLen','_-ProcName','self[\"ProcNameLen\"]*2'),\n        ('ProcName',':'),\n        ('LineNumber','<H'),\n    )",
  "class TDS_ENVCHANGE(Structure):\n    structure = (\n        ('TokenType','<B'),\n        ('Length','<H=4+len(Data)'),\n        ('Type','<B'),\n        ('_Data','_-Data','self[\"Length\"]-1'),\n        ('Data',':'),\n    )",
  "class TDS_DONEINPROC(Structure):\n    structure = (\n        ('TokenType','<B'),\n        ('Status','<H'),\n        ('CurCmd','<H'),\n        ('DoneRowCount','<L'),\n    )",
  "class TDS_ORDER(Structure):\n    structure = (\n        ('TokenType','<B'),\n        ('Length','<H'),\n        ('_Data','_-Data','self[\"Length\"]'),\n        ('Data',':'),\n    )",
  "class TDS_ENVCHANGE_VARCHAR(Structure):\n    structure = (\n        ('NewValueLen','<B=len(NewValue)'),\n        ('_NewValue','_-NewValue','self[\"NewValueLen\"]*2'),\n        ('NewValue',':'),\n        ('OldValueLen','<B=len(OldValue)'),\n        ('_OldValue','_-OldValue','self[\"OldValueLen\"]*2'),\n        ('OldValue',':'),\n    )",
  "class TDS_ROW(Structure):\n    structure = (\n        ('TokenType','<B'),\n        ('Data',':'),\n    )",
  "class TDS_DONE(Structure):\n    structure = (\n        ('TokenType','<B'),\n        ('Status','<H'),\n        ('CurCmd','<H'),\n        ('DoneRowCount','<L'),\n    )",
  "class TDS_COLMETADATA(Structure):\n    structure = (\n        ('TokenType','<B'),\n        ('Count','<H'),\n        ('Data',':'),\n    )",
  "class MSSQL:\n    def __init__(self, address, port=1433, rowsPrinter=DummyPrint()):\n        #self.packetSize = 32764\n        self.packetSize = 32763\n        self.server = address\n        self.port = port\n        self.socket = 0\n        self.replies = {}\n        self.colMeta = []\n        self.rows = []\n        self.currentDB = ''\n        self.COL_SEPARATOR = '  '\n        self.MAX_COL_LEN = 255\n        self.lastError = False\n        self.tlsSocket = None\n        self.__rowsPrinter = rowsPrinter\n\n    def getInstances(self, timeout = 5):\n        packet = SQLR()\n        packet['OpCode'] = SQLR_CLNT_UCAST_EX\n\n        # Open the connection\n        af, socktype, proto, canonname, sa = socket.getaddrinfo(self.server, SQLR_PORT, 0, socket.SOCK_DGRAM)[0]\n        s = socket.socket(af, socktype, proto)\n\n        s.sendto(packet.getData(), 0, ( self.server, SQLR_PORT ))\n        ready, _, _ = select.select([ s.fileno() ], [ ] , [ ], timeout)\n        if not ready:\n            return []\n        else:\n            data, _ = s.recvfrom(65536, 0)\n   \n        s.close()\n        resp = SQLR_Response(data)\n\n        # Now parse the results\n        entries = resp['Data'].split(b';;')\n\n        # We don't want the last one, it's empty\n        entries.pop()\n \n        # the answer to send back\n        resp = []\n\n        for i, entry in enumerate(entries):\n            fields = entry.split(b';')\n            ret = {}\n            for j, field in enumerate(fields):\n                if (j & 0x1) == 0:\n                    ret[field.decode('utf-8')] = fields[j+1].decode('utf-8')\n            resp.append(ret)\n\n        return resp\n        \n\n    def preLogin(self):\n        prelogin = TDS_PRELOGIN()\n        prelogin['Version'] = b\"\\x08\\x00\\x01\\x55\\x00\\x00\"\n        #prelogin['Encryption'] = TDS_ENCRYPT_NOT_SUP\n        prelogin['Encryption'] = TDS_ENCRYPT_OFF\n        prelogin['ThreadID'] = struct.pack('<L',random.randint(0,65535))\n        prelogin['Instance'] = b'MSSQLServer\\x00'\n\n        self.sendTDS(TDS_PRE_LOGIN, prelogin.getData(), 0)\n        tds = self.recvTDS()\n\n        return TDS_PRELOGIN(tds['Data'])\n    \n    def encryptPassword(self, password ):\n        return bytes(bytearray([((x & 0x0f) << 4) + ((x & 0xf0) >> 4) ^ 0xa5 for x in bytearray(password)]))\n\n    def connect(self):\n        af, socktype, proto, canonname, sa = socket.getaddrinfo(self.server, self.port, 0, socket.SOCK_STREAM)[0]\n        sock = socket.socket(af, socktype, proto)\n        \n        try:\n            sock.connect(sa)\n        except Exception:\n            #import traceback\n            #traceback.print_exc()\n            raise\n        \n        self.socket = sock\n        return sock\n\n    def disconnect(self):\n        if self.socket:\n            return self.socket.close()\n\n    def setPacketSize(self, packetSize):\n        self.packetSize = packetSize\n\n    def getPacketSize(self):\n        return self.packetSize\n    \n    def socketSendall(self,data):\n        if self.tlsSocket is None:\n            return self.socket.sendall(data)\n        else:\n            self.tlsSocket.sendall(data)\n            dd = self.tlsSocket.bio_read(self.packetSize)\n            return self.socket.sendall(dd)\n\n    def sendTDS(self, packetType, data, packetID = 1):\n        if (len(data)-8) > self.packetSize:\n            remaining = data[self.packetSize-8:]\n            tds = TDSPacket()\n            tds['Type'] = packetType\n            tds['Status'] = TDS_STATUS_NORMAL\n            tds['PacketID'] = packetID\n            tds['Data'] = data[:self.packetSize-8]\n            self.socketSendall(tds.getData())\n\n            while len(remaining) > (self.packetSize-8):\n                packetID += 1\n                tds['PacketID'] = packetID\n                tds['Data'] = remaining[:self.packetSize-8]\n                self.socketSendall(tds.getData())\n                remaining = remaining[self.packetSize-8:]\n            data = remaining\n            packetID+=1\n\n        tds = TDSPacket()\n        tds['Type'] = packetType\n        tds['Status'] = TDS_STATUS_EOM\n        tds['PacketID'] = packetID\n        tds['Data'] = data\n        self.socketSendall(tds.getData())\n\n    def socketRecv(self, packetSize):\n        data = self.socket.recv(packetSize)\n        if self.tlsSocket is not None:\n            dd = b''\n            self.tlsSocket.bio_write(data)\n            while True:\n                try:\n                    dd += self.tlsSocket.read(packetSize)\n                except SSL.WantReadError:\n                    data2 = self.socket.recv(packetSize - len(data) )\n                    self.tlsSocket.bio_write(data2)\n                    pass\n                else:\n                    data = dd\n                    break\n        return data\n\n    def recvTDS(self, packetSize = None):\n        # Do reassembly here\n        if packetSize is None:\n            packetSize = self.packetSize\n        packet = TDSPacket(self.socketRecv(packetSize))\n        status = packet['Status']\n        packetLen = packet['Length']-8\n        while packetLen > len(packet['Data']):\n            data = self.socketRecv(packetSize)\n            packet['Data'] += data\n        \n        remaining = None\n        if packetLen <  len(packet['Data']):\n            remaining = packet['Data'][packetLen:]\n            packet['Data'] = packet['Data'][:packetLen]\n\n        #print \"REMAINING \", \n        #if remaining is None: \n        #   print None \n        #else: \n        #   print len(remaining)\n\n        while status != TDS_STATUS_EOM:\n            if remaining is not None:\n                tmpPacket = TDSPacket(remaining)\n            else:\n                tmpPacket = TDSPacket(self.socketRecv(packetSize))\n\n            packetLen = tmpPacket['Length'] - 8\n            while packetLen > len(tmpPacket['Data']):\n                data = self.socketRecv(packetSize)\n                tmpPacket['Data'] += data\n\n            remaining = None\n            if packetLen <  len(tmpPacket['Data']):\n                remaining = tmpPacket['Data'][packetLen:]\n                tmpPacket['Data'] = tmpPacket['Data'][:packetLen]\n\n            status = tmpPacket['Status']\n            packet['Data'] += tmpPacket['Data']\n            packet['Length'] += tmpPacket['Length'] - 8\n            \n        #print packet['Length']\n        return packet\n\n    def kerberosLogin(self, database, username, password='', domain='', hashes=None, aesKey='', kdcHost=None, TGT=None, TGS=None, useCache=True):\n\n        if hashes is not None:\n            lmhash, nthash = hashes.split(':')\n            lmhash = binascii.a2b_hex(lmhash)\n            nthash = binascii.a2b_hex(nthash)\n        else:\n            lmhash = ''\n            nthash = ''\n\n        resp = self.preLogin()\n        # Test this!\n        if resp['Encryption'] == TDS_ENCRYPT_REQ or resp['Encryption'] == TDS_ENCRYPT_OFF:\n            LOG.info(\"Encryption required, switching to TLS\")\n\n            # Switching to TLS now\n            ctx = SSL.Context(SSL.TLS_METHOD)\n            ctx.set_cipher_list('ALL:@SECLEVEL=0'.encode('utf-8'))\n            tls = SSL.Connection(ctx,None)\n            tls.set_connect_state()\n            while True:\n                try:\n                    tls.do_handshake()\n                except SSL.WantReadError:\n                    data = tls.bio_read(4096)\n                    self.sendTDS(TDS_PRE_LOGIN, data,0)\n                    tds = self.recvTDS()\n                    tls.bio_write(tds['Data'])\n                else:\n                    break\n\n            # SSL and TLS limitation: Secure Socket Layer (SSL) and its replacement,\n            # Transport Layer Security(TLS), limit data fragments to 16k in size.\n            self.packetSize = 16*1024-1\n            self.tlsSocket = tls\n\n\n        login = TDS_LOGIN()\n\n        login['HostName'] = (''.join([random.choice(string.ascii_letters) for _ in range(8)])).encode('utf-16le')\n        login['AppName']  = (''.join([random.choice(string.ascii_letters) for _ in range(8)])).encode('utf-16le')\n        login['ServerName'] = self.server.encode('utf-16le')\n        login['CltIntName']  = login['AppName']\n        login['ClientPID'] = random.randint(0,1024)\n        login['PacketSize'] = self.packetSize\n        if database is not None:\n            login['Database'] = database.encode('utf-16le')\n        login['OptionFlags2'] = TDS_INIT_LANG_FATAL | TDS_ODBC_ON\n\n        from impacket.spnego import SPNEGO_NegTokenInit, TypesMech\n        # Importing down here so pyasn1 is not required if kerberos is not used.\n        from impacket.krb5.ccache import CCache\n        from impacket.krb5.asn1 import AP_REQ, Authenticator, TGS_REP, seq_set\n        from impacket.krb5.kerberosv5 import getKerberosTGT, getKerberosTGS, KerberosError\n        from impacket.krb5 import constants\n        from impacket.krb5.types import Principal, KerberosTime, Ticket\n        from pyasn1.codec.der import decoder, encoder\n        from pyasn1.type.univ import noValue\n        import datetime\n\n        if useCache:\n            domain, username, TGT, TGS = CCache.parseFile(domain, username, 'MSSQLSvc/%s:%d' % (self.server, self.port))\n\n            if TGS is None:\n                # search for the port's instance name instead (instance name based SPN)\n                LOG.debug('Searching target\\'s instances to look for port number %s' % self.port)\n                instances = self.getInstances()\n                instanceName = None\n                for i in instances:\n                    try:\n                        if int(i['tcp']) == self.port:\n                            instanceName = i['InstanceName']\n                    except Exception as e:\n                        pass\n\n                if instanceName:\n                    domain, username, TGT, TGS = CCache.parseFile(domain, username, 'MSSQLSvc/%s.%s:%s' % (self.server.split('.')[0], domain, instanceName))\n\n        # First of all, we need to get a TGT for the user\n        userName = Principal(username, type=constants.PrincipalNameType.NT_PRINCIPAL.value)\n        while True:\n            if TGT is None:\n                if TGS is None:\n                    try:\n                        tgt, cipher, oldSessionKey, sessionKey = getKerberosTGT(userName, password, domain, lmhash, nthash, aesKey, kdcHost)\n                    except KerberosError as e:\n                        if e.getErrorCode() == constants.ErrorCodes.KDC_ERR_ETYPE_NOSUPP.value:\n                            # We might face this if the target does not support AES\n                            # So, if that's the case we'll force using RC4 by converting\n                            # the password to lm/nt hashes and hope for the best. If that's already\n                            # done, byebye.\n                            if lmhash == '' and nthash == '' and (aesKey == '' or aesKey is None) and TGT is None and TGS is None:\n                                from impacket.ntlm import compute_lmhash, compute_nthash\n                                LOG.debug('Got KDC_ERR_ETYPE_NOSUPP, fallback to RC4')\n                                lmhash = compute_lmhash(password)\n                                nthash = compute_nthash(password)\n                                continue\n                            else:\n                                raise\n                        else:\n                            raise\n            else:\n                tgt = TGT['KDC_REP']\n                cipher = TGT['cipher']\n                sessionKey = TGT['sessionKey']\n\n            if TGS is None:\n                # From https://msdn.microsoft.com/en-us/library/ms191153.aspx?f=255&MSPPError=-2147217396\n                # Beginning with SQL Server 2008, the SPN format is changed in order to support Kerberos authentication\n                # on TCP/IP, named pipes, and shared memory. The supported SPN formats for named and default instances\n                # are as follows.\n                # Named instance\n                #     MSSQLSvc/FQDN:[port | instancename], where:\n                #         MSSQLSvc is the service that is being registered.\n                #         FQDN is the fully qualified domain name of the server.\n                #         port is the TCP port number.\n                #         instancename is the name of the SQL Server instance.\n                serverName = Principal('MSSQLSvc/%s.%s:%d' % (self.server.split('.')[0], domain, self.port), type=constants.PrincipalNameType.NT_SRV_INST.value)\n                try:\n                    tgs, cipher, oldSessionKey, sessionKey = getKerberosTGS(serverName, domain, kdcHost, tgt, cipher, sessionKey)\n                except KerberosError as e:\n                    if e.getErrorCode() == constants.ErrorCodes.KDC_ERR_ETYPE_NOSUPP.value:\n                        # We might face this if the target does not support AES\n                        # So, if that's the case we'll force using RC4 by converting\n                        # the password to lm/nt hashes and hope for the best. If that's already\n                        # done, byebye.\n                        if lmhash == '' and nthash == '' and (aesKey == '' or aesKey is None) and TGT is None and TGS is None:\n                            from impacket.ntlm import compute_lmhash, compute_nthash\n                            LOG.debug('Got KDC_ERR_ETYPE_NOSUPP, fallback to RC4')\n                            lmhash = compute_lmhash(password)\n                            nthash = compute_nthash(password)\n                        else:\n                            raise\n                    else:\n                        raise\n                else:\n                    break\n            else:\n                tgs = TGS['KDC_REP']\n                cipher = TGS['cipher']\n                sessionKey = TGS['sessionKey']\n                break\n\n        # Let's build a NegTokenInit with a Kerberos REQ_AP\n\n        blob = SPNEGO_NegTokenInit()\n\n        # Kerberos\n        blob['MechTypes'] = [TypesMech['MS KRB5 - Microsoft Kerberos 5']]\n\n        # Let's extract the ticket from the TGS\n        tgs = decoder.decode(tgs, asn1Spec = TGS_REP())[0]\n        ticket = Ticket()\n        ticket.from_asn1(tgs['ticket'])\n\n        # Now let's build the AP_REQ\n        apReq = AP_REQ()\n        apReq['pvno'] = 5\n        apReq['msg-type'] = int(constants.ApplicationTagNumbers.AP_REQ.value)\n\n        opts = list()\n        apReq['ap-options'] = constants.encodeFlags(opts)\n        seq_set(apReq,'ticket', ticket.to_asn1)\n\n        authenticator = Authenticator()\n        authenticator['authenticator-vno'] = 5\n        authenticator['crealm'] = domain\n        seq_set(authenticator, 'cname', userName.components_to_asn1)\n        now = datetime.datetime.utcnow()\n\n        authenticator['cusec'] = now.microsecond\n        authenticator['ctime'] = KerberosTime.to_asn1(now)\n\n        encodedAuthenticator = encoder.encode(authenticator)\n\n        # Key Usage 11\n        # AP-REQ Authenticator (includes application authenticator\n        # subkey), encrypted with the application session key\n        # (Section 5.5.1)\n        encryptedEncodedAuthenticator = cipher.encrypt(sessionKey, 11, encodedAuthenticator, None)\n\n        apReq['authenticator'] = noValue\n        apReq['authenticator']['etype'] = cipher.enctype\n        apReq['authenticator']['cipher'] = encryptedEncodedAuthenticator\n\n        blob['MechToken'] = encoder.encode(apReq)\n\n        login['OptionFlags2'] |= TDS_INTEGRATED_SECURITY_ON\n\n        login['SSPI'] = blob.getData()\n        login['Length'] = len(login.getData())\n\n        # Send the NTLMSSP Negotiate or SQL Auth Packet\n        self.sendTDS(TDS_LOGIN7, login.getData())\n\n        # According to the specs, if encryption is not required, we must encrypt just\n        # the first Login packet :-o\n        if resp['Encryption'] == TDS_ENCRYPT_OFF:\n            self.tlsSocket = None\n\n        tds = self.recvTDS()\n\n        self.replies = self.parseReply(tds['Data'])\n\n        if TDS_LOGINACK_TOKEN in self.replies:\n            return True\n        else:\n            return False\n\n    def login(self, database, username, password='', domain='', hashes = None, useWindowsAuth = False):\n\n        if hashes is not None:\n            lmhash, nthash = hashes.split(':')\n            lmhash = binascii.a2b_hex(lmhash)\n            nthash = binascii.a2b_hex(nthash)\n        else:\n            lmhash = ''\n            nthash = ''\n\n        resp = self.preLogin()\n        # Test this!\n        if resp['Encryption'] == TDS_ENCRYPT_REQ or resp['Encryption'] == TDS_ENCRYPT_OFF:\n            LOG.info(\"Encryption required, switching to TLS\")\n\n            # Switching to TLS now\n            ctx = SSL.Context(SSL.TLS_METHOD)\n            ctx.set_cipher_list('ALL:@SECLEVEL=0'.encode('utf-8'))\n            tls = SSL.Connection(ctx,None)\n            tls.set_connect_state()\n            while True:\n                try:\n                    tls.do_handshake()\n                except SSL.WantReadError:\n                    data = tls.bio_read(4096)\n                    self.sendTDS(TDS_PRE_LOGIN, data,0)\n                    tds = self.recvTDS()\n                    tls.bio_write(tds['Data'])\n                else:\n                    break\n\n            # SSL and TLS limitation: Secure Socket Layer (SSL) and its replacement, \n            # Transport Layer Security(TLS), limit data fragments to 16k in size.\n            self.packetSize = 16*1024-1\n            self.tlsSocket = tls \n\n\n        login = TDS_LOGIN()\n\n        login['HostName'] = (''.join([random.choice(string.ascii_letters) for i in range(8)])).encode('utf-16le')\n        login['AppName']  = (''.join([random.choice(string.ascii_letters) for i in range(8)])).encode('utf-16le')\n        login['ServerName'] = self.server.encode('utf-16le')\n        login['CltIntName']  = login['AppName']\n        login['ClientPID'] = random.randint(0,1024)\n        login['PacketSize'] = self.packetSize\n        if database is not None:\n            login['Database'] = database.encode('utf-16le')\n        login['OptionFlags2'] = TDS_INIT_LANG_FATAL | TDS_ODBC_ON\n\n        if useWindowsAuth is True:\n            login['OptionFlags2'] |= TDS_INTEGRATED_SECURITY_ON\n            # NTLMSSP Negotiate\n            auth = ntlm.getNTLMSSPType1('','')\n            login['SSPI'] = auth.getData()\n        else:\n            login['UserName'] = username.encode('utf-16le')\n            login['Password'] = self.encryptPassword(password.encode('utf-16le'))\n            login['SSPI'] = ''\n\n\n        login['Length'] = len(login.getData())\n\n        # Send the NTLMSSP Negotiate or SQL Auth Packet\n        self.sendTDS(TDS_LOGIN7, login.getData())\n\n        # According to the specs, if encryption is not required, we must encrypt just \n        # the first Login packet :-o \n        if resp['Encryption'] == TDS_ENCRYPT_OFF:\n            self.tlsSocket = None\n\n        tds = self.recvTDS()\n\n\n        if useWindowsAuth is True:\n            serverChallenge = tds['Data'][3:]\n\n            # Generate the NTLM ChallengeResponse AUTH \n            type3, exportedSessionKey = ntlm.getNTLMSSPType3(auth, serverChallenge, username, password, domain, lmhash, nthash)\n\n            self.sendTDS(TDS_SSPI, type3.getData())\n            tds = self.recvTDS()\n\n        self.replies = self.parseReply(tds['Data'])\n\n        if TDS_LOGINACK_TOKEN in self.replies:\n            return True\n        else:\n            return False\n\n\n    def processColMeta(self):\n        for col in self.colMeta:\n            if col['Type'] in [TDS_NVARCHARTYPE, TDS_NCHARTYPE, TDS_NTEXTTYPE]:\n                col['Length'] = col['TypeData']//2\n                fmt = '%%-%ds' \n            elif col['Type'] in [TDS_GUIDTYPE]:\n                col['Length'] = 36\n                fmt = '%%%ds' \n            elif col['Type'] in [TDS_DECIMALNTYPE,TDS_NUMERICNTYPE]:\n                col['Length'] = ord(col['TypeData'][0:1])\n                fmt = '%%%ds' \n            elif col['Type'] in [TDS_DATETIMNTYPE]:\n                col['Length'] = 19\n                fmt = '%%-%ds' \n            elif col['Type'] in [TDS_INT4TYPE, TDS_INTNTYPE]:\n                col['Length'] = 11\n                fmt = '%%%ds' \n            elif col['Type'] in [TDS_FLTNTYPE, TDS_MONEYNTYPE]:\n                col['Length'] = 25\n                fmt = '%%%ds' \n            elif col['Type'] in [TDS_BITNTYPE, TDS_BIGCHARTYPE]:\n                col['Length'] = col['TypeData']\n                fmt = '%%%ds' \n            elif col['Type'] in [TDS_BIGBINARYTYPE, TDS_BIGVARBINTYPE]:\n                col['Length'] = col['TypeData'] * 2\n                fmt = '%%%ds' \n            elif col['Type'] in [TDS_TEXTTYPE, TDS_BIGVARCHRTYPE]:\n                col['Length'] = col['TypeData']\n                fmt = '%%-%ds'\n            else:\n                col['Length'] = 10\n                fmt = '%%%ds'\n\n            col['minLenght'] = 0\n            for row in self.rows:\n                if len(str(row[col['Name']])) > col['minLenght']:\n                   col['minLenght'] = len(str(row[col['Name']]))\n            if col['minLenght'] < col['Length']:\n                col['Length'] = col['minLenght']\n\n            if len(col['Name']) > col['Length']:\n                col['Length'] = len(col['Name'])\n            elif col['Length'] > self.MAX_COL_LEN:\n                col['Length'] = self.MAX_COL_LEN\n\n            col['Format'] = fmt % col['Length']\n\n\n    def printColumnsHeader(self):\n        if len(self.colMeta) == 0:\n            return\n        for col in self.colMeta:\n            self.__rowsPrinter.logMessage(col['Format'] % col['Name'] + self.COL_SEPARATOR)\n        self.__rowsPrinter.logMessage('\\r')\n        for col in self.colMeta:\n            self.__rowsPrinter.logMessage('-'*col['Length'] + self.COL_SEPARATOR)\n        self.__rowsPrinter.logMessage('\\r')\n\n    def printRows(self):\n        if self.lastError is True:\n            return\n        self.processColMeta()\n        self.printColumnsHeader()\n        for row in self.rows:\n            for col in self.colMeta:\n                self.__rowsPrinter.logMessage(col['Format'] % row[col['Name']] + self.COL_SEPARATOR)\n            self.__rowsPrinter.logMessage('\\n')\n\n    def printReplies(self):\n        for keys in list(self.replies.keys()):\n            for i, key in enumerate(self.replies[keys]):\n                if key['TokenType'] == TDS_ERROR_TOKEN:\n                    error =  \"ERROR(%s): Line %d: %s\" % (key['ServerName'].decode('utf-16le'), key['LineNumber'], key['MsgText'].decode('utf-16le'))                                      \n                    self.lastError = SQLErrorException(\"ERROR: Line %d: %s\" % (key['LineNumber'], key['MsgText'].decode('utf-16le')))\n                    LOG.error(error)\n\n                elif key['TokenType'] == TDS_INFO_TOKEN:\n                    LOG.info(\"INFO(%s): Line %d: %s\" % (key['ServerName'].decode('utf-16le'), key['LineNumber'], key['MsgText'].decode('utf-16le')))\n\n                elif key['TokenType'] == TDS_LOGINACK_TOKEN:\n                    LOG.info(\"ACK: Result: %s - %s (%d%d %d%d) \" % (key['Interface'], key['ProgName'].decode('utf-16le'), key['MajorVer'], key['MinorVer'], key['BuildNumHi'], key['BuildNumLow']))\n\n                elif key['TokenType'] == TDS_ENVCHANGE_TOKEN:\n                    if key['Type'] in (TDS_ENVCHANGE_DATABASE, TDS_ENVCHANGE_LANGUAGE, TDS_ENVCHANGE_CHARSET, TDS_ENVCHANGE_PACKETSIZE):\n                        record = TDS_ENVCHANGE_VARCHAR(key['Data'])\n                        if record['OldValue'] == '':\n                            record['OldValue'] = 'None'.encode('utf-16le')\n                        elif record['NewValue'] == '':\n                            record['NewValue'] = 'None'.encode('utf-16le')\n                        if key['Type'] == TDS_ENVCHANGE_DATABASE:\n                            _type = 'DATABASE'\n                        elif key['Type'] == TDS_ENVCHANGE_LANGUAGE:\n                            _type = 'LANGUAGE'\n                        elif key['Type'] == TDS_ENVCHANGE_CHARSET:\n                            _type = 'CHARSET'\n                        elif key['Type'] == TDS_ENVCHANGE_PACKETSIZE:\n                            _type = 'PACKETSIZE'\n                        else:\n                            _type = \"%d\" % key['Type']                 \n                        LOG.info(\"ENVCHANGE(%s): Old Value: %s, New Value: %s\" % (_type,record['OldValue'].decode('utf-16le'), record['NewValue'].decode('utf-16le')))\n       \n    def parseRow(self,token,tuplemode=False):\n        # TODO: This REALLY needs to be improved. Right now we don't support correctly all the data types\n        # help would be appreciated ;) \n        if len(token) == 1:\n            return 0\n\n        row = [] if tuplemode else {}\n\n        origDataLen = len(token['Data'])\n        data = token['Data']\n        for col in self.colMeta:\n            _type = col['Type']\n            if (_type == TDS_NVARCHARTYPE) |\\\n               (_type == TDS_NCHARTYPE):\n                #print \"NVAR 0x%x\" % _type\n                charLen = struct.unpack('<H',data[:struct.calcsize('<H')])[0]\n                data = data[struct.calcsize('<H'):]\n                if charLen != 0xFFFF:\n                    value = data[:charLen].decode('utf-16le')\n                    data = data[charLen:]\n                else:\n                    value = 'NULL'\n\n            elif _type == TDS_BIGVARCHRTYPE:\n                charLen = struct.unpack('<H',data[:struct.calcsize('<H')])[0]\n                data = data[struct.calcsize('<H'):]\n                if charLen != 0xFFFF:\n                    value = data[:charLen]\n                    data = data[charLen:]\n                else:\n                    value = 'NULL'\n\n            elif _type == TDS_GUIDTYPE:\n                uuidLen = ord(data[0:1])\n                data = data[1:]\n                if uuidLen > 0:\n                    uu = data[:uuidLen]\n                    value = uuid.bin_to_string(uu)\n                    data = data[uuidLen:]\n                else:\n                    value = 'NULL'\n                \n            elif (_type == TDS_NTEXTTYPE) |\\\n                 (_type == TDS_IMAGETYPE) :\n                # Skip the pointer data\n                charLen = ord(data[0:1])\n                if charLen == 0:\n                    value = 'NULL'\n                    data = data[1:]\n                else:\n                    data = data[1+charLen+8:]\n                    charLen = struct.unpack('<L',data[:struct.calcsize('<L')])[0]\n                    data = data[struct.calcsize('<L'):]\n                    if charLen != 0xFFFF:\n                        if _type == TDS_NTEXTTYPE:\n                            value = data[:charLen].decode('utf-16le')\n                        else:\n                            value = binascii.b2a_hex(data[:charLen])\n                        data = data[charLen:]\n                    else:\n                        value = 'NULL'\n                \n            elif _type == TDS_TEXTTYPE:\n                # Skip the pointer data\n                charLen = ord(data[0:1])\n                if charLen == 0:\n                    value = 'NULL'\n                    data = data[1:]\n                else:\n                    data = data[1+charLen+8:]\n                    charLen = struct.unpack('<L',data[:struct.calcsize('<L')])[0]\n                    data = data[struct.calcsize('<L'):]\n                    if charLen != 0xFFFF:\n                        value = data[:charLen]\n                        data = data[charLen:]\n                    else:\n                        value = 'NULL'\n\n            elif (_type == TDS_BIGVARBINTYPE) |\\\n                 (_type == TDS_BIGBINARYTYPE):\n                charLen = struct.unpack('<H',data[:struct.calcsize('<H')])[0]\n                data = data[struct.calcsize('<H'):]\n                if charLen != 0xFFFF:\n                    value = binascii.b2a_hex(data[:charLen])\n                    data = data[charLen:]\n                else:\n                    value = 'NULL'\n\n            elif (_type == TDS_DATETIM4TYPE) |\\\n                 (_type == TDS_DATETIMNTYPE) |\\\n                 (_type == TDS_DATETIMETYPE):\n                value = ''    \n                if _type == TDS_DATETIMNTYPE:\n                    # For DATETIMNTYPE, the only valid lengths are 0x04 and 0x08, which map to smalldatetime and\n                    # datetime SQL data _types respectively.\n                    if ord(data[0:1]) == 4:\n                        _type = TDS_DATETIM4TYPE\n                    elif ord(data[0:1]) == 8:\n                        _type = TDS_DATETIMETYPE\n                    else:\n                        value = 'NULL'\n                    data = data[1:]\n                if _type == TDS_DATETIMETYPE:\n                    # datetime is represented in the following sequence:\n                    # * One 4-byte signed integer that represents the number of days since January 1, 1900. Negative\n                    #   numbers are allowed to represents dates since January 1, 1753.\n                    # * One 4-byte unsigned integer that represents the number of one three-hundredths of a second\n                    #  (300 counts per second) elapsed since 12 AM that day.\n                    dateValue = struct.unpack('<l',data[:4])[0]\n                    data = data[4:]\n                    if dateValue < 0:\n                        baseDate = datetime.date(1753,1,1)\n                    else:\n                        baseDate = datetime.date(1900,1,1)\n                    timeValue = struct.unpack('<L',data[:4])[0]\n                    data = data[4:] \n                elif _type == TDS_DATETIM4TYPE:\n                    # Small datetime\n                    # 2.2.5.5.1.8\n                    # Date/Times\n                    # smalldatetime is represented in the following sequence:\n                    # * One 2-byte unsigned integer that represents the number of days since January 1, 1900.\n                    # * One 2-byte unsigned integer that represents the number of minutes elapsed since 12 AM that\n                    #   day.\n                    dateValue = struct.unpack('<H',data[:struct.calcsize('<H')])[0]\n                    data = data[struct.calcsize('<H'):]\n                    timeValue = struct.unpack('<H',data[:struct.calcsize('<H')])[0]\n                    data = data[struct.calcsize('<H'):]\n                    baseDate = datetime.date(1900,1,1)\n                if value != 'NULL':\n                    dateValue = datetime.date.fromordinal(baseDate.toordinal() + dateValue)\n                    hours, mod = divmod(timeValue//300, 60*60)\n                    minutes, second = divmod(mod, 60)\n                    value = datetime.datetime(dateValue.year, dateValue.month, dateValue.day, hours, minutes, second)\n\n            elif (_type == TDS_INT4TYPE) |\\\n                 (_type == TDS_MONEY4TYPE) |\\\n                 (_type == TDS_FLT4TYPE):\n                #print \"INT4\"\n                value = struct.unpack('<l',data[:struct.calcsize('<l')])[0]\n                data = data[struct.calcsize('<l'):]\n\n            elif _type == TDS_FLTNTYPE:\n                valueSize = ord(data[:1])\n                if valueSize == 4:\n                    fmt = '<f'\n                elif valueSize == 8:\n                    fmt = '<d'\n\n                data = data[1:]\n\n                if valueSize > 0:\n                    value = struct.unpack(fmt,data[:valueSize])[0]\n                    data = data[valueSize:]\n                else:\n                    value = 'NULL'\n\n            elif _type == TDS_MONEYNTYPE:\n                valueSize = ord(data[:1])\n                if valueSize == 4:\n                    fmt = '<l'\n                elif valueSize == 8:\n                    fmt = '<q'\n\n                data = data[1:]\n\n                if valueSize > 0:\n                    value = struct.unpack(fmt,data[:valueSize])[0]\n                    if valueSize == 4:\n                        value = float(value) // math.pow(10,4)\n                    else:\n                        value = float(value >> 32) // math.pow(10,4)\n                    data = data[valueSize:]\n                else:\n                    value = 'NULL'\n\n                \n            elif _type == TDS_BIGCHARTYPE:\n                #print \"BIGC\"\n                charLen = struct.unpack('<H',data[:struct.calcsize('<H')])[0]\n                data = data[struct.calcsize('<H'):]\n                value = data[:charLen]\n                data = data[charLen:]\n\n            elif (_type == TDS_INT8TYPE) |\\\n                 (_type == TDS_FLT8TYPE) |\\\n                 (_type == TDS_MONEYTYPE):\n                #print \"DATETIME\"\n                value = struct.unpack('<q',data[:struct.calcsize('<q')])[0]\n                data = data[struct.calcsize('<q'):]\n\n\n            elif _type == TDS_INT2TYPE:\n                #print \"INT2TYPE\"\n                value = struct.unpack('<H',(data[:2]))[0]\n                data = data[2:]\n\n            elif _type == TDS_DATENTYPE:\n                # date is represented as one 3-byte unsigned integer that represents the number of days since\n                # January 1, year 1.\n                valueSize = ord(data[:1])\n                data = data[1:]\n                if valueSize > 0:\n                    dateBytes = data[:valueSize]\n                    dateValue = struct.unpack('<L','\\x00'+dateBytes)[0]\n                    value = datetime.date.fromtimestamp(dateValue)\n                    data = data[valueSize:]\n                else:\n                    value = 'NULL'\n\n            elif (_type == TDS_BITTYPE) |\\\n                 (_type == TDS_INT1TYPE):\n                #print \"BITTYPE\"\n                value = ord(data[:1])\n                data = data[1:]\n\n            elif (_type == TDS_NUMERICNTYPE) |\\\n                 (_type == TDS_DECIMALNTYPE):\n                valueLen = ord(data[:1])\n                data = data[1:]\n                value = data[:valueLen]\n                data = data[valueLen:]\n                precision = ord(col['TypeData'][1:2])\n                scale = ord(col['TypeData'][2:3])\n                if valueLen > 0:\n                    isPositiveSign = ord(value[0:1])\n                    if (valueLen-1) == 2:\n                        fmt = '<H'\n                    elif (valueLen-1) == 4:\n                        fmt = '<L'\n                    elif (valueLen-1) == 8:\n                        fmt = '<Q'\n                    else:\n                        # Still don't know how to handle higher values\n                        value = \"TODO: Interpret TDS_NUMERICNTYPE correctly\"\n                    number = struct.unpack(fmt, value[1:])[0]\n                    number //= math.pow(precision, scale)\n                    if isPositiveSign == 0:\n                        number *= -1 \n                    value = number\n                else:\n                    value = 'NULL'\n\n            elif _type == TDS_BITNTYPE:\n                #print \"BITNTYPE\"\n                valueSize = ord(data[:1])\n                data = data[1:]\n                if valueSize > 0:\n                    if valueSize == 1:\n                        value = ord(data[:valueSize])\n                    else:\n                        value = data[:valueSize]\n                else:\n                    value = 'NULL'\n                data = data[valueSize:]\n\n            elif _type == TDS_INTNTYPE:\n                valueSize = ord(data[:1])\n                if valueSize == 1:\n                    fmt = '<B'\n                elif valueSize == 2:\n                    fmt = '<h'\n                elif valueSize == 4:\n                    fmt = '<l'\n                elif valueSize == 8:\n                    fmt = '<q'\n                else:\n                    fmt = ''\n\n                data = data[1:]\n\n                if valueSize > 0:\n                    value = struct.unpack(fmt,data[:valueSize])[0]\n                    data = data[valueSize:]\n                else:\n                    value = 'NULL'\n            elif _type == TDS_SSVARIANTTYPE:\n                raise Exception(\"ParseRow: SQL Variant type not yet supported :(\")\n            else:\n                raise Exception(\"ParseROW: Unsupported data type: 0%x\" % _type)\n\n            if tuplemode:\n                row.append(value)\n            else:\n                row[col['Name']] = value\n\n\n        self.rows.append(row)\n\n        return origDataLen - len(data)\n\n    def parseColMetaData(self, token):\n        # TODO Add support for more data types!\n        count = token['Count']\n        if count == 0xFFFF:\n            return 0\n\n        self.colMeta = []\n        origDataLen = len(token['Data'])\n        data = token['Data']\n        for i in range(count):\n            column = {}\n            userType = struct.unpack('<H',data[:struct.calcsize('<H')])[0]\n            data = data[struct.calcsize('<H'):]\n            flags = struct.unpack('<H',data[:struct.calcsize('<H')])[0]\n            data = data[struct.calcsize('<H'):]\n            colType = struct.unpack('<B',data[:struct.calcsize('<B')])[0]\n            data = data[struct.calcsize('<B'):]\n            if (colType == TDS_BITTYPE)    |\\\n                 (colType == TDS_INT1TYPE)   |\\\n                 (colType == TDS_INT2TYPE)   |\\\n                 (colType == TDS_INT8TYPE)   |\\\n                 (colType == TDS_DATETIMETYPE) |\\\n                 (colType == TDS_DATETIM4TYPE) |\\\n                 (colType == TDS_FLT4TYPE)   |\\\n                 (colType == TDS_FLT8TYPE)   |\\\n                 (colType == TDS_MONEYTYPE)  |\\\n                 (colType == TDS_MONEY4TYPE) |\\\n                 (colType == TDS_DATENTYPE)  |\\\n                 (colType == TDS_INT4TYPE):\n                typeData = ''\n            elif (colType == TDS_INTNTYPE) |\\\n                 (colType == TDS_TIMENTYPE) |\\\n                 (colType == TDS_DATETIME2NTYPE) |\\\n                 (colType == TDS_DATETIMEOFFSETNTYPE) |\\\n                 (colType == TDS_FLTNTYPE) |\\\n                 (colType == TDS_MONEYNTYPE) |\\\n                 (colType == TDS_GUIDTYPE) |\\\n                 (colType == TDS_BITNTYPE):\n                typeData = ord(data[0:1])\n                data = data[1:]\n\n            elif colType == TDS_DATETIMNTYPE:\n                # For DATETIMNTYPE, the only valid lengths are 0x04 and 0x08, which map to smalldatetime and\n                # datetime SQL data types respectively.\n                typeData = ord(data[0:1])\n                data = data[1:]\n\n            elif (colType == TDS_BIGVARBINTYPE) |\\\n                 (colType == TDS_BIGBINARYTYPE) |\\\n                 (colType == TDS_NCHARTYPE)     |\\\n                 (colType == TDS_NVARCHARTYPE)  |\\\n                 (colType == TDS_BIGVARCHRTYPE) |\\\n                 (colType == TDS_BIGCHARTYPE):\n                typeData = struct.unpack('<H',data[:2])[0]\n                data = data[2:]\n            elif (colType == TDS_DECIMALNTYPE) |\\\n                 (colType == TDS_NUMERICNTYPE) |\\\n                 (colType == TDS_DECIMALTYPE):\n                typeData = data[:3]\n                data = data[3:]\n            elif (colType == TDS_IMAGETYPE) |\\\n                 (colType == TDS_TEXTTYPE) |\\\n                 (colType == TDS_XMLTYPE)  |\\\n                 (colType == TDS_SSVARIANTTYPE) |\\\n                 (colType == TDS_NTEXTTYPE):\n                typeData = struct.unpack('<L',data[:4])[0]\n                data = data[4:]\n            else:\n                raise Exception(\"Unsupported data type: 0x%x\" % colType)\n\n            # Collation exceptions:\n            if (colType == TDS_NTEXTTYPE) |\\\n               (colType == TDS_BIGCHARTYPE)  |\\\n               (colType == TDS_BIGVARCHRTYPE)  |\\\n               (colType == TDS_NCHARTYPE)  |\\\n               (colType == TDS_NVARCHARTYPE)  |\\\n               (colType == TDS_TEXTTYPE):\n                # Skip collation\n                data = data[5:]\n\n            # PartTableName exceptions:\n            if (colType == TDS_IMAGETYPE) |\\\n               (colType == TDS_TEXTTYPE) |\\\n               (colType == TDS_NTEXTTYPE):\n                # This types have Table Elements, we just discard them for now.\n                # ToDo parse this correctly!\n                # Get the Length\n                dataLen = struct.unpack('<H',data[:2])[0]\n                data = data[2:]\n                # skip the text\n                data = data[dataLen*2:]\n\n            colNameLength = struct.unpack('<B',data[:struct.calcsize('<B')])[0]\n            data = data[struct.calcsize('<B'):]\n            colName = data[:colNameLength*2].decode('utf-16le')\n            data = data[colNameLength*2:]\n            column['Name'] = colName\n            column['Type'] = colType\n            column['TypeData'] = typeData\n            column['Flags'] = flags\n            self.colMeta.append(column)\n\n        return origDataLen - len(data)\n\n    def parseReply(self, tokens,tuplemode=False):\n        if len(tokens) == 0:\n            return False\n\n        replies = {} \n        while len(tokens) > 0:\n            tokenID = struct.unpack('B',tokens[0:1])[0]\n            if tokenID == TDS_ERROR_TOKEN:\n                token = TDS_INFO_ERROR(tokens)\n            elif tokenID == TDS_RETURNSTATUS_TOKEN:\n                token = TDS_RETURNSTATUS(tokens)\n            elif tokenID == TDS_INFO_TOKEN:\n                token = TDS_INFO_ERROR(tokens)\n            elif tokenID == TDS_LOGINACK_TOKEN:\n                token = TDS_LOGIN_ACK(tokens)\n            elif tokenID == TDS_ENVCHANGE_TOKEN:\n                token = TDS_ENVCHANGE(tokens)\n                if token['Type'] is TDS_ENVCHANGE_PACKETSIZE:\n                    record = TDS_ENVCHANGE_VARCHAR(token['Data'])\n                    self.packetSize = int( record['NewValue'].decode('utf-16le') )\n                elif token['Type'] is TDS_ENVCHANGE_DATABASE:\n                    record = TDS_ENVCHANGE_VARCHAR(token['Data'])\n                    self.currentDB =  record['NewValue'].decode('utf-16le') \n\n            elif (tokenID == TDS_DONEINPROC_TOKEN) |\\\n                 (tokenID == TDS_DONEPROC_TOKEN): \n                token = TDS_DONEINPROC(tokens)\n            elif tokenID == TDS_ORDER_TOKEN:\n                token = TDS_ORDER(tokens)\n            elif tokenID == TDS_ROW_TOKEN:\n                #print \"ROW\"\n                token = TDS_ROW(tokens)\n                tokenLen = self.parseRow(token,tuplemode)\n                token['Data'] = token['Data'][:tokenLen]\n            elif tokenID == TDS_COLMETADATA_TOKEN:\n                #print \"COLMETA\"\n                token = TDS_COLMETADATA(tokens)\n                tokenLen = self.parseColMetaData(token)\n                token['Data'] = token['Data'][:tokenLen]\n            elif tokenID == TDS_DONE_TOKEN:\n                token = TDS_DONE(tokens)\n            else:\n                LOG.error(\"Unknown Token %x\" % tokenID)\n                return replies\n\n            if (tokenID in replies) is not True:\n                replies[tokenID] = list()\n\n            replies[tokenID].append(token)\n            tokens = tokens[len(token):]\n            #print \"TYPE 0x%x, LEN: %d\" %(tokenID, len(token))\n            #print repr(tokens[:10])\n\n        return replies\n\n    def batch(self, cmd,tuplemode=False,wait=True):\n        # First of all we clear the rows, colMeta and lastError\n        self.rows = []\n        self.colMeta = []\n        self.lastError = False\n        self.sendTDS(TDS_SQL_BATCH, (cmd+'\\r\\n').encode('utf-16le'))\n        if wait:\n            tds = self.recvTDS()\n            self.replies = self.parseReply(tds['Data'],tuplemode)\n            return self.rows\n        else:\n            return True\n        \n    \n    def batchStatement(self, cmd,tuplemode=False):\n        # First of all we clear the rows, colMeta and lastError\n        self.rows = []\n        self.colMeta = []\n        self.lastError = False\n        self.sendTDS(TDS_SQL_BATCH, (cmd+'\\r\\n').encode('utf-16le'))\n        #self.recvTDS()        \n\n            \n    # Handy alias\n    sql_query = batch\n\n    def changeDB(self, db):        \n        if db != self.currentDB:\n            chdb = 'use %s' % db            \n            self.batch(chdb)\n            self.printReplies()\n\n    def RunSQLQuery(self,db,sql_query,tuplemode=False,wait=True,**kwArgs):\n        db = db or 'master'\n        self.changeDB(db)\n        self.printReplies()\n        ret = self.batch(sql_query,tuplemode,wait)\n        if wait:\n            self.printReplies()\n        if self.lastError:\n            raise self.lastError\n        if self.lastError:\n            raise self.lastError\n        return ret\n    \n    def RunSQLStatement(self,db,sql_query,wait=True,**kwArgs):\n        self.RunSQLQuery(db,sql_query,wait=wait)\n        if self.lastError:\n            raise self.lastError\n        return True",
  "def logMessage(self,message):\n        if message == '\\n':\n            print(message)\n        elif message == '\\r':\n            print()\n        else:\n            print(message, end=' ')",
  "def __init__(self, data = None):\n        SQLR.__init__(self,data)\n        if data is not None:\n            self['OpCode'] = SQLR_CLNT_UCAST_INST",
  "def __init__(self, data = None):\n        SQLR.__init__(self,data)\n        if data is not None:\n            self['OpCode'] = SQLR_CLNT_UCAST_DAC",
  "def getData(self):\n        self['VersionOffset']=21\n        self['EncryptionOffset']=self['VersionOffset'] + len(self['Version'])\n        self['InstanceOffset']=self['EncryptionOffset'] + 1\n        self['ThreadIDOffset']=self['InstanceOffset'] + len(self['Instance'])\n        return Structure.getData(self)",
  "def __init__(self,data=None):\n        Structure.__init__(self,data)\n        if data is None:\n            self['UserName'] = ''\n            self['Password'] = ''\n            self['Database'] = ''\n            self['AtchDBFile'] = ''",
  "def fromString(self, data):\n        Structure.fromString(self, data)\n        if self['HostNameLength'] > 0:\n            self['HostName'] = data[self['HostNameOffset']:][:self['HostNameLength']*2]\n\n        if self['UserNameLength'] > 0:\n            self['UserName'] = data[self['UserNameOffset']:][:self['UserNameLength']*2]\n\n        if self['PasswordLength'] > 0:\n            self['Password'] = data[self['PasswordOffset']:][:self['PasswordLength']*2]\n\n        if self['AppNameLength'] > 0:\n            self['AppName'] = data[self['AppNameOffset']:][:self['AppNameLength']*2]\n\n        if self['ServerNameLength'] > 0:\n            self['ServerName'] = data[self['ServerNameOffset']:][:self['ServerNameLength']*2]\n\n        if self['CltIntNameLength'] > 0:\n            self['CltIntName'] = data[self['CltIntNameOffset']:][:self['CltIntNameLength']*2]\n\n        if self['DatabaseLength'] > 0:\n            self['Database'] = data[self['DatabaseOffset']:][:self['DatabaseLength']*2]\n\n        if self['SSPILength'] > 0:\n            self['SSPI'] = data[self['SSPIOffset']:][:self['SSPILength']*2]\n\n        if self['AtchDBFileLength'] > 0:\n            self['AtchDBFile'] = data[self['AtchDBFileOffset']:][:self['AtchDBFileLength']*2]",
  "def getData(self):\n        index = 36+50\n        self['HostNameOffset']= index\n\n        index += len(self['HostName'])\n\n        if self['UserName'] != '':\n            self['UserNameOffset'] = index\n        else:\n            self['UserNameOffset'] = 0\n\n        index += len(self['UserName'])\n\n        if self['Password'] != '':\n            self['PasswordOffset'] = index\n        else:\n            self['PasswordOffset'] = 0\n\n        index += len(self['Password'])\n\n        self['AppNameOffset']= index\n        self['ServerNameOffset']=self['AppNameOffset'] + len(self['AppName'])\n        self['CltIntNameOffset']=self['ServerNameOffset'] + len(self['ServerName'])\n        self['LanguageOffset']=self['CltIntNameOffset'] + len(self['CltIntName'])\n        self['DatabaseOffset']=self['LanguageOffset'] \n        self['SSPIOffset']=self['DatabaseOffset'] + len(self['Database'])\n        self['AtchDBFileOffset']=self['SSPIOffset'] + len(self['SSPI'])\n        return Structure.getData(self)",
  "def __init__(self, address, port=1433, rowsPrinter=DummyPrint()):\n        #self.packetSize = 32764\n        self.packetSize = 32763\n        self.server = address\n        self.port = port\n        self.socket = 0\n        self.replies = {}\n        self.colMeta = []\n        self.rows = []\n        self.currentDB = ''\n        self.COL_SEPARATOR = '  '\n        self.MAX_COL_LEN = 255\n        self.lastError = False\n        self.tlsSocket = None\n        self.__rowsPrinter = rowsPrinter",
  "def getInstances(self, timeout = 5):\n        packet = SQLR()\n        packet['OpCode'] = SQLR_CLNT_UCAST_EX\n\n        # Open the connection\n        af, socktype, proto, canonname, sa = socket.getaddrinfo(self.server, SQLR_PORT, 0, socket.SOCK_DGRAM)[0]\n        s = socket.socket(af, socktype, proto)\n\n        s.sendto(packet.getData(), 0, ( self.server, SQLR_PORT ))\n        ready, _, _ = select.select([ s.fileno() ], [ ] , [ ], timeout)\n        if not ready:\n            return []\n        else:\n            data, _ = s.recvfrom(65536, 0)\n   \n        s.close()\n        resp = SQLR_Response(data)\n\n        # Now parse the results\n        entries = resp['Data'].split(b';;')\n\n        # We don't want the last one, it's empty\n        entries.pop()\n \n        # the answer to send back\n        resp = []\n\n        for i, entry in enumerate(entries):\n            fields = entry.split(b';')\n            ret = {}\n            for j, field in enumerate(fields):\n                if (j & 0x1) == 0:\n                    ret[field.decode('utf-8')] = fields[j+1].decode('utf-8')\n            resp.append(ret)\n\n        return resp",
  "def preLogin(self):\n        prelogin = TDS_PRELOGIN()\n        prelogin['Version'] = b\"\\x08\\x00\\x01\\x55\\x00\\x00\"\n        #prelogin['Encryption'] = TDS_ENCRYPT_NOT_SUP\n        prelogin['Encryption'] = TDS_ENCRYPT_OFF\n        prelogin['ThreadID'] = struct.pack('<L',random.randint(0,65535))\n        prelogin['Instance'] = b'MSSQLServer\\x00'\n\n        self.sendTDS(TDS_PRE_LOGIN, prelogin.getData(), 0)\n        tds = self.recvTDS()\n\n        return TDS_PRELOGIN(tds['Data'])",
  "def encryptPassword(self, password ):\n        return bytes(bytearray([((x & 0x0f) << 4) + ((x & 0xf0) >> 4) ^ 0xa5 for x in bytearray(password)]))",
  "def connect(self):\n        af, socktype, proto, canonname, sa = socket.getaddrinfo(self.server, self.port, 0, socket.SOCK_STREAM)[0]\n        sock = socket.socket(af, socktype, proto)\n        \n        try:\n            sock.connect(sa)\n        except Exception:\n            #import traceback\n            #traceback.print_exc()\n            raise\n        \n        self.socket = sock\n        return sock",
  "def disconnect(self):\n        if self.socket:\n            return self.socket.close()",
  "def setPacketSize(self, packetSize):\n        self.packetSize = packetSize",
  "def getPacketSize(self):\n        return self.packetSize",
  "def socketSendall(self,data):\n        if self.tlsSocket is None:\n            return self.socket.sendall(data)\n        else:\n            self.tlsSocket.sendall(data)\n            dd = self.tlsSocket.bio_read(self.packetSize)\n            return self.socket.sendall(dd)",
  "def sendTDS(self, packetType, data, packetID = 1):\n        if (len(data)-8) > self.packetSize:\n            remaining = data[self.packetSize-8:]\n            tds = TDSPacket()\n            tds['Type'] = packetType\n            tds['Status'] = TDS_STATUS_NORMAL\n            tds['PacketID'] = packetID\n            tds['Data'] = data[:self.packetSize-8]\n            self.socketSendall(tds.getData())\n\n            while len(remaining) > (self.packetSize-8):\n                packetID += 1\n                tds['PacketID'] = packetID\n                tds['Data'] = remaining[:self.packetSize-8]\n                self.socketSendall(tds.getData())\n                remaining = remaining[self.packetSize-8:]\n            data = remaining\n            packetID+=1\n\n        tds = TDSPacket()\n        tds['Type'] = packetType\n        tds['Status'] = TDS_STATUS_EOM\n        tds['PacketID'] = packetID\n        tds['Data'] = data\n        self.socketSendall(tds.getData())",
  "def socketRecv(self, packetSize):\n        data = self.socket.recv(packetSize)\n        if self.tlsSocket is not None:\n            dd = b''\n            self.tlsSocket.bio_write(data)\n            while True:\n                try:\n                    dd += self.tlsSocket.read(packetSize)\n                except SSL.WantReadError:\n                    data2 = self.socket.recv(packetSize - len(data) )\n                    self.tlsSocket.bio_write(data2)\n                    pass\n                else:\n                    data = dd\n                    break\n        return data",
  "def recvTDS(self, packetSize = None):\n        # Do reassembly here\n        if packetSize is None:\n            packetSize = self.packetSize\n        packet = TDSPacket(self.socketRecv(packetSize))\n        status = packet['Status']\n        packetLen = packet['Length']-8\n        while packetLen > len(packet['Data']):\n            data = self.socketRecv(packetSize)\n            packet['Data'] += data\n        \n        remaining = None\n        if packetLen <  len(packet['Data']):\n            remaining = packet['Data'][packetLen:]\n            packet['Data'] = packet['Data'][:packetLen]\n\n        #print \"REMAINING \", \n        #if remaining is None: \n        #   print None \n        #else: \n        #   print len(remaining)\n\n        while status != TDS_STATUS_EOM:\n            if remaining is not None:\n                tmpPacket = TDSPacket(remaining)\n            else:\n                tmpPacket = TDSPacket(self.socketRecv(packetSize))\n\n            packetLen = tmpPacket['Length'] - 8\n            while packetLen > len(tmpPacket['Data']):\n                data = self.socketRecv(packetSize)\n                tmpPacket['Data'] += data\n\n            remaining = None\n            if packetLen <  len(tmpPacket['Data']):\n                remaining = tmpPacket['Data'][packetLen:]\n                tmpPacket['Data'] = tmpPacket['Data'][:packetLen]\n\n            status = tmpPacket['Status']\n            packet['Data'] += tmpPacket['Data']\n            packet['Length'] += tmpPacket['Length'] - 8\n            \n        #print packet['Length']\n        return packet",
  "def kerberosLogin(self, database, username, password='', domain='', hashes=None, aesKey='', kdcHost=None, TGT=None, TGS=None, useCache=True):\n\n        if hashes is not None:\n            lmhash, nthash = hashes.split(':')\n            lmhash = binascii.a2b_hex(lmhash)\n            nthash = binascii.a2b_hex(nthash)\n        else:\n            lmhash = ''\n            nthash = ''\n\n        resp = self.preLogin()\n        # Test this!\n        if resp['Encryption'] == TDS_ENCRYPT_REQ or resp['Encryption'] == TDS_ENCRYPT_OFF:\n            LOG.info(\"Encryption required, switching to TLS\")\n\n            # Switching to TLS now\n            ctx = SSL.Context(SSL.TLS_METHOD)\n            ctx.set_cipher_list('ALL:@SECLEVEL=0'.encode('utf-8'))\n            tls = SSL.Connection(ctx,None)\n            tls.set_connect_state()\n            while True:\n                try:\n                    tls.do_handshake()\n                except SSL.WantReadError:\n                    data = tls.bio_read(4096)\n                    self.sendTDS(TDS_PRE_LOGIN, data,0)\n                    tds = self.recvTDS()\n                    tls.bio_write(tds['Data'])\n                else:\n                    break\n\n            # SSL and TLS limitation: Secure Socket Layer (SSL) and its replacement,\n            # Transport Layer Security(TLS), limit data fragments to 16k in size.\n            self.packetSize = 16*1024-1\n            self.tlsSocket = tls\n\n\n        login = TDS_LOGIN()\n\n        login['HostName'] = (''.join([random.choice(string.ascii_letters) for _ in range(8)])).encode('utf-16le')\n        login['AppName']  = (''.join([random.choice(string.ascii_letters) for _ in range(8)])).encode('utf-16le')\n        login['ServerName'] = self.server.encode('utf-16le')\n        login['CltIntName']  = login['AppName']\n        login['ClientPID'] = random.randint(0,1024)\n        login['PacketSize'] = self.packetSize\n        if database is not None:\n            login['Database'] = database.encode('utf-16le')\n        login['OptionFlags2'] = TDS_INIT_LANG_FATAL | TDS_ODBC_ON\n\n        from impacket.spnego import SPNEGO_NegTokenInit, TypesMech\n        # Importing down here so pyasn1 is not required if kerberos is not used.\n        from impacket.krb5.ccache import CCache\n        from impacket.krb5.asn1 import AP_REQ, Authenticator, TGS_REP, seq_set\n        from impacket.krb5.kerberosv5 import getKerberosTGT, getKerberosTGS, KerberosError\n        from impacket.krb5 import constants\n        from impacket.krb5.types import Principal, KerberosTime, Ticket\n        from pyasn1.codec.der import decoder, encoder\n        from pyasn1.type.univ import noValue\n        import datetime\n\n        if useCache:\n            domain, username, TGT, TGS = CCache.parseFile(domain, username, 'MSSQLSvc/%s:%d' % (self.server, self.port))\n\n            if TGS is None:\n                # search for the port's instance name instead (instance name based SPN)\n                LOG.debug('Searching target\\'s instances to look for port number %s' % self.port)\n                instances = self.getInstances()\n                instanceName = None\n                for i in instances:\n                    try:\n                        if int(i['tcp']) == self.port:\n                            instanceName = i['InstanceName']\n                    except Exception as e:\n                        pass\n\n                if instanceName:\n                    domain, username, TGT, TGS = CCache.parseFile(domain, username, 'MSSQLSvc/%s.%s:%s' % (self.server.split('.')[0], domain, instanceName))\n\n        # First of all, we need to get a TGT for the user\n        userName = Principal(username, type=constants.PrincipalNameType.NT_PRINCIPAL.value)\n        while True:\n            if TGT is None:\n                if TGS is None:\n                    try:\n                        tgt, cipher, oldSessionKey, sessionKey = getKerberosTGT(userName, password, domain, lmhash, nthash, aesKey, kdcHost)\n                    except KerberosError as e:\n                        if e.getErrorCode() == constants.ErrorCodes.KDC_ERR_ETYPE_NOSUPP.value:\n                            # We might face this if the target does not support AES\n                            # So, if that's the case we'll force using RC4 by converting\n                            # the password to lm/nt hashes and hope for the best. If that's already\n                            # done, byebye.\n                            if lmhash == '' and nthash == '' and (aesKey == '' or aesKey is None) and TGT is None and TGS is None:\n                                from impacket.ntlm import compute_lmhash, compute_nthash\n                                LOG.debug('Got KDC_ERR_ETYPE_NOSUPP, fallback to RC4')\n                                lmhash = compute_lmhash(password)\n                                nthash = compute_nthash(password)\n                                continue\n                            else:\n                                raise\n                        else:\n                            raise\n            else:\n                tgt = TGT['KDC_REP']\n                cipher = TGT['cipher']\n                sessionKey = TGT['sessionKey']\n\n            if TGS is None:\n                # From https://msdn.microsoft.com/en-us/library/ms191153.aspx?f=255&MSPPError=-2147217396\n                # Beginning with SQL Server 2008, the SPN format is changed in order to support Kerberos authentication\n                # on TCP/IP, named pipes, and shared memory. The supported SPN formats for named and default instances\n                # are as follows.\n                # Named instance\n                #     MSSQLSvc/FQDN:[port | instancename], where:\n                #         MSSQLSvc is the service that is being registered.\n                #         FQDN is the fully qualified domain name of the server.\n                #         port is the TCP port number.\n                #         instancename is the name of the SQL Server instance.\n                serverName = Principal('MSSQLSvc/%s.%s:%d' % (self.server.split('.')[0], domain, self.port), type=constants.PrincipalNameType.NT_SRV_INST.value)\n                try:\n                    tgs, cipher, oldSessionKey, sessionKey = getKerberosTGS(serverName, domain, kdcHost, tgt, cipher, sessionKey)\n                except KerberosError as e:\n                    if e.getErrorCode() == constants.ErrorCodes.KDC_ERR_ETYPE_NOSUPP.value:\n                        # We might face this if the target does not support AES\n                        # So, if that's the case we'll force using RC4 by converting\n                        # the password to lm/nt hashes and hope for the best. If that's already\n                        # done, byebye.\n                        if lmhash == '' and nthash == '' and (aesKey == '' or aesKey is None) and TGT is None and TGS is None:\n                            from impacket.ntlm import compute_lmhash, compute_nthash\n                            LOG.debug('Got KDC_ERR_ETYPE_NOSUPP, fallback to RC4')\n                            lmhash = compute_lmhash(password)\n                            nthash = compute_nthash(password)\n                        else:\n                            raise\n                    else:\n                        raise\n                else:\n                    break\n            else:\n                tgs = TGS['KDC_REP']\n                cipher = TGS['cipher']\n                sessionKey = TGS['sessionKey']\n                break\n\n        # Let's build a NegTokenInit with a Kerberos REQ_AP\n\n        blob = SPNEGO_NegTokenInit()\n\n        # Kerberos\n        blob['MechTypes'] = [TypesMech['MS KRB5 - Microsoft Kerberos 5']]\n\n        # Let's extract the ticket from the TGS\n        tgs = decoder.decode(tgs, asn1Spec = TGS_REP())[0]\n        ticket = Ticket()\n        ticket.from_asn1(tgs['ticket'])\n\n        # Now let's build the AP_REQ\n        apReq = AP_REQ()\n        apReq['pvno'] = 5\n        apReq['msg-type'] = int(constants.ApplicationTagNumbers.AP_REQ.value)\n\n        opts = list()\n        apReq['ap-options'] = constants.encodeFlags(opts)\n        seq_set(apReq,'ticket', ticket.to_asn1)\n\n        authenticator = Authenticator()\n        authenticator['authenticator-vno'] = 5\n        authenticator['crealm'] = domain\n        seq_set(authenticator, 'cname', userName.components_to_asn1)\n        now = datetime.datetime.utcnow()\n\n        authenticator['cusec'] = now.microsecond\n        authenticator['ctime'] = KerberosTime.to_asn1(now)\n\n        encodedAuthenticator = encoder.encode(authenticator)\n\n        # Key Usage 11\n        # AP-REQ Authenticator (includes application authenticator\n        # subkey), encrypted with the application session key\n        # (Section 5.5.1)\n        encryptedEncodedAuthenticator = cipher.encrypt(sessionKey, 11, encodedAuthenticator, None)\n\n        apReq['authenticator'] = noValue\n        apReq['authenticator']['etype'] = cipher.enctype\n        apReq['authenticator']['cipher'] = encryptedEncodedAuthenticator\n\n        blob['MechToken'] = encoder.encode(apReq)\n\n        login['OptionFlags2'] |= TDS_INTEGRATED_SECURITY_ON\n\n        login['SSPI'] = blob.getData()\n        login['Length'] = len(login.getData())\n\n        # Send the NTLMSSP Negotiate or SQL Auth Packet\n        self.sendTDS(TDS_LOGIN7, login.getData())\n\n        # According to the specs, if encryption is not required, we must encrypt just\n        # the first Login packet :-o\n        if resp['Encryption'] == TDS_ENCRYPT_OFF:\n            self.tlsSocket = None\n\n        tds = self.recvTDS()\n\n        self.replies = self.parseReply(tds['Data'])\n\n        if TDS_LOGINACK_TOKEN in self.replies:\n            return True\n        else:\n            return False",
  "def login(self, database, username, password='', domain='', hashes = None, useWindowsAuth = False):\n\n        if hashes is not None:\n            lmhash, nthash = hashes.split(':')\n            lmhash = binascii.a2b_hex(lmhash)\n            nthash = binascii.a2b_hex(nthash)\n        else:\n            lmhash = ''\n            nthash = ''\n\n        resp = self.preLogin()\n        # Test this!\n        if resp['Encryption'] == TDS_ENCRYPT_REQ or resp['Encryption'] == TDS_ENCRYPT_OFF:\n            LOG.info(\"Encryption required, switching to TLS\")\n\n            # Switching to TLS now\n            ctx = SSL.Context(SSL.TLS_METHOD)\n            ctx.set_cipher_list('ALL:@SECLEVEL=0'.encode('utf-8'))\n            tls = SSL.Connection(ctx,None)\n            tls.set_connect_state()\n            while True:\n                try:\n                    tls.do_handshake()\n                except SSL.WantReadError:\n                    data = tls.bio_read(4096)\n                    self.sendTDS(TDS_PRE_LOGIN, data,0)\n                    tds = self.recvTDS()\n                    tls.bio_write(tds['Data'])\n                else:\n                    break\n\n            # SSL and TLS limitation: Secure Socket Layer (SSL) and its replacement, \n            # Transport Layer Security(TLS), limit data fragments to 16k in size.\n            self.packetSize = 16*1024-1\n            self.tlsSocket = tls \n\n\n        login = TDS_LOGIN()\n\n        login['HostName'] = (''.join([random.choice(string.ascii_letters) for i in range(8)])).encode('utf-16le')\n        login['AppName']  = (''.join([random.choice(string.ascii_letters) for i in range(8)])).encode('utf-16le')\n        login['ServerName'] = self.server.encode('utf-16le')\n        login['CltIntName']  = login['AppName']\n        login['ClientPID'] = random.randint(0,1024)\n        login['PacketSize'] = self.packetSize\n        if database is not None:\n            login['Database'] = database.encode('utf-16le')\n        login['OptionFlags2'] = TDS_INIT_LANG_FATAL | TDS_ODBC_ON\n\n        if useWindowsAuth is True:\n            login['OptionFlags2'] |= TDS_INTEGRATED_SECURITY_ON\n            # NTLMSSP Negotiate\n            auth = ntlm.getNTLMSSPType1('','')\n            login['SSPI'] = auth.getData()\n        else:\n            login['UserName'] = username.encode('utf-16le')\n            login['Password'] = self.encryptPassword(password.encode('utf-16le'))\n            login['SSPI'] = ''\n\n\n        login['Length'] = len(login.getData())\n\n        # Send the NTLMSSP Negotiate or SQL Auth Packet\n        self.sendTDS(TDS_LOGIN7, login.getData())\n\n        # According to the specs, if encryption is not required, we must encrypt just \n        # the first Login packet :-o \n        if resp['Encryption'] == TDS_ENCRYPT_OFF:\n            self.tlsSocket = None\n\n        tds = self.recvTDS()\n\n\n        if useWindowsAuth is True:\n            serverChallenge = tds['Data'][3:]\n\n            # Generate the NTLM ChallengeResponse AUTH \n            type3, exportedSessionKey = ntlm.getNTLMSSPType3(auth, serverChallenge, username, password, domain, lmhash, nthash)\n\n            self.sendTDS(TDS_SSPI, type3.getData())\n            tds = self.recvTDS()\n\n        self.replies = self.parseReply(tds['Data'])\n\n        if TDS_LOGINACK_TOKEN in self.replies:\n            return True\n        else:\n            return False",
  "def processColMeta(self):\n        for col in self.colMeta:\n            if col['Type'] in [TDS_NVARCHARTYPE, TDS_NCHARTYPE, TDS_NTEXTTYPE]:\n                col['Length'] = col['TypeData']//2\n                fmt = '%%-%ds' \n            elif col['Type'] in [TDS_GUIDTYPE]:\n                col['Length'] = 36\n                fmt = '%%%ds' \n            elif col['Type'] in [TDS_DECIMALNTYPE,TDS_NUMERICNTYPE]:\n                col['Length'] = ord(col['TypeData'][0:1])\n                fmt = '%%%ds' \n            elif col['Type'] in [TDS_DATETIMNTYPE]:\n                col['Length'] = 19\n                fmt = '%%-%ds' \n            elif col['Type'] in [TDS_INT4TYPE, TDS_INTNTYPE]:\n                col['Length'] = 11\n                fmt = '%%%ds' \n            elif col['Type'] in [TDS_FLTNTYPE, TDS_MONEYNTYPE]:\n                col['Length'] = 25\n                fmt = '%%%ds' \n            elif col['Type'] in [TDS_BITNTYPE, TDS_BIGCHARTYPE]:\n                col['Length'] = col['TypeData']\n                fmt = '%%%ds' \n            elif col['Type'] in [TDS_BIGBINARYTYPE, TDS_BIGVARBINTYPE]:\n                col['Length'] = col['TypeData'] * 2\n                fmt = '%%%ds' \n            elif col['Type'] in [TDS_TEXTTYPE, TDS_BIGVARCHRTYPE]:\n                col['Length'] = col['TypeData']\n                fmt = '%%-%ds'\n            else:\n                col['Length'] = 10\n                fmt = '%%%ds'\n\n            col['minLenght'] = 0\n            for row in self.rows:\n                if len(str(row[col['Name']])) > col['minLenght']:\n                   col['minLenght'] = len(str(row[col['Name']]))\n            if col['minLenght'] < col['Length']:\n                col['Length'] = col['minLenght']\n\n            if len(col['Name']) > col['Length']:\n                col['Length'] = len(col['Name'])\n            elif col['Length'] > self.MAX_COL_LEN:\n                col['Length'] = self.MAX_COL_LEN\n\n            col['Format'] = fmt % col['Length']",
  "def printColumnsHeader(self):\n        if len(self.colMeta) == 0:\n            return\n        for col in self.colMeta:\n            self.__rowsPrinter.logMessage(col['Format'] % col['Name'] + self.COL_SEPARATOR)\n        self.__rowsPrinter.logMessage('\\r')\n        for col in self.colMeta:\n            self.__rowsPrinter.logMessage('-'*col['Length'] + self.COL_SEPARATOR)\n        self.__rowsPrinter.logMessage('\\r')",
  "def printRows(self):\n        if self.lastError is True:\n            return\n        self.processColMeta()\n        self.printColumnsHeader()\n        for row in self.rows:\n            for col in self.colMeta:\n                self.__rowsPrinter.logMessage(col['Format'] % row[col['Name']] + self.COL_SEPARATOR)\n            self.__rowsPrinter.logMessage('\\n')",
  "def printReplies(self):\n        for keys in list(self.replies.keys()):\n            for i, key in enumerate(self.replies[keys]):\n                if key['TokenType'] == TDS_ERROR_TOKEN:\n                    error =  \"ERROR(%s): Line %d: %s\" % (key['ServerName'].decode('utf-16le'), key['LineNumber'], key['MsgText'].decode('utf-16le'))                                      \n                    self.lastError = SQLErrorException(\"ERROR: Line %d: %s\" % (key['LineNumber'], key['MsgText'].decode('utf-16le')))\n                    LOG.error(error)\n\n                elif key['TokenType'] == TDS_INFO_TOKEN:\n                    LOG.info(\"INFO(%s): Line %d: %s\" % (key['ServerName'].decode('utf-16le'), key['LineNumber'], key['MsgText'].decode('utf-16le')))\n\n                elif key['TokenType'] == TDS_LOGINACK_TOKEN:\n                    LOG.info(\"ACK: Result: %s - %s (%d%d %d%d) \" % (key['Interface'], key['ProgName'].decode('utf-16le'), key['MajorVer'], key['MinorVer'], key['BuildNumHi'], key['BuildNumLow']))\n\n                elif key['TokenType'] == TDS_ENVCHANGE_TOKEN:\n                    if key['Type'] in (TDS_ENVCHANGE_DATABASE, TDS_ENVCHANGE_LANGUAGE, TDS_ENVCHANGE_CHARSET, TDS_ENVCHANGE_PACKETSIZE):\n                        record = TDS_ENVCHANGE_VARCHAR(key['Data'])\n                        if record['OldValue'] == '':\n                            record['OldValue'] = 'None'.encode('utf-16le')\n                        elif record['NewValue'] == '':\n                            record['NewValue'] = 'None'.encode('utf-16le')\n                        if key['Type'] == TDS_ENVCHANGE_DATABASE:\n                            _type = 'DATABASE'\n                        elif key['Type'] == TDS_ENVCHANGE_LANGUAGE:\n                            _type = 'LANGUAGE'\n                        elif key['Type'] == TDS_ENVCHANGE_CHARSET:\n                            _type = 'CHARSET'\n                        elif key['Type'] == TDS_ENVCHANGE_PACKETSIZE:\n                            _type = 'PACKETSIZE'\n                        else:\n                            _type = \"%d\" % key['Type']                 \n                        LOG.info(\"ENVCHANGE(%s): Old Value: %s, New Value: %s\" % (_type,record['OldValue'].decode('utf-16le'), record['NewValue'].decode('utf-16le')))",
  "def parseRow(self,token,tuplemode=False):\n        # TODO: This REALLY needs to be improved. Right now we don't support correctly all the data types\n        # help would be appreciated ;) \n        if len(token) == 1:\n            return 0\n\n        row = [] if tuplemode else {}\n\n        origDataLen = len(token['Data'])\n        data = token['Data']\n        for col in self.colMeta:\n            _type = col['Type']\n            if (_type == TDS_NVARCHARTYPE) |\\\n               (_type == TDS_NCHARTYPE):\n                #print \"NVAR 0x%x\" % _type\n                charLen = struct.unpack('<H',data[:struct.calcsize('<H')])[0]\n                data = data[struct.calcsize('<H'):]\n                if charLen != 0xFFFF:\n                    value = data[:charLen].decode('utf-16le')\n                    data = data[charLen:]\n                else:\n                    value = 'NULL'\n\n            elif _type == TDS_BIGVARCHRTYPE:\n                charLen = struct.unpack('<H',data[:struct.calcsize('<H')])[0]\n                data = data[struct.calcsize('<H'):]\n                if charLen != 0xFFFF:\n                    value = data[:charLen]\n                    data = data[charLen:]\n                else:\n                    value = 'NULL'\n\n            elif _type == TDS_GUIDTYPE:\n                uuidLen = ord(data[0:1])\n                data = data[1:]\n                if uuidLen > 0:\n                    uu = data[:uuidLen]\n                    value = uuid.bin_to_string(uu)\n                    data = data[uuidLen:]\n                else:\n                    value = 'NULL'\n                \n            elif (_type == TDS_NTEXTTYPE) |\\\n                 (_type == TDS_IMAGETYPE) :\n                # Skip the pointer data\n                charLen = ord(data[0:1])\n                if charLen == 0:\n                    value = 'NULL'\n                    data = data[1:]\n                else:\n                    data = data[1+charLen+8:]\n                    charLen = struct.unpack('<L',data[:struct.calcsize('<L')])[0]\n                    data = data[struct.calcsize('<L'):]\n                    if charLen != 0xFFFF:\n                        if _type == TDS_NTEXTTYPE:\n                            value = data[:charLen].decode('utf-16le')\n                        else:\n                            value = binascii.b2a_hex(data[:charLen])\n                        data = data[charLen:]\n                    else:\n                        value = 'NULL'\n                \n            elif _type == TDS_TEXTTYPE:\n                # Skip the pointer data\n                charLen = ord(data[0:1])\n                if charLen == 0:\n                    value = 'NULL'\n                    data = data[1:]\n                else:\n                    data = data[1+charLen+8:]\n                    charLen = struct.unpack('<L',data[:struct.calcsize('<L')])[0]\n                    data = data[struct.calcsize('<L'):]\n                    if charLen != 0xFFFF:\n                        value = data[:charLen]\n                        data = data[charLen:]\n                    else:\n                        value = 'NULL'\n\n            elif (_type == TDS_BIGVARBINTYPE) |\\\n                 (_type == TDS_BIGBINARYTYPE):\n                charLen = struct.unpack('<H',data[:struct.calcsize('<H')])[0]\n                data = data[struct.calcsize('<H'):]\n                if charLen != 0xFFFF:\n                    value = binascii.b2a_hex(data[:charLen])\n                    data = data[charLen:]\n                else:\n                    value = 'NULL'\n\n            elif (_type == TDS_DATETIM4TYPE) |\\\n                 (_type == TDS_DATETIMNTYPE) |\\\n                 (_type == TDS_DATETIMETYPE):\n                value = ''    \n                if _type == TDS_DATETIMNTYPE:\n                    # For DATETIMNTYPE, the only valid lengths are 0x04 and 0x08, which map to smalldatetime and\n                    # datetime SQL data _types respectively.\n                    if ord(data[0:1]) == 4:\n                        _type = TDS_DATETIM4TYPE\n                    elif ord(data[0:1]) == 8:\n                        _type = TDS_DATETIMETYPE\n                    else:\n                        value = 'NULL'\n                    data = data[1:]\n                if _type == TDS_DATETIMETYPE:\n                    # datetime is represented in the following sequence:\n                    # * One 4-byte signed integer that represents the number of days since January 1, 1900. Negative\n                    #   numbers are allowed to represents dates since January 1, 1753.\n                    # * One 4-byte unsigned integer that represents the number of one three-hundredths of a second\n                    #  (300 counts per second) elapsed since 12 AM that day.\n                    dateValue = struct.unpack('<l',data[:4])[0]\n                    data = data[4:]\n                    if dateValue < 0:\n                        baseDate = datetime.date(1753,1,1)\n                    else:\n                        baseDate = datetime.date(1900,1,1)\n                    timeValue = struct.unpack('<L',data[:4])[0]\n                    data = data[4:] \n                elif _type == TDS_DATETIM4TYPE:\n                    # Small datetime\n                    # 2.2.5.5.1.8\n                    # Date/Times\n                    # smalldatetime is represented in the following sequence:\n                    # * One 2-byte unsigned integer that represents the number of days since January 1, 1900.\n                    # * One 2-byte unsigned integer that represents the number of minutes elapsed since 12 AM that\n                    #   day.\n                    dateValue = struct.unpack('<H',data[:struct.calcsize('<H')])[0]\n                    data = data[struct.calcsize('<H'):]\n                    timeValue = struct.unpack('<H',data[:struct.calcsize('<H')])[0]\n                    data = data[struct.calcsize('<H'):]\n                    baseDate = datetime.date(1900,1,1)\n                if value != 'NULL':\n                    dateValue = datetime.date.fromordinal(baseDate.toordinal() + dateValue)\n                    hours, mod = divmod(timeValue//300, 60*60)\n                    minutes, second = divmod(mod, 60)\n                    value = datetime.datetime(dateValue.year, dateValue.month, dateValue.day, hours, minutes, second)\n\n            elif (_type == TDS_INT4TYPE) |\\\n                 (_type == TDS_MONEY4TYPE) |\\\n                 (_type == TDS_FLT4TYPE):\n                #print \"INT4\"\n                value = struct.unpack('<l',data[:struct.calcsize('<l')])[0]\n                data = data[struct.calcsize('<l'):]\n\n            elif _type == TDS_FLTNTYPE:\n                valueSize = ord(data[:1])\n                if valueSize == 4:\n                    fmt = '<f'\n                elif valueSize == 8:\n                    fmt = '<d'\n\n                data = data[1:]\n\n                if valueSize > 0:\n                    value = struct.unpack(fmt,data[:valueSize])[0]\n                    data = data[valueSize:]\n                else:\n                    value = 'NULL'\n\n            elif _type == TDS_MONEYNTYPE:\n                valueSize = ord(data[:1])\n                if valueSize == 4:\n                    fmt = '<l'\n                elif valueSize == 8:\n                    fmt = '<q'\n\n                data = data[1:]\n\n                if valueSize > 0:\n                    value = struct.unpack(fmt,data[:valueSize])[0]\n                    if valueSize == 4:\n                        value = float(value) // math.pow(10,4)\n                    else:\n                        value = float(value >> 32) // math.pow(10,4)\n                    data = data[valueSize:]\n                else:\n                    value = 'NULL'\n\n                \n            elif _type == TDS_BIGCHARTYPE:\n                #print \"BIGC\"\n                charLen = struct.unpack('<H',data[:struct.calcsize('<H')])[0]\n                data = data[struct.calcsize('<H'):]\n                value = data[:charLen]\n                data = data[charLen:]\n\n            elif (_type == TDS_INT8TYPE) |\\\n                 (_type == TDS_FLT8TYPE) |\\\n                 (_type == TDS_MONEYTYPE):\n                #print \"DATETIME\"\n                value = struct.unpack('<q',data[:struct.calcsize('<q')])[0]\n                data = data[struct.calcsize('<q'):]\n\n\n            elif _type == TDS_INT2TYPE:\n                #print \"INT2TYPE\"\n                value = struct.unpack('<H',(data[:2]))[0]\n                data = data[2:]\n\n            elif _type == TDS_DATENTYPE:\n                # date is represented as one 3-byte unsigned integer that represents the number of days since\n                # January 1, year 1.\n                valueSize = ord(data[:1])\n                data = data[1:]\n                if valueSize > 0:\n                    dateBytes = data[:valueSize]\n                    dateValue = struct.unpack('<L','\\x00'+dateBytes)[0]\n                    value = datetime.date.fromtimestamp(dateValue)\n                    data = data[valueSize:]\n                else:\n                    value = 'NULL'\n\n            elif (_type == TDS_BITTYPE) |\\\n                 (_type == TDS_INT1TYPE):\n                #print \"BITTYPE\"\n                value = ord(data[:1])\n                data = data[1:]\n\n            elif (_type == TDS_NUMERICNTYPE) |\\\n                 (_type == TDS_DECIMALNTYPE):\n                valueLen = ord(data[:1])\n                data = data[1:]\n                value = data[:valueLen]\n                data = data[valueLen:]\n                precision = ord(col['TypeData'][1:2])\n                scale = ord(col['TypeData'][2:3])\n                if valueLen > 0:\n                    isPositiveSign = ord(value[0:1])\n                    if (valueLen-1) == 2:\n                        fmt = '<H'\n                    elif (valueLen-1) == 4:\n                        fmt = '<L'\n                    elif (valueLen-1) == 8:\n                        fmt = '<Q'\n                    else:\n                        # Still don't know how to handle higher values\n                        value = \"TODO: Interpret TDS_NUMERICNTYPE correctly\"\n                    number = struct.unpack(fmt, value[1:])[0]\n                    number //= math.pow(precision, scale)\n                    if isPositiveSign == 0:\n                        number *= -1 \n                    value = number\n                else:\n                    value = 'NULL'\n\n            elif _type == TDS_BITNTYPE:\n                #print \"BITNTYPE\"\n                valueSize = ord(data[:1])\n                data = data[1:]\n                if valueSize > 0:\n                    if valueSize == 1:\n                        value = ord(data[:valueSize])\n                    else:\n                        value = data[:valueSize]\n                else:\n                    value = 'NULL'\n                data = data[valueSize:]\n\n            elif _type == TDS_INTNTYPE:\n                valueSize = ord(data[:1])\n                if valueSize == 1:\n                    fmt = '<B'\n                elif valueSize == 2:\n                    fmt = '<h'\n                elif valueSize == 4:\n                    fmt = '<l'\n                elif valueSize == 8:\n                    fmt = '<q'\n                else:\n                    fmt = ''\n\n                data = data[1:]\n\n                if valueSize > 0:\n                    value = struct.unpack(fmt,data[:valueSize])[0]\n                    data = data[valueSize:]\n                else:\n                    value = 'NULL'\n            elif _type == TDS_SSVARIANTTYPE:\n                raise Exception(\"ParseRow: SQL Variant type not yet supported :(\")\n            else:\n                raise Exception(\"ParseROW: Unsupported data type: 0%x\" % _type)\n\n            if tuplemode:\n                row.append(value)\n            else:\n                row[col['Name']] = value\n\n\n        self.rows.append(row)\n\n        return origDataLen - len(data)",
  "def parseColMetaData(self, token):\n        # TODO Add support for more data types!\n        count = token['Count']\n        if count == 0xFFFF:\n            return 0\n\n        self.colMeta = []\n        origDataLen = len(token['Data'])\n        data = token['Data']\n        for i in range(count):\n            column = {}\n            userType = struct.unpack('<H',data[:struct.calcsize('<H')])[0]\n            data = data[struct.calcsize('<H'):]\n            flags = struct.unpack('<H',data[:struct.calcsize('<H')])[0]\n            data = data[struct.calcsize('<H'):]\n            colType = struct.unpack('<B',data[:struct.calcsize('<B')])[0]\n            data = data[struct.calcsize('<B'):]\n            if (colType == TDS_BITTYPE)    |\\\n                 (colType == TDS_INT1TYPE)   |\\\n                 (colType == TDS_INT2TYPE)   |\\\n                 (colType == TDS_INT8TYPE)   |\\\n                 (colType == TDS_DATETIMETYPE) |\\\n                 (colType == TDS_DATETIM4TYPE) |\\\n                 (colType == TDS_FLT4TYPE)   |\\\n                 (colType == TDS_FLT8TYPE)   |\\\n                 (colType == TDS_MONEYTYPE)  |\\\n                 (colType == TDS_MONEY4TYPE) |\\\n                 (colType == TDS_DATENTYPE)  |\\\n                 (colType == TDS_INT4TYPE):\n                typeData = ''\n            elif (colType == TDS_INTNTYPE) |\\\n                 (colType == TDS_TIMENTYPE) |\\\n                 (colType == TDS_DATETIME2NTYPE) |\\\n                 (colType == TDS_DATETIMEOFFSETNTYPE) |\\\n                 (colType == TDS_FLTNTYPE) |\\\n                 (colType == TDS_MONEYNTYPE) |\\\n                 (colType == TDS_GUIDTYPE) |\\\n                 (colType == TDS_BITNTYPE):\n                typeData = ord(data[0:1])\n                data = data[1:]\n\n            elif colType == TDS_DATETIMNTYPE:\n                # For DATETIMNTYPE, the only valid lengths are 0x04 and 0x08, which map to smalldatetime and\n                # datetime SQL data types respectively.\n                typeData = ord(data[0:1])\n                data = data[1:]\n\n            elif (colType == TDS_BIGVARBINTYPE) |\\\n                 (colType == TDS_BIGBINARYTYPE) |\\\n                 (colType == TDS_NCHARTYPE)     |\\\n                 (colType == TDS_NVARCHARTYPE)  |\\\n                 (colType == TDS_BIGVARCHRTYPE) |\\\n                 (colType == TDS_BIGCHARTYPE):\n                typeData = struct.unpack('<H',data[:2])[0]\n                data = data[2:]\n            elif (colType == TDS_DECIMALNTYPE) |\\\n                 (colType == TDS_NUMERICNTYPE) |\\\n                 (colType == TDS_DECIMALTYPE):\n                typeData = data[:3]\n                data = data[3:]\n            elif (colType == TDS_IMAGETYPE) |\\\n                 (colType == TDS_TEXTTYPE) |\\\n                 (colType == TDS_XMLTYPE)  |\\\n                 (colType == TDS_SSVARIANTTYPE) |\\\n                 (colType == TDS_NTEXTTYPE):\n                typeData = struct.unpack('<L',data[:4])[0]\n                data = data[4:]\n            else:\n                raise Exception(\"Unsupported data type: 0x%x\" % colType)\n\n            # Collation exceptions:\n            if (colType == TDS_NTEXTTYPE) |\\\n               (colType == TDS_BIGCHARTYPE)  |\\\n               (colType == TDS_BIGVARCHRTYPE)  |\\\n               (colType == TDS_NCHARTYPE)  |\\\n               (colType == TDS_NVARCHARTYPE)  |\\\n               (colType == TDS_TEXTTYPE):\n                # Skip collation\n                data = data[5:]\n\n            # PartTableName exceptions:\n            if (colType == TDS_IMAGETYPE) |\\\n               (colType == TDS_TEXTTYPE) |\\\n               (colType == TDS_NTEXTTYPE):\n                # This types have Table Elements, we just discard them for now.\n                # ToDo parse this correctly!\n                # Get the Length\n                dataLen = struct.unpack('<H',data[:2])[0]\n                data = data[2:]\n                # skip the text\n                data = data[dataLen*2:]\n\n            colNameLength = struct.unpack('<B',data[:struct.calcsize('<B')])[0]\n            data = data[struct.calcsize('<B'):]\n            colName = data[:colNameLength*2].decode('utf-16le')\n            data = data[colNameLength*2:]\n            column['Name'] = colName\n            column['Type'] = colType\n            column['TypeData'] = typeData\n            column['Flags'] = flags\n            self.colMeta.append(column)\n\n        return origDataLen - len(data)",
  "def parseReply(self, tokens,tuplemode=False):\n        if len(tokens) == 0:\n            return False\n\n        replies = {} \n        while len(tokens) > 0:\n            tokenID = struct.unpack('B',tokens[0:1])[0]\n            if tokenID == TDS_ERROR_TOKEN:\n                token = TDS_INFO_ERROR(tokens)\n            elif tokenID == TDS_RETURNSTATUS_TOKEN:\n                token = TDS_RETURNSTATUS(tokens)\n            elif tokenID == TDS_INFO_TOKEN:\n                token = TDS_INFO_ERROR(tokens)\n            elif tokenID == TDS_LOGINACK_TOKEN:\n                token = TDS_LOGIN_ACK(tokens)\n            elif tokenID == TDS_ENVCHANGE_TOKEN:\n                token = TDS_ENVCHANGE(tokens)\n                if token['Type'] is TDS_ENVCHANGE_PACKETSIZE:\n                    record = TDS_ENVCHANGE_VARCHAR(token['Data'])\n                    self.packetSize = int( record['NewValue'].decode('utf-16le') )\n                elif token['Type'] is TDS_ENVCHANGE_DATABASE:\n                    record = TDS_ENVCHANGE_VARCHAR(token['Data'])\n                    self.currentDB =  record['NewValue'].decode('utf-16le') \n\n            elif (tokenID == TDS_DONEINPROC_TOKEN) |\\\n                 (tokenID == TDS_DONEPROC_TOKEN): \n                token = TDS_DONEINPROC(tokens)\n            elif tokenID == TDS_ORDER_TOKEN:\n                token = TDS_ORDER(tokens)\n            elif tokenID == TDS_ROW_TOKEN:\n                #print \"ROW\"\n                token = TDS_ROW(tokens)\n                tokenLen = self.parseRow(token,tuplemode)\n                token['Data'] = token['Data'][:tokenLen]\n            elif tokenID == TDS_COLMETADATA_TOKEN:\n                #print \"COLMETA\"\n                token = TDS_COLMETADATA(tokens)\n                tokenLen = self.parseColMetaData(token)\n                token['Data'] = token['Data'][:tokenLen]\n            elif tokenID == TDS_DONE_TOKEN:\n                token = TDS_DONE(tokens)\n            else:\n                LOG.error(\"Unknown Token %x\" % tokenID)\n                return replies\n\n            if (tokenID in replies) is not True:\n                replies[tokenID] = list()\n\n            replies[tokenID].append(token)\n            tokens = tokens[len(token):]\n            #print \"TYPE 0x%x, LEN: %d\" %(tokenID, len(token))\n            #print repr(tokens[:10])\n\n        return replies",
  "def batch(self, cmd,tuplemode=False,wait=True):\n        # First of all we clear the rows, colMeta and lastError\n        self.rows = []\n        self.colMeta = []\n        self.lastError = False\n        self.sendTDS(TDS_SQL_BATCH, (cmd+'\\r\\n').encode('utf-16le'))\n        if wait:\n            tds = self.recvTDS()\n            self.replies = self.parseReply(tds['Data'],tuplemode)\n            return self.rows\n        else:\n            return True",
  "def batchStatement(self, cmd,tuplemode=False):\n        # First of all we clear the rows, colMeta and lastError\n        self.rows = []\n        self.colMeta = []\n        self.lastError = False\n        self.sendTDS(TDS_SQL_BATCH, (cmd+'\\r\\n').encode('utf-16le'))",
  "def changeDB(self, db):        \n        if db != self.currentDB:\n            chdb = 'use %s' % db            \n            self.batch(chdb)\n            self.printReplies()",
  "def RunSQLQuery(self,db,sql_query,tuplemode=False,wait=True,**kwArgs):\n        db = db or 'master'\n        self.changeDB(db)\n        self.printReplies()\n        ret = self.batch(sql_query,tuplemode,wait)\n        if wait:\n            self.printReplies()\n        if self.lastError:\n            raise self.lastError\n        if self.lastError:\n            raise self.lastError\n        return ret",
  "def RunSQLStatement(self,db,sql_query,wait=True,**kwArgs):\n        self.RunSQLQuery(db,sql_query,wait=wait)\n        if self.lastError:\n            raise self.lastError\n        return True",
  "def strerror(errclass, errcode):\n    if errclass == 0x01:\n        return 'OS error', ERRDOS.get(errcode, 'Unknown error')\n    elif errclass == 0x02:\n        return 'Server error', ERRSRV.get(errcode, 'Unknown error')\n    elif errclass == 0x03:\n        return 'Hardware error', ERRHRD.get(errcode, 'Unknown error')\n    # This is not a standard error class for SMB\n    #elif errclass == 0x80:\n    #    return 'Browse error', ERRBROWSE.get(errcode, 'Unknown error')\n    elif errclass == 0xff:\n        return 'Bad command', 'Bad command. Please file bug report'\n    else:\n        return 'Unknown error', 'Unknown error'",
  "class SessionError(Exception):\n    # SMB X/Open error codes for the ERRDOS error class\n    ERRsuccess                           = 0\n    ERRbadfunc                           = 1\n    ERRbadfile                           = 2\n    ERRbadpath                           = 3\n    ERRnofids                            = 4\n    ERRnoaccess                          = 5\n    ERRbadfid                            = 6\n    ERRbadmcb                            = 7\n    ERRnomem                             = 8\n    ERRbadmem                            = 9\n    ERRbadenv                            = 10\n    ERRbadaccess                         = 12\n    ERRbaddata                           = 13\n    ERRres                               = 14\n    ERRbaddrive                          = 15\n    ERRremcd                             = 16\n    ERRdiffdevice                        = 17\n    ERRnofiles                           = 18\n    ERRgeneral                           = 31\n    ERRbadshare                          = 32\n    ERRlock                              = 33\n    ERRunsup                             = 50\n    ERRnetnamedel                        = 64\n    ERRnosuchshare                       = 67\n    ERRfilexists                         = 80\n    ERRinvalidparam                      = 87\n    ERRcannotopen                        = 110\n    ERRinsufficientbuffer                = 122\n    ERRinvalidname                       = 123\n    ERRunknownlevel                      = 124\n    ERRnotlocked                         = 158\n    ERRrename                            = 183\n    ERRbadpipe                           = 230\n    ERRpipebusy                          = 231\n    ERRpipeclosing                       = 232\n    ERRnotconnected                      = 233\n    ERRmoredata                          = 234\n    ERRnomoreitems                       = 259\n    ERRbaddirectory                      = 267\n    ERReasnotsupported                   = 282\n    ERRlogonfailure                      = 1326\n    ERRbuftoosmall                       = 2123\n    ERRunknownipc                        = 2142\n    ERRnosuchprintjob                    = 2151\n    ERRinvgroup                          = 2455\n\n    # here's a special one from observing NT\n    ERRnoipc                             = 66\n\n    # These errors seem to be only returned by the NT printer driver system\n    ERRdriveralreadyinstalled            = 1795\n    ERRunknownprinterport                = 1796\n    ERRunknownprinterdriver              = 1797\n    ERRunknownprintprocessor             = 1798\n    ERRinvalidseparatorfile              = 1799\n    ERRinvalidjobpriority                = 1800\n    ERRinvalidprintername                = 1801\n    ERRprinteralreadyexists              = 1802\n    ERRinvalidprintercommand             = 1803\n    ERRinvaliddatatype                   = 1804\n    ERRinvalidenvironment                = 1805\n\n    ERRunknownprintmonitor               = 3000\n    ERRprinterdriverinuse                = 3001\n    ERRspoolfilenotfound                 = 3002\n    ERRnostartdoc                        = 3003\n    ERRnoaddjob                          = 3004\n    ERRprintprocessoralreadyinstalled    = 3005\n    ERRprintmonitoralreadyinstalled      = 3006\n    ERRinvalidprintmonitor               = 3007\n    ERRprintmonitorinuse                 = 3008\n    ERRprinterhasjobsqueued              = 3009\n\n    # Error codes for the ERRSRV class\n\n    ERRerror                             = 1\n    ERRbadpw                             = 2\n    ERRbadtype                           = 3\n    ERRaccess                            = 4\n    ERRinvnid                            = 5\n    ERRinvnetname                        = 6\n    ERRinvdevice                         = 7\n    ERRqfull                             = 49\n    ERRqtoobig                           = 50\n    ERRinvpfid                           = 52\n    ERRsmbcmd                            = 64\n    ERRsrverror                          = 65\n    ERRfilespecs                         = 67\n    ERRbadlink                           = 68\n    ERRbadpermits                        = 69\n    ERRbadpid                            = 70\n    ERRsetattrmode                       = 71\n    ERRpaused                            = 81\n    ERRmsgoff                            = 82\n    ERRnoroom                            = 83\n    ERRrmuns                             = 87\n    ERRtimeout                           = 88\n    ERRnoresource                        = 89\n    ERRtoomanyuids                       = 90\n    ERRbaduid                            = 91\n    ERRuseMPX                            = 250\n    ERRuseSTD                            = 251\n    ERRcontMPX                           = 252\n    ERRbadPW                             = None\n    ERRnosupport                         = 0\n    ERRunknownsmb                        = 22\n\n    # Error codes for the ERRHRD class\n\n    ERRnowrite                           = 19\n    ERRbadunit                           = 20\n    ERRnotready                          = 21\n    ERRbadcmd                            = 22\n    ERRdata                              = 23\n    ERRbadreq                            = 24\n    ERRseek                              = 25\n    ERRbadmedia                          = 26\n    ERRbadsector                         = 27\n    ERRnopaper                           = 28\n    ERRwrite                             = 29\n    ERRread                              = 30\n    ERRwrongdisk                         = 34\n    ERRFCBunavail                        = 35\n    ERRsharebufexc                       = 36\n    ERRdiskfull                          = 39\n\n\n    hard_msgs = {\n      19: (\"ERRnowrite\", \"Attempt to write on write-protected diskette.\"),\n      20: (\"ERRbadunit\", \"Unknown unit.\"),\n      21: (\"ERRnotready\", \"Drive not ready.\"),\n      22: (\"ERRbadcmd\", \"Unknown command.\"),\n      23: (\"ERRdata\", \"Data error (CRC).\"),\n      24: (\"ERRbadreq\", \"Bad request structure length.\"),\n      25: (\"ERRseek\", \"Seek error.\"),\n      26: (\"ERRbadmedia\", \"Unknown media type.\"),\n      27: (\"ERRbadsector\", \"Sector not found.\"),\n      28: (\"ERRnopaper\", \"Printer out of paper.\"),\n      29: (\"ERRwrite\", \"Write fault.\"),\n      30: (\"ERRread\", \"Read fault.\"),\n      31: (\"ERRgeneral\", \"General failure.\"),\n      32: (\"ERRbadshare\", \"An open conflicts with an existing open.\"),\n      33: (\"ERRlock\", \"A Lock request conflicted with an existing lock or specified an invalid mode, or an Unlock requested attempted to remove a lock held by another process.\"),\n      34: (\"ERRwrongdisk\", \"The wrong disk was found in a drive.\"),\n      35: (\"ERRFCBUnavail\", \"No FCBs are available to process request.\"),\n      36: (\"ERRsharebufexc\", \"A sharing buffer has been exceeded.\")\n      }\n\n    dos_msgs = {\n      ERRbadfunc: (\"ERRbadfunc\", \"Invalid function.\"),\n      ERRbadfile: (\"ERRbadfile\", \"File not found.\"),\n      ERRbadpath: (\"ERRbadpath\", \"Directory invalid.\"),\n      ERRnofids: (\"ERRnofids\", \"No file descriptors available\"),\n      ERRnoaccess: (\"ERRnoaccess\", \"Access denied.\"),\n      ERRbadfid: (\"ERRbadfid\", \"Invalid file handle.\"),\n      ERRbadmcb: (\"ERRbadmcb\", \"Memory control blocks destroyed.\"),\n      ERRnomem: (\"ERRnomem\", \"Insufficient server memory to perform the requested function.\"),\n      ERRbadmem: (\"ERRbadmem\", \"Invalid memory block address.\"),\n      ERRbadenv: (\"ERRbadenv\", \"Invalid environment.\"),\n      11: (\"ERRbadformat\", \"Invalid format.\"),\n      ERRbadaccess: (\"ERRbadaccess\", \"Invalid open mode.\"),\n      ERRbaddata: (\"ERRbaddata\", \"Invalid data.\"),\n      ERRres: (\"ERRres\", \"reserved.\"),\n      ERRbaddrive: (\"ERRbaddrive\", \"Invalid drive specified.\"),\n      ERRremcd: (\"ERRremcd\", \"A Delete Directory request attempted  to  remove  the  server's  current directory.\"),\n      ERRdiffdevice: (\"ERRdiffdevice\", \"Not same device.\"),\n      ERRnofiles: (\"ERRnofiles\", \"A File Search command can find no more files matching the specified criteria.\"),\n      ERRbadshare: (\"ERRbadshare\", \"The sharing mode specified for an Open conflicts with existing  FIDs  on the file.\"),\n      ERRlock: (\"ERRlock\", \"A Lock request conflicted with an existing lock or specified an  invalid mode,  or an Unlock requested attempted to remove a lock held by another process.\"),\n      ERRunsup: (\"ERRunsup\",  \"The operation is unsupported\"),\n      ERRnosuchshare: (\"ERRnosuchshare\",  \"You specified an invalid share name\"),\n      ERRfilexists: (\"ERRfilexists\", \"The file named in a Create Directory, Make  New  File  or  Link  request already exists.\"),\n      ERRinvalidname: (\"ERRinvalidname\",  \"Invalid name\"),\n      ERRbadpipe: (\"ERRbadpipe\", \"Pipe invalid.\"),\n      ERRpipebusy: (\"ERRpipebusy\", \"All instances of the requested pipe are busy.\"),\n      ERRpipeclosing: (\"ERRpipeclosing\", \"Pipe close in progress.\"),\n      ERRnotconnected: (\"ERRnotconnected\", \"No process on other end of pipe.\"),\n      ERRmoredata: (\"ERRmoredata\", \"There is more data to be returned.\"),\n      ERRinvgroup: (\"ERRinvgroup\", \"Invalid workgroup (try the -W option)\"),\n      ERRlogonfailure: (\"ERRlogonfailure\", \"Logon failure\"),\n      ERRdiskfull: (\"ERRdiskfull\", \"Disk full\"),\n      ERRgeneral: (\"ERRgeneral\",  \"General failure\"),\n      ERRunknownlevel: (\"ERRunknownlevel\",  \"Unknown info level\")\n      }\n\n    server_msgs = {\n      1: (\"ERRerror\", \"Non-specific error code.\"),\n      2: (\"ERRbadpw\", \"Bad password - name/password pair in a Tree Connect or Session Setup are invalid.\"),\n      3: (\"ERRbadtype\", \"reserved.\"),\n      4: (\"ERRaccess\", \"The requester does not have  the  necessary  access  rights  within  the specified  context for the requested function. The context is defined by the TID or the UID.\"),\n      5: (\"ERRinvnid\", \"The tree ID (TID) specified in a command was invalid.\"),\n      6: (\"ERRinvnetname\", \"Invalid network name in tree connect.\"),\n      7: (\"ERRinvdevice\", \"Invalid device - printer request made to non-printer connection or  non-printer request made to printer connection.\"),\n      49: (\"ERRqfull\", \"Print queue full (files) -- returned by open print file.\"),\n      50: (\"ERRqtoobig\", \"Print queue full -- no space.\"),\n      51: (\"ERRqeof\", \"EOF on print queue dump.\"),\n      52: (\"ERRinvpfid\", \"Invalid print file FID.\"),\n      64: (\"ERRsmbcmd\", \"The server did not recognize the command received.\"),\n      65: (\"ERRsrverror\",\"The server encountered an internal error, e.g., system file unavailable.\"),\n      67: (\"ERRfilespecs\", \"The file handle (FID) and pathname parameters contained an invalid  combination of values.\"),\n      68: (\"ERRreserved\", \"reserved.\"),\n      69: (\"ERRbadpermits\", \"The access permissions specified for a file or directory are not a valid combination.  The server cannot set the requested attribute.\"),\n      70: (\"ERRreserved\", \"reserved.\"),\n      71: (\"ERRsetattrmode\", \"The attribute mode in the Set File Attribute request is invalid.\"),\n      81: (\"ERRpaused\", \"Server is paused.\"),\n      82: (\"ERRmsgoff\", \"Not receiving messages.\"),\n      83: (\"ERRnoroom\", \"No room to buffer message.\"),\n      87: (\"ERRrmuns\", \"Too many remote user names.\"),\n      88: (\"ERRtimeout\", \"Operation timed out.\"),\n      89: (\"ERRnoresource\", \"No resources currently available for request.\"),\n      90: (\"ERRtoomanyuids\", \"Too many UIDs active on this session.\"),\n      91: (\"ERRbaduid\", \"The UID is not known as a valid ID on this session.\"),\n      250: (\"ERRusempx\",\"Temp unable to support Raw, use MPX mode.\"),\n      251: (\"ERRusestd\",\"Temp unable to support Raw, use standard read/write.\"),\n      252: (\"ERRcontmpx\", \"Continue in MPX mode.\"),\n      253: (\"ERRreserved\", \"reserved.\"),\n      254: (\"ERRreserved\", \"reserved.\"),\n  0xFFFF: (\"ERRnosupport\", \"Function not supported.\")\n  }\n    # Error clases\n\n    ERRDOS = 0x1\n    error_classes = { 0: (\"SUCCESS\", {}),\n                      ERRDOS: (\"ERRDOS\", dos_msgs),\n                      0x02: (\"ERRSRV\",server_msgs),\n                      0x03: (\"ERRHRD\",hard_msgs),\n                      0x04: (\"ERRXOS\", {} ),\n                      0xE1: (\"ERRRMX1\", {} ),\n                      0xE2: (\"ERRRMX2\", {} ),\n                      0xE3: (\"ERRRMX3\", {} ),\n                      0xFF: (\"ERRCMD\", {} ) }\n\n\n\n    def __init__( self, error_string, error_class, error_code, nt_status = 0, packet=0):\n        Exception.__init__(self, error_string)\n        self.nt_status = nt_status\n        self._args = error_string\n        if nt_status:\n           self.error_class = 0\n           self.error_code  = (error_code << 16) + error_class\n        else:\n           self.error_class = error_class\n           self.error_code = error_code\n        self.packet = packet\n\n    def get_error_class( self ):\n        return self.error_class\n\n    def get_error_code( self ):\n        return self.error_code\n\n    def get_error_packet(self):\n        return self.packet\n\n    def __str__( self ):\n        error_class = SessionError.error_classes.get( self.error_class, None )\n        if not error_class:\n            error_code_str = self.error_code\n            error_class_str = self.error_class\n        else:\n            error_class_str = error_class[0]\n            error_code = error_class[1].get( self.error_code, None )\n            if not error_code:\n                error_code_str = self.error_code\n            else:\n                error_code_str = '%s(%s)' % error_code\n\n        if self.nt_status:\n            return 'SMB SessionError: %s(%s)' % nt_errors.ERROR_MESSAGES[self.error_code]\n        else:\n            # Fall back to the old format\n            return 'SMB SessionError: class: %s, code: %s' % (error_class_str, error_code_str)",
  "class UnsupportedFeature(Exception):\n    pass",
  "class SharedDevice:\n    def __init__(self, name, share_type, comment):\n        self.__name = name\n        self.__type = share_type\n        self.__comment = comment\n\n    def get_name(self):\n        return self.__name\n\n    def get_type(self):\n        return self.__type\n\n    def get_comment(self):\n        return self.__comment\n\n    def __repr__(self):\n        return '<SharedDevice instance: name=' + self.__name + ', type=' + str(self.__type) + ', comment=\"' + self.__comment + '\">'",
  "class SharedFile:\n    def __init__(self, ctime, atime, mtime, filesize, allocsize, attribs, shortname, longname):\n        self.__ctime = ctime\n        self.__atime = atime\n        self.__mtime = mtime\n        self.__filesize = filesize\n        self.__allocsize = allocsize\n        self.__attribs = attribs\n        try:\n            if isinstance(shortname,bytes):\n                self.__shortname = shortname[:shortname.index(b'\\0')]\n            else:\n                self.__shortname = shortname[:shortname.index('\\0')]\n        except (ValueError, TypeError):\n            self.__shortname = shortname\n        try:\n            if isinstance(shortname,bytes):\n                self.__longname = longname[:longname.index(b'\\0')]\n            else:\n                self.__longname = longname[:longname.index('\\0')]\n        except (ValueError, TypeError):\n            self.__longname = longname\n\n    def get_ctime(self):\n        return self.__ctime\n\n    def get_ctime_epoch(self):\n        return self.__convert_smbtime(self.__ctime)\n\n    def get_mtime(self):\n        return self.__mtime\n\n    def get_mtime_epoch(self):\n        return self.__convert_smbtime(self.__mtime)\n\n    def get_atime(self):\n        return self.__atime\n\n    def get_atime_epoch(self):\n        return self.__convert_smbtime(self.__atime)\n\n    def get_filesize(self):\n        return self.__filesize\n\n    def get_allocsize(self):\n        return self.__allocsize\n\n    def get_attributes(self):\n        return self.__attribs\n\n    def is_archive(self):\n        return self.__attribs & ATTR_ARCHIVE\n\n    def is_compressed(self):\n        return self.__attribs & ATTR_COMPRESSED\n\n    def is_normal(self):\n        return self.__attribs & ATTR_NORMAL\n\n    def is_hidden(self):\n        return self.__attribs & ATTR_HIDDEN\n\n    def is_readonly(self):\n        return self.__attribs & ATTR_READONLY\n\n    def is_temporary(self):\n        return self.__attribs & ATTR_TEMPORARY\n\n    def is_directory(self):\n        return self.__attribs & ATTR_DIRECTORY\n\n    def is_system(self):\n        return self.__attribs & ATTR_SYSTEM\n\n    def get_shortname(self):\n        return self.__shortname\n\n    def get_longname(self):\n        return self.__longname\n\n    def __repr__(self):\n        return '<SharedFile instance: shortname=\"' + self.__shortname + '\", longname=\"' + self.__longname + '\", filesize=' + str(self.__filesize) + '>'\n\n    @staticmethod\n    def __convert_smbtime(t):\n        x = t >> 32\n        y = t & 0xffffffff\n        geo_cal_offset = 11644473600.0  # = 369.0 * 365.25 * 24 * 60 * 60 - (3.0 * 24 * 60 * 60 + 6.0 * 60 * 60)\n        return (x * 4.0 * (1 << 30) + (y & 0xfff00000)) * 1.0e-7 - geo_cal_offset",
  "class SMBMachine:\n    def __init__(self, nbname, nbt_type, comment):\n        self.__nbname = nbname\n        self.__type = nbt_type\n        self.__comment = comment\n\n    def __repr__(self):\n        return '<SMBMachine instance: nbname=\"' + self.__nbname + '\", type=' + hex(self.__type) + ', comment=\"' + self.__comment + '\">'",
  "class SMBDomain:\n    def __init__(self, nbgroup, domain_type, master_browser):\n        self.__nbgroup = nbgroup\n        self.__type = domain_type\n        self.__master_browser = master_browser\n\n    def __repr__(self):\n        return '<SMBDomain instance: nbgroup=\"' + self.__nbgroup + '\", type=' + hex(self.__type) + ', master browser=\"' + self.__master_browser + '\">'",
  "class NewSMBPacket(Structure):\n    structure = (\n        ('Signature', '\"\\xffSMB'),\n        ('Command','B=0'),\n        ('ErrorClass','B=0'),\n        ('_reserved','B=0'),\n        ('ErrorCode','<H=0'),\n        ('Flags1','B=0'),\n        ('Flags2','<H=0'),\n        ('PIDHigh','<H=0'),\n        ('SecurityFeatures','8s=\"\"'),\n        ('Reserved','<H=0'),\n        ('Tid','<H=0xffff'),\n        ('Pid','<H=0'),\n        ('Uid','<H=0'),\n        ('Mid','<H=0'),\n        ('Data','*:'),\n    )\n\n    def __init__(self, **kargs):\n        Structure.__init__(self, **kargs)\n\n        if ('Flags2' in self.fields) is False:\n             self['Flags2'] = 0\n        if ('Flags1' in self.fields) is False:\n             self['Flags1'] = 0\n\n        if 'data' not in kargs:\n            self['Data'] = []\n\n    def addCommand(self, command):\n        if len(self['Data']) == 0:\n            self['Command'] = command.command\n        else:\n            self['Data'][-1]['Parameters']['AndXCommand'] = command.command\n            self['Data'][-1]['Parameters']['AndXOffset'] = len(self)\n        self['Data'].append(command)\n\n    def isMoreData(self):\n        return (self['Command'] in [SMB.SMB_COM_TRANSACTION, SMB.SMB_COM_READ_ANDX, SMB.SMB_COM_READ_RAW] and\n                self['ErrorClass'] == 1 and self['ErrorCode'] == SessionError.ERRmoredata)\n\n    def isMoreProcessingRequired(self):\n        return self['ErrorClass'] == 0x16 and self['ErrorCode'] == 0xc000\n\n    def isValidAnswer(self, cmd):\n        # this was inside a loop reading more from the net (with recv_packet(None))\n        if self['Command'] == cmd:\n            if (self['ErrorClass'] == 0x00 and self['ErrorCode']  == 0x00):\n                    return 1\n            elif self.isMoreData():\n                return 1\n            elif self.isMoreProcessingRequired():\n                return 1\n            raise SessionError(\"SMB Library Error\", self['ErrorClass'] + (self['_reserved'] << 8), self['ErrorCode'], self['Flags2'] & SMB.FLAGS2_NT_STATUS, self)\n        else:\n            raise UnsupportedFeature(\"Unexpected answer from server: Got %d, Expected %d\" % (self['Command'], cmd))",
  "class SMBCommand(Structure):\n    structure = (\n        ('WordCount', 'B=len(Parameters)//2'),\n        ('_ParametersLength','_-Parameters','WordCount*2'),\n        ('Parameters',':'),             # default set by constructor\n        ('ByteCount','<H-Data'),\n        ('Data',':'),                   # default set by constructor\n    )\n\n    def __init__(self, commandOrData = None, data = None, **kargs):\n        if type(commandOrData) == type(0):\n            self.command = commandOrData\n        else:\n            data = data or commandOrData\n\n        Structure.__init__(self, data = data, **kargs)\n\n        if data is None:\n            self['Parameters'] = ''\n            self['Data']       = ''",
  "class AsciiOrUnicodeStructure(Structure):\n    UnicodeStructure = ()\n    AsciiStructure   = ()\n    def __init__(self, flags = 0, **kargs):\n        if flags & SMB.FLAGS2_UNICODE:\n            self.structure = self.UnicodeStructure\n        else:\n            self.structure = self.AsciiStructure\n        Structure.__init__(self, **kargs)",
  "class SMBCommand_Parameters(Structure):\n    pass",
  "class SMBAndXCommand_Parameters(Structure):\n    commonHdr = (\n        ('AndXCommand','B=0xff'),\n        ('_reserved','B=0'),\n        ('AndXOffset','<H=0'),\n    )\n    structure = (       # default structure, overridden by subclasses\n        ('Data',':=\"\"'),\n    )",
  "class SMBQueryFsAttributeInfo(Structure):\n    structure = (\n        ('FileSystemAttributes','<L'),\n        ('MaxFilenNameLengthInBytes','<L'),\n        ('LengthOfFileSystemName','<L-FileSystemName'),\n        ('FileSystemName',':'),\n    )",
  "class SMBQueryFsInfoVolume(AsciiOrUnicodeStructure):\n    commonHdr = (\n        ('ulVolSerialNbr','<L=0xABCDEFAA'),\n        ('cCharCount','<B-VolumeLabel'),\n    )\n    AsciiStructure = (\n        ('VolumeLabel','z'),\n    )\n    UnicodeStructure = (\n        ('VolumeLabel','u'),\n    )",
  "class FileFsSizeInformation(Structure):\n    structure = (\n        ('TotalAllocationUnits','<q=148529400'),\n        ('AvailableAllocationUnits','<q=14851044'),\n        ('SectorsPerAllocationUnit','<L=2'),\n        ('BytesPerSector','<L=512'),\n    )",
  "class SMBQueryFsSizeInfo(Structure):\n    structure = (\n        ('TotalAllocationUnits','<q=148529400'),\n        ('TotalFreeAllocationUnits','<q=14851044'),\n        ('SectorsPerAllocationUnit','<L=2'),\n        ('BytesPerSector','<L=512'),\n    )",
  "class SMBFileFsFullSizeInformation(Structure):\n    structure = (\n        ('TotalAllocationUnits','<q=148529400'),\n        ('CallerAvailableAllocationUnits','<q=148529400'),\n        ('ActualAvailableAllocationUnits','<q=148529400'),\n        ('SectorsPerAllocationUnit','<L=15'),\n        ('BytesPerSector','<L=512')\n    )",
  "class SMBQueryFsVolumeInfo(Structure):\n    structure = (\n        ('VolumeCreationTime','<q'),\n        ('SerialNumber','<L=0xABCDEFAA'),\n        ('VolumeLabelSize','<L=len(VolumeLabel)'),\n        ('Reserved','<H=0x10'),\n        ('VolumeLabel',':')\n    )",
  "class SMBQueryFsDeviceInfo(Structure):\n    structure = (\n        ('DeviceType', '<L=0'),\n        ('DeviceCharacteristics', '<L=0')\n    )",
  "class SMBFindFileBothDirectoryInfo(AsciiOrUnicodeStructure):\n    commonHdr = (\n        ('NextEntryOffset','<L=0'),\n        ('FileIndex','<L=0'),\n        ('CreationTime','<q'),\n        ('LastAccessTime','<q'),\n        ('LastWriteTime','<q'),\n        ('LastChangeTime','<q'),\n        ('EndOfFile','<q=0'),\n        ('AllocationSize','<q=0'),\n        ('ExtFileAttributes','<L=0'),\n    )\n    AsciiStructure = (\n        ('FileNameLength','<L-FileName','len(FileName)'),\n        ('EaSize','<L=0'),\n        ('ShortNameLength','<B=0'),\n        ('Reserved','<B=0'),\n        ('ShortName','24s'),\n        ('FileName',':'),\n    )\n    UnicodeStructure = (\n        ('FileNameLength','<L-FileName','len(FileName)*2'),\n        ('EaSize','<L=0'),\n        ('ShortNameLength','<B=0'),\n        ('Reserved','<B=0'),\n        ('ShortName','24s'),\n        ('FileName',':'),\n    )",
  "class SMBFindFileIdFullDirectoryInfo(AsciiOrUnicodeStructure):\n    commonHdr = (\n        ('NextEntryOffset','<L=0'),\n        ('FileIndex','<L=0'),\n        ('CreationTime','<q'),\n        ('LastAccessTime','<q'),\n        ('LastWriteTime','<q'),\n        ('LastChangeTime','<q'),\n        ('EndOfFile','<q=0'),\n        ('AllocationSize','<q=0'),\n        ('ExtFileAttributes','<L=0'),\n    )\n    AsciiStructure = (\n        ('FileNameLength','<L-FileName','len(FileName)'),\n        ('EaSize','<L=0'),\n        ('Reserved', '<L=0'),\n        ('FileID','<q=0'),\n        ('FileName','z'),\n    )\n    UnicodeStructure = (\n        ('FileNameLength','<L-FileName','len(FileName)*2'),\n        ('EaSize','<L=0'),\n        ('Reserved','<L=0'),\n        ('FileID','<q=0'),\n        ('FileName',':'),\n    )",
  "class SMBFindFileIdBothDirectoryInfo(AsciiOrUnicodeStructure):\n    commonHdr = (\n        ('NextEntryOffset','<L=0'),\n        ('FileIndex','<L=0'),\n        ('CreationTime','<q'),\n        ('LastAccessTime','<q'),\n        ('LastWriteTime','<q'),\n        ('LastChangeTime','<q'),\n        ('EndOfFile','<q=0'),\n        ('AllocationSize','<q=0'),\n        ('ExtFileAttributes','<L=0'),\n    )\n    AsciiStructure = (\n        ('FileNameLength','<L-FileName','len(FileName)'),\n        ('EaSize','<L=0'),\n        ('ShortNameLength','<B=0'),\n        ('Reserved','<B=0'),\n        ('ShortName','24s'),\n        ('Reserved','<H=0'),\n        ('FileID','<q=0'),\n        ('FileName','z'),\n    )\n    UnicodeStructure = (\n        ('FileNameLength','<L-FileName','len(FileName)*2'),\n        ('EaSize','<L=0'),\n        ('ShortNameLength','<B=0'),\n        ('Reserved','<B=0'),\n        ('ShortName','24s'),\n        ('Reserved','<H=0'),\n        ('FileID','<q=0'),\n        ('FileName',':'),\n    )",
  "class SMBFindFileDirectoryInfo(AsciiOrUnicodeStructure):\n    commonHdr = (\n        ('NextEntryOffset','<L=0'),\n        ('FileIndex','<L=0'),\n        ('CreationTime','<q'),\n        ('LastAccessTime','<q'),\n        ('LastWriteTime','<q'),\n        ('LastChangeTime','<q'),\n        ('EndOfFile','<q=0'),\n        ('AllocationSize','<q=1'),\n        ('ExtFileAttributes','<L=0'),\n    )\n    AsciiStructure = (\n        ('FileNameLength','<L-FileName','len(FileName)'),\n        ('FileName','z'),\n    )\n    UnicodeStructure = (\n        ('FileNameLength','<L-FileName','len(FileName)*2'),\n        ('FileName',':'),\n    )",
  "class SMBFindFileNamesInfo(AsciiOrUnicodeStructure):\n    commonHdr = (\n        ('NextEntryOffset','<L=0'),\n        ('FileIndex','<L=0'),\n    )\n    AsciiStructure = (\n        ('FileNameLength','<L-FileName','len(FileName)'),\n        ('FileName','z'),\n    )\n    UnicodeStructure = (\n        ('FileNameLength','<L-FileName','len(FileName)*2'),\n        ('FileName',':'),\n    )",
  "class SMBFindFileFullDirectoryInfo(AsciiOrUnicodeStructure):\n    commonHdr = (\n        ('NextEntryOffset','<L=0'),\n        ('FileIndex','<L=0'),\n        ('CreationTime','<q'),\n        ('LastAccessTime','<q'),\n        ('LastWriteTime','<q'),\n        ('LastChangeTime','<q'),\n        ('EndOfFile','<q=0'),\n        ('AllocationSize','<q=1'),\n        ('ExtFileAttributes','<L=0'),\n    )\n    AsciiStructure = (\n        ('FileNameLength','<L-FileName','len(FileName)'),\n        ('EaSize','<L'),\n        ('FileName','z'),\n    )\n    UnicodeStructure = (\n        ('FileNameLength','<L-FileName','len(FileName)*2'),\n        ('EaSize','<L'),\n        ('FileName',':'),\n    )",
  "class SMBFindInfoStandard(AsciiOrUnicodeStructure):\n    commonHdr = (\n        ('ResumeKey','<L=0xff'),\n        ('CreationDate','<H=0'),\n        ('CreationTime','<H=0'),\n        ('LastAccessDate','<H=0'),\n        ('LastAccessTime','<H=0'),\n        ('LastWriteDate','<H=0'),\n        ('LastWriteTime','<H=0'),\n        ('EaSize','<L'),\n        ('AllocationSize','<L=1'),\n        ('ExtFileAttributes','<H=0'),\n    )\n    AsciiStructure = (\n        ('FileNameLength','<B-FileName','len(FileName)'),\n        ('FileName','z'),\n    )\n    UnicodeStructure = (\n        ('FileNameLength','<B-FileName','len(FileName)*2'),\n        ('FileName',':'),\n    )",
  "class SMBSetFileDispositionInfo(Structure):\n    structure = (\n        ('DeletePending','<B'),\n    )",
  "class SMBSetFileBasicInfo(Structure):\n    structure = (\n        ('CreationTime','<q'),\n        ('LastAccessTime','<q'),\n        ('LastWriteTime','<q'),\n        ('ChangeTime','<q'),\n        ('ExtFileAttributes','<H'),\n        ('Reserved','<L'),\n    )",
  "class SMBFileStreamInformation(Structure):\n    commonHdr = (\n        ('NextEntryOffset','<L=0'),\n        ('StreamNameLength','<L=0'),\n        ('StreamSize','<q=0'),\n        ('StreamAllocationSize','<q=0'),\n        ('StreamName',':=\"\"'),\n    )",
  "class SMBFileNetworkOpenInfo(Structure):\n    structure = (\n        ('CreationTime','<q=0'),\n        ('LastAccessTime','<q=0'),\n        ('LastWriteTime','<q=0'),\n        ('ChangeTime','<q=0'),\n        ('AllocationSize','<q=0'),\n        ('EndOfFile','<q=0'),\n        ('FileAttributes','<L=0'),\n        ('Reserved','<L=0'),\n    )",
  "class SMBSetFileEndOfFileInfo(Structure):\n    structure = (\n        ('EndOfFile','<q'),\n    )",
  "class SMBFindNext2_Parameters(AsciiOrUnicodeStructure):\n     commonHdr = (\n         ('SID','<H'),\n         ('SearchCount','<H'),\n         ('InformationLevel','<H'),\n         ('ResumeKey','<L'),\n         ('Flags','<H'),\n     )\n     AsciiStructure = (\n         ('FileName','z'),\n     )\n     UnicodeStructure = (\n         ('FileName','u'),\n     )",
  "class SMBFindNext2Response_Parameters(Structure):\n     structure = (\n         ('SearchCount','<H'),\n         ('EndOfSearch','<H=1'),\n         ('EaErrorOffset','<H=0'),\n         ('LastNameOffset','<H=0'),\n     )",
  "class SMBFindNext2_Data(Structure):\n     structure = (\n         ('GetExtendedAttributesListLength','_-GetExtendedAttributesList', 'self[\"GetExtendedAttributesListLength\"]'),\n         ('GetExtendedAttributesList',':'),\n     )",
  "class SMBFindFirst2Response_Parameters(Structure):\n     structure = (\n         ('SID','<H'),\n         ('SearchCount','<H'),\n         ('EndOfSearch','<H=1'),\n         ('EaErrorOffset','<H=0'),\n         ('LastNameOffset','<H=0'),\n     )",
  "class SMBFindFirst2_Parameters(AsciiOrUnicodeStructure):\n     commonHdr = (\n         ('SearchAttributes','<H'),\n         ('SearchCount','<H'),\n         ('Flags','<H'),\n         ('InformationLevel','<H'),\n         ('SearchStorageType','<L'),\n     )\n     AsciiStructure = (\n         ('FileName','z'),\n     )\n     UnicodeStructure = (\n         ('FileName','u'),\n     )",
  "class SMBFindFirst2_Data(Structure):\n     structure = (\n         ('GetExtendedAttributesListLength','_-GetExtendedAttributesList', 'self[\"GetExtendedAttributesListLength\"]'),\n         ('GetExtendedAttributesList',':'),\n     )",
  "class SMBSetPathInformation_Parameters(AsciiOrUnicodeStructure):\n    commonHdr = (\n        ('InformationLevel','<H'),\n        ('Reserved','<L'),\n    )\n    AsciiStructure = (\n        ('FileName','z'),\n    )\n    UnicodeStructure = (\n        ('FileName','u'),\n    )",
  "class SMBSetPathInformationResponse_Parameters(Structure):\n    structure = (\n        ('EaErrorOffset','<H=0'),\n    )",
  "class SMBSetFileInformation_Parameters(Structure):\n    structure = (\n        ('FID','<H'),\n        ('InformationLevel','<H'),\n        ('Reserved','<H'),\n    )",
  "class SMBSetFileInformationResponse_Parameters(Structure):\n    structure = (\n        ('EaErrorOffset','<H=0'),\n    )",
  "class SMBQueryFileInformation_Parameters(Structure):\n    structure = (\n        ('FID','<H'),\n        ('InformationLevel','<H'),\n    )",
  "class SMBQueryFileInformationResponse_Parameters(Structure):\n    structure = (\n        ('EaErrorOffset','<H=0'),\n    )",
  "class SMBQueryFileInformation_Data(Structure):\n    structure = (\n        ('GetExtendedAttributeList',':'),\n    )",
  "class SMBQueryPathInformationResponse_Parameters(Structure):\n    structure = (\n        ('EaErrorOffset','<H=0'),\n    )",
  "class SMBQueryPathInformation_Parameters(AsciiOrUnicodeStructure):\n    commonHdr = (\n        ('InformationLevel','<H'),\n        ('Reserved','<L=0'),\n    )\n    AsciiStructure = (\n        ('FileName','z'),\n    )\n    UnicodeStructure = (\n        ('FileName','u'),\n    )",
  "class SMBQueryPathInformation_Data(Structure):\n    structure = (\n        ('GetExtendedAttributeList',':'),\n    )",
  "class SMBQueryFileEaInfo(Structure):\n    structure = (\n        ('EaSize','<L=0'),\n    )",
  "class SMBQueryFileBasicInfo(Structure):\n    structure = (\n        ('CreationTime','<q'),\n        ('LastAccessTime','<q'),\n        ('LastWriteTime','<q'),\n        ('LastChangeTime','<q'),\n        ('ExtFileAttributes','<L'),\n        #('Reserved','<L=0'),\n    )",
  "class SMBQueryFileStandardInfo(Structure):\n    structure = (\n        ('AllocationSize','<q'),\n        ('EndOfFile','<q'),\n        ('NumberOfLinks','<L=0'),\n        ('DeletePending','<B=0'),\n        ('Directory','<B'),\n    )",
  "class SMBQueryFileAllInfo(Structure):\n    structure = (\n        ('CreationTime','<q'),\n        ('LastAccessTime','<q'),\n        ('LastWriteTime','<q'),\n        ('LastChangeTime','<q'),\n        ('ExtFileAttributes','<L'),\n        ('Reserved','<L=0'),\n        ('AllocationSize','<q'),\n        ('EndOfFile','<q'),\n        ('NumberOfLinks','<L=0'),\n        ('DeletePending','<B=0'),\n        ('Directory','<B'),\n        ('Reserved','<H=0'),\n        ('EaSize','<L=0'),\n        ('FileNameLength','<L-FileName','len(FileName)'),\n        ('FileName',':'),\n    )",
  "class SMBNetShareEnum(Structure):\n    structure = (\n        ('RAPOpcode','<H=0'),\n        ('ParamDesc','z'),\n        ('DataDesc','z'),\n        ('InfoLevel','<H'),\n        ('ReceiveBufferSize','<H'),\n    )",
  "class SMBNetShareEnumResponse(Structure):\n    structure = (\n        ('Status','<H=0'),\n        ('Convert','<H=0'),\n        ('EntriesReturned','<H'),\n        ('EntriesAvailable','<H'),\n    )",
  "class NetShareInfo1(Structure):\n    structure = (\n        ('NetworkName','13s'),\n        ('Pad','<B=0'),\n        ('Type','<H=0'),\n        ('RemarkOffsetLow','<H=0'),\n        ('RemarkOffsetHigh','<H=0'),\n    )",
  "class SMBNetServerGetInfoResponse(Structure):\n    structure = (\n        ('Status','<H=0'),\n        ('Convert','<H=0'),\n        ('TotalBytesAvailable','<H'),\n    )",
  "class SMBNetServerInfo1(Structure):\n    # Level 1 Response\n    structure = (\n        ('ServerName','16s'),\n        ('MajorVersion','B=5'),\n        ('MinorVersion','B=0'),\n        ('ServerType','<L=3'),\n        ('ServerCommentLow','<H=0'),\n        ('ServerCommentHigh','<H=0'),\n    )",
  "class SMBNetShareGetInfo(Structure):\n    structure = (\n        ('RAPOpcode','<H=0'),\n        ('ParamDesc','z'),\n        ('DataDesc','z'),\n        ('ShareName','z'),\n        ('InfoLevel','<H'),\n        ('ReceiveBufferSize','<H'),\n    )",
  "class SMBNetShareGetInfoResponse(Structure):\n    structure = (\n        ('Status','<H=0'),\n        ('Convert','<H=0'),\n        ('TotalBytesAvailable','<H'),\n    )",
  "class SecurityFeatures(Structure):\n    structure = (\n        ('Key','<L=0'),\n        ('CID','<H=0'),\n        ('SequenceNumber','<H=0'),\n    )",
  "class SMBQueryInformation2_Parameters(Structure):\n    structure = (\n        ('Fid','<H'),\n    )",
  "class SMBQueryInformation2Response_Parameters(Structure):\n    structure = (\n        ('CreateDate','<H'),\n        ('CreationTime','<H'),\n        ('LastAccessDate','<H'),\n        ('LastAccessTime','<H'),\n        ('LastWriteDate','<H'),\n        ('LastWriteTime','<H'),\n        ('FileDataSize','<L'),\n        ('FileAllocationSize','<L'),\n        ('FileAttributes','<L'),\n    )",
  "class SMBSessionSetupAndX_Parameters(SMBAndXCommand_Parameters):\n    structure = (\n        ('MaxBuffer','<H'),\n        ('MaxMpxCount','<H'),\n        ('VCNumber','<H'),\n        ('SessionKey','<L'),\n        ('AnsiPwdLength','<H'),\n        ('UnicodePwdLength','<H'),\n        ('_reserved','<L=0'),\n        ('Capabilities','<L'),\n    )",
  "class SMBSessionSetupAndX_Extended_Parameters(SMBAndXCommand_Parameters):\n    structure = (\n        ('MaxBufferSize','<H'),\n        ('MaxMpxCount','<H'),\n        ('VcNumber','<H'),\n        ('SessionKey','<L'),\n        ('SecurityBlobLength','<H'),\n        ('Reserved','<L=0'),\n        ('Capabilities','<L'),\n    )",
  "class SMBSessionSetupAndX_Data(AsciiOrUnicodeStructure):\n    AsciiStructure = (\n        ('AnsiPwdLength','_-AnsiPwd','self[\"AnsiPwdLength\"]'),\n        ('UnicodePwdLength','_-UnicodePwd','self[\"UnicodePwdLength\"]'),\n        ('AnsiPwd',':=\"\"'),\n        ('UnicodePwd',':=\"\"'),\n        ('Account','z=\"\"'),\n        ('PrimaryDomain','z=\"\"'),\n        ('NativeOS','z=\"\"'),\n        ('NativeLanMan','z=\"\"'),\n    )\n\n    UnicodeStructure = (\n        ('AnsiPwdLength','_-AnsiPwd','self[\"AnsiPwdLength\"]'),\n        ('UnicodePwdLength','_-UnicodePwd','self[\"UnicodePwdLength\"]'),\n        ('AnsiPwd',':=\"\"'),\n        ('UnicodePwd',':=\"\"'),\n        ('Account','u=\"\"'),\n        ('PrimaryDomain','u=\"\"'),\n        ('NativeOS','u=\"\"'),\n        ('NativeLanMan','u=\"\"'),\n    )",
  "class SMBSessionSetupAndX_Extended_Data(AsciiOrUnicodeStructure):\n    AsciiStructure = (\n        ('SecurityBlobLength','_-SecurityBlob','self[\"SecurityBlobLength\"]'),\n        ('SecurityBlob',':'),\n        ('NativeOS','z=\"\"'),\n        ('NativeLanMan','z=\"\"'),\n    )\n\n    UnicodeStructure = (\n        ('SecurityBlobLength','_-SecurityBlob','self[\"SecurityBlobLength\"]'),\n        ('SecurityBlob',':'),\n        ('NativeOS','u=\"\"'),\n        ('NativeLanMan','u=\"\"'),\n    )",
  "class SMBSessionSetupAndXResponse_Parameters(SMBAndXCommand_Parameters):\n    structure = (\n        ('Action','<H'),\n    )",
  "class SMBSessionSetupAndX_Extended_Response_Parameters(SMBAndXCommand_Parameters):\n    structure = (\n        ('Action','<H=0'),\n        ('SecurityBlobLength','<H'),\n    )",
  "class SMBSessionSetupAndXResponse_Data(AsciiOrUnicodeStructure):\n    AsciiStructure = (\n        ('NativeOS','z=\"\"'),\n        ('NativeLanMan','z=\"\"'),\n        ('PrimaryDomain','z=\"\"'),\n    )\n\n    UnicodeStructure = (\n        ('NativeOS','u=\"\"'),\n        ('NativeLanMan','u=\"\"'),\n        ('PrimaryDomain','u=\"\"'),\n    )",
  "class SMBSessionSetupAndX_Extended_Response_Data(AsciiOrUnicodeStructure):\n    AsciiStructure = (\n        ('SecurityBlobLength','_-SecurityBlob','self[\"SecurityBlobLength\"]'),\n        ('SecurityBlob',':'),\n        ('NativeOS','z=\"\"'),\n        ('NativeLanMan','z=\"\"'),\n    )\n\n    UnicodeStructure = (\n        ('SecurityBlobLength','_-SecurityBlob','self[\"SecurityBlobLength\"]'),\n        ('SecurityBlob',':'),\n        ('PadLen','_-Pad','1 if (len(self[\"SecurityBlob\"]) % 2 == 0) else 0'),\n        ('Pad',':=\"\"'),\n        ('NativeOS','u=\"\"'),\n        ('NativeLanMan','u=\"\"'),\n    )\n    def getData(self):\n        if self.structure == self.UnicodeStructure:\n            if len(str(self['SecurityBlob'])) % 2 == 0:\n                self['Pad'] = '\\x00'\n        return AsciiOrUnicodeStructure.getData(self)",
  "class SMBTreeConnect_Parameters(SMBCommand_Parameters):\n    structure = (\n    )",
  "class SMBTreeConnect_Data(SMBCommand_Parameters):\n    structure = (\n        ('PathFormat','\"\\x04'),\n        ('Path','z'),\n        ('PasswordFormat','\"\\x04'),\n        ('Password','z'),\n        ('ServiceFormat','\"\\x04'),\n        ('Service','z'),\n    )",
  "class SMBTreeConnectAndX_Parameters(SMBAndXCommand_Parameters):\n    structure = (\n        ('Flags','<H=0'),\n        ('PasswordLength','<H'),\n    )",
  "class SMBTreeConnectAndXResponse_Parameters(SMBAndXCommand_Parameters):\n    structure = (\n        ('OptionalSupport','<H=0'),\n    )",
  "class SMBTreeConnectAndXExtendedResponse_Parameters(SMBAndXCommand_Parameters):\n    structure = (\n        ('OptionalSupport','<H=1'),\n        ('MaximalShareAccessRights','<L=0x1fffff'),\n        ('GuestMaximalShareAccessRights','<L=0x1fffff'),\n    )",
  "class SMBTreeConnectAndX_Data(AsciiOrUnicodeStructure):\n    AsciiStructure = (\n        ('_PasswordLength','_-Password','self[\"_PasswordLength\"]'),\n        ('Password',':'),\n        ('Path','z'),\n        ('Service','z'),\n    )\n\n    UnicodeStructure = (\n        ('_PasswordLength','_-Password','self[\"_PasswordLength\"] if self[\"_PasswordLength\"] > 0 else 1'),\n        ('Password',':'),\n        ('Path','u'),\n        ('Service','z'),\n    )",
  "class SMBTreeConnectAndXResponse_Data(AsciiOrUnicodeStructure):\n    AsciiStructure = (\n        ('Service','z'),\n        ('PadLen','_-Pad','self[\"PadLen\"]'),\n        ('Pad',':=\"\"'),\n        ('NativeFileSystem','z'),\n    )\n    UnicodeStructure = (\n        ('Service','z'),\n        ('PadLen','_-Pad','self[\"PadLen\"]'),\n        ('Pad',':=\"\"'),\n        ('NativeFileSystem','u'),\n    )",
  "class SMBNtCreateAndX_Parameters(SMBAndXCommand_Parameters):\n    structure = (\n        ('_reserved', 'B=0'),\n        ('FileNameLength','<H'),     # NameLength\n        ('CreateFlags','<L'),        # Flags\n        ('RootFid','<L=0'),          # RootDirectoryFID\n        ('AccessMask','<L'),         # DesiredAccess\n        ('AllocationSizeLo','<L=0'), # AllocationSize\n        ('AllocationSizeHi','<L=0'),\n        ('FileAttributes','<L=0'),   # ExtFileAttributes\n        ('ShareAccess','<L=3'),      #\n        ('Disposition','<L=1'),      # CreateDisposition\n        ('CreateOptions','<L'),      # CreateOptions\n        ('Impersonation','<L=2'),\n        ('SecurityFlags','B=3'),\n    )",
  "class SMBNtCreateAndXResponse_Parameters(SMBAndXCommand_Parameters):\n    # XXX Is there a memory leak in the response for NTCreate (where the Data section would be) in Win 2000, Win XP, and Win 2003?\n    structure = (\n        ('OplockLevel', 'B=0'),\n        ('Fid','<H'),\n        ('CreateAction','<L'),\n        ('CreateTime','<q=0'),\n        ('LastAccessTime','<q=0'),\n        ('LastWriteTime','<q=0'),\n        ('LastChangeTime','<q=0'),\n        ('FileAttributes','<L=0x80'),\n        ('AllocationSize','<q=0'),\n        ('EndOfFile','<q=0'),\n        ('FileType','<H=0'),\n        ('IPCState','<H=0'),\n        ('IsDirectory','B'),\n    )",
  "class SMBNtCreateAndXExtendedResponse_Parameters(SMBAndXCommand_Parameters):\n    # [MS-SMB] Extended response description\n    structure = (\n        ('OplockLevel', 'B=0'),\n        ('Fid','<H'),\n        ('CreateAction','<L'),\n        ('CreateTime','<q=0'),\n        ('LastAccessTime','<q=0'),\n        ('LastWriteTime','<q=0'),\n        ('LastChangeTime','<q=0'),\n        ('FileAttributes','<L=0x80'),\n        ('AllocationSize','<q=0'),\n        ('EndOfFile','<q=0'),\n        ('FileType','<H=0'),\n        ('IPCState','<H=0'),\n        ('IsDirectory','B'),\n        ('VolumeGUID','16s'),\n        ('FileIdLow','<L=0'),\n        ('FileIdHigh','<L=0'),\n        ('MaximalAccessRights','<L=0x12019b'),\n        ('GuestMaximalAccessRights','<L=0x120089'),\n    )",
  "class SMBNtCreateAndX_Data(AsciiOrUnicodeStructure):\n    AsciiStructure = (\n        ('FileName','z'),\n    )\n    UnicodeStructure = (\n        ('Pad','B'),\n        ('FileName','u'),\n    )",
  "class SMBOpenAndX_Parameters(SMBAndXCommand_Parameters):\n    structure = (\n        ('Flags','<H=0'),\n        ('DesiredAccess','<H=0'),\n        ('SearchAttributes','<H=0'),\n        ('FileAttributes','<H=0'),\n        ('CreationTime','<L=0'),\n        ('OpenMode','<H=1'),        # SMB_O_OPEN = 1\n        ('AllocationSize','<L=0'),\n        ('Reserved','8s=\"\"'),\n    )",
  "class SMBOpenAndX_Data(SMBNtCreateAndX_Data):\n    pass",
  "class SMBOpenAndXResponse_Parameters(SMBAndXCommand_Parameters):\n    structure = (\n        ('Fid','<H=0'),\n        ('FileAttributes','<H=0'),\n        ('LastWriten','<L=0'),\n        ('FileSize','<L=0'),\n        ('GrantedAccess','<H=0'),\n        ('FileType','<H=0'),\n        ('IPCState','<H=0'),\n        ('Action','<H=0'),\n        ('ServerFid','<L=0'),\n        ('_reserved','<H=0'),\n    )",
  "class SMBWrite_Parameters(SMBCommand_Parameters):\n    structure = (\n        ('Fid','<H'),\n        ('Count','<H'),\n        ('Offset','<L'),\n        ('Remaining','<H'),\n    )",
  "class SMBWriteResponse_Parameters(SMBCommand_Parameters):\n    structure = (\n        ('Count','<H'),\n    )",
  "class SMBWrite_Data(Structure):\n    structure = (\n        ('BufferFormat','<B=1'),\n        ('DataLength','<H-Data'),\n        ('Data',':'),\n    )",
  "class SMBWriteAndX_Parameters(SMBAndXCommand_Parameters):\n    structure = (\n        ('Fid','<H=0'),\n        ('Offset','<L=0'),\n        ('_reserved','<L=0xff'),\n        ('WriteMode','<H=8'),\n        ('Remaining','<H=0'),\n        ('DataLength_Hi','<H=0'),\n        ('DataLength','<H=0'),\n        ('DataOffset','<H=0'),\n        ('HighOffset','<L=0'),\n    )",
  "class SMBWriteAndX_Data_Short(Structure):\n     structure = (\n         ('_PadLen','_-Pad','self[\"DataOffset\"] - 59'),\n         ('Pad',':'),\n         #('Pad','<B=0'),\n         ('DataLength','_-Data','self[\"DataLength\"]'),\n         ('Data',':'),\n     )",
  "class SMBWriteAndX_Data(Structure):\n     structure = (\n         ('_PadLen','_-Pad','self[\"DataOffset\"] - 63'),\n         ('Pad',':'),\n         #('Pad','<B=0'),\n         ('DataLength','_-Data','self[\"DataLength\"]'),\n         ('Data',':'),\n     )",
  "class SMBWriteAndX_Parameters_Short(SMBAndXCommand_Parameters):\n    structure = (\n        ('Fid','<H'),\n        ('Offset','<L'),\n        ('_reserved','<L=0xff'),\n        ('WriteMode','<H=8'),\n        ('Remaining','<H'),\n        ('DataLength_Hi','<H=0'),\n        ('DataLength','<H'),\n        ('DataOffset','<H=0'),\n    )",
  "class SMBWriteAndXResponse_Parameters(SMBAndXCommand_Parameters):\n    structure = (\n        ('Count','<H'),\n        ('Available','<H'),\n        ('Reserved','<L=0'),\n    )",
  "class SMBWriteRaw_Parameters(SMBCommand_Parameters):\n    structure = (\n        ('Fid','<H'),\n        ('Count','<H'),\n        ('_reserved','<H=0'),\n        ('Offset','<L'),\n        ('Timeout','<L=0'),\n        ('WriteMode','<H=0'),\n        ('_reserved2','<L=0'),\n        ('DataLength','<H'),\n        ('DataOffset','<H=0'),\n    )",
  "class SMBRead_Parameters(SMBCommand_Parameters):\n    structure = (\n        ('Fid','<H'),\n        ('Count','<H'),\n        ('Offset','<L'),\n        ('Remaining','<H=Count'),\n    )",
  "class SMBReadResponse_Parameters(Structure):\n    structure = (\n        ('Count','<H=0'),\n        ('_reserved','8s=\"\"'),\n    )",
  "class SMBReadResponse_Data(Structure):\n    structure = (\n        ('BufferFormat','<B=0x1'),\n        ('DataLength','<H-Data'),\n        ('Data',':'),\n    )",
  "class SMBReadRaw_Parameters(SMBCommand_Parameters):\n    structure = (\n        ('Fid','<H'),\n        ('Offset','<L'),\n        ('MaxCount','<H'),\n        ('MinCount','<H=MaxCount'),\n        ('Timeout','<L=0'),\n        ('_reserved','<H=0'),\n    )",
  "class SMBNTTransaction_Parameters(SMBCommand_Parameters):\n    structure = (\n        ('MaxSetupCount','<B=0'),\n        ('Reserved1','<H=0'),\n        ('TotalParameterCount','<L'),\n        ('TotalDataCount','<L'),\n        ('MaxParameterCount','<L=1024'),\n        ('MaxDataCount','<L=65504'),\n        ('ParameterCount','<L'),\n        ('ParameterOffset','<L'),\n        ('DataCount','<L'),\n        ('DataOffset','<L'),\n        ('SetupCount','<B=len(Setup)//2'),\n        ('Function','<H=0'),\n        ('SetupLength','_-Setup','SetupCount*2'),\n        ('Setup',':'),\n    )",
  "class SMBNTTransactionResponse_Parameters(SMBCommand_Parameters):\n    structure = (\n        ('Reserved1','3s=\"\"'),\n        ('TotalParameterCount','<L'),\n        ('TotalDataCount','<L'),\n        ('ParameterCount','<L'),\n        ('ParameterOffset','<L'),\n        ('ParameterDisplacement','<L=0'),\n        ('DataCount','<L'),\n        ('DataOffset','<L'),\n        ('DataDisplacement','<L=0'),\n        ('SetupCount','<B=0'),\n        ('SetupLength','_-Setup','SetupCount*2'),\n        ('Setup',':'),\n    )",
  "class SMBNTTransaction_Data(Structure):\n    structure = (\n        ('Pad1Length','_-Pad1','self[\"Pad1Length\"]'),\n        ('Pad1',':'),\n        ('NT_Trans_ParametersLength','_-NT_Trans_Parameters','self[\"NT_Trans_ParametersLength\"]'),\n        ('NT_Trans_Parameters',':'),\n        ('Pad2Length','_-Pad2','self[\"Pad2Length\"]'),\n        ('Pad2',':'),\n        ('NT_Trans_DataLength','_-NT_Trans_Data','self[\"NT_Trans_DataLength\"]'),\n        ('NT_Trans_Data',':'),\n    )",
  "class SMBNTTransactionResponse_Data(Structure):\n    structure = (\n        ('Pad1Length','_-Pad1','self[\"Pad1Length\"]'),\n        ('Pad1',':'),\n        ('Trans_ParametersLength','_-Trans_Parameters','self[\"Trans_ParametersLength\"]'),\n        ('Trans_Parameters',':'),\n        ('Pad2Length','_-Pad2','self[\"Pad2Length\"]'),\n        ('Pad2',':'),\n        ('Trans_DataLength','_-Trans_Data','self[\"Trans_DataLength\"]'),\n        ('Trans_Data',':'),\n    )",
  "class SMBTransaction2Secondary_Parameters(SMBCommand_Parameters):\n    structure = (\n        ('TotalParameterCount','<H'),\n        ('TotalDataCount','<H'),\n        ('ParameterCount','<H'),\n        ('ParameterOffset','<H'),\n        ('ParameterDisplacement','<H'),\n        ('DataCount','<H'),\n        ('DataOffset','<H'),\n        ('DataDisplacement','<H=0'),\n        ('FID','<H'),\n    )",
  "class SMBTransaction2Secondary_Data(Structure):\n    structure = (\n        ('Pad1Length','_-Pad1','self[\"Pad1Length\"]'),\n        ('Pad1',':'),\n        ('Trans_ParametersLength','_-Trans_Parameters','self[\"Trans_ParametersLength\"]'),\n        ('Trans_Parameters',':'),\n        ('Pad2Length','_-Pad2','self[\"Pad2Length\"]'),\n        ('Pad2',':'),\n        ('Trans_DataLength','_-Trans_Data','self[\"Trans_DataLength\"]'),\n        ('Trans_Data',':'),\n    )",
  "class SMBTransaction2_Parameters(SMBCommand_Parameters):\n    structure = (\n        ('TotalParameterCount','<H'),\n        ('TotalDataCount','<H'),\n        ('MaxParameterCount','<H=1024'),\n        ('MaxDataCount','<H=65504'),\n        ('MaxSetupCount','<B=0'),\n        ('Reserved1','<B=0'),\n        ('Flags','<H=0'),\n        ('Timeout','<L=0'),\n        ('Reserved2','<H=0'),\n        ('ParameterCount','<H'),\n        ('ParameterOffset','<H'),\n        ('DataCount','<H'),\n        ('DataOffset','<H'),\n        ('SetupCount','<B=len(Setup)//2'),\n        ('Reserved3','<B=0'),\n        ('SetupLength','_-Setup','SetupCount*2'),\n        ('Setup',':'),\n    )",
  "class SMBTransaction2Response_Parameters(SMBCommand_Parameters):\n    structure = (\n        ('TotalParameterCount','<H'),\n        ('TotalDataCount','<H'),\n        ('Reserved1','<H=0'),\n        ('ParameterCount','<H'),\n        ('ParameterOffset','<H'),\n        ('ParameterDisplacement','<H=0'),\n        ('DataCount','<H'),\n        ('DataOffset','<H'),\n        ('DataDisplacement','<H=0'),\n        ('SetupCount','<B=0'),\n        ('Reserved2','<B=0'),\n        ('SetupLength','_-Setup','SetupCount*2'),\n        ('Setup',':'),\n    )",
  "class SMBTransaction2_Data(Structure):\n    structure = (\n#        ('NameLength','_-Name','1'),\n#        ('Name',':'),\n        ('Pad1Length','_-Pad1','self[\"Pad1Length\"]'),\n        ('Pad1',':'),\n        ('Trans_ParametersLength','_-Trans_Parameters','self[\"Trans_ParametersLength\"]'),\n        ('Trans_Parameters',':'),\n        ('Pad2Length','_-Pad2','self[\"Pad2Length\"]'),\n        ('Pad2',':'),\n        ('Trans_DataLength','_-Trans_Data','self[\"Trans_DataLength\"]'),\n        ('Trans_Data',':'),\n    )",
  "class SMBTransaction2Response_Data(Structure):\n    structure = (\n        ('Pad1Length','_-Pad1','self[\"Pad1Length\"]'),\n        ('Pad1',':'),\n        ('Trans_ParametersLength','_-Trans_Parameters','self[\"Trans_ParametersLength\"]'),\n        ('Trans_Parameters',':'),\n        ('Pad2Length','_-Pad2','self[\"Pad2Length\"]'),\n        ('Pad2',':'),\n        ('Trans_DataLength','_-Trans_Data','self[\"Trans_DataLength\"]'),\n        ('Trans_Data',':'),\n    )",
  "class SMBQueryInformation_Data(AsciiOrUnicodeStructure):\n    AsciiStructure = (\n        ('BufferFormat','B=4'),\n        ('FileName','z'),\n    )\n    UnicodeStructure = (\n        ('BufferFormat','B=4'),\n        ('FileName','u'),\n    )",
  "class SMBQueryInformationResponse_Parameters(Structure):\n    structure = (\n        ('FileAttributes','<H'),\n        ('LastWriteTime','<L'),\n        ('FileSize','<L'),\n        ('Reserved','\"0123456789'),\n    )",
  "class SMBTransaction_Parameters(SMBCommand_Parameters):\n    structure = (\n        ('TotalParameterCount','<H'),\n        ('TotalDataCount','<H'),\n        ('MaxParameterCount','<H=1024'),\n        ('MaxDataCount','<H=65504'),\n        ('MaxSetupCount','<B=0'),\n        ('Reserved1','<B=0'),\n        ('Flags','<H=0'),\n        ('Timeout','<L=0'),\n        ('Reserved2','<H=0'),\n        ('ParameterCount','<H'),\n        ('ParameterOffset','<H'),\n        ('DataCount','<H'),\n        ('DataOffset','<H'),\n        ('SetupCount','<B=len(Setup)//2'),\n        ('Reserved3','<B=0'),\n        ('SetupLength','_-Setup','SetupCount*2'),\n        ('Setup',':'),\n    )",
  "class SMBTransactionResponse_Parameters(SMBCommand_Parameters):\n    structure = (\n        ('TotalParameterCount','<H'),\n        ('TotalDataCount','<H'),\n        ('Reserved1','<H=0'),\n        ('ParameterCount','<H'),\n        ('ParameterOffset','<H'),\n        ('ParameterDisplacement','<H=0'),\n        ('DataCount','<H'),\n        ('DataOffset','<H'),\n        ('DataDisplacement','<H=0'),\n        ('SetupCount','<B'),\n        ('Reserved2','<B=0'),\n        ('SetupLength','_-Setup','SetupCount*2'),\n        ('Setup',':'),\n    )",
  "class SMBTransaction_SData(AsciiOrUnicodeStructure):\n    AsciiStructure = (\n        ('Name','z'),\n        ('Trans_ParametersLength','_-Trans_Parameters'),\n        ('Trans_Parameters',':'),\n        ('Trans_DataLength','_-Trans_Data'),\n        ('Trans_Data',':'),\n    )\n    UnicodeStructure = (\n        ('Pad','B'),\n        ('Name','u'),\n        ('Trans_ParametersLength','_-Trans_Parameters'),\n        ('Trans_Parameters',':'),\n        ('Trans_DataLength','_-Trans_Data'),\n        ('Trans_Data',':'),\n    )",
  "class SMBTransaction_Data(Structure):\n    structure = (\n        ('NameLength','_-Name'),\n        ('Name',':'),\n        ('Trans_ParametersLength','_-Trans_Parameters'),\n        ('Trans_Parameters',':'),\n        ('Trans_DataLength','_-Trans_Data'),\n        ('Trans_Data',':'),\n    )",
  "class SMBTransactionResponse_Data(Structure):\n    structure = (\n        ('Trans_ParametersLength','_-Trans_Parameters'),\n        ('Trans_Parameters',':'),\n        ('Trans_DataLength','_-Trans_Data'),\n        ('Trans_Data',':'),\n    )",
  "class SMBReadAndX_Parameters(SMBAndXCommand_Parameters):\n    structure = (\n        ('Fid','<H'),\n        ('Offset','<L'),\n        ('MaxCount','<H'),\n        ('MinCount','<H=MaxCount'),\n        ('_reserved','<L=0x0'),\n        ('Remaining','<H=MaxCount'),\n        ('HighOffset','<L=0'),\n    )",
  "class SMBReadAndX_Parameters2(SMBAndXCommand_Parameters):\n    structure = (\n        ('Fid','<H'),\n        ('Offset','<L'),\n        ('MaxCount','<H'),\n        ('MinCount','<H=MaxCount'),\n        ('_reserved','<L=0xffffffff'),\n        ('Remaining','<H=MaxCount'),\n    )",
  "class SMBReadAndXResponse_Parameters(SMBAndXCommand_Parameters):\n    structure = (\n        ('Remaining','<H=0'),\n        ('DataMode','<H=0'),\n        ('_reserved','<H=0'),\n        ('DataCount','<H'),\n        ('DataOffset','<H'),\n        ('DataCount_Hi','<L'),\n        ('_reserved2','6s=\"\"'),\n    )",
  "class SMBEcho_Data(Structure):\n    structure = (\n        ('Data',':'),\n    )",
  "class SMBEcho_Parameters(Structure):\n    structure = (\n        ('EchoCount','<H'),\n    )",
  "class SMBEchoResponse_Data(Structure):\n    structure = (\n        ('Data',':'),\n    )",
  "class SMBEchoResponse_Parameters(Structure):\n    structure = (\n        ('SequenceNumber','<H=1'),\n    )",
  "class SMBQueryInformationDiskResponse_Parameters(Structure):\n    structure = (\n        ('TotalUnits','<H'),\n        ('BlocksPerUnit','<H'),\n        ('BlockSize','<H'),\n        ('FreeUnits','<H'),\n        ('Reserved','<H=0'),\n    )",
  "class SMBLogOffAndX(SMBAndXCommand_Parameters):\n    structure = ()",
  "class SMBClose_Parameters(SMBCommand_Parameters):\n   structure = (\n        ('FID','<H'),\n        ('Time','<L=0'),\n   )",
  "class SMBFlush_Parameters(SMBCommand_Parameters):\n   structure = (\n        ('FID','<H'),\n   )",
  "class SMBCreateDirectory_Data(AsciiOrUnicodeStructure):\n    AsciiStructure = (\n        ('BufferFormat','<B=4'),\n        ('DirectoryName','z'),\n    )\n    UnicodeStructure = (\n        ('BufferFormat','<B=4'),\n        ('DirectoryName','u'),\n    )",
  "class SMBDelete_Data(AsciiOrUnicodeStructure):\n    AsciiStructure = (\n        ('BufferFormat','<B=4'),\n        ('FileName','z'),\n    )\n    UnicodeStructure = (\n        ('BufferFormat','<B=4'),\n        ('FileName','u'),\n    )",
  "class SMBDelete_Parameters(Structure):\n    structure = (\n        ('SearchAttributes','<H'),\n    )",
  "class SMBDeleteDirectory_Data(AsciiOrUnicodeStructure):\n    AsciiStructure = (\n        ('BufferFormat','<B=4'),\n        ('DirectoryName','z'),\n    )\n    UnicodeStructure = (\n        ('BufferFormat','<B=4'),\n        ('DirectoryName','u'),\n    )",
  "class SMBCheckDirectory_Data(AsciiOrUnicodeStructure):\n    AsciiStructure = (\n        ('BufferFormat','<B=4'),\n        ('DirectoryName','z'),\n    )\n    UnicodeStructure = (\n        ('BufferFormat','<B=4'),\n        ('DirectoryName','u'),\n    )",
  "class SMBRename_Parameters(SMBCommand_Parameters):\n    structure = (\n        ('SearchAttributes','<H'),\n    )",
  "class SMBRename_Data(AsciiOrUnicodeStructure):\n    AsciiStructure = (\n        ('BufferFormat1','<B=4'),\n        ('OldFileName','z'),\n        ('BufferFormat2','<B=4'),\n        ('NewFileName','z'),\n    )\n    UnicodeStructure = (\n        ('BufferFormat1','<B=4'),\n        ('OldFileName','u'),\n        ('BufferFormat2','<B=4'),\n        ('Pad','B=0'),\n        ('NewFileName','u'),\n    )",
  "class SMBOpen_Parameters(SMBCommand_Parameters):\n    structure = (\n        ('DesiredAccess','<H=0'),\n        ('SearchAttributes','<H=0'),\n    )",
  "class SMBOpen_Data(AsciiOrUnicodeStructure):\n    AsciiStructure = (\n        ('FileNameFormat','\"\\x04'),\n        ('FileName','z'),\n    )\n    UnicodeStructure = (\n        ('FileNameFormat','\"\\x04'),\n        ('FileName','u'),\n    )",
  "class SMBOpenResponse_Parameters(SMBCommand_Parameters):\n    structure = (\n        ('Fid','<H=0'),\n        ('FileAttributes','<H=0'),\n        ('LastWriten','<L=0'),\n        ('FileSize','<L=0'),\n        ('GrantedAccess','<H=0'),\n    )",
  "class SMBExtended_Security_Parameters(Structure):\n    structure = (\n        ('DialectIndex','<H'),\n        ('SecurityMode','<B'),\n        ('MaxMpxCount','<H'),\n        ('MaxNumberVcs','<H'),\n        ('MaxBufferSize','<L'),\n        ('MaxRawSize','<L'),\n        ('SessionKey','<L'),\n        ('Capabilities','<L'),\n        ('LowDateTime','<L'),\n        ('HighDateTime','<L'),\n        ('ServerTimeZone','<H'),\n        ('ChallengeLength','<B'),\n    )",
  "class SMBExtended_Security_Data(Structure):\n    structure = (\n        ('ServerGUID','16s'),\n        ('SecurityBlob',':'),\n    )",
  "class SMBNTLMDialect_Parameters(Structure):\n    structure = (\n        ('DialectIndex','<H'),\n        ('SecurityMode','<B'),\n        ('MaxMpxCount','<H'),\n        ('MaxNumberVcs','<H'),\n        ('MaxBufferSize','<L'),\n        ('MaxRawSize','<L'),\n        ('SessionKey','<L'),\n        ('Capabilities','<L'),\n        ('LowDateTime','<L'),\n        ('HighDateTime','<L'),\n        ('ServerTimeZone','<H'),\n        ('ChallengeLength','<B'),\n    )",
  "class SMBNTLMDialect_Data(Structure):\n    structure = (\n        ('ChallengeLength','_-Challenge','self[\"ChallengeLength\"]'),\n        ('Challenge',':'),\n        ('Payload',':'),\n# For some reason on an old Linux this field is not present, we have to check this out. There must be a flag stating this.\n        ('DomainName','_'),\n        ('ServerName','_'),\n    )\n    def __init__(self,data = None, alignment = 0):\n         Structure.__init__(self,data,alignment)\n         #self['ChallengeLength']=8\n\n    def fromString(self,data):\n        Structure.fromString(self,data)\n        self['DomainName'] = ''\n        self['ServerName'] = ''",
  "class SMB(object):\n\n    class HostnameValidationException(Exception):\n        pass\n\n    # SMB Command Codes\n    SMB_COM_CREATE_DIRECTORY                = 0x00\n    SMB_COM_DELETE_DIRECTORY                = 0x01\n    SMB_COM_OPEN                            = 0x02\n    SMB_COM_CREATE                          = 0x03\n    SMB_COM_CLOSE                           = 0x04\n    SMB_COM_FLUSH                           = 0x05\n    SMB_COM_DELETE                          = 0x06\n    SMB_COM_RENAME                          = 0x07\n    SMB_COM_QUERY_INFORMATION               = 0x08\n    SMB_COM_SET_INFORMATION                 = 0x09\n    SMB_COM_READ                            = 0x0A\n    SMB_COM_WRITE                           = 0x0B\n    SMB_COM_LOCK_BYTE_RANGE                 = 0x0C\n    SMB_COM_UNLOCK_BYTE_RANGE               = 0x0D\n    SMB_COM_CREATE_TEMPORARY                = 0x0E\n    SMB_COM_CREATE_NEW                      = 0x0F\n    SMB_COM_CHECK_DIRECTORY                 = 0x10\n    SMB_COM_PROCESS_EXIT                    = 0x11\n    SMB_COM_SEEK                            = 0x12\n    SMB_COM_LOCK_AND_READ                   = 0x13\n    SMB_COM_WRITE_AND_UNLOCK                = 0x14\n    SMB_COM_READ_RAW                        = 0x1A\n    SMB_COM_READ_MPX                        = 0x1B\n    SMB_COM_READ_MPX_SECONDARY              = 0x1C\n    SMB_COM_WRITE_RAW                       = 0x1D\n    SMB_COM_WRITE_MPX                       = 0x1E\n    SMB_COM_WRITE_MPX_SECONDARY             = 0x1F\n    SMB_COM_WRITE_COMPLETE                  = 0x20\n    SMB_COM_QUERY_SERVER                    = 0x21\n    SMB_COM_SET_INFORMATION2                = 0x22\n    SMB_COM_QUERY_INFORMATION2              = 0x23\n    SMB_COM_LOCKING_ANDX                    = 0x24\n    SMB_COM_TRANSACTION                     = 0x25\n    SMB_COM_TRANSACTION_SECONDARY           = 0x26\n    SMB_COM_IOCTL                           = 0x27\n    SMB_COM_IOCTL_SECONDARY                 = 0x28\n    SMB_COM_COPY                            = 0x29\n    SMB_COM_MOVE                            = 0x2A\n    SMB_COM_ECHO                            = 0x2B\n    SMB_COM_WRITE_AND_CLOSE                 = 0x2C\n    SMB_COM_OPEN_ANDX                       = 0x2D\n    SMB_COM_READ_ANDX                       = 0x2E\n    SMB_COM_WRITE_ANDX                      = 0x2F\n    SMB_COM_NEW_FILE_SIZE                   = 0x30\n    SMB_COM_CLOSE_AND_TREE_DISC             = 0x31\n    SMB_COM_TRANSACTION2                    = 0x32\n    SMB_COM_TRANSACTION2_SECONDARY          = 0x33\n    SMB_COM_FIND_CLOSE2                     = 0x34\n    SMB_COM_FIND_NOTIFY_CLOSE               = 0x35\n    # Used by Xenix/Unix 0x60 - 0x6E\n    SMB_COM_TREE_CONNECT                    = 0x70\n    SMB_COM_TREE_DISCONNECT                 = 0x71\n    SMB_COM_NEGOTIATE                       = 0x72\n    SMB_COM_SESSION_SETUP_ANDX              = 0x73\n    SMB_COM_LOGOFF_ANDX                     = 0x74\n    SMB_COM_TREE_CONNECT_ANDX               = 0x75\n    SMB_COM_QUERY_INFORMATION_DISK          = 0x80\n    SMB_COM_SEARCH                          = 0x81\n    SMB_COM_FIND                            = 0x82\n    SMB_COM_FIND_UNIQUE                     = 0x83\n    SMB_COM_FIND_CLOSE                      = 0x84\n    SMB_COM_NT_TRANSACT                     = 0xA0\n    SMB_COM_NT_TRANSACT_SECONDARY           = 0xA1\n    SMB_COM_NT_CREATE_ANDX                  = 0xA2\n    SMB_COM_NT_CANCEL                       = 0xA4\n    SMB_COM_NT_RENAME                       = 0xA5\n    SMB_COM_OPEN_PRINT_FILE                 = 0xC0\n    SMB_COM_WRITE_PRINT_FILE                = 0xC1\n    SMB_COM_CLOSE_PRINT_FILE                = 0xC2\n    SMB_COM_GET_PRINT_QUEUE                 = 0xC3\n    SMB_COM_READ_BULK                       = 0xD8\n    SMB_COM_WRITE_BULK                      = 0xD9\n    SMB_COM_WRITE_BULK_DATA                 = 0xDA\n\n    # TRANSACT codes\n    TRANS_TRANSACT_NMPIPE                   = 0x26\n\n    # TRANSACT2 codes\n    TRANS2_FIND_FIRST2                      = 0x0001\n    TRANS2_FIND_NEXT2                       = 0x0002\n    TRANS2_QUERY_FS_INFORMATION             = 0x0003\n    TRANS2_QUERY_PATH_INFORMATION           = 0x0005\n    TRANS2_QUERY_FILE_INFORMATION           = 0x0007\n    TRANS2_SET_FILE_INFORMATION             = 0x0008\n    TRANS2_SET_PATH_INFORMATION             = 0x0006\n\n    # Security Share Mode (Used internally by SMB class)\n    SECURITY_SHARE_MASK                     = 0x01\n    SECURITY_SHARE_SHARE                    = 0x00\n    SECURITY_SHARE_USER                     = 0x01\n    SECURITY_SIGNATURES_ENABLED             = 0X04\n    SECURITY_SIGNATURES_REQUIRED            = 0X08\n\n    # Security Auth Mode (Used internally by SMB class)\n    SECURITY_AUTH_MASK                      = 0x02\n    SECURITY_AUTH_ENCRYPTED                 = 0x02\n    SECURITY_AUTH_PLAINTEXT                 = 0x00\n\n    # Raw Mode Mask (Used internally by SMB class. Good for dialect up to and including LANMAN2.1)\n    RAW_READ_MASK                           = 0x01\n    RAW_WRITE_MASK                          = 0x02\n\n    # Capabilities Mask (Used internally by SMB class. Good for dialect NT LM 0.12)\n    CAP_RAW_MODE                            = 0x00000001\n    CAP_MPX_MODE                            = 0x0002\n    CAP_UNICODE                             = 0x0004\n    CAP_LARGE_FILES                         = 0x0008\n    CAP_EXTENDED_SECURITY                   = 0x80000000\n    CAP_USE_NT_ERRORS                       = 0x40\n    CAP_NT_SMBS                             = 0x10\n    CAP_LARGE_READX                         = 0x00004000\n    CAP_LARGE_WRITEX                        = 0x00008000\n    CAP_RPC_REMOTE_APIS                     = 0x20\n\n    # Flags1 Mask\n    FLAGS1_LOCK_AND_READ_OK                 = 0x01\n    FLAGS1_PATHCASELESS                     = 0x08\n    FLAGS1_CANONICALIZED_PATHS              = 0x10\n    FLAGS1_REPLY                            = 0x80\n\n    # Flags2 Mask\n    FLAGS2_LONG_NAMES                       = 0x0001\n    FLAGS2_EAS                              = 0x0002\n    FLAGS2_SMB_SECURITY_SIGNATURE           = 0x0004\n    FLAGS2_IS_LONG_NAME                     = 0x0040\n    FLAGS2_DFS                              = 0x1000\n    FLAGS2_PAGING_IO                        = 0x2000\n    FLAGS2_NT_STATUS                        = 0x4000\n    FLAGS2_UNICODE                          = 0x8000\n    FLAGS2_COMPRESSED                       = 0x0008\n    FLAGS2_SMB_SECURITY_SIGNATURE_REQUIRED  = 0x0010\n    FLAGS2_EXTENDED_SECURITY                = 0x0800\n\n    # Dialect's Security Mode flags\n    NEGOTIATE_USER_SECURITY                 = 0x01\n    NEGOTIATE_ENCRYPT_PASSWORDS             = 0x02\n    NEGOTIATE_SECURITY_SIGNATURE_ENABLE     = 0x04\n    NEGOTIATE_SECURITY_SIGNATURE_REQUIRED   = 0x08\n\n    # Tree Connect AndX Response optionalSuppor flags\n    SMB_SUPPORT_SEARCH_BITS                 = 0x01\n    SMB_SHARE_IS_IN_DFS                     = 0x02\n\n    def __init__(self, remote_name, remote_host, my_name=None, host_type=nmb.TYPE_SERVER, sess_port=445, timeout=None,\n                 UDP=0, session=None, negPacket=None):\n        # The uid attribute will be set when the client calls the login() method\n        self._uid = 0\n        self.__server_name = ''\n        self.__client_name = ''\n        self.__server_os = ''\n        self.__server_os_major = None\n        self.__server_os_minor = None\n        self.__server_os_build = None\n        self.__server_lanman = ''\n        self.__server_domain = ''\n        self.__server_dns_domain_name = ''\n        self.__server_dns_host_name = ''\n        self.__remote_name = remote_name.upper()\n        self.__remote_host = remote_host\n        self.__isNTLMv2 = True\n        self._dialects_parameters = None\n        self._dialects_data = None\n        self._doKerberos = False\n\n        # Credentials\n        self.__userName = b''\n        self.__password = b''\n        self.__domain   = b''\n        self.__lmhash   = b''\n        self.__nthash   = b''\n        self.__aesKey   = b''\n        self.__kdc      = b''\n        self.__TGT      = None\n        self.__TGS      = None\n\n        # Negotiate Protocol Result, used everywhere\n        # Could be extended or not, flags should be checked before\n        self._dialect_data = 0\n        self._dialect_parameters = 0\n        self._action = 0\n        self._sess = None\n        self.encrypt_passwords = True\n        self.tid = 0\n        self.fid = 0\n\n        # Strict host validation - off by default\n        self._strict_hostname_validation = False\n        self._validation_allow_absent = True\n        self._accepted_hostname = ''\n\n        # Signing stuff\n        self._SignSequenceNumber = 0\n        self._SigningSessionKey = b''\n        self._SigningChallengeResponse = b''\n        self._SignatureEnabled = False\n        self._SignatureVerificationEnabled = False\n        self._SignatureRequired = False\n\n        # Base flags (default flags, can be overridden using set_flags())\n        self.__flags1 = SMB.FLAGS1_PATHCASELESS | SMB.FLAGS1_CANONICALIZED_PATHS\n        self.__flags2 = SMB.FLAGS2_EXTENDED_SECURITY | SMB.FLAGS2_NT_STATUS | SMB.FLAGS2_LONG_NAMES\n\n        if timeout is None:\n            self.__timeout = 60\n        else:\n            self.__timeout = timeout\n\n        # If port 445 and the name sent is *SMBSERVER we're setting the name to the IP.\n        # This is to help some old applications still believing\n        # *SMSBSERVER will work against modern OSes. If port is NETBIOS_SESSION_PORT the user better\n        # know about *SMBSERVER's limitations\n        if sess_port == 445 and remote_name == '*SMBSERVER':\n           self.__remote_name = remote_host\n\n        # This is on purpose. I'm still not convinced to do a socket.gethostname() if not specified\n        if my_name is None:\n            self.__client_name = b''\n        else:\n            self.__client_name = my_name\n\n        if session is None:\n            if not my_name:\n                # If destination port is 139 yes, there's some client disclosure\n                my_name = socket.gethostname()\n                i = my_name.find('.')\n                if i > -1:\n                    my_name = my_name[:i]\n\n            if UDP:\n                self._sess = nmb.NetBIOSUDPSession(my_name, remote_name, remote_host, host_type, sess_port, self.__timeout)\n            else:\n                self._sess = nmb.NetBIOSTCPSession(my_name, remote_name, remote_host, host_type, sess_port, self.__timeout)\n\n                # Initialize session values (_dialect_data and _dialect_parameters)\n                self.neg_session()\n\n                # Call login() without any authentication information to\n                # setup a session if the remote server\n                # is in share mode.\n                if (self._dialects_parameters['SecurityMode'] & SMB.SECURITY_SHARE_MASK) == SMB.SECURITY_SHARE_SHARE:\n                    self.login('', '')\n        else:\n            self._sess = session\n            self.neg_session(negPacket = negPacket)\n            # Call login() without any authentication information to\n            # setup a session if the remote server\n            # is in share mode.\n            if (self._dialects_parameters['SecurityMode'] & SMB.SECURITY_SHARE_MASK) == SMB.SECURITY_SHARE_SHARE:\n                self.login('', '')\n\n    @staticmethod\n    def ntlm_supported():\n        return False\n\n    def getKerberos(self):\n        return self._doKerberos\n\n    def get_remote_name(self):\n        return self.__remote_name\n\n    def set_remote_name(self, name):\n        self.__remote_name = name\n        return True\n\n    def set_hostname_validation(self, validate, accept_empty, hostname):\n        self._strict_hostname_validation = validate\n        self._validation_allow_absent = accept_empty\n        self._accepted_hostname = hostname\n\n    def get_remote_host(self):\n        return self.__remote_host\n\n    def get_flags(self):\n        return self.__flags1, self.__flags2\n\n    def set_flags(self, flags1=None, flags2=None):\n        if flags1 is not None:\n           self.__flags1 = flags1\n        if flags2 is not None:\n           self.__flags2 = flags2\n\n    def set_timeout(self, timeout):\n        prev_timeout = self.__timeout\n        self.__timeout = timeout\n        return prev_timeout\n\n    def get_timeout(self):\n        return self.__timeout\n\n    @contextmanager\n    def use_timeout(self, timeout):\n        prev_timeout = self.set_timeout(timeout)\n        try:\n            yield\n        finally:\n            self.set_timeout(prev_timeout)\n\n    def get_session(self):\n        return self._sess\n\n    def get_tid(self):\n        return self.tid\n\n    def get_fid(self):\n        return self.fid\n\n    def isGuestSession(self):\n        return self._action & SMB_SETUP_GUEST\n\n    def doesSupportNTLMv2(self):\n        return self.__isNTLMv2\n\n    def close_session(self):\n        if self._sess:\n            self._sess.close()\n            self._sess = None\n\n    def recvSMB(self):\n        r = self._sess.recv_packet(self.__timeout)\n        return NewSMBPacket(data = r.get_trailer())\n\n    @staticmethod\n    def __decode_trans(params, data):\n        totparamcnt, totdatacnt, _, paramcnt, paramoffset, paramds, datacnt, dataoffset, datads, setupcnt = unpack('<HHHHHHHHHB', params[:19])\n        if paramcnt + paramds < totparamcnt or datacnt + datads < totdatacnt:\n            has_more = 1\n        else:\n            has_more = 0\n        paramoffset = paramoffset - 55 - setupcnt * 2\n        dataoffset = dataoffset - 55 - setupcnt * 2\n        return has_more, params[20:20 + setupcnt * 2], data[paramoffset:paramoffset + paramcnt], data[dataoffset:dataoffset + datacnt]\n\n    # TODO: Move this to NewSMBPacket, it belongs there\n    def signSMB(self, packet, signingSessionKey, signingChallengeResponse):\n        # This logic MUST be applied for messages sent in response to any of the higher-layer actions and in\n        # compliance with the message sequencing rules.\n        #  * The client or server that sends the message MUST provide the 32-bit sequence number for this\n        #    message, as specified in sections 3.2.4.1 and 3.3.4.1.\n        #  * The SMB_FLAGS2_SMB_SECURITY_SIGNATURE flag in the header MUST be set.\n        #  * To generate the signature, a 32-bit sequence number is copied into the\n        #    least significant 32 bits of the SecuritySignature field and the remaining\n        #    4 bytes are set to 0x00.\n        #  * The MD5 algorithm, as specified in [RFC1321], MUST be used to generate a hash of the SMB\n        #    message from the start of the SMB Header, which is defined as follows.\n        #    CALL MD5Init( md5context )\n        #    CALL MD5Update( md5context, Connection.SigningSessionKey )\n        #    CALL MD5Update( md5context, Connection.SigningChallengeResponse )\n        #    CALL MD5Update( md5context, SMB message )\n        #    CALL MD5Final( digest, md5context )\n        #    SET signature TO the first 8 bytes of the digest\n        # The resulting 8-byte signature MUST be copied into the SecuritySignature field of the SMB Header,\n        # after which the message can be transmitted.\n\n        #print \"seq(%d) signingSessionKey %r, signingChallengeResponse %r\" % (self._SignSequenceNumber, signingSessionKey, signingChallengeResponse)\n        packet['SecurityFeatures'] = pack('<q',self._SignSequenceNumber)\n        # Sign with the sequence\n        m = hashlib.md5()\n        m.update( signingSessionKey )\n        m.update( signingChallengeResponse )\n        m.update( packet.getData() )\n        # Replace sequence with acual hash\n        packet['SecurityFeatures'] = m.digest()[:8]\n        if self._SignatureVerificationEnabled:\n           self._SignSequenceNumber +=1\n        else:\n           self._SignSequenceNumber +=2\n\n    def checkSignSMB(self, packet, signingSessionKey, signingChallengeResponse):\n        # Let's check\n        signature = packet['SecurityFeatures']\n        #print \"Signature received: %r \" % signature\n        self.signSMB(packet, signingSessionKey, signingChallengeResponse)\n        #print \"Signature calculated: %r\" % packet['SecurityFeatures']\n        if self._SignatureVerificationEnabled is not True:\n           self._SignSequenceNumber -= 1\n        return packet['SecurityFeatures'] == signature\n\n    def sendSMB(self,smb):\n        smb['Uid'] = self._uid\n        #At least on AIX, PIDs can exceed 16 bits, so we mask them out\n        smb['Pid'] = (os.getpid() & 0xFFFF)\n        # set flags\n        smb['Flags1'] |= self.__flags1\n        smb['Flags2'] |= self.__flags2\n        if self._SignatureEnabled:\n            smb['Flags2'] |= SMB.FLAGS2_SMB_SECURITY_SIGNATURE\n            self.signSMB(smb, self._SigningSessionKey, self._SigningChallengeResponse)\n\n        self._sess.send_packet(smb.getData())\n\n    @staticmethod\n    def isValidAnswer(s, cmd):\n        while 1:\n            if s.rawData():\n                if s.get_command() == cmd:\n                    if s.get_error_class() == 0x00 and s.get_error_code() == 0x00:\n                        return 1\n                    else:\n                        raise SessionError( \"SMB Library Error\", s.get_error_class()+ (s.get_reserved() << 8), s.get_error_code() , s.get_flags2() & SMB.FLAGS2_NT_STATUS)\n                else:\n                    break\n        return 0\n\n    def neg_session(self, extended_security = True, negPacket = None):\n        def parsePacket(smb):\n            # If server speaks Unicode, let's set that flag from now on\n            if smb['Flags2'] & SMB.FLAGS2_UNICODE:\n                self.__flags2 |= SMB.FLAGS2_UNICODE\n\n            if smb.isValidAnswer(SMB.SMB_COM_NEGOTIATE):\n                sessionResponse = SMBCommand(smb['Data'][0])\n                self._dialects_parameters = SMBNTLMDialect_Parameters(sessionResponse['Parameters'])\n                self._dialects_data = SMBNTLMDialect_Data()\n                self._dialects_data['ChallengeLength'] = self._dialects_parameters['ChallengeLength']\n                self._dialects_data.fromString(sessionResponse['Data'])\n                if self._dialects_parameters['Capabilities'] & SMB.CAP_EXTENDED_SECURITY:\n                    # Whether we choose it or it is enforced by the server, we go for extended security\n                    self._dialects_parameters = SMBExtended_Security_Parameters(sessionResponse['Parameters'])\n                    self._dialects_data = SMBExtended_Security_Data(sessionResponse['Data'])\n                    # Let's setup some variable for later use\n                    if self._dialects_parameters['SecurityMode'] & SMB.SECURITY_SIGNATURES_REQUIRED:\n                         self._SignatureRequired = True\n\n                    # Interestingly, the security Blob might be missing sometimes.\n                    #spnego = SPNEGO_NegTokenInit(self._dialects_data['SecurityBlob'])\n                    #for i in spnego['MechTypes']:\n                    #      print \"Mech Found: %s\" % MechTypes[i]\n                    return 1\n\n                # If not, let's try the old way\n                else:\n                    if self._dialects_data['ServerName'] is not None:\n                        self.__server_name = self._dialects_data['ServerName']\n\n                    if self._dialects_parameters['DialectIndex'] == 0xffff:\n                        raise UnsupportedFeature(\"Remote server does not know NT LM 0.12\")\n                    return 1\n            else:\n                return 0\n\n        if negPacket is None:\n            smb = NewSMBPacket()\n            negSession = SMBCommand(SMB.SMB_COM_NEGOTIATE)\n            flags2 = self.get_flags()[1]\n            if extended_security is True:\n                self.set_flags(flags2=flags2|SMB.FLAGS2_EXTENDED_SECURITY)\n            else:\n                self.set_flags(flags2=flags2 & (~SMB.FLAGS2_EXTENDED_SECURITY))\n\n            negSession['Data'] = b'\\x02NT LM 0.12\\x00'\n            smb.addCommand(negSession)\n            self.sendSMB(smb)\n\n            while 1:\n                smb = self.recvSMB()\n                return parsePacket(smb)\n        else:\n\n            return parsePacket( NewSMBPacket( data = negPacket))\n\n    def tree_connect(self, path, password = '', service = SERVICE_ANY):\n        LOG.warning(\"[MS-CIFS] This is an original Core Protocol command.This command has been deprecated.Client Implementations SHOULD use SMB_COM_TREE_CONNECT_ANDX\")\n\n        # return 0x800\n        if password:\n            # Password is only encrypted if the server passed us an \"encryption\" during protocol dialect\n            if self._dialects_parameters['ChallengeLength'] > 0:\n                # this code is untested\n                password = self.get_ntlmv1_response(ntlm.compute_lmhash(password))\n\n        if not unicode_support:\n            if unicode_convert:\n                path = str(path)\n            else:\n                raise Exception('SMB: Can\\t conver path from unicode!')\n\n        smb = NewSMBPacket()\n        treeConnect = SMBCommand(SMB.SMB_COM_TREE_CONNECT)\n        treeConnect['Parameters'] = SMBTreeConnect_Parameters()\n        treeConnect['Data']       = SMBTreeConnect_Data()\n        treeConnect['Data']['Path'] = path.upper()\n        treeConnect['Data']['Password'] = password\n        treeConnect['Data']['Service'] = service\n        smb.addCommand(treeConnect)\n        self.sendSMB(smb)\n\n        while 1:\n            smb = self.recvSMB()\n            if smb.isValidAnswer(SMB.SMB_COM_TREE_CONNECT):\n                # XXX Here we are ignoring the rest of the response\n                return smb['Tid']\n            return smb['Tid']\n\n    def get_uid(self):\n        return self._uid\n\n    def set_uid(self, uid):\n        self._uid = uid\n\n    def tree_connect_andx(self, path, password = None, service = SERVICE_ANY, smb_packet=None):\n        if password:\n            # Password is only encrypted if the server passed us an \"encryption\" during protocol dialect\n            if self._dialects_parameters['ChallengeLength'] > 0:\n                # this code is untested\n                password = self.get_ntlmv1_response(ntlm.compute_lmhash(password))\n        else:\n            password = '\\x00'\n\n        if not unicode_support:\n            if unicode_convert:\n                path = str(path)\n            else:\n                raise Exception('SMB: Can\\t convert path from unicode!')\n\n        if smb_packet is None:\n            smb = NewSMBPacket()\n        else:\n            smb = smb_packet\n\n        # Just in case this came with the full path ,let's just leave\n        # the sharename, we'll take care of the rest\n\n        share = path.split('\\\\')[-1]\n        try:\n            _, _, _, _, sockaddr = socket.getaddrinfo(self.get_remote_host(), 80, 0, 0, socket.IPPROTO_TCP)[0]\n            remote_host = sockaddr[0]\n        except Exception:\n            remote_host =  self.get_remote_host()\n\n        path = '\\\\\\\\' + remote_host + '\\\\' +share\n        path = path.upper().encode('utf-16le') if self.__flags2 & SMB.FLAGS2_UNICODE else path\n\n        treeConnect = SMBCommand(SMB.SMB_COM_TREE_CONNECT_ANDX)\n        treeConnect['Parameters'] = SMBTreeConnectAndX_Parameters()\n        treeConnect['Data']       = SMBTreeConnectAndX_Data(flags=self.__flags2)\n        treeConnect['Parameters']['PasswordLength'] = len(password)\n        treeConnect['Data']['Password'] = password\n        treeConnect['Data']['Path'] = path\n        treeConnect['Data']['Service'] = service\n\n        if self.__flags2 & SMB.FLAGS2_UNICODE:\n            treeConnect['Data']['Pad'] = 0x0\n\n        smb.addCommand(treeConnect)\n\n        # filename = \"\\PIPE\\epmapper\"\n\n        # ntCreate = SMBCommand(SMB.SMB_COM_NT_CREATE_ANDX)\n        # ntCreate['Parameters'] = SMBNtCreateAndX_Parameters()\n        # ntCreate['Data']       = SMBNtCreateAndX_Data()\n        # ntCreate['Parameters']['FileNameLength'] = len(filename)\n        # ntCreate['Parameters']['CreateFlags'] = 0\n        # ntCreate['Parameters']['AccessMask'] = 0x3\n        # ntCreate['Parameters']['CreateOptions'] = 0x0\n        # ntCreate['Data']['FileName'] = filename\n\n        # smb.addCommand(ntCreate)\n        self.sendSMB(smb)\n\n        while 1:\n            smb = self.recvSMB()\n            if smb.isValidAnswer(SMB.SMB_COM_TREE_CONNECT_ANDX):\n                # XXX Here we are ignoring the rest of the response\n                self.tid = smb['Tid']\n                return self.tid\n            self.tid = smb['Tid']\n            return self.tid\n\n    # backwars compatibility\n    connect_tree = tree_connect_andx\n\n    @staticmethod\n    def getDialect():\n        return SMB_DIALECT\n\n    def get_server_name(self):\n        #return self._dialects_data['ServerName']\n        return self.__server_name\n\n    def get_client_name(self):\n        return self.__client_name\n\n    def get_session_key(self):\n        return self._SigningSessionKey\n\n    def set_session_key(self, key):\n        self._SignatureEnabled = True\n        self._SignSequenceNumber = 2\n        self._SigningSessionKey = key\n\n    def get_encryption_key(self):\n        if 'Challenge' in self._dialects_data.fields:\n            return self._dialects_data['Challenge']\n        else:\n            return None\n\n    def get_server_time(self):\n        timestamp = self._dialects_parameters['HighDateTime']\n        timestamp <<= 32\n        timestamp |= self._dialects_parameters['LowDateTime']\n        timestamp -= 116444736000000000\n        timestamp //= 10000000\n        d = datetime.datetime.utcfromtimestamp(timestamp)\n        return d.strftime(\"%a, %d %b %Y %H:%M:%S GMT\")\n\n    def disconnect_tree(self, tid):\n        smb = NewSMBPacket()\n        smb['Tid']  = tid\n\n        smb.addCommand(SMBCommand(SMB.SMB_COM_TREE_DISCONNECT))\n\n        self.sendSMB(smb)\n        self.recvSMB()\n\n    def open(self, tid, filename, open_mode, desired_access):\n        filename = filename.replace('/', '\\\\')\n        filename = filename.encode('utf-16le') if self.__flags2 & SMB.FLAGS2_UNICODE else filename\n\n        smb = NewSMBPacket()\n        smb['Tid']    = tid\n\n        openFile = SMBCommand(SMB.SMB_COM_OPEN)\n        openFile['Parameters'] = SMBOpen_Parameters()\n        openFile['Parameters']['DesiredAccess']    = desired_access\n        openFile['Parameters']['OpenMode']         = open_mode\n        openFile['Parameters']['SearchAttributes'] = ATTR_READONLY | ATTR_HIDDEN | ATTR_ARCHIVE\n        openFile['Data']       = SMBOpen_Data(flags=self.__flags2)\n        openFile['Data']['FileName'] = filename\n\n        smb.addCommand(openFile)\n\n        self.sendSMB(smb)\n\n        smb = self.recvSMB()\n        if smb.isValidAnswer(SMB.SMB_COM_OPEN):\n            # XXX Here we are ignoring the rest of the response\n            openFileResponse   = SMBCommand(smb['Data'][0])\n            openFileParameters = SMBOpenResponse_Parameters(openFileResponse['Parameters'])\n\n            return (\n                openFileParameters['Fid'],\n                openFileParameters['FileAttributes'],\n                openFileParameters['LastWriten'],\n                openFileParameters['FileSize'],\n                openFileParameters['GrantedAccess'],\n            )\n\n    def open_andx(self, tid, filename, open_mode, desired_access):\n        filename = filename.replace('/', '\\\\')\n        filename = filename.encode('utf-16le') if self.__flags2 & SMB.FLAGS2_UNICODE else filename\n\n        smb = NewSMBPacket()\n        smb['Tid']    = tid\n\n        openFile = SMBCommand(SMB.SMB_COM_OPEN_ANDX)\n        openFile['Parameters'] = SMBOpenAndX_Parameters()\n        openFile['Parameters']['DesiredAccess']    = desired_access\n        openFile['Parameters']['OpenMode']         = open_mode\n        openFile['Parameters']['SearchAttributes'] = ATTR_READONLY | ATTR_HIDDEN | ATTR_ARCHIVE\n        openFile['Data']       = SMBOpenAndX_Data(flags=self.__flags2)\n        openFile['Data']['FileName'] = filename\n\n        if self.__flags2 & SMB.FLAGS2_UNICODE:\n            openFile['Data']['Pad'] = 0x0\n\n        smb.addCommand(openFile)\n\n        self.sendSMB(smb)\n\n        smb = self.recvSMB()\n        if smb.isValidAnswer(SMB.SMB_COM_OPEN_ANDX):\n            # XXX Here we are ignoring the rest of the response\n            openFileResponse   = SMBCommand(smb['Data'][0])\n            openFileParameters = SMBOpenAndXResponse_Parameters(openFileResponse['Parameters'])\n\n            return (\n                openFileParameters['Fid'],\n                openFileParameters['FileAttributes'],\n                openFileParameters['LastWriten'],\n                openFileParameters['FileSize'],\n                openFileParameters['GrantedAccess'],\n                openFileParameters['FileType'],\n                openFileParameters['IPCState'],\n                openFileParameters['Action'],\n                openFileParameters['ServerFid'],\n            )\n\n    def close(self, tid, fid):\n        smb = NewSMBPacket()\n        smb['Tid']    = tid\n\n        closeFile = SMBCommand(SMB.SMB_COM_CLOSE)\n        closeFile['Parameters'] = SMBClose_Parameters()\n        closeFile['Parameters']['FID']    = fid\n        smb.addCommand(closeFile)\n\n        self.sendSMB(smb)\n        smb = self.recvSMB()\n        if smb.isValidAnswer(SMB.SMB_COM_CLOSE):\n           return 1\n        return 0\n\n    def send_trans(self, tid, setup, name, param, data, noAnswer = 0):\n        smb = NewSMBPacket()\n        smb['Tid']    = tid\n\n        transCommand = SMBCommand(SMB.SMB_COM_TRANSACTION)\n        transCommand['Parameters'] = SMBTransaction_Parameters()\n        transCommand['Data'] = SMBTransaction_Data()\n\n        transCommand['Parameters']['Setup'] = setup\n        transCommand['Parameters']['TotalParameterCount'] = len(param)\n        transCommand['Parameters']['TotalDataCount'] = len(data)\n\n        transCommand['Parameters']['ParameterCount'] = len(param)\n        transCommand['Parameters']['ParameterOffset'] = 32+3+28+len(setup)+len(name)\n\n        transCommand['Parameters']['DataCount'] = len(data)\n        transCommand['Parameters']['DataOffset'] = transCommand['Parameters']['ParameterOffset'] + len(param)\n\n        transCommand['Data']['Name'] = name\n        transCommand['Data']['Trans_Parameters'] = param\n        transCommand['Data']['Trans_Data'] = data\n\n        if noAnswer:\n           transCommand['Parameters']['Flags'] = TRANS_NO_RESPONSE\n\n        smb.addCommand(transCommand)\n\n        self.sendSMB(smb)\n\n    def send_trans2(self, tid, setup, name, param, data):\n        smb = NewSMBPacket()\n        smb['Tid']    = tid\n\n        command = pack('<H', setup)\n\n        transCommand = SMBCommand(SMB.SMB_COM_TRANSACTION2)\n        transCommand['Parameters'] = SMBTransaction2_Parameters()\n        transCommand['Parameters']['MaxDataCount'] = self._dialects_parameters['MaxBufferSize']\n        transCommand['Data'] = SMBTransaction2_Data()\n\n        transCommand['Parameters']['Setup'] = command\n        transCommand['Parameters']['TotalParameterCount'] = len(param)\n        transCommand['Parameters']['TotalDataCount'] = len(data)\n\n        if len(param) > 0:\n            padLen = (4 - (32+2+28 + len(command)) % 4 ) % 4\n            padBytes = '\\xFF' * padLen\n            transCommand['Data']['Pad1'] = padBytes\n        else:\n            transCommand['Data']['Pad1'] = ''\n            padLen = 0\n\n        transCommand['Parameters']['ParameterCount'] = len(param)\n        transCommand['Parameters']['ParameterOffset'] = 32+2+28+len(command)+len(name) + padLen\n\n        if len(data) > 0:\n            pad2Len = (4 - (32+2+28 + len(command) + padLen + len(param)) % 4) % 4\n            transCommand['Data']['Pad2'] = '\\xFF' * pad2Len\n        else:\n            transCommand['Data']['Pad2'] = ''\n            pad2Len = 0\n\n        transCommand['Parameters']['DataCount'] = len(data)\n        transCommand['Parameters']['DataOffset'] = transCommand['Parameters']['ParameterOffset'] + len(param) + pad2Len\n\n        transCommand['Data']['Name'] = name\n        transCommand['Data']['Trans_Parameters'] = param\n        transCommand['Data']['Trans_Data'] = data\n        smb.addCommand(transCommand)\n\n        self.sendSMB(smb)\n\n    def query_file_info(self, tid, fid, fileInfoClass = SMB_QUERY_FILE_STANDARD_INFO):\n        self.send_trans2(tid, SMB.TRANS2_QUERY_FILE_INFORMATION, '\\x00', pack('<HH', fid, fileInfoClass), '')\n\n        resp = self.recvSMB()\n        if resp.isValidAnswer(SMB.SMB_COM_TRANSACTION2):\n            trans2Response = SMBCommand(resp['Data'][0])\n            trans2Parameters = SMBTransaction2Response_Parameters(trans2Response['Parameters'])\n            # Remove Potential Prefix Padding\n            return trans2Response['Data'][-trans2Parameters['TotalDataCount']:]\n\n    def __nonraw_retr_file(self, tid, fid, offset, datasize, callback):\n        if (self._dialects_parameters['Capabilities'] & SMB.CAP_LARGE_READX) and self._SignatureEnabled is False:\n            max_buf_size = 65000\n        else:\n            max_buf_size = self._dialects_parameters['MaxBufferSize'] & ~0x3ff  # Read in multiple KB blocks\n\n        read_offset = offset\n        while read_offset < datasize:\n            data = self.read_andx(tid, fid, read_offset, max_buf_size)\n\n            callback(data)\n            read_offset += len(data)\n\n    def __nonraw_stor_file(self, tid, fid, offset, datasize, callback):\n        if (self._dialects_parameters['Capabilities'] & SMB.CAP_LARGE_WRITEX) and self._SignatureEnabled is False:\n            max_buf_size = 65000\n        else:\n            max_buf_size = self._dialects_parameters['MaxBufferSize'] & ~0x3ff  # Write in multiple KB blocks\n\n        write_offset = offset\n        while 1:\n            data = callback(max_buf_size)\n            if not data:\n                break\n\n            smb = self.write_andx(tid,fid,data, write_offset)\n            writeResponse   = SMBCommand(smb['Data'][0])\n            writeResponseParameters = SMBWriteAndXResponse_Parameters(writeResponse['Parameters'])\n            write_offset += writeResponseParameters['Count']\n\n    def get_server_domain(self):\n        return self.__server_domain\n\n    def get_server_dns_domain_name(self):\n        return self.__server_dns_domain_name\n\n    def get_server_dns_host_name(self):\n        return self.__server_dns_host_name\n\n    def get_server_os(self):\n        return self.__server_os\n\n    def get_server_os_major(self):\n        return self.__server_os_major\n\n    def get_server_os_minor(self):\n        return self.__server_os_minor\n\n    def get_server_os_build(self):\n        return self.__server_os_build\n\n    def set_server_os(self, os):\n        self.__server_os = os\n\n    def get_server_lanman(self):\n        return self.__server_lanman\n\n    def is_login_required(self):\n        # Login is required if share mode is user.\n        # Otherwise only public services or services in share mode\n        # are allowed.\n        return (self._dialects_parameters['SecurityMode'] & SMB.SECURITY_SHARE_MASK) == SMB.SECURITY_SHARE_USER\n\n    def is_signing_required(self):\n        return self._SignatureRequired\n\n    def get_ntlmv1_response(self, key):\n        challenge = self._dialects_data['Challenge']\n        return ntlm.get_ntlmv1_response(key, challenge)\n\n    def perform_hostname_validation(self):\n        if self.__server_name == '':\n            if not self._validation_allow_absent:\n                raise self.HostnameValidationException('Hostname was not supplied by target host and absent validation is disallowed')\n            return\n        if self.__server_name.lower() != self._accepted_hostname.lower() and self.__server_dns_host_name.lower() != self._accepted_hostname.lower():\n            raise self.HostnameValidationException('Supplied hostname %s does not match reported hostnames %s or %s' %\n                (self._accepted_hostname.lower(), self.__server_name.lower(), self.__server_dns_host_name.lower()))\n\n\n    def kerberos_login(self, user, password, domain = '', lmhash = '', nthash = '', aesKey = '', kdcHost = '', TGT=None, TGS=None):\n        # Importing down here so pyasn1 is not required if kerberos is not used.\n        from impacket.krb5.asn1 import AP_REQ, Authenticator, TGS_REP, seq_set\n        from impacket.krb5.kerberosv5 import getKerberosTGT, getKerberosTGS\n        from impacket.krb5 import constants\n        from impacket.krb5.types import Principal, KerberosTime, Ticket\n        from pyasn1.codec.der import decoder, encoder\n        import datetime\n\n        # login feature does not support unicode\n        # disable it if enabled\n        flags2 = self.__flags2\n        if flags2 & SMB.FLAGS2_UNICODE:\n            self.__flags2 = flags2 & (flags2 ^ SMB.FLAGS2_UNICODE)\n\n        # If TGT or TGS are specified, they are in the form of:\n        # TGS['KDC_REP'] = the response from the server\n        # TGS['cipher'] = the cipher used\n        # TGS['sessionKey'] = the sessionKey\n        # If we have hashes, normalize them\n        if lmhash != '' or nthash != '':\n            if len(lmhash) % 2:\n                lmhash = '0%s' % lmhash\n            if len(nthash) % 2:\n                nthash = '0%s' % nthash\n            try: # just in case they were converted already\n                lmhash = a2b_hex(lmhash)\n                nthash = a2b_hex(nthash)\n            except:\n                pass\n\n        self.__userName = user\n        self.__password = password\n        self.__domain   = domain\n        self.__lmhash   = lmhash\n        self.__nthash   = nthash\n        self.__aesKey   = aesKey\n        self.__kdc      = kdcHost\n        self.__TGT      = TGT\n        self.__TGS      = TGS\n        self._doKerberos= True\n\n        # First of all, we need to get a TGT for the user\n        userName = Principal(user, type=constants.PrincipalNameType.NT_PRINCIPAL.value)\n        if TGT is None:\n            if TGS is None:\n                tgt, cipher, oldSessionKey, sessionKey = getKerberosTGT(userName, password, domain, lmhash, nthash, aesKey, kdcHost)\n        else:\n            tgt = TGT['KDC_REP']\n            cipher = TGT['cipher']\n            sessionKey = TGT['sessionKey']\n\n        # Now that we have the TGT, we should ask for a TGS for cifs\n\n        if TGS is None:\n            serverName = Principal('cifs/%s' % self.__remote_name, type=constants.PrincipalNameType.NT_SRV_INST.value)\n            tgs, cipher, oldSessionKey, sessionKey = getKerberosTGS(serverName, domain, kdcHost, tgt, cipher, sessionKey)\n        else:\n            tgs = TGS['KDC_REP']\n            cipher = TGS['cipher']\n            sessionKey = TGS['sessionKey']\n\n        smb = NewSMBPacket()\n\n        # Are we required to sign SMB? If so we do it, if not we skip it\n        if self._SignatureRequired:\n           smb['Flags2'] |= SMB.FLAGS2_SMB_SECURITY_SIGNATURE\n\n\n        sessionSetup = SMBCommand(SMB.SMB_COM_SESSION_SETUP_ANDX)\n        sessionSetup['Parameters'] = SMBSessionSetupAndX_Extended_Parameters()\n        sessionSetup['Data']       = SMBSessionSetupAndX_Extended_Data()\n\n        sessionSetup['Parameters']['MaxBufferSize']        = 61440\n        sessionSetup['Parameters']['MaxMpxCount']          = 2\n        sessionSetup['Parameters']['VcNumber']             = 1\n        sessionSetup['Parameters']['SessionKey']           = 0\n        sessionSetup['Parameters']['Capabilities']         = SMB.CAP_EXTENDED_SECURITY | SMB.CAP_USE_NT_ERRORS | SMB.CAP_UNICODE | SMB.CAP_LARGE_READX | SMB.CAP_LARGE_WRITEX\n\n\n        # Let's build a NegTokenInit with the NTLMSSP\n        # TODO: In the future we should be able to choose different providers\n\n        blob = SPNEGO_NegTokenInit()\n\n        # Kerberos v5 mech\n        blob['MechTypes'] = [TypesMech['MS KRB5 - Microsoft Kerberos 5']]\n\n        # Let's extract the ticket from the TGS\n        tgs = decoder.decode(tgs, asn1Spec = TGS_REP())[0]\n        ticket = Ticket()\n        ticket.from_asn1(tgs['ticket'])\n\n        # Now let's build the AP_REQ\n        apReq = AP_REQ()\n        apReq['pvno'] = 5\n        apReq['msg-type'] = int(constants.ApplicationTagNumbers.AP_REQ.value)\n\n        opts = list()\n        apReq['ap-options'] = constants.encodeFlags(opts)\n        seq_set(apReq,'ticket', ticket.to_asn1)\n\n        authenticator = Authenticator()\n        authenticator['authenticator-vno'] = 5\n        authenticator['crealm'] = domain\n        seq_set(authenticator, 'cname', userName.components_to_asn1)\n        now = datetime.datetime.utcnow()\n\n        authenticator['cusec'] = now.microsecond\n        authenticator['ctime'] = KerberosTime.to_asn1(now)\n\n        encodedAuthenticator = encoder.encode(authenticator)\n\n        # Key Usage 11\n        # AP-REQ Authenticator (includes application authenticator\n        # subkey), encrypted with the application session key\n        # (Section 5.5.1)\n        encryptedEncodedAuthenticator = cipher.encrypt(sessionKey, 11, encodedAuthenticator, None)\n\n        apReq['authenticator'] = noValue\n        apReq['authenticator']['etype'] = cipher.enctype\n        apReq['authenticator']['cipher'] = encryptedEncodedAuthenticator\n\n        blob['MechToken'] = pack('B', ASN1_AID) + asn1encode(pack('B', ASN1_OID) + asn1encode(\n            TypesMech['KRB5 - Kerberos 5']) + KRB5_AP_REQ + encoder.encode(apReq))\n\n        sessionSetup['Parameters']['SecurityBlobLength']  = len(blob)\n        sessionSetup['Parameters'].getData()\n        sessionSetup['Data']['SecurityBlob']       = blob.getData()\n\n        # Fake Data here, don't want to get us fingerprinted\n        sessionSetup['Data']['NativeOS']      = 'Unix'\n        sessionSetup['Data']['NativeLanMan']  = 'Samba'\n\n        smb.addCommand(sessionSetup)\n        self.sendSMB(smb)\n\n        smb = self.recvSMB()\n        if smb.isValidAnswer(SMB.SMB_COM_SESSION_SETUP_ANDX):\n            # We will need to use this uid field for all future requests/responses\n            self._uid = smb['Uid']\n\n            # Now we have to extract the blob to continue the auth process\n            sessionResponse   = SMBCommand(smb['Data'][0])\n            sessionParameters = SMBSessionSetupAndX_Extended_Response_Parameters(sessionResponse['Parameters'])\n            sessionData       = SMBSessionSetupAndX_Extended_Response_Data(flags = smb['Flags2'])\n            sessionData['SecurityBlobLength'] = sessionParameters['SecurityBlobLength']\n            sessionData.fromString(sessionResponse['Data'])\n\n            self._action = sessionParameters['Action']\n            # If smb sign required, let's enable it for the rest of the connection\n            if self._dialects_parameters['SecurityMode'] & SMB.SECURITY_SIGNATURES_REQUIRED:\n               self._SigningSessionKey = sessionKey.contents\n               self._SignSequenceNumber = 2\n               self._SignatureEnabled = True\n\n            # restore unicode flag if needed\n            if flags2 & SMB.FLAGS2_UNICODE:\n                self.__flags2 |= SMB.FLAGS2_UNICODE\n\n            return 1\n        else:\n            raise Exception('Error: Could not login successfully')\n\n    def login_extended(self, user, password, domain = '', lmhash = '', nthash = '', use_ntlmv2 = True ):\n\n        # login feature does not support unicode\n        # disable it if enabled\n        flags2 = self.__flags2\n        if flags2 & SMB.FLAGS2_UNICODE:\n            self.__flags2 = flags2 & (flags2 ^ SMB.FLAGS2_UNICODE)\n\n        # Once everything's working we should join login methods into a single one\n        smb = NewSMBPacket()\n        # Are we required to sign SMB? If so we do it, if not we skip it\n        if self._SignatureRequired:\n           smb['Flags2'] |= SMB.FLAGS2_SMB_SECURITY_SIGNATURE\n\n        sessionSetup = SMBCommand(SMB.SMB_COM_SESSION_SETUP_ANDX)\n        sessionSetup['Parameters'] = SMBSessionSetupAndX_Extended_Parameters()\n        sessionSetup['Data']       = SMBSessionSetupAndX_Extended_Data()\n\n        sessionSetup['Parameters']['MaxBufferSize']        = 61440\n        sessionSetup['Parameters']['MaxMpxCount']          = 2\n        sessionSetup['Parameters']['VcNumber']             = 1\n        sessionSetup['Parameters']['SessionKey']           = 0\n        sessionSetup['Parameters']['Capabilities']         = SMB.CAP_EXTENDED_SECURITY | SMB.CAP_USE_NT_ERRORS | SMB.CAP_UNICODE | SMB.CAP_LARGE_READX | SMB.CAP_LARGE_WRITEX\n\n\n        # Let's build a NegTokenInit with the NTLMSSP\n        # TODO: In the future we should be able to choose different providers\n\n        blob = SPNEGO_NegTokenInit()\n\n        # NTLMSSP\n        blob['MechTypes'] = [TypesMech['NTLMSSP - Microsoft NTLM Security Support Provider']]\n        auth = ntlm.getNTLMSSPType1(self.get_client_name(),domain,self._SignatureRequired, use_ntlmv2 = use_ntlmv2)\n        blob['MechToken'] = auth.getData()\n\n        sessionSetup['Parameters']['SecurityBlobLength']  = len(blob)\n        sessionSetup['Parameters'].getData()\n        sessionSetup['Data']['SecurityBlob']       = blob.getData()\n\n        # Fake Data here, don't want to get us fingerprinted\n        sessionSetup['Data']['NativeOS']      = 'Unix'\n        sessionSetup['Data']['NativeLanMan']  = 'Samba'\n\n        smb.addCommand(sessionSetup)\n        self.sendSMB(smb)\n\n        smb = self.recvSMB()\n        if smb.isValidAnswer(SMB.SMB_COM_SESSION_SETUP_ANDX):\n            # We will need to use this uid field for all future requests/responses\n            self._uid = smb['Uid']\n\n            # Now we have to extract the blob to continue the auth process\n            sessionResponse   = SMBCommand(smb['Data'][0])\n            sessionParameters = SMBSessionSetupAndX_Extended_Response_Parameters(sessionResponse['Parameters'])\n            sessionData       = SMBSessionSetupAndX_Extended_Response_Data(flags = smb['Flags2'])\n            sessionData['SecurityBlobLength'] = sessionParameters['SecurityBlobLength']\n            sessionData.fromString(sessionResponse['Data'])\n            respToken = SPNEGO_NegTokenResp(sessionData['SecurityBlob'])\n\n            # Let's parse some data and keep it to ourselves in case it is asked\n            ntlmChallenge = ntlm.NTLMAuthChallenge(respToken['ResponseToken'])\n            if ntlmChallenge['TargetInfoFields_len'] > 0:\n                av_pairs = ntlm.AV_PAIRS(ntlmChallenge['TargetInfoFields'][:ntlmChallenge['TargetInfoFields_len']])\n                if av_pairs[ntlm.NTLMSSP_AV_HOSTNAME] is not None:\n                   try:\n                       self.__server_name = av_pairs[ntlm.NTLMSSP_AV_HOSTNAME][1].decode('utf-16le')\n                   except UnicodeDecodeError:\n                       # For some reason, we couldn't decode Unicode here.. silently discard the operation\n                       pass\n                if av_pairs[ntlm.NTLMSSP_AV_DOMAINNAME] is not None:\n                   try:\n                       if self.__server_name != av_pairs[ntlm.NTLMSSP_AV_DOMAINNAME][1].decode('utf-16le'):\n                           self.__server_domain = av_pairs[ntlm.NTLMSSP_AV_DOMAINNAME][1].decode('utf-16le')\n                   except UnicodeDecodeError:\n                       # For some reason, we couldn't decode Unicode here.. silently discard the operation\n                       pass\n                if av_pairs[ntlm.NTLMSSP_AV_DNS_DOMAINNAME] is not None:\n                   try:\n                       self.__server_dns_domain_name = av_pairs[ntlm.NTLMSSP_AV_DNS_DOMAINNAME][1].decode('utf-16le')\n                   except UnicodeDecodeError:\n                       # For some reason, we couldn't decode Unicode here.. silently discard the operation\n                       pass\n\n                if av_pairs[ntlm.NTLMSSP_AV_DNS_HOSTNAME] is not None:\n                   try:\n                       self.__server_dns_host_name = av_pairs[ntlm.NTLMSSP_AV_DNS_HOSTNAME][1].decode('utf-16le')\n                   except UnicodeDecodeError:\n                       # For some reason, we couldn't decode Unicode here.. silently discard the operation\n                       pass\n\n            if self._strict_hostname_validation:\n                self.perform_hostname_validation()\n\n            # Parse Version to know the target Operating system name. Not provided elsewhere anymore\n            if 'Version' in ntlmChallenge.fields:\n                version = ntlmChallenge['Version']\n\n                if len(version) >= 4:\n                   self.__server_os_major, self.__server_os_minor, self.__server_os_build = unpack('<BBH',version[:4])\n\n            type3, exportedSessionKey = ntlm.getNTLMSSPType3(auth, respToken['ResponseToken'], user, password, domain, lmhash, nthash, use_ntlmv2 = use_ntlmv2)\n\n            if exportedSessionKey is not None:\n                self._SigningSessionKey = exportedSessionKey\n\n            smb = NewSMBPacket()\n\n            # Are we required to sign SMB? If so we do it, if not we skip it\n            if self._SignatureRequired:\n               smb['Flags2'] |= SMB.FLAGS2_SMB_SECURITY_SIGNATURE\n\n            respToken2 = SPNEGO_NegTokenResp()\n            respToken2['ResponseToken'] = type3.getData()\n\n            # Reusing the previous structure\n            sessionSetup['Parameters']['SecurityBlobLength'] = len(respToken2)\n            sessionSetup['Data']['SecurityBlob'] = respToken2.getData()\n\n            # Storing some info for later use\n            self.__server_os     = sessionData['NativeOS']\n            self.__server_lanman = sessionData['NativeLanMan']\n\n            smb.addCommand(sessionSetup)\n            self.sendSMB(smb)\n\n            smb = self.recvSMB()\n            self._uid = 0\n            if smb.isValidAnswer(SMB.SMB_COM_SESSION_SETUP_ANDX):\n                self._uid = smb['Uid']\n                sessionResponse   = SMBCommand(smb['Data'][0])\n                sessionParameters = SMBSessionSetupAndXResponse_Parameters(sessionResponse['Parameters'])\n\n                self._action = sessionParameters['Action']\n                # If smb sign required, let's enable it for the rest of the connection\n                if self._dialects_parameters['SecurityMode'] & SMB.SECURITY_SIGNATURES_REQUIRED:\n                   self._SignSequenceNumber = 2\n                   self._SignatureEnabled = True\n\n                # restore unicode flag if needed\n                if flags2 & SMB.FLAGS2_UNICODE:\n                    self.__flags2 |= SMB.FLAGS2_UNICODE\n\n                return 1\n        else:\n            raise Exception('Error: Could not login successfully')\n\n    def getCredentials(self):\n        return (\n            self.__userName,\n            self.__password,\n            self.__domain,\n            self.__lmhash,\n            self.__nthash,\n            self.__aesKey,\n            self.__TGT,\n            self.__TGS)\n\n    def getIOCapabilities(self):\n        res = dict()\n        if (self._dialects_parameters['Capabilities'] & SMB.CAP_LARGE_READX) and self._SignatureEnabled is False:\n            max_size = 65000\n        else:\n            max_size = self._dialects_parameters['MaxBufferSize'] # Read in multiple KB blocks\n        res['MaxReadSize'] = max_size\n        res['MaxWriteSize'] = max_size\n        return res\n\n    def login(self, user, password, domain = '', lmhash = '', nthash = '', ntlm_fallback = True):\n\n        # If we have hashes, normalize them\n        if lmhash != '' or nthash != '':\n            if len(lmhash) % 2:\n                lmhash = '0%s' % lmhash\n            if len(nthash) % 2:\n                nthash = '0%s' % nthash\n            try: # just in case they were converted already\n                lmhash = a2b_hex(lmhash)\n                nthash = a2b_hex(nthash)\n            except:\n                pass\n\n        self.__userName = user\n        self.__password = password\n        self.__domain   = domain\n        self.__lmhash   = lmhash\n        self.__nthash   = nthash\n        self.__aesKey   = ''\n        self.__TGT      = None\n        self.__TGS      = None\n\n        if self._dialects_parameters['Capabilities'] & SMB.CAP_EXTENDED_SECURITY:\n            try:\n                self.login_extended(user, password, domain, lmhash, nthash, use_ntlmv2 = True)\n            except:\n                # If the target OS is Windows 5.0 or Samba, let's try using NTLMv1\n                if ntlm_fallback and ((self.get_server_lanman().find('Windows 2000') != -1) or (self.get_server_lanman().find('Samba') != -1)):\n                    self.login_extended(user, password, domain, lmhash, nthash, use_ntlmv2 = False)\n                    self.__isNTLMv2 = False\n                else:\n                    raise\n        elif ntlm_fallback:\n            self.login_standard(user, password, domain, lmhash, nthash)\n            self.__isNTLMv2 = False\n        else:\n            raise SessionError('Cannot authenticate against target, enable ntlm_fallback')\n\n    def login_standard(self, user, password, domain = '', lmhash = '', nthash = ''):\n\n        # login feature does not support unicode\n        # disable it if enabled\n        flags2 = self.__flags2\n        if flags2 & SMB.FLAGS2_UNICODE:\n            self.__flags2 = flags2 & (flags2 ^ SMB.FLAGS2_UNICODE)\n\n        # Only supports NTLMv1\n        # Password is only encrypted if the server passed us an \"encryption key\" during protocol dialect negotiation\n        if self._dialects_parameters['ChallengeLength'] > 0:\n            if lmhash != '' or nthash != '':\n               pwd_ansi = self.get_ntlmv1_response(lmhash)\n               pwd_unicode = self.get_ntlmv1_response(nthash)\n            elif password:\n               lmhash = ntlm.compute_lmhash(password)\n               nthash = ntlm.compute_nthash(password)\n               pwd_ansi = self.get_ntlmv1_response(lmhash)\n               pwd_unicode = self.get_ntlmv1_response(nthash)\n            else: # NULL SESSION\n               pwd_ansi = ''\n               pwd_unicode = ''\n        else:\n            pwd_ansi = password\n            pwd_unicode = ''\n\n        smb = NewSMBPacket()\n\n        sessionSetup = SMBCommand(SMB.SMB_COM_SESSION_SETUP_ANDX)\n        sessionSetup['Parameters'] = SMBSessionSetupAndX_Parameters()\n        sessionSetup['Data']       = SMBSessionSetupAndX_Data()\n\n        sessionSetup['Parameters']['MaxBuffer']        = 61440\n        sessionSetup['Parameters']['MaxMpxCount']      = 2\n        sessionSetup['Parameters']['VCNumber']         = os.getpid() & 0xFFFF # Value has to be expressed in 2 bytes\n        sessionSetup['Parameters']['SessionKey']       = self._dialects_parameters['SessionKey']\n        sessionSetup['Parameters']['AnsiPwdLength']    = len(pwd_ansi)\n        sessionSetup['Parameters']['UnicodePwdLength'] = len(pwd_unicode)\n        sessionSetup['Parameters']['Capabilities']     = SMB.CAP_RAW_MODE | SMB.CAP_USE_NT_ERRORS | SMB.CAP_LARGE_READX | SMB.CAP_LARGE_WRITEX\n\n        sessionSetup['Data']['AnsiPwd']       = pwd_ansi\n        sessionSetup['Data']['UnicodePwd']    = pwd_unicode\n        sessionSetup['Data']['Account']       = str(user)\n        sessionSetup['Data']['PrimaryDomain'] = str(domain)\n        sessionSetup['Data']['NativeOS']      = str(os.name)\n        sessionSetup['Data']['NativeLanMan']  = 'pysmb'\n        smb.addCommand(sessionSetup)\n\n        self.sendSMB(smb)\n\n        smb = self.recvSMB()\n        if smb.isValidAnswer(SMB.SMB_COM_SESSION_SETUP_ANDX):\n            # We will need to use this uid field for all future requests/responses\n            self._uid = smb['Uid']\n            sessionResponse   = SMBCommand(smb['Data'][0])\n            sessionParameters = SMBSessionSetupAndXResponse_Parameters(sessionResponse['Parameters'])\n            sessionData       = SMBSessionSetupAndXResponse_Data(flags = smb['Flags2'], data = sessionResponse['Data'])\n\n            self._action = sessionParameters['Action']\n\n            # Still gotta figure out how to do this with no EXTENDED_SECURITY\n            if sessionParameters['Action'] & SMB_SETUP_USE_LANMAN_KEY == 0:\n                 self._SigningChallengeResponse = sessionSetup['Data']['UnicodePwd']\n                 self._SigningSessionKey = nthash\n            else:\n                 self._SigningChallengeResponse = sessionSetup['Data']['AnsiPwd']\n                 self._SigningSessionKey = lmhash\n\n            #self._SignSequenceNumber = 1\n            #self.checkSignSMB(smb, self._SigningSessionKey ,self._SigningChallengeResponse)\n            #self._SignatureEnabled = True\n            self.__server_os     = sessionData['NativeOS']\n            self.__server_lanman = sessionData['NativeLanMan']\n            self.__server_domain = sessionData['PrimaryDomain']\n\n            # restore unicode flag if needed\n            if flags2 & SMB.FLAGS2_UNICODE:\n                self.__flags2 |= SMB.FLAGS2_UNICODE\n\n            return 1\n        else:\n            raise Exception('Error: Could not login successfully')\n\n    def waitNamedPipe(self, tid, pipe, timeout = 5, noAnswer = 0):\n        smb = NewSMBPacket()\n        smb['Tid']    = tid\n\n        transCommand = SMBCommand(SMB.SMB_COM_TRANSACTION)\n        transCommand['Parameters'] = SMBTransaction_Parameters()\n        transCommand['Data'] = SMBTransaction_Data()\n\n        setup = '\\x53\\x00\\x00\\x00'\n        name = '\\\\PIPE%s\\x00' % pipe\n        transCommand['Parameters']['Setup'] = setup\n        transCommand['Parameters']['TotalParameterCount'] = 0\n        transCommand['Parameters']['TotalDataCount'] = 0\n        transCommand['Parameters']['MaxParameterCount'] = 0\n        transCommand['Parameters']['MaxDataCount'] = 0\n        transCommand['Parameters']['Timeout'] = timeout * 1000\n\n        transCommand['Parameters']['ParameterCount'] = 0\n        transCommand['Parameters']['ParameterOffset'] = 32+3+28+len(setup)+len(name)\n\n        transCommand['Parameters']['DataCount'] = 0\n        transCommand['Parameters']['DataOffset'] = 0\n\n        transCommand['Data']['Name'] = name\n        transCommand['Data']['Trans_Parameters'] = ''\n        transCommand['Data']['Trans_Data'] = ''\n\n        if noAnswer:\n           transCommand['Parameters']['Flags'] = TRANS_NO_RESPONSE\n\n        smb.addCommand(transCommand)\n        self.sendSMB(smb)\n\n        smb = self.recvSMB()\n        if smb.isValidAnswer(SMB.SMB_COM_TRANSACTION):\n           return 1\n        return 0\n\n    def read(self, tid, fid, offset=0, max_size = None, wait_answer=1):\n        if not max_size:\n            max_size = self._dialects_parameters['MaxBufferSize'] # Read in multiple KB blocks\n\n        # max_size is not working, because although it would, the server returns an error (More data avail)\n\n        smb = NewSMBPacket()\n        smb['Tid']    = tid\n\n        read = SMBCommand(SMB.SMB_COM_READ)\n        read['Parameters'] = SMBRead_Parameters()\n        read['Parameters']['Fid'] = fid\n        read['Parameters']['Offset'] = offset\n        read['Parameters']['Count'] = max_size\n        smb.addCommand(read)\n\n        if wait_answer:\n            while 1:\n                self.sendSMB(smb)\n                ans = self.recvSMB()\n\n                if ans.isValidAnswer(SMB.SMB_COM_READ):\n                    readResponse   = SMBCommand(ans['Data'][0])\n                    readData       = SMBReadResponse_Data(readResponse['Data'])\n\n                    return readData['Data']\n\n        return None\n\n    def read_andx(self, tid, fid, offset=0, max_size = None, wait_answer=1, smb_packet=None):\n        if not max_size:\n            if (self._dialects_parameters['Capabilities'] & SMB.CAP_LARGE_READX) and self._SignatureEnabled is False:\n                max_size = 65000\n            else:\n                max_size = self._dialects_parameters['MaxBufferSize'] # Read in multiple KB blocks\n\n        # max_size is not working, because although it would, the server returns an error (More data avail)\n\n        if smb_packet is None:\n            smb = NewSMBPacket()\n            smb['Tid']    = tid\n\n            readAndX = SMBCommand(SMB.SMB_COM_READ_ANDX)\n            readAndX['Parameters'] = SMBReadAndX_Parameters()\n            readAndX['Parameters']['Fid'] = fid\n            readAndX['Parameters']['Offset'] = offset\n            readAndX['Parameters']['MaxCount'] = max_size\n            smb.addCommand(readAndX)\n        else:\n            smb = smb_packet\n\n        if wait_answer:\n            answer = b''\n            while 1:\n                self.sendSMB(smb)\n                ans = self.recvSMB()\n\n                if ans.isValidAnswer(SMB.SMB_COM_READ_ANDX):\n                    # XXX Here we are only using a few fields from the response\n                    readAndXResponse   = SMBCommand(ans['Data'][0])\n                    readAndXParameters = SMBReadAndXResponse_Parameters(readAndXResponse['Parameters'])\n\n                    offset = readAndXParameters['DataOffset']\n                    count = readAndXParameters['DataCount']+0x10000*readAndXParameters['DataCount_Hi']\n                    answer += ans.getData()[offset:offset+count]\n                    if not ans.isMoreData():\n                        return answer\n                    max_size = min(max_size, readAndXParameters['Remaining'])\n                    readAndX['Parameters']['Offset'] += count                      # XXX Offset is not important (apparently)\n        else:\n            self.sendSMB(smb)\n            ans = self.recvSMB()\n\n            try:\n                if ans.isValidAnswer(SMB.SMB_COM_READ_ANDX):\n                    return ans\n                else:\n                    return None\n            except:\n                return ans\n\n        return None\n\n    def read_raw(self, tid, fid, offset=0, max_size = None, wait_answer=1):\n        if not max_size:\n            max_size = self._dialects_parameters['MaxBufferSize'] # Read in multiple KB blocks\n\n        # max_size is not working, because although it would, the server returns an error (More data avail)\n        smb = NewSMBPacket()\n        smb['Tid']    = tid\n\n        readRaw = SMBCommand(SMB.SMB_COM_READ_RAW)\n        readRaw['Parameters'] = SMBReadRaw_Parameters()\n        readRaw['Parameters']['Fid'] = fid\n        readRaw['Parameters']['Offset'] = offset\n        readRaw['Parameters']['MaxCount'] = max_size\n        smb.addCommand(readRaw)\n\n        self.sendSMB(smb)\n        if wait_answer:\n            data = self._sess.recv_packet(self.__timeout).get_trailer()\n            if not data:\n                # If there is no data it means there was an error\n                data = self.read_andx(tid, fid, offset, max_size)\n            return data\n\n        return None\n\n    def write(self,tid,fid,data, offset = 0, wait_answer=1):\n        smb = NewSMBPacket()\n        smb['Tid']    = tid\n\n        write = SMBCommand(SMB.SMB_COM_WRITE)\n        write['Parameters'] = SMBWrite_Parameters()\n        write['Data'] = SMBWrite_Data()\n        write['Parameters']['Fid'] = fid\n        write['Parameters']['Count'] = len(data)\n        write['Parameters']['Offset'] = offset\n        write['Parameters']['Remaining'] = len(data)\n        write['Data']['Data'] = data\n        smb.addCommand(write)\n\n        self.sendSMB(smb)\n\n        if wait_answer:\n            smb = self.recvSMB()\n            if smb.isValidAnswer(SMB.SMB_COM_WRITE):\n                return smb\n        return None\n\n    def write_andx(self,tid,fid,data, offset = 0, wait_answer=1, write_pipe_mode = False, smb_packet=None):\n        if smb_packet is None:\n            smb = NewSMBPacket()\n            smb['Tid']    = tid\n\n            writeAndX = SMBCommand(SMB.SMB_COM_WRITE_ANDX)\n            smb.addCommand(writeAndX)\n\n            writeAndX['Parameters'] = SMBWriteAndX_Parameters()\n            writeAndX['Parameters']['Fid'] = fid\n            writeAndX['Parameters']['Offset'] = offset\n            writeAndX['Parameters']['WriteMode'] = 8\n            writeAndX['Parameters']['Remaining'] = len(data)\n            writeAndX['Parameters']['DataLength'] = len(data)\n            writeAndX['Parameters']['DataOffset'] = len(smb)    # this length already includes the parameter\n            writeAndX['Data'] = data\n\n            if write_pipe_mode is True:\n                # First of all we gotta know what the MaxBuffSize is\n                maxBuffSize = self._dialects_parameters['MaxBufferSize']\n                if len(data) > maxBuffSize:\n                    chunks_size = maxBuffSize - 60\n                    writeAndX['Parameters']['WriteMode'] = 0x0c\n                    sendData = b'\\xff\\xff' + data\n                    totalLen = len(sendData)\n                    writeAndX['Parameters']['DataLength'] = chunks_size\n                    writeAndX['Parameters']['Remaining'] = totalLen-2\n                    writeAndX['Data'] = sendData[:chunks_size]\n\n                    self.sendSMB(smb)\n                    if wait_answer:\n                        smbResp = self.recvSMB()\n                        smbResp.isValidAnswer(SMB.SMB_COM_WRITE_ANDX)\n\n                    alreadySent = chunks_size\n                    sendData = sendData[chunks_size:]\n\n                    while alreadySent < totalLen:\n                        writeAndX['Parameters']['WriteMode'] = 0x04\n                        writeAndX['Parameters']['DataLength'] = len(sendData[:chunks_size])\n                        writeAndX['Data'] = sendData[:chunks_size]\n                        self.sendSMB(smb)\n                        if wait_answer:\n                            smbResp = self.recvSMB()\n                            smbResp.isValidAnswer(SMB.SMB_COM_WRITE_ANDX)\n                        alreadySent += writeAndX['Parameters']['DataLength']\n                        sendData = sendData[chunks_size:]\n\n                    return smbResp\n\n        else:\n            smb = smb_packet\n\n        self.sendSMB(smb)\n\n        if wait_answer:\n            smb = self.recvSMB()\n            if smb.isValidAnswer(SMB.SMB_COM_WRITE_ANDX):\n                return smb\n        return None\n\n    def write_raw(self,tid,fid,data, offset = 0, wait_answer=1):\n        LOG.warning(\"[MS-CIFS] This command was introduced in the CorePlus dialect, but is often listed as part of the LAN Manager 1.0 dialect.This command has been deprecated.Clients SHOULD use SMB_COM_WRITE_ANDX\")\n        smb = NewSMBPacket()\n        smb['Tid']    = tid\n\n        writeRaw = SMBCommand(SMB.SMB_COM_WRITE_RAW)\n        writeRaw['Parameters'] = SMBWriteRaw_Parameters()\n        writeRaw['Parameters']['Fid'] = fid\n        writeRaw['Parameters']['Offset'] = offset\n        writeRaw['Parameters']['Count'] = len(data)\n        writeRaw['Parameters']['DataLength'] = 0\n        writeRaw['Parameters']['DataOffset'] = 0\n        smb.addCommand(writeRaw)\n\n        self.sendSMB(smb)\n        self._sess.send_packet(data)\n\n        if wait_answer:\n            smb = self.recvSMB()\n            if smb.isValidAnswer(SMB.SMB_COM_WRITE_RAW):\n                return smb\n        return None\n\n    def TransactNamedPipe(self, tid, fid, data = '', noAnswer = 0, waitAnswer = 1, offset = 0):\n        self.send_trans(tid,pack('<HH', 0x26, fid),'\\\\PIPE\\\\\\x00','',data, noAnswer = noAnswer)\n\n        if noAnswer or not waitAnswer:\n            return\n        smb = self.recvSMB()\n        if smb.isValidAnswer(SMB.SMB_COM_TRANSACTION):\n           transResponse = SMBCommand(smb['Data'][0])\n           transParameters = SMBTransactionResponse_Parameters(transResponse['Parameters'])\n           return transResponse['Data'][-transParameters['TotalDataCount']:] # Remove Potential Prefix Padding\n        return None\n\n    def TransactNamedPipeRecv(self):\n        s = self.recvSMB()\n        if s.isValidAnswer(SMB.SMB_COM_TRANSACTION):\n           transResponse = SMBCommand(s['Data'][0])\n           transParameters = SMBTransactionResponse_Parameters(transResponse['Parameters'])\n           return transResponse['Data'][-transParameters['TotalDataCount']:] # Remove Potential Prefix Padding\n        return None\n\n    def nt_create_andx(self,tid,filename, smb_packet=None, cmd = None, shareAccessMode = FILE_SHARE_READ | FILE_SHARE_WRITE, disposition = FILE_OPEN, accessMask = 0x2019f):\n        filename = filename.replace('/', '\\\\')\n        filename = filename.encode('utf-16le') if self.__flags2 & SMB.FLAGS2_UNICODE else filename\n\n        if smb_packet is None:\n            smb = NewSMBPacket()\n            smb['Tid']    = tid\n        else:\n            smb = smb_packet\n\n        if cmd is None:\n            ntCreate = SMBCommand(SMB.SMB_COM_NT_CREATE_ANDX)\n            ntCreate['Parameters'] = SMBNtCreateAndX_Parameters()\n            ntCreate['Data']       = SMBNtCreateAndX_Data(flags=self.__flags2)\n            ntCreate['Parameters']['FileNameLength'] = len(filename)\n            ntCreate['Parameters']['CreateFlags'] = 0x16\n            ntCreate['Parameters']['AccessMask'] = accessMask\n            ntCreate['Parameters']['CreateOptions'] = 0x40\n            ntCreate['Parameters']['ShareAccess'] = shareAccessMode\n            ntCreate['Parameters']['Disposition'] = disposition\n            ntCreate['Data']['FileName'] = filename\n\n            if self.__flags2 & SMB.FLAGS2_UNICODE:\n                ntCreate['Data']['Pad'] = 0x0\n        else:\n            ntCreate = cmd\n\n        smb.addCommand(ntCreate)\n\n        self.sendSMB(smb)\n\n        while 1:\n            smb = self.recvSMB()\n            if smb.isValidAnswer(SMB.SMB_COM_NT_CREATE_ANDX):\n                # XXX Here we are ignoring the rest of the response\n                ntCreateResponse   = SMBCommand(smb['Data'][0])\n                ntCreateParameters = SMBNtCreateAndXResponse_Parameters(ntCreateResponse['Parameters'])\n\n                self.fid = ntCreateParameters['Fid']\n                return ntCreateParameters['Fid']\n\n    def logoff(self):\n        smb = NewSMBPacket()\n\n        logOff = SMBCommand(SMB.SMB_COM_LOGOFF_ANDX)\n        logOff['Parameters'] = SMBLogOffAndX()\n        smb.addCommand(logOff)\n\n        self.sendSMB(smb)\n        self.recvSMB()\n        # Let's clear some fields so you can login again under the same session\n        self._uid = 0\n\n    def list_path(self, service, path = '*', password = None):\n        path = path.replace('/', '\\\\')\n        path = path.encode('utf-16le') if self.__flags2 & SMB.FLAGS2_UNICODE else path\n\n        tid = self.tree_connect_andx('\\\\\\\\' + self.__remote_name + '\\\\' + service, password)\n        try:\n            findFirstParameter = SMBFindFirst2_Parameters(self.__flags2)\n            findFirstParameter['SearchAttributes'] = SMB_FILE_ATTRIBUTE_DIRECTORY | SMB_FILE_ATTRIBUTE_HIDDEN | \\\n                                                     SMB_FILE_ATTRIBUTE_SYSTEM | SMB_FILE_ATTRIBUTE_READONLY | \\\n                                                     SMB_FILE_ATTRIBUTE_ARCHIVE\n            findFirstParameter['SearchCount'] = 512\n            findFirstParameter['Flags'] = SMB_FIND_RETURN_RESUME_KEYS | SMB_FIND_CLOSE_AT_EOS\n            findFirstParameter['InformationLevel'] = SMB_FIND_FILE_BOTH_DIRECTORY_INFO\n            findFirstParameter['SearchStorageType'] = 0\n            if self.__flags2 & SMB.FLAGS2_UNICODE:\n                findFirstParameter['FileName'] = path + b'\\x00\\x00'\n            else:\n                findFirstParameter['FileName'] = path + '\\x00'\n            self.send_trans2(tid, SMB.TRANS2_FIND_FIRST2, '\\x00', findFirstParameter, '')\n            files = [ ]\n\n            totalDataCount = 1\n            findData = b''\n            findFirst2ParameterBlock = b''\n            while len(findData) < totalDataCount:\n                resp = self.recvSMB()\n\n                if resp.isValidAnswer(SMB.SMB_COM_TRANSACTION2):\n                    trans2Response = SMBCommand(resp['Data'][0])\n                    trans2Parameters = SMBTransaction2Response_Parameters(trans2Response['Parameters'])\n                    totalDataCount = trans2Parameters['TotalDataCount']\n                    findFirst2ParameterBlock += trans2Response['Data'][trans2Parameters['ParameterOffset']-55:][:trans2Parameters['ParameterCount']]\n                    findData += trans2Response['Data'][trans2Parameters['DataOffset']-55:]\n\n            findParameterBlock = SMBFindFirst2Response_Parameters(findFirst2ParameterBlock)\n            # Save the SID for resume operations\n            sid = findParameterBlock['SID']\n\n            while findParameterBlock['SearchCount'] > 0:\n                record = SMBFindFileBothDirectoryInfo(data = findData)\n\n                shortname = record['ShortName'].decode('utf-16le') if self.__flags2 & SMB.FLAGS2_UNICODE else \\\n                                                                        record['ShortName'].decode('cp437')\n                filename = record['FileName'].decode('utf-16le') if self.__flags2 & SMB.FLAGS2_UNICODE else \\\n                                                                        record['FileName'].decode('cp437')\n\n                fileRecord = SharedFile(record['CreationTime'], record['LastAccessTime'], record['LastChangeTime'],\n                                  record['EndOfFile'], record['AllocationSize'], record['ExtFileAttributes'],\n                                  shortname, filename)\n                files.append(fileRecord)\n                if record['NextEntryOffset'] > 0 and len(findData[record['NextEntryOffset']:]) > 0:\n                    findData = findData[record['NextEntryOffset']:]\n                else:\n                    # More data to search?\n                    if findParameterBlock['EndOfSearch'] == 0:\n                        resume_filename = record['FileName']\n                        findNextParameter = SMBFindNext2_Parameters()\n                        findNextParameter['SID'] = sid\n                        findNextParameter['SearchCount'] = 1024\n                        findNextParameter['InformationLevel'] = SMB_FIND_FILE_BOTH_DIRECTORY_INFO\n                        findNextParameter['ResumeKey'] = 0\n                        findNextParameter['Flags'] = SMB_FIND_RETURN_RESUME_KEYS | SMB_FIND_CLOSE_AT_EOS\n                        if self.__flags2 & SMB.FLAGS2_UNICODE:\n                            findNextParameter['FileName'] = resume_filename + b'\\x00\\x00'\n                        else:\n                            findNextParameter['FileName'] = resume_filename + b'\\x00'\n                        self.send_trans2(tid, SMB.TRANS2_FIND_NEXT2, '\\x00', findNextParameter, '')\n                        findData = b''\n                        findNext2ParameterBlock = b''\n                        totalDataCount = 1\n                        while len(findData) < totalDataCount:\n                            resp = self.recvSMB()\n\n                            if resp.isValidAnswer(SMB.SMB_COM_TRANSACTION2):\n                                trans2Response = SMBCommand(resp['Data'][0])\n                                trans2Parameters = SMBTransaction2Response_Parameters(trans2Response['Parameters'])\n                                totalDataCount = trans2Parameters['TotalDataCount']\n                                findNext2ParameterBlock += trans2Response['Data'][trans2Parameters['ParameterOffset']-55:][:trans2Parameters['ParameterCount']]\n                                findData += trans2Response['Data'][trans2Parameters['DataOffset']-55:]\n                                findParameterBlock = SMBFindNext2Response_Parameters(findNext2ParameterBlock)\n                    else:\n                       break\n        finally:\n            self.disconnect_tree(tid)\n\n        return files\n\n    def retr_file(self, service, filename, callback, mode = FILE_OPEN, offset = 0, password = None, shareAccessMode = SMB_ACCESS_READ):\n        filename = filename.replace('/', '\\\\')\n\n        fid = -1\n        tid = self.tree_connect_andx('\\\\\\\\' + self.__remote_name + '\\\\' + service, password)\n        try:\n            fid = self.nt_create_andx(tid, filename, shareAccessMode = shareAccessMode, accessMask = 0x20089)\n\n            res = self.query_file_info(tid, fid)\n            datasize = SMBQueryFileStandardInfo(res)['EndOfFile']\n\n            self.__nonraw_retr_file(tid, fid, offset, datasize, callback)\n        finally:\n            if fid >= 0:\n                self.close(tid, fid)\n            self.disconnect_tree(tid)\n\n    def stor_file(self, service, filename, callback, mode = FILE_OVERWRITE_IF, offset = 0, password = None, shareAccessMode = SMB_ACCESS_WRITE):\n        filename = filename.replace('/', '\\\\')\n\n        fid = -1\n        tid = self.tree_connect_andx('\\\\\\\\' + self.__remote_name + '\\\\' + service, password)\n        try:\n            fid = self.nt_create_andx(tid, filename, shareAccessMode = shareAccessMode, disposition = mode )\n\n            self.__nonraw_stor_file(tid, fid, offset, 0, callback)\n        finally:\n            if fid >= 0:\n                self.close(tid, fid)\n            self.disconnect_tree(tid)\n\n    def stor_file_nonraw(self, service, filename, callback, mode = FILE_OVERWRITE_IF, offset = 0, password = None, shareAccessMode = SMB_ACCESS_WRITE ):\n        filename = filename.replace('/', '\\\\')\n\n        fid = -1\n        tid = self.tree_connect_andx('\\\\\\\\' + self.__remote_name + '\\\\' + service, password)\n        try:\n            fid = self.nt_create_andx(tid, filename, shareAccessMode = shareAccessMode, disposition = mode)\n            self.__nonraw_stor_file(tid, fid, offset, 0, callback)\n        finally:\n            if fid >= 0:\n                self.close(tid, fid)\n            self.disconnect_tree(tid)\n\n    def check_dir(self, service, path, password = None):\n        path = path.replace('/', '\\\\')\n        tid = self.tree_connect_andx('\\\\\\\\' + self.__remote_name + '\\\\' + service, password)\n        try:\n            smb = NewSMBPacket()\n            smb['Tid'] = tid\n            smb['Mid'] = 0\n\n            cmd = SMBCommand(SMB.SMB_COM_CHECK_DIRECTORY)\n            cmd['Parameters'] = ''\n            cmd['Data'] = SMBCheckDirectory_Data(flags = self.__flags2)\n            cmd['Data']['DirectoryName'] = path.encode('utf-16le') if self.__flags2 & SMB.FLAGS2_UNICODE else path\n            smb.addCommand(cmd)\n\n            self.sendSMB(smb)\n\n            while 1:\n                s = self.recvSMB()\n                if s.isValidAnswer(SMB.SMB_COM_CHECK_DIRECTORY):\n                    return\n        finally:\n            self.disconnect_tree(tid)\n\n    def remove(self, service, path, password = None):\n        path = path.replace('/', '\\\\')\n        # Perform a list to ensure the path exists\n        self.list_path(service, path, password)\n\n        tid = self.tree_connect_andx('\\\\\\\\' + self.__remote_name + '\\\\' + service, password)\n        try:\n            smb = NewSMBPacket()\n            smb['Tid'] = tid\n            smb['Mid'] = 0\n\n            cmd = SMBCommand(SMB.SMB_COM_DELETE)\n            cmd['Parameters'] = SMBDelete_Parameters()\n            cmd['Parameters']['SearchAttributes'] = ATTR_HIDDEN | ATTR_SYSTEM | ATTR_ARCHIVE\n            cmd['Data'] = SMBDelete_Data(flags = self.__flags2)\n            cmd['Data']['FileName'] = (path + '\\x00').encode('utf-16le') if self.__flags2 & SMB.FLAGS2_UNICODE else (path + '\\x00')\n            smb.addCommand(cmd)\n\n            self.sendSMB(smb)\n\n            while 1:\n                s = self.recvSMB()\n                if s.isValidAnswer(SMB.SMB_COM_DELETE):\n                    return\n        finally:\n            self.disconnect_tree(tid)\n\n    def rmdir(self, service, path, password = None):\n        path = path.replace('/', '\\\\')\n        # Check that the directory exists\n        self.check_dir(service, path, password)\n\n        tid = self.tree_connect_andx('\\\\\\\\' + self.__remote_name + '\\\\' + service, password)\n        try:\n            path = path.encode('utf-16le') if self.__flags2 & SMB.FLAGS2_UNICODE else path\n\n            smb = NewSMBPacket()\n            smb['Tid'] = tid\n            createDir = SMBCommand(SMB.SMB_COM_DELETE_DIRECTORY)\n            createDir['Data'] = SMBDeleteDirectory_Data(flags=self.__flags2)\n            createDir['Data']['DirectoryName'] = path\n            smb.addCommand(createDir)\n\n            self.sendSMB(smb)\n\n            while 1:\n                s = self.recvSMB()\n                if s.isValidAnswer(SMB.SMB_COM_DELETE_DIRECTORY):\n                    return\n        finally:\n            self.disconnect_tree(tid)\n\n    def mkdir(self, service, path, password = None):\n        path = path.replace('/', '\\\\')\n        tid = self.tree_connect_andx('\\\\\\\\' + self.__remote_name + '\\\\' + service, password)\n        try:\n            path = path.encode('utf-16le') if self.__flags2 & SMB.FLAGS2_UNICODE else path\n\n            smb = NewSMBPacket()\n            smb['Tid'] = tid\n            smb['Mid'] = 0\n\n            createDir = SMBCommand(SMB.SMB_COM_CREATE_DIRECTORY)\n            createDir['Data'] = SMBCreateDirectory_Data(flags=self.__flags2)\n            createDir['Data']['DirectoryName'] = path\n            smb.addCommand(createDir)\n\n            self.sendSMB(smb)\n\n            smb = self.recvSMB()\n            if smb.isValidAnswer(SMB.SMB_COM_CREATE_DIRECTORY):\n                return 1\n            return 0\n        finally:\n            self.disconnect_tree(tid)\n\n    def rename(self, service, old_path, new_path, password = None):\n        old_path = old_path.replace('/', '\\\\')\n        new_path = new_path.replace('/', '\\\\')\n        tid = self.tree_connect_andx('\\\\\\\\' + self.__remote_name + '\\\\' + service, password)\n        try:\n            smb = NewSMBPacket()\n            smb['Tid'] = tid\n            smb['Mid'] = 0\n\n            renameCmd = SMBCommand(SMB.SMB_COM_RENAME)\n            renameCmd['Parameters'] = SMBRename_Parameters()\n            renameCmd['Parameters']['SearchAttributes'] = ATTR_SYSTEM | ATTR_HIDDEN | ATTR_DIRECTORY\n            renameCmd['Data'] = SMBRename_Data(flags = self.__flags2)\n            renameCmd['Data']['OldFileName'] = old_path.encode('utf-16le') if self.__flags2 & SMB.FLAGS2_UNICODE else old_path\n            renameCmd['Data']['NewFileName'] = new_path.encode('utf-16le') if self.__flags2 & SMB.FLAGS2_UNICODE else new_path\n            smb.addCommand(renameCmd)\n\n            self.sendSMB(smb)\n\n            smb = self.recvSMB()\n            if smb.isValidAnswer(SMB.SMB_COM_RENAME):\n               return 1\n            return 0\n        finally:\n            self.disconnect_tree(tid)\n\n    def writeFile(self, treeId, fileId, data, offset = 0):\n        if (self._dialects_parameters['Capabilities'] & SMB.CAP_LARGE_WRITEX) and self._SignatureEnabled is False:\n            max_buf_size = 65000\n        else:\n            max_buf_size = self._dialects_parameters['MaxBufferSize'] & ~0x3ff  # Write in multiple KB blocks\n\n        write_offset = offset\n        while 1:\n            if len(data) == 0:\n                break\n            writeData = data[:max_buf_size]\n            data = data[max_buf_size:]\n\n            smb = self.write_andx(treeId,fileId,writeData, write_offset)\n            writeResponse   = SMBCommand(smb['Data'][0])\n            writeResponseParameters = SMBWriteAndXResponse_Parameters(writeResponse['Parameters'])\n            write_offset += writeResponseParameters['Count']\n\n    def get_socket(self):\n        return self._sess.get_socket()\n\n    def send_nt_trans(self, tid, subcommand, max_param_count, setup='', param='', data=''):\n        \"\"\"\n        [MS-CIFS]: 2.2.4.62.1 SMB_COM_NT_TRANSACT request.\n        :param tid:\n        :param subcommand: The transaction subcommand code\n        :param max_param_count:  This field MUST be set as specified in the subsections of Transaction subcommands.\n        :param setup: Transaction context to the server, depends on transaction subcommand.\n        :param param: Subcommand parameter bytes if any, depends on transaction subcommand.\n        :param data: Subcommand data bytes if any, depends on transaction subcommand.\n        :return: Buffer relative to requested subcommand.\n        \"\"\"\n        smb_packet = NewSMBPacket()\n        smb_packet['Tid'] = tid\n        #    setup depends on NT_TRANSACT subcommands so it may be 0.\n        setup_bytes = pack('<H', setup) if setup != '' else ''\n\n        transCommand = SMBCommand(SMB.SMB_COM_NT_TRANSACT)\n        transCommand['Parameters'] = SMBNTTransaction_Parameters()\n        transCommand['Parameters']['MaxDataCount'] = self._dialects_parameters['MaxBufferSize']\n        transCommand['Parameters']['Setup'] = setup_bytes\n        transCommand['Parameters']['Function'] = subcommand\n        transCommand['Parameters']['TotalParameterCount'] = len(param)\n        transCommand['Parameters']['TotalDataCount'] = len(data)\n        transCommand['Parameters']['MaxParameterCount'] = max_param_count\n        transCommand['Parameters']['MaxSetupCount'] = 0\n\n        transCommand['Data'] = SMBNTTransaction_Data()\n\n        # SMB header size + SMB_COM_NT_TRANSACT parameters size + length of setup bytes.\n        offset = 32 + 3 + 38 + len(setup_bytes)\n        transCommand['Data']['Pad1'] = ''\n        if offset % 4 != 0:\n            transCommand['Data']['Pad1'] = '\\0' * (4 - offset % 4)\n            offset += (4 - offset % 4)  # pad1 length\n\n        if len(param) > 0:\n            transCommand['Parameters']['ParameterOffset'] = offset\n        else:\n            transCommand['Parameters']['ParameterOffset'] = 0\n\n        offset += len(param)\n        transCommand['Data']['Pad2'] = ''\n        if offset % 4 != 0:\n            transCommand['Data']['Pad2'] = '\\0' * (4 - offset % 4)\n            offset += (4 - offset % 4)\n\n        if len(data) > 0:\n            transCommand['Parameters']['DataOffset'] = offset\n        else:\n            transCommand['Parameters']['DataOffset'] = 0\n\n        transCommand['Parameters']['DataCount'] = len(data)\n        transCommand['Parameters']['ParameterCount'] = len(param)\n        transCommand['Data']['NT_Trans_Parameters'] = param\n        transCommand['Data']['NT_Trans_Data'] = data\n        smb_packet.addCommand(transCommand)\n\n        self.sendSMB(smb_packet)\n\n    def query_sec_info(self, tid, fid, additional_information=7):\n        \"\"\"\n        [MS-CIFS]: 2.2.7.6.1\n        NT_TRANSACT_QUERY_SECURITY_DESC 0x0006\n        :param tid: valid tree id.\n        :param fid: valid file handle.\n        :param additional_information: SecurityInfoFields. default = owner + group + dacl ie. 7\n        :return: security descriptor buffer\n        \"\"\"\n        self.send_nt_trans(tid, subcommand=0x0006, max_param_count=4,\n                           param=pack('<HHL', fid, 0x0000, additional_information))\n        resp = self.recvSMB()\n        if resp.isValidAnswer(SMB.SMB_COM_NT_TRANSACT):\n            nt_trans_response = SMBCommand(resp['Data'][0])\n            nt_trans_parameters = SMBNTTransactionResponse_Parameters(nt_trans_response['Parameters'])\n            # Remove Potential Prefix Padding\n            return nt_trans_response['Data'][-nt_trans_parameters['TotalDataCount']:]\n\n    def echo(self, text = '', count = 1):\n\n        smb = NewSMBPacket()\n        comEcho = SMBCommand(SMB.SMB_COM_ECHO)\n        comEcho['Parameters'] = SMBEcho_Parameters()\n        comEcho['Data']       = SMBEcho_Data()\n        comEcho['Parameters']['EchoCount'] = count\n        comEcho['Data']['Data'] = text\n        smb.addCommand(comEcho)\n\n        self.sendSMB(smb)\n\n        for i in range(count):\n            resp = self.recvSMB()\n            resp.isValidAnswer(SMB.SMB_COM_ECHO)\n        return True",
  "def __init__( self, error_string, error_class, error_code, nt_status = 0, packet=0):\n        Exception.__init__(self, error_string)\n        self.nt_status = nt_status\n        self._args = error_string\n        if nt_status:\n           self.error_class = 0\n           self.error_code  = (error_code << 16) + error_class\n        else:\n           self.error_class = error_class\n           self.error_code = error_code\n        self.packet = packet",
  "def get_error_class( self ):\n        return self.error_class",
  "def get_error_code( self ):\n        return self.error_code",
  "def get_error_packet(self):\n        return self.packet",
  "def __str__( self ):\n        error_class = SessionError.error_classes.get( self.error_class, None )\n        if not error_class:\n            error_code_str = self.error_code\n            error_class_str = self.error_class\n        else:\n            error_class_str = error_class[0]\n            error_code = error_class[1].get( self.error_code, None )\n            if not error_code:\n                error_code_str = self.error_code\n            else:\n                error_code_str = '%s(%s)' % error_code\n\n        if self.nt_status:\n            return 'SMB SessionError: %s(%s)' % nt_errors.ERROR_MESSAGES[self.error_code]\n        else:\n            # Fall back to the old format\n            return 'SMB SessionError: class: %s, code: %s' % (error_class_str, error_code_str)",
  "def __init__(self, name, share_type, comment):\n        self.__name = name\n        self.__type = share_type\n        self.__comment = comment",
  "def get_name(self):\n        return self.__name",
  "def get_type(self):\n        return self.__type",
  "def get_comment(self):\n        return self.__comment",
  "def __repr__(self):\n        return '<SharedDevice instance: name=' + self.__name + ', type=' + str(self.__type) + ', comment=\"' + self.__comment + '\">'",
  "def __init__(self, ctime, atime, mtime, filesize, allocsize, attribs, shortname, longname):\n        self.__ctime = ctime\n        self.__atime = atime\n        self.__mtime = mtime\n        self.__filesize = filesize\n        self.__allocsize = allocsize\n        self.__attribs = attribs\n        try:\n            if isinstance(shortname,bytes):\n                self.__shortname = shortname[:shortname.index(b'\\0')]\n            else:\n                self.__shortname = shortname[:shortname.index('\\0')]\n        except (ValueError, TypeError):\n            self.__shortname = shortname\n        try:\n            if isinstance(shortname,bytes):\n                self.__longname = longname[:longname.index(b'\\0')]\n            else:\n                self.__longname = longname[:longname.index('\\0')]\n        except (ValueError, TypeError):\n            self.__longname = longname",
  "def get_ctime(self):\n        return self.__ctime",
  "def get_ctime_epoch(self):\n        return self.__convert_smbtime(self.__ctime)",
  "def get_mtime(self):\n        return self.__mtime",
  "def get_mtime_epoch(self):\n        return self.__convert_smbtime(self.__mtime)",
  "def get_atime(self):\n        return self.__atime",
  "def get_atime_epoch(self):\n        return self.__convert_smbtime(self.__atime)",
  "def get_filesize(self):\n        return self.__filesize",
  "def get_allocsize(self):\n        return self.__allocsize",
  "def get_attributes(self):\n        return self.__attribs",
  "def is_archive(self):\n        return self.__attribs & ATTR_ARCHIVE",
  "def is_compressed(self):\n        return self.__attribs & ATTR_COMPRESSED",
  "def is_normal(self):\n        return self.__attribs & ATTR_NORMAL",
  "def is_hidden(self):\n        return self.__attribs & ATTR_HIDDEN",
  "def is_readonly(self):\n        return self.__attribs & ATTR_READONLY",
  "def is_temporary(self):\n        return self.__attribs & ATTR_TEMPORARY",
  "def is_directory(self):\n        return self.__attribs & ATTR_DIRECTORY",
  "def is_system(self):\n        return self.__attribs & ATTR_SYSTEM",
  "def get_shortname(self):\n        return self.__shortname",
  "def get_longname(self):\n        return self.__longname",
  "def __repr__(self):\n        return '<SharedFile instance: shortname=\"' + self.__shortname + '\", longname=\"' + self.__longname + '\", filesize=' + str(self.__filesize) + '>'",
  "def __convert_smbtime(t):\n        x = t >> 32\n        y = t & 0xffffffff\n        geo_cal_offset = 11644473600.0  # = 369.0 * 365.25 * 24 * 60 * 60 - (3.0 * 24 * 60 * 60 + 6.0 * 60 * 60)\n        return (x * 4.0 * (1 << 30) + (y & 0xfff00000)) * 1.0e-7 - geo_cal_offset",
  "def __init__(self, nbname, nbt_type, comment):\n        self.__nbname = nbname\n        self.__type = nbt_type\n        self.__comment = comment",
  "def __repr__(self):\n        return '<SMBMachine instance: nbname=\"' + self.__nbname + '\", type=' + hex(self.__type) + ', comment=\"' + self.__comment + '\">'",
  "def __init__(self, nbgroup, domain_type, master_browser):\n        self.__nbgroup = nbgroup\n        self.__type = domain_type\n        self.__master_browser = master_browser",
  "def __repr__(self):\n        return '<SMBDomain instance: nbgroup=\"' + self.__nbgroup + '\", type=' + hex(self.__type) + ', master browser=\"' + self.__master_browser + '\">'",
  "def __init__(self, **kargs):\n        Structure.__init__(self, **kargs)\n\n        if ('Flags2' in self.fields) is False:\n             self['Flags2'] = 0\n        if ('Flags1' in self.fields) is False:\n             self['Flags1'] = 0\n\n        if 'data' not in kargs:\n            self['Data'] = []",
  "def addCommand(self, command):\n        if len(self['Data']) == 0:\n            self['Command'] = command.command\n        else:\n            self['Data'][-1]['Parameters']['AndXCommand'] = command.command\n            self['Data'][-1]['Parameters']['AndXOffset'] = len(self)\n        self['Data'].append(command)",
  "def isMoreData(self):\n        return (self['Command'] in [SMB.SMB_COM_TRANSACTION, SMB.SMB_COM_READ_ANDX, SMB.SMB_COM_READ_RAW] and\n                self['ErrorClass'] == 1 and self['ErrorCode'] == SessionError.ERRmoredata)",
  "def isMoreProcessingRequired(self):\n        return self['ErrorClass'] == 0x16 and self['ErrorCode'] == 0xc000",
  "def isValidAnswer(self, cmd):\n        # this was inside a loop reading more from the net (with recv_packet(None))\n        if self['Command'] == cmd:\n            if (self['ErrorClass'] == 0x00 and self['ErrorCode']  == 0x00):\n                    return 1\n            elif self.isMoreData():\n                return 1\n            elif self.isMoreProcessingRequired():\n                return 1\n            raise SessionError(\"SMB Library Error\", self['ErrorClass'] + (self['_reserved'] << 8), self['ErrorCode'], self['Flags2'] & SMB.FLAGS2_NT_STATUS, self)\n        else:\n            raise UnsupportedFeature(\"Unexpected answer from server: Got %d, Expected %d\" % (self['Command'], cmd))",
  "def __init__(self, commandOrData = None, data = None, **kargs):\n        if type(commandOrData) == type(0):\n            self.command = commandOrData\n        else:\n            data = data or commandOrData\n\n        Structure.__init__(self, data = data, **kargs)\n\n        if data is None:\n            self['Parameters'] = ''\n            self['Data']       = ''",
  "def __init__(self, flags = 0, **kargs):\n        if flags & SMB.FLAGS2_UNICODE:\n            self.structure = self.UnicodeStructure\n        else:\n            self.structure = self.AsciiStructure\n        Structure.__init__(self, **kargs)",
  "def getData(self):\n        if self.structure == self.UnicodeStructure:\n            if len(str(self['SecurityBlob'])) % 2 == 0:\n                self['Pad'] = '\\x00'\n        return AsciiOrUnicodeStructure.getData(self)",
  "def __init__(self,data = None, alignment = 0):\n         Structure.__init__(self,data,alignment)",
  "def fromString(self,data):\n        Structure.fromString(self,data)\n        self['DomainName'] = ''\n        self['ServerName'] = ''",
  "class HostnameValidationException(Exception):\n        pass",
  "def __init__(self, remote_name, remote_host, my_name=None, host_type=nmb.TYPE_SERVER, sess_port=445, timeout=None,\n                 UDP=0, session=None, negPacket=None):\n        # The uid attribute will be set when the client calls the login() method\n        self._uid = 0\n        self.__server_name = ''\n        self.__client_name = ''\n        self.__server_os = ''\n        self.__server_os_major = None\n        self.__server_os_minor = None\n        self.__server_os_build = None\n        self.__server_lanman = ''\n        self.__server_domain = ''\n        self.__server_dns_domain_name = ''\n        self.__server_dns_host_name = ''\n        self.__remote_name = remote_name.upper()\n        self.__remote_host = remote_host\n        self.__isNTLMv2 = True\n        self._dialects_parameters = None\n        self._dialects_data = None\n        self._doKerberos = False\n\n        # Credentials\n        self.__userName = b''\n        self.__password = b''\n        self.__domain   = b''\n        self.__lmhash   = b''\n        self.__nthash   = b''\n        self.__aesKey   = b''\n        self.__kdc      = b''\n        self.__TGT      = None\n        self.__TGS      = None\n\n        # Negotiate Protocol Result, used everywhere\n        # Could be extended or not, flags should be checked before\n        self._dialect_data = 0\n        self._dialect_parameters = 0\n        self._action = 0\n        self._sess = None\n        self.encrypt_passwords = True\n        self.tid = 0\n        self.fid = 0\n\n        # Strict host validation - off by default\n        self._strict_hostname_validation = False\n        self._validation_allow_absent = True\n        self._accepted_hostname = ''\n\n        # Signing stuff\n        self._SignSequenceNumber = 0\n        self._SigningSessionKey = b''\n        self._SigningChallengeResponse = b''\n        self._SignatureEnabled = False\n        self._SignatureVerificationEnabled = False\n        self._SignatureRequired = False\n\n        # Base flags (default flags, can be overridden using set_flags())\n        self.__flags1 = SMB.FLAGS1_PATHCASELESS | SMB.FLAGS1_CANONICALIZED_PATHS\n        self.__flags2 = SMB.FLAGS2_EXTENDED_SECURITY | SMB.FLAGS2_NT_STATUS | SMB.FLAGS2_LONG_NAMES\n\n        if timeout is None:\n            self.__timeout = 60\n        else:\n            self.__timeout = timeout\n\n        # If port 445 and the name sent is *SMBSERVER we're setting the name to the IP.\n        # This is to help some old applications still believing\n        # *SMSBSERVER will work against modern OSes. If port is NETBIOS_SESSION_PORT the user better\n        # know about *SMBSERVER's limitations\n        if sess_port == 445 and remote_name == '*SMBSERVER':\n           self.__remote_name = remote_host\n\n        # This is on purpose. I'm still not convinced to do a socket.gethostname() if not specified\n        if my_name is None:\n            self.__client_name = b''\n        else:\n            self.__client_name = my_name\n\n        if session is None:\n            if not my_name:\n                # If destination port is 139 yes, there's some client disclosure\n                my_name = socket.gethostname()\n                i = my_name.find('.')\n                if i > -1:\n                    my_name = my_name[:i]\n\n            if UDP:\n                self._sess = nmb.NetBIOSUDPSession(my_name, remote_name, remote_host, host_type, sess_port, self.__timeout)\n            else:\n                self._sess = nmb.NetBIOSTCPSession(my_name, remote_name, remote_host, host_type, sess_port, self.__timeout)\n\n                # Initialize session values (_dialect_data and _dialect_parameters)\n                self.neg_session()\n\n                # Call login() without any authentication information to\n                # setup a session if the remote server\n                # is in share mode.\n                if (self._dialects_parameters['SecurityMode'] & SMB.SECURITY_SHARE_MASK) == SMB.SECURITY_SHARE_SHARE:\n                    self.login('', '')\n        else:\n            self._sess = session\n            self.neg_session(negPacket = negPacket)\n            # Call login() without any authentication information to\n            # setup a session if the remote server\n            # is in share mode.\n            if (self._dialects_parameters['SecurityMode'] & SMB.SECURITY_SHARE_MASK) == SMB.SECURITY_SHARE_SHARE:\n                self.login('', '')",
  "def ntlm_supported():\n        return False",
  "def getKerberos(self):\n        return self._doKerberos",
  "def get_remote_name(self):\n        return self.__remote_name",
  "def set_remote_name(self, name):\n        self.__remote_name = name\n        return True",
  "def set_hostname_validation(self, validate, accept_empty, hostname):\n        self._strict_hostname_validation = validate\n        self._validation_allow_absent = accept_empty\n        self._accepted_hostname = hostname",
  "def get_remote_host(self):\n        return self.__remote_host",
  "def get_flags(self):\n        return self.__flags1, self.__flags2",
  "def set_flags(self, flags1=None, flags2=None):\n        if flags1 is not None:\n           self.__flags1 = flags1\n        if flags2 is not None:\n           self.__flags2 = flags2",
  "def set_timeout(self, timeout):\n        prev_timeout = self.__timeout\n        self.__timeout = timeout\n        return prev_timeout",
  "def get_timeout(self):\n        return self.__timeout",
  "def use_timeout(self, timeout):\n        prev_timeout = self.set_timeout(timeout)\n        try:\n            yield\n        finally:\n            self.set_timeout(prev_timeout)",
  "def get_session(self):\n        return self._sess",
  "def get_tid(self):\n        return self.tid",
  "def get_fid(self):\n        return self.fid",
  "def isGuestSession(self):\n        return self._action & SMB_SETUP_GUEST",
  "def doesSupportNTLMv2(self):\n        return self.__isNTLMv2",
  "def close_session(self):\n        if self._sess:\n            self._sess.close()\n            self._sess = None",
  "def recvSMB(self):\n        r = self._sess.recv_packet(self.__timeout)\n        return NewSMBPacket(data = r.get_trailer())",
  "def __decode_trans(params, data):\n        totparamcnt, totdatacnt, _, paramcnt, paramoffset, paramds, datacnt, dataoffset, datads, setupcnt = unpack('<HHHHHHHHHB', params[:19])\n        if paramcnt + paramds < totparamcnt or datacnt + datads < totdatacnt:\n            has_more = 1\n        else:\n            has_more = 0\n        paramoffset = paramoffset - 55 - setupcnt * 2\n        dataoffset = dataoffset - 55 - setupcnt * 2\n        return has_more, params[20:20 + setupcnt * 2], data[paramoffset:paramoffset + paramcnt], data[dataoffset:dataoffset + datacnt]",
  "def signSMB(self, packet, signingSessionKey, signingChallengeResponse):\n        # This logic MUST be applied for messages sent in response to any of the higher-layer actions and in\n        # compliance with the message sequencing rules.\n        #  * The client or server that sends the message MUST provide the 32-bit sequence number for this\n        #    message, as specified in sections 3.2.4.1 and 3.3.4.1.\n        #  * The SMB_FLAGS2_SMB_SECURITY_SIGNATURE flag in the header MUST be set.\n        #  * To generate the signature, a 32-bit sequence number is copied into the\n        #    least significant 32 bits of the SecuritySignature field and the remaining\n        #    4 bytes are set to 0x00.\n        #  * The MD5 algorithm, as specified in [RFC1321], MUST be used to generate a hash of the SMB\n        #    message from the start of the SMB Header, which is defined as follows.\n        #    CALL MD5Init( md5context )\n        #    CALL MD5Update( md5context, Connection.SigningSessionKey )\n        #    CALL MD5Update( md5context, Connection.SigningChallengeResponse )\n        #    CALL MD5Update( md5context, SMB message )\n        #    CALL MD5Final( digest, md5context )\n        #    SET signature TO the first 8 bytes of the digest\n        # The resulting 8-byte signature MUST be copied into the SecuritySignature field of the SMB Header,\n        # after which the message can be transmitted.\n\n        #print \"seq(%d) signingSessionKey %r, signingChallengeResponse %r\" % (self._SignSequenceNumber, signingSessionKey, signingChallengeResponse)\n        packet['SecurityFeatures'] = pack('<q',self._SignSequenceNumber)\n        # Sign with the sequence\n        m = hashlib.md5()\n        m.update( signingSessionKey )\n        m.update( signingChallengeResponse )\n        m.update( packet.getData() )\n        # Replace sequence with acual hash\n        packet['SecurityFeatures'] = m.digest()[:8]\n        if self._SignatureVerificationEnabled:\n           self._SignSequenceNumber +=1\n        else:\n           self._SignSequenceNumber +=2",
  "def checkSignSMB(self, packet, signingSessionKey, signingChallengeResponse):\n        # Let's check\n        signature = packet['SecurityFeatures']\n        #print \"Signature received: %r \" % signature\n        self.signSMB(packet, signingSessionKey, signingChallengeResponse)\n        #print \"Signature calculated: %r\" % packet['SecurityFeatures']\n        if self._SignatureVerificationEnabled is not True:\n           self._SignSequenceNumber -= 1\n        return packet['SecurityFeatures'] == signature",
  "def sendSMB(self,smb):\n        smb['Uid'] = self._uid\n        #At least on AIX, PIDs can exceed 16 bits, so we mask them out\n        smb['Pid'] = (os.getpid() & 0xFFFF)\n        # set flags\n        smb['Flags1'] |= self.__flags1\n        smb['Flags2'] |= self.__flags2\n        if self._SignatureEnabled:\n            smb['Flags2'] |= SMB.FLAGS2_SMB_SECURITY_SIGNATURE\n            self.signSMB(smb, self._SigningSessionKey, self._SigningChallengeResponse)\n\n        self._sess.send_packet(smb.getData())",
  "def isValidAnswer(s, cmd):\n        while 1:\n            if s.rawData():\n                if s.get_command() == cmd:\n                    if s.get_error_class() == 0x00 and s.get_error_code() == 0x00:\n                        return 1\n                    else:\n                        raise SessionError( \"SMB Library Error\", s.get_error_class()+ (s.get_reserved() << 8), s.get_error_code() , s.get_flags2() & SMB.FLAGS2_NT_STATUS)\n                else:\n                    break\n        return 0",
  "def neg_session(self, extended_security = True, negPacket = None):\n        def parsePacket(smb):\n            # If server speaks Unicode, let's set that flag from now on\n            if smb['Flags2'] & SMB.FLAGS2_UNICODE:\n                self.__flags2 |= SMB.FLAGS2_UNICODE\n\n            if smb.isValidAnswer(SMB.SMB_COM_NEGOTIATE):\n                sessionResponse = SMBCommand(smb['Data'][0])\n                self._dialects_parameters = SMBNTLMDialect_Parameters(sessionResponse['Parameters'])\n                self._dialects_data = SMBNTLMDialect_Data()\n                self._dialects_data['ChallengeLength'] = self._dialects_parameters['ChallengeLength']\n                self._dialects_data.fromString(sessionResponse['Data'])\n                if self._dialects_parameters['Capabilities'] & SMB.CAP_EXTENDED_SECURITY:\n                    # Whether we choose it or it is enforced by the server, we go for extended security\n                    self._dialects_parameters = SMBExtended_Security_Parameters(sessionResponse['Parameters'])\n                    self._dialects_data = SMBExtended_Security_Data(sessionResponse['Data'])\n                    # Let's setup some variable for later use\n                    if self._dialects_parameters['SecurityMode'] & SMB.SECURITY_SIGNATURES_REQUIRED:\n                         self._SignatureRequired = True\n\n                    # Interestingly, the security Blob might be missing sometimes.\n                    #spnego = SPNEGO_NegTokenInit(self._dialects_data['SecurityBlob'])\n                    #for i in spnego['MechTypes']:\n                    #      print \"Mech Found: %s\" % MechTypes[i]\n                    return 1\n\n                # If not, let's try the old way\n                else:\n                    if self._dialects_data['ServerName'] is not None:\n                        self.__server_name = self._dialects_data['ServerName']\n\n                    if self._dialects_parameters['DialectIndex'] == 0xffff:\n                        raise UnsupportedFeature(\"Remote server does not know NT LM 0.12\")\n                    return 1\n            else:\n                return 0\n\n        if negPacket is None:\n            smb = NewSMBPacket()\n            negSession = SMBCommand(SMB.SMB_COM_NEGOTIATE)\n            flags2 = self.get_flags()[1]\n            if extended_security is True:\n                self.set_flags(flags2=flags2|SMB.FLAGS2_EXTENDED_SECURITY)\n            else:\n                self.set_flags(flags2=flags2 & (~SMB.FLAGS2_EXTENDED_SECURITY))\n\n            negSession['Data'] = b'\\x02NT LM 0.12\\x00'\n            smb.addCommand(negSession)\n            self.sendSMB(smb)\n\n            while 1:\n                smb = self.recvSMB()\n                return parsePacket(smb)\n        else:\n\n            return parsePacket( NewSMBPacket( data = negPacket))",
  "def tree_connect(self, path, password = '', service = SERVICE_ANY):\n        LOG.warning(\"[MS-CIFS] This is an original Core Protocol command.This command has been deprecated.Client Implementations SHOULD use SMB_COM_TREE_CONNECT_ANDX\")\n\n        # return 0x800\n        if password:\n            # Password is only encrypted if the server passed us an \"encryption\" during protocol dialect\n            if self._dialects_parameters['ChallengeLength'] > 0:\n                # this code is untested\n                password = self.get_ntlmv1_response(ntlm.compute_lmhash(password))\n\n        if not unicode_support:\n            if unicode_convert:\n                path = str(path)\n            else:\n                raise Exception('SMB: Can\\t conver path from unicode!')\n\n        smb = NewSMBPacket()\n        treeConnect = SMBCommand(SMB.SMB_COM_TREE_CONNECT)\n        treeConnect['Parameters'] = SMBTreeConnect_Parameters()\n        treeConnect['Data']       = SMBTreeConnect_Data()\n        treeConnect['Data']['Path'] = path.upper()\n        treeConnect['Data']['Password'] = password\n        treeConnect['Data']['Service'] = service\n        smb.addCommand(treeConnect)\n        self.sendSMB(smb)\n\n        while 1:\n            smb = self.recvSMB()\n            if smb.isValidAnswer(SMB.SMB_COM_TREE_CONNECT):\n                # XXX Here we are ignoring the rest of the response\n                return smb['Tid']\n            return smb['Tid']",
  "def get_uid(self):\n        return self._uid",
  "def set_uid(self, uid):\n        self._uid = uid",
  "def tree_connect_andx(self, path, password = None, service = SERVICE_ANY, smb_packet=None):\n        if password:\n            # Password is only encrypted if the server passed us an \"encryption\" during protocol dialect\n            if self._dialects_parameters['ChallengeLength'] > 0:\n                # this code is untested\n                password = self.get_ntlmv1_response(ntlm.compute_lmhash(password))\n        else:\n            password = '\\x00'\n\n        if not unicode_support:\n            if unicode_convert:\n                path = str(path)\n            else:\n                raise Exception('SMB: Can\\t convert path from unicode!')\n\n        if smb_packet is None:\n            smb = NewSMBPacket()\n        else:\n            smb = smb_packet\n\n        # Just in case this came with the full path ,let's just leave\n        # the sharename, we'll take care of the rest\n\n        share = path.split('\\\\')[-1]\n        try:\n            _, _, _, _, sockaddr = socket.getaddrinfo(self.get_remote_host(), 80, 0, 0, socket.IPPROTO_TCP)[0]\n            remote_host = sockaddr[0]\n        except Exception:\n            remote_host =  self.get_remote_host()\n\n        path = '\\\\\\\\' + remote_host + '\\\\' +share\n        path = path.upper().encode('utf-16le') if self.__flags2 & SMB.FLAGS2_UNICODE else path\n\n        treeConnect = SMBCommand(SMB.SMB_COM_TREE_CONNECT_ANDX)\n        treeConnect['Parameters'] = SMBTreeConnectAndX_Parameters()\n        treeConnect['Data']       = SMBTreeConnectAndX_Data(flags=self.__flags2)\n        treeConnect['Parameters']['PasswordLength'] = len(password)\n        treeConnect['Data']['Password'] = password\n        treeConnect['Data']['Path'] = path\n        treeConnect['Data']['Service'] = service\n\n        if self.__flags2 & SMB.FLAGS2_UNICODE:\n            treeConnect['Data']['Pad'] = 0x0\n\n        smb.addCommand(treeConnect)\n\n        # filename = \"\\PIPE\\epmapper\"\n\n        # ntCreate = SMBCommand(SMB.SMB_COM_NT_CREATE_ANDX)\n        # ntCreate['Parameters'] = SMBNtCreateAndX_Parameters()\n        # ntCreate['Data']       = SMBNtCreateAndX_Data()\n        # ntCreate['Parameters']['FileNameLength'] = len(filename)\n        # ntCreate['Parameters']['CreateFlags'] = 0\n        # ntCreate['Parameters']['AccessMask'] = 0x3\n        # ntCreate['Parameters']['CreateOptions'] = 0x0\n        # ntCreate['Data']['FileName'] = filename\n\n        # smb.addCommand(ntCreate)\n        self.sendSMB(smb)\n\n        while 1:\n            smb = self.recvSMB()\n            if smb.isValidAnswer(SMB.SMB_COM_TREE_CONNECT_ANDX):\n                # XXX Here we are ignoring the rest of the response\n                self.tid = smb['Tid']\n                return self.tid\n            self.tid = smb['Tid']\n            return self.tid",
  "def getDialect():\n        return SMB_DIALECT",
  "def get_server_name(self):\n        #return self._dialects_data['ServerName']\n        return self.__server_name",
  "def get_client_name(self):\n        return self.__client_name",
  "def get_session_key(self):\n        return self._SigningSessionKey",
  "def set_session_key(self, key):\n        self._SignatureEnabled = True\n        self._SignSequenceNumber = 2\n        self._SigningSessionKey = key",
  "def get_encryption_key(self):\n        if 'Challenge' in self._dialects_data.fields:\n            return self._dialects_data['Challenge']\n        else:\n            return None",
  "def get_server_time(self):\n        timestamp = self._dialects_parameters['HighDateTime']\n        timestamp <<= 32\n        timestamp |= self._dialects_parameters['LowDateTime']\n        timestamp -= 116444736000000000\n        timestamp //= 10000000\n        d = datetime.datetime.utcfromtimestamp(timestamp)\n        return d.strftime(\"%a, %d %b %Y %H:%M:%S GMT\")",
  "def disconnect_tree(self, tid):\n        smb = NewSMBPacket()\n        smb['Tid']  = tid\n\n        smb.addCommand(SMBCommand(SMB.SMB_COM_TREE_DISCONNECT))\n\n        self.sendSMB(smb)\n        self.recvSMB()",
  "def open(self, tid, filename, open_mode, desired_access):\n        filename = filename.replace('/', '\\\\')\n        filename = filename.encode('utf-16le') if self.__flags2 & SMB.FLAGS2_UNICODE else filename\n\n        smb = NewSMBPacket()\n        smb['Tid']    = tid\n\n        openFile = SMBCommand(SMB.SMB_COM_OPEN)\n        openFile['Parameters'] = SMBOpen_Parameters()\n        openFile['Parameters']['DesiredAccess']    = desired_access\n        openFile['Parameters']['OpenMode']         = open_mode\n        openFile['Parameters']['SearchAttributes'] = ATTR_READONLY | ATTR_HIDDEN | ATTR_ARCHIVE\n        openFile['Data']       = SMBOpen_Data(flags=self.__flags2)\n        openFile['Data']['FileName'] = filename\n\n        smb.addCommand(openFile)\n\n        self.sendSMB(smb)\n\n        smb = self.recvSMB()\n        if smb.isValidAnswer(SMB.SMB_COM_OPEN):\n            # XXX Here we are ignoring the rest of the response\n            openFileResponse   = SMBCommand(smb['Data'][0])\n            openFileParameters = SMBOpenResponse_Parameters(openFileResponse['Parameters'])\n\n            return (\n                openFileParameters['Fid'],\n                openFileParameters['FileAttributes'],\n                openFileParameters['LastWriten'],\n                openFileParameters['FileSize'],\n                openFileParameters['GrantedAccess'],\n            )",
  "def open_andx(self, tid, filename, open_mode, desired_access):\n        filename = filename.replace('/', '\\\\')\n        filename = filename.encode('utf-16le') if self.__flags2 & SMB.FLAGS2_UNICODE else filename\n\n        smb = NewSMBPacket()\n        smb['Tid']    = tid\n\n        openFile = SMBCommand(SMB.SMB_COM_OPEN_ANDX)\n        openFile['Parameters'] = SMBOpenAndX_Parameters()\n        openFile['Parameters']['DesiredAccess']    = desired_access\n        openFile['Parameters']['OpenMode']         = open_mode\n        openFile['Parameters']['SearchAttributes'] = ATTR_READONLY | ATTR_HIDDEN | ATTR_ARCHIVE\n        openFile['Data']       = SMBOpenAndX_Data(flags=self.__flags2)\n        openFile['Data']['FileName'] = filename\n\n        if self.__flags2 & SMB.FLAGS2_UNICODE:\n            openFile['Data']['Pad'] = 0x0\n\n        smb.addCommand(openFile)\n\n        self.sendSMB(smb)\n\n        smb = self.recvSMB()\n        if smb.isValidAnswer(SMB.SMB_COM_OPEN_ANDX):\n            # XXX Here we are ignoring the rest of the response\n            openFileResponse   = SMBCommand(smb['Data'][0])\n            openFileParameters = SMBOpenAndXResponse_Parameters(openFileResponse['Parameters'])\n\n            return (\n                openFileParameters['Fid'],\n                openFileParameters['FileAttributes'],\n                openFileParameters['LastWriten'],\n                openFileParameters['FileSize'],\n                openFileParameters['GrantedAccess'],\n                openFileParameters['FileType'],\n                openFileParameters['IPCState'],\n                openFileParameters['Action'],\n                openFileParameters['ServerFid'],\n            )",
  "def close(self, tid, fid):\n        smb = NewSMBPacket()\n        smb['Tid']    = tid\n\n        closeFile = SMBCommand(SMB.SMB_COM_CLOSE)\n        closeFile['Parameters'] = SMBClose_Parameters()\n        closeFile['Parameters']['FID']    = fid\n        smb.addCommand(closeFile)\n\n        self.sendSMB(smb)\n        smb = self.recvSMB()\n        if smb.isValidAnswer(SMB.SMB_COM_CLOSE):\n           return 1\n        return 0",
  "def send_trans(self, tid, setup, name, param, data, noAnswer = 0):\n        smb = NewSMBPacket()\n        smb['Tid']    = tid\n\n        transCommand = SMBCommand(SMB.SMB_COM_TRANSACTION)\n        transCommand['Parameters'] = SMBTransaction_Parameters()\n        transCommand['Data'] = SMBTransaction_Data()\n\n        transCommand['Parameters']['Setup'] = setup\n        transCommand['Parameters']['TotalParameterCount'] = len(param)\n        transCommand['Parameters']['TotalDataCount'] = len(data)\n\n        transCommand['Parameters']['ParameterCount'] = len(param)\n        transCommand['Parameters']['ParameterOffset'] = 32+3+28+len(setup)+len(name)\n\n        transCommand['Parameters']['DataCount'] = len(data)\n        transCommand['Parameters']['DataOffset'] = transCommand['Parameters']['ParameterOffset'] + len(param)\n\n        transCommand['Data']['Name'] = name\n        transCommand['Data']['Trans_Parameters'] = param\n        transCommand['Data']['Trans_Data'] = data\n\n        if noAnswer:\n           transCommand['Parameters']['Flags'] = TRANS_NO_RESPONSE\n\n        smb.addCommand(transCommand)\n\n        self.sendSMB(smb)",
  "def send_trans2(self, tid, setup, name, param, data):\n        smb = NewSMBPacket()\n        smb['Tid']    = tid\n\n        command = pack('<H', setup)\n\n        transCommand = SMBCommand(SMB.SMB_COM_TRANSACTION2)\n        transCommand['Parameters'] = SMBTransaction2_Parameters()\n        transCommand['Parameters']['MaxDataCount'] = self._dialects_parameters['MaxBufferSize']\n        transCommand['Data'] = SMBTransaction2_Data()\n\n        transCommand['Parameters']['Setup'] = command\n        transCommand['Parameters']['TotalParameterCount'] = len(param)\n        transCommand['Parameters']['TotalDataCount'] = len(data)\n\n        if len(param) > 0:\n            padLen = (4 - (32+2+28 + len(command)) % 4 ) % 4\n            padBytes = '\\xFF' * padLen\n            transCommand['Data']['Pad1'] = padBytes\n        else:\n            transCommand['Data']['Pad1'] = ''\n            padLen = 0\n\n        transCommand['Parameters']['ParameterCount'] = len(param)\n        transCommand['Parameters']['ParameterOffset'] = 32+2+28+len(command)+len(name) + padLen\n\n        if len(data) > 0:\n            pad2Len = (4 - (32+2+28 + len(command) + padLen + len(param)) % 4) % 4\n            transCommand['Data']['Pad2'] = '\\xFF' * pad2Len\n        else:\n            transCommand['Data']['Pad2'] = ''\n            pad2Len = 0\n\n        transCommand['Parameters']['DataCount'] = len(data)\n        transCommand['Parameters']['DataOffset'] = transCommand['Parameters']['ParameterOffset'] + len(param) + pad2Len\n\n        transCommand['Data']['Name'] = name\n        transCommand['Data']['Trans_Parameters'] = param\n        transCommand['Data']['Trans_Data'] = data\n        smb.addCommand(transCommand)\n\n        self.sendSMB(smb)",
  "def query_file_info(self, tid, fid, fileInfoClass = SMB_QUERY_FILE_STANDARD_INFO):\n        self.send_trans2(tid, SMB.TRANS2_QUERY_FILE_INFORMATION, '\\x00', pack('<HH', fid, fileInfoClass), '')\n\n        resp = self.recvSMB()\n        if resp.isValidAnswer(SMB.SMB_COM_TRANSACTION2):\n            trans2Response = SMBCommand(resp['Data'][0])\n            trans2Parameters = SMBTransaction2Response_Parameters(trans2Response['Parameters'])\n            # Remove Potential Prefix Padding\n            return trans2Response['Data'][-trans2Parameters['TotalDataCount']:]",
  "def __nonraw_retr_file(self, tid, fid, offset, datasize, callback):\n        if (self._dialects_parameters['Capabilities'] & SMB.CAP_LARGE_READX) and self._SignatureEnabled is False:\n            max_buf_size = 65000\n        else:\n            max_buf_size = self._dialects_parameters['MaxBufferSize'] & ~0x3ff  # Read in multiple KB blocks\n\n        read_offset = offset\n        while read_offset < datasize:\n            data = self.read_andx(tid, fid, read_offset, max_buf_size)\n\n            callback(data)\n            read_offset += len(data)",
  "def __nonraw_stor_file(self, tid, fid, offset, datasize, callback):\n        if (self._dialects_parameters['Capabilities'] & SMB.CAP_LARGE_WRITEX) and self._SignatureEnabled is False:\n            max_buf_size = 65000\n        else:\n            max_buf_size = self._dialects_parameters['MaxBufferSize'] & ~0x3ff  # Write in multiple KB blocks\n\n        write_offset = offset\n        while 1:\n            data = callback(max_buf_size)\n            if not data:\n                break\n\n            smb = self.write_andx(tid,fid,data, write_offset)\n            writeResponse   = SMBCommand(smb['Data'][0])\n            writeResponseParameters = SMBWriteAndXResponse_Parameters(writeResponse['Parameters'])\n            write_offset += writeResponseParameters['Count']",
  "def get_server_domain(self):\n        return self.__server_domain",
  "def get_server_dns_domain_name(self):\n        return self.__server_dns_domain_name",
  "def get_server_dns_host_name(self):\n        return self.__server_dns_host_name",
  "def get_server_os(self):\n        return self.__server_os",
  "def get_server_os_major(self):\n        return self.__server_os_major",
  "def get_server_os_minor(self):\n        return self.__server_os_minor",
  "def get_server_os_build(self):\n        return self.__server_os_build",
  "def set_server_os(self, os):\n        self.__server_os = os",
  "def get_server_lanman(self):\n        return self.__server_lanman",
  "def is_login_required(self):\n        # Login is required if share mode is user.\n        # Otherwise only public services or services in share mode\n        # are allowed.\n        return (self._dialects_parameters['SecurityMode'] & SMB.SECURITY_SHARE_MASK) == SMB.SECURITY_SHARE_USER",
  "def is_signing_required(self):\n        return self._SignatureRequired",
  "def get_ntlmv1_response(self, key):\n        challenge = self._dialects_data['Challenge']\n        return ntlm.get_ntlmv1_response(key, challenge)",
  "def perform_hostname_validation(self):\n        if self.__server_name == '':\n            if not self._validation_allow_absent:\n                raise self.HostnameValidationException('Hostname was not supplied by target host and absent validation is disallowed')\n            return\n        if self.__server_name.lower() != self._accepted_hostname.lower() and self.__server_dns_host_name.lower() != self._accepted_hostname.lower():\n            raise self.HostnameValidationException('Supplied hostname %s does not match reported hostnames %s or %s' %\n                (self._accepted_hostname.lower(), self.__server_name.lower(), self.__server_dns_host_name.lower()))",
  "def kerberos_login(self, user, password, domain = '', lmhash = '', nthash = '', aesKey = '', kdcHost = '', TGT=None, TGS=None):\n        # Importing down here so pyasn1 is not required if kerberos is not used.\n        from impacket.krb5.asn1 import AP_REQ, Authenticator, TGS_REP, seq_set\n        from impacket.krb5.kerberosv5 import getKerberosTGT, getKerberosTGS\n        from impacket.krb5 import constants\n        from impacket.krb5.types import Principal, KerberosTime, Ticket\n        from pyasn1.codec.der import decoder, encoder\n        import datetime\n\n        # login feature does not support unicode\n        # disable it if enabled\n        flags2 = self.__flags2\n        if flags2 & SMB.FLAGS2_UNICODE:\n            self.__flags2 = flags2 & (flags2 ^ SMB.FLAGS2_UNICODE)\n\n        # If TGT or TGS are specified, they are in the form of:\n        # TGS['KDC_REP'] = the response from the server\n        # TGS['cipher'] = the cipher used\n        # TGS['sessionKey'] = the sessionKey\n        # If we have hashes, normalize them\n        if lmhash != '' or nthash != '':\n            if len(lmhash) % 2:\n                lmhash = '0%s' % lmhash\n            if len(nthash) % 2:\n                nthash = '0%s' % nthash\n            try: # just in case they were converted already\n                lmhash = a2b_hex(lmhash)\n                nthash = a2b_hex(nthash)\n            except:\n                pass\n\n        self.__userName = user\n        self.__password = password\n        self.__domain   = domain\n        self.__lmhash   = lmhash\n        self.__nthash   = nthash\n        self.__aesKey   = aesKey\n        self.__kdc      = kdcHost\n        self.__TGT      = TGT\n        self.__TGS      = TGS\n        self._doKerberos= True\n\n        # First of all, we need to get a TGT for the user\n        userName = Principal(user, type=constants.PrincipalNameType.NT_PRINCIPAL.value)\n        if TGT is None:\n            if TGS is None:\n                tgt, cipher, oldSessionKey, sessionKey = getKerberosTGT(userName, password, domain, lmhash, nthash, aesKey, kdcHost)\n        else:\n            tgt = TGT['KDC_REP']\n            cipher = TGT['cipher']\n            sessionKey = TGT['sessionKey']\n\n        # Now that we have the TGT, we should ask for a TGS for cifs\n\n        if TGS is None:\n            serverName = Principal('cifs/%s' % self.__remote_name, type=constants.PrincipalNameType.NT_SRV_INST.value)\n            tgs, cipher, oldSessionKey, sessionKey = getKerberosTGS(serverName, domain, kdcHost, tgt, cipher, sessionKey)\n        else:\n            tgs = TGS['KDC_REP']\n            cipher = TGS['cipher']\n            sessionKey = TGS['sessionKey']\n\n        smb = NewSMBPacket()\n\n        # Are we required to sign SMB? If so we do it, if not we skip it\n        if self._SignatureRequired:\n           smb['Flags2'] |= SMB.FLAGS2_SMB_SECURITY_SIGNATURE\n\n\n        sessionSetup = SMBCommand(SMB.SMB_COM_SESSION_SETUP_ANDX)\n        sessionSetup['Parameters'] = SMBSessionSetupAndX_Extended_Parameters()\n        sessionSetup['Data']       = SMBSessionSetupAndX_Extended_Data()\n\n        sessionSetup['Parameters']['MaxBufferSize']        = 61440\n        sessionSetup['Parameters']['MaxMpxCount']          = 2\n        sessionSetup['Parameters']['VcNumber']             = 1\n        sessionSetup['Parameters']['SessionKey']           = 0\n        sessionSetup['Parameters']['Capabilities']         = SMB.CAP_EXTENDED_SECURITY | SMB.CAP_USE_NT_ERRORS | SMB.CAP_UNICODE | SMB.CAP_LARGE_READX | SMB.CAP_LARGE_WRITEX\n\n\n        # Let's build a NegTokenInit with the NTLMSSP\n        # TODO: In the future we should be able to choose different providers\n\n        blob = SPNEGO_NegTokenInit()\n\n        # Kerberos v5 mech\n        blob['MechTypes'] = [TypesMech['MS KRB5 - Microsoft Kerberos 5']]\n\n        # Let's extract the ticket from the TGS\n        tgs = decoder.decode(tgs, asn1Spec = TGS_REP())[0]\n        ticket = Ticket()\n        ticket.from_asn1(tgs['ticket'])\n\n        # Now let's build the AP_REQ\n        apReq = AP_REQ()\n        apReq['pvno'] = 5\n        apReq['msg-type'] = int(constants.ApplicationTagNumbers.AP_REQ.value)\n\n        opts = list()\n        apReq['ap-options'] = constants.encodeFlags(opts)\n        seq_set(apReq,'ticket', ticket.to_asn1)\n\n        authenticator = Authenticator()\n        authenticator['authenticator-vno'] = 5\n        authenticator['crealm'] = domain\n        seq_set(authenticator, 'cname', userName.components_to_asn1)\n        now = datetime.datetime.utcnow()\n\n        authenticator['cusec'] = now.microsecond\n        authenticator['ctime'] = KerberosTime.to_asn1(now)\n\n        encodedAuthenticator = encoder.encode(authenticator)\n\n        # Key Usage 11\n        # AP-REQ Authenticator (includes application authenticator\n        # subkey), encrypted with the application session key\n        # (Section 5.5.1)\n        encryptedEncodedAuthenticator = cipher.encrypt(sessionKey, 11, encodedAuthenticator, None)\n\n        apReq['authenticator'] = noValue\n        apReq['authenticator']['etype'] = cipher.enctype\n        apReq['authenticator']['cipher'] = encryptedEncodedAuthenticator\n\n        blob['MechToken'] = pack('B', ASN1_AID) + asn1encode(pack('B', ASN1_OID) + asn1encode(\n            TypesMech['KRB5 - Kerberos 5']) + KRB5_AP_REQ + encoder.encode(apReq))\n\n        sessionSetup['Parameters']['SecurityBlobLength']  = len(blob)\n        sessionSetup['Parameters'].getData()\n        sessionSetup['Data']['SecurityBlob']       = blob.getData()\n\n        # Fake Data here, don't want to get us fingerprinted\n        sessionSetup['Data']['NativeOS']      = 'Unix'\n        sessionSetup['Data']['NativeLanMan']  = 'Samba'\n\n        smb.addCommand(sessionSetup)\n        self.sendSMB(smb)\n\n        smb = self.recvSMB()\n        if smb.isValidAnswer(SMB.SMB_COM_SESSION_SETUP_ANDX):\n            # We will need to use this uid field for all future requests/responses\n            self._uid = smb['Uid']\n\n            # Now we have to extract the blob to continue the auth process\n            sessionResponse   = SMBCommand(smb['Data'][0])\n            sessionParameters = SMBSessionSetupAndX_Extended_Response_Parameters(sessionResponse['Parameters'])\n            sessionData       = SMBSessionSetupAndX_Extended_Response_Data(flags = smb['Flags2'])\n            sessionData['SecurityBlobLength'] = sessionParameters['SecurityBlobLength']\n            sessionData.fromString(sessionResponse['Data'])\n\n            self._action = sessionParameters['Action']\n            # If smb sign required, let's enable it for the rest of the connection\n            if self._dialects_parameters['SecurityMode'] & SMB.SECURITY_SIGNATURES_REQUIRED:\n               self._SigningSessionKey = sessionKey.contents\n               self._SignSequenceNumber = 2\n               self._SignatureEnabled = True\n\n            # restore unicode flag if needed\n            if flags2 & SMB.FLAGS2_UNICODE:\n                self.__flags2 |= SMB.FLAGS2_UNICODE\n\n            return 1\n        else:\n            raise Exception('Error: Could not login successfully')",
  "def login_extended(self, user, password, domain = '', lmhash = '', nthash = '', use_ntlmv2 = True ):\n\n        # login feature does not support unicode\n        # disable it if enabled\n        flags2 = self.__flags2\n        if flags2 & SMB.FLAGS2_UNICODE:\n            self.__flags2 = flags2 & (flags2 ^ SMB.FLAGS2_UNICODE)\n\n        # Once everything's working we should join login methods into a single one\n        smb = NewSMBPacket()\n        # Are we required to sign SMB? If so we do it, if not we skip it\n        if self._SignatureRequired:\n           smb['Flags2'] |= SMB.FLAGS2_SMB_SECURITY_SIGNATURE\n\n        sessionSetup = SMBCommand(SMB.SMB_COM_SESSION_SETUP_ANDX)\n        sessionSetup['Parameters'] = SMBSessionSetupAndX_Extended_Parameters()\n        sessionSetup['Data']       = SMBSessionSetupAndX_Extended_Data()\n\n        sessionSetup['Parameters']['MaxBufferSize']        = 61440\n        sessionSetup['Parameters']['MaxMpxCount']          = 2\n        sessionSetup['Parameters']['VcNumber']             = 1\n        sessionSetup['Parameters']['SessionKey']           = 0\n        sessionSetup['Parameters']['Capabilities']         = SMB.CAP_EXTENDED_SECURITY | SMB.CAP_USE_NT_ERRORS | SMB.CAP_UNICODE | SMB.CAP_LARGE_READX | SMB.CAP_LARGE_WRITEX\n\n\n        # Let's build a NegTokenInit with the NTLMSSP\n        # TODO: In the future we should be able to choose different providers\n\n        blob = SPNEGO_NegTokenInit()\n\n        # NTLMSSP\n        blob['MechTypes'] = [TypesMech['NTLMSSP - Microsoft NTLM Security Support Provider']]\n        auth = ntlm.getNTLMSSPType1(self.get_client_name(),domain,self._SignatureRequired, use_ntlmv2 = use_ntlmv2)\n        blob['MechToken'] = auth.getData()\n\n        sessionSetup['Parameters']['SecurityBlobLength']  = len(blob)\n        sessionSetup['Parameters'].getData()\n        sessionSetup['Data']['SecurityBlob']       = blob.getData()\n\n        # Fake Data here, don't want to get us fingerprinted\n        sessionSetup['Data']['NativeOS']      = 'Unix'\n        sessionSetup['Data']['NativeLanMan']  = 'Samba'\n\n        smb.addCommand(sessionSetup)\n        self.sendSMB(smb)\n\n        smb = self.recvSMB()\n        if smb.isValidAnswer(SMB.SMB_COM_SESSION_SETUP_ANDX):\n            # We will need to use this uid field for all future requests/responses\n            self._uid = smb['Uid']\n\n            # Now we have to extract the blob to continue the auth process\n            sessionResponse   = SMBCommand(smb['Data'][0])\n            sessionParameters = SMBSessionSetupAndX_Extended_Response_Parameters(sessionResponse['Parameters'])\n            sessionData       = SMBSessionSetupAndX_Extended_Response_Data(flags = smb['Flags2'])\n            sessionData['SecurityBlobLength'] = sessionParameters['SecurityBlobLength']\n            sessionData.fromString(sessionResponse['Data'])\n            respToken = SPNEGO_NegTokenResp(sessionData['SecurityBlob'])\n\n            # Let's parse some data and keep it to ourselves in case it is asked\n            ntlmChallenge = ntlm.NTLMAuthChallenge(respToken['ResponseToken'])\n            if ntlmChallenge['TargetInfoFields_len'] > 0:\n                av_pairs = ntlm.AV_PAIRS(ntlmChallenge['TargetInfoFields'][:ntlmChallenge['TargetInfoFields_len']])\n                if av_pairs[ntlm.NTLMSSP_AV_HOSTNAME] is not None:\n                   try:\n                       self.__server_name = av_pairs[ntlm.NTLMSSP_AV_HOSTNAME][1].decode('utf-16le')\n                   except UnicodeDecodeError:\n                       # For some reason, we couldn't decode Unicode here.. silently discard the operation\n                       pass\n                if av_pairs[ntlm.NTLMSSP_AV_DOMAINNAME] is not None:\n                   try:\n                       if self.__server_name != av_pairs[ntlm.NTLMSSP_AV_DOMAINNAME][1].decode('utf-16le'):\n                           self.__server_domain = av_pairs[ntlm.NTLMSSP_AV_DOMAINNAME][1].decode('utf-16le')\n                   except UnicodeDecodeError:\n                       # For some reason, we couldn't decode Unicode here.. silently discard the operation\n                       pass\n                if av_pairs[ntlm.NTLMSSP_AV_DNS_DOMAINNAME] is not None:\n                   try:\n                       self.__server_dns_domain_name = av_pairs[ntlm.NTLMSSP_AV_DNS_DOMAINNAME][1].decode('utf-16le')\n                   except UnicodeDecodeError:\n                       # For some reason, we couldn't decode Unicode here.. silently discard the operation\n                       pass\n\n                if av_pairs[ntlm.NTLMSSP_AV_DNS_HOSTNAME] is not None:\n                   try:\n                       self.__server_dns_host_name = av_pairs[ntlm.NTLMSSP_AV_DNS_HOSTNAME][1].decode('utf-16le')\n                   except UnicodeDecodeError:\n                       # For some reason, we couldn't decode Unicode here.. silently discard the operation\n                       pass\n\n            if self._strict_hostname_validation:\n                self.perform_hostname_validation()\n\n            # Parse Version to know the target Operating system name. Not provided elsewhere anymore\n            if 'Version' in ntlmChallenge.fields:\n                version = ntlmChallenge['Version']\n\n                if len(version) >= 4:\n                   self.__server_os_major, self.__server_os_minor, self.__server_os_build = unpack('<BBH',version[:4])\n\n            type3, exportedSessionKey = ntlm.getNTLMSSPType3(auth, respToken['ResponseToken'], user, password, domain, lmhash, nthash, use_ntlmv2 = use_ntlmv2)\n\n            if exportedSessionKey is not None:\n                self._SigningSessionKey = exportedSessionKey\n\n            smb = NewSMBPacket()\n\n            # Are we required to sign SMB? If so we do it, if not we skip it\n            if self._SignatureRequired:\n               smb['Flags2'] |= SMB.FLAGS2_SMB_SECURITY_SIGNATURE\n\n            respToken2 = SPNEGO_NegTokenResp()\n            respToken2['ResponseToken'] = type3.getData()\n\n            # Reusing the previous structure\n            sessionSetup['Parameters']['SecurityBlobLength'] = len(respToken2)\n            sessionSetup['Data']['SecurityBlob'] = respToken2.getData()\n\n            # Storing some info for later use\n            self.__server_os     = sessionData['NativeOS']\n            self.__server_lanman = sessionData['NativeLanMan']\n\n            smb.addCommand(sessionSetup)\n            self.sendSMB(smb)\n\n            smb = self.recvSMB()\n            self._uid = 0\n            if smb.isValidAnswer(SMB.SMB_COM_SESSION_SETUP_ANDX):\n                self._uid = smb['Uid']\n                sessionResponse   = SMBCommand(smb['Data'][0])\n                sessionParameters = SMBSessionSetupAndXResponse_Parameters(sessionResponse['Parameters'])\n\n                self._action = sessionParameters['Action']\n                # If smb sign required, let's enable it for the rest of the connection\n                if self._dialects_parameters['SecurityMode'] & SMB.SECURITY_SIGNATURES_REQUIRED:\n                   self._SignSequenceNumber = 2\n                   self._SignatureEnabled = True\n\n                # restore unicode flag if needed\n                if flags2 & SMB.FLAGS2_UNICODE:\n                    self.__flags2 |= SMB.FLAGS2_UNICODE\n\n                return 1\n        else:\n            raise Exception('Error: Could not login successfully')",
  "def getCredentials(self):\n        return (\n            self.__userName,\n            self.__password,\n            self.__domain,\n            self.__lmhash,\n            self.__nthash,\n            self.__aesKey,\n            self.__TGT,\n            self.__TGS)",
  "def getIOCapabilities(self):\n        res = dict()\n        if (self._dialects_parameters['Capabilities'] & SMB.CAP_LARGE_READX) and self._SignatureEnabled is False:\n            max_size = 65000\n        else:\n            max_size = self._dialects_parameters['MaxBufferSize'] # Read in multiple KB blocks\n        res['MaxReadSize'] = max_size\n        res['MaxWriteSize'] = max_size\n        return res",
  "def login(self, user, password, domain = '', lmhash = '', nthash = '', ntlm_fallback = True):\n\n        # If we have hashes, normalize them\n        if lmhash != '' or nthash != '':\n            if len(lmhash) % 2:\n                lmhash = '0%s' % lmhash\n            if len(nthash) % 2:\n                nthash = '0%s' % nthash\n            try: # just in case they were converted already\n                lmhash = a2b_hex(lmhash)\n                nthash = a2b_hex(nthash)\n            except:\n                pass\n\n        self.__userName = user\n        self.__password = password\n        self.__domain   = domain\n        self.__lmhash   = lmhash\n        self.__nthash   = nthash\n        self.__aesKey   = ''\n        self.__TGT      = None\n        self.__TGS      = None\n\n        if self._dialects_parameters['Capabilities'] & SMB.CAP_EXTENDED_SECURITY:\n            try:\n                self.login_extended(user, password, domain, lmhash, nthash, use_ntlmv2 = True)\n            except:\n                # If the target OS is Windows 5.0 or Samba, let's try using NTLMv1\n                if ntlm_fallback and ((self.get_server_lanman().find('Windows 2000') != -1) or (self.get_server_lanman().find('Samba') != -1)):\n                    self.login_extended(user, password, domain, lmhash, nthash, use_ntlmv2 = False)\n                    self.__isNTLMv2 = False\n                else:\n                    raise\n        elif ntlm_fallback:\n            self.login_standard(user, password, domain, lmhash, nthash)\n            self.__isNTLMv2 = False\n        else:\n            raise SessionError('Cannot authenticate against target, enable ntlm_fallback')",
  "def login_standard(self, user, password, domain = '', lmhash = '', nthash = ''):\n\n        # login feature does not support unicode\n        # disable it if enabled\n        flags2 = self.__flags2\n        if flags2 & SMB.FLAGS2_UNICODE:\n            self.__flags2 = flags2 & (flags2 ^ SMB.FLAGS2_UNICODE)\n\n        # Only supports NTLMv1\n        # Password is only encrypted if the server passed us an \"encryption key\" during protocol dialect negotiation\n        if self._dialects_parameters['ChallengeLength'] > 0:\n            if lmhash != '' or nthash != '':\n               pwd_ansi = self.get_ntlmv1_response(lmhash)\n               pwd_unicode = self.get_ntlmv1_response(nthash)\n            elif password:\n               lmhash = ntlm.compute_lmhash(password)\n               nthash = ntlm.compute_nthash(password)\n               pwd_ansi = self.get_ntlmv1_response(lmhash)\n               pwd_unicode = self.get_ntlmv1_response(nthash)\n            else: # NULL SESSION\n               pwd_ansi = ''\n               pwd_unicode = ''\n        else:\n            pwd_ansi = password\n            pwd_unicode = ''\n\n        smb = NewSMBPacket()\n\n        sessionSetup = SMBCommand(SMB.SMB_COM_SESSION_SETUP_ANDX)\n        sessionSetup['Parameters'] = SMBSessionSetupAndX_Parameters()\n        sessionSetup['Data']       = SMBSessionSetupAndX_Data()\n\n        sessionSetup['Parameters']['MaxBuffer']        = 61440\n        sessionSetup['Parameters']['MaxMpxCount']      = 2\n        sessionSetup['Parameters']['VCNumber']         = os.getpid() & 0xFFFF # Value has to be expressed in 2 bytes\n        sessionSetup['Parameters']['SessionKey']       = self._dialects_parameters['SessionKey']\n        sessionSetup['Parameters']['AnsiPwdLength']    = len(pwd_ansi)\n        sessionSetup['Parameters']['UnicodePwdLength'] = len(pwd_unicode)\n        sessionSetup['Parameters']['Capabilities']     = SMB.CAP_RAW_MODE | SMB.CAP_USE_NT_ERRORS | SMB.CAP_LARGE_READX | SMB.CAP_LARGE_WRITEX\n\n        sessionSetup['Data']['AnsiPwd']       = pwd_ansi\n        sessionSetup['Data']['UnicodePwd']    = pwd_unicode\n        sessionSetup['Data']['Account']       = str(user)\n        sessionSetup['Data']['PrimaryDomain'] = str(domain)\n        sessionSetup['Data']['NativeOS']      = str(os.name)\n        sessionSetup['Data']['NativeLanMan']  = 'pysmb'\n        smb.addCommand(sessionSetup)\n\n        self.sendSMB(smb)\n\n        smb = self.recvSMB()\n        if smb.isValidAnswer(SMB.SMB_COM_SESSION_SETUP_ANDX):\n            # We will need to use this uid field for all future requests/responses\n            self._uid = smb['Uid']\n            sessionResponse   = SMBCommand(smb['Data'][0])\n            sessionParameters = SMBSessionSetupAndXResponse_Parameters(sessionResponse['Parameters'])\n            sessionData       = SMBSessionSetupAndXResponse_Data(flags = smb['Flags2'], data = sessionResponse['Data'])\n\n            self._action = sessionParameters['Action']\n\n            # Still gotta figure out how to do this with no EXTENDED_SECURITY\n            if sessionParameters['Action'] & SMB_SETUP_USE_LANMAN_KEY == 0:\n                 self._SigningChallengeResponse = sessionSetup['Data']['UnicodePwd']\n                 self._SigningSessionKey = nthash\n            else:\n                 self._SigningChallengeResponse = sessionSetup['Data']['AnsiPwd']\n                 self._SigningSessionKey = lmhash\n\n            #self._SignSequenceNumber = 1\n            #self.checkSignSMB(smb, self._SigningSessionKey ,self._SigningChallengeResponse)\n            #self._SignatureEnabled = True\n            self.__server_os     = sessionData['NativeOS']\n            self.__server_lanman = sessionData['NativeLanMan']\n            self.__server_domain = sessionData['PrimaryDomain']\n\n            # restore unicode flag if needed\n            if flags2 & SMB.FLAGS2_UNICODE:\n                self.__flags2 |= SMB.FLAGS2_UNICODE\n\n            return 1\n        else:\n            raise Exception('Error: Could not login successfully')",
  "def waitNamedPipe(self, tid, pipe, timeout = 5, noAnswer = 0):\n        smb = NewSMBPacket()\n        smb['Tid']    = tid\n\n        transCommand = SMBCommand(SMB.SMB_COM_TRANSACTION)\n        transCommand['Parameters'] = SMBTransaction_Parameters()\n        transCommand['Data'] = SMBTransaction_Data()\n\n        setup = '\\x53\\x00\\x00\\x00'\n        name = '\\\\PIPE%s\\x00' % pipe\n        transCommand['Parameters']['Setup'] = setup\n        transCommand['Parameters']['TotalParameterCount'] = 0\n        transCommand['Parameters']['TotalDataCount'] = 0\n        transCommand['Parameters']['MaxParameterCount'] = 0\n        transCommand['Parameters']['MaxDataCount'] = 0\n        transCommand['Parameters']['Timeout'] = timeout * 1000\n\n        transCommand['Parameters']['ParameterCount'] = 0\n        transCommand['Parameters']['ParameterOffset'] = 32+3+28+len(setup)+len(name)\n\n        transCommand['Parameters']['DataCount'] = 0\n        transCommand['Parameters']['DataOffset'] = 0\n\n        transCommand['Data']['Name'] = name\n        transCommand['Data']['Trans_Parameters'] = ''\n        transCommand['Data']['Trans_Data'] = ''\n\n        if noAnswer:\n           transCommand['Parameters']['Flags'] = TRANS_NO_RESPONSE\n\n        smb.addCommand(transCommand)\n        self.sendSMB(smb)\n\n        smb = self.recvSMB()\n        if smb.isValidAnswer(SMB.SMB_COM_TRANSACTION):\n           return 1\n        return 0",
  "def read(self, tid, fid, offset=0, max_size = None, wait_answer=1):\n        if not max_size:\n            max_size = self._dialects_parameters['MaxBufferSize'] # Read in multiple KB blocks\n\n        # max_size is not working, because although it would, the server returns an error (More data avail)\n\n        smb = NewSMBPacket()\n        smb['Tid']    = tid\n\n        read = SMBCommand(SMB.SMB_COM_READ)\n        read['Parameters'] = SMBRead_Parameters()\n        read['Parameters']['Fid'] = fid\n        read['Parameters']['Offset'] = offset\n        read['Parameters']['Count'] = max_size\n        smb.addCommand(read)\n\n        if wait_answer:\n            while 1:\n                self.sendSMB(smb)\n                ans = self.recvSMB()\n\n                if ans.isValidAnswer(SMB.SMB_COM_READ):\n                    readResponse   = SMBCommand(ans['Data'][0])\n                    readData       = SMBReadResponse_Data(readResponse['Data'])\n\n                    return readData['Data']\n\n        return None",
  "def read_andx(self, tid, fid, offset=0, max_size = None, wait_answer=1, smb_packet=None):\n        if not max_size:\n            if (self._dialects_parameters['Capabilities'] & SMB.CAP_LARGE_READX) and self._SignatureEnabled is False:\n                max_size = 65000\n            else:\n                max_size = self._dialects_parameters['MaxBufferSize'] # Read in multiple KB blocks\n\n        # max_size is not working, because although it would, the server returns an error (More data avail)\n\n        if smb_packet is None:\n            smb = NewSMBPacket()\n            smb['Tid']    = tid\n\n            readAndX = SMBCommand(SMB.SMB_COM_READ_ANDX)\n            readAndX['Parameters'] = SMBReadAndX_Parameters()\n            readAndX['Parameters']['Fid'] = fid\n            readAndX['Parameters']['Offset'] = offset\n            readAndX['Parameters']['MaxCount'] = max_size\n            smb.addCommand(readAndX)\n        else:\n            smb = smb_packet\n\n        if wait_answer:\n            answer = b''\n            while 1:\n                self.sendSMB(smb)\n                ans = self.recvSMB()\n\n                if ans.isValidAnswer(SMB.SMB_COM_READ_ANDX):\n                    # XXX Here we are only using a few fields from the response\n                    readAndXResponse   = SMBCommand(ans['Data'][0])\n                    readAndXParameters = SMBReadAndXResponse_Parameters(readAndXResponse['Parameters'])\n\n                    offset = readAndXParameters['DataOffset']\n                    count = readAndXParameters['DataCount']+0x10000*readAndXParameters['DataCount_Hi']\n                    answer += ans.getData()[offset:offset+count]\n                    if not ans.isMoreData():\n                        return answer\n                    max_size = min(max_size, readAndXParameters['Remaining'])\n                    readAndX['Parameters']['Offset'] += count                      # XXX Offset is not important (apparently)\n        else:\n            self.sendSMB(smb)\n            ans = self.recvSMB()\n\n            try:\n                if ans.isValidAnswer(SMB.SMB_COM_READ_ANDX):\n                    return ans\n                else:\n                    return None\n            except:\n                return ans\n\n        return None",
  "def read_raw(self, tid, fid, offset=0, max_size = None, wait_answer=1):\n        if not max_size:\n            max_size = self._dialects_parameters['MaxBufferSize'] # Read in multiple KB blocks\n\n        # max_size is not working, because although it would, the server returns an error (More data avail)\n        smb = NewSMBPacket()\n        smb['Tid']    = tid\n\n        readRaw = SMBCommand(SMB.SMB_COM_READ_RAW)\n        readRaw['Parameters'] = SMBReadRaw_Parameters()\n        readRaw['Parameters']['Fid'] = fid\n        readRaw['Parameters']['Offset'] = offset\n        readRaw['Parameters']['MaxCount'] = max_size\n        smb.addCommand(readRaw)\n\n        self.sendSMB(smb)\n        if wait_answer:\n            data = self._sess.recv_packet(self.__timeout).get_trailer()\n            if not data:\n                # If there is no data it means there was an error\n                data = self.read_andx(tid, fid, offset, max_size)\n            return data\n\n        return None",
  "def write(self,tid,fid,data, offset = 0, wait_answer=1):\n        smb = NewSMBPacket()\n        smb['Tid']    = tid\n\n        write = SMBCommand(SMB.SMB_COM_WRITE)\n        write['Parameters'] = SMBWrite_Parameters()\n        write['Data'] = SMBWrite_Data()\n        write['Parameters']['Fid'] = fid\n        write['Parameters']['Count'] = len(data)\n        write['Parameters']['Offset'] = offset\n        write['Parameters']['Remaining'] = len(data)\n        write['Data']['Data'] = data\n        smb.addCommand(write)\n\n        self.sendSMB(smb)\n\n        if wait_answer:\n            smb = self.recvSMB()\n            if smb.isValidAnswer(SMB.SMB_COM_WRITE):\n                return smb\n        return None",
  "def write_andx(self,tid,fid,data, offset = 0, wait_answer=1, write_pipe_mode = False, smb_packet=None):\n        if smb_packet is None:\n            smb = NewSMBPacket()\n            smb['Tid']    = tid\n\n            writeAndX = SMBCommand(SMB.SMB_COM_WRITE_ANDX)\n            smb.addCommand(writeAndX)\n\n            writeAndX['Parameters'] = SMBWriteAndX_Parameters()\n            writeAndX['Parameters']['Fid'] = fid\n            writeAndX['Parameters']['Offset'] = offset\n            writeAndX['Parameters']['WriteMode'] = 8\n            writeAndX['Parameters']['Remaining'] = len(data)\n            writeAndX['Parameters']['DataLength'] = len(data)\n            writeAndX['Parameters']['DataOffset'] = len(smb)    # this length already includes the parameter\n            writeAndX['Data'] = data\n\n            if write_pipe_mode is True:\n                # First of all we gotta know what the MaxBuffSize is\n                maxBuffSize = self._dialects_parameters['MaxBufferSize']\n                if len(data) > maxBuffSize:\n                    chunks_size = maxBuffSize - 60\n                    writeAndX['Parameters']['WriteMode'] = 0x0c\n                    sendData = b'\\xff\\xff' + data\n                    totalLen = len(sendData)\n                    writeAndX['Parameters']['DataLength'] = chunks_size\n                    writeAndX['Parameters']['Remaining'] = totalLen-2\n                    writeAndX['Data'] = sendData[:chunks_size]\n\n                    self.sendSMB(smb)\n                    if wait_answer:\n                        smbResp = self.recvSMB()\n                        smbResp.isValidAnswer(SMB.SMB_COM_WRITE_ANDX)\n\n                    alreadySent = chunks_size\n                    sendData = sendData[chunks_size:]\n\n                    while alreadySent < totalLen:\n                        writeAndX['Parameters']['WriteMode'] = 0x04\n                        writeAndX['Parameters']['DataLength'] = len(sendData[:chunks_size])\n                        writeAndX['Data'] = sendData[:chunks_size]\n                        self.sendSMB(smb)\n                        if wait_answer:\n                            smbResp = self.recvSMB()\n                            smbResp.isValidAnswer(SMB.SMB_COM_WRITE_ANDX)\n                        alreadySent += writeAndX['Parameters']['DataLength']\n                        sendData = sendData[chunks_size:]\n\n                    return smbResp\n\n        else:\n            smb = smb_packet\n\n        self.sendSMB(smb)\n\n        if wait_answer:\n            smb = self.recvSMB()\n            if smb.isValidAnswer(SMB.SMB_COM_WRITE_ANDX):\n                return smb\n        return None",
  "def write_raw(self,tid,fid,data, offset = 0, wait_answer=1):\n        LOG.warning(\"[MS-CIFS] This command was introduced in the CorePlus dialect, but is often listed as part of the LAN Manager 1.0 dialect.This command has been deprecated.Clients SHOULD use SMB_COM_WRITE_ANDX\")\n        smb = NewSMBPacket()\n        smb['Tid']    = tid\n\n        writeRaw = SMBCommand(SMB.SMB_COM_WRITE_RAW)\n        writeRaw['Parameters'] = SMBWriteRaw_Parameters()\n        writeRaw['Parameters']['Fid'] = fid\n        writeRaw['Parameters']['Offset'] = offset\n        writeRaw['Parameters']['Count'] = len(data)\n        writeRaw['Parameters']['DataLength'] = 0\n        writeRaw['Parameters']['DataOffset'] = 0\n        smb.addCommand(writeRaw)\n\n        self.sendSMB(smb)\n        self._sess.send_packet(data)\n\n        if wait_answer:\n            smb = self.recvSMB()\n            if smb.isValidAnswer(SMB.SMB_COM_WRITE_RAW):\n                return smb\n        return None",
  "def TransactNamedPipe(self, tid, fid, data = '', noAnswer = 0, waitAnswer = 1, offset = 0):\n        self.send_trans(tid,pack('<HH', 0x26, fid),'\\\\PIPE\\\\\\x00','',data, noAnswer = noAnswer)\n\n        if noAnswer or not waitAnswer:\n            return\n        smb = self.recvSMB()\n        if smb.isValidAnswer(SMB.SMB_COM_TRANSACTION):\n           transResponse = SMBCommand(smb['Data'][0])\n           transParameters = SMBTransactionResponse_Parameters(transResponse['Parameters'])\n           return transResponse['Data'][-transParameters['TotalDataCount']:] # Remove Potential Prefix Padding\n        return None",
  "def TransactNamedPipeRecv(self):\n        s = self.recvSMB()\n        if s.isValidAnswer(SMB.SMB_COM_TRANSACTION):\n           transResponse = SMBCommand(s['Data'][0])\n           transParameters = SMBTransactionResponse_Parameters(transResponse['Parameters'])\n           return transResponse['Data'][-transParameters['TotalDataCount']:] # Remove Potential Prefix Padding\n        return None",
  "def nt_create_andx(self,tid,filename, smb_packet=None, cmd = None, shareAccessMode = FILE_SHARE_READ | FILE_SHARE_WRITE, disposition = FILE_OPEN, accessMask = 0x2019f):\n        filename = filename.replace('/', '\\\\')\n        filename = filename.encode('utf-16le') if self.__flags2 & SMB.FLAGS2_UNICODE else filename\n\n        if smb_packet is None:\n            smb = NewSMBPacket()\n            smb['Tid']    = tid\n        else:\n            smb = smb_packet\n\n        if cmd is None:\n            ntCreate = SMBCommand(SMB.SMB_COM_NT_CREATE_ANDX)\n            ntCreate['Parameters'] = SMBNtCreateAndX_Parameters()\n            ntCreate['Data']       = SMBNtCreateAndX_Data(flags=self.__flags2)\n            ntCreate['Parameters']['FileNameLength'] = len(filename)\n            ntCreate['Parameters']['CreateFlags'] = 0x16\n            ntCreate['Parameters']['AccessMask'] = accessMask\n            ntCreate['Parameters']['CreateOptions'] = 0x40\n            ntCreate['Parameters']['ShareAccess'] = shareAccessMode\n            ntCreate['Parameters']['Disposition'] = disposition\n            ntCreate['Data']['FileName'] = filename\n\n            if self.__flags2 & SMB.FLAGS2_UNICODE:\n                ntCreate['Data']['Pad'] = 0x0\n        else:\n            ntCreate = cmd\n\n        smb.addCommand(ntCreate)\n\n        self.sendSMB(smb)\n\n        while 1:\n            smb = self.recvSMB()\n            if smb.isValidAnswer(SMB.SMB_COM_NT_CREATE_ANDX):\n                # XXX Here we are ignoring the rest of the response\n                ntCreateResponse   = SMBCommand(smb['Data'][0])\n                ntCreateParameters = SMBNtCreateAndXResponse_Parameters(ntCreateResponse['Parameters'])\n\n                self.fid = ntCreateParameters['Fid']\n                return ntCreateParameters['Fid']",
  "def logoff(self):\n        smb = NewSMBPacket()\n\n        logOff = SMBCommand(SMB.SMB_COM_LOGOFF_ANDX)\n        logOff['Parameters'] = SMBLogOffAndX()\n        smb.addCommand(logOff)\n\n        self.sendSMB(smb)\n        self.recvSMB()\n        # Let's clear some fields so you can login again under the same session\n        self._uid = 0",
  "def list_path(self, service, path = '*', password = None):\n        path = path.replace('/', '\\\\')\n        path = path.encode('utf-16le') if self.__flags2 & SMB.FLAGS2_UNICODE else path\n\n        tid = self.tree_connect_andx('\\\\\\\\' + self.__remote_name + '\\\\' + service, password)\n        try:\n            findFirstParameter = SMBFindFirst2_Parameters(self.__flags2)\n            findFirstParameter['SearchAttributes'] = SMB_FILE_ATTRIBUTE_DIRECTORY | SMB_FILE_ATTRIBUTE_HIDDEN | \\\n                                                     SMB_FILE_ATTRIBUTE_SYSTEM | SMB_FILE_ATTRIBUTE_READONLY | \\\n                                                     SMB_FILE_ATTRIBUTE_ARCHIVE\n            findFirstParameter['SearchCount'] = 512\n            findFirstParameter['Flags'] = SMB_FIND_RETURN_RESUME_KEYS | SMB_FIND_CLOSE_AT_EOS\n            findFirstParameter['InformationLevel'] = SMB_FIND_FILE_BOTH_DIRECTORY_INFO\n            findFirstParameter['SearchStorageType'] = 0\n            if self.__flags2 & SMB.FLAGS2_UNICODE:\n                findFirstParameter['FileName'] = path + b'\\x00\\x00'\n            else:\n                findFirstParameter['FileName'] = path + '\\x00'\n            self.send_trans2(tid, SMB.TRANS2_FIND_FIRST2, '\\x00', findFirstParameter, '')\n            files = [ ]\n\n            totalDataCount = 1\n            findData = b''\n            findFirst2ParameterBlock = b''\n            while len(findData) < totalDataCount:\n                resp = self.recvSMB()\n\n                if resp.isValidAnswer(SMB.SMB_COM_TRANSACTION2):\n                    trans2Response = SMBCommand(resp['Data'][0])\n                    trans2Parameters = SMBTransaction2Response_Parameters(trans2Response['Parameters'])\n                    totalDataCount = trans2Parameters['TotalDataCount']\n                    findFirst2ParameterBlock += trans2Response['Data'][trans2Parameters['ParameterOffset']-55:][:trans2Parameters['ParameterCount']]\n                    findData += trans2Response['Data'][trans2Parameters['DataOffset']-55:]\n\n            findParameterBlock = SMBFindFirst2Response_Parameters(findFirst2ParameterBlock)\n            # Save the SID for resume operations\n            sid = findParameterBlock['SID']\n\n            while findParameterBlock['SearchCount'] > 0:\n                record = SMBFindFileBothDirectoryInfo(data = findData)\n\n                shortname = record['ShortName'].decode('utf-16le') if self.__flags2 & SMB.FLAGS2_UNICODE else \\\n                                                                        record['ShortName'].decode('cp437')\n                filename = record['FileName'].decode('utf-16le') if self.__flags2 & SMB.FLAGS2_UNICODE else \\\n                                                                        record['FileName'].decode('cp437')\n\n                fileRecord = SharedFile(record['CreationTime'], record['LastAccessTime'], record['LastChangeTime'],\n                                  record['EndOfFile'], record['AllocationSize'], record['ExtFileAttributes'],\n                                  shortname, filename)\n                files.append(fileRecord)\n                if record['NextEntryOffset'] > 0 and len(findData[record['NextEntryOffset']:]) > 0:\n                    findData = findData[record['NextEntryOffset']:]\n                else:\n                    # More data to search?\n                    if findParameterBlock['EndOfSearch'] == 0:\n                        resume_filename = record['FileName']\n                        findNextParameter = SMBFindNext2_Parameters()\n                        findNextParameter['SID'] = sid\n                        findNextParameter['SearchCount'] = 1024\n                        findNextParameter['InformationLevel'] = SMB_FIND_FILE_BOTH_DIRECTORY_INFO\n                        findNextParameter['ResumeKey'] = 0\n                        findNextParameter['Flags'] = SMB_FIND_RETURN_RESUME_KEYS | SMB_FIND_CLOSE_AT_EOS\n                        if self.__flags2 & SMB.FLAGS2_UNICODE:\n                            findNextParameter['FileName'] = resume_filename + b'\\x00\\x00'\n                        else:\n                            findNextParameter['FileName'] = resume_filename + b'\\x00'\n                        self.send_trans2(tid, SMB.TRANS2_FIND_NEXT2, '\\x00', findNextParameter, '')\n                        findData = b''\n                        findNext2ParameterBlock = b''\n                        totalDataCount = 1\n                        while len(findData) < totalDataCount:\n                            resp = self.recvSMB()\n\n                            if resp.isValidAnswer(SMB.SMB_COM_TRANSACTION2):\n                                trans2Response = SMBCommand(resp['Data'][0])\n                                trans2Parameters = SMBTransaction2Response_Parameters(trans2Response['Parameters'])\n                                totalDataCount = trans2Parameters['TotalDataCount']\n                                findNext2ParameterBlock += trans2Response['Data'][trans2Parameters['ParameterOffset']-55:][:trans2Parameters['ParameterCount']]\n                                findData += trans2Response['Data'][trans2Parameters['DataOffset']-55:]\n                                findParameterBlock = SMBFindNext2Response_Parameters(findNext2ParameterBlock)\n                    else:\n                       break\n        finally:\n            self.disconnect_tree(tid)\n\n        return files",
  "def retr_file(self, service, filename, callback, mode = FILE_OPEN, offset = 0, password = None, shareAccessMode = SMB_ACCESS_READ):\n        filename = filename.replace('/', '\\\\')\n\n        fid = -1\n        tid = self.tree_connect_andx('\\\\\\\\' + self.__remote_name + '\\\\' + service, password)\n        try:\n            fid = self.nt_create_andx(tid, filename, shareAccessMode = shareAccessMode, accessMask = 0x20089)\n\n            res = self.query_file_info(tid, fid)\n            datasize = SMBQueryFileStandardInfo(res)['EndOfFile']\n\n            self.__nonraw_retr_file(tid, fid, offset, datasize, callback)\n        finally:\n            if fid >= 0:\n                self.close(tid, fid)\n            self.disconnect_tree(tid)",
  "def stor_file(self, service, filename, callback, mode = FILE_OVERWRITE_IF, offset = 0, password = None, shareAccessMode = SMB_ACCESS_WRITE):\n        filename = filename.replace('/', '\\\\')\n\n        fid = -1\n        tid = self.tree_connect_andx('\\\\\\\\' + self.__remote_name + '\\\\' + service, password)\n        try:\n            fid = self.nt_create_andx(tid, filename, shareAccessMode = shareAccessMode, disposition = mode )\n\n            self.__nonraw_stor_file(tid, fid, offset, 0, callback)\n        finally:\n            if fid >= 0:\n                self.close(tid, fid)\n            self.disconnect_tree(tid)",
  "def stor_file_nonraw(self, service, filename, callback, mode = FILE_OVERWRITE_IF, offset = 0, password = None, shareAccessMode = SMB_ACCESS_WRITE ):\n        filename = filename.replace('/', '\\\\')\n\n        fid = -1\n        tid = self.tree_connect_andx('\\\\\\\\' + self.__remote_name + '\\\\' + service, password)\n        try:\n            fid = self.nt_create_andx(tid, filename, shareAccessMode = shareAccessMode, disposition = mode)\n            self.__nonraw_stor_file(tid, fid, offset, 0, callback)\n        finally:\n            if fid >= 0:\n                self.close(tid, fid)\n            self.disconnect_tree(tid)",
  "def check_dir(self, service, path, password = None):\n        path = path.replace('/', '\\\\')\n        tid = self.tree_connect_andx('\\\\\\\\' + self.__remote_name + '\\\\' + service, password)\n        try:\n            smb = NewSMBPacket()\n            smb['Tid'] = tid\n            smb['Mid'] = 0\n\n            cmd = SMBCommand(SMB.SMB_COM_CHECK_DIRECTORY)\n            cmd['Parameters'] = ''\n            cmd['Data'] = SMBCheckDirectory_Data(flags = self.__flags2)\n            cmd['Data']['DirectoryName'] = path.encode('utf-16le') if self.__flags2 & SMB.FLAGS2_UNICODE else path\n            smb.addCommand(cmd)\n\n            self.sendSMB(smb)\n\n            while 1:\n                s = self.recvSMB()\n                if s.isValidAnswer(SMB.SMB_COM_CHECK_DIRECTORY):\n                    return\n        finally:\n            self.disconnect_tree(tid)",
  "def remove(self, service, path, password = None):\n        path = path.replace('/', '\\\\')\n        # Perform a list to ensure the path exists\n        self.list_path(service, path, password)\n\n        tid = self.tree_connect_andx('\\\\\\\\' + self.__remote_name + '\\\\' + service, password)\n        try:\n            smb = NewSMBPacket()\n            smb['Tid'] = tid\n            smb['Mid'] = 0\n\n            cmd = SMBCommand(SMB.SMB_COM_DELETE)\n            cmd['Parameters'] = SMBDelete_Parameters()\n            cmd['Parameters']['SearchAttributes'] = ATTR_HIDDEN | ATTR_SYSTEM | ATTR_ARCHIVE\n            cmd['Data'] = SMBDelete_Data(flags = self.__flags2)\n            cmd['Data']['FileName'] = (path + '\\x00').encode('utf-16le') if self.__flags2 & SMB.FLAGS2_UNICODE else (path + '\\x00')\n            smb.addCommand(cmd)\n\n            self.sendSMB(smb)\n\n            while 1:\n                s = self.recvSMB()\n                if s.isValidAnswer(SMB.SMB_COM_DELETE):\n                    return\n        finally:\n            self.disconnect_tree(tid)",
  "def rmdir(self, service, path, password = None):\n        path = path.replace('/', '\\\\')\n        # Check that the directory exists\n        self.check_dir(service, path, password)\n\n        tid = self.tree_connect_andx('\\\\\\\\' + self.__remote_name + '\\\\' + service, password)\n        try:\n            path = path.encode('utf-16le') if self.__flags2 & SMB.FLAGS2_UNICODE else path\n\n            smb = NewSMBPacket()\n            smb['Tid'] = tid\n            createDir = SMBCommand(SMB.SMB_COM_DELETE_DIRECTORY)\n            createDir['Data'] = SMBDeleteDirectory_Data(flags=self.__flags2)\n            createDir['Data']['DirectoryName'] = path\n            smb.addCommand(createDir)\n\n            self.sendSMB(smb)\n\n            while 1:\n                s = self.recvSMB()\n                if s.isValidAnswer(SMB.SMB_COM_DELETE_DIRECTORY):\n                    return\n        finally:\n            self.disconnect_tree(tid)",
  "def mkdir(self, service, path, password = None):\n        path = path.replace('/', '\\\\')\n        tid = self.tree_connect_andx('\\\\\\\\' + self.__remote_name + '\\\\' + service, password)\n        try:\n            path = path.encode('utf-16le') if self.__flags2 & SMB.FLAGS2_UNICODE else path\n\n            smb = NewSMBPacket()\n            smb['Tid'] = tid\n            smb['Mid'] = 0\n\n            createDir = SMBCommand(SMB.SMB_COM_CREATE_DIRECTORY)\n            createDir['Data'] = SMBCreateDirectory_Data(flags=self.__flags2)\n            createDir['Data']['DirectoryName'] = path\n            smb.addCommand(createDir)\n\n            self.sendSMB(smb)\n\n            smb = self.recvSMB()\n            if smb.isValidAnswer(SMB.SMB_COM_CREATE_DIRECTORY):\n                return 1\n            return 0\n        finally:\n            self.disconnect_tree(tid)",
  "def rename(self, service, old_path, new_path, password = None):\n        old_path = old_path.replace('/', '\\\\')\n        new_path = new_path.replace('/', '\\\\')\n        tid = self.tree_connect_andx('\\\\\\\\' + self.__remote_name + '\\\\' + service, password)\n        try:\n            smb = NewSMBPacket()\n            smb['Tid'] = tid\n            smb['Mid'] = 0\n\n            renameCmd = SMBCommand(SMB.SMB_COM_RENAME)\n            renameCmd['Parameters'] = SMBRename_Parameters()\n            renameCmd['Parameters']['SearchAttributes'] = ATTR_SYSTEM | ATTR_HIDDEN | ATTR_DIRECTORY\n            renameCmd['Data'] = SMBRename_Data(flags = self.__flags2)\n            renameCmd['Data']['OldFileName'] = old_path.encode('utf-16le') if self.__flags2 & SMB.FLAGS2_UNICODE else old_path\n            renameCmd['Data']['NewFileName'] = new_path.encode('utf-16le') if self.__flags2 & SMB.FLAGS2_UNICODE else new_path\n            smb.addCommand(renameCmd)\n\n            self.sendSMB(smb)\n\n            smb = self.recvSMB()\n            if smb.isValidAnswer(SMB.SMB_COM_RENAME):\n               return 1\n            return 0\n        finally:\n            self.disconnect_tree(tid)",
  "def writeFile(self, treeId, fileId, data, offset = 0):\n        if (self._dialects_parameters['Capabilities'] & SMB.CAP_LARGE_WRITEX) and self._SignatureEnabled is False:\n            max_buf_size = 65000\n        else:\n            max_buf_size = self._dialects_parameters['MaxBufferSize'] & ~0x3ff  # Write in multiple KB blocks\n\n        write_offset = offset\n        while 1:\n            if len(data) == 0:\n                break\n            writeData = data[:max_buf_size]\n            data = data[max_buf_size:]\n\n            smb = self.write_andx(treeId,fileId,writeData, write_offset)\n            writeResponse   = SMBCommand(smb['Data'][0])\n            writeResponseParameters = SMBWriteAndXResponse_Parameters(writeResponse['Parameters'])\n            write_offset += writeResponseParameters['Count']",
  "def get_socket(self):\n        return self._sess.get_socket()",
  "def send_nt_trans(self, tid, subcommand, max_param_count, setup='', param='', data=''):\n        \"\"\"\n        [MS-CIFS]: 2.2.4.62.1 SMB_COM_NT_TRANSACT request.\n        :param tid:\n        :param subcommand: The transaction subcommand code\n        :param max_param_count:  This field MUST be set as specified in the subsections of Transaction subcommands.\n        :param setup: Transaction context to the server, depends on transaction subcommand.\n        :param param: Subcommand parameter bytes if any, depends on transaction subcommand.\n        :param data: Subcommand data bytes if any, depends on transaction subcommand.\n        :return: Buffer relative to requested subcommand.\n        \"\"\"\n        smb_packet = NewSMBPacket()\n        smb_packet['Tid'] = tid\n        #    setup depends on NT_TRANSACT subcommands so it may be 0.\n        setup_bytes = pack('<H', setup) if setup != '' else ''\n\n        transCommand = SMBCommand(SMB.SMB_COM_NT_TRANSACT)\n        transCommand['Parameters'] = SMBNTTransaction_Parameters()\n        transCommand['Parameters']['MaxDataCount'] = self._dialects_parameters['MaxBufferSize']\n        transCommand['Parameters']['Setup'] = setup_bytes\n        transCommand['Parameters']['Function'] = subcommand\n        transCommand['Parameters']['TotalParameterCount'] = len(param)\n        transCommand['Parameters']['TotalDataCount'] = len(data)\n        transCommand['Parameters']['MaxParameterCount'] = max_param_count\n        transCommand['Parameters']['MaxSetupCount'] = 0\n\n        transCommand['Data'] = SMBNTTransaction_Data()\n\n        # SMB header size + SMB_COM_NT_TRANSACT parameters size + length of setup bytes.\n        offset = 32 + 3 + 38 + len(setup_bytes)\n        transCommand['Data']['Pad1'] = ''\n        if offset % 4 != 0:\n            transCommand['Data']['Pad1'] = '\\0' * (4 - offset % 4)\n            offset += (4 - offset % 4)  # pad1 length\n\n        if len(param) > 0:\n            transCommand['Parameters']['ParameterOffset'] = offset\n        else:\n            transCommand['Parameters']['ParameterOffset'] = 0\n\n        offset += len(param)\n        transCommand['Data']['Pad2'] = ''\n        if offset % 4 != 0:\n            transCommand['Data']['Pad2'] = '\\0' * (4 - offset % 4)\n            offset += (4 - offset % 4)\n\n        if len(data) > 0:\n            transCommand['Parameters']['DataOffset'] = offset\n        else:\n            transCommand['Parameters']['DataOffset'] = 0\n\n        transCommand['Parameters']['DataCount'] = len(data)\n        transCommand['Parameters']['ParameterCount'] = len(param)\n        transCommand['Data']['NT_Trans_Parameters'] = param\n        transCommand['Data']['NT_Trans_Data'] = data\n        smb_packet.addCommand(transCommand)\n\n        self.sendSMB(smb_packet)",
  "def query_sec_info(self, tid, fid, additional_information=7):\n        \"\"\"\n        [MS-CIFS]: 2.2.7.6.1\n        NT_TRANSACT_QUERY_SECURITY_DESC 0x0006\n        :param tid: valid tree id.\n        :param fid: valid file handle.\n        :param additional_information: SecurityInfoFields. default = owner + group + dacl ie. 7\n        :return: security descriptor buffer\n        \"\"\"\n        self.send_nt_trans(tid, subcommand=0x0006, max_param_count=4,\n                           param=pack('<HHL', fid, 0x0000, additional_information))\n        resp = self.recvSMB()\n        if resp.isValidAnswer(SMB.SMB_COM_NT_TRANSACT):\n            nt_trans_response = SMBCommand(resp['Data'][0])\n            nt_trans_parameters = SMBNTTransactionResponse_Parameters(nt_trans_response['Parameters'])\n            # Remove Potential Prefix Padding\n            return nt_trans_response['Data'][-nt_trans_parameters['TotalDataCount']:]",
  "def echo(self, text = '', count = 1):\n\n        smb = NewSMBPacket()\n        comEcho = SMBCommand(SMB.SMB_COM_ECHO)\n        comEcho['Parameters'] = SMBEcho_Parameters()\n        comEcho['Data']       = SMBEcho_Data()\n        comEcho['Parameters']['EchoCount'] = count\n        comEcho['Data']['Data'] = text\n        smb.addCommand(comEcho)\n\n        self.sendSMB(smb)\n\n        for i in range(count):\n            resp = self.recvSMB()\n            resp.isValidAnswer(SMB.SMB_COM_ECHO)\n        return True",
  "def parsePacket(smb):\n            # If server speaks Unicode, let's set that flag from now on\n            if smb['Flags2'] & SMB.FLAGS2_UNICODE:\n                self.__flags2 |= SMB.FLAGS2_UNICODE\n\n            if smb.isValidAnswer(SMB.SMB_COM_NEGOTIATE):\n                sessionResponse = SMBCommand(smb['Data'][0])\n                self._dialects_parameters = SMBNTLMDialect_Parameters(sessionResponse['Parameters'])\n                self._dialects_data = SMBNTLMDialect_Data()\n                self._dialects_data['ChallengeLength'] = self._dialects_parameters['ChallengeLength']\n                self._dialects_data.fromString(sessionResponse['Data'])\n                if self._dialects_parameters['Capabilities'] & SMB.CAP_EXTENDED_SECURITY:\n                    # Whether we choose it or it is enforced by the server, we go for extended security\n                    self._dialects_parameters = SMBExtended_Security_Parameters(sessionResponse['Parameters'])\n                    self._dialects_data = SMBExtended_Security_Data(sessionResponse['Data'])\n                    # Let's setup some variable for later use\n                    if self._dialects_parameters['SecurityMode'] & SMB.SECURITY_SIGNATURES_REQUIRED:\n                         self._SignatureRequired = True\n\n                    # Interestingly, the security Blob might be missing sometimes.\n                    #spnego = SPNEGO_NegTokenInit(self._dialects_data['SecurityBlob'])\n                    #for i in spnego['MechTypes']:\n                    #      print \"Mech Found: %s\" % MechTypes[i]\n                    return 1\n\n                # If not, let's try the old way\n                else:\n                    if self._dialects_data['ServerName'] is not None:\n                        self.__server_name = self._dialects_data['ServerName']\n\n                    if self._dialects_parameters['DialectIndex'] == 0xffff:\n                        raise UnsupportedFeature(\"Remote server does not know NT LM 0.12\")\n                    return 1\n            else:\n                return 0",
  "class ImpactPacketException(Exception):\n    def __init__(self, value):\n        self.value = value\n    def __str__(self):\n        return repr(self.value)",
  "class PacketBuffer(object):\n    \"\"\"Implement the basic operations utilized to operate on a\n    packet's raw buffer. All the packet classes derive from this one.\n\n    The byte, word, long and ip_address getters and setters accept\n    negative indexes, having these the a similar effect as in a\n    regular Python sequence slice.\n    \"\"\"\n\n    def __init__(self, length = None):\n        \"If 'length' is specified the buffer is created with an initial size\"\n        if length:\n            self.__bytes = array.array('B', b'\\0' * length)\n        else:\n            self.__bytes = array.array('B')\n\n    def set_bytes_from_string(self, data):\n        \"Sets the value of the packet buffer from the string 'data'\"\n        self.__bytes = array.array('B', data)\n\n    def get_buffer_as_string(self):\n        \"Returns the packet buffer as a string object\"\n        return array_tobytes(self.__bytes)\n\n    def get_bytes(self):\n        \"Returns the packet buffer as an array\"\n        return self.__bytes\n\n    def set_bytes(self, bytes):\n        \"Set the packet buffer from an array\"\n        # Make a copy to be safe\n        self.__bytes = array.array('B', bytes.tolist())\n\n    def set_byte(self, index, value):\n        \"Set byte at 'index' to 'value'\"\n        index = self.__validate_index(index, 1)\n        self.__bytes[index] = value\n\n    def get_byte(self, index):\n        \"Return byte at 'index'\"\n        index = self.__validate_index(index, 1)\n        return self.__bytes[index]\n\n    def set_word(self, index, value, order = '!'):\n        \"Set 2-byte word at 'index' to 'value'. See struct module's documentation to understand the meaning of 'order'.\"\n        index = self.__validate_index(index, 2)\n        ary = array.array(\"B\", struct.pack(order + 'H', value))\n        if -2 == index:\n            self.__bytes[index:] = ary\n        else:\n            self.__bytes[index:index+2] = ary\n\n    def get_word(self, index, order = '!'):\n        \"Return 2-byte word at 'index'. See struct module's documentation to understand the meaning of 'order'.\"\n        index = self.__validate_index(index, 2)\n        if -2 == index:\n            bytes = self.__bytes[index:]\n        else:\n            bytes = self.__bytes[index:index+2]\n        (value,) = struct.unpack(order + 'H', array_tobytes(bytes))\n        return value\n\n    def set_long(self, index, value, order = '!'):\n        \"Set 4-byte 'value' at 'index'. See struct module's documentation to understand the meaning of 'order'.\"\n        index = self.__validate_index(index, 4)\n        ary = array.array(\"B\", struct.pack(order + 'L', value))\n        if -4 == index:\n            self.__bytes[index:] = ary\n        else:\n            self.__bytes[index:index+4] = ary\n\n    def get_long(self, index, order = '!'):\n        \"Return 4-byte value at 'index'. See struct module's documentation to understand the meaning of 'order'.\"\n        index = self.__validate_index(index, 4)\n        if -4 == index:\n            bytes = self.__bytes[index:]\n        else:\n            bytes = self.__bytes[index:index+4]\n        (value,) = struct.unpack(order + 'L', array_tobytes(bytes))\n        return value\n\n    def set_long_long(self, index, value, order = '!'):\n        \"Set 8-byte 'value' at 'index'. See struct module's documentation to understand the meaning of 'order'.\"\n        index = self.__validate_index(index, 8)\n        ary = array.array(\"B\", struct.pack(order + 'Q', value))\n        if -8 == index:\n            self.__bytes[index:] = ary\n        else:\n            self.__bytes[index:index+8] = ary\n\n    def get_long_long(self, index, order = '!'):\n        \"Return 8-byte value at 'index'. See struct module's documentation to understand the meaning of 'order'.\"\n        index = self.__validate_index(index, 8)\n        if -8 == index:\n            bytes = self.__bytes[index:]\n        else:\n            bytes = self.__bytes[index:index+8]\n        (value,) = struct.unpack(order + 'Q', array_tobytes(bytes))\n        return value\n\n\n    def get_ip_address(self, index):\n        \"Return 4-byte value at 'index' as an IP string\"\n        index = self.__validate_index(index, 4)\n        if -4 == index:\n            bytes = self.__bytes[index:]\n        else:\n            bytes = self.__bytes[index:index+4]\n        return socket.inet_ntoa(array_tobytes(bytes))\n\n    def set_ip_address(self, index, ip_string):\n        \"Set 4-byte value at 'index' from 'ip_string'\"\n        index = self.__validate_index(index, 4)\n        raw = socket.inet_aton(ip_string)\n        (b1,b2,b3,b4) = struct.unpack(\"BBBB\", raw)\n        self.set_byte(index, b1)\n        self.set_byte(index + 1, b2)\n        self.set_byte(index + 2, b3)\n        self.set_byte(index + 3, b4)\n\n    def set_checksum_from_data(self, index, data):\n        \"Set 16-bit checksum at 'index' by calculating checksum of 'data'\"\n        self.set_word(index, self.compute_checksum(data))\n\n    def compute_checksum(self, anArray):\n        \"Return the one's complement of the one's complement sum of all the 16-bit words in 'anArray'\"\n        nleft = len(anArray)\n        sum = 0\n        pos = 0\n        while nleft > 1:\n            sum = anArray[pos] * 256 + (anArray[pos + 1] + sum)\n            pos = pos + 2\n            nleft = nleft - 2\n        if nleft == 1:\n            sum = sum + anArray[pos] * 256\n        return self.normalize_checksum(sum)\n\n    def normalize_checksum(self, aValue):\n        sum = aValue\n        sum = (sum >> 16) + (sum & 0xFFFF)\n        sum += (sum >> 16)\n        sum = (~sum & 0xFFFF)\n        return sum\n\n    def __validate_index(self, index, size):\n        \"\"\"This method performs two tasks: to allocate enough space to\n        fit the elements at positions index through index+size, and to\n        adjust negative indexes to their absolute equivalent.\n        \"\"\"\n\n        orig_index = index\n\n        curlen = len(self.__bytes)\n        if index < 0:\n            index = curlen + index\n\n        diff = index + size - curlen\n        if diff > 0:\n            array_frombytes(self.__bytes, b'\\0' * diff)\n            if orig_index < 0:\n                orig_index -= diff\n\n        return orig_index",
  "class ProtocolLayer():\n    \"Protocol Layer Manager for insertion and removal of protocol layers.\"\n\n    __child = None\n    __parent = None\n        \n    def contains(self, aHeader):\n        \"Set 'aHeader' as the child of this protocol layer\"\n        self.__child = aHeader\n        aHeader.set_parent(self)\n\n    def set_parent(self, my_parent):\n        \"Set the header 'my_parent' as the parent of this protocol layer\"\n        self.__parent = my_parent\n\n    def child(self):\n        \"Return the child of this protocol layer\"\n        return self.__child\n\n    def parent(self):\n        \"Return the parent of this protocol layer\"\n        return self.__parent\n    \n    def unlink_child(self):\n        \"Break the hierarchy parent/child child/parent\"\n        if self.__child:\n            self.__child.set_parent(None)\n            self.__child = None",
  "class ProtocolPacket(ProtocolLayer):\n    __HEADER_SIZE = 0\n    __BODY_SIZE = 0\n    __TAIL_SIZE = 0\n    \n    __header = None\n    __body = None\n    __tail = None\n\n    def __init__(self, header_size, tail_size):\n        self.__HEADER_SIZE = header_size\n        self.__TAIL_SIZE = tail_size\n        self.__header=PacketBuffer(self.__HEADER_SIZE)\n        self.__body=PacketBuffer()\n        self.__tail=PacketBuffer(self.__TAIL_SIZE)\n        \n    def __update_body_from_child(self):\n        # Update child raw packet in my body\n        if self.child():\n            body=self.child().get_packet()\n            self.__BODY_SIZE=len(body)\n            self.__body.set_bytes_from_string(body)\n            \n    def __get_header(self):\n        return self.__header\n    \n    header = property(__get_header)\n\n    def __get_body(self):\n        self.__update_body_from_child()\n        return self.__body\n    \n    body = property(__get_body)\n    \n    def __get_tail(self):\n        return self.__tail\n    \n    tail = property(__get_tail)\n\n    def get_header_size(self):\n        \"Return frame header size\"\n        return self.__HEADER_SIZE\n    \n    def get_tail_size(self):\n        \"Return frame tail size\"\n        return self.__TAIL_SIZE\n    \n    def get_body_size(self):\n        \"Return frame body size\"\n        self.__update_body_from_child()\n        return self.__BODY_SIZE\n\n    def get_size(self):\n        \"Return frame total size\"\n        return self.get_header_size()+self.get_body_size()+self.get_tail_size()\n    \n    def load_header(self, aBuffer):\n        self.__HEADER_SIZE=len(aBuffer)\n        self.__header.set_bytes_from_string(aBuffer)\n    \n    def load_body(self, aBuffer):\n        \"Load the packet body from string. \"\\\n        \"WARNING: Using this function will break the hierarchy of preceding protocol layer\"\n        self.unlink_child()\n        self.__BODY_SIZE=len(aBuffer)\n        self.__body.set_bytes_from_string(aBuffer)\n    \n    def load_tail(self, aBuffer):\n        self.__TAIL_SIZE=len(aBuffer)\n        self.__tail.set_bytes_from_string(aBuffer)\n    \n    def __extract_header(self, aBuffer):\n        self.load_header(aBuffer[:self.__HEADER_SIZE])\n        \n    def __extract_body(self, aBuffer):\n        if self.__TAIL_SIZE<=0:\n            end=None\n        else:\n            end=-self.__TAIL_SIZE\n        self.__BODY_SIZE=len(aBuffer[self.__HEADER_SIZE:end])\n        self.__body.set_bytes_from_string(aBuffer[self.__HEADER_SIZE:end])\n        \n    def __extract_tail(self, aBuffer):\n        if self.__TAIL_SIZE<=0:\n            # leave the array empty\n            return\n        else:\n            start=-self.__TAIL_SIZE\n        self.__tail.set_bytes_from_string(aBuffer[start:])\n\n    def load_packet(self, aBuffer):\n        \"Load the whole packet from a string\" \\\n        \"WARNING: Using this function will break the hierarchy of preceding protocol layer\"\n        self.unlink_child()\n        \n        self.__extract_header(aBuffer)\n        self.__extract_body(aBuffer)\n        self.__extract_tail(aBuffer)\n        \n    def get_header_as_string(self):\n        return self.__header.get_buffer_as_string()\n        \n    def get_body_as_string(self):\n        self.__update_body_from_child()\n        return self.__body.get_buffer_as_string()\n    body_string = property(get_body_as_string)\n    \n    def get_tail_as_string(self):\n        return self.__tail.get_buffer_as_string()\n    tail_string = property(get_tail_as_string)\n        \n    def get_packet(self):\n        self.__update_body_from_child()\n        \n        ret = b''\n        \n        header = self.get_header_as_string()\n        if header:\n            ret += header\n\n        body = self.get_body_as_string()\n        if body:\n            ret += body\n        \n        tail = self.get_tail_as_string()    \n        if tail:\n            ret += tail\n            \n        return ret",
  "class Header(PacketBuffer,ProtocolLayer):\n    \"This is the base class from which all protocol definitions extend.\"\n\n    packet_printable = [c for c in string.printable if c not in string.whitespace] + [' ']\n\n    ethertype = None\n    protocol = None\n    def __init__(self, length = None):\n        PacketBuffer.__init__(self, length)\n        self.auto_checksum = 1\n\n    def get_data_as_string(self):\n        \"Returns all data from children of this header as string\"\n\n        if self.child():\n            return self.child().get_packet()\n        else:\n            return None\n\n    def get_packet(self):\n        \"\"\"Returns the raw representation of this packet and its\n        children as a string. The output from this method is a packet\n        ready to be transmitted over the wire.\n        \"\"\"\n        self.calculate_checksum()\n\n        data = self.get_data_as_string()\n        if data:\n            return self.get_buffer_as_string() + data\n        else:\n            return self.get_buffer_as_string()\n\n    def get_size(self):\n        \"Return the size of this header and all of it's children\"\n        tmp_value = self.get_header_size()\n        if self.child():\n            tmp_value = tmp_value + self.child().get_size()\n        return tmp_value\n\n    def calculate_checksum(self):\n        \"Calculate and set the checksum for this header\"\n        pass\n\n    def get_pseudo_header(self):\n        \"Pseudo headers can be used to limit over what content will the checksums be calculated.\"\n        # default implementation returns empty array\n        return array.array('B')\n\n    def load_header(self, aBuffer):\n        \"Properly set the state of this instance to reflect that of the raw packet passed as argument.\"\n        self.set_bytes_from_string(aBuffer)\n        hdr_len = self.get_header_size()\n        if(len(aBuffer) < hdr_len):         #we must do something like this\n            diff = hdr_len - len(aBuffer)\n            for i in range(0, diff):\n                aBuffer += '\\x00'\n        self.set_bytes_from_string(aBuffer[:hdr_len])\n\n    def get_header_size(self):\n        \"Return the size of this header, that is, not counting neither the size of the children nor of the parents.\"\n        raise RuntimeError(\"Method %s.get_header_size must be overridden.\" % self.__class__)\n\n    def list_as_hex(self, aList):\n        if len(aList):\n            ltmp = []\n            line = []\n            count = 0\n            for byte in aList:\n                if not (count % 2):\n                    if (count % 16):\n                        ltmp.append(' ')\n                    else:\n                        ltmp.append(' '*4)\n                        ltmp.append(''.join(line))\n                        ltmp.append('\\n')\n                        line = []\n                if chr(byte) in Header.packet_printable:\n                    line.append(chr(byte))\n                else:\n                    line.append('.')\n                ltmp.append('%.2x' % byte)\n                count += 1\n            if (count%16):\n                left = 16 - (count%16)\n                ltmp.append(' ' * (4+(left // 2) + (left*2)))\n                ltmp.append(''.join(line))\n                ltmp.append('\\n')\n            return ltmp\n        else:\n            return []\n\n    def __str__(self):\n        ltmp = self.list_as_hex(self.get_bytes().tolist())\n\n        if self.child():\n            ltmp.append(['\\n', str(self.child())])\n\n        if len(ltmp)>0:\n            return ''.join(ltmp)\n        else:\n            return ''",
  "class Data(Header):\n    \"\"\"This packet type can hold raw data. It's normally employed to\n    hold a packet's innermost layer's contents in those cases for\n    which the protocol details are unknown, and there's a copy of a\n    valid packet available.\n\n    For instance, if all that's known about a certain protocol is that\n    a UDP packet with its contents set to \"HELLO\" initiate a new\n    session, creating such packet is as simple as in the following code\n    fragment:\n    packet = UDP()\n    packet.contains('HELLO')\n    \"\"\"\n\n    def __init__(self, aBuffer = None):\n        Header.__init__(self)\n        if aBuffer:\n            self.set_data(aBuffer)\n\n    def set_data(self, data):\n        self.set_bytes_from_string(data)\n\n    def get_size(self):\n        return len(self.get_bytes())",
  "class EthernetTag(PacketBuffer):\n    \"\"\"Represents a VLAN header specified in IEEE 802.1Q and 802.1ad.\n       Provides methods for convenient manipulation with header fields.\"\"\"\n\n    def __init__(self, value=0x81000000):\n        PacketBuffer.__init__(self, 4)\n        self.set_long(0, value)\n\n    def get_tpid(self):\n        \"\"\"Returns Tag Protocol Identifier\"\"\"\n        return self.get_word(0)\n\n    def set_tpid(self, value):\n        \"\"\"Sets Tag Protocol Identifier\"\"\"\n        return self.set_word(0, value)\n\n    def get_pcp(self):\n        \"\"\"Returns Priority Code Point\"\"\"\n        return (self.get_byte(2) & 0xE0) >> 5\n\n    def set_pcp(self, value):\n        \"\"\"Sets Priority Code Point\"\"\"\n        orig_value = self.get_byte(2)\n        self.set_byte(2, (orig_value & 0x1F) | ((value & 0x07) << 5))\n\n    def get_dei(self):\n        \"\"\"Returns Drop Eligible Indicator\"\"\"\n        return (self.get_byte(2) & 0x10) >> 4\n\n    def set_dei(self, value):\n        \"\"\"Sets Drop Eligible Indicator\"\"\"\n        orig_value = self.get_byte(2)\n        self.set_byte(2, orig_value | 0x10 if value else orig_value & 0xEF)\n\n    def get_vid(self):\n        \"\"\"Returns VLAN Identifier\"\"\"\n        return self.get_word(2) & 0x0FFF\n\n    def set_vid(self, value):\n        \"\"\"Sets VLAN Identifier\"\"\"\n        orig_value = self.get_word(2)\n        self.set_word(2, (orig_value & 0xF000) | (value & 0x0FFF))\n\n    def __str__(self):\n        priorities = (\n            'Best Effort',\n            'Background',\n            'Excellent Effort',\n            'Critical Applications',\n            'Video, < 100 ms latency and jitter',\n            'Voice, < 10 ms latency and jitter',\n            'Internetwork Control',\n            'Network Control')\n\n        pcp = self.get_pcp()\n        return '\\n'.join((\n            '802.1Q header: 0x{0:08X}'.format(self.get_long(0)),\n            'Priority Code Point: {0} ({1})'.format(pcp, priorities[pcp]),\n            'Drop Eligible Indicator: {0}'.format(self.get_dei()),\n            'VLAN Identifier: {0}'.format(self.get_vid())))",
  "class Ethernet(Header):\n    def __init__(self, aBuffer = None):\n        Header.__init__(self, 14)\n        self.tag_cnt = 0\n        if(aBuffer):\n            self.load_header(aBuffer)\n\n    def set_ether_type(self, aValue):\n        \"Set ethernet data type field to 'aValue'\"\n        self.set_word(12 + 4*self.tag_cnt, aValue)\n\n    def get_ether_type(self):\n        \"Return ethernet data type field\"\n        return self.get_word(12 + 4*self.tag_cnt)\n\n    def get_tag(self, index):\n        \"\"\"Returns an EthernetTag initialized from index-th VLAN tag.\n           The tags are numbered from 0 to self.tag_cnt-1 as they appear in the frame.\n           It is possible to use negative indexes as well.\"\"\"\n        index = self.__validate_tag_index(index)\n        return EthernetTag(self.get_long(12+4*index))\n\n    def set_tag(self, index, tag):\n        \"\"\"Sets the index-th VLAN tag to contents of an EthernetTag object.\n           The tags are numbered from 0 to self.tag_cnt-1 as they appear in the frame.\n           It is possible to use negative indexes as well.\"\"\"\n        index = self.__validate_tag_index(index)\n        pos = 12 + 4*index\n        for i,val in enumerate(tag.get_bytes()):\n            self.set_byte(pos+i, val)\n\n    def push_tag(self, tag, index=0):\n        \"\"\"Inserts contents of an EthernetTag object before the index-th VLAN tag.\n           Index defaults to 0 (the top of the stack).\"\"\"\n        if index < 0:\n            index += self.tag_cnt\n        pos = 12 + 4*max(0, min(index, self.tag_cnt))\n        data = self.get_bytes()\n        data[pos:pos] = tag.get_bytes()\n        self.set_bytes(data)\n        self.tag_cnt += 1\n\n    def pop_tag(self, index=0):\n        \"\"\"Removes the index-th VLAN tag and returns it as an EthernetTag object.\n           Index defaults to 0 (the top of the stack).\"\"\"\n        index = self.__validate_tag_index(index)\n        pos = 12 + 4*index\n        tag = self.get_long(pos)\n        data = self.get_bytes()\n        del data[pos:pos+4]\n        self.set_bytes(data)\n        self.tag_cnt -= 1\n        return EthernetTag(tag)\n\n    def load_header(self, aBuffer):\n        self.tag_cnt = 0\n        while aBuffer[12+4*self.tag_cnt:14+4*self.tag_cnt] in (b'\\x81\\x00', b'\\x88\\xa8', b'\\x91\\x00'):\n            self.tag_cnt += 1\n\n        hdr_len = self.get_header_size()\n        diff = hdr_len - len(aBuffer)\n        if diff > 0:\n            aBuffer += b'\\x00'*diff\n        self.set_bytes_from_string(aBuffer[:hdr_len])\n\n    def get_header_size(self):\n        \"Return size of Ethernet header\"\n        return 14 + 4*self.tag_cnt\n\n    def get_packet(self):\n\n        if self.child():\n            try:\n                self.set_ether_type(self.child().ethertype)\n            except:\n                \" an Ethernet packet may have a Data() \"\n                pass\n        return Header.get_packet(self)\n\n    def get_ether_dhost(self):\n        \"Return 48 bit destination ethernet address as a 6 byte array\"\n        return self.get_bytes()[0:6]\n\n    def set_ether_dhost(self, aValue):\n        \"Set destination ethernet address from 6 byte array 'aValue'\"\n        for i in range(0, 6):\n            self.set_byte(i, aValue[i])\n\n    def get_ether_shost(self):\n        \"Return 48 bit source ethernet address as a 6 byte array\"\n        return self.get_bytes()[6:12]\n\n    def set_ether_shost(self, aValue):\n        \"Set source ethernet address from 6 byte array 'aValue'\"\n        for i in range(0, 6):\n            self.set_byte(i + 6, aValue[i])\n\n    @staticmethod\n    def as_eth_addr(anArray):\n        tmp_list = [x > 15 and '%x'%x or '0%x'%x for x in anArray]\n        return '' + reduce(lambda x, y: x+':'+y, tmp_list)\n\n    def __str__(self):\n        tmp_str = 'Ether: ' + self.as_eth_addr(self.get_ether_shost()) + ' -> '\n        tmp_str += self.as_eth_addr(self.get_ether_dhost())\n        if self.child():\n            tmp_str += '\\n' + str( self.child())\n        return tmp_str\n\n    def __validate_tag_index(self, index):\n        \"\"\"Adjusts negative indices to their absolute equivalents.\n           Raises IndexError when out of range <0, self.tag_cnt-1>.\"\"\"\n        if index < 0:\n            index += self.tag_cnt\n        if index < 0 or index >= self.tag_cnt:\n            raise IndexError(\"Tag index out of range\")\n        return index",
  "class LinuxSLL(Header):\n    type_descriptions = [\n        \"sent to us by somebody else\",\n        \"broadcast by somebody else\",\n        \"multicast by somebody else\",\n        \"sent to somebody else to somebody else\",\n        \"sent by us\",\n        ]\n\n    def __init__(self, aBuffer = None):\n        Header.__init__(self, 16)\n        if (aBuffer):\n            self.load_header(aBuffer)\n\n    def set_type(self, type):\n        \"Sets the packet type field to type\"\n        self.set_word(0, type)\n\n    def get_type(self):\n        \"Returns the packet type field\"\n        return self.get_word(0)\n\n    def set_arphdr(self, value):\n        \"Sets the ARPHDR value for the link layer device type\"\n        self.set_word(2, type)\n\n    def get_arphdr(self):\n        \"Returns the ARPHDR value for the link layer device type\"\n        return self.get_word(2)\n\n    def set_addr_len(self, len):\n        \"Sets the length of the sender's address field to len\"\n        self.set_word(4, len)\n\n    def get_addr_len(self):\n        \"Returns the length of the sender's address field\"\n        return self.get_word(4)\n\n    def set_addr(self, addr):\n        \"Sets the sender's address field to addr. Addr must be at most 8-byte long.\"\n        if (len(addr) < 8):\n            addr += b'\\0' * (8 - len(addr))\n        self.get_bytes()[6:14] = addr\n\n    def get_addr(self):\n        \"Returns the sender's address field\"\n        return array_tobytes(self.get_bytes()[6:14])\n\n    def set_ether_type(self, aValue):\n        \"Set ethernet data type field to 'aValue'\"\n        self.set_word(14, aValue)\n\n    def get_ether_type(self):\n        \"Return ethernet data type field\"\n        return self.get_word(14)\n\n    def get_header_size(self):\n        \"Return size of packet header\"\n        return 16\n\n    def get_packet(self):\n        if self.child():\n            self.set_ether_type(self.child().ethertype)\n        return Header.get_packet(self)\n\n    def get_type_desc(self):\n        type = self.get_type()\n        if type < len(LinuxSLL.type_descriptions):\n            return LinuxSLL.type_descriptions[type]\n        else:\n            return \"Unknown\"\n\n    def __str__(self):\n        ss = []\n        alen = self.get_addr_len()\n        addr = hexlify(self.get_addr()[0:alen])\n        ss.append(\"Linux SLL: addr=%s type=`%s'\" % (addr, self.get_type_desc()))\n        if self.child():\n            ss.append(str(self.child()))\n\n        return '\\n'.join(ss)",
  "class IP(Header):\n    ethertype = 0x800\n    def __init__(self, aBuffer = None):\n        Header.__init__(self, 20)\n        self.set_ip_v(4)\n        self.set_ip_hl(5)\n        self.set_ip_ttl(255)\n        self.__option_list = []\n        if(aBuffer):\n            # When decoding, checksum shouldn't be modified\n            self.auto_checksum = 0\n            self.load_header(aBuffer)\n            \n        if sys.platform.count('bsd'):\n            self.is_BSD = True\n        else:\n            self.is_BSD = False\n\n\n    def get_packet(self):\n        # set protocol\n        if self.get_ip_p() == 0 and self.child():\n            self.set_ip_p(self.child().protocol)\n\n        # set total length\n        if self.get_ip_len() == 0:\n            self.set_ip_len(self.get_size())\n\n        child_data = self.get_data_as_string()\n\n        if self.auto_checksum:\n            self.reset_ip_sum()\n\n        my_bytes = self.get_bytes()\n\n        for op in self.__option_list:\n            my_bytes.extend(op.get_bytes())\n\n        # Pad to a multiple of 4 bytes\n        num_pad = (4 - (len(my_bytes) % 4)) % 4\n        if num_pad:\n            array_frombytes(my_bytes, b\"\\0\" * num_pad)\n\n        # only change ip_hl value if options are present\n        if len(self.__option_list):\n            self.set_ip_hl(len(my_bytes) // 4)\n\n\n        # set the checksum if the user hasn't modified it\n        if self.auto_checksum:\n            self.set_ip_sum(self.compute_checksum(my_bytes))\n\n        if child_data is None:\n            return array_tobytes(my_bytes)\n        else:\n            return array_tobytes(my_bytes) + child_data\n\n\n\n    #  def calculate_checksum(self, buffer = None):\n    #      tmp_value = self.get_ip_sum()\n    #      if self.auto_checksum and (not tmp_value):\n    #          if buffer:\n    #              tmp_bytes = buffer\n    #          else:\n    #              tmp_bytes = self.bytes[0:self.get_header_size()]\n    #\n    #          self.set_ip_sum(self.compute_checksum(tmp_bytes))\n\n\n    def get_pseudo_header(self):\n        pseudo_buf = array.array(\"B\")\n        pseudo_buf.extend(self.get_bytes()[12:20])\n        pseudo_buf.fromlist([0])\n        pseudo_buf.extend(self.get_bytes()[9:10])\n        tmp_size = self.child().get_size()\n\n        size_str = struct.pack(\"!H\", tmp_size)\n\n        array_frombytes(pseudo_buf, size_str)\n        return pseudo_buf\n\n    def add_option(self, option):\n        self.__option_list.append(option)\n        sum = 0\n        for op in self.__option_list:\n            sum += op.get_len()\n        if sum > 40:\n            raise ImpactPacketException(\"Options overflowed in IP packet with length: %d\" % sum)\n\n\n    def get_ip_v(self):\n        n = self.get_byte(0)\n        return (n >> 4)\n\n    def set_ip_v(self, value):\n        n = self.get_byte(0)\n        version = value & 0xF\n        n = n & 0xF\n        n = n | (version << 4)\n        self.set_byte(0, n)\n\n    def get_ip_hl(self):\n        n = self.get_byte(0)\n        return (n & 0xF)\n\n    def set_ip_hl(self, value):\n        n = self.get_byte(0)\n        len = value & 0xF\n        n = n & 0xF0\n        n = (n | len)\n        self.set_byte(0, n)\n\n    def get_ip_tos(self):\n        return self.get_byte(1)\n\n    def set_ip_tos(self,value):\n        self.set_byte(1, value)\n\n    def get_ip_len(self):\n        if self.is_BSD:\n            return self.get_word(2, order = '=')\n        else:\n            return self.get_word(2)\n\n    def set_ip_len(self, value):\n        if self.is_BSD:\n            self.set_word(2, value, order = '=')\n        else:\n            self.set_word(2, value)\n\n    def get_ip_id(self):\n        return self.get_word(4)\n    def set_ip_id(self, value):\n        return self.set_word(4, value)\n\n    def get_ip_off(self):\n        if self.is_BSD:\n            return self.get_word(6, order = '=')\n        else:\n            return self.get_word(6)\n\n    def set_ip_off(self, aValue):\n        if self.is_BSD:\n            self.set_word(6, aValue, order = '=')\n        else:\n            self.set_word(6, aValue)\n\n    def get_ip_offmask(self):\n        return self.get_ip_off() & 0x1FFF\n\n    def set_ip_offmask(self, aValue):\n        tmp_value = self.get_ip_off() & 0xD000\n        tmp_value |= aValue\n        self.set_ip_off(tmp_value)\n\n    def get_ip_rf(self):\n        return self.get_ip_off() & 0x8000\n\n    def set_ip_rf(self, aValue):\n        tmp_value = self.get_ip_off()\n        if aValue:\n            tmp_value |= 0x8000\n        else:\n            my_not = 0xFFFF ^ 0x8000\n            tmp_value &= my_not\n        self.set_ip_off(tmp_value)\n\n    def get_ip_df(self):\n        return self.get_ip_off() & 0x4000\n\n    def set_ip_df(self, aValue):\n        tmp_value = self.get_ip_off()\n        if aValue:\n            tmp_value |= 0x4000\n        else:\n            my_not = 0xFFFF ^ 0x4000\n            tmp_value &= my_not\n        self.set_ip_off(tmp_value)\n\n    def get_ip_mf(self):\n        return self.get_ip_off() & 0x2000\n\n    def set_ip_mf(self, aValue):\n        tmp_value = self.get_ip_off()\n        if aValue:\n            tmp_value |= 0x2000\n        else:\n            my_not = 0xFFFF ^ 0x2000\n            tmp_value &= my_not\n        self.set_ip_off(tmp_value)\n\n\n    def fragment_by_list(self, aList):\n        if self.child():\n            proto = self.child().protocol\n        else:\n            proto = 0\n\n        child_data = self.get_data_as_string()\n        if not child_data:\n            return [self]\n\n        ip_header_bytes = self.get_bytes()\n        current_offset = 0\n        fragment_list = []\n\n        for frag_size in aList:\n            ip = IP()\n            ip.set_bytes(ip_header_bytes) # copy of original header\n            ip.set_ip_p(proto)\n\n\n            if frag_size % 8:   # round this fragment size up to next multiple of 8\n                frag_size += 8 - (frag_size % 8)\n\n\n            ip.set_ip_offmask(current_offset // 8)\n            current_offset += frag_size\n\n            data = Data(child_data[:frag_size])\n            child_data = child_data[frag_size:]\n\n            ip.set_ip_len(20 + data.get_size())\n            ip.contains(data)\n\n\n            if child_data:\n\n                ip.set_ip_mf(1)\n\n                fragment_list.append(ip)\n            else: # no more data bytes left to add to fragments\n\n                ip.set_ip_mf(0)\n\n                fragment_list.append(ip)\n                return fragment_list\n\n        if child_data: # any remaining data?\n            # create a fragment containing all of the remaining child_data\n            ip = IP()\n            ip.set_bytes(ip_header_bytes)\n            ip.set_ip_offmask(current_offset)\n            ip.set_ip_len(20 + len(child_data))\n            data = Data(child_data)\n            ip.contains(data)\n            fragment_list.append(ip)\n\n        return fragment_list\n\n\n    def fragment_by_size(self, aSize):\n        data_len = len(self.get_data_as_string())\n        num_frags = data_len // aSize\n\n        if data_len % aSize:\n            num_frags += 1\n\n        size_list = []\n        for i in range(0, num_frags):\n            size_list.append(aSize)\n        return self.fragment_by_list(size_list)\n\n\n    def get_ip_ttl(self):\n        return self.get_byte(8)\n    def set_ip_ttl(self, value):\n        self.set_byte(8, value)\n\n    def get_ip_p(self):\n        return self.get_byte(9)\n\n    def set_ip_p(self, value):\n        self.set_byte(9, value)\n\n    def get_ip_sum(self):\n        return self.get_word(10)\n    def set_ip_sum(self, value):\n        self.auto_checksum = 0\n        self.set_word(10, value)\n\n    def reset_ip_sum(self):\n        self.set_ip_sum(0x0000)\n        self.auto_checksum = 1\n\n    def get_ip_src(self):\n        return self.get_ip_address(12)\n    def set_ip_src(self, value):\n        self.set_ip_address(12, value)\n\n    def get_ip_dst(self):\n        return self.get_ip_address(16)\n\n    def set_ip_dst(self, value):\n        self.set_ip_address(16, value)\n\n    def get_header_size(self):\n        op_len = 0\n        for op in self.__option_list:\n            op_len += op.get_len()\n\n        num_pad = (4 - (op_len % 4)) % 4\n\n        return 20 + op_len + num_pad\n\n    def load_header(self, aBuffer):\n        self.set_bytes_from_string(aBuffer[:20])\n        opt_left = (self.get_ip_hl() - 5) * 4\n        opt_bytes = array.array('B', aBuffer[20:(20 + opt_left)])\n        if len(opt_bytes) != opt_left:\n            raise ImpactPacketException(\"Cannot load options from truncated packet\")\n\n\n        while opt_left:\n            op_type = opt_bytes[0]\n            if op_type == IPOption.IPOPT_EOL or op_type == IPOption.IPOPT_NOP:\n                new_option = IPOption(op_type)\n                op_len = 1\n            else:\n                op_len = opt_bytes[1]\n                if op_len > len(opt_bytes):\n                    raise ImpactPacketException(\"IP Option length is too high\")\n\n                new_option = IPOption(op_type, op_len)\n                new_option.set_bytes(opt_bytes[:op_len])\n\n            opt_bytes = opt_bytes[op_len:]\n            opt_left -= op_len\n            self.add_option(new_option)\n            if op_type == IPOption.IPOPT_EOL:\n                break\n\n\n    def __str__(self):\n        flags = ' '\n        if self.get_ip_df():\n            flags += 'DF '\n        if self.get_ip_mf():\n            flags += 'MF '\n        if self.get_ip_rf():\n            flags += 'RF '\n        tmp_str = 'IP%s%s -> %s ' % (flags, self.get_ip_src(),self.get_ip_dst())\n        for op in self.__option_list:\n            tmp_str += '\\n' + str(op)\n        if self.child():\n            tmp_str += '\\n' + str(self.child())\n        return tmp_str",
  "class IPOption(PacketBuffer):\n    IPOPT_EOL = 0\n    IPOPT_NOP = 1\n    IPOPT_RR = 7\n    IPOPT_TS = 68\n    IPOPT_LSRR = 131\n    IPOPT_SSRR = 137\n\n    def __init__(self, opcode = 0, size = None):\n        if size and (size < 3 or size > 40):\n            raise ImpactPacketException(\"IP Options must have a size between 3 and 40 bytes\")\n\n        if(opcode == IPOption.IPOPT_EOL):\n            PacketBuffer.__init__(self, 1)\n            self.set_code(IPOption.IPOPT_EOL)\n        elif(opcode == IPOption.IPOPT_NOP):\n            PacketBuffer.__init__(self, 1)\n            self.set_code(IPOption.IPOPT_NOP)\n        elif(opcode == IPOption.IPOPT_RR):\n            if not size:\n                size = 39\n            PacketBuffer.__init__(self, size)\n            self.set_code(IPOption.IPOPT_RR)\n            self.set_len(size)\n            self.set_ptr(4)\n\n        elif(opcode == IPOption.IPOPT_LSRR):\n            if not size:\n                size = 39\n            PacketBuffer.__init__(self, size)\n            self.set_code(IPOption.IPOPT_LSRR)\n            self.set_len(size)\n            self.set_ptr(4)\n\n        elif(opcode == IPOption.IPOPT_SSRR):\n            if not size:\n                size = 39\n            PacketBuffer.__init__(self, size)\n            self.set_code(IPOption.IPOPT_SSRR)\n            self.set_len(size)\n            self.set_ptr(4)\n\n        elif(opcode == IPOption.IPOPT_TS):\n            if not size:\n                size = 40\n            PacketBuffer.__init__(self, size)\n            self.set_code(IPOption.IPOPT_TS)\n            self.set_len(size)\n            self.set_ptr(5)\n            self.set_flags(0)\n        else:\n            if not size:\n                raise ImpactPacketException(\"Size required for this type\")\n            PacketBuffer.__init__(self,size)\n            self.set_code(opcode)\n            self.set_len(size)\n\n\n    def append_ip(self, ip):\n        op = self.get_code()\n        if not (op == IPOption.IPOPT_RR or op == IPOption.IPOPT_LSRR or op == IPOption.IPOPT_SSRR or op == IPOption.IPOPT_TS):\n            raise ImpactPacketException(\"append_ip() not support for option type %d\" % self.opt_type)\n\n        p = self.get_ptr()\n        if not p:\n            raise ImpactPacketException(\"append_ip() failed, option ptr uninitialized\")\n\n        if (p + 4) > self.get_len():\n            raise ImpactPacketException(\"append_ip() would overflow option\")\n\n        self.set_ip_address(p - 1, ip)\n        p += 4\n        self.set_ptr(p)\n\n\n    def set_code(self, value):\n        self.set_byte(0, value)\n\n    def get_code(self):\n        return self.get_byte(0)\n\n\n    def set_flags(self, flags):\n        if not (self.get_code() == IPOption.IPOPT_TS):\n            raise ImpactPacketException(\"Operation only supported on Timestamp option\")\n        self.set_byte(3, flags)\n\n    def get_flags(self, flags):\n        if not (self.get_code() == IPOption.IPOPT_TS):\n            raise ImpactPacketException(\"Operation only supported on Timestamp option\")\n        return self.get_byte(3)\n\n\n    def set_len(self, len):\n        self.set_byte(1, len)\n\n\n    def set_ptr(self, ptr):\n        self.set_byte(2, ptr)\n\n    def get_ptr(self):\n        return self.get_byte(2)\n\n    def get_len(self):\n        return len(self.get_bytes())\n\n\n    def __str__(self):\n        map = {IPOption.IPOPT_EOL : \"End of List \",\n               IPOption.IPOPT_NOP : \"No Operation \",\n               IPOption.IPOPT_RR  : \"Record Route \",\n               IPOption.IPOPT_TS  : \"Timestamp \",\n               IPOption.IPOPT_LSRR : \"Loose Source Route \",\n               IPOption.IPOPT_SSRR : \"Strict Source Route \"}\n\n        tmp_str = \"\\tIP Option: \"\n        op = self.get_code()\n        if op in map:\n            tmp_str += map[op]\n        else:\n            tmp_str += \"Code: %d \" % op\n\n        if op == IPOption.IPOPT_RR or op == IPOption.IPOPT_LSRR or op ==IPOption.IPOPT_SSRR:\n            tmp_str += self.print_addresses()\n\n\n        return tmp_str\n\n\n    def print_addresses(self):\n        p = 3\n        tmp_str = \"[\"\n        if self.get_len() >= 7: # at least one complete IP address\n            while 1:\n                if p + 1 == self.get_ptr():\n                    tmp_str += \"#\"\n                tmp_str += self.get_ip_address(p)\n                p += 4\n                if p >= self.get_len():\n                    break\n                else:\n                    tmp_str += \", \"\n        tmp_str += \"] \"\n        if self.get_ptr() % 4: # ptr field should be a multiple of 4\n            tmp_str += \"nonsense ptr field: %d \" % self.get_ptr()\n        return tmp_str",
  "class UDP(Header):\n    protocol = 17\n    def __init__(self, aBuffer = None):\n        Header.__init__(self, 8)\n        if(aBuffer):\n            self.load_header(aBuffer)\n\n    def get_uh_sport(self):\n        return self.get_word(0)\n    def set_uh_sport(self, value):\n        self.set_word(0, value)\n\n    def get_uh_dport(self):\n        return self.get_word(2)\n    def set_uh_dport(self, value):\n        self.set_word(2, value)\n\n    def get_uh_ulen(self):\n        return self.get_word(4)\n\n    def set_uh_ulen(self, value):\n        self.set_word(4, value)\n\n    def get_uh_sum(self):\n        return self.get_word(6)\n\n    def set_uh_sum(self, value):\n        self.set_word(6, value)\n        self.auto_checksum = 0\n\n    def calculate_checksum(self):\n        if self.auto_checksum and (not self.get_uh_sum()):\n            # if there isn't a parent to grab a pseudo-header from we'll assume the user knows what they're doing\n            # and won't meddle with the checksum or throw an exception\n            if not self.parent():\n                return\n\n            buffer = self.parent().get_pseudo_header()\n\n            buffer += self.get_bytes()\n            data = self.get_data_as_string()\n            if(data):\n                array_frombytes(buffer, data)\n            self.set_uh_sum(self.compute_checksum(buffer))\n\n    def get_header_size(self):\n        return 8\n\n    def __str__(self):\n        tmp_str = 'UDP %d -> %d' % (self.get_uh_sport(), self.get_uh_dport())\n        if self.child():\n            tmp_str += '\\n' + str(self.child())\n        return tmp_str\n\n    def get_packet(self):\n        # set total length\n        if(self.get_uh_ulen() == 0):\n            self.set_uh_ulen(self.get_size())\n        return Header.get_packet(self)",
  "class TCP(Header):\n    protocol = 6\n    TCP_FLAGS_MASK = 0x00FF # lowest 16 bits are the flags\n    def __init__(self, aBuffer = None):\n        Header.__init__(self, 20)\n        self.set_th_off(5)\n        self.__option_list = []\n        if aBuffer:\n            self.load_header(aBuffer)\n\n    def add_option(self, option):\n        self.__option_list.append(option)\n\n        sum = 0\n        for op in self.__option_list:\n            sum += op.get_size()\n\n        if sum > 40:\n            raise ImpactPacketException(\"Cannot add TCP option, would overflow option space\")\n\n    def get_options(self):\n        return self.__option_list\n\n    def swapSourceAndDestination(self):\n        oldSource = self.get_th_sport()\n        self.set_th_sport(self.get_th_dport())\n        self.set_th_dport(oldSource)\n\n    #\n    # Header field accessors\n    #\n\n    def set_th_sport(self, aValue):\n        self.set_word(0, aValue)\n\n    def get_th_sport(self):\n        return self.get_word(0)\n\n    def get_th_dport(self):\n        return self.get_word(2)\n\n    def set_th_dport(self, aValue):\n        self.set_word(2, aValue)\n\n    def get_th_seq(self):\n        return self.get_long(4)\n\n    def set_th_seq(self, aValue):\n        self.set_long(4, aValue)\n\n    def get_th_ack(self):\n        return self.get_long(8)\n\n    def set_th_ack(self, aValue):\n        self.set_long(8, aValue)\n\n    def get_th_flags(self):\n        return self.get_word(12) & self.TCP_FLAGS_MASK\n    \n    def set_th_flags(self, aValue):\n        masked = self.get_word(12) & (~self.TCP_FLAGS_MASK)\n        nb = masked | (aValue & self.TCP_FLAGS_MASK)\n        return self.set_word(12, nb, \">\")\n     \n    def get_th_win(self):\n        return self.get_word(14)\n\n    def set_th_win(self, aValue):\n        self.set_word(14, aValue)\n\n    def set_th_sum(self, aValue):\n        self.set_word(16, aValue)\n        self.auto_checksum = 0\n\n    def get_th_sum(self):\n        return self.get_word(16)\n\n    def get_th_urp(self):\n        return self.get_word(18)\n\n    def set_th_urp(self, aValue):\n        return self.set_word(18, aValue)\n\n    # Flag accessors\n\n    def get_th_reserved(self):\n        tmp_value = self.get_byte(12) & 0x0f\n        return tmp_value\n\n\n    def get_th_off(self):\n        tmp_value = self.get_byte(12) >> 4\n        return tmp_value\n\n    def set_th_off(self, aValue):\n        mask = 0xF0\n        masked = self.get_byte(12) & (~mask)\n        nb = masked | ( (aValue << 4) & mask)\n        return self.set_byte(12, nb)\n\n    def get_CWR(self):\n        return self.get_flag(128)\n    def set_CWR(self):\n        return self.set_flags(128)\n    def reset_CWR(self):\n        return self.reset_flags(128)\n\n    def get_ECE(self):\n        return self.get_flag(64)\n    def set_ECE(self):\n        return self.set_flags(64)\n    def reset_ECE(self):\n        return self.reset_flags(64)\n\n    def get_URG(self):\n        return self.get_flag(32)\n    def set_URG(self):\n        return self.set_flags(32)\n    def reset_URG(self):\n        return self.reset_flags(32)\n\n    def get_ACK(self):\n        return self.get_flag(16)\n    def set_ACK(self):\n        return self.set_flags(16)\n    def reset_ACK(self):\n        return self.reset_flags(16)\n\n    def get_PSH(self):\n        return self.get_flag(8)\n    def set_PSH(self):\n        return self.set_flags(8)\n    def reset_PSH(self):\n        return self.reset_flags(8)\n\n    def get_RST(self):\n        return self.get_flag(4)\n    def set_RST(self):\n        return self.set_flags(4)\n    def reset_RST(self):\n        return self.reset_flags(4)\n\n    def get_SYN(self):\n        return self.get_flag(2)\n    def set_SYN(self):\n        return self.set_flags(2)\n    def reset_SYN(self):\n        return self.reset_flags(2)\n\n    def get_FIN(self):\n        return self.get_flag(1)\n    def set_FIN(self):\n        return self.set_flags(1)\n    def reset_FIN(self):\n        return self.reset_flags(1)\n\n    # Overridden Methods\n\n    def get_header_size(self):\n        return 20 + len(self.get_padded_options())\n\n    def calculate_checksum(self):\n        if not self.auto_checksum or not self.parent():\n            return\n\n        self.set_th_sum(0)\n        buffer = self.parent().get_pseudo_header()\n        buffer += self.get_bytes()\n        buffer += self.get_padded_options()\n\n        data = self.get_data_as_string()\n        if(data):\n            array_frombytes(buffer, data)\n\n        res = self.compute_checksum(buffer)\n\n        self.set_th_sum(self.compute_checksum(buffer))\n\n    def get_packet(self):\n        \"Returns entire packet including child data as a string.  This is the function used to extract the final packet\"\n\n        # only change th_off value if options are present\n        if len(self.__option_list):\n            self.set_th_off(self.get_header_size() // 4)\n\n        self.calculate_checksum()\n\n        bytes = self.get_bytes() + self.get_padded_options()\n        data = self.get_data_as_string()\n\n        if data:\n            return array_tobytes(bytes) + data\n        else:\n            return array_tobytes(bytes)\n\n    def load_header(self, aBuffer):\n        self.set_bytes_from_string(aBuffer[:20])\n        opt_left = (self.get_th_off() - 5) * 4\n        opt_bytes = array.array('B', aBuffer[20:(20 + opt_left)])\n        if len(opt_bytes) != opt_left:\n            raise ImpactPacketException(\"Cannot load options from truncated packet\")\n\n        while opt_left:\n            op_kind = opt_bytes[0]\n            if op_kind == TCPOption.TCPOPT_EOL or op_kind == TCPOption.TCPOPT_NOP:\n                new_option = TCPOption(op_kind)\n                op_len = 1\n            else:\n                op_len = opt_bytes[1]\n                if op_len > len(opt_bytes):\n                    raise ImpactPacketException(\"TCP Option length is too high\")\n                if op_len < 2:\n                    raise ImpactPacketException(\"TCP Option length is too low\")\n\n                new_option = TCPOption(op_kind)\n                new_option.set_bytes(opt_bytes[:op_len])\n\n            opt_bytes = opt_bytes[op_len:]\n            opt_left -= op_len\n            self.add_option(new_option)\n            if op_kind == TCPOption.TCPOPT_EOL:\n                break\n\n    #\n    # Private\n    #\n\n    def get_flag(self, bit):\n        if self.get_th_flags() & bit:\n            return 1\n        else:\n            return 0\n\n    def reset_flags(self, aValue):\n        tmp_value = self.get_th_flags() & (~aValue)\n        return self.set_th_flags(tmp_value)\n\n    def set_flags(self, aValue):\n        tmp_value =  self.get_th_flags() | aValue\n        return self.set_th_flags(tmp_value)\n\n    def get_padded_options(self):\n        \"Return an array containing all options padded to a 4 byte boundary\"\n        op_buf = array.array('B')\n        for op in self.__option_list:\n            op_buf += op.get_bytes()\n        num_pad = (4 - (len(op_buf) % 4)) % 4\n        if num_pad:\n            array_frombytes(op_buf, b\"\\0\" * num_pad)\n        return op_buf\n\n    def __str__(self):\n        tmp_str = 'TCP '\n        if self.get_ECE():\n            tmp_str += 'ece '\n        if self.get_CWR():\n            tmp_str += 'cwr '\n        if self.get_ACK():\n            tmp_str += 'ack '\n        if self.get_FIN():\n            tmp_str += 'fin '\n        if self.get_PSH():\n            tmp_str += 'push '\n        if self.get_RST():\n            tmp_str += 'rst '\n        if self.get_SYN():\n            tmp_str += 'syn '\n        if self.get_URG():\n            tmp_str += 'urg '\n        tmp_str += '%d -> %d' % (self.get_th_sport(), self.get_th_dport())\n        for op in self.__option_list:\n            tmp_str += '\\n' + str(op)\n\n        if self.child():\n            tmp_str += '\\n' + str(self.child())\n        return tmp_str",
  "class TCPOption(PacketBuffer):\n    TCPOPT_EOL =             0\n    TCPOPT_NOP  =            1\n    TCPOPT_MAXSEG =          2\n    TCPOPT_WINDOW  =         3\n    TCPOPT_SACK_PERMITTED =  4\n    TCPOPT_SACK         =    5\n    TCPOPT_TIMESTAMP    =    8\n    TCPOPT_SIGNATURE    =    19\n\n\n    def __init__(self, kind, data = None):\n\n        if kind == TCPOption.TCPOPT_EOL:\n            PacketBuffer.__init__(self, 1)\n            self.set_kind(TCPOption.TCPOPT_EOL)\n        elif kind == TCPOption.TCPOPT_NOP:\n            PacketBuffer.__init__(self, 1)\n            self.set_kind(TCPOption.TCPOPT_NOP)\n        elif kind == TCPOption.TCPOPT_MAXSEG:\n            PacketBuffer.__init__(self, 4)\n            self.set_kind(TCPOption.TCPOPT_MAXSEG)\n            self.set_len(4)\n            if data:\n                self.set_mss(data)\n            else:\n                self.set_mss(512)\n        elif kind == TCPOption.TCPOPT_WINDOW:\n            PacketBuffer.__init__(self, 3)\n            self.set_kind(TCPOption.TCPOPT_WINDOW)\n            self.set_len(3)\n            if data:\n                self.set_shift_cnt(data)\n            else:\n                self.set_shift_cnt(0)\n        elif kind == TCPOption.TCPOPT_TIMESTAMP:\n            PacketBuffer.__init__(self, 10)\n            self.set_kind(TCPOption.TCPOPT_TIMESTAMP)\n            self.set_len(10)\n            if data:\n                self.set_ts(data)\n            else:\n                self.set_ts(0)\n        elif kind == TCPOption.TCPOPT_SACK_PERMITTED:\n            PacketBuffer.__init__(self, 2)\n            self.set_kind(TCPOption.TCPOPT_SACK_PERMITTED)\n            self.set_len(2)                \n\n        elif kind == TCPOption.TCPOPT_SACK:\n            PacketBuffer.__init__(self, 2)\n            self.set_kind(TCPOption.TCPOPT_SACK)\n\n    def set_left_edge(self, aValue):\n        self.set_long (2, aValue)\n\n    def set_right_edge(self, aValue):\n        self.set_long (6, aValue)\n\n    def set_kind(self, kind):\n        self.set_byte(0, kind)\n\n\n    def get_kind(self):\n        return self.get_byte(0)\n\n\n    def set_len(self, len):\n        if self.get_size() < 2:\n            raise ImpactPacketException(\"Cannot set length field on an option having a size smaller than 2 bytes\")\n        self.set_byte(1, len)\n\n    def get_len(self):\n        if self.get_size() < 2:\n            raise ImpactPacketException(\"Cannot retrieve length field from an option having a size smaller than 2 bytes\")\n        return self.get_byte(1)\n\n    def get_size(self):\n        return len(self.get_bytes())\n\n\n    def set_mss(self, len):\n        if self.get_kind() != TCPOption.TCPOPT_MAXSEG:\n            raise ImpactPacketException(\"Can only set MSS on TCPOPT_MAXSEG option\")\n        self.set_word(2, len)\n\n    def get_mss(self):\n        if self.get_kind() != TCPOption.TCPOPT_MAXSEG:\n            raise ImpactPacketException(\"Can only retrieve MSS from TCPOPT_MAXSEG option\")\n        return self.get_word(2)\n\n    def set_shift_cnt(self, cnt):\n        if self.get_kind() != TCPOption.TCPOPT_WINDOW:\n            raise ImpactPacketException(\"Can only set Shift Count on TCPOPT_WINDOW option\")\n        self.set_byte(2, cnt)\n\n    def get_shift_cnt(self):\n        if self.get_kind() != TCPOption.TCPOPT_WINDOW:\n            raise ImpactPacketException(\"Can only retrieve Shift Count from TCPOPT_WINDOW option\")\n        return self.get_byte(2)\n\n    def get_ts(self):\n        if self.get_kind() != TCPOption.TCPOPT_TIMESTAMP:\n            raise ImpactPacketException(\"Can only retrieve timestamp from TCPOPT_TIMESTAMP option\")\n        return self.get_long(2)\n\n    def set_ts(self, ts):\n        if self.get_kind() != TCPOption.TCPOPT_TIMESTAMP:\n            raise ImpactPacketException(\"Can only set timestamp on TCPOPT_TIMESTAMP option\")\n        self.set_long(2, ts)\n\n    def get_ts_echo(self):\n        if self.get_kind() != TCPOption.TCPOPT_TIMESTAMP:\n            raise ImpactPacketException(\"Can only retrieve timestamp from TCPOPT_TIMESTAMP option\")\n        return self.get_long(6)\n\n    def set_ts_echo(self, ts):\n        if self.get_kind() != TCPOption.TCPOPT_TIMESTAMP:\n            raise ImpactPacketException(\"Can only set timestamp on TCPOPT_TIMESTAMP option\")\n        self.set_long(6, ts)\n\n    def __str__(self):\n        map = { TCPOption.TCPOPT_EOL : \"End of List \",\n                TCPOption.TCPOPT_NOP : \"No Operation \",\n                TCPOption.TCPOPT_MAXSEG : \"Maximum Segment Size \",\n                TCPOption.TCPOPT_WINDOW : \"Window Scale \",\n                TCPOption.TCPOPT_TIMESTAMP : \"Timestamp \" }\n\n        tmp_str = \"\\tTCP Option: \"\n        op = self.get_kind()\n        if op in map:\n            tmp_str += map[op]\n        else:\n            tmp_str += \" kind: %d \" % op\n        if op == TCPOption.TCPOPT_MAXSEG:\n            tmp_str += \" MSS : %d \" % self.get_mss()\n        elif op == TCPOption.TCPOPT_WINDOW:\n            tmp_str += \" Shift Count: %d \" % self.get_shift_cnt()\n        elif op == TCPOption.TCPOPT_TIMESTAMP:\n            pass # TODO\n        return tmp_str",
  "class ICMP(Header):\n    protocol = 1\n    ICMP_ECHOREPLY              = 0\n    ICMP_UNREACH                = 3\n    ICMP_UNREACH_NET            = 0\n    ICMP_UNREACH_HOST           = 1\n    ICMP_UNREACH_PROTOCOL       = 2\n    ICMP_UNREACH_PORT           = 3\n    ICMP_UNREACH_NEEDFRAG       = 4\n    ICMP_UNREACH_SRCFAIL        = 5\n    ICMP_UNREACH_NET_UNKNOWN    = 6\n    ICMP_UNREACH_HOST_UNKNOWN   = 7\n    ICMP_UNREACH_ISOLATED       = 8\n    ICMP_UNREACH_NET_PROHIB     = 9\n    ICMP_UNREACH_HOST_PROHIB    = 10\n    ICMP_UNREACH_TOSNET         = 11\n    ICMP_UNREACH_TOSHOST        = 12\n    ICMP_UNREACH_FILTERPROHIB   = 13\n    ICMP_UNREACH_HOST_PRECEDENCE = 14\n    ICMP_UNREACH_PRECEDENCE_CUTOFF = 15\n    ICMP_SOURCEQUENCH               = 4\n    ICMP_REDIRECT                   = 5\n    ICMP_REDIRECT_NET           = 0\n    ICMP_REDIRECT_HOST          = 1\n    ICMP_REDIRECT_TOSNET        = 2\n    ICMP_REDIRECT_TOSHOST       = 3\n    ICMP_ALTHOSTADDR                = 6\n    ICMP_ECHO                       = 8\n    ICMP_ROUTERADVERT               = 9\n    ICMP_ROUTERSOLICIT              = 10\n    ICMP_TIMXCEED                   = 11\n    ICMP_TIMXCEED_INTRANS       = 0\n    ICMP_TIMXCEED_REASS         = 1\n    ICMP_PARAMPROB                  = 12\n    ICMP_PARAMPROB_ERRATPTR     = 0\n    ICMP_PARAMPROB_OPTABSENT    = 1\n    ICMP_PARAMPROB_LENGTH       = 2\n    ICMP_TSTAMP                     = 13\n    ICMP_TSTAMPREPLY                = 14\n    ICMP_IREQ                       = 15\n    ICMP_IREQREPLY                  = 16\n    ICMP_MASKREQ                    = 17\n    ICMP_MASKREPLY                  = 18\n\n    def __init__(self, aBuffer = None):\n        Header.__init__(self, 8)\n        if aBuffer:\n            self.load_header(aBuffer)\n\n    def get_header_size(self):\n        anamolies = { ICMP.ICMP_TSTAMP : 20, ICMP.ICMP_TSTAMPREPLY : 20, ICMP.ICMP_MASKREQ : 12, ICMP.ICMP_MASKREPLY : 12 }\n        if self.get_icmp_type() in anamolies:\n            return anamolies[self.get_icmp_type()]\n        else:\n            return 8\n\n    def get_icmp_type(self):\n        return self.get_byte(0)\n\n    def set_icmp_type(self, aValue):\n        self.set_byte(0, aValue)\n\n    def get_icmp_code(self):\n        return self.get_byte(1)\n\n    def set_icmp_code(self, aValue):\n        self.set_byte(1, aValue)\n\n    def get_icmp_cksum(self):\n        return self.get_word(2)\n\n    def set_icmp_cksum(self, aValue):\n        self.set_word(2, aValue)\n        self.auto_checksum = 0\n\n    def get_icmp_gwaddr(self):\n        return self.get_ip_address(4)\n\n    def set_icmp_gwaddr(self, ip):\n        self.set_ip_address(4, ip)\n\n    def get_icmp_id(self):\n        return self.get_word(4)\n\n    def set_icmp_id(self, aValue):\n        self.set_word(4, aValue)\n\n    def get_icmp_seq(self):\n        return self.get_word(6)\n\n    def set_icmp_seq(self, aValue):\n        self.set_word(6, aValue)\n\n    def get_icmp_void(self):\n        return self.get_long(4)\n\n    def set_icmp_void(self, aValue):\n        self.set_long(4, aValue)\n\n\n    def get_icmp_nextmtu(self):\n        return self.get_word(6)\n\n    def set_icmp_nextmtu(self, aValue):\n        self.set_word(6, aValue)\n\n    def get_icmp_num_addrs(self):\n        return self.get_byte(4)\n\n    def set_icmp_num_addrs(self, aValue):\n        self.set_byte(4, aValue)\n\n    def get_icmp_wpa(self):\n        return self.get_byte(5)\n\n    def set_icmp_wpa(self, aValue):\n        self.set_byte(5, aValue)\n\n    def get_icmp_lifetime(self):\n        return self.get_word(6)\n\n    def set_icmp_lifetime(self, aValue):\n        self.set_word(6, aValue)\n\n    def get_icmp_otime(self):\n        return self.get_long(8)\n\n    def set_icmp_otime(self, aValue):\n        self.set_long(8, aValue)\n\n    def get_icmp_rtime(self):\n        return self.get_long(12)\n\n    def set_icmp_rtime(self, aValue):\n        self.set_long(12, aValue)\n\n    def get_icmp_ttime(self):\n        return self.get_long(16)\n\n    def set_icmp_ttime(self, aValue):\n        self.set_long(16, aValue)\n\n    def get_icmp_mask(self):\n        return self.get_ip_address(8)\n\n    def set_icmp_mask(self, mask):\n        self.set_ip_address(8, mask)\n\n\n    def calculate_checksum(self):\n        if self.auto_checksum and (not self.get_icmp_cksum()):\n            buffer = self.get_buffer_as_string()\n            data = self.get_data_as_string()\n            if data:\n                buffer += data\n\n            tmp_array = array.array('B', buffer)\n            self.set_icmp_cksum(self.compute_checksum(tmp_array))\n\n    def get_type_name(self, aType):\n        tmp_type = {0:'ECHOREPLY', 3:'UNREACH', 4:'SOURCEQUENCH',5:'REDIRECT', 6:'ALTHOSTADDR', 8:'ECHO', 9:'ROUTERADVERT', 10:'ROUTERSOLICIT', 11:'TIMXCEED', 12:'PARAMPROB', 13:'TSTAMP', 14:'TSTAMPREPLY', 15:'IREQ', 16:'IREQREPLY', 17:'MASKREQ', 18:'MASKREPLY', 30:'TRACEROUTE', 31:'DATACONVERR', 32:'MOBILE REDIRECT', 33:'IPV6 WHEREAREYOU', 34:'IPV6 IAMHERE', 35:'MOBILE REGREQUEST', 36:'MOBILE REGREPLY', 39:'SKIP', 40:'PHOTURIS'}\n        answer = tmp_type.get(aType, 'UNKNOWN')\n        return answer\n\n    def get_code_name(self, aType, aCode):\n        tmp_code = {3:['UNREACH NET', 'UNREACH HOST', 'UNREACH PROTOCOL', 'UNREACH PORT', 'UNREACH NEEDFRAG', 'UNREACH SRCFAIL', 'UNREACH NET UNKNOWN', 'UNREACH HOST UNKNOWN', 'UNREACH ISOLATED', 'UNREACH NET PROHIB', 'UNREACH HOST PROHIB', 'UNREACH TOSNET', 'UNREACH TOSHOST', 'UNREACH FILTER PROHIB', 'UNREACH HOST PRECEDENCE', 'UNREACH PRECEDENCE CUTOFF', 'UNKNOWN ICMP UNREACH']}\n        tmp_code[5] = ['REDIRECT NET', 'REDIRECT HOST', 'REDIRECT TOSNET', 'REDIRECT TOSHOST']\n        tmp_code[9] = ['ROUTERADVERT NORMAL', None, None, None, None, None, None, None, None, None, None, None, None, None, None, None,'ROUTERADVERT NOROUTE COMMON']\n        tmp_code[11] = ['TIMXCEED INTRANS ', 'TIMXCEED REASS']\n        tmp_code[12] = ['PARAMPROB ERRATPTR ', 'PARAMPROB OPTABSENT', 'PARAMPROB LENGTH']\n        tmp_code[40] = [None, 'PHOTURIS UNKNOWN INDEX', 'PHOTURIS AUTH FAILED', 'PHOTURIS DECRYPT FAILED']\n        if aType in tmp_code:\n            tmp_list = tmp_code[aType]\n            if ((aCode + 1) > len(tmp_list)) or (not tmp_list[aCode]):\n                return 'UNKNOWN'\n            else:\n                return tmp_list[aCode]\n        else:\n            return 'UNKNOWN'\n\n    def __str__(self):\n        tmp_type = self.get_icmp_type()\n        tmp_code = self.get_icmp_code()\n        tmp_str = 'ICMP type: ' + self.get_type_name(tmp_type)\n        tmp_str+= ' code: ' + self.get_code_name(tmp_type, tmp_code)\n        if self.child():\n            tmp_str += '\\n' + str( self.child() )\n        return tmp_str\n\n    def isDestinationUnreachable(self):\n        return self.get_icmp_type() == 3\n\n    def isError(self):\n        return not self.isQuery()\n\n    def isHostUnreachable(self):\n        return self.isDestinationUnreachable() and (self.get_icmp_code() == 1)\n\n    def isNetUnreachable(self):\n        return self.isDestinationUnreachable() and (self.get_icmp_code() == 0)\n\n    def isPortUnreachable(self):\n        return self.isDestinationUnreachable() and (self.get_icmp_code() == 3)\n\n    def isProtocolUnreachable(self):\n        return self.isDestinationUnreachable() and (self.get_icmp_code() == 2)\n\n    def isQuery(self):\n        tmp_dict = {8:'',  9:'',  10:'', 13:'', 14:'', 15:'', 16:'', 17:'', 18:''}\n        return self.get_icmp_type() in tmp_dict",
  "class IGMP(Header):\n    protocol = 2\n    def __init__(self, aBuffer = None):\n        Header.__init__(self, 8)\n        if aBuffer:\n            self.load_header(aBuffer)\n\n    def get_igmp_type(self):\n        return self.get_byte(0)\n\n    def set_igmp_type(self, aValue):\n        self.set_byte(0, aValue)\n\n    def get_igmp_code(self):\n        return self.get_byte(1)\n\n    def set_igmp_code(self, aValue):\n        self.set_byte(1, aValue)\n\n    def get_igmp_cksum(self):\n        return self.get_word(2)\n\n    def set_igmp_cksum(self, aValue):\n        self.set_word(2, aValue)\n\n    def get_igmp_group(self):\n        return self.get_long(4)\n\n    def set_igmp_group(self, aValue):\n        self.set_long(4, aValue)\n\n    def get_header_size(self):\n        return 8\n\n    def get_type_name(self, aType):\n        tmp_dict = {0x11:'HOST MEMBERSHIP QUERY ', 0x12:'v1 HOST MEMBERSHIP REPORT ', 0x13:'IGMP DVMRP ', 0x14:' PIM ', 0x16:'v2 HOST MEMBERSHIP REPORT ', 0x17:'HOST LEAVE MESSAGE ', 0x1e:'MTRACE REPLY ', 0X1f:'MTRACE QUERY '}\n        answer = tmp_dict.get(aType, 'UNKNOWN TYPE OR VERSION ')\n        return answer\n\n    def calculate_checksum(self):\n        if self.auto_checksum and (not self.get_igmp_cksum()):\n            self.set_igmp_cksum(self.compute_checksum(self.get_bytes()))\n\n    def __str__(self):\n        tmp_str = 'IGMP: ' + self.get_type_name(self.get_igmp_type())\n        tmp_str += 'Group: ' +  socket.inet_ntoa(struct.pack('!L',self.get_igmp_group()))\n        if self.child():\n            tmp_str += '\\n' + str(self.child())\n        return tmp_str",
  "class ARP(Header):\n    ethertype = 0x806\n    def __init__(self, aBuffer = None):\n        Header.__init__(self, 7)\n        if aBuffer:\n            self.load_header(aBuffer)\n\n    def get_ar_hrd(self):\n        return self.get_word(0)\n\n    def set_ar_hrd(self, aValue):\n        self.set_word(0, aValue)\n\n    def get_ar_pro(self):\n        return self.get_word(2)\n\n    def set_ar_pro(self, aValue):\n        self.set_word(2, aValue)\n\n    def get_ar_hln(self):\n        return self.get_byte(4)\n\n    def set_ar_hln(self, aValue):\n        self.set_byte(4, aValue)\n\n    def get_ar_pln(self):\n        return self.get_byte(5)\n\n    def set_ar_pln(self, aValue):\n        self.set_byte(5, aValue)\n\n    def get_ar_op(self):\n        return self.get_word(6)\n\n    def set_ar_op(self, aValue):\n        self.set_word(6, aValue)\n\n    def get_ar_sha(self):\n        tmp_size = self.get_ar_hln()\n        return self.get_bytes().tolist()[8: 8 + tmp_size]\n\n    def set_ar_sha(self, aValue):\n        for i in range(0, self.get_ar_hln()):\n            self.set_byte(i + 8, aValue[i])\n\n    def get_ar_spa(self):\n        tmp_size = self.get_ar_pln()\n        return self.get_bytes().tolist()[8 + self.get_ar_hln(): 8 + self.get_ar_hln() + tmp_size]\n\n    def set_ar_spa(self, aValue):\n        for i in range(0, self.get_ar_pln()):\n            self.set_byte(i + 8 + self.get_ar_hln(), aValue[i])\n\n    def get_ar_tha(self):\n        tmp_size = self.get_ar_hln()\n        tmp_from = 8 + self.get_ar_hln() + self.get_ar_pln()\n        return self.get_bytes().tolist()[tmp_from: tmp_from + tmp_size]\n\n    def set_ar_tha(self, aValue):\n        tmp_from = 8 + self.get_ar_hln() + self.get_ar_pln()\n        for i in range(0, self.get_ar_hln()):\n            self.set_byte(i + tmp_from, aValue[i])\n\n    def get_ar_tpa(self):\n        tmp_size = self.get_ar_pln()\n        tmp_from = 8 + ( 2 * self.get_ar_hln()) + self.get_ar_pln()\n        return self.get_bytes().tolist()[tmp_from: tmp_from + tmp_size]\n\n    def set_ar_tpa(self, aValue):\n        tmp_from = 8 + (2 * self.get_ar_hln()) + self.get_ar_pln()\n        for i in range(0, self.get_ar_pln()):\n            self.set_byte(i + tmp_from, aValue[i])\n\n    def get_header_size(self):\n        return 8 + (2 * self.get_ar_hln()) + (2 * self.get_ar_pln())\n\n    def get_op_name(self, ar_op):\n        tmp_dict = {1:'REQUEST', 2:'REPLY', 3:'REVREQUEST', 4:'REVREPLY', 8:'INVREQUEST', 9:'INVREPLY'}\n        answer = tmp_dict.get(ar_op, 'UNKNOWN')\n        return answer\n\n    def get_hrd_name(self, ar_hrd):\n        tmp_dict = { 1:'ARPHRD ETHER', 6:'ARPHRD IEEE802', 15:'ARPHRD FRELAY'}\n        answer = tmp_dict.get(ar_hrd, 'UNKNOWN')\n        return answer\n\n\n    def as_hrd(self, anArray):\n        if not anArray:\n            return ''\n        tmp_str = '%x' % anArray[0]\n        for i in range(1, len(anArray)):\n            tmp_str += ':%x' % anArray[i]\n        return tmp_str\n\n    def as_pro(self, anArray):\n        if not anArray:\n            return ''\n        tmp_str = '%d' % anArray[0]\n        for i in range(1, len(anArray)):\n            tmp_str += '.%d' % anArray[i]\n        return tmp_str\n\n    def __str__(self):\n        tmp_op = self.get_ar_op()\n        tmp_str = 'ARP format: ' + self.get_hrd_name(self.get_ar_hrd()) + ' '\n        tmp_str += 'opcode: ' + self.get_op_name(tmp_op)\n        tmp_str += '\\n' + self.as_hrd(self.get_ar_sha()) + ' -> '\n        tmp_str += self.as_hrd(self.get_ar_tha())\n        tmp_str += '\\n' + self.as_pro(self.get_ar_spa()) + ' -> '\n        tmp_str += self.as_pro(self.get_ar_tpa())\n        if self.child():\n            tmp_str += '\\n' + str(self.child())\n        return tmp_str",
  "def example(): #To execute an example, remove this line\n    a = Ethernet()\n    b = ARP()\n    c = Data('Hola loco!!!')\n    b.set_ar_hln(6)\n    b.set_ar_pln(4)\n    #a.set_ip_dst('192.168.22.6')\n    #a.set_ip_src('1.1.1.2')\n    a.contains(b)\n    b.contains(c)\n    b.set_ar_op(2)\n    b.set_ar_hrd(1)\n    b.set_ar_spa((192, 168, 22, 6))\n    b.set_ar_tpa((192, 168, 66, 171))\n    a.set_ether_shost((0x0, 0xe0, 0x7d, 0x8a, 0xef, 0x3d))\n    a.set_ether_dhost((0x0, 0xc0, 0xdf, 0x6, 0x5, 0xe))\n    print(\"beto %s\" % a)",
  "def __init__(self, value):\n        self.value = value",
  "def __str__(self):\n        return repr(self.value)",
  "def __init__(self, length = None):\n        \"If 'length' is specified the buffer is created with an initial size\"\n        if length:\n            self.__bytes = array.array('B', b'\\0' * length)\n        else:\n            self.__bytes = array.array('B')",
  "def set_bytes_from_string(self, data):\n        \"Sets the value of the packet buffer from the string 'data'\"\n        self.__bytes = array.array('B', data)",
  "def get_buffer_as_string(self):\n        \"Returns the packet buffer as a string object\"\n        return array_tobytes(self.__bytes)",
  "def get_bytes(self):\n        \"Returns the packet buffer as an array\"\n        return self.__bytes",
  "def set_bytes(self, bytes):\n        \"Set the packet buffer from an array\"\n        # Make a copy to be safe\n        self.__bytes = array.array('B', bytes.tolist())",
  "def set_byte(self, index, value):\n        \"Set byte at 'index' to 'value'\"\n        index = self.__validate_index(index, 1)\n        self.__bytes[index] = value",
  "def get_byte(self, index):\n        \"Return byte at 'index'\"\n        index = self.__validate_index(index, 1)\n        return self.__bytes[index]",
  "def set_word(self, index, value, order = '!'):\n        \"Set 2-byte word at 'index' to 'value'. See struct module's documentation to understand the meaning of 'order'.\"\n        index = self.__validate_index(index, 2)\n        ary = array.array(\"B\", struct.pack(order + 'H', value))\n        if -2 == index:\n            self.__bytes[index:] = ary\n        else:\n            self.__bytes[index:index+2] = ary",
  "def get_word(self, index, order = '!'):\n        \"Return 2-byte word at 'index'. See struct module's documentation to understand the meaning of 'order'.\"\n        index = self.__validate_index(index, 2)\n        if -2 == index:\n            bytes = self.__bytes[index:]\n        else:\n            bytes = self.__bytes[index:index+2]\n        (value,) = struct.unpack(order + 'H', array_tobytes(bytes))\n        return value",
  "def set_long(self, index, value, order = '!'):\n        \"Set 4-byte 'value' at 'index'. See struct module's documentation to understand the meaning of 'order'.\"\n        index = self.__validate_index(index, 4)\n        ary = array.array(\"B\", struct.pack(order + 'L', value))\n        if -4 == index:\n            self.__bytes[index:] = ary\n        else:\n            self.__bytes[index:index+4] = ary",
  "def get_long(self, index, order = '!'):\n        \"Return 4-byte value at 'index'. See struct module's documentation to understand the meaning of 'order'.\"\n        index = self.__validate_index(index, 4)\n        if -4 == index:\n            bytes = self.__bytes[index:]\n        else:\n            bytes = self.__bytes[index:index+4]\n        (value,) = struct.unpack(order + 'L', array_tobytes(bytes))\n        return value",
  "def set_long_long(self, index, value, order = '!'):\n        \"Set 8-byte 'value' at 'index'. See struct module's documentation to understand the meaning of 'order'.\"\n        index = self.__validate_index(index, 8)\n        ary = array.array(\"B\", struct.pack(order + 'Q', value))\n        if -8 == index:\n            self.__bytes[index:] = ary\n        else:\n            self.__bytes[index:index+8] = ary",
  "def get_long_long(self, index, order = '!'):\n        \"Return 8-byte value at 'index'. See struct module's documentation to understand the meaning of 'order'.\"\n        index = self.__validate_index(index, 8)\n        if -8 == index:\n            bytes = self.__bytes[index:]\n        else:\n            bytes = self.__bytes[index:index+8]\n        (value,) = struct.unpack(order + 'Q', array_tobytes(bytes))\n        return value",
  "def get_ip_address(self, index):\n        \"Return 4-byte value at 'index' as an IP string\"\n        index = self.__validate_index(index, 4)\n        if -4 == index:\n            bytes = self.__bytes[index:]\n        else:\n            bytes = self.__bytes[index:index+4]\n        return socket.inet_ntoa(array_tobytes(bytes))",
  "def set_ip_address(self, index, ip_string):\n        \"Set 4-byte value at 'index' from 'ip_string'\"\n        index = self.__validate_index(index, 4)\n        raw = socket.inet_aton(ip_string)\n        (b1,b2,b3,b4) = struct.unpack(\"BBBB\", raw)\n        self.set_byte(index, b1)\n        self.set_byte(index + 1, b2)\n        self.set_byte(index + 2, b3)\n        self.set_byte(index + 3, b4)",
  "def set_checksum_from_data(self, index, data):\n        \"Set 16-bit checksum at 'index' by calculating checksum of 'data'\"\n        self.set_word(index, self.compute_checksum(data))",
  "def compute_checksum(self, anArray):\n        \"Return the one's complement of the one's complement sum of all the 16-bit words in 'anArray'\"\n        nleft = len(anArray)\n        sum = 0\n        pos = 0\n        while nleft > 1:\n            sum = anArray[pos] * 256 + (anArray[pos + 1] + sum)\n            pos = pos + 2\n            nleft = nleft - 2\n        if nleft == 1:\n            sum = sum + anArray[pos] * 256\n        return self.normalize_checksum(sum)",
  "def normalize_checksum(self, aValue):\n        sum = aValue\n        sum = (sum >> 16) + (sum & 0xFFFF)\n        sum += (sum >> 16)\n        sum = (~sum & 0xFFFF)\n        return sum",
  "def __validate_index(self, index, size):\n        \"\"\"This method performs two tasks: to allocate enough space to\n        fit the elements at positions index through index+size, and to\n        adjust negative indexes to their absolute equivalent.\n        \"\"\"\n\n        orig_index = index\n\n        curlen = len(self.__bytes)\n        if index < 0:\n            index = curlen + index\n\n        diff = index + size - curlen\n        if diff > 0:\n            array_frombytes(self.__bytes, b'\\0' * diff)\n            if orig_index < 0:\n                orig_index -= diff\n\n        return orig_index",
  "def contains(self, aHeader):\n        \"Set 'aHeader' as the child of this protocol layer\"\n        self.__child = aHeader\n        aHeader.set_parent(self)",
  "def set_parent(self, my_parent):\n        \"Set the header 'my_parent' as the parent of this protocol layer\"\n        self.__parent = my_parent",
  "def child(self):\n        \"Return the child of this protocol layer\"\n        return self.__child",
  "def parent(self):\n        \"Return the parent of this protocol layer\"\n        return self.__parent",
  "def unlink_child(self):\n        \"Break the hierarchy parent/child child/parent\"\n        if self.__child:\n            self.__child.set_parent(None)\n            self.__child = None",
  "def __init__(self, header_size, tail_size):\n        self.__HEADER_SIZE = header_size\n        self.__TAIL_SIZE = tail_size\n        self.__header=PacketBuffer(self.__HEADER_SIZE)\n        self.__body=PacketBuffer()\n        self.__tail=PacketBuffer(self.__TAIL_SIZE)",
  "def __update_body_from_child(self):\n        # Update child raw packet in my body\n        if self.child():\n            body=self.child().get_packet()\n            self.__BODY_SIZE=len(body)\n            self.__body.set_bytes_from_string(body)",
  "def __get_header(self):\n        return self.__header",
  "def __get_body(self):\n        self.__update_body_from_child()\n        return self.__body",
  "def __get_tail(self):\n        return self.__tail",
  "def get_header_size(self):\n        \"Return frame header size\"\n        return self.__HEADER_SIZE",
  "def get_tail_size(self):\n        \"Return frame tail size\"\n        return self.__TAIL_SIZE",
  "def get_body_size(self):\n        \"Return frame body size\"\n        self.__update_body_from_child()\n        return self.__BODY_SIZE",
  "def get_size(self):\n        \"Return frame total size\"\n        return self.get_header_size()+self.get_body_size()+self.get_tail_size()",
  "def load_header(self, aBuffer):\n        self.__HEADER_SIZE=len(aBuffer)\n        self.__header.set_bytes_from_string(aBuffer)",
  "def load_body(self, aBuffer):\n        \"Load the packet body from string. \"\\\n        \"WARNING: Using this function will break the hierarchy of preceding protocol layer\"\n        self.unlink_child()\n        self.__BODY_SIZE=len(aBuffer)\n        self.__body.set_bytes_from_string(aBuffer)",
  "def load_tail(self, aBuffer):\n        self.__TAIL_SIZE=len(aBuffer)\n        self.__tail.set_bytes_from_string(aBuffer)",
  "def __extract_header(self, aBuffer):\n        self.load_header(aBuffer[:self.__HEADER_SIZE])",
  "def __extract_body(self, aBuffer):\n        if self.__TAIL_SIZE<=0:\n            end=None\n        else:\n            end=-self.__TAIL_SIZE\n        self.__BODY_SIZE=len(aBuffer[self.__HEADER_SIZE:end])\n        self.__body.set_bytes_from_string(aBuffer[self.__HEADER_SIZE:end])",
  "def __extract_tail(self, aBuffer):\n        if self.__TAIL_SIZE<=0:\n            # leave the array empty\n            return\n        else:\n            start=-self.__TAIL_SIZE\n        self.__tail.set_bytes_from_string(aBuffer[start:])",
  "def load_packet(self, aBuffer):\n        \"Load the whole packet from a string\" \\\n        \"WARNING: Using this function will break the hierarchy of preceding protocol layer\"\n        self.unlink_child()\n        \n        self.__extract_header(aBuffer)\n        self.__extract_body(aBuffer)\n        self.__extract_tail(aBuffer)",
  "def get_header_as_string(self):\n        return self.__header.get_buffer_as_string()",
  "def get_body_as_string(self):\n        self.__update_body_from_child()\n        return self.__body.get_buffer_as_string()",
  "def get_tail_as_string(self):\n        return self.__tail.get_buffer_as_string()",
  "def get_packet(self):\n        self.__update_body_from_child()\n        \n        ret = b''\n        \n        header = self.get_header_as_string()\n        if header:\n            ret += header\n\n        body = self.get_body_as_string()\n        if body:\n            ret += body\n        \n        tail = self.get_tail_as_string()    \n        if tail:\n            ret += tail\n            \n        return ret",
  "def __init__(self, length = None):\n        PacketBuffer.__init__(self, length)\n        self.auto_checksum = 1",
  "def get_data_as_string(self):\n        \"Returns all data from children of this header as string\"\n\n        if self.child():\n            return self.child().get_packet()\n        else:\n            return None",
  "def get_packet(self):\n        \"\"\"Returns the raw representation of this packet and its\n        children as a string. The output from this method is a packet\n        ready to be transmitted over the wire.\n        \"\"\"\n        self.calculate_checksum()\n\n        data = self.get_data_as_string()\n        if data:\n            return self.get_buffer_as_string() + data\n        else:\n            return self.get_buffer_as_string()",
  "def get_size(self):\n        \"Return the size of this header and all of it's children\"\n        tmp_value = self.get_header_size()\n        if self.child():\n            tmp_value = tmp_value + self.child().get_size()\n        return tmp_value",
  "def calculate_checksum(self):\n        \"Calculate and set the checksum for this header\"\n        pass",
  "def get_pseudo_header(self):\n        \"Pseudo headers can be used to limit over what content will the checksums be calculated.\"\n        # default implementation returns empty array\n        return array.array('B')",
  "def load_header(self, aBuffer):\n        \"Properly set the state of this instance to reflect that of the raw packet passed as argument.\"\n        self.set_bytes_from_string(aBuffer)\n        hdr_len = self.get_header_size()\n        if(len(aBuffer) < hdr_len):         #we must do something like this\n            diff = hdr_len - len(aBuffer)\n            for i in range(0, diff):\n                aBuffer += '\\x00'\n        self.set_bytes_from_string(aBuffer[:hdr_len])",
  "def get_header_size(self):\n        \"Return the size of this header, that is, not counting neither the size of the children nor of the parents.\"\n        raise RuntimeError(\"Method %s.get_header_size must be overridden.\" % self.__class__)",
  "def list_as_hex(self, aList):\n        if len(aList):\n            ltmp = []\n            line = []\n            count = 0\n            for byte in aList:\n                if not (count % 2):\n                    if (count % 16):\n                        ltmp.append(' ')\n                    else:\n                        ltmp.append(' '*4)\n                        ltmp.append(''.join(line))\n                        ltmp.append('\\n')\n                        line = []\n                if chr(byte) in Header.packet_printable:\n                    line.append(chr(byte))\n                else:\n                    line.append('.')\n                ltmp.append('%.2x' % byte)\n                count += 1\n            if (count%16):\n                left = 16 - (count%16)\n                ltmp.append(' ' * (4+(left // 2) + (left*2)))\n                ltmp.append(''.join(line))\n                ltmp.append('\\n')\n            return ltmp\n        else:\n            return []",
  "def __str__(self):\n        ltmp = self.list_as_hex(self.get_bytes().tolist())\n\n        if self.child():\n            ltmp.append(['\\n', str(self.child())])\n\n        if len(ltmp)>0:\n            return ''.join(ltmp)\n        else:\n            return ''",
  "def __init__(self, aBuffer = None):\n        Header.__init__(self)\n        if aBuffer:\n            self.set_data(aBuffer)",
  "def set_data(self, data):\n        self.set_bytes_from_string(data)",
  "def get_size(self):\n        return len(self.get_bytes())",
  "def __init__(self, value=0x81000000):\n        PacketBuffer.__init__(self, 4)\n        self.set_long(0, value)",
  "def get_tpid(self):\n        \"\"\"Returns Tag Protocol Identifier\"\"\"\n        return self.get_word(0)",
  "def set_tpid(self, value):\n        \"\"\"Sets Tag Protocol Identifier\"\"\"\n        return self.set_word(0, value)",
  "def get_pcp(self):\n        \"\"\"Returns Priority Code Point\"\"\"\n        return (self.get_byte(2) & 0xE0) >> 5",
  "def set_pcp(self, value):\n        \"\"\"Sets Priority Code Point\"\"\"\n        orig_value = self.get_byte(2)\n        self.set_byte(2, (orig_value & 0x1F) | ((value & 0x07) << 5))",
  "def get_dei(self):\n        \"\"\"Returns Drop Eligible Indicator\"\"\"\n        return (self.get_byte(2) & 0x10) >> 4",
  "def set_dei(self, value):\n        \"\"\"Sets Drop Eligible Indicator\"\"\"\n        orig_value = self.get_byte(2)\n        self.set_byte(2, orig_value | 0x10 if value else orig_value & 0xEF)",
  "def get_vid(self):\n        \"\"\"Returns VLAN Identifier\"\"\"\n        return self.get_word(2) & 0x0FFF",
  "def set_vid(self, value):\n        \"\"\"Sets VLAN Identifier\"\"\"\n        orig_value = self.get_word(2)\n        self.set_word(2, (orig_value & 0xF000) | (value & 0x0FFF))",
  "def __str__(self):\n        priorities = (\n            'Best Effort',\n            'Background',\n            'Excellent Effort',\n            'Critical Applications',\n            'Video, < 100 ms latency and jitter',\n            'Voice, < 10 ms latency and jitter',\n            'Internetwork Control',\n            'Network Control')\n\n        pcp = self.get_pcp()\n        return '\\n'.join((\n            '802.1Q header: 0x{0:08X}'.format(self.get_long(0)),\n            'Priority Code Point: {0} ({1})'.format(pcp, priorities[pcp]),\n            'Drop Eligible Indicator: {0}'.format(self.get_dei()),\n            'VLAN Identifier: {0}'.format(self.get_vid())))",
  "def __init__(self, aBuffer = None):\n        Header.__init__(self, 14)\n        self.tag_cnt = 0\n        if(aBuffer):\n            self.load_header(aBuffer)",
  "def set_ether_type(self, aValue):\n        \"Set ethernet data type field to 'aValue'\"\n        self.set_word(12 + 4*self.tag_cnt, aValue)",
  "def get_ether_type(self):\n        \"Return ethernet data type field\"\n        return self.get_word(12 + 4*self.tag_cnt)",
  "def get_tag(self, index):\n        \"\"\"Returns an EthernetTag initialized from index-th VLAN tag.\n           The tags are numbered from 0 to self.tag_cnt-1 as they appear in the frame.\n           It is possible to use negative indexes as well.\"\"\"\n        index = self.__validate_tag_index(index)\n        return EthernetTag(self.get_long(12+4*index))",
  "def set_tag(self, index, tag):\n        \"\"\"Sets the index-th VLAN tag to contents of an EthernetTag object.\n           The tags are numbered from 0 to self.tag_cnt-1 as they appear in the frame.\n           It is possible to use negative indexes as well.\"\"\"\n        index = self.__validate_tag_index(index)\n        pos = 12 + 4*index\n        for i,val in enumerate(tag.get_bytes()):\n            self.set_byte(pos+i, val)",
  "def push_tag(self, tag, index=0):\n        \"\"\"Inserts contents of an EthernetTag object before the index-th VLAN tag.\n           Index defaults to 0 (the top of the stack).\"\"\"\n        if index < 0:\n            index += self.tag_cnt\n        pos = 12 + 4*max(0, min(index, self.tag_cnt))\n        data = self.get_bytes()\n        data[pos:pos] = tag.get_bytes()\n        self.set_bytes(data)\n        self.tag_cnt += 1",
  "def pop_tag(self, index=0):\n        \"\"\"Removes the index-th VLAN tag and returns it as an EthernetTag object.\n           Index defaults to 0 (the top of the stack).\"\"\"\n        index = self.__validate_tag_index(index)\n        pos = 12 + 4*index\n        tag = self.get_long(pos)\n        data = self.get_bytes()\n        del data[pos:pos+4]\n        self.set_bytes(data)\n        self.tag_cnt -= 1\n        return EthernetTag(tag)",
  "def load_header(self, aBuffer):\n        self.tag_cnt = 0\n        while aBuffer[12+4*self.tag_cnt:14+4*self.tag_cnt] in (b'\\x81\\x00', b'\\x88\\xa8', b'\\x91\\x00'):\n            self.tag_cnt += 1\n\n        hdr_len = self.get_header_size()\n        diff = hdr_len - len(aBuffer)\n        if diff > 0:\n            aBuffer += b'\\x00'*diff\n        self.set_bytes_from_string(aBuffer[:hdr_len])",
  "def get_header_size(self):\n        \"Return size of Ethernet header\"\n        return 14 + 4*self.tag_cnt",
  "def get_packet(self):\n\n        if self.child():\n            try:\n                self.set_ether_type(self.child().ethertype)\n            except:\n                \" an Ethernet packet may have a Data() \"\n                pass\n        return Header.get_packet(self)",
  "def get_ether_dhost(self):\n        \"Return 48 bit destination ethernet address as a 6 byte array\"\n        return self.get_bytes()[0:6]",
  "def set_ether_dhost(self, aValue):\n        \"Set destination ethernet address from 6 byte array 'aValue'\"\n        for i in range(0, 6):\n            self.set_byte(i, aValue[i])",
  "def get_ether_shost(self):\n        \"Return 48 bit source ethernet address as a 6 byte array\"\n        return self.get_bytes()[6:12]",
  "def set_ether_shost(self, aValue):\n        \"Set source ethernet address from 6 byte array 'aValue'\"\n        for i in range(0, 6):\n            self.set_byte(i + 6, aValue[i])",
  "def as_eth_addr(anArray):\n        tmp_list = [x > 15 and '%x'%x or '0%x'%x for x in anArray]\n        return '' + reduce(lambda x, y: x+':'+y, tmp_list)",
  "def __str__(self):\n        tmp_str = 'Ether: ' + self.as_eth_addr(self.get_ether_shost()) + ' -> '\n        tmp_str += self.as_eth_addr(self.get_ether_dhost())\n        if self.child():\n            tmp_str += '\\n' + str( self.child())\n        return tmp_str",
  "def __validate_tag_index(self, index):\n        \"\"\"Adjusts negative indices to their absolute equivalents.\n           Raises IndexError when out of range <0, self.tag_cnt-1>.\"\"\"\n        if index < 0:\n            index += self.tag_cnt\n        if index < 0 or index >= self.tag_cnt:\n            raise IndexError(\"Tag index out of range\")\n        return index",
  "def __init__(self, aBuffer = None):\n        Header.__init__(self, 16)\n        if (aBuffer):\n            self.load_header(aBuffer)",
  "def set_type(self, type):\n        \"Sets the packet type field to type\"\n        self.set_word(0, type)",
  "def get_type(self):\n        \"Returns the packet type field\"\n        return self.get_word(0)",
  "def set_arphdr(self, value):\n        \"Sets the ARPHDR value for the link layer device type\"\n        self.set_word(2, type)",
  "def get_arphdr(self):\n        \"Returns the ARPHDR value for the link layer device type\"\n        return self.get_word(2)",
  "def set_addr_len(self, len):\n        \"Sets the length of the sender's address field to len\"\n        self.set_word(4, len)",
  "def get_addr_len(self):\n        \"Returns the length of the sender's address field\"\n        return self.get_word(4)",
  "def set_addr(self, addr):\n        \"Sets the sender's address field to addr. Addr must be at most 8-byte long.\"\n        if (len(addr) < 8):\n            addr += b'\\0' * (8 - len(addr))\n        self.get_bytes()[6:14] = addr",
  "def get_addr(self):\n        \"Returns the sender's address field\"\n        return array_tobytes(self.get_bytes()[6:14])",
  "def set_ether_type(self, aValue):\n        \"Set ethernet data type field to 'aValue'\"\n        self.set_word(14, aValue)",
  "def get_ether_type(self):\n        \"Return ethernet data type field\"\n        return self.get_word(14)",
  "def get_header_size(self):\n        \"Return size of packet header\"\n        return 16",
  "def get_packet(self):\n        if self.child():\n            self.set_ether_type(self.child().ethertype)\n        return Header.get_packet(self)",
  "def get_type_desc(self):\n        type = self.get_type()\n        if type < len(LinuxSLL.type_descriptions):\n            return LinuxSLL.type_descriptions[type]\n        else:\n            return \"Unknown\"",
  "def __str__(self):\n        ss = []\n        alen = self.get_addr_len()\n        addr = hexlify(self.get_addr()[0:alen])\n        ss.append(\"Linux SLL: addr=%s type=`%s'\" % (addr, self.get_type_desc()))\n        if self.child():\n            ss.append(str(self.child()))\n\n        return '\\n'.join(ss)",
  "def __init__(self, aBuffer = None):\n        Header.__init__(self, 20)\n        self.set_ip_v(4)\n        self.set_ip_hl(5)\n        self.set_ip_ttl(255)\n        self.__option_list = []\n        if(aBuffer):\n            # When decoding, checksum shouldn't be modified\n            self.auto_checksum = 0\n            self.load_header(aBuffer)\n            \n        if sys.platform.count('bsd'):\n            self.is_BSD = True\n        else:\n            self.is_BSD = False",
  "def get_packet(self):\n        # set protocol\n        if self.get_ip_p() == 0 and self.child():\n            self.set_ip_p(self.child().protocol)\n\n        # set total length\n        if self.get_ip_len() == 0:\n            self.set_ip_len(self.get_size())\n\n        child_data = self.get_data_as_string()\n\n        if self.auto_checksum:\n            self.reset_ip_sum()\n\n        my_bytes = self.get_bytes()\n\n        for op in self.__option_list:\n            my_bytes.extend(op.get_bytes())\n\n        # Pad to a multiple of 4 bytes\n        num_pad = (4 - (len(my_bytes) % 4)) % 4\n        if num_pad:\n            array_frombytes(my_bytes, b\"\\0\" * num_pad)\n\n        # only change ip_hl value if options are present\n        if len(self.__option_list):\n            self.set_ip_hl(len(my_bytes) // 4)\n\n\n        # set the checksum if the user hasn't modified it\n        if self.auto_checksum:\n            self.set_ip_sum(self.compute_checksum(my_bytes))\n\n        if child_data is None:\n            return array_tobytes(my_bytes)\n        else:\n            return array_tobytes(my_bytes) + child_data",
  "def get_pseudo_header(self):\n        pseudo_buf = array.array(\"B\")\n        pseudo_buf.extend(self.get_bytes()[12:20])\n        pseudo_buf.fromlist([0])\n        pseudo_buf.extend(self.get_bytes()[9:10])\n        tmp_size = self.child().get_size()\n\n        size_str = struct.pack(\"!H\", tmp_size)\n\n        array_frombytes(pseudo_buf, size_str)\n        return pseudo_buf",
  "def add_option(self, option):\n        self.__option_list.append(option)\n        sum = 0\n        for op in self.__option_list:\n            sum += op.get_len()\n        if sum > 40:\n            raise ImpactPacketException(\"Options overflowed in IP packet with length: %d\" % sum)",
  "def get_ip_v(self):\n        n = self.get_byte(0)\n        return (n >> 4)",
  "def set_ip_v(self, value):\n        n = self.get_byte(0)\n        version = value & 0xF\n        n = n & 0xF\n        n = n | (version << 4)\n        self.set_byte(0, n)",
  "def get_ip_hl(self):\n        n = self.get_byte(0)\n        return (n & 0xF)",
  "def set_ip_hl(self, value):\n        n = self.get_byte(0)\n        len = value & 0xF\n        n = n & 0xF0\n        n = (n | len)\n        self.set_byte(0, n)",
  "def get_ip_tos(self):\n        return self.get_byte(1)",
  "def set_ip_tos(self,value):\n        self.set_byte(1, value)",
  "def get_ip_len(self):\n        if self.is_BSD:\n            return self.get_word(2, order = '=')\n        else:\n            return self.get_word(2)",
  "def set_ip_len(self, value):\n        if self.is_BSD:\n            self.set_word(2, value, order = '=')\n        else:\n            self.set_word(2, value)",
  "def get_ip_id(self):\n        return self.get_word(4)",
  "def set_ip_id(self, value):\n        return self.set_word(4, value)",
  "def get_ip_off(self):\n        if self.is_BSD:\n            return self.get_word(6, order = '=')\n        else:\n            return self.get_word(6)",
  "def set_ip_off(self, aValue):\n        if self.is_BSD:\n            self.set_word(6, aValue, order = '=')\n        else:\n            self.set_word(6, aValue)",
  "def get_ip_offmask(self):\n        return self.get_ip_off() & 0x1FFF",
  "def set_ip_offmask(self, aValue):\n        tmp_value = self.get_ip_off() & 0xD000\n        tmp_value |= aValue\n        self.set_ip_off(tmp_value)",
  "def get_ip_rf(self):\n        return self.get_ip_off() & 0x8000",
  "def set_ip_rf(self, aValue):\n        tmp_value = self.get_ip_off()\n        if aValue:\n            tmp_value |= 0x8000\n        else:\n            my_not = 0xFFFF ^ 0x8000\n            tmp_value &= my_not\n        self.set_ip_off(tmp_value)",
  "def get_ip_df(self):\n        return self.get_ip_off() & 0x4000",
  "def set_ip_df(self, aValue):\n        tmp_value = self.get_ip_off()\n        if aValue:\n            tmp_value |= 0x4000\n        else:\n            my_not = 0xFFFF ^ 0x4000\n            tmp_value &= my_not\n        self.set_ip_off(tmp_value)",
  "def get_ip_mf(self):\n        return self.get_ip_off() & 0x2000",
  "def set_ip_mf(self, aValue):\n        tmp_value = self.get_ip_off()\n        if aValue:\n            tmp_value |= 0x2000\n        else:\n            my_not = 0xFFFF ^ 0x2000\n            tmp_value &= my_not\n        self.set_ip_off(tmp_value)",
  "def fragment_by_list(self, aList):\n        if self.child():\n            proto = self.child().protocol\n        else:\n            proto = 0\n\n        child_data = self.get_data_as_string()\n        if not child_data:\n            return [self]\n\n        ip_header_bytes = self.get_bytes()\n        current_offset = 0\n        fragment_list = []\n\n        for frag_size in aList:\n            ip = IP()\n            ip.set_bytes(ip_header_bytes) # copy of original header\n            ip.set_ip_p(proto)\n\n\n            if frag_size % 8:   # round this fragment size up to next multiple of 8\n                frag_size += 8 - (frag_size % 8)\n\n\n            ip.set_ip_offmask(current_offset // 8)\n            current_offset += frag_size\n\n            data = Data(child_data[:frag_size])\n            child_data = child_data[frag_size:]\n\n            ip.set_ip_len(20 + data.get_size())\n            ip.contains(data)\n\n\n            if child_data:\n\n                ip.set_ip_mf(1)\n\n                fragment_list.append(ip)\n            else: # no more data bytes left to add to fragments\n\n                ip.set_ip_mf(0)\n\n                fragment_list.append(ip)\n                return fragment_list\n\n        if child_data: # any remaining data?\n            # create a fragment containing all of the remaining child_data\n            ip = IP()\n            ip.set_bytes(ip_header_bytes)\n            ip.set_ip_offmask(current_offset)\n            ip.set_ip_len(20 + len(child_data))\n            data = Data(child_data)\n            ip.contains(data)\n            fragment_list.append(ip)\n\n        return fragment_list",
  "def fragment_by_size(self, aSize):\n        data_len = len(self.get_data_as_string())\n        num_frags = data_len // aSize\n\n        if data_len % aSize:\n            num_frags += 1\n\n        size_list = []\n        for i in range(0, num_frags):\n            size_list.append(aSize)\n        return self.fragment_by_list(size_list)",
  "def get_ip_ttl(self):\n        return self.get_byte(8)",
  "def set_ip_ttl(self, value):\n        self.set_byte(8, value)",
  "def get_ip_p(self):\n        return self.get_byte(9)",
  "def set_ip_p(self, value):\n        self.set_byte(9, value)",
  "def get_ip_sum(self):\n        return self.get_word(10)",
  "def set_ip_sum(self, value):\n        self.auto_checksum = 0\n        self.set_word(10, value)",
  "def reset_ip_sum(self):\n        self.set_ip_sum(0x0000)\n        self.auto_checksum = 1",
  "def get_ip_src(self):\n        return self.get_ip_address(12)",
  "def set_ip_src(self, value):\n        self.set_ip_address(12, value)",
  "def get_ip_dst(self):\n        return self.get_ip_address(16)",
  "def set_ip_dst(self, value):\n        self.set_ip_address(16, value)",
  "def get_header_size(self):\n        op_len = 0\n        for op in self.__option_list:\n            op_len += op.get_len()\n\n        num_pad = (4 - (op_len % 4)) % 4\n\n        return 20 + op_len + num_pad",
  "def load_header(self, aBuffer):\n        self.set_bytes_from_string(aBuffer[:20])\n        opt_left = (self.get_ip_hl() - 5) * 4\n        opt_bytes = array.array('B', aBuffer[20:(20 + opt_left)])\n        if len(opt_bytes) != opt_left:\n            raise ImpactPacketException(\"Cannot load options from truncated packet\")\n\n\n        while opt_left:\n            op_type = opt_bytes[0]\n            if op_type == IPOption.IPOPT_EOL or op_type == IPOption.IPOPT_NOP:\n                new_option = IPOption(op_type)\n                op_len = 1\n            else:\n                op_len = opt_bytes[1]\n                if op_len > len(opt_bytes):\n                    raise ImpactPacketException(\"IP Option length is too high\")\n\n                new_option = IPOption(op_type, op_len)\n                new_option.set_bytes(opt_bytes[:op_len])\n\n            opt_bytes = opt_bytes[op_len:]\n            opt_left -= op_len\n            self.add_option(new_option)\n            if op_type == IPOption.IPOPT_EOL:\n                break",
  "def __str__(self):\n        flags = ' '\n        if self.get_ip_df():\n            flags += 'DF '\n        if self.get_ip_mf():\n            flags += 'MF '\n        if self.get_ip_rf():\n            flags += 'RF '\n        tmp_str = 'IP%s%s -> %s ' % (flags, self.get_ip_src(),self.get_ip_dst())\n        for op in self.__option_list:\n            tmp_str += '\\n' + str(op)\n        if self.child():\n            tmp_str += '\\n' + str(self.child())\n        return tmp_str",
  "def __init__(self, opcode = 0, size = None):\n        if size and (size < 3 or size > 40):\n            raise ImpactPacketException(\"IP Options must have a size between 3 and 40 bytes\")\n\n        if(opcode == IPOption.IPOPT_EOL):\n            PacketBuffer.__init__(self, 1)\n            self.set_code(IPOption.IPOPT_EOL)\n        elif(opcode == IPOption.IPOPT_NOP):\n            PacketBuffer.__init__(self, 1)\n            self.set_code(IPOption.IPOPT_NOP)\n        elif(opcode == IPOption.IPOPT_RR):\n            if not size:\n                size = 39\n            PacketBuffer.__init__(self, size)\n            self.set_code(IPOption.IPOPT_RR)\n            self.set_len(size)\n            self.set_ptr(4)\n\n        elif(opcode == IPOption.IPOPT_LSRR):\n            if not size:\n                size = 39\n            PacketBuffer.__init__(self, size)\n            self.set_code(IPOption.IPOPT_LSRR)\n            self.set_len(size)\n            self.set_ptr(4)\n\n        elif(opcode == IPOption.IPOPT_SSRR):\n            if not size:\n                size = 39\n            PacketBuffer.__init__(self, size)\n            self.set_code(IPOption.IPOPT_SSRR)\n            self.set_len(size)\n            self.set_ptr(4)\n\n        elif(opcode == IPOption.IPOPT_TS):\n            if not size:\n                size = 40\n            PacketBuffer.__init__(self, size)\n            self.set_code(IPOption.IPOPT_TS)\n            self.set_len(size)\n            self.set_ptr(5)\n            self.set_flags(0)\n        else:\n            if not size:\n                raise ImpactPacketException(\"Size required for this type\")\n            PacketBuffer.__init__(self,size)\n            self.set_code(opcode)\n            self.set_len(size)",
  "def append_ip(self, ip):\n        op = self.get_code()\n        if not (op == IPOption.IPOPT_RR or op == IPOption.IPOPT_LSRR or op == IPOption.IPOPT_SSRR or op == IPOption.IPOPT_TS):\n            raise ImpactPacketException(\"append_ip() not support for option type %d\" % self.opt_type)\n\n        p = self.get_ptr()\n        if not p:\n            raise ImpactPacketException(\"append_ip() failed, option ptr uninitialized\")\n\n        if (p + 4) > self.get_len():\n            raise ImpactPacketException(\"append_ip() would overflow option\")\n\n        self.set_ip_address(p - 1, ip)\n        p += 4\n        self.set_ptr(p)",
  "def set_code(self, value):\n        self.set_byte(0, value)",
  "def get_code(self):\n        return self.get_byte(0)",
  "def set_flags(self, flags):\n        if not (self.get_code() == IPOption.IPOPT_TS):\n            raise ImpactPacketException(\"Operation only supported on Timestamp option\")\n        self.set_byte(3, flags)",
  "def get_flags(self, flags):\n        if not (self.get_code() == IPOption.IPOPT_TS):\n            raise ImpactPacketException(\"Operation only supported on Timestamp option\")\n        return self.get_byte(3)",
  "def set_len(self, len):\n        self.set_byte(1, len)",
  "def set_ptr(self, ptr):\n        self.set_byte(2, ptr)",
  "def get_ptr(self):\n        return self.get_byte(2)",
  "def get_len(self):\n        return len(self.get_bytes())",
  "def __str__(self):\n        map = {IPOption.IPOPT_EOL : \"End of List \",\n               IPOption.IPOPT_NOP : \"No Operation \",\n               IPOption.IPOPT_RR  : \"Record Route \",\n               IPOption.IPOPT_TS  : \"Timestamp \",\n               IPOption.IPOPT_LSRR : \"Loose Source Route \",\n               IPOption.IPOPT_SSRR : \"Strict Source Route \"}\n\n        tmp_str = \"\\tIP Option: \"\n        op = self.get_code()\n        if op in map:\n            tmp_str += map[op]\n        else:\n            tmp_str += \"Code: %d \" % op\n\n        if op == IPOption.IPOPT_RR or op == IPOption.IPOPT_LSRR or op ==IPOption.IPOPT_SSRR:\n            tmp_str += self.print_addresses()\n\n\n        return tmp_str",
  "def print_addresses(self):\n        p = 3\n        tmp_str = \"[\"\n        if self.get_len() >= 7: # at least one complete IP address\n            while 1:\n                if p + 1 == self.get_ptr():\n                    tmp_str += \"#\"\n                tmp_str += self.get_ip_address(p)\n                p += 4\n                if p >= self.get_len():\n                    break\n                else:\n                    tmp_str += \", \"\n        tmp_str += \"] \"\n        if self.get_ptr() % 4: # ptr field should be a multiple of 4\n            tmp_str += \"nonsense ptr field: %d \" % self.get_ptr()\n        return tmp_str",
  "def __init__(self, aBuffer = None):\n        Header.__init__(self, 8)\n        if(aBuffer):\n            self.load_header(aBuffer)",
  "def get_uh_sport(self):\n        return self.get_word(0)",
  "def set_uh_sport(self, value):\n        self.set_word(0, value)",
  "def get_uh_dport(self):\n        return self.get_word(2)",
  "def set_uh_dport(self, value):\n        self.set_word(2, value)",
  "def get_uh_ulen(self):\n        return self.get_word(4)",
  "def set_uh_ulen(self, value):\n        self.set_word(4, value)",
  "def get_uh_sum(self):\n        return self.get_word(6)",
  "def set_uh_sum(self, value):\n        self.set_word(6, value)\n        self.auto_checksum = 0",
  "def calculate_checksum(self):\n        if self.auto_checksum and (not self.get_uh_sum()):\n            # if there isn't a parent to grab a pseudo-header from we'll assume the user knows what they're doing\n            # and won't meddle with the checksum or throw an exception\n            if not self.parent():\n                return\n\n            buffer = self.parent().get_pseudo_header()\n\n            buffer += self.get_bytes()\n            data = self.get_data_as_string()\n            if(data):\n                array_frombytes(buffer, data)\n            self.set_uh_sum(self.compute_checksum(buffer))",
  "def get_header_size(self):\n        return 8",
  "def __str__(self):\n        tmp_str = 'UDP %d -> %d' % (self.get_uh_sport(), self.get_uh_dport())\n        if self.child():\n            tmp_str += '\\n' + str(self.child())\n        return tmp_str",
  "def get_packet(self):\n        # set total length\n        if(self.get_uh_ulen() == 0):\n            self.set_uh_ulen(self.get_size())\n        return Header.get_packet(self)",
  "def __init__(self, aBuffer = None):\n        Header.__init__(self, 20)\n        self.set_th_off(5)\n        self.__option_list = []\n        if aBuffer:\n            self.load_header(aBuffer)",
  "def add_option(self, option):\n        self.__option_list.append(option)\n\n        sum = 0\n        for op in self.__option_list:\n            sum += op.get_size()\n\n        if sum > 40:\n            raise ImpactPacketException(\"Cannot add TCP option, would overflow option space\")",
  "def get_options(self):\n        return self.__option_list",
  "def swapSourceAndDestination(self):\n        oldSource = self.get_th_sport()\n        self.set_th_sport(self.get_th_dport())\n        self.set_th_dport(oldSource)",
  "def set_th_sport(self, aValue):\n        self.set_word(0, aValue)",
  "def get_th_sport(self):\n        return self.get_word(0)",
  "def get_th_dport(self):\n        return self.get_word(2)",
  "def set_th_dport(self, aValue):\n        self.set_word(2, aValue)",
  "def get_th_seq(self):\n        return self.get_long(4)",
  "def set_th_seq(self, aValue):\n        self.set_long(4, aValue)",
  "def get_th_ack(self):\n        return self.get_long(8)",
  "def set_th_ack(self, aValue):\n        self.set_long(8, aValue)",
  "def get_th_flags(self):\n        return self.get_word(12) & self.TCP_FLAGS_MASK",
  "def set_th_flags(self, aValue):\n        masked = self.get_word(12) & (~self.TCP_FLAGS_MASK)\n        nb = masked | (aValue & self.TCP_FLAGS_MASK)\n        return self.set_word(12, nb, \">\")",
  "def get_th_win(self):\n        return self.get_word(14)",
  "def set_th_win(self, aValue):\n        self.set_word(14, aValue)",
  "def set_th_sum(self, aValue):\n        self.set_word(16, aValue)\n        self.auto_checksum = 0",
  "def get_th_sum(self):\n        return self.get_word(16)",
  "def get_th_urp(self):\n        return self.get_word(18)",
  "def set_th_urp(self, aValue):\n        return self.set_word(18, aValue)",
  "def get_th_reserved(self):\n        tmp_value = self.get_byte(12) & 0x0f\n        return tmp_value",
  "def get_th_off(self):\n        tmp_value = self.get_byte(12) >> 4\n        return tmp_value",
  "def set_th_off(self, aValue):\n        mask = 0xF0\n        masked = self.get_byte(12) & (~mask)\n        nb = masked | ( (aValue << 4) & mask)\n        return self.set_byte(12, nb)",
  "def get_CWR(self):\n        return self.get_flag(128)",
  "def set_CWR(self):\n        return self.set_flags(128)",
  "def reset_CWR(self):\n        return self.reset_flags(128)",
  "def get_ECE(self):\n        return self.get_flag(64)",
  "def set_ECE(self):\n        return self.set_flags(64)",
  "def reset_ECE(self):\n        return self.reset_flags(64)",
  "def get_URG(self):\n        return self.get_flag(32)",
  "def set_URG(self):\n        return self.set_flags(32)",
  "def reset_URG(self):\n        return self.reset_flags(32)",
  "def get_ACK(self):\n        return self.get_flag(16)",
  "def set_ACK(self):\n        return self.set_flags(16)",
  "def reset_ACK(self):\n        return self.reset_flags(16)",
  "def get_PSH(self):\n        return self.get_flag(8)",
  "def set_PSH(self):\n        return self.set_flags(8)",
  "def reset_PSH(self):\n        return self.reset_flags(8)",
  "def get_RST(self):\n        return self.get_flag(4)",
  "def set_RST(self):\n        return self.set_flags(4)",
  "def reset_RST(self):\n        return self.reset_flags(4)",
  "def get_SYN(self):\n        return self.get_flag(2)",
  "def set_SYN(self):\n        return self.set_flags(2)",
  "def reset_SYN(self):\n        return self.reset_flags(2)",
  "def get_FIN(self):\n        return self.get_flag(1)",
  "def set_FIN(self):\n        return self.set_flags(1)",
  "def reset_FIN(self):\n        return self.reset_flags(1)",
  "def get_header_size(self):\n        return 20 + len(self.get_padded_options())",
  "def calculate_checksum(self):\n        if not self.auto_checksum or not self.parent():\n            return\n\n        self.set_th_sum(0)\n        buffer = self.parent().get_pseudo_header()\n        buffer += self.get_bytes()\n        buffer += self.get_padded_options()\n\n        data = self.get_data_as_string()\n        if(data):\n            array_frombytes(buffer, data)\n\n        res = self.compute_checksum(buffer)\n\n        self.set_th_sum(self.compute_checksum(buffer))",
  "def get_packet(self):\n        \"Returns entire packet including child data as a string.  This is the function used to extract the final packet\"\n\n        # only change th_off value if options are present\n        if len(self.__option_list):\n            self.set_th_off(self.get_header_size() // 4)\n\n        self.calculate_checksum()\n\n        bytes = self.get_bytes() + self.get_padded_options()\n        data = self.get_data_as_string()\n\n        if data:\n            return array_tobytes(bytes) + data\n        else:\n            return array_tobytes(bytes)",
  "def load_header(self, aBuffer):\n        self.set_bytes_from_string(aBuffer[:20])\n        opt_left = (self.get_th_off() - 5) * 4\n        opt_bytes = array.array('B', aBuffer[20:(20 + opt_left)])\n        if len(opt_bytes) != opt_left:\n            raise ImpactPacketException(\"Cannot load options from truncated packet\")\n\n        while opt_left:\n            op_kind = opt_bytes[0]\n            if op_kind == TCPOption.TCPOPT_EOL or op_kind == TCPOption.TCPOPT_NOP:\n                new_option = TCPOption(op_kind)\n                op_len = 1\n            else:\n                op_len = opt_bytes[1]\n                if op_len > len(opt_bytes):\n                    raise ImpactPacketException(\"TCP Option length is too high\")\n                if op_len < 2:\n                    raise ImpactPacketException(\"TCP Option length is too low\")\n\n                new_option = TCPOption(op_kind)\n                new_option.set_bytes(opt_bytes[:op_len])\n\n            opt_bytes = opt_bytes[op_len:]\n            opt_left -= op_len\n            self.add_option(new_option)\n            if op_kind == TCPOption.TCPOPT_EOL:\n                break",
  "def get_flag(self, bit):\n        if self.get_th_flags() & bit:\n            return 1\n        else:\n            return 0",
  "def reset_flags(self, aValue):\n        tmp_value = self.get_th_flags() & (~aValue)\n        return self.set_th_flags(tmp_value)",
  "def set_flags(self, aValue):\n        tmp_value =  self.get_th_flags() | aValue\n        return self.set_th_flags(tmp_value)",
  "def get_padded_options(self):\n        \"Return an array containing all options padded to a 4 byte boundary\"\n        op_buf = array.array('B')\n        for op in self.__option_list:\n            op_buf += op.get_bytes()\n        num_pad = (4 - (len(op_buf) % 4)) % 4\n        if num_pad:\n            array_frombytes(op_buf, b\"\\0\" * num_pad)\n        return op_buf",
  "def __str__(self):\n        tmp_str = 'TCP '\n        if self.get_ECE():\n            tmp_str += 'ece '\n        if self.get_CWR():\n            tmp_str += 'cwr '\n        if self.get_ACK():\n            tmp_str += 'ack '\n        if self.get_FIN():\n            tmp_str += 'fin '\n        if self.get_PSH():\n            tmp_str += 'push '\n        if self.get_RST():\n            tmp_str += 'rst '\n        if self.get_SYN():\n            tmp_str += 'syn '\n        if self.get_URG():\n            tmp_str += 'urg '\n        tmp_str += '%d -> %d' % (self.get_th_sport(), self.get_th_dport())\n        for op in self.__option_list:\n            tmp_str += '\\n' + str(op)\n\n        if self.child():\n            tmp_str += '\\n' + str(self.child())\n        return tmp_str",
  "def __init__(self, kind, data = None):\n\n        if kind == TCPOption.TCPOPT_EOL:\n            PacketBuffer.__init__(self, 1)\n            self.set_kind(TCPOption.TCPOPT_EOL)\n        elif kind == TCPOption.TCPOPT_NOP:\n            PacketBuffer.__init__(self, 1)\n            self.set_kind(TCPOption.TCPOPT_NOP)\n        elif kind == TCPOption.TCPOPT_MAXSEG:\n            PacketBuffer.__init__(self, 4)\n            self.set_kind(TCPOption.TCPOPT_MAXSEG)\n            self.set_len(4)\n            if data:\n                self.set_mss(data)\n            else:\n                self.set_mss(512)\n        elif kind == TCPOption.TCPOPT_WINDOW:\n            PacketBuffer.__init__(self, 3)\n            self.set_kind(TCPOption.TCPOPT_WINDOW)\n            self.set_len(3)\n            if data:\n                self.set_shift_cnt(data)\n            else:\n                self.set_shift_cnt(0)\n        elif kind == TCPOption.TCPOPT_TIMESTAMP:\n            PacketBuffer.__init__(self, 10)\n            self.set_kind(TCPOption.TCPOPT_TIMESTAMP)\n            self.set_len(10)\n            if data:\n                self.set_ts(data)\n            else:\n                self.set_ts(0)\n        elif kind == TCPOption.TCPOPT_SACK_PERMITTED:\n            PacketBuffer.__init__(self, 2)\n            self.set_kind(TCPOption.TCPOPT_SACK_PERMITTED)\n            self.set_len(2)                \n\n        elif kind == TCPOption.TCPOPT_SACK:\n            PacketBuffer.__init__(self, 2)\n            self.set_kind(TCPOption.TCPOPT_SACK)",
  "def set_left_edge(self, aValue):\n        self.set_long (2, aValue)",
  "def set_right_edge(self, aValue):\n        self.set_long (6, aValue)",
  "def set_kind(self, kind):\n        self.set_byte(0, kind)",
  "def get_kind(self):\n        return self.get_byte(0)",
  "def set_len(self, len):\n        if self.get_size() < 2:\n            raise ImpactPacketException(\"Cannot set length field on an option having a size smaller than 2 bytes\")\n        self.set_byte(1, len)",
  "def get_len(self):\n        if self.get_size() < 2:\n            raise ImpactPacketException(\"Cannot retrieve length field from an option having a size smaller than 2 bytes\")\n        return self.get_byte(1)",
  "def get_size(self):\n        return len(self.get_bytes())",
  "def set_mss(self, len):\n        if self.get_kind() != TCPOption.TCPOPT_MAXSEG:\n            raise ImpactPacketException(\"Can only set MSS on TCPOPT_MAXSEG option\")\n        self.set_word(2, len)",
  "def get_mss(self):\n        if self.get_kind() != TCPOption.TCPOPT_MAXSEG:\n            raise ImpactPacketException(\"Can only retrieve MSS from TCPOPT_MAXSEG option\")\n        return self.get_word(2)",
  "def set_shift_cnt(self, cnt):\n        if self.get_kind() != TCPOption.TCPOPT_WINDOW:\n            raise ImpactPacketException(\"Can only set Shift Count on TCPOPT_WINDOW option\")\n        self.set_byte(2, cnt)",
  "def get_shift_cnt(self):\n        if self.get_kind() != TCPOption.TCPOPT_WINDOW:\n            raise ImpactPacketException(\"Can only retrieve Shift Count from TCPOPT_WINDOW option\")\n        return self.get_byte(2)",
  "def get_ts(self):\n        if self.get_kind() != TCPOption.TCPOPT_TIMESTAMP:\n            raise ImpactPacketException(\"Can only retrieve timestamp from TCPOPT_TIMESTAMP option\")\n        return self.get_long(2)",
  "def set_ts(self, ts):\n        if self.get_kind() != TCPOption.TCPOPT_TIMESTAMP:\n            raise ImpactPacketException(\"Can only set timestamp on TCPOPT_TIMESTAMP option\")\n        self.set_long(2, ts)",
  "def get_ts_echo(self):\n        if self.get_kind() != TCPOption.TCPOPT_TIMESTAMP:\n            raise ImpactPacketException(\"Can only retrieve timestamp from TCPOPT_TIMESTAMP option\")\n        return self.get_long(6)",
  "def set_ts_echo(self, ts):\n        if self.get_kind() != TCPOption.TCPOPT_TIMESTAMP:\n            raise ImpactPacketException(\"Can only set timestamp on TCPOPT_TIMESTAMP option\")\n        self.set_long(6, ts)",
  "def __str__(self):\n        map = { TCPOption.TCPOPT_EOL : \"End of List \",\n                TCPOption.TCPOPT_NOP : \"No Operation \",\n                TCPOption.TCPOPT_MAXSEG : \"Maximum Segment Size \",\n                TCPOption.TCPOPT_WINDOW : \"Window Scale \",\n                TCPOption.TCPOPT_TIMESTAMP : \"Timestamp \" }\n\n        tmp_str = \"\\tTCP Option: \"\n        op = self.get_kind()\n        if op in map:\n            tmp_str += map[op]\n        else:\n            tmp_str += \" kind: %d \" % op\n        if op == TCPOption.TCPOPT_MAXSEG:\n            tmp_str += \" MSS : %d \" % self.get_mss()\n        elif op == TCPOption.TCPOPT_WINDOW:\n            tmp_str += \" Shift Count: %d \" % self.get_shift_cnt()\n        elif op == TCPOption.TCPOPT_TIMESTAMP:\n            pass # TODO\n        return tmp_str",
  "def __init__(self, aBuffer = None):\n        Header.__init__(self, 8)\n        if aBuffer:\n            self.load_header(aBuffer)",
  "def get_header_size(self):\n        anamolies = { ICMP.ICMP_TSTAMP : 20, ICMP.ICMP_TSTAMPREPLY : 20, ICMP.ICMP_MASKREQ : 12, ICMP.ICMP_MASKREPLY : 12 }\n        if self.get_icmp_type() in anamolies:\n            return anamolies[self.get_icmp_type()]\n        else:\n            return 8",
  "def get_icmp_type(self):\n        return self.get_byte(0)",
  "def set_icmp_type(self, aValue):\n        self.set_byte(0, aValue)",
  "def get_icmp_code(self):\n        return self.get_byte(1)",
  "def set_icmp_code(self, aValue):\n        self.set_byte(1, aValue)",
  "def get_icmp_cksum(self):\n        return self.get_word(2)",
  "def set_icmp_cksum(self, aValue):\n        self.set_word(2, aValue)\n        self.auto_checksum = 0",
  "def get_icmp_gwaddr(self):\n        return self.get_ip_address(4)",
  "def set_icmp_gwaddr(self, ip):\n        self.set_ip_address(4, ip)",
  "def get_icmp_id(self):\n        return self.get_word(4)",
  "def set_icmp_id(self, aValue):\n        self.set_word(4, aValue)",
  "def get_icmp_seq(self):\n        return self.get_word(6)",
  "def set_icmp_seq(self, aValue):\n        self.set_word(6, aValue)",
  "def get_icmp_void(self):\n        return self.get_long(4)",
  "def set_icmp_void(self, aValue):\n        self.set_long(4, aValue)",
  "def get_icmp_nextmtu(self):\n        return self.get_word(6)",
  "def set_icmp_nextmtu(self, aValue):\n        self.set_word(6, aValue)",
  "def get_icmp_num_addrs(self):\n        return self.get_byte(4)",
  "def set_icmp_num_addrs(self, aValue):\n        self.set_byte(4, aValue)",
  "def get_icmp_wpa(self):\n        return self.get_byte(5)",
  "def set_icmp_wpa(self, aValue):\n        self.set_byte(5, aValue)",
  "def get_icmp_lifetime(self):\n        return self.get_word(6)",
  "def set_icmp_lifetime(self, aValue):\n        self.set_word(6, aValue)",
  "def get_icmp_otime(self):\n        return self.get_long(8)",
  "def set_icmp_otime(self, aValue):\n        self.set_long(8, aValue)",
  "def get_icmp_rtime(self):\n        return self.get_long(12)",
  "def set_icmp_rtime(self, aValue):\n        self.set_long(12, aValue)",
  "def get_icmp_ttime(self):\n        return self.get_long(16)",
  "def set_icmp_ttime(self, aValue):\n        self.set_long(16, aValue)",
  "def get_icmp_mask(self):\n        return self.get_ip_address(8)",
  "def set_icmp_mask(self, mask):\n        self.set_ip_address(8, mask)",
  "def calculate_checksum(self):\n        if self.auto_checksum and (not self.get_icmp_cksum()):\n            buffer = self.get_buffer_as_string()\n            data = self.get_data_as_string()\n            if data:\n                buffer += data\n\n            tmp_array = array.array('B', buffer)\n            self.set_icmp_cksum(self.compute_checksum(tmp_array))",
  "def get_type_name(self, aType):\n        tmp_type = {0:'ECHOREPLY', 3:'UNREACH', 4:'SOURCEQUENCH',5:'REDIRECT', 6:'ALTHOSTADDR', 8:'ECHO', 9:'ROUTERADVERT', 10:'ROUTERSOLICIT', 11:'TIMXCEED', 12:'PARAMPROB', 13:'TSTAMP', 14:'TSTAMPREPLY', 15:'IREQ', 16:'IREQREPLY', 17:'MASKREQ', 18:'MASKREPLY', 30:'TRACEROUTE', 31:'DATACONVERR', 32:'MOBILE REDIRECT', 33:'IPV6 WHEREAREYOU', 34:'IPV6 IAMHERE', 35:'MOBILE REGREQUEST', 36:'MOBILE REGREPLY', 39:'SKIP', 40:'PHOTURIS'}\n        answer = tmp_type.get(aType, 'UNKNOWN')\n        return answer",
  "def get_code_name(self, aType, aCode):\n        tmp_code = {3:['UNREACH NET', 'UNREACH HOST', 'UNREACH PROTOCOL', 'UNREACH PORT', 'UNREACH NEEDFRAG', 'UNREACH SRCFAIL', 'UNREACH NET UNKNOWN', 'UNREACH HOST UNKNOWN', 'UNREACH ISOLATED', 'UNREACH NET PROHIB', 'UNREACH HOST PROHIB', 'UNREACH TOSNET', 'UNREACH TOSHOST', 'UNREACH FILTER PROHIB', 'UNREACH HOST PRECEDENCE', 'UNREACH PRECEDENCE CUTOFF', 'UNKNOWN ICMP UNREACH']}\n        tmp_code[5] = ['REDIRECT NET', 'REDIRECT HOST', 'REDIRECT TOSNET', 'REDIRECT TOSHOST']\n        tmp_code[9] = ['ROUTERADVERT NORMAL', None, None, None, None, None, None, None, None, None, None, None, None, None, None, None,'ROUTERADVERT NOROUTE COMMON']\n        tmp_code[11] = ['TIMXCEED INTRANS ', 'TIMXCEED REASS']\n        tmp_code[12] = ['PARAMPROB ERRATPTR ', 'PARAMPROB OPTABSENT', 'PARAMPROB LENGTH']\n        tmp_code[40] = [None, 'PHOTURIS UNKNOWN INDEX', 'PHOTURIS AUTH FAILED', 'PHOTURIS DECRYPT FAILED']\n        if aType in tmp_code:\n            tmp_list = tmp_code[aType]\n            if ((aCode + 1) > len(tmp_list)) or (not tmp_list[aCode]):\n                return 'UNKNOWN'\n            else:\n                return tmp_list[aCode]\n        else:\n            return 'UNKNOWN'",
  "def __str__(self):\n        tmp_type = self.get_icmp_type()\n        tmp_code = self.get_icmp_code()\n        tmp_str = 'ICMP type: ' + self.get_type_name(tmp_type)\n        tmp_str+= ' code: ' + self.get_code_name(tmp_type, tmp_code)\n        if self.child():\n            tmp_str += '\\n' + str( self.child() )\n        return tmp_str",
  "def isDestinationUnreachable(self):\n        return self.get_icmp_type() == 3",
  "def isError(self):\n        return not self.isQuery()",
  "def isHostUnreachable(self):\n        return self.isDestinationUnreachable() and (self.get_icmp_code() == 1)",
  "def isNetUnreachable(self):\n        return self.isDestinationUnreachable() and (self.get_icmp_code() == 0)",
  "def isPortUnreachable(self):\n        return self.isDestinationUnreachable() and (self.get_icmp_code() == 3)",
  "def isProtocolUnreachable(self):\n        return self.isDestinationUnreachable() and (self.get_icmp_code() == 2)",
  "def isQuery(self):\n        tmp_dict = {8:'',  9:'',  10:'', 13:'', 14:'', 15:'', 16:'', 17:'', 18:''}\n        return self.get_icmp_type() in tmp_dict",
  "def __init__(self, aBuffer = None):\n        Header.__init__(self, 8)\n        if aBuffer:\n            self.load_header(aBuffer)",
  "def get_igmp_type(self):\n        return self.get_byte(0)",
  "def set_igmp_type(self, aValue):\n        self.set_byte(0, aValue)",
  "def get_igmp_code(self):\n        return self.get_byte(1)",
  "def set_igmp_code(self, aValue):\n        self.set_byte(1, aValue)",
  "def get_igmp_cksum(self):\n        return self.get_word(2)",
  "def set_igmp_cksum(self, aValue):\n        self.set_word(2, aValue)",
  "def get_igmp_group(self):\n        return self.get_long(4)",
  "def set_igmp_group(self, aValue):\n        self.set_long(4, aValue)",
  "def get_header_size(self):\n        return 8",
  "def get_type_name(self, aType):\n        tmp_dict = {0x11:'HOST MEMBERSHIP QUERY ', 0x12:'v1 HOST MEMBERSHIP REPORT ', 0x13:'IGMP DVMRP ', 0x14:' PIM ', 0x16:'v2 HOST MEMBERSHIP REPORT ', 0x17:'HOST LEAVE MESSAGE ', 0x1e:'MTRACE REPLY ', 0X1f:'MTRACE QUERY '}\n        answer = tmp_dict.get(aType, 'UNKNOWN TYPE OR VERSION ')\n        return answer",
  "def calculate_checksum(self):\n        if self.auto_checksum and (not self.get_igmp_cksum()):\n            self.set_igmp_cksum(self.compute_checksum(self.get_bytes()))",
  "def __str__(self):\n        tmp_str = 'IGMP: ' + self.get_type_name(self.get_igmp_type())\n        tmp_str += 'Group: ' +  socket.inet_ntoa(struct.pack('!L',self.get_igmp_group()))\n        if self.child():\n            tmp_str += '\\n' + str(self.child())\n        return tmp_str",
  "def __init__(self, aBuffer = None):\n        Header.__init__(self, 7)\n        if aBuffer:\n            self.load_header(aBuffer)",
  "def get_ar_hrd(self):\n        return self.get_word(0)",
  "def set_ar_hrd(self, aValue):\n        self.set_word(0, aValue)",
  "def get_ar_pro(self):\n        return self.get_word(2)",
  "def set_ar_pro(self, aValue):\n        self.set_word(2, aValue)",
  "def get_ar_hln(self):\n        return self.get_byte(4)",
  "def set_ar_hln(self, aValue):\n        self.set_byte(4, aValue)",
  "def get_ar_pln(self):\n        return self.get_byte(5)",
  "def set_ar_pln(self, aValue):\n        self.set_byte(5, aValue)",
  "def get_ar_op(self):\n        return self.get_word(6)",
  "def set_ar_op(self, aValue):\n        self.set_word(6, aValue)",
  "def get_ar_sha(self):\n        tmp_size = self.get_ar_hln()\n        return self.get_bytes().tolist()[8: 8 + tmp_size]",
  "def set_ar_sha(self, aValue):\n        for i in range(0, self.get_ar_hln()):\n            self.set_byte(i + 8, aValue[i])",
  "def get_ar_spa(self):\n        tmp_size = self.get_ar_pln()\n        return self.get_bytes().tolist()[8 + self.get_ar_hln(): 8 + self.get_ar_hln() + tmp_size]",
  "def set_ar_spa(self, aValue):\n        for i in range(0, self.get_ar_pln()):\n            self.set_byte(i + 8 + self.get_ar_hln(), aValue[i])",
  "def get_ar_tha(self):\n        tmp_size = self.get_ar_hln()\n        tmp_from = 8 + self.get_ar_hln() + self.get_ar_pln()\n        return self.get_bytes().tolist()[tmp_from: tmp_from + tmp_size]",
  "def set_ar_tha(self, aValue):\n        tmp_from = 8 + self.get_ar_hln() + self.get_ar_pln()\n        for i in range(0, self.get_ar_hln()):\n            self.set_byte(i + tmp_from, aValue[i])",
  "def get_ar_tpa(self):\n        tmp_size = self.get_ar_pln()\n        tmp_from = 8 + ( 2 * self.get_ar_hln()) + self.get_ar_pln()\n        return self.get_bytes().tolist()[tmp_from: tmp_from + tmp_size]",
  "def set_ar_tpa(self, aValue):\n        tmp_from = 8 + (2 * self.get_ar_hln()) + self.get_ar_pln()\n        for i in range(0, self.get_ar_pln()):\n            self.set_byte(i + tmp_from, aValue[i])",
  "def get_header_size(self):\n        return 8 + (2 * self.get_ar_hln()) + (2 * self.get_ar_pln())",
  "def get_op_name(self, ar_op):\n        tmp_dict = {1:'REQUEST', 2:'REPLY', 3:'REVREQUEST', 4:'REVREPLY', 8:'INVREQUEST', 9:'INVREPLY'}\n        answer = tmp_dict.get(ar_op, 'UNKNOWN')\n        return answer",
  "def get_hrd_name(self, ar_hrd):\n        tmp_dict = { 1:'ARPHRD ETHER', 6:'ARPHRD IEEE802', 15:'ARPHRD FRELAY'}\n        answer = tmp_dict.get(ar_hrd, 'UNKNOWN')\n        return answer",
  "def as_hrd(self, anArray):\n        if not anArray:\n            return ''\n        tmp_str = '%x' % anArray[0]\n        for i in range(1, len(anArray)):\n            tmp_str += ':%x' % anArray[i]\n        return tmp_str",
  "def as_pro(self, anArray):\n        if not anArray:\n            return ''\n        tmp_str = '%d' % anArray[0]\n        for i in range(1, len(anArray)):\n            tmp_str += '.%d' % anArray[i]\n        return tmp_str",
  "def __str__(self):\n        tmp_op = self.get_ar_op()\n        tmp_str = 'ARP format: ' + self.get_hrd_name(self.get_ar_hrd()) + ' '\n        tmp_str += 'opcode: ' + self.get_op_name(tmp_op)\n        tmp_str += '\\n' + self.as_hrd(self.get_ar_sha()) + ' -> '\n        tmp_str += self.as_hrd(self.get_ar_tha())\n        tmp_str += '\\n' + self.as_pro(self.get_ar_spa()) + ' -> '\n        tmp_str += self.as_pro(self.get_ar_tpa())\n        if self.child():\n            tmp_str += '\\n' + str(self.child())\n        return tmp_str",
  "def computeNTLMv2(identity, lmhash, nthash, serverChallenge, authenticateMessage, ntlmChallenge, type1):\n    # Let's calculate the NTLMv2 Response\n\n    responseKeyNT = ntlm.NTOWFv2(identity, '', authenticateMessage['domain_name'].decode('utf-16le'), nthash)\n    responseKeyLM = ntlm.LMOWFv2(identity, '', authenticateMessage['domain_name'].decode('utf-16le'), lmhash)\n\n    ntProofStr = authenticateMessage['ntlm'][:16]\n    temp = authenticateMessage['ntlm'][16:]\n    ntProofStr2 = ntlm.hmac_md5(responseKeyNT, serverChallenge + temp)\n    lmChallengeResponse = authenticateMessage['lanman']\n    sessionBaseKey = ntlm.hmac_md5(responseKeyNT, ntProofStr)\n\n    responseFlags = type1['flags']\n\n    # Let's check the return flags\n    if (ntlmChallenge['flags'] & ntlm.NTLMSSP_NEGOTIATE_EXTENDED_SESSIONSECURITY) == 0:\n        # No extended session security, taking it out\n        responseFlags &= 0xffffffff ^ ntlm.NTLMSSP_NEGOTIATE_EXTENDED_SESSIONSECURITY\n    if (ntlmChallenge['flags'] & ntlm.NTLMSSP_NEGOTIATE_128) == 0:\n        # No support for 128 key len, taking it out\n        responseFlags &= 0xffffffff ^ ntlm.NTLMSSP_NEGOTIATE_128\n    if (ntlmChallenge['flags'] & ntlm.NTLMSSP_NEGOTIATE_KEY_EXCH) == 0:\n        # No key exchange supported, taking it out\n        responseFlags &= 0xffffffff ^ ntlm.NTLMSSP_NEGOTIATE_KEY_EXCH\n    if (ntlmChallenge['flags'] & ntlm.NTLMSSP_NEGOTIATE_SEAL) == 0:\n        # No sign available, taking it out\n        responseFlags &= 0xffffffff ^ ntlm.NTLMSSP_NEGOTIATE_SEAL\n    if (ntlmChallenge['flags'] & ntlm.NTLMSSP_NEGOTIATE_SIGN) == 0:\n        # No sign available, taking it out\n        responseFlags &= 0xffffffff ^ ntlm.NTLMSSP_NEGOTIATE_SIGN\n    if (ntlmChallenge['flags'] & ntlm.NTLMSSP_NEGOTIATE_ALWAYS_SIGN) == 0:\n        # No sign available, taking it out\n        responseFlags &= 0xffffffff ^ ntlm.NTLMSSP_NEGOTIATE_ALWAYS_SIGN\n\n    keyExchangeKey = ntlm.KXKEY(ntlmChallenge['flags'], sessionBaseKey, lmChallengeResponse,\n                                ntlmChallenge['challenge'], '',\n                                lmhash, nthash, True)\n\n    # If we set up key exchange, let's fill the right variables\n    if ntlmChallenge['flags'] & ntlm.NTLMSSP_NEGOTIATE_KEY_EXCH:\n        exportedSessionKey = authenticateMessage['session_key']\n        exportedSessionKey = ntlm.generateEncryptedSessionKey(keyExchangeKey, exportedSessionKey)\n    else:\n        encryptedRandomSessionKey = None\n        # [MS-NLMP] page 46\n        exportedSessionKey = keyExchangeKey\n\n    # Do they match?\n    if ntProofStr == ntProofStr2:\n        # Yes!, process login\n        return STATUS_SUCCESS, exportedSessionKey\n    else:\n        return STATUS_LOGON_FAILURE, exportedSessionKey",
  "def outputToJohnFormat(challenge, username, domain, lmresponse, ntresponse):\n    # We don't want to add a possible failure here, since this is an\n    # extra bonus. We try, if it fails, returns nothing\n    # ToDo: Document the parameter's types (bytes / string) and check all the places where it's called\n    ret_value = ''\n    if type(challenge) is not bytes:\n        challenge = challenge.decode('latin-1')\n\n    try:\n        if len(ntresponse) > 24:\n            # Extended Security - NTLMv2\n            ret_value = {'hash_string': '%s::%s:%s:%s:%s' % (\n                username.decode('utf-16le'), domain.decode('utf-16le'), hexlify(challenge).decode('latin-1'),\n                hexlify(ntresponse).decode('latin-1')[:32],\n                hexlify(ntresponse).decode()[32:]), 'hash_version': 'ntlmv2'}\n        else:\n            # NTLMv1\n            ret_value = {'hash_string': '%s::%s:%s:%s:%s' % (\n                username.decode('utf-16le'), domain.decode('utf-16le'), hexlify(lmresponse).decode('latin-1'),\n                hexlify(ntresponse).decode('latin-1'),\n                hexlify(challenge).decode()), 'hash_version': 'ntlm'}\n    except:\n        # Let's try w/o decoding Unicode\n        try:\n            if len(ntresponse) > 24:\n                # Extended Security - NTLMv2\n                ret_value = {'hash_string': '%s::%s:%s:%s:%s' % (\n                    username.decode('latin-1'), domain.decode('latin-1'), hexlify(challenge).decode('latin-1'),\n                    hexlify(ntresponse)[:32].decode('latin-1'), hexlify(ntresponse)[32:].decode('latin-1')),\n                             'hash_version': 'ntlmv2'}\n            else:\n                # NTLMv1\n                ret_value = {'hash_string': '%s::%s:%s:%s:%s' % (\n                    username, domain, hexlify(lmresponse).decode('latin-1'), hexlify(ntresponse).decode('latin-1'),\n                    hexlify(challenge).decode('latin-1')), 'hash_version': 'ntlm'}\n        except Exception as e:\n            import traceback\n            traceback.print_exc()\n            LOG.error(\"outputToJohnFormat: %s\" % e)\n            pass\n\n    return ret_value",
  "def writeJohnOutputToFile(hash_string, hash_version, file_name):\n    fn_data = os.path.splitext(file_name)\n    if hash_version == \"ntlmv2\":\n        output_filename = fn_data[0] + \"_ntlmv2\" + fn_data[1]\n    else:\n        output_filename = fn_data[0] + \"_ntlm\" + fn_data[1]\n\n    with open(output_filename, \"a\") as f:\n        f.write(hash_string)\n        f.write('\\n')",
  "def decodeSMBString(flags, text):\n    if flags & smb.SMB.FLAGS2_UNICODE:\n        return text.decode('utf-16le')\n    else:\n        return text",
  "def encodeSMBString(flags, text):\n    if flags & smb.SMB.FLAGS2_UNICODE:\n        return (text).encode('utf-16le')\n    else:\n        return text.encode('ascii')",
  "def getFileTime(t):\n    t *= 10000000\n    t += 116444736000000000\n    return t",
  "def getUnixTime(t):\n    t -= 116444736000000000\n    t //= 10000000\n    return t",
  "def getSMBDate(t):\n    # TODO: Fix this :P\n    d = datetime.date.fromtimestamp(t)\n    year = d.year - 1980\n    ret = (year << 8) + (d.month << 4) + d.day\n    return ret",
  "def getSMBTime(t):\n    # TODO: Fix this :P\n    d = datetime.datetime.fromtimestamp(t)\n    return (d.hour << 8) + (d.minute << 4) + d.second",
  "def getShares(connId, smbServer):\n    config = smbServer.getServerConfig()\n    sections = config.sections()\n    # Remove the global one\n    del (sections[sections.index('global')])\n    shares = {}\n    for i in sections:\n        shares[i] = dict(config.items(i))\n    return shares",
  "def searchShare(connId, share, smbServer):\n    config = smbServer.getServerConfig()\n    if config.has_section(share):\n        return dict(config.items(share))\n    else:\n        return None",
  "def normalize_path(file_name, path=None):\n    \"\"\"Normalizes a path by replacing \"\\\" with \"/\" and stripping potential\n    leading \"/\" chars. If a path is provided, only strip leading '/' when\n    the path is empty.\n\n    :param file_name: file name to normalize\n    :type file_name: string\n\n    :param path: path to normalize\n    :type path: string\n\n    :return normalized file name\n    :rtype string\n    \"\"\"\n    file_name = os.path.normpath(file_name.replace('\\\\', '/'))\n    if len(file_name) > 0 and (file_name[0] == '/' or file_name[0] == '\\\\'):\n        if path is None or path != '':\n            # Strip leading \"/\"\n            file_name = file_name[1:]\n    return file_name",
  "def isInFileJail(path, file_name):\n    \"\"\"Validates if a provided file name path is inside a path. This function is used\n    to check for path traversals.\n\n    :param path: base path to check\n    :type path: string\n    :param file_name: file name to validate\n    :type file_name: string\n\n    :return whether the file name is inside the base path or not\n    :rtype bool\n    \"\"\"\n    path_name = os.path.join(path, file_name)\n    share_real_path = os.path.realpath(path)\n    return os.path.commonprefix((os.path.realpath(path_name), share_real_path)) == share_real_path",
  "def openFile(path, fileName, accessMode, fileAttributes, openMode):\n    fileName = normalize_path(fileName)\n    pathName = os.path.join(path, fileName)\n    errorCode = 0\n    mode = 0\n\n    if not isInFileJail(path, fileName):\n        LOG.error(\"Path not in current working directory\")\n        errorCode = STATUS_OBJECT_PATH_SYNTAX_BAD\n        return 0, mode, pathName, errorCode\n\n    # Check the Open Mode\n    if openMode & 0x10:\n        # If the file does not exist, create it.\n        mode = os.O_CREAT\n    else:\n        # If file does not exist, return an error\n        if os.path.exists(pathName) is not True:\n            errorCode = STATUS_NO_SUCH_FILE\n            return 0, mode, pathName, errorCode\n\n    if os.path.isdir(pathName) and (fileAttributes & smb.ATTR_DIRECTORY) == 0:\n        # Request to open a normal file and this is actually a directory\n        errorCode = STATUS_FILE_IS_A_DIRECTORY\n        return 0, mode, pathName, errorCode\n    # Check the Access Mode\n    if accessMode & 0x7 == 1:\n        mode |= os.O_WRONLY\n    elif accessMode & 0x7 == 2:\n        mode |= os.O_RDWR\n    else:\n        mode = os.O_RDONLY\n\n    try:\n        if sys.platform == 'win32':\n            mode |= os.O_BINARY\n        fid = os.open(pathName, mode)\n    except Exception as e:\n        LOG.error(\"openFile: %s,%s\" % (pathName, mode), e)\n        fid = 0\n        errorCode = STATUS_ACCESS_DENIED\n\n    return fid, mode, pathName, errorCode",
  "def queryFsInformation(path, filename, level=None, pktFlags=smb.SMB.FLAGS2_UNICODE):\n    if pktFlags & smb.SMB.FLAGS2_UNICODE:\n        encoding = 'utf-16le'\n    else:\n        encoding = 'ascii'\n\n    fileName = normalize_path(filename)\n    pathName = os.path.join(path, fileName)\n    fileSize = os.path.getsize(pathName)\n    (mode, ino, dev, nlink, uid, gid, size, atime, mtime, ctime) = os.stat(pathName)\n\n    if level is None:\n        lastWriteTime = mtime\n        attribs = 0\n        if os.path.isdir(pathName):\n            attribs |= smb.SMB_FILE_ATTRIBUTE_DIRECTORY\n        if os.path.isfile(pathName):\n            attribs |= smb.SMB_FILE_ATTRIBUTE_NORMAL\n        fileAttributes = attribs\n        return fileSize, lastWriteTime, fileAttributes\n\n    elif level == smb.SMB_QUERY_FS_ATTRIBUTE_INFO or level == smb2.SMB2_FILESYSTEM_ATTRIBUTE_INFO:\n        data = smb.SMBQueryFsAttributeInfo()\n        data['FileSystemAttributes'] = smb.FILE_CASE_SENSITIVE_SEARCH | smb.FILE_CASE_PRESERVED_NAMES\n        data['MaxFilenNameLengthInBytes'] = 255\n        data['LengthOfFileSystemName'] = len('XTFS') * 2\n        data['FileSystemName'] = 'XTFS'.encode('utf-16le')\n        return data.getData()\n    elif level == smb.SMB_INFO_VOLUME:\n        data = smb.SMBQueryFsInfoVolume(flags=pktFlags)\n        data['VolumeLabel'] = 'SHARE'.encode(encoding)\n        return data.getData()\n    elif level == smb.SMB_QUERY_FS_VOLUME_INFO or level == smb2.SMB2_FILESYSTEM_VOLUME_INFO:\n        data = smb.SMBQueryFsVolumeInfo()\n        data['VolumeLabel'] = ''\n        data['VolumeCreationTime'] = getFileTime(ctime)\n        return data.getData()\n    elif level == smb.SMB_QUERY_FS_SIZE_INFO:\n        data = smb.SMBQueryFsSizeInfo()\n        return data.getData()\n    elif level == smb.SMB_QUERY_FS_DEVICE_INFO or level == smb2.SMB2_FILESYSTEM_DEVICE_INFO:\n        data = smb.SMBQueryFsDeviceInfo()\n        data['DeviceType'] = smb.FILE_DEVICE_DISK\n        return data.getData()\n    elif level == smb.FILE_FS_FULL_SIZE_INFORMATION:\n        data = smb.SMBFileFsFullSizeInformation()\n        return data.getData()\n    elif level == smb.FILE_FS_SIZE_INFORMATION:\n        data = smb.FileFsSizeInformation()\n        return data.getData()\n    else:\n        return None",
  "def findFirst2(path, fileName, level, searchAttributes, pktFlags=smb.SMB.FLAGS2_UNICODE, isSMB2=False):\n    # TODO: Depending on the level, this could be done much simpler\n\n    # Let's choose the right encoding depending on the request\n    if pktFlags & smb.SMB.FLAGS2_UNICODE:\n        encoding = 'utf-16le'\n    else:\n        encoding = 'ascii'\n\n    fileName = normalize_path(fileName)\n    pathName = os.path.join(path, fileName)\n\n    if not isInFileJail(path, fileName):\n        LOG.error(\"Path not in current working directory\")\n        return [], 0, STATUS_OBJECT_PATH_SYNTAX_BAD\n\n    files = []\n\n    if pathName.find('*') == -1 and pathName.find('?') == -1:\n        # No search patterns\n        pattern = ''\n    else:\n        pattern = os.path.basename(pathName)\n        dirName = os.path.dirname(pathName)\n\n    # Always add . and .. Not that important for Windows, but Samba whines if\n    # not present (for * search only)\n    if pattern == '*':\n        files.append(os.path.join(dirName, '.'))\n        files.append(os.path.join(dirName, '..'))\n\n    if pattern != '':\n        for file in os.listdir(dirName):\n            if fnmatch.fnmatch(file.lower(), pattern.lower()):\n                entry = os.path.join(dirName, file)\n                if os.path.isdir(entry):\n                    if searchAttributes & smb.ATTR_DIRECTORY:\n                        files.append(entry)\n                else:\n                    files.append(entry)\n    else:\n        if os.path.exists(pathName):\n            files.append(pathName)\n\n    searchResult = []\n    searchCount = len(files)\n    errorCode = STATUS_SUCCESS\n\n    for i in files:\n        if level == smb.SMB_FIND_FILE_BOTH_DIRECTORY_INFO or level == smb2.SMB2_FILE_BOTH_DIRECTORY_INFO:\n            item = smb.SMBFindFileBothDirectoryInfo(flags=pktFlags)\n        elif level == smb.SMB_FIND_FILE_DIRECTORY_INFO or level == smb2.SMB2_FILE_DIRECTORY_INFO:\n            item = smb.SMBFindFileDirectoryInfo(flags=pktFlags)\n        elif level == smb.SMB_FIND_FILE_FULL_DIRECTORY_INFO or level == smb2.SMB2_FULL_DIRECTORY_INFO:\n            item = smb.SMBFindFileFullDirectoryInfo(flags=pktFlags)\n        elif level == smb.SMB_FIND_INFO_STANDARD:\n            item = smb.SMBFindInfoStandard(flags=pktFlags)\n        elif level == smb.SMB_FIND_FILE_ID_FULL_DIRECTORY_INFO or level == smb2.SMB2_FILE_ID_FULL_DIRECTORY_INFO:\n            item = smb.SMBFindFileIdFullDirectoryInfo(flags=pktFlags)\n        elif level == smb.SMB_FIND_FILE_ID_BOTH_DIRECTORY_INFO or level == smb2.SMB2_FILE_ID_BOTH_DIRECTORY_INFO:\n            item = smb.SMBFindFileIdBothDirectoryInfo(flags=pktFlags)\n        elif level == smb.SMB_FIND_FILE_NAMES_INFO or level == smb2.SMB2_FILE_NAMES_INFO:\n            item = smb.SMBFindFileNamesInfo(flags=pktFlags)\n        else:\n            LOG.error(\"Wrong level %d!\" % level)\n            return searchResult, searchCount, STATUS_NOT_SUPPORTED\n\n        (mode, ino, dev, nlink, uid, gid, size, atime, mtime, ctime) = os.stat(i)\n        if os.path.isdir(i):\n            item['ExtFileAttributes'] = smb.ATTR_DIRECTORY\n        else:\n            item['ExtFileAttributes'] = smb.ATTR_NORMAL | smb.ATTR_ARCHIVE\n\n        item['FileName'] = os.path.basename(i).encode(encoding)\n\n        if level in [smb.SMB_FIND_FILE_BOTH_DIRECTORY_INFO, smb2.SMB2_FILE_BOTH_DIRECTORY_INFO,\n                     smb.SMB_FIND_FILE_ID_BOTH_DIRECTORY_INFO, smb2.SMB2_FILE_ID_BOTH_DIRECTORY_INFO]:\n            item['EaSize'] = 0\n            item['EndOfFile'] = size\n            item['AllocationSize'] = size\n            item['CreationTime'] = getFileTime(ctime)\n            item['LastAccessTime'] = getFileTime(atime)\n            item['LastWriteTime'] = getFileTime(mtime)\n            item['LastChangeTime'] = getFileTime(mtime)\n            item['ShortName'] = '\\x00' * 24\n            item['FileName'] = os.path.basename(i).encode(encoding)\n            padLen = (8 - (len(item) % 8)) % 8\n            item['NextEntryOffset'] = len(item) + padLen\n        elif level in [smb.SMB_FIND_FILE_DIRECTORY_INFO, smb2.SMB2_FILE_DIRECTORY_INFO]:\n            item['EndOfFile'] = size\n            item['AllocationSize'] = size\n            item['CreationTime'] = getFileTime(ctime)\n            item['LastAccessTime'] = getFileTime(atime)\n            item['LastWriteTime'] = getFileTime(mtime)\n            item['LastChangeTime'] = getFileTime(mtime)\n            item['FileName'] = os.path.basename(i).encode(encoding)\n            padLen = (8 - (len(item) % 8)) % 8\n            item['NextEntryOffset'] = len(item) + padLen\n        elif level in [smb.SMB_FIND_FILE_FULL_DIRECTORY_INFO, smb.SMB_FIND_FILE_ID_FULL_DIRECTORY_INFO,\n                       smb2.SMB2_FULL_DIRECTORY_INFO, smb2.SMB2_FILE_ID_FULL_DIRECTORY_INFO]:\n            item['EaSize'] = 0\n            item['EndOfFile'] = size\n            item['AllocationSize'] = size\n            item['CreationTime'] = getFileTime(ctime)\n            item['LastAccessTime'] = getFileTime(atime)\n            item['LastWriteTime'] = getFileTime(mtime)\n            item['LastChangeTime'] = getFileTime(mtime)\n            padLen = (8 - (len(item) % 8)) % 8\n            item['NextEntryOffset'] = len(item) + padLen\n        elif level == smb.SMB_FIND_INFO_STANDARD:\n            item['EaSize'] = size\n            item['CreationDate'] = getSMBDate(ctime)\n            item['CreationTime'] = getSMBTime(ctime)\n            item['LastAccessDate'] = getSMBDate(atime)\n            item['LastAccessTime'] = getSMBTime(atime)\n            item['LastWriteDate'] = getSMBDate(mtime)\n            item['LastWriteTime'] = getSMBTime(mtime)\n        searchResult.append(item)\n\n    # No more files\n    if (level >= smb.SMB_FIND_FILE_DIRECTORY_INFO or isSMB2 is True) and searchCount > 0:\n        searchResult[-1]['NextEntryOffset'] = 0\n\n    return searchResult, searchCount, errorCode",
  "def queryFileInformation(path, filename, level):\n    # print \"queryFileInfo path: %s, filename: %s, level:0x%x\" % (path,filename,level)\n    return queryPathInformation(path, filename, level)",
  "def queryPathInformation(path, filename, level):\n    # TODO: Depending on the level, this could be done much simpler\n    try:\n        errorCode = 0\n        fileName = normalize_path(filename, path)\n        pathName = os.path.join(path, fileName)\n\n        if not isInFileJail(path, fileName):\n            LOG.error(\"Path not in current working directory\")\n            return None, STATUS_OBJECT_PATH_SYNTAX_BAD\n\n        if os.path.exists(pathName):\n            (mode, ino, dev, nlink, uid, gid, size, atime, mtime, ctime) = os.stat(pathName)\n            if level == smb.SMB_QUERY_FILE_BASIC_INFO:\n                infoRecord = smb.SMBQueryFileBasicInfo()\n                infoRecord['CreationTime'] = getFileTime(ctime)\n                infoRecord['LastAccessTime'] = getFileTime(atime)\n                infoRecord['LastWriteTime'] = getFileTime(mtime)\n                infoRecord['LastChangeTime'] = getFileTime(mtime)\n                if os.path.isdir(pathName):\n                    infoRecord['ExtFileAttributes'] = smb.ATTR_DIRECTORY\n                else:\n                    infoRecord['ExtFileAttributes'] = smb.ATTR_NORMAL | smb.ATTR_ARCHIVE\n            elif level == smb.SMB_QUERY_FILE_STANDARD_INFO or level == smb2.SMB2_FILE_STANDARD_INFO:\n                infoRecord = smb.SMBQueryFileStandardInfo()\n                infoRecord['AllocationSize'] = size\n                infoRecord['EndOfFile'] = size\n                if os.path.isdir(pathName):\n                    infoRecord['Directory'] = 1\n                else:\n                    infoRecord['Directory'] = 0\n            elif level == smb.SMB_QUERY_FILE_ALL_INFO:\n                infoRecord = smb.SMBQueryFileAllInfo()\n                infoRecord['CreationTime'] = getFileTime(ctime)\n                infoRecord['LastAccessTime'] = getFileTime(atime)\n                infoRecord['LastWriteTime'] = getFileTime(mtime)\n                infoRecord['LastChangeTime'] = getFileTime(mtime)\n                if os.path.isdir(pathName):\n                    infoRecord['ExtFileAttributes'] = smb.ATTR_DIRECTORY\n                else:\n                    infoRecord['ExtFileAttributes'] = smb.ATTR_NORMAL | smb.ATTR_ARCHIVE\n                infoRecord['AllocationSize'] = size\n                infoRecord['EndOfFile'] = size\n                if os.path.isdir(pathName):\n                    infoRecord['Directory'] = 1\n                else:\n                    infoRecord['Directory'] = 0\n                infoRecord['FileName'] = filename.encode('utf-16le')\n            elif level == smb2.SMB2_FILE_ALL_INFO:\n                infoRecord = smb2.FILE_ALL_INFORMATION()\n                infoRecord['BasicInformation'] = smb2.FILE_BASIC_INFORMATION()\n                infoRecord['StandardInformation'] = smb2.FILE_STANDARD_INFORMATION()\n                infoRecord['InternalInformation'] = smb2.FILE_INTERNAL_INFORMATION()\n                infoRecord['EaInformation'] = smb2.FILE_EA_INFORMATION()\n                infoRecord['AccessInformation'] = smb2.FILE_ACCESS_INFORMATION()\n                infoRecord['PositionInformation'] = smb2.FILE_POSITION_INFORMATION()\n                infoRecord['ModeInformation'] = smb2.FILE_MODE_INFORMATION()\n                infoRecord['AlignmentInformation'] = smb2.FILE_ALIGNMENT_INFORMATION()\n                infoRecord['NameInformation'] = smb2.FILE_NAME_INFORMATION()\n                infoRecord['BasicInformation']['CreationTime'] = getFileTime(ctime)\n                infoRecord['BasicInformation']['LastAccessTime'] = getFileTime(atime)\n                infoRecord['BasicInformation']['LastWriteTime'] = getFileTime(mtime)\n                infoRecord['BasicInformation']['ChangeTime'] = getFileTime(mtime)\n                if os.path.isdir(pathName):\n                    infoRecord['BasicInformation']['FileAttributes'] = smb.SMB_FILE_ATTRIBUTE_DIRECTORY\n                    infoRecord['StandardInformation']['Directory'] = 1\n                    infoRecord['EaInformation']['EaSize'] = smb.ATTR_DIRECTORY\n                else:\n                    infoRecord['BasicInformation']['FileAttributes'] = smb.SMB_FILE_ATTRIBUTE_NORMAL | smb.SMB_FILE_ATTRIBUTE_ARCHIVE\n                    infoRecord['StandardInformation']['Directory'] = 0\n                    infoRecord['EaInformation']['EaSize'] = smb.ATTR_NORMAL | smb.ATTR_ARCHIVE\n                infoRecord['StandardInformation']['AllocationSize'] = size\n                infoRecord['StandardInformation']['EndOfFile'] = size\n                infoRecord['StandardInformation']['NumberOfLinks'] = nlink\n                infoRecord['StandardInformation']['DeletePending'] = 0\n                infoRecord['InternalInformation']['IndexNumber'] = ino\n                infoRecord['AccessInformation']['AccessFlags'] = 0 #\n                infoRecord['PositionInformation']['CurrentByteOffset'] = 0 #\n                infoRecord['ModeInformation']['mode'] = mode\n                infoRecord['AlignmentInformation']['AlignmentRequirement'] = 0 #\n                infoRecord['NameInformation']['FileName'] = fileName\n                infoRecord['NameInformation']['FileNameLength'] = len(fileName)\n            elif level == smb2.SMB2_FILE_NETWORK_OPEN_INFO:\n                infoRecord = smb.SMBFileNetworkOpenInfo()\n                infoRecord['CreationTime'] = getFileTime(ctime)\n                infoRecord['LastAccessTime'] = getFileTime(atime)\n                infoRecord['LastWriteTime'] = getFileTime(mtime)\n                infoRecord['ChangeTime'] = getFileTime(mtime)\n                infoRecord['AllocationSize'] = size\n                infoRecord['EndOfFile'] = size\n                if os.path.isdir(pathName):\n                    infoRecord['FileAttributes'] = smb.ATTR_DIRECTORY\n                else:\n                    infoRecord['FileAttributes'] = smb.ATTR_NORMAL | smb.ATTR_ARCHIVE\n            elif level == smb.SMB_QUERY_FILE_EA_INFO or level == smb2.SMB2_FILE_EA_INFO:\n                infoRecord = smb.SMBQueryFileEaInfo()\n            elif level == smb.SMB_QUERY_FILE_STREAM_INFO or level == smb2.SMB2_FILE_STREAM_INFO:\n                infoRecord = smb.SMBFileStreamInformation()\n            else:\n                LOG.error('Unknown level for query path info! 0x%x' % level)\n                # UNSUPPORTED\n                return None, STATUS_NOT_SUPPORTED\n\n            return infoRecord, errorCode\n        else:\n            # NOT FOUND\n            return None, STATUS_OBJECT_NAME_NOT_FOUND\n    except Exception as e:\n        LOG.error('queryPathInfo: %s' % e)\n        raise",
  "def queryDiskInformation(path):\n    # TODO: Do something useful here :)\n    # For now we just return fake values\n    totalUnits = 65535\n    freeUnits = 65535\n    return totalUnits, freeUnits",
  "class NTTRANSCommands:\n    def default(self, connId, smbServer, recvPacket, parameters, data, maxDataCount=0):\n        pass",
  "class TRANSCommands:\n    @staticmethod\n    def lanMan(connId, smbServer, recvPacket, parameters, data, maxDataCount=0):\n        # Minimal [MS-RAP] implementation, just to return the shares\n        connData = smbServer.getConnectionData(connId)\n\n        respSetup = b''\n        respParameters = b''\n        respData = b''\n        errorCode = STATUS_SUCCESS\n        if struct.unpack('<H', parameters[:2])[0] == 0:\n            # NetShareEnum Request\n            netShareEnum = smb.SMBNetShareEnum(parameters)\n            if netShareEnum['InfoLevel'] == 1:\n                shares = getShares(connId, smbServer)\n                respParameters = smb.SMBNetShareEnumResponse()\n                respParameters['EntriesReturned'] = len(shares)\n                respParameters['EntriesAvailable'] = len(shares)\n                tailData = ''\n                for i in shares:\n                    # NetShareInfo1 len == 20\n                    entry = smb.NetShareInfo1()\n                    entry['NetworkName'] = i + '\\x00' * (13 - len(i))\n                    entry['Type'] = int(shares[i]['share type'])\n                    # (beto) If offset == 0 it crashes explorer.exe on windows 7\n                    entry['RemarkOffsetLow'] = 20 * len(shares) + len(tailData)\n                    respData += entry.getData()\n                    if 'comment' in shares[i]:\n                        tailData += shares[i]['comment'] + '\\x00'\n                    else:\n                        tailData += '\\x00'\n                respData += tailData\n            else:\n                # We don't support other info levels\n                errorCode = STATUS_NOT_SUPPORTED\n        elif struct.unpack('<H', parameters[:2])[0] == 13:\n            # NetrServerGetInfo Request\n            respParameters = smb.SMBNetServerGetInfoResponse()\n            netServerInfo = smb.SMBNetServerInfo1()\n            netServerInfo['ServerName'] = smbServer.getServerName()\n            respData = netServerInfo.getData()\n            respParameters['TotalBytesAvailable'] = len(respData)\n        elif struct.unpack('<H', parameters[:2])[0] == 1:\n            # NetrShareGetInfo Request\n            request = smb.SMBNetShareGetInfo(parameters)\n            respParameters = smb.SMBNetShareGetInfoResponse()\n            shares = getShares(connId, smbServer)\n            share = shares[request['ShareName'].upper()]\n            shareInfo = smb.NetShareInfo1()\n            shareInfo['NetworkName'] = request['ShareName'].upper() + '\\x00'\n            shareInfo['Type'] = int(share['share type'])\n            respData = shareInfo.getData()\n            if 'comment' in share:\n                shareInfo['RemarkOffsetLow'] = len(respData)\n                respData += share['comment'] + '\\x00'\n            respParameters['TotalBytesAvailable'] = len(respData)\n\n        else:\n            # We don't know how to handle anything else\n            errorCode = STATUS_NOT_SUPPORTED\n\n        smbServer.setConnectionData(connId, connData)\n\n        return respSetup, respParameters, respData, errorCode\n\n    @staticmethod\n    def transactNamedPipe(connId, smbServer, recvPacket, parameters, data, maxDataCount=0):\n        connData = smbServer.getConnectionData(connId)\n\n        respSetup = b''\n        respParameters = b''\n        respData = b''\n        errorCode = STATUS_SUCCESS\n        SMBCommand = smb.SMBCommand(recvPacket['Data'][0])\n        transParameters = smb.SMBTransaction_Parameters(SMBCommand['Parameters'])\n\n        # Extract the FID\n        fid = struct.unpack('<H', transParameters['Setup'][2:])[0]\n\n        if fid in connData['OpenedFiles']:\n            fileHandle = connData['OpenedFiles'][fid]['FileHandle']\n            if fileHandle != PIPE_FILE_DESCRIPTOR:\n                os.write(fileHandle, data)\n                respData = os.read(fileHandle, data)\n            else:\n                sock = connData['OpenedFiles'][fid]['Socket']\n                sock.send(data)\n                respData = sock.recv(maxDataCount)\n        else:\n            errorCode = STATUS_INVALID_HANDLE\n\n        smbServer.setConnectionData(connId, connData)\n\n        return respSetup, respParameters, respData, errorCode",
  "class TRANS2Commands:\n    # All these commands return setup, parameters, data, errorCode\n    @staticmethod\n    def setPathInformation(connId, smbServer, recvPacket, parameters, data, maxDataCount=0):\n        connData = smbServer.getConnectionData(connId)\n\n        respSetup = b''\n        respParameters = b''\n        respData = b''\n        errorCode = STATUS_SUCCESS\n        setPathInfoParameters = smb.SMBSetPathInformation_Parameters(flags=recvPacket['Flags2'], data=parameters)\n        if recvPacket['Tid'] in connData['ConnectedShares']:\n            path = connData['ConnectedShares'][recvPacket['Tid']]['path']\n            fileName = normalize_path(decodeSMBString(recvPacket['Flags2'], setPathInfoParameters['FileName']), path)\n            pathName = os.path.join(path, fileName)\n\n            if isInFileJail(path, fileName):\n                smbServer.log(\"Path not in current working directory\")\n                errorCode = STATUS_OBJECT_PATH_SYNTAX_BAD\n\n            elif os.path.exists(pathName):\n                informationLevel = setPathInfoParameters['InformationLevel']\n                if informationLevel == smb.SMB_SET_FILE_BASIC_INFO:\n                    infoRecord = smb.SMBSetFileBasicInfo(data)\n                    # Creation time won't be set,  the other ones we play with.\n                    atime = infoRecord['LastAccessTime']\n                    if atime == 0:\n                        atime = -1\n                    else:\n                        atime = getUnixTime(atime)\n                    mtime = infoRecord['LastWriteTime']\n                    if mtime == 0:\n                        mtime = -1\n                    else:\n                        mtime = getUnixTime(mtime)\n                    if mtime != -1 or atime != -1:\n                        os.utime(pathName, (atime, mtime))\n                else:\n                    smbServer.log('Unknown level for set path info! 0x%x' % setPathInfoParameters['InformationLevel'],\n                                  logging.ERROR)\n                    # UNSUPPORTED\n                    errorCode = STATUS_NOT_SUPPORTED\n            else:\n                errorCode = STATUS_OBJECT_NAME_NOT_FOUND\n\n            if errorCode == STATUS_SUCCESS:\n                respParameters = smb.SMBSetPathInformationResponse_Parameters()\n\n        else:\n            errorCode = STATUS_SMB_BAD_TID\n\n        smbServer.setConnectionData(connId, connData)\n\n        return respSetup, respParameters, respData, errorCode\n\n    @staticmethod\n    def setFileInformation(connId, smbServer, recvPacket, parameters, data, maxDataCount=0):\n        connData = smbServer.getConnectionData(connId)\n\n        respSetup = b''\n        respParameters = b''\n        respData = b''\n        errorCode = STATUS_SUCCESS\n        setFileInfoParameters = smb.SMBSetFileInformation_Parameters(parameters)\n\n        if recvPacket['Tid'] in connData['ConnectedShares']:\n            if setFileInfoParameters['FID'] in connData['OpenedFiles']:\n                fileName = connData['OpenedFiles'][setFileInfoParameters['FID']]['FileName']\n                informationLevel = setFileInfoParameters['InformationLevel']\n                if informationLevel == smb.SMB_SET_FILE_DISPOSITION_INFO:\n                    infoRecord = smb.SMBSetFileDispositionInfo(parameters)\n                    if infoRecord['DeletePending'] > 0:\n                        # Mark this file for removal after closed\n                        connData['OpenedFiles'][setFileInfoParameters['FID']]['DeleteOnClose'] = True\n                        respParameters = smb.SMBSetFileInformationResponse_Parameters()\n                elif informationLevel == smb.SMB_SET_FILE_BASIC_INFO:\n                    infoRecord = smb.SMBSetFileBasicInfo(data)\n                    # Creation time won't be set,  the other ones we play with.\n                    atime = infoRecord['LastAccessTime']\n                    if atime == 0:\n                        atime = -1\n                    else:\n                        atime = getUnixTime(atime)\n                    mtime = infoRecord['LastWriteTime']\n                    if mtime == 0:\n                        mtime = -1\n                    else:\n                        mtime = getUnixTime(mtime)\n                    os.utime(fileName, (atime, mtime))\n                elif informationLevel == smb.SMB_SET_FILE_END_OF_FILE_INFO:\n                    fileHandle = connData['OpenedFiles'][setFileInfoParameters['FID']]['FileHandle']\n                    infoRecord = smb.SMBSetFileEndOfFileInfo(data)\n                    if infoRecord['EndOfFile'] > 0:\n                        os.lseek(fileHandle, infoRecord['EndOfFile'] - 1, 0)\n                        os.write(fileHandle, b'\\x00')\n                else:\n                    smbServer.log('Unknown level for set file info! 0x%x' % setFileInfoParameters['InformationLevel'],\n                                  logging.ERROR)\n                    # UNSUPPORTED\n                    errorCode = STATUS_NOT_SUPPORTED\n            else:\n                errorCode = STATUS_NO_SUCH_FILE\n\n            if errorCode == STATUS_SUCCESS:\n                respParameters = smb.SMBSetFileInformationResponse_Parameters()\n        else:\n            errorCode = STATUS_SMB_BAD_TID\n\n        smbServer.setConnectionData(connId, connData)\n\n        return respSetup, respParameters, respData, errorCode\n\n    @staticmethod\n    def queryFileInformation(connId, smbServer, recvPacket, parameters, data, maxDataCount=0):\n        connData = smbServer.getConnectionData(connId)\n\n        respSetup = b''\n        respParameters = b''\n        respData = b''\n\n        queryFileInfoParameters = smb.SMBQueryFileInformation_Parameters(parameters)\n\n        if recvPacket['Tid'] in connData['ConnectedShares']:\n            if queryFileInfoParameters['FID'] in connData['OpenedFiles']:\n                pathName = connData['OpenedFiles'][queryFileInfoParameters['FID']]['FileName']\n\n                infoRecord, errorCode = queryFileInformation(os.path.dirname(pathName), os.path.basename(pathName),\n                                                             queryFileInfoParameters['InformationLevel'])\n\n                if infoRecord is not None:\n                    respParameters = smb.SMBQueryFileInformationResponse_Parameters()\n                    respData = infoRecord\n            else:\n                errorCode = STATUS_INVALID_HANDLE\n        else:\n            errorCode = STATUS_SMB_BAD_TID\n\n        smbServer.setConnectionData(connId, connData)\n\n        return respSetup, respParameters, respData, errorCode\n\n    @staticmethod\n    def queryPathInformation(connId, smbServer, recvPacket, parameters, data, maxDataCount=0):\n        connData = smbServer.getConnectionData(connId)\n\n        respSetup = b''\n        respParameters = b''\n        respData = b''\n        errorCode = 0\n\n        queryPathInfoParameters = smb.SMBQueryPathInformation_Parameters(flags=recvPacket['Flags2'], data=parameters)\n\n        if recvPacket['Tid'] in connData['ConnectedShares']:\n            path = connData['ConnectedShares'][recvPacket['Tid']]['path']\n            try:\n                infoRecord, errorCode = queryPathInformation(path, decodeSMBString(recvPacket['Flags2'],\n                                                                                   queryPathInfoParameters['FileName']),\n                                                             queryPathInfoParameters['InformationLevel'])\n            except Exception as e:\n                smbServer.log(\"queryPathInformation: %s\" % e, logging.ERROR)\n\n            if infoRecord is not None:\n                respParameters = smb.SMBQueryPathInformationResponse_Parameters()\n                respData = infoRecord\n        else:\n            errorCode = STATUS_SMB_BAD_TID\n\n        smbServer.setConnectionData(connId, connData)\n\n        return respSetup, respParameters, respData, errorCode\n\n    @staticmethod\n    def queryFsInformation(connId, smbServer, recvPacket, parameters, data, maxDataCount=0):\n        connData = smbServer.getConnectionData(connId)\n        errorCode = 0\n        # Get the Tid associated\n        if recvPacket['Tid'] in connData['ConnectedShares']:\n            data = queryFsInformation(connData['ConnectedShares'][recvPacket['Tid']]['path'], '',\n                                      struct.unpack('<H', parameters)[0], pktFlags=recvPacket['Flags2'])\n\n        smbServer.setConnectionData(connId, connData)\n\n        return b'', b'', data, errorCode\n\n    @staticmethod\n    def findNext2(connId, smbServer, recvPacket, parameters, data, maxDataCount):\n        connData = smbServer.getConnectionData(connId)\n\n        respSetup = b''\n        respParameters = b''\n        respData = b''\n        errorCode = STATUS_SUCCESS\n        findNext2Parameters = smb.SMBFindNext2_Parameters(flags=recvPacket['Flags2'], data=parameters)\n\n        sid = findNext2Parameters['SID']\n        if recvPacket['Tid'] in connData['ConnectedShares']:\n            if sid in connData['SIDs']:\n                searchResult = connData['SIDs'][sid]\n                respParameters = smb.SMBFindNext2Response_Parameters()\n                endOfSearch = 1\n                searchCount = 1\n                totalData = 0\n                for i in enumerate(searchResult):\n                    data = i[1].getData()\n                    lenData = len(data)\n                    if (totalData + lenData) >= maxDataCount or (i[0] + 1) >= findNext2Parameters['SearchCount']:\n                        # We gotta stop here and continue on a find_next2\n                        endOfSearch = 0\n                        connData['SIDs'][sid] = searchResult[i[0]:]\n                        respParameters['LastNameOffset'] = totalData\n                        break\n                    else:\n                        searchCount += 1\n                        respData += data\n                        totalData += lenData\n\n                # Have we reached the end of the search or still stuff to send?\n                if endOfSearch > 0:\n                    # Let's remove the SID from our ConnData\n                    del (connData['SIDs'][sid])\n\n                respParameters['EndOfSearch'] = endOfSearch\n                respParameters['SearchCount'] = searchCount\n            else:\n                errorCode = STATUS_INVALID_HANDLE\n        else:\n            errorCode = STATUS_SMB_BAD_TID\n\n        smbServer.setConnectionData(connId, connData)\n\n        return respSetup, respParameters, respData, errorCode\n\n    @staticmethod\n    def findFirst2(connId, smbServer, recvPacket, parameters, data, maxDataCount):\n        connData = smbServer.getConnectionData(connId)\n\n        respSetup = b''\n        respParameters = b''\n        respData = b''\n        findFirst2Parameters = smb.SMBFindFirst2_Parameters(recvPacket['Flags2'], data=parameters)\n\n        if recvPacket['Tid'] in connData['ConnectedShares']:\n            path = connData['ConnectedShares'][recvPacket['Tid']]['path']\n\n            searchResult, searchCount, errorCode = findFirst2(path,\n                                                              decodeSMBString(recvPacket['Flags2'],\n                                                                              findFirst2Parameters['FileName']),\n                                                              findFirst2Parameters['InformationLevel'],\n                                                              findFirst2Parameters['SearchAttributes'],\n                                                              pktFlags=recvPacket['Flags2'])\n\n            if searchCount > 0:\n                respParameters = smb.SMBFindFirst2Response_Parameters()\n                endOfSearch = 1\n                sid = 0x80  # default SID\n                searchCount = 0\n                totalData = 0\n                for i in enumerate(searchResult):\n                    # i[1].dump()\n                    data = i[1].getData()\n                    lenData = len(data)\n                    if (totalData + lenData) >= maxDataCount or (i[0] + 1) > findFirst2Parameters['SearchCount']:\n                        # We gotta stop here and continue on a find_next2\n                        endOfSearch = 0\n                        # Simple way to generate a fid\n                        if len(connData['SIDs']) == 0:\n                            sid = 1\n                        else:\n                            sid = list(connData['SIDs'].keys())[-1] + 1\n                        # Store the remaining search results in the ConnData SID\n                        connData['SIDs'][sid] = searchResult[i[0]:]\n                        respParameters['LastNameOffset'] = totalData\n                        break\n                    else:\n                        searchCount += 1\n                        respData += data\n\n                        padLen = (8 - (lenData % 8)) % 8\n                        respData += b'\\xaa' * padLen\n                        totalData += lenData + padLen\n\n                respParameters['SID'] = sid\n                respParameters['EndOfSearch'] = endOfSearch\n                respParameters['SearchCount'] = searchCount\n\n            # If we've empty files and errorCode was not already set, we return NO_SUCH_FILE\n            elif errorCode == 0:\n                errorCode = STATUS_NO_SUCH_FILE\n        else:\n            errorCode = STATUS_SMB_BAD_TID\n\n        smbServer.setConnectionData(connId, connData)\n\n        return respSetup, respParameters, respData, errorCode",
  "class SMBCommands:\n\n    @staticmethod\n    def smbTransaction(connId, smbServer, SMBCommand, recvPacket, transCommands):\n        connData = smbServer.getConnectionData(connId)\n\n        respSMBCommand = smb.SMBCommand(recvPacket['Command'])\n\n        transParameters = smb.SMBTransaction_Parameters(SMBCommand['Parameters'])\n\n        # Do the stuff\n        if transParameters['ParameterCount'] != transParameters['TotalParameterCount']:\n            # TODO: Handle partial parameters\n            raise Exception(\"Unsupported partial parameters in TRANSACT2!\")\n        else:\n            transData = smb.SMBTransaction_SData(flags=recvPacket['Flags2'])\n            # Standard says servers shouldn't trust Parameters and Data comes\n            # in order, so we have to parse the offsets, ugly\n\n            paramCount = transParameters['ParameterCount']\n            transData['Trans_ParametersLength'] = paramCount\n            dataCount = transParameters['DataCount']\n            transData['Trans_DataLength'] = dataCount\n            transData.fromString(SMBCommand['Data'])\n            if transParameters['ParameterOffset'] > 0:\n                paramOffset = transParameters['ParameterOffset'] - 63 - transParameters['SetupLength']\n                transData['Trans_Parameters'] = SMBCommand['Data'][paramOffset:paramOffset + paramCount]\n            else:\n                transData['Trans_Parameters'] = b''\n\n            if transParameters['DataOffset'] > 0:\n                dataOffset = transParameters['DataOffset'] - 63 - transParameters['SetupLength']\n                transData['Trans_Data'] = SMBCommand['Data'][dataOffset:dataOffset + dataCount]\n            else:\n                transData['Trans_Data'] = b''\n\n            # Call the handler for this TRANSACTION\n            if transParameters['SetupCount'] == 0:\n                # No subcommand, let's play with the Name\n                command = decodeSMBString(recvPacket['Flags2'], transData['Name'])\n            else:\n                command = struct.unpack('<H', transParameters['Setup'][:2])[0]\n\n            if command in transCommands:\n                # Call the TRANS subcommand\n                setup = b''\n                parameters = b''\n                data = b''\n                try:\n                    setup, parameters, data, errorCode = transCommands[command](connId,\n                                                                                smbServer,\n                                                                                recvPacket,\n                                                                                transData['Trans_Parameters'],\n                                                                                transData['Trans_Data'],\n                                                                                transParameters['MaxDataCount'])\n                except Exception as e:\n                    # print 'Transaction: %s' % e,e\n                    smbServer.log('Transaction: (%r,%s)' % (command, e), logging.ERROR)\n                    errorCode = STATUS_ACCESS_DENIED\n                    # raise\n\n                if setup == b'' and parameters == b'' and data == b'':\n                    # Something wen't wrong\n                    respParameters = b''\n                    respData = b''\n                else:\n                    # Build the answer\n                    if hasattr(data, 'getData'):\n                        data = data.getData()\n                    remainingData = len(data)\n                    if hasattr(parameters, 'getData'):\n                        parameters = parameters.getData()\n                    remainingParameters = len(parameters)\n                    commands = []\n                    dataDisplacement = 0\n                    while remainingData > 0 or remainingParameters > 0:\n                        respSMBCommand = smb.SMBCommand(recvPacket['Command'])\n                        respParameters = smb.SMBTransactionResponse_Parameters()\n                        respData = smb.SMBTransaction2Response_Data()\n\n                        respParameters['TotalParameterCount'] = len(parameters)\n                        respParameters['ParameterCount'] = len(parameters)\n                        respData['Trans_ParametersLength'] = len(parameters)\n                        respParameters['TotalDataCount'] = len(data)\n                        respParameters['DataDisplacement'] = dataDisplacement\n\n                        # TODO: Do the same for parameters\n                        if len(data) > transParameters['MaxDataCount']:\n                            # Answer doesn't fit in this packet\n                            LOG.debug(\"Lowering answer from %d to %d\" % (len(data), transParameters['MaxDataCount']))\n                            respParameters['DataCount'] = transParameters['MaxDataCount']\n                        else:\n                            respParameters['DataCount'] = len(data)\n\n                        respData['Trans_DataLength'] = respParameters['DataCount']\n                        respParameters['SetupCount'] = len(setup)\n                        respParameters['Setup'] = setup\n                        # TODO: Make sure we're calculating the pad right\n                        if len(parameters) > 0:\n                            # padLen = 4 - (55 + len(setup)) % 4\n                            padLen = (4 - (55 + len(setup)) % 4) % 4\n                            padBytes = b'\\xFF' * padLen\n                            respData['Pad1'] = padBytes\n                            respParameters['ParameterOffset'] = 55 + len(setup) + padLen\n                        else:\n                            padLen = 0\n                            respParameters['ParameterOffset'] = 0\n                            respData['Pad1'] = b''\n\n                        if len(data) > 0:\n                            # pad2Len = 4 - (55 + len(setup) + padLen + len(parameters)) % 4\n                            pad2Len = (4 - (55 + len(setup) + padLen + len(parameters)) % 4) % 4\n                            respData['Pad2'] = b'\\xFF' * pad2Len\n                            respParameters['DataOffset'] = 55 + len(setup) + padLen + len(parameters) + pad2Len\n                        else:\n                            respParameters['DataOffset'] = 0\n                            respData['Pad2'] = b''\n\n                        respData['Trans_Parameters'] = parameters[:respParameters['ParameterCount']]\n                        respData['Trans_Data'] = data[:respParameters['DataCount']]\n                        respSMBCommand['Parameters'] = respParameters\n                        respSMBCommand['Data'] = respData\n\n                        data = data[respParameters['DataCount']:]\n                        remainingData -= respParameters['DataCount']\n                        dataDisplacement += respParameters['DataCount'] + 1\n\n                        parameters = parameters[respParameters['ParameterCount']:]\n                        remainingParameters -= respParameters['ParameterCount']\n                        commands.append(respSMBCommand)\n\n                    smbServer.setConnectionData(connId, connData)\n                    return commands, None, errorCode\n\n            else:\n                smbServer.log(\"Unsupported Transact command %r\" % command, logging.ERROR)\n                respParameters = b''\n                respData = b''\n                errorCode = STATUS_NOT_IMPLEMENTED\n\n        respSMBCommand['Parameters'] = respParameters\n        respSMBCommand['Data'] = respData\n        smbServer.setConnectionData(connId, connData)\n\n        return [respSMBCommand], None, errorCode\n\n    @staticmethod\n    def smbNTTransact(connId, smbServer, SMBCommand, recvPacket, transCommands):\n        connData = smbServer.getConnectionData(connId)\n\n        respSMBCommand = smb.SMBCommand(recvPacket['Command'])\n\n        NTTransParameters = smb.SMBNTTransaction_Parameters(SMBCommand['Parameters'])\n        # Do the stuff\n        if NTTransParameters['ParameterCount'] != NTTransParameters['TotalParameterCount']:\n            # TODO: Handle partial parameters\n            raise Exception(\"Unsupported partial parameters in NTTrans!\")\n        else:\n            NTTransData = smb.SMBNTTransaction_Data()\n            # Standard says servers shouldn't trust Parameters and Data comes\n            # in order, so we have to parse the offsets, ugly\n\n            paramCount = NTTransParameters['ParameterCount']\n            NTTransData['NT_Trans_ParametersLength'] = paramCount\n            dataCount = NTTransParameters['DataCount']\n            NTTransData['NT_Trans_DataLength'] = dataCount\n\n            if NTTransParameters['ParameterOffset'] > 0:\n                paramOffset = NTTransParameters['ParameterOffset'] - 73 - NTTransParameters['SetupLength']\n                NTTransData['NT_Trans_Parameters'] = SMBCommand['Data'][paramOffset:paramOffset + paramCount]\n            else:\n                NTTransData['NT_Trans_Parameters'] = b''\n\n            if NTTransParameters['DataOffset'] > 0:\n                dataOffset = NTTransParameters['DataOffset'] - 73 - NTTransParameters['SetupLength']\n                NTTransData['NT_Trans_Data'] = SMBCommand['Data'][dataOffset:dataOffset + dataCount]\n            else:\n                NTTransData['NT_Trans_Data'] = b''\n\n            # Call the handler for this TRANSACTION\n            command = NTTransParameters['Function']\n            if command in transCommands:\n                # Call the NT TRANS subcommand\n                setup = b''\n                parameters = b''\n                data = b''\n                try:\n                    setup, parameters, data, errorCode = transCommands[command](connId,\n                                                                                smbServer,\n                                                                                recvPacket,\n                                                                                NTTransData['NT_Trans_Parameters'],\n                                                                                NTTransData['NT_Trans_Data'],\n                                                                                NTTransParameters['MaxDataCount'])\n                except Exception as e:\n                    smbServer.log('NTTransaction: (0x%x,%s)' % (command, e), logging.ERROR)\n                    errorCode = STATUS_ACCESS_DENIED\n                    # raise\n\n                if setup == b'' and parameters == b'' and data == b'':\n                    # Something wen't wrong\n                    respParameters = b''\n                    respData = b''\n                    if errorCode == STATUS_SUCCESS:\n                        errorCode = STATUS_ACCESS_DENIED\n                else:\n                    # Build the answer\n                    if hasattr(data, 'getData'):\n                        data = data.getData()\n                    remainingData = len(data)\n                    if hasattr(parameters, 'getData'):\n                        parameters = parameters.getData()\n                    remainingParameters = len(parameters)\n                    commands = []\n                    dataDisplacement = 0\n                    while remainingData > 0 or remainingParameters > 0:\n                        respSMBCommand = smb.SMBCommand(recvPacket['Command'])\n                        respParameters = smb.SMBNTTransactionResponse_Parameters()\n                        respData = smb.SMBNTTransactionResponse_Data()\n\n                        respParameters['TotalParameterCount'] = len(parameters)\n                        respParameters['ParameterCount'] = len(parameters)\n                        respData['Trans_ParametersLength'] = len(parameters)\n                        respParameters['TotalDataCount'] = len(data)\n                        respParameters['DataDisplacement'] = dataDisplacement\n                        # TODO: Do the same for parameters\n                        if len(data) > NTTransParameters['MaxDataCount']:\n                            # Answer doesn't fit in this packet\n                            LOG.debug(\"Lowering answer from %d to %d\" % (len(data), NTTransParameters['MaxDataCount']))\n                            respParameters['DataCount'] = NTTransParameters['MaxDataCount']\n                        else:\n                            respParameters['DataCount'] = len(data)\n\n                        respData['NT_Trans_DataLength'] = respParameters['DataCount']\n                        respParameters['SetupCount'] = len(setup)\n                        respParameters['Setup'] = setup\n                        # TODO: Make sure we're calculating the pad right\n                        if len(parameters) > 0:\n                            # padLen = 4 - (71 + len(setup)) % 4\n                            padLen = (4 - (73 + len(setup)) % 4) % 4\n                            padBytes = b'\\xFF' * padLen\n                            respData['Pad1'] = padBytes\n                            respParameters['ParameterOffset'] = 73 + len(setup) + padLen\n                        else:\n                            padLen = 0\n                            respParameters['ParameterOffset'] = 0\n                            respData['Pad1'] = b''\n\n                        if len(data) > 0:\n                            # pad2Len = 4 - (71 + len(setup) + padLen + len(parameters)) % 4\n                            pad2Len = (4 - (73 + len(setup) + padLen + len(parameters)) % 4) % 4\n                            respData['Pad2'] = b'\\xFF' * pad2Len\n                            respParameters['DataOffset'] = 73 + len(setup) + padLen + len(parameters) + pad2Len\n                        else:\n                            respParameters['DataOffset'] = 0\n                            respData['Pad2'] = b''\n\n                        respData['NT_Trans_Parameters'] = parameters[:respParameters['ParameterCount']]\n                        respData['NT_Trans_Data'] = data[:respParameters['DataCount']]\n                        respSMBCommand['Parameters'] = respParameters\n                        respSMBCommand['Data'] = respData\n\n                        data = data[respParameters['DataCount']:]\n                        remainingData -= respParameters['DataCount']\n                        dataDisplacement += respParameters['DataCount'] + 1\n\n                        parameters = parameters[respParameters['ParameterCount']:]\n                        remainingParameters -= respParameters['ParameterCount']\n                        commands.append(respSMBCommand)\n\n                    smbServer.setConnectionData(connId, connData)\n                    return commands, None, errorCode\n\n            else:\n                # smbServer.log(\"Unsupported NTTransact command 0x%x\" % command, logging.ERROR)\n                respParameters = b''\n                respData = b''\n                errorCode = STATUS_NOT_IMPLEMENTED\n\n        respSMBCommand['Parameters'] = respParameters\n        respSMBCommand['Data'] = respData\n\n        smbServer.setConnectionData(connId, connData)\n        return [respSMBCommand], None, errorCode\n\n    @staticmethod\n    def smbTransaction2(connId, smbServer, SMBCommand, recvPacket, transCommands):\n        connData = smbServer.getConnectionData(connId)\n\n        respSMBCommand = smb.SMBCommand(recvPacket['Command'])\n\n        trans2Parameters = smb.SMBTransaction2_Parameters(SMBCommand['Parameters'])\n\n        # Do the stuff\n        if trans2Parameters['ParameterCount'] != trans2Parameters['TotalParameterCount']:\n            # TODO: Handle partial parameters\n            # print \"Unsupported partial parameters in TRANSACT2!\"\n            raise Exception(\"Unsupported partial parameters in TRANSACT2!\")\n        else:\n            trans2Data = smb.SMBTransaction2_Data()\n            # Standard says servers shouldn't trust Parameters and Data comes\n            # in order, so we have to parse the offsets, ugly\n\n            paramCount = trans2Parameters['ParameterCount']\n            trans2Data['Trans_ParametersLength'] = paramCount\n            dataCount = trans2Parameters['DataCount']\n            trans2Data['Trans_DataLength'] = dataCount\n\n            if trans2Parameters['ParameterOffset'] > 0:\n                paramOffset = trans2Parameters['ParameterOffset'] - 63 - trans2Parameters['SetupLength']\n                trans2Data['Trans_Parameters'] = SMBCommand['Data'][paramOffset:paramOffset + paramCount]\n            else:\n                trans2Data['Trans_Parameters'] = b''\n\n            if trans2Parameters['DataOffset'] > 0:\n                dataOffset = trans2Parameters['DataOffset'] - 63 - trans2Parameters['SetupLength']\n                trans2Data['Trans_Data'] = SMBCommand['Data'][dataOffset:dataOffset + dataCount]\n            else:\n                trans2Data['Trans_Data'] = b''\n\n            # Call the handler for this TRANSACTION\n            command = struct.unpack('<H', trans2Parameters['Setup'])[0]\n            if command in transCommands:\n                # Call the TRANS2 subcommand\n                try:\n                    setup, parameters, data, errorCode = transCommands[command](connId,\n                                                                                smbServer,\n                                                                                recvPacket,\n                                                                                trans2Data['Trans_Parameters'],\n                                                                                trans2Data['Trans_Data'],\n                                                                                trans2Parameters['MaxDataCount'])\n                except Exception as e:\n                    smbServer.log('Transaction2: (0x%x,%s)' % (command, e), logging.ERROR)\n                    # import traceback\n                    # traceback.print_exc()\n                    raise\n\n                if setup == b'' and parameters == b'' and data == b'':\n                    # Something wen't wrong\n                    respParameters = b''\n                    respData = b''\n                else:\n                    # Build the answer\n                    if hasattr(data, 'getData'):\n                        data = data.getData()\n                    remainingData = len(data)\n                    if hasattr(parameters, 'getData'):\n                        parameters = parameters.getData()\n                    remainingParameters = len(parameters)\n                    commands = []\n                    dataDisplacement = 0\n                    while remainingData > 0 or remainingParameters > 0:\n                        respSMBCommand = smb.SMBCommand(recvPacket['Command'])\n                        respParameters = smb.SMBTransaction2Response_Parameters()\n                        respData = smb.SMBTransaction2Response_Data()\n\n                        respParameters['TotalParameterCount'] = len(parameters)\n                        respParameters['ParameterCount'] = len(parameters)\n                        respData['Trans_ParametersLength'] = len(parameters)\n                        respParameters['TotalDataCount'] = len(data)\n                        respParameters['DataDisplacement'] = dataDisplacement\n                        # TODO: Do the same for parameters\n                        if len(data) > trans2Parameters['MaxDataCount']:\n                            # Answer doesn't fit in this packet\n                            LOG.debug(\"Lowering answer from %d to %d\" % (len(data), trans2Parameters['MaxDataCount']))\n                            respParameters['DataCount'] = trans2Parameters['MaxDataCount']\n                        else:\n                            respParameters['DataCount'] = len(data)\n\n                        respData['Trans_DataLength'] = respParameters['DataCount']\n                        respParameters['SetupCount'] = len(setup)\n                        respParameters['Setup'] = setup\n                        # TODO: Make sure we're calculating the pad right\n                        if len(parameters) > 0:\n                            # padLen = 4 - (55 + len(setup)) % 4\n                            padLen = (4 - (55 + len(setup)) % 4) % 4\n                            padBytes = b'\\xFF' * padLen\n                            respData['Pad1'] = padBytes\n                            respParameters['ParameterOffset'] = 55 + len(setup) + padLen\n                        else:\n                            padLen = 0\n                            respParameters['ParameterOffset'] = 0\n                            respData['Pad1'] = b''\n\n                        if len(data) > 0:\n                            # pad2Len = 4 - (55 + len(setup) + padLen + len(parameters)) % 4\n                            pad2Len = (4 - (55 + len(setup) + padLen + len(parameters)) % 4) % 4\n                            respData['Pad2'] = b'\\xFF' * pad2Len\n                            respParameters['DataOffset'] = 55 + len(setup) + padLen + len(parameters) + pad2Len\n                        else:\n                            respParameters['DataOffset'] = 0\n                            respData['Pad2'] = b''\n\n                        respData['Trans_Parameters'] = parameters[:respParameters['ParameterCount']]\n                        respData['Trans_Data'] = data[:respParameters['DataCount']]\n                        respSMBCommand['Parameters'] = respParameters\n                        respSMBCommand['Data'] = respData\n\n                        data = data[respParameters['DataCount']:]\n                        remainingData -= respParameters['DataCount']\n                        dataDisplacement += respParameters['DataCount'] + 1\n\n                        parameters = parameters[respParameters['ParameterCount']:]\n                        remainingParameters -= respParameters['ParameterCount']\n                        commands.append(respSMBCommand)\n\n                    smbServer.setConnectionData(connId, connData)\n                    return commands, None, errorCode\n\n            else:\n                smbServer.log(\"Unsupported Transact/2 command 0x%x\" % command, logging.ERROR)\n                respParameters = b''\n                respData = b''\n                errorCode = STATUS_NOT_IMPLEMENTED\n\n        respSMBCommand['Parameters'] = respParameters\n        respSMBCommand['Data'] = respData\n\n        smbServer.setConnectionData(connId, connData)\n        return [respSMBCommand], None, errorCode\n\n    @staticmethod\n    def smbComLockingAndX(connId, smbServer, SMBCommand, recvPacket):\n        connData = smbServer.getConnectionData(connId)\n\n        respSMBCommand = smb.SMBCommand(smb.SMB.SMB_COM_LOCKING_ANDX)\n        respParameters = b''\n        respData = b''\n\n        # I'm actually doing nothing.. just make MacOS happy ;)\n        errorCode = STATUS_SUCCESS\n\n        respSMBCommand['Parameters'] = respParameters\n        respSMBCommand['Data'] = respData\n        smbServer.setConnectionData(connId, connData)\n\n        return [respSMBCommand], None, errorCode\n\n    @staticmethod\n    def smbComClose(connId, smbServer, SMBCommand, recvPacket):\n        connData = smbServer.getConnectionData(connId)\n\n        respSMBCommand = smb.SMBCommand(smb.SMB.SMB_COM_CLOSE)\n        respParameters = b''\n        respData = b''\n\n        comClose = smb.SMBClose_Parameters(SMBCommand['Parameters'])\n\n        # Get the Tid associated\n        if recvPacket['Tid'] in connData['ConnectedShares']:\n            if comClose['FID'] in connData['OpenedFiles']:\n                errorCode = STATUS_SUCCESS\n                fileHandle = connData['OpenedFiles'][comClose['FID']]['FileHandle']\n                try:\n                    if fileHandle == PIPE_FILE_DESCRIPTOR:\n                        connData['OpenedFiles'][comClose['FID']]['Socket'].close()\n                    elif fileHandle != VOID_FILE_DESCRIPTOR:\n                        os.close(fileHandle)\n                except Exception as e:\n                    smbServer.log(\"comClose %s\" % e, logging.ERROR)\n                    errorCode = STATUS_ACCESS_DENIED\n                else:\n                    # Check if the file was marked for removal\n                    if connData['OpenedFiles'][comClose['FID']]['DeleteOnClose'] is True:\n                        try:\n                            os.remove(connData['OpenedFiles'][comClose['FID']]['FileName'])\n                        except Exception as e:\n                            smbServer.log(\"comClose %s\" % e, logging.ERROR)\n                            errorCode = STATUS_ACCESS_DENIED\n                    del (connData['OpenedFiles'][comClose['FID']])\n            else:\n                errorCode = STATUS_INVALID_HANDLE\n        else:\n            errorCode = STATUS_SMB_BAD_TID\n\n        if errorCode > 0:\n            respParameters = b''\n            respData = b''\n\n        respSMBCommand['Parameters'] = respParameters\n        respSMBCommand['Data'] = respData\n        smbServer.setConnectionData(connId, connData)\n\n        return [respSMBCommand], None, errorCode\n\n    @staticmethod\n    def smbComWrite(connId, smbServer, SMBCommand, recvPacket):\n        connData = smbServer.getConnectionData(connId)\n\n        respSMBCommand = smb.SMBCommand(smb.SMB.SMB_COM_WRITE)\n        respParameters = smb.SMBWriteResponse_Parameters()\n        respData = b''\n\n        comWriteParameters = smb.SMBWrite_Parameters(SMBCommand['Parameters'])\n        comWriteData = smb.SMBWrite_Data(SMBCommand['Data'])\n\n        # Get the Tid associated\n        if recvPacket['Tid'] in connData['ConnectedShares']:\n            if comWriteParameters['Fid'] in connData['OpenedFiles']:\n                fileHandle = connData['OpenedFiles'][comWriteParameters['Fid']]['FileHandle']\n                errorCode = STATUS_SUCCESS\n                try:\n                    if fileHandle != PIPE_FILE_DESCRIPTOR:\n                        # TODO: Handle big size files\n                        # If we're trying to write past the file end we just skip the write call (Vista does this)\n                        if os.lseek(fileHandle, 0, 2) >= comWriteParameters['Offset']:\n                            os.lseek(fileHandle, comWriteParameters['Offset'], 0)\n                            os.write(fileHandle, comWriteData['Data'])\n                    else:\n                        sock = connData['OpenedFiles'][comWriteParameters['Fid']]['Socket']\n                        sock.send(comWriteData['Data'])\n                    respParameters['Count'] = comWriteParameters['Count']\n                except Exception as e:\n                    smbServer.log('smbComWrite: %s' % e, logging.ERROR)\n                    errorCode = STATUS_ACCESS_DENIED\n            else:\n                errorCode = STATUS_INVALID_HANDLE\n        else:\n            errorCode = STATUS_SMB_BAD_TID\n\n        if errorCode > 0:\n            respParameters = b''\n            respData = b''\n\n        respSMBCommand['Parameters'] = respParameters\n        respSMBCommand['Data'] = respData\n        smbServer.setConnectionData(connId, connData)\n\n        return [respSMBCommand], None, errorCode\n\n    @staticmethod\n    def smbComFlush(connId, smbServer, SMBCommand, recvPacket):\n        connData = smbServer.getConnectionData(connId)\n\n        respSMBCommand = smb.SMBCommand(smb.SMB.SMB_COM_FLUSH)\n        respParameters = b''\n        respData = b''\n\n        comFlush = smb.SMBFlush_Parameters(SMBCommand['Parameters'])\n\n        # Get the Tid associated\n        if recvPacket['Tid'] in connData['ConnectedShares']:\n            if comFlush['FID'] in connData['OpenedFiles']:\n                errorCode = STATUS_SUCCESS\n                fileHandle = connData['OpenedFiles'][comFlush['FID']]['FileHandle']\n                try:\n                    os.fsync(fileHandle)\n                except Exception as e:\n                    smbServer.log(\"comFlush %s\" % e, logging.ERROR)\n                    errorCode = STATUS_ACCESS_DENIED\n            else:\n                errorCode = STATUS_INVALID_HANDLE\n        else:\n            errorCode = STATUS_SMB_BAD_TID\n\n        if errorCode > 0:\n            respParameters = b''\n            respData = b''\n\n        respSMBCommand['Parameters'] = respParameters\n        respSMBCommand['Data'] = respData\n        smbServer.setConnectionData(connId, connData)\n\n        return [respSMBCommand], None, errorCode\n\n    @staticmethod\n    def smbComCreateDirectory(connId, smbServer, SMBCommand, recvPacket):\n        connData = smbServer.getConnectionData(connId)\n\n        respSMBCommand = smb.SMBCommand(smb.SMB.SMB_COM_CREATE_DIRECTORY)\n        respParameters = b''\n        respData = b''\n\n        comCreateDirectoryData = smb.SMBCreateDirectory_Data(flags=recvPacket['Flags2'], data=SMBCommand['Data'])\n\n        # Get the Tid associated\n        if recvPacket['Tid'] in connData['ConnectedShares']:\n            errorCode = STATUS_SUCCESS\n            path = connData['ConnectedShares'][recvPacket['Tid']]['path']\n            fileName = normalize_path(decodeSMBString(recvPacket['Flags2'], comCreateDirectoryData['DirectoryName']))\n            pathName = os.path.join(path, fileName)\n\n            if not isInFileJail(path, fileName):\n                smbServer.log(\"Path not in current working directory\", logging.ERROR)\n                errorCode = STATUS_OBJECT_PATH_SYNTAX_BAD\n\n            elif os.path.exists(pathName):\n                errorCode = STATUS_OBJECT_NAME_COLLISION\n\n            else:\n                try:\n                    os.mkdir(pathName)\n                except Exception as e:\n                    smbServer.log(\"smbComCreateDirectory: %s\" % e, logging.ERROR)\n                    errorCode = STATUS_ACCESS_DENIED\n        else:\n            errorCode = STATUS_SMB_BAD_TID\n\n        if errorCode > 0:\n            respParameters = b''\n            respData = b''\n\n        respSMBCommand['Parameters'] = respParameters\n        respSMBCommand['Data'] = respData\n        smbServer.setConnectionData(connId, connData)\n\n        return [respSMBCommand], None, errorCode\n\n    @staticmethod\n    def smbComRename(connId, smbServer, SMBCommand, recvPacket):\n        connData = smbServer.getConnectionData(connId)\n\n        respSMBCommand = smb.SMBCommand(smb.SMB.SMB_COM_RENAME)\n        respParameters = b''\n        respData = b''\n\n        comRenameData = smb.SMBRename_Data(flags=recvPacket['Flags2'], data=SMBCommand['Data'])\n\n        # Get the Tid associated\n        if recvPacket['Tid'] in connData['ConnectedShares']:\n            errorCode = STATUS_SUCCESS\n            path = connData['ConnectedShares'][recvPacket['Tid']]['path']\n            oldFileName = normalize_path(decodeSMBString(recvPacket['Flags2'], comRenameData['OldFileName']))\n            oldPathName = os.path.join(path, oldFileName)\n            newFileName = normalize_path(decodeSMBString(recvPacket['Flags2'], comRenameData['NewFileName']))\n            newPathName = os.path.join(path, newFileName)\n\n            if not isInFileJail(path, oldFileName) or not isInFileJail(path, newFileName):\n                smbServer.log(\"Path not in current working directory\", logging.ERROR)\n                errorCode = STATUS_OBJECT_PATH_SYNTAX_BAD\n\n            elif not os.path.exists(oldPathName):\n                errorCode = STATUS_NO_SUCH_FILE\n\n            else:\n                try:\n                    os.rename(oldPathName, newPathName)\n                except OSError as e:\n                    smbServer.log(\"smbComRename: %s\" % e, logging.ERROR)\n                    errorCode = STATUS_ACCESS_DENIED\n        else:\n            errorCode = STATUS_SMB_BAD_TID\n\n        if errorCode > 0:\n            respParameters = b''\n            respData = b''\n\n        respSMBCommand['Parameters'] = respParameters\n        respSMBCommand['Data'] = respData\n        smbServer.setConnectionData(connId, connData)\n\n        return [respSMBCommand], None, errorCode\n\n    @staticmethod\n    def smbComDelete(connId, smbServer, SMBCommand, recvPacket):\n        connData = smbServer.getConnectionData(connId)\n\n        respSMBCommand = smb.SMBCommand(smb.SMB.SMB_COM_DELETE)\n        respParameters = b''\n        respData = b''\n\n        comDeleteData = smb.SMBDelete_Data(flags=recvPacket['Flags2'], data=SMBCommand['Data'])\n\n        # Get the Tid associated\n        if recvPacket['Tid'] in connData['ConnectedShares']:\n            errorCode = STATUS_SUCCESS\n            path = connData['ConnectedShares'][recvPacket['Tid']]['path']\n            fileName = normalize_path(decodeSMBString(recvPacket['Flags2'], comDeleteData['FileName']))\n            pathName = os.path.join(path, fileName)\n\n            if not isInFileJail(path, fileName):\n                smbServer.log(\"Path not in current working directory\", logging.ERROR)\n                errorCode = STATUS_OBJECT_PATH_SYNTAX_BAD\n\n            elif not os.path.exists(pathName):\n                errorCode = STATUS_NO_SUCH_FILE\n\n            else:\n                try:\n                    os.remove(pathName)\n                except OSError as e:\n                    smbServer.log(\"smbComDelete: %s\" % e, logging.ERROR)\n                    errorCode = STATUS_ACCESS_DENIED\n        else:\n            errorCode = STATUS_SMB_BAD_TID\n\n        if errorCode > 0:\n            respParameters = b''\n            respData = b''\n\n        respSMBCommand['Parameters'] = respParameters\n        respSMBCommand['Data'] = respData\n        smbServer.setConnectionData(connId, connData)\n\n        return [respSMBCommand], None, errorCode\n\n    @staticmethod\n    def smbComDeleteDirectory(connId, smbServer, SMBCommand, recvPacket):\n        connData = smbServer.getConnectionData(connId)\n\n        respSMBCommand = smb.SMBCommand(smb.SMB.SMB_COM_DELETE_DIRECTORY)\n        respParameters = b''\n        respData = b''\n\n        comDeleteDirectoryData = smb.SMBDeleteDirectory_Data(flags=recvPacket['Flags2'], data=SMBCommand['Data'])\n\n        # Get the Tid associated\n        if recvPacket['Tid'] in connData['ConnectedShares']:\n            errorCode = STATUS_SUCCESS\n            path = connData['ConnectedShares'][recvPacket['Tid']]['path']\n            fileName = normalize_path(decodeSMBString(recvPacket['Flags2'], comDeleteDirectoryData['DirectoryName']))\n            pathName = os.path.join(path, fileName)\n\n            if not isInFileJail(path, fileName):\n                smbServer.log(\"Path not in current working directory\", logging.ERROR)\n                errorCode = STATUS_OBJECT_PATH_SYNTAX_BAD\n\n            if os.path.exists(pathName) is not True:\n                errorCode = STATUS_NO_SUCH_FILE\n\n            else:\n                try:\n                    os.rmdir(pathName)\n                except OSError as e:\n                    smbServer.log(\"smbComDeleteDirectory: %s\" % e, logging.ERROR)\n                    if e.errno == errno.ENOTEMPTY:\n                        errorCode = STATUS_DIRECTORY_NOT_EMPTY\n                    else:\n                        errorCode = STATUS_ACCESS_DENIED\n        else:\n            errorCode = STATUS_SMB_BAD_TID\n\n        if errorCode > 0:\n            respParameters = b''\n            respData = b''\n\n        respSMBCommand['Parameters'] = respParameters\n        respSMBCommand['Data'] = respData\n        smbServer.setConnectionData(connId, connData)\n\n        return [respSMBCommand], None, errorCode\n\n    @staticmethod\n    def smbComWriteAndX(connId, smbServer, SMBCommand, recvPacket):\n        connData = smbServer.getConnectionData(connId)\n\n        respSMBCommand = smb.SMBCommand(smb.SMB.SMB_COM_WRITE_ANDX)\n        respParameters = smb.SMBWriteAndXResponse_Parameters()\n        respData = b''\n\n        if SMBCommand['WordCount'] == 0x0C:\n            writeAndX = smb.SMBWriteAndX_Parameters_Short(SMBCommand['Parameters'])\n            writeAndXData = smb.SMBWriteAndX_Data_Short()\n        else:\n            writeAndX = smb.SMBWriteAndX_Parameters(SMBCommand['Parameters'])\n            writeAndXData = smb.SMBWriteAndX_Data()\n        writeAndXData['DataLength'] = writeAndX['DataLength']\n        writeAndXData['DataOffset'] = writeAndX['DataOffset']\n        writeAndXData.fromString(SMBCommand['Data'])\n\n        # Get the Tid associated\n        if recvPacket['Tid'] in connData['ConnectedShares']:\n            if writeAndX['Fid'] in connData['OpenedFiles']:\n                fileHandle = connData['OpenedFiles'][writeAndX['Fid']]['FileHandle']\n                errorCode = STATUS_SUCCESS\n                try:\n                    if fileHandle != PIPE_FILE_DESCRIPTOR:\n                        offset = writeAndX['Offset']\n                        if 'HighOffset' in writeAndX.fields:\n                            offset += (writeAndX['HighOffset'] << 32)\n                        # If we're trying to write past the file end we just skip the write call (Vista does this)\n                        if os.lseek(fileHandle, 0, 2) >= offset:\n                            os.lseek(fileHandle, offset, 0)\n                            os.write(fileHandle, writeAndXData['Data'])\n                    else:\n                        sock = connData['OpenedFiles'][writeAndX['Fid']]['Socket']\n                        sock.send(writeAndXData['Data'])\n\n                    respParameters['Count'] = writeAndX['DataLength']\n                    respParameters['Available'] = 0xff\n                except Exception as e:\n                    smbServer.log('smbComWriteAndx: %s' % e, logging.ERROR)\n                    errorCode = STATUS_ACCESS_DENIED\n            else:\n                errorCode = STATUS_INVALID_HANDLE\n        else:\n            errorCode = STATUS_SMB_BAD_TID\n\n        if errorCode > 0:\n            respParameters = b''\n            respData = b''\n\n        respSMBCommand['Parameters'] = respParameters\n        respSMBCommand['Data'] = respData\n        smbServer.setConnectionData(connId, connData)\n\n        return [respSMBCommand], None, errorCode\n\n    @staticmethod\n    def smbComRead(connId, smbServer, SMBCommand, recvPacket):\n        connData = smbServer.getConnectionData(connId)\n\n        respSMBCommand = smb.SMBCommand(smb.SMB.SMB_COM_READ)\n        respParameters = smb.SMBReadResponse_Parameters()\n        respData = smb.SMBReadResponse_Data()\n\n        comReadParameters = smb.SMBRead_Parameters(SMBCommand['Parameters'])\n\n        # Get the Tid associated\n        if recvPacket['Tid'] in connData['ConnectedShares']:\n            if comReadParameters['Fid'] in connData['OpenedFiles']:\n                fileHandle = connData['OpenedFiles'][comReadParameters['Fid']]['FileHandle']\n                errorCode = STATUS_SUCCESS\n                try:\n                    if fileHandle != PIPE_FILE_DESCRIPTOR:\n                        # TODO: Handle big size files\n                        os.lseek(fileHandle, comReadParameters['Offset'], 0)\n                        content = os.read(fileHandle, comReadParameters['Count'])\n                    else:\n                        sock = connData['OpenedFiles'][comReadParameters['Fid']]['Socket']\n                        content = sock.recv(comReadParameters['Count'])\n                    respParameters['Count'] = len(content)\n                    respData['DataLength'] = len(content)\n                    respData['Data'] = content\n                except Exception as e:\n                    smbServer.log('smbComRead: %s ' % e, logging.ERROR)\n                    errorCode = STATUS_ACCESS_DENIED\n            else:\n                errorCode = STATUS_INVALID_HANDLE\n        else:\n            errorCode = STATUS_SMB_BAD_TID\n\n        if errorCode > 0:\n            respParameters = b''\n            respData = b''\n\n        respSMBCommand['Parameters'] = respParameters\n        respSMBCommand['Data'] = respData\n        smbServer.setConnectionData(connId, connData)\n\n        return [respSMBCommand], None, errorCode\n\n    @staticmethod\n    def smbComReadAndX(connId, smbServer, SMBCommand, recvPacket):\n        connData = smbServer.getConnectionData(connId)\n\n        respSMBCommand = smb.SMBCommand(smb.SMB.SMB_COM_READ_ANDX)\n        respParameters = smb.SMBReadAndXResponse_Parameters()\n        respData = b''\n\n        if SMBCommand['WordCount'] == 0x0A:\n            readAndX = smb.SMBReadAndX_Parameters2(SMBCommand['Parameters'])\n        else:\n            readAndX = smb.SMBReadAndX_Parameters(SMBCommand['Parameters'])\n\n        # Get the Tid associated\n        if recvPacket['Tid'] in connData['ConnectedShares']:\n            if readAndX['Fid'] in connData['OpenedFiles']:\n                fileHandle = connData['OpenedFiles'][readAndX['Fid']]['FileHandle']\n                errorCode = 0\n                try:\n                    if fileHandle != PIPE_FILE_DESCRIPTOR:\n                        offset = readAndX['Offset']\n                        if 'HighOffset' in readAndX.fields:\n                            offset += (readAndX['HighOffset'] << 32)\n                        os.lseek(fileHandle, offset, 0)\n                        content = os.read(fileHandle, readAndX['MaxCount'])\n                    else:\n                        sock = connData['OpenedFiles'][readAndX['Fid']]['Socket']\n                        content = sock.recv(readAndX['MaxCount'])\n                    respParameters['Remaining'] = 0xffff\n                    respParameters['DataCount'] = len(content)\n                    respParameters['DataOffset'] = 59\n                    respParameters['DataCount_Hi'] = 0\n                    respData = content\n                except Exception as e:\n                    smbServer.log('smbComReadAndX: %s ' % e, logging.ERROR)\n                    errorCode = STATUS_ACCESS_DENIED\n            else:\n                errorCode = STATUS_INVALID_HANDLE\n        else:\n            errorCode = STATUS_SMB_BAD_TID\n\n        if errorCode > 0:\n            respParameters = b''\n            respData = b''\n\n        respSMBCommand['Parameters'] = respParameters\n        respSMBCommand['Data'] = respData\n        smbServer.setConnectionData(connId, connData)\n\n        return [respSMBCommand], None, errorCode\n\n    @staticmethod\n    def smbQueryInformation(connId, smbServer, SMBCommand, recvPacket):\n        connData = smbServer.getConnectionData(connId)\n\n        respSMBCommand = smb.SMBCommand(smb.SMB.SMB_COM_QUERY_INFORMATION)\n        respParameters = smb.SMBQueryInformationResponse_Parameters()\n        respData = b''\n\n        queryInformation = smb.SMBQueryInformation_Data(flags=recvPacket['Flags2'], data=SMBCommand['Data'])\n\n        # Get the Tid associated\n        if recvPacket['Tid'] in connData['ConnectedShares']:\n            path = connData['ConnectedShares'][recvPacket['Tid']]['path']\n            fileName = normalize_path(decodeSMBString(recvPacket['Flags2'], queryInformation['FileName']))\n            if not isInFileJail(path, fileName):\n                smbServer.log(\"Path not in current working directory\", logging.ERROR)\n                errorCode = STATUS_OBJECT_PATH_SYNTAX_BAD\n\n            else:\n                fileSize, lastWriteTime, fileAttributes = queryFsInformation(path, fileName, pktFlags=recvPacket['Flags2'])\n\n                respParameters['FileSize'] = fileSize\n                respParameters['LastWriteTime'] = lastWriteTime\n                respParameters['FileAttributes'] = fileAttributes\n                errorCode = STATUS_SUCCESS\n        else:\n            errorCode = STATUS_SMB_BAD_TID\n\n        if errorCode > 0:\n            respParameters = b''\n            respData = b''\n\n        respSMBCommand['Parameters'] = respParameters\n        respSMBCommand['Data'] = respData\n\n        smbServer.setConnectionData(connId, connData)\n        return [respSMBCommand], None, errorCode\n\n    @staticmethod\n    def smbQueryInformationDisk(connId, smbServer, SMBCommand, recvPacket):\n        connData = smbServer.getConnectionData(connId)\n\n        respSMBCommand = smb.SMBCommand(smb.SMB.SMB_COM_QUERY_INFORMATION_DISK)\n        respParameters = smb.SMBQueryInformationDiskResponse_Parameters()\n        respData = b''\n\n        # Get the Tid associated\n        if recvPacket['Tid'] in connData['ConnectedShares']:\n            totalUnits, freeUnits = queryDiskInformation(\n                connData['ConnectedShares'][recvPacket['Tid']]['path'])\n\n            respParameters['TotalUnits'] = totalUnits\n            respParameters['BlocksPerUnit'] = 1\n            respParameters['BlockSize'] = 1\n            respParameters['FreeUnits'] = freeUnits\n            errorCode = STATUS_SUCCESS\n        else:\n            errorCode = STATUS_SMB_BAD_TID\n\n        if errorCode > 0:\n            respData = b''\n            respParameters = b''\n\n        respSMBCommand['Parameters'] = respParameters\n        respSMBCommand['Data'] = respData\n\n        smbServer.setConnectionData(connId, connData)\n        return [respSMBCommand], None, errorCode\n\n    @staticmethod\n    def smbComEcho(connId, smbServer, SMBCommand, recvPacket):\n        connData = smbServer.getConnectionData(connId)\n\n        respSMBCommand = smb.SMBCommand(smb.SMB.SMB_COM_ECHO)\n        respParameters = smb.SMBEchoResponse_Parameters()\n        respData = smb.SMBEchoResponse_Data()\n\n        echoData = smb.SMBEcho_Data(SMBCommand['Data'])\n\n        respParameters['SequenceNumber'] = 1\n        respData['Data'] = echoData['Data']\n\n        respSMBCommand['Parameters'] = respParameters\n        respSMBCommand['Data'] = respData\n\n        errorCode = STATUS_SUCCESS\n        smbServer.setConnectionData(connId, connData)\n        return [respSMBCommand], None, errorCode\n\n    @staticmethod\n    def smbComTreeDisconnect(connId, smbServer, SMBCommand, recvPacket):\n        connData = smbServer.getConnectionData(connId)\n\n        respSMBCommand = smb.SMBCommand(smb.SMB.SMB_COM_TREE_DISCONNECT)\n\n        # Check if the Tid matches the Tid trying to disconnect\n        respParameters = b''\n        respData = b''\n\n        if recvPacket['Tid'] in connData['ConnectedShares']:\n            smbServer.log(\"Disconnecting Share(%d:%s)\" % (\n            recvPacket['Tid'], connData['ConnectedShares'][recvPacket['Tid']]['shareName']))\n            del (connData['ConnectedShares'][recvPacket['Tid']])\n            errorCode = STATUS_SUCCESS\n        else:\n            errorCode = STATUS_SMB_BAD_TID\n\n        respSMBCommand['Parameters'] = respParameters\n        respSMBCommand['Data'] = respData\n\n        smbServer.setConnectionData(connId, connData)\n        return [respSMBCommand], None, errorCode\n\n    @staticmethod\n    def smbComLogOffAndX(connId, smbServer, SMBCommand, recvPacket):\n        connData = smbServer.getConnectionData(connId)\n\n        respSMBCommand = smb.SMBCommand(smb.SMB.SMB_COM_LOGOFF_ANDX)\n\n        # Check if the Uid matches the user trying to logoff\n        respParameters = b''\n        respData = b''\n        if recvPacket['Uid'] != connData['Uid']:\n            errorCode = STATUS_SMB_BAD_UID\n        else:\n            errorCode = STATUS_SUCCESS\n\n        respSMBCommand['Parameters'] = respParameters\n        respSMBCommand['Data'] = respData\n        connData['Uid'] = 0\n        connData['Authenticated'] = False\n\n        smbServer.setConnectionData(connId, connData)\n\n        return [respSMBCommand], None, errorCode\n\n    @staticmethod\n    def smbComQueryInformation2(connId, smbServer, SMBCommand, recvPacket):\n        connData = smbServer.getConnectionData(connId)\n\n        respSMBCommand = smb.SMBCommand(smb.SMB.SMB_COM_QUERY_INFORMATION2)\n        respParameters = smb.SMBQueryInformation2Response_Parameters()\n        respData = b''\n\n        queryInformation2 = smb.SMBQueryInformation2_Parameters(SMBCommand['Parameters'])\n        errorCode = 0xFF\n\n        # Get the Tid associated\n        if recvPacket['Tid'] in connData['ConnectedShares']:\n            if queryInformation2['Fid'] in connData['OpenedFiles']:\n                errorCode = STATUS_SUCCESS\n                pathName = connData['OpenedFiles'][queryInformation2['Fid']]['FileName']\n                try:\n                    (mode, ino, dev, nlink, uid, gid, size, atime, mtime, ctime) = os.stat(pathName)\n                    respParameters['CreateDate'] = getSMBDate(ctime)\n                    respParameters['CreationTime'] = getSMBTime(ctime)\n                    respParameters['LastAccessDate'] = getSMBDate(atime)\n                    respParameters['LastAccessTime'] = getSMBTime(atime)\n                    respParameters['LastWriteDate'] = getSMBDate(mtime)\n                    respParameters['LastWriteTime'] = getSMBTime(mtime)\n                    respParameters['FileDataSize'] = size\n                    respParameters['FileAllocationSize'] = size\n                    attribs = 0\n                    if os.path.isdir(pathName):\n                        attribs = smb.SMB_FILE_ATTRIBUTE_DIRECTORY\n                    if os.path.isfile(pathName):\n                        attribs = smb.SMB_FILE_ATTRIBUTE_NORMAL\n                    respParameters['FileAttributes'] = attribs\n                except Exception as e:\n                    smbServer.log('smbComQueryInformation2 %s' % e, logging.ERROR)\n                    errorCode = STATUS_ACCESS_DENIED\n        else:\n            errorCode = STATUS_SMB_BAD_TID\n\n        if errorCode > 0:\n            respParameters = b''\n            respData = b''\n\n        respSMBCommand['Parameters'] = respParameters\n        respSMBCommand['Data'] = respData\n        smbServer.setConnectionData(connId, connData)\n\n        return [respSMBCommand], None, errorCode\n\n    @staticmethod\n    def smbComNtCreateAndX(connId, smbServer, SMBCommand, recvPacket):\n        # TODO: Fully implement this\n        connData = smbServer.getConnectionData(connId)\n\n        respSMBCommand = smb.SMBCommand(smb.SMB.SMB_COM_NT_CREATE_ANDX)\n        respParameters = smb.SMBNtCreateAndXResponse_Parameters()\n        respData = b''\n\n        ntCreateAndXParameters = smb.SMBNtCreateAndX_Parameters(SMBCommand['Parameters'])\n        ntCreateAndXData = smb.SMBNtCreateAndX_Data(flags=recvPacket['Flags2'], data=SMBCommand['Data'])\n\n        # if ntCreateAndXParameters['CreateFlags'] & 0x10:  # NT_CREATE_REQUEST_EXTENDED_RESPONSE\n        #    respParameters        = smb.SMBNtCreateAndXExtendedResponse_Parameters()\n        #    respParameters['VolumeGUID'] = '\\x00'\n\n        # Get the Tid associated\n        if recvPacket['Tid'] in connData['ConnectedShares']:\n            # If we have a rootFid, the path is relative to that fid\n            errorCode = STATUS_SUCCESS\n            if ntCreateAndXParameters['RootFid'] > 0:\n                path = connData['OpenedFiles'][ntCreateAndXParameters['RootFid']]['FileName']\n                LOG.debug(\"RootFid present %s!\" % path)\n            else:\n                if 'path' in connData['ConnectedShares'][recvPacket['Tid']]:\n                    path = connData['ConnectedShares'][recvPacket['Tid']]['path']\n                else:\n                    path = 'NONE'\n                    errorCode = STATUS_ACCESS_DENIED\n\n            deleteOnClose = False\n\n            fileName = normalize_path(decodeSMBString(recvPacket['Flags2'], ntCreateAndXData['FileName']))\n            if not isInFileJail(path, fileName):\n                LOG.error(\"Path not in current working directory\")\n                respSMBCommand['Parameters'] = b''\n                respSMBCommand['Data'] = b''\n                return [respSMBCommand], None, STATUS_OBJECT_PATH_SYNTAX_BAD\n\n            pathName = os.path.join(path, fileName)\n            createDisposition = ntCreateAndXParameters['Disposition']\n            mode = 0\n\n            if createDisposition == smb.FILE_SUPERSEDE:\n                mode |= os.O_TRUNC | os.O_CREAT\n            elif createDisposition & smb.FILE_OVERWRITE_IF == smb.FILE_OVERWRITE_IF:\n                mode |= os.O_TRUNC | os.O_CREAT\n            elif createDisposition & smb.FILE_OVERWRITE == smb.FILE_OVERWRITE:\n                if os.path.exists(pathName) is True:\n                    mode |= os.O_TRUNC\n                else:\n                    errorCode = STATUS_NO_SUCH_FILE\n            elif createDisposition & smb.FILE_OPEN_IF == smb.FILE_OPEN_IF:\n                mode |= os.O_CREAT\n            elif createDisposition & smb.FILE_CREATE == smb.FILE_CREATE:\n                if os.path.exists(pathName) is True:\n                    errorCode = STATUS_OBJECT_NAME_COLLISION\n                else:\n                    mode |= os.O_CREAT\n            elif createDisposition & smb.FILE_OPEN == smb.FILE_OPEN:\n                if os.path.exists(pathName) is not True and (\n                        str(pathName) in smbServer.getRegisteredNamedPipes()) is not True:\n                    errorCode = STATUS_NO_SUCH_FILE\n\n            if errorCode == STATUS_SUCCESS:\n                desiredAccess = ntCreateAndXParameters['AccessMask']\n                if (desiredAccess & smb.FILE_READ_DATA) or (desiredAccess & smb.GENERIC_READ):\n                    mode |= os.O_RDONLY\n                if (desiredAccess & smb.FILE_WRITE_DATA) or (desiredAccess & smb.GENERIC_WRITE):\n                    if (desiredAccess & smb.FILE_READ_DATA) or (desiredAccess & smb.GENERIC_READ):\n                        mode |= os.O_RDWR  # | os.O_APPEND\n                    else:\n                        mode |= os.O_WRONLY  # | os.O_APPEND\n                if desiredAccess & smb.GENERIC_ALL:\n                    mode |= os.O_RDWR  # | os.O_APPEND\n\n                createOptions = ntCreateAndXParameters['CreateOptions']\n                if mode & os.O_CREAT == os.O_CREAT:\n                    if createOptions & smb.FILE_DIRECTORY_FILE == smb.FILE_DIRECTORY_FILE:\n                        try:\n                            # Let's create the directory\n                            os.mkdir(pathName)\n                            mode = os.O_RDONLY\n                        except Exception as e:\n                            smbServer.log(\"NTCreateAndX: %s,%s,%s\" % (pathName, mode, e), logging.ERROR)\n                            errorCode = STATUS_ACCESS_DENIED\n                if createOptions & smb.FILE_NON_DIRECTORY_FILE == smb.FILE_NON_DIRECTORY_FILE:\n                    # If the file being opened is a directory, the server MUST fail the request with\n                    # STATUS_FILE_IS_A_DIRECTORY in the Status field of the SMB Header in the server\n                    # response.\n                    if os.path.isdir(pathName) is True:\n                        errorCode = STATUS_FILE_IS_A_DIRECTORY\n\n                if createOptions & smb.FILE_DELETE_ON_CLOSE == smb.FILE_DELETE_ON_CLOSE:\n                    deleteOnClose = True\n\n                if errorCode == STATUS_SUCCESS:\n                    try:\n                        if os.path.isdir(pathName) and sys.platform == 'win32':\n                            fid = VOID_FILE_DESCRIPTOR\n                        else:\n                            if sys.platform == 'win32':\n                                mode |= os.O_BINARY\n                            if str(pathName) in smbServer.getRegisteredNamedPipes():\n                                fid = PIPE_FILE_DESCRIPTOR\n                                sock = socket.socket()\n                                sock.connect(smbServer.getRegisteredNamedPipes()[str(pathName)])\n                            else:\n                                fid = os.open(pathName, mode)\n                    except Exception as e:\n                        smbServer.log(\"NTCreateAndX: %s,%s,%s\" % (pathName, mode, e), logging.ERROR)\n                        # print e\n                        fid = 0\n                        errorCode = STATUS_ACCESS_DENIED\n        else:\n            errorCode = STATUS_SMB_BAD_TID\n\n        if errorCode == STATUS_SUCCESS:\n            # Simple way to generate a fid\n            if len(connData['OpenedFiles']) == 0:\n                fakefid = 1\n            else:\n                fakefid = list(connData['OpenedFiles'].keys())[-1] + 1\n            respParameters['Fid'] = fakefid\n            respParameters['CreateAction'] = createDisposition\n            if fid == PIPE_FILE_DESCRIPTOR:\n                respParameters['FileAttributes'] = 0x80\n                respParameters['IsDirectory'] = 0\n                respParameters['CreateTime'] = 0\n                respParameters['LastAccessTime'] = 0\n                respParameters['LastWriteTime'] = 0\n                respParameters['LastChangeTime'] = 0\n                respParameters['AllocationSize'] = 4096\n                respParameters['EndOfFile'] = 0\n                respParameters['FileType'] = 2\n                respParameters['IPCState'] = 0x5ff\n            else:\n                if os.path.isdir(pathName):\n                    respParameters['FileAttributes'] = smb.SMB_FILE_ATTRIBUTE_DIRECTORY\n                    respParameters['IsDirectory'] = 1\n                else:\n                    respParameters['IsDirectory'] = 0\n                    respParameters['FileAttributes'] = ntCreateAndXParameters['FileAttributes']\n                # Let's get this file's information\n                respInfo, errorCode = queryPathInformation(path, fileName, level=smb.SMB_QUERY_FILE_ALL_INFO)\n                if errorCode == STATUS_SUCCESS:\n                    respParameters['CreateTime'] = respInfo['CreationTime']\n                    respParameters['LastAccessTime'] = respInfo['LastAccessTime']\n                    respParameters['LastWriteTime'] = respInfo['LastWriteTime']\n                    respParameters['LastChangeTime'] = respInfo['LastChangeTime']\n                    respParameters['FileAttributes'] = respInfo['ExtFileAttributes']\n                    respParameters['AllocationSize'] = respInfo['AllocationSize']\n                    respParameters['EndOfFile'] = respInfo['EndOfFile']\n                else:\n                    respParameters = b''\n                    respData = b''\n\n            if errorCode == STATUS_SUCCESS:\n                # Let's store the fid for the connection\n                # smbServer.log('Create file %s, mode:0x%x' % (pathName, mode))\n                connData['OpenedFiles'][fakefid] = {}\n                connData['OpenedFiles'][fakefid]['FileHandle'] = fid\n                connData['OpenedFiles'][fakefid]['FileName'] = pathName\n                connData['OpenedFiles'][fakefid]['DeleteOnClose'] = deleteOnClose\n                if fid == PIPE_FILE_DESCRIPTOR:\n                    connData['OpenedFiles'][fakefid]['Socket'] = sock\n        else:\n            respParameters = b''\n            respData = b''\n\n        respSMBCommand['Parameters'] = respParameters\n        respSMBCommand['Data'] = respData\n        smbServer.setConnectionData(connId, connData)\n\n        return [respSMBCommand], None, errorCode\n\n    @staticmethod\n    def smbComOpenAndX(connId, smbServer, SMBCommand, recvPacket):\n        connData = smbServer.getConnectionData(connId)\n\n        respSMBCommand = smb.SMBCommand(smb.SMB.SMB_COM_OPEN_ANDX)\n        respParameters = smb.SMBOpenAndXResponse_Parameters()\n        respData = b''\n\n        openAndXParameters = smb.SMBOpenAndX_Parameters(SMBCommand['Parameters'])\n        openAndXData = smb.SMBOpenAndX_Data(flags=recvPacket['Flags2'], data=SMBCommand['Data'])\n\n        # Get the Tid associated\n        if recvPacket['Tid'] in connData['ConnectedShares']:\n            path = connData['ConnectedShares'][recvPacket['Tid']]['path']\n            openedFile, mode, pathName, errorCode = openFile(path,\n                                                             decodeSMBString(recvPacket['Flags2'],\n                                                                             openAndXData['FileName']),\n                                                             openAndXParameters['DesiredAccess'],\n                                                             openAndXParameters['FileAttributes'],\n                                                             openAndXParameters['OpenMode'])\n        else:\n            errorCode = STATUS_SMB_BAD_TID\n\n        if errorCode == STATUS_SUCCESS:\n            # Simple way to generate a fid\n            fid = len(connData['OpenedFiles']) + 1\n            if len(connData['OpenedFiles']) == 0:\n                fid = 1\n            else:\n                fid = list(connData['OpenedFiles'].keys())[-1] + 1\n            respParameters['Fid'] = fid\n            if mode & os.O_CREAT:\n                # File did not exist and was created\n                respParameters['Action'] = 0x2\n            elif mode & os.O_RDONLY:\n                # File existed and was opened\n                respParameters['Action'] = 0x1\n            elif mode & os.O_APPEND:\n                # File existed and was opened\n                respParameters['Action'] = 0x1\n            else:\n                # File existed and was truncated\n                respParameters['Action'] = 0x3\n\n            # Let's store the fid for the connection\n            # smbServer.log('Opening file %s' % pathName)\n            connData['OpenedFiles'][fid] = {}\n            connData['OpenedFiles'][fid]['FileHandle'] = openedFile\n            connData['OpenedFiles'][fid]['FileName'] = pathName\n            connData['OpenedFiles'][fid]['DeleteOnClose'] = False\n        else:\n            respParameters = b''\n            respData = b''\n\n        respSMBCommand['Parameters'] = respParameters\n        respSMBCommand['Data'] = respData\n        smbServer.setConnectionData(connId, connData)\n\n        return [respSMBCommand], None, errorCode\n\n    @staticmethod\n    def smbComTreeConnectAndX(connId, smbServer, SMBCommand, recvPacket):\n        connData = smbServer.getConnectionData(connId)\n\n        resp = smb.NewSMBPacket()\n        resp['Flags1'] = smb.SMB.FLAGS1_REPLY\n        resp['Flags2'] = smb.SMB.FLAGS2_EXTENDED_SECURITY | smb.SMB.FLAGS2_NT_STATUS | smb.SMB.FLAGS2_LONG_NAMES | \\\n                         recvPacket['Flags2'] & smb.SMB.FLAGS2_UNICODE\n\n        resp['Tid'] = recvPacket['Tid']\n        resp['Mid'] = recvPacket['Mid']\n        resp['Pid'] = connData['Pid']\n\n        respSMBCommand = smb.SMBCommand(smb.SMB.SMB_COM_TREE_CONNECT_ANDX)\n        respParameters = smb.SMBTreeConnectAndXResponse_Parameters()\n        respData = smb.SMBTreeConnectAndXResponse_Data()\n\n        treeConnectAndXParameters = smb.SMBTreeConnectAndX_Parameters(SMBCommand['Parameters'])\n\n        if treeConnectAndXParameters['Flags'] & 0x8:\n            respParameters = smb.SMBTreeConnectAndXExtendedResponse_Parameters()\n\n        treeConnectAndXData = smb.SMBTreeConnectAndX_Data(flags=recvPacket['Flags2'])\n        treeConnectAndXData['_PasswordLength'] = treeConnectAndXParameters['PasswordLength']\n        treeConnectAndXData.fromString(SMBCommand['Data'])\n\n        errorCode = STATUS_SUCCESS\n\n        ## Process here the request, does the share exist?\n        UNCOrShare = decodeSMBString(recvPacket['Flags2'], treeConnectAndXData['Path'])\n\n        # Is this a UNC?\n        if ntpath.ismount(UNCOrShare):\n            path = UNCOrShare.split('\\\\')[3]\n        else:\n            path = ntpath.basename(UNCOrShare)\n\n        share = searchShare(connId, path, smbServer)\n        if share is not None:\n            # Simple way to generate a Tid\n            if len(connData['ConnectedShares']) == 0:\n                tid = 1\n            else:\n                tid = list(connData['ConnectedShares'].keys())[-1] + 1\n            connData['ConnectedShares'][tid] = share\n            connData['ConnectedShares'][tid]['shareName'] = path\n            resp['Tid'] = tid\n            # smbServer.log(\"Connecting Share(%d:%s)\" % (tid,path))\n        else:\n            smbServer.log(\"TreeConnectAndX not found %s\" % path, logging.ERROR)\n            errorCode = STATUS_OBJECT_PATH_NOT_FOUND\n            resp['ErrorCode'] = errorCode >> 16\n            resp['ErrorClass'] = errorCode & 0xff\n        ##\n        respParameters['OptionalSupport'] = smb.SMB.SMB_SUPPORT_SEARCH_BITS\n\n        if path == 'IPC$':\n            respData['Service'] = 'IPC'\n        else:\n            respData['Service'] = path\n        respData['PadLen'] = 0\n        respData['NativeFileSystem'] = encodeSMBString(recvPacket['Flags2'], 'NTFS').decode()\n\n        respSMBCommand['Parameters'] = respParameters\n        respSMBCommand['Data'] = respData\n\n        resp['Uid'] = connData['Uid']\n        resp.addCommand(respSMBCommand)\n\n        # Sign the packet if needed\n        if connData['SignatureEnabled']:\n            smbServer.signSMBv1(connData, resp, connData['SigningSessionKey'], connData['SigningChallengeResponse'])\n        smbServer.setConnectionData(connId, connData)\n\n        return None, [resp], errorCode\n\n    @staticmethod\n    def smbComSessionSetupAndX(connId, smbServer, SMBCommand, recvPacket):\n        connData = smbServer.getConnectionData(connId, checkStatus=False)\n\n        respSMBCommand = smb.SMBCommand(smb.SMB.SMB_COM_SESSION_SETUP_ANDX)\n\n        # From [MS-SMB]\n        # When extended security is being used (see section 3.2.4.2.4), the\n        # request MUST take the following form\n        # [..]\n        # WordCount (1 byte): The value of this field MUST be 0x0C.\n        if SMBCommand['WordCount'] == 12:\n            # Extended security. Here we deal with all SPNEGO stuff\n            respParameters = smb.SMBSessionSetupAndX_Extended_Response_Parameters()\n            respData = smb.SMBSessionSetupAndX_Extended_Response_Data(flags=recvPacket['Flags2'])\n            sessionSetupParameters = smb.SMBSessionSetupAndX_Extended_Parameters(SMBCommand['Parameters'])\n            sessionSetupData = smb.SMBSessionSetupAndX_Extended_Data()\n            sessionSetupData['SecurityBlobLength'] = sessionSetupParameters['SecurityBlobLength']\n            sessionSetupData.fromString(SMBCommand['Data'])\n            connData['Capabilities'] = sessionSetupParameters['Capabilities']\n\n            rawNTLM = False\n            if struct.unpack('B', sessionSetupData['SecurityBlob'][0:1])[0] == ASN1_AID:\n                # NEGOTIATE packet\n                blob = SPNEGO_NegTokenInit(sessionSetupData['SecurityBlob'])\n                token = blob['MechToken']\n                if len(blob['MechTypes'][0]) > 0:\n                    # Is this GSSAPI NTLM or something else we don't support?\n                    mechType = blob['MechTypes'][0]\n                    if mechType != TypesMech['NTLMSSP - Microsoft NTLM Security Support Provider']:\n                        # Nope, do we know it?\n                        if mechType in MechTypes:\n                            mechStr = MechTypes[mechType]\n                        else:\n                            mechStr = hexlify(mechType)\n                        smbServer.log(\"Unsupported MechType '%s'\" % mechStr, logging.CRITICAL)\n                        # We don't know the token, we answer back again saying\n                        # we just support NTLM.\n                        # ToDo: Build this into a SPNEGO_NegTokenResp()\n                        respToken = b'\\xa1\\x15\\x30\\x13\\xa0\\x03\\x0a\\x01\\x03\\xa1\\x0c\\x06\\x0a\\x2b\\x06\\x01\\x04\\x01\\x82\\x37\\x02\\x02\\x0a'\n                        respParameters['SecurityBlobLength'] = len(respToken)\n                        respData['SecurityBlobLength'] = respParameters['SecurityBlobLength']\n                        respData['SecurityBlob'] = respToken\n                        respData['NativeOS'] = encodeSMBString(recvPacket['Flags2'], smbServer.getServerOS())\n                        respData['NativeLanMan'] = encodeSMBString(recvPacket['Flags2'], smbServer.getServerOS())\n                        respSMBCommand['Parameters'] = respParameters\n                        respSMBCommand['Data'] = respData\n                        return [respSMBCommand], None, STATUS_MORE_PROCESSING_REQUIRED\n\n            elif struct.unpack('B', sessionSetupData['SecurityBlob'][0:1])[0] == ASN1_SUPPORTED_MECH:\n                # AUTH packet\n                blob = SPNEGO_NegTokenResp(sessionSetupData['SecurityBlob'])\n                token = blob['ResponseToken']\n            else:\n                # No GSSAPI stuff, raw NTLMSSP\n                rawNTLM = True\n                token = sessionSetupData['SecurityBlob']\n\n            # Here we only handle NTLMSSP, depending on what stage of the\n            # authentication we are, we act on it\n            messageType = struct.unpack('<L', token[len('NTLMSSP\\x00'):len('NTLMSSP\\x00') + 4])[0]\n\n            if messageType == 0x01:\n                # NEGOTIATE_MESSAGE\n                negotiateMessage = ntlm.NTLMAuthNegotiate()\n                negotiateMessage.fromString(token)\n                # Let's store it in the connection data\n                connData['NEGOTIATE_MESSAGE'] = negotiateMessage\n                # Let's build the answer flags\n                # TODO: Parse all the flags. With this we're leaving some clients out\n\n                ansFlags = 0\n\n                if negotiateMessage['flags'] & ntlm.NTLMSSP_NEGOTIATE_56:\n                    ansFlags |= ntlm.NTLMSSP_NEGOTIATE_56\n                if negotiateMessage['flags'] & ntlm.NTLMSSP_NEGOTIATE_128:\n                    ansFlags |= ntlm.NTLMSSP_NEGOTIATE_128\n                if negotiateMessage['flags'] & ntlm.NTLMSSP_NEGOTIATE_KEY_EXCH:\n                    ansFlags |= ntlm.NTLMSSP_NEGOTIATE_KEY_EXCH\n                if negotiateMessage['flags'] & ntlm.NTLMSSP_NEGOTIATE_EXTENDED_SESSIONSECURITY:\n                    ansFlags |= ntlm.NTLMSSP_NEGOTIATE_EXTENDED_SESSIONSECURITY\n                if negotiateMessage['flags'] & ntlm.NTLMSSP_NEGOTIATE_UNICODE:\n                    ansFlags |= ntlm.NTLMSSP_NEGOTIATE_UNICODE\n                if negotiateMessage['flags'] & ntlm.NTLM_NEGOTIATE_OEM:\n                    ansFlags |= ntlm.NTLM_NEGOTIATE_OEM\n\n                ansFlags |= ntlm.NTLMSSP_NEGOTIATE_VERSION | ntlm.NTLMSSP_NEGOTIATE_TARGET_INFO | ntlm.NTLMSSP_TARGET_TYPE_SERVER | ntlm.NTLMSSP_NEGOTIATE_NTLM | ntlm.NTLMSSP_REQUEST_TARGET\n\n                # Generate the AV_PAIRS\n                av_pairs = ntlm.AV_PAIRS()\n                # TODO: Put the proper data from SMBSERVER config\n                av_pairs[ntlm.NTLMSSP_AV_HOSTNAME] = av_pairs[\n                    ntlm.NTLMSSP_AV_DNS_HOSTNAME] = smbServer.getServerName().encode('utf-16le')\n                av_pairs[ntlm.NTLMSSP_AV_DOMAINNAME] = av_pairs[\n                    ntlm.NTLMSSP_AV_DNS_DOMAINNAME] = smbServer.getServerDomain().encode('utf-16le')\n                av_pairs[ntlm.NTLMSSP_AV_TIME] = struct.pack('<q', (\n                            116444736000000000 + calendar.timegm(time.gmtime()) * 10000000))\n\n                challengeMessage = ntlm.NTLMAuthChallenge()\n                challengeMessage['flags'] = ansFlags\n                challengeMessage['domain_len'] = len(smbServer.getServerDomain().encode('utf-16le'))\n                challengeMessage['domain_max_len'] = challengeMessage['domain_len']\n                challengeMessage['domain_offset'] = 40 + 16\n                challengeMessage['challenge'] = smbServer.getSMBChallenge()\n                challengeMessage['domain_name'] = smbServer.getServerDomain().encode('utf-16le')\n                challengeMessage['TargetInfoFields_len'] = len(av_pairs)\n                challengeMessage['TargetInfoFields_max_len'] = len(av_pairs)\n                challengeMessage['TargetInfoFields'] = av_pairs\n                challengeMessage['TargetInfoFields_offset'] = 40 + 16 + len(challengeMessage['domain_name'])\n                challengeMessage['Version'] = b'\\xff' * 8\n                challengeMessage['VersionLen'] = 8\n\n                if rawNTLM is False:\n                    respToken = SPNEGO_NegTokenResp()\n                    # accept-incomplete. We want more data\n                    respToken['NegState'] = b'\\x01'\n                    respToken['SupportedMech'] = TypesMech['NTLMSSP - Microsoft NTLM Security Support Provider']\n\n                    respToken['ResponseToken'] = challengeMessage.getData()\n                else:\n                    respToken = challengeMessage\n\n                # Setting the packet to STATUS_MORE_PROCESSING\n                errorCode = STATUS_MORE_PROCESSING_REQUIRED\n                # Let's set up an UID for this connection and store it\n                # in the connection's data\n                # Picking a fixed value\n                # TODO: Manage more UIDs for the same session\n                connData['Uid'] = 10\n                # Let's store it in the connection data\n                connData['CHALLENGE_MESSAGE'] = challengeMessage\n\n            elif messageType == 0x02:\n                # CHALLENGE_MESSAGE\n                raise Exception('Challenge Message raise, not implemented!')\n\n            elif messageType == 0x03:\n                # AUTHENTICATE_MESSAGE, here we deal with authentication\n                authenticateMessage = ntlm.NTLMAuthChallengeResponse()\n                authenticateMessage.fromString(token)\n                smbServer.log(\"AUTHENTICATE_MESSAGE (%s\\\\%s,%s)\" % (\n                    authenticateMessage['domain_name'].decode('utf-16le'),\n                    authenticateMessage['user_name'].decode('utf-16le'),\n                    authenticateMessage['host_name'].decode('utf-16le')))\n                # Do we have credentials to check?\n                if len(smbServer.getCredentials()) > 0:\n                    identity = authenticateMessage['user_name'].decode('utf-16le').lower()\n                    # Do we have this user's credentials?\n                    if identity in smbServer.getCredentials():\n                        # Process data:\n                        # Let's parse some data and keep it to ourselves in case it is asked\n                        uid, lmhash, nthash = smbServer.getCredentials()[identity]\n\n                        errorCode, sessionKey = computeNTLMv2(identity, lmhash, nthash, smbServer.getSMBChallenge(),\n                                                              authenticateMessage, connData['CHALLENGE_MESSAGE'],\n                                                              connData['NEGOTIATE_MESSAGE'])\n\n                        if sessionKey is not None:\n                            connData['SignatureEnabled'] = False\n                            connData['SigningSessionKey'] = sessionKey\n                            connData['SignSequenceNumber'] = 1\n                    else:\n                        errorCode = STATUS_LOGON_FAILURE\n                else:\n                    # No credentials provided, let's grant access\n                    errorCode = STATUS_SUCCESS\n\n                if errorCode == STATUS_SUCCESS:\n                    connData['Authenticated'] = True\n                    respToken = SPNEGO_NegTokenResp()\n                    # accept-completed\n                    respToken['NegState'] = b'\\x00'\n\n                    smbServer.log(\n                        'User %s\\\\%s authenticated successfully' % (authenticateMessage['host_name'].decode('utf-16le'),\n                                                                    authenticateMessage['user_name'].decode(\n                                                                        'utf-16le')))\n                    # Let's store it in the connection data\n                    connData['AUTHENTICATE_MESSAGE'] = authenticateMessage\n                    try:\n                        jtr_dump_path = smbServer.getJTRdumpPath()\n                        ntlm_hash_data = outputToJohnFormat(connData['CHALLENGE_MESSAGE']['challenge'],\n                                                            authenticateMessage['user_name'],\n                                                            authenticateMessage['domain_name'],\n                                                            authenticateMessage['lanman'], authenticateMessage['ntlm'])\n                        smbServer.log(ntlm_hash_data['hash_string'])\n                        if jtr_dump_path != '':\n                            writeJohnOutputToFile(ntlm_hash_data['hash_string'], ntlm_hash_data['hash_version'],\n                                                  jtr_dump_path)\n                    except:\n                        smbServer.log(\"Could not write NTLM Hashes to the specified JTR_Dump_Path %s\" % jtr_dump_path)\n                else:\n                    respToken = SPNEGO_NegTokenResp()\n                    respToken['NegState'] = b'\\x02'\n                    smbServer.log(\"Could not authenticate user!\")\n                if smbServer.auth_callback is not None:\n                    try:\n                        smbServer.auth_callback(\n                            smbServer=smbServer,\n                            connData=connData,\n                            domain_name=authenticateMessage['domain_name'].decode('utf-16le'),\n                            user_name=authenticateMessage['user_name'].decode('utf-16le'),\n                            host_name=authenticateMessage['host_name'].decode('utf-16le')\n                        )\n                    except Exception as e:\n                        print(\"[!] Could not call auth_callback: %s\" % e)\n\n            else:\n                raise Exception(\"Unknown NTLMSSP MessageType %d\" % messageType)\n\n            respParameters['SecurityBlobLength'] = len(respToken)\n            respData['SecurityBlobLength'] = respParameters['SecurityBlobLength']\n            respData['SecurityBlob'] = respToken.getData()\n\n        else:\n            # Process Standard Security\n            respParameters = smb.SMBSessionSetupAndXResponse_Parameters()\n            respData = smb.SMBSessionSetupAndXResponse_Data()\n            sessionSetupParameters = smb.SMBSessionSetupAndX_Parameters(SMBCommand['Parameters'])\n            sessionSetupData = smb.SMBSessionSetupAndX_Data()\n            sessionSetupData['AnsiPwdLength'] = sessionSetupParameters['AnsiPwdLength']\n            sessionSetupData['UnicodePwdLength'] = sessionSetupParameters['UnicodePwdLength']\n            sessionSetupData.fromString(SMBCommand['Data'])\n            connData['Capabilities'] = sessionSetupParameters['Capabilities']\n            # Do the verification here, for just now we grant access\n            # TODO: Manage more UIDs for the same session\n            errorCode = STATUS_SUCCESS\n            connData['Uid'] = 10\n            connData['Authenticated'] = True\n            respParameters['Action'] = 0\n            smbServer.log('User %s\\\\%s authenticated successfully (basic)' % (\n            sessionSetupData['PrimaryDomain'], sessionSetupData['Account']))\n            try:\n                jtr_dump_path = smbServer.getJTRdumpPath()\n                ntlm_hash_data = outputToJohnFormat(b'', b(sessionSetupData['Account']),\n                                                    b(sessionSetupData['PrimaryDomain']), sessionSetupData['AnsiPwd'],\n                                                    sessionSetupData['UnicodePwd'])\n                smbServer.log(ntlm_hash_data['hash_string'])\n                if jtr_dump_path != '':\n                    writeJohnOutputToFile(ntlm_hash_data['hash_string'], ntlm_hash_data['hash_version'], jtr_dump_path)\n            except:\n                smbServer.log(\"Could not write NTLM Hashes to the specified JTR_Dump_Path %s\" % jtr_dump_path)\n\n        respData['NativeOS'] = encodeSMBString(recvPacket['Flags2'], smbServer.getServerOS())\n        respData['NativeLanMan'] = encodeSMBString(recvPacket['Flags2'], smbServer.getServerOS())\n        respSMBCommand['Parameters'] = respParameters\n        respSMBCommand['Data'] = respData\n\n        # From now on, the client can ask for other commands\n        connData['Authenticated'] = True\n        # For now, just switching to nobody\n        # os.setregid(65534,65534)\n        # os.setreuid(65534,65534)\n        smbServer.setConnectionData(connId, connData)\n\n        return [respSMBCommand], None, errorCode\n\n    @staticmethod\n    def smbComNegotiate(connId, smbServer, SMBCommand, recvPacket):\n        connData = smbServer.getConnectionData(connId, checkStatus=False)\n        connData['Pid'] = recvPacket['Pid']\n\n        SMBCommand = smb.SMBCommand(recvPacket['Data'][0])\n        respSMBCommand = smb.SMBCommand(smb.SMB.SMB_COM_NEGOTIATE)\n\n        resp = smb.NewSMBPacket()\n        resp['Flags1'] = smb.SMB.FLAGS1_REPLY\n        resp['Pid'] = connData['Pid']\n        resp['Tid'] = recvPacket['Tid']\n        resp['Mid'] = recvPacket['Mid']\n\n        # TODO: We support more dialects, and parse them accordingly\n        dialects = SMBCommand['Data'].split(b'\\x02')\n        try:\n            index = dialects.index(b'NT LM 0.12\\x00') - 1\n            # Let's fill the data for NTLM\n            if recvPacket['Flags2'] & smb.SMB.FLAGS2_EXTENDED_SECURITY:\n                resp['Flags2'] = smb.SMB.FLAGS2_EXTENDED_SECURITY | smb.SMB.FLAGS2_NT_STATUS | smb.SMB.FLAGS2_UNICODE\n                # resp['Flags2'] = smb.SMB.FLAGS2_EXTENDED_SECURITY | smb.SMB.FLAGS2_NT_STATUS\n                _dialects_data = smb.SMBExtended_Security_Data()\n                _dialects_data['ServerGUID'] = b'A' * 16\n                blob = SPNEGO_NegTokenInit()\n                blob['MechTypes'] = [TypesMech['NTLMSSP - Microsoft NTLM Security Support Provider']]\n                _dialects_data['SecurityBlob'] = blob.getData()\n\n                _dialects_parameters = smb.SMBExtended_Security_Parameters()\n                _dialects_parameters[\n                    'Capabilities'] = smb.SMB.CAP_EXTENDED_SECURITY | smb.SMB.CAP_USE_NT_ERRORS | smb.SMB.CAP_NT_SMBS | smb.SMB.CAP_UNICODE\n                _dialects_parameters['ChallengeLength'] = 0\n\n            else:\n                resp['Flags2'] = smb.SMB.FLAGS2_NT_STATUS | smb.SMB.FLAGS2_UNICODE\n                _dialects_parameters = smb.SMBNTLMDialect_Parameters()\n                _dialects_data = smb.SMBNTLMDialect_Data()\n                _dialects_data['Payload'] = ''\n                if 'EncryptionKey' in connData:\n                    _dialects_data['Challenge'] = connData['EncryptionKey']\n                    _dialects_parameters['ChallengeLength'] = len(_dialects_data.getData())\n                else:\n                    # TODO: Handle random challenges, now one that can be used with rainbow tables\n                    _dialects_data['Challenge'] = b'\\x11\\x22\\x33\\x44\\x55\\x66\\x77\\x88'\n                    _dialects_parameters['ChallengeLength'] = 8\n                _dialects_parameters['Capabilities'] = smb.SMB.CAP_USE_NT_ERRORS | smb.SMB.CAP_NT_SMBS\n\n                # Let's see if we need to support RPC_REMOTE_APIS\n            config = smbServer.getServerConfig()\n            if config.has_option('global', 'rpc_apis'):\n                if config.getboolean('global', 'rpc_apis') is True:\n                    _dialects_parameters['Capabilities'] |= smb.SMB.CAP_RPC_REMOTE_APIS\n\n            _dialects_parameters['DialectIndex'] = index\n            # _dialects_parameters['SecurityMode']    = smb.SMB.SECURITY_AUTH_ENCRYPTED | smb.SMB.SECURITY_SHARE_USER | smb.SMB.SECURITY_SIGNATURES_REQUIRED\n            _dialects_parameters['SecurityMode'] = smb.SMB.SECURITY_AUTH_ENCRYPTED | smb.SMB.SECURITY_SHARE_USER\n            _dialects_parameters['MaxMpxCount'] = 1\n            _dialects_parameters['MaxNumberVcs'] = 1\n            _dialects_parameters['MaxBufferSize'] = 64000\n            _dialects_parameters['MaxRawSize'] = 65536\n            _dialects_parameters['SessionKey'] = 0\n            _dialects_parameters['LowDateTime'] = 0\n            _dialects_parameters['HighDateTime'] = 0\n            _dialects_parameters['ServerTimeZone'] = 0\n\n            respSMBCommand['Data'] = _dialects_data\n            respSMBCommand['Parameters'] = _dialects_parameters\n            connData['_dialects_data'] = _dialects_data\n            connData['_dialects_parameters'] = _dialects_parameters\n\n        except Exception as e:\n            # No NTLM throw an error\n            smbServer.log('smbComNegotiate: %s' % e, logging.ERROR)\n            respSMBCommand['Data'] = struct.pack('<H', 0xffff)\n\n        smbServer.setConnectionData(connId, connData)\n\n        resp.addCommand(respSMBCommand)\n\n        return None, [resp], STATUS_SUCCESS\n\n    @staticmethod\n    def default(connId, smbServer, SMBCommand, recvPacket):\n        # By default we return an SMB Packet with error not implemented\n        smbServer.log(\"Not implemented command: 0x%x\" % recvPacket['Command'], logging.DEBUG)\n        packet = smb.NewSMBPacket()\n        packet['Flags1'] = smb.SMB.FLAGS1_REPLY\n        packet['Flags2'] = smb.SMB.FLAGS2_NT_STATUS\n        packet['Command'] = recvPacket['Command']\n        packet['Pid'] = recvPacket['Pid']\n        packet['Tid'] = recvPacket['Tid']\n        packet['Mid'] = recvPacket['Mid']\n        packet['Uid'] = recvPacket['Uid']\n        packet['Data'] = b'\\x00\\x00\\x00'\n        errorCode = STATUS_NOT_IMPLEMENTED\n        packet['ErrorCode'] = errorCode >> 16\n        packet['ErrorClass'] = errorCode & 0xff\n\n        return None, [packet], errorCode",
  "class SMB2Commands:\n    @staticmethod\n    def smb2Negotiate(connId, smbServer, recvPacket, isSMB1=False):\n        connData = smbServer.getConnectionData(connId, checkStatus=False)\n\n        respPacket = smb2.SMB2Packet()\n        respPacket['Flags'] = smb2.SMB2_FLAGS_SERVER_TO_REDIR\n        respPacket['Status'] = STATUS_SUCCESS\n        respPacket['CreditRequestResponse'] = 1\n        respPacket['Command'] = smb2.SMB2_NEGOTIATE\n        respPacket['SessionID'] = 0\n        if isSMB1 is False:\n            respPacket['MessageID'] = recvPacket['MessageID']\n        else:\n            respPacket['MessageID'] = 0\n        respPacket['TreeID'] = 0\n\n        respSMBCommand = smb2.SMB2Negotiate_Response()\n\n        respSMBCommand['SecurityMode'] = 1\n        if isSMB1 is True:\n            # Let's first parse the packet to see if the client supports SMB2\n            SMBCommand = smb.SMBCommand(recvPacket['Data'][0])\n\n            dialects = SMBCommand['Data'].split(b'\\x02')\n            if b'SMB 2.002\\x00' in dialects or b'SMB 2.???\\x00' in dialects:\n                respSMBCommand['DialectRevision'] = smb2.SMB2_DIALECT_002\n            else:\n                # Client does not support SMB2 fallbacking\n                raise Exception('SMB2 not supported, fallbacking')\n        else:\n            respSMBCommand['DialectRevision'] = smb2.SMB2_DIALECT_002\n        respSMBCommand['ServerGuid'] = b'A' * 16\n        respSMBCommand['Capabilities'] = 0\n        respSMBCommand['MaxTransactSize'] = 65536\n        respSMBCommand['MaxReadSize'] = 65536\n        respSMBCommand['MaxWriteSize'] = 65536\n        respSMBCommand['SystemTime'] = getFileTime(calendar.timegm(time.gmtime()))\n        respSMBCommand['ServerStartTime'] = getFileTime(calendar.timegm(time.gmtime()))\n        respSMBCommand['SecurityBufferOffset'] = 0x80\n\n        blob = SPNEGO_NegTokenInit()\n        blob['MechTypes'] = [TypesMech['NTLMSSP - Microsoft NTLM Security Support Provider']]\n\n        respSMBCommand['Buffer'] = blob.getData()\n        respSMBCommand['SecurityBufferLength'] = len(respSMBCommand['Buffer'])\n\n        respPacket['Data'] = respSMBCommand\n\n        smbServer.setConnectionData(connId, connData)\n\n        return None, [respPacket], STATUS_SUCCESS\n\n    @staticmethod\n    def smb2SessionSetup(connId, smbServer, recvPacket):\n        connData = smbServer.getConnectionData(connId, checkStatus=False)\n\n        respSMBCommand = smb2.SMB2SessionSetup_Response()\n\n        sessionSetupData = smb2.SMB2SessionSetup(recvPacket['Data'])\n\n        connData['Capabilities'] = sessionSetupData['Capabilities']\n\n        securityBlob = sessionSetupData['Buffer']\n\n        rawNTLM = False\n        if struct.unpack('B', securityBlob[0:1])[0] == ASN1_AID:\n            # NEGOTIATE packet\n            blob = SPNEGO_NegTokenInit(securityBlob)\n            token = blob['MechToken']\n            if len(blob['MechTypes'][0]) > 0:\n                # Is this GSSAPI NTLM or something else we don't support?\n                mechType = blob['MechTypes'][0]\n                if mechType != TypesMech['NTLMSSP - Microsoft NTLM Security Support Provider']:\n                    # Nope, do we know it?\n                    if mechType in MechTypes:\n                        mechStr = MechTypes[mechType]\n                    else:\n                        mechStr = hexlify(mechType)\n                    smbServer.log(\"Unsupported MechType '%s'\" % mechStr, logging.CRITICAL)\n                    # We don't know the token, we answer back again saying\n                    # we just support NTLM.\n                    # ToDo: Build this into a SPNEGO_NegTokenResp()\n                    respToken = b'\\xa1\\x15\\x30\\x13\\xa0\\x03\\x0a\\x01\\x03\\xa1\\x0c\\x06\\x0a\\x2b\\x06\\x01\\x04\\x01\\x82\\x37\\x02\\x02\\x0a'\n                    respSMBCommand['SecurityBufferOffset'] = 0x48\n                    respSMBCommand['SecurityBufferLength'] = len(respToken)\n                    respSMBCommand['Buffer'] = respToken\n\n                    return [respSMBCommand], None, STATUS_MORE_PROCESSING_REQUIRED\n        elif struct.unpack('B', securityBlob[0:1])[0] == ASN1_SUPPORTED_MECH:\n            # AUTH packet\n            blob = SPNEGO_NegTokenResp(securityBlob)\n            token = blob['ResponseToken']\n        else:\n            # No GSSAPI stuff, raw NTLMSSP\n            rawNTLM = True\n            token = securityBlob\n\n        # Here we only handle NTLMSSP, depending on what stage of the\n        # authentication we are, we act on it\n        messageType = struct.unpack('<L', token[len('NTLMSSP\\x00'):len('NTLMSSP\\x00') + 4])[0]\n\n        if messageType == 0x01:\n            # NEGOTIATE_MESSAGE\n            negotiateMessage = ntlm.NTLMAuthNegotiate()\n            negotiateMessage.fromString(token)\n            # Let's store it in the connection data\n            connData['NEGOTIATE_MESSAGE'] = negotiateMessage\n            # Let's build the answer flags\n            # TODO: Parse all the flags. With this we're leaving some clients out\n\n            ansFlags = 0\n\n            if negotiateMessage['flags'] & ntlm.NTLMSSP_NEGOTIATE_56:\n                ansFlags |= ntlm.NTLMSSP_NEGOTIATE_56\n            if negotiateMessage['flags'] & ntlm.NTLMSSP_NEGOTIATE_128:\n                ansFlags |= ntlm.NTLMSSP_NEGOTIATE_128\n            if negotiateMessage['flags'] & ntlm.NTLMSSP_NEGOTIATE_KEY_EXCH:\n                ansFlags |= ntlm.NTLMSSP_NEGOTIATE_KEY_EXCH\n            if negotiateMessage['flags'] & ntlm.NTLMSSP_NEGOTIATE_EXTENDED_SESSIONSECURITY:\n                ansFlags |= ntlm.NTLMSSP_NEGOTIATE_EXTENDED_SESSIONSECURITY\n            if negotiateMessage['flags'] & ntlm.NTLMSSP_NEGOTIATE_UNICODE:\n                ansFlags |= ntlm.NTLMSSP_NEGOTIATE_UNICODE\n            if negotiateMessage['flags'] & ntlm.NTLM_NEGOTIATE_OEM:\n                ansFlags |= ntlm.NTLM_NEGOTIATE_OEM\n\n            ansFlags |= ntlm.NTLMSSP_NEGOTIATE_VERSION | ntlm.NTLMSSP_NEGOTIATE_TARGET_INFO | ntlm.NTLMSSP_TARGET_TYPE_SERVER | ntlm.NTLMSSP_NEGOTIATE_NTLM | ntlm.NTLMSSP_REQUEST_TARGET\n\n            # Generate the AV_PAIRS\n            av_pairs = ntlm.AV_PAIRS()\n            # TODO: Put the proper data from SMBSERVER config\n            av_pairs[ntlm.NTLMSSP_AV_HOSTNAME] = av_pairs[\n                ntlm.NTLMSSP_AV_DNS_HOSTNAME] = smbServer.getServerName().encode('utf-16le')\n            av_pairs[ntlm.NTLMSSP_AV_DOMAINNAME] = av_pairs[\n                ntlm.NTLMSSP_AV_DNS_DOMAINNAME] = smbServer.getServerDomain().encode('utf-16le')\n            av_pairs[ntlm.NTLMSSP_AV_TIME] = struct.pack('<q', (\n                        116444736000000000 + calendar.timegm(time.gmtime()) * 10000000))\n\n            challengeMessage = ntlm.NTLMAuthChallenge()\n            challengeMessage['flags'] = ansFlags\n            challengeMessage['domain_len'] = len(smbServer.getServerDomain().encode('utf-16le'))\n            challengeMessage['domain_max_len'] = challengeMessage['domain_len']\n            challengeMessage['domain_offset'] = 40 + 16\n            challengeMessage['challenge'] = smbServer.getSMBChallenge()\n            challengeMessage['domain_name'] = smbServer.getServerDomain().encode('utf-16le')\n            challengeMessage['TargetInfoFields_len'] = len(av_pairs)\n            challengeMessage['TargetInfoFields_max_len'] = len(av_pairs)\n            challengeMessage['TargetInfoFields'] = av_pairs\n            challengeMessage['TargetInfoFields_offset'] = 40 + 16 + len(challengeMessage['domain_name'])\n            challengeMessage['Version'] = b'\\xff' * 8\n            challengeMessage['VersionLen'] = 8\n\n            if rawNTLM is False:\n                respToken = SPNEGO_NegTokenResp()\n                # accept-incomplete. We want more data\n                respToken['NegState'] = b'\\x01'\n                respToken['SupportedMech'] = TypesMech['NTLMSSP - Microsoft NTLM Security Support Provider']\n\n                respToken['ResponseToken'] = challengeMessage.getData()\n            else:\n                respToken = challengeMessage\n\n            # Setting the packet to STATUS_MORE_PROCESSING\n            errorCode = STATUS_MORE_PROCESSING_REQUIRED\n            # Let's set up an UID for this connection and store it\n            # in the connection's data\n            # Picking a fixed value\n            # TODO: Manage more UIDs for the same session\n            connData['Uid'] = random.randint(1, 0xffffffff)\n            # Let's store it in the connection data\n            connData['CHALLENGE_MESSAGE'] = challengeMessage\n\n        elif messageType == 0x02:\n            # CHALLENGE_MESSAGE\n            raise Exception('Challenge Message raise, not implemented!')\n        elif messageType == 0x03:\n            # AUTHENTICATE_MESSAGE, here we deal with authentication\n            authenticateMessage = ntlm.NTLMAuthChallengeResponse()\n            authenticateMessage.fromString(token)\n            smbServer.log(\"AUTHENTICATE_MESSAGE (%s\\\\%s,%s)\" % (\n                authenticateMessage['domain_name'].decode('utf-16le'),\n                authenticateMessage['user_name'].decode('utf-16le'),\n                authenticateMessage['host_name'].decode('utf-16le')))\n\n            isGuest = False\n            isAnonymus = False\n\n            # TODO: Check the credentials! Now granting permissions\n            # Do we have credentials to check?\n            if len(smbServer.getCredentials()) > 0:\n                identity = authenticateMessage['user_name'].decode('utf-16le').lower()\n                # Do we have this user's credentials?\n                if identity in smbServer.getCredentials():\n                    # Process data:\n                    # Let's parse some data and keep it to ourselves in case it is asked\n                    uid, lmhash, nthash = smbServer.getCredentials()[identity]\n\n                    errorCode, sessionKey = computeNTLMv2(identity, lmhash, nthash, smbServer.getSMBChallenge(),\n                                                          authenticateMessage, connData['CHALLENGE_MESSAGE'],\n                                                          connData['NEGOTIATE_MESSAGE'])\n\n                    if sessionKey is not None:\n                        connData['SignatureEnabled'] = True\n                        connData['SigningSessionKey'] = sessionKey\n                        connData['SignSequenceNumber'] = 1\n                else:\n                    errorCode = STATUS_LOGON_FAILURE\n            else:\n                # No credentials provided, let's grant access\n                if authenticateMessage['flags'] & ntlm.NTLMSSP_NEGOTIATE_ANONYMOUS:\n                    isAnonymus = True\n                    if smbServer._SMBSERVER__anonymousLogon == False:\n                        errorCode = STATUS_ACCESS_DENIED\n                    else:\n                        errorCode = STATUS_SUCCESS\n                else:\n                    isGuest = True\n                    errorCode = STATUS_SUCCESS\n\n            if errorCode == STATUS_SUCCESS:\n                connData['Authenticated'] = True\n                respToken = SPNEGO_NegTokenResp()\n                # accept-completed\n                respToken['NegState'] = b'\\x00'\n                smbServer.log('User %s\\\\%s authenticated successfully' % (\n                    authenticateMessage['host_name'].decode('utf-16le'),\n                    authenticateMessage['user_name'].decode('utf-16le')))\n                # Let's store it in the connection data\n                connData['AUTHENTICATE_MESSAGE'] = authenticateMessage\n                try:\n                    jtr_dump_path = smbServer.getJTRdumpPath()\n                    ntlm_hash_data = outputToJohnFormat(connData['CHALLENGE_MESSAGE']['challenge'],\n                                                        authenticateMessage['user_name'],\n                                                        authenticateMessage['domain_name'],\n                                                        authenticateMessage['lanman'], authenticateMessage['ntlm'])\n                    smbServer.log(ntlm_hash_data['hash_string'])\n                    if jtr_dump_path != '':\n                        writeJohnOutputToFile(ntlm_hash_data['hash_string'], ntlm_hash_data['hash_version'],\n                                              jtr_dump_path)\n                except:\n                    smbServer.log(\"Could not write NTLM Hashes to the specified JTR_Dump_Path %s\" % jtr_dump_path)\n\n                if isGuest:\n                    respSMBCommand['SessionFlags'] = 1\n                elif isAnonymus:\n                    respSMBCommand['SessionFlags'] = 2\n\n            else:\n                respToken = SPNEGO_NegTokenResp()\n                respToken['NegState'] = b'\\x02'\n                smbServer.log(\"Could not authenticate user!\")\n\n            if smbServer.auth_callback is not None:\n                try:\n                    smbServer.auth_callback(\n                        smbServer=smbServer,\n                        connData=connData,\n                        domain_name=authenticateMessage['domain_name'].decode('utf-16le'),\n                        user_name=authenticateMessage['user_name'].decode('utf-16le'),\n                        host_name=authenticateMessage['host_name'].decode('utf-16le')\n                    )\n                except Exception as e:\n                    print(\"[!] Could not call auth_callback: %s\" % e)\n\n        else:\n            raise Exception(\"Unknown NTLMSSP MessageType %d\" % messageType)\n\n        respSMBCommand['SecurityBufferOffset'] = 0x48\n        respSMBCommand['SecurityBufferLength'] = len(respToken)\n        respSMBCommand['Buffer'] = respToken.getData()\n\n        # From now on, the client can ask for other commands\n        connData['Authenticated'] = True\n        # For now, just switching to nobody\n        # os.setregid(65534,65534)\n        # os.setreuid(65534,65534)\n        smbServer.setConnectionData(connId, connData)\n\n        return [respSMBCommand], None, errorCode\n\n    @staticmethod\n    def smb2TreeConnect(connId, smbServer, recvPacket):\n        connData = smbServer.getConnectionData(connId)\n\n        respPacket = smb2.SMB2Packet()\n        respPacket['Flags'] = smb2.SMB2_FLAGS_SERVER_TO_REDIR\n        respPacket['Status'] = STATUS_SUCCESS\n        respPacket['CreditRequestResponse'] = 1\n        respPacket['Command'] = recvPacket['Command']\n        respPacket['SessionID'] = connData['Uid']\n        respPacket['Reserved'] = recvPacket['Reserved']\n        respPacket['MessageID'] = recvPacket['MessageID']\n        respPacket['TreeID'] = recvPacket['TreeID']\n\n        respSMBCommand = smb2.SMB2TreeConnect_Response()\n\n        treeConnectRequest = smb2.SMB2TreeConnect(recvPacket['Data'])\n\n        errorCode = STATUS_SUCCESS\n\n        ## Process here the request, does the share exist?\n        path = recvPacket.getData()[treeConnectRequest['PathOffset']:][:treeConnectRequest['PathLength']]\n        UNCOrShare = path.decode('utf-16le')\n\n        # Is this a UNC?\n        if ntpath.ismount(UNCOrShare):\n            path = UNCOrShare.split('\\\\')[3]\n        else:\n            path = ntpath.basename(UNCOrShare)\n\n        share = searchShare(connId, path.upper(), smbServer)\n        if share is not None:\n            # Simple way to generate a Tid\n            if len(connData['ConnectedShares']) == 0:\n                tid = 1\n            else:\n                tid = list(connData['ConnectedShares'].keys())[-1] + 1\n            connData['ConnectedShares'][tid] = share\n            connData['ConnectedShares'][tid]['shareName'] = path\n            respPacket['TreeID'] = tid\n            smbServer.log(\"Connecting Share(%d:%s)\" % (tid, path))\n        else:\n            smbServer.log(\"SMB2_TREE_CONNECT not found %s\" % path, logging.ERROR)\n            errorCode = STATUS_OBJECT_PATH_NOT_FOUND\n            respPacket['Status'] = errorCode\n        ##\n\n        if path.upper() == 'IPC$':\n            respSMBCommand['ShareType'] = smb2.SMB2_SHARE_TYPE_PIPE\n            respSMBCommand['ShareFlags'] = 0x30\n        else:\n            respSMBCommand['ShareType'] = smb2.SMB2_SHARE_TYPE_DISK\n            respSMBCommand['ShareFlags'] = 0x0\n\n        respSMBCommand['Capabilities'] = 0\n        respSMBCommand['MaximalAccess'] = 0x000f01ff\n\n        respPacket['Data'] = respSMBCommand\n\n        # Sign the packet if needed\n        if connData['SignatureEnabled']:\n            smbServer.signSMBv2(respPacket, connData['SigningSessionKey'])\n        smbServer.setConnectionData(connId, connData)\n\n        return None, [respPacket], errorCode\n\n    @staticmethod\n    def smb2Create(connId, smbServer, recvPacket):\n        connData = smbServer.getConnectionData(connId)\n\n        respSMBCommand = smb2.SMB2Create_Response()\n\n        ntCreateRequest = smb2.SMB2Create(recvPacket['Data'])\n\n        respSMBCommand['Buffer'] = b'\\x00'\n        # Get the Tid associated\n        if recvPacket['TreeID'] in connData['ConnectedShares']:\n            # If we have a rootFid, the path is relative to that fid\n            errorCode = STATUS_SUCCESS\n            if 'path' in connData['ConnectedShares'][recvPacket['TreeID']]:\n                path = connData['ConnectedShares'][recvPacket['TreeID']]['path']\n            else:\n                path = 'NONE'\n                errorCode = STATUS_ACCESS_DENIED\n\n            deleteOnClose = False\n\n            fileName = normalize_path(ntCreateRequest['Buffer'][:ntCreateRequest['NameLength']].decode('utf-16le'))\n\n            if not isInFileJail(path, fileName):\n                LOG.error(\"Path not in current working directory\")\n                return [smb2.SMB2Error()], None, STATUS_OBJECT_PATH_SYNTAX_BAD\n\n            pathName = os.path.join(path, fileName)\n            createDisposition = ntCreateRequest['CreateDisposition']\n            mode = 0\n\n            if createDisposition == smb2.FILE_SUPERSEDE:\n                mode |= os.O_TRUNC | os.O_CREAT\n            elif createDisposition & smb2.FILE_OVERWRITE_IF == smb2.FILE_OVERWRITE_IF:\n                mode |= os.O_TRUNC | os.O_CREAT\n            elif createDisposition & smb2.FILE_OVERWRITE == smb2.FILE_OVERWRITE:\n                if os.path.exists(pathName) is True:\n                    mode |= os.O_TRUNC\n                else:\n                    errorCode = STATUS_NO_SUCH_FILE\n            elif createDisposition & smb2.FILE_OPEN_IF == smb2.FILE_OPEN_IF:\n                mode |= os.O_CREAT\n            elif createDisposition & smb2.FILE_CREATE == smb2.FILE_CREATE:\n                if os.path.exists(pathName) is True:\n                    errorCode = STATUS_OBJECT_NAME_COLLISION\n                else:\n                    mode |= os.O_CREAT\n            elif createDisposition & smb2.FILE_OPEN == smb2.FILE_OPEN:\n                if os.path.exists(pathName) is not True and (\n                        str(pathName) in smbServer.getRegisteredNamedPipes()) is not True:\n                    errorCode = STATUS_NO_SUCH_FILE\n\n            if errorCode == STATUS_SUCCESS:\n                desiredAccess = ntCreateRequest['DesiredAccess']\n                if (desiredAccess & smb2.FILE_READ_DATA) or (desiredAccess & smb2.GENERIC_READ):\n                    mode |= os.O_RDONLY\n                if (desiredAccess & smb2.FILE_WRITE_DATA) or (desiredAccess & smb2.GENERIC_WRITE):\n                    if (desiredAccess & smb2.FILE_READ_DATA) or (desiredAccess & smb2.GENERIC_READ):\n                        mode |= os.O_RDWR  # | os.O_APPEND\n                    else:\n                        mode |= os.O_WRONLY  # | os.O_APPEND\n                if desiredAccess & smb2.GENERIC_ALL:\n                    mode |= os.O_RDWR  # | os.O_APPEND\n\n                createOptions = ntCreateRequest['CreateOptions']\n                if mode & os.O_CREAT == os.O_CREAT:\n                    if createOptions & smb2.FILE_DIRECTORY_FILE == smb2.FILE_DIRECTORY_FILE:\n                        try:\n                            # Let's create the directory\n                            os.mkdir(pathName)\n                            mode = os.O_RDONLY\n                        except Exception as e:\n                            smbServer.log(\"SMB2_CREATE: %s,%s,%s\" % (pathName, mode, e), logging.ERROR)\n                            errorCode = STATUS_ACCESS_DENIED\n                if createOptions & smb2.FILE_NON_DIRECTORY_FILE == smb2.FILE_NON_DIRECTORY_FILE:\n                    # If the file being opened is a directory, the server MUST fail the request with\n                    # STATUS_FILE_IS_A_DIRECTORY in the Status field of the SMB Header in the server\n                    # response.\n                    if os.path.isdir(pathName) is True:\n                        errorCode = STATUS_FILE_IS_A_DIRECTORY\n\n                if createOptions & smb2.FILE_DELETE_ON_CLOSE == smb2.FILE_DELETE_ON_CLOSE:\n                    deleteOnClose = True\n\n                if errorCode == STATUS_SUCCESS:\n                    try:\n                        if os.path.isdir(pathName) and sys.platform == 'win32':\n                            fid = VOID_FILE_DESCRIPTOR\n                        else:\n                            if sys.platform == 'win32':\n                                mode |= os.O_BINARY\n                            if str(pathName) in smbServer.getRegisteredNamedPipes():\n                                fid = PIPE_FILE_DESCRIPTOR\n                                sock = socket.socket()\n                                sock.connect(smbServer.getRegisteredNamedPipes()[str(pathName)])\n                            else:\n                                fid = os.open(pathName, mode)\n                    except Exception as e:\n                        smbServer.log(\"SMB2_CREATE: %s,%s,%s\" % (pathName, mode, e), logging.ERROR)\n                        # print e\n                        fid = 0\n                        errorCode = STATUS_ACCESS_DENIED\n        else:\n            errorCode = STATUS_SMB_BAD_TID\n\n        if errorCode == STATUS_SUCCESS:\n            # Simple way to generate a fid\n            fakefid = uuid.generate()\n\n            respSMBCommand['FileID'] = fakefid\n            respSMBCommand['CreateAction'] = createDisposition\n\n            if fid == PIPE_FILE_DESCRIPTOR:\n                respSMBCommand['CreationTime'] = 0\n                respSMBCommand['LastAccessTime'] = 0\n                respSMBCommand['LastWriteTime'] = 0\n                respSMBCommand['ChangeTime'] = 0\n                respSMBCommand['AllocationSize'] = 4096\n                respSMBCommand['EndOfFile'] = 0\n                respSMBCommand['FileAttributes'] = 0x80\n\n            else:\n                if os.path.isdir(pathName):\n                    respSMBCommand['FileAttributes'] = smb.SMB_FILE_ATTRIBUTE_DIRECTORY\n                else:\n                    respSMBCommand['FileAttributes'] = ntCreateRequest['FileAttributes']\n                # Let's get this file's information\n                respInfo, errorCode = queryPathInformation(path, fileName, level=smb.SMB_QUERY_FILE_ALL_INFO)\n                if errorCode == STATUS_SUCCESS:\n                    respSMBCommand['CreationTime'] = respInfo['CreationTime']\n                    respSMBCommand['LastAccessTime'] = respInfo['LastAccessTime']\n                    respSMBCommand['LastWriteTime'] = respInfo['LastWriteTime']\n                    respSMBCommand['LastChangeTime'] = respInfo['LastChangeTime']\n                    respSMBCommand['FileAttributes'] = respInfo['ExtFileAttributes']\n                    respSMBCommand['AllocationSize'] = respInfo['AllocationSize']\n                    respSMBCommand['EndOfFile'] = respInfo['EndOfFile']\n\n            if errorCode == STATUS_SUCCESS:\n                # Let's store the fid for the connection\n                # smbServer.log('Create file %s, mode:0x%x' % (pathName, mode))\n                connData['OpenedFiles'][fakefid] = {}\n                connData['OpenedFiles'][fakefid]['FileHandle'] = fid\n                connData['OpenedFiles'][fakefid]['FileName'] = pathName\n                connData['OpenedFiles'][fakefid]['DeleteOnClose'] = deleteOnClose\n                connData['OpenedFiles'][fakefid]['Open'] = {}\n                connData['OpenedFiles'][fakefid]['Open']['EnumerationLocation'] = 0\n                connData['OpenedFiles'][fakefid]['Open']['EnumerationSearchPattern'] = ''\n                if fid == PIPE_FILE_DESCRIPTOR:\n                    connData['OpenedFiles'][fakefid]['Socket'] = sock\n        else:\n            respSMBCommand = smb2.SMB2Error()\n\n        if errorCode == STATUS_SUCCESS:\n            connData['LastRequest']['SMB2_CREATE'] = respSMBCommand\n        smbServer.setConnectionData(connId, connData)\n\n        return [respSMBCommand], None, errorCode\n\n    @staticmethod\n    def smb2Close(connId, smbServer, recvPacket):\n        connData = smbServer.getConnectionData(connId)\n\n        respSMBCommand = smb2.SMB2Close_Response()\n\n        closeRequest = smb2.SMB2Close(recvPacket['Data'])\n\n        if closeRequest['FileID'].getData() == b'\\xff' * 16:\n            # Let's take the data from the lastRequest\n            if 'SMB2_CREATE' in connData['LastRequest']:\n                fileID = connData['LastRequest']['SMB2_CREATE']['FileID']\n            else:\n                fileID = closeRequest['FileID'].getData()\n        else:\n            fileID = closeRequest['FileID'].getData()\n\n        # Get the Tid associated\n        if recvPacket['TreeID'] in connData['ConnectedShares']:\n            if fileID in connData['OpenedFiles']:\n                errorCode = STATUS_SUCCESS\n                fileHandle = connData['OpenedFiles'][fileID]['FileHandle']\n                pathName = connData['OpenedFiles'][fileID]['FileName']\n                infoRecord = None\n                try:\n                    if fileHandle == PIPE_FILE_DESCRIPTOR:\n                        connData['OpenedFiles'][fileID]['Socket'].close()\n                    elif fileHandle != VOID_FILE_DESCRIPTOR:\n                        os.close(fileHandle)\n                        infoRecord, errorCode = queryFileInformation(os.path.dirname(pathName), os.path.basename(pathName),\n                                                                     smb2.SMB2_FILE_NETWORK_OPEN_INFO)\n                except Exception as e:\n                    smbServer.log(\"SMB2_CLOSE %s\" % e, logging.ERROR)\n                    errorCode = STATUS_INVALID_HANDLE\n                else:\n                    # Check if the file was marked for removal\n                    if connData['OpenedFiles'][fileID]['DeleteOnClose'] is True:\n                        try:\n                            if os.path.isdir(pathName):\n                                shutil.rmtree(connData['OpenedFiles'][fileID]['FileName'])\n                            else:\n                                os.remove(connData['OpenedFiles'][fileID]['FileName'])\n                        except Exception as e:\n                            smbServer.log(\"SMB2_CLOSE %s\" % e, logging.ERROR)\n                            errorCode = STATUS_ACCESS_DENIED\n\n                    # Now fill out the response\n                    if infoRecord is not None:\n                        respSMBCommand['CreationTime'] = infoRecord['CreationTime']\n                        respSMBCommand['LastAccessTime'] = infoRecord['LastAccessTime']\n                        respSMBCommand['LastWriteTime'] = infoRecord['LastWriteTime']\n                        respSMBCommand['ChangeTime'] = infoRecord['ChangeTime']\n                        respSMBCommand['AllocationSize'] = infoRecord['AllocationSize']\n                        respSMBCommand['EndofFile'] = infoRecord['EndOfFile']\n                        respSMBCommand['FileAttributes'] = infoRecord['FileAttributes']\n                    if errorCode == STATUS_SUCCESS:\n                        del (connData['OpenedFiles'][fileID])\n            else:\n                errorCode = STATUS_INVALID_HANDLE\n        else:\n            errorCode = STATUS_SMB_BAD_TID\n\n        smbServer.setConnectionData(connId, connData)\n        return [respSMBCommand], None, errorCode\n\n    @staticmethod\n    def smb2QueryInfo(connId, smbServer, recvPacket):\n        connData = smbServer.getConnectionData(connId)\n\n        respSMBCommand = smb2.SMB2QueryInfo_Response()\n\n        queryInfo = smb2.SMB2QueryInfo(recvPacket['Data'])\n\n        errorCode = STATUS_SUCCESS\n\n        respSMBCommand['OutputBufferOffset'] = 0x48\n        respSMBCommand['Buffer'] = b'\\x00'\n\n        if queryInfo['FileID'].getData() == b'\\xff' * 16:\n            # Let's take the data from the lastRequest\n            if 'SMB2_CREATE' in connData['LastRequest']:\n                fileID = connData['LastRequest']['SMB2_CREATE']['FileID']\n            else:\n                fileID = queryInfo['FileID'].getData()\n        else:\n            fileID = queryInfo['FileID'].getData()\n\n        # Get the Tid associated\n        if recvPacket['TreeID'] in connData['ConnectedShares']:\n            if fileID in connData['OpenedFiles']:\n                fileName = connData['OpenedFiles'][fileID]['FileName']\n\n                if queryInfo['InfoType'] == smb2.SMB2_0_INFO_FILE:\n                    if queryInfo['FileInfoClass'] == smb2.SMB2_FILE_INTERNAL_INFO:\n                        # No need to call queryFileInformation, we have the data here\n                        infoRecord = smb2.FILE_INTERNAL_INFORMATION()\n                        infoRecord['IndexNumber'] = fileID\n                    else:\n                        infoRecord, errorCode = queryFileInformation(os.path.dirname(fileName),\n                                                                     os.path.basename(fileName),\n                                                                     queryInfo['FileInfoClass'])\n                elif queryInfo['InfoType'] == smb2.SMB2_0_INFO_FILESYSTEM:\n                    if queryInfo['FileInfoClass'] == smb2.SMB2_FILE_EA_INFO:\n                        infoRecord = b'\\x00' * 4\n                    else:\n                        infoRecord = queryFsInformation(os.path.dirname(fileName), os.path.basename(fileName),\n                                                        queryInfo['FileInfoClass'])\n                elif queryInfo['InfoType'] == smb2.SMB2_0_INFO_SECURITY:\n                    # Failing for now, until we support it\n                    infoRecord = None\n                    errorCode = STATUS_ACCESS_DENIED\n                else:\n                    smbServer.log(\"queryInfo not supported (%x)\" % queryInfo['InfoType'], logging.ERROR)\n\n                if infoRecord is not None:\n                    respSMBCommand['OutputBufferLength'] = len(infoRecord)\n                    respSMBCommand['Buffer'] = infoRecord\n            else:\n                errorCode = STATUS_INVALID_HANDLE\n        else:\n            errorCode = STATUS_SMB_BAD_TID\n\n        smbServer.setConnectionData(connId, connData)\n        return [respSMBCommand], None, errorCode\n\n    @staticmethod\n    def smb2SetInfo(connId, smbServer, recvPacket):\n        connData = smbServer.getConnectionData(connId)\n\n        respSMBCommand = smb2.SMB2SetInfo_Response()\n\n        setInfo = smb2.SMB2SetInfo(recvPacket['Data'])\n\n        errorCode = STATUS_SUCCESS\n\n        if setInfo['FileID'].getData() == b'\\xff' * 16:\n            # Let's take the data from the lastRequest\n            if 'SMB2_CREATE' in connData['LastRequest']:\n                fileID = connData['LastRequest']['SMB2_CREATE']['FileID']\n            else:\n                fileID = setInfo['FileID'].getData()\n        else:\n            fileID = setInfo['FileID'].getData()\n\n        # Get the Tid associated\n        if recvPacket['TreeID'] in connData['ConnectedShares']:\n            path = connData['ConnectedShares'][recvPacket['TreeID']]['path']\n            if fileID in connData['OpenedFiles']:\n                pathName = connData['OpenedFiles'][fileID]['FileName']\n\n                if setInfo['InfoType'] == smb2.SMB2_0_INFO_FILE:\n                    # The file information is being set\n                    informationLevel = setInfo['FileInfoClass']\n                    if informationLevel == smb2.SMB2_FILE_DISPOSITION_INFO:\n                        infoRecord = smb.SMBSetFileDispositionInfo(setInfo['Buffer'])\n                        if infoRecord['DeletePending'] > 0:\n                            # Mark this file for removal after closed\n                            connData['OpenedFiles'][fileID]['DeleteOnClose'] = True\n                    elif informationLevel == smb2.SMB2_FILE_BASIC_INFO:\n                        infoRecord = smb.SMBSetFileBasicInfo(setInfo['Buffer'])\n                        # Creation time won't be set,  the other ones we play with.\n                        atime = infoRecord['LastWriteTime']\n                        if atime == 0:\n                            atime = -1\n                        else:\n                            atime = getUnixTime(atime)\n                        mtime = infoRecord['ChangeTime']\n                        if mtime == 0:\n                            mtime = -1\n                        else:\n                            mtime = getUnixTime(mtime)\n                        if atime > 0 and mtime > 0:\n                            os.utime(pathName, (atime, mtime))\n                    elif informationLevel == smb2.SMB2_FILE_END_OF_FILE_INFO:\n                        fileHandle = connData['OpenedFiles'][fileID]['FileHandle']\n                        infoRecord = smb.SMBSetFileEndOfFileInfo(setInfo['Buffer'])\n                        if infoRecord['EndOfFile'] > 0:\n                            os.lseek(fileHandle, infoRecord['EndOfFile'] - 1, 0)\n                            os.write(fileHandle, b'\\x00')\n                    elif informationLevel == smb2.SMB2_FILE_RENAME_INFO:\n                        renameInfo = smb2.FILE_RENAME_INFORMATION_TYPE_2(setInfo['Buffer'])\n                        newFileName = normalize_path(renameInfo['FileName'].decode('utf-16le'))\n                        newPathName = os.path.join(path, newFileName)\n                        if not isInFileJail(path, newFileName):\n                            smbServer.log(\"Path not in current working directory\", logging.ERROR)\n                            return [smb2.SMB2Error()], None, STATUS_OBJECT_PATH_SYNTAX_BAD\n\n                        if renameInfo['ReplaceIfExists'] == 0 and os.path.exists(newPathName):\n                            return [smb2.SMB2Error()], None, STATUS_OBJECT_NAME_COLLISION\n                        try:\n                            os.rename(pathName, newPathName)\n                            connData['OpenedFiles'][fileID]['FileName'] = newPathName\n                        except Exception as e:\n                            smbServer.log(\"smb2SetInfo: %s\" % e, logging.ERROR)\n                            errorCode = STATUS_ACCESS_DENIED\n                    elif informationLevel == smb2.SMB2_FILE_ALLOCATION_INFO:\n                        # See https://github.com/samba-team/samba/blob/master/source3/smbd/smb2_trans2.c#LL5201C8-L5201C39\n                        smbServer.log(\"Warning: SMB2_FILE_ALLOCATION_INFO not implemented\")\n                        errorCode = STATUS_SUCCESS\n                    else:\n                        smbServer.log('Unknown level for set file info! 0x%x' % informationLevel, logging.ERROR)\n                        # UNSUPPORTED\n                        errorCode = STATUS_NOT_SUPPORTED\n                # elif setInfo['InfoType'] == smb2.SMB2_0_INFO_FILESYSTEM:\n                #    # The underlying object store information is being set.\n                #    setInfo = queryFsInformation('/', fileName, queryInfo['FileInfoClass'])\n                # elif setInfo['InfoType'] == smb2.SMB2_0_INFO_SECURITY:\n                #    # The security information is being set.\n                #    # Failing for now, until we support it\n                #    infoRecord = None\n                #    errorCode = STATUS_ACCESS_DENIED\n                # elif setInfo['InfoType'] == smb2.SMB2_0_INFO_QUOTA:\n                #    # The underlying object store quota information is being set.\n                #    setInfo = queryFsInformation('/', fileName, queryInfo['FileInfoClass'])\n                else:\n                    smbServer.log(\"setInfo not supported (%x)\" % setInfo['InfoType'], logging.ERROR)\n\n            else:\n                errorCode = STATUS_INVALID_HANDLE\n        else:\n            errorCode = STATUS_SMB_BAD_TID\n\n        smbServer.setConnectionData(connId, connData)\n        return [respSMBCommand], None, errorCode\n\n    @staticmethod\n    def smb2Write(connId, smbServer, recvPacket):\n        connData = smbServer.getConnectionData(connId)\n\n        respSMBCommand = smb2.SMB2Write_Response()\n        writeRequest = smb2.SMB2Write(recvPacket['Data'])\n\n        respSMBCommand['Buffer'] = b'\\x00'\n\n        if writeRequest['FileID'].getData() == b'\\xff' * 16:\n            # Let's take the data from the lastRequest\n            if 'SMB2_CREATE' in connData['LastRequest']:\n                fileID = connData['LastRequest']['SMB2_CREATE']['FileID']\n            else:\n                fileID = writeRequest['FileID'].getData()\n        else:\n            fileID = writeRequest['FileID'].getData()\n\n        # Get the Tid associated\n        if recvPacket['TreeID'] in connData['ConnectedShares']:\n            if fileID in connData['OpenedFiles']:\n                fileHandle = connData['OpenedFiles'][fileID]['FileHandle']\n                errorCode = STATUS_SUCCESS\n                try:\n                    if fileHandle != PIPE_FILE_DESCRIPTOR:\n                        offset = writeRequest['Offset']\n                        # If we're trying to write past the file end we just skip the write call (Vista does this)\n                        if os.lseek(fileHandle, 0, 2) >= offset:\n                            os.lseek(fileHandle, offset, 0)\n                            os.write(fileHandle, writeRequest['Buffer'])\n                    else:\n                        sock = connData['OpenedFiles'][fileID]['Socket']\n                        sock.send(writeRequest['Buffer'])\n\n                    respSMBCommand['Count'] = writeRequest['Length']\n                    respSMBCommand['Remaining'] = 0xff\n                except Exception as e:\n                    smbServer.log('SMB2_WRITE: %s' % e, logging.ERROR)\n                    errorCode = STATUS_ACCESS_DENIED\n            else:\n                errorCode = STATUS_INVALID_HANDLE\n        else:\n            errorCode = STATUS_SMB_BAD_TID\n\n        smbServer.setConnectionData(connId, connData)\n        return [respSMBCommand], None, errorCode\n\n    @staticmethod\n    def smb2Read(connId, smbServer, recvPacket):\n        connData = smbServer.getConnectionData(connId)\n\n        respSMBCommand = smb2.SMB2Read_Response()\n        readRequest = smb2.SMB2Read(recvPacket['Data'])\n\n        respSMBCommand['Buffer'] = b'\\x00'\n\n        if readRequest['FileID'].getData() == b'\\xff' * 16:\n            # Let's take the data from the lastRequest\n            if 'SMB2_CREATE' in connData['LastRequest']:\n                fileID = connData['LastRequest']['SMB2_CREATE']['FileID']\n            else:\n                fileID = readRequest['FileID'].getData()\n        else:\n            fileID = readRequest['FileID'].getData()\n\n        # Get the Tid associated\n        if recvPacket['TreeID'] in connData['ConnectedShares']:\n            if fileID in connData['OpenedFiles']:\n                fileHandle = connData['OpenedFiles'][fileID]['FileHandle']\n                errorCode = 0\n                try:\n                    if fileHandle != PIPE_FILE_DESCRIPTOR:\n                        offset = readRequest['Offset']\n                        os.lseek(fileHandle, offset, 0)\n                        content = os.read(fileHandle, readRequest['Length'])\n                    else:\n                        sock = connData['OpenedFiles'][fileID]['Socket']\n                        content = sock.recv(readRequest['Length'])\n\n                    respSMBCommand['DataOffset'] = 0x50\n                    respSMBCommand['DataLength'] = len(content)\n                    respSMBCommand['DataRemaining'] = 0\n                    respSMBCommand['Buffer'] = content\n                except Exception as e:\n                    smbServer.log('SMB2_READ: %s ' % e, logging.ERROR)\n                    errorCode = STATUS_ACCESS_DENIED\n            else:\n                errorCode = STATUS_INVALID_HANDLE\n        else:\n            errorCode = STATUS_SMB_BAD_TID\n\n        smbServer.setConnectionData(connId, connData)\n        return [respSMBCommand], None, errorCode\n\n    @staticmethod\n    def smb2Flush(connId, smbServer, recvPacket):\n        connData = smbServer.getConnectionData(connId)\n\n        respSMBCommand = smb2.SMB2Flush_Response()\n        flushRequest = smb2.SMB2Flush(recvPacket['Data'])\n\n        # Get the Tid associated\n        if recvPacket['TreeID'] in connData['ConnectedShares']:\n            if flushRequest['FileID'].getData() in connData['OpenedFiles']:\n                fileHandle = connData['OpenedFiles'][flushRequest['FileID'].getData()]['FileHandle']\n                errorCode = STATUS_SUCCESS\n                try:\n                    os.fsync(fileHandle)\n                except Exception as e:\n                    smbServer.log(\"SMB2_FLUSH %s\" % e, logging.ERROR)\n                    errorCode = STATUS_ACCESS_DENIED\n            else:\n                errorCode = STATUS_INVALID_HANDLE\n        else:\n            errorCode = STATUS_SMB_BAD_TID\n\n        smbServer.setConnectionData(connId, connData)\n        return [respSMBCommand], None, errorCode\n\n    @staticmethod\n    def smb2QueryDirectory(connId, smbServer, recvPacket):\n        connData = smbServer.getConnectionData(connId)\n        respSMBCommand = smb2.SMB2QueryDirectory_Response()\n        queryDirectoryRequest = smb2.SMB2QueryDirectory(recvPacket['Data'])\n\n        respSMBCommand['Buffer'] = b'\\x00'\n\n        # The server MUST locate the tree connection, as specified in section 3.3.5.2.11.\n        if (recvPacket['TreeID'] in connData['ConnectedShares']) is False:\n            return [smb2.SMB2Error()], None, STATUS_NETWORK_NAME_DELETED\n\n        # Next, the server MUST locate the open for the directory to be queried\n        # If no open is found, the server MUST fail the request with STATUS_FILE_CLOSED\n        if queryDirectoryRequest['FileID'].getData() == b'\\xff' * 16:\n            # Let's take the data from the lastRequest\n            if 'SMB2_CREATE' in connData['LastRequest']:\n                fileID = connData['LastRequest']['SMB2_CREATE']['FileID']\n            else:\n                fileID = queryDirectoryRequest['FileID'].getData()\n        else:\n            fileID = queryDirectoryRequest['FileID'].getData()\n\n        if (fileID in connData['OpenedFiles']) is False:\n            return [smb2.SMB2Error()], None, STATUS_FILE_CLOSED\n\n        # If the open is not an open to a directory, the request MUST be failed\n        # with STATUS_INVALID_PARAMETER.\n        if os.path.isdir(connData['OpenedFiles'][fileID]['FileName']) is False:\n            return [smb2.SMB2Error()], None, STATUS_INVALID_PARAMETER\n\n        # If any other information class is specified in the FileInformationClass\n        # field of the SMB2 QUERY_DIRECTORY Request, the server MUST fail the\n        # operation with STATUS_INVALID_INFO_CLASS.\n        if queryDirectoryRequest['FileInformationClass'] not in (\n                smb2.FILE_DIRECTORY_INFORMATION, smb2.FILE_FULL_DIRECTORY_INFORMATION,\n                smb2.FILEID_FULL_DIRECTORY_INFORMATION,\n                smb2.FILE_BOTH_DIRECTORY_INFORMATION, smb2.FILEID_BOTH_DIRECTORY_INFORMATION,\n                smb2.FILENAMES_INFORMATION):\n            return [smb2.SMB2Error()], None, STATUS_INVALID_INFO_CLASS\n\n        # If SMB2_REOPEN is set in the Flags field of the SMB2 QUERY_DIRECTORY\n        # Request, the server SHOULD<326> set Open.EnumerationLocation to 0\n        # and Open.EnumerationSearchPattern to an empty string.\n        if queryDirectoryRequest['Flags'] & smb2.SMB2_REOPEN:\n            connData['OpenedFiles'][fileID]['Open']['EnumerationLocation'] = 0\n            connData['OpenedFiles'][fileID]['Open']['EnumerationSearchPattern'] = ''\n\n        # If SMB2_RESTART_SCANS is set in the Flags field of the SMB2\n        # QUERY_DIRECTORY Request, the server MUST set\n        # Open.EnumerationLocation to 0.\n        if queryDirectoryRequest['Flags'] & smb2.SMB2_RESTART_SCANS:\n            connData['OpenedFiles'][fileID]['Open']['EnumerationLocation'] = 0\n\n        # If Open.EnumerationLocation is 0 and Open.EnumerationSearchPattern\n        # is an empty string, then Open.EnumerationSearchPattern MUST be set\n        # to the search pattern specified in the SMB2 QUERY_DIRECTORY by\n        # FileNameOffset and FileNameLength. If FileNameLength is 0, the server\n        # SHOULD<327> set Open.EnumerationSearchPattern as \"*\" to search all entries.\n\n        pattern = queryDirectoryRequest['Buffer'].decode('utf-16le')\n        if connData['OpenedFiles'][fileID]['Open']['EnumerationLocation'] == 0 and \\\n                connData['OpenedFiles'][fileID]['Open']['EnumerationSearchPattern'] == '':\n            if pattern == '':\n                pattern = '*'\n            connData['OpenedFiles'][fileID]['Open']['EnumerationSearchPattern'] = pattern\n\n        # If SMB2_INDEX_SPECIFIED is set and FileNameLength is not zero,\n        # the server MUST set Open.EnumerationSearchPattern to the search pattern\n        # specified in the request by FileNameOffset and FileNameLength.\n        if queryDirectoryRequest['Flags'] & smb2.SMB2_INDEX_SPECIFIED and \\\n                queryDirectoryRequest['FileNameLength'] > 0:\n            connData['OpenedFiles'][fileID]['Open']['EnumerationSearchPattern'] = pattern\n\n        pathName = os.path.join(os.path.normpath(connData['OpenedFiles'][fileID]['FileName']), pattern)\n        searchResult, searchCount, errorCode = findFirst2(os.path.dirname(pathName),\n                                                          os.path.basename(pathName),\n                                                          queryDirectoryRequest['FileInformationClass'],\n                                                          smb.ATTR_DIRECTORY, isSMB2=True)\n\n        if errorCode != STATUS_SUCCESS:\n            return [smb2.SMB2Error()], None, errorCode\n\n        if searchCount > 2 and pattern == '*':\n            # strip . and ..\n            searchCount -= 2\n            searchResult = searchResult[2:]\n\n        if searchCount == 0 and connData['OpenedFiles'][fileID]['Open']['EnumerationLocation'] == 0:\n            return [smb2.SMB2Error()], None, STATUS_NO_SUCH_FILE\n\n        if connData['OpenedFiles'][fileID]['Open']['EnumerationLocation'] < 0:\n            return [smb2.SMB2Error()], None, STATUS_NO_MORE_FILES\n\n        totalData = 0\n        respData = b''\n        for nItem in range(connData['OpenedFiles'][fileID]['Open']['EnumerationLocation'], searchCount):\n            connData['OpenedFiles'][fileID]['Open']['EnumerationLocation'] += 1\n            if queryDirectoryRequest['Flags'] & smb2.SL_RETURN_SINGLE_ENTRY:\n                # If single entry is requested we must clear the NextEntryOffset\n                searchResult[nItem]['NextEntryOffset'] = 0\n            data = searchResult[nItem].getData()\n            lenData = len(data)\n            padLen = (8 - (lenData % 8)) % 8\n\n            if (totalData + lenData) >= queryDirectoryRequest['OutputBufferLength']:\n                connData['OpenedFiles'][fileID]['Open']['EnumerationLocation'] -= 1\n                break\n            else:\n                respData += data + b'\\x00' * padLen\n                totalData += lenData + padLen\n\n            if queryDirectoryRequest['Flags'] & smb2.SL_RETURN_SINGLE_ENTRY:\n                break\n\n        if connData['OpenedFiles'][fileID]['Open']['EnumerationLocation'] >= searchCount:\n            connData['OpenedFiles'][fileID]['Open']['EnumerationLocation'] = -1\n\n        respSMBCommand['OutputBufferOffset'] = 0x48\n        respSMBCommand['OutputBufferLength'] = totalData\n        respSMBCommand['Buffer'] = respData\n\n        smbServer.setConnectionData(connId, connData)\n        return [respSMBCommand], None, errorCode\n\n    @staticmethod\n    def smb2ChangeNotify(connId, smbServer, recvPacket):\n\n        return [smb2.SMB2Error()], None, STATUS_NOT_SUPPORTED\n\n    @staticmethod\n    def smb2Echo(connId, smbServer, recvPacket):\n\n        respSMBCommand = smb2.SMB2Echo_Response()\n\n        return [respSMBCommand], None, STATUS_SUCCESS\n\n    @staticmethod\n    def smb2TreeDisconnect(connId, smbServer, recvPacket):\n        connData = smbServer.getConnectionData(connId)\n\n        respSMBCommand = smb2.SMB2TreeDisconnect_Response()\n\n        # Get the Tid associated\n        if recvPacket['TreeID'] in connData['ConnectedShares']:\n            smbServer.log(\"Disconnecting Share(%d:%s)\" % (\n                recvPacket['TreeID'], connData['ConnectedShares'][recvPacket['TreeID']]['shareName']))\n            del (connData['ConnectedShares'][recvPacket['TreeID']])\n            errorCode = STATUS_SUCCESS\n        else:\n            errorCode = STATUS_SMB_BAD_TID\n\n        smbServer.setConnectionData(connId, connData)\n        return [respSMBCommand], None, errorCode\n\n    @staticmethod\n    def smb2Logoff(connId, smbServer, recvPacket):\n        connData = smbServer.getConnectionData(connId)\n\n        respSMBCommand = smb2.SMB2Logoff_Response()\n\n        if recvPacket['SessionID'] != connData['Uid']:\n            # STATUS_SMB_BAD_UID\n            errorCode = STATUS_SMB_BAD_UID\n        else:\n            errorCode = STATUS_SUCCESS\n\n        connData['Uid'] = 0\n        connData['Authenticated'] = False\n\n        smbServer.setConnectionData(connId, connData)\n        return [respSMBCommand], None, errorCode\n\n    @staticmethod\n    def smb2Ioctl(connId, smbServer, recvPacket):\n        connData = smbServer.getConnectionData(connId)\n\n        respSMBCommand = smb2.SMB2Ioctl_Response()\n        ioctlRequest = smb2.SMB2Ioctl(recvPacket['Data'])\n\n        ioctls = smbServer.getIoctls()\n        if ioctlRequest['CtlCode'] in ioctls:\n            outputData, errorCode = ioctls[ioctlRequest['CtlCode']](connId, smbServer, ioctlRequest)\n            if errorCode == STATUS_SUCCESS:\n                respSMBCommand['CtlCode'] = ioctlRequest['CtlCode']\n                respSMBCommand['FileID'] = ioctlRequest['FileID']\n                respSMBCommand['InputOffset'] = 0\n                respSMBCommand['InputCount'] = 0\n                respSMBCommand['OutputOffset'] = 0x70\n                respSMBCommand['OutputCount'] = len(outputData)\n                respSMBCommand['Flags'] = 0\n                respSMBCommand['Buffer'] = outputData\n            else:\n                respSMBCommand = outputData\n        else:\n            smbServer.log(\"Ioctl not implemented command: 0x%x\" % ioctlRequest['CtlCode'], logging.DEBUG)\n            errorCode = STATUS_INVALID_DEVICE_REQUEST\n            respSMBCommand = smb2.SMB2Error()\n\n        smbServer.setConnectionData(connId, connData)\n        return [respSMBCommand], None, errorCode\n\n    @staticmethod\n    def smb2Lock(connId, smbServer, recvPacket):\n        connData = smbServer.getConnectionData(connId)\n\n        respSMBCommand = smb2.SMB2Lock_Response()\n\n        # I'm actually doing nothing.. just make MacOS happy ;)\n        errorCode = STATUS_SUCCESS\n\n        smbServer.setConnectionData(connId, connData)\n        return [respSMBCommand], None, errorCode\n\n    @staticmethod\n    def smb2Cancel(connId, smbServer, recvPacket):\n        # I'm actually doing nothing\n        return [smb2.SMB2Error()], None, STATUS_CANCELLED\n\n    @staticmethod\n    def default(connId, smbServer, recvPacket):\n        # By default we return an SMB Packet with error not implemented\n        smbServer.log(\"Not implemented command: 0x%x\" % recvPacket['Command'], logging.DEBUG)\n        return [smb2.SMB2Error()], None, STATUS_NOT_SUPPORTED",
  "class Ioctls:\n    @staticmethod\n    def fsctlDfsGetReferrals(connId, smbServer, ioctlRequest):\n        return smb2.SMB2Error(), STATUS_FS_DRIVER_REQUIRED\n\n    @staticmethod\n    def fsctlPipeTransceive(connId, smbServer, ioctlRequest):\n        connData = smbServer.getConnectionData(connId)\n\n        ioctlResponse = ''\n\n        if ioctlRequest['FileID'].getData() in connData['OpenedFiles']:\n            fileHandle = connData['OpenedFiles'][ioctlRequest['FileID'].getData()]['FileHandle']\n            errorCode = STATUS_SUCCESS\n            try:\n                if fileHandle != PIPE_FILE_DESCRIPTOR:\n                    errorCode = STATUS_INVALID_DEVICE_REQUEST\n                else:\n                    sock = connData['OpenedFiles'][ioctlRequest['FileID'].getData()]['Socket']\n                    sock.sendall(ioctlRequest['Buffer'])\n                    ioctlResponse = sock.recv(ioctlRequest['MaxOutputResponse'])\n            except Exception as e:\n                smbServer.log('fsctlPipeTransceive: %s ' % e, logging.ERROR)\n                errorCode = STATUS_ACCESS_DENIED\n        else:\n            errorCode = STATUS_INVALID_DEVICE_REQUEST\n\n        smbServer.setConnectionData(connId, connData)\n        return ioctlResponse, errorCode\n\n    @staticmethod\n    def fsctlValidateNegotiateInfo(connId, smbServer, ioctlRequest):\n        connData = smbServer.getConnectionData(connId)\n\n        errorCode = STATUS_SUCCESS\n\n        validateNegotiateInfo = smb2.VALIDATE_NEGOTIATE_INFO(ioctlRequest['Buffer'])\n        validateNegotiateInfoResponse = smb2.VALIDATE_NEGOTIATE_INFO_RESPONSE()\n        validateNegotiateInfoResponse['Capabilities'] = 0\n        validateNegotiateInfoResponse['Guid'] = b'A' * 16\n        validateNegotiateInfoResponse['SecurityMode'] = 1\n        validateNegotiateInfoResponse['Dialect'] = smb2.SMB2_DIALECT_002\n\n        smbServer.setConnectionData(connId, connData)\n        return validateNegotiateInfoResponse.getData(), errorCode",
  "class SMBSERVERHandler(socketserver.BaseRequestHandler):\n    def __init__(self, request, client_address, server, select_poll=False):\n        self.__SMB = server\n        # In case of AF_INET6 the client_address contains 4 items, ignore the last 2\n        self.__ip, self.__port = client_address[:2]\n        self.__request = request\n        self.__connId = threading.current_thread().name\n        self.__timeOut = 60 * 5\n        self.__select_poll = select_poll\n        # self.__connId = os.getpid()\n        socketserver.BaseRequestHandler.__init__(self, request, client_address, server)\n\n    def handle(self):\n        self.__SMB.log(\"Incoming connection (%s,%d)\" % (self.__ip, self.__port))\n        self.__SMB.addConnection(self.__connId, self.__ip, self.__port)\n        while True:\n            try:\n                # First of all let's get the NETBIOS packet\n                session = nmb.NetBIOSTCPSession(self.__SMB.getServerName(), 'HOST', self.__ip, sess_port=self.__port,\n                                                sock=self.__request, select_poll=self.__select_poll)\n                try:\n                    p = session.recv_packet(self.__timeOut)\n                except nmb.NetBIOSTimeout:\n                    raise\n                except nmb.NetBIOSError:\n                    break\n\n                if p.get_type() == nmb.NETBIOS_SESSION_REQUEST:\n                    # Someone is requesting a session, we're gonna accept them all :)\n                    _, rn, my = p.get_trailer().split(b' ')\n                    remote_name = nmb.decode_name(b'\\x20' + rn)\n                    myname = nmb.decode_name(b'\\x20' + my)\n                    self.__SMB.log(\n                        \"NetBIOS Session request (%s,%s,%s)\" % (self.__ip, remote_name[1].strip(), myname[1]))\n                    r = nmb.NetBIOSSessionPacket()\n                    r.set_type(nmb.NETBIOS_SESSION_POSITIVE_RESPONSE)\n                    r.set_trailer(p.get_trailer())\n                    self.__request.send(r.rawData())\n                else:\n                    resp = self.__SMB.processRequest(self.__connId, p.get_trailer())\n                    # Send all the packets received. Except for big transactions this should be\n                    # a single packet\n                    for i in resp:\n                        if hasattr(i, 'getData'):\n                            session.send_packet(i.getData())\n                        else:\n                            session.send_packet(i)\n            except Exception as e:\n                self.__SMB.log(\"Handle: %s\" % e)\n                # import traceback\n                # traceback.print_exc()\n                break\n\n    def finish(self):\n        # Thread/process is dying, we should tell the main SMB thread to remove all this thread data\n        self.__SMB.log(\"Closing down connection (%s,%d)\" % (self.__ip, self.__port))\n        self.__SMB.removeConnection(self.__connId)\n        return socketserver.BaseRequestHandler.finish(self)",
  "class SMBSERVER(socketserver.ThreadingMixIn, socketserver.TCPServer):\n    # class SMBSERVER(socketserver.ForkingMixIn, socketserver.TCPServer):\n    def __init__(self, server_address, handler_class=SMBSERVERHandler, config_parser=None):\n        socketserver.TCPServer.allow_reuse_address = True\n        socketserver.TCPServer.__init__(self, server_address, handler_class)\n\n        # Server name and OS to be presented whenever is necessary\n        self.__serverName = ''\n        self.__serverOS = ''\n        self.__serverDomain = ''\n        self.__challenge = ''\n        self.__log = None\n\n        # Our ConfigParser data\n        self.__serverConfig = config_parser\n\n        # Our credentials to be used during the server's lifetime\n        self.__credentials = {}\n\n        # Our log file\n        self.__logFile = ''\n\n        # Registered Named Pipes, format is PipeName,Socket\n        self.__registeredNamedPipes = {}\n\n        # JTR dump path\n        self.__jtr_dump_path = ''\n\n        # SMB2 Support flag = default not active\n        self.__SMB2Support = False\n\n        # Allow anonymous logon\n        self.__anonymousLogon = True\n\n        self.auth_callback = None\n\n        # Our list of commands we will answer, by default the NOT IMPLEMENTED one\n        self.__smbCommandsHandler = SMBCommands()\n        self.__smbTrans2Handler = TRANS2Commands()\n        self.__smbTransHandler = TRANSCommands()\n        self.__smbNTTransHandler = NTTRANSCommands()\n        self.__smb2CommandsHandler = SMB2Commands()\n        self.__IoctlHandler = Ioctls()\n\n        self.__smbNTTransCommands = {\n            # NT IOCTL, can't find doc for this\n            0xff: self.__smbNTTransHandler.default\n        }\n\n        self.__smbTransCommands = {\n            '\\\\PIPE\\\\LANMAN': self.__smbTransHandler.lanMan,\n            smb.SMB.TRANS_TRANSACT_NMPIPE: self.__smbTransHandler.transactNamedPipe,\n        }\n        self.__smbTrans2Commands = {\n            smb.SMB.TRANS2_FIND_FIRST2: self.__smbTrans2Handler.findFirst2,\n            smb.SMB.TRANS2_FIND_NEXT2: self.__smbTrans2Handler.findNext2,\n            smb.SMB.TRANS2_QUERY_FS_INFORMATION: self.__smbTrans2Handler.queryFsInformation,\n            smb.SMB.TRANS2_QUERY_PATH_INFORMATION: self.__smbTrans2Handler.queryPathInformation,\n            smb.SMB.TRANS2_QUERY_FILE_INFORMATION: self.__smbTrans2Handler.queryFileInformation,\n            smb.SMB.TRANS2_SET_FILE_INFORMATION: self.__smbTrans2Handler.setFileInformation,\n            smb.SMB.TRANS2_SET_PATH_INFORMATION: self.__smbTrans2Handler.setPathInformation\n        }\n\n        self.__smbCommands = {\n            smb.SMB.SMB_COM_FLUSH: self.__smbCommandsHandler.smbComFlush,\n            smb.SMB.SMB_COM_CREATE_DIRECTORY: self.__smbCommandsHandler.smbComCreateDirectory,\n            smb.SMB.SMB_COM_DELETE_DIRECTORY: self.__smbCommandsHandler.smbComDeleteDirectory,\n            smb.SMB.SMB_COM_RENAME: self.__smbCommandsHandler.smbComRename,\n            smb.SMB.SMB_COM_DELETE: self.__smbCommandsHandler.smbComDelete,\n            smb.SMB.SMB_COM_NEGOTIATE: self.__smbCommandsHandler.smbComNegotiate,\n            smb.SMB.SMB_COM_SESSION_SETUP_ANDX: self.__smbCommandsHandler.smbComSessionSetupAndX,\n            smb.SMB.SMB_COM_LOGOFF_ANDX: self.__smbCommandsHandler.smbComLogOffAndX,\n            smb.SMB.SMB_COM_TREE_CONNECT_ANDX: self.__smbCommandsHandler.smbComTreeConnectAndX,\n            smb.SMB.SMB_COM_TREE_DISCONNECT: self.__smbCommandsHandler.smbComTreeDisconnect,\n            smb.SMB.SMB_COM_ECHO: self.__smbCommandsHandler.smbComEcho,\n            smb.SMB.SMB_COM_QUERY_INFORMATION: self.__smbCommandsHandler.smbQueryInformation,\n            smb.SMB.SMB_COM_TRANSACTION2: self.__smbCommandsHandler.smbTransaction2,\n            smb.SMB.SMB_COM_TRANSACTION: self.__smbCommandsHandler.smbTransaction,\n            # Not needed for now\n            smb.SMB.SMB_COM_NT_TRANSACT: self.__smbCommandsHandler.smbNTTransact,\n            smb.SMB.SMB_COM_QUERY_INFORMATION_DISK: self.__smbCommandsHandler.smbQueryInformationDisk,\n            smb.SMB.SMB_COM_OPEN_ANDX: self.__smbCommandsHandler.smbComOpenAndX,\n            smb.SMB.SMB_COM_QUERY_INFORMATION2: self.__smbCommandsHandler.smbComQueryInformation2,\n            smb.SMB.SMB_COM_READ_ANDX: self.__smbCommandsHandler.smbComReadAndX,\n            smb.SMB.SMB_COM_READ: self.__smbCommandsHandler.smbComRead,\n            smb.SMB.SMB_COM_WRITE_ANDX: self.__smbCommandsHandler.smbComWriteAndX,\n            smb.SMB.SMB_COM_WRITE: self.__smbCommandsHandler.smbComWrite,\n            smb.SMB.SMB_COM_CLOSE: self.__smbCommandsHandler.smbComClose,\n            smb.SMB.SMB_COM_LOCKING_ANDX: self.__smbCommandsHandler.smbComLockingAndX,\n            smb.SMB.SMB_COM_NT_CREATE_ANDX: self.__smbCommandsHandler.smbComNtCreateAndX,\n            0xFF: self.__smbCommandsHandler.default\n        }\n\n        self.__smb2Ioctls = {\n            smb2.FSCTL_DFS_GET_REFERRALS: self.__IoctlHandler.fsctlDfsGetReferrals,\n            # smb2.FSCTL_PIPE_PEEK:                    self.__IoctlHandler.fsctlPipePeek,\n            # smb2.FSCTL_PIPE_WAIT:                    self.__IoctlHandler.fsctlPipeWait,\n            smb2.FSCTL_PIPE_TRANSCEIVE: self.__IoctlHandler.fsctlPipeTransceive,\n            # smb2.FSCTL_SRV_COPYCHUNK:                self.__IoctlHandler.fsctlSrvCopyChunk,\n            # smb2.FSCTL_SRV_ENUMERATE_SNAPSHOTS:      self.__IoctlHandler.fsctlSrvEnumerateSnapshots,\n            # smb2.FSCTL_SRV_REQUEST_RESUME_KEY:       self.__IoctlHandler.fsctlSrvRequestResumeKey,\n            # smb2.FSCTL_SRV_READ_HASH:                self.__IoctlHandler.fsctlSrvReadHash,\n            # smb2.FSCTL_SRV_COPYCHUNK_WRITE:          self.__IoctlHandler.fsctlSrvCopyChunkWrite,\n            # smb2.FSCTL_LMR_REQUEST_RESILIENCY:       self.__IoctlHandler.fsctlLmrRequestResiliency,\n            # smb2.FSCTL_QUERY_NETWORK_INTERFACE_INFO: self.__IoctlHandler.fsctlQueryNetworkInterfaceInfo,\n            # smb2.FSCTL_SET_REPARSE_POINT:            self.__IoctlHandler.fsctlSetReparsePoint,\n            # smb2.FSCTL_DFS_GET_REFERRALS_EX:         self.__IoctlHandler.fsctlDfsGetReferralsEx,\n            # smb2.FSCTL_FILE_LEVEL_TRIM:              self.__IoctlHandler.fsctlFileLevelTrim,\n            smb2.FSCTL_VALIDATE_NEGOTIATE_INFO: self.__IoctlHandler.fsctlValidateNegotiateInfo,\n        }\n\n        self.__smb2Commands = {\n            smb2.SMB2_NEGOTIATE: self.__smb2CommandsHandler.smb2Negotiate,\n            smb2.SMB2_SESSION_SETUP: self.__smb2CommandsHandler.smb2SessionSetup,\n            smb2.SMB2_LOGOFF: self.__smb2CommandsHandler.smb2Logoff,\n            smb2.SMB2_TREE_CONNECT: self.__smb2CommandsHandler.smb2TreeConnect,\n            smb2.SMB2_TREE_DISCONNECT: self.__smb2CommandsHandler.smb2TreeDisconnect,\n            smb2.SMB2_CREATE: self.__smb2CommandsHandler.smb2Create,\n            smb2.SMB2_CLOSE: self.__smb2CommandsHandler.smb2Close,\n            smb2.SMB2_FLUSH: self.__smb2CommandsHandler.smb2Flush,\n            smb2.SMB2_READ: self.__smb2CommandsHandler.smb2Read,\n            smb2.SMB2_WRITE: self.__smb2CommandsHandler.smb2Write,\n            smb2.SMB2_LOCK: self.__smb2CommandsHandler.smb2Lock,\n            smb2.SMB2_IOCTL: self.__smb2CommandsHandler.smb2Ioctl,\n            smb2.SMB2_CANCEL: self.__smb2CommandsHandler.smb2Cancel,\n            smb2.SMB2_ECHO: self.__smb2CommandsHandler.smb2Echo,\n            smb2.SMB2_QUERY_DIRECTORY: self.__smb2CommandsHandler.smb2QueryDirectory,\n            smb2.SMB2_CHANGE_NOTIFY: self.__smb2CommandsHandler.smb2ChangeNotify,\n            smb2.SMB2_QUERY_INFO: self.__smb2CommandsHandler.smb2QueryInfo,\n            smb2.SMB2_SET_INFO: self.__smb2CommandsHandler.smb2SetInfo,\n            # smb2.SMB2_OPLOCK_BREAK:    self.__smb2CommandsHandler.smb2SessionSetup,\n            0xFF: self.__smb2CommandsHandler.default\n        }\n\n        # List of active connections\n        self.__activeConnections = {}\n\n    def getIoctls(self):\n        return self.__smb2Ioctls\n\n    def getCredentials(self):\n        return self.__credentials\n\n    def removeConnection(self, name):\n        try:\n            del (self.__activeConnections[name])\n        except:\n            pass\n        self.log(\"Remaining connections %s\" % list(self.__activeConnections.keys()))\n\n    def addConnection(self, name, ip, port):\n        self.__activeConnections[name] = {}\n        # Let's init with some know stuff we will need to have\n        # TODO: Document what's in there\n        # print \"Current Connections\", self.__activeConnections.keys()\n        self.__activeConnections[name]['PacketNum'] = 0\n        self.__activeConnections[name]['ClientIP'] = ip\n        self.__activeConnections[name]['ClientPort'] = port\n        self.__activeConnections[name]['Uid'] = 0\n        self.__activeConnections[name]['ConnectedShares'] = {}\n        self.__activeConnections[name]['OpenedFiles'] = {}\n        # SID results for findfirst2\n        self.__activeConnections[name]['SIDs'] = {}\n        self.__activeConnections[name]['LastRequest'] = {}\n        self.__activeConnections[name]['SignatureEnabled'] = False\n        self.__activeConnections[name]['SigningChallengeResponse'] = ''\n        self.__activeConnections[name]['SigningSessionKey'] = b''\n        self.__activeConnections[name]['Authenticated'] = False\n\n    def getActiveConnections(self):\n        return self.__activeConnections\n\n    def setConnectionData(self, connId, data):\n        self.__activeConnections[connId] = data\n        # print \"setConnectionData\"\n        # print self.__activeConnections\n\n    def getConnectionData(self, connId, checkStatus=True):\n        conn = self.__activeConnections[connId]\n        if checkStatus is True:\n            if ('Authenticated' in conn) is not True:\n                # Can't keep going further\n                raise Exception(\"User not Authenticated!\")\n        return conn\n\n    def getRegisteredNamedPipes(self):\n        return self.__registeredNamedPipes\n\n    def registerNamedPipe(self, pipeName, address):\n        self.__registeredNamedPipes[str(pipeName)] = address\n        return True\n\n    def unregisterNamedPipe(self, pipeName):\n        if pipeName in self.__registeredNamedPipes:\n            del (self.__registeredNamedPipes[str(pipeName)])\n            return True\n        return False\n\n    def unregisterTransaction(self, transCommand):\n        if transCommand in self.__smbTransCommands:\n            del (self.__smbTransCommands[transCommand])\n\n    def hookTransaction(self, transCommand, callback):\n        # If you call this function, callback will replace\n        # the current Transaction sub command.\n        # (don't get confused with the Transaction smbCommand)\n        # If the transaction sub command doesn't not exist, it is added\n        # If the transaction sub command exists, it returns the original function         # replaced\n        #\n        # callback MUST be declared as:\n        # callback(connId, smbServer, recvPacket, parameters, data, maxDataCount=0)\n        #\n        # WHERE:\n        #\n        # connId      : the connection Id, used to grab/update information about\n        #               the current connection\n        # smbServer   : the SMBServer instance available for you to ask\n        #               configuration data\n        # recvPacket  : the full SMBPacket that triggered this command\n        # parameters  : the transaction parameters\n        # data        : the transaction data\n        # maxDataCount: the max amount of data that can be transferred agreed\n        #               with the client\n        #\n        # and MUST return:\n        # respSetup, respParameters, respData, errorCode\n        #\n        # WHERE:\n        #\n        # respSetup: the setup response of the transaction\n        # respParameters: the parameters response of the transaction\n        # respData: the data response of the transaction\n        # errorCode: the NT error code\n\n        if transCommand in self.__smbTransCommands:\n            originalCommand = self.__smbTransCommands[transCommand]\n        else:\n            originalCommand = None\n\n        self.__smbTransCommands[transCommand] = callback\n        return originalCommand\n\n    def unregisterTransaction2(self, transCommand):\n        if transCommand in self.__smbTrans2Commands:\n            del (self.__smbTrans2Commands[transCommand])\n\n    def hookTransaction2(self, transCommand, callback):\n        # Here we should add to __smbTrans2Commands\n        # Same description as Transaction\n        if transCommand in self.__smbTrans2Commands:\n            originalCommand = self.__smbTrans2Commands[transCommand]\n        else:\n            originalCommand = None\n\n        self.__smbTrans2Commands[transCommand] = callback\n        return originalCommand\n\n    def unregisterNTTransaction(self, transCommand):\n        if transCommand in self.__smbNTTransCommands:\n            del (self.__smbNTTransCommands[transCommand])\n\n    def hookNTTransaction(self, transCommand, callback):\n        # Here we should add to __smbNTTransCommands\n        # Same description as Transaction\n        if transCommand in self.__smbNTTransCommands:\n            originalCommand = self.__smbNTTransCommands[transCommand]\n        else:\n            originalCommand = None\n\n        self.__smbNTTransCommands[transCommand] = callback\n        return originalCommand\n\n    def unregisterSmbCommand(self, smbCommand):\n        if smbCommand in self.__smbCommands:\n            del (self.__smbCommands[smbCommand])\n\n    def hookSmbCommand(self, smbCommand, callback):\n        # Here we should add to self.__smbCommands\n        # If you call this function, callback will replace\n        # the current smbCommand.\n        # If smbCommand doesn't not exist, it is added\n        # If SMB command exists, it returns the original function replaced\n        #\n        # callback MUST be declared as:\n        # callback(connId, smbServer, SMBCommand, recvPacket)\n        #\n        # WHERE:\n        #\n        # connId    : the connection Id, used to grab/update information about\n        #             the current connection\n        # smbServer : the SMBServer instance available for you to ask\n        #             configuration data\n        # SMBCommand: the SMBCommand itself, with its data and parameters.\n        #             Check smb.py:SMBCommand() for a reference\n        # recvPacket: the full SMBPacket that triggered this command\n        #\n        # and MUST return:\n        # <list of respSMBCommands>, <list of packets>, errorCode\n        # <list of packets> has higher preference over commands, in case you\n        # want to change the whole packet\n        # errorCode: the NT error code\n        #\n        # For SMB_COM_TRANSACTION2, SMB_COM_TRANSACTION and SMB_COM_NT_TRANSACT\n        # the callback function is slightly different:\n        #\n        # callback(connId, smbServer, SMBCommand, recvPacket, transCommands)\n        #\n        # WHERE:\n        #\n        # transCommands: a list of transaction subcommands already registered\n        #\n\n        if smbCommand in self.__smbCommands:\n            originalCommand = self.__smbCommands[smbCommand]\n        else:\n            originalCommand = None\n\n        self.__smbCommands[smbCommand] = callback\n        return originalCommand\n\n    def unregisterSmb2Command(self, smb2Command):\n        if smb2Command in self.__smb2Commands:\n            del (self.__smb2Commands[smb2Command])\n\n    def hookSmb2Command(self, smb2Command, callback):\n        if smb2Command in self.__smb2Commands:\n            originalCommand = self.__smb2Commands[smb2Command]\n        else:\n            originalCommand = None\n\n        self.__smb2Commands[smb2Command] = callback\n        return originalCommand\n\n    def log(self, msg, level=logging.INFO):\n        self.__log.log(level, msg)\n\n    def getServerName(self):\n        return self.__serverName\n\n    def getServerOS(self):\n        return self.__serverOS\n\n    def getServerDomain(self):\n        return self.__serverDomain\n\n    def getSMBChallenge(self):\n        return self.__challenge\n\n    def getServerConfig(self):\n        return self.__serverConfig\n\n    def setServerConfig(self, config):\n        self.__serverConfig = config\n\n    def getJTRdumpPath(self):\n        return self.__jtr_dump_path\n\n    def getAuthCallback(self):\n        return self.auth_callback\n\n    def setAuthCallback(self, callback):\n        self.auth_callback = callback\n\n    def verify_request(self, request, client_address):\n        # TODO: Control here the max amount of processes we want to launch\n        # returning False, closes the connection\n        return True\n\n    def signSMBv1(self, connData, packet, signingSessionKey, signingChallengeResponse):\n        # This logic MUST be applied for messages sent in response to any of the higher-layer actions and in\n        # compliance with the message sequencing rules.\n        #  * The client or server that sends the message MUST provide the 32-bit sequence number for this\n        #    message, as specified in sections 3.2.4.1 and 3.3.4.1.\n        #  * The SMB_FLAGS2_SMB_SECURITY_SIGNATURE flag in the header MUST be set.\n        #  * To generate the signature, a 32-bit sequence number is copied into the\n        #    least significant 32 bits of the SecuritySignature field and the remaining\n        #    4 bytes are set to 0x00.\n        #  * The MD5 algorithm, as specified in [RFC1321], MUST be used to generate a hash of the SMB\n        #    message from the start of the SMB Header, which is defined as follows.\n        #    CALL MD5Init( md5context )\n        #    CALL MD5Update( md5context, Connection.SigningSessionKey )\n        #    CALL MD5Update( md5context, Connection.SigningChallengeResponse )\n        #    CALL MD5Update( md5context, SMB message )\n        #    CALL MD5Final( digest, md5context )\n        #    SET signature TO the first 8 bytes of the digest\n        # The resulting 8-byte signature MUST be copied into the SecuritySignature field of the SMB Header,\n        # after which the message can be transmitted.\n\n        # print \"seq(%d) signingSessionKey %r, signingChallengeResponse %r\" % (connData['SignSequenceNumber'], signingSessionKey, signingChallengeResponse)\n        packet['SecurityFeatures'] = struct.pack('<q', connData['SignSequenceNumber'])\n        # Sign with the sequence\n        m = hashlib.md5()\n        m.update(signingSessionKey)\n        m.update(signingChallengeResponse)\n        if hasattr(packet, 'getData'):\n            m.update(packet.getData())\n        else:\n            m.update(packet)\n        # Replace sequence with acual hash\n        packet['SecurityFeatures'] = m.digest()[:8]\n        connData['SignSequenceNumber'] += 2\n\n    def signSMBv2(self, packet, signingSessionKey):\n        packet['Signature'] = b'\\x00' * 16\n        packet['Flags'] |= smb2.SMB2_FLAGS_SIGNED\n        signature = hmac.new(signingSessionKey, packet.getData(), hashlib.sha256).digest()\n        packet['Signature'] = signature[:16]\n        # print \"%s\" % packet['Signature'].encode('hex')\n\n    def processRequest(self, connId, data):\n\n        # TODO: Process batched commands.\n        isSMB2 = False\n        SMBCommand = None\n        try:\n            packet = smb.NewSMBPacket(data=data)\n            SMBCommand = smb.SMBCommand(packet['Data'][0])\n        except:\n            # Maybe a SMB2 packet?\n            packet = smb2.SMB2Packet(data=data)\n            connData = self.getConnectionData(connId, False)\n            self.signSMBv2(packet, connData['SigningSessionKey'])\n            isSMB2 = True\n\n        connData = self.getConnectionData(connId, False)\n\n        # We might have compound requests\n        compoundedPacketsResponse = []\n        compoundedPackets = []\n        try:\n            # Search out list of implemented commands\n            # We provide them with:\n            # connId      : representing the data for this specific connection\n            # self        : the SMBSERVER if they want to ask data to it\n            # SMBCommand  : the SMBCommand they are expecting to process\n            # packet      : the received packet itself, in case they need more data than the actual command\n            # Only for Transactions\n            # transCommand: a list of transaction subcommands\n            # We expect to get:\n            # respCommands: a list of answers for the commands processed\n            # respPacket  : if the commands chose to directly craft packet/s, we use this and not the previous\n            #               this MUST be a list\n            # errorCode   : self explanatory\n            if isSMB2 is False:\n                # Is the client authenticated already?\n                if connData['Authenticated'] is False and packet['Command'] not in (\n                smb.SMB.SMB_COM_NEGOTIATE, smb.SMB.SMB_COM_SESSION_SETUP_ANDX):\n                    # Nope.. in that case he should only ask for a few commands, if not throw him out.\n                    errorCode = STATUS_ACCESS_DENIED\n                    respPackets = None\n                    respCommands = [smb.SMBCommand(packet['Command'])]\n                else:\n                    if packet['Command'] == smb.SMB.SMB_COM_TRANSACTION2:\n                        respCommands, respPackets, errorCode = self.__smbCommands[packet['Command']](\n                            connId,\n                            self,\n                            SMBCommand,\n                            packet,\n                            self.__smbTrans2Commands)\n                    elif packet['Command'] == smb.SMB.SMB_COM_NT_TRANSACT:\n                        respCommands, respPackets, errorCode = self.__smbCommands[packet['Command']](\n                            connId,\n                            self,\n                            SMBCommand,\n                            packet,\n                            self.__smbNTTransCommands)\n                    elif packet['Command'] == smb.SMB.SMB_COM_TRANSACTION:\n                        respCommands, respPackets, errorCode = self.__smbCommands[packet['Command']](\n                            connId,\n                            self,\n                            SMBCommand,\n                            packet,\n                            self.__smbTransCommands)\n                    else:\n                        if packet['Command'] in self.__smbCommands:\n                            if self.__SMB2Support is True:\n                                if packet['Command'] == smb.SMB.SMB_COM_NEGOTIATE:\n                                    try:\n                                        respCommands, respPackets, errorCode = self.__smb2Commands[smb2.SMB2_NEGOTIATE](\n                                            connId, self, packet, True)\n                                        isSMB2 = True\n                                    except Exception as e:\n                                        import traceback\n                                        traceback.print_exc()\n                                        self.log('SMB2_NEGOTIATE: %s' % e, logging.ERROR)\n                                        # If something went wrong, let's fallback to SMB1\n                                        respCommands, respPackets, errorCode = self.__smbCommands[packet['Command']](\n                                            connId,\n                                            self,\n                                            SMBCommand,\n                                            packet)\n                                        # self.__SMB2Support = False\n                                        pass\n                                else:\n                                    respCommands, respPackets, errorCode = self.__smbCommands[packet['Command']](\n                                        connId,\n                                        self,\n                                        SMBCommand,\n                                        packet)\n                            else:\n                                respCommands, respPackets, errorCode = self.__smbCommands[packet['Command']](\n                                    connId,\n                                    self,\n                                    SMBCommand,\n                                    packet)\n                        else:\n                            respCommands, respPackets, errorCode = self.__smbCommands[255](connId, self, SMBCommand,\n                                                                                           packet)\n\n                compoundedPacketsResponse.append((respCommands, respPackets, errorCode))\n                compoundedPackets.append(packet)\n\n            else:\n                # Is the client authenticated already?\n                if connData['Authenticated'] is False and packet['Command'] not in (\n                smb2.SMB2_NEGOTIATE, smb2.SMB2_SESSION_SETUP):\n                    # Nope.. in that case he should only ask for a few commands, if not throw him out.\n                    errorCode = STATUS_ACCESS_DENIED\n                    respPackets = None\n                    respCommands = ['']\n                    compoundedPacketsResponse.append((respCommands, respPackets, errorCode))\n                    compoundedPackets.append(packet)\n                else:\n                    done = False\n                    while not done:\n                        if packet['Command'] in self.__smb2Commands:\n                            if self.__SMB2Support is True:\n                                respCommands, respPackets, errorCode = self.__smb2Commands[packet['Command']](\n                                    connId,\n                                    self,\n                                    packet)\n                            else:\n                                respCommands, respPackets, errorCode = self.__smb2Commands[255](connId, self, packet)\n                        else:\n                            respCommands, respPackets, errorCode = self.__smb2Commands[255](connId, self, packet)\n                        # Let's store the result for this compounded packet\n                        compoundedPacketsResponse.append((respCommands, respPackets, errorCode))\n                        compoundedPackets.append(packet)\n                        if packet['NextCommand'] != 0:\n                            data = data[packet['NextCommand']:]\n                            packet = smb2.SMB2Packet(data=data)\n                        else:\n                            done = True\n\n        except Exception as e:\n            # import traceback\n            # traceback.print_exc()\n            # Something wen't wrong, defaulting to Bad user ID\n            self.log('processRequest (0x%x,%s)' % (packet['Command'], e), logging.ERROR)\n            raise\n\n        # We prepare the response packet to commands don't need to bother about that.\n        connData = self.getConnectionData(connId, False)\n\n        # Force reconnection loop.. This is just a test.. client will send me back credentials :)\n        # connData['PacketNum'] += 1\n        # if connData['PacketNum'] == 15:\n        #    connData['PacketNum'] = 0\n        #    # Something wen't wrong, defaulting to Bad user ID\n        #    self.log('Sending BAD USER ID!', logging.ERROR)\n        #    #raise\n        #    packet['Flags1'] |= smb.SMB.FLAGS1_REPLY\n        #    packet['Flags2'] = 0\n        #    errorCode = STATUS_SMB_BAD_UID\n        #    packet['ErrorCode']   = errorCode >> 16\n        #    packet['ErrorClass']  = errorCode & 0xff\n        #    return [packet]\n\n        self.setConnectionData(connId, connData)\n\n        packetsToSend = []\n        for packetNum in range(len(compoundedPacketsResponse)):\n            respCommands, respPackets, errorCode = compoundedPacketsResponse[packetNum]\n            packet = compoundedPackets[packetNum]\n            if respPackets is None:\n                for respCommand in respCommands:\n                    if isSMB2 is False:\n                        respPacket = smb.NewSMBPacket()\n                        respPacket['Flags1'] = smb.SMB.FLAGS1_REPLY\n\n                        # TODO this should come from a per session configuration\n                        respPacket[\n                            'Flags2'] = smb.SMB.FLAGS2_EXTENDED_SECURITY | smb.SMB.FLAGS2_NT_STATUS | smb.SMB.FLAGS2_LONG_NAMES | \\\n                                        packet['Flags2'] & smb.SMB.FLAGS2_UNICODE\n                        # respPacket['Flags2'] = smb.SMB.FLAGS2_EXTENDED_SECURITY | smb.SMB.FLAGS2_NT_STATUS | smb.SMB.FLAGS2_LONG_NAMES\n                        # respPacket['Flags1'] = 0x98\n                        # respPacket['Flags2'] = 0xc807\n\n                        respPacket['Tid'] = packet['Tid']\n                        respPacket['Mid'] = packet['Mid']\n                        respPacket['Pid'] = packet['Pid']\n                        respPacket['Uid'] = connData['Uid']\n\n                        respPacket['ErrorCode'] = errorCode >> 16\n                        respPacket['_reserved'] = errorCode >> 8 & 0xff\n                        respPacket['ErrorClass'] = errorCode & 0xff\n                        respPacket.addCommand(respCommand)\n\n                        if connData['SignatureEnabled']:\n                            respPacket['Flags2'] |= smb.SMB.FLAGS2_SMB_SECURITY_SIGNATURE\n                            self.signSMBv1(connData, respPacket, connData['SigningSessionKey'],\n                                           connData['SigningChallengeResponse'])\n\n                        packetsToSend.append(respPacket)\n                    else:\n                        respPacket = smb2.SMB2Packet()\n                        respPacket['Flags'] = smb2.SMB2_FLAGS_SERVER_TO_REDIR\n                        if packetNum > 0:\n                            respPacket['Flags'] |= smb2.SMB2_FLAGS_RELATED_OPERATIONS\n                        respPacket['Status'] = errorCode\n                        respPacket['CreditRequestResponse'] = packet['CreditRequestResponse']\n                        respPacket['Command'] = packet['Command']\n                        respPacket['CreditCharge'] = packet['CreditCharge']\n                        # respPacket['CreditCharge'] = 0\n                        respPacket['Reserved'] = packet['Reserved']\n                        respPacket['SessionID'] = connData['Uid']\n                        respPacket['MessageID'] = packet['MessageID']\n                        respPacket['TreeID'] = packet['TreeID']\n                        if hasattr(respCommand, 'getData'):\n                            respPacket['Data'] = respCommand.getData()\n                        else:\n                            respPacket['Data'] = str(respCommand)\n\n                        if connData['SignatureEnabled']:\n                            self.signSMBv2(respPacket, connData['SigningSessionKey'])\n\n                        packetsToSend.append(respPacket)\n            else:\n                # The SMBCommand took care of building the packet\n                packetsToSend = respPackets\n\n        if isSMB2 is True:\n            # Let's build a compound answer\n            finalData = b''\n            i = 0\n            for i in range(len(packetsToSend) - 1):\n                packet = packetsToSend[i]\n                # Align to 8-bytes\n                padLen = (8 - (len(packet) % 8)) % 8\n                packet['NextCommand'] = len(packet) + padLen\n                if hasattr(packet, 'getData'):\n                    finalData += packet.getData() + padLen * b'\\x00'\n                else:\n                    finalData += packet + padLen * b'\\x00'\n\n            # Last one\n            if hasattr(packetsToSend[len(packetsToSend) - 1], 'getData'):\n                finalData += packetsToSend[len(packetsToSend) - 1].getData()\n            else:\n                finalData += packetsToSend[len(packetsToSend) - 1]\n            packetsToSend = [finalData]\n\n        # We clear the compound requests\n        connData['LastRequest'] = {}\n\n        return packetsToSend\n\n    def processConfigFile(self, configFile=None):\n        # TODO: Do a real config parser\n        if self.__serverConfig is None:\n            if configFile is None:\n                configFile = 'smb.conf'\n            self.__serverConfig = configparser.ConfigParser()\n            self.__serverConfig.read(configFile)\n\n        self.__serverName = self.__serverConfig.get('global', 'server_name')\n        self.__serverOS = self.__serverConfig.get('global', 'server_os')\n        self.__serverDomain = self.__serverConfig.get('global', 'server_domain')\n        self.__logFile = self.__serverConfig.get('global', 'log_file')\n        if self.__serverConfig.has_option('global', 'challenge'):\n            self.__challenge = unhexlify(self.__serverConfig.get('global', 'challenge'))\n        else:\n            self.__challenge = b'A' * 8\n\n        if self.__serverConfig.has_option(\"global\", \"jtr_dump_path\"):\n            self.__jtr_dump_path = self.__serverConfig.get(\"global\", \"jtr_dump_path\")\n\n        if self.__serverConfig.has_option(\"global\", \"SMB2Support\"):\n            self.__SMB2Support = self.__serverConfig.getboolean(\"global\", \"SMB2Support\")\n        else:\n            self.__SMB2Support = False\n\n\n        if self.__serverConfig.has_option(\"global\", \"anonymous_logon\"):\n            self.__anonymousLogon = self.__serverConfig.getboolean(\"global\", \"anonymous_logon\")\n        else:\n            self.__anonymousLogon = True\n\n        if self.__logFile != 'None':\n            logging.basicConfig(filename=self.__logFile,\n                                level=logging.DEBUG,\n                                format=\"%(asctime)s: %(levelname)s: %(message)s\",\n                                datefmt='%m/%d/%Y %I:%M:%S %p')\n        self.__log = LOG\n\n        # Process the credentials\n        credentials_fname = self.__serverConfig.get('global', 'credentials_file')\n        if credentials_fname != \"\":\n            cred = open(credentials_fname)\n            line = cred.readline()\n            while line:\n                name, uid, lmhash, nthash = line.split(':')\n                self.__credentials[name.lower()] = (uid, lmhash, nthash.strip('\\r\\n'))\n                line = cred.readline()\n            cred.close()\n        self.log('Config file parsed')\n\n    def addCredential(self, name, uid, lmhash, nthash):\n        # If we have hashes, normalize them\n        if lmhash != '' or nthash != '':\n            if len(lmhash) % 2:\n                lmhash = '0%s' % lmhash\n            if len(nthash) % 2:\n                nthash = '0%s' % nthash\n            try:  # just in case they were converted already\n                lmhash = a2b_hex(lmhash)\n                nthash = a2b_hex(nthash)\n            except:\n                pass\n        self.__credentials[name.lower()] = (uid, lmhash, nthash)",
  "class WKSTServer(DCERPCServer):\n    def __init__(self):\n        DCERPCServer.__init__(self)\n        self.wkssvcCallBacks = {\n            0: self.NetrWkstaGetInfo,\n        }\n        self.addCallbacks(('6BFFD098-A112-3610-9833-46C3F87E345A', '1.0'), '\\\\PIPE\\\\wkssvc', self.wkssvcCallBacks)\n\n    def NetrWkstaGetInfo(self, data):\n        request = NetrWkstaGetInfo(data)\n        self.log(\"NetrWkstaGetInfo Level: %d\" % request['Level'])\n\n        answer = NetrWkstaGetInfoResponse()\n\n        if request['Level'] not in (100, 101):\n            answer['ErrorCode'] = ERROR_INVALID_LEVEL\n            return answer\n\n        answer['WkstaInfo']['tag'] = request['Level']\n\n        if request['Level'] == 100:\n            # Windows. Decimal value 500.\n            answer['WkstaInfo']['WkstaInfo100']['wki100_platform_id'] = 0x000001F4\n            answer['WkstaInfo']['WkstaInfo100']['wki100_computername'] = NULL\n            answer['WkstaInfo']['WkstaInfo100']['wki100_langroup'] = NULL\n            answer['WkstaInfo']['WkstaInfo100']['wki100_ver_major'] = 5\n            answer['WkstaInfo']['WkstaInfo100']['wki100_ver_minor'] = 0\n        else:\n            # Windows. Decimal value 500.\n            answer['WkstaInfo']['WkstaInfo101']['wki101_platform_id'] = 0x000001F4\n            answer['WkstaInfo']['WkstaInfo101']['wki101_computername'] = NULL\n            answer['WkstaInfo']['WkstaInfo101']['wki101_langroup'] = NULL\n            answer['WkstaInfo']['WkstaInfo101']['wki101_ver_major'] = 5\n            answer['WkstaInfo']['WkstaInfo101']['wki101_ver_minor'] = 0\n            answer['WkstaInfo']['WkstaInfo101']['wki101_lanroot'] = NULL\n\n        return answer",
  "class SRVSServer(DCERPCServer):\n    def __init__(self):\n        DCERPCServer.__init__(self)\n\n        self._shares = {}\n        self.__serverConfig = None\n        self.__logFile = None\n\n        self.srvsvcCallBacks = {\n            15: self.NetrShareEnum,\n            16: self.NetrShareGetInfo,\n            21: self.NetrServerGetInfo,\n        }\n\n        self.addCallbacks(('4B324FC8-1670-01D3-1278-5A47BF6EE188', '3.0'), '\\\\PIPE\\\\srvsvc', self.srvsvcCallBacks)\n\n    def setServerConfig(self, config):\n        self.__serverConfig = config\n\n    def processConfigFile(self, configFile=None):\n        if configFile is not None:\n            self.__serverConfig = configparser.ConfigParser()\n            self.__serverConfig.read(configFile)\n        sections = self.__serverConfig.sections()\n        # Let's check the log file\n        self.__logFile = self.__serverConfig.get('global', 'log_file')\n        if self.__logFile != 'None':\n            logging.basicConfig(filename=self.__logFile,\n                                level=logging.DEBUG,\n                                format=\"%(asctime)s: %(levelname)s: %(message)s\",\n                                datefmt='%m/%d/%Y %I:%M:%S %p')\n\n        # Remove the global one\n        del (sections[sections.index('global')])\n        self._shares = {}\n        for i in sections:\n            self._shares[i] = dict(self.__serverConfig.items(i))\n\n    def NetrShareGetInfo(self, data):\n        request = NetrShareGetInfo(data)\n        self.log(\"NetrGetShareInfo Level: %d\" % request['Level'])\n\n        s = request['NetName'][:-1].upper()\n        answer = NetrShareGetInfoResponse()\n        if s in self._shares:\n            share = self._shares[s]\n\n            answer['InfoStruct']['tag'] = 1\n            answer['InfoStruct']['ShareInfo1']['shi1_netname'] = s + '\\x00'\n            answer['InfoStruct']['ShareInfo1']['shi1_type'] = share['share type']\n            answer['InfoStruct']['ShareInfo1']['shi1_remark'] = share['comment'] + '\\x00'\n            answer['ErrorCode'] = 0\n        else:\n            answer['InfoStruct']['tag'] = 1\n            answer['InfoStruct']['ShareInfo1'] = NULL\n            answer['ErrorCode'] = 0x0906  # WERR_NET_NAME_NOT_FOUND\n\n        return answer\n\n    def NetrServerGetInfo(self, data):\n        request = NetrServerGetInfo(data)\n        self.log(\"NetrServerGetInfo Level: %d\" % request['Level'])\n        answer = NetrServerGetInfoResponse()\n        answer['InfoStruct']['tag'] = 101\n        # PLATFORM_ID_NT = 500\n        answer['InfoStruct']['ServerInfo101']['sv101_platform_id'] = 500\n        answer['InfoStruct']['ServerInfo101']['sv101_name'] = request['ServerName']\n        # Windows 7 = 6.1\n        answer['InfoStruct']['ServerInfo101']['sv101_version_major'] = 6\n        answer['InfoStruct']['ServerInfo101']['sv101_version_minor'] = 1\n        # Workstation = 1\n        answer['InfoStruct']['ServerInfo101']['sv101_type'] = 1\n        answer['InfoStruct']['ServerInfo101']['sv101_comment'] = NULL\n        answer['ErrorCode'] = 0\n        return answer\n\n    def NetrShareEnum(self, data):\n        request = NetrShareEnum(data)\n        self.log(\"NetrShareEnum Level: %d\" % request['InfoStruct']['Level'])\n        shareEnum = NetrShareEnumResponse()\n        shareEnum['InfoStruct']['Level'] = 1\n        shareEnum['InfoStruct']['ShareInfo']['tag'] = 1\n        shareEnum['TotalEntries'] = len(self._shares)\n        shareEnum['InfoStruct']['ShareInfo']['Level1']['EntriesRead'] = len(self._shares)\n        shareEnum['ErrorCode'] = 0\n\n        for i in self._shares:\n            shareInfo = SHARE_INFO_1()\n            shareInfo['shi1_netname'] = i + '\\x00'\n            shareInfo['shi1_type'] = self._shares[i]['share type']\n            shareInfo['shi1_remark'] = self._shares[i]['comment'] + '\\x00'\n            shareEnum['InfoStruct']['ShareInfo']['Level1']['Buffer'].append(shareInfo)\n\n        return shareEnum",
  "class SimpleSMBServer:\n    \"\"\"\n    SimpleSMBServer class - Implements a simple, customizable SMB Server\n\n    :param string listenAddress: the address you want the server to listen on\n    :param integer listenPort: the port number you want the server to listen on\n    :param string configFile: a file with all the servers' configuration. If no file specified, this class will create the basic parameters needed to run. You will need to add your shares manually tho. See addShare() method\n    \"\"\"\n\n    def __init__(self, listenAddress='0.0.0.0', listenPort=445, configFile=''):\n        if configFile != '':\n            self.__server = SMBSERVER((listenAddress, listenPort))\n            self.__server.processConfigFile(configFile)\n            self.__smbConfig = None\n        else:\n            # Here we write a mini config for the server\n            self.__smbConfig = configparser.ConfigParser()\n            self.__smbConfig.add_section('global')\n            self.__smbConfig.set('global', 'server_name',\n                                 ''.join([random.choice(string.ascii_letters) for _ in range(8)]))\n            self.__smbConfig.set('global', 'server_os', ''.join([random.choice(string.ascii_letters) for _ in range(8)])\n                                 )\n            self.__smbConfig.set('global', 'server_domain',\n                                 ''.join([random.choice(string.ascii_letters) for _ in range(8)])\n                                 )\n            self.__smbConfig.set('global', 'log_file', 'None')\n            self.__smbConfig.set('global', 'rpc_apis', 'yes')\n            self.__smbConfig.set('global', 'credentials_file', '')\n            self.__smbConfig.set('global', 'challenge', \"A\" * 16)\n\n            # IPC always needed\n            self.__smbConfig.add_section('IPC$')\n            self.__smbConfig.set('IPC$', 'comment', '')\n            self.__smbConfig.set('IPC$', 'read only', 'yes')\n            self.__smbConfig.set('IPC$', 'share type', '3')\n            self.__smbConfig.set('IPC$', 'path', '')\n            self.__server = SMBSERVER((listenAddress, listenPort), config_parser=self.__smbConfig)\n            self.__server.processConfigFile()\n\n        # Now we have to register the MS-SRVS server. This specially important for\n        # Windows 7+ and Mavericks clients since they WON'T (specially OSX)\n        # ask for shares using MS-RAP.\n\n        self.__srvsServer = SRVSServer()\n        self.__srvsServer.daemon = True\n        self.__wkstServer = WKSTServer()\n        self.__wkstServer.daemon = True\n        self.__server.registerNamedPipe('srvsvc', ('127.0.0.1', self.__srvsServer.getListenPort()))\n        self.__server.registerNamedPipe('wkssvc', ('127.0.0.1', self.__wkstServer.getListenPort()))\n\n    def start(self):\n        self.__srvsServer.start()\n        self.__wkstServer.start()\n        self.__server.serve_forever()\n\n    def stop(self):\n        self.__server.server_close()\n\n    def registerNamedPipe(self, pipeName, address):\n        return self.__server.registerNamedPipe(pipeName, address)\n\n    def unregisterNamedPipe(self, pipeName):\n        return self.__server.unregisterNamedPipe(pipeName)\n\n    def getRegisteredNamedPipes(self):\n        return self.__server.getRegisteredNamedPipes()\n\n    def addShare(self, shareName, sharePath, shareComment='', shareType='0', readOnly='no'):\n        share = shareName.upper()\n        self.__smbConfig.add_section(share)\n        self.__smbConfig.set(share, 'comment', shareComment)\n        self.__smbConfig.set(share, 'read only', readOnly)\n        self.__smbConfig.set(share, 'share type', shareType)\n        self.__smbConfig.set(share, 'path', sharePath)\n        self.__server.setServerConfig(self.__smbConfig)\n        self.__srvsServer.setServerConfig(self.__smbConfig)\n        self.__server.processConfigFile()\n        self.__srvsServer.processConfigFile()\n\n    def removeShare(self, shareName):\n        self.__smbConfig.remove_section(shareName.upper())\n        self.__server.setServerConfig(self.__smbConfig)\n        self.__srvsServer.setServerConfig(self.__smbConfig)\n        self.__server.processConfigFile()\n        self.__srvsServer.processConfigFile()\n\n    def setSMBChallenge(self, challenge):\n        if challenge != '':\n            self.__smbConfig.set('global', 'challenge', challenge)\n            self.__server.setServerConfig(self.__smbConfig)\n            self.__server.processConfigFile()\n\n    def setLogFile(self, logFile):\n        self.__smbConfig.set('global', 'log_file', logFile)\n        self.__server.setServerConfig(self.__smbConfig)\n        self.__server.processConfigFile()\n\n    def setCredentialsFile(self, logFile):\n        self.__smbConfig.set('global', 'credentials_file', logFile)\n        self.__server.setServerConfig(self.__smbConfig)\n        self.__server.processConfigFile()\n\n    def addCredential(self, name, uid, lmhash, nthash):\n        self.__server.addCredential(name, uid, lmhash, nthash)\n\n    def setSMB2Support(self, value):\n        if value is True:\n            self.__smbConfig.set(\"global\", \"SMB2Support\", \"True\")\n        else:\n            self.__smbConfig.set(\"global\", \"SMB2Support\", \"False\")\n        self.__server.setServerConfig(self.__smbConfig)\n        self.__server.processConfigFile()\n\n    def getAuthCallback(self):\n        return self.__server.getAuthCallback()\n\n    def setAuthCallback(self, callback):\n        self.__server.setAuthCallback(callback)",
  "def default(self, connId, smbServer, recvPacket, parameters, data, maxDataCount=0):\n        pass",
  "def lanMan(connId, smbServer, recvPacket, parameters, data, maxDataCount=0):\n        # Minimal [MS-RAP] implementation, just to return the shares\n        connData = smbServer.getConnectionData(connId)\n\n        respSetup = b''\n        respParameters = b''\n        respData = b''\n        errorCode = STATUS_SUCCESS\n        if struct.unpack('<H', parameters[:2])[0] == 0:\n            # NetShareEnum Request\n            netShareEnum = smb.SMBNetShareEnum(parameters)\n            if netShareEnum['InfoLevel'] == 1:\n                shares = getShares(connId, smbServer)\n                respParameters = smb.SMBNetShareEnumResponse()\n                respParameters['EntriesReturned'] = len(shares)\n                respParameters['EntriesAvailable'] = len(shares)\n                tailData = ''\n                for i in shares:\n                    # NetShareInfo1 len == 20\n                    entry = smb.NetShareInfo1()\n                    entry['NetworkName'] = i + '\\x00' * (13 - len(i))\n                    entry['Type'] = int(shares[i]['share type'])\n                    # (beto) If offset == 0 it crashes explorer.exe on windows 7\n                    entry['RemarkOffsetLow'] = 20 * len(shares) + len(tailData)\n                    respData += entry.getData()\n                    if 'comment' in shares[i]:\n                        tailData += shares[i]['comment'] + '\\x00'\n                    else:\n                        tailData += '\\x00'\n                respData += tailData\n            else:\n                # We don't support other info levels\n                errorCode = STATUS_NOT_SUPPORTED\n        elif struct.unpack('<H', parameters[:2])[0] == 13:\n            # NetrServerGetInfo Request\n            respParameters = smb.SMBNetServerGetInfoResponse()\n            netServerInfo = smb.SMBNetServerInfo1()\n            netServerInfo['ServerName'] = smbServer.getServerName()\n            respData = netServerInfo.getData()\n            respParameters['TotalBytesAvailable'] = len(respData)\n        elif struct.unpack('<H', parameters[:2])[0] == 1:\n            # NetrShareGetInfo Request\n            request = smb.SMBNetShareGetInfo(parameters)\n            respParameters = smb.SMBNetShareGetInfoResponse()\n            shares = getShares(connId, smbServer)\n            share = shares[request['ShareName'].upper()]\n            shareInfo = smb.NetShareInfo1()\n            shareInfo['NetworkName'] = request['ShareName'].upper() + '\\x00'\n            shareInfo['Type'] = int(share['share type'])\n            respData = shareInfo.getData()\n            if 'comment' in share:\n                shareInfo['RemarkOffsetLow'] = len(respData)\n                respData += share['comment'] + '\\x00'\n            respParameters['TotalBytesAvailable'] = len(respData)\n\n        else:\n            # We don't know how to handle anything else\n            errorCode = STATUS_NOT_SUPPORTED\n\n        smbServer.setConnectionData(connId, connData)\n\n        return respSetup, respParameters, respData, errorCode",
  "def transactNamedPipe(connId, smbServer, recvPacket, parameters, data, maxDataCount=0):\n        connData = smbServer.getConnectionData(connId)\n\n        respSetup = b''\n        respParameters = b''\n        respData = b''\n        errorCode = STATUS_SUCCESS\n        SMBCommand = smb.SMBCommand(recvPacket['Data'][0])\n        transParameters = smb.SMBTransaction_Parameters(SMBCommand['Parameters'])\n\n        # Extract the FID\n        fid = struct.unpack('<H', transParameters['Setup'][2:])[0]\n\n        if fid in connData['OpenedFiles']:\n            fileHandle = connData['OpenedFiles'][fid]['FileHandle']\n            if fileHandle != PIPE_FILE_DESCRIPTOR:\n                os.write(fileHandle, data)\n                respData = os.read(fileHandle, data)\n            else:\n                sock = connData['OpenedFiles'][fid]['Socket']\n                sock.send(data)\n                respData = sock.recv(maxDataCount)\n        else:\n            errorCode = STATUS_INVALID_HANDLE\n\n        smbServer.setConnectionData(connId, connData)\n\n        return respSetup, respParameters, respData, errorCode",
  "def setPathInformation(connId, smbServer, recvPacket, parameters, data, maxDataCount=0):\n        connData = smbServer.getConnectionData(connId)\n\n        respSetup = b''\n        respParameters = b''\n        respData = b''\n        errorCode = STATUS_SUCCESS\n        setPathInfoParameters = smb.SMBSetPathInformation_Parameters(flags=recvPacket['Flags2'], data=parameters)\n        if recvPacket['Tid'] in connData['ConnectedShares']:\n            path = connData['ConnectedShares'][recvPacket['Tid']]['path']\n            fileName = normalize_path(decodeSMBString(recvPacket['Flags2'], setPathInfoParameters['FileName']), path)\n            pathName = os.path.join(path, fileName)\n\n            if isInFileJail(path, fileName):\n                smbServer.log(\"Path not in current working directory\")\n                errorCode = STATUS_OBJECT_PATH_SYNTAX_BAD\n\n            elif os.path.exists(pathName):\n                informationLevel = setPathInfoParameters['InformationLevel']\n                if informationLevel == smb.SMB_SET_FILE_BASIC_INFO:\n                    infoRecord = smb.SMBSetFileBasicInfo(data)\n                    # Creation time won't be set,  the other ones we play with.\n                    atime = infoRecord['LastAccessTime']\n                    if atime == 0:\n                        atime = -1\n                    else:\n                        atime = getUnixTime(atime)\n                    mtime = infoRecord['LastWriteTime']\n                    if mtime == 0:\n                        mtime = -1\n                    else:\n                        mtime = getUnixTime(mtime)\n                    if mtime != -1 or atime != -1:\n                        os.utime(pathName, (atime, mtime))\n                else:\n                    smbServer.log('Unknown level for set path info! 0x%x' % setPathInfoParameters['InformationLevel'],\n                                  logging.ERROR)\n                    # UNSUPPORTED\n                    errorCode = STATUS_NOT_SUPPORTED\n            else:\n                errorCode = STATUS_OBJECT_NAME_NOT_FOUND\n\n            if errorCode == STATUS_SUCCESS:\n                respParameters = smb.SMBSetPathInformationResponse_Parameters()\n\n        else:\n            errorCode = STATUS_SMB_BAD_TID\n\n        smbServer.setConnectionData(connId, connData)\n\n        return respSetup, respParameters, respData, errorCode",
  "def setFileInformation(connId, smbServer, recvPacket, parameters, data, maxDataCount=0):\n        connData = smbServer.getConnectionData(connId)\n\n        respSetup = b''\n        respParameters = b''\n        respData = b''\n        errorCode = STATUS_SUCCESS\n        setFileInfoParameters = smb.SMBSetFileInformation_Parameters(parameters)\n\n        if recvPacket['Tid'] in connData['ConnectedShares']:\n            if setFileInfoParameters['FID'] in connData['OpenedFiles']:\n                fileName = connData['OpenedFiles'][setFileInfoParameters['FID']]['FileName']\n                informationLevel = setFileInfoParameters['InformationLevel']\n                if informationLevel == smb.SMB_SET_FILE_DISPOSITION_INFO:\n                    infoRecord = smb.SMBSetFileDispositionInfo(parameters)\n                    if infoRecord['DeletePending'] > 0:\n                        # Mark this file for removal after closed\n                        connData['OpenedFiles'][setFileInfoParameters['FID']]['DeleteOnClose'] = True\n                        respParameters = smb.SMBSetFileInformationResponse_Parameters()\n                elif informationLevel == smb.SMB_SET_FILE_BASIC_INFO:\n                    infoRecord = smb.SMBSetFileBasicInfo(data)\n                    # Creation time won't be set,  the other ones we play with.\n                    atime = infoRecord['LastAccessTime']\n                    if atime == 0:\n                        atime = -1\n                    else:\n                        atime = getUnixTime(atime)\n                    mtime = infoRecord['LastWriteTime']\n                    if mtime == 0:\n                        mtime = -1\n                    else:\n                        mtime = getUnixTime(mtime)\n                    os.utime(fileName, (atime, mtime))\n                elif informationLevel == smb.SMB_SET_FILE_END_OF_FILE_INFO:\n                    fileHandle = connData['OpenedFiles'][setFileInfoParameters['FID']]['FileHandle']\n                    infoRecord = smb.SMBSetFileEndOfFileInfo(data)\n                    if infoRecord['EndOfFile'] > 0:\n                        os.lseek(fileHandle, infoRecord['EndOfFile'] - 1, 0)\n                        os.write(fileHandle, b'\\x00')\n                else:\n                    smbServer.log('Unknown level for set file info! 0x%x' % setFileInfoParameters['InformationLevel'],\n                                  logging.ERROR)\n                    # UNSUPPORTED\n                    errorCode = STATUS_NOT_SUPPORTED\n            else:\n                errorCode = STATUS_NO_SUCH_FILE\n\n            if errorCode == STATUS_SUCCESS:\n                respParameters = smb.SMBSetFileInformationResponse_Parameters()\n        else:\n            errorCode = STATUS_SMB_BAD_TID\n\n        smbServer.setConnectionData(connId, connData)\n\n        return respSetup, respParameters, respData, errorCode",
  "def queryFileInformation(connId, smbServer, recvPacket, parameters, data, maxDataCount=0):\n        connData = smbServer.getConnectionData(connId)\n\n        respSetup = b''\n        respParameters = b''\n        respData = b''\n\n        queryFileInfoParameters = smb.SMBQueryFileInformation_Parameters(parameters)\n\n        if recvPacket['Tid'] in connData['ConnectedShares']:\n            if queryFileInfoParameters['FID'] in connData['OpenedFiles']:\n                pathName = connData['OpenedFiles'][queryFileInfoParameters['FID']]['FileName']\n\n                infoRecord, errorCode = queryFileInformation(os.path.dirname(pathName), os.path.basename(pathName),\n                                                             queryFileInfoParameters['InformationLevel'])\n\n                if infoRecord is not None:\n                    respParameters = smb.SMBQueryFileInformationResponse_Parameters()\n                    respData = infoRecord\n            else:\n                errorCode = STATUS_INVALID_HANDLE\n        else:\n            errorCode = STATUS_SMB_BAD_TID\n\n        smbServer.setConnectionData(connId, connData)\n\n        return respSetup, respParameters, respData, errorCode",
  "def queryPathInformation(connId, smbServer, recvPacket, parameters, data, maxDataCount=0):\n        connData = smbServer.getConnectionData(connId)\n\n        respSetup = b''\n        respParameters = b''\n        respData = b''\n        errorCode = 0\n\n        queryPathInfoParameters = smb.SMBQueryPathInformation_Parameters(flags=recvPacket['Flags2'], data=parameters)\n\n        if recvPacket['Tid'] in connData['ConnectedShares']:\n            path = connData['ConnectedShares'][recvPacket['Tid']]['path']\n            try:\n                infoRecord, errorCode = queryPathInformation(path, decodeSMBString(recvPacket['Flags2'],\n                                                                                   queryPathInfoParameters['FileName']),\n                                                             queryPathInfoParameters['InformationLevel'])\n            except Exception as e:\n                smbServer.log(\"queryPathInformation: %s\" % e, logging.ERROR)\n\n            if infoRecord is not None:\n                respParameters = smb.SMBQueryPathInformationResponse_Parameters()\n                respData = infoRecord\n        else:\n            errorCode = STATUS_SMB_BAD_TID\n\n        smbServer.setConnectionData(connId, connData)\n\n        return respSetup, respParameters, respData, errorCode",
  "def queryFsInformation(connId, smbServer, recvPacket, parameters, data, maxDataCount=0):\n        connData = smbServer.getConnectionData(connId)\n        errorCode = 0\n        # Get the Tid associated\n        if recvPacket['Tid'] in connData['ConnectedShares']:\n            data = queryFsInformation(connData['ConnectedShares'][recvPacket['Tid']]['path'], '',\n                                      struct.unpack('<H', parameters)[0], pktFlags=recvPacket['Flags2'])\n\n        smbServer.setConnectionData(connId, connData)\n\n        return b'', b'', data, errorCode",
  "def findNext2(connId, smbServer, recvPacket, parameters, data, maxDataCount):\n        connData = smbServer.getConnectionData(connId)\n\n        respSetup = b''\n        respParameters = b''\n        respData = b''\n        errorCode = STATUS_SUCCESS\n        findNext2Parameters = smb.SMBFindNext2_Parameters(flags=recvPacket['Flags2'], data=parameters)\n\n        sid = findNext2Parameters['SID']\n        if recvPacket['Tid'] in connData['ConnectedShares']:\n            if sid in connData['SIDs']:\n                searchResult = connData['SIDs'][sid]\n                respParameters = smb.SMBFindNext2Response_Parameters()\n                endOfSearch = 1\n                searchCount = 1\n                totalData = 0\n                for i in enumerate(searchResult):\n                    data = i[1].getData()\n                    lenData = len(data)\n                    if (totalData + lenData) >= maxDataCount or (i[0] + 1) >= findNext2Parameters['SearchCount']:\n                        # We gotta stop here and continue on a find_next2\n                        endOfSearch = 0\n                        connData['SIDs'][sid] = searchResult[i[0]:]\n                        respParameters['LastNameOffset'] = totalData\n                        break\n                    else:\n                        searchCount += 1\n                        respData += data\n                        totalData += lenData\n\n                # Have we reached the end of the search or still stuff to send?\n                if endOfSearch > 0:\n                    # Let's remove the SID from our ConnData\n                    del (connData['SIDs'][sid])\n\n                respParameters['EndOfSearch'] = endOfSearch\n                respParameters['SearchCount'] = searchCount\n            else:\n                errorCode = STATUS_INVALID_HANDLE\n        else:\n            errorCode = STATUS_SMB_BAD_TID\n\n        smbServer.setConnectionData(connId, connData)\n\n        return respSetup, respParameters, respData, errorCode",
  "def findFirst2(connId, smbServer, recvPacket, parameters, data, maxDataCount):\n        connData = smbServer.getConnectionData(connId)\n\n        respSetup = b''\n        respParameters = b''\n        respData = b''\n        findFirst2Parameters = smb.SMBFindFirst2_Parameters(recvPacket['Flags2'], data=parameters)\n\n        if recvPacket['Tid'] in connData['ConnectedShares']:\n            path = connData['ConnectedShares'][recvPacket['Tid']]['path']\n\n            searchResult, searchCount, errorCode = findFirst2(path,\n                                                              decodeSMBString(recvPacket['Flags2'],\n                                                                              findFirst2Parameters['FileName']),\n                                                              findFirst2Parameters['InformationLevel'],\n                                                              findFirst2Parameters['SearchAttributes'],\n                                                              pktFlags=recvPacket['Flags2'])\n\n            if searchCount > 0:\n                respParameters = smb.SMBFindFirst2Response_Parameters()\n                endOfSearch = 1\n                sid = 0x80  # default SID\n                searchCount = 0\n                totalData = 0\n                for i in enumerate(searchResult):\n                    # i[1].dump()\n                    data = i[1].getData()\n                    lenData = len(data)\n                    if (totalData + lenData) >= maxDataCount or (i[0] + 1) > findFirst2Parameters['SearchCount']:\n                        # We gotta stop here and continue on a find_next2\n                        endOfSearch = 0\n                        # Simple way to generate a fid\n                        if len(connData['SIDs']) == 0:\n                            sid = 1\n                        else:\n                            sid = list(connData['SIDs'].keys())[-1] + 1\n                        # Store the remaining search results in the ConnData SID\n                        connData['SIDs'][sid] = searchResult[i[0]:]\n                        respParameters['LastNameOffset'] = totalData\n                        break\n                    else:\n                        searchCount += 1\n                        respData += data\n\n                        padLen = (8 - (lenData % 8)) % 8\n                        respData += b'\\xaa' * padLen\n                        totalData += lenData + padLen\n\n                respParameters['SID'] = sid\n                respParameters['EndOfSearch'] = endOfSearch\n                respParameters['SearchCount'] = searchCount\n\n            # If we've empty files and errorCode was not already set, we return NO_SUCH_FILE\n            elif errorCode == 0:\n                errorCode = STATUS_NO_SUCH_FILE\n        else:\n            errorCode = STATUS_SMB_BAD_TID\n\n        smbServer.setConnectionData(connId, connData)\n\n        return respSetup, respParameters, respData, errorCode",
  "def smbTransaction(connId, smbServer, SMBCommand, recvPacket, transCommands):\n        connData = smbServer.getConnectionData(connId)\n\n        respSMBCommand = smb.SMBCommand(recvPacket['Command'])\n\n        transParameters = smb.SMBTransaction_Parameters(SMBCommand['Parameters'])\n\n        # Do the stuff\n        if transParameters['ParameterCount'] != transParameters['TotalParameterCount']:\n            # TODO: Handle partial parameters\n            raise Exception(\"Unsupported partial parameters in TRANSACT2!\")\n        else:\n            transData = smb.SMBTransaction_SData(flags=recvPacket['Flags2'])\n            # Standard says servers shouldn't trust Parameters and Data comes\n            # in order, so we have to parse the offsets, ugly\n\n            paramCount = transParameters['ParameterCount']\n            transData['Trans_ParametersLength'] = paramCount\n            dataCount = transParameters['DataCount']\n            transData['Trans_DataLength'] = dataCount\n            transData.fromString(SMBCommand['Data'])\n            if transParameters['ParameterOffset'] > 0:\n                paramOffset = transParameters['ParameterOffset'] - 63 - transParameters['SetupLength']\n                transData['Trans_Parameters'] = SMBCommand['Data'][paramOffset:paramOffset + paramCount]\n            else:\n                transData['Trans_Parameters'] = b''\n\n            if transParameters['DataOffset'] > 0:\n                dataOffset = transParameters['DataOffset'] - 63 - transParameters['SetupLength']\n                transData['Trans_Data'] = SMBCommand['Data'][dataOffset:dataOffset + dataCount]\n            else:\n                transData['Trans_Data'] = b''\n\n            # Call the handler for this TRANSACTION\n            if transParameters['SetupCount'] == 0:\n                # No subcommand, let's play with the Name\n                command = decodeSMBString(recvPacket['Flags2'], transData['Name'])\n            else:\n                command = struct.unpack('<H', transParameters['Setup'][:2])[0]\n\n            if command in transCommands:\n                # Call the TRANS subcommand\n                setup = b''\n                parameters = b''\n                data = b''\n                try:\n                    setup, parameters, data, errorCode = transCommands[command](connId,\n                                                                                smbServer,\n                                                                                recvPacket,\n                                                                                transData['Trans_Parameters'],\n                                                                                transData['Trans_Data'],\n                                                                                transParameters['MaxDataCount'])\n                except Exception as e:\n                    # print 'Transaction: %s' % e,e\n                    smbServer.log('Transaction: (%r,%s)' % (command, e), logging.ERROR)\n                    errorCode = STATUS_ACCESS_DENIED\n                    # raise\n\n                if setup == b'' and parameters == b'' and data == b'':\n                    # Something wen't wrong\n                    respParameters = b''\n                    respData = b''\n                else:\n                    # Build the answer\n                    if hasattr(data, 'getData'):\n                        data = data.getData()\n                    remainingData = len(data)\n                    if hasattr(parameters, 'getData'):\n                        parameters = parameters.getData()\n                    remainingParameters = len(parameters)\n                    commands = []\n                    dataDisplacement = 0\n                    while remainingData > 0 or remainingParameters > 0:\n                        respSMBCommand = smb.SMBCommand(recvPacket['Command'])\n                        respParameters = smb.SMBTransactionResponse_Parameters()\n                        respData = smb.SMBTransaction2Response_Data()\n\n                        respParameters['TotalParameterCount'] = len(parameters)\n                        respParameters['ParameterCount'] = len(parameters)\n                        respData['Trans_ParametersLength'] = len(parameters)\n                        respParameters['TotalDataCount'] = len(data)\n                        respParameters['DataDisplacement'] = dataDisplacement\n\n                        # TODO: Do the same for parameters\n                        if len(data) > transParameters['MaxDataCount']:\n                            # Answer doesn't fit in this packet\n                            LOG.debug(\"Lowering answer from %d to %d\" % (len(data), transParameters['MaxDataCount']))\n                            respParameters['DataCount'] = transParameters['MaxDataCount']\n                        else:\n                            respParameters['DataCount'] = len(data)\n\n                        respData['Trans_DataLength'] = respParameters['DataCount']\n                        respParameters['SetupCount'] = len(setup)\n                        respParameters['Setup'] = setup\n                        # TODO: Make sure we're calculating the pad right\n                        if len(parameters) > 0:\n                            # padLen = 4 - (55 + len(setup)) % 4\n                            padLen = (4 - (55 + len(setup)) % 4) % 4\n                            padBytes = b'\\xFF' * padLen\n                            respData['Pad1'] = padBytes\n                            respParameters['ParameterOffset'] = 55 + len(setup) + padLen\n                        else:\n                            padLen = 0\n                            respParameters['ParameterOffset'] = 0\n                            respData['Pad1'] = b''\n\n                        if len(data) > 0:\n                            # pad2Len = 4 - (55 + len(setup) + padLen + len(parameters)) % 4\n                            pad2Len = (4 - (55 + len(setup) + padLen + len(parameters)) % 4) % 4\n                            respData['Pad2'] = b'\\xFF' * pad2Len\n                            respParameters['DataOffset'] = 55 + len(setup) + padLen + len(parameters) + pad2Len\n                        else:\n                            respParameters['DataOffset'] = 0\n                            respData['Pad2'] = b''\n\n                        respData['Trans_Parameters'] = parameters[:respParameters['ParameterCount']]\n                        respData['Trans_Data'] = data[:respParameters['DataCount']]\n                        respSMBCommand['Parameters'] = respParameters\n                        respSMBCommand['Data'] = respData\n\n                        data = data[respParameters['DataCount']:]\n                        remainingData -= respParameters['DataCount']\n                        dataDisplacement += respParameters['DataCount'] + 1\n\n                        parameters = parameters[respParameters['ParameterCount']:]\n                        remainingParameters -= respParameters['ParameterCount']\n                        commands.append(respSMBCommand)\n\n                    smbServer.setConnectionData(connId, connData)\n                    return commands, None, errorCode\n\n            else:\n                smbServer.log(\"Unsupported Transact command %r\" % command, logging.ERROR)\n                respParameters = b''\n                respData = b''\n                errorCode = STATUS_NOT_IMPLEMENTED\n\n        respSMBCommand['Parameters'] = respParameters\n        respSMBCommand['Data'] = respData\n        smbServer.setConnectionData(connId, connData)\n\n        return [respSMBCommand], None, errorCode",
  "def smbNTTransact(connId, smbServer, SMBCommand, recvPacket, transCommands):\n        connData = smbServer.getConnectionData(connId)\n\n        respSMBCommand = smb.SMBCommand(recvPacket['Command'])\n\n        NTTransParameters = smb.SMBNTTransaction_Parameters(SMBCommand['Parameters'])\n        # Do the stuff\n        if NTTransParameters['ParameterCount'] != NTTransParameters['TotalParameterCount']:\n            # TODO: Handle partial parameters\n            raise Exception(\"Unsupported partial parameters in NTTrans!\")\n        else:\n            NTTransData = smb.SMBNTTransaction_Data()\n            # Standard says servers shouldn't trust Parameters and Data comes\n            # in order, so we have to parse the offsets, ugly\n\n            paramCount = NTTransParameters['ParameterCount']\n            NTTransData['NT_Trans_ParametersLength'] = paramCount\n            dataCount = NTTransParameters['DataCount']\n            NTTransData['NT_Trans_DataLength'] = dataCount\n\n            if NTTransParameters['ParameterOffset'] > 0:\n                paramOffset = NTTransParameters['ParameterOffset'] - 73 - NTTransParameters['SetupLength']\n                NTTransData['NT_Trans_Parameters'] = SMBCommand['Data'][paramOffset:paramOffset + paramCount]\n            else:\n                NTTransData['NT_Trans_Parameters'] = b''\n\n            if NTTransParameters['DataOffset'] > 0:\n                dataOffset = NTTransParameters['DataOffset'] - 73 - NTTransParameters['SetupLength']\n                NTTransData['NT_Trans_Data'] = SMBCommand['Data'][dataOffset:dataOffset + dataCount]\n            else:\n                NTTransData['NT_Trans_Data'] = b''\n\n            # Call the handler for this TRANSACTION\n            command = NTTransParameters['Function']\n            if command in transCommands:\n                # Call the NT TRANS subcommand\n                setup = b''\n                parameters = b''\n                data = b''\n                try:\n                    setup, parameters, data, errorCode = transCommands[command](connId,\n                                                                                smbServer,\n                                                                                recvPacket,\n                                                                                NTTransData['NT_Trans_Parameters'],\n                                                                                NTTransData['NT_Trans_Data'],\n                                                                                NTTransParameters['MaxDataCount'])\n                except Exception as e:\n                    smbServer.log('NTTransaction: (0x%x,%s)' % (command, e), logging.ERROR)\n                    errorCode = STATUS_ACCESS_DENIED\n                    # raise\n\n                if setup == b'' and parameters == b'' and data == b'':\n                    # Something wen't wrong\n                    respParameters = b''\n                    respData = b''\n                    if errorCode == STATUS_SUCCESS:\n                        errorCode = STATUS_ACCESS_DENIED\n                else:\n                    # Build the answer\n                    if hasattr(data, 'getData'):\n                        data = data.getData()\n                    remainingData = len(data)\n                    if hasattr(parameters, 'getData'):\n                        parameters = parameters.getData()\n                    remainingParameters = len(parameters)\n                    commands = []\n                    dataDisplacement = 0\n                    while remainingData > 0 or remainingParameters > 0:\n                        respSMBCommand = smb.SMBCommand(recvPacket['Command'])\n                        respParameters = smb.SMBNTTransactionResponse_Parameters()\n                        respData = smb.SMBNTTransactionResponse_Data()\n\n                        respParameters['TotalParameterCount'] = len(parameters)\n                        respParameters['ParameterCount'] = len(parameters)\n                        respData['Trans_ParametersLength'] = len(parameters)\n                        respParameters['TotalDataCount'] = len(data)\n                        respParameters['DataDisplacement'] = dataDisplacement\n                        # TODO: Do the same for parameters\n                        if len(data) > NTTransParameters['MaxDataCount']:\n                            # Answer doesn't fit in this packet\n                            LOG.debug(\"Lowering answer from %d to %d\" % (len(data), NTTransParameters['MaxDataCount']))\n                            respParameters['DataCount'] = NTTransParameters['MaxDataCount']\n                        else:\n                            respParameters['DataCount'] = len(data)\n\n                        respData['NT_Trans_DataLength'] = respParameters['DataCount']\n                        respParameters['SetupCount'] = len(setup)\n                        respParameters['Setup'] = setup\n                        # TODO: Make sure we're calculating the pad right\n                        if len(parameters) > 0:\n                            # padLen = 4 - (71 + len(setup)) % 4\n                            padLen = (4 - (73 + len(setup)) % 4) % 4\n                            padBytes = b'\\xFF' * padLen\n                            respData['Pad1'] = padBytes\n                            respParameters['ParameterOffset'] = 73 + len(setup) + padLen\n                        else:\n                            padLen = 0\n                            respParameters['ParameterOffset'] = 0\n                            respData['Pad1'] = b''\n\n                        if len(data) > 0:\n                            # pad2Len = 4 - (71 + len(setup) + padLen + len(parameters)) % 4\n                            pad2Len = (4 - (73 + len(setup) + padLen + len(parameters)) % 4) % 4\n                            respData['Pad2'] = b'\\xFF' * pad2Len\n                            respParameters['DataOffset'] = 73 + len(setup) + padLen + len(parameters) + pad2Len\n                        else:\n                            respParameters['DataOffset'] = 0\n                            respData['Pad2'] = b''\n\n                        respData['NT_Trans_Parameters'] = parameters[:respParameters['ParameterCount']]\n                        respData['NT_Trans_Data'] = data[:respParameters['DataCount']]\n                        respSMBCommand['Parameters'] = respParameters\n                        respSMBCommand['Data'] = respData\n\n                        data = data[respParameters['DataCount']:]\n                        remainingData -= respParameters['DataCount']\n                        dataDisplacement += respParameters['DataCount'] + 1\n\n                        parameters = parameters[respParameters['ParameterCount']:]\n                        remainingParameters -= respParameters['ParameterCount']\n                        commands.append(respSMBCommand)\n\n                    smbServer.setConnectionData(connId, connData)\n                    return commands, None, errorCode\n\n            else:\n                # smbServer.log(\"Unsupported NTTransact command 0x%x\" % command, logging.ERROR)\n                respParameters = b''\n                respData = b''\n                errorCode = STATUS_NOT_IMPLEMENTED\n\n        respSMBCommand['Parameters'] = respParameters\n        respSMBCommand['Data'] = respData\n\n        smbServer.setConnectionData(connId, connData)\n        return [respSMBCommand], None, errorCode",
  "def smbTransaction2(connId, smbServer, SMBCommand, recvPacket, transCommands):\n        connData = smbServer.getConnectionData(connId)\n\n        respSMBCommand = smb.SMBCommand(recvPacket['Command'])\n\n        trans2Parameters = smb.SMBTransaction2_Parameters(SMBCommand['Parameters'])\n\n        # Do the stuff\n        if trans2Parameters['ParameterCount'] != trans2Parameters['TotalParameterCount']:\n            # TODO: Handle partial parameters\n            # print \"Unsupported partial parameters in TRANSACT2!\"\n            raise Exception(\"Unsupported partial parameters in TRANSACT2!\")\n        else:\n            trans2Data = smb.SMBTransaction2_Data()\n            # Standard says servers shouldn't trust Parameters and Data comes\n            # in order, so we have to parse the offsets, ugly\n\n            paramCount = trans2Parameters['ParameterCount']\n            trans2Data['Trans_ParametersLength'] = paramCount\n            dataCount = trans2Parameters['DataCount']\n            trans2Data['Trans_DataLength'] = dataCount\n\n            if trans2Parameters['ParameterOffset'] > 0:\n                paramOffset = trans2Parameters['ParameterOffset'] - 63 - trans2Parameters['SetupLength']\n                trans2Data['Trans_Parameters'] = SMBCommand['Data'][paramOffset:paramOffset + paramCount]\n            else:\n                trans2Data['Trans_Parameters'] = b''\n\n            if trans2Parameters['DataOffset'] > 0:\n                dataOffset = trans2Parameters['DataOffset'] - 63 - trans2Parameters['SetupLength']\n                trans2Data['Trans_Data'] = SMBCommand['Data'][dataOffset:dataOffset + dataCount]\n            else:\n                trans2Data['Trans_Data'] = b''\n\n            # Call the handler for this TRANSACTION\n            command = struct.unpack('<H', trans2Parameters['Setup'])[0]\n            if command in transCommands:\n                # Call the TRANS2 subcommand\n                try:\n                    setup, parameters, data, errorCode = transCommands[command](connId,\n                                                                                smbServer,\n                                                                                recvPacket,\n                                                                                trans2Data['Trans_Parameters'],\n                                                                                trans2Data['Trans_Data'],\n                                                                                trans2Parameters['MaxDataCount'])\n                except Exception as e:\n                    smbServer.log('Transaction2: (0x%x,%s)' % (command, e), logging.ERROR)\n                    # import traceback\n                    # traceback.print_exc()\n                    raise\n\n                if setup == b'' and parameters == b'' and data == b'':\n                    # Something wen't wrong\n                    respParameters = b''\n                    respData = b''\n                else:\n                    # Build the answer\n                    if hasattr(data, 'getData'):\n                        data = data.getData()\n                    remainingData = len(data)\n                    if hasattr(parameters, 'getData'):\n                        parameters = parameters.getData()\n                    remainingParameters = len(parameters)\n                    commands = []\n                    dataDisplacement = 0\n                    while remainingData > 0 or remainingParameters > 0:\n                        respSMBCommand = smb.SMBCommand(recvPacket['Command'])\n                        respParameters = smb.SMBTransaction2Response_Parameters()\n                        respData = smb.SMBTransaction2Response_Data()\n\n                        respParameters['TotalParameterCount'] = len(parameters)\n                        respParameters['ParameterCount'] = len(parameters)\n                        respData['Trans_ParametersLength'] = len(parameters)\n                        respParameters['TotalDataCount'] = len(data)\n                        respParameters['DataDisplacement'] = dataDisplacement\n                        # TODO: Do the same for parameters\n                        if len(data) > trans2Parameters['MaxDataCount']:\n                            # Answer doesn't fit in this packet\n                            LOG.debug(\"Lowering answer from %d to %d\" % (len(data), trans2Parameters['MaxDataCount']))\n                            respParameters['DataCount'] = trans2Parameters['MaxDataCount']\n                        else:\n                            respParameters['DataCount'] = len(data)\n\n                        respData['Trans_DataLength'] = respParameters['DataCount']\n                        respParameters['SetupCount'] = len(setup)\n                        respParameters['Setup'] = setup\n                        # TODO: Make sure we're calculating the pad right\n                        if len(parameters) > 0:\n                            # padLen = 4 - (55 + len(setup)) % 4\n                            padLen = (4 - (55 + len(setup)) % 4) % 4\n                            padBytes = b'\\xFF' * padLen\n                            respData['Pad1'] = padBytes\n                            respParameters['ParameterOffset'] = 55 + len(setup) + padLen\n                        else:\n                            padLen = 0\n                            respParameters['ParameterOffset'] = 0\n                            respData['Pad1'] = b''\n\n                        if len(data) > 0:\n                            # pad2Len = 4 - (55 + len(setup) + padLen + len(parameters)) % 4\n                            pad2Len = (4 - (55 + len(setup) + padLen + len(parameters)) % 4) % 4\n                            respData['Pad2'] = b'\\xFF' * pad2Len\n                            respParameters['DataOffset'] = 55 + len(setup) + padLen + len(parameters) + pad2Len\n                        else:\n                            respParameters['DataOffset'] = 0\n                            respData['Pad2'] = b''\n\n                        respData['Trans_Parameters'] = parameters[:respParameters['ParameterCount']]\n                        respData['Trans_Data'] = data[:respParameters['DataCount']]\n                        respSMBCommand['Parameters'] = respParameters\n                        respSMBCommand['Data'] = respData\n\n                        data = data[respParameters['DataCount']:]\n                        remainingData -= respParameters['DataCount']\n                        dataDisplacement += respParameters['DataCount'] + 1\n\n                        parameters = parameters[respParameters['ParameterCount']:]\n                        remainingParameters -= respParameters['ParameterCount']\n                        commands.append(respSMBCommand)\n\n                    smbServer.setConnectionData(connId, connData)\n                    return commands, None, errorCode\n\n            else:\n                smbServer.log(\"Unsupported Transact/2 command 0x%x\" % command, logging.ERROR)\n                respParameters = b''\n                respData = b''\n                errorCode = STATUS_NOT_IMPLEMENTED\n\n        respSMBCommand['Parameters'] = respParameters\n        respSMBCommand['Data'] = respData\n\n        smbServer.setConnectionData(connId, connData)\n        return [respSMBCommand], None, errorCode",
  "def smbComLockingAndX(connId, smbServer, SMBCommand, recvPacket):\n        connData = smbServer.getConnectionData(connId)\n\n        respSMBCommand = smb.SMBCommand(smb.SMB.SMB_COM_LOCKING_ANDX)\n        respParameters = b''\n        respData = b''\n\n        # I'm actually doing nothing.. just make MacOS happy ;)\n        errorCode = STATUS_SUCCESS\n\n        respSMBCommand['Parameters'] = respParameters\n        respSMBCommand['Data'] = respData\n        smbServer.setConnectionData(connId, connData)\n\n        return [respSMBCommand], None, errorCode",
  "def smbComClose(connId, smbServer, SMBCommand, recvPacket):\n        connData = smbServer.getConnectionData(connId)\n\n        respSMBCommand = smb.SMBCommand(smb.SMB.SMB_COM_CLOSE)\n        respParameters = b''\n        respData = b''\n\n        comClose = smb.SMBClose_Parameters(SMBCommand['Parameters'])\n\n        # Get the Tid associated\n        if recvPacket['Tid'] in connData['ConnectedShares']:\n            if comClose['FID'] in connData['OpenedFiles']:\n                errorCode = STATUS_SUCCESS\n                fileHandle = connData['OpenedFiles'][comClose['FID']]['FileHandle']\n                try:\n                    if fileHandle == PIPE_FILE_DESCRIPTOR:\n                        connData['OpenedFiles'][comClose['FID']]['Socket'].close()\n                    elif fileHandle != VOID_FILE_DESCRIPTOR:\n                        os.close(fileHandle)\n                except Exception as e:\n                    smbServer.log(\"comClose %s\" % e, logging.ERROR)\n                    errorCode = STATUS_ACCESS_DENIED\n                else:\n                    # Check if the file was marked for removal\n                    if connData['OpenedFiles'][comClose['FID']]['DeleteOnClose'] is True:\n                        try:\n                            os.remove(connData['OpenedFiles'][comClose['FID']]['FileName'])\n                        except Exception as e:\n                            smbServer.log(\"comClose %s\" % e, logging.ERROR)\n                            errorCode = STATUS_ACCESS_DENIED\n                    del (connData['OpenedFiles'][comClose['FID']])\n            else:\n                errorCode = STATUS_INVALID_HANDLE\n        else:\n            errorCode = STATUS_SMB_BAD_TID\n\n        if errorCode > 0:\n            respParameters = b''\n            respData = b''\n\n        respSMBCommand['Parameters'] = respParameters\n        respSMBCommand['Data'] = respData\n        smbServer.setConnectionData(connId, connData)\n\n        return [respSMBCommand], None, errorCode",
  "def smbComWrite(connId, smbServer, SMBCommand, recvPacket):\n        connData = smbServer.getConnectionData(connId)\n\n        respSMBCommand = smb.SMBCommand(smb.SMB.SMB_COM_WRITE)\n        respParameters = smb.SMBWriteResponse_Parameters()\n        respData = b''\n\n        comWriteParameters = smb.SMBWrite_Parameters(SMBCommand['Parameters'])\n        comWriteData = smb.SMBWrite_Data(SMBCommand['Data'])\n\n        # Get the Tid associated\n        if recvPacket['Tid'] in connData['ConnectedShares']:\n            if comWriteParameters['Fid'] in connData['OpenedFiles']:\n                fileHandle = connData['OpenedFiles'][comWriteParameters['Fid']]['FileHandle']\n                errorCode = STATUS_SUCCESS\n                try:\n                    if fileHandle != PIPE_FILE_DESCRIPTOR:\n                        # TODO: Handle big size files\n                        # If we're trying to write past the file end we just skip the write call (Vista does this)\n                        if os.lseek(fileHandle, 0, 2) >= comWriteParameters['Offset']:\n                            os.lseek(fileHandle, comWriteParameters['Offset'], 0)\n                            os.write(fileHandle, comWriteData['Data'])\n                    else:\n                        sock = connData['OpenedFiles'][comWriteParameters['Fid']]['Socket']\n                        sock.send(comWriteData['Data'])\n                    respParameters['Count'] = comWriteParameters['Count']\n                except Exception as e:\n                    smbServer.log('smbComWrite: %s' % e, logging.ERROR)\n                    errorCode = STATUS_ACCESS_DENIED\n            else:\n                errorCode = STATUS_INVALID_HANDLE\n        else:\n            errorCode = STATUS_SMB_BAD_TID\n\n        if errorCode > 0:\n            respParameters = b''\n            respData = b''\n\n        respSMBCommand['Parameters'] = respParameters\n        respSMBCommand['Data'] = respData\n        smbServer.setConnectionData(connId, connData)\n\n        return [respSMBCommand], None, errorCode",
  "def smbComFlush(connId, smbServer, SMBCommand, recvPacket):\n        connData = smbServer.getConnectionData(connId)\n\n        respSMBCommand = smb.SMBCommand(smb.SMB.SMB_COM_FLUSH)\n        respParameters = b''\n        respData = b''\n\n        comFlush = smb.SMBFlush_Parameters(SMBCommand['Parameters'])\n\n        # Get the Tid associated\n        if recvPacket['Tid'] in connData['ConnectedShares']:\n            if comFlush['FID'] in connData['OpenedFiles']:\n                errorCode = STATUS_SUCCESS\n                fileHandle = connData['OpenedFiles'][comFlush['FID']]['FileHandle']\n                try:\n                    os.fsync(fileHandle)\n                except Exception as e:\n                    smbServer.log(\"comFlush %s\" % e, logging.ERROR)\n                    errorCode = STATUS_ACCESS_DENIED\n            else:\n                errorCode = STATUS_INVALID_HANDLE\n        else:\n            errorCode = STATUS_SMB_BAD_TID\n\n        if errorCode > 0:\n            respParameters = b''\n            respData = b''\n\n        respSMBCommand['Parameters'] = respParameters\n        respSMBCommand['Data'] = respData\n        smbServer.setConnectionData(connId, connData)\n\n        return [respSMBCommand], None, errorCode",
  "def smbComCreateDirectory(connId, smbServer, SMBCommand, recvPacket):\n        connData = smbServer.getConnectionData(connId)\n\n        respSMBCommand = smb.SMBCommand(smb.SMB.SMB_COM_CREATE_DIRECTORY)\n        respParameters = b''\n        respData = b''\n\n        comCreateDirectoryData = smb.SMBCreateDirectory_Data(flags=recvPacket['Flags2'], data=SMBCommand['Data'])\n\n        # Get the Tid associated\n        if recvPacket['Tid'] in connData['ConnectedShares']:\n            errorCode = STATUS_SUCCESS\n            path = connData['ConnectedShares'][recvPacket['Tid']]['path']\n            fileName = normalize_path(decodeSMBString(recvPacket['Flags2'], comCreateDirectoryData['DirectoryName']))\n            pathName = os.path.join(path, fileName)\n\n            if not isInFileJail(path, fileName):\n                smbServer.log(\"Path not in current working directory\", logging.ERROR)\n                errorCode = STATUS_OBJECT_PATH_SYNTAX_BAD\n\n            elif os.path.exists(pathName):\n                errorCode = STATUS_OBJECT_NAME_COLLISION\n\n            else:\n                try:\n                    os.mkdir(pathName)\n                except Exception as e:\n                    smbServer.log(\"smbComCreateDirectory: %s\" % e, logging.ERROR)\n                    errorCode = STATUS_ACCESS_DENIED\n        else:\n            errorCode = STATUS_SMB_BAD_TID\n\n        if errorCode > 0:\n            respParameters = b''\n            respData = b''\n\n        respSMBCommand['Parameters'] = respParameters\n        respSMBCommand['Data'] = respData\n        smbServer.setConnectionData(connId, connData)\n\n        return [respSMBCommand], None, errorCode",
  "def smbComRename(connId, smbServer, SMBCommand, recvPacket):\n        connData = smbServer.getConnectionData(connId)\n\n        respSMBCommand = smb.SMBCommand(smb.SMB.SMB_COM_RENAME)\n        respParameters = b''\n        respData = b''\n\n        comRenameData = smb.SMBRename_Data(flags=recvPacket['Flags2'], data=SMBCommand['Data'])\n\n        # Get the Tid associated\n        if recvPacket['Tid'] in connData['ConnectedShares']:\n            errorCode = STATUS_SUCCESS\n            path = connData['ConnectedShares'][recvPacket['Tid']]['path']\n            oldFileName = normalize_path(decodeSMBString(recvPacket['Flags2'], comRenameData['OldFileName']))\n            oldPathName = os.path.join(path, oldFileName)\n            newFileName = normalize_path(decodeSMBString(recvPacket['Flags2'], comRenameData['NewFileName']))\n            newPathName = os.path.join(path, newFileName)\n\n            if not isInFileJail(path, oldFileName) or not isInFileJail(path, newFileName):\n                smbServer.log(\"Path not in current working directory\", logging.ERROR)\n                errorCode = STATUS_OBJECT_PATH_SYNTAX_BAD\n\n            elif not os.path.exists(oldPathName):\n                errorCode = STATUS_NO_SUCH_FILE\n\n            else:\n                try:\n                    os.rename(oldPathName, newPathName)\n                except OSError as e:\n                    smbServer.log(\"smbComRename: %s\" % e, logging.ERROR)\n                    errorCode = STATUS_ACCESS_DENIED\n        else:\n            errorCode = STATUS_SMB_BAD_TID\n\n        if errorCode > 0:\n            respParameters = b''\n            respData = b''\n\n        respSMBCommand['Parameters'] = respParameters\n        respSMBCommand['Data'] = respData\n        smbServer.setConnectionData(connId, connData)\n\n        return [respSMBCommand], None, errorCode",
  "def smbComDelete(connId, smbServer, SMBCommand, recvPacket):\n        connData = smbServer.getConnectionData(connId)\n\n        respSMBCommand = smb.SMBCommand(smb.SMB.SMB_COM_DELETE)\n        respParameters = b''\n        respData = b''\n\n        comDeleteData = smb.SMBDelete_Data(flags=recvPacket['Flags2'], data=SMBCommand['Data'])\n\n        # Get the Tid associated\n        if recvPacket['Tid'] in connData['ConnectedShares']:\n            errorCode = STATUS_SUCCESS\n            path = connData['ConnectedShares'][recvPacket['Tid']]['path']\n            fileName = normalize_path(decodeSMBString(recvPacket['Flags2'], comDeleteData['FileName']))\n            pathName = os.path.join(path, fileName)\n\n            if not isInFileJail(path, fileName):\n                smbServer.log(\"Path not in current working directory\", logging.ERROR)\n                errorCode = STATUS_OBJECT_PATH_SYNTAX_BAD\n\n            elif not os.path.exists(pathName):\n                errorCode = STATUS_NO_SUCH_FILE\n\n            else:\n                try:\n                    os.remove(pathName)\n                except OSError as e:\n                    smbServer.log(\"smbComDelete: %s\" % e, logging.ERROR)\n                    errorCode = STATUS_ACCESS_DENIED\n        else:\n            errorCode = STATUS_SMB_BAD_TID\n\n        if errorCode > 0:\n            respParameters = b''\n            respData = b''\n\n        respSMBCommand['Parameters'] = respParameters\n        respSMBCommand['Data'] = respData\n        smbServer.setConnectionData(connId, connData)\n\n        return [respSMBCommand], None, errorCode",
  "def smbComDeleteDirectory(connId, smbServer, SMBCommand, recvPacket):\n        connData = smbServer.getConnectionData(connId)\n\n        respSMBCommand = smb.SMBCommand(smb.SMB.SMB_COM_DELETE_DIRECTORY)\n        respParameters = b''\n        respData = b''\n\n        comDeleteDirectoryData = smb.SMBDeleteDirectory_Data(flags=recvPacket['Flags2'], data=SMBCommand['Data'])\n\n        # Get the Tid associated\n        if recvPacket['Tid'] in connData['ConnectedShares']:\n            errorCode = STATUS_SUCCESS\n            path = connData['ConnectedShares'][recvPacket['Tid']]['path']\n            fileName = normalize_path(decodeSMBString(recvPacket['Flags2'], comDeleteDirectoryData['DirectoryName']))\n            pathName = os.path.join(path, fileName)\n\n            if not isInFileJail(path, fileName):\n                smbServer.log(\"Path not in current working directory\", logging.ERROR)\n                errorCode = STATUS_OBJECT_PATH_SYNTAX_BAD\n\n            if os.path.exists(pathName) is not True:\n                errorCode = STATUS_NO_SUCH_FILE\n\n            else:\n                try:\n                    os.rmdir(pathName)\n                except OSError as e:\n                    smbServer.log(\"smbComDeleteDirectory: %s\" % e, logging.ERROR)\n                    if e.errno == errno.ENOTEMPTY:\n                        errorCode = STATUS_DIRECTORY_NOT_EMPTY\n                    else:\n                        errorCode = STATUS_ACCESS_DENIED\n        else:\n            errorCode = STATUS_SMB_BAD_TID\n\n        if errorCode > 0:\n            respParameters = b''\n            respData = b''\n\n        respSMBCommand['Parameters'] = respParameters\n        respSMBCommand['Data'] = respData\n        smbServer.setConnectionData(connId, connData)\n\n        return [respSMBCommand], None, errorCode",
  "def smbComWriteAndX(connId, smbServer, SMBCommand, recvPacket):\n        connData = smbServer.getConnectionData(connId)\n\n        respSMBCommand = smb.SMBCommand(smb.SMB.SMB_COM_WRITE_ANDX)\n        respParameters = smb.SMBWriteAndXResponse_Parameters()\n        respData = b''\n\n        if SMBCommand['WordCount'] == 0x0C:\n            writeAndX = smb.SMBWriteAndX_Parameters_Short(SMBCommand['Parameters'])\n            writeAndXData = smb.SMBWriteAndX_Data_Short()\n        else:\n            writeAndX = smb.SMBWriteAndX_Parameters(SMBCommand['Parameters'])\n            writeAndXData = smb.SMBWriteAndX_Data()\n        writeAndXData['DataLength'] = writeAndX['DataLength']\n        writeAndXData['DataOffset'] = writeAndX['DataOffset']\n        writeAndXData.fromString(SMBCommand['Data'])\n\n        # Get the Tid associated\n        if recvPacket['Tid'] in connData['ConnectedShares']:\n            if writeAndX['Fid'] in connData['OpenedFiles']:\n                fileHandle = connData['OpenedFiles'][writeAndX['Fid']]['FileHandle']\n                errorCode = STATUS_SUCCESS\n                try:\n                    if fileHandle != PIPE_FILE_DESCRIPTOR:\n                        offset = writeAndX['Offset']\n                        if 'HighOffset' in writeAndX.fields:\n                            offset += (writeAndX['HighOffset'] << 32)\n                        # If we're trying to write past the file end we just skip the write call (Vista does this)\n                        if os.lseek(fileHandle, 0, 2) >= offset:\n                            os.lseek(fileHandle, offset, 0)\n                            os.write(fileHandle, writeAndXData['Data'])\n                    else:\n                        sock = connData['OpenedFiles'][writeAndX['Fid']]['Socket']\n                        sock.send(writeAndXData['Data'])\n\n                    respParameters['Count'] = writeAndX['DataLength']\n                    respParameters['Available'] = 0xff\n                except Exception as e:\n                    smbServer.log('smbComWriteAndx: %s' % e, logging.ERROR)\n                    errorCode = STATUS_ACCESS_DENIED\n            else:\n                errorCode = STATUS_INVALID_HANDLE\n        else:\n            errorCode = STATUS_SMB_BAD_TID\n\n        if errorCode > 0:\n            respParameters = b''\n            respData = b''\n\n        respSMBCommand['Parameters'] = respParameters\n        respSMBCommand['Data'] = respData\n        smbServer.setConnectionData(connId, connData)\n\n        return [respSMBCommand], None, errorCode",
  "def smbComRead(connId, smbServer, SMBCommand, recvPacket):\n        connData = smbServer.getConnectionData(connId)\n\n        respSMBCommand = smb.SMBCommand(smb.SMB.SMB_COM_READ)\n        respParameters = smb.SMBReadResponse_Parameters()\n        respData = smb.SMBReadResponse_Data()\n\n        comReadParameters = smb.SMBRead_Parameters(SMBCommand['Parameters'])\n\n        # Get the Tid associated\n        if recvPacket['Tid'] in connData['ConnectedShares']:\n            if comReadParameters['Fid'] in connData['OpenedFiles']:\n                fileHandle = connData['OpenedFiles'][comReadParameters['Fid']]['FileHandle']\n                errorCode = STATUS_SUCCESS\n                try:\n                    if fileHandle != PIPE_FILE_DESCRIPTOR:\n                        # TODO: Handle big size files\n                        os.lseek(fileHandle, comReadParameters['Offset'], 0)\n                        content = os.read(fileHandle, comReadParameters['Count'])\n                    else:\n                        sock = connData['OpenedFiles'][comReadParameters['Fid']]['Socket']\n                        content = sock.recv(comReadParameters['Count'])\n                    respParameters['Count'] = len(content)\n                    respData['DataLength'] = len(content)\n                    respData['Data'] = content\n                except Exception as e:\n                    smbServer.log('smbComRead: %s ' % e, logging.ERROR)\n                    errorCode = STATUS_ACCESS_DENIED\n            else:\n                errorCode = STATUS_INVALID_HANDLE\n        else:\n            errorCode = STATUS_SMB_BAD_TID\n\n        if errorCode > 0:\n            respParameters = b''\n            respData = b''\n\n        respSMBCommand['Parameters'] = respParameters\n        respSMBCommand['Data'] = respData\n        smbServer.setConnectionData(connId, connData)\n\n        return [respSMBCommand], None, errorCode",
  "def smbComReadAndX(connId, smbServer, SMBCommand, recvPacket):\n        connData = smbServer.getConnectionData(connId)\n\n        respSMBCommand = smb.SMBCommand(smb.SMB.SMB_COM_READ_ANDX)\n        respParameters = smb.SMBReadAndXResponse_Parameters()\n        respData = b''\n\n        if SMBCommand['WordCount'] == 0x0A:\n            readAndX = smb.SMBReadAndX_Parameters2(SMBCommand['Parameters'])\n        else:\n            readAndX = smb.SMBReadAndX_Parameters(SMBCommand['Parameters'])\n\n        # Get the Tid associated\n        if recvPacket['Tid'] in connData['ConnectedShares']:\n            if readAndX['Fid'] in connData['OpenedFiles']:\n                fileHandle = connData['OpenedFiles'][readAndX['Fid']]['FileHandle']\n                errorCode = 0\n                try:\n                    if fileHandle != PIPE_FILE_DESCRIPTOR:\n                        offset = readAndX['Offset']\n                        if 'HighOffset' in readAndX.fields:\n                            offset += (readAndX['HighOffset'] << 32)\n                        os.lseek(fileHandle, offset, 0)\n                        content = os.read(fileHandle, readAndX['MaxCount'])\n                    else:\n                        sock = connData['OpenedFiles'][readAndX['Fid']]['Socket']\n                        content = sock.recv(readAndX['MaxCount'])\n                    respParameters['Remaining'] = 0xffff\n                    respParameters['DataCount'] = len(content)\n                    respParameters['DataOffset'] = 59\n                    respParameters['DataCount_Hi'] = 0\n                    respData = content\n                except Exception as e:\n                    smbServer.log('smbComReadAndX: %s ' % e, logging.ERROR)\n                    errorCode = STATUS_ACCESS_DENIED\n            else:\n                errorCode = STATUS_INVALID_HANDLE\n        else:\n            errorCode = STATUS_SMB_BAD_TID\n\n        if errorCode > 0:\n            respParameters = b''\n            respData = b''\n\n        respSMBCommand['Parameters'] = respParameters\n        respSMBCommand['Data'] = respData\n        smbServer.setConnectionData(connId, connData)\n\n        return [respSMBCommand], None, errorCode",
  "def smbQueryInformation(connId, smbServer, SMBCommand, recvPacket):\n        connData = smbServer.getConnectionData(connId)\n\n        respSMBCommand = smb.SMBCommand(smb.SMB.SMB_COM_QUERY_INFORMATION)\n        respParameters = smb.SMBQueryInformationResponse_Parameters()\n        respData = b''\n\n        queryInformation = smb.SMBQueryInformation_Data(flags=recvPacket['Flags2'], data=SMBCommand['Data'])\n\n        # Get the Tid associated\n        if recvPacket['Tid'] in connData['ConnectedShares']:\n            path = connData['ConnectedShares'][recvPacket['Tid']]['path']\n            fileName = normalize_path(decodeSMBString(recvPacket['Flags2'], queryInformation['FileName']))\n            if not isInFileJail(path, fileName):\n                smbServer.log(\"Path not in current working directory\", logging.ERROR)\n                errorCode = STATUS_OBJECT_PATH_SYNTAX_BAD\n\n            else:\n                fileSize, lastWriteTime, fileAttributes = queryFsInformation(path, fileName, pktFlags=recvPacket['Flags2'])\n\n                respParameters['FileSize'] = fileSize\n                respParameters['LastWriteTime'] = lastWriteTime\n                respParameters['FileAttributes'] = fileAttributes\n                errorCode = STATUS_SUCCESS\n        else:\n            errorCode = STATUS_SMB_BAD_TID\n\n        if errorCode > 0:\n            respParameters = b''\n            respData = b''\n\n        respSMBCommand['Parameters'] = respParameters\n        respSMBCommand['Data'] = respData\n\n        smbServer.setConnectionData(connId, connData)\n        return [respSMBCommand], None, errorCode",
  "def smbQueryInformationDisk(connId, smbServer, SMBCommand, recvPacket):\n        connData = smbServer.getConnectionData(connId)\n\n        respSMBCommand = smb.SMBCommand(smb.SMB.SMB_COM_QUERY_INFORMATION_DISK)\n        respParameters = smb.SMBQueryInformationDiskResponse_Parameters()\n        respData = b''\n\n        # Get the Tid associated\n        if recvPacket['Tid'] in connData['ConnectedShares']:\n            totalUnits, freeUnits = queryDiskInformation(\n                connData['ConnectedShares'][recvPacket['Tid']]['path'])\n\n            respParameters['TotalUnits'] = totalUnits\n            respParameters['BlocksPerUnit'] = 1\n            respParameters['BlockSize'] = 1\n            respParameters['FreeUnits'] = freeUnits\n            errorCode = STATUS_SUCCESS\n        else:\n            errorCode = STATUS_SMB_BAD_TID\n\n        if errorCode > 0:\n            respData = b''\n            respParameters = b''\n\n        respSMBCommand['Parameters'] = respParameters\n        respSMBCommand['Data'] = respData\n\n        smbServer.setConnectionData(connId, connData)\n        return [respSMBCommand], None, errorCode",
  "def smbComEcho(connId, smbServer, SMBCommand, recvPacket):\n        connData = smbServer.getConnectionData(connId)\n\n        respSMBCommand = smb.SMBCommand(smb.SMB.SMB_COM_ECHO)\n        respParameters = smb.SMBEchoResponse_Parameters()\n        respData = smb.SMBEchoResponse_Data()\n\n        echoData = smb.SMBEcho_Data(SMBCommand['Data'])\n\n        respParameters['SequenceNumber'] = 1\n        respData['Data'] = echoData['Data']\n\n        respSMBCommand['Parameters'] = respParameters\n        respSMBCommand['Data'] = respData\n\n        errorCode = STATUS_SUCCESS\n        smbServer.setConnectionData(connId, connData)\n        return [respSMBCommand], None, errorCode",
  "def smbComTreeDisconnect(connId, smbServer, SMBCommand, recvPacket):\n        connData = smbServer.getConnectionData(connId)\n\n        respSMBCommand = smb.SMBCommand(smb.SMB.SMB_COM_TREE_DISCONNECT)\n\n        # Check if the Tid matches the Tid trying to disconnect\n        respParameters = b''\n        respData = b''\n\n        if recvPacket['Tid'] in connData['ConnectedShares']:\n            smbServer.log(\"Disconnecting Share(%d:%s)\" % (\n            recvPacket['Tid'], connData['ConnectedShares'][recvPacket['Tid']]['shareName']))\n            del (connData['ConnectedShares'][recvPacket['Tid']])\n            errorCode = STATUS_SUCCESS\n        else:\n            errorCode = STATUS_SMB_BAD_TID\n\n        respSMBCommand['Parameters'] = respParameters\n        respSMBCommand['Data'] = respData\n\n        smbServer.setConnectionData(connId, connData)\n        return [respSMBCommand], None, errorCode",
  "def smbComLogOffAndX(connId, smbServer, SMBCommand, recvPacket):\n        connData = smbServer.getConnectionData(connId)\n\n        respSMBCommand = smb.SMBCommand(smb.SMB.SMB_COM_LOGOFF_ANDX)\n\n        # Check if the Uid matches the user trying to logoff\n        respParameters = b''\n        respData = b''\n        if recvPacket['Uid'] != connData['Uid']:\n            errorCode = STATUS_SMB_BAD_UID\n        else:\n            errorCode = STATUS_SUCCESS\n\n        respSMBCommand['Parameters'] = respParameters\n        respSMBCommand['Data'] = respData\n        connData['Uid'] = 0\n        connData['Authenticated'] = False\n\n        smbServer.setConnectionData(connId, connData)\n\n        return [respSMBCommand], None, errorCode",
  "def smbComQueryInformation2(connId, smbServer, SMBCommand, recvPacket):\n        connData = smbServer.getConnectionData(connId)\n\n        respSMBCommand = smb.SMBCommand(smb.SMB.SMB_COM_QUERY_INFORMATION2)\n        respParameters = smb.SMBQueryInformation2Response_Parameters()\n        respData = b''\n\n        queryInformation2 = smb.SMBQueryInformation2_Parameters(SMBCommand['Parameters'])\n        errorCode = 0xFF\n\n        # Get the Tid associated\n        if recvPacket['Tid'] in connData['ConnectedShares']:\n            if queryInformation2['Fid'] in connData['OpenedFiles']:\n                errorCode = STATUS_SUCCESS\n                pathName = connData['OpenedFiles'][queryInformation2['Fid']]['FileName']\n                try:\n                    (mode, ino, dev, nlink, uid, gid, size, atime, mtime, ctime) = os.stat(pathName)\n                    respParameters['CreateDate'] = getSMBDate(ctime)\n                    respParameters['CreationTime'] = getSMBTime(ctime)\n                    respParameters['LastAccessDate'] = getSMBDate(atime)\n                    respParameters['LastAccessTime'] = getSMBTime(atime)\n                    respParameters['LastWriteDate'] = getSMBDate(mtime)\n                    respParameters['LastWriteTime'] = getSMBTime(mtime)\n                    respParameters['FileDataSize'] = size\n                    respParameters['FileAllocationSize'] = size\n                    attribs = 0\n                    if os.path.isdir(pathName):\n                        attribs = smb.SMB_FILE_ATTRIBUTE_DIRECTORY\n                    if os.path.isfile(pathName):\n                        attribs = smb.SMB_FILE_ATTRIBUTE_NORMAL\n                    respParameters['FileAttributes'] = attribs\n                except Exception as e:\n                    smbServer.log('smbComQueryInformation2 %s' % e, logging.ERROR)\n                    errorCode = STATUS_ACCESS_DENIED\n        else:\n            errorCode = STATUS_SMB_BAD_TID\n\n        if errorCode > 0:\n            respParameters = b''\n            respData = b''\n\n        respSMBCommand['Parameters'] = respParameters\n        respSMBCommand['Data'] = respData\n        smbServer.setConnectionData(connId, connData)\n\n        return [respSMBCommand], None, errorCode",
  "def smbComNtCreateAndX(connId, smbServer, SMBCommand, recvPacket):\n        # TODO: Fully implement this\n        connData = smbServer.getConnectionData(connId)\n\n        respSMBCommand = smb.SMBCommand(smb.SMB.SMB_COM_NT_CREATE_ANDX)\n        respParameters = smb.SMBNtCreateAndXResponse_Parameters()\n        respData = b''\n\n        ntCreateAndXParameters = smb.SMBNtCreateAndX_Parameters(SMBCommand['Parameters'])\n        ntCreateAndXData = smb.SMBNtCreateAndX_Data(flags=recvPacket['Flags2'], data=SMBCommand['Data'])\n\n        # if ntCreateAndXParameters['CreateFlags'] & 0x10:  # NT_CREATE_REQUEST_EXTENDED_RESPONSE\n        #    respParameters        = smb.SMBNtCreateAndXExtendedResponse_Parameters()\n        #    respParameters['VolumeGUID'] = '\\x00'\n\n        # Get the Tid associated\n        if recvPacket['Tid'] in connData['ConnectedShares']:\n            # If we have a rootFid, the path is relative to that fid\n            errorCode = STATUS_SUCCESS\n            if ntCreateAndXParameters['RootFid'] > 0:\n                path = connData['OpenedFiles'][ntCreateAndXParameters['RootFid']]['FileName']\n                LOG.debug(\"RootFid present %s!\" % path)\n            else:\n                if 'path' in connData['ConnectedShares'][recvPacket['Tid']]:\n                    path = connData['ConnectedShares'][recvPacket['Tid']]['path']\n                else:\n                    path = 'NONE'\n                    errorCode = STATUS_ACCESS_DENIED\n\n            deleteOnClose = False\n\n            fileName = normalize_path(decodeSMBString(recvPacket['Flags2'], ntCreateAndXData['FileName']))\n            if not isInFileJail(path, fileName):\n                LOG.error(\"Path not in current working directory\")\n                respSMBCommand['Parameters'] = b''\n                respSMBCommand['Data'] = b''\n                return [respSMBCommand], None, STATUS_OBJECT_PATH_SYNTAX_BAD\n\n            pathName = os.path.join(path, fileName)\n            createDisposition = ntCreateAndXParameters['Disposition']\n            mode = 0\n\n            if createDisposition == smb.FILE_SUPERSEDE:\n                mode |= os.O_TRUNC | os.O_CREAT\n            elif createDisposition & smb.FILE_OVERWRITE_IF == smb.FILE_OVERWRITE_IF:\n                mode |= os.O_TRUNC | os.O_CREAT\n            elif createDisposition & smb.FILE_OVERWRITE == smb.FILE_OVERWRITE:\n                if os.path.exists(pathName) is True:\n                    mode |= os.O_TRUNC\n                else:\n                    errorCode = STATUS_NO_SUCH_FILE\n            elif createDisposition & smb.FILE_OPEN_IF == smb.FILE_OPEN_IF:\n                mode |= os.O_CREAT\n            elif createDisposition & smb.FILE_CREATE == smb.FILE_CREATE:\n                if os.path.exists(pathName) is True:\n                    errorCode = STATUS_OBJECT_NAME_COLLISION\n                else:\n                    mode |= os.O_CREAT\n            elif createDisposition & smb.FILE_OPEN == smb.FILE_OPEN:\n                if os.path.exists(pathName) is not True and (\n                        str(pathName) in smbServer.getRegisteredNamedPipes()) is not True:\n                    errorCode = STATUS_NO_SUCH_FILE\n\n            if errorCode == STATUS_SUCCESS:\n                desiredAccess = ntCreateAndXParameters['AccessMask']\n                if (desiredAccess & smb.FILE_READ_DATA) or (desiredAccess & smb.GENERIC_READ):\n                    mode |= os.O_RDONLY\n                if (desiredAccess & smb.FILE_WRITE_DATA) or (desiredAccess & smb.GENERIC_WRITE):\n                    if (desiredAccess & smb.FILE_READ_DATA) or (desiredAccess & smb.GENERIC_READ):\n                        mode |= os.O_RDWR  # | os.O_APPEND\n                    else:\n                        mode |= os.O_WRONLY  # | os.O_APPEND\n                if desiredAccess & smb.GENERIC_ALL:\n                    mode |= os.O_RDWR  # | os.O_APPEND\n\n                createOptions = ntCreateAndXParameters['CreateOptions']\n                if mode & os.O_CREAT == os.O_CREAT:\n                    if createOptions & smb.FILE_DIRECTORY_FILE == smb.FILE_DIRECTORY_FILE:\n                        try:\n                            # Let's create the directory\n                            os.mkdir(pathName)\n                            mode = os.O_RDONLY\n                        except Exception as e:\n                            smbServer.log(\"NTCreateAndX: %s,%s,%s\" % (pathName, mode, e), logging.ERROR)\n                            errorCode = STATUS_ACCESS_DENIED\n                if createOptions & smb.FILE_NON_DIRECTORY_FILE == smb.FILE_NON_DIRECTORY_FILE:\n                    # If the file being opened is a directory, the server MUST fail the request with\n                    # STATUS_FILE_IS_A_DIRECTORY in the Status field of the SMB Header in the server\n                    # response.\n                    if os.path.isdir(pathName) is True:\n                        errorCode = STATUS_FILE_IS_A_DIRECTORY\n\n                if createOptions & smb.FILE_DELETE_ON_CLOSE == smb.FILE_DELETE_ON_CLOSE:\n                    deleteOnClose = True\n\n                if errorCode == STATUS_SUCCESS:\n                    try:\n                        if os.path.isdir(pathName) and sys.platform == 'win32':\n                            fid = VOID_FILE_DESCRIPTOR\n                        else:\n                            if sys.platform == 'win32':\n                                mode |= os.O_BINARY\n                            if str(pathName) in smbServer.getRegisteredNamedPipes():\n                                fid = PIPE_FILE_DESCRIPTOR\n                                sock = socket.socket()\n                                sock.connect(smbServer.getRegisteredNamedPipes()[str(pathName)])\n                            else:\n                                fid = os.open(pathName, mode)\n                    except Exception as e:\n                        smbServer.log(\"NTCreateAndX: %s,%s,%s\" % (pathName, mode, e), logging.ERROR)\n                        # print e\n                        fid = 0\n                        errorCode = STATUS_ACCESS_DENIED\n        else:\n            errorCode = STATUS_SMB_BAD_TID\n\n        if errorCode == STATUS_SUCCESS:\n            # Simple way to generate a fid\n            if len(connData['OpenedFiles']) == 0:\n                fakefid = 1\n            else:\n                fakefid = list(connData['OpenedFiles'].keys())[-1] + 1\n            respParameters['Fid'] = fakefid\n            respParameters['CreateAction'] = createDisposition\n            if fid == PIPE_FILE_DESCRIPTOR:\n                respParameters['FileAttributes'] = 0x80\n                respParameters['IsDirectory'] = 0\n                respParameters['CreateTime'] = 0\n                respParameters['LastAccessTime'] = 0\n                respParameters['LastWriteTime'] = 0\n                respParameters['LastChangeTime'] = 0\n                respParameters['AllocationSize'] = 4096\n                respParameters['EndOfFile'] = 0\n                respParameters['FileType'] = 2\n                respParameters['IPCState'] = 0x5ff\n            else:\n                if os.path.isdir(pathName):\n                    respParameters['FileAttributes'] = smb.SMB_FILE_ATTRIBUTE_DIRECTORY\n                    respParameters['IsDirectory'] = 1\n                else:\n                    respParameters['IsDirectory'] = 0\n                    respParameters['FileAttributes'] = ntCreateAndXParameters['FileAttributes']\n                # Let's get this file's information\n                respInfo, errorCode = queryPathInformation(path, fileName, level=smb.SMB_QUERY_FILE_ALL_INFO)\n                if errorCode == STATUS_SUCCESS:\n                    respParameters['CreateTime'] = respInfo['CreationTime']\n                    respParameters['LastAccessTime'] = respInfo['LastAccessTime']\n                    respParameters['LastWriteTime'] = respInfo['LastWriteTime']\n                    respParameters['LastChangeTime'] = respInfo['LastChangeTime']\n                    respParameters['FileAttributes'] = respInfo['ExtFileAttributes']\n                    respParameters['AllocationSize'] = respInfo['AllocationSize']\n                    respParameters['EndOfFile'] = respInfo['EndOfFile']\n                else:\n                    respParameters = b''\n                    respData = b''\n\n            if errorCode == STATUS_SUCCESS:\n                # Let's store the fid for the connection\n                # smbServer.log('Create file %s, mode:0x%x' % (pathName, mode))\n                connData['OpenedFiles'][fakefid] = {}\n                connData['OpenedFiles'][fakefid]['FileHandle'] = fid\n                connData['OpenedFiles'][fakefid]['FileName'] = pathName\n                connData['OpenedFiles'][fakefid]['DeleteOnClose'] = deleteOnClose\n                if fid == PIPE_FILE_DESCRIPTOR:\n                    connData['OpenedFiles'][fakefid]['Socket'] = sock\n        else:\n            respParameters = b''\n            respData = b''\n\n        respSMBCommand['Parameters'] = respParameters\n        respSMBCommand['Data'] = respData\n        smbServer.setConnectionData(connId, connData)\n\n        return [respSMBCommand], None, errorCode",
  "def smbComOpenAndX(connId, smbServer, SMBCommand, recvPacket):\n        connData = smbServer.getConnectionData(connId)\n\n        respSMBCommand = smb.SMBCommand(smb.SMB.SMB_COM_OPEN_ANDX)\n        respParameters = smb.SMBOpenAndXResponse_Parameters()\n        respData = b''\n\n        openAndXParameters = smb.SMBOpenAndX_Parameters(SMBCommand['Parameters'])\n        openAndXData = smb.SMBOpenAndX_Data(flags=recvPacket['Flags2'], data=SMBCommand['Data'])\n\n        # Get the Tid associated\n        if recvPacket['Tid'] in connData['ConnectedShares']:\n            path = connData['ConnectedShares'][recvPacket['Tid']]['path']\n            openedFile, mode, pathName, errorCode = openFile(path,\n                                                             decodeSMBString(recvPacket['Flags2'],\n                                                                             openAndXData['FileName']),\n                                                             openAndXParameters['DesiredAccess'],\n                                                             openAndXParameters['FileAttributes'],\n                                                             openAndXParameters['OpenMode'])\n        else:\n            errorCode = STATUS_SMB_BAD_TID\n\n        if errorCode == STATUS_SUCCESS:\n            # Simple way to generate a fid\n            fid = len(connData['OpenedFiles']) + 1\n            if len(connData['OpenedFiles']) == 0:\n                fid = 1\n            else:\n                fid = list(connData['OpenedFiles'].keys())[-1] + 1\n            respParameters['Fid'] = fid\n            if mode & os.O_CREAT:\n                # File did not exist and was created\n                respParameters['Action'] = 0x2\n            elif mode & os.O_RDONLY:\n                # File existed and was opened\n                respParameters['Action'] = 0x1\n            elif mode & os.O_APPEND:\n                # File existed and was opened\n                respParameters['Action'] = 0x1\n            else:\n                # File existed and was truncated\n                respParameters['Action'] = 0x3\n\n            # Let's store the fid for the connection\n            # smbServer.log('Opening file %s' % pathName)\n            connData['OpenedFiles'][fid] = {}\n            connData['OpenedFiles'][fid]['FileHandle'] = openedFile\n            connData['OpenedFiles'][fid]['FileName'] = pathName\n            connData['OpenedFiles'][fid]['DeleteOnClose'] = False\n        else:\n            respParameters = b''\n            respData = b''\n\n        respSMBCommand['Parameters'] = respParameters\n        respSMBCommand['Data'] = respData\n        smbServer.setConnectionData(connId, connData)\n\n        return [respSMBCommand], None, errorCode",
  "def smbComTreeConnectAndX(connId, smbServer, SMBCommand, recvPacket):\n        connData = smbServer.getConnectionData(connId)\n\n        resp = smb.NewSMBPacket()\n        resp['Flags1'] = smb.SMB.FLAGS1_REPLY\n        resp['Flags2'] = smb.SMB.FLAGS2_EXTENDED_SECURITY | smb.SMB.FLAGS2_NT_STATUS | smb.SMB.FLAGS2_LONG_NAMES | \\\n                         recvPacket['Flags2'] & smb.SMB.FLAGS2_UNICODE\n\n        resp['Tid'] = recvPacket['Tid']\n        resp['Mid'] = recvPacket['Mid']\n        resp['Pid'] = connData['Pid']\n\n        respSMBCommand = smb.SMBCommand(smb.SMB.SMB_COM_TREE_CONNECT_ANDX)\n        respParameters = smb.SMBTreeConnectAndXResponse_Parameters()\n        respData = smb.SMBTreeConnectAndXResponse_Data()\n\n        treeConnectAndXParameters = smb.SMBTreeConnectAndX_Parameters(SMBCommand['Parameters'])\n\n        if treeConnectAndXParameters['Flags'] & 0x8:\n            respParameters = smb.SMBTreeConnectAndXExtendedResponse_Parameters()\n\n        treeConnectAndXData = smb.SMBTreeConnectAndX_Data(flags=recvPacket['Flags2'])\n        treeConnectAndXData['_PasswordLength'] = treeConnectAndXParameters['PasswordLength']\n        treeConnectAndXData.fromString(SMBCommand['Data'])\n\n        errorCode = STATUS_SUCCESS\n\n        ## Process here the request, does the share exist?\n        UNCOrShare = decodeSMBString(recvPacket['Flags2'], treeConnectAndXData['Path'])\n\n        # Is this a UNC?\n        if ntpath.ismount(UNCOrShare):\n            path = UNCOrShare.split('\\\\')[3]\n        else:\n            path = ntpath.basename(UNCOrShare)\n\n        share = searchShare(connId, path, smbServer)\n        if share is not None:\n            # Simple way to generate a Tid\n            if len(connData['ConnectedShares']) == 0:\n                tid = 1\n            else:\n                tid = list(connData['ConnectedShares'].keys())[-1] + 1\n            connData['ConnectedShares'][tid] = share\n            connData['ConnectedShares'][tid]['shareName'] = path\n            resp['Tid'] = tid\n            # smbServer.log(\"Connecting Share(%d:%s)\" % (tid,path))\n        else:\n            smbServer.log(\"TreeConnectAndX not found %s\" % path, logging.ERROR)\n            errorCode = STATUS_OBJECT_PATH_NOT_FOUND\n            resp['ErrorCode'] = errorCode >> 16\n            resp['ErrorClass'] = errorCode & 0xff\n        ##\n        respParameters['OptionalSupport'] = smb.SMB.SMB_SUPPORT_SEARCH_BITS\n\n        if path == 'IPC$':\n            respData['Service'] = 'IPC'\n        else:\n            respData['Service'] = path\n        respData['PadLen'] = 0\n        respData['NativeFileSystem'] = encodeSMBString(recvPacket['Flags2'], 'NTFS').decode()\n\n        respSMBCommand['Parameters'] = respParameters\n        respSMBCommand['Data'] = respData\n\n        resp['Uid'] = connData['Uid']\n        resp.addCommand(respSMBCommand)\n\n        # Sign the packet if needed\n        if connData['SignatureEnabled']:\n            smbServer.signSMBv1(connData, resp, connData['SigningSessionKey'], connData['SigningChallengeResponse'])\n        smbServer.setConnectionData(connId, connData)\n\n        return None, [resp], errorCode",
  "def smbComSessionSetupAndX(connId, smbServer, SMBCommand, recvPacket):\n        connData = smbServer.getConnectionData(connId, checkStatus=False)\n\n        respSMBCommand = smb.SMBCommand(smb.SMB.SMB_COM_SESSION_SETUP_ANDX)\n\n        # From [MS-SMB]\n        # When extended security is being used (see section 3.2.4.2.4), the\n        # request MUST take the following form\n        # [..]\n        # WordCount (1 byte): The value of this field MUST be 0x0C.\n        if SMBCommand['WordCount'] == 12:\n            # Extended security. Here we deal with all SPNEGO stuff\n            respParameters = smb.SMBSessionSetupAndX_Extended_Response_Parameters()\n            respData = smb.SMBSessionSetupAndX_Extended_Response_Data(flags=recvPacket['Flags2'])\n            sessionSetupParameters = smb.SMBSessionSetupAndX_Extended_Parameters(SMBCommand['Parameters'])\n            sessionSetupData = smb.SMBSessionSetupAndX_Extended_Data()\n            sessionSetupData['SecurityBlobLength'] = sessionSetupParameters['SecurityBlobLength']\n            sessionSetupData.fromString(SMBCommand['Data'])\n            connData['Capabilities'] = sessionSetupParameters['Capabilities']\n\n            rawNTLM = False\n            if struct.unpack('B', sessionSetupData['SecurityBlob'][0:1])[0] == ASN1_AID:\n                # NEGOTIATE packet\n                blob = SPNEGO_NegTokenInit(sessionSetupData['SecurityBlob'])\n                token = blob['MechToken']\n                if len(blob['MechTypes'][0]) > 0:\n                    # Is this GSSAPI NTLM or something else we don't support?\n                    mechType = blob['MechTypes'][0]\n                    if mechType != TypesMech['NTLMSSP - Microsoft NTLM Security Support Provider']:\n                        # Nope, do we know it?\n                        if mechType in MechTypes:\n                            mechStr = MechTypes[mechType]\n                        else:\n                            mechStr = hexlify(mechType)\n                        smbServer.log(\"Unsupported MechType '%s'\" % mechStr, logging.CRITICAL)\n                        # We don't know the token, we answer back again saying\n                        # we just support NTLM.\n                        # ToDo: Build this into a SPNEGO_NegTokenResp()\n                        respToken = b'\\xa1\\x15\\x30\\x13\\xa0\\x03\\x0a\\x01\\x03\\xa1\\x0c\\x06\\x0a\\x2b\\x06\\x01\\x04\\x01\\x82\\x37\\x02\\x02\\x0a'\n                        respParameters['SecurityBlobLength'] = len(respToken)\n                        respData['SecurityBlobLength'] = respParameters['SecurityBlobLength']\n                        respData['SecurityBlob'] = respToken\n                        respData['NativeOS'] = encodeSMBString(recvPacket['Flags2'], smbServer.getServerOS())\n                        respData['NativeLanMan'] = encodeSMBString(recvPacket['Flags2'], smbServer.getServerOS())\n                        respSMBCommand['Parameters'] = respParameters\n                        respSMBCommand['Data'] = respData\n                        return [respSMBCommand], None, STATUS_MORE_PROCESSING_REQUIRED\n\n            elif struct.unpack('B', sessionSetupData['SecurityBlob'][0:1])[0] == ASN1_SUPPORTED_MECH:\n                # AUTH packet\n                blob = SPNEGO_NegTokenResp(sessionSetupData['SecurityBlob'])\n                token = blob['ResponseToken']\n            else:\n                # No GSSAPI stuff, raw NTLMSSP\n                rawNTLM = True\n                token = sessionSetupData['SecurityBlob']\n\n            # Here we only handle NTLMSSP, depending on what stage of the\n            # authentication we are, we act on it\n            messageType = struct.unpack('<L', token[len('NTLMSSP\\x00'):len('NTLMSSP\\x00') + 4])[0]\n\n            if messageType == 0x01:\n                # NEGOTIATE_MESSAGE\n                negotiateMessage = ntlm.NTLMAuthNegotiate()\n                negotiateMessage.fromString(token)\n                # Let's store it in the connection data\n                connData['NEGOTIATE_MESSAGE'] = negotiateMessage\n                # Let's build the answer flags\n                # TODO: Parse all the flags. With this we're leaving some clients out\n\n                ansFlags = 0\n\n                if negotiateMessage['flags'] & ntlm.NTLMSSP_NEGOTIATE_56:\n                    ansFlags |= ntlm.NTLMSSP_NEGOTIATE_56\n                if negotiateMessage['flags'] & ntlm.NTLMSSP_NEGOTIATE_128:\n                    ansFlags |= ntlm.NTLMSSP_NEGOTIATE_128\n                if negotiateMessage['flags'] & ntlm.NTLMSSP_NEGOTIATE_KEY_EXCH:\n                    ansFlags |= ntlm.NTLMSSP_NEGOTIATE_KEY_EXCH\n                if negotiateMessage['flags'] & ntlm.NTLMSSP_NEGOTIATE_EXTENDED_SESSIONSECURITY:\n                    ansFlags |= ntlm.NTLMSSP_NEGOTIATE_EXTENDED_SESSIONSECURITY\n                if negotiateMessage['flags'] & ntlm.NTLMSSP_NEGOTIATE_UNICODE:\n                    ansFlags |= ntlm.NTLMSSP_NEGOTIATE_UNICODE\n                if negotiateMessage['flags'] & ntlm.NTLM_NEGOTIATE_OEM:\n                    ansFlags |= ntlm.NTLM_NEGOTIATE_OEM\n\n                ansFlags |= ntlm.NTLMSSP_NEGOTIATE_VERSION | ntlm.NTLMSSP_NEGOTIATE_TARGET_INFO | ntlm.NTLMSSP_TARGET_TYPE_SERVER | ntlm.NTLMSSP_NEGOTIATE_NTLM | ntlm.NTLMSSP_REQUEST_TARGET\n\n                # Generate the AV_PAIRS\n                av_pairs = ntlm.AV_PAIRS()\n                # TODO: Put the proper data from SMBSERVER config\n                av_pairs[ntlm.NTLMSSP_AV_HOSTNAME] = av_pairs[\n                    ntlm.NTLMSSP_AV_DNS_HOSTNAME] = smbServer.getServerName().encode('utf-16le')\n                av_pairs[ntlm.NTLMSSP_AV_DOMAINNAME] = av_pairs[\n                    ntlm.NTLMSSP_AV_DNS_DOMAINNAME] = smbServer.getServerDomain().encode('utf-16le')\n                av_pairs[ntlm.NTLMSSP_AV_TIME] = struct.pack('<q', (\n                            116444736000000000 + calendar.timegm(time.gmtime()) * 10000000))\n\n                challengeMessage = ntlm.NTLMAuthChallenge()\n                challengeMessage['flags'] = ansFlags\n                challengeMessage['domain_len'] = len(smbServer.getServerDomain().encode('utf-16le'))\n                challengeMessage['domain_max_len'] = challengeMessage['domain_len']\n                challengeMessage['domain_offset'] = 40 + 16\n                challengeMessage['challenge'] = smbServer.getSMBChallenge()\n                challengeMessage['domain_name'] = smbServer.getServerDomain().encode('utf-16le')\n                challengeMessage['TargetInfoFields_len'] = len(av_pairs)\n                challengeMessage['TargetInfoFields_max_len'] = len(av_pairs)\n                challengeMessage['TargetInfoFields'] = av_pairs\n                challengeMessage['TargetInfoFields_offset'] = 40 + 16 + len(challengeMessage['domain_name'])\n                challengeMessage['Version'] = b'\\xff' * 8\n                challengeMessage['VersionLen'] = 8\n\n                if rawNTLM is False:\n                    respToken = SPNEGO_NegTokenResp()\n                    # accept-incomplete. We want more data\n                    respToken['NegState'] = b'\\x01'\n                    respToken['SupportedMech'] = TypesMech['NTLMSSP - Microsoft NTLM Security Support Provider']\n\n                    respToken['ResponseToken'] = challengeMessage.getData()\n                else:\n                    respToken = challengeMessage\n\n                # Setting the packet to STATUS_MORE_PROCESSING\n                errorCode = STATUS_MORE_PROCESSING_REQUIRED\n                # Let's set up an UID for this connection and store it\n                # in the connection's data\n                # Picking a fixed value\n                # TODO: Manage more UIDs for the same session\n                connData['Uid'] = 10\n                # Let's store it in the connection data\n                connData['CHALLENGE_MESSAGE'] = challengeMessage\n\n            elif messageType == 0x02:\n                # CHALLENGE_MESSAGE\n                raise Exception('Challenge Message raise, not implemented!')\n\n            elif messageType == 0x03:\n                # AUTHENTICATE_MESSAGE, here we deal with authentication\n                authenticateMessage = ntlm.NTLMAuthChallengeResponse()\n                authenticateMessage.fromString(token)\n                smbServer.log(\"AUTHENTICATE_MESSAGE (%s\\\\%s,%s)\" % (\n                    authenticateMessage['domain_name'].decode('utf-16le'),\n                    authenticateMessage['user_name'].decode('utf-16le'),\n                    authenticateMessage['host_name'].decode('utf-16le')))\n                # Do we have credentials to check?\n                if len(smbServer.getCredentials()) > 0:\n                    identity = authenticateMessage['user_name'].decode('utf-16le').lower()\n                    # Do we have this user's credentials?\n                    if identity in smbServer.getCredentials():\n                        # Process data:\n                        # Let's parse some data and keep it to ourselves in case it is asked\n                        uid, lmhash, nthash = smbServer.getCredentials()[identity]\n\n                        errorCode, sessionKey = computeNTLMv2(identity, lmhash, nthash, smbServer.getSMBChallenge(),\n                                                              authenticateMessage, connData['CHALLENGE_MESSAGE'],\n                                                              connData['NEGOTIATE_MESSAGE'])\n\n                        if sessionKey is not None:\n                            connData['SignatureEnabled'] = False\n                            connData['SigningSessionKey'] = sessionKey\n                            connData['SignSequenceNumber'] = 1\n                    else:\n                        errorCode = STATUS_LOGON_FAILURE\n                else:\n                    # No credentials provided, let's grant access\n                    errorCode = STATUS_SUCCESS\n\n                if errorCode == STATUS_SUCCESS:\n                    connData['Authenticated'] = True\n                    respToken = SPNEGO_NegTokenResp()\n                    # accept-completed\n                    respToken['NegState'] = b'\\x00'\n\n                    smbServer.log(\n                        'User %s\\\\%s authenticated successfully' % (authenticateMessage['host_name'].decode('utf-16le'),\n                                                                    authenticateMessage['user_name'].decode(\n                                                                        'utf-16le')))\n                    # Let's store it in the connection data\n                    connData['AUTHENTICATE_MESSAGE'] = authenticateMessage\n                    try:\n                        jtr_dump_path = smbServer.getJTRdumpPath()\n                        ntlm_hash_data = outputToJohnFormat(connData['CHALLENGE_MESSAGE']['challenge'],\n                                                            authenticateMessage['user_name'],\n                                                            authenticateMessage['domain_name'],\n                                                            authenticateMessage['lanman'], authenticateMessage['ntlm'])\n                        smbServer.log(ntlm_hash_data['hash_string'])\n                        if jtr_dump_path != '':\n                            writeJohnOutputToFile(ntlm_hash_data['hash_string'], ntlm_hash_data['hash_version'],\n                                                  jtr_dump_path)\n                    except:\n                        smbServer.log(\"Could not write NTLM Hashes to the specified JTR_Dump_Path %s\" % jtr_dump_path)\n                else:\n                    respToken = SPNEGO_NegTokenResp()\n                    respToken['NegState'] = b'\\x02'\n                    smbServer.log(\"Could not authenticate user!\")\n                if smbServer.auth_callback is not None:\n                    try:\n                        smbServer.auth_callback(\n                            smbServer=smbServer,\n                            connData=connData,\n                            domain_name=authenticateMessage['domain_name'].decode('utf-16le'),\n                            user_name=authenticateMessage['user_name'].decode('utf-16le'),\n                            host_name=authenticateMessage['host_name'].decode('utf-16le')\n                        )\n                    except Exception as e:\n                        print(\"[!] Could not call auth_callback: %s\" % e)\n\n            else:\n                raise Exception(\"Unknown NTLMSSP MessageType %d\" % messageType)\n\n            respParameters['SecurityBlobLength'] = len(respToken)\n            respData['SecurityBlobLength'] = respParameters['SecurityBlobLength']\n            respData['SecurityBlob'] = respToken.getData()\n\n        else:\n            # Process Standard Security\n            respParameters = smb.SMBSessionSetupAndXResponse_Parameters()\n            respData = smb.SMBSessionSetupAndXResponse_Data()\n            sessionSetupParameters = smb.SMBSessionSetupAndX_Parameters(SMBCommand['Parameters'])\n            sessionSetupData = smb.SMBSessionSetupAndX_Data()\n            sessionSetupData['AnsiPwdLength'] = sessionSetupParameters['AnsiPwdLength']\n            sessionSetupData['UnicodePwdLength'] = sessionSetupParameters['UnicodePwdLength']\n            sessionSetupData.fromString(SMBCommand['Data'])\n            connData['Capabilities'] = sessionSetupParameters['Capabilities']\n            # Do the verification here, for just now we grant access\n            # TODO: Manage more UIDs for the same session\n            errorCode = STATUS_SUCCESS\n            connData['Uid'] = 10\n            connData['Authenticated'] = True\n            respParameters['Action'] = 0\n            smbServer.log('User %s\\\\%s authenticated successfully (basic)' % (\n            sessionSetupData['PrimaryDomain'], sessionSetupData['Account']))\n            try:\n                jtr_dump_path = smbServer.getJTRdumpPath()\n                ntlm_hash_data = outputToJohnFormat(b'', b(sessionSetupData['Account']),\n                                                    b(sessionSetupData['PrimaryDomain']), sessionSetupData['AnsiPwd'],\n                                                    sessionSetupData['UnicodePwd'])\n                smbServer.log(ntlm_hash_data['hash_string'])\n                if jtr_dump_path != '':\n                    writeJohnOutputToFile(ntlm_hash_data['hash_string'], ntlm_hash_data['hash_version'], jtr_dump_path)\n            except:\n                smbServer.log(\"Could not write NTLM Hashes to the specified JTR_Dump_Path %s\" % jtr_dump_path)\n\n        respData['NativeOS'] = encodeSMBString(recvPacket['Flags2'], smbServer.getServerOS())\n        respData['NativeLanMan'] = encodeSMBString(recvPacket['Flags2'], smbServer.getServerOS())\n        respSMBCommand['Parameters'] = respParameters\n        respSMBCommand['Data'] = respData\n\n        # From now on, the client can ask for other commands\n        connData['Authenticated'] = True\n        # For now, just switching to nobody\n        # os.setregid(65534,65534)\n        # os.setreuid(65534,65534)\n        smbServer.setConnectionData(connId, connData)\n\n        return [respSMBCommand], None, errorCode",
  "def smbComNegotiate(connId, smbServer, SMBCommand, recvPacket):\n        connData = smbServer.getConnectionData(connId, checkStatus=False)\n        connData['Pid'] = recvPacket['Pid']\n\n        SMBCommand = smb.SMBCommand(recvPacket['Data'][0])\n        respSMBCommand = smb.SMBCommand(smb.SMB.SMB_COM_NEGOTIATE)\n\n        resp = smb.NewSMBPacket()\n        resp['Flags1'] = smb.SMB.FLAGS1_REPLY\n        resp['Pid'] = connData['Pid']\n        resp['Tid'] = recvPacket['Tid']\n        resp['Mid'] = recvPacket['Mid']\n\n        # TODO: We support more dialects, and parse them accordingly\n        dialects = SMBCommand['Data'].split(b'\\x02')\n        try:\n            index = dialects.index(b'NT LM 0.12\\x00') - 1\n            # Let's fill the data for NTLM\n            if recvPacket['Flags2'] & smb.SMB.FLAGS2_EXTENDED_SECURITY:\n                resp['Flags2'] = smb.SMB.FLAGS2_EXTENDED_SECURITY | smb.SMB.FLAGS2_NT_STATUS | smb.SMB.FLAGS2_UNICODE\n                # resp['Flags2'] = smb.SMB.FLAGS2_EXTENDED_SECURITY | smb.SMB.FLAGS2_NT_STATUS\n                _dialects_data = smb.SMBExtended_Security_Data()\n                _dialects_data['ServerGUID'] = b'A' * 16\n                blob = SPNEGO_NegTokenInit()\n                blob['MechTypes'] = [TypesMech['NTLMSSP - Microsoft NTLM Security Support Provider']]\n                _dialects_data['SecurityBlob'] = blob.getData()\n\n                _dialects_parameters = smb.SMBExtended_Security_Parameters()\n                _dialects_parameters[\n                    'Capabilities'] = smb.SMB.CAP_EXTENDED_SECURITY | smb.SMB.CAP_USE_NT_ERRORS | smb.SMB.CAP_NT_SMBS | smb.SMB.CAP_UNICODE\n                _dialects_parameters['ChallengeLength'] = 0\n\n            else:\n                resp['Flags2'] = smb.SMB.FLAGS2_NT_STATUS | smb.SMB.FLAGS2_UNICODE\n                _dialects_parameters = smb.SMBNTLMDialect_Parameters()\n                _dialects_data = smb.SMBNTLMDialect_Data()\n                _dialects_data['Payload'] = ''\n                if 'EncryptionKey' in connData:\n                    _dialects_data['Challenge'] = connData['EncryptionKey']\n                    _dialects_parameters['ChallengeLength'] = len(_dialects_data.getData())\n                else:\n                    # TODO: Handle random challenges, now one that can be used with rainbow tables\n                    _dialects_data['Challenge'] = b'\\x11\\x22\\x33\\x44\\x55\\x66\\x77\\x88'\n                    _dialects_parameters['ChallengeLength'] = 8\n                _dialects_parameters['Capabilities'] = smb.SMB.CAP_USE_NT_ERRORS | smb.SMB.CAP_NT_SMBS\n\n                # Let's see if we need to support RPC_REMOTE_APIS\n            config = smbServer.getServerConfig()\n            if config.has_option('global', 'rpc_apis'):\n                if config.getboolean('global', 'rpc_apis') is True:\n                    _dialects_parameters['Capabilities'] |= smb.SMB.CAP_RPC_REMOTE_APIS\n\n            _dialects_parameters['DialectIndex'] = index\n            # _dialects_parameters['SecurityMode']    = smb.SMB.SECURITY_AUTH_ENCRYPTED | smb.SMB.SECURITY_SHARE_USER | smb.SMB.SECURITY_SIGNATURES_REQUIRED\n            _dialects_parameters['SecurityMode'] = smb.SMB.SECURITY_AUTH_ENCRYPTED | smb.SMB.SECURITY_SHARE_USER\n            _dialects_parameters['MaxMpxCount'] = 1\n            _dialects_parameters['MaxNumberVcs'] = 1\n            _dialects_parameters['MaxBufferSize'] = 64000\n            _dialects_parameters['MaxRawSize'] = 65536\n            _dialects_parameters['SessionKey'] = 0\n            _dialects_parameters['LowDateTime'] = 0\n            _dialects_parameters['HighDateTime'] = 0\n            _dialects_parameters['ServerTimeZone'] = 0\n\n            respSMBCommand['Data'] = _dialects_data\n            respSMBCommand['Parameters'] = _dialects_parameters\n            connData['_dialects_data'] = _dialects_data\n            connData['_dialects_parameters'] = _dialects_parameters\n\n        except Exception as e:\n            # No NTLM throw an error\n            smbServer.log('smbComNegotiate: %s' % e, logging.ERROR)\n            respSMBCommand['Data'] = struct.pack('<H', 0xffff)\n\n        smbServer.setConnectionData(connId, connData)\n\n        resp.addCommand(respSMBCommand)\n\n        return None, [resp], STATUS_SUCCESS",
  "def default(connId, smbServer, SMBCommand, recvPacket):\n        # By default we return an SMB Packet with error not implemented\n        smbServer.log(\"Not implemented command: 0x%x\" % recvPacket['Command'], logging.DEBUG)\n        packet = smb.NewSMBPacket()\n        packet['Flags1'] = smb.SMB.FLAGS1_REPLY\n        packet['Flags2'] = smb.SMB.FLAGS2_NT_STATUS\n        packet['Command'] = recvPacket['Command']\n        packet['Pid'] = recvPacket['Pid']\n        packet['Tid'] = recvPacket['Tid']\n        packet['Mid'] = recvPacket['Mid']\n        packet['Uid'] = recvPacket['Uid']\n        packet['Data'] = b'\\x00\\x00\\x00'\n        errorCode = STATUS_NOT_IMPLEMENTED\n        packet['ErrorCode'] = errorCode >> 16\n        packet['ErrorClass'] = errorCode & 0xff\n\n        return None, [packet], errorCode",
  "def smb2Negotiate(connId, smbServer, recvPacket, isSMB1=False):\n        connData = smbServer.getConnectionData(connId, checkStatus=False)\n\n        respPacket = smb2.SMB2Packet()\n        respPacket['Flags'] = smb2.SMB2_FLAGS_SERVER_TO_REDIR\n        respPacket['Status'] = STATUS_SUCCESS\n        respPacket['CreditRequestResponse'] = 1\n        respPacket['Command'] = smb2.SMB2_NEGOTIATE\n        respPacket['SessionID'] = 0\n        if isSMB1 is False:\n            respPacket['MessageID'] = recvPacket['MessageID']\n        else:\n            respPacket['MessageID'] = 0\n        respPacket['TreeID'] = 0\n\n        respSMBCommand = smb2.SMB2Negotiate_Response()\n\n        respSMBCommand['SecurityMode'] = 1\n        if isSMB1 is True:\n            # Let's first parse the packet to see if the client supports SMB2\n            SMBCommand = smb.SMBCommand(recvPacket['Data'][0])\n\n            dialects = SMBCommand['Data'].split(b'\\x02')\n            if b'SMB 2.002\\x00' in dialects or b'SMB 2.???\\x00' in dialects:\n                respSMBCommand['DialectRevision'] = smb2.SMB2_DIALECT_002\n            else:\n                # Client does not support SMB2 fallbacking\n                raise Exception('SMB2 not supported, fallbacking')\n        else:\n            respSMBCommand['DialectRevision'] = smb2.SMB2_DIALECT_002\n        respSMBCommand['ServerGuid'] = b'A' * 16\n        respSMBCommand['Capabilities'] = 0\n        respSMBCommand['MaxTransactSize'] = 65536\n        respSMBCommand['MaxReadSize'] = 65536\n        respSMBCommand['MaxWriteSize'] = 65536\n        respSMBCommand['SystemTime'] = getFileTime(calendar.timegm(time.gmtime()))\n        respSMBCommand['ServerStartTime'] = getFileTime(calendar.timegm(time.gmtime()))\n        respSMBCommand['SecurityBufferOffset'] = 0x80\n\n        blob = SPNEGO_NegTokenInit()\n        blob['MechTypes'] = [TypesMech['NTLMSSP - Microsoft NTLM Security Support Provider']]\n\n        respSMBCommand['Buffer'] = blob.getData()\n        respSMBCommand['SecurityBufferLength'] = len(respSMBCommand['Buffer'])\n\n        respPacket['Data'] = respSMBCommand\n\n        smbServer.setConnectionData(connId, connData)\n\n        return None, [respPacket], STATUS_SUCCESS",
  "def smb2SessionSetup(connId, smbServer, recvPacket):\n        connData = smbServer.getConnectionData(connId, checkStatus=False)\n\n        respSMBCommand = smb2.SMB2SessionSetup_Response()\n\n        sessionSetupData = smb2.SMB2SessionSetup(recvPacket['Data'])\n\n        connData['Capabilities'] = sessionSetupData['Capabilities']\n\n        securityBlob = sessionSetupData['Buffer']\n\n        rawNTLM = False\n        if struct.unpack('B', securityBlob[0:1])[0] == ASN1_AID:\n            # NEGOTIATE packet\n            blob = SPNEGO_NegTokenInit(securityBlob)\n            token = blob['MechToken']\n            if len(blob['MechTypes'][0]) > 0:\n                # Is this GSSAPI NTLM or something else we don't support?\n                mechType = blob['MechTypes'][0]\n                if mechType != TypesMech['NTLMSSP - Microsoft NTLM Security Support Provider']:\n                    # Nope, do we know it?\n                    if mechType in MechTypes:\n                        mechStr = MechTypes[mechType]\n                    else:\n                        mechStr = hexlify(mechType)\n                    smbServer.log(\"Unsupported MechType '%s'\" % mechStr, logging.CRITICAL)\n                    # We don't know the token, we answer back again saying\n                    # we just support NTLM.\n                    # ToDo: Build this into a SPNEGO_NegTokenResp()\n                    respToken = b'\\xa1\\x15\\x30\\x13\\xa0\\x03\\x0a\\x01\\x03\\xa1\\x0c\\x06\\x0a\\x2b\\x06\\x01\\x04\\x01\\x82\\x37\\x02\\x02\\x0a'\n                    respSMBCommand['SecurityBufferOffset'] = 0x48\n                    respSMBCommand['SecurityBufferLength'] = len(respToken)\n                    respSMBCommand['Buffer'] = respToken\n\n                    return [respSMBCommand], None, STATUS_MORE_PROCESSING_REQUIRED\n        elif struct.unpack('B', securityBlob[0:1])[0] == ASN1_SUPPORTED_MECH:\n            # AUTH packet\n            blob = SPNEGO_NegTokenResp(securityBlob)\n            token = blob['ResponseToken']\n        else:\n            # No GSSAPI stuff, raw NTLMSSP\n            rawNTLM = True\n            token = securityBlob\n\n        # Here we only handle NTLMSSP, depending on what stage of the\n        # authentication we are, we act on it\n        messageType = struct.unpack('<L', token[len('NTLMSSP\\x00'):len('NTLMSSP\\x00') + 4])[0]\n\n        if messageType == 0x01:\n            # NEGOTIATE_MESSAGE\n            negotiateMessage = ntlm.NTLMAuthNegotiate()\n            negotiateMessage.fromString(token)\n            # Let's store it in the connection data\n            connData['NEGOTIATE_MESSAGE'] = negotiateMessage\n            # Let's build the answer flags\n            # TODO: Parse all the flags. With this we're leaving some clients out\n\n            ansFlags = 0\n\n            if negotiateMessage['flags'] & ntlm.NTLMSSP_NEGOTIATE_56:\n                ansFlags |= ntlm.NTLMSSP_NEGOTIATE_56\n            if negotiateMessage['flags'] & ntlm.NTLMSSP_NEGOTIATE_128:\n                ansFlags |= ntlm.NTLMSSP_NEGOTIATE_128\n            if negotiateMessage['flags'] & ntlm.NTLMSSP_NEGOTIATE_KEY_EXCH:\n                ansFlags |= ntlm.NTLMSSP_NEGOTIATE_KEY_EXCH\n            if negotiateMessage['flags'] & ntlm.NTLMSSP_NEGOTIATE_EXTENDED_SESSIONSECURITY:\n                ansFlags |= ntlm.NTLMSSP_NEGOTIATE_EXTENDED_SESSIONSECURITY\n            if negotiateMessage['flags'] & ntlm.NTLMSSP_NEGOTIATE_UNICODE:\n                ansFlags |= ntlm.NTLMSSP_NEGOTIATE_UNICODE\n            if negotiateMessage['flags'] & ntlm.NTLM_NEGOTIATE_OEM:\n                ansFlags |= ntlm.NTLM_NEGOTIATE_OEM\n\n            ansFlags |= ntlm.NTLMSSP_NEGOTIATE_VERSION | ntlm.NTLMSSP_NEGOTIATE_TARGET_INFO | ntlm.NTLMSSP_TARGET_TYPE_SERVER | ntlm.NTLMSSP_NEGOTIATE_NTLM | ntlm.NTLMSSP_REQUEST_TARGET\n\n            # Generate the AV_PAIRS\n            av_pairs = ntlm.AV_PAIRS()\n            # TODO: Put the proper data from SMBSERVER config\n            av_pairs[ntlm.NTLMSSP_AV_HOSTNAME] = av_pairs[\n                ntlm.NTLMSSP_AV_DNS_HOSTNAME] = smbServer.getServerName().encode('utf-16le')\n            av_pairs[ntlm.NTLMSSP_AV_DOMAINNAME] = av_pairs[\n                ntlm.NTLMSSP_AV_DNS_DOMAINNAME] = smbServer.getServerDomain().encode('utf-16le')\n            av_pairs[ntlm.NTLMSSP_AV_TIME] = struct.pack('<q', (\n                        116444736000000000 + calendar.timegm(time.gmtime()) * 10000000))\n\n            challengeMessage = ntlm.NTLMAuthChallenge()\n            challengeMessage['flags'] = ansFlags\n            challengeMessage['domain_len'] = len(smbServer.getServerDomain().encode('utf-16le'))\n            challengeMessage['domain_max_len'] = challengeMessage['domain_len']\n            challengeMessage['domain_offset'] = 40 + 16\n            challengeMessage['challenge'] = smbServer.getSMBChallenge()\n            challengeMessage['domain_name'] = smbServer.getServerDomain().encode('utf-16le')\n            challengeMessage['TargetInfoFields_len'] = len(av_pairs)\n            challengeMessage['TargetInfoFields_max_len'] = len(av_pairs)\n            challengeMessage['TargetInfoFields'] = av_pairs\n            challengeMessage['TargetInfoFields_offset'] = 40 + 16 + len(challengeMessage['domain_name'])\n            challengeMessage['Version'] = b'\\xff' * 8\n            challengeMessage['VersionLen'] = 8\n\n            if rawNTLM is False:\n                respToken = SPNEGO_NegTokenResp()\n                # accept-incomplete. We want more data\n                respToken['NegState'] = b'\\x01'\n                respToken['SupportedMech'] = TypesMech['NTLMSSP - Microsoft NTLM Security Support Provider']\n\n                respToken['ResponseToken'] = challengeMessage.getData()\n            else:\n                respToken = challengeMessage\n\n            # Setting the packet to STATUS_MORE_PROCESSING\n            errorCode = STATUS_MORE_PROCESSING_REQUIRED\n            # Let's set up an UID for this connection and store it\n            # in the connection's data\n            # Picking a fixed value\n            # TODO: Manage more UIDs for the same session\n            connData['Uid'] = random.randint(1, 0xffffffff)\n            # Let's store it in the connection data\n            connData['CHALLENGE_MESSAGE'] = challengeMessage\n\n        elif messageType == 0x02:\n            # CHALLENGE_MESSAGE\n            raise Exception('Challenge Message raise, not implemented!')\n        elif messageType == 0x03:\n            # AUTHENTICATE_MESSAGE, here we deal with authentication\n            authenticateMessage = ntlm.NTLMAuthChallengeResponse()\n            authenticateMessage.fromString(token)\n            smbServer.log(\"AUTHENTICATE_MESSAGE (%s\\\\%s,%s)\" % (\n                authenticateMessage['domain_name'].decode('utf-16le'),\n                authenticateMessage['user_name'].decode('utf-16le'),\n                authenticateMessage['host_name'].decode('utf-16le')))\n\n            isGuest = False\n            isAnonymus = False\n\n            # TODO: Check the credentials! Now granting permissions\n            # Do we have credentials to check?\n            if len(smbServer.getCredentials()) > 0:\n                identity = authenticateMessage['user_name'].decode('utf-16le').lower()\n                # Do we have this user's credentials?\n                if identity in smbServer.getCredentials():\n                    # Process data:\n                    # Let's parse some data and keep it to ourselves in case it is asked\n                    uid, lmhash, nthash = smbServer.getCredentials()[identity]\n\n                    errorCode, sessionKey = computeNTLMv2(identity, lmhash, nthash, smbServer.getSMBChallenge(),\n                                                          authenticateMessage, connData['CHALLENGE_MESSAGE'],\n                                                          connData['NEGOTIATE_MESSAGE'])\n\n                    if sessionKey is not None:\n                        connData['SignatureEnabled'] = True\n                        connData['SigningSessionKey'] = sessionKey\n                        connData['SignSequenceNumber'] = 1\n                else:\n                    errorCode = STATUS_LOGON_FAILURE\n            else:\n                # No credentials provided, let's grant access\n                if authenticateMessage['flags'] & ntlm.NTLMSSP_NEGOTIATE_ANONYMOUS:\n                    isAnonymus = True\n                    if smbServer._SMBSERVER__anonymousLogon == False:\n                        errorCode = STATUS_ACCESS_DENIED\n                    else:\n                        errorCode = STATUS_SUCCESS\n                else:\n                    isGuest = True\n                    errorCode = STATUS_SUCCESS\n\n            if errorCode == STATUS_SUCCESS:\n                connData['Authenticated'] = True\n                respToken = SPNEGO_NegTokenResp()\n                # accept-completed\n                respToken['NegState'] = b'\\x00'\n                smbServer.log('User %s\\\\%s authenticated successfully' % (\n                    authenticateMessage['host_name'].decode('utf-16le'),\n                    authenticateMessage['user_name'].decode('utf-16le')))\n                # Let's store it in the connection data\n                connData['AUTHENTICATE_MESSAGE'] = authenticateMessage\n                try:\n                    jtr_dump_path = smbServer.getJTRdumpPath()\n                    ntlm_hash_data = outputToJohnFormat(connData['CHALLENGE_MESSAGE']['challenge'],\n                                                        authenticateMessage['user_name'],\n                                                        authenticateMessage['domain_name'],\n                                                        authenticateMessage['lanman'], authenticateMessage['ntlm'])\n                    smbServer.log(ntlm_hash_data['hash_string'])\n                    if jtr_dump_path != '':\n                        writeJohnOutputToFile(ntlm_hash_data['hash_string'], ntlm_hash_data['hash_version'],\n                                              jtr_dump_path)\n                except:\n                    smbServer.log(\"Could not write NTLM Hashes to the specified JTR_Dump_Path %s\" % jtr_dump_path)\n\n                if isGuest:\n                    respSMBCommand['SessionFlags'] = 1\n                elif isAnonymus:\n                    respSMBCommand['SessionFlags'] = 2\n\n            else:\n                respToken = SPNEGO_NegTokenResp()\n                respToken['NegState'] = b'\\x02'\n                smbServer.log(\"Could not authenticate user!\")\n\n            if smbServer.auth_callback is not None:\n                try:\n                    smbServer.auth_callback(\n                        smbServer=smbServer,\n                        connData=connData,\n                        domain_name=authenticateMessage['domain_name'].decode('utf-16le'),\n                        user_name=authenticateMessage['user_name'].decode('utf-16le'),\n                        host_name=authenticateMessage['host_name'].decode('utf-16le')\n                    )\n                except Exception as e:\n                    print(\"[!] Could not call auth_callback: %s\" % e)\n\n        else:\n            raise Exception(\"Unknown NTLMSSP MessageType %d\" % messageType)\n\n        respSMBCommand['SecurityBufferOffset'] = 0x48\n        respSMBCommand['SecurityBufferLength'] = len(respToken)\n        respSMBCommand['Buffer'] = respToken.getData()\n\n        # From now on, the client can ask for other commands\n        connData['Authenticated'] = True\n        # For now, just switching to nobody\n        # os.setregid(65534,65534)\n        # os.setreuid(65534,65534)\n        smbServer.setConnectionData(connId, connData)\n\n        return [respSMBCommand], None, errorCode",
  "def smb2TreeConnect(connId, smbServer, recvPacket):\n        connData = smbServer.getConnectionData(connId)\n\n        respPacket = smb2.SMB2Packet()\n        respPacket['Flags'] = smb2.SMB2_FLAGS_SERVER_TO_REDIR\n        respPacket['Status'] = STATUS_SUCCESS\n        respPacket['CreditRequestResponse'] = 1\n        respPacket['Command'] = recvPacket['Command']\n        respPacket['SessionID'] = connData['Uid']\n        respPacket['Reserved'] = recvPacket['Reserved']\n        respPacket['MessageID'] = recvPacket['MessageID']\n        respPacket['TreeID'] = recvPacket['TreeID']\n\n        respSMBCommand = smb2.SMB2TreeConnect_Response()\n\n        treeConnectRequest = smb2.SMB2TreeConnect(recvPacket['Data'])\n\n        errorCode = STATUS_SUCCESS\n\n        ## Process here the request, does the share exist?\n        path = recvPacket.getData()[treeConnectRequest['PathOffset']:][:treeConnectRequest['PathLength']]\n        UNCOrShare = path.decode('utf-16le')\n\n        # Is this a UNC?\n        if ntpath.ismount(UNCOrShare):\n            path = UNCOrShare.split('\\\\')[3]\n        else:\n            path = ntpath.basename(UNCOrShare)\n\n        share = searchShare(connId, path.upper(), smbServer)\n        if share is not None:\n            # Simple way to generate a Tid\n            if len(connData['ConnectedShares']) == 0:\n                tid = 1\n            else:\n                tid = list(connData['ConnectedShares'].keys())[-1] + 1\n            connData['ConnectedShares'][tid] = share\n            connData['ConnectedShares'][tid]['shareName'] = path\n            respPacket['TreeID'] = tid\n            smbServer.log(\"Connecting Share(%d:%s)\" % (tid, path))\n        else:\n            smbServer.log(\"SMB2_TREE_CONNECT not found %s\" % path, logging.ERROR)\n            errorCode = STATUS_OBJECT_PATH_NOT_FOUND\n            respPacket['Status'] = errorCode\n        ##\n\n        if path.upper() == 'IPC$':\n            respSMBCommand['ShareType'] = smb2.SMB2_SHARE_TYPE_PIPE\n            respSMBCommand['ShareFlags'] = 0x30\n        else:\n            respSMBCommand['ShareType'] = smb2.SMB2_SHARE_TYPE_DISK\n            respSMBCommand['ShareFlags'] = 0x0\n\n        respSMBCommand['Capabilities'] = 0\n        respSMBCommand['MaximalAccess'] = 0x000f01ff\n\n        respPacket['Data'] = respSMBCommand\n\n        # Sign the packet if needed\n        if connData['SignatureEnabled']:\n            smbServer.signSMBv2(respPacket, connData['SigningSessionKey'])\n        smbServer.setConnectionData(connId, connData)\n\n        return None, [respPacket], errorCode",
  "def smb2Create(connId, smbServer, recvPacket):\n        connData = smbServer.getConnectionData(connId)\n\n        respSMBCommand = smb2.SMB2Create_Response()\n\n        ntCreateRequest = smb2.SMB2Create(recvPacket['Data'])\n\n        respSMBCommand['Buffer'] = b'\\x00'\n        # Get the Tid associated\n        if recvPacket['TreeID'] in connData['ConnectedShares']:\n            # If we have a rootFid, the path is relative to that fid\n            errorCode = STATUS_SUCCESS\n            if 'path' in connData['ConnectedShares'][recvPacket['TreeID']]:\n                path = connData['ConnectedShares'][recvPacket['TreeID']]['path']\n            else:\n                path = 'NONE'\n                errorCode = STATUS_ACCESS_DENIED\n\n            deleteOnClose = False\n\n            fileName = normalize_path(ntCreateRequest['Buffer'][:ntCreateRequest['NameLength']].decode('utf-16le'))\n\n            if not isInFileJail(path, fileName):\n                LOG.error(\"Path not in current working directory\")\n                return [smb2.SMB2Error()], None, STATUS_OBJECT_PATH_SYNTAX_BAD\n\n            pathName = os.path.join(path, fileName)\n            createDisposition = ntCreateRequest['CreateDisposition']\n            mode = 0\n\n            if createDisposition == smb2.FILE_SUPERSEDE:\n                mode |= os.O_TRUNC | os.O_CREAT\n            elif createDisposition & smb2.FILE_OVERWRITE_IF == smb2.FILE_OVERWRITE_IF:\n                mode |= os.O_TRUNC | os.O_CREAT\n            elif createDisposition & smb2.FILE_OVERWRITE == smb2.FILE_OVERWRITE:\n                if os.path.exists(pathName) is True:\n                    mode |= os.O_TRUNC\n                else:\n                    errorCode = STATUS_NO_SUCH_FILE\n            elif createDisposition & smb2.FILE_OPEN_IF == smb2.FILE_OPEN_IF:\n                mode |= os.O_CREAT\n            elif createDisposition & smb2.FILE_CREATE == smb2.FILE_CREATE:\n                if os.path.exists(pathName) is True:\n                    errorCode = STATUS_OBJECT_NAME_COLLISION\n                else:\n                    mode |= os.O_CREAT\n            elif createDisposition & smb2.FILE_OPEN == smb2.FILE_OPEN:\n                if os.path.exists(pathName) is not True and (\n                        str(pathName) in smbServer.getRegisteredNamedPipes()) is not True:\n                    errorCode = STATUS_NO_SUCH_FILE\n\n            if errorCode == STATUS_SUCCESS:\n                desiredAccess = ntCreateRequest['DesiredAccess']\n                if (desiredAccess & smb2.FILE_READ_DATA) or (desiredAccess & smb2.GENERIC_READ):\n                    mode |= os.O_RDONLY\n                if (desiredAccess & smb2.FILE_WRITE_DATA) or (desiredAccess & smb2.GENERIC_WRITE):\n                    if (desiredAccess & smb2.FILE_READ_DATA) or (desiredAccess & smb2.GENERIC_READ):\n                        mode |= os.O_RDWR  # | os.O_APPEND\n                    else:\n                        mode |= os.O_WRONLY  # | os.O_APPEND\n                if desiredAccess & smb2.GENERIC_ALL:\n                    mode |= os.O_RDWR  # | os.O_APPEND\n\n                createOptions = ntCreateRequest['CreateOptions']\n                if mode & os.O_CREAT == os.O_CREAT:\n                    if createOptions & smb2.FILE_DIRECTORY_FILE == smb2.FILE_DIRECTORY_FILE:\n                        try:\n                            # Let's create the directory\n                            os.mkdir(pathName)\n                            mode = os.O_RDONLY\n                        except Exception as e:\n                            smbServer.log(\"SMB2_CREATE: %s,%s,%s\" % (pathName, mode, e), logging.ERROR)\n                            errorCode = STATUS_ACCESS_DENIED\n                if createOptions & smb2.FILE_NON_DIRECTORY_FILE == smb2.FILE_NON_DIRECTORY_FILE:\n                    # If the file being opened is a directory, the server MUST fail the request with\n                    # STATUS_FILE_IS_A_DIRECTORY in the Status field of the SMB Header in the server\n                    # response.\n                    if os.path.isdir(pathName) is True:\n                        errorCode = STATUS_FILE_IS_A_DIRECTORY\n\n                if createOptions & smb2.FILE_DELETE_ON_CLOSE == smb2.FILE_DELETE_ON_CLOSE:\n                    deleteOnClose = True\n\n                if errorCode == STATUS_SUCCESS:\n                    try:\n                        if os.path.isdir(pathName) and sys.platform == 'win32':\n                            fid = VOID_FILE_DESCRIPTOR\n                        else:\n                            if sys.platform == 'win32':\n                                mode |= os.O_BINARY\n                            if str(pathName) in smbServer.getRegisteredNamedPipes():\n                                fid = PIPE_FILE_DESCRIPTOR\n                                sock = socket.socket()\n                                sock.connect(smbServer.getRegisteredNamedPipes()[str(pathName)])\n                            else:\n                                fid = os.open(pathName, mode)\n                    except Exception as e:\n                        smbServer.log(\"SMB2_CREATE: %s,%s,%s\" % (pathName, mode, e), logging.ERROR)\n                        # print e\n                        fid = 0\n                        errorCode = STATUS_ACCESS_DENIED\n        else:\n            errorCode = STATUS_SMB_BAD_TID\n\n        if errorCode == STATUS_SUCCESS:\n            # Simple way to generate a fid\n            fakefid = uuid.generate()\n\n            respSMBCommand['FileID'] = fakefid\n            respSMBCommand['CreateAction'] = createDisposition\n\n            if fid == PIPE_FILE_DESCRIPTOR:\n                respSMBCommand['CreationTime'] = 0\n                respSMBCommand['LastAccessTime'] = 0\n                respSMBCommand['LastWriteTime'] = 0\n                respSMBCommand['ChangeTime'] = 0\n                respSMBCommand['AllocationSize'] = 4096\n                respSMBCommand['EndOfFile'] = 0\n                respSMBCommand['FileAttributes'] = 0x80\n\n            else:\n                if os.path.isdir(pathName):\n                    respSMBCommand['FileAttributes'] = smb.SMB_FILE_ATTRIBUTE_DIRECTORY\n                else:\n                    respSMBCommand['FileAttributes'] = ntCreateRequest['FileAttributes']\n                # Let's get this file's information\n                respInfo, errorCode = queryPathInformation(path, fileName, level=smb.SMB_QUERY_FILE_ALL_INFO)\n                if errorCode == STATUS_SUCCESS:\n                    respSMBCommand['CreationTime'] = respInfo['CreationTime']\n                    respSMBCommand['LastAccessTime'] = respInfo['LastAccessTime']\n                    respSMBCommand['LastWriteTime'] = respInfo['LastWriteTime']\n                    respSMBCommand['LastChangeTime'] = respInfo['LastChangeTime']\n                    respSMBCommand['FileAttributes'] = respInfo['ExtFileAttributes']\n                    respSMBCommand['AllocationSize'] = respInfo['AllocationSize']\n                    respSMBCommand['EndOfFile'] = respInfo['EndOfFile']\n\n            if errorCode == STATUS_SUCCESS:\n                # Let's store the fid for the connection\n                # smbServer.log('Create file %s, mode:0x%x' % (pathName, mode))\n                connData['OpenedFiles'][fakefid] = {}\n                connData['OpenedFiles'][fakefid]['FileHandle'] = fid\n                connData['OpenedFiles'][fakefid]['FileName'] = pathName\n                connData['OpenedFiles'][fakefid]['DeleteOnClose'] = deleteOnClose\n                connData['OpenedFiles'][fakefid]['Open'] = {}\n                connData['OpenedFiles'][fakefid]['Open']['EnumerationLocation'] = 0\n                connData['OpenedFiles'][fakefid]['Open']['EnumerationSearchPattern'] = ''\n                if fid == PIPE_FILE_DESCRIPTOR:\n                    connData['OpenedFiles'][fakefid]['Socket'] = sock\n        else:\n            respSMBCommand = smb2.SMB2Error()\n\n        if errorCode == STATUS_SUCCESS:\n            connData['LastRequest']['SMB2_CREATE'] = respSMBCommand\n        smbServer.setConnectionData(connId, connData)\n\n        return [respSMBCommand], None, errorCode",
  "def smb2Close(connId, smbServer, recvPacket):\n        connData = smbServer.getConnectionData(connId)\n\n        respSMBCommand = smb2.SMB2Close_Response()\n\n        closeRequest = smb2.SMB2Close(recvPacket['Data'])\n\n        if closeRequest['FileID'].getData() == b'\\xff' * 16:\n            # Let's take the data from the lastRequest\n            if 'SMB2_CREATE' in connData['LastRequest']:\n                fileID = connData['LastRequest']['SMB2_CREATE']['FileID']\n            else:\n                fileID = closeRequest['FileID'].getData()\n        else:\n            fileID = closeRequest['FileID'].getData()\n\n        # Get the Tid associated\n        if recvPacket['TreeID'] in connData['ConnectedShares']:\n            if fileID in connData['OpenedFiles']:\n                errorCode = STATUS_SUCCESS\n                fileHandle = connData['OpenedFiles'][fileID]['FileHandle']\n                pathName = connData['OpenedFiles'][fileID]['FileName']\n                infoRecord = None\n                try:\n                    if fileHandle == PIPE_FILE_DESCRIPTOR:\n                        connData['OpenedFiles'][fileID]['Socket'].close()\n                    elif fileHandle != VOID_FILE_DESCRIPTOR:\n                        os.close(fileHandle)\n                        infoRecord, errorCode = queryFileInformation(os.path.dirname(pathName), os.path.basename(pathName),\n                                                                     smb2.SMB2_FILE_NETWORK_OPEN_INFO)\n                except Exception as e:\n                    smbServer.log(\"SMB2_CLOSE %s\" % e, logging.ERROR)\n                    errorCode = STATUS_INVALID_HANDLE\n                else:\n                    # Check if the file was marked for removal\n                    if connData['OpenedFiles'][fileID]['DeleteOnClose'] is True:\n                        try:\n                            if os.path.isdir(pathName):\n                                shutil.rmtree(connData['OpenedFiles'][fileID]['FileName'])\n                            else:\n                                os.remove(connData['OpenedFiles'][fileID]['FileName'])\n                        except Exception as e:\n                            smbServer.log(\"SMB2_CLOSE %s\" % e, logging.ERROR)\n                            errorCode = STATUS_ACCESS_DENIED\n\n                    # Now fill out the response\n                    if infoRecord is not None:\n                        respSMBCommand['CreationTime'] = infoRecord['CreationTime']\n                        respSMBCommand['LastAccessTime'] = infoRecord['LastAccessTime']\n                        respSMBCommand['LastWriteTime'] = infoRecord['LastWriteTime']\n                        respSMBCommand['ChangeTime'] = infoRecord['ChangeTime']\n                        respSMBCommand['AllocationSize'] = infoRecord['AllocationSize']\n                        respSMBCommand['EndofFile'] = infoRecord['EndOfFile']\n                        respSMBCommand['FileAttributes'] = infoRecord['FileAttributes']\n                    if errorCode == STATUS_SUCCESS:\n                        del (connData['OpenedFiles'][fileID])\n            else:\n                errorCode = STATUS_INVALID_HANDLE\n        else:\n            errorCode = STATUS_SMB_BAD_TID\n\n        smbServer.setConnectionData(connId, connData)\n        return [respSMBCommand], None, errorCode",
  "def smb2QueryInfo(connId, smbServer, recvPacket):\n        connData = smbServer.getConnectionData(connId)\n\n        respSMBCommand = smb2.SMB2QueryInfo_Response()\n\n        queryInfo = smb2.SMB2QueryInfo(recvPacket['Data'])\n\n        errorCode = STATUS_SUCCESS\n\n        respSMBCommand['OutputBufferOffset'] = 0x48\n        respSMBCommand['Buffer'] = b'\\x00'\n\n        if queryInfo['FileID'].getData() == b'\\xff' * 16:\n            # Let's take the data from the lastRequest\n            if 'SMB2_CREATE' in connData['LastRequest']:\n                fileID = connData['LastRequest']['SMB2_CREATE']['FileID']\n            else:\n                fileID = queryInfo['FileID'].getData()\n        else:\n            fileID = queryInfo['FileID'].getData()\n\n        # Get the Tid associated\n        if recvPacket['TreeID'] in connData['ConnectedShares']:\n            if fileID in connData['OpenedFiles']:\n                fileName = connData['OpenedFiles'][fileID]['FileName']\n\n                if queryInfo['InfoType'] == smb2.SMB2_0_INFO_FILE:\n                    if queryInfo['FileInfoClass'] == smb2.SMB2_FILE_INTERNAL_INFO:\n                        # No need to call queryFileInformation, we have the data here\n                        infoRecord = smb2.FILE_INTERNAL_INFORMATION()\n                        infoRecord['IndexNumber'] = fileID\n                    else:\n                        infoRecord, errorCode = queryFileInformation(os.path.dirname(fileName),\n                                                                     os.path.basename(fileName),\n                                                                     queryInfo['FileInfoClass'])\n                elif queryInfo['InfoType'] == smb2.SMB2_0_INFO_FILESYSTEM:\n                    if queryInfo['FileInfoClass'] == smb2.SMB2_FILE_EA_INFO:\n                        infoRecord = b'\\x00' * 4\n                    else:\n                        infoRecord = queryFsInformation(os.path.dirname(fileName), os.path.basename(fileName),\n                                                        queryInfo['FileInfoClass'])\n                elif queryInfo['InfoType'] == smb2.SMB2_0_INFO_SECURITY:\n                    # Failing for now, until we support it\n                    infoRecord = None\n                    errorCode = STATUS_ACCESS_DENIED\n                else:\n                    smbServer.log(\"queryInfo not supported (%x)\" % queryInfo['InfoType'], logging.ERROR)\n\n                if infoRecord is not None:\n                    respSMBCommand['OutputBufferLength'] = len(infoRecord)\n                    respSMBCommand['Buffer'] = infoRecord\n            else:\n                errorCode = STATUS_INVALID_HANDLE\n        else:\n            errorCode = STATUS_SMB_BAD_TID\n\n        smbServer.setConnectionData(connId, connData)\n        return [respSMBCommand], None, errorCode",
  "def smb2SetInfo(connId, smbServer, recvPacket):\n        connData = smbServer.getConnectionData(connId)\n\n        respSMBCommand = smb2.SMB2SetInfo_Response()\n\n        setInfo = smb2.SMB2SetInfo(recvPacket['Data'])\n\n        errorCode = STATUS_SUCCESS\n\n        if setInfo['FileID'].getData() == b'\\xff' * 16:\n            # Let's take the data from the lastRequest\n            if 'SMB2_CREATE' in connData['LastRequest']:\n                fileID = connData['LastRequest']['SMB2_CREATE']['FileID']\n            else:\n                fileID = setInfo['FileID'].getData()\n        else:\n            fileID = setInfo['FileID'].getData()\n\n        # Get the Tid associated\n        if recvPacket['TreeID'] in connData['ConnectedShares']:\n            path = connData['ConnectedShares'][recvPacket['TreeID']]['path']\n            if fileID in connData['OpenedFiles']:\n                pathName = connData['OpenedFiles'][fileID]['FileName']\n\n                if setInfo['InfoType'] == smb2.SMB2_0_INFO_FILE:\n                    # The file information is being set\n                    informationLevel = setInfo['FileInfoClass']\n                    if informationLevel == smb2.SMB2_FILE_DISPOSITION_INFO:\n                        infoRecord = smb.SMBSetFileDispositionInfo(setInfo['Buffer'])\n                        if infoRecord['DeletePending'] > 0:\n                            # Mark this file for removal after closed\n                            connData['OpenedFiles'][fileID]['DeleteOnClose'] = True\n                    elif informationLevel == smb2.SMB2_FILE_BASIC_INFO:\n                        infoRecord = smb.SMBSetFileBasicInfo(setInfo['Buffer'])\n                        # Creation time won't be set,  the other ones we play with.\n                        atime = infoRecord['LastWriteTime']\n                        if atime == 0:\n                            atime = -1\n                        else:\n                            atime = getUnixTime(atime)\n                        mtime = infoRecord['ChangeTime']\n                        if mtime == 0:\n                            mtime = -1\n                        else:\n                            mtime = getUnixTime(mtime)\n                        if atime > 0 and mtime > 0:\n                            os.utime(pathName, (atime, mtime))\n                    elif informationLevel == smb2.SMB2_FILE_END_OF_FILE_INFO:\n                        fileHandle = connData['OpenedFiles'][fileID]['FileHandle']\n                        infoRecord = smb.SMBSetFileEndOfFileInfo(setInfo['Buffer'])\n                        if infoRecord['EndOfFile'] > 0:\n                            os.lseek(fileHandle, infoRecord['EndOfFile'] - 1, 0)\n                            os.write(fileHandle, b'\\x00')\n                    elif informationLevel == smb2.SMB2_FILE_RENAME_INFO:\n                        renameInfo = smb2.FILE_RENAME_INFORMATION_TYPE_2(setInfo['Buffer'])\n                        newFileName = normalize_path(renameInfo['FileName'].decode('utf-16le'))\n                        newPathName = os.path.join(path, newFileName)\n                        if not isInFileJail(path, newFileName):\n                            smbServer.log(\"Path not in current working directory\", logging.ERROR)\n                            return [smb2.SMB2Error()], None, STATUS_OBJECT_PATH_SYNTAX_BAD\n\n                        if renameInfo['ReplaceIfExists'] == 0 and os.path.exists(newPathName):\n                            return [smb2.SMB2Error()], None, STATUS_OBJECT_NAME_COLLISION\n                        try:\n                            os.rename(pathName, newPathName)\n                            connData['OpenedFiles'][fileID]['FileName'] = newPathName\n                        except Exception as e:\n                            smbServer.log(\"smb2SetInfo: %s\" % e, logging.ERROR)\n                            errorCode = STATUS_ACCESS_DENIED\n                    elif informationLevel == smb2.SMB2_FILE_ALLOCATION_INFO:\n                        # See https://github.com/samba-team/samba/blob/master/source3/smbd/smb2_trans2.c#LL5201C8-L5201C39\n                        smbServer.log(\"Warning: SMB2_FILE_ALLOCATION_INFO not implemented\")\n                        errorCode = STATUS_SUCCESS\n                    else:\n                        smbServer.log('Unknown level for set file info! 0x%x' % informationLevel, logging.ERROR)\n                        # UNSUPPORTED\n                        errorCode = STATUS_NOT_SUPPORTED\n                # elif setInfo['InfoType'] == smb2.SMB2_0_INFO_FILESYSTEM:\n                #    # The underlying object store information is being set.\n                #    setInfo = queryFsInformation('/', fileName, queryInfo['FileInfoClass'])\n                # elif setInfo['InfoType'] == smb2.SMB2_0_INFO_SECURITY:\n                #    # The security information is being set.\n                #    # Failing for now, until we support it\n                #    infoRecord = None\n                #    errorCode = STATUS_ACCESS_DENIED\n                # elif setInfo['InfoType'] == smb2.SMB2_0_INFO_QUOTA:\n                #    # The underlying object store quota information is being set.\n                #    setInfo = queryFsInformation('/', fileName, queryInfo['FileInfoClass'])\n                else:\n                    smbServer.log(\"setInfo not supported (%x)\" % setInfo['InfoType'], logging.ERROR)\n\n            else:\n                errorCode = STATUS_INVALID_HANDLE\n        else:\n            errorCode = STATUS_SMB_BAD_TID\n\n        smbServer.setConnectionData(connId, connData)\n        return [respSMBCommand], None, errorCode",
  "def smb2Write(connId, smbServer, recvPacket):\n        connData = smbServer.getConnectionData(connId)\n\n        respSMBCommand = smb2.SMB2Write_Response()\n        writeRequest = smb2.SMB2Write(recvPacket['Data'])\n\n        respSMBCommand['Buffer'] = b'\\x00'\n\n        if writeRequest['FileID'].getData() == b'\\xff' * 16:\n            # Let's take the data from the lastRequest\n            if 'SMB2_CREATE' in connData['LastRequest']:\n                fileID = connData['LastRequest']['SMB2_CREATE']['FileID']\n            else:\n                fileID = writeRequest['FileID'].getData()\n        else:\n            fileID = writeRequest['FileID'].getData()\n\n        # Get the Tid associated\n        if recvPacket['TreeID'] in connData['ConnectedShares']:\n            if fileID in connData['OpenedFiles']:\n                fileHandle = connData['OpenedFiles'][fileID]['FileHandle']\n                errorCode = STATUS_SUCCESS\n                try:\n                    if fileHandle != PIPE_FILE_DESCRIPTOR:\n                        offset = writeRequest['Offset']\n                        # If we're trying to write past the file end we just skip the write call (Vista does this)\n                        if os.lseek(fileHandle, 0, 2) >= offset:\n                            os.lseek(fileHandle, offset, 0)\n                            os.write(fileHandle, writeRequest['Buffer'])\n                    else:\n                        sock = connData['OpenedFiles'][fileID]['Socket']\n                        sock.send(writeRequest['Buffer'])\n\n                    respSMBCommand['Count'] = writeRequest['Length']\n                    respSMBCommand['Remaining'] = 0xff\n                except Exception as e:\n                    smbServer.log('SMB2_WRITE: %s' % e, logging.ERROR)\n                    errorCode = STATUS_ACCESS_DENIED\n            else:\n                errorCode = STATUS_INVALID_HANDLE\n        else:\n            errorCode = STATUS_SMB_BAD_TID\n\n        smbServer.setConnectionData(connId, connData)\n        return [respSMBCommand], None, errorCode",
  "def smb2Read(connId, smbServer, recvPacket):\n        connData = smbServer.getConnectionData(connId)\n\n        respSMBCommand = smb2.SMB2Read_Response()\n        readRequest = smb2.SMB2Read(recvPacket['Data'])\n\n        respSMBCommand['Buffer'] = b'\\x00'\n\n        if readRequest['FileID'].getData() == b'\\xff' * 16:\n            # Let's take the data from the lastRequest\n            if 'SMB2_CREATE' in connData['LastRequest']:\n                fileID = connData['LastRequest']['SMB2_CREATE']['FileID']\n            else:\n                fileID = readRequest['FileID'].getData()\n        else:\n            fileID = readRequest['FileID'].getData()\n\n        # Get the Tid associated\n        if recvPacket['TreeID'] in connData['ConnectedShares']:\n            if fileID in connData['OpenedFiles']:\n                fileHandle = connData['OpenedFiles'][fileID]['FileHandle']\n                errorCode = 0\n                try:\n                    if fileHandle != PIPE_FILE_DESCRIPTOR:\n                        offset = readRequest['Offset']\n                        os.lseek(fileHandle, offset, 0)\n                        content = os.read(fileHandle, readRequest['Length'])\n                    else:\n                        sock = connData['OpenedFiles'][fileID]['Socket']\n                        content = sock.recv(readRequest['Length'])\n\n                    respSMBCommand['DataOffset'] = 0x50\n                    respSMBCommand['DataLength'] = len(content)\n                    respSMBCommand['DataRemaining'] = 0\n                    respSMBCommand['Buffer'] = content\n                except Exception as e:\n                    smbServer.log('SMB2_READ: %s ' % e, logging.ERROR)\n                    errorCode = STATUS_ACCESS_DENIED\n            else:\n                errorCode = STATUS_INVALID_HANDLE\n        else:\n            errorCode = STATUS_SMB_BAD_TID\n\n        smbServer.setConnectionData(connId, connData)\n        return [respSMBCommand], None, errorCode",
  "def smb2Flush(connId, smbServer, recvPacket):\n        connData = smbServer.getConnectionData(connId)\n\n        respSMBCommand = smb2.SMB2Flush_Response()\n        flushRequest = smb2.SMB2Flush(recvPacket['Data'])\n\n        # Get the Tid associated\n        if recvPacket['TreeID'] in connData['ConnectedShares']:\n            if flushRequest['FileID'].getData() in connData['OpenedFiles']:\n                fileHandle = connData['OpenedFiles'][flushRequest['FileID'].getData()]['FileHandle']\n                errorCode = STATUS_SUCCESS\n                try:\n                    os.fsync(fileHandle)\n                except Exception as e:\n                    smbServer.log(\"SMB2_FLUSH %s\" % e, logging.ERROR)\n                    errorCode = STATUS_ACCESS_DENIED\n            else:\n                errorCode = STATUS_INVALID_HANDLE\n        else:\n            errorCode = STATUS_SMB_BAD_TID\n\n        smbServer.setConnectionData(connId, connData)\n        return [respSMBCommand], None, errorCode",
  "def smb2QueryDirectory(connId, smbServer, recvPacket):\n        connData = smbServer.getConnectionData(connId)\n        respSMBCommand = smb2.SMB2QueryDirectory_Response()\n        queryDirectoryRequest = smb2.SMB2QueryDirectory(recvPacket['Data'])\n\n        respSMBCommand['Buffer'] = b'\\x00'\n\n        # The server MUST locate the tree connection, as specified in section 3.3.5.2.11.\n        if (recvPacket['TreeID'] in connData['ConnectedShares']) is False:\n            return [smb2.SMB2Error()], None, STATUS_NETWORK_NAME_DELETED\n\n        # Next, the server MUST locate the open for the directory to be queried\n        # If no open is found, the server MUST fail the request with STATUS_FILE_CLOSED\n        if queryDirectoryRequest['FileID'].getData() == b'\\xff' * 16:\n            # Let's take the data from the lastRequest\n            if 'SMB2_CREATE' in connData['LastRequest']:\n                fileID = connData['LastRequest']['SMB2_CREATE']['FileID']\n            else:\n                fileID = queryDirectoryRequest['FileID'].getData()\n        else:\n            fileID = queryDirectoryRequest['FileID'].getData()\n\n        if (fileID in connData['OpenedFiles']) is False:\n            return [smb2.SMB2Error()], None, STATUS_FILE_CLOSED\n\n        # If the open is not an open to a directory, the request MUST be failed\n        # with STATUS_INVALID_PARAMETER.\n        if os.path.isdir(connData['OpenedFiles'][fileID]['FileName']) is False:\n            return [smb2.SMB2Error()], None, STATUS_INVALID_PARAMETER\n\n        # If any other information class is specified in the FileInformationClass\n        # field of the SMB2 QUERY_DIRECTORY Request, the server MUST fail the\n        # operation with STATUS_INVALID_INFO_CLASS.\n        if queryDirectoryRequest['FileInformationClass'] not in (\n                smb2.FILE_DIRECTORY_INFORMATION, smb2.FILE_FULL_DIRECTORY_INFORMATION,\n                smb2.FILEID_FULL_DIRECTORY_INFORMATION,\n                smb2.FILE_BOTH_DIRECTORY_INFORMATION, smb2.FILEID_BOTH_DIRECTORY_INFORMATION,\n                smb2.FILENAMES_INFORMATION):\n            return [smb2.SMB2Error()], None, STATUS_INVALID_INFO_CLASS\n\n        # If SMB2_REOPEN is set in the Flags field of the SMB2 QUERY_DIRECTORY\n        # Request, the server SHOULD<326> set Open.EnumerationLocation to 0\n        # and Open.EnumerationSearchPattern to an empty string.\n        if queryDirectoryRequest['Flags'] & smb2.SMB2_REOPEN:\n            connData['OpenedFiles'][fileID]['Open']['EnumerationLocation'] = 0\n            connData['OpenedFiles'][fileID]['Open']['EnumerationSearchPattern'] = ''\n\n        # If SMB2_RESTART_SCANS is set in the Flags field of the SMB2\n        # QUERY_DIRECTORY Request, the server MUST set\n        # Open.EnumerationLocation to 0.\n        if queryDirectoryRequest['Flags'] & smb2.SMB2_RESTART_SCANS:\n            connData['OpenedFiles'][fileID]['Open']['EnumerationLocation'] = 0\n\n        # If Open.EnumerationLocation is 0 and Open.EnumerationSearchPattern\n        # is an empty string, then Open.EnumerationSearchPattern MUST be set\n        # to the search pattern specified in the SMB2 QUERY_DIRECTORY by\n        # FileNameOffset and FileNameLength. If FileNameLength is 0, the server\n        # SHOULD<327> set Open.EnumerationSearchPattern as \"*\" to search all entries.\n\n        pattern = queryDirectoryRequest['Buffer'].decode('utf-16le')\n        if connData['OpenedFiles'][fileID]['Open']['EnumerationLocation'] == 0 and \\\n                connData['OpenedFiles'][fileID]['Open']['EnumerationSearchPattern'] == '':\n            if pattern == '':\n                pattern = '*'\n            connData['OpenedFiles'][fileID]['Open']['EnumerationSearchPattern'] = pattern\n\n        # If SMB2_INDEX_SPECIFIED is set and FileNameLength is not zero,\n        # the server MUST set Open.EnumerationSearchPattern to the search pattern\n        # specified in the request by FileNameOffset and FileNameLength.\n        if queryDirectoryRequest['Flags'] & smb2.SMB2_INDEX_SPECIFIED and \\\n                queryDirectoryRequest['FileNameLength'] > 0:\n            connData['OpenedFiles'][fileID]['Open']['EnumerationSearchPattern'] = pattern\n\n        pathName = os.path.join(os.path.normpath(connData['OpenedFiles'][fileID]['FileName']), pattern)\n        searchResult, searchCount, errorCode = findFirst2(os.path.dirname(pathName),\n                                                          os.path.basename(pathName),\n                                                          queryDirectoryRequest['FileInformationClass'],\n                                                          smb.ATTR_DIRECTORY, isSMB2=True)\n\n        if errorCode != STATUS_SUCCESS:\n            return [smb2.SMB2Error()], None, errorCode\n\n        if searchCount > 2 and pattern == '*':\n            # strip . and ..\n            searchCount -= 2\n            searchResult = searchResult[2:]\n\n        if searchCount == 0 and connData['OpenedFiles'][fileID]['Open']['EnumerationLocation'] == 0:\n            return [smb2.SMB2Error()], None, STATUS_NO_SUCH_FILE\n\n        if connData['OpenedFiles'][fileID]['Open']['EnumerationLocation'] < 0:\n            return [smb2.SMB2Error()], None, STATUS_NO_MORE_FILES\n\n        totalData = 0\n        respData = b''\n        for nItem in range(connData['OpenedFiles'][fileID]['Open']['EnumerationLocation'], searchCount):\n            connData['OpenedFiles'][fileID]['Open']['EnumerationLocation'] += 1\n            if queryDirectoryRequest['Flags'] & smb2.SL_RETURN_SINGLE_ENTRY:\n                # If single entry is requested we must clear the NextEntryOffset\n                searchResult[nItem]['NextEntryOffset'] = 0\n            data = searchResult[nItem].getData()\n            lenData = len(data)\n            padLen = (8 - (lenData % 8)) % 8\n\n            if (totalData + lenData) >= queryDirectoryRequest['OutputBufferLength']:\n                connData['OpenedFiles'][fileID]['Open']['EnumerationLocation'] -= 1\n                break\n            else:\n                respData += data + b'\\x00' * padLen\n                totalData += lenData + padLen\n\n            if queryDirectoryRequest['Flags'] & smb2.SL_RETURN_SINGLE_ENTRY:\n                break\n\n        if connData['OpenedFiles'][fileID]['Open']['EnumerationLocation'] >= searchCount:\n            connData['OpenedFiles'][fileID]['Open']['EnumerationLocation'] = -1\n\n        respSMBCommand['OutputBufferOffset'] = 0x48\n        respSMBCommand['OutputBufferLength'] = totalData\n        respSMBCommand['Buffer'] = respData\n\n        smbServer.setConnectionData(connId, connData)\n        return [respSMBCommand], None, errorCode",
  "def smb2ChangeNotify(connId, smbServer, recvPacket):\n\n        return [smb2.SMB2Error()], None, STATUS_NOT_SUPPORTED",
  "def smb2Echo(connId, smbServer, recvPacket):\n\n        respSMBCommand = smb2.SMB2Echo_Response()\n\n        return [respSMBCommand], None, STATUS_SUCCESS",
  "def smb2TreeDisconnect(connId, smbServer, recvPacket):\n        connData = smbServer.getConnectionData(connId)\n\n        respSMBCommand = smb2.SMB2TreeDisconnect_Response()\n\n        # Get the Tid associated\n        if recvPacket['TreeID'] in connData['ConnectedShares']:\n            smbServer.log(\"Disconnecting Share(%d:%s)\" % (\n                recvPacket['TreeID'], connData['ConnectedShares'][recvPacket['TreeID']]['shareName']))\n            del (connData['ConnectedShares'][recvPacket['TreeID']])\n            errorCode = STATUS_SUCCESS\n        else:\n            errorCode = STATUS_SMB_BAD_TID\n\n        smbServer.setConnectionData(connId, connData)\n        return [respSMBCommand], None, errorCode",
  "def smb2Logoff(connId, smbServer, recvPacket):\n        connData = smbServer.getConnectionData(connId)\n\n        respSMBCommand = smb2.SMB2Logoff_Response()\n\n        if recvPacket['SessionID'] != connData['Uid']:\n            # STATUS_SMB_BAD_UID\n            errorCode = STATUS_SMB_BAD_UID\n        else:\n            errorCode = STATUS_SUCCESS\n\n        connData['Uid'] = 0\n        connData['Authenticated'] = False\n\n        smbServer.setConnectionData(connId, connData)\n        return [respSMBCommand], None, errorCode",
  "def smb2Ioctl(connId, smbServer, recvPacket):\n        connData = smbServer.getConnectionData(connId)\n\n        respSMBCommand = smb2.SMB2Ioctl_Response()\n        ioctlRequest = smb2.SMB2Ioctl(recvPacket['Data'])\n\n        ioctls = smbServer.getIoctls()\n        if ioctlRequest['CtlCode'] in ioctls:\n            outputData, errorCode = ioctls[ioctlRequest['CtlCode']](connId, smbServer, ioctlRequest)\n            if errorCode == STATUS_SUCCESS:\n                respSMBCommand['CtlCode'] = ioctlRequest['CtlCode']\n                respSMBCommand['FileID'] = ioctlRequest['FileID']\n                respSMBCommand['InputOffset'] = 0\n                respSMBCommand['InputCount'] = 0\n                respSMBCommand['OutputOffset'] = 0x70\n                respSMBCommand['OutputCount'] = len(outputData)\n                respSMBCommand['Flags'] = 0\n                respSMBCommand['Buffer'] = outputData\n            else:\n                respSMBCommand = outputData\n        else:\n            smbServer.log(\"Ioctl not implemented command: 0x%x\" % ioctlRequest['CtlCode'], logging.DEBUG)\n            errorCode = STATUS_INVALID_DEVICE_REQUEST\n            respSMBCommand = smb2.SMB2Error()\n\n        smbServer.setConnectionData(connId, connData)\n        return [respSMBCommand], None, errorCode",
  "def smb2Lock(connId, smbServer, recvPacket):\n        connData = smbServer.getConnectionData(connId)\n\n        respSMBCommand = smb2.SMB2Lock_Response()\n\n        # I'm actually doing nothing.. just make MacOS happy ;)\n        errorCode = STATUS_SUCCESS\n\n        smbServer.setConnectionData(connId, connData)\n        return [respSMBCommand], None, errorCode",
  "def smb2Cancel(connId, smbServer, recvPacket):\n        # I'm actually doing nothing\n        return [smb2.SMB2Error()], None, STATUS_CANCELLED",
  "def default(connId, smbServer, recvPacket):\n        # By default we return an SMB Packet with error not implemented\n        smbServer.log(\"Not implemented command: 0x%x\" % recvPacket['Command'], logging.DEBUG)\n        return [smb2.SMB2Error()], None, STATUS_NOT_SUPPORTED",
  "def fsctlDfsGetReferrals(connId, smbServer, ioctlRequest):\n        return smb2.SMB2Error(), STATUS_FS_DRIVER_REQUIRED",
  "def fsctlPipeTransceive(connId, smbServer, ioctlRequest):\n        connData = smbServer.getConnectionData(connId)\n\n        ioctlResponse = ''\n\n        if ioctlRequest['FileID'].getData() in connData['OpenedFiles']:\n            fileHandle = connData['OpenedFiles'][ioctlRequest['FileID'].getData()]['FileHandle']\n            errorCode = STATUS_SUCCESS\n            try:\n                if fileHandle != PIPE_FILE_DESCRIPTOR:\n                    errorCode = STATUS_INVALID_DEVICE_REQUEST\n                else:\n                    sock = connData['OpenedFiles'][ioctlRequest['FileID'].getData()]['Socket']\n                    sock.sendall(ioctlRequest['Buffer'])\n                    ioctlResponse = sock.recv(ioctlRequest['MaxOutputResponse'])\n            except Exception as e:\n                smbServer.log('fsctlPipeTransceive: %s ' % e, logging.ERROR)\n                errorCode = STATUS_ACCESS_DENIED\n        else:\n            errorCode = STATUS_INVALID_DEVICE_REQUEST\n\n        smbServer.setConnectionData(connId, connData)\n        return ioctlResponse, errorCode",
  "def fsctlValidateNegotiateInfo(connId, smbServer, ioctlRequest):\n        connData = smbServer.getConnectionData(connId)\n\n        errorCode = STATUS_SUCCESS\n\n        validateNegotiateInfo = smb2.VALIDATE_NEGOTIATE_INFO(ioctlRequest['Buffer'])\n        validateNegotiateInfoResponse = smb2.VALIDATE_NEGOTIATE_INFO_RESPONSE()\n        validateNegotiateInfoResponse['Capabilities'] = 0\n        validateNegotiateInfoResponse['Guid'] = b'A' * 16\n        validateNegotiateInfoResponse['SecurityMode'] = 1\n        validateNegotiateInfoResponse['Dialect'] = smb2.SMB2_DIALECT_002\n\n        smbServer.setConnectionData(connId, connData)\n        return validateNegotiateInfoResponse.getData(), errorCode",
  "def __init__(self, request, client_address, server, select_poll=False):\n        self.__SMB = server\n        # In case of AF_INET6 the client_address contains 4 items, ignore the last 2\n        self.__ip, self.__port = client_address[:2]\n        self.__request = request\n        self.__connId = threading.current_thread().name\n        self.__timeOut = 60 * 5\n        self.__select_poll = select_poll\n        # self.__connId = os.getpid()\n        socketserver.BaseRequestHandler.__init__(self, request, client_address, server)",
  "def handle(self):\n        self.__SMB.log(\"Incoming connection (%s,%d)\" % (self.__ip, self.__port))\n        self.__SMB.addConnection(self.__connId, self.__ip, self.__port)\n        while True:\n            try:\n                # First of all let's get the NETBIOS packet\n                session = nmb.NetBIOSTCPSession(self.__SMB.getServerName(), 'HOST', self.__ip, sess_port=self.__port,\n                                                sock=self.__request, select_poll=self.__select_poll)\n                try:\n                    p = session.recv_packet(self.__timeOut)\n                except nmb.NetBIOSTimeout:\n                    raise\n                except nmb.NetBIOSError:\n                    break\n\n                if p.get_type() == nmb.NETBIOS_SESSION_REQUEST:\n                    # Someone is requesting a session, we're gonna accept them all :)\n                    _, rn, my = p.get_trailer().split(b' ')\n                    remote_name = nmb.decode_name(b'\\x20' + rn)\n                    myname = nmb.decode_name(b'\\x20' + my)\n                    self.__SMB.log(\n                        \"NetBIOS Session request (%s,%s,%s)\" % (self.__ip, remote_name[1].strip(), myname[1]))\n                    r = nmb.NetBIOSSessionPacket()\n                    r.set_type(nmb.NETBIOS_SESSION_POSITIVE_RESPONSE)\n                    r.set_trailer(p.get_trailer())\n                    self.__request.send(r.rawData())\n                else:\n                    resp = self.__SMB.processRequest(self.__connId, p.get_trailer())\n                    # Send all the packets received. Except for big transactions this should be\n                    # a single packet\n                    for i in resp:\n                        if hasattr(i, 'getData'):\n                            session.send_packet(i.getData())\n                        else:\n                            session.send_packet(i)\n            except Exception as e:\n                self.__SMB.log(\"Handle: %s\" % e)\n                # import traceback\n                # traceback.print_exc()\n                break",
  "def finish(self):\n        # Thread/process is dying, we should tell the main SMB thread to remove all this thread data\n        self.__SMB.log(\"Closing down connection (%s,%d)\" % (self.__ip, self.__port))\n        self.__SMB.removeConnection(self.__connId)\n        return socketserver.BaseRequestHandler.finish(self)",
  "def __init__(self, server_address, handler_class=SMBSERVERHandler, config_parser=None):\n        socketserver.TCPServer.allow_reuse_address = True\n        socketserver.TCPServer.__init__(self, server_address, handler_class)\n\n        # Server name and OS to be presented whenever is necessary\n        self.__serverName = ''\n        self.__serverOS = ''\n        self.__serverDomain = ''\n        self.__challenge = ''\n        self.__log = None\n\n        # Our ConfigParser data\n        self.__serverConfig = config_parser\n\n        # Our credentials to be used during the server's lifetime\n        self.__credentials = {}\n\n        # Our log file\n        self.__logFile = ''\n\n        # Registered Named Pipes, format is PipeName,Socket\n        self.__registeredNamedPipes = {}\n\n        # JTR dump path\n        self.__jtr_dump_path = ''\n\n        # SMB2 Support flag = default not active\n        self.__SMB2Support = False\n\n        # Allow anonymous logon\n        self.__anonymousLogon = True\n\n        self.auth_callback = None\n\n        # Our list of commands we will answer, by default the NOT IMPLEMENTED one\n        self.__smbCommandsHandler = SMBCommands()\n        self.__smbTrans2Handler = TRANS2Commands()\n        self.__smbTransHandler = TRANSCommands()\n        self.__smbNTTransHandler = NTTRANSCommands()\n        self.__smb2CommandsHandler = SMB2Commands()\n        self.__IoctlHandler = Ioctls()\n\n        self.__smbNTTransCommands = {\n            # NT IOCTL, can't find doc for this\n            0xff: self.__smbNTTransHandler.default\n        }\n\n        self.__smbTransCommands = {\n            '\\\\PIPE\\\\LANMAN': self.__smbTransHandler.lanMan,\n            smb.SMB.TRANS_TRANSACT_NMPIPE: self.__smbTransHandler.transactNamedPipe,\n        }\n        self.__smbTrans2Commands = {\n            smb.SMB.TRANS2_FIND_FIRST2: self.__smbTrans2Handler.findFirst2,\n            smb.SMB.TRANS2_FIND_NEXT2: self.__smbTrans2Handler.findNext2,\n            smb.SMB.TRANS2_QUERY_FS_INFORMATION: self.__smbTrans2Handler.queryFsInformation,\n            smb.SMB.TRANS2_QUERY_PATH_INFORMATION: self.__smbTrans2Handler.queryPathInformation,\n            smb.SMB.TRANS2_QUERY_FILE_INFORMATION: self.__smbTrans2Handler.queryFileInformation,\n            smb.SMB.TRANS2_SET_FILE_INFORMATION: self.__smbTrans2Handler.setFileInformation,\n            smb.SMB.TRANS2_SET_PATH_INFORMATION: self.__smbTrans2Handler.setPathInformation\n        }\n\n        self.__smbCommands = {\n            smb.SMB.SMB_COM_FLUSH: self.__smbCommandsHandler.smbComFlush,\n            smb.SMB.SMB_COM_CREATE_DIRECTORY: self.__smbCommandsHandler.smbComCreateDirectory,\n            smb.SMB.SMB_COM_DELETE_DIRECTORY: self.__smbCommandsHandler.smbComDeleteDirectory,\n            smb.SMB.SMB_COM_RENAME: self.__smbCommandsHandler.smbComRename,\n            smb.SMB.SMB_COM_DELETE: self.__smbCommandsHandler.smbComDelete,\n            smb.SMB.SMB_COM_NEGOTIATE: self.__smbCommandsHandler.smbComNegotiate,\n            smb.SMB.SMB_COM_SESSION_SETUP_ANDX: self.__smbCommandsHandler.smbComSessionSetupAndX,\n            smb.SMB.SMB_COM_LOGOFF_ANDX: self.__smbCommandsHandler.smbComLogOffAndX,\n            smb.SMB.SMB_COM_TREE_CONNECT_ANDX: self.__smbCommandsHandler.smbComTreeConnectAndX,\n            smb.SMB.SMB_COM_TREE_DISCONNECT: self.__smbCommandsHandler.smbComTreeDisconnect,\n            smb.SMB.SMB_COM_ECHO: self.__smbCommandsHandler.smbComEcho,\n            smb.SMB.SMB_COM_QUERY_INFORMATION: self.__smbCommandsHandler.smbQueryInformation,\n            smb.SMB.SMB_COM_TRANSACTION2: self.__smbCommandsHandler.smbTransaction2,\n            smb.SMB.SMB_COM_TRANSACTION: self.__smbCommandsHandler.smbTransaction,\n            # Not needed for now\n            smb.SMB.SMB_COM_NT_TRANSACT: self.__smbCommandsHandler.smbNTTransact,\n            smb.SMB.SMB_COM_QUERY_INFORMATION_DISK: self.__smbCommandsHandler.smbQueryInformationDisk,\n            smb.SMB.SMB_COM_OPEN_ANDX: self.__smbCommandsHandler.smbComOpenAndX,\n            smb.SMB.SMB_COM_QUERY_INFORMATION2: self.__smbCommandsHandler.smbComQueryInformation2,\n            smb.SMB.SMB_COM_READ_ANDX: self.__smbCommandsHandler.smbComReadAndX,\n            smb.SMB.SMB_COM_READ: self.__smbCommandsHandler.smbComRead,\n            smb.SMB.SMB_COM_WRITE_ANDX: self.__smbCommandsHandler.smbComWriteAndX,\n            smb.SMB.SMB_COM_WRITE: self.__smbCommandsHandler.smbComWrite,\n            smb.SMB.SMB_COM_CLOSE: self.__smbCommandsHandler.smbComClose,\n            smb.SMB.SMB_COM_LOCKING_ANDX: self.__smbCommandsHandler.smbComLockingAndX,\n            smb.SMB.SMB_COM_NT_CREATE_ANDX: self.__smbCommandsHandler.smbComNtCreateAndX,\n            0xFF: self.__smbCommandsHandler.default\n        }\n\n        self.__smb2Ioctls = {\n            smb2.FSCTL_DFS_GET_REFERRALS: self.__IoctlHandler.fsctlDfsGetReferrals,\n            # smb2.FSCTL_PIPE_PEEK:                    self.__IoctlHandler.fsctlPipePeek,\n            # smb2.FSCTL_PIPE_WAIT:                    self.__IoctlHandler.fsctlPipeWait,\n            smb2.FSCTL_PIPE_TRANSCEIVE: self.__IoctlHandler.fsctlPipeTransceive,\n            # smb2.FSCTL_SRV_COPYCHUNK:                self.__IoctlHandler.fsctlSrvCopyChunk,\n            # smb2.FSCTL_SRV_ENUMERATE_SNAPSHOTS:      self.__IoctlHandler.fsctlSrvEnumerateSnapshots,\n            # smb2.FSCTL_SRV_REQUEST_RESUME_KEY:       self.__IoctlHandler.fsctlSrvRequestResumeKey,\n            # smb2.FSCTL_SRV_READ_HASH:                self.__IoctlHandler.fsctlSrvReadHash,\n            # smb2.FSCTL_SRV_COPYCHUNK_WRITE:          self.__IoctlHandler.fsctlSrvCopyChunkWrite,\n            # smb2.FSCTL_LMR_REQUEST_RESILIENCY:       self.__IoctlHandler.fsctlLmrRequestResiliency,\n            # smb2.FSCTL_QUERY_NETWORK_INTERFACE_INFO: self.__IoctlHandler.fsctlQueryNetworkInterfaceInfo,\n            # smb2.FSCTL_SET_REPARSE_POINT:            self.__IoctlHandler.fsctlSetReparsePoint,\n            # smb2.FSCTL_DFS_GET_REFERRALS_EX:         self.__IoctlHandler.fsctlDfsGetReferralsEx,\n            # smb2.FSCTL_FILE_LEVEL_TRIM:              self.__IoctlHandler.fsctlFileLevelTrim,\n            smb2.FSCTL_VALIDATE_NEGOTIATE_INFO: self.__IoctlHandler.fsctlValidateNegotiateInfo,\n        }\n\n        self.__smb2Commands = {\n            smb2.SMB2_NEGOTIATE: self.__smb2CommandsHandler.smb2Negotiate,\n            smb2.SMB2_SESSION_SETUP: self.__smb2CommandsHandler.smb2SessionSetup,\n            smb2.SMB2_LOGOFF: self.__smb2CommandsHandler.smb2Logoff,\n            smb2.SMB2_TREE_CONNECT: self.__smb2CommandsHandler.smb2TreeConnect,\n            smb2.SMB2_TREE_DISCONNECT: self.__smb2CommandsHandler.smb2TreeDisconnect,\n            smb2.SMB2_CREATE: self.__smb2CommandsHandler.smb2Create,\n            smb2.SMB2_CLOSE: self.__smb2CommandsHandler.smb2Close,\n            smb2.SMB2_FLUSH: self.__smb2CommandsHandler.smb2Flush,\n            smb2.SMB2_READ: self.__smb2CommandsHandler.smb2Read,\n            smb2.SMB2_WRITE: self.__smb2CommandsHandler.smb2Write,\n            smb2.SMB2_LOCK: self.__smb2CommandsHandler.smb2Lock,\n            smb2.SMB2_IOCTL: self.__smb2CommandsHandler.smb2Ioctl,\n            smb2.SMB2_CANCEL: self.__smb2CommandsHandler.smb2Cancel,\n            smb2.SMB2_ECHO: self.__smb2CommandsHandler.smb2Echo,\n            smb2.SMB2_QUERY_DIRECTORY: self.__smb2CommandsHandler.smb2QueryDirectory,\n            smb2.SMB2_CHANGE_NOTIFY: self.__smb2CommandsHandler.smb2ChangeNotify,\n            smb2.SMB2_QUERY_INFO: self.__smb2CommandsHandler.smb2QueryInfo,\n            smb2.SMB2_SET_INFO: self.__smb2CommandsHandler.smb2SetInfo,\n            # smb2.SMB2_OPLOCK_BREAK:    self.__smb2CommandsHandler.smb2SessionSetup,\n            0xFF: self.__smb2CommandsHandler.default\n        }\n\n        # List of active connections\n        self.__activeConnections = {}",
  "def getIoctls(self):\n        return self.__smb2Ioctls",
  "def getCredentials(self):\n        return self.__credentials",
  "def removeConnection(self, name):\n        try:\n            del (self.__activeConnections[name])\n        except:\n            pass\n        self.log(\"Remaining connections %s\" % list(self.__activeConnections.keys()))",
  "def addConnection(self, name, ip, port):\n        self.__activeConnections[name] = {}\n        # Let's init with some know stuff we will need to have\n        # TODO: Document what's in there\n        # print \"Current Connections\", self.__activeConnections.keys()\n        self.__activeConnections[name]['PacketNum'] = 0\n        self.__activeConnections[name]['ClientIP'] = ip\n        self.__activeConnections[name]['ClientPort'] = port\n        self.__activeConnections[name]['Uid'] = 0\n        self.__activeConnections[name]['ConnectedShares'] = {}\n        self.__activeConnections[name]['OpenedFiles'] = {}\n        # SID results for findfirst2\n        self.__activeConnections[name]['SIDs'] = {}\n        self.__activeConnections[name]['LastRequest'] = {}\n        self.__activeConnections[name]['SignatureEnabled'] = False\n        self.__activeConnections[name]['SigningChallengeResponse'] = ''\n        self.__activeConnections[name]['SigningSessionKey'] = b''\n        self.__activeConnections[name]['Authenticated'] = False",
  "def getActiveConnections(self):\n        return self.__activeConnections",
  "def setConnectionData(self, connId, data):\n        self.__activeConnections[connId] = data",
  "def getConnectionData(self, connId, checkStatus=True):\n        conn = self.__activeConnections[connId]\n        if checkStatus is True:\n            if ('Authenticated' in conn) is not True:\n                # Can't keep going further\n                raise Exception(\"User not Authenticated!\")\n        return conn",
  "def getRegisteredNamedPipes(self):\n        return self.__registeredNamedPipes",
  "def registerNamedPipe(self, pipeName, address):\n        self.__registeredNamedPipes[str(pipeName)] = address\n        return True",
  "def unregisterNamedPipe(self, pipeName):\n        if pipeName in self.__registeredNamedPipes:\n            del (self.__registeredNamedPipes[str(pipeName)])\n            return True\n        return False",
  "def unregisterTransaction(self, transCommand):\n        if transCommand in self.__smbTransCommands:\n            del (self.__smbTransCommands[transCommand])",
  "def hookTransaction(self, transCommand, callback):\n        # If you call this function, callback will replace\n        # the current Transaction sub command.\n        # (don't get confused with the Transaction smbCommand)\n        # If the transaction sub command doesn't not exist, it is added\n        # If the transaction sub command exists, it returns the original function         # replaced\n        #\n        # callback MUST be declared as:\n        # callback(connId, smbServer, recvPacket, parameters, data, maxDataCount=0)\n        #\n        # WHERE:\n        #\n        # connId      : the connection Id, used to grab/update information about\n        #               the current connection\n        # smbServer   : the SMBServer instance available for you to ask\n        #               configuration data\n        # recvPacket  : the full SMBPacket that triggered this command\n        # parameters  : the transaction parameters\n        # data        : the transaction data\n        # maxDataCount: the max amount of data that can be transferred agreed\n        #               with the client\n        #\n        # and MUST return:\n        # respSetup, respParameters, respData, errorCode\n        #\n        # WHERE:\n        #\n        # respSetup: the setup response of the transaction\n        # respParameters: the parameters response of the transaction\n        # respData: the data response of the transaction\n        # errorCode: the NT error code\n\n        if transCommand in self.__smbTransCommands:\n            originalCommand = self.__smbTransCommands[transCommand]\n        else:\n            originalCommand = None\n\n        self.__smbTransCommands[transCommand] = callback\n        return originalCommand",
  "def unregisterTransaction2(self, transCommand):\n        if transCommand in self.__smbTrans2Commands:\n            del (self.__smbTrans2Commands[transCommand])",
  "def hookTransaction2(self, transCommand, callback):\n        # Here we should add to __smbTrans2Commands\n        # Same description as Transaction\n        if transCommand in self.__smbTrans2Commands:\n            originalCommand = self.__smbTrans2Commands[transCommand]\n        else:\n            originalCommand = None\n\n        self.__smbTrans2Commands[transCommand] = callback\n        return originalCommand",
  "def unregisterNTTransaction(self, transCommand):\n        if transCommand in self.__smbNTTransCommands:\n            del (self.__smbNTTransCommands[transCommand])",
  "def hookNTTransaction(self, transCommand, callback):\n        # Here we should add to __smbNTTransCommands\n        # Same description as Transaction\n        if transCommand in self.__smbNTTransCommands:\n            originalCommand = self.__smbNTTransCommands[transCommand]\n        else:\n            originalCommand = None\n\n        self.__smbNTTransCommands[transCommand] = callback\n        return originalCommand",
  "def unregisterSmbCommand(self, smbCommand):\n        if smbCommand in self.__smbCommands:\n            del (self.__smbCommands[smbCommand])",
  "def hookSmbCommand(self, smbCommand, callback):\n        # Here we should add to self.__smbCommands\n        # If you call this function, callback will replace\n        # the current smbCommand.\n        # If smbCommand doesn't not exist, it is added\n        # If SMB command exists, it returns the original function replaced\n        #\n        # callback MUST be declared as:\n        # callback(connId, smbServer, SMBCommand, recvPacket)\n        #\n        # WHERE:\n        #\n        # connId    : the connection Id, used to grab/update information about\n        #             the current connection\n        # smbServer : the SMBServer instance available for you to ask\n        #             configuration data\n        # SMBCommand: the SMBCommand itself, with its data and parameters.\n        #             Check smb.py:SMBCommand() for a reference\n        # recvPacket: the full SMBPacket that triggered this command\n        #\n        # and MUST return:\n        # <list of respSMBCommands>, <list of packets>, errorCode\n        # <list of packets> has higher preference over commands, in case you\n        # want to change the whole packet\n        # errorCode: the NT error code\n        #\n        # For SMB_COM_TRANSACTION2, SMB_COM_TRANSACTION and SMB_COM_NT_TRANSACT\n        # the callback function is slightly different:\n        #\n        # callback(connId, smbServer, SMBCommand, recvPacket, transCommands)\n        #\n        # WHERE:\n        #\n        # transCommands: a list of transaction subcommands already registered\n        #\n\n        if smbCommand in self.__smbCommands:\n            originalCommand = self.__smbCommands[smbCommand]\n        else:\n            originalCommand = None\n\n        self.__smbCommands[smbCommand] = callback\n        return originalCommand",
  "def unregisterSmb2Command(self, smb2Command):\n        if smb2Command in self.__smb2Commands:\n            del (self.__smb2Commands[smb2Command])",
  "def hookSmb2Command(self, smb2Command, callback):\n        if smb2Command in self.__smb2Commands:\n            originalCommand = self.__smb2Commands[smb2Command]\n        else:\n            originalCommand = None\n\n        self.__smb2Commands[smb2Command] = callback\n        return originalCommand",
  "def log(self, msg, level=logging.INFO):\n        self.__log.log(level, msg)",
  "def getServerName(self):\n        return self.__serverName",
  "def getServerOS(self):\n        return self.__serverOS",
  "def getServerDomain(self):\n        return self.__serverDomain",
  "def getSMBChallenge(self):\n        return self.__challenge",
  "def getServerConfig(self):\n        return self.__serverConfig",
  "def setServerConfig(self, config):\n        self.__serverConfig = config",
  "def getJTRdumpPath(self):\n        return self.__jtr_dump_path",
  "def getAuthCallback(self):\n        return self.auth_callback",
  "def setAuthCallback(self, callback):\n        self.auth_callback = callback",
  "def verify_request(self, request, client_address):\n        # TODO: Control here the max amount of processes we want to launch\n        # returning False, closes the connection\n        return True",
  "def signSMBv1(self, connData, packet, signingSessionKey, signingChallengeResponse):\n        # This logic MUST be applied for messages sent in response to any of the higher-layer actions and in\n        # compliance with the message sequencing rules.\n        #  * The client or server that sends the message MUST provide the 32-bit sequence number for this\n        #    message, as specified in sections 3.2.4.1 and 3.3.4.1.\n        #  * The SMB_FLAGS2_SMB_SECURITY_SIGNATURE flag in the header MUST be set.\n        #  * To generate the signature, a 32-bit sequence number is copied into the\n        #    least significant 32 bits of the SecuritySignature field and the remaining\n        #    4 bytes are set to 0x00.\n        #  * The MD5 algorithm, as specified in [RFC1321], MUST be used to generate a hash of the SMB\n        #    message from the start of the SMB Header, which is defined as follows.\n        #    CALL MD5Init( md5context )\n        #    CALL MD5Update( md5context, Connection.SigningSessionKey )\n        #    CALL MD5Update( md5context, Connection.SigningChallengeResponse )\n        #    CALL MD5Update( md5context, SMB message )\n        #    CALL MD5Final( digest, md5context )\n        #    SET signature TO the first 8 bytes of the digest\n        # The resulting 8-byte signature MUST be copied into the SecuritySignature field of the SMB Header,\n        # after which the message can be transmitted.\n\n        # print \"seq(%d) signingSessionKey %r, signingChallengeResponse %r\" % (connData['SignSequenceNumber'], signingSessionKey, signingChallengeResponse)\n        packet['SecurityFeatures'] = struct.pack('<q', connData['SignSequenceNumber'])\n        # Sign with the sequence\n        m = hashlib.md5()\n        m.update(signingSessionKey)\n        m.update(signingChallengeResponse)\n        if hasattr(packet, 'getData'):\n            m.update(packet.getData())\n        else:\n            m.update(packet)\n        # Replace sequence with acual hash\n        packet['SecurityFeatures'] = m.digest()[:8]\n        connData['SignSequenceNumber'] += 2",
  "def signSMBv2(self, packet, signingSessionKey):\n        packet['Signature'] = b'\\x00' * 16\n        packet['Flags'] |= smb2.SMB2_FLAGS_SIGNED\n        signature = hmac.new(signingSessionKey, packet.getData(), hashlib.sha256).digest()\n        packet['Signature'] = signature[:16]",
  "def processRequest(self, connId, data):\n\n        # TODO: Process batched commands.\n        isSMB2 = False\n        SMBCommand = None\n        try:\n            packet = smb.NewSMBPacket(data=data)\n            SMBCommand = smb.SMBCommand(packet['Data'][0])\n        except:\n            # Maybe a SMB2 packet?\n            packet = smb2.SMB2Packet(data=data)\n            connData = self.getConnectionData(connId, False)\n            self.signSMBv2(packet, connData['SigningSessionKey'])\n            isSMB2 = True\n\n        connData = self.getConnectionData(connId, False)\n\n        # We might have compound requests\n        compoundedPacketsResponse = []\n        compoundedPackets = []\n        try:\n            # Search out list of implemented commands\n            # We provide them with:\n            # connId      : representing the data for this specific connection\n            # self        : the SMBSERVER if they want to ask data to it\n            # SMBCommand  : the SMBCommand they are expecting to process\n            # packet      : the received packet itself, in case they need more data than the actual command\n            # Only for Transactions\n            # transCommand: a list of transaction subcommands\n            # We expect to get:\n            # respCommands: a list of answers for the commands processed\n            # respPacket  : if the commands chose to directly craft packet/s, we use this and not the previous\n            #               this MUST be a list\n            # errorCode   : self explanatory\n            if isSMB2 is False:\n                # Is the client authenticated already?\n                if connData['Authenticated'] is False and packet['Command'] not in (\n                smb.SMB.SMB_COM_NEGOTIATE, smb.SMB.SMB_COM_SESSION_SETUP_ANDX):\n                    # Nope.. in that case he should only ask for a few commands, if not throw him out.\n                    errorCode = STATUS_ACCESS_DENIED\n                    respPackets = None\n                    respCommands = [smb.SMBCommand(packet['Command'])]\n                else:\n                    if packet['Command'] == smb.SMB.SMB_COM_TRANSACTION2:\n                        respCommands, respPackets, errorCode = self.__smbCommands[packet['Command']](\n                            connId,\n                            self,\n                            SMBCommand,\n                            packet,\n                            self.__smbTrans2Commands)\n                    elif packet['Command'] == smb.SMB.SMB_COM_NT_TRANSACT:\n                        respCommands, respPackets, errorCode = self.__smbCommands[packet['Command']](\n                            connId,\n                            self,\n                            SMBCommand,\n                            packet,\n                            self.__smbNTTransCommands)\n                    elif packet['Command'] == smb.SMB.SMB_COM_TRANSACTION:\n                        respCommands, respPackets, errorCode = self.__smbCommands[packet['Command']](\n                            connId,\n                            self,\n                            SMBCommand,\n                            packet,\n                            self.__smbTransCommands)\n                    else:\n                        if packet['Command'] in self.__smbCommands:\n                            if self.__SMB2Support is True:\n                                if packet['Command'] == smb.SMB.SMB_COM_NEGOTIATE:\n                                    try:\n                                        respCommands, respPackets, errorCode = self.__smb2Commands[smb2.SMB2_NEGOTIATE](\n                                            connId, self, packet, True)\n                                        isSMB2 = True\n                                    except Exception as e:\n                                        import traceback\n                                        traceback.print_exc()\n                                        self.log('SMB2_NEGOTIATE: %s' % e, logging.ERROR)\n                                        # If something went wrong, let's fallback to SMB1\n                                        respCommands, respPackets, errorCode = self.__smbCommands[packet['Command']](\n                                            connId,\n                                            self,\n                                            SMBCommand,\n                                            packet)\n                                        # self.__SMB2Support = False\n                                        pass\n                                else:\n                                    respCommands, respPackets, errorCode = self.__smbCommands[packet['Command']](\n                                        connId,\n                                        self,\n                                        SMBCommand,\n                                        packet)\n                            else:\n                                respCommands, respPackets, errorCode = self.__smbCommands[packet['Command']](\n                                    connId,\n                                    self,\n                                    SMBCommand,\n                                    packet)\n                        else:\n                            respCommands, respPackets, errorCode = self.__smbCommands[255](connId, self, SMBCommand,\n                                                                                           packet)\n\n                compoundedPacketsResponse.append((respCommands, respPackets, errorCode))\n                compoundedPackets.append(packet)\n\n            else:\n                # Is the client authenticated already?\n                if connData['Authenticated'] is False and packet['Command'] not in (\n                smb2.SMB2_NEGOTIATE, smb2.SMB2_SESSION_SETUP):\n                    # Nope.. in that case he should only ask for a few commands, if not throw him out.\n                    errorCode = STATUS_ACCESS_DENIED\n                    respPackets = None\n                    respCommands = ['']\n                    compoundedPacketsResponse.append((respCommands, respPackets, errorCode))\n                    compoundedPackets.append(packet)\n                else:\n                    done = False\n                    while not done:\n                        if packet['Command'] in self.__smb2Commands:\n                            if self.__SMB2Support is True:\n                                respCommands, respPackets, errorCode = self.__smb2Commands[packet['Command']](\n                                    connId,\n                                    self,\n                                    packet)\n                            else:\n                                respCommands, respPackets, errorCode = self.__smb2Commands[255](connId, self, packet)\n                        else:\n                            respCommands, respPackets, errorCode = self.__smb2Commands[255](connId, self, packet)\n                        # Let's store the result for this compounded packet\n                        compoundedPacketsResponse.append((respCommands, respPackets, errorCode))\n                        compoundedPackets.append(packet)\n                        if packet['NextCommand'] != 0:\n                            data = data[packet['NextCommand']:]\n                            packet = smb2.SMB2Packet(data=data)\n                        else:\n                            done = True\n\n        except Exception as e:\n            # import traceback\n            # traceback.print_exc()\n            # Something wen't wrong, defaulting to Bad user ID\n            self.log('processRequest (0x%x,%s)' % (packet['Command'], e), logging.ERROR)\n            raise\n\n        # We prepare the response packet to commands don't need to bother about that.\n        connData = self.getConnectionData(connId, False)\n\n        # Force reconnection loop.. This is just a test.. client will send me back credentials :)\n        # connData['PacketNum'] += 1\n        # if connData['PacketNum'] == 15:\n        #    connData['PacketNum'] = 0\n        #    # Something wen't wrong, defaulting to Bad user ID\n        #    self.log('Sending BAD USER ID!', logging.ERROR)\n        #    #raise\n        #    packet['Flags1'] |= smb.SMB.FLAGS1_REPLY\n        #    packet['Flags2'] = 0\n        #    errorCode = STATUS_SMB_BAD_UID\n        #    packet['ErrorCode']   = errorCode >> 16\n        #    packet['ErrorClass']  = errorCode & 0xff\n        #    return [packet]\n\n        self.setConnectionData(connId, connData)\n\n        packetsToSend = []\n        for packetNum in range(len(compoundedPacketsResponse)):\n            respCommands, respPackets, errorCode = compoundedPacketsResponse[packetNum]\n            packet = compoundedPackets[packetNum]\n            if respPackets is None:\n                for respCommand in respCommands:\n                    if isSMB2 is False:\n                        respPacket = smb.NewSMBPacket()\n                        respPacket['Flags1'] = smb.SMB.FLAGS1_REPLY\n\n                        # TODO this should come from a per session configuration\n                        respPacket[\n                            'Flags2'] = smb.SMB.FLAGS2_EXTENDED_SECURITY | smb.SMB.FLAGS2_NT_STATUS | smb.SMB.FLAGS2_LONG_NAMES | \\\n                                        packet['Flags2'] & smb.SMB.FLAGS2_UNICODE\n                        # respPacket['Flags2'] = smb.SMB.FLAGS2_EXTENDED_SECURITY | smb.SMB.FLAGS2_NT_STATUS | smb.SMB.FLAGS2_LONG_NAMES\n                        # respPacket['Flags1'] = 0x98\n                        # respPacket['Flags2'] = 0xc807\n\n                        respPacket['Tid'] = packet['Tid']\n                        respPacket['Mid'] = packet['Mid']\n                        respPacket['Pid'] = packet['Pid']\n                        respPacket['Uid'] = connData['Uid']\n\n                        respPacket['ErrorCode'] = errorCode >> 16\n                        respPacket['_reserved'] = errorCode >> 8 & 0xff\n                        respPacket['ErrorClass'] = errorCode & 0xff\n                        respPacket.addCommand(respCommand)\n\n                        if connData['SignatureEnabled']:\n                            respPacket['Flags2'] |= smb.SMB.FLAGS2_SMB_SECURITY_SIGNATURE\n                            self.signSMBv1(connData, respPacket, connData['SigningSessionKey'],\n                                           connData['SigningChallengeResponse'])\n\n                        packetsToSend.append(respPacket)\n                    else:\n                        respPacket = smb2.SMB2Packet()\n                        respPacket['Flags'] = smb2.SMB2_FLAGS_SERVER_TO_REDIR\n                        if packetNum > 0:\n                            respPacket['Flags'] |= smb2.SMB2_FLAGS_RELATED_OPERATIONS\n                        respPacket['Status'] = errorCode\n                        respPacket['CreditRequestResponse'] = packet['CreditRequestResponse']\n                        respPacket['Command'] = packet['Command']\n                        respPacket['CreditCharge'] = packet['CreditCharge']\n                        # respPacket['CreditCharge'] = 0\n                        respPacket['Reserved'] = packet['Reserved']\n                        respPacket['SessionID'] = connData['Uid']\n                        respPacket['MessageID'] = packet['MessageID']\n                        respPacket['TreeID'] = packet['TreeID']\n                        if hasattr(respCommand, 'getData'):\n                            respPacket['Data'] = respCommand.getData()\n                        else:\n                            respPacket['Data'] = str(respCommand)\n\n                        if connData['SignatureEnabled']:\n                            self.signSMBv2(respPacket, connData['SigningSessionKey'])\n\n                        packetsToSend.append(respPacket)\n            else:\n                # The SMBCommand took care of building the packet\n                packetsToSend = respPackets\n\n        if isSMB2 is True:\n            # Let's build a compound answer\n            finalData = b''\n            i = 0\n            for i in range(len(packetsToSend) - 1):\n                packet = packetsToSend[i]\n                # Align to 8-bytes\n                padLen = (8 - (len(packet) % 8)) % 8\n                packet['NextCommand'] = len(packet) + padLen\n                if hasattr(packet, 'getData'):\n                    finalData += packet.getData() + padLen * b'\\x00'\n                else:\n                    finalData += packet + padLen * b'\\x00'\n\n            # Last one\n            if hasattr(packetsToSend[len(packetsToSend) - 1], 'getData'):\n                finalData += packetsToSend[len(packetsToSend) - 1].getData()\n            else:\n                finalData += packetsToSend[len(packetsToSend) - 1]\n            packetsToSend = [finalData]\n\n        # We clear the compound requests\n        connData['LastRequest'] = {}\n\n        return packetsToSend",
  "def processConfigFile(self, configFile=None):\n        # TODO: Do a real config parser\n        if self.__serverConfig is None:\n            if configFile is None:\n                configFile = 'smb.conf'\n            self.__serverConfig = configparser.ConfigParser()\n            self.__serverConfig.read(configFile)\n\n        self.__serverName = self.__serverConfig.get('global', 'server_name')\n        self.__serverOS = self.__serverConfig.get('global', 'server_os')\n        self.__serverDomain = self.__serverConfig.get('global', 'server_domain')\n        self.__logFile = self.__serverConfig.get('global', 'log_file')\n        if self.__serverConfig.has_option('global', 'challenge'):\n            self.__challenge = unhexlify(self.__serverConfig.get('global', 'challenge'))\n        else:\n            self.__challenge = b'A' * 8\n\n        if self.__serverConfig.has_option(\"global\", \"jtr_dump_path\"):\n            self.__jtr_dump_path = self.__serverConfig.get(\"global\", \"jtr_dump_path\")\n\n        if self.__serverConfig.has_option(\"global\", \"SMB2Support\"):\n            self.__SMB2Support = self.__serverConfig.getboolean(\"global\", \"SMB2Support\")\n        else:\n            self.__SMB2Support = False\n\n\n        if self.__serverConfig.has_option(\"global\", \"anonymous_logon\"):\n            self.__anonymousLogon = self.__serverConfig.getboolean(\"global\", \"anonymous_logon\")\n        else:\n            self.__anonymousLogon = True\n\n        if self.__logFile != 'None':\n            logging.basicConfig(filename=self.__logFile,\n                                level=logging.DEBUG,\n                                format=\"%(asctime)s: %(levelname)s: %(message)s\",\n                                datefmt='%m/%d/%Y %I:%M:%S %p')\n        self.__log = LOG\n\n        # Process the credentials\n        credentials_fname = self.__serverConfig.get('global', 'credentials_file')\n        if credentials_fname != \"\":\n            cred = open(credentials_fname)\n            line = cred.readline()\n            while line:\n                name, uid, lmhash, nthash = line.split(':')\n                self.__credentials[name.lower()] = (uid, lmhash, nthash.strip('\\r\\n'))\n                line = cred.readline()\n            cred.close()\n        self.log('Config file parsed')",
  "def addCredential(self, name, uid, lmhash, nthash):\n        # If we have hashes, normalize them\n        if lmhash != '' or nthash != '':\n            if len(lmhash) % 2:\n                lmhash = '0%s' % lmhash\n            if len(nthash) % 2:\n                nthash = '0%s' % nthash\n            try:  # just in case they were converted already\n                lmhash = a2b_hex(lmhash)\n                nthash = a2b_hex(nthash)\n            except:\n                pass\n        self.__credentials[name.lower()] = (uid, lmhash, nthash)",
  "def __init__(self):\n        DCERPCServer.__init__(self)\n        self.wkssvcCallBacks = {\n            0: self.NetrWkstaGetInfo,\n        }\n        self.addCallbacks(('6BFFD098-A112-3610-9833-46C3F87E345A', '1.0'), '\\\\PIPE\\\\wkssvc', self.wkssvcCallBacks)",
  "def NetrWkstaGetInfo(self, data):\n        request = NetrWkstaGetInfo(data)\n        self.log(\"NetrWkstaGetInfo Level: %d\" % request['Level'])\n\n        answer = NetrWkstaGetInfoResponse()\n\n        if request['Level'] not in (100, 101):\n            answer['ErrorCode'] = ERROR_INVALID_LEVEL\n            return answer\n\n        answer['WkstaInfo']['tag'] = request['Level']\n\n        if request['Level'] == 100:\n            # Windows. Decimal value 500.\n            answer['WkstaInfo']['WkstaInfo100']['wki100_platform_id'] = 0x000001F4\n            answer['WkstaInfo']['WkstaInfo100']['wki100_computername'] = NULL\n            answer['WkstaInfo']['WkstaInfo100']['wki100_langroup'] = NULL\n            answer['WkstaInfo']['WkstaInfo100']['wki100_ver_major'] = 5\n            answer['WkstaInfo']['WkstaInfo100']['wki100_ver_minor'] = 0\n        else:\n            # Windows. Decimal value 500.\n            answer['WkstaInfo']['WkstaInfo101']['wki101_platform_id'] = 0x000001F4\n            answer['WkstaInfo']['WkstaInfo101']['wki101_computername'] = NULL\n            answer['WkstaInfo']['WkstaInfo101']['wki101_langroup'] = NULL\n            answer['WkstaInfo']['WkstaInfo101']['wki101_ver_major'] = 5\n            answer['WkstaInfo']['WkstaInfo101']['wki101_ver_minor'] = 0\n            answer['WkstaInfo']['WkstaInfo101']['wki101_lanroot'] = NULL\n\n        return answer",
  "def __init__(self):\n        DCERPCServer.__init__(self)\n\n        self._shares = {}\n        self.__serverConfig = None\n        self.__logFile = None\n\n        self.srvsvcCallBacks = {\n            15: self.NetrShareEnum,\n            16: self.NetrShareGetInfo,\n            21: self.NetrServerGetInfo,\n        }\n\n        self.addCallbacks(('4B324FC8-1670-01D3-1278-5A47BF6EE188', '3.0'), '\\\\PIPE\\\\srvsvc', self.srvsvcCallBacks)",
  "def setServerConfig(self, config):\n        self.__serverConfig = config",
  "def processConfigFile(self, configFile=None):\n        if configFile is not None:\n            self.__serverConfig = configparser.ConfigParser()\n            self.__serverConfig.read(configFile)\n        sections = self.__serverConfig.sections()\n        # Let's check the log file\n        self.__logFile = self.__serverConfig.get('global', 'log_file')\n        if self.__logFile != 'None':\n            logging.basicConfig(filename=self.__logFile,\n                                level=logging.DEBUG,\n                                format=\"%(asctime)s: %(levelname)s: %(message)s\",\n                                datefmt='%m/%d/%Y %I:%M:%S %p')\n\n        # Remove the global one\n        del (sections[sections.index('global')])\n        self._shares = {}\n        for i in sections:\n            self._shares[i] = dict(self.__serverConfig.items(i))",
  "def NetrShareGetInfo(self, data):\n        request = NetrShareGetInfo(data)\n        self.log(\"NetrGetShareInfo Level: %d\" % request['Level'])\n\n        s = request['NetName'][:-1].upper()\n        answer = NetrShareGetInfoResponse()\n        if s in self._shares:\n            share = self._shares[s]\n\n            answer['InfoStruct']['tag'] = 1\n            answer['InfoStruct']['ShareInfo1']['shi1_netname'] = s + '\\x00'\n            answer['InfoStruct']['ShareInfo1']['shi1_type'] = share['share type']\n            answer['InfoStruct']['ShareInfo1']['shi1_remark'] = share['comment'] + '\\x00'\n            answer['ErrorCode'] = 0\n        else:\n            answer['InfoStruct']['tag'] = 1\n            answer['InfoStruct']['ShareInfo1'] = NULL\n            answer['ErrorCode'] = 0x0906  # WERR_NET_NAME_NOT_FOUND\n\n        return answer",
  "def NetrServerGetInfo(self, data):\n        request = NetrServerGetInfo(data)\n        self.log(\"NetrServerGetInfo Level: %d\" % request['Level'])\n        answer = NetrServerGetInfoResponse()\n        answer['InfoStruct']['tag'] = 101\n        # PLATFORM_ID_NT = 500\n        answer['InfoStruct']['ServerInfo101']['sv101_platform_id'] = 500\n        answer['InfoStruct']['ServerInfo101']['sv101_name'] = request['ServerName']\n        # Windows 7 = 6.1\n        answer['InfoStruct']['ServerInfo101']['sv101_version_major'] = 6\n        answer['InfoStruct']['ServerInfo101']['sv101_version_minor'] = 1\n        # Workstation = 1\n        answer['InfoStruct']['ServerInfo101']['sv101_type'] = 1\n        answer['InfoStruct']['ServerInfo101']['sv101_comment'] = NULL\n        answer['ErrorCode'] = 0\n        return answer",
  "def NetrShareEnum(self, data):\n        request = NetrShareEnum(data)\n        self.log(\"NetrShareEnum Level: %d\" % request['InfoStruct']['Level'])\n        shareEnum = NetrShareEnumResponse()\n        shareEnum['InfoStruct']['Level'] = 1\n        shareEnum['InfoStruct']['ShareInfo']['tag'] = 1\n        shareEnum['TotalEntries'] = len(self._shares)\n        shareEnum['InfoStruct']['ShareInfo']['Level1']['EntriesRead'] = len(self._shares)\n        shareEnum['ErrorCode'] = 0\n\n        for i in self._shares:\n            shareInfo = SHARE_INFO_1()\n            shareInfo['shi1_netname'] = i + '\\x00'\n            shareInfo['shi1_type'] = self._shares[i]['share type']\n            shareInfo['shi1_remark'] = self._shares[i]['comment'] + '\\x00'\n            shareEnum['InfoStruct']['ShareInfo']['Level1']['Buffer'].append(shareInfo)\n\n        return shareEnum",
  "def __init__(self, listenAddress='0.0.0.0', listenPort=445, configFile=''):\n        if configFile != '':\n            self.__server = SMBSERVER((listenAddress, listenPort))\n            self.__server.processConfigFile(configFile)\n            self.__smbConfig = None\n        else:\n            # Here we write a mini config for the server\n            self.__smbConfig = configparser.ConfigParser()\n            self.__smbConfig.add_section('global')\n            self.__smbConfig.set('global', 'server_name',\n                                 ''.join([random.choice(string.ascii_letters) for _ in range(8)]))\n            self.__smbConfig.set('global', 'server_os', ''.join([random.choice(string.ascii_letters) for _ in range(8)])\n                                 )\n            self.__smbConfig.set('global', 'server_domain',\n                                 ''.join([random.choice(string.ascii_letters) for _ in range(8)])\n                                 )\n            self.__smbConfig.set('global', 'log_file', 'None')\n            self.__smbConfig.set('global', 'rpc_apis', 'yes')\n            self.__smbConfig.set('global', 'credentials_file', '')\n            self.__smbConfig.set('global', 'challenge', \"A\" * 16)\n\n            # IPC always needed\n            self.__smbConfig.add_section('IPC$')\n            self.__smbConfig.set('IPC$', 'comment', '')\n            self.__smbConfig.set('IPC$', 'read only', 'yes')\n            self.__smbConfig.set('IPC$', 'share type', '3')\n            self.__smbConfig.set('IPC$', 'path', '')\n            self.__server = SMBSERVER((listenAddress, listenPort), config_parser=self.__smbConfig)\n            self.__server.processConfigFile()\n\n        # Now we have to register the MS-SRVS server. This specially important for\n        # Windows 7+ and Mavericks clients since they WON'T (specially OSX)\n        # ask for shares using MS-RAP.\n\n        self.__srvsServer = SRVSServer()\n        self.__srvsServer.daemon = True\n        self.__wkstServer = WKSTServer()\n        self.__wkstServer.daemon = True\n        self.__server.registerNamedPipe('srvsvc', ('127.0.0.1', self.__srvsServer.getListenPort()))\n        self.__server.registerNamedPipe('wkssvc', ('127.0.0.1', self.__wkstServer.getListenPort()))",
  "def start(self):\n        self.__srvsServer.start()\n        self.__wkstServer.start()\n        self.__server.serve_forever()",
  "def stop(self):\n        self.__server.server_close()",
  "def registerNamedPipe(self, pipeName, address):\n        return self.__server.registerNamedPipe(pipeName, address)",
  "def unregisterNamedPipe(self, pipeName):\n        return self.__server.unregisterNamedPipe(pipeName)",
  "def getRegisteredNamedPipes(self):\n        return self.__server.getRegisteredNamedPipes()",
  "def addShare(self, shareName, sharePath, shareComment='', shareType='0', readOnly='no'):\n        share = shareName.upper()\n        self.__smbConfig.add_section(share)\n        self.__smbConfig.set(share, 'comment', shareComment)\n        self.__smbConfig.set(share, 'read only', readOnly)\n        self.__smbConfig.set(share, 'share type', shareType)\n        self.__smbConfig.set(share, 'path', sharePath)\n        self.__server.setServerConfig(self.__smbConfig)\n        self.__srvsServer.setServerConfig(self.__smbConfig)\n        self.__server.processConfigFile()\n        self.__srvsServer.processConfigFile()",
  "def removeShare(self, shareName):\n        self.__smbConfig.remove_section(shareName.upper())\n        self.__server.setServerConfig(self.__smbConfig)\n        self.__srvsServer.setServerConfig(self.__smbConfig)\n        self.__server.processConfigFile()\n        self.__srvsServer.processConfigFile()",
  "def setSMBChallenge(self, challenge):\n        if challenge != '':\n            self.__smbConfig.set('global', 'challenge', challenge)\n            self.__server.setServerConfig(self.__smbConfig)\n            self.__server.processConfigFile()",
  "def setLogFile(self, logFile):\n        self.__smbConfig.set('global', 'log_file', logFile)\n        self.__server.setServerConfig(self.__smbConfig)\n        self.__server.processConfigFile()",
  "def setCredentialsFile(self, logFile):\n        self.__smbConfig.set('global', 'credentials_file', logFile)\n        self.__server.setServerConfig(self.__smbConfig)\n        self.__server.processConfigFile()",
  "def addCredential(self, name, uid, lmhash, nthash):\n        self.__server.addCredential(name, uid, lmhash, nthash)",
  "def setSMB2Support(self, value):\n        if value is True:\n            self.__smbConfig.set(\"global\", \"SMB2Support\", \"True\")\n        else:\n            self.__smbConfig.set(\"global\", \"SMB2Support\", \"False\")\n        self.__server.setServerConfig(self.__smbConfig)\n        self.__server.processConfigFile()",
  "def getAuthCallback(self):\n        return self.__server.getAuthCallback()",
  "def setAuthCallback(self, callback):\n        self.__server.setAuthCallback(callback)",
  "def rebind(f):\n    functools.wraps(f)\n    def rebinder(*args, **kwargs):\n        return f(*args, **kwargs)\n        \n    return rebinder",
  "class Field(object):\n    def __init__(self, index):\n        self.index = index\n    \n    def __call__(self, k, d):\n        getter = rebind(self.getter)\n        getter_name = \"get_\" + k\n        getter.__name__ = getter_name\n        getter.__doc__ = \"Get the %s field\" % k\n        d[getter_name] = getter\n        \n        setter = rebind(self.setter)\n        setter_name = \"set_\" + k\n        setter.__name__ = setter_name\n        setter.__doc__ = \"Set the %s field\" % k\n        d[\"set_\" + k] = setter\n        \n        d[k] = property(getter, setter, doc=\"%s property\" % k)",
  "class Bit(Field):\n    def __init__(self, index, bit_number):\n        Field.__init__(self, index)\n        self.mask = 2 ** bit_number\n        self.off_mask = (~self.mask) & 0xff\n        \n    def getter(self, o):\n        return (o.header.get_byte(self.index) & self.mask) != 0\n    \n    def setter(self, o, value=True):\n        b = o.header.get_byte(self.index)\n        if value:\n            b |= self.mask\n        else:\n            b &= self.off_mask\n        \n        o.header.set_byte(self.index, b)",
  "class Byte(Field):\n    \n    def __init__(self, index):\n        Field.__init__(self, index)\n        \n    def getter(self, o):\n        return o.header.get_byte(self.index)\n    \n    def setter(self, o, value):\n        o.header.set_byte(self.index, value)",
  "class Word(Field):\n    def __init__(self, index, order=\"!\"):\n        Field.__init__(self, index)\n        self.order = order\n        \n    def getter(self, o):\n        return o.header.get_word(self.index, self.order)\n    \n    def setter(self, o, value):\n        o.header.set_word(self.index, value, self.order)",
  "class Long(Field):        \n    def __init__(self, index, order=\"!\"):\n        Field.__init__(self, index)        \n        self.order = order\n        \n    def getter(self, o):\n        return o.header.get_long(self.index, self.order)\n    \n    def setter(self, o, value):\n        o.header.set_long(self.index, value, self.order)",
  "class ThreeBytesBigEndian(Field):\n    def __init__(self, index):\n        Field.__init__(self, index)\n                \n    def getter(self, o):\n        b = ip.array_tobytes(o.header.get_bytes()[self.index:self.index+3])\n        #unpack requires a string argument of length 4 and b is 3 bytes long\n        (value,) = struct.unpack('!L', b'\\x00'+b)\n        return value\n\n    def setter(self, o, value):\n        # clear the bits\n        mask = ((~0xFFFFFF00) & 0xFF)\n        masked = o.header.get_long(self.index, \">\") & mask\n        # set the bits \n        nb = masked | ((value & 0x00FFFFFF) << 8)\n        o.header.set_long(self.index, nb, \">\")",
  "class ProtocolPacketMetaklass(type):\n    def __new__(cls, name, bases, d):\n        d[\"_fields\"] = []\n        items = list(d.items())\n        if not object in bases:\n            bases += (object,)\n        for k,v in items:\n            if isinstance(v, Field):\n                d[\"_fields\"].append(k) \n                v(k, d)\n                \n        d[\"_fields\"].sort()\n        \n        def _fields_repr(self):\n            return \" \".join( \"%s:%s\" % (f, repr(getattr(self, f))) for f in self._fields )\n        def __repr__(self):\n            \n            return \"<%(name)s %(fields)s \\nchild:%(r_child)s>\" % {\n                \"name\": name,\n                \"fields\": self._fields_repr(),\n                \"r_child\": repr(self.child()), \n            }\n        \n        d[\"_fields_repr\"] = _fields_repr\n        d[\"__repr__\"] = __repr__\n        \n        return type.__new__(cls, name, bases, d)",
  "class ProtocolPacket(ip.ProtocolPacket):\n    def __init__(self, buff = None):\n        ip.ProtocolPacket.__init__(self, self.header_size, self.tail_size)\n        if buff:\n            self.load_packet(buff)",
  "def rebinder(*args, **kwargs):\n        return f(*args, **kwargs)",
  "def __init__(self, index):\n        self.index = index",
  "def __call__(self, k, d):\n        getter = rebind(self.getter)\n        getter_name = \"get_\" + k\n        getter.__name__ = getter_name\n        getter.__doc__ = \"Get the %s field\" % k\n        d[getter_name] = getter\n        \n        setter = rebind(self.setter)\n        setter_name = \"set_\" + k\n        setter.__name__ = setter_name\n        setter.__doc__ = \"Set the %s field\" % k\n        d[\"set_\" + k] = setter\n        \n        d[k] = property(getter, setter, doc=\"%s property\" % k)",
  "def __init__(self, index, bit_number):\n        Field.__init__(self, index)\n        self.mask = 2 ** bit_number\n        self.off_mask = (~self.mask) & 0xff",
  "def getter(self, o):\n        return (o.header.get_byte(self.index) & self.mask) != 0",
  "def setter(self, o, value=True):\n        b = o.header.get_byte(self.index)\n        if value:\n            b |= self.mask\n        else:\n            b &= self.off_mask\n        \n        o.header.set_byte(self.index, b)",
  "def __init__(self, index):\n        Field.__init__(self, index)",
  "def getter(self, o):\n        return o.header.get_byte(self.index)",
  "def setter(self, o, value):\n        o.header.set_byte(self.index, value)",
  "def __init__(self, index, order=\"!\"):\n        Field.__init__(self, index)\n        self.order = order",
  "def getter(self, o):\n        return o.header.get_word(self.index, self.order)",
  "def setter(self, o, value):\n        o.header.set_word(self.index, value, self.order)",
  "def __init__(self, index, order=\"!\"):\n        Field.__init__(self, index)        \n        self.order = order",
  "def getter(self, o):\n        return o.header.get_long(self.index, self.order)",
  "def setter(self, o, value):\n        o.header.set_long(self.index, value, self.order)",
  "def __init__(self, index):\n        Field.__init__(self, index)",
  "def getter(self, o):\n        b = ip.array_tobytes(o.header.get_bytes()[self.index:self.index+3])\n        #unpack requires a string argument of length 4 and b is 3 bytes long\n        (value,) = struct.unpack('!L', b'\\x00'+b)\n        return value",
  "def setter(self, o, value):\n        # clear the bits\n        mask = ((~0xFFFFFF00) & 0xFF)\n        masked = o.header.get_long(self.index, \">\") & mask\n        # set the bits \n        nb = masked | ((value & 0x00FFFFFF) << 8)\n        o.header.set_long(self.index, nb, \">\")",
  "def __new__(cls, name, bases, d):\n        d[\"_fields\"] = []\n        items = list(d.items())\n        if not object in bases:\n            bases += (object,)\n        for k,v in items:\n            if isinstance(v, Field):\n                d[\"_fields\"].append(k) \n                v(k, d)\n                \n        d[\"_fields\"].sort()\n        \n        def _fields_repr(self):\n            return \" \".join( \"%s:%s\" % (f, repr(getattr(self, f))) for f in self._fields )\n        def __repr__(self):\n            \n            return \"<%(name)s %(fields)s \\nchild:%(r_child)s>\" % {\n                \"name\": name,\n                \"fields\": self._fields_repr(),\n                \"r_child\": repr(self.child()), \n            }\n        \n        d[\"_fields_repr\"] = _fields_repr\n        d[\"__repr__\"] = __repr__\n        \n        return type.__new__(cls, name, bases, d)",
  "def __init__(self, buff = None):\n        ip.ProtocolPacket.__init__(self, self.header_size, self.tail_size)\n        if buff:\n            self.load_packet(buff)",
  "def _fields_repr(self):\n            return \" \".join( \"%s:%s\" % (f, repr(getattr(self, f))) for f in self._fields )",
  "def __repr__(self):\n            \n            return \"<%(name)s %(fields)s \\nchild:%(r_child)s>\" % {\n                \"name\": name,\n                \"fields\": self._fields_repr(),\n                \"r_child\": repr(self.child()), \n            }",
  "class DNSFlags():\n    'Bitmap with the flags of a dns packet.'\n    # QR - Query/Response - 1 bit\n    QR_QUERY                = int(\"0000000000000000\", 2)\n    QR_RESPONSE             = int(\"1000000000000000\", 2)\n    # OP - Opcode - 4 bits\n    OP_STANDARD_QUERY       = int(\"0000000000000000\", 2) # Standard query.\n    OP_INVERSE_QUERY        = int(\"0100000000000000\", 2) # Inverse query.\n    OP_STATUS_QUERY         = int(\"0010000000000000\", 2) # Server status request.\n    OP_NOTIFY               = int(\"0000100000000000\", 2) # Notify.\n    OP_UPDATE               = int(\"0100100000000000\", 2) # Update.\n    # AA - Authority Answer - 1 bit\n    AA_NOT_AUTH_ANSWER      = int(\"0000000000000000\", 2) # Not authoritative.\n    AA_AUTH_ANSWER          = int(\"0000010000000000\", 2) # Is authoritative.\n    # TC - Truncated - 1 bit\n    TC_NOT_TRUNCATED        = int(\"0000000000000000\", 2) # Not truncated.\n    TC_TRUNCATED            = int(\"0000001000000000\", 2) # Message truncated.\n    # RD - Recursion Desired - 1 bit\n    RD_NOT_RECURSIVE_QUERY  = int(\"0000000000000000\", 2) # Recursion not desired.\n    RD_RECURSIVE_QUERY      = int(\"0000000100000000\", 2) # Recursion desired.\n    # RA - Recursion Available - 1 bit\n    RA_NOT_AVAILABLE        = int(\"0000000000000000\", 2) # Recursive query support not available.\n    RA_AVAILABLE            = int(\"0000000010000000\", 2) # Recursive query support available.\n    # Z - 3 bits\n    Z                       = int(\"0000000000000000\", 2)\n    # AD - Authenticated Data - 1 bit\n    AUTHENTICATED_DATA      = int(\"0000000000100000\", 2)\n    # CD - Checking Disabled - 1 bit\n    CHECKING_DISABLED       = int(\"0000000000010000\", 2)\n    # RCODE - 4 bits\n    RCODE_NO_ERROR          = int(\"0000000000000000\", 2) # The request completed successfully.\n    RCODE_FORMAT_ERROR      = int(\"0000000000001000\", 2) # The name server was unable to interpret the query.\n    RCODE_SERVER_FAILURE    = int(\"0000000000000100\", 2) # The name server was unable to process this query due to a problem with the name server.\n    RCODE_NAME_ERROR        = int(\"0000000000001100\", 2) # Meaningful only for responses from an authoritative name server, this code signifies that the domain name referenced in the query does not exist.\n    RCODE_NOT_IMPLEMENTED   = int(\"0000000000000010\", 2) # Not Implemented. The name server does not support the requested kind of query.\n    RCODE_REFUSED           = int(\"0000000000001010\", 2) # The name server refuses to perform the specified operation for policy reasons. \n    RCODE_YXDOMAIN          = int(\"0000000000000110\", 2) # Name Exists when it should not.\n    RCODE_YXRRSET           = int(\"0000000000001110\", 2) # RR Set Exists when it should not.\n    RCODE_NXRRSET           = int(\"0000000000000001\", 2) # RR Set that should exist does not.\n    RCODE_NOAUTH            = int(\"0000000000001001\", 2) # Server Not Authoritative for zone.\n    RCODE_NOTZONE           = int(\"0000000000000101\", 2)",
  "class DNSType():\n    A            = 1     # IPv4 address.\n    NS           = 2     # Authoritative name server.\n    MD           = 3     # Mail destination. Obsolete use MX instead.\n    MF           = 4     # Mail forwarder. Obsolete use MX instead.\n    CNAME        = 5     # Canonical name for an alias.\n    SOA          = 6     # Marks the start of a zone of authority.\n    MB           = 7     # Mailbox domain name.\n    MG           = 8     # Mail group member.\n    MR           = 9     # Mail rename domain name.\n    NULL         = 10    # Null resource record.\n    WKS          = 11    # Well known service description.\n    PTR          = 12    # Domain name pointer.\n    HINFO        = 13    # Host information.\n    MINFO        = 14    # Mailbox or mail list information.\n    MX           = 15    # Mail exchange.\n    TXT          = 16    # Text strings.\n    RP           = 17    # Responsible Person.\n    AFSDB        = 18    # AFS Data Base location.\n    X25          = 19    # X.25 PSDN address.\n    ISDN         = 20    # ISDN address.\n    RT           = 21    # Route Through.\n    NSAP         = 22    # NSAP address. NSAP style A record.\n    NSAP_PTR     = 23    # NSAP pointer.\n    SIG          = 24    # Security signature.\n    KEY          = 25    # Security key.\n    PX           = 26    # X.400 mail mapping information.\n    GPOS         = 27    # Geographical Position.\n    AAAA         = 28    # IPv6 Address.\n    LOC          = 29    # Location Information.\n    NXT          = 30    # Next Domain (obsolete).\n    EID          = 31    # Endpoint Identifier.\n    NB           = 32    # NetBIOS general Name Service.\n    NBSTAT       = 33    # NetBIOS NODE STATUS.\n    ATMA         = 34    # ATM Address.\n    NAPTR        = 35    # Naming Authority Pointer.\n    KX           = 36    # Key Exchanger.\n    CERT         = 37\n    A6           = 38\n    DNAME        = 39\n    SINK         = 40\n    OPT          = 41\n    APL          = 42\n    DS           = 43    # Delegation Signer.\n    SSHFP        = 44    # SSH Key Fingerprint.\n    IPSECKEY     = 45\n    RRSIG        = 46\n    NSEC         = 47    # NextSECure.\n    DNSKEY       = 48\n    DHCID        = 49    # DHCP identifier.\n    NSEC3        = 50\n    NSEC3PARAM   = 51\n    \n    HIP          = 55    # Host Identity Protocol.\n    NINFO        = 56\n    RKEY         = 57\n    \n    SPF          = 99    # Sender Policy Framework.\n    UINFO        = 100\n    UID          = 101\n    GID          = 102\n    UNSPEC       = 103\n    \n    TKEY         = 249\n    TSIG         = 250   # Transaction Signature.\n    IXFR         = 251   # Incremental transfer.\n    AXFR         = 252   # A request for a transfer of an entire zone.\n    MAILB        = 253   # A request for mailbox-related records (MB, MG or MR).\n    MAILA        = 254   # A request for mail agent RRs. Obsolete.\n    ALL          = 255   # A request for all records.\n    \n    DNSSEC       = 32768 # Trust Authorities.\n    DNSSEC       = 32769 # DNSSEC Lookaside Validation.\n    \n    @staticmethod\n    def getTypeName(type):\n        for item, value in list(DNSType.__dict__.items()):\n            if value == type:\n                return item",
  "class DNSClass():\n    RESERVED     = 0\n    IN           = 1 # Internet.\n    CH           = 3 # Chaos.\n    HS           = 4 # Hesiod.\n    \n    NONE         = 254\n    ANY          = 255 # QCLASS only\n    \n    @staticmethod\n    def getClassName(type):\n        for item, value in list(DNSClass.__dict__.items()):\n            if value == type:\n                return item",
  "class DNS(ProtocolPacket):\n    '''The Message Header is present in all messages. Never empty.\n    Contains various flags and values which control the transaction.'''\n    \n    __TYPE_LEN       = 2 # Unsigned 16 bit value.\n    __CLASS_LEN      = 2 # Unsigned 16 bit value.\n    __POINTER_LEN    = 2 # A pointer is an unsigned 16-bit value.\n    __TTL_LEN        = 4 # Unsigned 32 bit value. The time in seconds that the record may be cached.\n    __RDLENGTH_LEN   = 2 # Unsigned 16-bit value that defines the length in bytes (octets) of the RDATA record.\n    __TYPE_A_LEN     = 4 # Unsigned 32-bit value representing the IP address.\n    __SERIAL_LEN     = 4 # Serial Number  Unsigned 32-bit integer.\n    __REFRESH_LEN    = 4 # Refresh interval  Unsigned 32-bit integer.\n    __RETRY_LEN      = 4 # Retry Interval  Unsigned 32-bit integer.\n    __EXPIRATION_LEN = 4 # Expiration Limit  Unsigned 32-bit integer.\n    __MINTTL_LEN     = 4 # Minimum TTL  Unsigned 32-bit integer.\n    __PREF_LEN       = 2 # Preference  Unsigned 16-bit integer.\n    __IS_POINTER   = int(\"11000000\", 2)\n    __OFFSETMASK   = int(\"00111111\", 2)\n    \n    def __init__(self, aBuffer = None):\n        self.__HEADER_BASE_SIZE = 12\n        self.__TAIL_SIZE        = 0\n        ProtocolPacket.__init__(self, self.__HEADER_BASE_SIZE, self.__TAIL_SIZE)\n        if aBuffer:\n            self.load_packet(aBuffer)\n    \n    def get_transaction_id(self):\n        'Get 16 bit message ID.'\n        return self.header.get_word(0)\n    \n    def set_transaction_id(self, value):\n        'Set 16 bit message ID.'\n        self.header.set_word(0, value)\n    \n    def get_transaction_id_tcp(self):\n        'Get 16 bit message ID.'\n        return self.header.get_word(2)\n    \n    def set_transaction_id_tcp(self, value):\n        'Set 16 bit message ID.'\n        self.header.set_word(2, value)\n\n    def get_flags(self):\n        'Get 16 bit flags.'\n        return self.header.get_word(2)\n\n    def set_flags(self, value):\n        'Set 16 bit flags.'\n        self.header.set_word(2, value)\n\n    def get_flags_tcp(self):\n        'Get 16 bit flags.'\n        return self.header.get_word(4)\n    \n    def set_flags_tcp(self, value):\n        'Set 16 bit flags.'\n        self.header.set_word(4, value)\n    \n    def get_qdcount(self):\n        'Get Unsigned 16 bit integer specifying the number of entries in the question section.'\n        return self.header.get_word(4)\n    \n    def set_qdcount(self, value):\n        'Set Unsigned 16 bit integer specifying the number of entries in the question section.'\n        self.header.set_word(4, value)\n    \n    def get_qdcount_tcp(self):\n        'Get Unsigned 16 bit integer specifying the number of entries in the question section.'\n        return self.header.get_word(6)\n    \n    def set_qdcount_tcp(self, value):\n        'Set Unsigned 16 bit integer specifying the number of entries in the question section.'\n        self.header.set_word(6, value)\n\n    def get_ancount(self):\n        'Get Unsigned 16 bit integer specifying the number of resource records in the answer section'\n        return self.header.get_word(6)\n    \n    def set_ancount(self, value):\n        'Set Unsigned 16 bit integer specifying the number of resource records in the answer section'\n        self.header.set_word(6, value)\n    \n    def get_nscount(self):\n        'Get Unsigned 16 bit integer specifying the number of name server resource records in the authority section.'\n        return self.header.get_word(8)\n    \n    def set_nscount(self, value):\n        'Set Unsigned 16 bit integer specifying the number of name server resource records in the authority section.'\n        self.header.set_word(8, value)\n    \n    def get_arcount(self):\n        'Get Unsigned 16 bit integer specifying the number of resource records in the additional records section.'\n        return self.header.get_word(10)\n    \n    def set_arcount(self, value):\n        'Set Unsigned 16 bit integer specifying the number of resource records in the additional records section.'\n        self.header.set_word(10, value)\n    \n    def get_questions(self):\n        'Get a list of the DNS Question.'\n        return self.__get_questions()[0]\n    \n    def __get_questions(self):\n        aux = []\n        offset   = 0\n        qdcount = self.get_qdcount()\n        data    = self.get_body_as_string()\n        for _ in range(qdcount): # number of questions\n            offset, qname = self.parseCompressedMessage(data, offset)\n            qtype  = data[offset:offset+self.__TYPE_LEN]\n            offset  += self.__TYPE_LEN\n            qclass = data[offset:offset+self.__CLASS_LEN]\n            offset  += self.__CLASS_LEN\n            qtype  = struct.unpack(\"!H\", qtype)[0]\n            qclass = struct.unpack(\"!H\", qclass)[0]\n            aux.append((qname, qtype, qclass))\n        return (aux, offset)\n\n    def get_questions_tcp(self):\n        'Get a list of the DNS Question.'\n        return self.__get_questions_tcp()[0]\n\n    def __get_questions_tcp(self):\n        aux = []\n        offset   = 2\n        qdcount = self.get_qdcount_tcp()\n        data    = self.get_body_as_string()\n        for _ in range(qdcount): # number of questions\n            offset, qname = self.parseCompressedMessage(data, offset)\n            qtype  = data[offset:offset+self.__TYPE_LEN]\n            offset  += self.__TYPE_LEN\n            qclass = data[offset:offset+self.__CLASS_LEN]\n            offset  += self.__CLASS_LEN\n            qtype  = struct.unpack(\"!H\", qtype)[0]\n            qclass = struct.unpack(\"!H\", qclass)[0]\n            aux.append((qname, qtype, qclass))\n        return (aux, offset)\n\n    def parseCompressedMessage(self, buf, offset=0):\n        'Parse compressed message defined on rfc1035 4.1.4.'\n        if offset >= len(buf):\n            raise Exception(\"No more data to parse. Offset is bigger than length of buffer.\")\n        byte = struct.unpack(\"B\", buf[offset:offset+1])[0]\n        #  if the first two bits are ones (11000000=0xC0), the next bits are the offset\n        if byte & 0xC0 == 0xC0:\n            # It's a pointer\n            pointer = struct.unpack(\"!H\", buf[offset:offset+2])[0] # network unsigned short\n            pointer = (pointer & 0x3FFF) - self.__HEADER_BASE_SIZE\n            if offset == pointer:\n                raise Exception(\"The infinite loop is in DNS decompression. Encountered pointer points to the current offset.\")\n            offset += 2\n            name = self.parseCompressedMessage(buf, pointer)[1]\n            return (offset, name)\n        else:\n            # It's a label\n            if byte == 0x00:\n                offset += 1\n                return (offset, '')\n            offset += 1\n            name = buf[offset:offset+byte]\n            offset += byte\n            offset, unnamed = self.parseCompressedMessage(buf, offset)\n            if not unnamed:\n                return (offset, name)\n            else:\n                return (offset, name + b\".\" + unnamed)\n    \n    def get_answers(self):\n        return self.__get_answers()[0]\n    \n    def get_authoritative(self):\n        return self.__get_authoritative()[0]\n    \n    def get_additionals(self):\n        return self.__get_additionals()[0]\n    \n    def __get_answers(self):\n        offset  = self.__get_questions()[1] # get the initial offset\n        ancount = self.get_ancount()\n        return self.__process_answer_structure(offset, ancount)\n    \n    def __get_authoritative(self):\n        'Get a list of the DNS Authoritative.'\n        offset  = self.__get_answers()[1] # get the initial offset\n        nscount = self.get_nscount()\n        return self.__process_answer_structure(offset, nscount)\n    \n    def __get_additionals(self):\n        'Get a list of the DNS Additional Records.'\n        offset  = self.__get_authoritative()[1] # get the initial offset\n        arcount = self.get_arcount()\n        return self.__process_answer_structure(offset, arcount)\n    \n    def __process_answer_structure(self, offset, num):\n        aux  = []\n        data = self.get_body_as_string()\n        for _ in range(num):\n            offset, qname = self.parseCompressedMessage(data, offset)\n            qtype  = data[offset:offset+self.__TYPE_LEN]\n            qtype  = struct.unpack(\"!H\", qtype)[0]\n            offset  += self.__TYPE_LEN\n            \n            qclass = data[offset:offset+self.__CLASS_LEN]\n            qclass = struct.unpack(\"!H\", qclass)[0]\n            offset  += self.__CLASS_LEN\n            \n            qttl_raw = data[offset:offset+self.__TTL_LEN]\n            qttl = struct.unpack(\"!L\", qttl_raw)[0]\n            offset  += self.__TTL_LEN\n            \n            qrdlength = data[offset:offset+self.__RDLENGTH_LEN]\n            qrdlength = struct.unpack(\"!H\", qrdlength)[0]\n            offset  += self.__RDLENGTH_LEN\n            \n            qrdata = {}\n            if qtype == DNSType.A:\n                # IP Address  Unsigned 32-bit value representing the IP address\n                qrdata[\"IPAddress\"] = socket.inet_ntoa(data[offset:offset+qrdlength])\n                offset  += self.__TYPE_A_LEN\n            elif qtype == DNSType.SOA:\n                # Primary NS  Variable length. The name of the Primary Master for the domain. May be a label, pointer or any combination.\n                offset, primaryNs = self.parseCompressedMessage(data, offset)\n                qrdata[\"PrimaryNS\"] = primaryNs\n                # Admin MB  Variable length. The administrator's mailbox. May be a label, pointer or any combination.\n                offset, adminMb = self.parseCompressedMessage(data, offset)\n                qrdata[\"AdminMB\"] = adminMb\n                # Serial Number  Unsigned 32-bit integer.\n                qrdata[\"SerialNumber\"] = struct.unpack(\"!L\", data[offset:offset+self.__SERIAL_LEN])[0]\n                offset += self.__SERIAL_LEN\n                # Refresh interval  Unsigned 32-bit integer.\n                qrdata[\"RefreshInterval\"] = struct.unpack(\"!L\", data[offset:offset+self.__REFRESH_LEN])[0]\n                offset += self.__REFRESH_LEN\n                # Retry Interval  Unsigned 32-bit integer.\n                qrdata[\"RetryInterval\"] = struct.unpack(\"!L\", data[offset:offset+self.__RETRY_LEN])[0]\n                offset += self.__RETRY_LEN\n                # Expiration Limit  Unsigned 32-bit integer.\n                qrdata[\"ExpirationLimit\"] = struct.unpack(\"!L\", data[offset:offset+self.__EXPIRATION_LEN])[0]\n                offset += self.__EXPIRATION_LEN\n                # Minimum TTL  Unsigned 32-bit integer.\n                qrdata[\"MinimumTTL\"] = struct.unpack(\"!L\", data[offset:offset+self.__MINTTL_LEN])[0]\n                offset += self.__MINTTL_LEN\n            elif qtype == DNSType.MX:\n                # Preference  Unsigned 16-bit integer.\n                qrdata[\"Preference\"] = struct.unpack(\"!H\", data[offset:offset+self.__PREF_LEN])[0]\n                # Mail Exchanger  The name host name that provides the service. May be a label, pointer or any combination.\n                offset, mailExch = self.parseCompressedMessage(data, offset)\n                qrdata[\"MailExchanger\"] = mailExch\n            elif qtype == DNSType.PTR or qtype == DNSType.NS or qtype == DNSType.CNAME:\n                # Name  The host name that represents the supplied IP address (in the case of a PTR) or the NS name for the supplied domain (in the case of NS). May be a label, pointer or any combination.\n                offset, name = self.parseCompressedMessage(data, offset)\n                qrdata[\"Name\"] = str(name.decode('ascii'))\n            elif qtype == DNSType.OPT:\n                # rfc2671 4.3\n                #NAME         domain name    empty (root domain)\n                #TYPE         u_int16_t      OPT\n                #CLASS        u_int16_t      sender's UDP payload size\n                #TTL          u_int32_t      extended RCODE and flags\n                #RDLEN        u_int16_t      describes RDATA\n                #RDATA        octet stream   {attribute,value} pairs\n                #udp_payload = qclass\n                udp_payload_size = qclass\n                ext_rcode = struct.unpack(\"B\", qttl_raw[0:1])[0]\n                version = struct.unpack(\"B\", qttl_raw[1:2])[0]\n                flags = struct.unpack(\"!H\", qttl_raw[2:4])[0]\n                qrdata[\"RDATA\"] = data[offset:offset+qrdlength]\n                offset  += qrdlength\n                aux.append((qname, qtype, udp_payload_size, ext_rcode, version, flags, qrdata))\n                continue   \n            else:\n                # We don't know how to parse it, just skip it\n                offset  += qrdlength\n                \n            aux.append((qname, qtype, qclass, qttl, qrdata))\n        return (aux, offset)\n    \n    def get_header_size(self):\n        return self.__HEADER_BASE_SIZE\n    \n    def __str__(self):\n        res = \"\"\n        \n        id      = self.get_transaction_id()\n        flags   = self.get_flags()\n        qdcount = self.get_qdcount()\n        ancount = self.get_ancount()\n        nscount = self.get_nscount()\n        arcount = self.get_arcount()\n        \n        res += \"DNS \"\n        if flags & DNSFlags.QR_RESPONSE:\n            res += \"RESPONSE\\n\"\n        else:\n            res += \"QUERY\\n\"\n        \n        res += \" - Transaction ID -- [0x%04x] %d\\n\" % (id, id)\n        res += \" - Flags ----------- [0x%04x] %d\\n\" % (flags, flags)\n        res += \" - QdCount --------- [0x%04x] %d\\n\" % (qdcount, qdcount)\n        res += \" - AnCount --------- [0x%04x] %d\\n\" % (ancount, ancount)\n        res += \" - NsCount --------- [0x%04x] %d\\n\" % (nscount, nscount)\n        res += \" - ArCount --------- [0x%04x] %d\\n\" % (arcount, arcount)\n        \n        if qdcount > 0:\n            res += \" - Questions:\\n\"\n            questions = self.get_questions()\n            questions.reverse()\n            while(questions):\n                qname, qtype, qclass = questions.pop()\n                format = (str(qname.decode('ascii')), DNSType.getTypeName(qtype), qtype, DNSClass.getClassName(qclass), qclass)\n                res += \"  * Domain: %s - Type: %s [0x%04x] - Class: %s [0x%04x]\\n\" % format\n        \n        if ancount > 0:\n            res += \" - Answers:\\n\"\n            answers = self.get_answers()\n            answers.reverse()\n            while(answers):\n                qname, qtype, qclass, qttl, qrdata = answers.pop()\n                format = (str(qname.decode('ascii')), DNSType.getTypeName(qtype), qtype, DNSClass.getClassName(qclass), qclass, qttl, repr(qrdata))\n                res += \"  * Domain: %s - Type: %s [0x%04x] - Class: %s [0x%04x] - TTL: %d seconds - %s\\n\" % format\n        \n        if nscount > 0:\n            res += \" - Authoritative:\\n\"\n            authoritative = self.get_authoritative()\n            authoritative.reverse()\n            while(authoritative):\n                qname, qtype, qclass, qttl, qrdata = authoritative.pop()\n                format = (str(qname.decode('ascii')), DNSType.getTypeName(qtype), qtype, DNSClass.getClassName(qclass), qclass, qttl, repr(qrdata))\n                res += \"  * Domain: %s - Type: %s [0x%04x] - Class: %s [0x%04x] - TTL: %d seconds - %s\\n\" % format\n        \n        if arcount > 0:\n            res += \" - Additionals:\\n\"\n            additionals = self.get_additionals()\n            for additional in additionals:\n                qtype = additional[1]\n                if qtype == DNSType.OPT:\n                    \n                    qname, qtype, udp_payload_size, ext_rcode, version, flags, qrdata = additional\n                    format = (DNSType.getTypeName(qtype), qtype, udp_payload_size, ext_rcode, version, flags, repr(qrdata['RDATA']))\n                    res += \"  * Name: <Root> - Type: %s [0x%04x] - udp payload size: [%d] - extended RCODE: [0x%02x] - EDNS0 version: [0x%02x] - Z Flags: [0x%02x] - RDATA: [%s]\\n\" % format\n                else:\n                    qname, qtype, qclass, qttl, qrdata = additional\n                    format = (str(qname.decode('ascii')), DNSType.getTypeName(qtype), qtype, DNSClass.getClassName(qclass), qclass, qttl, repr(qrdata))\n                    res += \"  * Domain: %s - Type: %s [0x%04x] - Class: %s [0x%04x] - TTL: %d seconds - %s\\n\" % format\n        \n        return res\n \n    def __get_questions_raw(self):\n        if self.get_qdcount() == 0:\n            return ''\n        questions_offset = self.__get_questions()[1]\n        raw_data  = self.get_body_as_string()[:questions_offset]\n        return raw_data\n\n    def __get_answers_raw(self):\n        if self.get_ancount() == 0:\n            return ''\n        questions_offset = self.__get_questions()[1]\n        answers_offset = self.__get_answers()[1]\n        raw_data  = self.get_body_as_string()[questions_offset: answers_offset]\n        return raw_data\n\n    def __get_authoritative_raw(self):\n        if self.get_nscount() == 0:\n            return ''\n        answers_offset = self.__get_answers()[1]\n        authoritative_offset = self.__get_authoritative()[1]\n        raw_data  = self.get_body_as_string()[answers_offset:authoritative_offset]\n        return raw_data\n\n    def __get_additionals_raw(self):\n        if self.get_arcount() == 0:\n            return ''\n        authoritative_offset = self.__get_authoritative()[1]\n        raw_data  = self.get_body_as_string()[authoritative_offset:]\n        return raw_data\n\n    def add_answer(self, answer_raw):\n        '''Add a raw answer'''\n        questions_raw = self.__get_questions_raw()\n        answers_raw = self.__get_answers_raw()\n        authoritative_raw = self.__get_authoritative_raw()\n        additionals_raw = self.__get_additionals_raw()\n        \n        answers_raw += answer_raw\n        \n        body = questions_raw + answers_raw + authoritative_raw + additionals_raw\n        self.load_body(body) # It breaks children hierarchy\n        \n        # Increment the answer count  \n        cur_answer_count = self.get_ancount()+1\n        self.set_ancount(cur_answer_count)\n\n    def is_edns0(self):\n        additionals = self.get_additionals()\n        for item in additionals:\n            response_type = item[1]\n            if response_type == DNSType.OPT:\n                return True\n        return False",
  "def getTypeName(type):\n        for item, value in list(DNSType.__dict__.items()):\n            if value == type:\n                return item",
  "def getClassName(type):\n        for item, value in list(DNSClass.__dict__.items()):\n            if value == type:\n                return item",
  "def __init__(self, aBuffer = None):\n        self.__HEADER_BASE_SIZE = 12\n        self.__TAIL_SIZE        = 0\n        ProtocolPacket.__init__(self, self.__HEADER_BASE_SIZE, self.__TAIL_SIZE)\n        if aBuffer:\n            self.load_packet(aBuffer)",
  "def get_transaction_id(self):\n        'Get 16 bit message ID.'\n        return self.header.get_word(0)",
  "def set_transaction_id(self, value):\n        'Set 16 bit message ID.'\n        self.header.set_word(0, value)",
  "def get_transaction_id_tcp(self):\n        'Get 16 bit message ID.'\n        return self.header.get_word(2)",
  "def set_transaction_id_tcp(self, value):\n        'Set 16 bit message ID.'\n        self.header.set_word(2, value)",
  "def get_flags(self):\n        'Get 16 bit flags.'\n        return self.header.get_word(2)",
  "def set_flags(self, value):\n        'Set 16 bit flags.'\n        self.header.set_word(2, value)",
  "def get_flags_tcp(self):\n        'Get 16 bit flags.'\n        return self.header.get_word(4)",
  "def set_flags_tcp(self, value):\n        'Set 16 bit flags.'\n        self.header.set_word(4, value)",
  "def get_qdcount(self):\n        'Get Unsigned 16 bit integer specifying the number of entries in the question section.'\n        return self.header.get_word(4)",
  "def set_qdcount(self, value):\n        'Set Unsigned 16 bit integer specifying the number of entries in the question section.'\n        self.header.set_word(4, value)",
  "def get_qdcount_tcp(self):\n        'Get Unsigned 16 bit integer specifying the number of entries in the question section.'\n        return self.header.get_word(6)",
  "def set_qdcount_tcp(self, value):\n        'Set Unsigned 16 bit integer specifying the number of entries in the question section.'\n        self.header.set_word(6, value)",
  "def get_ancount(self):\n        'Get Unsigned 16 bit integer specifying the number of resource records in the answer section'\n        return self.header.get_word(6)",
  "def set_ancount(self, value):\n        'Set Unsigned 16 bit integer specifying the number of resource records in the answer section'\n        self.header.set_word(6, value)",
  "def get_nscount(self):\n        'Get Unsigned 16 bit integer specifying the number of name server resource records in the authority section.'\n        return self.header.get_word(8)",
  "def set_nscount(self, value):\n        'Set Unsigned 16 bit integer specifying the number of name server resource records in the authority section.'\n        self.header.set_word(8, value)",
  "def get_arcount(self):\n        'Get Unsigned 16 bit integer specifying the number of resource records in the additional records section.'\n        return self.header.get_word(10)",
  "def set_arcount(self, value):\n        'Set Unsigned 16 bit integer specifying the number of resource records in the additional records section.'\n        self.header.set_word(10, value)",
  "def get_questions(self):\n        'Get a list of the DNS Question.'\n        return self.__get_questions()[0]",
  "def __get_questions(self):\n        aux = []\n        offset   = 0\n        qdcount = self.get_qdcount()\n        data    = self.get_body_as_string()\n        for _ in range(qdcount): # number of questions\n            offset, qname = self.parseCompressedMessage(data, offset)\n            qtype  = data[offset:offset+self.__TYPE_LEN]\n            offset  += self.__TYPE_LEN\n            qclass = data[offset:offset+self.__CLASS_LEN]\n            offset  += self.__CLASS_LEN\n            qtype  = struct.unpack(\"!H\", qtype)[0]\n            qclass = struct.unpack(\"!H\", qclass)[0]\n            aux.append((qname, qtype, qclass))\n        return (aux, offset)",
  "def get_questions_tcp(self):\n        'Get a list of the DNS Question.'\n        return self.__get_questions_tcp()[0]",
  "def __get_questions_tcp(self):\n        aux = []\n        offset   = 2\n        qdcount = self.get_qdcount_tcp()\n        data    = self.get_body_as_string()\n        for _ in range(qdcount): # number of questions\n            offset, qname = self.parseCompressedMessage(data, offset)\n            qtype  = data[offset:offset+self.__TYPE_LEN]\n            offset  += self.__TYPE_LEN\n            qclass = data[offset:offset+self.__CLASS_LEN]\n            offset  += self.__CLASS_LEN\n            qtype  = struct.unpack(\"!H\", qtype)[0]\n            qclass = struct.unpack(\"!H\", qclass)[0]\n            aux.append((qname, qtype, qclass))\n        return (aux, offset)",
  "def parseCompressedMessage(self, buf, offset=0):\n        'Parse compressed message defined on rfc1035 4.1.4.'\n        if offset >= len(buf):\n            raise Exception(\"No more data to parse. Offset is bigger than length of buffer.\")\n        byte = struct.unpack(\"B\", buf[offset:offset+1])[0]\n        #  if the first two bits are ones (11000000=0xC0), the next bits are the offset\n        if byte & 0xC0 == 0xC0:\n            # It's a pointer\n            pointer = struct.unpack(\"!H\", buf[offset:offset+2])[0] # network unsigned short\n            pointer = (pointer & 0x3FFF) - self.__HEADER_BASE_SIZE\n            if offset == pointer:\n                raise Exception(\"The infinite loop is in DNS decompression. Encountered pointer points to the current offset.\")\n            offset += 2\n            name = self.parseCompressedMessage(buf, pointer)[1]\n            return (offset, name)\n        else:\n            # It's a label\n            if byte == 0x00:\n                offset += 1\n                return (offset, '')\n            offset += 1\n            name = buf[offset:offset+byte]\n            offset += byte\n            offset, unnamed = self.parseCompressedMessage(buf, offset)\n            if not unnamed:\n                return (offset, name)\n            else:\n                return (offset, name + b\".\" + unnamed)",
  "def get_answers(self):\n        return self.__get_answers()[0]",
  "def get_authoritative(self):\n        return self.__get_authoritative()[0]",
  "def get_additionals(self):\n        return self.__get_additionals()[0]",
  "def __get_answers(self):\n        offset  = self.__get_questions()[1] # get the initial offset\n        ancount = self.get_ancount()\n        return self.__process_answer_structure(offset, ancount)",
  "def __get_authoritative(self):\n        'Get a list of the DNS Authoritative.'\n        offset  = self.__get_answers()[1] # get the initial offset\n        nscount = self.get_nscount()\n        return self.__process_answer_structure(offset, nscount)",
  "def __get_additionals(self):\n        'Get a list of the DNS Additional Records.'\n        offset  = self.__get_authoritative()[1] # get the initial offset\n        arcount = self.get_arcount()\n        return self.__process_answer_structure(offset, arcount)",
  "def __process_answer_structure(self, offset, num):\n        aux  = []\n        data = self.get_body_as_string()\n        for _ in range(num):\n            offset, qname = self.parseCompressedMessage(data, offset)\n            qtype  = data[offset:offset+self.__TYPE_LEN]\n            qtype  = struct.unpack(\"!H\", qtype)[0]\n            offset  += self.__TYPE_LEN\n            \n            qclass = data[offset:offset+self.__CLASS_LEN]\n            qclass = struct.unpack(\"!H\", qclass)[0]\n            offset  += self.__CLASS_LEN\n            \n            qttl_raw = data[offset:offset+self.__TTL_LEN]\n            qttl = struct.unpack(\"!L\", qttl_raw)[0]\n            offset  += self.__TTL_LEN\n            \n            qrdlength = data[offset:offset+self.__RDLENGTH_LEN]\n            qrdlength = struct.unpack(\"!H\", qrdlength)[0]\n            offset  += self.__RDLENGTH_LEN\n            \n            qrdata = {}\n            if qtype == DNSType.A:\n                # IP Address  Unsigned 32-bit value representing the IP address\n                qrdata[\"IPAddress\"] = socket.inet_ntoa(data[offset:offset+qrdlength])\n                offset  += self.__TYPE_A_LEN\n            elif qtype == DNSType.SOA:\n                # Primary NS  Variable length. The name of the Primary Master for the domain. May be a label, pointer or any combination.\n                offset, primaryNs = self.parseCompressedMessage(data, offset)\n                qrdata[\"PrimaryNS\"] = primaryNs\n                # Admin MB  Variable length. The administrator's mailbox. May be a label, pointer or any combination.\n                offset, adminMb = self.parseCompressedMessage(data, offset)\n                qrdata[\"AdminMB\"] = adminMb\n                # Serial Number  Unsigned 32-bit integer.\n                qrdata[\"SerialNumber\"] = struct.unpack(\"!L\", data[offset:offset+self.__SERIAL_LEN])[0]\n                offset += self.__SERIAL_LEN\n                # Refresh interval  Unsigned 32-bit integer.\n                qrdata[\"RefreshInterval\"] = struct.unpack(\"!L\", data[offset:offset+self.__REFRESH_LEN])[0]\n                offset += self.__REFRESH_LEN\n                # Retry Interval  Unsigned 32-bit integer.\n                qrdata[\"RetryInterval\"] = struct.unpack(\"!L\", data[offset:offset+self.__RETRY_LEN])[0]\n                offset += self.__RETRY_LEN\n                # Expiration Limit  Unsigned 32-bit integer.\n                qrdata[\"ExpirationLimit\"] = struct.unpack(\"!L\", data[offset:offset+self.__EXPIRATION_LEN])[0]\n                offset += self.__EXPIRATION_LEN\n                # Minimum TTL  Unsigned 32-bit integer.\n                qrdata[\"MinimumTTL\"] = struct.unpack(\"!L\", data[offset:offset+self.__MINTTL_LEN])[0]\n                offset += self.__MINTTL_LEN\n            elif qtype == DNSType.MX:\n                # Preference  Unsigned 16-bit integer.\n                qrdata[\"Preference\"] = struct.unpack(\"!H\", data[offset:offset+self.__PREF_LEN])[0]\n                # Mail Exchanger  The name host name that provides the service. May be a label, pointer or any combination.\n                offset, mailExch = self.parseCompressedMessage(data, offset)\n                qrdata[\"MailExchanger\"] = mailExch\n            elif qtype == DNSType.PTR or qtype == DNSType.NS or qtype == DNSType.CNAME:\n                # Name  The host name that represents the supplied IP address (in the case of a PTR) or the NS name for the supplied domain (in the case of NS). May be a label, pointer or any combination.\n                offset, name = self.parseCompressedMessage(data, offset)\n                qrdata[\"Name\"] = str(name.decode('ascii'))\n            elif qtype == DNSType.OPT:\n                # rfc2671 4.3\n                #NAME         domain name    empty (root domain)\n                #TYPE         u_int16_t      OPT\n                #CLASS        u_int16_t      sender's UDP payload size\n                #TTL          u_int32_t      extended RCODE and flags\n                #RDLEN        u_int16_t      describes RDATA\n                #RDATA        octet stream   {attribute,value} pairs\n                #udp_payload = qclass\n                udp_payload_size = qclass\n                ext_rcode = struct.unpack(\"B\", qttl_raw[0:1])[0]\n                version = struct.unpack(\"B\", qttl_raw[1:2])[0]\n                flags = struct.unpack(\"!H\", qttl_raw[2:4])[0]\n                qrdata[\"RDATA\"] = data[offset:offset+qrdlength]\n                offset  += qrdlength\n                aux.append((qname, qtype, udp_payload_size, ext_rcode, version, flags, qrdata))\n                continue   \n            else:\n                # We don't know how to parse it, just skip it\n                offset  += qrdlength\n                \n            aux.append((qname, qtype, qclass, qttl, qrdata))\n        return (aux, offset)",
  "def get_header_size(self):\n        return self.__HEADER_BASE_SIZE",
  "def __str__(self):\n        res = \"\"\n        \n        id      = self.get_transaction_id()\n        flags   = self.get_flags()\n        qdcount = self.get_qdcount()\n        ancount = self.get_ancount()\n        nscount = self.get_nscount()\n        arcount = self.get_arcount()\n        \n        res += \"DNS \"\n        if flags & DNSFlags.QR_RESPONSE:\n            res += \"RESPONSE\\n\"\n        else:\n            res += \"QUERY\\n\"\n        \n        res += \" - Transaction ID -- [0x%04x] %d\\n\" % (id, id)\n        res += \" - Flags ----------- [0x%04x] %d\\n\" % (flags, flags)\n        res += \" - QdCount --------- [0x%04x] %d\\n\" % (qdcount, qdcount)\n        res += \" - AnCount --------- [0x%04x] %d\\n\" % (ancount, ancount)\n        res += \" - NsCount --------- [0x%04x] %d\\n\" % (nscount, nscount)\n        res += \" - ArCount --------- [0x%04x] %d\\n\" % (arcount, arcount)\n        \n        if qdcount > 0:\n            res += \" - Questions:\\n\"\n            questions = self.get_questions()\n            questions.reverse()\n            while(questions):\n                qname, qtype, qclass = questions.pop()\n                format = (str(qname.decode('ascii')), DNSType.getTypeName(qtype), qtype, DNSClass.getClassName(qclass), qclass)\n                res += \"  * Domain: %s - Type: %s [0x%04x] - Class: %s [0x%04x]\\n\" % format\n        \n        if ancount > 0:\n            res += \" - Answers:\\n\"\n            answers = self.get_answers()\n            answers.reverse()\n            while(answers):\n                qname, qtype, qclass, qttl, qrdata = answers.pop()\n                format = (str(qname.decode('ascii')), DNSType.getTypeName(qtype), qtype, DNSClass.getClassName(qclass), qclass, qttl, repr(qrdata))\n                res += \"  * Domain: %s - Type: %s [0x%04x] - Class: %s [0x%04x] - TTL: %d seconds - %s\\n\" % format\n        \n        if nscount > 0:\n            res += \" - Authoritative:\\n\"\n            authoritative = self.get_authoritative()\n            authoritative.reverse()\n            while(authoritative):\n                qname, qtype, qclass, qttl, qrdata = authoritative.pop()\n                format = (str(qname.decode('ascii')), DNSType.getTypeName(qtype), qtype, DNSClass.getClassName(qclass), qclass, qttl, repr(qrdata))\n                res += \"  * Domain: %s - Type: %s [0x%04x] - Class: %s [0x%04x] - TTL: %d seconds - %s\\n\" % format\n        \n        if arcount > 0:\n            res += \" - Additionals:\\n\"\n            additionals = self.get_additionals()\n            for additional in additionals:\n                qtype = additional[1]\n                if qtype == DNSType.OPT:\n                    \n                    qname, qtype, udp_payload_size, ext_rcode, version, flags, qrdata = additional\n                    format = (DNSType.getTypeName(qtype), qtype, udp_payload_size, ext_rcode, version, flags, repr(qrdata['RDATA']))\n                    res += \"  * Name: <Root> - Type: %s [0x%04x] - udp payload size: [%d] - extended RCODE: [0x%02x] - EDNS0 version: [0x%02x] - Z Flags: [0x%02x] - RDATA: [%s]\\n\" % format\n                else:\n                    qname, qtype, qclass, qttl, qrdata = additional\n                    format = (str(qname.decode('ascii')), DNSType.getTypeName(qtype), qtype, DNSClass.getClassName(qclass), qclass, qttl, repr(qrdata))\n                    res += \"  * Domain: %s - Type: %s [0x%04x] - Class: %s [0x%04x] - TTL: %d seconds - %s\\n\" % format\n        \n        return res",
  "def __get_questions_raw(self):\n        if self.get_qdcount() == 0:\n            return ''\n        questions_offset = self.__get_questions()[1]\n        raw_data  = self.get_body_as_string()[:questions_offset]\n        return raw_data",
  "def __get_answers_raw(self):\n        if self.get_ancount() == 0:\n            return ''\n        questions_offset = self.__get_questions()[1]\n        answers_offset = self.__get_answers()[1]\n        raw_data  = self.get_body_as_string()[questions_offset: answers_offset]\n        return raw_data",
  "def __get_authoritative_raw(self):\n        if self.get_nscount() == 0:\n            return ''\n        answers_offset = self.__get_answers()[1]\n        authoritative_offset = self.__get_authoritative()[1]\n        raw_data  = self.get_body_as_string()[answers_offset:authoritative_offset]\n        return raw_data",
  "def __get_additionals_raw(self):\n        if self.get_arcount() == 0:\n            return ''\n        authoritative_offset = self.__get_authoritative()[1]\n        raw_data  = self.get_body_as_string()[authoritative_offset:]\n        return raw_data",
  "def add_answer(self, answer_raw):\n        '''Add a raw answer'''\n        questions_raw = self.__get_questions_raw()\n        answers_raw = self.__get_answers_raw()\n        authoritative_raw = self.__get_authoritative_raw()\n        additionals_raw = self.__get_additionals_raw()\n        \n        answers_raw += answer_raw\n        \n        body = questions_raw + answers_raw + authoritative_raw + additionals_raw\n        self.load_body(body) # It breaks children hierarchy\n        \n        # Increment the answer count  \n        cur_answer_count = self.get_ancount()+1\n        self.set_ancount(cur_answer_count)",
  "def is_edns0(self):\n        additionals = self.get_additionals()\n        for item in additionals:\n            response_type = item[1]\n            if response_type == DNSType.OPT:\n                return True\n        return False",
  "class SMBConnection:\n    \"\"\"\n    SMBConnection class\n\n    :param string remoteName: name of the remote host, can be its NETBIOS name, IP or *\\\\*SMBSERVER*.  If the later,\n           and port is 139, the library will try to get the target's server name.\n    :param string remoteHost: target server's remote address (IPv4, IPv6) or FQDN\n    :param string/optional myName: client's NETBIOS name\n    :param integer/optional sess_port: target port to connect\n    :param integer/optional timeout: timeout in seconds when receiving packets\n    :param optional preferredDialect: the dialect desired to talk with the target server. If not specified the highest\n           one available will be used\n    :param optional boolean manualNegotiate: the user manually performs SMB_COM_NEGOTIATE\n\n    :return: a SMBConnection instance, if not raises a SessionError exception\n    \"\"\"\n\n    def __init__(self, remoteName='', remoteHost='', myName=None, sess_port=nmb.SMB_SESSION_PORT, timeout=60, preferredDialect=None,\n                 existingConnection=None, manualNegotiate=False):\n\n        self._SMBConnection = 0\n        self._dialect       = ''\n        self._nmbSession    = 0\n        self._sess_port     = sess_port\n        self._myName        = myName\n        self._remoteHost    = remoteHost\n        self._remoteName    = remoteName\n        self._timeout       = timeout\n        self._preferredDialect = preferredDialect\n        self._existingConnection = existingConnection\n        self._manualNegotiate = manualNegotiate\n        self._doKerberos = False\n        self._kdcHost = None\n        self._useCache = True\n        self._ntlmFallback = True\n\n        if existingConnection is not None:\n            # Existing Connection must be a smb or smb3 instance\n            assert ( isinstance(existingConnection,smb.SMB) or isinstance(existingConnection, smb3.SMB3))\n            self._SMBConnection = existingConnection\n            self._preferredDialect = self._SMBConnection.getDialect()\n            self._doKerberos = self._SMBConnection.getKerberos()\n            return\n\n        ##preferredDialect = smb.SMB_DIALECT\n\n        if manualNegotiate is False:\n            self.negotiateSession(preferredDialect)\n\n    def negotiateSession(self, preferredDialect=None,\n                         flags1=smb.SMB.FLAGS1_PATHCASELESS | smb.SMB.FLAGS1_CANONICALIZED_PATHS,\n                         flags2=smb.SMB.FLAGS2_EXTENDED_SECURITY | smb.SMB.FLAGS2_NT_STATUS | smb.SMB.FLAGS2_LONG_NAMES,\n                         negoData='\\x02NT LM 0.12\\x00\\x02SMB 2.002\\x00\\x02SMB 2.???\\x00'):\n        \"\"\"\n        Perform protocol negotiation\n\n        :param string preferredDialect: the dialect desired to talk with the target server. If None is specified the highest one available will be used\n        :param string flags1: the SMB FLAGS capabilities\n        :param string flags2: the SMB FLAGS2 capabilities\n        :param string negoData: data to be sent as part of the nego handshake\n\n        :return: True\n        :raise SessionError: if error\n        \"\"\"\n\n        # If port 445 and the name sent is *SMBSERVER we're setting the name to the IP. This is to help some old\n        # applications still believing\n        # *SMSBSERVER will work against modern OSes. If port is NETBIOS_SESSION_PORT the user better know about i\n        # *SMBSERVER's limitations\n        if self._sess_port == nmb.SMB_SESSION_PORT and self._remoteName == '*SMBSERVER':\n            self._remoteName = self._remoteHost\n        elif self._sess_port == nmb.NETBIOS_SESSION_PORT and self._remoteName == '*SMBSERVER':\n            # If remote name is *SMBSERVER let's try to query its name.. if can't be guessed, continue and hope for the best\n            nb = nmb.NetBIOS()\n            try:\n                res = nb.getnetbiosname(self._remoteHost)\n            except:\n                pass\n            else:\n                self._remoteName = res\n\n        if self._sess_port == nmb.NETBIOS_SESSION_PORT:\n            negoData = '\\x02NT LM 0.12\\x00\\x02SMB 2.002\\x00'\n\n        hostType = nmb.TYPE_SERVER\n        if preferredDialect is None:\n            # If no preferredDialect sent, we try the highest available one.\n            packet = self.negotiateSessionWildcard(self._myName, self._remoteName, self._remoteHost, self._sess_port,\n                                                   self._timeout, True, flags1=flags1, flags2=flags2, data=negoData)\n            if packet[0:1] == b'\\xfe':\n                # Answer is SMB2 packet\n                self._SMBConnection = smb3.SMB3(self._remoteName, self._remoteHost, self._myName, hostType,\n                                                self._sess_port, self._timeout, session=self._nmbSession,\n                                                negSessionResponse=SMB2Packet(packet))\n            else:\n                # Answer is SMB packet, sticking to SMBv1\n                self._SMBConnection = smb.SMB(self._remoteName, self._remoteHost, self._myName, hostType,\n                                              self._sess_port, self._timeout, session=self._nmbSession,\n                                              negPacket=packet)\n        else:\n            if preferredDialect == smb.SMB_DIALECT:\n                self._SMBConnection = smb.SMB(self._remoteName, self._remoteHost, self._myName, hostType,\n                                              self._sess_port, self._timeout)\n            elif preferredDialect in [SMB2_DIALECT_002, SMB2_DIALECT_21, SMB2_DIALECT_30, SMB2_DIALECT_311]:\n                self._SMBConnection = smb3.SMB3(self._remoteName, self._remoteHost, self._myName, hostType,\n                                                self._sess_port, self._timeout, preferredDialect=preferredDialect)\n            else:\n                raise Exception(\"Unknown dialect %s\")\n\n        # propagate flags to the smb sub-object, except for Unicode (if server supports)\n        # does not affect smb3 objects\n        if isinstance(self._SMBConnection, smb.SMB):\n            if self._SMBConnection.get_flags()[1] & smb.SMB.FLAGS2_UNICODE:\n                flags2 |= smb.SMB.FLAGS2_UNICODE\n            self._SMBConnection.set_flags(flags1=flags1, flags2=flags2)\n\n        return True\n\n    def negotiateSessionWildcard(self, myName, remoteName, remoteHost, sess_port, timeout, extended_security=True, flags1=0,\n                                 flags2=0, data=None):\n        # Here we follow [MS-SMB2] negotiation handshake trying to understand what dialects\n        # (including SMB1) is supported on the other end.\n\n        if not myName:\n            myName = socket.gethostname()\n            i = myName.find('.')\n            if i > -1:\n                myName = myName[:i]\n\n        tries = 0\n        smbp = smb.NewSMBPacket()\n        smbp['Flags1'] = flags1\n        # FLAGS2_UNICODE is required by some stacks to continue, regardless of subsequent support\n        smbp['Flags2'] = flags2 | smb.SMB.FLAGS2_UNICODE\n        resp = None\n        while tries < 2:\n            self._nmbSession = nmb.NetBIOSTCPSession(myName, remoteName, remoteHost, nmb.TYPE_SERVER, sess_port,\n                                                     timeout)\n\n            negSession = smb.SMBCommand(smb.SMB.SMB_COM_NEGOTIATE)\n            if extended_security is True:\n                smbp['Flags2'] |= smb.SMB.FLAGS2_EXTENDED_SECURITY\n            negSession['Data'] = data\n            smbp.addCommand(negSession)\n            self._nmbSession.send_packet(smbp.getData())\n\n            try:\n                resp = self._nmbSession.recv_packet(timeout)\n                break\n            except nmb.NetBIOSError:\n                # OSX Yosemite asks for more Flags. Let's give it a try and see what happens\n                smbp['Flags2'] |= smb.SMB.FLAGS2_NT_STATUS | smb.SMB.FLAGS2_LONG_NAMES | smb.SMB.FLAGS2_UNICODE\n                smbp['Data'] = []\n\n            tries += 1\n\n        if resp is None:\n            # No luck, quitting\n            raise Exception('No answer!')\n\n        return resp.get_trailer()\n\n\n    def getNMBServer(self):\n        return self._nmbSession\n\n    def getSMBServer(self):\n        \"\"\"\n        returns the SMB/SMB3 instance being used. Useful for calling low level methods\n        \"\"\"\n        return self._SMBConnection\n\n    def getDialect(self):\n        return self._SMBConnection.getDialect()\n\n    def getServerName(self):\n        return self._SMBConnection.get_server_name()\n\n    def getClientName(self):\n        return self._SMBConnection.get_client_name()\n\n    def getRemoteHost(self):\n        return self._SMBConnection.get_remote_host()\n\n    def getRemoteName(self):\n        return self._SMBConnection.get_remote_name()\n\n    def setRemoteName(self, name):\n        return self._SMBConnection.set_remote_name(name)\n\n    def getServerDomain(self):\n        return self._SMBConnection.get_server_domain()\n\n    def getServerDNSDomainName(self):\n        return self._SMBConnection.get_server_dns_domain_name()\n\n    def getServerDNSHostName(self):\n        return self._SMBConnection.get_server_dns_host_name()\n\n    def getServerOS(self):\n        return self._SMBConnection.get_server_os()\n\n    def getServerOSMajor(self):\n        return self._SMBConnection.get_server_os_major()\n\n    def getServerOSMinor(self):\n        return self._SMBConnection.get_server_os_minor()\n\n    def getServerOSBuild(self):\n        return self._SMBConnection.get_server_os_build()\n\n    def doesSupportNTLMv2(self):\n        return self._SMBConnection.doesSupportNTLMv2()\n\n    def isLoginRequired(self):\n        return self._SMBConnection.is_login_required()\n\n    def isSigningRequired(self):\n        return self._SMBConnection.is_signing_required()\n\n    def getCredentials(self):\n        return self._SMBConnection.getCredentials()\n\n    def getIOCapabilities(self):\n        return self._SMBConnection.getIOCapabilities()\n\n    def login(self, user, password, domain = '', lmhash = '', nthash = '', ntlmFallback = True):\n        \"\"\"\n        logins into the target system\n\n        :param string user: username\n        :param string password: password for the user\n        :param string domain: domain where the account is valid for\n        :param string lmhash: LMHASH used to authenticate using hashes (password is not used)\n        :param string nthash: NTHASH used to authenticate using hashes (password is not used)\n        :param bool ntlmFallback: If True it will try NTLMv1 authentication if NTLMv2 fails. Only available for SMBv1\n\n        :return: None\n        :raise SessionError: if error\n        \"\"\"\n        self._ntlmFallback = ntlmFallback\n        try:\n            if self.getDialect() == smb.SMB_DIALECT:\n                return self._SMBConnection.login(user, password, domain, lmhash, nthash, ntlmFallback)\n            else:\n                return self._SMBConnection.login(user, password, domain, lmhash, nthash)\n        except (smb.SessionError, smb3.SessionError) as e:\n            raise SessionError(e.get_error_code(), e.get_error_packet())\n\n    def kerberosLogin(self, user, password, domain='', lmhash='', nthash='', aesKey='', kdcHost=None, TGT=None,\n                      TGS=None, useCache=True):\n        \"\"\"\n        logins into the target system explicitly using Kerberos. Hashes are used if RC4_HMAC is supported.\n\n        :param string user: username\n        :param string password: password for the user\n        :param string domain: domain where the account is valid for (required)\n        :param string lmhash: LMHASH used to authenticate using hashes (password is not used)\n        :param string nthash: NTHASH used to authenticate using hashes (password is not used)\n        :param string aesKey: aes256-cts-hmac-sha1-96 or aes128-cts-hmac-sha1-96 used for Kerberos authentication\n        :param string kdcHost: hostname or IP Address for the KDC. If None, the domain will be used (it needs to resolve tho)\n        :param struct TGT: If there's a TGT available, send the structure here and it will be used\n        :param struct TGS: same for TGS. See smb3.py for the format\n        :param bool useCache: whether or not we should use the ccache for credentials lookup. If TGT or TGS are specified this is False\n\n        :return: None\n        :raise SessionError: if error\n        \"\"\"\n        from impacket.krb5.ccache import CCache\n        from impacket.krb5.kerberosv5 import KerberosError\n        from impacket.krb5 import constants\n\n        self._kdcHost = kdcHost\n        self._useCache = useCache\n\n        if TGT is not None or TGS is not None:\n            useCache = False\n\n        if useCache:\n            domain, user, TGT, TGS = CCache.parseFile(domain, user, 'cifs/%s' % self.getRemoteName())\n\n        while True:\n            try:\n                if self.getDialect() == smb.SMB_DIALECT:\n                    return self._SMBConnection.kerberos_login(user, password, domain, lmhash, nthash, aesKey, kdcHost,\n                                                              TGT, TGS)\n                return self._SMBConnection.kerberosLogin(user, password, domain, lmhash, nthash, aesKey, kdcHost, TGT,\n                                                         TGS)\n            except (smb.SessionError, smb3.SessionError) as e:\n                raise SessionError(e.get_error_code(), e.get_error_packet())\n            except KerberosError as e:\n                if e.getErrorCode() == constants.ErrorCodes.KDC_ERR_ETYPE_NOSUPP.value:\n                    # We might face this if the target does not support AES\n                    # So, if that's the case we'll force using RC4 by converting\n                    # the password to lm/nt hashes and hope for the best. If that's already\n                    # done, byebye.\n                    if lmhash == '' and nthash == '' and (aesKey == '' or aesKey is None) and TGT is None and TGS is None:\n                        lmhash = compute_lmhash(password)\n                        nthash = compute_nthash(password)\n                    else:\n                        raise e\n                else:\n                    raise e\n\n    def isGuestSession(self):\n        try:\n            return self._SMBConnection.isGuestSession()\n        except (smb.SessionError, smb3.SessionError) as e:\n            raise SessionError(e.get_error_code(), e.get_error_packet())\n\n    def logoff(self):\n        try:\n            return self._SMBConnection.logoff()\n        except (smb.SessionError, smb3.SessionError) as e:\n            raise SessionError(e.get_error_code(), e.get_error_packet())\n\n\n    def connectTree(self,share):\n        if self.getDialect() == smb.SMB_DIALECT:\n            # If we already have a UNC we do nothing.\n            if ntpath.ismount(share) is False:\n                # Else we build it\n                share = ntpath.basename(share)\n                share = '\\\\\\\\' + self.getRemoteHost() + '\\\\' + share\n        try:\n            return self._SMBConnection.connect_tree(share)\n        except (smb.SessionError, smb3.SessionError) as e:\n            raise SessionError(e.get_error_code(), e.get_error_packet())\n\n\n    def disconnectTree(self, treeId):\n        try:\n            return self._SMBConnection.disconnect_tree(treeId)\n        except (smb.SessionError, smb3.SessionError) as e:\n            raise SessionError(e.get_error_code(), e.get_error_packet())\n\n\n    def listShares(self):\n        \"\"\"\n        get a list of available shares at the connected target\n\n        :return: a list containing dict entries for each share\n        :raise SessionError: if error\n        \"\"\"\n        # Get the shares through RPC\n        from impacket.dcerpc.v5 import transport, srvs\n        rpctransport = transport.SMBTransport(self.getRemoteName(), self.getRemoteHost(), filename=r'\\srvsvc',\n                                              smb_connection=self)\n        dce = rpctransport.get_dce_rpc()\n        dce.connect()\n        dce.bind(srvs.MSRPC_UUID_SRVS)\n        resp = srvs.hNetrShareEnum(dce, 1)\n        return resp['InfoStruct']['ShareInfo']['Level1']['Buffer']\n\n    def listPath(self, shareName, path, password = None):\n        \"\"\"\n        list the files/directories under shareName/path\n\n        :param string shareName: a valid name for the share where the files/directories are going to be searched\n        :param string path: a base path relative to shareName\n        :param string password: the password for the share\n\n        :return: a list containing smb.SharedFile items\n        :raise SessionError: if error\n        \"\"\"\n\n        try:\n            return self._SMBConnection.list_path(shareName, path, password)\n        except (smb.SessionError, smb3.SessionError) as e:\n            raise SessionError(e.get_error_code(), e.get_error_packet())\n\n    def createFile(self, treeId, pathName, desiredAccess=GENERIC_ALL,\n                   shareMode=FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,\n                   creationOption=FILE_NON_DIRECTORY_FILE, creationDisposition=FILE_OVERWRITE_IF,\n                   fileAttributes=FILE_ATTRIBUTE_NORMAL, impersonationLevel=SMB2_IL_IMPERSONATION, securityFlags=0,\n                   oplockLevel=SMB2_OPLOCK_LEVEL_NONE, createContexts=None):\n        \"\"\"\n        Creates a remote file\n\n        :param HANDLE treeId: a valid handle for the share where the file is to be created\n        :param string pathName: the path name of the file to create\n        :param int desiredAccess: The level of access that is required, as specified in https://msdn.microsoft.com/en-us/library/cc246503.aspx\n        :param int shareMode: Specifies the sharing mode for the open.\n        :param int creationOption: Specifies the options to be applied when creating or opening the file.\n        :param int creationDisposition: Defines the action the server MUST take if the file that is specified in the name\n        field already exists.\n        :param int fileAttributes: This field MUST be a combination of the values specified in [MS-FSCC] section 2.6, and MUST NOT include any values other than those specified in that section.\n        :param int impersonationLevel: This field specifies the impersonation level requested by the application that is issuing the create request.\n        :param int securityFlags: This field MUST NOT be used and MUST be reserved. The client MUST set this to 0, and the server MUST ignore it.\n        :param int oplockLevel: The requested oplock level\n        :param createContexts: A variable-length attribute that is sent with an SMB2 CREATE Request or SMB2 CREATE Response that either gives extra information about how the create will be processed, or returns extra information about how the create was processed.\n\n        :return: a valid file descriptor\n        :raise SessionError: if error\n        \"\"\"\n        if self.getDialect() == smb.SMB_DIALECT:\n            _, flags2 = self._SMBConnection.get_flags()\n\n            pathName = pathName.replace('/', '\\\\')\n            packetPathName = pathName.encode('utf-16le') if flags2 & smb.SMB.FLAGS2_UNICODE else pathName\n\n            ntCreate = smb.SMBCommand(smb.SMB.SMB_COM_NT_CREATE_ANDX)\n            ntCreate['Parameters'] = smb.SMBNtCreateAndX_Parameters()\n            ntCreate['Data']       = smb.SMBNtCreateAndX_Data(flags=flags2)\n            ntCreate['Parameters']['FileNameLength']= len(packetPathName)\n            ntCreate['Parameters']['AccessMask']    = desiredAccess\n            ntCreate['Parameters']['FileAttributes']= fileAttributes\n            ntCreate['Parameters']['ShareAccess']   = shareMode\n            ntCreate['Parameters']['Disposition']   = creationDisposition\n            ntCreate['Parameters']['CreateOptions'] = creationOption\n            ntCreate['Parameters']['Impersonation'] = impersonationLevel\n            ntCreate['Parameters']['SecurityFlags'] = securityFlags\n            ntCreate['Parameters']['CreateFlags']   = 0x16\n            ntCreate['Data']['FileName'] = packetPathName\n\n            if flags2 & smb.SMB.FLAGS2_UNICODE:\n                ntCreate['Data']['Pad'] = 0x0\n\n            if createContexts is not None:\n                LOG.error(\"CreateContexts not supported in SMB1\")\n\n            try:\n                return self._SMBConnection.nt_create_andx(treeId, pathName, cmd = ntCreate)\n            except (smb.SessionError, smb3.SessionError) as e:\n                raise SessionError(e.get_error_code(), e.get_error_packet())\n        else:\n            try:\n                return self._SMBConnection.create(treeId, pathName, desiredAccess, shareMode, creationOption,\n                                                  creationDisposition, fileAttributes, impersonationLevel,\n                                                  securityFlags, oplockLevel, createContexts)\n            except (smb.SessionError, smb3.SessionError) as e:\n                raise SessionError(e.get_error_code(), e.get_error_packet())\n\n    def openFile(self, treeId, pathName, desiredAccess=FILE_READ_DATA | FILE_WRITE_DATA, shareMode=FILE_SHARE_READ,\n                 creationOption=FILE_NON_DIRECTORY_FILE, creationDisposition=FILE_OPEN,\n                 fileAttributes=FILE_ATTRIBUTE_NORMAL, impersonationLevel=SMB2_IL_IMPERSONATION, securityFlags=0,\n                 oplockLevel=SMB2_OPLOCK_LEVEL_NONE, createContexts=None):\n        \"\"\"\n        opens a remote file\n\n        :param HANDLE treeId: a valid handle for the share where the file is to be opened\n        :param string pathName: the path name to open\n        :param int desiredAccess: The level of access that is required, as specified in https://msdn.microsoft.com/en-us/library/cc246503.aspx\n        :param int shareMode: Specifies the sharing mode for the open.\n        :param int creationOption: Specifies the options to be applied when creating or opening the file.\n        :param int creationDisposition: Defines the action the server MUST take if the file that is specified in the name\n        field already exists.\n        :param int fileAttributes: This field MUST be a combination of the values specified in [MS-FSCC] section 2.6, and MUST NOT include any values other than those specified in that section.\n        :param int impersonationLevel: This field specifies the impersonation level requested by the application that is issuing the create request.\n        :param int securityFlags: This field MUST NOT be used and MUST be reserved. The client MUST set this to 0, and the server MUST ignore it.\n        :param int oplockLevel: The requested oplock level\n        :param createContexts: A variable-length attribute that is sent with an SMB2 CREATE Request or SMB2 CREATE Response that either gives extra information about how the create will be processed, or returns extra information about how the create was processed.\n\n        :return: a valid file descriptor\n        :raise SessionError: if error\n        \"\"\"\n\n        if self.getDialect() == smb.SMB_DIALECT:\n            _, flags2 = self._SMBConnection.get_flags()\n\n            pathName = pathName.replace('/', '\\\\')\n            packetPathName = pathName.encode('utf-16le') if flags2 & smb.SMB.FLAGS2_UNICODE else pathName\n\n            ntCreate = smb.SMBCommand(smb.SMB.SMB_COM_NT_CREATE_ANDX)\n            ntCreate['Parameters'] = smb.SMBNtCreateAndX_Parameters()\n            ntCreate['Data']       = smb.SMBNtCreateAndX_Data(flags=flags2)\n            ntCreate['Parameters']['FileNameLength']= len(packetPathName)\n            ntCreate['Parameters']['AccessMask']    = desiredAccess\n            ntCreate['Parameters']['FileAttributes']= fileAttributes\n            ntCreate['Parameters']['ShareAccess']   = shareMode\n            ntCreate['Parameters']['Disposition']   = creationDisposition\n            ntCreate['Parameters']['CreateOptions'] = creationOption\n            ntCreate['Parameters']['Impersonation'] = impersonationLevel\n            ntCreate['Parameters']['SecurityFlags'] = securityFlags\n            ntCreate['Parameters']['CreateFlags']   = 0x16\n            ntCreate['Data']['FileName'] = packetPathName\n\n            if flags2 & smb.SMB.FLAGS2_UNICODE:\n                ntCreate['Data']['Pad'] = 0x0\n\n            if createContexts is not None:\n                LOG.error(\"CreateContexts not supported in SMB1\")\n\n            try:\n                return self._SMBConnection.nt_create_andx(treeId, pathName, cmd = ntCreate)\n            except (smb.SessionError, smb3.SessionError) as e:\n                raise SessionError(e.get_error_code(), e.get_error_packet())\n        else:\n            try:\n                return self._SMBConnection.create(treeId, pathName, desiredAccess, shareMode, creationOption,\n                                                  creationDisposition, fileAttributes, impersonationLevel,\n                                                  securityFlags, oplockLevel, createContexts)\n            except (smb.SessionError, smb3.SessionError) as e:\n                raise SessionError(e.get_error_code(), e.get_error_packet())\n\n    def writeFile(self, treeId, fileId, data, offset=0):\n        \"\"\"\n        writes data to a file\n\n        :param HANDLE treeId: a valid handle for the share where the file is to be written\n        :param HANDLE fileId: a valid handle for the file\n        :param string data: buffer with the data to write\n        :param integer offset: offset where to start writing the data\n\n        :return: amount of bytes written\n        :raise SessionError: if error\n        \"\"\"\n        try:\n            return self._SMBConnection.writeFile(treeId, fileId, data, offset)\n        except (smb.SessionError, smb3.SessionError) as e:\n            raise SessionError(e.get_error_code(), e.get_error_packet())\n\n    def readFile(self, treeId, fileId, offset = 0, bytesToRead = None, singleCall = True):\n        \"\"\"\n        reads data from a file\n\n        :param HANDLE treeId: a valid handle for the share where the file is to be read\n        :param HANDLE fileId: a valid handle for the file to be read\n        :param integer offset: offset where to start reading the data\n        :param integer bytesToRead: amount of bytes to attempt reading. If None, it will attempt to read Dialect['MaxBufferSize'] bytes.\n        :param boolean singleCall: If True it won't attempt to read all bytesToRead. It will only make a single read call\n\n        :return: the data read. Length of data read is not always bytesToRead\n        :raise SessionError: if error\n        \"\"\"\n        finished = False\n        data = b''\n        maxReadSize = self._SMBConnection.getIOCapabilities()['MaxReadSize']\n        if bytesToRead is None:\n            bytesToRead = maxReadSize\n        remainingBytesToRead = bytesToRead\n        while not finished:\n            if remainingBytesToRead > maxReadSize:\n                toRead = maxReadSize\n            else:\n                toRead = remainingBytesToRead\n            try:\n                bytesRead = self._SMBConnection.read_andx(treeId, fileId, offset, toRead)\n            except (smb.SessionError, smb3.SessionError) as e:\n                if e.get_error_code() == nt_errors.STATUS_END_OF_FILE:\n                    toRead = b''\n                    break\n                else:\n                    raise SessionError(e.get_error_code(), e.get_error_packet())\n\n            data += bytesRead\n            if len(data) >= bytesToRead:\n                finished = True\n            elif len(bytesRead) == 0:\n                # End of the file achieved.\n                finished = True\n            elif singleCall is True:\n                finished = True\n            else:\n                offset += len(bytesRead)\n                remainingBytesToRead -= len(bytesRead)\n\n        return data\n\n    def closeFile(self, treeId, fileId):\n        \"\"\"\n        closes a file handle\n\n        :param HANDLE treeId: a valid handle for the share where the file is to be opened\n        :param HANDLE fileId: a valid handle for the file/directory to be closed\n\n        :return: None\n        :raise SessionError: if error\n        \"\"\"\n        try:\n            return self._SMBConnection.close(treeId, fileId)\n        except (smb.SessionError, smb3.SessionError) as e:\n            raise SessionError(e.get_error_code(), e.get_error_packet())\n\n    def deleteFile(self, shareName, pathName):\n        \"\"\"\n        removes a file\n\n        :param string shareName: a valid name for the share where the file is to be deleted\n        :param string pathName: the path name to remove\n\n        :return: None\n        :raise SessionError: if error\n        \"\"\"\n        try:\n            return self._SMBConnection.remove(shareName, pathName)\n        except (smb.SessionError, smb3.SessionError) as e:\n            raise SessionError(e.get_error_code(), e.get_error_packet())\n\n    def queryInfo(self, treeId, fileId):\n        \"\"\"\n        queries basic information about an opened file/directory\n\n        :param HANDLE treeId: a valid handle for the share where the file is to be queried\n        :param HANDLE fileId: a valid handle for the file/directory to be queried\n\n        :return: a smb.SMBQueryFileStandardInfo structure.\n        :raise SessionError: if error\n        \"\"\"\n        try:\n            if self.getDialect() == smb.SMB_DIALECT:\n                res = self._SMBConnection.query_file_info(treeId, fileId)\n            else:\n                res = self._SMBConnection.queryInfo(treeId, fileId)\n            return smb.SMBQueryFileStandardInfo(res)\n        except (smb.SessionError, smb3.SessionError) as e:\n            raise SessionError(e.get_error_code(), e.get_error_packet())\n\n    def createDirectory(self, shareName, pathName ):\n        \"\"\"\n        creates a directory\n\n        :param string shareName: a valid name for the share where the directory is to be created\n        :param string pathName: the path name or the directory to create\n\n        :return: None\n        :raise SessionError: if error\n        \"\"\"\n        try:\n            return self._SMBConnection.mkdir(shareName, pathName)\n        except (smb.SessionError, smb3.SessionError) as e:\n            raise SessionError(e.get_error_code(), e.get_error_packet())\n\n    def deleteDirectory(self, shareName, pathName):\n        \"\"\"\n        deletes a directory\n\n        :param string shareName: a valid name for the share where directory is to be deleted\n        :param string pathName: the path name or the directory to delete\n\n        :return: None\n        :raise SessionError: if error\n        \"\"\"\n        try:\n            return self._SMBConnection.rmdir(shareName, pathName)\n        except (smb.SessionError, smb3.SessionError) as e:\n            raise SessionError(e.get_error_code(), e.get_error_packet())\n\n    def waitNamedPipe(self, treeId, pipeName, timeout = 5):\n        \"\"\"\n        waits for a named pipe\n\n        :param HANDLE treeId: a valid handle for the share where the pipe is\n        :param string pipeName: the pipe name to check\n        :param integer timeout: time to wait for an answer\n\n        :return: None\n        :raise SessionError: if error\n        \"\"\"\n        try:\n            return self._SMBConnection.waitNamedPipe(treeId, pipeName, timeout = timeout)\n        except (smb.SessionError, smb3.SessionError) as e:\n            raise SessionError(e.get_error_code(), e.get_error_packet())\n\n    def transactNamedPipe(self, treeId, fileId, data, waitAnswer = True):\n        \"\"\"\n        writes to a named pipe using a transaction command\n\n        :param HANDLE treeId: a valid handle for the share where the pipe is\n        :param HANDLE fileId: a valid handle for the pipe\n        :param string data: buffer with the data to write\n        :param boolean waitAnswer: whether or not to wait for an answer\n\n        :return: None\n        :raise SessionError: if error\n        \"\"\"\n        try:\n            return self._SMBConnection.TransactNamedPipe(treeId, fileId, data, waitAnswer = waitAnswer)\n        except (smb.SessionError, smb3.SessionError) as e:\n            raise SessionError(e.get_error_code(), e.get_error_packet())\n\n    def transactNamedPipeRecv(self):\n        \"\"\"\n        reads from a named pipe using a transaction command\n\n        :return: data read\n        :raise SessionError: if error\n        \"\"\"\n        try:\n            return self._SMBConnection.TransactNamedPipeRecv()\n        except (smb.SessionError, smb3.SessionError) as e:\n            raise SessionError(e.get_error_code(), e.get_error_packet())\n\n    def writeNamedPipe(self, treeId, fileId, data, waitAnswer = True):\n        \"\"\"\n        writes to a named pipe\n\n        :param HANDLE treeId: a valid handle for the share where the pipe is\n        :param HANDLE fileId: a valid handle for the pipe\n        :param string data: buffer with the data to write\n        :param boolean waitAnswer: whether or not to wait for an answer\n\n        :return: None\n        :raise SessionError: if error\n        \"\"\"\n        try:\n            if self.getDialect() == smb.SMB_DIALECT:\n                return self._SMBConnection.write_andx(treeId, fileId, data, wait_answer = waitAnswer, write_pipe_mode = True)\n            else:\n                return self.writeFile(treeId, fileId, data, 0)\n        except (smb.SessionError, smb3.SessionError) as e:\n            raise SessionError(e.get_error_code(), e.get_error_packet())\n\n    def readNamedPipe(self,treeId, fileId, bytesToRead = None ):\n        \"\"\"\n        read from a named pipe\n\n        :param HANDLE treeId: a valid handle for the share where the pipe resides\n        :param HANDLE fileId: a valid handle for the pipe\n        :param integer bytesToRead: amount of data to read\n\n        :return: None\n        :raise SessionError: if error\n        \"\"\"\n\n        try:\n            return self.readFile(treeId, fileId, bytesToRead = bytesToRead, singleCall = True)\n        except (smb.SessionError, smb3.SessionError) as e:\n            raise SessionError(e.get_error_code(), e.get_error_packet())\n\n\n    def getFile(self, shareName, pathName, callback, shareAccessMode = None):\n        \"\"\"\n        downloads a file\n\n        :param string shareName: name for the share where the file is to be retrieved\n        :param string pathName: the path name to retrieve\n        :param callback callback: function called to write the contents read.\n        :param int shareAccessMode:\n\n        :return: None\n        :raise SessionError: if error\n        \"\"\"\n        try:\n            if shareAccessMode is None:\n                # if share access mode is none, let's the underlying API deals with it\n                return self._SMBConnection.retr_file(shareName, pathName, callback)\n            else:\n                return self._SMBConnection.retr_file(shareName, pathName, callback, shareAccessMode=shareAccessMode)\n        except (smb.SessionError, smb3.SessionError) as e:\n            raise SessionError(e.get_error_code(), e.get_error_packet())\n\n    def putFile(self, shareName, pathName, callback, shareAccessMode = None):\n        \"\"\"\n        uploads a file\n\n        :param string shareName: name for the share where the file is to be uploaded\n        :param string pathName: the path name to upload\n        :param callback callback: function called to read the contents to be written.\n        :param int shareAccessMode:\n\n        :return: None\n        :raise SessionError: if error\n        \"\"\"\n        try:\n            if shareAccessMode is None:\n                # if share access mode is none, let's the underlying API deals with it\n                return self._SMBConnection.stor_file(shareName, pathName, callback)\n            else:\n                return self._SMBConnection.stor_file(shareName, pathName, callback, shareAccessMode)\n        except (smb.SessionError, smb3.SessionError) as e:\n            raise SessionError(e.get_error_code(), e.get_error_packet())\n\n    def listSnapshots(self, tid, path):\n        \"\"\"\n        lists the snapshots for the given directory\n\n        :param int tid: tree id of current connection\n        :param string path: directory to list the snapshots of\n\n        :raise SessionError: if error\n        \"\"\"\n\n        # Verify we're under SMB2+ session\n        if self.getDialect() not in [SMB2_DIALECT_002, SMB2_DIALECT_21, SMB2_DIALECT_30]:\n            raise SessionError(error = nt_errors.STATUS_NOT_SUPPORTED)\n\n        fid = self.openFile(tid, path, FILE_READ_DATA | FILE_READ_EA | FILE_READ_ATTRIBUTES | READ_CONTROL | SYNCHRONIZE,\n                            fileAttributes=None, creationOption=FILE_SYNCHRONOUS_IO_NONALERT,\n                            shareMode=FILE_SHARE_READ | FILE_SHARE_WRITE)\n\n        # first send with maxOutputResponse=16 to get the required size\n        try:\n            snapshotData = SRV_SNAPSHOT_ARRAY(self._SMBConnection.ioctl(tid, fid, FSCTL_SRV_ENUMERATE_SNAPSHOTS,\n                                  flags=SMB2_0_IOCTL_IS_FSCTL, maxOutputResponse=16))\n        except (smb.SessionError, smb3.SessionError) as e:\n            self.closeFile(tid, fid)\n            raise SessionError(e.get_error_code(), e.get_error_packet())\n\n        if snapshotData['SnapShotArraySize'] >= 52:\n            # now send an appropriate sized buffer\n            try:\n               snapshotData = SRV_SNAPSHOT_ARRAY(self._SMBConnection.ioctl(tid, fid, FSCTL_SRV_ENUMERATE_SNAPSHOTS,\n                                  flags=SMB2_0_IOCTL_IS_FSCTL, maxOutputResponse=snapshotData['SnapShotArraySize']+12))\n            except (smb.SessionError, smb3.SessionError) as e:\n               self.closeFile(tid, fid)\n               raise SessionError(e.get_error_code(), e.get_error_packet())\n\n        self.closeFile(tid, fid)\n        return list(filter(None, snapshotData['SnapShots'].decode('utf16').split('\\x00')))\n\n    def createMountPoint(self, tid, path, target):\n        \"\"\"\n        creates a mount point at an existing directory\n\n        :param int tid: tree id of current connection\n        :param string path: directory at which to create mount point (must already exist)\n        :param string target: target address of mount point\n\n        :raise SessionError: if error\n        \"\"\"\n\n        # Verify we're under SMB2+ session\n        if self.getDialect() not in [SMB2_DIALECT_002, SMB2_DIALECT_21, SMB2_DIALECT_30]:\n            raise SessionError(error = nt_errors.STATUS_NOT_SUPPORTED)\n\n        fid = self.openFile(tid, path, GENERIC_READ | GENERIC_WRITE,\n                            creationOption=FILE_OPEN_REPARSE_POINT)\n\n        if target.startswith(\"\\\\\"):\n            fixed_name  = target.encode('utf-16le')\n        else:\n            fixed_name  = (\"\\\\??\\\\\" + target).encode('utf-16le')\n\n        name        = target.encode('utf-16le')\n\n        reparseData = MOUNT_POINT_REPARSE_DATA_STRUCTURE()\n\n        reparseData['PathBuffer']           = fixed_name + b\"\\x00\\x00\" + name + b\"\\x00\\x00\"\n        reparseData['SubstituteNameLength'] = len(fixed_name)\n        reparseData['PrintNameOffset']      = len(fixed_name) + 2\n        reparseData['PrintNameLength']      = len(name)\n\n        self._SMBConnection.ioctl(tid, fid, FSCTL_SET_REPARSE_POINT, flags=SMB2_0_IOCTL_IS_FSCTL,\n                                  inputBlob=reparseData)\n\n        self.closeFile(tid, fid)\n\n    def removeMountPoint(self, tid, path):\n        \"\"\"\n        removes a mount point without deleting the underlying directory\n\n        :param int tid: tree id of current connection\n        :param string path: path to mount point to remove\n\n        :raise SessionError: if error\n        \"\"\"\n\n        # Verify we're under SMB2+ session\n        if self.getDialect() not in [SMB2_DIALECT_002, SMB2_DIALECT_21, SMB2_DIALECT_30]:\n            raise SessionError(error = nt_errors.STATUS_NOT_SUPPORTED)\n\n        fid = self.openFile(tid, path, GENERIC_READ | GENERIC_WRITE,\n                            creationOption=FILE_OPEN_REPARSE_POINT)\n\n        reparseData = MOUNT_POINT_REPARSE_GUID_DATA_STRUCTURE()\n\n        reparseData['DataBuffer'] = b\"\"\n\n        try:\n            self._SMBConnection.ioctl(tid, fid, FSCTL_DELETE_REPARSE_POINT, flags=SMB2_0_IOCTL_IS_FSCTL,\n                                      inputBlob=reparseData)\n        except (smb.SessionError, smb3.SessionError) as e:\n            self.closeFile(tid, fid)\n            raise SessionError(e.get_error_code(), e.get_error_packet())\n\n        self.closeFile(tid, fid)\n\n    def rename(self, shareName, oldPath, newPath):\n        \"\"\"\n        renames a file/directory\n\n        :param string shareName: name for the share where the files/directories are\n        :param string oldPath: the old path name or the directory/file to rename\n        :param string newPath: the new path name or the directory/file to rename\n\n        :return: True\n        :raise SessionError: if error\n        \"\"\"\n\n        try:\n            return self._SMBConnection.rename(shareName, oldPath, newPath)\n        except (smb.SessionError, smb3.SessionError) as e:\n            raise SessionError(e.get_error_code(), e.get_error_packet())\n\n    def reconnect(self):\n        \"\"\"\n        reconnects the SMB object based on the original options and credentials used. Only exception is that\n        manualNegotiate will not be honored.\n        Not only the connection will be created but also a login attempt using the original credentials and\n        method (Kerberos, PtH, etc)\n\n        :return: True\n        :raise SessionError: if error\n        \"\"\"\n        userName, password, domain, lmhash, nthash, aesKey, TGT, TGS = self.getCredentials()\n        self.negotiateSession(self._preferredDialect)\n        if self._doKerberos is True:\n            self.kerberosLogin(userName, password, domain, lmhash, nthash, aesKey, self._kdcHost, TGT, TGS, self._useCache)\n        else:\n            self.login(userName, password, domain, lmhash, nthash, self._ntlmFallback)\n\n        return True\n\n    def setTimeout(self, timeout):\n        try:\n            return self._SMBConnection.set_timeout(timeout)\n        except (smb.SessionError, smb3.SessionError) as e:\n            raise SessionError(e.get_error_code(), e.get_error_packet())\n\n    def getSessionKey(self):\n        if self.getDialect() == smb.SMB_DIALECT:\n            return self._SMBConnection.get_session_key()\n        else:\n            return self._SMBConnection.getSessionKey()\n\n    def setSessionKey(self, key):\n        if self.getDialect() == smb.SMB_DIALECT:\n            return self._SMBConnection.set_session_key(key)\n        else:\n            return self._SMBConnection.setSessionKey(key)\n\n    def setHostnameValidation(self, validate, accept_empty, hostname):\n        return self._SMBConnection.set_hostname_validation(validate, accept_empty, hostname)\n\n    def close(self):\n        \"\"\"\n        logs off and closes the underlying _NetBIOSSession()\n\n        :return: None\n        \"\"\"\n        try:\n            self.logoff()\n        except:\n            pass\n        self._SMBConnection.close_session()",
  "class SessionError(Exception):\n    \"\"\"\n    This is the exception every client should catch regardless of the underlying\n    SMB version used. We'll take care of that. NETBIOS exceptions are NOT included,\n    since all SMB versions share the same NETBIOS instances.\n    \"\"\"\n    def __init__( self, error = 0, packet=0):\n        Exception.__init__(self)\n        self.error = error\n        self.packet = packet\n\n    def getErrorCode( self ):\n        return self.error\n\n    def getErrorPacket( self ):\n        return self.packet\n\n    def getErrorString( self ):\n        return nt_errors.ERROR_MESSAGES[self.error]\n\n    def __str__( self ):\n        if self.error in nt_errors.ERROR_MESSAGES:\n            return 'SMB SessionError: %s(%s)' % (nt_errors.ERROR_MESSAGES[self.error])\n        else:\n            return 'SMB SessionError: 0x%x' % self.error",
  "def __init__(self, remoteName='', remoteHost='', myName=None, sess_port=nmb.SMB_SESSION_PORT, timeout=60, preferredDialect=None,\n                 existingConnection=None, manualNegotiate=False):\n\n        self._SMBConnection = 0\n        self._dialect       = ''\n        self._nmbSession    = 0\n        self._sess_port     = sess_port\n        self._myName        = myName\n        self._remoteHost    = remoteHost\n        self._remoteName    = remoteName\n        self._timeout       = timeout\n        self._preferredDialect = preferredDialect\n        self._existingConnection = existingConnection\n        self._manualNegotiate = manualNegotiate\n        self._doKerberos = False\n        self._kdcHost = None\n        self._useCache = True\n        self._ntlmFallback = True\n\n        if existingConnection is not None:\n            # Existing Connection must be a smb or smb3 instance\n            assert ( isinstance(existingConnection,smb.SMB) or isinstance(existingConnection, smb3.SMB3))\n            self._SMBConnection = existingConnection\n            self._preferredDialect = self._SMBConnection.getDialect()\n            self._doKerberos = self._SMBConnection.getKerberos()\n            return\n\n        ##preferredDialect = smb.SMB_DIALECT\n\n        if manualNegotiate is False:\n            self.negotiateSession(preferredDialect)",
  "def negotiateSession(self, preferredDialect=None,\n                         flags1=smb.SMB.FLAGS1_PATHCASELESS | smb.SMB.FLAGS1_CANONICALIZED_PATHS,\n                         flags2=smb.SMB.FLAGS2_EXTENDED_SECURITY | smb.SMB.FLAGS2_NT_STATUS | smb.SMB.FLAGS2_LONG_NAMES,\n                         negoData='\\x02NT LM 0.12\\x00\\x02SMB 2.002\\x00\\x02SMB 2.???\\x00'):\n        \"\"\"\n        Perform protocol negotiation\n\n        :param string preferredDialect: the dialect desired to talk with the target server. If None is specified the highest one available will be used\n        :param string flags1: the SMB FLAGS capabilities\n        :param string flags2: the SMB FLAGS2 capabilities\n        :param string negoData: data to be sent as part of the nego handshake\n\n        :return: True\n        :raise SessionError: if error\n        \"\"\"\n\n        # If port 445 and the name sent is *SMBSERVER we're setting the name to the IP. This is to help some old\n        # applications still believing\n        # *SMSBSERVER will work against modern OSes. If port is NETBIOS_SESSION_PORT the user better know about i\n        # *SMBSERVER's limitations\n        if self._sess_port == nmb.SMB_SESSION_PORT and self._remoteName == '*SMBSERVER':\n            self._remoteName = self._remoteHost\n        elif self._sess_port == nmb.NETBIOS_SESSION_PORT and self._remoteName == '*SMBSERVER':\n            # If remote name is *SMBSERVER let's try to query its name.. if can't be guessed, continue and hope for the best\n            nb = nmb.NetBIOS()\n            try:\n                res = nb.getnetbiosname(self._remoteHost)\n            except:\n                pass\n            else:\n                self._remoteName = res\n\n        if self._sess_port == nmb.NETBIOS_SESSION_PORT:\n            negoData = '\\x02NT LM 0.12\\x00\\x02SMB 2.002\\x00'\n\n        hostType = nmb.TYPE_SERVER\n        if preferredDialect is None:\n            # If no preferredDialect sent, we try the highest available one.\n            packet = self.negotiateSessionWildcard(self._myName, self._remoteName, self._remoteHost, self._sess_port,\n                                                   self._timeout, True, flags1=flags1, flags2=flags2, data=negoData)\n            if packet[0:1] == b'\\xfe':\n                # Answer is SMB2 packet\n                self._SMBConnection = smb3.SMB3(self._remoteName, self._remoteHost, self._myName, hostType,\n                                                self._sess_port, self._timeout, session=self._nmbSession,\n                                                negSessionResponse=SMB2Packet(packet))\n            else:\n                # Answer is SMB packet, sticking to SMBv1\n                self._SMBConnection = smb.SMB(self._remoteName, self._remoteHost, self._myName, hostType,\n                                              self._sess_port, self._timeout, session=self._nmbSession,\n                                              negPacket=packet)\n        else:\n            if preferredDialect == smb.SMB_DIALECT:\n                self._SMBConnection = smb.SMB(self._remoteName, self._remoteHost, self._myName, hostType,\n                                              self._sess_port, self._timeout)\n            elif preferredDialect in [SMB2_DIALECT_002, SMB2_DIALECT_21, SMB2_DIALECT_30, SMB2_DIALECT_311]:\n                self._SMBConnection = smb3.SMB3(self._remoteName, self._remoteHost, self._myName, hostType,\n                                                self._sess_port, self._timeout, preferredDialect=preferredDialect)\n            else:\n                raise Exception(\"Unknown dialect %s\")\n\n        # propagate flags to the smb sub-object, except for Unicode (if server supports)\n        # does not affect smb3 objects\n        if isinstance(self._SMBConnection, smb.SMB):\n            if self._SMBConnection.get_flags()[1] & smb.SMB.FLAGS2_UNICODE:\n                flags2 |= smb.SMB.FLAGS2_UNICODE\n            self._SMBConnection.set_flags(flags1=flags1, flags2=flags2)\n\n        return True",
  "def negotiateSessionWildcard(self, myName, remoteName, remoteHost, sess_port, timeout, extended_security=True, flags1=0,\n                                 flags2=0, data=None):\n        # Here we follow [MS-SMB2] negotiation handshake trying to understand what dialects\n        # (including SMB1) is supported on the other end.\n\n        if not myName:\n            myName = socket.gethostname()\n            i = myName.find('.')\n            if i > -1:\n                myName = myName[:i]\n\n        tries = 0\n        smbp = smb.NewSMBPacket()\n        smbp['Flags1'] = flags1\n        # FLAGS2_UNICODE is required by some stacks to continue, regardless of subsequent support\n        smbp['Flags2'] = flags2 | smb.SMB.FLAGS2_UNICODE\n        resp = None\n        while tries < 2:\n            self._nmbSession = nmb.NetBIOSTCPSession(myName, remoteName, remoteHost, nmb.TYPE_SERVER, sess_port,\n                                                     timeout)\n\n            negSession = smb.SMBCommand(smb.SMB.SMB_COM_NEGOTIATE)\n            if extended_security is True:\n                smbp['Flags2'] |= smb.SMB.FLAGS2_EXTENDED_SECURITY\n            negSession['Data'] = data\n            smbp.addCommand(negSession)\n            self._nmbSession.send_packet(smbp.getData())\n\n            try:\n                resp = self._nmbSession.recv_packet(timeout)\n                break\n            except nmb.NetBIOSError:\n                # OSX Yosemite asks for more Flags. Let's give it a try and see what happens\n                smbp['Flags2'] |= smb.SMB.FLAGS2_NT_STATUS | smb.SMB.FLAGS2_LONG_NAMES | smb.SMB.FLAGS2_UNICODE\n                smbp['Data'] = []\n\n            tries += 1\n\n        if resp is None:\n            # No luck, quitting\n            raise Exception('No answer!')\n\n        return resp.get_trailer()",
  "def getNMBServer(self):\n        return self._nmbSession",
  "def getSMBServer(self):\n        \"\"\"\n        returns the SMB/SMB3 instance being used. Useful for calling low level methods\n        \"\"\"\n        return self._SMBConnection",
  "def getDialect(self):\n        return self._SMBConnection.getDialect()",
  "def getServerName(self):\n        return self._SMBConnection.get_server_name()",
  "def getClientName(self):\n        return self._SMBConnection.get_client_name()",
  "def getRemoteHost(self):\n        return self._SMBConnection.get_remote_host()",
  "def getRemoteName(self):\n        return self._SMBConnection.get_remote_name()",
  "def setRemoteName(self, name):\n        return self._SMBConnection.set_remote_name(name)",
  "def getServerDomain(self):\n        return self._SMBConnection.get_server_domain()",
  "def getServerDNSDomainName(self):\n        return self._SMBConnection.get_server_dns_domain_name()",
  "def getServerDNSHostName(self):\n        return self._SMBConnection.get_server_dns_host_name()",
  "def getServerOS(self):\n        return self._SMBConnection.get_server_os()",
  "def getServerOSMajor(self):\n        return self._SMBConnection.get_server_os_major()",
  "def getServerOSMinor(self):\n        return self._SMBConnection.get_server_os_minor()",
  "def getServerOSBuild(self):\n        return self._SMBConnection.get_server_os_build()",
  "def doesSupportNTLMv2(self):\n        return self._SMBConnection.doesSupportNTLMv2()",
  "def isLoginRequired(self):\n        return self._SMBConnection.is_login_required()",
  "def isSigningRequired(self):\n        return self._SMBConnection.is_signing_required()",
  "def getCredentials(self):\n        return self._SMBConnection.getCredentials()",
  "def getIOCapabilities(self):\n        return self._SMBConnection.getIOCapabilities()",
  "def login(self, user, password, domain = '', lmhash = '', nthash = '', ntlmFallback = True):\n        \"\"\"\n        logins into the target system\n\n        :param string user: username\n        :param string password: password for the user\n        :param string domain: domain where the account is valid for\n        :param string lmhash: LMHASH used to authenticate using hashes (password is not used)\n        :param string nthash: NTHASH used to authenticate using hashes (password is not used)\n        :param bool ntlmFallback: If True it will try NTLMv1 authentication if NTLMv2 fails. Only available for SMBv1\n\n        :return: None\n        :raise SessionError: if error\n        \"\"\"\n        self._ntlmFallback = ntlmFallback\n        try:\n            if self.getDialect() == smb.SMB_DIALECT:\n                return self._SMBConnection.login(user, password, domain, lmhash, nthash, ntlmFallback)\n            else:\n                return self._SMBConnection.login(user, password, domain, lmhash, nthash)\n        except (smb.SessionError, smb3.SessionError) as e:\n            raise SessionError(e.get_error_code(), e.get_error_packet())",
  "def kerberosLogin(self, user, password, domain='', lmhash='', nthash='', aesKey='', kdcHost=None, TGT=None,\n                      TGS=None, useCache=True):\n        \"\"\"\n        logins into the target system explicitly using Kerberos. Hashes are used if RC4_HMAC is supported.\n\n        :param string user: username\n        :param string password: password for the user\n        :param string domain: domain where the account is valid for (required)\n        :param string lmhash: LMHASH used to authenticate using hashes (password is not used)\n        :param string nthash: NTHASH used to authenticate using hashes (password is not used)\n        :param string aesKey: aes256-cts-hmac-sha1-96 or aes128-cts-hmac-sha1-96 used for Kerberos authentication\n        :param string kdcHost: hostname or IP Address for the KDC. If None, the domain will be used (it needs to resolve tho)\n        :param struct TGT: If there's a TGT available, send the structure here and it will be used\n        :param struct TGS: same for TGS. See smb3.py for the format\n        :param bool useCache: whether or not we should use the ccache for credentials lookup. If TGT or TGS are specified this is False\n\n        :return: None\n        :raise SessionError: if error\n        \"\"\"\n        from impacket.krb5.ccache import CCache\n        from impacket.krb5.kerberosv5 import KerberosError\n        from impacket.krb5 import constants\n\n        self._kdcHost = kdcHost\n        self._useCache = useCache\n\n        if TGT is not None or TGS is not None:\n            useCache = False\n\n        if useCache:\n            domain, user, TGT, TGS = CCache.parseFile(domain, user, 'cifs/%s' % self.getRemoteName())\n\n        while True:\n            try:\n                if self.getDialect() == smb.SMB_DIALECT:\n                    return self._SMBConnection.kerberos_login(user, password, domain, lmhash, nthash, aesKey, kdcHost,\n                                                              TGT, TGS)\n                return self._SMBConnection.kerberosLogin(user, password, domain, lmhash, nthash, aesKey, kdcHost, TGT,\n                                                         TGS)\n            except (smb.SessionError, smb3.SessionError) as e:\n                raise SessionError(e.get_error_code(), e.get_error_packet())\n            except KerberosError as e:\n                if e.getErrorCode() == constants.ErrorCodes.KDC_ERR_ETYPE_NOSUPP.value:\n                    # We might face this if the target does not support AES\n                    # So, if that's the case we'll force using RC4 by converting\n                    # the password to lm/nt hashes and hope for the best. If that's already\n                    # done, byebye.\n                    if lmhash == '' and nthash == '' and (aesKey == '' or aesKey is None) and TGT is None and TGS is None:\n                        lmhash = compute_lmhash(password)\n                        nthash = compute_nthash(password)\n                    else:\n                        raise e\n                else:\n                    raise e",
  "def isGuestSession(self):\n        try:\n            return self._SMBConnection.isGuestSession()\n        except (smb.SessionError, smb3.SessionError) as e:\n            raise SessionError(e.get_error_code(), e.get_error_packet())",
  "def logoff(self):\n        try:\n            return self._SMBConnection.logoff()\n        except (smb.SessionError, smb3.SessionError) as e:\n            raise SessionError(e.get_error_code(), e.get_error_packet())",
  "def connectTree(self,share):\n        if self.getDialect() == smb.SMB_DIALECT:\n            # If we already have a UNC we do nothing.\n            if ntpath.ismount(share) is False:\n                # Else we build it\n                share = ntpath.basename(share)\n                share = '\\\\\\\\' + self.getRemoteHost() + '\\\\' + share\n        try:\n            return self._SMBConnection.connect_tree(share)\n        except (smb.SessionError, smb3.SessionError) as e:\n            raise SessionError(e.get_error_code(), e.get_error_packet())",
  "def disconnectTree(self, treeId):\n        try:\n            return self._SMBConnection.disconnect_tree(treeId)\n        except (smb.SessionError, smb3.SessionError) as e:\n            raise SessionError(e.get_error_code(), e.get_error_packet())",
  "def listShares(self):\n        \"\"\"\n        get a list of available shares at the connected target\n\n        :return: a list containing dict entries for each share\n        :raise SessionError: if error\n        \"\"\"\n        # Get the shares through RPC\n        from impacket.dcerpc.v5 import transport, srvs\n        rpctransport = transport.SMBTransport(self.getRemoteName(), self.getRemoteHost(), filename=r'\\srvsvc',\n                                              smb_connection=self)\n        dce = rpctransport.get_dce_rpc()\n        dce.connect()\n        dce.bind(srvs.MSRPC_UUID_SRVS)\n        resp = srvs.hNetrShareEnum(dce, 1)\n        return resp['InfoStruct']['ShareInfo']['Level1']['Buffer']",
  "def listPath(self, shareName, path, password = None):\n        \"\"\"\n        list the files/directories under shareName/path\n\n        :param string shareName: a valid name for the share where the files/directories are going to be searched\n        :param string path: a base path relative to shareName\n        :param string password: the password for the share\n\n        :return: a list containing smb.SharedFile items\n        :raise SessionError: if error\n        \"\"\"\n\n        try:\n            return self._SMBConnection.list_path(shareName, path, password)\n        except (smb.SessionError, smb3.SessionError) as e:\n            raise SessionError(e.get_error_code(), e.get_error_packet())",
  "def createFile(self, treeId, pathName, desiredAccess=GENERIC_ALL,\n                   shareMode=FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,\n                   creationOption=FILE_NON_DIRECTORY_FILE, creationDisposition=FILE_OVERWRITE_IF,\n                   fileAttributes=FILE_ATTRIBUTE_NORMAL, impersonationLevel=SMB2_IL_IMPERSONATION, securityFlags=0,\n                   oplockLevel=SMB2_OPLOCK_LEVEL_NONE, createContexts=None):\n        \"\"\"\n        Creates a remote file\n\n        :param HANDLE treeId: a valid handle for the share where the file is to be created\n        :param string pathName: the path name of the file to create\n        :param int desiredAccess: The level of access that is required, as specified in https://msdn.microsoft.com/en-us/library/cc246503.aspx\n        :param int shareMode: Specifies the sharing mode for the open.\n        :param int creationOption: Specifies the options to be applied when creating or opening the file.\n        :param int creationDisposition: Defines the action the server MUST take if the file that is specified in the name\n        field already exists.\n        :param int fileAttributes: This field MUST be a combination of the values specified in [MS-FSCC] section 2.6, and MUST NOT include any values other than those specified in that section.\n        :param int impersonationLevel: This field specifies the impersonation level requested by the application that is issuing the create request.\n        :param int securityFlags: This field MUST NOT be used and MUST be reserved. The client MUST set this to 0, and the server MUST ignore it.\n        :param int oplockLevel: The requested oplock level\n        :param createContexts: A variable-length attribute that is sent with an SMB2 CREATE Request or SMB2 CREATE Response that either gives extra information about how the create will be processed, or returns extra information about how the create was processed.\n\n        :return: a valid file descriptor\n        :raise SessionError: if error\n        \"\"\"\n        if self.getDialect() == smb.SMB_DIALECT:\n            _, flags2 = self._SMBConnection.get_flags()\n\n            pathName = pathName.replace('/', '\\\\')\n            packetPathName = pathName.encode('utf-16le') if flags2 & smb.SMB.FLAGS2_UNICODE else pathName\n\n            ntCreate = smb.SMBCommand(smb.SMB.SMB_COM_NT_CREATE_ANDX)\n            ntCreate['Parameters'] = smb.SMBNtCreateAndX_Parameters()\n            ntCreate['Data']       = smb.SMBNtCreateAndX_Data(flags=flags2)\n            ntCreate['Parameters']['FileNameLength']= len(packetPathName)\n            ntCreate['Parameters']['AccessMask']    = desiredAccess\n            ntCreate['Parameters']['FileAttributes']= fileAttributes\n            ntCreate['Parameters']['ShareAccess']   = shareMode\n            ntCreate['Parameters']['Disposition']   = creationDisposition\n            ntCreate['Parameters']['CreateOptions'] = creationOption\n            ntCreate['Parameters']['Impersonation'] = impersonationLevel\n            ntCreate['Parameters']['SecurityFlags'] = securityFlags\n            ntCreate['Parameters']['CreateFlags']   = 0x16\n            ntCreate['Data']['FileName'] = packetPathName\n\n            if flags2 & smb.SMB.FLAGS2_UNICODE:\n                ntCreate['Data']['Pad'] = 0x0\n\n            if createContexts is not None:\n                LOG.error(\"CreateContexts not supported in SMB1\")\n\n            try:\n                return self._SMBConnection.nt_create_andx(treeId, pathName, cmd = ntCreate)\n            except (smb.SessionError, smb3.SessionError) as e:\n                raise SessionError(e.get_error_code(), e.get_error_packet())\n        else:\n            try:\n                return self._SMBConnection.create(treeId, pathName, desiredAccess, shareMode, creationOption,\n                                                  creationDisposition, fileAttributes, impersonationLevel,\n                                                  securityFlags, oplockLevel, createContexts)\n            except (smb.SessionError, smb3.SessionError) as e:\n                raise SessionError(e.get_error_code(), e.get_error_packet())",
  "def openFile(self, treeId, pathName, desiredAccess=FILE_READ_DATA | FILE_WRITE_DATA, shareMode=FILE_SHARE_READ,\n                 creationOption=FILE_NON_DIRECTORY_FILE, creationDisposition=FILE_OPEN,\n                 fileAttributes=FILE_ATTRIBUTE_NORMAL, impersonationLevel=SMB2_IL_IMPERSONATION, securityFlags=0,\n                 oplockLevel=SMB2_OPLOCK_LEVEL_NONE, createContexts=None):\n        \"\"\"\n        opens a remote file\n\n        :param HANDLE treeId: a valid handle for the share where the file is to be opened\n        :param string pathName: the path name to open\n        :param int desiredAccess: The level of access that is required, as specified in https://msdn.microsoft.com/en-us/library/cc246503.aspx\n        :param int shareMode: Specifies the sharing mode for the open.\n        :param int creationOption: Specifies the options to be applied when creating or opening the file.\n        :param int creationDisposition: Defines the action the server MUST take if the file that is specified in the name\n        field already exists.\n        :param int fileAttributes: This field MUST be a combination of the values specified in [MS-FSCC] section 2.6, and MUST NOT include any values other than those specified in that section.\n        :param int impersonationLevel: This field specifies the impersonation level requested by the application that is issuing the create request.\n        :param int securityFlags: This field MUST NOT be used and MUST be reserved. The client MUST set this to 0, and the server MUST ignore it.\n        :param int oplockLevel: The requested oplock level\n        :param createContexts: A variable-length attribute that is sent with an SMB2 CREATE Request or SMB2 CREATE Response that either gives extra information about how the create will be processed, or returns extra information about how the create was processed.\n\n        :return: a valid file descriptor\n        :raise SessionError: if error\n        \"\"\"\n\n        if self.getDialect() == smb.SMB_DIALECT:\n            _, flags2 = self._SMBConnection.get_flags()\n\n            pathName = pathName.replace('/', '\\\\')\n            packetPathName = pathName.encode('utf-16le') if flags2 & smb.SMB.FLAGS2_UNICODE else pathName\n\n            ntCreate = smb.SMBCommand(smb.SMB.SMB_COM_NT_CREATE_ANDX)\n            ntCreate['Parameters'] = smb.SMBNtCreateAndX_Parameters()\n            ntCreate['Data']       = smb.SMBNtCreateAndX_Data(flags=flags2)\n            ntCreate['Parameters']['FileNameLength']= len(packetPathName)\n            ntCreate['Parameters']['AccessMask']    = desiredAccess\n            ntCreate['Parameters']['FileAttributes']= fileAttributes\n            ntCreate['Parameters']['ShareAccess']   = shareMode\n            ntCreate['Parameters']['Disposition']   = creationDisposition\n            ntCreate['Parameters']['CreateOptions'] = creationOption\n            ntCreate['Parameters']['Impersonation'] = impersonationLevel\n            ntCreate['Parameters']['SecurityFlags'] = securityFlags\n            ntCreate['Parameters']['CreateFlags']   = 0x16\n            ntCreate['Data']['FileName'] = packetPathName\n\n            if flags2 & smb.SMB.FLAGS2_UNICODE:\n                ntCreate['Data']['Pad'] = 0x0\n\n            if createContexts is not None:\n                LOG.error(\"CreateContexts not supported in SMB1\")\n\n            try:\n                return self._SMBConnection.nt_create_andx(treeId, pathName, cmd = ntCreate)\n            except (smb.SessionError, smb3.SessionError) as e:\n                raise SessionError(e.get_error_code(), e.get_error_packet())\n        else:\n            try:\n                return self._SMBConnection.create(treeId, pathName, desiredAccess, shareMode, creationOption,\n                                                  creationDisposition, fileAttributes, impersonationLevel,\n                                                  securityFlags, oplockLevel, createContexts)\n            except (smb.SessionError, smb3.SessionError) as e:\n                raise SessionError(e.get_error_code(), e.get_error_packet())",
  "def writeFile(self, treeId, fileId, data, offset=0):\n        \"\"\"\n        writes data to a file\n\n        :param HANDLE treeId: a valid handle for the share where the file is to be written\n        :param HANDLE fileId: a valid handle for the file\n        :param string data: buffer with the data to write\n        :param integer offset: offset where to start writing the data\n\n        :return: amount of bytes written\n        :raise SessionError: if error\n        \"\"\"\n        try:\n            return self._SMBConnection.writeFile(treeId, fileId, data, offset)\n        except (smb.SessionError, smb3.SessionError) as e:\n            raise SessionError(e.get_error_code(), e.get_error_packet())",
  "def readFile(self, treeId, fileId, offset = 0, bytesToRead = None, singleCall = True):\n        \"\"\"\n        reads data from a file\n\n        :param HANDLE treeId: a valid handle for the share where the file is to be read\n        :param HANDLE fileId: a valid handle for the file to be read\n        :param integer offset: offset where to start reading the data\n        :param integer bytesToRead: amount of bytes to attempt reading. If None, it will attempt to read Dialect['MaxBufferSize'] bytes.\n        :param boolean singleCall: If True it won't attempt to read all bytesToRead. It will only make a single read call\n\n        :return: the data read. Length of data read is not always bytesToRead\n        :raise SessionError: if error\n        \"\"\"\n        finished = False\n        data = b''\n        maxReadSize = self._SMBConnection.getIOCapabilities()['MaxReadSize']\n        if bytesToRead is None:\n            bytesToRead = maxReadSize\n        remainingBytesToRead = bytesToRead\n        while not finished:\n            if remainingBytesToRead > maxReadSize:\n                toRead = maxReadSize\n            else:\n                toRead = remainingBytesToRead\n            try:\n                bytesRead = self._SMBConnection.read_andx(treeId, fileId, offset, toRead)\n            except (smb.SessionError, smb3.SessionError) as e:\n                if e.get_error_code() == nt_errors.STATUS_END_OF_FILE:\n                    toRead = b''\n                    break\n                else:\n                    raise SessionError(e.get_error_code(), e.get_error_packet())\n\n            data += bytesRead\n            if len(data) >= bytesToRead:\n                finished = True\n            elif len(bytesRead) == 0:\n                # End of the file achieved.\n                finished = True\n            elif singleCall is True:\n                finished = True\n            else:\n                offset += len(bytesRead)\n                remainingBytesToRead -= len(bytesRead)\n\n        return data",
  "def closeFile(self, treeId, fileId):\n        \"\"\"\n        closes a file handle\n\n        :param HANDLE treeId: a valid handle for the share where the file is to be opened\n        :param HANDLE fileId: a valid handle for the file/directory to be closed\n\n        :return: None\n        :raise SessionError: if error\n        \"\"\"\n        try:\n            return self._SMBConnection.close(treeId, fileId)\n        except (smb.SessionError, smb3.SessionError) as e:\n            raise SessionError(e.get_error_code(), e.get_error_packet())",
  "def deleteFile(self, shareName, pathName):\n        \"\"\"\n        removes a file\n\n        :param string shareName: a valid name for the share where the file is to be deleted\n        :param string pathName: the path name to remove\n\n        :return: None\n        :raise SessionError: if error\n        \"\"\"\n        try:\n            return self._SMBConnection.remove(shareName, pathName)\n        except (smb.SessionError, smb3.SessionError) as e:\n            raise SessionError(e.get_error_code(), e.get_error_packet())",
  "def queryInfo(self, treeId, fileId):\n        \"\"\"\n        queries basic information about an opened file/directory\n\n        :param HANDLE treeId: a valid handle for the share where the file is to be queried\n        :param HANDLE fileId: a valid handle for the file/directory to be queried\n\n        :return: a smb.SMBQueryFileStandardInfo structure.\n        :raise SessionError: if error\n        \"\"\"\n        try:\n            if self.getDialect() == smb.SMB_DIALECT:\n                res = self._SMBConnection.query_file_info(treeId, fileId)\n            else:\n                res = self._SMBConnection.queryInfo(treeId, fileId)\n            return smb.SMBQueryFileStandardInfo(res)\n        except (smb.SessionError, smb3.SessionError) as e:\n            raise SessionError(e.get_error_code(), e.get_error_packet())",
  "def createDirectory(self, shareName, pathName ):\n        \"\"\"\n        creates a directory\n\n        :param string shareName: a valid name for the share where the directory is to be created\n        :param string pathName: the path name or the directory to create\n\n        :return: None\n        :raise SessionError: if error\n        \"\"\"\n        try:\n            return self._SMBConnection.mkdir(shareName, pathName)\n        except (smb.SessionError, smb3.SessionError) as e:\n            raise SessionError(e.get_error_code(), e.get_error_packet())",
  "def deleteDirectory(self, shareName, pathName):\n        \"\"\"\n        deletes a directory\n\n        :param string shareName: a valid name for the share where directory is to be deleted\n        :param string pathName: the path name or the directory to delete\n\n        :return: None\n        :raise SessionError: if error\n        \"\"\"\n        try:\n            return self._SMBConnection.rmdir(shareName, pathName)\n        except (smb.SessionError, smb3.SessionError) as e:\n            raise SessionError(e.get_error_code(), e.get_error_packet())",
  "def waitNamedPipe(self, treeId, pipeName, timeout = 5):\n        \"\"\"\n        waits for a named pipe\n\n        :param HANDLE treeId: a valid handle for the share where the pipe is\n        :param string pipeName: the pipe name to check\n        :param integer timeout: time to wait for an answer\n\n        :return: None\n        :raise SessionError: if error\n        \"\"\"\n        try:\n            return self._SMBConnection.waitNamedPipe(treeId, pipeName, timeout = timeout)\n        except (smb.SessionError, smb3.SessionError) as e:\n            raise SessionError(e.get_error_code(), e.get_error_packet())",
  "def transactNamedPipe(self, treeId, fileId, data, waitAnswer = True):\n        \"\"\"\n        writes to a named pipe using a transaction command\n\n        :param HANDLE treeId: a valid handle for the share where the pipe is\n        :param HANDLE fileId: a valid handle for the pipe\n        :param string data: buffer with the data to write\n        :param boolean waitAnswer: whether or not to wait for an answer\n\n        :return: None\n        :raise SessionError: if error\n        \"\"\"\n        try:\n            return self._SMBConnection.TransactNamedPipe(treeId, fileId, data, waitAnswer = waitAnswer)\n        except (smb.SessionError, smb3.SessionError) as e:\n            raise SessionError(e.get_error_code(), e.get_error_packet())",
  "def transactNamedPipeRecv(self):\n        \"\"\"\n        reads from a named pipe using a transaction command\n\n        :return: data read\n        :raise SessionError: if error\n        \"\"\"\n        try:\n            return self._SMBConnection.TransactNamedPipeRecv()\n        except (smb.SessionError, smb3.SessionError) as e:\n            raise SessionError(e.get_error_code(), e.get_error_packet())",
  "def writeNamedPipe(self, treeId, fileId, data, waitAnswer = True):\n        \"\"\"\n        writes to a named pipe\n\n        :param HANDLE treeId: a valid handle for the share where the pipe is\n        :param HANDLE fileId: a valid handle for the pipe\n        :param string data: buffer with the data to write\n        :param boolean waitAnswer: whether or not to wait for an answer\n\n        :return: None\n        :raise SessionError: if error\n        \"\"\"\n        try:\n            if self.getDialect() == smb.SMB_DIALECT:\n                return self._SMBConnection.write_andx(treeId, fileId, data, wait_answer = waitAnswer, write_pipe_mode = True)\n            else:\n                return self.writeFile(treeId, fileId, data, 0)\n        except (smb.SessionError, smb3.SessionError) as e:\n            raise SessionError(e.get_error_code(), e.get_error_packet())",
  "def readNamedPipe(self,treeId, fileId, bytesToRead = None ):\n        \"\"\"\n        read from a named pipe\n\n        :param HANDLE treeId: a valid handle for the share where the pipe resides\n        :param HANDLE fileId: a valid handle for the pipe\n        :param integer bytesToRead: amount of data to read\n\n        :return: None\n        :raise SessionError: if error\n        \"\"\"\n\n        try:\n            return self.readFile(treeId, fileId, bytesToRead = bytesToRead, singleCall = True)\n        except (smb.SessionError, smb3.SessionError) as e:\n            raise SessionError(e.get_error_code(), e.get_error_packet())",
  "def getFile(self, shareName, pathName, callback, shareAccessMode = None):\n        \"\"\"\n        downloads a file\n\n        :param string shareName: name for the share where the file is to be retrieved\n        :param string pathName: the path name to retrieve\n        :param callback callback: function called to write the contents read.\n        :param int shareAccessMode:\n\n        :return: None\n        :raise SessionError: if error\n        \"\"\"\n        try:\n            if shareAccessMode is None:\n                # if share access mode is none, let's the underlying API deals with it\n                return self._SMBConnection.retr_file(shareName, pathName, callback)\n            else:\n                return self._SMBConnection.retr_file(shareName, pathName, callback, shareAccessMode=shareAccessMode)\n        except (smb.SessionError, smb3.SessionError) as e:\n            raise SessionError(e.get_error_code(), e.get_error_packet())",
  "def putFile(self, shareName, pathName, callback, shareAccessMode = None):\n        \"\"\"\n        uploads a file\n\n        :param string shareName: name for the share where the file is to be uploaded\n        :param string pathName: the path name to upload\n        :param callback callback: function called to read the contents to be written.\n        :param int shareAccessMode:\n\n        :return: None\n        :raise SessionError: if error\n        \"\"\"\n        try:\n            if shareAccessMode is None:\n                # if share access mode is none, let's the underlying API deals with it\n                return self._SMBConnection.stor_file(shareName, pathName, callback)\n            else:\n                return self._SMBConnection.stor_file(shareName, pathName, callback, shareAccessMode)\n        except (smb.SessionError, smb3.SessionError) as e:\n            raise SessionError(e.get_error_code(), e.get_error_packet())",
  "def listSnapshots(self, tid, path):\n        \"\"\"\n        lists the snapshots for the given directory\n\n        :param int tid: tree id of current connection\n        :param string path: directory to list the snapshots of\n\n        :raise SessionError: if error\n        \"\"\"\n\n        # Verify we're under SMB2+ session\n        if self.getDialect() not in [SMB2_DIALECT_002, SMB2_DIALECT_21, SMB2_DIALECT_30]:\n            raise SessionError(error = nt_errors.STATUS_NOT_SUPPORTED)\n\n        fid = self.openFile(tid, path, FILE_READ_DATA | FILE_READ_EA | FILE_READ_ATTRIBUTES | READ_CONTROL | SYNCHRONIZE,\n                            fileAttributes=None, creationOption=FILE_SYNCHRONOUS_IO_NONALERT,\n                            shareMode=FILE_SHARE_READ | FILE_SHARE_WRITE)\n\n        # first send with maxOutputResponse=16 to get the required size\n        try:\n            snapshotData = SRV_SNAPSHOT_ARRAY(self._SMBConnection.ioctl(tid, fid, FSCTL_SRV_ENUMERATE_SNAPSHOTS,\n                                  flags=SMB2_0_IOCTL_IS_FSCTL, maxOutputResponse=16))\n        except (smb.SessionError, smb3.SessionError) as e:\n            self.closeFile(tid, fid)\n            raise SessionError(e.get_error_code(), e.get_error_packet())\n\n        if snapshotData['SnapShotArraySize'] >= 52:\n            # now send an appropriate sized buffer\n            try:\n               snapshotData = SRV_SNAPSHOT_ARRAY(self._SMBConnection.ioctl(tid, fid, FSCTL_SRV_ENUMERATE_SNAPSHOTS,\n                                  flags=SMB2_0_IOCTL_IS_FSCTL, maxOutputResponse=snapshotData['SnapShotArraySize']+12))\n            except (smb.SessionError, smb3.SessionError) as e:\n               self.closeFile(tid, fid)\n               raise SessionError(e.get_error_code(), e.get_error_packet())\n\n        self.closeFile(tid, fid)\n        return list(filter(None, snapshotData['SnapShots'].decode('utf16').split('\\x00')))",
  "def createMountPoint(self, tid, path, target):\n        \"\"\"\n        creates a mount point at an existing directory\n\n        :param int tid: tree id of current connection\n        :param string path: directory at which to create mount point (must already exist)\n        :param string target: target address of mount point\n\n        :raise SessionError: if error\n        \"\"\"\n\n        # Verify we're under SMB2+ session\n        if self.getDialect() not in [SMB2_DIALECT_002, SMB2_DIALECT_21, SMB2_DIALECT_30]:\n            raise SessionError(error = nt_errors.STATUS_NOT_SUPPORTED)\n\n        fid = self.openFile(tid, path, GENERIC_READ | GENERIC_WRITE,\n                            creationOption=FILE_OPEN_REPARSE_POINT)\n\n        if target.startswith(\"\\\\\"):\n            fixed_name  = target.encode('utf-16le')\n        else:\n            fixed_name  = (\"\\\\??\\\\\" + target).encode('utf-16le')\n\n        name        = target.encode('utf-16le')\n\n        reparseData = MOUNT_POINT_REPARSE_DATA_STRUCTURE()\n\n        reparseData['PathBuffer']           = fixed_name + b\"\\x00\\x00\" + name + b\"\\x00\\x00\"\n        reparseData['SubstituteNameLength'] = len(fixed_name)\n        reparseData['PrintNameOffset']      = len(fixed_name) + 2\n        reparseData['PrintNameLength']      = len(name)\n\n        self._SMBConnection.ioctl(tid, fid, FSCTL_SET_REPARSE_POINT, flags=SMB2_0_IOCTL_IS_FSCTL,\n                                  inputBlob=reparseData)\n\n        self.closeFile(tid, fid)",
  "def removeMountPoint(self, tid, path):\n        \"\"\"\n        removes a mount point without deleting the underlying directory\n\n        :param int tid: tree id of current connection\n        :param string path: path to mount point to remove\n\n        :raise SessionError: if error\n        \"\"\"\n\n        # Verify we're under SMB2+ session\n        if self.getDialect() not in [SMB2_DIALECT_002, SMB2_DIALECT_21, SMB2_DIALECT_30]:\n            raise SessionError(error = nt_errors.STATUS_NOT_SUPPORTED)\n\n        fid = self.openFile(tid, path, GENERIC_READ | GENERIC_WRITE,\n                            creationOption=FILE_OPEN_REPARSE_POINT)\n\n        reparseData = MOUNT_POINT_REPARSE_GUID_DATA_STRUCTURE()\n\n        reparseData['DataBuffer'] = b\"\"\n\n        try:\n            self._SMBConnection.ioctl(tid, fid, FSCTL_DELETE_REPARSE_POINT, flags=SMB2_0_IOCTL_IS_FSCTL,\n                                      inputBlob=reparseData)\n        except (smb.SessionError, smb3.SessionError) as e:\n            self.closeFile(tid, fid)\n            raise SessionError(e.get_error_code(), e.get_error_packet())\n\n        self.closeFile(tid, fid)",
  "def rename(self, shareName, oldPath, newPath):\n        \"\"\"\n        renames a file/directory\n\n        :param string shareName: name for the share where the files/directories are\n        :param string oldPath: the old path name or the directory/file to rename\n        :param string newPath: the new path name or the directory/file to rename\n\n        :return: True\n        :raise SessionError: if error\n        \"\"\"\n\n        try:\n            return self._SMBConnection.rename(shareName, oldPath, newPath)\n        except (smb.SessionError, smb3.SessionError) as e:\n            raise SessionError(e.get_error_code(), e.get_error_packet())",
  "def reconnect(self):\n        \"\"\"\n        reconnects the SMB object based on the original options and credentials used. Only exception is that\n        manualNegotiate will not be honored.\n        Not only the connection will be created but also a login attempt using the original credentials and\n        method (Kerberos, PtH, etc)\n\n        :return: True\n        :raise SessionError: if error\n        \"\"\"\n        userName, password, domain, lmhash, nthash, aesKey, TGT, TGS = self.getCredentials()\n        self.negotiateSession(self._preferredDialect)\n        if self._doKerberos is True:\n            self.kerberosLogin(userName, password, domain, lmhash, nthash, aesKey, self._kdcHost, TGT, TGS, self._useCache)\n        else:\n            self.login(userName, password, domain, lmhash, nthash, self._ntlmFallback)\n\n        return True",
  "def setTimeout(self, timeout):\n        try:\n            return self._SMBConnection.set_timeout(timeout)\n        except (smb.SessionError, smb3.SessionError) as e:\n            raise SessionError(e.get_error_code(), e.get_error_packet())",
  "def getSessionKey(self):\n        if self.getDialect() == smb.SMB_DIALECT:\n            return self._SMBConnection.get_session_key()\n        else:\n            return self._SMBConnection.getSessionKey()",
  "def setSessionKey(self, key):\n        if self.getDialect() == smb.SMB_DIALECT:\n            return self._SMBConnection.set_session_key(key)\n        else:\n            return self._SMBConnection.setSessionKey(key)",
  "def setHostnameValidation(self, validate, accept_empty, hostname):\n        return self._SMBConnection.set_hostname_validation(validate, accept_empty, hostname)",
  "def close(self):\n        \"\"\"\n        logs off and closes the underlying _NetBIOSSession()\n\n        :return: None\n        \"\"\"\n        try:\n            self.logoff()\n        except:\n            pass\n        self._SMBConnection.close_session()",
  "def __init__( self, error = 0, packet=0):\n        Exception.__init__(self)\n        self.error = error\n        self.packet = packet",
  "def getErrorCode( self ):\n        return self.error",
  "def getErrorPacket( self ):\n        return self.packet",
  "def getErrorString( self ):\n        return nt_errors.ERROR_MESSAGES[self.error]",
  "def __str__( self ):\n        if self.error in nt_errors.ERROR_MESSAGES:\n            return 'SMB SessionError: %s(%s)' % (nt_errors.ERROR_MESSAGES[self.error])\n        else:\n            return 'SMB SessionError: 0x%x' % self.error",
  "class NullHandler(logging.Handler):\n        def emit(self, record):\n            pass",
  "def emit(self, record):\n            pass",
  "def getFlags(myenum, flags):\n    return '|'.join([name for name, member in myenum.__members__.items() if member.value & flags])",
  "class FLAGS(Enum):\n    CRYPTPROTECT_UI_FORBIDDEN = 0x1\n    CRYPTPROTECT_LOCAL_MACHINE = 0x4\n    CRYPTPROTECT_CRED_SYNC = 0x8\n    CRYPTPROTECT_AUDIT = 0x10\n    CRYPTPROTECT_VERIFY_PROTECTION = 0x40\n    CRYPTPROTECT_CRED_REGENERATE = 0x80\n    CRYPTPROTECT_SYSTEM = 0x20000000",
  "class ALGORITHMS(Enum):\n    CALG_MD2                = (ALG_CLASS_HASH | ALG_TYPE_ANY | ALG_SID_MD2)\n    CALG_MD4                = (ALG_CLASS_HASH | ALG_TYPE_ANY | ALG_SID_MD4)\n    CALG_MD5                = (ALG_CLASS_HASH | ALG_TYPE_ANY | ALG_SID_MD5)\n    CALG_SHA                = (ALG_CLASS_HASH | ALG_TYPE_ANY | ALG_SID_SHA)\n    CALG_SHA1               = (ALG_CLASS_HASH | ALG_TYPE_ANY | ALG_SID_SHA1)\n    CALG_RSA_SIGN           = (ALG_CLASS_SIGNATURE | ALG_TYPE_RSA | ALG_SID_RSA_ANY)\n    CALG_DSS_SIGN           = (ALG_CLASS_SIGNATURE | ALG_TYPE_DSS | ALG_SID_DSS_ANY)\n    CALG_NO_SIGN            = (ALG_CLASS_SIGNATURE | ALG_TYPE_ANY | ALG_SID_ANY)\n    CALG_RSA_KEYX           = (ALG_CLASS_KEY_EXCHANGE|ALG_TYPE_RSA|ALG_SID_RSA_ANY)\n    CALG_DES                = (ALG_CLASS_DATA_ENCRYPT|ALG_TYPE_BLOCK|ALG_SID_DES)\n    CALG_3DES_112           = (ALG_CLASS_DATA_ENCRYPT|ALG_TYPE_BLOCK|ALG_SID_3DES_112)\n    CALG_3DES               = (ALG_CLASS_DATA_ENCRYPT|ALG_TYPE_BLOCK|ALG_SID_3DES)\n    CALG_DESX               = (ALG_CLASS_DATA_ENCRYPT|ALG_TYPE_BLOCK|ALG_SID_DESX)\n    CALG_RC2                = (ALG_CLASS_DATA_ENCRYPT|ALG_TYPE_BLOCK|ALG_SID_RC2)\n    CALG_RC4                = (ALG_CLASS_DATA_ENCRYPT|ALG_TYPE_STREAM|ALG_SID_RC4)\n    CALG_SEAL               = (ALG_CLASS_DATA_ENCRYPT|ALG_TYPE_STREAM|ALG_SID_SEAL)\n    CALG_DH_SF              = (ALG_CLASS_KEY_EXCHANGE|ALG_TYPE_DH|ALG_SID_DH_SANDF)\n    CALG_DH_EPHEM           = (ALG_CLASS_KEY_EXCHANGE|ALG_TYPE_DH|ALG_SID_DH_EPHEM)\n    CALG_AGREEDKEY_ANY      = (ALG_CLASS_KEY_EXCHANGE|ALG_TYPE_DH|ALG_SID_AGREED_KEY_ANY)\n    CALG_KEA_KEYX           = (ALG_CLASS_KEY_EXCHANGE|ALG_TYPE_DH|ALG_SID_KEA)\n    CALG_HUGHES_MD5         = (ALG_CLASS_KEY_EXCHANGE|ALG_TYPE_ANY|ALG_SID_MD5)\n    CALG_SKIPJACK           = (ALG_CLASS_DATA_ENCRYPT|ALG_TYPE_BLOCK|ALG_SID_SKIPJACK)\n    CALG_TEK                = (ALG_CLASS_DATA_ENCRYPT|ALG_TYPE_BLOCK|ALG_SID_TEK)\n    CALG_SSL3_SHAMD5        = (ALG_CLASS_HASH | ALG_TYPE_ANY | ALG_SID_SSL3SHAMD5)\n    CALG_SSL3_MASTER        = (ALG_CLASS_MSG_ENCRYPT|ALG_TYPE_SECURECHANNEL|ALG_SID_SSL3_MASTER)\n    CALG_SCHANNEL_MASTER_HASH   = (ALG_CLASS_MSG_ENCRYPT|ALG_TYPE_SECURECHANNEL|ALG_SID_SCHANNEL_MASTER_HASH)\n    CALG_SCHANNEL_MAC_KEY   = (ALG_CLASS_MSG_ENCRYPT|ALG_TYPE_SECURECHANNEL|ALG_SID_SCHANNEL_MAC_KEY)\n    CALG_SCHANNEL_ENC_KEY   = (ALG_CLASS_MSG_ENCRYPT|ALG_TYPE_SECURECHANNEL|ALG_SID_SCHANNEL_ENC_KEY)\n    CALG_PCT1_MASTER        = (ALG_CLASS_MSG_ENCRYPT|ALG_TYPE_SECURECHANNEL|ALG_SID_PCT1_MASTER)\n    CALG_SSL2_MASTER        = (ALG_CLASS_MSG_ENCRYPT|ALG_TYPE_SECURECHANNEL|ALG_SID_SSL2_MASTER)\n    CALG_TLS1_MASTER        = (ALG_CLASS_MSG_ENCRYPT|ALG_TYPE_SECURECHANNEL|ALG_SID_TLS1_MASTER)\n    CALG_RC5                = (ALG_CLASS_DATA_ENCRYPT|ALG_TYPE_BLOCK|ALG_SID_RC5)\n    CALG_HMAC               = (ALG_CLASS_HASH | ALG_TYPE_ANY | ALG_SID_HMAC)\n    CALG_TLS1PRF            = (ALG_CLASS_HASH | ALG_TYPE_ANY | ALG_SID_TLS1PRF)\n    CALG_HASH_REPLACE_OWF   = (ALG_CLASS_HASH | ALG_TYPE_ANY | ALG_SID_HASH_REPLACE_OWF)\n    CALG_AES_128            = (ALG_CLASS_DATA_ENCRYPT|ALG_TYPE_BLOCK|ALG_SID_AES_128)\n    CALG_AES_192            = (ALG_CLASS_DATA_ENCRYPT|ALG_TYPE_BLOCK|ALG_SID_AES_192)\n    CALG_AES_256            = (ALG_CLASS_DATA_ENCRYPT|ALG_TYPE_BLOCK|ALG_SID_AES_256)\n    CALG_AES                = (ALG_CLASS_DATA_ENCRYPT|ALG_TYPE_BLOCK|ALG_SID_AES)\n    CALG_SHA_256            = (ALG_CLASS_HASH | ALG_TYPE_ANY | ALG_SID_SHA_256)\n    CALG_SHA_384            = (ALG_CLASS_HASH | ALG_TYPE_ANY | ALG_SID_SHA_384)\n    CALG_SHA_512            = (ALG_CLASS_HASH | ALG_TYPE_ANY | ALG_SID_SHA_512)\n    CALG_ECDH               = (ALG_CLASS_KEY_EXCHANGE | ALG_TYPE_DH | ALG_SID_ECDH)\n    CALG_ECMQV              = (ALG_CLASS_KEY_EXCHANGE | ALG_TYPE_ANY | ALG_SID_ECMQV)\n    CALG_ECDSA              = (ALG_CLASS_SIGNATURE | ALG_TYPE_DSS | ALG_SID_ECDSA)",
  "class CREDENTIAL_FLAGS(Enum):\n    CRED_FLAGS_PASSWORD_FOR_CERT = 0x1\n    CRED_FLAGS_PROMPT_NOW = 0x2\n    CRED_FLAGS_USERNAME_TARGET = 0x4\n    CRED_FLAGS_OWF_CRED_BLOB = 0x8\n    CRED_FLAGS_REQUIRE_CONFIRMATION = 0x10\n    CRED_FLAGS_WILDCARD_MATCH = 0x20\n    CRED_FLAGS_VSM_PROTECTED = 0x40\n    CRED_FLAGS_NGC_CERT = 0x80",
  "class CREDENTIAL_TYPE(Enum):\n    CRED_TYPE_GENERIC = 0x1\n    CRED_TYPE_DOMAIN_PASSWORD = 0x2\n    CRED_TYPE_DOMAIN_CERTIFICATE = 0x3\n    CRED_TYPE_DOMAIN_VISIBLE_PASSWORD = 0x4\n    CRED_TYPE_GENERIC_CERTIFICATE = 0x5\n    CRED_TYPE_DOMAIN_EXTENDED = 0x6\n    CRED_TYPE_MAXIMUM = 0x7\n    CRED_TYPE_MAXIMUM_EX = 0x8",
  "class CREDENTIAL_PERSIST(Enum):\n    CRED_PERSIST_NONE = 0x0\n    CRED_PERSIST_SESSION = 0x1\n    CRED_PERSIST_LOCAL_MACHINE = 0x2\n    CRED_PERSIST_ENTERPRISE = 0x3",
  "class MasterKeyFile(Structure):\n    structure = (\n        ('Version', '<L=0'),\n        ('unk1', '<L=0'),\n        ('unk2', '<L=0'),\n        ('Guid', \"72s=b''\"),\n        ('Unkown', '<L=0'),\n        ('Policy', '<L=0'),\n        ('Flags', '<L=0'),\n        ('MasterKeyLen', '<Q=0'),\n        ('BackupKeyLen', '<Q=0'),\n        ('CredHistLen', '<Q=0'),\n        ('DomainKeyLen', '<Q=0'),\n    )\n\n    def dump(self):\n        print(\"[MASTERKEYFILE]\")\n        print(\"Version     : %8x (%d)\" % (self['Version'], self['Version']))\n        print(\"Guid        : %s\" % self['Guid'].decode('utf-16le'))\n        print(\"Flags       : %8x (%d)\" % (self['Flags'], self['Flags']))\n        print(\"Policy      : %8x (%d)\" % (self['Policy'], self['Policy']))\n        print(\"MasterKeyLen: %.8x (%d)\" % (self['MasterKeyLen'], self['MasterKeyLen']))\n        print(\"BackupKeyLen: %.8x (%d)\" % (self['BackupKeyLen'], self['BackupKeyLen']))\n        print(\"CredHistLen : %.8x (%d)\" % (self['CredHistLen'], self['CredHistLen']))\n        print(\"DomainKeyLen: %.8x (%d)\" % (self['DomainKeyLen'], self['DomainKeyLen']))\n        print()",
  "class MasterKey(Structure):\n    structure = (\n        ('Version', '<L=0'),\n        ('Salt', '16s=b\"\"'),\n        ('MasterKeyIterationCount', '<L=0'),\n        ('HashAlgo', \"<L=0\"),\n        ('CryptAlgo', '<L=0'),\n        ('data', ':'),\n    )\n\n    def __init__(self, data = None, alignment = 0):\n        Structure.__init__(self, data, alignment)\n        self.decryptedKey = None\n\n    def dump(self):\n        print(\"[MASTERKEY]\")\n        print(\"Version     : %8x (%d)\" % (self['Version'], self['Version']))\n        print(\"Salt        : %s\" % hexlify(self['Salt']))\n        print(\"Rounds      : %8x (%d)\" % (self['MasterKeyIterationCount'], self['MasterKeyIterationCount']))\n        print(\"HashAlgo    : %.8x (%d) (%s)\" % (self['HashAlgo'], self['HashAlgo'], ALGORITHMS(self['HashAlgo']).name))\n        print(\"CryptAlgo   : %.8x (%d) (%s)\" % (self['CryptAlgo'], self['CryptAlgo'], ALGORITHMS(self['CryptAlgo']).name))\n        print(\"data        : %s\" % (hexlify(self['data'])))\n        print()\n\n    def deriveKey(self, passphrase, salt, keylen, count, hashFunction):\n        keyMaterial = b\"\"\n        i = 1\n        while len(keyMaterial) < keylen:\n            U = salt + pack(\"!L\", i)\n            i += 1\n            derived = bytearray(hashFunction(passphrase, U))\n            for r in range(count - 1):\n                actual = bytearray(hashFunction(passphrase, derived))\n                if PY3:\n                    derived = (int.from_bytes(derived, sys.byteorder) ^ int.from_bytes(actual, sys.byteorder)).to_bytes(len(actual), sys.byteorder)\n                else:\n                    derived = bytearray([ chr((a) ^ (b)) for (a,b) in zip(derived, actual) ])\n            keyMaterial += derived\n\n        return keyMaterial[:keylen]\n\n    def decrypt(self, key):\n        if self['HashAlgo'] == ALGORITHMS.CALG_HMAC.value:\n            hashModule = SHA1\n        else:\n            hashModule = ALGORITHMS_DATA[self['HashAlgo']][1]\n\n        prf = lambda p, s: HMAC.new(p, s, hashModule).digest()\n        derivedBlob = self.deriveKey(key, self['Salt'],\n                                    ALGORITHMS_DATA[self['CryptAlgo']][0] + ALGORITHMS_DATA[self['CryptAlgo']][3],\n                                    count=self['MasterKeyIterationCount'], hashFunction=prf)\n\n        cryptKey = derivedBlob[:ALGORITHMS_DATA[self['CryptAlgo']][0]]\n        iv = derivedBlob[ALGORITHMS_DATA[self['CryptAlgo']][0]:][:ALGORITHMS_DATA[self['CryptAlgo']][3]]\n\n        cipher = ALGORITHMS_DATA[self['CryptAlgo']][1].new(cryptKey, mode = ALGORITHMS_DATA[self['CryptAlgo']][2], iv = iv)\n        cleartext = cipher.decrypt(self['data'])\n\n        decryptedKey = cleartext[-64:]\n        hmacSalt = cleartext[:16]\n        hmac = cleartext[16:][:ALGORITHMS_DATA[self['HashAlgo']][0]]\n\n        hmacKey = HMAC.new(key, hmacSalt, hashModule).digest()\n\n        hmacCalculated = HMAC.new(hmacKey, decryptedKey, hashModule ).digest()\n\n        if hmacCalculated[:ALGORITHMS_DATA[self['HashAlgo']][0]] == hmac:\n            self.decryptedKey = decryptedKey\n            return decryptedKey\n        else:\n            return None",
  "class CredHist(Structure):\n    structure = (\n        ('Version', '<L=0'),\n        ('Guid', \"16s=b''\"),\n    )\n    def dump(self):\n        print(\"[CREDHIST]\")\n        print(\"Version       : %8x (%d)\" % (self['Version'], self['Version']))\n        print(\"Guid          : %s\" % bin_to_string(self['Guid']))\n        print()",
  "class DomainKey(Structure):\n    structure = (\n        ('Version', '<L=0'),\n        ('SecretLen', '<L=0'),\n        ('AccessCheckLen', '<L=0'),\n        ('Guid', \"16s=b\"\"\"),\n        ('_SecretData', '_-SecretData', 'self[\"SecretLen\"]'),\n        ('SecretData', ':'),\n        ('_AccessCheck', '_-AccessCheck', 'self[\"AccessCheckLen\"]'),\n        ('AccessCheck', ':'),\n    )\n    def dump(self):\n        print(\"[DOMAINKEY]\")\n        print(\"Version       : %8x (%d)\" % (self['Version'], self['Version']))\n        print(\"Guid          : %s\" % bin_to_string(self['Guid']))\n        print(\"SecretLen     : %8x (%d)\" % (self['SecretLen'], self['SecretLen']))\n        print(\"AccessCheckLen: %.8x (%d)\" % (self['AccessCheckLen'], self['AccessCheckLen']))\n        print(\"SecretData    : %s\" % (hexlify(self['SecretData'])))\n        print(\"AccessCheck   : %s\" % (hexlify(self['AccessCheck'])))\n        print()",
  "class DPAPI_SYSTEM(Structure):\n    structure = (\n        ('Version', '<L=0'),\n        ('MachineKey', '20s=b\"\"'),\n        ('UserKey', '20s=b\"\"'),\n    )\n\n    def dump(self):\n        print(\"[DPAPI_SYSTEM]\")\n        print(\"Version    : %8x (%d)\" % (self['Version'], self['Version']))\n        print(\"MachineKey : 0x%s\" % hexlify(self['MachineKey']).decode('latin-1'))\n        print(\"UserKey    : 0x%s\" % hexlify(self['UserKey']).decode('latin-1'))\n        print()",
  "class CredentialFile(Structure):\n    structure = (\n        ('Version', '<L=0'),\n        ('Size', '<L=0'),\n        ('Unknown', '<L=0'),\n        ('_Data', '_-Data', 'self[\"Size\"]'),\n        ('Data', ':'),\n    )",
  "class DPAPI_BLOB(Structure):\n    structure = (\n        ('Version', '<L=0'),\n        ('GuidCredential', \"16s=b\"\"\"),\n        ('MasterKeyVersion', '<L=0'),\n        ('GuidMasterKey', \"16s=b\"\"\"),\n        ('Flags', '<L=0'),\n\n        ('DescriptionLen', '<L=0'),\n        ('_Description', '_-Description', 'self[\"DescriptionLen\"]'),\n        ('Description', ':'),\n\n        ('CryptAlgo', '<L=0'),\n        ('CryptAlgoLen', '<L=0'),\n\n        ('SaltLen', '<L=0'),\n        ('_Salt', '_-Salt', 'self[\"SaltLen\"]'),\n        ('Salt', ':'),\n\n        ('HMacKeyLen', '<L=0'),\n        ('_HMacKey', '_-HMacKey', 'self[\"HMacKeyLen\"]'),\n        ('HMacKey', ':'),\n\n        ('HashAlgo', '<L=0'),\n        ('HashAlgoLen', '<L=0'),\n\n        ('HMac', '<L=0'),\n        ('_HMac', '_-HMac', 'self[\"HMac\"]'),\n        ('HMac', ':'),\n\n        ('DataLen', '<L=0'),\n        ('_Data', '_-Data', 'self[\"DataLen\"]'),\n        ('Data', ':'),\n\n        ('SignLen', '<L=0'),\n        ('_Sign', '_-Sign', 'self[\"SignLen\"]'),\n        ('Sign', ':'),\n\n    )\n\n    def dump(self):\n        print(\"[BLOB]\")\n        print(\"Version          : %8x (%d)\" % (self['Version'], self['Version']))\n        print(\"Guid Credential  : %s\" % bin_to_string(self['GuidCredential']))\n        print(\"MasterKeyVersion : %8x (%d)\" % (self['MasterKeyVersion'], self['MasterKeyVersion']))\n        print(\"Guid MasterKey   : %s\" % bin_to_string(self['GuidMasterKey']))\n        print(\"Flags            : %8x (%s)\" % (self['Flags'], getFlags(FLAGS, self['Flags'])))\n        print(\"Description      : %s\" % (self['Description'].decode('utf-16le')))\n        print(\"CryptAlgo        : %.8x (%d) (%s)\" % (self['CryptAlgo'], self['CryptAlgo'], ALGORITHMS(self['CryptAlgo']).name))\n        print(\"Salt             : %s\" % (hexlify(self['Salt'])))\n        print(\"HMacKey          : %s\" % (hexlify(self['HMacKey'])))\n        print(\"HashAlgo         : %.8x (%d) (%s)\" % (self['HashAlgo'], self['HashAlgo'], ALGORITHMS(self['HashAlgo']).name))\n        print(\"HMac             : %s\" % (hexlify(self['HMac'])))\n        print(\"Data             : %s\" % (hexlify(self['Data'])))\n        print(\"Sign             : %s\" % (hexlify(self['Sign'])))\n        print()\n\n\n    def deriveKey(self, sessionKey):\n        def fixparity(deskey):\n            from six import indexbytes, b\n            temp = b''\n            for i in range(len(deskey)):\n                t = (bin(indexbytes(deskey,i))[2:]).rjust(8,'0')\n                if t[:7].count('1') %2 == 0:\n                    temp+= b(chr(int(t[:7]+'1',2)))\n                else:\n                    temp+= b(chr(int(t[:7]+'0',2)))\n            return temp\n\n        if len(sessionKey) > ALGORITHMS_DATA[self['HashAlgo']][4]:\n            derivedKey = HMAC.new(sessionKey,  digestmod = ALGORITHMS_DATA[self['HashAlgo']][1]).digest()\n        else:\n            derivedKey = sessionKey\n\n\n        if len(derivedKey) < ALGORITHMS_DATA[self['CryptAlgo']][0]:\n            # Extend the key\n            derivedKey += b'\\x00'*ALGORITHMS_DATA[self['HashAlgo']][4]\n            ipad = bytearray([ i ^ 0x36 for i in bytearray(derivedKey)][:ALGORITHMS_DATA[self['HashAlgo']][4]])\n            opad = bytearray([ i ^ 0x5c for i in bytearray(derivedKey)][:ALGORITHMS_DATA[self['HashAlgo']][4]])\n            derivedKey = ALGORITHMS_DATA[self['HashAlgo']][1].new(ipad).digest() + \\\n                ALGORITHMS_DATA[self['HashAlgo']][1].new(opad).digest()\n            derivedKey = fixparity(derivedKey)\n\n        return derivedKey\n\n    def decrypt(self, key, entropy = None):\n        keyHash = SHA1.new(key).digest()\n        sessionKey = HMAC.new(keyHash, self['Salt'], ALGORITHMS_DATA[self['HashAlgo']][1])\n        if entropy is not None:\n            sessionKey.update(entropy)\n\n        sessionKey = sessionKey.digest()\n\n        # Derive the key\n        derivedKey = self.deriveKey(sessionKey)\n\n        cipher = ALGORITHMS_DATA[self['CryptAlgo']][1].new(derivedKey[:ALGORITHMS_DATA[self['CryptAlgo']][0]],\n                                mode=ALGORITHMS_DATA[self['CryptAlgo']][2], iv=b'\\x00'*ALGORITHMS_DATA[self['CryptAlgo']][3])\n        cleartext = unpad(cipher.decrypt(self['Data']), ALGORITHMS_DATA[self['CryptAlgo']][1].block_size)\n\n        # Now check the signature\n\n        # ToDo Fix this, it's just ugly, more testing so we can remove one\n        toSign = (self.rawData[20:][:len(self.rawData)-20-len(self['Sign'])-4])\n\n        # Calculate the different HMACKeys\n        keyHash2 = keyHash + b\"\\x00\"*ALGORITHMS_DATA[self['HashAlgo']][1].block_size\n        ipad = bytearray([i ^ 0x36 for i in bytearray(keyHash2)][:ALGORITHMS_DATA[self['HashAlgo']][1].block_size])\n        opad = bytearray([i ^ 0x5c for i in bytearray(keyHash2)][:ALGORITHMS_DATA[self['HashAlgo']][1].block_size])\n        a = ALGORITHMS_DATA[self['HashAlgo']][1].new(ipad)\n        a.update(self['HMac'])\n\n        hmacCalculated1 = ALGORITHMS_DATA[self['HashAlgo']][1].new(opad)\n        hmacCalculated1.update(a.digest())\n\n        if entropy is not None:\n            hmacCalculated1.update(entropy)\n\n        hmacCalculated1.update(toSign)\n\n        hmacCalculated3 = HMAC.new(keyHash, self['HMac'], ALGORITHMS_DATA[self['HashAlgo']][1])\n        if entropy is not None:\n            hmacCalculated3.update(entropy)\n\n        hmacCalculated3.update(toSign)\n\n        if hmacCalculated1.digest() == self['Sign'] or hmacCalculated3.digest() == self['Sign']:\n            return cleartext\n        else:\n            return None",
  "class VAULT_ATTRIBUTE(Structure):\n    structure = (\n        ('Id', '<L=0'),\n        ('Unknown1', '<L=0'),\n        ('Unknown2', '<L=0'),\n        ('Unknown3', '<L=0'),\n    )\n\n    padding = (\n        ('Pad', '6s=b\"\"'),\n    )\n\n    id100 = (\n        ('Unknown5', '<L=0'),\n    )\n\n    extended = (\n        ('Size','<L=0'),\n        ('IVPresent', '<B=?&IVSize'),\n        ('IVSize', '<L=0'),\n        ('_IV', '_-IV', 'self[\"IVSize\"] if self[\"IVSize\"] is not None else 0'),\n        ('IV', ':'),\n        ('_Data','_-Data', 'self[\"Size\"]-self[\"IVSize\"]-5 if self[\"IVPresent\"] else self[\"Size\"]-1'),\n        ('Data',':'),\n    )\n    def __init__(self, data = None, alignment = 0):\n        if len(data) > 20:\n            if data[16:][:6] == b'\\x00'*6:\n                self.structure += self.padding\n            if unpack('<L',data[:4])[0] >= 100:\n                self.structure += self.id100\n            if len(data[16:]) >= 9:\n                self.structure += self.extended\n        Structure.__init__(self, data, alignment)\n\n\n    def dump(self):\n        print(\"[ATTRIBUTE %d]\" % self['Id'])\n        if len(self.rawData) > 28:\n            print(\"Size   : 0x%x\" % self['Size'])\n            if self['IVPresent'] > 0:\n                print(\"IVSize : 0x%x\" % self['IVSize'])\n                print(\"IV     : %s\" % hexlify(self['IV']))\n            print(\"Data   : %s\" % hexlify(self['Data']))",
  "class VAULT_ATTRIBUTE_MAP_ENTRY(Structure):\n    structure = (\n        ('Id', '<L=0'),\n        ('Offset', '<L=0'),\n        ('Unknown1', '<L=0'),\n    )\n    def dump(self):\n        print(\"[MAP ENTRY %d @ 0x%.8x]\" % (self['Id'], self['Offset']))",
  "class VAULT_VCRD(Structure):\n    structure = (\n        ('SchemaGuid', \"16s=b\"\"\"),\n        ('Unknown0', '<L=0'),\n        ('LastWritten', '<Q=0'),\n        ('Unknown1', '<L=0'),\n        ('Unknown2', '<L=0'),\n        ('FriendlyNameLen', '<L=0'),\n        ('FriendlyNameL', '_-FriendlyName', 'self[\"FriendlyNameLen\"]'),\n        ('FriendlyName', ':'),\n        ('AttributesMapsSize', '<L=0'),\n        ('AttributeL', '_-AttributeMaps', 'self[\"AttributesMapsSize\"]'),\n        ('AttributeMaps', ':'),\n        ('Data', ':'),\n    )\n\n    def __init__(self, data = None, alignment = 0):\n        Structure.__init__(self, data, alignment)\n        if data is not None:\n            # Process the MAP entries\n            self.mapEntries = list()\n            data = self['AttributeMaps']\n            for i in range(self['AttributesMapsSize']//len(VAULT_ATTRIBUTE_MAP_ENTRY())):\n                entry = VAULT_ATTRIBUTE_MAP_ENTRY(data)\n                self.mapEntries.append(entry)\n                data = data[len(VAULT_ATTRIBUTE_MAP_ENTRY()):]\n\n            self.attributesLen = list()\n\n            for i in range(len(self.mapEntries)):\n                if i > 0:\n                    self.attributesLen.append(self.mapEntries[i]['Offset']-self.mapEntries[i-1]['Offset'])\n\n            self.attributesLen.append(len(self.rawData) - self.mapEntries[i]['Offset'] )\n\n            self.attributes = list()\n            for i, entry in enumerate(self.mapEntries):\n                attribute = VAULT_ATTRIBUTE(self.rawData[entry['Offset']:][:self.attributesLen[i]])\n                self.attributes.append(attribute)\n\n            # Do we have remaining data?\n            self['Data'] = self.rawData[self.mapEntries[-1]['Offset']+len(self.attributes[-1].getData()):]\n\n    def dump(self):\n        print(\"[VCRD]\")\n        print(\"SchemaGuid  : %s\" % bin_to_string(self['SchemaGuid']))\n        print(\"LastWritten : %s\" % (datetime.utcfromtimestamp(getUnixTime(self['LastWritten']))))\n        print(\"FriendlyName: %s\" % (self['FriendlyName'].decode('utf-16le')))\n        print()\n        for i,entry in enumerate(self.mapEntries):\n            entry.dump()\n            self.attributes[i].dump()\n        print()\n        print(\"Remaining   : %s\" % (hexlify(self['Data'])))\n        print()",
  "class VAULT_VPOL(Structure):\n    structure = (\n        ('Version', '<L=0'),\n        ('Guid', \"16s=b\"\"\"),\n        ('DescriptionLen', '<L=0'),\n        ('_Description', '_-Description', 'self[\"DescriptionLen\"]'),\n        ('Description', ':'),\n        ('Unknown', '12s=b\"\"'),\n        ('Size', '<L=0'),\n        ('Guid2', \"16s=b\"\"\"),\n        ('Guid3', \"16s=b\"\"\"),\n        ('KeySize','<L=0'),\n        ('_Blob', '_-Blob', 'self[\"KeySize\"]'),\n        ('Blob', ':', DPAPI_BLOB),\n    )\n\n    def dump(self):\n        print(\"[VAULT_VPOL]\")\n        print(\"Version      : %8x (%d)\" % (self['Version'], self['Version']))\n        print(\"Guid         : %s\" % bin_to_string(self['Guid']))\n        print(\"Description  : %s\" % (self['Description'].decode('utf-16le')))\n        print(\"Size         : 0x%.8x (%d)\" % (self['Size'], self['Size']))\n        print(\"Guid2        : %s\" % bin_to_string(self['Guid2']))\n        print(\"Guid3        : %s\" % bin_to_string(self['Guid3']))\n        print(\"KeySize      : 0x%.8x (%d)\" % (self['KeySize'], self['KeySize']))\n        self['Blob'].dump()\n        print()",
  "class BCRYPT_KEY_DATA_BLOB_HEADER(Structure):\n    structure = (\n        ('dwMagic','<L=0'),\n        ('dwVersion','<L=0'),\n        ('cbKeyData','<L=0'),\n        ('_bKey','_-bKey', 'self[\"cbKeyData\"]'),\n        ('bKey',':'),\n    )",
  "class BCRYPT_KSSM_DATA_BLOB_HEADER(Structure):\n    structure = (\n        ('cbLength','<L=0'),\n        ('dwKeyMagic','<L=0'),\n        ('dwUnknown2','<L=0'),\n        ('dwUnknown3','<L=0'),\n        ('dwKeyBitLen','<L=0'),\n        ('cbKeyLength','<L=0'),\n        #('_bKey','_-bKey', 'self[\"cbKeyData\"]'),\n        #('AesKey','32s=\"\"'),\n        #('dwUnknown4','<L=0'),\n        #('KeySchedule','448s=\"\"'),\n        #('dwUnknown5','<L=0'),\n        #('cbScheduleLen','<L=0'),\n        #('Unknown6','16s=\"\"'),\n    )",
  "class BCRYPT_KEY_WRAP(Structure):\n    structureKDBM = (\n        ('Size','<L=0'),\n        ('Version','<L=0'),\n        ('Unknown2','<L=0'),\n        ('_bKeyBlob','_-bKeyBlob', 'self[\"Size\"]'),\n        ('bKeyBlob',':', BCRYPT_KEY_DATA_BLOB_HEADER),\n    )\n    structureKSSM = (\n        ('Size','<L=0'),\n        ('Version','<L=0'),\n        ('Unknown2','<L=0'),\n        ('_bKeyBlob','_-bKeyBlob', 'self[\"Size\"]-8'),\n        ('bKeyBlob',':'),\n    )\n    def __init__(self, data = None, alignment = 0):\n        if len(data) >=16:\n            if data[0:1] == b'\\x24' or data[0:1] == b'\\x34':\n                self.structure = self.structureKDBM\n            else:\n                self.structure = self.structureKSSM\n        Structure.__init__(self, data, alignment)",
  "class VAULT_VPOL_KEYS(Structure):\n    structure = (\n        ('Key1',':', BCRYPT_KEY_WRAP),\n        ('Key2',':', BCRYPT_KEY_WRAP),\n    )\n    def dump(self):\n        print(\"[VAULT_VPOL_KEYS]\")\n        if self['Key1']['Size'] > 0x24:\n            print('Key1:')\n            hexdump(self['Key1']['bKeyBlob'])\n            print('Key2:')\n            hexdump(self['Key2']['bKeyBlob'])\n        else:\n            print('Key1: 0x%s' % hexlify(self['Key1']['bKeyBlob']['bKey']).decode('latin-1'))\n            print('Key2: 0x%s' % hexlify(self['Key2']['bKeyBlob']['bKey']).decode('latin-1'))\n            print()",
  "class VAULT_INTERNET_EXPLORER(Structure):\n    structure = (\n        ('Version','<L=0'),\n        ('Count','<L=0'),\n        ('Unknown','<L=0'),\n        ('Id1', '<L=0'),\n        ('UsernameLen', '<L=0'),\n        ('_Username', '_-Username','self[\"UsernameLen\"]'),\n        ('Username', ':'),\n\n        ('Id2', '<L=0'),\n        ('ResourceLen', '<L=0'),\n        ('_Resource', '_-Resource', 'self[\"ResourceLen\"]'),\n        ('Resource', ':'),\n\n        ('Id3', '<L=0'),\n        ('PasswordLen', '<L=0'),\n        ('_Password', '_-Password', 'self[\"PasswordLen\"]'),\n        ('Password', ':'),\n    )\n    def fromString(self, data):\n        Structure.fromString(self, data)\n\n    def dump(self):\n        print(\"[Internet Explorer]\")\n        print('Username        : %s' % self['Username'].decode('utf-16le'))\n        print('Resource        : %s' % self['Resource'].decode('utf-16le'))\n        print('Password        : %s' % (hexlify(self['Password'])))\n        print()",
  "class VAULT_WIN_BIO_KEY(Structure):\n    structure = (\n        ('Version','<L=0'),\n        ('Count','<L=0'),\n        ('Unknown','<L=0'),\n        ('Id1', '<L=0'),\n        ('SidLen', '<L=0'),\n        ('_Sid', '_-Sid','self[\"SidLen\"]'),\n        ('Sid', ':'),\n\n        ('Id2', '<L=0'),\n        ('NameLen', '<L=0'),\n        ('_Name', '_-Name', 'self[\"NameLen\"]'),\n        ('Name', ':'),\n\n        ('Id3', '<L=0'),\n        ('BioKeyLen', '<L=0'),\n        ('_BioKey', '_-BioKey', 'self[\"BioKeyLen\"]'),\n        ('BioKey', ':'),\n    )\n    def fromString(self, data):\n        Structure.fromString(self, data)\n        if data is not None:\n            bioKey = BCRYPT_KEY_DATA_BLOB_HEADER(unhexlify(self['BioKey'].decode('utf-16le')[:-1]))\n            self['BioKey'] = bioKey\n\n    def dump(self):\n        print(\"[WINDOWS BIOMETRIC KEY]\")\n        print('Sid          : %s' % RPC_SID(b'\\x05\\x00\\x00\\x00'+self['Sid']).formatCanonical())\n        print('Friendly Name: %s' % self['Name'].decode('utf-16le'))\n        print('Biometric Key: 0x%s' % (hexlify(self['BioKey']['bKey'])).decode('latin-1'))\n        print()",
  "class NGC_LOCAL_ACCOOUNT(Structure):\n    structure = (\n        ('Version','<L=0'),\n        ('UnlockKeySize','<L=0'),\n        ('IVSize','<L=0'),\n        ('CipherTextSize','<L=0'),\n        ('MustBeZeroTest','<L=0'),\n        ('_UnlockKey', '_-UnlockKey', 'self[\"UnlockKeySize\"]'),\n        ('UnlockKey', ':'),\n        ('_IV', '_-IV', 'self[\"IVSize\"]'),\n        ('IV', ':'),\n        ('_CipherText', '_-CipherText', 'self[\"CipherTextSize\"]'),\n        ('CipherText', ':'),\n    )\n#    def __init__(self, data=None, alignment = 0):\n#        hexdump(data)\n    def dump(self):\n        print(\"[NGC LOCAL ACCOOUNT]\")\n        print('UnlockKey    : %s' % hexlify(self[\"UnlockKey\"]))\n        print('IV           : %s' % hexlify(self[\"IV\"]))\n        print('CipherText   : %s' % hexlify(self[\"CipherText\"]))",
  "class VAULT_NGC_ACCOOUNT(Structure):\n    structure = (\n        ('Version','<L=0'),\n        ('Count','<L=0'),\n        ('Unknown','<L=0'),\n        ('Id1', '<L=0'),\n        ('SidLen', '<L=0'),\n        ('_Sid', '_-Sid','self[\"SidLen\"]'),\n        ('Sid', ':'),\n\n        ('Id2', '<L=0'),\n        ('NameLen', '<L=0'),\n        ('_Name', '_-Name', 'self[\"NameLen\"]'),\n        ('Name', ':'),\n\n        ('Id3', '<L=0'),\n        ('BlobLen', '<L=0'),\n        ('Blob', '_-Blob', 'self[\"BlobLen\"]'),\n        ('Blob', ':', NGC_LOCAL_ACCOOUNT),\n    )\n    def dump(self):\n        print(\"[NGC VAULT]\")\n        print('Sid          : %s' % RPC_SID(b'\\x05\\x00\\x00\\x00'+self['Sid']).formatCanonical())\n        print('Friendly Name: %s' % self['Name'].decode('utf-16le'))\n        self['Blob'].dump()\n        print()",
  "class CREDENTIAL_ATTRIBUTE(Structure):\n    # some info here https://docs.microsoft.com/en-us/windows/desktop/api/wincred/ns-wincred-_credential_attributea\n    structure = (\n        ('Flags','<L=0'),\n\n        ('KeyWordSize', '<L=0'),\n        ('_KeyWord', '_-KeyWord', 'self[\"KeyWordSize\"]'),\n        ('KeyWord', ':'),\n\n        ('DataSize', '<L=0'),\n        ('_Data', '_-Data', 'self[\"DataSize\"]'),\n        ('Data', ':'),\n    )\n\n    def dump(self):\n        print(\"KeyWord : %s\" % (self['KeyWord'].decode('utf-16le')))\n        #print(\"Flags   : %8x (%s)\" % (self['Flags'], getFlags(CREDENTIAL_FLAGS, self['Flags'])))\n        print(\"Data    : \")\n        hexdump(self['Data'])",
  "class CREDENTIAL_BLOB(Structure):\n    # some info here https://docs.microsoft.com/en-us/windows/desktop/api/wincred/ns-wincred-_credentiala\n    structure = (\n        ('Flags','<L=0'),\n        ('Size','<L=0'),\n        ('Unknown0','<L=0'),\n        ('Type','<L=0'),\n        ('Flags2','<L=0'),\n        ('LastWritten','<Q=0'),\n        ('Unknown2','<L=0'),\n        ('Persist','<L=0'),\n        ('AttrCount','<L=0'),\n        ('Unknown3','<Q=0'),\n\n        ('TargetSize','<L=0'),\n        ('_Target','_-Target','self[\"TargetSize\"]'),\n        ('Target',':'),\n\n        ('TargetAliasSize', '<L=0'),\n        ('_TargetAliast', '_-TargetAlias', 'self[\"TargetAliasSize\"]'),\n        ('TargetAlias', ':'),\n\n        ('DescriptionSize', '<L=0'),\n        ('_Description', '_-Description', 'self[\"DescriptionSize\"]'),\n        ('Description', ':'),\n\n        ('UnknownSize', '<L=0'),\n        ('_Unknown', '_-Unknown', 'self[\"UnknownSize\"]'),\n        ('Unknown', ':'),\n\n        ('UsernameSize', '<L=0'),\n        ('_Username', '_-Username', 'self[\"UsernameSize\"]'),\n        ('Username', ':'),\n\n        ('Unknown3Size', '<L=0'),\n        ('_Unknown3', '_-Unknown3', 'self[\"Unknown3Size\"]'),\n        ('Unknown3', ':'),\n\n        ('Remaining', ':'),\n    )\n    def __init__(self, data = None, alignment = 0):\n        Structure.__init__(self, data, alignment)\n        self.attributes = 0\n        if data is not None:\n            # Unpack the attributes\n            remaining = self['Remaining']\n            self.attributes = list()\n            for i in range(self['AttrCount']):\n                attr = CREDENTIAL_ATTRIBUTE(remaining)\n                self.attributes.append(attr)\n                remaining = remaining[len(attr):]\n\n    def dump(self):\n        print(\"[CREDENTIAL]\")\n        print(\"LastWritten : %s\" % (datetime.utcfromtimestamp(getUnixTime(self['LastWritten']))))\n        print(\"Flags       : 0x%.8x (%s)\" % (self['Flags'], getFlags(CREDENTIAL_FLAGS, self['Flags'])))\n        print(\"Persist     : 0x%.8x (%s)\" % (self['Persist'], CREDENTIAL_PERSIST(self['Persist']).name))\n        print(\"Type        : 0x%.8x (%s)\" % (self['Type'], CREDENTIAL_TYPE(self['Type']).name))\n        print(\"Target      : %s\" % (self['Target'].decode('utf-16le')))\n        print(\"Description : %s\" % (self['Description'].decode('utf-16le')))\n        print(\"Unknown     : %s\" % (self['Unknown'].decode('utf-16le')))\n        print(\"Username    : %s\" % (self['Username'].decode('utf-16le')))\n        try:\n            print(\"Unknown     : %s\" % (self['Unknown3'].decode('utf-16le')))\n        except UnicodeDecodeError:\n            print(\"Unknown     : %s\" % (self['Unknown3'].decode('latin-1')))\n\n        print()\n        for entry in self.attributes:\n            entry.dump()",
  "class P_BACKUP_KEY(Structure):\n    structure = (\n        ('Version', '<L=0'),\n        ('Data', ':'),\n    )",
  "class PREFERRED_BACKUP_KEY(Structure):\n    structure = (\n        ('Version', '<L=0'),\n        ('KeyLength', '<L=0'),\n        ('CertificateLength', '<L=0'),\n        ('Data', ':'),\n    )",
  "class PVK_FILE_HDR(Structure):\n    structure = (\n        ('dwMagic', '<L=0'),\n        ('dwVersion', '<L=0'),\n        ('dwKeySpec', '<L=0'),\n        ('dwEncryptType', '<L=0'),\n        ('cbEncryptData', '<L=0'),\n        ('cbPvk', '<L=0'),\n    )",
  "class PUBLICKEYSTRUC(Structure):\n    structure = (\n        ('bType', '<B=0'),\n        ('bVersion', '<B=0'),\n        ('reserved', '<H=0'),\n        ('aiKeyAlg', ALG_ID),\n    )",
  "class RSAPUBKEY(Structure):\n    structure = (\n        ('magic', '<L=0'),\n        ('bitlen', '<L=0'),\n        ('pubexp', '<L=0'),\n    )",
  "class PUBLIC_KEY_BLOB(Structure):\n    structure = (\n        ('publickeystruc', ':', PUBLICKEYSTRUC),\n        ('rsapubkey', ':', RSAPUBKEY),\n        ('_modulus', '_-modulus', 'self[\"rsapubkey\"][\"bitlen\"] // 8'),\n    )",
  "class PRIVATE_KEY_BLOB(Structure):\n    structure = (\n        ('publickeystruc', ':', PUBLICKEYSTRUC),\n        ('rsapubkey', ':', RSAPUBKEY),\n        ('_modulus', '_-modulus', 'self[\"rsapubkey\"][\"bitlen\"] // 8'),\n        ('modulus', ':'),\n        ('_prime1', '_-prime1', 'self[\"rsapubkey\"][\"bitlen\"] // 16'),\n        ('prime1', ':'),\n        ('_prime2', '_-prime2', 'self[\"rsapubkey\"][\"bitlen\"] // 16'),\n        ('prime2', ':'),\n        ('_exponent1', '_-exponent1', 'self[\"rsapubkey\"][\"bitlen\"] // 16'),\n        ('exponent1', ':'),\n        ('_exponent2', '_-exponent2', 'self[\"rsapubkey\"][\"bitlen\"] // 16'),\n        ('exponent2', ':'),\n        ('_coefficient', '_-coefficient', 'self[\"rsapubkey\"][\"bitlen\"] // 16'),\n        ('coefficient', ':'),\n        ('_privateExponent', '_-privateExponent', 'self[\"rsapubkey\"][\"bitlen\"] // 8'),\n        ('privateExponent', ':'),\n    )",
  "class SIMPLE_KEY_BLOB(Structure):\n    structure = (\n        ('publickeystruc', ':', PUBLICKEYSTRUC),\n        ('algid', ALG_ID),\n        ('encryptedkey', ':'),\n    )",
  "class DPAPI_DOMAIN_RSA_MASTER_KEY(Structure):\n    structure = (\n        ('cbMasterKey', '<L=0'),\n        ('cbSuppKey', '<L=0'),\n        ('buffer', ':'),\n    )",
  "def privatekeyblob_to_pkcs1(key):\n    '''\n    parse private key into pkcs#1 format\n    :param key:\n    :return:\n    '''\n    modulus = bytes_to_long(key['modulus'][::-1]) # n\n    prime1 = bytes_to_long(key['prime1'][::-1]) # p\n    prime2 = bytes_to_long(key['prime2'][::-1]) # q\n    exp1 = bytes_to_long(key['exponent1'][::-1])\n    exp2 = bytes_to_long(key['exponent2'][::-1])\n    coefficient = bytes_to_long(key['coefficient'][::-1])\n    privateExp = bytes_to_long(key['privateExponent'][::-1]) # d\n    if PY3:\n        long = int\n    pubExp = long(key['rsapubkey']['pubexp']) # e\n    # RSA.Integer(prime2).inverse(prime1) # u\n\n    r = RSA.construct((modulus, pubExp, privateExp, prime1, prime2))\n    return r",
  "def dump(self):\n        print(\"[MASTERKEYFILE]\")\n        print(\"Version     : %8x (%d)\" % (self['Version'], self['Version']))\n        print(\"Guid        : %s\" % self['Guid'].decode('utf-16le'))\n        print(\"Flags       : %8x (%d)\" % (self['Flags'], self['Flags']))\n        print(\"Policy      : %8x (%d)\" % (self['Policy'], self['Policy']))\n        print(\"MasterKeyLen: %.8x (%d)\" % (self['MasterKeyLen'], self['MasterKeyLen']))\n        print(\"BackupKeyLen: %.8x (%d)\" % (self['BackupKeyLen'], self['BackupKeyLen']))\n        print(\"CredHistLen : %.8x (%d)\" % (self['CredHistLen'], self['CredHistLen']))\n        print(\"DomainKeyLen: %.8x (%d)\" % (self['DomainKeyLen'], self['DomainKeyLen']))\n        print()",
  "def __init__(self, data = None, alignment = 0):\n        Structure.__init__(self, data, alignment)\n        self.decryptedKey = None",
  "def dump(self):\n        print(\"[MASTERKEY]\")\n        print(\"Version     : %8x (%d)\" % (self['Version'], self['Version']))\n        print(\"Salt        : %s\" % hexlify(self['Salt']))\n        print(\"Rounds      : %8x (%d)\" % (self['MasterKeyIterationCount'], self['MasterKeyIterationCount']))\n        print(\"HashAlgo    : %.8x (%d) (%s)\" % (self['HashAlgo'], self['HashAlgo'], ALGORITHMS(self['HashAlgo']).name))\n        print(\"CryptAlgo   : %.8x (%d) (%s)\" % (self['CryptAlgo'], self['CryptAlgo'], ALGORITHMS(self['CryptAlgo']).name))\n        print(\"data        : %s\" % (hexlify(self['data'])))\n        print()",
  "def deriveKey(self, passphrase, salt, keylen, count, hashFunction):\n        keyMaterial = b\"\"\n        i = 1\n        while len(keyMaterial) < keylen:\n            U = salt + pack(\"!L\", i)\n            i += 1\n            derived = bytearray(hashFunction(passphrase, U))\n            for r in range(count - 1):\n                actual = bytearray(hashFunction(passphrase, derived))\n                if PY3:\n                    derived = (int.from_bytes(derived, sys.byteorder) ^ int.from_bytes(actual, sys.byteorder)).to_bytes(len(actual), sys.byteorder)\n                else:\n                    derived = bytearray([ chr((a) ^ (b)) for (a,b) in zip(derived, actual) ])\n            keyMaterial += derived\n\n        return keyMaterial[:keylen]",
  "def decrypt(self, key):\n        if self['HashAlgo'] == ALGORITHMS.CALG_HMAC.value:\n            hashModule = SHA1\n        else:\n            hashModule = ALGORITHMS_DATA[self['HashAlgo']][1]\n\n        prf = lambda p, s: HMAC.new(p, s, hashModule).digest()\n        derivedBlob = self.deriveKey(key, self['Salt'],\n                                    ALGORITHMS_DATA[self['CryptAlgo']][0] + ALGORITHMS_DATA[self['CryptAlgo']][3],\n                                    count=self['MasterKeyIterationCount'], hashFunction=prf)\n\n        cryptKey = derivedBlob[:ALGORITHMS_DATA[self['CryptAlgo']][0]]\n        iv = derivedBlob[ALGORITHMS_DATA[self['CryptAlgo']][0]:][:ALGORITHMS_DATA[self['CryptAlgo']][3]]\n\n        cipher = ALGORITHMS_DATA[self['CryptAlgo']][1].new(cryptKey, mode = ALGORITHMS_DATA[self['CryptAlgo']][2], iv = iv)\n        cleartext = cipher.decrypt(self['data'])\n\n        decryptedKey = cleartext[-64:]\n        hmacSalt = cleartext[:16]\n        hmac = cleartext[16:][:ALGORITHMS_DATA[self['HashAlgo']][0]]\n\n        hmacKey = HMAC.new(key, hmacSalt, hashModule).digest()\n\n        hmacCalculated = HMAC.new(hmacKey, decryptedKey, hashModule ).digest()\n\n        if hmacCalculated[:ALGORITHMS_DATA[self['HashAlgo']][0]] == hmac:\n            self.decryptedKey = decryptedKey\n            return decryptedKey\n        else:\n            return None",
  "def dump(self):\n        print(\"[CREDHIST]\")\n        print(\"Version       : %8x (%d)\" % (self['Version'], self['Version']))\n        print(\"Guid          : %s\" % bin_to_string(self['Guid']))\n        print()",
  "def dump(self):\n        print(\"[DOMAINKEY]\")\n        print(\"Version       : %8x (%d)\" % (self['Version'], self['Version']))\n        print(\"Guid          : %s\" % bin_to_string(self['Guid']))\n        print(\"SecretLen     : %8x (%d)\" % (self['SecretLen'], self['SecretLen']))\n        print(\"AccessCheckLen: %.8x (%d)\" % (self['AccessCheckLen'], self['AccessCheckLen']))\n        print(\"SecretData    : %s\" % (hexlify(self['SecretData'])))\n        print(\"AccessCheck   : %s\" % (hexlify(self['AccessCheck'])))\n        print()",
  "def dump(self):\n        print(\"[DPAPI_SYSTEM]\")\n        print(\"Version    : %8x (%d)\" % (self['Version'], self['Version']))\n        print(\"MachineKey : 0x%s\" % hexlify(self['MachineKey']).decode('latin-1'))\n        print(\"UserKey    : 0x%s\" % hexlify(self['UserKey']).decode('latin-1'))\n        print()",
  "def dump(self):\n        print(\"[BLOB]\")\n        print(\"Version          : %8x (%d)\" % (self['Version'], self['Version']))\n        print(\"Guid Credential  : %s\" % bin_to_string(self['GuidCredential']))\n        print(\"MasterKeyVersion : %8x (%d)\" % (self['MasterKeyVersion'], self['MasterKeyVersion']))\n        print(\"Guid MasterKey   : %s\" % bin_to_string(self['GuidMasterKey']))\n        print(\"Flags            : %8x (%s)\" % (self['Flags'], getFlags(FLAGS, self['Flags'])))\n        print(\"Description      : %s\" % (self['Description'].decode('utf-16le')))\n        print(\"CryptAlgo        : %.8x (%d) (%s)\" % (self['CryptAlgo'], self['CryptAlgo'], ALGORITHMS(self['CryptAlgo']).name))\n        print(\"Salt             : %s\" % (hexlify(self['Salt'])))\n        print(\"HMacKey          : %s\" % (hexlify(self['HMacKey'])))\n        print(\"HashAlgo         : %.8x (%d) (%s)\" % (self['HashAlgo'], self['HashAlgo'], ALGORITHMS(self['HashAlgo']).name))\n        print(\"HMac             : %s\" % (hexlify(self['HMac'])))\n        print(\"Data             : %s\" % (hexlify(self['Data'])))\n        print(\"Sign             : %s\" % (hexlify(self['Sign'])))\n        print()",
  "def deriveKey(self, sessionKey):\n        def fixparity(deskey):\n            from six import indexbytes, b\n            temp = b''\n            for i in range(len(deskey)):\n                t = (bin(indexbytes(deskey,i))[2:]).rjust(8,'0')\n                if t[:7].count('1') %2 == 0:\n                    temp+= b(chr(int(t[:7]+'1',2)))\n                else:\n                    temp+= b(chr(int(t[:7]+'0',2)))\n            return temp\n\n        if len(sessionKey) > ALGORITHMS_DATA[self['HashAlgo']][4]:\n            derivedKey = HMAC.new(sessionKey,  digestmod = ALGORITHMS_DATA[self['HashAlgo']][1]).digest()\n        else:\n            derivedKey = sessionKey\n\n\n        if len(derivedKey) < ALGORITHMS_DATA[self['CryptAlgo']][0]:\n            # Extend the key\n            derivedKey += b'\\x00'*ALGORITHMS_DATA[self['HashAlgo']][4]\n            ipad = bytearray([ i ^ 0x36 for i in bytearray(derivedKey)][:ALGORITHMS_DATA[self['HashAlgo']][4]])\n            opad = bytearray([ i ^ 0x5c for i in bytearray(derivedKey)][:ALGORITHMS_DATA[self['HashAlgo']][4]])\n            derivedKey = ALGORITHMS_DATA[self['HashAlgo']][1].new(ipad).digest() + \\\n                ALGORITHMS_DATA[self['HashAlgo']][1].new(opad).digest()\n            derivedKey = fixparity(derivedKey)\n\n        return derivedKey",
  "def decrypt(self, key, entropy = None):\n        keyHash = SHA1.new(key).digest()\n        sessionKey = HMAC.new(keyHash, self['Salt'], ALGORITHMS_DATA[self['HashAlgo']][1])\n        if entropy is not None:\n            sessionKey.update(entropy)\n\n        sessionKey = sessionKey.digest()\n\n        # Derive the key\n        derivedKey = self.deriveKey(sessionKey)\n\n        cipher = ALGORITHMS_DATA[self['CryptAlgo']][1].new(derivedKey[:ALGORITHMS_DATA[self['CryptAlgo']][0]],\n                                mode=ALGORITHMS_DATA[self['CryptAlgo']][2], iv=b'\\x00'*ALGORITHMS_DATA[self['CryptAlgo']][3])\n        cleartext = unpad(cipher.decrypt(self['Data']), ALGORITHMS_DATA[self['CryptAlgo']][1].block_size)\n\n        # Now check the signature\n\n        # ToDo Fix this, it's just ugly, more testing so we can remove one\n        toSign = (self.rawData[20:][:len(self.rawData)-20-len(self['Sign'])-4])\n\n        # Calculate the different HMACKeys\n        keyHash2 = keyHash + b\"\\x00\"*ALGORITHMS_DATA[self['HashAlgo']][1].block_size\n        ipad = bytearray([i ^ 0x36 for i in bytearray(keyHash2)][:ALGORITHMS_DATA[self['HashAlgo']][1].block_size])\n        opad = bytearray([i ^ 0x5c for i in bytearray(keyHash2)][:ALGORITHMS_DATA[self['HashAlgo']][1].block_size])\n        a = ALGORITHMS_DATA[self['HashAlgo']][1].new(ipad)\n        a.update(self['HMac'])\n\n        hmacCalculated1 = ALGORITHMS_DATA[self['HashAlgo']][1].new(opad)\n        hmacCalculated1.update(a.digest())\n\n        if entropy is not None:\n            hmacCalculated1.update(entropy)\n\n        hmacCalculated1.update(toSign)\n\n        hmacCalculated3 = HMAC.new(keyHash, self['HMac'], ALGORITHMS_DATA[self['HashAlgo']][1])\n        if entropy is not None:\n            hmacCalculated3.update(entropy)\n\n        hmacCalculated3.update(toSign)\n\n        if hmacCalculated1.digest() == self['Sign'] or hmacCalculated3.digest() == self['Sign']:\n            return cleartext\n        else:\n            return None",
  "def __init__(self, data = None, alignment = 0):\n        if len(data) > 20:\n            if data[16:][:6] == b'\\x00'*6:\n                self.structure += self.padding\n            if unpack('<L',data[:4])[0] >= 100:\n                self.structure += self.id100\n            if len(data[16:]) >= 9:\n                self.structure += self.extended\n        Structure.__init__(self, data, alignment)",
  "def dump(self):\n        print(\"[ATTRIBUTE %d]\" % self['Id'])\n        if len(self.rawData) > 28:\n            print(\"Size   : 0x%x\" % self['Size'])\n            if self['IVPresent'] > 0:\n                print(\"IVSize : 0x%x\" % self['IVSize'])\n                print(\"IV     : %s\" % hexlify(self['IV']))\n            print(\"Data   : %s\" % hexlify(self['Data']))",
  "def dump(self):\n        print(\"[MAP ENTRY %d @ 0x%.8x]\" % (self['Id'], self['Offset']))",
  "def __init__(self, data = None, alignment = 0):\n        Structure.__init__(self, data, alignment)\n        if data is not None:\n            # Process the MAP entries\n            self.mapEntries = list()\n            data = self['AttributeMaps']\n            for i in range(self['AttributesMapsSize']//len(VAULT_ATTRIBUTE_MAP_ENTRY())):\n                entry = VAULT_ATTRIBUTE_MAP_ENTRY(data)\n                self.mapEntries.append(entry)\n                data = data[len(VAULT_ATTRIBUTE_MAP_ENTRY()):]\n\n            self.attributesLen = list()\n\n            for i in range(len(self.mapEntries)):\n                if i > 0:\n                    self.attributesLen.append(self.mapEntries[i]['Offset']-self.mapEntries[i-1]['Offset'])\n\n            self.attributesLen.append(len(self.rawData) - self.mapEntries[i]['Offset'] )\n\n            self.attributes = list()\n            for i, entry in enumerate(self.mapEntries):\n                attribute = VAULT_ATTRIBUTE(self.rawData[entry['Offset']:][:self.attributesLen[i]])\n                self.attributes.append(attribute)\n\n            # Do we have remaining data?\n            self['Data'] = self.rawData[self.mapEntries[-1]['Offset']+len(self.attributes[-1].getData()):]",
  "def dump(self):\n        print(\"[VCRD]\")\n        print(\"SchemaGuid  : %s\" % bin_to_string(self['SchemaGuid']))\n        print(\"LastWritten : %s\" % (datetime.utcfromtimestamp(getUnixTime(self['LastWritten']))))\n        print(\"FriendlyName: %s\" % (self['FriendlyName'].decode('utf-16le')))\n        print()\n        for i,entry in enumerate(self.mapEntries):\n            entry.dump()\n            self.attributes[i].dump()\n        print()\n        print(\"Remaining   : %s\" % (hexlify(self['Data'])))\n        print()",
  "def dump(self):\n        print(\"[VAULT_VPOL]\")\n        print(\"Version      : %8x (%d)\" % (self['Version'], self['Version']))\n        print(\"Guid         : %s\" % bin_to_string(self['Guid']))\n        print(\"Description  : %s\" % (self['Description'].decode('utf-16le')))\n        print(\"Size         : 0x%.8x (%d)\" % (self['Size'], self['Size']))\n        print(\"Guid2        : %s\" % bin_to_string(self['Guid2']))\n        print(\"Guid3        : %s\" % bin_to_string(self['Guid3']))\n        print(\"KeySize      : 0x%.8x (%d)\" % (self['KeySize'], self['KeySize']))\n        self['Blob'].dump()\n        print()",
  "def __init__(self, data = None, alignment = 0):\n        if len(data) >=16:\n            if data[0:1] == b'\\x24' or data[0:1] == b'\\x34':\n                self.structure = self.structureKDBM\n            else:\n                self.structure = self.structureKSSM\n        Structure.__init__(self, data, alignment)",
  "def dump(self):\n        print(\"[VAULT_VPOL_KEYS]\")\n        if self['Key1']['Size'] > 0x24:\n            print('Key1:')\n            hexdump(self['Key1']['bKeyBlob'])\n            print('Key2:')\n            hexdump(self['Key2']['bKeyBlob'])\n        else:\n            print('Key1: 0x%s' % hexlify(self['Key1']['bKeyBlob']['bKey']).decode('latin-1'))\n            print('Key2: 0x%s' % hexlify(self['Key2']['bKeyBlob']['bKey']).decode('latin-1'))\n            print()",
  "def fromString(self, data):\n        Structure.fromString(self, data)",
  "def dump(self):\n        print(\"[Internet Explorer]\")\n        print('Username        : %s' % self['Username'].decode('utf-16le'))\n        print('Resource        : %s' % self['Resource'].decode('utf-16le'))\n        print('Password        : %s' % (hexlify(self['Password'])))\n        print()",
  "def fromString(self, data):\n        Structure.fromString(self, data)\n        if data is not None:\n            bioKey = BCRYPT_KEY_DATA_BLOB_HEADER(unhexlify(self['BioKey'].decode('utf-16le')[:-1]))\n            self['BioKey'] = bioKey",
  "def dump(self):\n        print(\"[WINDOWS BIOMETRIC KEY]\")\n        print('Sid          : %s' % RPC_SID(b'\\x05\\x00\\x00\\x00'+self['Sid']).formatCanonical())\n        print('Friendly Name: %s' % self['Name'].decode('utf-16le'))\n        print('Biometric Key: 0x%s' % (hexlify(self['BioKey']['bKey'])).decode('latin-1'))\n        print()",
  "def dump(self):\n        print(\"[NGC LOCAL ACCOOUNT]\")\n        print('UnlockKey    : %s' % hexlify(self[\"UnlockKey\"]))\n        print('IV           : %s' % hexlify(self[\"IV\"]))\n        print('CipherText   : %s' % hexlify(self[\"CipherText\"]))",
  "def dump(self):\n        print(\"[NGC VAULT]\")\n        print('Sid          : %s' % RPC_SID(b'\\x05\\x00\\x00\\x00'+self['Sid']).formatCanonical())\n        print('Friendly Name: %s' % self['Name'].decode('utf-16le'))\n        self['Blob'].dump()\n        print()",
  "def dump(self):\n        print(\"KeyWord : %s\" % (self['KeyWord'].decode('utf-16le')))\n        #print(\"Flags   : %8x (%s)\" % (self['Flags'], getFlags(CREDENTIAL_FLAGS, self['Flags'])))\n        print(\"Data    : \")\n        hexdump(self['Data'])",
  "def __init__(self, data = None, alignment = 0):\n        Structure.__init__(self, data, alignment)\n        self.attributes = 0\n        if data is not None:\n            # Unpack the attributes\n            remaining = self['Remaining']\n            self.attributes = list()\n            for i in range(self['AttrCount']):\n                attr = CREDENTIAL_ATTRIBUTE(remaining)\n                self.attributes.append(attr)\n                remaining = remaining[len(attr):]",
  "def dump(self):\n        print(\"[CREDENTIAL]\")\n        print(\"LastWritten : %s\" % (datetime.utcfromtimestamp(getUnixTime(self['LastWritten']))))\n        print(\"Flags       : 0x%.8x (%s)\" % (self['Flags'], getFlags(CREDENTIAL_FLAGS, self['Flags'])))\n        print(\"Persist     : 0x%.8x (%s)\" % (self['Persist'], CREDENTIAL_PERSIST(self['Persist']).name))\n        print(\"Type        : 0x%.8x (%s)\" % (self['Type'], CREDENTIAL_TYPE(self['Type']).name))\n        print(\"Target      : %s\" % (self['Target'].decode('utf-16le')))\n        print(\"Description : %s\" % (self['Description'].decode('utf-16le')))\n        print(\"Unknown     : %s\" % (self['Unknown'].decode('utf-16le')))\n        print(\"Username    : %s\" % (self['Username'].decode('utf-16le')))\n        try:\n            print(\"Unknown     : %s\" % (self['Unknown3'].decode('utf-16le')))\n        except UnicodeDecodeError:\n            print(\"Unknown     : %s\" % (self['Unknown3'].decode('latin-1')))\n\n        print()\n        for entry in self.attributes:\n            entry.dump()",
  "def fixparity(deskey):\n            from six import indexbytes, b\n            temp = b''\n            for i in range(len(deskey)):\n                t = (bin(indexbytes(deskey,i))[2:]).rjust(8,'0')\n                if t[:7].count('1') %2 == 0:\n                    temp+= b(chr(int(t[:7]+'1',2)))\n                else:\n                    temp+= b(chr(int(t[:7]+'0',2)))\n            return temp",
  "class BootpPacket(ProtocolPacket, structure.Structure):\n    commonHdr = (\n            ('op','b'),\n            ('htype','b=1'),    # 1 = Ether\n            ('hlen','b=len(chaddr)'),\n            ('hops','b=0'),\n            ('xid','!L=0'),\n            ('secs','!H=0'),\n            ('flags','!H=0'),\n            ('ciaddr','!L=0'),\n            ('yiaddr','!L=0'),\n            ('siaddr','!L=0'),\n            ('giaddr','!L=0'),\n            ('_chaddr','16s=chaddr'),\n            ('chaddr','_','_chaddr[:hlen]'),\n            ('sname','64s=\"\"'),\n            ('file','128s=\"\"'))\n\n    def __init__(self, data = None, alignment = 0):\n        structure.Structure.__init__(self, data, alignment)",
  "class DhcpPacket(ProtocolPacket, structure.Structure):\n    # DHCP: https://www.ietf.org/rfc/rfc2131.txt\n    # DHCP Options: https://www.ietf.org/rfc/rfc1533.txt\n    # good list of options: http://www.networksorcery.com/enp/protocol/bootp/options.htm\n    MAGIC_NUMBER = 0x63825363\n    BOOTREQUEST = 1\n    BOOTREPLY   = 2\n\n    DHCPDISCOVER= 1\n    DHCPOFFER   = 2\n    DHCPREQUEST = 3 \n    DHCPDECLINE = 4\n    DHCPACK     = 5\n    DHCPNAK     = 6\n    DHCPRELEASE = 7\n    DHCPINFORM  = 8\n\n    options = {\n        # 3. Vendor Extensions\n        'pad':(0,'_'),\n        'subnet-mask':(1,'!L'),\n        'time-offset':(2,'!L'),\n        'router':(3,'*!L'),\n        'time-server':(4,'*!L'),\n        'name-server':(5,'*!L'),\n        'domain-name-server':(6,'*!L'),\n        'log-server':(7,'*!L'),\n        'cookie-server':(8,'*!L'),\n        'lpr-server':(9,'*!L'),\n        'impress-server':(10,'*!L'),\n        'resource-locator-server':(11,'*!L'),\n        'host-name':(12,':'),\n        'boot-file-size':(13,'!H'),\n        'merit-dump-file':(14,':'),\n        'domain-name':(15,':'),\n        'swap-server':(16,':'),\n        'root-path':(17,':'),\n        'extensions-path':(18,':'),\n\n        # 4. IP Layer Parameters per Host\n        'ip-forwarding':(19,'B'),\n        'non-local-source-routing':(20,'B'),\n        'policy-filter':(21,'*!L'),\n        'maximum-datagram-reassembly-size':(22,'!H'),\n        'default-ip-ttl':(23,'B'),\n        'path-mtu-aging-timeout':(24,'!L'),\n        'path-mtu-plateau-table':(25,'*!H'),\n\n        # 5. IP Layer Parameters per Interface\n        'interface-mtu':(26,'!H'),\n        'all-subnets-are-local':(27,'B'),\n        'broadcast-address':(28,'!L'),\n        'perform-mask-discovery':(29,'B'),\n        'mask-supplier':(30,'B'),\n        'perform-router-discovery':(31,'B'),\n        'router-solicitation-address':(32,'!L'),\n        'static-route':(33,'*!L'),\n\n        # 6. Link Layer Parameters per Interface\n        'trailer-encapsulation':(34,'B'),\n        'arp-cache-timeout':(35,'!L'),\n        'ethernet-encapsulation':(36,'B'),\n\n        # 7. TCP parameters\n        'tcp-default-ttl':(37,'B'),\n        'tcp-keepalive-interval':(38,'!L'),\n        'tcp-keepalive-garbage':(39,'B'),\n\n        # 8. Application and Service parameters\n        'nis-domain':(40,':'),\n        'nis-servers':(41,'*!L'),\n        'ntp-servers':(42,'*!L'),\n        'vendor-specific':(43,':'),\n        'netbios-name-server':(44,'*!L'),\n        'netbios-datagrame-distribution-server':(45,'*!L'),\n        'netbios-node-type':(46,'B'),\n        'netbios-scope':(47,':'),\n        'x11-font-server':(48,'*!L'),\n        'x11-display-manager':(49,'*!L'),\n\n\n        # 9. DHCP Extensions\n        'requested-ip':(50,'!L'),\n        'lease-time':(51,'!L'),\n        'option-overload':(52,'B'),\n        'message-type':(53,'B'),\n        'server-id':(54,'!L'),\n        'parameter-request-list':(55,':'),\n        'message':(56,':'),\n        'maximum-dhcp-message-size':(57,'!H'),\n        'renewal-time':(58,'!L'),\n        'rebinding-time':(59,'!L'),\n        'vendor-class':(60,':'),\n        'client-id':(61,':'),\n\n        # other non-rfc1533 options\n        'slp-directory-agent':(78,':'),           # https://www.ietf.org/rfc/rfc2610.txt\n        'slp-service-scope':(79,':'),             # https://www.ietf.org/rfc/rfc2610.txt\n        'fully-qualified-domain-name':(81,':'),   # https://www.ietf.org/rfc/rfc4702.txt\n        'default-url': (114, ':'),                # text (URL) - not defined in any RFC but assigned by IANA\n        'auto-configuration':(116,'B'),           # https://www.ietf.org/rfc/rfc2563.txt\n        'domain-search-list':(119,':'),           # https://www.ietf.org/rfc/rfc3397.txt\n        'classless-route-121':(121, ':'),         # https://www.ietf.org/rfc/rfc3442.txt\n        'classless-route-249':(249, ':'),         # https://web.archive.org/web/20140205135249/support.microsoft.com/kb/121005\n        'proxy-autoconfig':(252,':'),\n        'eof':(255,'_'),\n    }\n\n    structure = (\n            ('cookie','!L'),\n            ('_options',':=self.packOptions(options)'),\n            ('options','_','self.unpackOptions(_options)'))\n\n    def __init__(self, data = None, alignment = 0):\n        structure.Structure.__init__(self, data, alignment)\n\n    def packOptions(self, options):\n        # options is an array of tuples: ('name',value)\n\n        answer = b''\n        for name, value in options:\n            code,format = self.options[name]\n            val = self.pack(format, value)\n            answer += b'%c%c%s' % (code, len(val), val)\n\n        return answer\n\n    def getOptionNameAndFormat(self, optionCode):\n        for k in self.options:\n            code,format = self.options[k]\n            if code == optionCode: return k, format\n        return optionCode, ':'\n\n    def unpackOptions(self, options):\n        # options is a string\n\n        # print '%r' % options\n        answer = []\n        i = 0\n        options = bytearray(options)\n        while i < len(options)-1:\n            name, format = self.getOptionNameAndFormat(options[i])\n            # size = self.calcUnpackSize(format, options[i+1:])\n            size = options[i+1]\n            # print i, name, format, size\n            value = self.unpack(format, options[i+2:i+2+size])\n            answer.append((name, value))\n            i += 2+size\n\n        return answer\n\n    def unpackParameterRequestList(self, options):\n        return [self.getOptionNameAndFormat(ord(opt))[0] for opt in options]\n\n    def isAskingForProxyAutodiscovery(self):\n        for opt in self.fields['options']:\n            if opt[0] == 'parameter-request-list':\n                for optCode in opt[1]:\n                    if ord(optCode) == 252:\n                        return True\n        return False\n\n    def getOptionValue(self, name):\n        for opt in self.fields['options']:\n            if opt[0] == name:\n                return opt[1]\n        return None",
  "def __init__(self, data = None, alignment = 0):\n        structure.Structure.__init__(self, data, alignment)",
  "def __init__(self, data = None, alignment = 0):\n        structure.Structure.__init__(self, data, alignment)",
  "def packOptions(self, options):\n        # options is an array of tuples: ('name',value)\n\n        answer = b''\n        for name, value in options:\n            code,format = self.options[name]\n            val = self.pack(format, value)\n            answer += b'%c%c%s' % (code, len(val), val)\n\n        return answer",
  "def getOptionNameAndFormat(self, optionCode):\n        for k in self.options:\n            code,format = self.options[k]\n            if code == optionCode: return k, format\n        return optionCode, ':'",
  "def unpackOptions(self, options):\n        # options is a string\n\n        # print '%r' % options\n        answer = []\n        i = 0\n        options = bytearray(options)\n        while i < len(options)-1:\n            name, format = self.getOptionNameAndFormat(options[i])\n            # size = self.calcUnpackSize(format, options[i+1:])\n            size = options[i+1]\n            # print i, name, format, size\n            value = self.unpack(format, options[i+2:i+2+size])\n            answer.append((name, value))\n            i += 2+size\n\n        return answer",
  "def unpackParameterRequestList(self, options):\n        return [self.getOptionNameAndFormat(ord(opt))[0] for opt in options]",
  "def isAskingForProxyAutodiscovery(self):\n        for opt in self.fields['options']:\n            if opt[0] == 'parameter-request-list':\n                for optCode in opt[1]:\n                    if ord(optCode) == 252:\n                        return True\n        return False",
  "def getOptionValue(self, name):\n        for opt in self.fields['options']:\n            if opt[0] == name:\n                return opt[1]\n        return None",
  "def generate():\n    # UHm... crappy Python has an maximum integer of 2**31-1.\n    top = (1<<31)-1\n    return pack(\"IIII\", randrange(top), randrange(top), randrange(top), randrange(top))",
  "def bin_to_string(uuid):\n    uuid1, uuid2, uuid3 = unpack('<LHH', uuid[:8])\n    uuid4, uuid5, uuid6 = unpack('>HHL', uuid[8:16])\n    return '%08X-%04X-%04X-%04X-%04X%08X' % (uuid1, uuid2, uuid3, uuid4, uuid5, uuid6)",
  "def string_to_bin(uuid):\n    # If a UUID in the 00000000000000000000000000000000 format, let's return bytes as is\n    if '-' not in uuid:\n        return binascii.unhexlify(uuid)\n\n    # If a UUID in the 00000000-0000-0000-0000-000000000000 format, parse it as Variant 2 UUID\n    # The first three components of the UUID are little-endian, and the last two are big-endian\n    matches = re.match(r\"([\\dA-Fa-f]{8})-([\\dA-Fa-f]{4})-([\\dA-Fa-f]{4})-([\\dA-Fa-f]{4})-([\\dA-Fa-f]{4})([\\dA-Fa-f]{8})\",\n                       uuid)\n    (uuid1, uuid2, uuid3, uuid4, uuid5, uuid6) = [int(x, 16) for x in matches.groups()]\n    uuid = pack('<LHH', uuid1, uuid2, uuid3)\n    uuid += pack('>HHL', uuid4, uuid5, uuid6)\n    return uuid",
  "def stringver_to_bin(s):\n    (maj, min) = s.split('.')\n    return pack('<H', int(maj)) + pack('<H', int(min))",
  "def uuidtup_to_bin(tup):\n    if len(tup) != 2:\n        return\n    return string_to_bin(tup[0]) + stringver_to_bin(tup[1])",
  "def bin_to_uuidtup(bin):\n    assert len(bin) == 20\n    uuidstr = bin_to_string(bin[:16])\n    maj, min = unpack(\"<HH\", bin[16:])\n    return uuidstr, \"%d.%d\" % (maj, min)",
  "def string_to_uuidtup(s):\n    \"\"\"\n    if version is not found in the input string \"1.0\"  is returned\n    example:\n              \"00000000-0000-0000-0000-000000000000 3.0\" returns ('00000000-0000-0000-0000-000000000000','3.0')\n              \"10000000-2000-3000-4000-500000000000 version 3.0\" returns ('00000000-0000-0000-0000-000000000000','3.0')\n              \"10000000-2000-3000-4000-500000000000 v 3.0\" returns ('00000000-0000-0000-0000-000000000000','3.0')\n              \"10000000-2000-3000-4000-500000000000\" returns ('00000000-0000-0000-0000-000000000000','1.0')\n\n    :param s: string\n    :return: tuple (uuid,version)\n    \"\"\"\n    g = re.search(r\"([A-Fa-f0-9]{8}-[A-Fa-f0-9]{4}-[A-Fa-f0-9]{4}-[A-Fa-f0-9]{4}-[A-Fa-f0-9]{12}).*?([0-9]{1,5}\\.[0-9]{1,5})\",\n                  s + \" 1.0\")\n    if g: \n        (u, v) = g.groups()\n        return u, v\n    return",
  "def uuidtup_to_string(tup):\n    uuid, (maj, min) = tup\n    return \"%s v%d.%d\" % (uuid, maj, min)",
  "class ESENT_JET_SIGNATURE(Structure):\n    structure = (\n        ('Random','<L=0'),\n        ('CreationTime','<Q=0'),\n        ('NetBiosName','16s=b\"\"'),\n    )",
  "class ESENT_DB_HEADER(Structure):\n    structure = (\n        ('CheckSum','<L=0'),\n        ('Signature','\"\\xef\\xcd\\xab\\x89'),\n        ('Version','<L=0'),\n        ('FileType','<L=0'),\n        ('DBTime','<Q=0'),\n        ('DBSignature',':',ESENT_JET_SIGNATURE),\n        ('DBState','<L=0'),\n        ('ConsistentPosition','<Q=0'),\n        ('ConsistentTime','<Q=0'),\n        ('AttachTime','<Q=0'),\n        ('AttachPosition','<Q=0'),\n        ('DetachTime','<Q=0'),\n        ('DetachPosition','<Q=0'),\n        ('LogSignature',':',ESENT_JET_SIGNATURE),\n        ('Unknown','<L=0'),\n        ('PreviousBackup','24s=b\"\"'),\n        ('PreviousIncBackup','24s=b\"\"'),\n        ('CurrentFullBackup','24s=b\"\"'),\n        ('ShadowingDisables','<L=0'),\n        ('LastObjectID','<L=0'),\n        ('WindowsMajorVersion','<L=0'),\n        ('WindowsMinorVersion','<L=0'),\n        ('WindowsBuildNumber','<L=0'),\n        ('WindowsServicePackNumber','<L=0'),\n        ('FileFormatRevision','<L=0'),\n        ('PageSize','<L=0'),\n        ('RepairCount','<L=0'),\n        ('RepairTime','<Q=0'),\n        ('Unknown2','28s=b\"\"'),\n        ('ScrubTime','<Q=0'),\n        ('RequiredLog','<Q=0'),\n        ('UpgradeExchangeFormat','<L=0'),\n        ('UpgradeFreePages','<L=0'),\n        ('UpgradeSpaceMapPages','<L=0'),\n        ('CurrentShadowBackup','24s=b\"\"'),\n        ('CreationFileFormatVersion','<L=0'),\n        ('CreationFileFormatRevision','<L=0'),\n        ('Unknown3','16s=b\"\"'),\n        ('OldRepairCount','<L=0'),\n        ('ECCCount','<L=0'),\n        ('LastECCTime','<Q=0'),\n        ('OldECCFixSuccessCount','<L=0'),\n        ('ECCFixErrorCount','<L=0'),\n        ('LastECCFixErrorTime','<Q=0'),\n        ('OldECCFixErrorCount','<L=0'),\n        ('BadCheckSumErrorCount','<L=0'),\n        ('LastBadCheckSumTime','<Q=0'),\n        ('OldCheckSumErrorCount','<L=0'),\n        ('CommittedLog','<L=0'),\n        ('PreviousShadowCopy','24s=b\"\"'),\n        ('PreviousDifferentialBackup','24s=b\"\"'),\n        ('Unknown4','40s=b\"\"'),\n        ('NLSMajorVersion','<L=0'),\n        ('NLSMinorVersion','<L=0'),\n        ('Unknown5','148s=b\"\"'),\n        ('UnknownFlags','<L=0'),\n    )",
  "class ESENT_PAGE_HEADER(Structure):\n    structure_2003_SP0 = (\n        ('CheckSum','<L=0'),\n        ('PageNumber','<L=0'),\n    )\n    structure_0x620_0x0b = (\n        ('CheckSum','<L=0'),\n        ('ECCCheckSum','<L=0'),\n    )\n    structure_win7 = (\n        ('CheckSum','<Q=0'),\n    )\n    common = (\n        ('LastModificationTime','<Q=0'),\n        ('PreviousPageNumber','<L=0'),\n        ('NextPageNumber','<L=0'),\n        ('FatherDataPage','<L=0'),\n        ('AvailableDataSize','<H=0'),\n        ('AvailableUncommittedDataSize','<H=0'),\n        ('FirstAvailableDataOffset','<H=0'),\n        ('FirstAvailablePageTag','<H=0'),\n        ('PageFlags','<L=0'),\n    )\n    extended_win7 = (\n        ('ExtendedCheckSum1','<Q=0'),\n        ('ExtendedCheckSum2','<Q=0'),\n        ('ExtendedCheckSum3','<Q=0'),\n        ('PageNumber','<Q=0'),\n        ('Unknown','<Q=0'),\n    )\n    def __init__(self, version, revision, pageSize=8192, data=None):\n        if (version < 0x620) or (version == 0x620 and revision < 0x0b):\n            # For sure the old format\n            self.structure = self.structure_2003_SP0 + self.common\n        elif version == 0x620 and revision < 0x11:\n            # Exchange 2003 SP1 and Windows Vista and later\n            self.structure = self.structure_0x620_0x0b + self.common\n        else:\n            # Windows 7 and later\n            self.structure = self.structure_win7 + self.common\n            if pageSize > 8192:\n                self.structure += self.extended_win7\n\n        Structure.__init__(self,data)",
  "class ESENT_ROOT_HEADER(Structure):\n    structure = (\n        ('InitialNumberOfPages','<L=0'),\n        ('ParentFatherDataPage','<L=0'),\n        ('ExtentSpace','<L=0'),\n        ('SpaceTreePageNumber','<L=0'),\n    )",
  "class ESENT_BRANCH_HEADER(Structure):\n    structure = (\n        ('CommonPageKey',':'),\n    )",
  "class ESENT_BRANCH_ENTRY(Structure):\n    common = (\n        ('CommonPageKeySize','<H=0'),\n    )\n    structure = (\n        ('LocalPageKeySize','<H=0'),\n        ('_LocalPageKey','_-LocalPageKey','self[\"LocalPageKeySize\"]'),\n        ('LocalPageKey',':'),\n        ('ChildPageNumber','<L=0'),\n    )\n    def __init__(self, flags, data=None):\n        if flags & TAG_COMMON > 0:\n            # Include the common header\n            self.structure = self.common + self.structure\n        Structure.__init__(self,data)",
  "class ESENT_LEAF_HEADER(Structure):\n    structure = (\n        ('CommonPageKey',':'),\n    )",
  "class ESENT_LEAF_ENTRY(Structure):\n    common = (\n        ('CommonPageKeySize','<H=0'),\n    )\n    structure = (\n        ('LocalPageKeySize','<H=0'),\n        ('_LocalPageKey','_-LocalPageKey','self[\"LocalPageKeySize\"]'),\n        ('LocalPageKey',':'),\n        ('EntryData',':'),\n    )\n    def __init__(self, flags, data=None):\n        if flags & TAG_COMMON > 0:\n            # Include the common header\n            self.structure = self.common + self.structure\n        Structure.__init__(self,data)",
  "class ESENT_SPACE_TREE_HEADER(Structure):\n    structure = (\n        ('Unknown','<Q=0'),\n    )",
  "class ESENT_SPACE_TREE_ENTRY(Structure):\n    structure = (\n        ('PageKeySize','<H=0'),\n        ('LastPageNumber','<L=0'),\n        ('NumberOfPages','<L=0'),\n    )",
  "class ESENT_INDEX_ENTRY(Structure):\n    structure = (\n        ('RecordPageKey',':'),\n    )",
  "class ESENT_DATA_DEFINITION_HEADER(Structure):\n    structure = (\n        ('LastFixedSize','<B=0'),\n        ('LastVariableDataType','<B=0'),\n        ('VariableSizeOffset','<H=0'),\n    )",
  "class ESENT_CATALOG_DATA_DEFINITION_ENTRY(Structure):\n    fixed = (\n        ('FatherDataPageID','<L=0'),\n        ('Type','<H=0'),\n        ('Identifier','<L=0'),\n    )\n\n    column_stuff = (\n        ('ColumnType','<L=0'),\n        ('SpaceUsage','<L=0'),\n        ('ColumnFlags','<L=0'),\n        ('CodePage','<L=0'),\n    )\n\n    other = (\n        ('FatherDataPageNumber','<L=0'),\n    )\n\n    table_stuff = (\n        ('SpaceUsage','<L=0'),\n#        ('TableFlags','<L=0'),\n#        ('InitialNumberOfPages','<L=0'),\n    )\n\n    index_stuff = (\n        ('SpaceUsage','<L=0'),\n        ('IndexFlags','<L=0'),\n        ('Locale','<L=0'),\n    )\n\n    lv_stuff = (\n        ('SpaceUsage','<L=0'),\n#        ('LVFlags','<L=0'),\n#        ('InitialNumberOfPages','<L=0'),\n    )\n    common = (\n#        ('RootFlag','<B=0'),\n#        ('RecordOffset','<H=0'),\n#        ('LCMapFlags','<L=0'),\n#        ('KeyMost','<H=0'),\n        ('Trailing',':'),\n    )\n\n    def __init__(self,data):\n        # Depending on the type of data we'll end up building a different struct\n        dataType = unpack('<H', data[4:][:2])[0]\n        self.structure = self.fixed\n\n        if dataType == CATALOG_TYPE_TABLE:\n            self.structure += self.other + self.table_stuff\n        elif dataType == CATALOG_TYPE_COLUMN:\n            self.structure += self.column_stuff\n        elif dataType == CATALOG_TYPE_INDEX:\n            self.structure += self.other + self.index_stuff\n        elif dataType == CATALOG_TYPE_LONG_VALUE:\n            self.structure += self.other + self.lv_stuff\n        elif dataType == CATALOG_TYPE_CALLBACK:\n            raise Exception('CallBack types not supported!')\n        else:\n            LOG.error('Unknown catalog type 0x%x' % dataType)\n            self.structure = ()\n            Structure.__init__(self,data)\n\n        self.structure += self.common\n\n        Structure.__init__(self,data)",
  "def getUnixTime(t):\n    t -= 116444736000000000\n    t //= 10000000\n    return t",
  "class ESENT_PAGE:\n    def __init__(self, db, data=None):\n        self.__DBHeader = db\n        self.data = data\n        self.record = None\n        if data is not None:\n            self.record = ESENT_PAGE_HEADER(self.__DBHeader['Version'], self.__DBHeader['FileFormatRevision'], self.__DBHeader['PageSize'], data)\n\n    def printFlags(self):\n        flags = self.record['PageFlags']\n        if flags & FLAGS_EMPTY:\n            print(\"\\tEmpty\")\n        if flags & FLAGS_INDEX:\n            print(\"\\tIndex\")\n        if flags & FLAGS_LEAF:\n            print(\"\\tLeaf\")\n        else:\n            print(\"\\tBranch\")\n        if flags & FLAGS_LONG_VALUE:\n            print(\"\\tLong Value\")\n        if flags & FLAGS_NEW_CHECKSUM:\n            print(\"\\tNew Checksum\")\n        if flags & FLAGS_NEW_FORMAT:\n            print(\"\\tNew Format\")\n        if flags & FLAGS_PARENT:\n            print(\"\\tParent\")\n        if flags & FLAGS_ROOT:\n            print(\"\\tRoot\")\n        if flags & FLAGS_SPACE_TREE:\n            print(\"\\tSpace Tree\")\n\n    def dump(self):\n        baseOffset = len(self.record)\n        self.record.dump()\n        tags = self.data[-4*self.record['FirstAvailablePageTag']:]\n\n        print(\"FLAGS: \")\n        self.printFlags()\n\n        print()\n\n        for i in range(self.record['FirstAvailablePageTag']):\n            tag = tags[-4:]\n            if self.__DBHeader['Version'] == 0x620 and self.__DBHeader['FileFormatRevision'] > 11 and self.__DBHeader['PageSize'] > 8192:\n                valueSize = unpack('<H', tag[:2])[0] & 0x7fff\n                valueOffset = unpack('<H',tag[2:])[0] & 0x7fff\n                hexdump((self.data[baseOffset+valueOffset:][:6]))\n                pageFlags = ord(self.data[baseOffset+valueOffset:][1]) >> 5\n                #print \"TAG FLAG: 0x%x \" % (unpack('<L', self.data[baseOffset+valueOffset:][:4]) ) >> 5\n                #print \"TAG FLAG: 0x \" , ord(self.data[baseOffset+valueOffset:][0])\n            else:\n                valueSize = unpack('<H', tag[:2])[0] & 0x1fff\n                pageFlags = (unpack('<H', tag[2:])[0] & 0xe000) >> 13\n                valueOffset = unpack('<H',tag[2:])[0] & 0x1fff\n                \n            print(\"TAG %-8d offset:0x%-6x flags:0x%-4x valueSize:0x%x\" % (i,valueOffset,pageFlags,valueSize))\n            #hexdump(self.getTag(i)[1])\n            tags = tags[:-4]\n\n        if self.record['PageFlags'] & FLAGS_ROOT > 0:\n            rootHeader = ESENT_ROOT_HEADER(self.getTag(0)[1])\n            rootHeader.dump()\n        elif self.record['PageFlags'] & FLAGS_LEAF == 0:\n            # Branch Header\n            flags, data = self.getTag(0)\n            branchHeader = ESENT_BRANCH_HEADER(data)\n            branchHeader.dump()\n        else:\n            # Leaf Header\n            flags, data = self.getTag(0)\n            if self.record['PageFlags'] & FLAGS_SPACE_TREE > 0:\n                # Space Tree\n                spaceTreeHeader = ESENT_SPACE_TREE_HEADER(data)\n                spaceTreeHeader.dump()\n            else:\n                leafHeader = ESENT_LEAF_HEADER(data)\n                leafHeader.dump()\n\n        # Print the leaf/branch tags\n        for tagNum in range(1,self.record['FirstAvailablePageTag']):\n            flags, data = self.getTag(tagNum)\n            if self.record['PageFlags'] & FLAGS_LEAF == 0:\n                # Branch page\n                branchEntry = ESENT_BRANCH_ENTRY(flags, data)\n                branchEntry.dump()\n            elif self.record['PageFlags'] & FLAGS_LEAF > 0:\n                # Leaf page\n                if self.record['PageFlags'] & FLAGS_SPACE_TREE > 0:\n                    # Space Tree\n                    spaceTreeEntry = ESENT_SPACE_TREE_ENTRY(data)\n                    #spaceTreeEntry.dump()\n\n                elif self.record['PageFlags'] & FLAGS_INDEX > 0:\n                    # Index Entry\n                    indexEntry = ESENT_INDEX_ENTRY(data)\n                    #indexEntry.dump()\n                elif self.record['PageFlags'] & FLAGS_LONG_VALUE > 0:\n                    # Long Page Value\n                    raise Exception('Long value still not supported')\n                else:\n                    # Table Value\n                    leafEntry = ESENT_LEAF_ENTRY(flags, data)\n                    dataDefinitionHeader = ESENT_DATA_DEFINITION_HEADER(leafEntry['EntryData'])\n                    dataDefinitionHeader.dump()\n                    catalogEntry = ESENT_CATALOG_DATA_DEFINITION_ENTRY(leafEntry['EntryData'][len(dataDefinitionHeader):])\n                    catalogEntry.dump()\n                    hexdump(leafEntry['EntryData'])\n\n    def getTag(self, tagNum):\n        if self.record['FirstAvailablePageTag'] < tagNum:\n            raise Exception('Trying to grab an unknown tag 0x%x' % tagNum)\n\n        tags = self.data[-4*self.record['FirstAvailablePageTag']:]\n        baseOffset = len(self.record)\n        for i in range(tagNum):\n            tags = tags[:-4]\n\n        tag = tags[-4:]\n\n        if self.__DBHeader['Version'] == 0x620 and self.__DBHeader['FileFormatRevision'] >= 17 and self.__DBHeader['PageSize'] > 8192:\n            valueSize = unpack('<H', tag[:2])[0] & 0x7fff\n            valueOffset = unpack('<H',tag[2:])[0] & 0x7fff\n            tmpData = bytearray(self.data[baseOffset+valueOffset:][:valueSize])\n            pageFlags = tmpData[1] >> 5\n            tmpData[1] = tmpData[1:2][0] & 0x1f\n            tmpData = bytes(tmpData)\n            tagData = tmpData\n        else:\n            valueSize = unpack('<H', tag[:2])[0] & 0x1fff\n            pageFlags = (unpack('<H', tag[2:])[0] & 0xe000) >> 13\n            valueOffset = unpack('<H',tag[2:])[0] & 0x1fff\n            tagData = self.data[baseOffset+valueOffset:][:valueSize]\n\n        #return pageFlags, self.data[baseOffset+valueOffset:][:valueSize]\n        return pageFlags, tagData",
  "class ESENT_DB:\n    def __init__(self, fileName, pageSize = 8192, isRemote = False):\n        self.__fileName = fileName\n        self.__pageSize = pageSize\n        self.__DB = None\n        self.__DBHeader = None\n        self.__totalPages = None\n        self.__tables = OrderedDict()\n        self.__currentTable = None\n        self.__isRemote = isRemote\n        self.mountDB()\n\n    def mountDB(self):\n        LOG.debug(\"Mounting DB...\")\n        if self.__isRemote is True:\n            self.__DB = self.__fileName\n            self.__DB.open()\n        else:\n            self.__DB = open(self.__fileName,\"rb\")\n        mainHeader = self.getPage(-1)\n        self.__DBHeader = ESENT_DB_HEADER(mainHeader)\n        self.__pageSize = self.__DBHeader['PageSize']\n        self.__DB.seek(0,2)\n        self.__totalPages = (self.__DB.tell() // self.__pageSize) -2\n        LOG.debug(\"Database Version:0x%x, Revision:0x%x\"% (self.__DBHeader['Version'], self.__DBHeader['FileFormatRevision']))\n        LOG.debug(\"Page Size: %d\" % self.__pageSize)\n        LOG.debug(\"Total Pages in file: %d\" % self.__totalPages)\n        self.parseCatalog(CATALOG_PAGE_NUMBER)\n\n    def printCatalog(self):\n        indent = '    '\n\n        print(\"Database version: 0x%x, 0x%x\" % (self.__DBHeader['Version'], self.__DBHeader['FileFormatRevision'] ))\n        print(\"Page size: %d \" % self.__pageSize)\n        print(\"Number of pages: %d\" % self.__totalPages)\n        print() \n        print(\"Catalog for %s\" % self.__fileName)\n        for table in list(self.__tables.keys()):\n            print(\"[%s]\" % table.decode('utf8'))\n            print(\"%sColumns \" % indent)\n            for column in list(self.__tables[table]['Columns'].keys()):\n                record = self.__tables[table]['Columns'][column]['Record']\n                print(\"%s%-5d%-30s%s\" % (indent*2, record['Identifier'], column.decode('utf-8'),ColumnTypeToName[record['ColumnType']]))\n            print(\"%sIndexes\"% indent)\n            for index in list(self.__tables[table]['Indexes'].keys()):\n                print(\"%s%s\" % (indent*2, index.decode('utf-8')))\n            print(\"\")\n\n    def __addItem(self, entry):\n        dataDefinitionHeader = ESENT_DATA_DEFINITION_HEADER(entry['EntryData'])\n        catalogEntry = ESENT_CATALOG_DATA_DEFINITION_ENTRY(entry['EntryData'][len(dataDefinitionHeader):])\n        itemName = self.__parseItemName(entry)\n\n        if catalogEntry['Type'] == CATALOG_TYPE_TABLE:\n            self.__tables[itemName] = OrderedDict()\n            self.__tables[itemName]['TableEntry'] = entry\n            self.__tables[itemName]['Columns']    = OrderedDict()\n            self.__tables[itemName]['Indexes']    = OrderedDict()\n            self.__tables[itemName]['LongValues'] = OrderedDict()\n            self.__currentTable = itemName\n        elif catalogEntry['Type'] == CATALOG_TYPE_COLUMN:\n            self.__tables[self.__currentTable]['Columns'][itemName] = entry\n            self.__tables[self.__currentTable]['Columns'][itemName]['Header'] = dataDefinitionHeader\n            self.__tables[self.__currentTable]['Columns'][itemName]['Record'] = catalogEntry\n        elif catalogEntry['Type'] == CATALOG_TYPE_INDEX:\n            self.__tables[self.__currentTable]['Indexes'][itemName] = entry\n        elif catalogEntry['Type'] == CATALOG_TYPE_LONG_VALUE:\n            self.__addLongValue(entry)\n        else:\n            raise Exception('Unknown type 0x%x' % catalogEntry['Type'])\n\n    def __parseItemName(self,entry):\n        dataDefinitionHeader = ESENT_DATA_DEFINITION_HEADER(entry['EntryData'])\n\n        if dataDefinitionHeader['LastVariableDataType'] > 127:\n            numEntries =  dataDefinitionHeader['LastVariableDataType'] - 127\n        else:\n            numEntries =  dataDefinitionHeader['LastVariableDataType']\n\n        itemLen = unpack('<H',entry['EntryData'][dataDefinitionHeader['VariableSizeOffset']:][:2])[0]\n        itemName = entry['EntryData'][dataDefinitionHeader['VariableSizeOffset']:][2*numEntries:][:itemLen]\n        return itemName\n\n    def __addLongValue(self, entry):\n        dataDefinitionHeader = ESENT_DATA_DEFINITION_HEADER(entry['EntryData'])\n        lvLen = unpack('<H',entry['EntryData'][dataDefinitionHeader['VariableSizeOffset']:][:2])[0]\n        lvName = entry['EntryData'][dataDefinitionHeader['VariableSizeOffset']:][7:][:lvLen]\n        self.__tables[self.__currentTable]['LongValues'][lvName] = entry\n\n    def parsePage(self, page):\n        # Print the leaf/branch tags\n        for tagNum in range(1,page.record['FirstAvailablePageTag']):\n            flags, data = page.getTag(tagNum)\n            if page.record['PageFlags'] & FLAGS_LEAF > 0:\n                # Leaf page\n                if page.record['PageFlags'] & FLAGS_SPACE_TREE > 0:\n                    pass\n                elif page.record['PageFlags'] & FLAGS_INDEX > 0:\n                    pass\n                elif page.record['PageFlags'] & FLAGS_LONG_VALUE > 0:\n                    pass\n                else:\n                    # Table Value\n                    leafEntry = ESENT_LEAF_ENTRY(flags, data)\n                    self.__addItem(leafEntry)\n\n    def parseCatalog(self, pageNum):\n        # Parse all the pages starting at pageNum and commit table data\n        page = self.getPage(pageNum)\n        self.parsePage(page)\n\n        for i in range(1, page.record['FirstAvailablePageTag']):\n            flags, data = page.getTag(i)\n            if page.record['PageFlags'] & FLAGS_LEAF == 0:\n                # Branch page\n                branchEntry = ESENT_BRANCH_ENTRY(flags, data)\n                self.parseCatalog(branchEntry['ChildPageNumber'])\n\n\n    def readHeader(self):\n        LOG.debug(\"Reading Boot Sector for %s\" % self.__volumeName)\n\n    def getPage(self, pageNum):\n        LOG.debug(\"Trying to fetch page %d (0x%x)\" % (pageNum, (pageNum+1)*self.__pageSize))\n        self.__DB.seek((pageNum+1)*self.__pageSize, 0)\n        data = self.__DB.read(self.__pageSize)\n        while len(data) < self.__pageSize:\n            remaining = self.__pageSize - len(data)\n            data += self.__DB.read(remaining)\n        # Special case for the first page\n        if pageNum <= 0:\n            return data\n        else:\n            return ESENT_PAGE(self.__DBHeader, data)\n\n    def close(self):\n        self.__DB.close()\n\n    def openTable(self, tableName):\n        # Returns a cursos for later use\n\n        if isinstance(tableName, bytes) is not True:\n            tableName = b(tableName)\n\n        if tableName in self.__tables:\n            entry = self.__tables[tableName]['TableEntry']\n            dataDefinitionHeader = ESENT_DATA_DEFINITION_HEADER(entry['EntryData'])\n            catalogEntry = ESENT_CATALOG_DATA_DEFINITION_ENTRY(entry['EntryData'][len(dataDefinitionHeader):])\n            \n            # Let's position the cursor at the leaf levels for fast reading\n            pageNum = catalogEntry['FatherDataPageNumber']\n            done = False\n            while done is False:\n                page = self.getPage(pageNum)\n                if page.record['FirstAvailablePageTag'] <= 1:\n                    # There are no records\n                    done = True\n                for i in range(1, page.record['FirstAvailablePageTag']):\n                    flags, data = page.getTag(i)\n                    if page.record['PageFlags'] & FLAGS_LEAF == 0:\n                        # Branch page, move on to the next page\n                        branchEntry = ESENT_BRANCH_ENTRY(flags, data)\n                        pageNum = branchEntry['ChildPageNumber']\n                        break\n                    else:\n                        done = True\n                        break\n                \n            cursor = TABLE_CURSOR\n            cursor['TableData'] = self.__tables[tableName]\n            cursor['FatherDataPageNumber'] = catalogEntry['FatherDataPageNumber']\n            cursor['CurrentPageData'] = page\n            cursor['CurrentTag']  = 0\n            return cursor\n        else:\n            return None\n\n    def __getNextTag(self, cursor):\n        page = cursor['CurrentPageData']\n\n        if cursor['CurrentTag'] >= page.record['FirstAvailablePageTag']:\n            # No more data in this page, chau\n            return None\n\n        flags, data = page.getTag(cursor['CurrentTag'])\n        if page.record['PageFlags'] & FLAGS_LEAF > 0:\n            # Leaf page\n            if page.record['PageFlags'] & FLAGS_SPACE_TREE > 0:\n                raise Exception('FLAGS_SPACE_TREE > 0')\n            elif page.record['PageFlags'] & FLAGS_INDEX > 0:\n                raise Exception('FLAGS_INDEX > 0')\n            elif page.record['PageFlags'] & FLAGS_LONG_VALUE > 0:\n                raise Exception('FLAGS_LONG_VALUE > 0')\n            else:\n                # Table Value\n                leafEntry = ESENT_LEAF_ENTRY(flags, data)\n                return leafEntry\n\n        return None\n\n    def getNextRow(self, cursor, filter_tables = None):\n        cursor['CurrentTag'] += 1\n\n        tag = self.__getNextTag(cursor)\n        #hexdump(tag)\n\n        if tag is None:\n            # No more tags in this page, search for the next one on the right\n            page = cursor['CurrentPageData']\n            if page.record['NextPageNumber'] == 0:\n                # No more pages, chau\n                return None\n            else:\n                cursor['CurrentPageData'] = self.getPage(page.record['NextPageNumber'])\n                cursor['CurrentTag'] = 0\n                return self.getNextRow(cursor, filter_tables = filter_tables)\n        else:\n            return self.__tagToRecord(cursor, tag['EntryData'], filter_tables = filter_tables)\n\n    def __tagToRecord(self, cursor, tag, filter_tables = None):\n        # So my brain doesn't forget, the data record is composed of:\n        # Header\n        # Fixed Size Data (ID < 127)\n        #     The easiest to parse. Their size is fixed in the record. You can get its size\n        #     from the Column Record, field SpaceUsage\n        # Variable Size Data (127 < ID < 255)\n        #     At VariableSizeOffset you get an array of two bytes per variable entry, pointing\n        #     to the length of the value. Values start at:\n        #                numEntries = LastVariableDataType - 127\n        #                VariableSizeOffset + numEntries * 2 (bytes)\n        # Tagged Data ( > 255 )\n        #     After the Variable Size Value, there's more data for the tagged values.\n        #     Right at the beginning there's another array (taggedItems), pointing to the\n        #     values, size.\n        #\n        # The interesting thing about this DB records is there's no need for all the columns to be there, hence\n        # saving space. That's why I got over all the columns, and if I find data (of any type), i assign it. If \n        # not, the column's empty.\n        #\n        # There are a lot of caveats in the code, so take your time to explore it. \n        #\n        # ToDo: Better complete this description\n        #\n\n        record = OrderedDict()\n        taggedItems = OrderedDict()\n        taggedItemsParsed = False\n\n        dataDefinitionHeader = ESENT_DATA_DEFINITION_HEADER(tag)\n        #dataDefinitionHeader.dump()\n        variableDataBytesProcessed = (dataDefinitionHeader['LastVariableDataType'] - 127) * 2\n        prevItemLen = 0\n        tagLen = len(tag)\n        fixedSizeOffset = len(dataDefinitionHeader)\n        variableSizeOffset = dataDefinitionHeader['VariableSizeOffset'] \n \n        columns = cursor['TableData']['Columns'] \n        \n        for column in list(columns.keys()):\n            if filter_tables is not None:\n                if column not in filter_tables:\n                    continue\n            columnRecord = columns[column]['Record']\n            #columnRecord.dump()\n            if columnRecord['Identifier'] <= dataDefinitionHeader['LastFixedSize']:\n                # Fixed Size column data type, still available data\n                record[column] = tag[fixedSizeOffset:][:columnRecord['SpaceUsage']]\n                fixedSizeOffset += columnRecord['SpaceUsage']\n\n            elif 127 < columnRecord['Identifier'] <= dataDefinitionHeader['LastVariableDataType']:\n                # Variable data type\n                index = columnRecord['Identifier'] - 127 - 1\n                itemLen = unpack('<H',tag[variableSizeOffset+index*2:][:2])[0]\n\n                if itemLen & 0x8000:\n                    # Empty item\n                    itemLen = prevItemLen\n                    record[column] = None\n                else:\n                    itemValue = tag[variableSizeOffset+variableDataBytesProcessed:][:itemLen-prevItemLen]\n                    record[column] = itemValue\n\n                #if columnRecord['Identifier'] <= dataDefinitionHeader['LastVariableDataType']:\n                variableDataBytesProcessed +=itemLen-prevItemLen\n\n                prevItemLen = itemLen\n\n            elif columnRecord['Identifier'] > 255:\n                # Have we parsed the tagged items already?\n                if taggedItemsParsed is False and (variableDataBytesProcessed+variableSizeOffset) < tagLen:\n                    index = variableDataBytesProcessed+variableSizeOffset\n                    #hexdump(tag[index:])\n                    endOfVS = self.__pageSize\n                    firstOffsetTag = (unpack('<H', tag[index+2:][:2])[0] & 0x3fff) + variableDataBytesProcessed+variableSizeOffset\n                    while True:\n                        taggedIdentifier = unpack('<H', tag[index:][:2])[0]\n                        index += 2\n                        taggedOffset = (unpack('<H', tag[index:][:2])[0] & 0x3fff) \n                        # As of Windows 7 and later ( version 0x620 revision 0x11) the \n                        # tagged data type flags are always present\n                        if self.__DBHeader['Version'] == 0x620 and self.__DBHeader['FileFormatRevision'] >= 17 and self.__DBHeader['PageSize'] > 8192: \n                            flagsPresent = 1\n                        else:\n                            flagsPresent = (unpack('<H', tag[index:][:2])[0] & 0x4000)\n                        index += 2\n                        if taggedOffset < endOfVS:\n                            endOfVS = taggedOffset\n                        taggedItems[taggedIdentifier] = (taggedOffset, tagLen, flagsPresent)\n                        #print \"ID: %d, Offset:%d, firstOffset:%d, index:%d, flag: 0x%x\" % (taggedIdentifier, taggedOffset,firstOffsetTag,index, flagsPresent)\n                        if index >= firstOffsetTag:\n                            # We reached the end of the variable size array\n                            break\n                \n                    # Calculate length of variable items\n                    # Ugly.. should be redone\n                    prevKey = list(taggedItems.keys())[0]\n                    for i in range(1,len(taggedItems)):\n                        offset0, length, flags = taggedItems[prevKey]\n                        offset, _, _ = list(taggedItems.items())[i][1]\n                        taggedItems[prevKey] = (offset0, offset-offset0, flags)\n                        #print \"ID: %d, Offset: %d, Len: %d, flags: %d\" % (prevKey, offset0, offset-offset0, flags)\n                        prevKey = list(taggedItems.keys())[i]\n                    taggedItemsParsed = True\n \n                # Tagged data type\n                if columnRecord['Identifier'] in taggedItems:\n                    offsetItem = variableDataBytesProcessed + variableSizeOffset + taggedItems[columnRecord['Identifier']][0] \n                    itemSize = taggedItems[columnRecord['Identifier']][1]\n                    # If item have flags, we should skip them\n                    if taggedItems[columnRecord['Identifier']][2] > 0:\n                        itemFlag = ord(tag[offsetItem:offsetItem+1])\n                        offsetItem += 1\n                        itemSize -= 1\n                    else:\n                        itemFlag = 0\n\n                    #print \"ID: %d, itemFlag: 0x%x\" %( columnRecord['Identifier'], itemFlag)\n                    if itemFlag & (TAGGED_DATA_TYPE_COMPRESSED ):\n                        LOG.error('Unsupported tag column: %s, flag:0x%x' % (column, itemFlag))\n                        record[column] = None\n                    elif itemFlag & TAGGED_DATA_TYPE_MULTI_VALUE:\n                        # ToDo: Parse multi-values properly\n                        LOG.debug('Multivalue detected in column %s, returning raw results' % (column))\n                        record[column] = (hexlify(tag[offsetItem:][:itemSize]),)\n                    else:\n                        record[column] = tag[offsetItem:][:itemSize]\n\n                else:\n                    record[column] = None\n            else:\n                record[column] = None\n\n            # If we understand the data type, we unpack it and cast it accordingly\n            # otherwise, we just encode it in hex\n            if type(record[column]) is tuple:\n                # A multi value data, we won't decode it, just leave it this way\n                record[column] = record[column][0]\n            elif columnRecord['ColumnType'] == JET_coltypText or columnRecord['ColumnType'] == JET_coltypLongText: \n                # Let's handle strings\n                if record[column] is not None:\n                    if columnRecord['CodePage'] not in StringCodePages:\n                        raise Exception('Unknown codepage 0x%x'% columnRecord['CodePage'])\n                    stringDecoder = StringCodePages[columnRecord['CodePage']]\n\n                    try:\n                        record[column] = record[column].decode(stringDecoder)\n                    except Exception:\n                        LOG.debug(\"Exception:\", exc_info=True)\n                        LOG.debug('Fixing Record[%r][%d]: %r' % (column, columnRecord['ColumnType'], record[column]))\n                        record[column] = record[column].decode(stringDecoder, \"replace\")\n                        pass\n            else:\n                unpackData = ColumnTypeSize[columnRecord['ColumnType']]\n                if record[column] is not None:\n                    if unpackData is None:\n                        record[column] = hexlify(record[column])\n                    else:\n                        unpackStr = unpackData[1]\n                        record[column] = unpack(unpackStr, record[column])[0]\n\n        return record",
  "def __init__(self, version, revision, pageSize=8192, data=None):\n        if (version < 0x620) or (version == 0x620 and revision < 0x0b):\n            # For sure the old format\n            self.structure = self.structure_2003_SP0 + self.common\n        elif version == 0x620 and revision < 0x11:\n            # Exchange 2003 SP1 and Windows Vista and later\n            self.structure = self.structure_0x620_0x0b + self.common\n        else:\n            # Windows 7 and later\n            self.structure = self.structure_win7 + self.common\n            if pageSize > 8192:\n                self.structure += self.extended_win7\n\n        Structure.__init__(self,data)",
  "def __init__(self, flags, data=None):\n        if flags & TAG_COMMON > 0:\n            # Include the common header\n            self.structure = self.common + self.structure\n        Structure.__init__(self,data)",
  "def __init__(self, flags, data=None):\n        if flags & TAG_COMMON > 0:\n            # Include the common header\n            self.structure = self.common + self.structure\n        Structure.__init__(self,data)",
  "def __init__(self,data):\n        # Depending on the type of data we'll end up building a different struct\n        dataType = unpack('<H', data[4:][:2])[0]\n        self.structure = self.fixed\n\n        if dataType == CATALOG_TYPE_TABLE:\n            self.structure += self.other + self.table_stuff\n        elif dataType == CATALOG_TYPE_COLUMN:\n            self.structure += self.column_stuff\n        elif dataType == CATALOG_TYPE_INDEX:\n            self.structure += self.other + self.index_stuff\n        elif dataType == CATALOG_TYPE_LONG_VALUE:\n            self.structure += self.other + self.lv_stuff\n        elif dataType == CATALOG_TYPE_CALLBACK:\n            raise Exception('CallBack types not supported!')\n        else:\n            LOG.error('Unknown catalog type 0x%x' % dataType)\n            self.structure = ()\n            Structure.__init__(self,data)\n\n        self.structure += self.common\n\n        Structure.__init__(self,data)",
  "def __init__(self, db, data=None):\n        self.__DBHeader = db\n        self.data = data\n        self.record = None\n        if data is not None:\n            self.record = ESENT_PAGE_HEADER(self.__DBHeader['Version'], self.__DBHeader['FileFormatRevision'], self.__DBHeader['PageSize'], data)",
  "def printFlags(self):\n        flags = self.record['PageFlags']\n        if flags & FLAGS_EMPTY:\n            print(\"\\tEmpty\")\n        if flags & FLAGS_INDEX:\n            print(\"\\tIndex\")\n        if flags & FLAGS_LEAF:\n            print(\"\\tLeaf\")\n        else:\n            print(\"\\tBranch\")\n        if flags & FLAGS_LONG_VALUE:\n            print(\"\\tLong Value\")\n        if flags & FLAGS_NEW_CHECKSUM:\n            print(\"\\tNew Checksum\")\n        if flags & FLAGS_NEW_FORMAT:\n            print(\"\\tNew Format\")\n        if flags & FLAGS_PARENT:\n            print(\"\\tParent\")\n        if flags & FLAGS_ROOT:\n            print(\"\\tRoot\")\n        if flags & FLAGS_SPACE_TREE:\n            print(\"\\tSpace Tree\")",
  "def dump(self):\n        baseOffset = len(self.record)\n        self.record.dump()\n        tags = self.data[-4*self.record['FirstAvailablePageTag']:]\n\n        print(\"FLAGS: \")\n        self.printFlags()\n\n        print()\n\n        for i in range(self.record['FirstAvailablePageTag']):\n            tag = tags[-4:]\n            if self.__DBHeader['Version'] == 0x620 and self.__DBHeader['FileFormatRevision'] > 11 and self.__DBHeader['PageSize'] > 8192:\n                valueSize = unpack('<H', tag[:2])[0] & 0x7fff\n                valueOffset = unpack('<H',tag[2:])[0] & 0x7fff\n                hexdump((self.data[baseOffset+valueOffset:][:6]))\n                pageFlags = ord(self.data[baseOffset+valueOffset:][1]) >> 5\n                #print \"TAG FLAG: 0x%x \" % (unpack('<L', self.data[baseOffset+valueOffset:][:4]) ) >> 5\n                #print \"TAG FLAG: 0x \" , ord(self.data[baseOffset+valueOffset:][0])\n            else:\n                valueSize = unpack('<H', tag[:2])[0] & 0x1fff\n                pageFlags = (unpack('<H', tag[2:])[0] & 0xe000) >> 13\n                valueOffset = unpack('<H',tag[2:])[0] & 0x1fff\n                \n            print(\"TAG %-8d offset:0x%-6x flags:0x%-4x valueSize:0x%x\" % (i,valueOffset,pageFlags,valueSize))\n            #hexdump(self.getTag(i)[1])\n            tags = tags[:-4]\n\n        if self.record['PageFlags'] & FLAGS_ROOT > 0:\n            rootHeader = ESENT_ROOT_HEADER(self.getTag(0)[1])\n            rootHeader.dump()\n        elif self.record['PageFlags'] & FLAGS_LEAF == 0:\n            # Branch Header\n            flags, data = self.getTag(0)\n            branchHeader = ESENT_BRANCH_HEADER(data)\n            branchHeader.dump()\n        else:\n            # Leaf Header\n            flags, data = self.getTag(0)\n            if self.record['PageFlags'] & FLAGS_SPACE_TREE > 0:\n                # Space Tree\n                spaceTreeHeader = ESENT_SPACE_TREE_HEADER(data)\n                spaceTreeHeader.dump()\n            else:\n                leafHeader = ESENT_LEAF_HEADER(data)\n                leafHeader.dump()\n\n        # Print the leaf/branch tags\n        for tagNum in range(1,self.record['FirstAvailablePageTag']):\n            flags, data = self.getTag(tagNum)\n            if self.record['PageFlags'] & FLAGS_LEAF == 0:\n                # Branch page\n                branchEntry = ESENT_BRANCH_ENTRY(flags, data)\n                branchEntry.dump()\n            elif self.record['PageFlags'] & FLAGS_LEAF > 0:\n                # Leaf page\n                if self.record['PageFlags'] & FLAGS_SPACE_TREE > 0:\n                    # Space Tree\n                    spaceTreeEntry = ESENT_SPACE_TREE_ENTRY(data)\n                    #spaceTreeEntry.dump()\n\n                elif self.record['PageFlags'] & FLAGS_INDEX > 0:\n                    # Index Entry\n                    indexEntry = ESENT_INDEX_ENTRY(data)\n                    #indexEntry.dump()\n                elif self.record['PageFlags'] & FLAGS_LONG_VALUE > 0:\n                    # Long Page Value\n                    raise Exception('Long value still not supported')\n                else:\n                    # Table Value\n                    leafEntry = ESENT_LEAF_ENTRY(flags, data)\n                    dataDefinitionHeader = ESENT_DATA_DEFINITION_HEADER(leafEntry['EntryData'])\n                    dataDefinitionHeader.dump()\n                    catalogEntry = ESENT_CATALOG_DATA_DEFINITION_ENTRY(leafEntry['EntryData'][len(dataDefinitionHeader):])\n                    catalogEntry.dump()\n                    hexdump(leafEntry['EntryData'])",
  "def getTag(self, tagNum):\n        if self.record['FirstAvailablePageTag'] < tagNum:\n            raise Exception('Trying to grab an unknown tag 0x%x' % tagNum)\n\n        tags = self.data[-4*self.record['FirstAvailablePageTag']:]\n        baseOffset = len(self.record)\n        for i in range(tagNum):\n            tags = tags[:-4]\n\n        tag = tags[-4:]\n\n        if self.__DBHeader['Version'] == 0x620 and self.__DBHeader['FileFormatRevision'] >= 17 and self.__DBHeader['PageSize'] > 8192:\n            valueSize = unpack('<H', tag[:2])[0] & 0x7fff\n            valueOffset = unpack('<H',tag[2:])[0] & 0x7fff\n            tmpData = bytearray(self.data[baseOffset+valueOffset:][:valueSize])\n            pageFlags = tmpData[1] >> 5\n            tmpData[1] = tmpData[1:2][0] & 0x1f\n            tmpData = bytes(tmpData)\n            tagData = tmpData\n        else:\n            valueSize = unpack('<H', tag[:2])[0] & 0x1fff\n            pageFlags = (unpack('<H', tag[2:])[0] & 0xe000) >> 13\n            valueOffset = unpack('<H',tag[2:])[0] & 0x1fff\n            tagData = self.data[baseOffset+valueOffset:][:valueSize]\n\n        #return pageFlags, self.data[baseOffset+valueOffset:][:valueSize]\n        return pageFlags, tagData",
  "def __init__(self, fileName, pageSize = 8192, isRemote = False):\n        self.__fileName = fileName\n        self.__pageSize = pageSize\n        self.__DB = None\n        self.__DBHeader = None\n        self.__totalPages = None\n        self.__tables = OrderedDict()\n        self.__currentTable = None\n        self.__isRemote = isRemote\n        self.mountDB()",
  "def mountDB(self):\n        LOG.debug(\"Mounting DB...\")\n        if self.__isRemote is True:\n            self.__DB = self.__fileName\n            self.__DB.open()\n        else:\n            self.__DB = open(self.__fileName,\"rb\")\n        mainHeader = self.getPage(-1)\n        self.__DBHeader = ESENT_DB_HEADER(mainHeader)\n        self.__pageSize = self.__DBHeader['PageSize']\n        self.__DB.seek(0,2)\n        self.__totalPages = (self.__DB.tell() // self.__pageSize) -2\n        LOG.debug(\"Database Version:0x%x, Revision:0x%x\"% (self.__DBHeader['Version'], self.__DBHeader['FileFormatRevision']))\n        LOG.debug(\"Page Size: %d\" % self.__pageSize)\n        LOG.debug(\"Total Pages in file: %d\" % self.__totalPages)\n        self.parseCatalog(CATALOG_PAGE_NUMBER)",
  "def printCatalog(self):\n        indent = '    '\n\n        print(\"Database version: 0x%x, 0x%x\" % (self.__DBHeader['Version'], self.__DBHeader['FileFormatRevision'] ))\n        print(\"Page size: %d \" % self.__pageSize)\n        print(\"Number of pages: %d\" % self.__totalPages)\n        print() \n        print(\"Catalog for %s\" % self.__fileName)\n        for table in list(self.__tables.keys()):\n            print(\"[%s]\" % table.decode('utf8'))\n            print(\"%sColumns \" % indent)\n            for column in list(self.__tables[table]['Columns'].keys()):\n                record = self.__tables[table]['Columns'][column]['Record']\n                print(\"%s%-5d%-30s%s\" % (indent*2, record['Identifier'], column.decode('utf-8'),ColumnTypeToName[record['ColumnType']]))\n            print(\"%sIndexes\"% indent)\n            for index in list(self.__tables[table]['Indexes'].keys()):\n                print(\"%s%s\" % (indent*2, index.decode('utf-8')))\n            print(\"\")",
  "def __addItem(self, entry):\n        dataDefinitionHeader = ESENT_DATA_DEFINITION_HEADER(entry['EntryData'])\n        catalogEntry = ESENT_CATALOG_DATA_DEFINITION_ENTRY(entry['EntryData'][len(dataDefinitionHeader):])\n        itemName = self.__parseItemName(entry)\n\n        if catalogEntry['Type'] == CATALOG_TYPE_TABLE:\n            self.__tables[itemName] = OrderedDict()\n            self.__tables[itemName]['TableEntry'] = entry\n            self.__tables[itemName]['Columns']    = OrderedDict()\n            self.__tables[itemName]['Indexes']    = OrderedDict()\n            self.__tables[itemName]['LongValues'] = OrderedDict()\n            self.__currentTable = itemName\n        elif catalogEntry['Type'] == CATALOG_TYPE_COLUMN:\n            self.__tables[self.__currentTable]['Columns'][itemName] = entry\n            self.__tables[self.__currentTable]['Columns'][itemName]['Header'] = dataDefinitionHeader\n            self.__tables[self.__currentTable]['Columns'][itemName]['Record'] = catalogEntry\n        elif catalogEntry['Type'] == CATALOG_TYPE_INDEX:\n            self.__tables[self.__currentTable]['Indexes'][itemName] = entry\n        elif catalogEntry['Type'] == CATALOG_TYPE_LONG_VALUE:\n            self.__addLongValue(entry)\n        else:\n            raise Exception('Unknown type 0x%x' % catalogEntry['Type'])",
  "def __parseItemName(self,entry):\n        dataDefinitionHeader = ESENT_DATA_DEFINITION_HEADER(entry['EntryData'])\n\n        if dataDefinitionHeader['LastVariableDataType'] > 127:\n            numEntries =  dataDefinitionHeader['LastVariableDataType'] - 127\n        else:\n            numEntries =  dataDefinitionHeader['LastVariableDataType']\n\n        itemLen = unpack('<H',entry['EntryData'][dataDefinitionHeader['VariableSizeOffset']:][:2])[0]\n        itemName = entry['EntryData'][dataDefinitionHeader['VariableSizeOffset']:][2*numEntries:][:itemLen]\n        return itemName",
  "def __addLongValue(self, entry):\n        dataDefinitionHeader = ESENT_DATA_DEFINITION_HEADER(entry['EntryData'])\n        lvLen = unpack('<H',entry['EntryData'][dataDefinitionHeader['VariableSizeOffset']:][:2])[0]\n        lvName = entry['EntryData'][dataDefinitionHeader['VariableSizeOffset']:][7:][:lvLen]\n        self.__tables[self.__currentTable]['LongValues'][lvName] = entry",
  "def parsePage(self, page):\n        # Print the leaf/branch tags\n        for tagNum in range(1,page.record['FirstAvailablePageTag']):\n            flags, data = page.getTag(tagNum)\n            if page.record['PageFlags'] & FLAGS_LEAF > 0:\n                # Leaf page\n                if page.record['PageFlags'] & FLAGS_SPACE_TREE > 0:\n                    pass\n                elif page.record['PageFlags'] & FLAGS_INDEX > 0:\n                    pass\n                elif page.record['PageFlags'] & FLAGS_LONG_VALUE > 0:\n                    pass\n                else:\n                    # Table Value\n                    leafEntry = ESENT_LEAF_ENTRY(flags, data)\n                    self.__addItem(leafEntry)",
  "def parseCatalog(self, pageNum):\n        # Parse all the pages starting at pageNum and commit table data\n        page = self.getPage(pageNum)\n        self.parsePage(page)\n\n        for i in range(1, page.record['FirstAvailablePageTag']):\n            flags, data = page.getTag(i)\n            if page.record['PageFlags'] & FLAGS_LEAF == 0:\n                # Branch page\n                branchEntry = ESENT_BRANCH_ENTRY(flags, data)\n                self.parseCatalog(branchEntry['ChildPageNumber'])",
  "def readHeader(self):\n        LOG.debug(\"Reading Boot Sector for %s\" % self.__volumeName)",
  "def getPage(self, pageNum):\n        LOG.debug(\"Trying to fetch page %d (0x%x)\" % (pageNum, (pageNum+1)*self.__pageSize))\n        self.__DB.seek((pageNum+1)*self.__pageSize, 0)\n        data = self.__DB.read(self.__pageSize)\n        while len(data) < self.__pageSize:\n            remaining = self.__pageSize - len(data)\n            data += self.__DB.read(remaining)\n        # Special case for the first page\n        if pageNum <= 0:\n            return data\n        else:\n            return ESENT_PAGE(self.__DBHeader, data)",
  "def close(self):\n        self.__DB.close()",
  "def openTable(self, tableName):\n        # Returns a cursos for later use\n\n        if isinstance(tableName, bytes) is not True:\n            tableName = b(tableName)\n\n        if tableName in self.__tables:\n            entry = self.__tables[tableName]['TableEntry']\n            dataDefinitionHeader = ESENT_DATA_DEFINITION_HEADER(entry['EntryData'])\n            catalogEntry = ESENT_CATALOG_DATA_DEFINITION_ENTRY(entry['EntryData'][len(dataDefinitionHeader):])\n            \n            # Let's position the cursor at the leaf levels for fast reading\n            pageNum = catalogEntry['FatherDataPageNumber']\n            done = False\n            while done is False:\n                page = self.getPage(pageNum)\n                if page.record['FirstAvailablePageTag'] <= 1:\n                    # There are no records\n                    done = True\n                for i in range(1, page.record['FirstAvailablePageTag']):\n                    flags, data = page.getTag(i)\n                    if page.record['PageFlags'] & FLAGS_LEAF == 0:\n                        # Branch page, move on to the next page\n                        branchEntry = ESENT_BRANCH_ENTRY(flags, data)\n                        pageNum = branchEntry['ChildPageNumber']\n                        break\n                    else:\n                        done = True\n                        break\n                \n            cursor = TABLE_CURSOR\n            cursor['TableData'] = self.__tables[tableName]\n            cursor['FatherDataPageNumber'] = catalogEntry['FatherDataPageNumber']\n            cursor['CurrentPageData'] = page\n            cursor['CurrentTag']  = 0\n            return cursor\n        else:\n            return None",
  "def __getNextTag(self, cursor):\n        page = cursor['CurrentPageData']\n\n        if cursor['CurrentTag'] >= page.record['FirstAvailablePageTag']:\n            # No more data in this page, chau\n            return None\n\n        flags, data = page.getTag(cursor['CurrentTag'])\n        if page.record['PageFlags'] & FLAGS_LEAF > 0:\n            # Leaf page\n            if page.record['PageFlags'] & FLAGS_SPACE_TREE > 0:\n                raise Exception('FLAGS_SPACE_TREE > 0')\n            elif page.record['PageFlags'] & FLAGS_INDEX > 0:\n                raise Exception('FLAGS_INDEX > 0')\n            elif page.record['PageFlags'] & FLAGS_LONG_VALUE > 0:\n                raise Exception('FLAGS_LONG_VALUE > 0')\n            else:\n                # Table Value\n                leafEntry = ESENT_LEAF_ENTRY(flags, data)\n                return leafEntry\n\n        return None",
  "def getNextRow(self, cursor, filter_tables = None):\n        cursor['CurrentTag'] += 1\n\n        tag = self.__getNextTag(cursor)\n        #hexdump(tag)\n\n        if tag is None:\n            # No more tags in this page, search for the next one on the right\n            page = cursor['CurrentPageData']\n            if page.record['NextPageNumber'] == 0:\n                # No more pages, chau\n                return None\n            else:\n                cursor['CurrentPageData'] = self.getPage(page.record['NextPageNumber'])\n                cursor['CurrentTag'] = 0\n                return self.getNextRow(cursor, filter_tables = filter_tables)\n        else:\n            return self.__tagToRecord(cursor, tag['EntryData'], filter_tables = filter_tables)",
  "def __tagToRecord(self, cursor, tag, filter_tables = None):\n        # So my brain doesn't forget, the data record is composed of:\n        # Header\n        # Fixed Size Data (ID < 127)\n        #     The easiest to parse. Their size is fixed in the record. You can get its size\n        #     from the Column Record, field SpaceUsage\n        # Variable Size Data (127 < ID < 255)\n        #     At VariableSizeOffset you get an array of two bytes per variable entry, pointing\n        #     to the length of the value. Values start at:\n        #                numEntries = LastVariableDataType - 127\n        #                VariableSizeOffset + numEntries * 2 (bytes)\n        # Tagged Data ( > 255 )\n        #     After the Variable Size Value, there's more data for the tagged values.\n        #     Right at the beginning there's another array (taggedItems), pointing to the\n        #     values, size.\n        #\n        # The interesting thing about this DB records is there's no need for all the columns to be there, hence\n        # saving space. That's why I got over all the columns, and if I find data (of any type), i assign it. If \n        # not, the column's empty.\n        #\n        # There are a lot of caveats in the code, so take your time to explore it. \n        #\n        # ToDo: Better complete this description\n        #\n\n        record = OrderedDict()\n        taggedItems = OrderedDict()\n        taggedItemsParsed = False\n\n        dataDefinitionHeader = ESENT_DATA_DEFINITION_HEADER(tag)\n        #dataDefinitionHeader.dump()\n        variableDataBytesProcessed = (dataDefinitionHeader['LastVariableDataType'] - 127) * 2\n        prevItemLen = 0\n        tagLen = len(tag)\n        fixedSizeOffset = len(dataDefinitionHeader)\n        variableSizeOffset = dataDefinitionHeader['VariableSizeOffset'] \n \n        columns = cursor['TableData']['Columns'] \n        \n        for column in list(columns.keys()):\n            if filter_tables is not None:\n                if column not in filter_tables:\n                    continue\n            columnRecord = columns[column]['Record']\n            #columnRecord.dump()\n            if columnRecord['Identifier'] <= dataDefinitionHeader['LastFixedSize']:\n                # Fixed Size column data type, still available data\n                record[column] = tag[fixedSizeOffset:][:columnRecord['SpaceUsage']]\n                fixedSizeOffset += columnRecord['SpaceUsage']\n\n            elif 127 < columnRecord['Identifier'] <= dataDefinitionHeader['LastVariableDataType']:\n                # Variable data type\n                index = columnRecord['Identifier'] - 127 - 1\n                itemLen = unpack('<H',tag[variableSizeOffset+index*2:][:2])[0]\n\n                if itemLen & 0x8000:\n                    # Empty item\n                    itemLen = prevItemLen\n                    record[column] = None\n                else:\n                    itemValue = tag[variableSizeOffset+variableDataBytesProcessed:][:itemLen-prevItemLen]\n                    record[column] = itemValue\n\n                #if columnRecord['Identifier'] <= dataDefinitionHeader['LastVariableDataType']:\n                variableDataBytesProcessed +=itemLen-prevItemLen\n\n                prevItemLen = itemLen\n\n            elif columnRecord['Identifier'] > 255:\n                # Have we parsed the tagged items already?\n                if taggedItemsParsed is False and (variableDataBytesProcessed+variableSizeOffset) < tagLen:\n                    index = variableDataBytesProcessed+variableSizeOffset\n                    #hexdump(tag[index:])\n                    endOfVS = self.__pageSize\n                    firstOffsetTag = (unpack('<H', tag[index+2:][:2])[0] & 0x3fff) + variableDataBytesProcessed+variableSizeOffset\n                    while True:\n                        taggedIdentifier = unpack('<H', tag[index:][:2])[0]\n                        index += 2\n                        taggedOffset = (unpack('<H', tag[index:][:2])[0] & 0x3fff) \n                        # As of Windows 7 and later ( version 0x620 revision 0x11) the \n                        # tagged data type flags are always present\n                        if self.__DBHeader['Version'] == 0x620 and self.__DBHeader['FileFormatRevision'] >= 17 and self.__DBHeader['PageSize'] > 8192: \n                            flagsPresent = 1\n                        else:\n                            flagsPresent = (unpack('<H', tag[index:][:2])[0] & 0x4000)\n                        index += 2\n                        if taggedOffset < endOfVS:\n                            endOfVS = taggedOffset\n                        taggedItems[taggedIdentifier] = (taggedOffset, tagLen, flagsPresent)\n                        #print \"ID: %d, Offset:%d, firstOffset:%d, index:%d, flag: 0x%x\" % (taggedIdentifier, taggedOffset,firstOffsetTag,index, flagsPresent)\n                        if index >= firstOffsetTag:\n                            # We reached the end of the variable size array\n                            break\n                \n                    # Calculate length of variable items\n                    # Ugly.. should be redone\n                    prevKey = list(taggedItems.keys())[0]\n                    for i in range(1,len(taggedItems)):\n                        offset0, length, flags = taggedItems[prevKey]\n                        offset, _, _ = list(taggedItems.items())[i][1]\n                        taggedItems[prevKey] = (offset0, offset-offset0, flags)\n                        #print \"ID: %d, Offset: %d, Len: %d, flags: %d\" % (prevKey, offset0, offset-offset0, flags)\n                        prevKey = list(taggedItems.keys())[i]\n                    taggedItemsParsed = True\n \n                # Tagged data type\n                if columnRecord['Identifier'] in taggedItems:\n                    offsetItem = variableDataBytesProcessed + variableSizeOffset + taggedItems[columnRecord['Identifier']][0] \n                    itemSize = taggedItems[columnRecord['Identifier']][1]\n                    # If item have flags, we should skip them\n                    if taggedItems[columnRecord['Identifier']][2] > 0:\n                        itemFlag = ord(tag[offsetItem:offsetItem+1])\n                        offsetItem += 1\n                        itemSize -= 1\n                    else:\n                        itemFlag = 0\n\n                    #print \"ID: %d, itemFlag: 0x%x\" %( columnRecord['Identifier'], itemFlag)\n                    if itemFlag & (TAGGED_DATA_TYPE_COMPRESSED ):\n                        LOG.error('Unsupported tag column: %s, flag:0x%x' % (column, itemFlag))\n                        record[column] = None\n                    elif itemFlag & TAGGED_DATA_TYPE_MULTI_VALUE:\n                        # ToDo: Parse multi-values properly\n                        LOG.debug('Multivalue detected in column %s, returning raw results' % (column))\n                        record[column] = (hexlify(tag[offsetItem:][:itemSize]),)\n                    else:\n                        record[column] = tag[offsetItem:][:itemSize]\n\n                else:\n                    record[column] = None\n            else:\n                record[column] = None\n\n            # If we understand the data type, we unpack it and cast it accordingly\n            # otherwise, we just encode it in hex\n            if type(record[column]) is tuple:\n                # A multi value data, we won't decode it, just leave it this way\n                record[column] = record[column][0]\n            elif columnRecord['ColumnType'] == JET_coltypText or columnRecord['ColumnType'] == JET_coltypLongText: \n                # Let's handle strings\n                if record[column] is not None:\n                    if columnRecord['CodePage'] not in StringCodePages:\n                        raise Exception('Unknown codepage 0x%x'% columnRecord['CodePage'])\n                    stringDecoder = StringCodePages[columnRecord['CodePage']]\n\n                    try:\n                        record[column] = record[column].decode(stringDecoder)\n                    except Exception:\n                        LOG.debug(\"Exception:\", exc_info=True)\n                        LOG.debug('Fixing Record[%r][%d]: %r' % (column, columnRecord['ColumnType'], record[column]))\n                        record[column] = record[column].decode(stringDecoder, \"replace\")\n                        pass\n            else:\n                unpackData = ColumnTypeSize[columnRecord['ColumnType']]\n                if record[column] is not None:\n                    if unpackData is None:\n                        record[column] = hexlify(record[column])\n                    else:\n                        unpackStr = unpackData[1]\n                        record[column] = unpack(unpackStr, record[column])[0]\n\n        return record",
  "class IP6_Address:\n    ADDRESS_BYTE_SIZE = 16\n    #A Hex Group is a 16-bit unit of the address\n    TOTAL_HEX_GROUPS = 8\n    HEX_GROUP_SIZE = 4 #Size in characters\n    TOTAL_SEPARATORS = TOTAL_HEX_GROUPS - 1\n    ADDRESS_TEXT_SIZE = (TOTAL_HEX_GROUPS * HEX_GROUP_SIZE) + TOTAL_SEPARATORS\n    SEPARATOR = \":\"\n    SCOPE_SEPARATOR = \"%\"\n    \n#############################################################################################################\n# Constructor and construction helpers\n\n    def __init__(self, address):\n        #The internal representation of an IP6 address is a 16-byte array\n        self.__bytes = array.array('B', b'\\0' * self.ADDRESS_BYTE_SIZE)\n        self.__scope_id = \"\"\n\n        #Invoke a constructor based on the type of the argument\n        if isinstance(address, string_types):\n            self.__from_string(address)\n        else:\n            self.__from_bytes(address)\n\n\n    def __from_string(self, address):\n        #Separate the Scope ID, if present\n        if self.__is_a_scoped_address(address):\n            split_parts = address.split(self.SCOPE_SEPARATOR)\n            address = split_parts[0]\n            if split_parts[1] == \"\":\n                raise Exception(\"Empty scope ID\")\n            self.__scope_id = split_parts[1]\n        \n        #Expand address if it's in compressed form\n        if self.__is_address_in_compressed_form(address):\n            address = self.__expand_compressed_address(address)\n            \n        #Insert leading zeroes where needed        \n        address = self.__insert_leading_zeroes(address)\n        \n        #Sanity check\n        if len(address) != self.ADDRESS_TEXT_SIZE:\n            raise Exception('IP6_Address - from_string - address size != ' + str(self.ADDRESS_TEXT_SIZE))\n    \n        #Split address into hex groups\n        hex_groups = address.split(self.SEPARATOR)\n        if len(hex_groups) != self.TOTAL_HEX_GROUPS:\n            raise Exception('IP6_Address - parsed hex groups != ' + str(self.TOTAL_HEX_GROUPS))\n\n        #For each hex group, convert it into integer words\n        offset = 0\n        for group in hex_groups:\n            if len(group) != self.HEX_GROUP_SIZE:\n                raise Exception('IP6_Address - parsed hex group length != ' + str(self.HEX_GROUP_SIZE))\n            \n            group_as_int = int(group, 16)\n            self.__bytes[offset]     = (group_as_int & 0xFF00) >> 8\n            self.__bytes[offset + 1] = (group_as_int & 0x00FF) \n            offset += 2            \n\n    def __from_bytes(self, theBytes):\n        if len(theBytes) != self.ADDRESS_BYTE_SIZE:\n            raise Exception (\"IP6_Address - from_bytes - array size != \" + str(self.ADDRESS_BYTE_SIZE))\n        self.__bytes = theBytes\n\n#############################################################################################################\n# Projectors\n    def as_string(self, compress_address = True, scoped_address = True):\n        s = \"\"\n        for i, v in enumerate(self.__bytes):\n            s += hex(v)[2:].rjust(2, '0')\n            if i % 2 == 1:\n                s += self.SEPARATOR\n        s = s[:-1].upper()\n        \n        if compress_address:\n            s = self.__trim_leading_zeroes(s)\n            s = self.__trim_longest_zero_chain(s)\n            \n        if scoped_address and self.get_scope_id() != \"\":\n            s += self.SCOPE_SEPARATOR + self.__scope_id\n        return s\n                \n    def as_bytes(self):\n        return self.__bytes\n    \n    def __str__(self):\n        return self.as_string()\n    \n    def get_scope_id(self):\n        return self.__scope_id\n    \n    def get_unscoped_address(self):\n        return self.as_string(True, False) #Compressed address = True, Scoped address = False\n        \n#############################################################################################################\n# Semantic helpers\n    def is_multicast(self):\n        return self.__bytes[0] == 0xFF\n    \n    def is_unicast(self):\n        return self.__bytes[0] == 0xFE\n    \n    def is_link_local_unicast(self):\n        return self.is_unicast() and (self.__bytes[1] & 0xC0 == 0x80)\n    \n    def is_site_local_unicast(self):\n        return self.is_unicast() and (self.__bytes[1] & 0xC0 == 0xC0)\n    \n    def is_unique_local_unicast(self):\n        return self.__bytes[0] == 0xFD\n                \n    \n    def get_human_readable_address_type(self):\n        if self.is_multicast():\n            return \"multicast\"\n        elif self.is_unicast():\n            if self.is_link_local_unicast():\n                return \"link-local unicast\"\n            elif self.is_site_local_unicast():\n                return \"site-local unicast\"\n            else:\n                return \"unicast\"\n        elif self.is_unique_local_unicast():\n            return \"unique-local unicast\"\n        else:\n            return \"unknown type\"\n\n#############################################################################################################\n#Expansion helpers\n\n    #Predicate - returns whether an address is in compressed form\n    def __is_address_in_compressed_form(self, address):\n        #Sanity check - triple colon detection (not detected by searches of double colon)        \n        if address.count(self.SEPARATOR * 3) > 0:\n            raise Exception('IP6_Address - found triple colon')\n        \n        #Count the double colon marker\n        compression_marker_count = self.__count_compression_marker(address)        \n        if compression_marker_count == 0:\n            return False\n        elif compression_marker_count == 1:\n            return True\n        else:\n            raise Exception('IP6_Address - more than one compression marker (\\\"::\\\") found')\n       \n    #Returns how many hex groups are present, in a compressed address \n    def __count_compressed_groups(self, address):\n        trimmed_address = address.replace(self.SEPARATOR * 2, self.SEPARATOR) #Replace \"::\" with \":\"        \n        return trimmed_address.count(self.SEPARATOR) + 1\n\n    #Counts how many compression markers are present\n    def __count_compression_marker(self, address):\n        return address.count(self.SEPARATOR * 2) #Count occurrences of \"::\"\n\n    #Inserts leading zeroes in every hex group\n    def __insert_leading_zeroes(self, address):\n        hex_groups = address.split(self.SEPARATOR)\n        \n        new_address = \"\"\n        for hex_group in hex_groups:\n            if len(hex_group) < 4:\n                hex_group = hex_group.rjust(4, \"0\")\n            new_address += hex_group + self.SEPARATOR\n            \n        return new_address[:-1] #Trim the last colon\n            \n            \n    #Expands a compressed address\n    def __expand_compressed_address(self, address):\n        group_count = self.__count_compressed_groups(address)\n        groups_to_insert = self.TOTAL_HEX_GROUPS - group_count\n        \n        pos = address.find(self.SEPARATOR * 2) + 1 \n        while groups_to_insert:\n            address = address[:pos] + \"0000\" + self.SEPARATOR + address[pos:]\n            pos += 5\n            groups_to_insert -= 1\n\n        #Replace the compression marker with a single colon            \n        address = address.replace(self.SEPARATOR * 2, self.SEPARATOR)        \n        return address\n\n\n#############################################################################################################\n#Compression helpers\n\n    def __trim_longest_zero_chain(self, address):\n        chain_size = 8\n        \n        while chain_size > 0:\n            groups = address.split(self.SEPARATOR)\n\n            for index, group in enumerate(groups):\n                #Find the first zero\n                if group == \"0\":\n                    start_index = index\n                    end_index = index\n                    #Find the end of this chain of zeroes\n                    while end_index < 7 and groups[end_index + 1] == \"0\":\n                        end_index += 1\n                        \n                    #If the zero chain matches the current size, trim it\n                    found_size = end_index - start_index + 1\n                    if found_size == chain_size:\n                        address = self.SEPARATOR.join(groups[0:start_index]) + self.SEPARATOR * 2 + self.SEPARATOR.join(groups[(end_index+1):])\n                        return address\n                    \n            #No chain of this size found, try with a lower size    \n            chain_size -= 1\n        return address\n\n                                \n    #Trims all leading zeroes from every hex group\n    def __trim_leading_zeroes(self, theStr):\n        groups = theStr.split(self.SEPARATOR)\n        theStr = \"\"\n        \n        for group in groups:\n            group = group.lstrip(\"0\") + self.SEPARATOR\n            if group == self.SEPARATOR:\n                group = \"0\" + self.SEPARATOR\n            theStr += group\n        return theStr[:-1]\n                \n\n#############################################################################################################\n    @classmethod\n    def is_a_valid_text_representation(cls, text_representation):\n        try:\n            #Capitalize on the constructor's ability to detect invalid text representations of an IP6 address            \n            IP6_Address(text_representation)\n            return True\n        except Exception:\n            return False\n                \n    def __is_a_scoped_address(self, text_representation):\n        return text_representation.count(self.SCOPE_SEPARATOR) == 1",
  "def __init__(self, address):\n        #The internal representation of an IP6 address is a 16-byte array\n        self.__bytes = array.array('B', b'\\0' * self.ADDRESS_BYTE_SIZE)\n        self.__scope_id = \"\"\n\n        #Invoke a constructor based on the type of the argument\n        if isinstance(address, string_types):\n            self.__from_string(address)\n        else:\n            self.__from_bytes(address)",
  "def __from_string(self, address):\n        #Separate the Scope ID, if present\n        if self.__is_a_scoped_address(address):\n            split_parts = address.split(self.SCOPE_SEPARATOR)\n            address = split_parts[0]\n            if split_parts[1] == \"\":\n                raise Exception(\"Empty scope ID\")\n            self.__scope_id = split_parts[1]\n        \n        #Expand address if it's in compressed form\n        if self.__is_address_in_compressed_form(address):\n            address = self.__expand_compressed_address(address)\n            \n        #Insert leading zeroes where needed        \n        address = self.__insert_leading_zeroes(address)\n        \n        #Sanity check\n        if len(address) != self.ADDRESS_TEXT_SIZE:\n            raise Exception('IP6_Address - from_string - address size != ' + str(self.ADDRESS_TEXT_SIZE))\n    \n        #Split address into hex groups\n        hex_groups = address.split(self.SEPARATOR)\n        if len(hex_groups) != self.TOTAL_HEX_GROUPS:\n            raise Exception('IP6_Address - parsed hex groups != ' + str(self.TOTAL_HEX_GROUPS))\n\n        #For each hex group, convert it into integer words\n        offset = 0\n        for group in hex_groups:\n            if len(group) != self.HEX_GROUP_SIZE:\n                raise Exception('IP6_Address - parsed hex group length != ' + str(self.HEX_GROUP_SIZE))\n            \n            group_as_int = int(group, 16)\n            self.__bytes[offset]     = (group_as_int & 0xFF00) >> 8\n            self.__bytes[offset + 1] = (group_as_int & 0x00FF) \n            offset += 2",
  "def __from_bytes(self, theBytes):\n        if len(theBytes) != self.ADDRESS_BYTE_SIZE:\n            raise Exception (\"IP6_Address - from_bytes - array size != \" + str(self.ADDRESS_BYTE_SIZE))\n        self.__bytes = theBytes",
  "def as_string(self, compress_address = True, scoped_address = True):\n        s = \"\"\n        for i, v in enumerate(self.__bytes):\n            s += hex(v)[2:].rjust(2, '0')\n            if i % 2 == 1:\n                s += self.SEPARATOR\n        s = s[:-1].upper()\n        \n        if compress_address:\n            s = self.__trim_leading_zeroes(s)\n            s = self.__trim_longest_zero_chain(s)\n            \n        if scoped_address and self.get_scope_id() != \"\":\n            s += self.SCOPE_SEPARATOR + self.__scope_id\n        return s",
  "def as_bytes(self):\n        return self.__bytes",
  "def __str__(self):\n        return self.as_string()",
  "def get_scope_id(self):\n        return self.__scope_id",
  "def get_unscoped_address(self):\n        return self.as_string(True, False)",
  "def is_multicast(self):\n        return self.__bytes[0] == 0xFF",
  "def is_unicast(self):\n        return self.__bytes[0] == 0xFE",
  "def is_link_local_unicast(self):\n        return self.is_unicast() and (self.__bytes[1] & 0xC0 == 0x80)",
  "def is_site_local_unicast(self):\n        return self.is_unicast() and (self.__bytes[1] & 0xC0 == 0xC0)",
  "def is_unique_local_unicast(self):\n        return self.__bytes[0] == 0xFD",
  "def get_human_readable_address_type(self):\n        if self.is_multicast():\n            return \"multicast\"\n        elif self.is_unicast():\n            if self.is_link_local_unicast():\n                return \"link-local unicast\"\n            elif self.is_site_local_unicast():\n                return \"site-local unicast\"\n            else:\n                return \"unicast\"\n        elif self.is_unique_local_unicast():\n            return \"unique-local unicast\"\n        else:\n            return \"unknown type\"",
  "def __is_address_in_compressed_form(self, address):\n        #Sanity check - triple colon detection (not detected by searches of double colon)        \n        if address.count(self.SEPARATOR * 3) > 0:\n            raise Exception('IP6_Address - found triple colon')\n        \n        #Count the double colon marker\n        compression_marker_count = self.__count_compression_marker(address)        \n        if compression_marker_count == 0:\n            return False\n        elif compression_marker_count == 1:\n            return True\n        else:\n            raise Exception('IP6_Address - more than one compression marker (\\\"::\\\") found')",
  "def __count_compressed_groups(self, address):\n        trimmed_address = address.replace(self.SEPARATOR * 2, self.SEPARATOR) #Replace \"::\" with \":\"        \n        return trimmed_address.count(self.SEPARATOR) + 1",
  "def __count_compression_marker(self, address):\n        return address.count(self.SEPARATOR * 2)",
  "def __insert_leading_zeroes(self, address):\n        hex_groups = address.split(self.SEPARATOR)\n        \n        new_address = \"\"\n        for hex_group in hex_groups:\n            if len(hex_group) < 4:\n                hex_group = hex_group.rjust(4, \"0\")\n            new_address += hex_group + self.SEPARATOR\n            \n        return new_address[:-1]",
  "def __expand_compressed_address(self, address):\n        group_count = self.__count_compressed_groups(address)\n        groups_to_insert = self.TOTAL_HEX_GROUPS - group_count\n        \n        pos = address.find(self.SEPARATOR * 2) + 1 \n        while groups_to_insert:\n            address = address[:pos] + \"0000\" + self.SEPARATOR + address[pos:]\n            pos += 5\n            groups_to_insert -= 1\n\n        #Replace the compression marker with a single colon            \n        address = address.replace(self.SEPARATOR * 2, self.SEPARATOR)        \n        return address",
  "def __trim_longest_zero_chain(self, address):\n        chain_size = 8\n        \n        while chain_size > 0:\n            groups = address.split(self.SEPARATOR)\n\n            for index, group in enumerate(groups):\n                #Find the first zero\n                if group == \"0\":\n                    start_index = index\n                    end_index = index\n                    #Find the end of this chain of zeroes\n                    while end_index < 7 and groups[end_index + 1] == \"0\":\n                        end_index += 1\n                        \n                    #If the zero chain matches the current size, trim it\n                    found_size = end_index - start_index + 1\n                    if found_size == chain_size:\n                        address = self.SEPARATOR.join(groups[0:start_index]) + self.SEPARATOR * 2 + self.SEPARATOR.join(groups[(end_index+1):])\n                        return address\n                    \n            #No chain of this size found, try with a lower size    \n            chain_size -= 1\n        return address",
  "def __trim_leading_zeroes(self, theStr):\n        groups = theStr.split(self.SEPARATOR)\n        theStr = \"\"\n        \n        for group in groups:\n            group = group.lstrip(\"0\") + self.SEPARATOR\n            if group == self.SEPARATOR:\n                group = \"0\" + self.SEPARATOR\n            theStr += group\n        return theStr[:-1]",
  "def is_a_valid_text_representation(cls, text_representation):\n        try:\n            #Capitalize on the constructor's ability to detect invalid text representations of an IP6 address            \n            IP6_Address(text_representation)\n            return True\n        except Exception:\n            return False",
  "def __is_a_scoped_address(self, text_representation):\n        return text_representation.count(self.SCOPE_SEPARATOR) == 1",
  "class Header(Structure):\n    structure = (\n        ('tag','!H=0'),\n        ('taglen','!H=0'),\n        ('_tagdata','_-tagdata','self[\"taglen\"]'),\n        ('tagdata',':'),\n    )",
  "class DeltaTime(Structure):\n    structure = (\n        ('time_offset','!L=0'),\n        ('usec_offset','!L=0'),\n    )",
  "class CountedOctetString(Structure):\n    structure = (\n        ('length','!L=0'),\n        ('_data','_-data','self[\"length\"]'),\n        ('data',':'),\n    )\n\n    def prettyPrint(self, indent=''):\n        return \"%s%s\" % (indent, hexlify(self['data']))",
  "class KeyBlockV3(Structure):\n    structure = (\n        ('keytype','!H=0'),\n        ('etype','!H=0'),\n        ('etype2', '!H=0'),  # Version 3 repeats the etype\n        ('keylen','!H=0'),\n        ('_keyvalue','_-keyvalue','self[\"keylen\"]'),\n        ('keyvalue',':'),\n    )\n\n    def prettyPrint(self):\n        return \"Key: (0x%x)%s\" % (self['keytype'], hexlify(self['keyvalue']))",
  "class KeyBlockV4(Structure):\n    structure = (\n        ('keytype','!H=0'),\n        ('etype','!H=0'),\n        ('keylen','!H=0'),\n        ('_keyvalue','_-keyvalue','self[\"keylen\"]'),\n        ('keyvalue',':'),\n    )\n\n    def prettyPrint(self):\n        return \"Key: (0x%x)%s\" % (self['keytype'], hexlify(self['keyvalue']))",
  "class Times(Structure):\n    structure = (\n        ('authtime','!L=0'),\n        ('starttime','!L=0'),\n        ('endtime','!L=0'),\n        ('renew_till','!L=0'),\n    )\n    def prettyPrint(self, indent = ''):\n        print((\"%sAuth : %s\" % (indent, datetime.fromtimestamp(self['authtime']).isoformat())))\n        print((\"%sStart: %s\" % (indent, datetime.fromtimestamp(self['starttime']).isoformat())))\n        print((\"%sEnd  : %s\" % (indent, datetime.fromtimestamp(self['endtime']).isoformat())))\n        print((\"%sRenew: %s\" % (indent, datetime.fromtimestamp(self['renew_till']).isoformat())))",
  "class Address(Structure):\n    structure = (\n        ('addrtype','!H=0'),\n        ('addrdata',':', CountedOctetString),\n    )",
  "class AuthData(Structure):\n    structure = (\n        ('authtype','!H=0'),\n        ('authdata',':', CountedOctetString),\n    )",
  "class Principal:\n    class PrincipalHeader(Structure):\n        structure = (\n            ('name_type','!L=0'),\n            ('num_components','!L=0'),\n        )\n    def __init__(self, data=None):\n        self.components = []\n        self.realm = None\n        if data is not None:\n            self.header = self.PrincipalHeader(data)\n            data = data[len(self.header):]\n            self.realm = CountedOctetString(data)\n            data = data[len(self.realm):]\n            self.components = []\n            for component in range(self.header['num_components']):\n                comp = CountedOctetString(data)\n                data = data[len(comp):]\n                self.components.append(comp)\n        else:\n            self.header = self.PrincipalHeader()\n\n    def __len__(self):\n        totalLen = len(self.header) + len(self.realm)\n        for i in self.components:\n            totalLen += len(i)\n        return totalLen\n\n    def getData(self):\n        data = self.header.getData() + self.realm.getData()\n        for component in self.components:\n            data += component.getData()\n        return data\n\n    def __str__(self):\n        return self.getData()\n\n    def prettyPrint(self):\n        principal = b''\n        for component in self.components:\n            if isinstance(component['data'], bytes) is not True:\n                component = b(component['data'])\n            else:\n                component = component['data']\n            principal += component + b'/'\n\n        principal = principal[:-1]\n        if isinstance(self.realm['data'], bytes):\n            realm = self.realm['data']\n        else:\n            realm = b(self.realm['data'])\n        principal += b'@' + realm\n        return principal\n\n    def fromPrincipal(self, principal):\n        self.header['name_type'] = principal.type\n        self.header['num_components'] = len(principal.components)\n        octetString = CountedOctetString()\n        octetString['length'] = len(principal.realm)\n        octetString['data'] = principal.realm\n        self.realm = octetString\n        self.components = []\n        for c in principal.components:\n            octetString = CountedOctetString()\n            octetString['length'] = len(c)\n            octetString['data'] = c\n            self.components.append(octetString)\n\n    def toPrincipal(self):\n        return types.Principal(self.prettyPrint(), type=self.header['name_type'])",
  "class Credential:\n    class CredentialHeaderV3(Structure):\n        structure = (\n            ('client',':', Principal),\n            ('server',':', Principal),\n            ('key',':', KeyBlockV3),\n            ('time',':', Times),\n            ('is_skey','B=0'),\n            ('tktflags','!L=0'),\n            ('num_address','!L=0'),\n        )\n\n    class CredentialHeaderV4(Structure):\n        structure = (\n            ('client',':', Principal),\n            ('server',':', Principal),\n            ('key',':', KeyBlockV4),\n            ('time',':', Times),\n            ('is_skey','B=0'),\n            ('tktflags','!L=0'),\n            ('num_address','!L=0'),\n        )\n\n    def __init__(self, data=None, ccache_version=None):\n        self.addresses = ()\n        self.authData = ()\n        self.header = None\n        self.ticket = None\n        self.secondTicket = None\n\n        if data is not None:\n            if ccache_version == 3:\n                self.header = self.CredentialHeaderV3(data)\n            else:\n                self.header = self.CredentialHeaderV4(data)\n\n            data = data[len(self.header):]\n            self.addresses = []\n            for address in range(self.header['num_address']):\n                ad = Address(data)\n                data = data[len(ad):]\n                self.addresses.append(ad)\n            num_authdata = unpack('!L', data[:4])[0]\n            data = data[calcsize('!L'):]\n            for authdata in range(num_authdata):\n                ad = AuthData(data)\n                data = data[len(ad):]\n                self.authData.append(ad)\n            self.ticket = CountedOctetString(data)\n            data = data[len(self.ticket):]\n            self.secondTicket = CountedOctetString(data)\n            data = data[len( self.secondTicket):]\n        else:\n            self.header = self.CredentialHeaderV4()\n\n    def __getitem__(self, key):\n        return self.header[key]\n\n    def __setitem__(self, item, value):\n        self.header[item] = value\n\n    def getServerPrincipal(self):\n        return self.header['server'].prettyPrint()\n\n    def __len__(self):\n        totalLen = len(self.header)\n        for i in self.addresses:\n            totalLen += len(i)\n        totalLen += calcsize('!L')\n        for i in self.authData:\n            totalLen += len(i)\n        totalLen += len(self.ticket)\n        totalLen += len(self.secondTicket)\n        return totalLen\n\n    def dump(self):\n        self.header.dump()\n\n    def getData(self):\n        data = self.header.getData()\n        for i in self.addresses:\n            data += i.getData()\n        data += pack('!L', len(self.authData))\n        for i in self.authData:\n            data += i.getData()\n        data += self.ticket.getData()\n        data += self.secondTicket.getData()\n        return data\n\n    def __str__(self):\n        return self.getData()\n\n    def prettyPrint(self, indent=''):\n        print((\"%sClient: %s\" % (indent, self.header['client'].prettyPrint())))\n        print((\"%sServer: %s\" % (indent, self.header['server'].prettyPrint())))\n        print((\"%s%s\" % (indent, self.header['key'].prettyPrint())))\n        print((\"%sTimes: \" % indent))\n        self.header['time'].prettyPrint('\\t\\t')\n        print((\"%sSubKey: %s\" % (indent, self.header['is_skey'])))\n        print((\"%sFlags: 0x%x\" % (indent, self.header['tktflags'])))\n        print((\"%sAddresses: %d\" % (indent, self.header['num_address'])))\n        for address in self.addresses:\n            address.prettyPrint('\\t\\t')\n        print((\"%sAuth Data: %d\" % (indent, len(self.authData))))\n        for ad in self.authData:\n            ad.prettyPrint('\\t\\t')\n        print((\"%sTicket: %s\" % (indent, self.ticket.prettyPrint())))\n        print((\"%sSecond Ticket: %s\" % (indent, self.secondTicket.prettyPrint())))\n\n    def toTGT(self):\n        tgt_rep = AS_REP()\n        tgt_rep['pvno'] = 5\n        tgt_rep['msg-type'] = int(constants.ApplicationTagNumbers.AS_REP.value)\n        tgt_rep['crealm'] = self['server'].realm['data']\n\n        # Fake EncryptedData\n        tgt_rep['enc-part'] = noValue\n        tgt_rep['enc-part']['etype'] = 1\n        tgt_rep['enc-part']['cipher'] = ''\n        seq_set(tgt_rep, 'cname', self['client'].toPrincipal().components_to_asn1)\n        ticket = types.Ticket()\n        ticket.from_asn1(self.ticket['data'])\n        seq_set(tgt_rep,'ticket', ticket.to_asn1)\n\n        cipher = crypto._enctype_table[self['key']['keytype']]()\n\n        tgt = dict()\n        tgt['KDC_REP'] = encoder.encode(tgt_rep)\n        tgt['cipher'] = cipher\n        tgt['sessionKey'] = crypto.Key(cipher.enctype, self['key']['keyvalue'])\n        return tgt\n\n    def toTGS(self, newSPN=None):\n        tgs_rep = TGS_REP()\n        tgs_rep['pvno'] = 5\n        tgs_rep['msg-type'] = int(constants.ApplicationTagNumbers.TGS_REP.value)\n        tgs_rep['crealm'] = self['server'].realm['data']\n\n        # Fake EncryptedData\n        tgs_rep['enc-part'] = noValue\n        tgs_rep['enc-part']['etype'] = 1\n        tgs_rep['enc-part']['cipher'] = ''\n        seq_set(tgs_rep, 'cname', self['client'].toPrincipal().components_to_asn1)\n        ticket = types.Ticket()\n        ticket.from_asn1(self.ticket['data'])\n        if newSPN is not None:\n            if newSPN.upper() != str(ticket.service_principal).upper():\n                LOG.debug('Changing sname from %s to %s and hoping for the best' % (ticket.service_principal, newSPN) )\n                ticket.service_principal = types.Principal(newSPN, type=int(ticket.service_principal.type))\n        seq_set(tgs_rep,'ticket', ticket.to_asn1)\n\n        cipher = crypto._enctype_table[self['key']['keytype']]()\n\n        tgs = dict()\n        tgs['KDC_REP'] = encoder.encode(tgs_rep)\n        tgs['cipher'] = cipher\n        tgs['sessionKey'] = crypto.Key(cipher.enctype, self['key']['keyvalue'])\n        return tgs",
  "class CCache:\n    # https://web.mit.edu/kerberos/krb5-devel/doc/formats/ccache_file_format.html\n\n    class MiniHeader(Structure):\n        structure = (\n            ('file_format_version','!H=0x0504'),\n            ('headerlen','!H=12'),\n        )\n\n    def __init__(self, data = None):\n        self.headers = None\n        self.principal = None\n        self.credentials = []\n        self.miniHeader = None\n\n        if data is not None:\n            if PY2:\n                ccache_version = unpack('>B', data[1])[0]\n            else:\n                ccache_version = data[1]\n\n            # Versions 1 and 2 are not implemented yet\n            if ccache_version == 1 or ccache_version == 2:\n                raise NotImplementedError('Not Implemented!')\n\n            # Only Version 4 contains a header\n            if ccache_version == 4:\n                miniHeader = self.MiniHeader(data)\n                data = data[len(miniHeader.getData()):]\n\n                headerLen = miniHeader['headerlen']\n\n                self.headers = []\n                while headerLen > 0:\n                    header = Header(data)\n                    self.headers.append(header)\n                    headerLen -= len(header)\n                    data = data[len(header):]\n            else:\n                # Skip over the version bytes\n                data = data[2:]\n\n            # Now the primary_principal\n            self.principal = Principal(data)\n\n            data = data[len(self.principal):]\n\n            # Now let's parse the credentials\n            self.credentials = []\n            while len(data) > 0:\n                cred = Credential(data, ccache_version)\n                if cred['server'].prettyPrint().find(b'krb5_ccache_conf_data') < 0:\n                    self.credentials.append(cred)\n                data = data[len(cred.getData()):]\n\n    def getData(self):\n        data = self.MiniHeader().getData()\n        for header in self.headers:\n            data += header.getData()\n        data += self.principal.getData()\n        for credential in self.credentials:\n            data += credential.getData()\n        return data\n\n    def getCredential(self, server, anySPN=True):\n        for c in self.credentials:\n            if c['server'].prettyPrint().upper() == b(server.upper()) or c['server'].prettyPrint().upper().split(b'@')[0] == b(server.upper())\\\n                    or c['server'].prettyPrint().upper().split(b'@')[0] == b(server.upper().split('@')[0]):\n                LOG.debug('Returning cached credential for %s' % c['server'].prettyPrint().upper().decode('utf-8'))\n                return c\n        LOG.debug('SPN %s not found in cache' % server.upper())\n        if anySPN is True:\n            LOG.debug('AnySPN is True, looking for another suitable SPN')\n            for c in self.credentials:\n                # Let's search for any TGT/TGS that matches the server w/o the SPN's service type/port, returns\n                # the first one\n                if c['server'].prettyPrint().find(b'/') >=0:\n                    # Let's take the port out for comparison\n                    cachedSPN = (c['server'].prettyPrint().upper().split(b'/')[1].split(b'@')[0].split(b':')[0] + b'@' + c['server'].prettyPrint().upper().split(b'/')[1].split(b'@')[1])\n                    searchSPN = '%s@%s' % (server.upper().split('/')[1].split('@')[0].split(':')[0],\n                                               server.upper().split('/')[1].split('@')[1])\n                    if cachedSPN == b(searchSPN):\n                        LOG.debug('Returning cached credential for %s' % c['server'].prettyPrint().upper().decode('utf-8'))\n                        return c\n\n        return None\n\n    def toTimeStamp(self, dt, epoch=datetime(1970,1,1)):\n        td = dt - epoch\n        # return td.total_seconds()\n        return int((td.microseconds + (td.seconds + td.days * 24 * 3600) * 10**6) // 1e6)\n\n    def reverseFlags(self, flags):\n        result = 0\n        if isinstance(flags, str):\n            flags = flags[1:-2]\n        for i,j in enumerate(reversed(flags)):\n            if j != 0:\n                result += j << i\n        return result\n\n    def fromTGT(self, tgt, oldSessionKey, sessionKey):\n        self.headers = []\n        header = Header()\n        header['tag'] = 1\n        header['taglen'] = 8\n        header['tagdata'] = b'\\xff\\xff\\xff\\xff\\x00\\x00\\x00\\x00'\n        self.headers.append(header)\n\n        decodedTGT = decoder.decode(tgt, asn1Spec = AS_REP())[0]\n\n        tmpPrincipal = types.Principal()\n        tmpPrincipal.from_asn1(decodedTGT, 'crealm', 'cname')\n        self.principal = Principal()\n        self.principal.fromPrincipal(tmpPrincipal)\n\n        # Now let's add the credential\n        cipherText = decodedTGT['enc-part']['cipher']\n\n        cipher = crypto._enctype_table[decodedTGT['enc-part']['etype']]\n\n        # Key Usage 3\n        # AS-REP encrypted part (includes TGS session key or\n        # application session key), encrypted with the client key\n        # (Section 5.4.2)\n        plainText = cipher.decrypt(oldSessionKey, 3, cipherText)\n\n        encASRepPart = decoder.decode(plainText, asn1Spec = EncASRepPart())[0]\n        credential = Credential()\n        server = types.Principal()\n        server.from_asn1(encASRepPart, 'srealm', 'sname')\n        tmpServer = Principal()\n        tmpServer.fromPrincipal(server)\n\n        credential['client'] = self.principal\n        credential['server'] = tmpServer\n        credential['is_skey'] = 0\n\n        credential['key'] = KeyBlockV4()\n        credential['key']['keytype'] = int(encASRepPart['key']['keytype'])\n        credential['key']['keyvalue'] = encASRepPart['key']['keyvalue'].asOctets()\n        credential['key']['keylen'] = len(credential['key']['keyvalue'])\n\n        credential['time'] = Times()\n        credential['time']['authtime'] = self.toTimeStamp(types.KerberosTime.from_asn1(encASRepPart['authtime']))\n        credential['time']['starttime'] = self.toTimeStamp(types.KerberosTime.from_asn1(encASRepPart['starttime']))\n        credential['time']['endtime'] = self.toTimeStamp(types.KerberosTime.from_asn1(encASRepPart['endtime']))\n        # After KB4586793 for CVE-2020-17049 this timestamp may be omitted\n        if encASRepPart['renew-till'].hasValue():\n            credential['time']['renew_till'] = self.toTimeStamp(types.KerberosTime.from_asn1(encASRepPart['renew-till']))\n        flags = self.reverseFlags(encASRepPart['flags'])\n        credential['tktflags'] = flags\n\n        credential['num_address'] = 0\n        credential.ticket = CountedOctetString()\n        credential.ticket['data'] = encoder.encode(decodedTGT['ticket'].clone(tagSet=Ticket.tagSet, cloneValueFlag=True))\n        credential.ticket['length'] = len(credential.ticket['data'])\n        credential.secondTicket = CountedOctetString()\n        credential.secondTicket['data'] = b''\n        credential.secondTicket['length'] = 0\n        self.credentials.append(credential)\n\n    def fromTGS(self, tgs, oldSessionKey, sessionKey):\n        self.headers = []\n        header = Header()\n        header['tag'] = 1\n        header['taglen'] = 8\n        header['tagdata'] = b'\\xff\\xff\\xff\\xff\\x00\\x00\\x00\\x00'\n        self.headers.append(header)\n\n        decodedTGS = decoder.decode(tgs, asn1Spec = TGS_REP())[0]\n\n        tmpPrincipal = types.Principal()\n        tmpPrincipal.from_asn1(decodedTGS, 'crealm', 'cname')\n        self.principal = Principal()\n        self.principal.fromPrincipal(tmpPrincipal)\n\n        # Now let's add the credential\n        cipherText = decodedTGS['enc-part']['cipher']\n\n        cipher = crypto._enctype_table[decodedTGS['enc-part']['etype']]\n\n        # Key Usage 8\n        # TGS-REP encrypted part (includes application session\n        # key), encrypted with the TGS session key (Section 5.4.2)\n        plainText = cipher.decrypt(oldSessionKey, 8, cipherText)\n\n        encTGSRepPart = decoder.decode(plainText, asn1Spec = EncTGSRepPart())[0]\n\n        credential = Credential()\n        server = types.Principal()\n        server.from_asn1(encTGSRepPart, 'srealm', 'sname')\n        tmpServer = Principal()\n        tmpServer.fromPrincipal(server)\n\n        credential['client'] = self.principal\n        credential['server'] = tmpServer\n        credential['is_skey'] = 0\n\n        credential['key'] = KeyBlockV4()\n        credential['key']['keytype'] = int(encTGSRepPart['key']['keytype'])\n        credential['key']['keyvalue'] = encTGSRepPart['key']['keyvalue'].asOctets()\n        credential['key']['keylen'] = len(credential['key']['keyvalue'])\n\n        credential['time'] = Times()\n        credential['time']['authtime'] = self.toTimeStamp(types.KerberosTime.from_asn1(encTGSRepPart['authtime']))\n        credential['time']['starttime'] = self.toTimeStamp(types.KerberosTime.from_asn1(encTGSRepPart['starttime']))\n        credential['time']['endtime'] = self.toTimeStamp(types.KerberosTime.from_asn1(encTGSRepPart['endtime']))\n        # After KB4586793 for CVE-2020-17049 this timestamp may be omitted\n        if encTGSRepPart['renew-till'].hasValue():\n            credential['time']['renew_till'] = self.toTimeStamp(types.KerberosTime.from_asn1(encTGSRepPart['renew-till']))\n\n        flags = self.reverseFlags(encTGSRepPart['flags'])\n        credential['tktflags'] = flags\n\n        credential['num_address'] = 0\n\n        credential.ticket = CountedOctetString()\n        credential.ticket['data'] = encoder.encode(decodedTGS['ticket'].clone(tagSet=Ticket.tagSet, cloneValueFlag=True))\n        credential.ticket['length'] = len(credential.ticket['data'])\n        credential.secondTicket = CountedOctetString()\n        credential.secondTicket['data'] = b''\n        credential.secondTicket['length'] = 0\n        self.credentials.append(credential)\n\n    @classmethod\n    def loadFile(cls, fileName):\n        if fileName is None:\n            LOG.critical('CCache file is not found. Skipping...')\n            LOG.debug('The specified path is not correct or the KRB5CCNAME environment variable is not defined')\n            return None\n\n        try:\n            f = open(fileName, 'rb')\n            data = f.read()\n            f.close()\n            return cls(data)\n        except FileNotFoundError as e:\n            raise e\n\n    def saveFile(self, fileName):\n        f = open(fileName, 'wb+')\n        f.write(self.getData())\n        f.close()\n\n    @classmethod\n    def parseFile(cls, domain='', username='', target=''):\n        \"\"\"\n        parses the CCache file specified in the KRB5CCNAME environment variable\n\n        :param domain: an optional domain name of a user\n        :param username: an optional username of a user\n        :param target: an optional SPN of a target system\n\n        :return: domain, username, TGT, TGS\n        \"\"\"\n\n        ccache = cls.loadFile(os.getenv('KRB5CCNAME'))\n        if ccache is None:\n            return domain, username, None, None\n\n        LOG.debug('Using Kerberos Cache: %s' % os.getenv('KRB5CCNAME'))\n\n        if domain == '':\n            domain = ccache.principal.realm['data'].decode('utf-8')\n            LOG.debug('Domain retrieved from CCache: %s' % domain)\n\n        creds = None\n        if target != '':\n            principal = '%s@%s' % (target.upper(), domain.upper())\n            creds = ccache.getCredential(principal)\n\n        TGT = None\n        TGS = None\n        if creds is None:\n            principal = 'krbtgt/%s@%s' % (domain.upper(), domain.upper())\n            creds = ccache.getCredential(principal)\n            if creds is not None:\n                LOG.debug('Using TGT from cache')\n                TGT = creds.toTGT()\n            else:\n                LOG.debug('No valid credentials found in cache')\n        else:\n            LOG.debug('Using TGS from cache')\n            TGS = creds.toTGS(principal)\n\n        if username == '' and creds is not None:\n            username = creds['client'].prettyPrint().split(b'@')[0].decode('utf-8')\n            LOG.debug('Username retrieved from CCache: %s' % username)\n        elif username == '' and len(ccache.principal.components) > 0:\n            username = ccache.principal.components[0]['data'].decode('utf-8')\n            LOG.debug('Username retrieved from CCache: %s' % username)\n\n        return domain, username, TGT, TGS\n\n    def prettyPrint(self):\n        print((\"Primary Principal: %s\" % self.principal.prettyPrint()))\n        print(\"Credentials: \")\n        for i, credential in enumerate(self.credentials):\n            print((\"[%d]\" % i))\n            credential.prettyPrint('\\t')\n\n    @classmethod\n    def loadKirbiFile(cls, fileName):\n        f = open(fileName, 'rb')\n        data = f.read()\n        f.close()\n        ccache = cls()\n        ccache.fromKRBCRED(data)\n        return ccache\n\n    def saveKirbiFile(self, fileName):\n        f = open(fileName, 'wb+')\n        f.write(self.toKRBCRED())\n        f.close()\n\n    def fromKRBCRED(self, encodedKrbCred):\n\n        krbCred = decoder.decode(encodedKrbCred, asn1Spec=KRB_CRED())[0]\n        encKrbCredPart = decoder.decode(krbCred['enc-part']['cipher'], asn1Spec=EncKrbCredPart())[0]\n        krbCredInfo = encKrbCredPart['ticket-info'][0]\n\n        self.setDefaultHeader()\n\n        tmpPrincipal = types.Principal()\n        tmpPrincipal.from_asn1(krbCredInfo, 'prealm', 'pname')\n        self.principal = Principal()\n        self.principal.fromPrincipal(tmpPrincipal)\n\n        credential = Credential()\n        server = types.Principal()\n        server.from_asn1(krbCredInfo, 'srealm', 'sname')\n        tmpServer = Principal()\n        tmpServer.fromPrincipal(server)\n\n        credential['client'] = self.principal\n        credential['server'] = tmpServer\n        credential['is_skey'] = 0\n\n        credential['key'] = KeyBlockV4()\n        credential['key']['keytype'] = int(krbCredInfo['key']['keytype'])\n        credential['key']['keyvalue'] = krbCredInfo['key']['keyvalue'].asOctets()\n        credential['key']['keylen'] = len(credential['key']['keyvalue'])\n\n        credential['time'] = Times()\n\n        credential['time']['authtime'] = self.toTimeStamp(types.KerberosTime.from_asn1(krbCredInfo['starttime']))\n        credential['time']['starttime'] = self.toTimeStamp(types.KerberosTime.from_asn1(krbCredInfo['starttime']))\n        credential['time']['endtime'] = self.toTimeStamp(types.KerberosTime.from_asn1(krbCredInfo['endtime']))\n        # After KB4586793 for CVE-2020-17049 this timestamp may be omitted\n        if krbCredInfo['renew-till'].hasValue():\n            credential['time']['renew_till'] = self.toTimeStamp(types.KerberosTime.from_asn1(krbCredInfo['renew-till']))\n\n        flags = self.reverseFlags(krbCredInfo['flags'])\n        credential['tktflags'] = flags\n\n        credential['num_address'] = 0\n        credential.ticket = CountedOctetString()\n        credential.ticket['data'] = encoder.encode(\n            krbCred['tickets'][0].clone(tagSet=Ticket.tagSet, cloneValueFlag=True)\n        )\n        credential.ticket['length'] = len(credential.ticket['data'])\n        credential.secondTicket = CountedOctetString()\n        credential.secondTicket['data'] = b''\n        credential.secondTicket['length'] = 0\n\n        self.credentials.append(credential)\n\n    def toKRBCRED(self):\n        principal = self.principal\n        credential = self.credentials[0]\n\n        krbCredInfo = KrbCredInfo()\n\n        krbCredInfo['key'] = noValue\n        krbCredInfo['key']['keytype'] = credential['key']['keytype']\n        krbCredInfo['key']['keyvalue'] = credential['key']['keyvalue']\n\n        krbCredInfo['prealm'] = principal.realm.fields['data']\n\n        krbCredInfo['pname'] = noValue\n        krbCredInfo['pname']['name-type'] = principal.header['name_type']\n        seq_set_iter(krbCredInfo['pname'], 'name-string', (principal.components[0].fields['data'],))\n\n        krbCredInfo['flags'] = credential['tktflags']\n\n        krbCredInfo['starttime'] = KerberosTime.to_asn1(datetime.utcfromtimestamp(credential['time']['starttime']))\n        krbCredInfo['endtime'] = KerberosTime.to_asn1(datetime.utcfromtimestamp(credential['time']['endtime']))\n        krbCredInfo['renew-till'] = KerberosTime.to_asn1(datetime.utcfromtimestamp(credential['time']['renew_till']))\n\n        krbCredInfo['srealm'] = credential['server'].realm.fields['data']\n\n        krbCredInfo['sname'] = noValue\n        krbCredInfo['sname']['name-type'] = credential['server'].header['name_type']\n        tmp_service_class = credential['server'].components[0].fields['data']\n        tmp_service_hostname = credential['server'].components[1].fields['data']\n        seq_set_iter(krbCredInfo['sname'], 'name-string', (tmp_service_class, tmp_service_hostname))\n\n        encKrbCredPart = EncKrbCredPart()\n        seq_set_iter(encKrbCredPart, 'ticket-info', (krbCredInfo,))\n\n        krbCred = KRB_CRED()\n        krbCred['pvno'] = 5\n        krbCred['msg-type'] = 22\n\n        krbCred['enc-part'] = noValue\n        krbCred['enc-part']['etype'] = 0\n        krbCred['enc-part']['cipher'] = encoder.encode(encKrbCredPart)\n\n        ticket = decoder.decode(credential.ticket['data'], asn1Spec=Ticket())[0]\n        seq_set_iter(krbCred, 'tickets', (ticket,))\n\n        encodedKrbCred = encoder.encode(krbCred)\n\n        return encodedKrbCred\n\n    def setDefaultHeader(self):\n        self.headers = []\n        header = Header()\n        header['tag'] = 1\n        header['taglen'] = 8\n        header['tagdata'] = b'\\xff\\xff\\xff\\xff\\x00\\x00\\x00\\x00'\n        self.headers.append(header)",
  "def prettyPrint(self, indent=''):\n        return \"%s%s\" % (indent, hexlify(self['data']))",
  "def prettyPrint(self):\n        return \"Key: (0x%x)%s\" % (self['keytype'], hexlify(self['keyvalue']))",
  "def prettyPrint(self):\n        return \"Key: (0x%x)%s\" % (self['keytype'], hexlify(self['keyvalue']))",
  "def prettyPrint(self, indent = ''):\n        print((\"%sAuth : %s\" % (indent, datetime.fromtimestamp(self['authtime']).isoformat())))\n        print((\"%sStart: %s\" % (indent, datetime.fromtimestamp(self['starttime']).isoformat())))\n        print((\"%sEnd  : %s\" % (indent, datetime.fromtimestamp(self['endtime']).isoformat())))\n        print((\"%sRenew: %s\" % (indent, datetime.fromtimestamp(self['renew_till']).isoformat())))",
  "class PrincipalHeader(Structure):\n        structure = (\n            ('name_type','!L=0'),\n            ('num_components','!L=0'),\n        )",
  "def __init__(self, data=None):\n        self.components = []\n        self.realm = None\n        if data is not None:\n            self.header = self.PrincipalHeader(data)\n            data = data[len(self.header):]\n            self.realm = CountedOctetString(data)\n            data = data[len(self.realm):]\n            self.components = []\n            for component in range(self.header['num_components']):\n                comp = CountedOctetString(data)\n                data = data[len(comp):]\n                self.components.append(comp)\n        else:\n            self.header = self.PrincipalHeader()",
  "def __len__(self):\n        totalLen = len(self.header) + len(self.realm)\n        for i in self.components:\n            totalLen += len(i)\n        return totalLen",
  "def getData(self):\n        data = self.header.getData() + self.realm.getData()\n        for component in self.components:\n            data += component.getData()\n        return data",
  "def __str__(self):\n        return self.getData()",
  "def prettyPrint(self):\n        principal = b''\n        for component in self.components:\n            if isinstance(component['data'], bytes) is not True:\n                component = b(component['data'])\n            else:\n                component = component['data']\n            principal += component + b'/'\n\n        principal = principal[:-1]\n        if isinstance(self.realm['data'], bytes):\n            realm = self.realm['data']\n        else:\n            realm = b(self.realm['data'])\n        principal += b'@' + realm\n        return principal",
  "def fromPrincipal(self, principal):\n        self.header['name_type'] = principal.type\n        self.header['num_components'] = len(principal.components)\n        octetString = CountedOctetString()\n        octetString['length'] = len(principal.realm)\n        octetString['data'] = principal.realm\n        self.realm = octetString\n        self.components = []\n        for c in principal.components:\n            octetString = CountedOctetString()\n            octetString['length'] = len(c)\n            octetString['data'] = c\n            self.components.append(octetString)",
  "def toPrincipal(self):\n        return types.Principal(self.prettyPrint(), type=self.header['name_type'])",
  "class CredentialHeaderV3(Structure):\n        structure = (\n            ('client',':', Principal),\n            ('server',':', Principal),\n            ('key',':', KeyBlockV3),\n            ('time',':', Times),\n            ('is_skey','B=0'),\n            ('tktflags','!L=0'),\n            ('num_address','!L=0'),\n        )",
  "class CredentialHeaderV4(Structure):\n        structure = (\n            ('client',':', Principal),\n            ('server',':', Principal),\n            ('key',':', KeyBlockV4),\n            ('time',':', Times),\n            ('is_skey','B=0'),\n            ('tktflags','!L=0'),\n            ('num_address','!L=0'),\n        )",
  "def __init__(self, data=None, ccache_version=None):\n        self.addresses = ()\n        self.authData = ()\n        self.header = None\n        self.ticket = None\n        self.secondTicket = None\n\n        if data is not None:\n            if ccache_version == 3:\n                self.header = self.CredentialHeaderV3(data)\n            else:\n                self.header = self.CredentialHeaderV4(data)\n\n            data = data[len(self.header):]\n            self.addresses = []\n            for address in range(self.header['num_address']):\n                ad = Address(data)\n                data = data[len(ad):]\n                self.addresses.append(ad)\n            num_authdata = unpack('!L', data[:4])[0]\n            data = data[calcsize('!L'):]\n            for authdata in range(num_authdata):\n                ad = AuthData(data)\n                data = data[len(ad):]\n                self.authData.append(ad)\n            self.ticket = CountedOctetString(data)\n            data = data[len(self.ticket):]\n            self.secondTicket = CountedOctetString(data)\n            data = data[len( self.secondTicket):]\n        else:\n            self.header = self.CredentialHeaderV4()",
  "def __getitem__(self, key):\n        return self.header[key]",
  "def __setitem__(self, item, value):\n        self.header[item] = value",
  "def getServerPrincipal(self):\n        return self.header['server'].prettyPrint()",
  "def __len__(self):\n        totalLen = len(self.header)\n        for i in self.addresses:\n            totalLen += len(i)\n        totalLen += calcsize('!L')\n        for i in self.authData:\n            totalLen += len(i)\n        totalLen += len(self.ticket)\n        totalLen += len(self.secondTicket)\n        return totalLen",
  "def dump(self):\n        self.header.dump()",
  "def getData(self):\n        data = self.header.getData()\n        for i in self.addresses:\n            data += i.getData()\n        data += pack('!L', len(self.authData))\n        for i in self.authData:\n            data += i.getData()\n        data += self.ticket.getData()\n        data += self.secondTicket.getData()\n        return data",
  "def __str__(self):\n        return self.getData()",
  "def prettyPrint(self, indent=''):\n        print((\"%sClient: %s\" % (indent, self.header['client'].prettyPrint())))\n        print((\"%sServer: %s\" % (indent, self.header['server'].prettyPrint())))\n        print((\"%s%s\" % (indent, self.header['key'].prettyPrint())))\n        print((\"%sTimes: \" % indent))\n        self.header['time'].prettyPrint('\\t\\t')\n        print((\"%sSubKey: %s\" % (indent, self.header['is_skey'])))\n        print((\"%sFlags: 0x%x\" % (indent, self.header['tktflags'])))\n        print((\"%sAddresses: %d\" % (indent, self.header['num_address'])))\n        for address in self.addresses:\n            address.prettyPrint('\\t\\t')\n        print((\"%sAuth Data: %d\" % (indent, len(self.authData))))\n        for ad in self.authData:\n            ad.prettyPrint('\\t\\t')\n        print((\"%sTicket: %s\" % (indent, self.ticket.prettyPrint())))\n        print((\"%sSecond Ticket: %s\" % (indent, self.secondTicket.prettyPrint())))",
  "def toTGT(self):\n        tgt_rep = AS_REP()\n        tgt_rep['pvno'] = 5\n        tgt_rep['msg-type'] = int(constants.ApplicationTagNumbers.AS_REP.value)\n        tgt_rep['crealm'] = self['server'].realm['data']\n\n        # Fake EncryptedData\n        tgt_rep['enc-part'] = noValue\n        tgt_rep['enc-part']['etype'] = 1\n        tgt_rep['enc-part']['cipher'] = ''\n        seq_set(tgt_rep, 'cname', self['client'].toPrincipal().components_to_asn1)\n        ticket = types.Ticket()\n        ticket.from_asn1(self.ticket['data'])\n        seq_set(tgt_rep,'ticket', ticket.to_asn1)\n\n        cipher = crypto._enctype_table[self['key']['keytype']]()\n\n        tgt = dict()\n        tgt['KDC_REP'] = encoder.encode(tgt_rep)\n        tgt['cipher'] = cipher\n        tgt['sessionKey'] = crypto.Key(cipher.enctype, self['key']['keyvalue'])\n        return tgt",
  "def toTGS(self, newSPN=None):\n        tgs_rep = TGS_REP()\n        tgs_rep['pvno'] = 5\n        tgs_rep['msg-type'] = int(constants.ApplicationTagNumbers.TGS_REP.value)\n        tgs_rep['crealm'] = self['server'].realm['data']\n\n        # Fake EncryptedData\n        tgs_rep['enc-part'] = noValue\n        tgs_rep['enc-part']['etype'] = 1\n        tgs_rep['enc-part']['cipher'] = ''\n        seq_set(tgs_rep, 'cname', self['client'].toPrincipal().components_to_asn1)\n        ticket = types.Ticket()\n        ticket.from_asn1(self.ticket['data'])\n        if newSPN is not None:\n            if newSPN.upper() != str(ticket.service_principal).upper():\n                LOG.debug('Changing sname from %s to %s and hoping for the best' % (ticket.service_principal, newSPN) )\n                ticket.service_principal = types.Principal(newSPN, type=int(ticket.service_principal.type))\n        seq_set(tgs_rep,'ticket', ticket.to_asn1)\n\n        cipher = crypto._enctype_table[self['key']['keytype']]()\n\n        tgs = dict()\n        tgs['KDC_REP'] = encoder.encode(tgs_rep)\n        tgs['cipher'] = cipher\n        tgs['sessionKey'] = crypto.Key(cipher.enctype, self['key']['keyvalue'])\n        return tgs",
  "class MiniHeader(Structure):\n        structure = (\n            ('file_format_version','!H=0x0504'),\n            ('headerlen','!H=12'),\n        )",
  "def __init__(self, data = None):\n        self.headers = None\n        self.principal = None\n        self.credentials = []\n        self.miniHeader = None\n\n        if data is not None:\n            if PY2:\n                ccache_version = unpack('>B', data[1])[0]\n            else:\n                ccache_version = data[1]\n\n            # Versions 1 and 2 are not implemented yet\n            if ccache_version == 1 or ccache_version == 2:\n                raise NotImplementedError('Not Implemented!')\n\n            # Only Version 4 contains a header\n            if ccache_version == 4:\n                miniHeader = self.MiniHeader(data)\n                data = data[len(miniHeader.getData()):]\n\n                headerLen = miniHeader['headerlen']\n\n                self.headers = []\n                while headerLen > 0:\n                    header = Header(data)\n                    self.headers.append(header)\n                    headerLen -= len(header)\n                    data = data[len(header):]\n            else:\n                # Skip over the version bytes\n                data = data[2:]\n\n            # Now the primary_principal\n            self.principal = Principal(data)\n\n            data = data[len(self.principal):]\n\n            # Now let's parse the credentials\n            self.credentials = []\n            while len(data) > 0:\n                cred = Credential(data, ccache_version)\n                if cred['server'].prettyPrint().find(b'krb5_ccache_conf_data') < 0:\n                    self.credentials.append(cred)\n                data = data[len(cred.getData()):]",
  "def getData(self):\n        data = self.MiniHeader().getData()\n        for header in self.headers:\n            data += header.getData()\n        data += self.principal.getData()\n        for credential in self.credentials:\n            data += credential.getData()\n        return data",
  "def getCredential(self, server, anySPN=True):\n        for c in self.credentials:\n            if c['server'].prettyPrint().upper() == b(server.upper()) or c['server'].prettyPrint().upper().split(b'@')[0] == b(server.upper())\\\n                    or c['server'].prettyPrint().upper().split(b'@')[0] == b(server.upper().split('@')[0]):\n                LOG.debug('Returning cached credential for %s' % c['server'].prettyPrint().upper().decode('utf-8'))\n                return c\n        LOG.debug('SPN %s not found in cache' % server.upper())\n        if anySPN is True:\n            LOG.debug('AnySPN is True, looking for another suitable SPN')\n            for c in self.credentials:\n                # Let's search for any TGT/TGS that matches the server w/o the SPN's service type/port, returns\n                # the first one\n                if c['server'].prettyPrint().find(b'/') >=0:\n                    # Let's take the port out for comparison\n                    cachedSPN = (c['server'].prettyPrint().upper().split(b'/')[1].split(b'@')[0].split(b':')[0] + b'@' + c['server'].prettyPrint().upper().split(b'/')[1].split(b'@')[1])\n                    searchSPN = '%s@%s' % (server.upper().split('/')[1].split('@')[0].split(':')[0],\n                                               server.upper().split('/')[1].split('@')[1])\n                    if cachedSPN == b(searchSPN):\n                        LOG.debug('Returning cached credential for %s' % c['server'].prettyPrint().upper().decode('utf-8'))\n                        return c\n\n        return None",
  "def toTimeStamp(self, dt, epoch=datetime(1970,1,1)):\n        td = dt - epoch\n        # return td.total_seconds()\n        return int((td.microseconds + (td.seconds + td.days * 24 * 3600) * 10**6) // 1e6)",
  "def reverseFlags(self, flags):\n        result = 0\n        if isinstance(flags, str):\n            flags = flags[1:-2]\n        for i,j in enumerate(reversed(flags)):\n            if j != 0:\n                result += j << i\n        return result",
  "def fromTGT(self, tgt, oldSessionKey, sessionKey):\n        self.headers = []\n        header = Header()\n        header['tag'] = 1\n        header['taglen'] = 8\n        header['tagdata'] = b'\\xff\\xff\\xff\\xff\\x00\\x00\\x00\\x00'\n        self.headers.append(header)\n\n        decodedTGT = decoder.decode(tgt, asn1Spec = AS_REP())[0]\n\n        tmpPrincipal = types.Principal()\n        tmpPrincipal.from_asn1(decodedTGT, 'crealm', 'cname')\n        self.principal = Principal()\n        self.principal.fromPrincipal(tmpPrincipal)\n\n        # Now let's add the credential\n        cipherText = decodedTGT['enc-part']['cipher']\n\n        cipher = crypto._enctype_table[decodedTGT['enc-part']['etype']]\n\n        # Key Usage 3\n        # AS-REP encrypted part (includes TGS session key or\n        # application session key), encrypted with the client key\n        # (Section 5.4.2)\n        plainText = cipher.decrypt(oldSessionKey, 3, cipherText)\n\n        encASRepPart = decoder.decode(plainText, asn1Spec = EncASRepPart())[0]\n        credential = Credential()\n        server = types.Principal()\n        server.from_asn1(encASRepPart, 'srealm', 'sname')\n        tmpServer = Principal()\n        tmpServer.fromPrincipal(server)\n\n        credential['client'] = self.principal\n        credential['server'] = tmpServer\n        credential['is_skey'] = 0\n\n        credential['key'] = KeyBlockV4()\n        credential['key']['keytype'] = int(encASRepPart['key']['keytype'])\n        credential['key']['keyvalue'] = encASRepPart['key']['keyvalue'].asOctets()\n        credential['key']['keylen'] = len(credential['key']['keyvalue'])\n\n        credential['time'] = Times()\n        credential['time']['authtime'] = self.toTimeStamp(types.KerberosTime.from_asn1(encASRepPart['authtime']))\n        credential['time']['starttime'] = self.toTimeStamp(types.KerberosTime.from_asn1(encASRepPart['starttime']))\n        credential['time']['endtime'] = self.toTimeStamp(types.KerberosTime.from_asn1(encASRepPart['endtime']))\n        # After KB4586793 for CVE-2020-17049 this timestamp may be omitted\n        if encASRepPart['renew-till'].hasValue():\n            credential['time']['renew_till'] = self.toTimeStamp(types.KerberosTime.from_asn1(encASRepPart['renew-till']))\n        flags = self.reverseFlags(encASRepPart['flags'])\n        credential['tktflags'] = flags\n\n        credential['num_address'] = 0\n        credential.ticket = CountedOctetString()\n        credential.ticket['data'] = encoder.encode(decodedTGT['ticket'].clone(tagSet=Ticket.tagSet, cloneValueFlag=True))\n        credential.ticket['length'] = len(credential.ticket['data'])\n        credential.secondTicket = CountedOctetString()\n        credential.secondTicket['data'] = b''\n        credential.secondTicket['length'] = 0\n        self.credentials.append(credential)",
  "def fromTGS(self, tgs, oldSessionKey, sessionKey):\n        self.headers = []\n        header = Header()\n        header['tag'] = 1\n        header['taglen'] = 8\n        header['tagdata'] = b'\\xff\\xff\\xff\\xff\\x00\\x00\\x00\\x00'\n        self.headers.append(header)\n\n        decodedTGS = decoder.decode(tgs, asn1Spec = TGS_REP())[0]\n\n        tmpPrincipal = types.Principal()\n        tmpPrincipal.from_asn1(decodedTGS, 'crealm', 'cname')\n        self.principal = Principal()\n        self.principal.fromPrincipal(tmpPrincipal)\n\n        # Now let's add the credential\n        cipherText = decodedTGS['enc-part']['cipher']\n\n        cipher = crypto._enctype_table[decodedTGS['enc-part']['etype']]\n\n        # Key Usage 8\n        # TGS-REP encrypted part (includes application session\n        # key), encrypted with the TGS session key (Section 5.4.2)\n        plainText = cipher.decrypt(oldSessionKey, 8, cipherText)\n\n        encTGSRepPart = decoder.decode(plainText, asn1Spec = EncTGSRepPart())[0]\n\n        credential = Credential()\n        server = types.Principal()\n        server.from_asn1(encTGSRepPart, 'srealm', 'sname')\n        tmpServer = Principal()\n        tmpServer.fromPrincipal(server)\n\n        credential['client'] = self.principal\n        credential['server'] = tmpServer\n        credential['is_skey'] = 0\n\n        credential['key'] = KeyBlockV4()\n        credential['key']['keytype'] = int(encTGSRepPart['key']['keytype'])\n        credential['key']['keyvalue'] = encTGSRepPart['key']['keyvalue'].asOctets()\n        credential['key']['keylen'] = len(credential['key']['keyvalue'])\n\n        credential['time'] = Times()\n        credential['time']['authtime'] = self.toTimeStamp(types.KerberosTime.from_asn1(encTGSRepPart['authtime']))\n        credential['time']['starttime'] = self.toTimeStamp(types.KerberosTime.from_asn1(encTGSRepPart['starttime']))\n        credential['time']['endtime'] = self.toTimeStamp(types.KerberosTime.from_asn1(encTGSRepPart['endtime']))\n        # After KB4586793 for CVE-2020-17049 this timestamp may be omitted\n        if encTGSRepPart['renew-till'].hasValue():\n            credential['time']['renew_till'] = self.toTimeStamp(types.KerberosTime.from_asn1(encTGSRepPart['renew-till']))\n\n        flags = self.reverseFlags(encTGSRepPart['flags'])\n        credential['tktflags'] = flags\n\n        credential['num_address'] = 0\n\n        credential.ticket = CountedOctetString()\n        credential.ticket['data'] = encoder.encode(decodedTGS['ticket'].clone(tagSet=Ticket.tagSet, cloneValueFlag=True))\n        credential.ticket['length'] = len(credential.ticket['data'])\n        credential.secondTicket = CountedOctetString()\n        credential.secondTicket['data'] = b''\n        credential.secondTicket['length'] = 0\n        self.credentials.append(credential)",
  "def loadFile(cls, fileName):\n        if fileName is None:\n            LOG.critical('CCache file is not found. Skipping...')\n            LOG.debug('The specified path is not correct or the KRB5CCNAME environment variable is not defined')\n            return None\n\n        try:\n            f = open(fileName, 'rb')\n            data = f.read()\n            f.close()\n            return cls(data)\n        except FileNotFoundError as e:\n            raise e",
  "def saveFile(self, fileName):\n        f = open(fileName, 'wb+')\n        f.write(self.getData())\n        f.close()",
  "def parseFile(cls, domain='', username='', target=''):\n        \"\"\"\n        parses the CCache file specified in the KRB5CCNAME environment variable\n\n        :param domain: an optional domain name of a user\n        :param username: an optional username of a user\n        :param target: an optional SPN of a target system\n\n        :return: domain, username, TGT, TGS\n        \"\"\"\n\n        ccache = cls.loadFile(os.getenv('KRB5CCNAME'))\n        if ccache is None:\n            return domain, username, None, None\n\n        LOG.debug('Using Kerberos Cache: %s' % os.getenv('KRB5CCNAME'))\n\n        if domain == '':\n            domain = ccache.principal.realm['data'].decode('utf-8')\n            LOG.debug('Domain retrieved from CCache: %s' % domain)\n\n        creds = None\n        if target != '':\n            principal = '%s@%s' % (target.upper(), domain.upper())\n            creds = ccache.getCredential(principal)\n\n        TGT = None\n        TGS = None\n        if creds is None:\n            principal = 'krbtgt/%s@%s' % (domain.upper(), domain.upper())\n            creds = ccache.getCredential(principal)\n            if creds is not None:\n                LOG.debug('Using TGT from cache')\n                TGT = creds.toTGT()\n            else:\n                LOG.debug('No valid credentials found in cache')\n        else:\n            LOG.debug('Using TGS from cache')\n            TGS = creds.toTGS(principal)\n\n        if username == '' and creds is not None:\n            username = creds['client'].prettyPrint().split(b'@')[0].decode('utf-8')\n            LOG.debug('Username retrieved from CCache: %s' % username)\n        elif username == '' and len(ccache.principal.components) > 0:\n            username = ccache.principal.components[0]['data'].decode('utf-8')\n            LOG.debug('Username retrieved from CCache: %s' % username)\n\n        return domain, username, TGT, TGS",
  "def prettyPrint(self):\n        print((\"Primary Principal: %s\" % self.principal.prettyPrint()))\n        print(\"Credentials: \")\n        for i, credential in enumerate(self.credentials):\n            print((\"[%d]\" % i))\n            credential.prettyPrint('\\t')",
  "def loadKirbiFile(cls, fileName):\n        f = open(fileName, 'rb')\n        data = f.read()\n        f.close()\n        ccache = cls()\n        ccache.fromKRBCRED(data)\n        return ccache",
  "def saveKirbiFile(self, fileName):\n        f = open(fileName, 'wb+')\n        f.write(self.toKRBCRED())\n        f.close()",
  "def fromKRBCRED(self, encodedKrbCred):\n\n        krbCred = decoder.decode(encodedKrbCred, asn1Spec=KRB_CRED())[0]\n        encKrbCredPart = decoder.decode(krbCred['enc-part']['cipher'], asn1Spec=EncKrbCredPart())[0]\n        krbCredInfo = encKrbCredPart['ticket-info'][0]\n\n        self.setDefaultHeader()\n\n        tmpPrincipal = types.Principal()\n        tmpPrincipal.from_asn1(krbCredInfo, 'prealm', 'pname')\n        self.principal = Principal()\n        self.principal.fromPrincipal(tmpPrincipal)\n\n        credential = Credential()\n        server = types.Principal()\n        server.from_asn1(krbCredInfo, 'srealm', 'sname')\n        tmpServer = Principal()\n        tmpServer.fromPrincipal(server)\n\n        credential['client'] = self.principal\n        credential['server'] = tmpServer\n        credential['is_skey'] = 0\n\n        credential['key'] = KeyBlockV4()\n        credential['key']['keytype'] = int(krbCredInfo['key']['keytype'])\n        credential['key']['keyvalue'] = krbCredInfo['key']['keyvalue'].asOctets()\n        credential['key']['keylen'] = len(credential['key']['keyvalue'])\n\n        credential['time'] = Times()\n\n        credential['time']['authtime'] = self.toTimeStamp(types.KerberosTime.from_asn1(krbCredInfo['starttime']))\n        credential['time']['starttime'] = self.toTimeStamp(types.KerberosTime.from_asn1(krbCredInfo['starttime']))\n        credential['time']['endtime'] = self.toTimeStamp(types.KerberosTime.from_asn1(krbCredInfo['endtime']))\n        # After KB4586793 for CVE-2020-17049 this timestamp may be omitted\n        if krbCredInfo['renew-till'].hasValue():\n            credential['time']['renew_till'] = self.toTimeStamp(types.KerberosTime.from_asn1(krbCredInfo['renew-till']))\n\n        flags = self.reverseFlags(krbCredInfo['flags'])\n        credential['tktflags'] = flags\n\n        credential['num_address'] = 0\n        credential.ticket = CountedOctetString()\n        credential.ticket['data'] = encoder.encode(\n            krbCred['tickets'][0].clone(tagSet=Ticket.tagSet, cloneValueFlag=True)\n        )\n        credential.ticket['length'] = len(credential.ticket['data'])\n        credential.secondTicket = CountedOctetString()\n        credential.secondTicket['data'] = b''\n        credential.secondTicket['length'] = 0\n\n        self.credentials.append(credential)",
  "def toKRBCRED(self):\n        principal = self.principal\n        credential = self.credentials[0]\n\n        krbCredInfo = KrbCredInfo()\n\n        krbCredInfo['key'] = noValue\n        krbCredInfo['key']['keytype'] = credential['key']['keytype']\n        krbCredInfo['key']['keyvalue'] = credential['key']['keyvalue']\n\n        krbCredInfo['prealm'] = principal.realm.fields['data']\n\n        krbCredInfo['pname'] = noValue\n        krbCredInfo['pname']['name-type'] = principal.header['name_type']\n        seq_set_iter(krbCredInfo['pname'], 'name-string', (principal.components[0].fields['data'],))\n\n        krbCredInfo['flags'] = credential['tktflags']\n\n        krbCredInfo['starttime'] = KerberosTime.to_asn1(datetime.utcfromtimestamp(credential['time']['starttime']))\n        krbCredInfo['endtime'] = KerberosTime.to_asn1(datetime.utcfromtimestamp(credential['time']['endtime']))\n        krbCredInfo['renew-till'] = KerberosTime.to_asn1(datetime.utcfromtimestamp(credential['time']['renew_till']))\n\n        krbCredInfo['srealm'] = credential['server'].realm.fields['data']\n\n        krbCredInfo['sname'] = noValue\n        krbCredInfo['sname']['name-type'] = credential['server'].header['name_type']\n        tmp_service_class = credential['server'].components[0].fields['data']\n        tmp_service_hostname = credential['server'].components[1].fields['data']\n        seq_set_iter(krbCredInfo['sname'], 'name-string', (tmp_service_class, tmp_service_hostname))\n\n        encKrbCredPart = EncKrbCredPart()\n        seq_set_iter(encKrbCredPart, 'ticket-info', (krbCredInfo,))\n\n        krbCred = KRB_CRED()\n        krbCred['pvno'] = 5\n        krbCred['msg-type'] = 22\n\n        krbCred['enc-part'] = noValue\n        krbCred['enc-part']['etype'] = 0\n        krbCred['enc-part']['cipher'] = encoder.encode(encKrbCredPart)\n\n        ticket = decoder.decode(credential.ticket['data'], asn1Spec=Ticket())[0]\n        seq_set_iter(krbCred, 'tickets', (ticket,))\n\n        encodedKrbCred = encoder.encode(krbCred)\n\n        return encodedKrbCred",
  "def setDefaultHeader(self):\n        self.headers = []\n        header = Header()\n        header['tag'] = 1\n        header['taglen'] = 8\n        header['tagdata'] = b'\\xff\\xff\\xff\\xff\\x00\\x00\\x00\\x00'\n        self.headers.append(header)",
  "class Enctype(Enum):\n    DES_CRC = 1\n    DES_MD4 = 2\n    DES_MD5 = 3\n    DES3 = 16\n    AES128 = 17\n    AES256 = 18\n    RC4 = 23",
  "class CountedOctetString(Structure):\n    \"\"\"\n    Note: This is very similar to the CountedOctetString structure in ccache, except:\n      * `length` is uint16 instead of uint32\n    \"\"\"\n    structure = (\n        ('length','!H=0'),\n        ('_data','_-data','self[\"length\"]'),\n        ('data',':'),\n    )\n\n    def prettyPrint(self, indent=''):\n        return \"%s%s\" % (indent, hexlify(self['data']))",
  "class KeyBlock(Structure):\n    structure = (\n        ('keytype','!H=0'),\n        ('keyvalue',':', CountedOctetString),\n    )\n\n    def prettyKeytype(self):\n        try:\n            return Enctype(self['keytype']).name\n        except:\n            return \"UNKNOWN:0x%x\" % (self['keytype'])\n\n    def hexlifiedValue(self):\n        return hexlify(self['keyvalue']['data'])\n\n    def prettyPrint(self):\n        return \"(%s)%s\" % (self.prettyKeytype(), self.hexlifiedValue())",
  "class KeytabPrincipal:\n    \"\"\"\n    Note: This is very similar to the principal structure in ccache, except:\n      * `num_components` is just uint16\n      * using other size type for CountedOctetString\n      * `name_type` field follows the other fields behind.\n    \"\"\"\n    class PrincipalHeader1(Structure):\n        structure = (\n            ('num_components', '!H=0'),\n        )\n\n    class PrincipalHeader2(Structure):\n        structure = (\n            ('name_type', '!L=0'),\n        )\n\n    def __init__(self, data=None):\n        self.components = []\n        self.realm = None\n        if data is not None:\n            self.header1 = self.PrincipalHeader1(data)\n            data = data[len(self.header1):]\n            self.realm = CountedOctetString(data)\n            data = data[len(self.realm):]\n            self.components = []\n            for component in range(self.header1['num_components']):\n                comp = CountedOctetString(data)\n                data = data[len(comp):]\n                self.components.append(comp)\n            self.header2 = self.PrincipalHeader2(data)\n        else:\n            self.header1 = self.PrincipalHeader1()\n            self.header2 = self.PrincipalHeader2()\n\n    def __len__(self):\n        totalLen = len(self.header1) + len(self.header2) + len(self.realm)\n        for i in self.components:\n            totalLen += len(i)\n        return totalLen\n\n    def getData(self):\n        data = self.header1.getData() + self.realm.getData()\n        for component in self.components:\n            data += component.getData()\n        data += self.header2.getData()\n        return data\n\n    def __str__(self):\n        return self.getData()\n\n    def prettyPrint(self):\n        principal = b''\n        for component in self.components:\n            if isinstance(component['data'], bytes) is not True:\n                component = b(component['data'])\n            else:\n                component = component['data']\n            principal += component + b'/'\n\n        principal = principal[:-1]\n        if isinstance(self.realm['data'], bytes):\n            realm = self.realm['data']\n        else:\n            realm = b(self.realm['data'])\n        principal += b'@' + realm\n        return principal",
  "class KeytabEntry:\n    class KeytabEntryMainpart(Structure):\n        \"\"\"\n      keytab_entry {\n          int32_t size;     # wtf, signed size. what could possibly ...\n          uint16_t num_components;    /* sub 1 if version 0x501 */  |\\\n          counted_octet_string realm;                               | \\\\  Keytab\n          counted_octet_string components[num_components];          | /  Princial\n          uint32_t name_type;   /* not present if version 0x501 */  |/\n          uint32_t timestamp;\n          uint8_t vno8;\n          keyblock key;\n          uint32_t vno; /* only present if >= 4 bytes left in entry */\n      };\n        \"\"\"\n        structure = (\n            ('size', '!l=0'),\n            ('principal', ':', KeytabPrincipal),\n            ('timestamp', '!L=0'),\n            ('vno8', '!B=0'),\n            ('keyblock', ':', KeyBlock),\n        )\n\n    def __init__(self, data=None):\n        self.rest = b''\n        if data:\n            self.main_part = self.KeytabEntryMainpart(data)\n            self.size = abs(self.main_part['size']) + 4  # size field itself not included\n            self.kvno = self.main_part['vno8']\n            self.deleted = self.main_part['size'] < 0\n            len_main = len(self.main_part)\n            if self.size > len_main:\n                self.rest = data[len_main:self.size]\n                if len(self.rest) >= 4 and \\\n                        self.rest[:4] != [0, 0, 0, 0]:  # if \"field\" is present but all 0, it seems to gets ignored\n                    self.kvno = unpack('!L', self.rest[:4])[0]\n        else:\n            self.main_part = self.KeytabEntryMainpart()\n            self.deleted = True\n            self.size = len(self.main_part)\n            self.kvno = 0\n\n    def __len__(self):\n        return self.size\n\n    def getData(self):\n        data = self.main_part.getData()\n        if self.rest:\n            data += self.rest\n        return data\n\n    def prettyPrint(self, indent=''):\n        if self.deleted:\n            return \"%s[DELETED]\" % indent\n        else:\n            text = \"%sPrincipal: %s\\n\" %(indent, self.main_part['principal'].prettyPrint())\n            text += \"%sTimestamp: %s\" % (indent, datetime.fromtimestamp(self.main_part['timestamp']).isoformat())\n            text += \"\\tKVNO: %i\\n\" % self.kvno\n            text += \"%sKey: %s\" % (indent, self.main_part['keyblock'].prettyPrint())\n            #if self.rest:\n            #    text += \"\\n%sRest: %s\" % (indent, self.rest)\n            return text",
  "class Keytab:\n\n    GetkeyEnctypePreference = (Enctype.AES256.value,\n                                 Enctype.AES128.value,\n                                 Enctype.RC4.value)\n\n    class MiniHeader(Structure):\n        structure = (\n            ('file_format_version', '!H=0x0502'),\n        )\n\n    def __init__(self, data=None):\n        self.miniHeader = None\n        self.entries = []\n        if data is not None:\n            self.miniHeader = self.MiniHeader(data)\n            data = data[len(self.miniHeader):]\n            while len(data):\n                entry = KeytabEntry(data)\n                self.entries.append(entry)\n                data = data[len(entry):]\n\n    def getData(self):\n        data = self.MiniHeader().getData()\n        for entry in self.entries:\n            data += entry.getData()\n        return data\n\n    def getKey(self, principal, specificEncType=None, ignoreRealm=True):\n        principal = b(principal.upper())\n        if ignoreRealm:\n            principal = principal.split(b'@')[0]\n        matching_keys = {}\n        for entry in self.entries:\n            entry_principal = entry.main_part['principal'].prettyPrint().upper()\n            if entry_principal == principal or (ignoreRealm and entry_principal.split(b'@')[0] == principal):\n                keytype = entry.main_part[\"keyblock\"][\"keytype\"]\n                if keytype == specificEncType:\n                    LOG.debug('Returning %s key for %s' % (entry.main_part['keyblock'].prettyKeytype(),\n                                                           entry.main_part['principal'].prettyPrint()))\n                    return entry.main_part[\"keyblock\"]\n                elif specificEncType is None:\n                    matching_keys[keytype] = entry\n\n        if specificEncType is None and matching_keys:\n            for preference in self.GetkeyEnctypePreference:\n                if preference in matching_keys:\n                    entry = matching_keys[preference]\n                    LOG.debug('Returning %s key for %s' % (entry.main_part['keyblock'].prettyKeytype(),\n                                                           entry.main_part['principal'].prettyPrint()))\n                    return entry.main_part[\"keyblock\"]\n\n        LOG.debug('Principal %s not found in keytab' % principal)\n        return None\n\n    @classmethod\n    def loadFile(cls, fileName):\n        f = open(fileName, 'rb')\n        data = f.read()\n        f.close()\n        return cls(data)\n\n    @classmethod\n    def loadKeysFromKeytab(cls, fileName, username, domain, options):\n        keytab = Keytab.loadFile(fileName)\n        keyblock = keytab.getKey(\"%s@%s\" % (username, domain))\n        if keyblock:\n            if keyblock[\"keytype\"] == Enctype.AES256.value or keyblock[\"keytype\"] == Enctype.AES128.value:\n                options.aesKey = keyblock.hexlifiedValue()\n            elif keyblock[\"keytype\"] == Enctype.RC4.value:\n                options.hashes= ':' + keyblock.hexlifiedValue().decode('ascii')\n        else:\n            LOG.warning(\"No matching key for SPN '%s' in given keytab found!\", username)\n\n\n    def saveFile(self, fileName):\n        f = open(fileName, 'wb+')\n        f.write(self.getData())\n        f.close()\n\n    def prettyPrint(self):\n        print(\"Keytab Entries:\")\n        for i, entry in enumerate(self.entries):\n            print((\"[%d]\" % i))\n            print(entry.prettyPrint('\\t'))",
  "def prettyPrint(self, indent=''):\n        return \"%s%s\" % (indent, hexlify(self['data']))",
  "def prettyKeytype(self):\n        try:\n            return Enctype(self['keytype']).name\n        except:\n            return \"UNKNOWN:0x%x\" % (self['keytype'])",
  "def hexlifiedValue(self):\n        return hexlify(self['keyvalue']['data'])",
  "def prettyPrint(self):\n        return \"(%s)%s\" % (self.prettyKeytype(), self.hexlifiedValue())",
  "class PrincipalHeader1(Structure):\n        structure = (\n            ('num_components', '!H=0'),\n        )",
  "class PrincipalHeader2(Structure):\n        structure = (\n            ('name_type', '!L=0'),\n        )",
  "def __init__(self, data=None):\n        self.components = []\n        self.realm = None\n        if data is not None:\n            self.header1 = self.PrincipalHeader1(data)\n            data = data[len(self.header1):]\n            self.realm = CountedOctetString(data)\n            data = data[len(self.realm):]\n            self.components = []\n            for component in range(self.header1['num_components']):\n                comp = CountedOctetString(data)\n                data = data[len(comp):]\n                self.components.append(comp)\n            self.header2 = self.PrincipalHeader2(data)\n        else:\n            self.header1 = self.PrincipalHeader1()\n            self.header2 = self.PrincipalHeader2()",
  "def __len__(self):\n        totalLen = len(self.header1) + len(self.header2) + len(self.realm)\n        for i in self.components:\n            totalLen += len(i)\n        return totalLen",
  "def getData(self):\n        data = self.header1.getData() + self.realm.getData()\n        for component in self.components:\n            data += component.getData()\n        data += self.header2.getData()\n        return data",
  "def __str__(self):\n        return self.getData()",
  "def prettyPrint(self):\n        principal = b''\n        for component in self.components:\n            if isinstance(component['data'], bytes) is not True:\n                component = b(component['data'])\n            else:\n                component = component['data']\n            principal += component + b'/'\n\n        principal = principal[:-1]\n        if isinstance(self.realm['data'], bytes):\n            realm = self.realm['data']\n        else:\n            realm = b(self.realm['data'])\n        principal += b'@' + realm\n        return principal",
  "class KeytabEntryMainpart(Structure):\n        \"\"\"\n      keytab_entry {\n          int32_t size;     # wtf, signed size. what could possibly ...\n          uint16_t num_components;    /* sub 1 if version 0x501 */  |\\\n          counted_octet_string realm;                               | \\\\  Keytab\n          counted_octet_string components[num_components];          | /  Princial\n          uint32_t name_type;   /* not present if version 0x501 */  |/\n          uint32_t timestamp;\n          uint8_t vno8;\n          keyblock key;\n          uint32_t vno; /* only present if >= 4 bytes left in entry */\n      };\n        \"\"\"\n        structure = (\n            ('size', '!l=0'),\n            ('principal', ':', KeytabPrincipal),\n            ('timestamp', '!L=0'),\n            ('vno8', '!B=0'),\n            ('keyblock', ':', KeyBlock),\n        )",
  "def __init__(self, data=None):\n        self.rest = b''\n        if data:\n            self.main_part = self.KeytabEntryMainpart(data)\n            self.size = abs(self.main_part['size']) + 4  # size field itself not included\n            self.kvno = self.main_part['vno8']\n            self.deleted = self.main_part['size'] < 0\n            len_main = len(self.main_part)\n            if self.size > len_main:\n                self.rest = data[len_main:self.size]\n                if len(self.rest) >= 4 and \\\n                        self.rest[:4] != [0, 0, 0, 0]:  # if \"field\" is present but all 0, it seems to gets ignored\n                    self.kvno = unpack('!L', self.rest[:4])[0]\n        else:\n            self.main_part = self.KeytabEntryMainpart()\n            self.deleted = True\n            self.size = len(self.main_part)\n            self.kvno = 0",
  "def __len__(self):\n        return self.size",
  "def getData(self):\n        data = self.main_part.getData()\n        if self.rest:\n            data += self.rest\n        return data",
  "def prettyPrint(self, indent=''):\n        if self.deleted:\n            return \"%s[DELETED]\" % indent\n        else:\n            text = \"%sPrincipal: %s\\n\" %(indent, self.main_part['principal'].prettyPrint())\n            text += \"%sTimestamp: %s\" % (indent, datetime.fromtimestamp(self.main_part['timestamp']).isoformat())\n            text += \"\\tKVNO: %i\\n\" % self.kvno\n            text += \"%sKey: %s\" % (indent, self.main_part['keyblock'].prettyPrint())\n            #if self.rest:\n            #    text += \"\\n%sRest: %s\" % (indent, self.rest)\n            return text",
  "class MiniHeader(Structure):\n        structure = (\n            ('file_format_version', '!H=0x0502'),\n        )",
  "def __init__(self, data=None):\n        self.miniHeader = None\n        self.entries = []\n        if data is not None:\n            self.miniHeader = self.MiniHeader(data)\n            data = data[len(self.miniHeader):]\n            while len(data):\n                entry = KeytabEntry(data)\n                self.entries.append(entry)\n                data = data[len(entry):]",
  "def getData(self):\n        data = self.MiniHeader().getData()\n        for entry in self.entries:\n            data += entry.getData()\n        return data",
  "def getKey(self, principal, specificEncType=None, ignoreRealm=True):\n        principal = b(principal.upper())\n        if ignoreRealm:\n            principal = principal.split(b'@')[0]\n        matching_keys = {}\n        for entry in self.entries:\n            entry_principal = entry.main_part['principal'].prettyPrint().upper()\n            if entry_principal == principal or (ignoreRealm and entry_principal.split(b'@')[0] == principal):\n                keytype = entry.main_part[\"keyblock\"][\"keytype\"]\n                if keytype == specificEncType:\n                    LOG.debug('Returning %s key for %s' % (entry.main_part['keyblock'].prettyKeytype(),\n                                                           entry.main_part['principal'].prettyPrint()))\n                    return entry.main_part[\"keyblock\"]\n                elif specificEncType is None:\n                    matching_keys[keytype] = entry\n\n        if specificEncType is None and matching_keys:\n            for preference in self.GetkeyEnctypePreference:\n                if preference in matching_keys:\n                    entry = matching_keys[preference]\n                    LOG.debug('Returning %s key for %s' % (entry.main_part['keyblock'].prettyKeytype(),\n                                                           entry.main_part['principal'].prettyPrint()))\n                    return entry.main_part[\"keyblock\"]\n\n        LOG.debug('Principal %s not found in keytab' % principal)\n        return None",
  "def loadFile(cls, fileName):\n        f = open(fileName, 'rb')\n        data = f.read()\n        f.close()\n        return cls(data)",
  "def loadKeysFromKeytab(cls, fileName, username, domain, options):\n        keytab = Keytab.loadFile(fileName)\n        keyblock = keytab.getKey(\"%s@%s\" % (username, domain))\n        if keyblock:\n            if keyblock[\"keytype\"] == Enctype.AES256.value or keyblock[\"keytype\"] == Enctype.AES128.value:\n                options.aesKey = keyblock.hexlifiedValue()\n            elif keyblock[\"keytype\"] == Enctype.RC4.value:\n                options.hashes= ':' + keyblock.hexlifiedValue().decode('ascii')\n        else:\n            LOG.warning(\"No matching key for SPN '%s' in given keytab found!\", username)",
  "def saveFile(self, fileName):\n        f = open(fileName, 'wb+')\n        f.write(self.getData())\n        f.close()",
  "def prettyPrint(self):\n        print(\"Keytab Entries:\")\n        for i, entry in enumerate(self.entries):\n            print((\"[%d]\" % i))\n            print(entry.prettyPrint('\\t'))",
  "def _application_tag(tag_value):\n    return univ.Sequence.tagSet.tagExplicitly(\n        tag.Tag(tag.tagClassApplication, tag.tagFormatConstructed,\n                int(tag_value)))",
  "def _vno_component(tag_value, name=\"pvno\"):\n    return _sequence_component(\n        name, tag_value, univ.Integer(),\n        subtypeSpec=constraint.ValueRangeConstraint(5, 5))",
  "def _msg_type_component(tag_value, values):\n    c = constraint.ConstraintsUnion(\n        *(constraint.SingleValueConstraint(int(v)) for v in values))\n    return _sequence_component('msg-type', tag_value, univ.Integer(),\n                               subtypeSpec=c)",
  "def _sequence_component(name, tag_value, type, **subkwargs):\n    return namedtype.NamedType(name, type.subtype(\n        explicitTag=tag.Tag(tag.tagClassContext, tag.tagFormatSimple,\n                            tag_value),\n        **subkwargs))",
  "def _sequence_optional_component(name, tag_value, type, **subkwargs):\n    return namedtype.OptionalNamedType(name, type.subtype(\n        explicitTag=tag.Tag(tag.tagClassContext, tag.tagFormatSimple,\n                            tag_value),\n        **subkwargs))",
  "def seq_set(seq, name, builder=None, *args, **kwargs):\n    component = seq.setComponentByName(name).getComponentByName(name)\n    if builder is not None:\n        seq.setComponentByName(name, builder(component, *args, **kwargs))\n    else:\n        seq.setComponentByName(name)\n    return seq.getComponentByName(name)",
  "def seq_set_dict(seq, name, pairs, *args, **kwargs):\n    component = seq.setComponentByName(name).getComponentByName(name)\n    for k, v in pairs.items():\n        component.setComponentByName(k, v)",
  "def seq_set_iter(seq, name, iterable):\n    component = seq.setComponentByName(name).getComponentByName(name)\n    for pos, v in enumerate(iterable):\n        component.setComponentByPosition(pos, v)",
  "def seq_set_flags(seq, name, flags):\n    seq_set(seq, name, flags.to_asn1)",
  "def seq_append(seq, name, pairs):\n    component = seq.getComponentByName(name)\n    if component is None:\n        component = seq.setComponentByName(name).getComponentByName(name)\n    index = len(component)\n    element = component.setComponentByPosition(index\n                                               ).getComponentByPosition(index)\n    for k, v in pairs.items():\n        element.setComponentByName(k, v)",
  "class Int32(univ.Integer):\n    subtypeSpec = univ.Integer.subtypeSpec + constraint.ValueRangeConstraint(\n        -2147483648, 2147483647)",
  "class UInt32(univ.Integer):\n    pass",
  "class Microseconds(univ.Integer):\n    subtypeSpec = univ.Integer.subtypeSpec + constraint.ValueRangeConstraint(\n        0, 999999)",
  "class KerberosString(char.GeneralString):\n    # TODO marc: I'm not sure how to express this constraint in the API.\n    # For now, we will be liberal in what we accept.\n    # subtypeSpec = constraint.PermittedAlphabetConstraint(char.IA5String())\n    pass",
  "class Realm(KerberosString):\n    pass",
  "class PrincipalName(univ.Sequence):\n    componentType = namedtype.NamedTypes(\n        _sequence_component(\"name-type\", 0, Int32()),\n        _sequence_component(\"name-string\", 1,\n                            univ.SequenceOf(componentType=KerberosString()))\n                            )",
  "class KerberosTime(useful.GeneralizedTime):\n    pass",
  "class HostAddress(univ.Sequence):\n    componentType = namedtype.NamedTypes(\n        _sequence_component(\"addr-type\", 0, Int32()),\n        _sequence_component(\"address\", 1, univ.OctetString())\n        )",
  "class HostAddresses(univ.SequenceOf):\n    componentType = HostAddress()",
  "class AuthorizationData(univ.SequenceOf):\n    componentType = univ.Sequence(componentType=namedtype.NamedTypes(\n        _sequence_component('ad-type', 0, Int32()),\n        _sequence_component('ad-data', 1, univ.OctetString())\n        ))",
  "class PA_DATA(univ.Sequence):\n    componentType = namedtype.NamedTypes(\n        _sequence_component('padata-type', 1, Int32()),\n        _sequence_component('padata-value', 2, univ.OctetString())\n        )",
  "class KerberosFlags(univ.BitString):\n    # TODO marc: it doesn't look like there's any way to specify the\n    # SIZE (32.. MAX) parameter to the encoder.  However, we can\n    # arrange at a higher layer to pass in >= 32 bits to the encoder.\n    pass",
  "class EncryptedData(univ.Sequence):\n    componentType = namedtype.NamedTypes(\n        _sequence_component(\"etype\", 0, Int32()),\n        _sequence_optional_component(\"kvno\", 1, UInt32()),\n        _sequence_component(\"cipher\", 2, univ.OctetString())\n        )",
  "class EncryptionKey(univ.Sequence):\n    componentType = namedtype.NamedTypes(\n        _sequence_component('keytype', 0, Int32()),\n        _sequence_component('keyvalue', 1, univ.OctetString()))",
  "class Checksum(univ.Sequence):\n    componentType = namedtype.NamedTypes(\n        _sequence_component('cksumtype', 0, Int32()),\n        _sequence_component('checksum', 1, univ.OctetString()))",
  "class Ticket(univ.Sequence):\n    tagSet = _application_tag(constants.ApplicationTagNumbers.Ticket.value)\n    componentType = namedtype.NamedTypes(\n        _vno_component(name=\"tkt-vno\", tag_value=0),\n        _sequence_component(\"realm\", 1, Realm()),\n        _sequence_component(\"sname\", 2, PrincipalName()),\n        _sequence_component(\"enc-part\", 3, EncryptedData())\n        )",
  "class TicketFlags(KerberosFlags):\n    pass",
  "class TransitedEncoding(univ.Sequence):\n    componentType = namedtype.NamedTypes(\n        _sequence_component('tr-type', 0, Int32()),\n        _sequence_component('contents', 1, univ.OctetString()))",
  "class EncTicketPart(univ.Sequence):\n    tagSet = _application_tag(constants.ApplicationTagNumbers.EncTicketPart.value)\n    componentType = namedtype.NamedTypes(\n        _sequence_component(\"flags\", 0, TicketFlags()),\n        _sequence_component(\"key\", 1, EncryptionKey()),\n        _sequence_component(\"crealm\", 2, Realm()),\n        _sequence_component(\"cname\", 3, PrincipalName()),\n        _sequence_component(\"transited\", 4, TransitedEncoding()),\n        _sequence_component(\"authtime\", 5, KerberosTime()),\n        _sequence_optional_component(\"starttime\", 6, KerberosTime()),\n        _sequence_component(\"endtime\", 7, KerberosTime()),\n        _sequence_optional_component(\"renew-till\", 8, KerberosTime()),\n        _sequence_optional_component(\"caddr\", 9, HostAddresses()),\n        _sequence_optional_component(\"authorization-data\", 10, AuthorizationData())\n        )",
  "class KDCOptions(KerberosFlags):\n    pass",
  "class KDC_REQ_BODY(univ.Sequence):\n    componentType = namedtype.NamedTypes(\n        _sequence_component('kdc-options', 0, KDCOptions()),\n        _sequence_optional_component('cname', 1, PrincipalName()),\n        _sequence_component('realm', 2, Realm()),\n        _sequence_optional_component('sname', 3, PrincipalName()),\n        _sequence_optional_component('from', 4, KerberosTime()),\n        _sequence_component('till', 5, KerberosTime()),\n        _sequence_optional_component('rtime', 6, KerberosTime()),\n        _sequence_component('nonce', 7, UInt32()),\n        _sequence_component('etype', 8,\n                            univ.SequenceOf(componentType=Int32())),\n        _sequence_optional_component('addresses', 9, HostAddresses()),\n        _sequence_optional_component('enc-authorization-data', 10,\n                                     EncryptedData()),\n        _sequence_optional_component('additional-tickets', 11,\n                                     univ.SequenceOf(componentType=Ticket()))\n        )",
  "class KDC_REQ(univ.Sequence):\n    componentType = namedtype.NamedTypes(\n        _vno_component(1),\n        _msg_type_component(2, (constants.ApplicationTagNumbers.AS_REQ.value,\n                                constants.ApplicationTagNumbers.TGS_REQ.value)),\n        _sequence_optional_component('padata', 3,\n                                     univ.SequenceOf(componentType=PA_DATA())),\n        _sequence_component('req-body', 4, KDC_REQ_BODY())\n        )",
  "class AS_REQ(KDC_REQ):\n    tagSet = _application_tag(constants.ApplicationTagNumbers.AS_REQ.value)",
  "class TGS_REQ(KDC_REQ):\n    tagSet = _application_tag(constants.ApplicationTagNumbers.TGS_REQ.value)",
  "class KDC_REP(univ.Sequence):\n    componentType = namedtype.NamedTypes(\n        _vno_component(0),\n        _msg_type_component(1, (constants.ApplicationTagNumbers.AS_REP.value,\n                                constants.ApplicationTagNumbers.TGS_REP.value)),\n        _sequence_optional_component('padata', 2,\n                                     univ.SequenceOf(componentType=PA_DATA())),\n        _sequence_component('crealm', 3, Realm()),\n        _sequence_component('cname', 4, PrincipalName()),\n        _sequence_component('ticket', 5, Ticket()),\n        _sequence_component('enc-part', 6, EncryptedData())\n        )",
  "class LastReq(univ.SequenceOf):\n    componentType = univ.Sequence(componentType=namedtype.NamedTypes(\n        _sequence_component('lr-type', 0, Int32()),\n        _sequence_component('lr-value', 1, KerberosTime())\n        ))",
  "class METHOD_DATA(univ.SequenceOf):\n    componentType = PA_DATA()",
  "class EncKDCRepPart(univ.Sequence):\n    componentType = namedtype.NamedTypes(\n        _sequence_component('key', 0, EncryptionKey()),\n        _sequence_component('last-req', 1, LastReq()),\n        _sequence_component('nonce', 2, UInt32()),\n        _sequence_optional_component('key-expiration', 3, KerberosTime()),\n        _sequence_component('flags', 4, TicketFlags()),\n        _sequence_component('authtime', 5, KerberosTime()),\n        _sequence_optional_component('starttime', 6, KerberosTime()),\n        _sequence_component('endtime', 7, KerberosTime()),\n        _sequence_optional_component('renew-till', 8, KerberosTime()),\n        _sequence_component('srealm', 9, Realm()),\n        _sequence_component('sname', 10, PrincipalName()),\n        _sequence_optional_component('caddr', 11, HostAddresses()),\n        _sequence_optional_component('encrypted_pa_data', 12, METHOD_DATA())\n        )",
  "class EncASRepPart(EncKDCRepPart):\n    tagSet = _application_tag(constants.ApplicationTagNumbers.EncASRepPart.value)",
  "class EncTGSRepPart(EncKDCRepPart):\n    tagSet = _application_tag(constants.ApplicationTagNumbers.EncTGSRepPart.value)",
  "class AS_REP(KDC_REP):\n    tagSet = _application_tag(constants.ApplicationTagNumbers.AS_REP.value)",
  "class TGS_REP(KDC_REP):\n    tagSet = _application_tag(constants.ApplicationTagNumbers.TGS_REP.value)",
  "class APOptions(KerberosFlags):\n    pass",
  "class Authenticator(univ.Sequence):\n    tagSet = _application_tag(constants.ApplicationTagNumbers.Authenticator.value)\n    componentType = namedtype.NamedTypes(\n        _vno_component(name='authenticator-vno', tag_value=0),\n        _sequence_component('crealm', 1, Realm()),\n        _sequence_component('cname', 2, PrincipalName()),\n        _sequence_optional_component('cksum', 3, Checksum()),\n        _sequence_component('cusec', 4, Microseconds()),\n        _sequence_component('ctime', 5, KerberosTime()),\n        _sequence_optional_component('subkey', 6, EncryptionKey()),\n        _sequence_optional_component('seq-number', 7, UInt32()),\n        _sequence_optional_component('authorization-data', 8,\n                                     AuthorizationData())\n        )",
  "class AP_REQ(univ.Sequence):\n    tagSet = _application_tag(constants.ApplicationTagNumbers.AP_REQ.value)\n    componentType = namedtype.NamedTypes(\n        _vno_component(0),\n        _msg_type_component(1, (constants.ApplicationTagNumbers.AP_REQ.value,)),\n        _sequence_component('ap-options', 2, APOptions()),\n        _sequence_component('ticket', 3, Ticket()),\n        _sequence_component('authenticator', 4, EncryptedData())\n        )",
  "class AP_REP(univ.Sequence):\n    tagSet = _application_tag(constants.ApplicationTagNumbers.AP_REP.value)\n    componentType = namedtype.NamedTypes(\n        _vno_component(0),\n        _msg_type_component(1, (constants.ApplicationTagNumbers.AP_REP.value,)),\n        _sequence_component('enc-part', 2, EncryptedData()),\n        )",
  "class EncAPRepPart(univ.Sequence):\n    tagSet = _application_tag(constants.ApplicationTagNumbers.EncApRepPart.value)\n    componentType = namedtype.NamedTypes(\n        _sequence_component('ctime', 0, KerberosTime()),\n        _sequence_component('cusec', 1, Microseconds()),\n        _sequence_optional_component('subkey', 2, EncryptionKey()),\n        _sequence_optional_component('seq-number', 3, UInt32()),\n        )",
  "class KRB_SAFE_BODY(univ.Sequence):\n    componentType = namedtype.NamedTypes(\n        _sequence_component('user-data', 0, univ.OctetString()),\n        _sequence_optional_component('timestamp', 1, KerberosTime()),\n        _sequence_optional_component('usec', 2, Microseconds()),\n        _sequence_optional_component('seq-number', 3, UInt32()),\n        _sequence_component('s-address', 4, HostAddress()),\n        _sequence_optional_component('r-address', 5, HostAddress()),\n        )",
  "class KRB_SAFE(univ.Sequence):\n    tagSet = _application_tag(constants.ApplicationTagNumbers.KRB_SAFE.value)\n    componentType = namedtype.NamedTypes(\n        _vno_component(0),\n        _msg_type_component(1, (constants.ApplicationTagNumbers.KRB_SAFE.value,)),\n        _sequence_component('safe-body', 2, KRB_SAFE_BODY()),\n        _sequence_component('cksum', 3, Checksum()),\n        )",
  "class KRB_PRIV(univ.Sequence):\n    tagSet = _application_tag(constants.ApplicationTagNumbers.KRB_PRIV.value)\n    componentType = namedtype.NamedTypes(\n        _vno_component(0),\n        _msg_type_component(1, (constants.ApplicationTagNumbers.KRB_PRIV.value,)),\n        _sequence_component('enc-part', 3, EncryptedData()),\n        )",
  "class EncKrbPrivPart(univ.Sequence):\n    tagSet = _application_tag(constants.ApplicationTagNumbers.EncKrbPrivPart.value)\n    componentType = namedtype.NamedTypes(\n        _sequence_component('user-data', 0, univ.OctetString()),\n        _sequence_optional_component('timestamp', 1, KerberosTime()),\n        _sequence_optional_component('cusec', 2, Microseconds()),\n        _sequence_optional_component('seq-number', 3, UInt32()),\n        _sequence_component('s-address', 4, HostAddress()),\n        _sequence_optional_component('r-address', 5, HostAddress()),\n        )",
  "class KRB_CRED(univ.Sequence):\n    tagSet = _application_tag(constants.ApplicationTagNumbers.KRB_CRED.value)\n    componentType = namedtype.NamedTypes(\n        _vno_component(0),\n        _msg_type_component(1, (constants.ApplicationTagNumbers.KRB_CRED.value,)),\n        _sequence_optional_component('tickets', 2,\n                                     univ.SequenceOf(componentType=Ticket())),\n        _sequence_component('enc-part', 3, EncryptedData()),\n        )",
  "class KrbCredInfo(univ.Sequence):\n    componentType = namedtype.NamedTypes(\n        _sequence_component('key', 0, EncryptionKey()),\n        _sequence_optional_component('prealm', 1, Realm()),\n        _sequence_optional_component('pname', 2, PrincipalName()),\n        _sequence_optional_component('flags', 3, TicketFlags()),\n        _sequence_optional_component('authtime', 4, KerberosTime()),\n        _sequence_optional_component('starttime', 5, KerberosTime()),\n        _sequence_optional_component('endtime', 6, KerberosTime()),\n        _sequence_optional_component('renew-till', 7, KerberosTime()),\n        _sequence_optional_component('srealm', 8, Realm()),\n        _sequence_optional_component('sname', 9, PrincipalName()),\n        _sequence_optional_component('caddr', 10, HostAddresses()),\n        )",
  "class EncKrbCredPart(univ.Sequence):\n    tagSet = _application_tag(constants.ApplicationTagNumbers.EncKrbCredPart.value)\n    componentType = namedtype.NamedTypes(\n        _sequence_component('ticket-info', 0, univ.SequenceOf(componentType=KrbCredInfo())),\n        _sequence_optional_component('nonce', 1, UInt32()),\n        _sequence_optional_component('timestamp', 2, KerberosTime()),\n        _sequence_optional_component('usec', 3, Microseconds()),\n        _sequence_optional_component('s-address', 4, HostAddress()),\n        _sequence_optional_component('r-address', 5, HostAddress()),\n        )",
  "class KRB_ERROR(univ.Sequence):\n    tagSet = _application_tag(constants.ApplicationTagNumbers.KRB_ERROR.value)\n    componentType = namedtype.NamedTypes(\n        _vno_component(0),\n        _msg_type_component(1, (constants.ApplicationTagNumbers.KRB_ERROR.value,)),\n        _sequence_optional_component('ctime', 2, KerberosTime()),\n        _sequence_optional_component('cusec', 3, Microseconds()),\n        _sequence_component('stime', 4, KerberosTime()),\n        _sequence_component('susec', 5, Microseconds()),\n        _sequence_component('error-code', 6, Int32()),\n        _sequence_optional_component('crealm', 7, Realm()),\n        _sequence_optional_component('cname', 8, PrincipalName()),\n        _sequence_component('realm', 9, Realm()),\n        _sequence_component('sname', 10, PrincipalName()),\n        _sequence_optional_component('e-text', 11, KerberosString()),\n        _sequence_optional_component('e-data', 12, univ.OctetString())\n        )",
  "class TYPED_DATA(univ.SequenceOf):\n    componentType = namedtype.NamedTypes(\n        _sequence_component('data-type', 0, Int32()),\n        _sequence_optional_component('data-value', 1, univ.OctetString()),\n    )",
  "class PA_ENC_TIMESTAMP(EncryptedData):\n    pass",
  "class PA_ENC_TS_ENC(univ.Sequence):\n    componentType = namedtype.NamedTypes(\n        _sequence_component('patimestamp', 0, KerberosTime()),\n        _sequence_optional_component('pausec', 1, Microseconds()))",
  "class ETYPE_INFO_ENTRY(univ.Sequence):\n    componentType = namedtype.NamedTypes(\n        _sequence_component('etype', 0, Int32()),\n        _sequence_optional_component('salt', 1, univ.OctetString()))",
  "class ETYPE_INFO(univ.SequenceOf):\n    componentType = ETYPE_INFO_ENTRY()",
  "class ETYPE_INFO2_ENTRY(univ.Sequence):\n    componentType = namedtype.NamedTypes(\n        _sequence_component('etype', 0, Int32()),\n        _sequence_optional_component('salt', 1, KerberosString()),\n        _sequence_optional_component('s2kparams', 2, univ.OctetString()))",
  "class ETYPE_INFO2(univ.SequenceOf):\n    componentType = ETYPE_INFO2_ENTRY()",
  "class AD_IF_RELEVANT(AuthorizationData):\n    pass",
  "class AD_KDCIssued(univ.Sequence):\n    componentType = namedtype.NamedTypes(\n        _sequence_component('ad-checksum', 0, Checksum()),\n        _sequence_optional_component('i-realm', 1, Realm()),\n        _sequence_optional_component('i-sname', 2, PrincipalName()),\n        _sequence_component('elements', 3, AuthorizationData()))",
  "class AD_AND_OR(univ.Sequence):\n    componentType = namedtype.NamedTypes(\n        _sequence_component('condition-count', 0, Int32()),\n        _sequence_optional_component('elements', 1, AuthorizationData()))",
  "class AD_MANDATORY_FOR_KDC(AuthorizationData):\n    pass",
  "class KERB_PA_PAC_REQUEST(univ.Sequence):\n    componentType = namedtype.NamedTypes(\n    namedtype.NamedType('include-pac', univ.Boolean().subtype(explicitTag=tag.Tag(tag.tagClassContext, tag.tagFormatSimple, 0))),\n    )",
  "class PA_FOR_USER_ENC(univ.Sequence):\n    componentType = namedtype.NamedTypes(\n        _sequence_component('userName', 0, PrincipalName()),\n        _sequence_optional_component('userRealm', 1, Realm()),\n        _sequence_optional_component('cksum', 2, Checksum()),\n        _sequence_optional_component('auth-package', 3, KerberosString()))",
  "class KERB_ERROR_DATA(univ.Sequence):\n    componentType = namedtype.NamedTypes(\n        _sequence_component('data-type', 1, Int32()),\n        _sequence_component('data-value', 2, univ.OctetString()))",
  "class PA_PAC_OPTIONS(univ.Sequence):\n    componentType = namedtype.NamedTypes(\n        _sequence_component('flags', 0, KerberosFlags()),\n    )",
  "class KERB_KEY_LIST_REQ(univ.SequenceOf):\n    componentType = Int32()",
  "class KERB_KEY_LIST_REP(univ.SequenceOf):\n    componentType = EncryptionKey()",
  "def encodeFlags(flags):\n    finalFlags = list()\n\n    for i in range(0,32):\n        finalFlags.append(0,)\n\n\n    for f in flags:\n        finalFlags[f] = 1\n\n    return finalFlags",
  "class ApplicationTagNumbers(Enum):\n    Ticket         = 1\n    Authenticator  = 2\n    EncTicketPart  = 3\n    AS_REQ         = 10\n    AS_REP         = 11\n    TGS_REQ        = 12\n    TGS_REP        = 13\n    AP_REQ         = 14\n    AP_REP         = 15\n    RESERVED16     = 16\n    RESERVED17     = 17\n    KRB_SAFE       = 20\n    KRB_PRIV       = 21\n    KRB_CRED       = 22\n    EncASRepPart   = 25\n    EncTGSRepPart  = 26\n    EncApRepPart   = 27\n    EncKrbPrivPart = 28 \n    EncKrbCredPart = 29\n    KRB_ERROR      = 30",
  "class PrincipalNameType(Enum):\n    NT_UNKNOWN              = 0\n    NT_PRINCIPAL            = 1\n    NT_SRV_INST             = 2\n    NT_SRV_HST              = 3\n    NT_SRV_XHST             = 4\n    NT_UID                  = 5\n    NT_X500_PRINCIPAL       = 6\n    NT_SMTP_NAME            = 7\n    NT_ENTERPRISE           = 10\n    NT_WELLKNOWN            = 11\n    NT_SRV_HST_DOMAIN       = 12\n    NT_MS_PRINCIPAL         = -128\n    NT_MS_PRINCIPAL_AND_ID  = -129\n    NT_ENT_PRINCIPAL_AND_ID = -130",
  "class PreAuthenticationDataTypes(Enum):\n    PA_TGS_REQ                 = 1\n    PA_ENC_TIMESTAMP           = 2\n    PA_PW_SALT                 = 3\n    PA_ENC_UNIX_TIME           = 5\n    PA_SANDIA_SECUREID         = 6\n    PA_SESAME                  = 7\n    PA_OSF_DCE                 = 8\n    PA_CYBERSAFE_SECUREID      = 9\n    PA_AFS3_SALT               = 10\n    PA_ETYPE_INFO              = 11\n    PA_SAM_CHALLENGE           = 12\n    PA_SAM_RESPONSE            = 13\n    PA_PK_AS_REQ_OLD           = 14\n    PA_PK_AS_REP_OLD           = 15\n    PA_PK_AS_REQ               = 16\n    PA_PK_AS_REP               = 17\n    PA_ETYPE_INFO2             = 19\n    PA_USE_SPECIFIED_KVNO      = 20\n    PA_SAM_REDIRECT            = 21\n    PA_GET_FROM_TYPED_DATA     = 22\n    TD_PADATA                  = 22\n    PA_SAM_ETYPE_INFO          = 23\n    PA_ALT_PRINC               = 24\n    PA_SAM_CHALLENGE2          = 30\n    PA_SAM_RESPONSE2           = 31\n    PA_EXTRA_TGT               = 41\n    TD_PKINIT_CMS_CERTIFICATES = 101\n    TD_KRB_PRINCIPAL           = 102\n    TD_KRB_REALM               = 103\n    TD_TRUSTED_CERTIFIERS      = 104\n    TD_CERTIFICATE_INDEX       = 105\n    TD_APP_DEFINED_ERROR       = 106\n    TD_REQ_NONCE               = 107\n    TD_REQ_SEQ                 = 108\n    PA_PAC_REQUEST             = 128\n    PA_FOR_USER                = 129\n    PA_FX_COOKIE               = 133 \n    PA_FX_FAST                 = 136\n    PA_FX_ERROR                = 137\n    PA_ENCRYPTED_CHALLENGE     = 138\n    KERB_KEY_LIST_REQ          = 161\n    KERB_KEY_LIST_REP          = 162\n    PA_SUPPORTED_ENCTYPES      = 165\n    PA_PAC_OPTIONS             = 167",
  "class AddressType(Enum):\n    IPv4            = 2\n    Directional     = 3\n    ChaosNet        = 5\n    XNS             = 6\n    ISO             = 7\n    DECNET_Phase_IV = 12\n    AppleTalk_DDP   = 16\n    NetBios         = 20\n    IPv6            = 24",
  "class AuthorizationDataType(Enum):\n    AD_IF_RELEVANT                     = 1\n    AD_INTENDED_FOR_SERVER             = 2\n    AD_INTENDED_FOR_APPLICATION_CLASS  = 3\n    AD_KDC_ISSUED                      = 4\n    AD_AND_OR                          = 5\n    AD_MANDATORY_TICKET_EXTENSIONS     = 6\n    AD_IN_TICKET_EXTENSIONS            = 7\n    AD_MANDATORY_FOR_KDC               = 8\n    #Reserved values                    = 9-63\n    OSF_DCE                            = 64\n    SESAME                             = 65\n    AD_OSF_DCE_PKI_CERTID              = 66 \n    AD_WIN2K_PAC                       = 128 \n    AD_ETYPE_NEGOTIATION               = 129",
  "class TransitedEncodingTypes(Enum):\n    DOMAIN_X500_COMPRESS = 1",
  "class ProtocolVersionNumber(Enum):\n    pvno = 5",
  "class KerberosMessageTypes(Enum):\n    KRB_AS_REQ      = 10    # Request for initial authentication\n    KRB_AS_REP      = 11    # Response to KRB_AS_REQ request\n    KRB_TGS_REQ     = 12    # Request for authentication based on TGT\n    KRB_TGS_REP     = 13    # Response to KRB_TGS_REQ request\n    KRB_AP_REQ      = 14    # Application request to server\n    KRB_AP_REP      = 15    # Response to KRB_AP_REQ_MUTUAL\n    KRB_RESERVED16  = 16    # Reserved for user-to-user krb_tgt_request\n    KRB_RESERVED17  = 17    # Reserved for user-to-user krb_tgt_reply\n    KRB_SAFE        = 20    # Safe (checksummed) application message\n    KRB_PRIV        = 21    # Private (encrypted) application message\n    KRB_CRED        = 22    # Private (encrypted) message to forward\n                            # credentials\n    KRB_ERROR       = 30",
  "class NameTypes(Enum):\n    KRB_NT_UNKNOWN              = 0    # Name type not known\n    KRB_NT_PRINCIPAL            = 1    # Just the name of the principal as in DCE,\n                                       # or for users\n    KRB_NT_SRV_INST             = 2    # Service and other unique instance (krbtgt)\n    KRB_NT_SRV_HST              = 3    # Service with host name as instance\n                                       # (telnet, rcommands)\n    KRB_NT_SRV_XHST             = 4    # Service with host as remaining components\n    KRB_NT_UID                  = 5    # Unique ID\n    KRB_NT_X500_PRINCIPAL       = 6    # Encoded X.509 Distinguished name [RFC2253]\n    KRB_NT_SMTP_NAME            = 7    # Name in form of SMTP email name\n                                       # (e.g., user@example.com)\n    KRB_NT_ENTERPRISE           = 10   #   Enterprise name; may be mapped to\n                                       # principal name\n    # Other Name Types\n    KRB_NT_WELLKNOWN            = 11\n    KRB_NT_SRV_HST_DOMAIN       = 12\n    KRB_NT_MS_PRINCIPAL         = -128\n    KRB_NT_MS_PRINCIPAL_AND_ID  = -129\n    KRB_NT_ENT_PRINCIPAL_AND_ID = -130",
  "class ErrorCodes(Enum):\n    KDC_ERR_NONE                                 = 0  # No error\n    KDC_ERR_NAME_EXP                             = 1  # Client's entry in database\n                                                      # has expired\n    KDC_ERR_SERVICE_EXP                          = 2  # Server's entry in database\n                                                      # has expired\n    KDC_ERR_BAD_PVNO                             = 3  # Requested protocol version\n                                                      # number not supported\n    KDC_ERR_C_OLD_MAST_KVNO                      = 4  # Client's key encrypted in\n                                                      # old master key\n    KDC_ERR_S_OLD_MAST_KVNO                      = 5  # Server's key encrypted in\n                                                      # old master key\n    KDC_ERR_C_PRINCIPAL_UNKNOWN                  = 6  # Client not found in\n                                                      # Kerberos database\n    KDC_ERR_S_PRINCIPAL_UNKNOWN                  = 7  # Server not found in\n                                                      # Kerberos database\n    KDC_ERR_PRINCIPAL_NOT_UNIQUE                 = 8  # Multiple principal entries\n                                                      # in database\n    KDC_ERR_NULL_KEY                             = 9  # The client or server has a\n                                                      # null key\n    KDC_ERR_CANNOT_POSTDATE                     = 10  # Ticket not eligible for\n                                                      # postdating\n    KDC_ERR_NEVER_VALID                         = 11  # Requested starttime is\n                                                      # later than end time\n    KDC_ERR_POLICY                              = 12  # KDC policy rejects request\n    KDC_ERR_BADOPTION                           = 13  # KDC cannot accommodate\n                                                      # requested option\n    KDC_ERR_ETYPE_NOSUPP                        = 14  # KDC has no support for\n                                                      # encryption type\n    KDC_ERR_SUMTYPE_NOSUPP                      = 15  # KDC has no support for\n                                                      # checksum type\n    KDC_ERR_PADATA_TYPE_NOSUPP                  = 16  # KDC has no support for\n                                                      # padata type\n    KDC_ERR_TRTYPE_NOSUPP                       = 17  # KDC has no support for\n                                                      # transited type\n    KDC_ERR_CLIENT_REVOKED                      = 18  # Clients credentials have\n                                                      # been revoked\n    KDC_ERR_SERVICE_REVOKED                     = 19  # Credentials for server have\n                                                      # been revoked\n    KDC_ERR_TGT_REVOKED                         = 20  # TGT has been revoked\n    KDC_ERR_CLIENT_NOTYET                       = 21  # Client not yet valid; try\n                                                      # again later\n    KDC_ERR_SERVICE_NOTYET                      = 22  # Server not yet valid; try\n                                                      # again later\n    KDC_ERR_KEY_EXPIRED                         = 23  # Password has expired;\n                                                      # change password to reset\n    KDC_ERR_PREAUTH_FAILED                      = 24  # Pre-authentication\n                                                      # information was invalid\n    KDC_ERR_PREAUTH_REQUIRED                    = 25  # Additional pre-\n                                                      # authentication required\n    KDC_ERR_SERVER_NOMATCH                      = 26  # Requested server and ticket\n                                                      # don't match\n    KDC_ERR_MUST_USE_USER2USER                  = 27  # Server principal valid for\n                                                      # user2user only\n    KDC_ERR_PATH_NOT_ACCEPTED                   = 28  # KDC Policy rejects\n                                                      # transited path\n    KDC_ERR_SVC_UNAVAILABLE                     = 29  # A service is not available\n    KRB_AP_ERR_BAD_INTEGRITY                    = 31  # Integrity check on\n                                                      # decrypted field failed\n    KRB_AP_ERR_TKT_EXPIRED                      = 32  # Ticket expired\n    KRB_AP_ERR_TKT_NYV                          = 33  # Ticket not yet valid\n    KRB_AP_ERR_REPEAT                           = 34  # Request is a replay\n    KRB_AP_ERR_NOT_US                           = 35  # The ticket isn't for us\n    KRB_AP_ERR_BADMATCH                         = 36  # Ticket and authenticator\n                                                      # don't match\n    KRB_AP_ERR_SKEW                             = 37  # Clock skew too great\n    KRB_AP_ERR_BADADDR                          = 38  # Incorrect net address\n    KRB_AP_ERR_BADVERSION                       = 39  # Protocol version mismatch\n    KRB_AP_ERR_MSG_TYPE                         = 40  # Invalid msg type\n    KRB_AP_ERR_MODIFIED                         = 41  # Message stream modified\n    KRB_AP_ERR_BADORDER                         = 42  # Message out of order\n    KRB_AP_ERR_BADKEYVER                        = 44  # Specified version of key is\n                                                      # not available\n    KRB_AP_ERR_NOKEY                            = 45  # Service key not available\n    KRB_AP_ERR_MUT_FAIL                         = 46  # Mutual authentication\n                                                      # failed\n    KRB_AP_ERR_BADDIRECTION                     = 47  # Incorrect message direction\n    KRB_AP_ERR_METHOD                           = 48  # Alternative authentication\n                                                      # method required\n    KRB_AP_ERR_BADSEQ                           = 49  # Incorrect sequence number\n                                                      # in message\n    KRB_AP_ERR_INAPP_CKSUM                      = 50  # Inappropriate type of\n                                                      # checksum in message\n    KRB_AP_PATH_NOT_ACCEPTED                    = 51  # Policy rejects transited\n                                                      # path\n    KRB_ERR_RESPONSE_TOO_BIG                    = 52  # Response too big for UDP;\n                                                      # retry with TCP\n    KRB_ERR_GENERIC                             = 60  # Generic error (description\n                                                      # in e-text)\n    KRB_ERR_FIELD_TOOLONG                       = 61  # Field is too long for this\n                                                      # implementation\n    KDC_ERROR_CLIENT_NOT_TRUSTED                = 62  # Reserved for PKINIT\n    KDC_ERROR_KDC_NOT_TRUSTED                   = 63  # Reserved for PKINIT\n    KDC_ERROR_INVALID_SIG                       = 64  # Reserved for PKINIT\n    KDC_ERR_KEY_TOO_WEAK                        = 65  # Reserved for PKINIT\n    KDC_ERR_CERTIFICATE_MISMATCH                = 66  # Reserved for PKINIT\n    KRB_AP_ERR_NO_TGT                           = 67  # No TGT available to\n                                                      # validate USER-TO-USER\n    KDC_ERR_WRONG_REALM                         = 68  # Reserved for future use\n    KRB_AP_ERR_USER_TO_USER_REQUIRED            = 69  # Ticket must be for\n                                                      # USER-TO-USER\n    KDC_ERR_CANT_VERIFY_CERTIFICATE             = 70  # Reserved for PKINIT\n    KDC_ERR_INVALID_CERTIFICATE                 = 71  # Reserved for PKINIT\n    KDC_ERR_REVOKED_CERTIFICATE                 = 72  # Reserved for PKINIT\n    KDC_ERR_REVOCATION_STATUS_UNKNOWN           = 73  # Reserved for PKINIT\n    KDC_ERR_REVOCATION_STATUS_UNAVAILABLE       = 74  # Reserved for PKINIT\n    KDC_ERR_CLIENT_NAME_MISMATCH                = 75  # Reserved for PKINIT\n    KDC_ERR_KDC_NAME_MISMATCH                   = 76  # Reserved for PKINIT\n    KDC_ERR_INCONSISTENT_KEY_PURPOSE            = 77  # Reserved for PKINIT\n    KDC_ERR_DIGEST_IN_CERT_NOT_ACCEPTED         = 78  # Reserved for PKINIT\n    KDC_ERR_PA_CHECKSUM_MUST_BE_INCLUDED        = 79  # Reserved for PKINIT\n    KDC_ERR_DIGEST_IN_SIGNED_DATA_NOT_ACCEPTED  = 80  # Reserved for PKINIT\n    KDC_ERR_PUBLIC_KEY_ENCRYPTION_NOT_SUPPORTED = 81  # Reserved for PKINIT\n    KDC_ERR_PREAUTH_EXPIRED                     = 90  # Pre-authentication has expired\n    KDC_ERR_MORE_PREAUTH_DATA_REQUIRED          = 91  # Additional pre-authentication data is required\n    KDC_ERR_PREAUTH_BAD_AUTHENTICATION_SET      = 92  # KDC cannot accommodate requested pre-authentication data element\n    KDC_ERR_UNKNOWN_CRITICAL_FAST_OPTIONS       = 93",
  "class TicketFlags(Enum):\n    reserved                 = 0\n    forwardable              = 1\n    forwarded                = 2\n    proxiable                = 3\n    proxy                    = 4\n    may_postdate             = 5\n    postdated                = 6\n    invalid                  = 7\n    renewable                = 8\n    initial                  = 9\n    pre_authent              = 10\n    hw_authent               = 11\n    transited_policy_checked = 12\n    ok_as_delegate           = 13\n    enc_pa_rep               = 15\n    anonymous                = 16",
  "class KDCOptions(Enum):\n    reserved                = 0\n    forwardable             = 1\n    forwarded               = 2\n    proxiable               = 3\n    proxy                   = 4\n    allow_postdate          = 5\n    postdated               = 6\n    unused7                 = 7\n    renewable               = 8\n    unused9                 = 9\n    unused10                = 10\n    opt_hardware_auth       = 11\n    unused12                = 12\n    unused13                = 13\n    cname_in_addl_tkt       = 14\n    canonicalize            = 15\n    disable_transited_check = 26\n    renewable_ok            = 27\n    enc_tkt_in_skey         = 28\n    renew                   = 30\n    validate                = 31",
  "class APOptions(Enum):\n    reserved        = 0\n    use_session_key = 1\n    mutual_required = 2",
  "class PAPacOptions(Enum):\n    # [MS-KILE] 2.2.10\n    claims                                = 0\n    branch_aware                          = 1\n    forward_to_full_dc                    = 2\n    # [MS-SFU] 2.2.5\n    resource_based_constrained_delegation = 3",
  "class EncryptionTypes(Enum):\n    des_cbc_crc                  = 1\n    des_cbc_md4                  = 2\n    des_cbc_md5                  = 3\n    _reserved_4                  = 4\n    des3_cbc_md5                 = 5\n    _reserved_6                  = 6\n    des3_cbc_sha1                = 7\n    dsaWithSHA1_CmsOID           = 9\n    md5WithRSAEncryption_CmsOID  = 10\n    sha1WithRSAEncryption_CmsOID = 11\n    rc2CBC_EnvOID                = 12\n    rsaEncryption_EnvOID         = 13\n    rsaES_OAEP_ENV_OID           = 14\n    des_ede3_cbc_Env_OID         = 15\n    des3_cbc_sha1_kd             = 16\n    aes128_cts_hmac_sha1_96      = 17\n    aes256_cts_hmac_sha1_96      = 18\n    rc4_hmac                     = 23\n    rc4_hmac_exp                 = 24\n    subkey_keymaterial           = 65\n    rc4_hmac_old_exp             = -135",
  "class ChecksumTypes(Enum):\n    rsa_md5_des       = 8\n    rsa_md4_des       = 4\n    hmac_md5          = -138\n    hmac_sha1_des3_kd = 12\n    hmac_sha1_96_aes128 = 15\n    hmac_sha1_96_aes256 = 16",
  "def get_random_bytes(lenBytes):\n    # We don't really need super strong randomness here to use PyCrypto.Random\n    return urandom(lenBytes)",
  "class Enctype(object):\n    DES_CRC = 1\n    DES_MD4 = 2\n    DES_MD5 = 3\n    DES3 = 16\n    AES128 = 17\n    AES256 = 18\n    RC4 = 23",
  "class Cksumtype(object):\n    CRC32 = 1\n    MD4 = 2\n    MD4_DES = 3\n    MD5 = 7\n    MD5_DES = 8\n    SHA1 = 9\n    SHA1_DES3 = 12\n    SHA1_AES128 = 15\n    SHA1_AES256 = 16\n    HMAC_MD5 = -138",
  "class InvalidChecksum(ValueError):\n    pass",
  "def _zeropad(s, padsize):\n    # Return s padded with 0 bytes to a multiple of padsize.\n    padlen = (padsize - (len(s) % padsize)) % padsize\n    return s + b'\\0'*padlen",
  "def _xorbytes(b1, b2):\n    # xor two strings together and return the resulting string.\n    assert len(b1) == len(b2)\n    return bytearray((x ^ y) for x, y in zip(b1, b2))",
  "def _mac_equal(mac1, mac2):\n    # Constant-time comparison function.  (We can't use HMAC.verify\n    # since we use truncated macs.)\n    assert len(mac1) == len(mac2)\n    res = 0\n    for x, y in zip(mac1, mac2):\n        res |= x ^ y\n    return res == 0",
  "def _nfold(ba, nbytes):\n    # Convert bytearray to a string of length nbytes using the RFC 3961 nfold\n    # operation.\n\n    # Rotate the bytes in ba to the right by nbits bits.\n    def rotate_right(ba, nbits):\n        ba = bytearray(ba)\n        nbytes, remain = (nbits//8) % len(ba), nbits % 8\n        return bytearray((ba[i-nbytes] >> remain) | ((ba[i-nbytes-1] << (8-remain)) & 0xff) for i in range(len(ba)))\n\n    # Add equal-length strings together with end-around carry.\n    def add_ones_complement(str1, str2):\n        n = len(str1)\n        v = [a + b for a, b in zip(str1, str2)]\n        # Propagate carry bits to the left until there aren't any left.\n        while any(x & ~0xff for x in v):\n            v = [(v[i-n+1]>>8) + (v[i]&0xff) for i in range(n)]\n        return bytearray(x for x in v)\n\n    # Concatenate copies of str to produce the least common multiple\n    # of len(str) and nbytes, rotating each copy of str to the right\n    # by 13 bits times its list position.  Decompose the concatenation\n    # into slices of length nbytes, and add them together as\n    # big-endian ones' complement integers.\n    slen = len(ba)\n    lcm = nbytes * slen // gcd(nbytes, slen)\n    bigstr = bytearray()\n    for i in range(lcm//slen):\n        bigstr += rotate_right(ba, 13 * i)\n    slices = (bigstr[p:p+nbytes] for p in range(0, lcm, nbytes))\n    return bytes(reduce(add_ones_complement, slices))",
  "def _is_weak_des_key(keybytes):\n    return keybytes in (b'\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01',\n                        b'\\xFE\\xFE\\xFE\\xFE\\xFE\\xFE\\xFE\\xFE',\n                        b'\\x1F\\x1F\\x1F\\x1F\\x0E\\x0E\\x0E\\x0E',\n                        b'\\xE0\\xE0\\xE0\\xE0\\xF1\\xF1\\xF1\\xF1',\n                        b'\\x01\\xFE\\x01\\xFE\\x01\\xFE\\x01\\xFE',\n                        b'\\xFE\\x01\\xFE\\x01\\xFE\\x01\\xFE\\x01',\n                        b'\\x1F\\xE0\\x1F\\xE0\\x0E\\xF1\\x0E\\xF1',\n                        b'\\xE0\\x1F\\xE0\\x1F\\xF1\\x0E\\xF1\\x0E',\n                        b'\\x01\\xE0\\x01\\xE0\\x01\\xF1\\x01\\xF1',\n                        b'\\xE0\\x01\\xE0\\x01\\xF1\\x01\\xF1\\x01',\n                        b'\\x1F\\xFE\\x1F\\xFE\\x0E\\xFE\\x0E\\xFE',\n                        b'\\xFE\\x1F\\xFE\\x1F\\xFE\\x0E\\xFE\\x0E',\n                        b'\\x01\\x1F\\x01\\x1F\\x01\\x0E\\x01\\x0E',\n                        b'\\x1F\\x01\\x1F\\x01\\x0E\\x01\\x0E\\x01',\n                        b'\\xE0\\xFE\\xE0\\xFE\\xF1\\xFE\\xF1\\xFE',\n                        b'\\xFE\\xE0\\xFE\\xE0\\xFE\\xF1\\xFE\\xF1')",
  "class _EnctypeProfile(object):\n    # Base class for enctype profiles.  Usable enctype classes must define:\n    #   * enctype: enctype number\n    #   * keysize: protocol size of key in bytes\n    #   * seedsize: random_to_key input size in bytes\n    #   * random_to_key (if the keyspace is not dense)\n    #   * string_to_key\n    #   * encrypt\n    #   * decrypt\n    #   * prf\n\n    @classmethod\n    def random_to_key(cls, seed):\n        if len(seed) != cls.seedsize:\n            raise ValueError('Wrong seed length')\n        return Key(cls.enctype, seed)",
  "class _SimplifiedEnctype(_EnctypeProfile):\n    # Base class for enctypes using the RFC 3961 simplified profile.\n    # Defines the encrypt, decrypt, and prf methods.  Subclasses must\n    # define:\n    #   * blocksize: Underlying cipher block size in bytes\n    #   * padsize: Underlying cipher padding multiple (1 or blocksize)\n    #   * macsize: Size of integrity MAC in bytes\n    #   * hashmod: PyCrypto hash module for underlying hash function\n    #   * basic_encrypt, basic_decrypt: Underlying CBC/CTS cipher\n\n    @classmethod\n    def derive(cls, key, constant):\n        # RFC 3961 only says to n-fold the constant only if it is\n        # shorter than the cipher block size.  But all Unix\n        # implementations n-fold constants if their length is larger\n        # than the block size as well, and n-folding when the length\n        # is equal to the block size is a no-op.\n        plaintext = _nfold(constant, cls.blocksize)\n        rndseed = b''\n        while len(rndseed) < cls.seedsize:\n            ciphertext = cls.basic_encrypt(key, plaintext)\n            rndseed += ciphertext\n            plaintext = ciphertext\n        return cls.random_to_key(rndseed[0:cls.seedsize])\n\n    @classmethod\n    def encrypt(cls, key, keyusage, plaintext, confounder):\n        ki = cls.derive(key, pack('>IB', keyusage, 0x55))\n        ke = cls.derive(key, pack('>IB', keyusage, 0xAA))\n        if confounder is None:\n            confounder = get_random_bytes(cls.blocksize)\n        basic_plaintext = confounder + _zeropad(plaintext, cls.padsize)\n        hmac = HMAC.new(ki.contents, basic_plaintext, cls.hashmod).digest()\n        return cls.basic_encrypt(ke, basic_plaintext) + hmac[:cls.macsize]\n\n    @classmethod\n    def decrypt(cls, key, keyusage, ciphertext):\n        ki = cls.derive(key, pack('>IB', keyusage, 0x55))\n        ke = cls.derive(key, pack('>IB', keyusage, 0xAA))\n        if len(ciphertext) < cls.blocksize + cls.macsize:\n            raise ValueError('ciphertext too short')\n        basic_ctext, mac = bytearray(ciphertext[:-cls.macsize]), bytearray(ciphertext[-cls.macsize:])\n        if len(basic_ctext) % cls.padsize != 0:\n            raise ValueError('ciphertext does not meet padding requirement')\n        basic_plaintext = cls.basic_decrypt(ke, bytes(basic_ctext))\n        hmac = bytearray(HMAC.new(ki.contents, basic_plaintext, cls.hashmod).digest())\n        expmac = hmac[:cls.macsize]\n        if not _mac_equal(mac, expmac):\n            raise InvalidChecksum('ciphertext integrity failure')\n        # Discard the confounder.\n        return bytes(basic_plaintext[cls.blocksize:])\n\n    @classmethod\n    def prf(cls, key, string):\n        # Hash the input.  RFC 3961 says to truncate to the padding\n        # size, but implementations truncate to the block size.\n        hashval = cls.hashmod.new(string).digest()\n        truncated = hashval[:-(len(hashval) % cls.blocksize)]\n        # Encrypt the hash with a derived key.\n        kp = cls.derive(key, b'prf')\n        return cls.basic_encrypt(kp, truncated)",
  "class _DESCBC(_SimplifiedEnctype):\n    enctype = Enctype.DES_MD5\n    keysize = 8\n    seedsize = 8\n    blocksize = 8\n    padsize = 8\n    macsize = 16\n    hashmod = MD5\n\n    @classmethod\n    def encrypt(cls, key, keyusage, plaintext, confounder):\n        if confounder is None:\n            confounder = get_random_bytes(cls.blocksize)\n        basic_plaintext = confounder + b'\\x00'*cls.macsize + _zeropad(plaintext, cls.padsize)\n        checksum = cls.hashmod.new(basic_plaintext).digest()\n        basic_plaintext = basic_plaintext[:len(confounder)] + checksum + basic_plaintext[len(confounder)+len(checksum):]\n        return cls.basic_encrypt(key, basic_plaintext)\n        \n        \n    @classmethod\n    def decrypt(cls, key, keyusage, ciphertext):\n        if len(ciphertext) < cls.blocksize + cls.macsize:\n            raise ValueError('ciphertext too short')\n        \n        complex_plaintext = cls.basic_decrypt(key, ciphertext)\n        cofounder = complex_plaintext[:cls.padsize]\n        mac = complex_plaintext[cls.padsize:cls.padsize+cls.macsize]\n        message = complex_plaintext[cls.padsize+cls.macsize:]\n        \n        expmac = cls.hashmod.new(cofounder+b'\\x00'*cls.macsize+message).digest()\n        if not _mac_equal(mac, expmac):\n            raise InvalidChecksum('ciphertext integrity failure')\n        return bytes(message)\n    \n    @classmethod\n    def mit_des_string_to_key(cls,string,salt):\n    \n        def fixparity(deskey):\n            temp = b''\n            for i in range(len(deskey)):\n                t = (bin(indexbytes(deskey,i))[2:]).rjust(8,'0')\n                if t[:7].count('1') %2 == 0:\n                    temp+= b(chr(int(t[:7]+'1',2)))\n                else:\n                    temp+= b(chr(int(t[:7]+'0',2)))\n            return temp\n    \n        def addparity(l1):\n            temp = list()\n            for byte in l1:\n                if (bin(byte).count('1') % 2) == 0:\n                    byte = (byte << 1)|0b00000001\n                else:\n                    byte = (byte << 1)&0b11111110\n                temp.append(byte)\n            return temp\n        \n        def XOR(l1,l2):\n            temp = list()\n            for b1,b2 in zip(l1,l2):\n                temp.append((b1^b2)&0b01111111)\n            \n            return temp\n        \n        odd = True\n        tempstring = [0,0,0,0,0,0,0,0]\n        s = _zeropad(string + salt, cls.padsize)\n\n        for block in [s[i:i+8] for i in range(0, len(s), 8)]:\n            temp56 = list()\n            #removeMSBits\n            for byte in block:\n                if PY3:\n                    temp56.append(byte&0b01111111)\n                else:\n                    temp56.append(ord(byte)&0b01111111)\n            \n            #reverse\n            if odd is False:\n                bintemp = b''\n                for byte in temp56:\n                    bintemp += b(bin(byte)[2:].rjust(7,'0'))\n                bintemp = bintemp[::-1]\n                \n                temp56 = list()\n                for bits7 in [bintemp[i:i+7] for i in range(0, len(bintemp), 7)]:\n                    temp56.append(int(bits7,2))\n\n            odd = not odd\n                \n            tempstring = XOR(tempstring,temp56)\n        \n        tempkey = ''.join(chr(byte) for byte in addparity(tempstring))\n        if _is_weak_des_key(tempkey):\n            tempkey[7] = chr(ord(tempkey[7]) ^ 0xF0)\n\n        cipher = DES.new(b(tempkey), DES.MODE_CBC, b(tempkey))\n        checksumkey = cipher.encrypt(s)[-8:]\n        checksumkey = fixparity(checksumkey)\n        if _is_weak_des_key(checksumkey):\n            checksumkey[7] = chr(ord(checksumkey[7]) ^ 0xF0)\n        \n        return Key(cls.enctype, checksumkey)\n\n    @classmethod\n    def basic_encrypt(cls, key, plaintext):\n        assert len(plaintext) % 8 == 0\n        des = DES.new(key.contents, DES.MODE_CBC, b'\\0' * 8)\n        return des.encrypt(bytes(plaintext))\n\n    @classmethod\n    def basic_decrypt(cls, key, ciphertext):\n        assert len(ciphertext) % 8 == 0\n        des = DES.new(key.contents, DES.MODE_CBC, b'\\0' * 8)\n        return des.decrypt(bytes(ciphertext))\n    \n    @classmethod\n    def string_to_key(cls, string, salt, params):\n        if params is not None and params != b'':\n            raise ValueError('Invalid DES string-to-key parameters')\n        if not isinstance(string, binary_type):\n            string = string.encode(\"utf-8\")\n        if not isinstance(salt, binary_type):\n            salt = salt.encode(\"utf-8\")\n\n        key = cls.mit_des_string_to_key(string, salt)\n        return key",
  "class _DES3CBC(_SimplifiedEnctype):\n    enctype = Enctype.DES3\n    keysize = 24\n    seedsize = 21\n    blocksize = 8\n    padsize = 8\n    macsize = 20\n    hashmod = SHA\n\n    @classmethod\n    def random_to_key(cls, seed):\n        # XXX Maybe reframe as _DESEnctype.random_to_key and use that\n        # way from DES3 random-to-key when DES is implemented, since\n        # MIT does this instead of the RFC 3961 random-to-key.\n        def expand(seed):\n            def parity(b):\n                # Return b with the low-order bit set to yield odd parity.\n                b &= ~1\n                return b if bin(b & ~1).count('1') % 2 else b | 1\n            assert len(seed) == 7\n            firstbytes = [parity(b & ~1) for b in seed]\n            lastbyte = parity(sum((seed[i]&1) << i+1 for i in range(7)))\n            keybytes= bytearray(firstbytes + [lastbyte])\n            if _is_weak_des_key(keybytes):\n                keybytes[7] = keybytes[7] ^ 0xF0\n            return bytes(keybytes)\n\n        seed = bytearray(seed)\n        if len(seed) != 21:\n            raise ValueError('Wrong seed length')\n        k1, k2, k3 = expand(seed[:7]), expand(seed[7:14]), expand(seed[14:])\n        return Key(cls.enctype, k1 + k2 + k3)\n\n    @classmethod\n    def string_to_key(cls, string, salt, params):\n        if params is not None and params != b'':\n            raise ValueError('Invalid DES3 string-to-key parameters')\n        if not isinstance(string, binary_type):\n            string = string.encode(\"utf-8\")\n        if not isinstance(salt, binary_type):\n            salt = salt.encode(\"utf-8\")\n\n        k = cls.random_to_key(_nfold(string + salt, 21))\n        return cls.derive(k, b'kerberos')\n\n    @classmethod\n    def basic_encrypt(cls, key, plaintext):\n        assert len(plaintext) % 8 == 0\n        des3 = DES3.new(key.contents, AES.MODE_CBC, b'\\0' * 8)\n        return des3.encrypt(bytes(plaintext))\n\n    @classmethod\n    def basic_decrypt(cls, key, ciphertext):\n        assert len(ciphertext) % 8 == 0\n        des3 = DES3.new(key.contents, AES.MODE_CBC, b'\\0' * 8)\n        return des3.decrypt(bytes(ciphertext))",
  "class _AESEnctype(_SimplifiedEnctype):\n    # Base class for aes128-cts and aes256-cts.\n    blocksize = 16\n    padsize = 1\n    macsize = 12\n    hashmod = SHA\n\n    @classmethod\n    def string_to_key(cls, string, salt, params):\n        if not isinstance(string, binary_type):\n            string = string.encode(\"utf-8\")\n        if not isinstance(salt, binary_type):\n            salt = salt.encode(\"utf-8\")\n\n        (iterations,) = unpack('>L', params or b'\\x00\\x00\\x10\\x00')\n        prf = lambda p, s: HMAC.new(p, s, SHA).digest()\n        seed = PBKDF2(string, salt, cls.seedsize, iterations, prf)\n        tkey = cls.random_to_key(seed)\n        return cls.derive(tkey, b'kerberos')\n\n    @classmethod\n    def basic_encrypt(cls, key, plaintext):\n        assert len(plaintext) >= 16\n        aes = AES.new(key.contents, AES.MODE_CBC, b'\\0' * 16)\n        ctext = aes.encrypt(_zeropad(bytes(plaintext), 16))\n        if len(plaintext) > 16:\n            # Swap the last two ciphertext blocks and truncate the\n            # final block to match the plaintext length.\n            lastlen = len(plaintext) % 16 or 16\n            ctext = ctext[:-32] + ctext[-16:] + ctext[-32:-16][:lastlen]\n        return ctext\n\n    @classmethod\n    def basic_decrypt(cls, key, ciphertext):\n        assert len(ciphertext) >= 16\n        aes = AES.new(key.contents, AES.MODE_ECB)\n        if len(ciphertext) == 16:\n            return aes.decrypt(ciphertext)\n        # Split the ciphertext into blocks.  The last block may be partial.\n        cblocks = [bytearray(ciphertext[p:p+16]) for p in range(0, len(ciphertext), 16)]\n        lastlen = len(cblocks[-1])\n        # CBC-decrypt all but the last two blocks.\n        prev_cblock = bytearray(16)\n        plaintext = b''\n        for bb in cblocks[:-2]:\n            plaintext += _xorbytes(bytearray(aes.decrypt(bytes(bb))), prev_cblock)\n            prev_cblock = bb\n        # Decrypt the second-to-last cipher block.  The left side of\n        # the decrypted block will be the final block of plaintext\n        # xor'd with the final partial cipher block; the right side\n        # will be the omitted bytes of ciphertext from the final\n        # block.\n        bb = bytearray(aes.decrypt(bytes(cblocks[-2])))\n        lastplaintext =_xorbytes(bb[:lastlen], cblocks[-1])\n        omitted = bb[lastlen:]\n        # Decrypt the final cipher block plus the omitted bytes to get\n        # the second-to-last plaintext block.\n        plaintext += _xorbytes(bytearray(aes.decrypt(bytes(cblocks[-1]) + bytes(omitted))), prev_cblock)\n        return plaintext + lastplaintext",
  "class _AES128CTS(_AESEnctype):\n    enctype = Enctype.AES128\n    keysize = 16\n    seedsize = 16",
  "class _AES256CTS(_AESEnctype):\n    enctype = Enctype.AES256\n    keysize = 32\n    seedsize = 32",
  "class _RC4(_EnctypeProfile):\n    enctype = Enctype.RC4\n    keysize = 16\n    seedsize = 16\n\n    @staticmethod\n    def usage_str(keyusage):\n        # Return a four-byte string for an RFC 3961 keyusage, using\n        # the RFC 4757 rules.  Per the errata, do not map 9 to 8.\n        table = {3: 8, 23: 13}\n        msusage = table[keyusage] if keyusage in table else keyusage\n        return pack('<I', msusage)\n\n    @classmethod\n    def string_to_key(cls, string, salt, params):\n        utf16string = string.encode('UTF-16LE')\n        return Key(cls.enctype, MD4.new(utf16string).digest())\n\n    @classmethod\n    def encrypt(cls, key, keyusage, plaintext, confounder):\n        if confounder is None:\n            confounder = get_random_bytes(8)\n        ki = HMAC.new(key.contents, cls.usage_str(keyusage), MD5).digest()\n        cksum = HMAC.new(ki, confounder + plaintext, MD5).digest()\n        ke = HMAC.new(ki, cksum, MD5).digest()\n        return cksum + ARC4.new(ke).encrypt(bytes(confounder + plaintext))\n\n    @classmethod\n    def decrypt(cls, key, keyusage, ciphertext):\n        if len(ciphertext) < 24:\n            raise ValueError('ciphertext too short')\n        cksum, basic_ctext = bytearray(ciphertext[:16]), bytearray(ciphertext[16:])\n        ki = HMAC.new(key.contents, cls.usage_str(keyusage), MD5).digest()\n        ke = HMAC.new(ki, cksum, MD5).digest()\n        basic_plaintext = bytearray(ARC4.new(ke).decrypt(bytes(basic_ctext)))\n        exp_cksum = bytearray(HMAC.new(ki, basic_plaintext, MD5).digest())\n        ok = _mac_equal(cksum, exp_cksum)\n        if not ok and keyusage == 9:\n            # Try again with usage 8, due to RFC 4757 errata.\n            ki = HMAC.new(key.contents, pack('<I', 8), MD5).digest()\n            exp_cksum = HMAC.new(ki, basic_plaintext, MD5).digest()\n            ok = _mac_equal(cksum, exp_cksum)\n        if not ok:\n            raise InvalidChecksum('ciphertext integrity failure')\n        # Discard the confounder.\n        return bytes(basic_plaintext[8:])\n\n    @classmethod\n    def prf(cls, key, string):\n        return HMAC.new(key.contents, bytes(string), SHA).digest()",
  "class _ChecksumProfile(object):\n    # Base class for checksum profiles.  Usable checksum classes must\n    # define:\n    #   * checksum\n    #   * verify (if verification is not just checksum-and-compare)\n    @classmethod\n    def verify(cls, key, keyusage, text, cksum):\n        expected = cls.checksum(key, keyusage, text)\n        if not _mac_equal(bytearray(cksum), bytearray(expected)):\n            raise InvalidChecksum('checksum verification failure')",
  "class _SimplifiedChecksum(_ChecksumProfile):\n    # Base class for checksums using the RFC 3961 simplified profile.\n    # Defines the checksum and verify methods.  Subclasses must\n    # define:\n    #   * macsize: Size of checksum in bytes\n    #   * enc: Profile of associated enctype\n\n    @classmethod\n    def checksum(cls, key, keyusage, text):\n        kc = cls.enc.derive(key, pack('>IB', keyusage, 0x99))\n        hmac = HMAC.new(kc.contents, text, cls.enc.hashmod).digest()\n        return hmac[:cls.macsize]\n\n    @classmethod\n    def verify(cls, key, keyusage, text, cksum):\n        if key.enctype != cls.enc.enctype:\n            raise ValueError('Wrong key type for checksum')\n        super(_SimplifiedChecksum, cls).verify(key, keyusage, text, cksum)",
  "class _SHA1AES128(_SimplifiedChecksum):\n    macsize = 12\n    enc = _AES128CTS",
  "class _SHA1AES256(_SimplifiedChecksum):\n    macsize = 12\n    enc = _AES256CTS",
  "class _SHA1DES3(_SimplifiedChecksum):\n    macsize = 20\n    enc = _DES3CBC",
  "class _HMACMD5(_ChecksumProfile):\n    @classmethod\n    def checksum(cls, key, keyusage, text):\n        ksign = HMAC.new(key.contents, b'signaturekey\\0', MD5).digest()\n        md5hash = MD5.new(_RC4.usage_str(keyusage) + text).digest()\n        return HMAC.new(ksign, md5hash, MD5).digest()\n\n    @classmethod\n    def verify(cls, key, keyusage, text, cksum):\n        if key.enctype != Enctype.RC4:\n            raise ValueError('Wrong key type for checksum')\n        super(_HMACMD5, cls).verify(key, keyusage, text, cksum)",
  "def _get_enctype_profile(enctype):\n    if enctype not in _enctype_table:\n        raise ValueError('Invalid enctype %d' % enctype)\n    return _enctype_table[enctype]",
  "def _get_checksum_profile(cksumtype):\n    if cksumtype not in _checksum_table:\n        raise ValueError('Invalid cksumtype %d' % cksumtype)\n    return _checksum_table[cksumtype]",
  "class Key(object):\n    def __init__(self, enctype, contents):\n        e = _get_enctype_profile(enctype)\n        if len(contents) != e.keysize:\n            raise ValueError('Wrong key length')\n        self.enctype = enctype\n        self.contents = contents",
  "def random_to_key(enctype, seed):\n    e = _get_enctype_profile(enctype)\n    if len(seed) != e.seedsize:\n        raise ValueError('Wrong crypto seed length')\n    return e.random_to_key(seed)",
  "def string_to_key(enctype, string, salt, params=None):\n    e = _get_enctype_profile(enctype)\n    return e.string_to_key(string, salt, params)",
  "def encrypt(key, keyusage, plaintext, confounder=None):\n    e = _get_enctype_profile(key.enctype)\n    return e.encrypt(key, keyusage, bytes(plaintext), bytes(confounder))",
  "def decrypt(key, keyusage, ciphertext):\n    # Throw InvalidChecksum on checksum failure.  Throw ValueError on\n    # invalid key enctype or malformed ciphertext.\n    e = _get_enctype_profile(key.enctype)\n    return e.decrypt(key, keyusage, ciphertext)",
  "def prf(key, string):\n    e = _get_enctype_profile(key.enctype)\n    return e.prf(key, string)",
  "def make_checksum(cksumtype, key, keyusage, text):\n    c = _get_checksum_profile(cksumtype)\n    return c.checksum(key, keyusage, text)",
  "def verify_checksum(cksumtype, key, keyusage, text, cksum):\n    # Throw InvalidChecksum exception on checksum failure.  Throw\n    # ValueError on invalid cksumtype, invalid key enctype, or\n    # malformed checksum.\n    c = _get_checksum_profile(cksumtype)\n    c.verify(key, keyusage, text, cksum)",
  "def cf2(enctype, key1, key2, pepper1, pepper2):\n    # Combine two keys and two pepper strings to produce a result key\n    # of type enctype, using the RFC 6113 KRB-FX-CF2 function.\n    def prfplus(key, pepper, l):\n        # Produce l bytes of output using the RFC 6113 PRF+ function.\n        out = b''\n        count = 1\n        while len(out) < l:\n            out += prf(key, b(chr(count)) + pepper)\n            count += 1\n        return out[:l]\n\n    e = _get_enctype_profile(enctype)\n    return e.random_to_key(_xorbytes(bytearray(prfplus(key1, pepper1, e.seedsize)),\n                                     bytearray(prfplus(key2, pepper2, e.seedsize))))",
  "def rotate_right(ba, nbits):\n        ba = bytearray(ba)\n        nbytes, remain = (nbits//8) % len(ba), nbits % 8\n        return bytearray((ba[i-nbytes] >> remain) | ((ba[i-nbytes-1] << (8-remain)) & 0xff) for i in range(len(ba)))",
  "def add_ones_complement(str1, str2):\n        n = len(str1)\n        v = [a + b for a, b in zip(str1, str2)]\n        # Propagate carry bits to the left until there aren't any left.\n        while any(x & ~0xff for x in v):\n            v = [(v[i-n+1]>>8) + (v[i]&0xff) for i in range(n)]\n        return bytearray(x for x in v)",
  "def random_to_key(cls, seed):\n        if len(seed) != cls.seedsize:\n            raise ValueError('Wrong seed length')\n        return Key(cls.enctype, seed)",
  "def derive(cls, key, constant):\n        # RFC 3961 only says to n-fold the constant only if it is\n        # shorter than the cipher block size.  But all Unix\n        # implementations n-fold constants if their length is larger\n        # than the block size as well, and n-folding when the length\n        # is equal to the block size is a no-op.\n        plaintext = _nfold(constant, cls.blocksize)\n        rndseed = b''\n        while len(rndseed) < cls.seedsize:\n            ciphertext = cls.basic_encrypt(key, plaintext)\n            rndseed += ciphertext\n            plaintext = ciphertext\n        return cls.random_to_key(rndseed[0:cls.seedsize])",
  "def encrypt(cls, key, keyusage, plaintext, confounder):\n        ki = cls.derive(key, pack('>IB', keyusage, 0x55))\n        ke = cls.derive(key, pack('>IB', keyusage, 0xAA))\n        if confounder is None:\n            confounder = get_random_bytes(cls.blocksize)\n        basic_plaintext = confounder + _zeropad(plaintext, cls.padsize)\n        hmac = HMAC.new(ki.contents, basic_plaintext, cls.hashmod).digest()\n        return cls.basic_encrypt(ke, basic_plaintext) + hmac[:cls.macsize]",
  "def decrypt(cls, key, keyusage, ciphertext):\n        ki = cls.derive(key, pack('>IB', keyusage, 0x55))\n        ke = cls.derive(key, pack('>IB', keyusage, 0xAA))\n        if len(ciphertext) < cls.blocksize + cls.macsize:\n            raise ValueError('ciphertext too short')\n        basic_ctext, mac = bytearray(ciphertext[:-cls.macsize]), bytearray(ciphertext[-cls.macsize:])\n        if len(basic_ctext) % cls.padsize != 0:\n            raise ValueError('ciphertext does not meet padding requirement')\n        basic_plaintext = cls.basic_decrypt(ke, bytes(basic_ctext))\n        hmac = bytearray(HMAC.new(ki.contents, basic_plaintext, cls.hashmod).digest())\n        expmac = hmac[:cls.macsize]\n        if not _mac_equal(mac, expmac):\n            raise InvalidChecksum('ciphertext integrity failure')\n        # Discard the confounder.\n        return bytes(basic_plaintext[cls.blocksize:])",
  "def prf(cls, key, string):\n        # Hash the input.  RFC 3961 says to truncate to the padding\n        # size, but implementations truncate to the block size.\n        hashval = cls.hashmod.new(string).digest()\n        truncated = hashval[:-(len(hashval) % cls.blocksize)]\n        # Encrypt the hash with a derived key.\n        kp = cls.derive(key, b'prf')\n        return cls.basic_encrypt(kp, truncated)",
  "def encrypt(cls, key, keyusage, plaintext, confounder):\n        if confounder is None:\n            confounder = get_random_bytes(cls.blocksize)\n        basic_plaintext = confounder + b'\\x00'*cls.macsize + _zeropad(plaintext, cls.padsize)\n        checksum = cls.hashmod.new(basic_plaintext).digest()\n        basic_plaintext = basic_plaintext[:len(confounder)] + checksum + basic_plaintext[len(confounder)+len(checksum):]\n        return cls.basic_encrypt(key, basic_plaintext)",
  "def decrypt(cls, key, keyusage, ciphertext):\n        if len(ciphertext) < cls.blocksize + cls.macsize:\n            raise ValueError('ciphertext too short')\n        \n        complex_plaintext = cls.basic_decrypt(key, ciphertext)\n        cofounder = complex_plaintext[:cls.padsize]\n        mac = complex_plaintext[cls.padsize:cls.padsize+cls.macsize]\n        message = complex_plaintext[cls.padsize+cls.macsize:]\n        \n        expmac = cls.hashmod.new(cofounder+b'\\x00'*cls.macsize+message).digest()\n        if not _mac_equal(mac, expmac):\n            raise InvalidChecksum('ciphertext integrity failure')\n        return bytes(message)",
  "def mit_des_string_to_key(cls,string,salt):\n    \n        def fixparity(deskey):\n            temp = b''\n            for i in range(len(deskey)):\n                t = (bin(indexbytes(deskey,i))[2:]).rjust(8,'0')\n                if t[:7].count('1') %2 == 0:\n                    temp+= b(chr(int(t[:7]+'1',2)))\n                else:\n                    temp+= b(chr(int(t[:7]+'0',2)))\n            return temp\n    \n        def addparity(l1):\n            temp = list()\n            for byte in l1:\n                if (bin(byte).count('1') % 2) == 0:\n                    byte = (byte << 1)|0b00000001\n                else:\n                    byte = (byte << 1)&0b11111110\n                temp.append(byte)\n            return temp\n        \n        def XOR(l1,l2):\n            temp = list()\n            for b1,b2 in zip(l1,l2):\n                temp.append((b1^b2)&0b01111111)\n            \n            return temp\n        \n        odd = True\n        tempstring = [0,0,0,0,0,0,0,0]\n        s = _zeropad(string + salt, cls.padsize)\n\n        for block in [s[i:i+8] for i in range(0, len(s), 8)]:\n            temp56 = list()\n            #removeMSBits\n            for byte in block:\n                if PY3:\n                    temp56.append(byte&0b01111111)\n                else:\n                    temp56.append(ord(byte)&0b01111111)\n            \n            #reverse\n            if odd is False:\n                bintemp = b''\n                for byte in temp56:\n                    bintemp += b(bin(byte)[2:].rjust(7,'0'))\n                bintemp = bintemp[::-1]\n                \n                temp56 = list()\n                for bits7 in [bintemp[i:i+7] for i in range(0, len(bintemp), 7)]:\n                    temp56.append(int(bits7,2))\n\n            odd = not odd\n                \n            tempstring = XOR(tempstring,temp56)\n        \n        tempkey = ''.join(chr(byte) for byte in addparity(tempstring))\n        if _is_weak_des_key(tempkey):\n            tempkey[7] = chr(ord(tempkey[7]) ^ 0xF0)\n\n        cipher = DES.new(b(tempkey), DES.MODE_CBC, b(tempkey))\n        checksumkey = cipher.encrypt(s)[-8:]\n        checksumkey = fixparity(checksumkey)\n        if _is_weak_des_key(checksumkey):\n            checksumkey[7] = chr(ord(checksumkey[7]) ^ 0xF0)\n        \n        return Key(cls.enctype, checksumkey)",
  "def basic_encrypt(cls, key, plaintext):\n        assert len(plaintext) % 8 == 0\n        des = DES.new(key.contents, DES.MODE_CBC, b'\\0' * 8)\n        return des.encrypt(bytes(plaintext))",
  "def basic_decrypt(cls, key, ciphertext):\n        assert len(ciphertext) % 8 == 0\n        des = DES.new(key.contents, DES.MODE_CBC, b'\\0' * 8)\n        return des.decrypt(bytes(ciphertext))",
  "def string_to_key(cls, string, salt, params):\n        if params is not None and params != b'':\n            raise ValueError('Invalid DES string-to-key parameters')\n        if not isinstance(string, binary_type):\n            string = string.encode(\"utf-8\")\n        if not isinstance(salt, binary_type):\n            salt = salt.encode(\"utf-8\")\n\n        key = cls.mit_des_string_to_key(string, salt)\n        return key",
  "def random_to_key(cls, seed):\n        # XXX Maybe reframe as _DESEnctype.random_to_key and use that\n        # way from DES3 random-to-key when DES is implemented, since\n        # MIT does this instead of the RFC 3961 random-to-key.\n        def expand(seed):\n            def parity(b):\n                # Return b with the low-order bit set to yield odd parity.\n                b &= ~1\n                return b if bin(b & ~1).count('1') % 2 else b | 1\n            assert len(seed) == 7\n            firstbytes = [parity(b & ~1) for b in seed]\n            lastbyte = parity(sum((seed[i]&1) << i+1 for i in range(7)))\n            keybytes= bytearray(firstbytes + [lastbyte])\n            if _is_weak_des_key(keybytes):\n                keybytes[7] = keybytes[7] ^ 0xF0\n            return bytes(keybytes)\n\n        seed = bytearray(seed)\n        if len(seed) != 21:\n            raise ValueError('Wrong seed length')\n        k1, k2, k3 = expand(seed[:7]), expand(seed[7:14]), expand(seed[14:])\n        return Key(cls.enctype, k1 + k2 + k3)",
  "def string_to_key(cls, string, salt, params):\n        if params is not None and params != b'':\n            raise ValueError('Invalid DES3 string-to-key parameters')\n        if not isinstance(string, binary_type):\n            string = string.encode(\"utf-8\")\n        if not isinstance(salt, binary_type):\n            salt = salt.encode(\"utf-8\")\n\n        k = cls.random_to_key(_nfold(string + salt, 21))\n        return cls.derive(k, b'kerberos')",
  "def basic_encrypt(cls, key, plaintext):\n        assert len(plaintext) % 8 == 0\n        des3 = DES3.new(key.contents, AES.MODE_CBC, b'\\0' * 8)\n        return des3.encrypt(bytes(plaintext))",
  "def basic_decrypt(cls, key, ciphertext):\n        assert len(ciphertext) % 8 == 0\n        des3 = DES3.new(key.contents, AES.MODE_CBC, b'\\0' * 8)\n        return des3.decrypt(bytes(ciphertext))",
  "def string_to_key(cls, string, salt, params):\n        if not isinstance(string, binary_type):\n            string = string.encode(\"utf-8\")\n        if not isinstance(salt, binary_type):\n            salt = salt.encode(\"utf-8\")\n\n        (iterations,) = unpack('>L', params or b'\\x00\\x00\\x10\\x00')\n        prf = lambda p, s: HMAC.new(p, s, SHA).digest()\n        seed = PBKDF2(string, salt, cls.seedsize, iterations, prf)\n        tkey = cls.random_to_key(seed)\n        return cls.derive(tkey, b'kerberos')",
  "def basic_encrypt(cls, key, plaintext):\n        assert len(plaintext) >= 16\n        aes = AES.new(key.contents, AES.MODE_CBC, b'\\0' * 16)\n        ctext = aes.encrypt(_zeropad(bytes(plaintext), 16))\n        if len(plaintext) > 16:\n            # Swap the last two ciphertext blocks and truncate the\n            # final block to match the plaintext length.\n            lastlen = len(plaintext) % 16 or 16\n            ctext = ctext[:-32] + ctext[-16:] + ctext[-32:-16][:lastlen]\n        return ctext",
  "def basic_decrypt(cls, key, ciphertext):\n        assert len(ciphertext) >= 16\n        aes = AES.new(key.contents, AES.MODE_ECB)\n        if len(ciphertext) == 16:\n            return aes.decrypt(ciphertext)\n        # Split the ciphertext into blocks.  The last block may be partial.\n        cblocks = [bytearray(ciphertext[p:p+16]) for p in range(0, len(ciphertext), 16)]\n        lastlen = len(cblocks[-1])\n        # CBC-decrypt all but the last two blocks.\n        prev_cblock = bytearray(16)\n        plaintext = b''\n        for bb in cblocks[:-2]:\n            plaintext += _xorbytes(bytearray(aes.decrypt(bytes(bb))), prev_cblock)\n            prev_cblock = bb\n        # Decrypt the second-to-last cipher block.  The left side of\n        # the decrypted block will be the final block of plaintext\n        # xor'd with the final partial cipher block; the right side\n        # will be the omitted bytes of ciphertext from the final\n        # block.\n        bb = bytearray(aes.decrypt(bytes(cblocks[-2])))\n        lastplaintext =_xorbytes(bb[:lastlen], cblocks[-1])\n        omitted = bb[lastlen:]\n        # Decrypt the final cipher block plus the omitted bytes to get\n        # the second-to-last plaintext block.\n        plaintext += _xorbytes(bytearray(aes.decrypt(bytes(cblocks[-1]) + bytes(omitted))), prev_cblock)\n        return plaintext + lastplaintext",
  "def usage_str(keyusage):\n        # Return a four-byte string for an RFC 3961 keyusage, using\n        # the RFC 4757 rules.  Per the errata, do not map 9 to 8.\n        table = {3: 8, 23: 13}\n        msusage = table[keyusage] if keyusage in table else keyusage\n        return pack('<I', msusage)",
  "def string_to_key(cls, string, salt, params):\n        utf16string = string.encode('UTF-16LE')\n        return Key(cls.enctype, MD4.new(utf16string).digest())",
  "def encrypt(cls, key, keyusage, plaintext, confounder):\n        if confounder is None:\n            confounder = get_random_bytes(8)\n        ki = HMAC.new(key.contents, cls.usage_str(keyusage), MD5).digest()\n        cksum = HMAC.new(ki, confounder + plaintext, MD5).digest()\n        ke = HMAC.new(ki, cksum, MD5).digest()\n        return cksum + ARC4.new(ke).encrypt(bytes(confounder + plaintext))",
  "def decrypt(cls, key, keyusage, ciphertext):\n        if len(ciphertext) < 24:\n            raise ValueError('ciphertext too short')\n        cksum, basic_ctext = bytearray(ciphertext[:16]), bytearray(ciphertext[16:])\n        ki = HMAC.new(key.contents, cls.usage_str(keyusage), MD5).digest()\n        ke = HMAC.new(ki, cksum, MD5).digest()\n        basic_plaintext = bytearray(ARC4.new(ke).decrypt(bytes(basic_ctext)))\n        exp_cksum = bytearray(HMAC.new(ki, basic_plaintext, MD5).digest())\n        ok = _mac_equal(cksum, exp_cksum)\n        if not ok and keyusage == 9:\n            # Try again with usage 8, due to RFC 4757 errata.\n            ki = HMAC.new(key.contents, pack('<I', 8), MD5).digest()\n            exp_cksum = HMAC.new(ki, basic_plaintext, MD5).digest()\n            ok = _mac_equal(cksum, exp_cksum)\n        if not ok:\n            raise InvalidChecksum('ciphertext integrity failure')\n        # Discard the confounder.\n        return bytes(basic_plaintext[8:])",
  "def prf(cls, key, string):\n        return HMAC.new(key.contents, bytes(string), SHA).digest()",
  "def verify(cls, key, keyusage, text, cksum):\n        expected = cls.checksum(key, keyusage, text)\n        if not _mac_equal(bytearray(cksum), bytearray(expected)):\n            raise InvalidChecksum('checksum verification failure')",
  "def checksum(cls, key, keyusage, text):\n        kc = cls.enc.derive(key, pack('>IB', keyusage, 0x99))\n        hmac = HMAC.new(kc.contents, text, cls.enc.hashmod).digest()\n        return hmac[:cls.macsize]",
  "def verify(cls, key, keyusage, text, cksum):\n        if key.enctype != cls.enc.enctype:\n            raise ValueError('Wrong key type for checksum')\n        super(_SimplifiedChecksum, cls).verify(key, keyusage, text, cksum)",
  "def checksum(cls, key, keyusage, text):\n        ksign = HMAC.new(key.contents, b'signaturekey\\0', MD5).digest()\n        md5hash = MD5.new(_RC4.usage_str(keyusage) + text).digest()\n        return HMAC.new(ksign, md5hash, MD5).digest()",
  "def verify(cls, key, keyusage, text, cksum):\n        if key.enctype != Enctype.RC4:\n            raise ValueError('Wrong key type for checksum')\n        super(_HMACMD5, cls).verify(key, keyusage, text, cksum)",
  "def __init__(self, enctype, contents):\n        e = _get_enctype_profile(enctype)\n        if len(contents) != e.keysize:\n            raise ValueError('Wrong key length')\n        self.enctype = enctype\n        self.contents = contents",
  "def prfplus(key, pepper, l):\n        # Produce l bytes of output using the RFC 6113 PRF+ function.\n        out = b''\n        count = 1\n        while len(out) < l:\n            out += prf(key, b(chr(count)) + pepper)\n            count += 1\n        return out[:l]",
  "def fixparity(deskey):\n            temp = b''\n            for i in range(len(deskey)):\n                t = (bin(indexbytes(deskey,i))[2:]).rjust(8,'0')\n                if t[:7].count('1') %2 == 0:\n                    temp+= b(chr(int(t[:7]+'1',2)))\n                else:\n                    temp+= b(chr(int(t[:7]+'0',2)))\n            return temp",
  "def addparity(l1):\n            temp = list()\n            for byte in l1:\n                if (bin(byte).count('1') % 2) == 0:\n                    byte = (byte << 1)|0b00000001\n                else:\n                    byte = (byte << 1)&0b11111110\n                temp.append(byte)\n            return temp",
  "def XOR(l1,l2):\n            temp = list()\n            for b1,b2 in zip(l1,l2):\n                temp.append((b1^b2)&0b01111111)\n            \n            return temp",
  "def expand(seed):\n            def parity(b):\n                # Return b with the low-order bit set to yield odd parity.\n                b &= ~1\n                return b if bin(b & ~1).count('1') % 2 else b | 1\n            assert len(seed) == 7\n            firstbytes = [parity(b & ~1) for b in seed]\n            lastbyte = parity(sum((seed[i]&1) << i+1 for i in range(7)))\n            keybytes= bytearray(firstbytes + [lastbyte])\n            if _is_weak_des_key(keybytes):\n                keybytes[7] = keybytes[7] ^ 0xF0\n            return bytes(keybytes)",
  "def parity(b):\n                # Return b with the low-order bit set to yield odd parity.\n                b &= ~1\n                return b if bin(b & ~1).count('1') % 2 else b | 1",
  "class KerberosException(Exception):\n    pass",
  "def _asn1_decode(data, asn1Spec):\n    if isinstance(data, str) or isinstance(data,bytes):\n        data, substrate = decoder.decode(data, asn1Spec=asn1Spec)\n        if substrate != b'':\n            raise KerberosException(\"asn1 encoding invalid\")\n    return data",
  "class Principal(object):\n    \"\"\"The principal's value can be supplied as:\n* a single string\n* a sequence containing a sequence of component strings and a realm string\n* a sequence whose first n-1 elemeents are component strings and whose last\n  component is the realm\n\nIf the value contains no realm, then default_realm will be used.\"\"\"\n    def __init__(self, value=None, default_realm=None, type=None):\n        self.type = constants.PrincipalNameType.NT_UNKNOWN\n        self.components = []\n        self.realm = None\n\n        if value is None:\n            return\n\n        try:               # Python 2\n            if isinstance(value, unicode):\n                value = value.encode('utf-8')\n        except NameError:  # Python 3\n            if isinstance(value, bytes):\n                value = value.decode('utf-8')\n\n        if isinstance(value, Principal):\n            self.type = value.type\n            self.components = value.components[:]\n            self.realm = value.realm\n        elif isinstance(value, str):\n            m = re.match(r'((?:[^\\\\]|\\\\.)+?)(@((?:[^\\\\@]|\\\\.)+))?$', value)\n            if not m:\n                raise KerberosException(\"invalid principal syntax\")\n\n            def unquote_component(comp):\n                return re.sub(r'\\\\(.)', r'\\1', comp)\n\n            if m.group(2) is not None:\n                self.realm = unquote_component(m.group(3))\n            else:\n                self.realm = default_realm\n\n            self.components = [\n                unquote_component(qc)\n                for qc in re.findall(r'(?:[^\\\\/]|\\\\.)+', m.group(1))]\n        elif len(value) == 2:\n            self.components = value[0]\n            self.realm = value[-1]\n            if isinstance(self.components, str):\n                self.components = [self.components]\n        elif len(value) >= 2:\n            self.components = value[0:-1]\n            self.realm = value[-1]\n        else:\n            raise KerberosException(\"invalid principal value\")\n\n        if type is not None:\n            self.type = type\n\n    def __eq__(self, other):\n        if isinstance (other, str):\n            other = Principal (other)\n\n        return (self.type == constants.PrincipalNameType.NT_UNKNOWN.value or\n                other.type == constants.PrincipalNameType.NT_UNKNOWN.value or\n                self.type == other.type) and all (map (lambda a, b: a == b, self.components, other.components)) and \\\n               self.realm == other.realm\n\n    def __str__(self):\n        def quote_component(comp):\n            return re.sub(r'([\\\\/@])', r'\\\\\\1', comp)\n\n        ret = \"/\".join([quote_component(c) for c in self.components])\n        if self.realm is not None:\n            ret += \"@\" + self.realm\n\n        return ret\n\n    def __repr__(self):\n        return \"Principal((\" + repr(self.components) + \", \" + \\\n               repr(self.realm) + \"), t=\" + str(self.type) + \")\"\n\n    def from_asn1(self, data, realm_component, name_component):\n        name = data.getComponentByName(name_component)\n        self.type = constants.PrincipalNameType(\n            name.getComponentByName('name-type')).value\n        self.components = [\n            str(c) for c in name.getComponentByName('name-string')]\n        self.realm = str(data.getComponentByName(realm_component))\n        return self\n\n    def components_to_asn1(self, name):\n        name.setComponentByName('name-type', int(self.type))\n        strings = name.setComponentByName('name-string'\n                                          ).getComponentByName('name-string')\n        for i, c in enumerate(self.components):\n            strings.setComponentByPosition(i, c)\n\n        return name",
  "class Address(object):\n    DIRECTIONAL_AP_REQ_SENDER = struct.pack('!I', 0)\n    DIRECTIONAL_AP_REQ_RECIPIENT = struct.pack('!I', 1)\n\n    def __init__(self):\n        self.type = None\n        self.data = None\n\n    def __str__(self):\n        family = self.family\n\n        if family is not None:\n            return str((family, self.address))\n        else:\n            return str((self.type, self.value))\n\n    @property\n    def family(self):\n        if self.type == constants.AddressType.IPv4.value:\n            return socket.AF_INET\n        elif self.type == constants.AddressType.IPv4.value:\n            return socket.AF_INET6\n        else:\n            return None\n\n    @property\n    def address(self):\n        if self.type == constants.AddressType.IPv4.value:\n            return socket.inet_pton(self.family, self.data)\n        elif self.type == constants.AddressType.IPv4.value:\n            return socket.inet_pton(self.family, self.data)\n        else:\n            return None\n\n    def encode(self):\n        # ipv4-mapped ipv6 addresses must be encoded as ipv4.\n        pass",
  "class EncryptedData(object):\n    def __init__(self):\n        self.etype = None\n        self.kvno = None\n        self.ciphertext = None\n\n    def from_asn1(self, data):\n        data = _asn1_decode(data, asn1.EncryptedData())\n        self.etype = constants.EncryptionTypes(data.getComponentByName('etype')).value\n        kvno = data.getComponentByName('kvno')\n        if (kvno is None) or (kvno.hasValue() is False):\n            self.kvno = False\n        else:\n            self.kvno = kvno\n        self.ciphertext = str(data.getComponentByName('cipher'))\n        return self\n\n    def to_asn1(self, component):\n        component.setComponentByName('etype', int(self.etype))\n        if self.kvno:\n            component.setComponentByName('kvno', self.kvno)\n        component.setComponentByName('cipher', self.ciphertext)\n        return component",
  "class Ticket(object):\n    def __init__(self):\n        # This is the kerberos version, not the service principal key\n        # version number.\n        self.tkt_vno = None\n        self.service_principal = None\n        self.encrypted_part = None\n\n    def from_asn1(self, data):\n        data = _asn1_decode(data, asn1.Ticket())\n        self.tkt_vno = int(data.getComponentByName('tkt-vno'))\n        self.service_principal = Principal()\n        self.service_principal.from_asn1(data, 'realm', 'sname')\n        self.encrypted_part = EncryptedData()\n        self.encrypted_part.from_asn1(data.getComponentByName('enc-part'))\n        return self\n\n    def to_asn1(self, component):\n        component.setComponentByName('tkt-vno', 5)\n        component.setComponentByName('realm', self.service_principal.realm)\n        asn1.seq_set(component, 'sname',\n                     self.service_principal.components_to_asn1)\n        asn1.seq_set(component, 'enc-part', self.encrypted_part.to_asn1)\n        return component\n\n    def __str__(self):\n        return \"<Ticket for %s vno %s>\" % (str(self.service_principal), str(self.encrypted_part.kvno))",
  "class KerberosTime(object):\n    INDEFINITE = datetime.datetime(1970, 1, 1, 0, 0, 0)\n\n    @staticmethod\n    def to_asn1(dt):\n        # A KerberosTime is really just a string, so we can return a\n        # string here, and the asn1 library will convert it correctly.\n\n        return \"%04d%02d%02d%02d%02d%02dZ\" % (dt.year, dt.month, dt.day, dt.hour, dt.minute, dt.second)\n\n    @staticmethod\n    def from_asn1(data):\n        data = str(data)\n        year = int(data[0:4])\n        month = int(data[4:6])\n        day = int(data[6:8])\n        hour = int(data[8:10])\n        minute = int(data[10:12])\n        second = int(data[12:14])\n        if data[14] != 'Z':\n            raise KerberosException(\"timezone in KerberosTime is not Z\")\n        return datetime.datetime(year, month, day, hour, minute, second)",
  "def __init__(self, value=None, default_realm=None, type=None):\n        self.type = constants.PrincipalNameType.NT_UNKNOWN\n        self.components = []\n        self.realm = None\n\n        if value is None:\n            return\n\n        try:               # Python 2\n            if isinstance(value, unicode):\n                value = value.encode('utf-8')\n        except NameError:  # Python 3\n            if isinstance(value, bytes):\n                value = value.decode('utf-8')\n\n        if isinstance(value, Principal):\n            self.type = value.type\n            self.components = value.components[:]\n            self.realm = value.realm\n        elif isinstance(value, str):\n            m = re.match(r'((?:[^\\\\]|\\\\.)+?)(@((?:[^\\\\@]|\\\\.)+))?$', value)\n            if not m:\n                raise KerberosException(\"invalid principal syntax\")\n\n            def unquote_component(comp):\n                return re.sub(r'\\\\(.)', r'\\1', comp)\n\n            if m.group(2) is not None:\n                self.realm = unquote_component(m.group(3))\n            else:\n                self.realm = default_realm\n\n            self.components = [\n                unquote_component(qc)\n                for qc in re.findall(r'(?:[^\\\\/]|\\\\.)+', m.group(1))]\n        elif len(value) == 2:\n            self.components = value[0]\n            self.realm = value[-1]\n            if isinstance(self.components, str):\n                self.components = [self.components]\n        elif len(value) >= 2:\n            self.components = value[0:-1]\n            self.realm = value[-1]\n        else:\n            raise KerberosException(\"invalid principal value\")\n\n        if type is not None:\n            self.type = type",
  "def __eq__(self, other):\n        if isinstance (other, str):\n            other = Principal (other)\n\n        return (self.type == constants.PrincipalNameType.NT_UNKNOWN.value or\n                other.type == constants.PrincipalNameType.NT_UNKNOWN.value or\n                self.type == other.type) and all (map (lambda a, b: a == b, self.components, other.components)) and \\\n               self.realm == other.realm",
  "def __str__(self):\n        def quote_component(comp):\n            return re.sub(r'([\\\\/@])', r'\\\\\\1', comp)\n\n        ret = \"/\".join([quote_component(c) for c in self.components])\n        if self.realm is not None:\n            ret += \"@\" + self.realm\n\n        return ret",
  "def __repr__(self):\n        return \"Principal((\" + repr(self.components) + \", \" + \\\n               repr(self.realm) + \"), t=\" + str(self.type) + \")\"",
  "def from_asn1(self, data, realm_component, name_component):\n        name = data.getComponentByName(name_component)\n        self.type = constants.PrincipalNameType(\n            name.getComponentByName('name-type')).value\n        self.components = [\n            str(c) for c in name.getComponentByName('name-string')]\n        self.realm = str(data.getComponentByName(realm_component))\n        return self",
  "def components_to_asn1(self, name):\n        name.setComponentByName('name-type', int(self.type))\n        strings = name.setComponentByName('name-string'\n                                          ).getComponentByName('name-string')\n        for i, c in enumerate(self.components):\n            strings.setComponentByPosition(i, c)\n\n        return name",
  "def __init__(self):\n        self.type = None\n        self.data = None",
  "def __str__(self):\n        family = self.family\n\n        if family is not None:\n            return str((family, self.address))\n        else:\n            return str((self.type, self.value))",
  "def family(self):\n        if self.type == constants.AddressType.IPv4.value:\n            return socket.AF_INET\n        elif self.type == constants.AddressType.IPv4.value:\n            return socket.AF_INET6\n        else:\n            return None",
  "def address(self):\n        if self.type == constants.AddressType.IPv4.value:\n            return socket.inet_pton(self.family, self.data)\n        elif self.type == constants.AddressType.IPv4.value:\n            return socket.inet_pton(self.family, self.data)\n        else:\n            return None",
  "def encode(self):\n        # ipv4-mapped ipv6 addresses must be encoded as ipv4.\n        pass",
  "def __init__(self):\n        self.etype = None\n        self.kvno = None\n        self.ciphertext = None",
  "def from_asn1(self, data):\n        data = _asn1_decode(data, asn1.EncryptedData())\n        self.etype = constants.EncryptionTypes(data.getComponentByName('etype')).value\n        kvno = data.getComponentByName('kvno')\n        if (kvno is None) or (kvno.hasValue() is False):\n            self.kvno = False\n        else:\n            self.kvno = kvno\n        self.ciphertext = str(data.getComponentByName('cipher'))\n        return self",
  "def to_asn1(self, component):\n        component.setComponentByName('etype', int(self.etype))\n        if self.kvno:\n            component.setComponentByName('kvno', self.kvno)\n        component.setComponentByName('cipher', self.ciphertext)\n        return component",
  "def __init__(self):\n        # This is the kerberos version, not the service principal key\n        # version number.\n        self.tkt_vno = None\n        self.service_principal = None\n        self.encrypted_part = None",
  "def from_asn1(self, data):\n        data = _asn1_decode(data, asn1.Ticket())\n        self.tkt_vno = int(data.getComponentByName('tkt-vno'))\n        self.service_principal = Principal()\n        self.service_principal.from_asn1(data, 'realm', 'sname')\n        self.encrypted_part = EncryptedData()\n        self.encrypted_part.from_asn1(data.getComponentByName('enc-part'))\n        return self",
  "def to_asn1(self, component):\n        component.setComponentByName('tkt-vno', 5)\n        component.setComponentByName('realm', self.service_principal.realm)\n        asn1.seq_set(component, 'sname',\n                     self.service_principal.components_to_asn1)\n        asn1.seq_set(component, 'enc-part', self.encrypted_part.to_asn1)\n        return component",
  "def __str__(self):\n        return \"<Ticket for %s vno %s>\" % (str(self.service_principal), str(self.encrypted_part.kvno))",
  "def to_asn1(dt):\n        # A KerberosTime is really just a string, so we can return a\n        # string here, and the asn1 library will convert it correctly.\n\n        return \"%04d%02d%02d%02d%02d%02dZ\" % (dt.year, dt.month, dt.day, dt.hour, dt.minute, dt.second)",
  "def from_asn1(data):\n        data = str(data)\n        year = int(data[0:4])\n        month = int(data[4:6])\n        day = int(data[6:8])\n        hour = int(data[8:10])\n        minute = int(data[10:12])\n        second = int(data[12:14])\n        if data[14] != 'Z':\n            raise KerberosException(\"timezone in KerberosTime is not Z\")\n        return datetime.datetime(year, month, day, hour, minute, second)",
  "def quote_component(comp):\n            return re.sub(r'([\\\\/@])', r'\\\\\\1', comp)",
  "def unquote_component(comp):\n                return re.sub(r'\\\\(.)', r'\\1', comp)",
  "class KERB_SID_AND_ATTRIBUTES(NDRSTRUCT):\n    structure = (\n        ('Sid', PISID),\n        ('Attributes', ULONG),\n    )",
  "class KERB_SID_AND_ATTRIBUTES_ARRAY(NDRUniConformantArray):\n    item = KERB_SID_AND_ATTRIBUTES",
  "class PKERB_SID_AND_ATTRIBUTES_ARRAY(NDRPOINTER):\n    referent = (\n        ('Data', KERB_SID_AND_ATTRIBUTES_ARRAY),\n    )",
  "class DOMAIN_GROUP_MEMBERSHIP(NDRSTRUCT):\n    structure = (\n        ('DomainId', PISID),\n        ('GroupCount', ULONG),\n        ('GroupIds', PGROUP_MEMBERSHIP_ARRAY),\n    )",
  "class DOMAIN_GROUP_MEMBERSHIP_ARRAY(NDRUniConformantArray):\n    item = DOMAIN_GROUP_MEMBERSHIP",
  "class PDOMAIN_GROUP_MEMBERSHIP_ARRAY(NDRPOINTER):\n    referent = (\n        ('Data', KERB_SID_AND_ATTRIBUTES_ARRAY),\n    )",
  "class PACTYPE(Structure):\n    structure = (\n        ('cBuffers', '<L=0'),\n        ('Version', '<L=0'),\n        ('Buffers', ':'),\n    )",
  "class PAC_INFO_BUFFER(Structure):\n    structure = (\n        ('ulType', '<L=0'),\n        ('cbBufferSize', '<L=0'),\n        ('Offset', '<Q=0'),\n    )",
  "class KERB_VALIDATION_INFO(NDRSTRUCT):\n    structure = (\n        ('LogonTime', FILETIME),\n        ('LogoffTime', FILETIME),\n        ('KickOffTime', FILETIME),\n        ('PasswordLastSet', FILETIME),\n        ('PasswordCanChange', FILETIME),\n        ('PasswordMustChange', FILETIME),\n        ('EffectiveName', RPC_UNICODE_STRING),\n        ('FullName', RPC_UNICODE_STRING),\n        ('LogonScript', RPC_UNICODE_STRING),\n        ('ProfilePath', RPC_UNICODE_STRING),\n        ('HomeDirectory', RPC_UNICODE_STRING),\n        ('HomeDirectoryDrive', RPC_UNICODE_STRING),\n        ('LogonCount', USHORT),\n        ('BadPasswordCount', USHORT),\n        ('UserId', ULONG),\n        ('PrimaryGroupId', ULONG),\n        ('GroupCount', ULONG),\n        ('GroupIds', PGROUP_MEMBERSHIP_ARRAY),\n        ('UserFlags', ULONG),\n        ('UserSessionKey', USER_SESSION_KEY),\n        ('LogonServer', RPC_UNICODE_STRING),\n        ('LogonDomainName', RPC_UNICODE_STRING),\n        ('LogonDomainId', PRPC_SID),\n\n        # Also called Reserved1\n        ('LMKey', CHAR_FIXED_8_ARRAY),\n\n        ('UserAccountControl', ULONG),\n        ('SubAuthStatus', ULONG),\n        ('LastSuccessfulILogon', FILETIME),\n        ('LastFailedILogon', FILETIME),\n        ('FailedILogonCount', ULONG),\n        ('Reserved3', ULONG),\n\n        ('SidCount', ULONG),\n        #('ExtraSids', PNETLOGON_SID_AND_ATTRIBUTES_ARRAY),\n        ('ExtraSids', PKERB_SID_AND_ATTRIBUTES_ARRAY),\n        ('ResourceGroupDomainSid', PISID),\n        ('ResourceGroupCount', ULONG),\n        ('ResourceGroupIds', PGROUP_MEMBERSHIP_ARRAY),\n    )",
  "class PKERB_VALIDATION_INFO(NDRPOINTER):\n    referent = (\n        ('Data', KERB_VALIDATION_INFO),\n    )",
  "class PAC_CREDENTIAL_INFO(Structure):\n    structure = (\n        ('Version', '<L=0'),\n        ('EncryptionType', '<L=0'),\n        ('SerializedData', ':'),\n    )",
  "class SECPKG_SUPPLEMENTAL_CRED(NDRSTRUCT):\n    structure = (\n        ('PackageName', RPC_UNICODE_STRING),\n        ('CredentialSize', ULONG),\n        ('Credentials', PUCHAR_ARRAY),\n    )",
  "class SECPKG_SUPPLEMENTAL_CRED_ARRAY(NDRUniConformantArray):\n    item = SECPKG_SUPPLEMENTAL_CRED",
  "class PAC_CREDENTIAL_DATA(NDRSTRUCT):\n    structure = (\n        ('CredentialCount', ULONG),\n        ('Credentials', SECPKG_SUPPLEMENTAL_CRED_ARRAY),\n    )",
  "class NTLM_SUPPLEMENTAL_CREDENTIAL(NDRSTRUCT):\n    structure = (\n        ('Version', ULONG),\n        ('Flags', ULONG),\n        ('LmPassword', '16s=b\"\"'),\n        ('NtPassword', '16s=b\"\"'),\n    )",
  "class PAC_CLIENT_INFO(Structure):\n    structure = (\n        ('ClientId', '<Q=0'),\n        ('NameLength', '<H=0'),\n        ('_Name', '_-Name', 'self[\"NameLength\"]'),\n        ('Name', ':'),\n    )",
  "class PAC_SIGNATURE_DATA(Structure):\n    structure = (\n        ('SignatureType', '<l=0'),\n        ('Signature', ':'),\n    )",
  "class S4U_DELEGATION_INFO(NDRSTRUCT):\n    structure = (\n        ('S4U2proxyTarget', RPC_UNICODE_STRING),\n        ('TransitedListSize', ULONG),\n        ('S4UTransitedServices', PRPC_UNICODE_STRING_ARRAY ),\n    )",
  "class UPN_DNS_INFO(Structure):\n    structure = (\n        ('UpnLength', '<H=0'),\n        ('UpnOffset', '<H=0'),\n        ('DnsDomainNameLength', '<H=0'),\n        ('DnsDomainNameOffset', '<H=0'),\n        ('Flags', '<L=0')\n    )",
  "class UPN_DNS_INFO_FULL(Structure):\n    structure = (\n        ('UpnLength', '<H=0'),\n        ('UpnOffset', '<H=0'),\n        ('DnsDomainNameLength', '<H=0'),\n        ('DnsDomainNameOffset', '<H=0'),\n        ('Flags', '<L=0'),\n        ('SamNameLength', '<H=0'),\n        ('SamNameOffset', '<H=0'),\n        ('SidLength', '<H=0'),\n        ('SidOffset', '<H=0'),\n    )",
  "class PAC_CLIENT_CLAIMS_INFO(Structure):\n    structure = (\n        ('Claims', ':'),\n    )",
  "class PAC_DEVICE_INFO(NDRSTRUCT):\n    structure = (\n        ('UserId', ULONG),\n        ('PrimaryGroupId', ULONG),\n        ('AccountDomainId', PISID ),\n        ('AccountGroupCount', ULONG ),\n        ('AccountGroupIds', PGROUP_MEMBERSHIP_ARRAY ),\n        ('SidCount', ULONG ),\n        ('ExtraSids', PKERB_SID_AND_ATTRIBUTES_ARRAY ),\n        ('DomainGroupCount', ULONG ),\n        ('DomainGroup', PDOMAIN_GROUP_MEMBERSHIP_ARRAY ),\n    )",
  "class PAC_DEVICE_CLAIMS_INFO(Structure):\n    structure = (\n        ('Claims', ':'),\n    )",
  "class VALIDATION_INFO(TypeSerialization1):\n    structure = (\n        ('Data', PKERB_VALIDATION_INFO),\n    )",
  "class PAC_ATTRIBUTE_INFO(NDRSTRUCT):\n    structure = (\n        ('FlagsLength', ULONG),\n        ('Flags', ULONG),\n    )",
  "class PAC_REQUESTOR(Structure):\n    structure = (\n        ('UserSid',':',SID),\n    )",
  "class CheckSumField(Structure):\n    structure = (\n        ('Lgth','<L=16'),\n        ('Bnd','16s=b\"\"'),\n        ('Flags','<L=0'),\n    )",
  "def GSSAPI(cipher):\n    if cipher.enctype == constants.EncryptionTypes.aes256_cts_hmac_sha1_96.value:\n        return GSSAPI_AES256()\n    if cipher.enctype == constants.EncryptionTypes.aes128_cts_hmac_sha1_96.value:\n        return GSSAPI_AES128()\n    elif cipher.enctype == constants.EncryptionTypes.rc4_hmac.value:\n        return GSSAPI_RC4()\n    else:\n        raise Exception('Unsupported etype 0x%x' % cipher.enctype)",
  "class GSSAPI_RC4:\n    # 1.2.1. Per-message Tokens - MIC\n    class MIC(Structure):\n        structure = (\n            ('TOK_ID','<H=0x0101'),\n            ('SGN_ALG','<H=0'),\n            ('Filler','<L=0xffffffff'),\n            ('SND_SEQ','8s=b\"\"'),\n            ('SGN_CKSUM','8s=b\"\"'),\n        )\n\n    # 1.2.2. Per-message Tokens - Wrap\n    class WRAP(Structure):\n        structure = (\n            ('TOK_ID','<H=0x0102'),\n            ('SGN_ALG','<H=0'),\n            ('SEAL_ALG','<H=0'),\n            ('Filler','<H=0xffff'),\n            ('SND_SEQ','8s=b\"\"'),\n            ('SGN_CKSUM','8s=b\"\"'),\n            ('Confounder','8s=b\"\"'),\n        )\n\n    def GSS_GetMIC(self, sessionKey, data, sequenceNumber, direction = 'init'):\n        GSS_GETMIC_HEADER = b'\\x60\\x23\\x06\\x09\\x2a\\x86\\x48\\x86\\xf7\\x12\\x01\\x02\\x02'\n        token = self.MIC()\n\n        # Let's pad the data\n        pad = (4 - (len(data) % 4)) & 0x3\n        padStr = b(chr(pad)) * pad\n        data += padStr\n \n        token['SGN_ALG'] = GSS_HMAC\n        if direction == 'init':\n            token['SND_SEQ'] = struct.pack('>L', sequenceNumber) + b'\\x00'*4\n        else:\n            token['SND_SEQ'] = struct.pack('>L', sequenceNumber) + b'\\xff'*4\n\n        Ksign = HMAC.new(sessionKey.contents, b'signaturekey\\0', MD5).digest()\n        Sgn_Cksum = MD5.new( struct.pack('<L',15) + token.getData()[:8] + data).digest()\n        Sgn_Cksum = HMAC.new(Ksign, Sgn_Cksum, MD5).digest()\n        token['SGN_CKSUM'] = Sgn_Cksum[:8]\n\n        Kseq = HMAC.new(sessionKey.contents, struct.pack('<L',0), MD5).digest()\n        Kseq = HMAC.new(Kseq, token['SGN_CKSUM'], MD5).digest()\n        token['SND_SEQ'] = ARC4.new(Kseq).encrypt(token['SND_SEQ'])\n        finalData = GSS_GETMIC_HEADER + token.getData()\n        return finalData\n   \n    def GSS_Wrap(self, sessionKey, data, sequenceNumber, direction = 'init', encrypt=True, authData=None):\n        # Damn inacurate RFC, useful info from here\n        # https://social.msdn.microsoft.com/Forums/en-US/fb98e8f4-e697-4652-bcb7-604e027e14cc/gsswrap-token-size-kerberos-and-rc4hmac?forum=os_windowsprotocols\n        # and here\n        # http://www.rfc-editor.org/errata_search.php?rfc=4757\n        GSS_WRAP_HEADER = b'\\x60\\x2b\\x06\\x09\\x2a\\x86\\x48\\x86\\xf7\\x12\\x01\\x02\\x02'\n        token = self.WRAP()\n\n        # Let's pad the data\n        pad = (8 - (len(data) % 8)) & 0x7\n        padStr = b(chr(pad)) * pad\n        data += padStr\n\n        token['SGN_ALG'] = GSS_HMAC\n        token['SEAL_ALG'] = GSS_RC4\n\n        if direction == 'init':\n            token['SND_SEQ'] = struct.pack('>L', sequenceNumber) + b'\\x00'*4\n        else:\n            token['SND_SEQ'] = struct.pack('>L', sequenceNumber) + b'\\xff'*4\n\n        # Random confounder :)\n        token['Confounder'] = b(''.join([rand.choice(string.ascii_letters) for _ in range(8)]))\n\n        Ksign = HMAC.new(sessionKey.contents, b'signaturekey\\0', MD5).digest()\n        Sgn_Cksum = MD5.new(struct.pack('<L',13) + token.getData()[:8] + token['Confounder'] + data).digest()\n\n        Klocal = bytearray()\n        from builtins import bytes\n        for n in bytes(sessionKey.contents):\n            Klocal.append( n ^ 0xF0)\n\n        Kcrypt = HMAC.new(Klocal,struct.pack('<L',0), MD5).digest()\n        Kcrypt = HMAC.new(Kcrypt,struct.pack('>L', sequenceNumber), MD5).digest()\n        \n        Sgn_Cksum = HMAC.new(Ksign, Sgn_Cksum, MD5).digest()\n\n        token['SGN_CKSUM'] = Sgn_Cksum[:8]\n\n        Kseq = HMAC.new(sessionKey.contents, struct.pack('<L',0), MD5).digest()\n        Kseq = HMAC.new(Kseq, token['SGN_CKSUM'], MD5).digest()\n\n        token['SND_SEQ'] = ARC4.new(Kseq).encrypt(token['SND_SEQ'])\n\n        if authData is not None:\n            from impacket.dcerpc.v5.rpcrt import SEC_TRAILER\n            wrap = self.WRAP(authData[len(SEC_TRAILER()) + len(GSS_WRAP_HEADER):])\n            snd_seq = wrap['SND_SEQ']\n\n            Kseq = HMAC.new(sessionKey.contents, struct.pack('<L',0), MD5).digest()\n            Kseq = HMAC.new(Kseq, wrap['SGN_CKSUM'], MD5).digest()\n\n            snd_seq = ARC4.new(Kseq).encrypt(wrap['SND_SEQ'])\n \n            Kcrypt = HMAC.new(Klocal,struct.pack('<L',0), MD5).digest()\n            Kcrypt = HMAC.new(Kcrypt,snd_seq[:4], MD5).digest()\n            rc4 = ARC4.new(Kcrypt)\n            cipherText = rc4.decrypt(token['Confounder'] + data)[8:]\n        elif encrypt is True:\n            rc4 = ARC4.new(Kcrypt)\n            token['Confounder'] = rc4.encrypt(token['Confounder'])\n            cipherText = rc4.encrypt(data)\n        else:\n            cipherText = data\n\n        finalData = GSS_WRAP_HEADER + token.getData()\n        return cipherText, finalData\n\n    def GSS_Unwrap(self, sessionKey, data, sequenceNumber, direction = 'init', encrypt=True, authData=None):\n        return self.GSS_Wrap(sessionKey, data, sequenceNumber, direction, encrypt, authData)",
  "class GSSAPI_AES():\n    checkSumProfile = None\n    cipherType = None\n\n    class MIC(Structure):\n        structure = (\n            ('TOK_ID','>H=0x0404'),\n            ('Flags','B=0'),\n            ('Filler0','B=0xff'),\n            ('Filler','>L=0xffffffff'),\n            ('SND_SEQ','8s=b\"\"'),\n            ('SGN_CKSUM','12s=b\"\"'),\n        )\n\n    # 1.2.2. Per-message Tokens - Wrap\n    class WRAP(Structure):\n        structure = (\n            ('TOK_ID','>H=0x0504'),\n            ('Flags','B=0'),\n            ('Filler','B=0xff'),\n            ('EC','>H=0'),\n            ('RRC','>H=0'),\n            ('SND_SEQ','8s=b\"\"'),\n        )\n\n    def GSS_GetMIC(self, sessionKey, data, sequenceNumber, direction = 'init'):\n        token = self.MIC()\n\n        # Let's pad the data\n        pad = (4 - (len(data) % 4)) & 0x3\n        padStr = chr(pad) * pad\n        data += padStr\n\n        checkSumProfile = self.checkSumProfile()\n\n        token['Flags'] = 4\n        token['SND_SEQ'] = struct.pack('>Q',sequenceNumber)\n        token['SGN_CKSUM'] = checkSumProfile.checksum(sessionKey, KG_USAGE_INITIATOR_SIGN, data + token.getData()[:16])\n \n        return token.getData()\n   \n    def rotate(self, data, numBytes):\n        numBytes %= len(data)\n        left = len(data) - numBytes\n        result = data[left:] + data[:left]\n        return result\n\n    def unrotate(self, data, numBytes):\n        numBytes %= len(data)\n        result = data[numBytes:] + data[:numBytes]\n        return result\n        \n    def GSS_Wrap(self, sessionKey, data, sequenceNumber, direction = 'init', encrypt=True):\n        token = self.WRAP()\n\n        cipher = self.cipherType()\n\n        # Let's pad the data\n        pad = (cipher.blocksize - (len(data) % cipher.blocksize)) & 15\n        padStr = b'\\xFF' * pad\n        data += padStr\n\n        # The RRC field ([RFC4121] section 4.2.5) is 12 if no encryption is requested or 28 if encryption \n        # is requested. The RRC field is chosen such that all the data can be encrypted in place.\n        rrc = 28\n\n        token['Flags'] = 6\n        token['EC'] = pad\n        token['RRC'] = 0\n        token['SND_SEQ'] = struct.pack('>Q',sequenceNumber)\n\n        cipherText = cipher.encrypt(sessionKey, KG_USAGE_INITIATOR_SEAL,  data + token.getData(), None)\n        token['RRC'] = rrc\n\n        cipherText = self.rotate(cipherText, token['RRC'] + token['EC'])\n\n        #nn = self.unrotate(cipherText, token['RRC'] + token['EC'])\n        ret1 = cipherText[len(self.WRAP()) + token['RRC'] + token['EC']:]\n        ret2 = token.getData() + cipherText[:len(self.WRAP()) + token['RRC'] + token['EC']]\n\n        return ret1, ret2\n\n    def GSS_Unwrap(self, sessionKey, data, sequenceNumber, direction = 'init', encrypt=True, authData=None):\n        from impacket.dcerpc.v5.rpcrt import SEC_TRAILER\n\n        cipher = self.cipherType()\n        token = self.WRAP(authData[len(SEC_TRAILER()):])\n\n        rotated = authData[len(self.WRAP())+len(SEC_TRAILER()):] + data\n \n        cipherText = self.unrotate(rotated, token['RRC'] + token['EC'])\n        plainText = cipher.decrypt(sessionKey, KG_USAGE_ACCEPTOR_SEAL,  cipherText)\n\n        return plainText[:-(token['EC']+len(self.WRAP()))], None",
  "class GSSAPI_AES256(GSSAPI_AES):\n    checkSumProfile = crypto._SHA1AES256\n    cipherType = crypto._AES256CTS",
  "class GSSAPI_AES128(GSSAPI_AES):\n    checkSumProfile = crypto._SHA1AES128\n    cipherType = crypto._AES128CTS",
  "class MIC(Structure):\n        structure = (\n            ('TOK_ID','<H=0x0101'),\n            ('SGN_ALG','<H=0'),\n            ('Filler','<L=0xffffffff'),\n            ('SND_SEQ','8s=b\"\"'),\n            ('SGN_CKSUM','8s=b\"\"'),\n        )",
  "class WRAP(Structure):\n        structure = (\n            ('TOK_ID','<H=0x0102'),\n            ('SGN_ALG','<H=0'),\n            ('SEAL_ALG','<H=0'),\n            ('Filler','<H=0xffff'),\n            ('SND_SEQ','8s=b\"\"'),\n            ('SGN_CKSUM','8s=b\"\"'),\n            ('Confounder','8s=b\"\"'),\n        )",
  "def GSS_GetMIC(self, sessionKey, data, sequenceNumber, direction = 'init'):\n        GSS_GETMIC_HEADER = b'\\x60\\x23\\x06\\x09\\x2a\\x86\\x48\\x86\\xf7\\x12\\x01\\x02\\x02'\n        token = self.MIC()\n\n        # Let's pad the data\n        pad = (4 - (len(data) % 4)) & 0x3\n        padStr = b(chr(pad)) * pad\n        data += padStr\n \n        token['SGN_ALG'] = GSS_HMAC\n        if direction == 'init':\n            token['SND_SEQ'] = struct.pack('>L', sequenceNumber) + b'\\x00'*4\n        else:\n            token['SND_SEQ'] = struct.pack('>L', sequenceNumber) + b'\\xff'*4\n\n        Ksign = HMAC.new(sessionKey.contents, b'signaturekey\\0', MD5).digest()\n        Sgn_Cksum = MD5.new( struct.pack('<L',15) + token.getData()[:8] + data).digest()\n        Sgn_Cksum = HMAC.new(Ksign, Sgn_Cksum, MD5).digest()\n        token['SGN_CKSUM'] = Sgn_Cksum[:8]\n\n        Kseq = HMAC.new(sessionKey.contents, struct.pack('<L',0), MD5).digest()\n        Kseq = HMAC.new(Kseq, token['SGN_CKSUM'], MD5).digest()\n        token['SND_SEQ'] = ARC4.new(Kseq).encrypt(token['SND_SEQ'])\n        finalData = GSS_GETMIC_HEADER + token.getData()\n        return finalData",
  "def GSS_Wrap(self, sessionKey, data, sequenceNumber, direction = 'init', encrypt=True, authData=None):\n        # Damn inacurate RFC, useful info from here\n        # https://social.msdn.microsoft.com/Forums/en-US/fb98e8f4-e697-4652-bcb7-604e027e14cc/gsswrap-token-size-kerberos-and-rc4hmac?forum=os_windowsprotocols\n        # and here\n        # http://www.rfc-editor.org/errata_search.php?rfc=4757\n        GSS_WRAP_HEADER = b'\\x60\\x2b\\x06\\x09\\x2a\\x86\\x48\\x86\\xf7\\x12\\x01\\x02\\x02'\n        token = self.WRAP()\n\n        # Let's pad the data\n        pad = (8 - (len(data) % 8)) & 0x7\n        padStr = b(chr(pad)) * pad\n        data += padStr\n\n        token['SGN_ALG'] = GSS_HMAC\n        token['SEAL_ALG'] = GSS_RC4\n\n        if direction == 'init':\n            token['SND_SEQ'] = struct.pack('>L', sequenceNumber) + b'\\x00'*4\n        else:\n            token['SND_SEQ'] = struct.pack('>L', sequenceNumber) + b'\\xff'*4\n\n        # Random confounder :)\n        token['Confounder'] = b(''.join([rand.choice(string.ascii_letters) for _ in range(8)]))\n\n        Ksign = HMAC.new(sessionKey.contents, b'signaturekey\\0', MD5).digest()\n        Sgn_Cksum = MD5.new(struct.pack('<L',13) + token.getData()[:8] + token['Confounder'] + data).digest()\n\n        Klocal = bytearray()\n        from builtins import bytes\n        for n in bytes(sessionKey.contents):\n            Klocal.append( n ^ 0xF0)\n\n        Kcrypt = HMAC.new(Klocal,struct.pack('<L',0), MD5).digest()\n        Kcrypt = HMAC.new(Kcrypt,struct.pack('>L', sequenceNumber), MD5).digest()\n        \n        Sgn_Cksum = HMAC.new(Ksign, Sgn_Cksum, MD5).digest()\n\n        token['SGN_CKSUM'] = Sgn_Cksum[:8]\n\n        Kseq = HMAC.new(sessionKey.contents, struct.pack('<L',0), MD5).digest()\n        Kseq = HMAC.new(Kseq, token['SGN_CKSUM'], MD5).digest()\n\n        token['SND_SEQ'] = ARC4.new(Kseq).encrypt(token['SND_SEQ'])\n\n        if authData is not None:\n            from impacket.dcerpc.v5.rpcrt import SEC_TRAILER\n            wrap = self.WRAP(authData[len(SEC_TRAILER()) + len(GSS_WRAP_HEADER):])\n            snd_seq = wrap['SND_SEQ']\n\n            Kseq = HMAC.new(sessionKey.contents, struct.pack('<L',0), MD5).digest()\n            Kseq = HMAC.new(Kseq, wrap['SGN_CKSUM'], MD5).digest()\n\n            snd_seq = ARC4.new(Kseq).encrypt(wrap['SND_SEQ'])\n \n            Kcrypt = HMAC.new(Klocal,struct.pack('<L',0), MD5).digest()\n            Kcrypt = HMAC.new(Kcrypt,snd_seq[:4], MD5).digest()\n            rc4 = ARC4.new(Kcrypt)\n            cipherText = rc4.decrypt(token['Confounder'] + data)[8:]\n        elif encrypt is True:\n            rc4 = ARC4.new(Kcrypt)\n            token['Confounder'] = rc4.encrypt(token['Confounder'])\n            cipherText = rc4.encrypt(data)\n        else:\n            cipherText = data\n\n        finalData = GSS_WRAP_HEADER + token.getData()\n        return cipherText, finalData",
  "def GSS_Unwrap(self, sessionKey, data, sequenceNumber, direction = 'init', encrypt=True, authData=None):\n        return self.GSS_Wrap(sessionKey, data, sequenceNumber, direction, encrypt, authData)",
  "class MIC(Structure):\n        structure = (\n            ('TOK_ID','>H=0x0404'),\n            ('Flags','B=0'),\n            ('Filler0','B=0xff'),\n            ('Filler','>L=0xffffffff'),\n            ('SND_SEQ','8s=b\"\"'),\n            ('SGN_CKSUM','12s=b\"\"'),\n        )",
  "class WRAP(Structure):\n        structure = (\n            ('TOK_ID','>H=0x0504'),\n            ('Flags','B=0'),\n            ('Filler','B=0xff'),\n            ('EC','>H=0'),\n            ('RRC','>H=0'),\n            ('SND_SEQ','8s=b\"\"'),\n        )",
  "def GSS_GetMIC(self, sessionKey, data, sequenceNumber, direction = 'init'):\n        token = self.MIC()\n\n        # Let's pad the data\n        pad = (4 - (len(data) % 4)) & 0x3\n        padStr = chr(pad) * pad\n        data += padStr\n\n        checkSumProfile = self.checkSumProfile()\n\n        token['Flags'] = 4\n        token['SND_SEQ'] = struct.pack('>Q',sequenceNumber)\n        token['SGN_CKSUM'] = checkSumProfile.checksum(sessionKey, KG_USAGE_INITIATOR_SIGN, data + token.getData()[:16])\n \n        return token.getData()",
  "def rotate(self, data, numBytes):\n        numBytes %= len(data)\n        left = len(data) - numBytes\n        result = data[left:] + data[:left]\n        return result",
  "def unrotate(self, data, numBytes):\n        numBytes %= len(data)\n        result = data[numBytes:] + data[:numBytes]\n        return result",
  "def GSS_Wrap(self, sessionKey, data, sequenceNumber, direction = 'init', encrypt=True):\n        token = self.WRAP()\n\n        cipher = self.cipherType()\n\n        # Let's pad the data\n        pad = (cipher.blocksize - (len(data) % cipher.blocksize)) & 15\n        padStr = b'\\xFF' * pad\n        data += padStr\n\n        # The RRC field ([RFC4121] section 4.2.5) is 12 if no encryption is requested or 28 if encryption \n        # is requested. The RRC field is chosen such that all the data can be encrypted in place.\n        rrc = 28\n\n        token['Flags'] = 6\n        token['EC'] = pad\n        token['RRC'] = 0\n        token['SND_SEQ'] = struct.pack('>Q',sequenceNumber)\n\n        cipherText = cipher.encrypt(sessionKey, KG_USAGE_INITIATOR_SEAL,  data + token.getData(), None)\n        token['RRC'] = rrc\n\n        cipherText = self.rotate(cipherText, token['RRC'] + token['EC'])\n\n        #nn = self.unrotate(cipherText, token['RRC'] + token['EC'])\n        ret1 = cipherText[len(self.WRAP()) + token['RRC'] + token['EC']:]\n        ret2 = token.getData() + cipherText[:len(self.WRAP()) + token['RRC'] + token['EC']]\n\n        return ret1, ret2",
  "def GSS_Unwrap(self, sessionKey, data, sequenceNumber, direction = 'init', encrypt=True, authData=None):\n        from impacket.dcerpc.v5.rpcrt import SEC_TRAILER\n\n        cipher = self.cipherType()\n        token = self.WRAP(authData[len(SEC_TRAILER()):])\n\n        rotated = authData[len(self.WRAP())+len(SEC_TRAILER()):] + data\n \n        cipherText = self.unrotate(rotated, token['RRC'] + token['EC'])\n        plainText = cipher.decrypt(sessionKey, KG_USAGE_ACCEPTOR_SEAL,  cipherText)\n\n        return plainText[:-(token['EC']+len(self.WRAP()))], None",
  "def sendReceive(data, host, kdcHost, port=88):\n    if kdcHost is None:\n        targetHost = host\n    else:\n        targetHost = kdcHost\n\n    messageLen = struct.pack('!i', len(data))\n\n    LOG.debug('Trying to connect to KDC at %s:%s' % (targetHost, port))\n    try:\n        af, socktype, proto, canonname, sa = socket.getaddrinfo(targetHost, port, 0, socket.SOCK_STREAM)[0]\n        s = socket.socket(af, socktype, proto)\n        s.connect(sa)\n    except socket.error as e:\n        raise socket.error(\"Connection error (%s:%s)\" % (targetHost, port), e)\n\n    s.sendall(messageLen + data)\n\n    recvDataLen = struct.unpack('!i', s.recv(4))[0]\n\n    r = s.recv(recvDataLen)\n    while len(r) < recvDataLen:\n        r += s.recv(recvDataLen-len(r))\n\n    try:\n        krbError = KerberosError(packet = decoder.decode(r, asn1Spec = KRB_ERROR())[0])\n    except:\n        return r\n\n    if krbError.getErrorCode() != constants.ErrorCodes.KDC_ERR_PREAUTH_REQUIRED.value:\n        try:\n            for i in decoder.decode(r):\n                if type(i) == Sequence:\n                    for k in vars(i)[\"_componentValues\"]:\n                        if type(k) == GeneralizedTime:\n                            server_time = datetime.datetime.strptime(k.asOctets().decode(\"utf-8\"), \"%Y%m%d%H%M%SZ\")\n                            LOG.debug(\"Server time (UTC): %s\" % server_time)\n        except:\n            # Couldn't get server time for some reason\n            pass\n        raise krbError\n\n    return r",
  "def getKerberosTGT(clientName, password, domain, lmhash, nthash, aesKey='', kdcHost=None, requestPAC=True, serverName=None):\n\n    # Convert to binary form, just in case we're receiving strings\n    if isinstance(lmhash, str):\n        try:\n            lmhash = unhexlify(lmhash)\n        except TypeError:\n            pass\n    if isinstance(nthash, str):\n        try:\n            nthash = unhexlify(nthash)\n        except TypeError:\n            pass\n    if isinstance(aesKey, str):\n        try:\n            aesKey = unhexlify(aesKey)\n        except TypeError:\n            pass\n    if serverName is not None and not isinstance(serverName, Principal):\n        try:\n            serverName = Principal(serverName, type=constants.PrincipalNameType.NT_PRINCIPAL.value)\n        except TypeError:\n            pass\n\n    asReq = AS_REQ()\n\n    domain = domain.upper()\n    if serverName is None:\n        serverName = Principal('krbtgt/%s'%domain, type=constants.PrincipalNameType.NT_PRINCIPAL.value)\n\n    pacRequest = KERB_PA_PAC_REQUEST()\n    pacRequest['include-pac'] = requestPAC\n    encodedPacRequest = encoder.encode(pacRequest)\n\n    asReq['pvno'] = 5\n    asReq['msg-type'] =  int(constants.ApplicationTagNumbers.AS_REQ.value)\n\n    asReq['padata'] = noValue\n    asReq['padata'][0] = noValue\n    asReq['padata'][0]['padata-type'] = int(constants.PreAuthenticationDataTypes.PA_PAC_REQUEST.value)\n    asReq['padata'][0]['padata-value'] = encodedPacRequest\n\n    reqBody = seq_set(asReq, 'req-body')\n\n    opts = list()\n    opts.append( constants.KDCOptions.forwardable.value )\n    opts.append( constants.KDCOptions.renewable.value )\n    opts.append( constants.KDCOptions.proxiable.value )\n    reqBody['kdc-options']  = constants.encodeFlags(opts)\n\n    seq_set(reqBody, 'sname', serverName.components_to_asn1)\n    seq_set(reqBody, 'cname', clientName.components_to_asn1)\n\n    if domain == '':\n        raise Exception('Empty Domain not allowed in Kerberos')\n\n    reqBody['realm'] = domain\n\n    now = datetime.datetime.utcnow() + datetime.timedelta(days=1)\n    reqBody['till'] = KerberosTime.to_asn1(now)\n    reqBody['rtime'] = KerberosTime.to_asn1(now)\n    reqBody['nonce'] =  rand.getrandbits(31)\n\n    # Yes.. this shouldn't happen but it's inherited from the past\n    if aesKey is None:\n        aesKey = b''\n\n    if nthash == b'':\n        # This is still confusing. I thought KDC_ERR_ETYPE_NOSUPP was enough, \n        # but I found some systems that accepts all ciphers, and trigger an error \n        # when requesting subsequent TGS :(. More research needed.\n        # So, in order to support more than one cypher, I'm setting aes first\n        # since most of the systems would accept it. If we're lucky and \n        # KDC_ERR_ETYPE_NOSUPP is returned, we will later try rc4.\n        if aesKey != b'':\n            if len(aesKey) == 32:\n                supportedCiphers = (int(constants.EncryptionTypes.aes256_cts_hmac_sha1_96.value),)\n            else:\n                supportedCiphers = (int(constants.EncryptionTypes.aes128_cts_hmac_sha1_96.value),)\n        else:\n            supportedCiphers = (int(constants.EncryptionTypes.aes256_cts_hmac_sha1_96.value),)\n    else:\n        # We have hashes to try, only way is to request RC4 only\n        supportedCiphers = (int(constants.EncryptionTypes.rc4_hmac.value),)\n\n    seq_set_iter(reqBody, 'etype', supportedCiphers)\n\n    message = encoder.encode(asReq)\n\n    try:\n        r = sendReceive(message, domain, kdcHost)\n    except KerberosError as e:\n        if e.getErrorCode() == constants.ErrorCodes.KDC_ERR_ETYPE_NOSUPP.value:\n            if supportedCiphers[0] in (constants.EncryptionTypes.aes128_cts_hmac_sha1_96.value, constants.EncryptionTypes.aes256_cts_hmac_sha1_96.value) and aesKey == b'':\n                supportedCiphers = (int(constants.EncryptionTypes.rc4_hmac.value),)\n                seq_set_iter(reqBody, 'etype', supportedCiphers)\n                message = encoder.encode(asReq)\n                r = sendReceive(message, domain, kdcHost)\n            else: \n                raise \n        else:\n            raise \n\n    # This should be the PREAUTH_FAILED packet or the actual TGT if the target principal has the\n    # 'Do not require Kerberos preauthentication' set\n    preAuth = True\n    try:\n        asRep = decoder.decode(r, asn1Spec = KRB_ERROR())[0]\n    except:\n        # Most of the times we shouldn't be here, is this a TGT?\n        asRep = decoder.decode(r, asn1Spec=AS_REP())[0]\n        # Yes\n        preAuth = False\n\n    encryptionTypesData = dict()\n    salt = ''\n    if preAuth is False:\n        # In theory, we should have the right credentials for the etype specified before.\n        methods = asRep['padata']\n        encryptionTypesData[supportedCiphers[0]] = salt # handle RC4 fallback, we don't need any salt\n        tgt = r\n    else:\n        methods = decoder.decode(asRep['e-data'], asn1Spec=METHOD_DATA())[0]\n\n    for method in methods:\n        if method['padata-type'] == constants.PreAuthenticationDataTypes.PA_ETYPE_INFO2.value:\n            etypes2 = decoder.decode(method['padata-value'], asn1Spec = ETYPE_INFO2())[0]\n            for etype2 in etypes2:\n                try:\n                    if etype2['salt'] is None or etype2['salt'].hasValue() is False:\n                        salt = ''\n                    else:\n                        salt = etype2['salt'].prettyPrint()\n                except PyAsn1Error:\n                    salt = ''\n\n                encryptionTypesData[etype2['etype']] = b(salt)\n        elif method['padata-type'] == constants.PreAuthenticationDataTypes.PA_ETYPE_INFO.value:\n            etypes = decoder.decode(method['padata-value'], asn1Spec = ETYPE_INFO())[0]\n            for etype in etypes:\n                try:\n                    if etype['salt'] is None or etype['salt'].hasValue() is False:\n                        salt = ''\n                    else:\n                        salt = etype['salt'].prettyPrint()\n                except PyAsn1Error:\n                    salt = ''\n\n                encryptionTypesData[etype['etype']] = b(salt)\n\n    enctype = supportedCiphers[0]\n\n    cipher = _enctype_table[enctype]\n\n    # Pass the hash/aes key :P\n    if isinstance(nthash, bytes) and nthash != b'':\n        key = Key(cipher.enctype, nthash)\n    elif aesKey != b'':\n        key = Key(cipher.enctype, aesKey)\n    else:\n        key = cipher.string_to_key(password, encryptionTypesData[enctype], None)\n\n    if preAuth is True:\n        if enctype in encryptionTypesData is False:\n            raise Exception('No Encryption Data Available!')\n\n        # Let's build the timestamp\n        timeStamp = PA_ENC_TS_ENC()\n\n        now = datetime.datetime.utcnow()\n        timeStamp['patimestamp'] = KerberosTime.to_asn1(now)\n        timeStamp['pausec'] = now.microsecond\n\n        # Encrypt the shyte\n        encodedTimeStamp = encoder.encode(timeStamp)\n\n        # Key Usage 1\n        # AS-REQ PA-ENC-TIMESTAMP padata timestamp, encrypted with the\n        # client key (Section 5.2.7.2)\n        encriptedTimeStamp = cipher.encrypt(key, 1, encodedTimeStamp, None)\n\n        encryptedData = EncryptedData()\n        encryptedData['etype'] = cipher.enctype\n        encryptedData['cipher'] = encriptedTimeStamp\n        encodedEncryptedData = encoder.encode(encryptedData)\n\n        # Now prepare the new AS_REQ again with the PADATA\n        # ToDo: cannot we reuse the previous one?\n        asReq = AS_REQ()\n\n        asReq['pvno'] = 5\n        asReq['msg-type'] =  int(constants.ApplicationTagNumbers.AS_REQ.value)\n\n        asReq['padata'] = noValue\n        asReq['padata'][0] = noValue\n        asReq['padata'][0]['padata-type'] = int(constants.PreAuthenticationDataTypes.PA_ENC_TIMESTAMP.value)\n        asReq['padata'][0]['padata-value'] = encodedEncryptedData\n\n        asReq['padata'][1] = noValue\n        asReq['padata'][1]['padata-type'] = int(constants.PreAuthenticationDataTypes.PA_PAC_REQUEST.value)\n        asReq['padata'][1]['padata-value'] = encodedPacRequest\n\n        reqBody = seq_set(asReq, 'req-body')\n\n        opts = list()\n        opts.append( constants.KDCOptions.forwardable.value )\n        opts.append( constants.KDCOptions.renewable.value )\n        opts.append( constants.KDCOptions.proxiable.value )\n        reqBody['kdc-options'] = constants.encodeFlags(opts)\n\n        seq_set(reqBody, 'sname', serverName.components_to_asn1)\n        seq_set(reqBody, 'cname', clientName.components_to_asn1)\n\n        reqBody['realm'] =  domain\n\n        now = datetime.datetime.utcnow() + datetime.timedelta(days=1)\n        reqBody['till'] = KerberosTime.to_asn1(now)\n        reqBody['rtime'] =  KerberosTime.to_asn1(now)\n        reqBody['nonce'] = rand.getrandbits(31)\n\n        seq_set_iter(reqBody, 'etype', ( (int(cipher.enctype),)))\n\n        try:\n            tgt = sendReceive(encoder.encode(asReq), domain, kdcHost)\n        except Exception as e:\n            if str(e).find('KDC_ERR_ETYPE_NOSUPP') >= 0:\n                if lmhash == b'' and nthash == b'' and (aesKey == b'' or aesKey is None):\n                    from impacket.ntlm import compute_lmhash, compute_nthash\n                    lmhash = compute_lmhash(password)\n                    nthash = compute_nthash(password)\n                    return getKerberosTGT(clientName, password, domain, lmhash, nthash, aesKey, kdcHost, requestPAC)\n            raise\n\n\n        asRep = decoder.decode(tgt, asn1Spec = AS_REP())[0]\n\n    # So, we have the TGT, now extract the new session key and finish\n    cipherText = asRep['enc-part']['cipher']\n\n    if preAuth is False:\n        # Let's output the TGT enc-part/cipher in John format, in case somebody wants to use it.\n        LOG.debug('$krb5asrep$%d$%s@%s:%s$%s' % (asRep['enc-part']['etype'],clientName, domain, hexlify(asRep['enc-part']['cipher'].asOctets()[:16]),\n                                           hexlify(asRep['enc-part']['cipher'].asOctets()[16:])) )\n    # Key Usage 3\n    # AS-REP encrypted part (includes TGS session key or\n    # application session key), encrypted with the client key\n    # (Section 5.4.2)\n    try:\n        plainText = cipher.decrypt(key, 3, cipherText)\n    except InvalidChecksum as e:\n        # probably bad password if preauth is disabled\n        if preAuth is False:\n            error_msg = \"failed to decrypt session key: %s\" % str(e)\n            raise SessionKeyDecryptionError(error_msg, asRep, cipher, key, cipherText)\n        raise\n    encASRepPart = decoder.decode(plainText, asn1Spec = EncASRepPart())[0]\n\n    # Get the session key and the ticket\n    cipher = _enctype_table[encASRepPart['key']['keytype']]\n    sessionKey = Key(cipher.enctype,encASRepPart['key']['keyvalue'].asOctets())\n\n    # ToDo: Check Nonces!\n\n    return tgt, cipher, key, sessionKey",
  "def getKerberosTGS(serverName, domain, kdcHost, tgt, cipher, sessionKey):\n\n    # Decode the TGT\n    try:\n        decodedTGT = decoder.decode(tgt, asn1Spec = AS_REP())[0]\n    except:\n        decodedTGT = decoder.decode(tgt, asn1Spec = TGS_REP())[0]\n\n    domain = domain.upper()\n    # Extract the ticket from the TGT\n    ticket = Ticket()\n    ticket.from_asn1(decodedTGT['ticket'])\n\n    apReq = AP_REQ()\n    apReq['pvno'] = 5\n    apReq['msg-type'] = int(constants.ApplicationTagNumbers.AP_REQ.value)\n\n    opts = list()\n    apReq['ap-options'] =  constants.encodeFlags(opts)\n    seq_set(apReq,'ticket', ticket.to_asn1)\n\n    authenticator = Authenticator()\n    authenticator['authenticator-vno'] = 5\n    authenticator['crealm'] = decodedTGT['crealm'].asOctets()\n\n    clientName = Principal()\n    clientName.from_asn1( decodedTGT, 'crealm', 'cname')\n\n    seq_set(authenticator, 'cname', clientName.components_to_asn1)\n\n    now = datetime.datetime.utcnow()\n    authenticator['cusec'] =  now.microsecond\n    authenticator['ctime'] = KerberosTime.to_asn1(now)\n\n    encodedAuthenticator = encoder.encode(authenticator)\n\n    # Key Usage 7\n    # TGS-REQ PA-TGS-REQ padata AP-REQ Authenticator (includes\n    # TGS authenticator subkey), encrypted with the TGS session\n    # key (Section 5.5.1)\n    encryptedEncodedAuthenticator = cipher.encrypt(sessionKey, 7, encodedAuthenticator, None)\n\n    apReq['authenticator'] = noValue\n    apReq['authenticator']['etype'] = cipher.enctype\n    apReq['authenticator']['cipher'] = encryptedEncodedAuthenticator\n\n    encodedApReq = encoder.encode(apReq)\n\n    tgsReq = TGS_REQ()\n\n    tgsReq['pvno'] =  5\n    tgsReq['msg-type'] = int(constants.ApplicationTagNumbers.TGS_REQ.value)\n    tgsReq['padata'] = noValue\n    tgsReq['padata'][0] = noValue\n    tgsReq['padata'][0]['padata-type'] = int(constants.PreAuthenticationDataTypes.PA_TGS_REQ.value)\n    tgsReq['padata'][0]['padata-value'] = encodedApReq\n\n    reqBody = seq_set(tgsReq, 'req-body')\n\n    opts = list()\n    opts.append( constants.KDCOptions.forwardable.value )\n    opts.append( constants.KDCOptions.renewable.value )\n    opts.append( constants.KDCOptions.renewable_ok.value )\n    opts.append( constants.KDCOptions.canonicalize.value )\n\n    reqBody['kdc-options'] = constants.encodeFlags(opts)\n    seq_set(reqBody, 'sname', serverName.components_to_asn1)\n    reqBody['realm'] = domain\n\n    now = datetime.datetime.utcnow() + datetime.timedelta(days=1)\n\n    reqBody['till'] = KerberosTime.to_asn1(now)\n    reqBody['nonce'] = rand.getrandbits(31)\n    seq_set_iter(reqBody, 'etype',\n                      (\n                          int(constants.EncryptionTypes.rc4_hmac.value),\n                          int(constants.EncryptionTypes.des3_cbc_sha1_kd.value),\n                          int(constants.EncryptionTypes.des_cbc_md5.value),\n                          int(cipher.enctype)\n                       )\n                )\n\n    message = encoder.encode(tgsReq)\n\n    r = sendReceive(message, domain, kdcHost)\n\n    # Get the session key\n\n    tgs = decoder.decode(r, asn1Spec = TGS_REP())[0]\n\n    cipherText = tgs['enc-part']['cipher']\n\n    # Key Usage 8\n    # TGS-REP encrypted part (includes application session\n    # key), encrypted with the TGS session key (Section 5.4.2)\n    plainText = cipher.decrypt(sessionKey, 8, cipherText)\n\n    encTGSRepPart = decoder.decode(plainText, asn1Spec = EncTGSRepPart())[0]\n\n    newSessionKey = Key(encTGSRepPart['key']['keytype'], encTGSRepPart['key']['keyvalue'].asOctets())\n    # Creating new cipher based on received keytype\n    cipher = _enctype_table[encTGSRepPart['key']['keytype']]\n\n    # Check we've got what we asked for\n    res = decoder.decode(r, asn1Spec = TGS_REP())[0]\n    spn = Principal()\n    spn.from_asn1(res['ticket'], 'realm', 'sname')\n\n    if spn.components[0] == serverName.components[0]:\n        # Yes.. bye bye\n        return r, cipher, sessionKey, newSessionKey\n    else:\n        # Let's extract the Ticket, change the domain and keep asking\n        domain = spn.components[1]\n        return getKerberosTGS(serverName, domain, kdcHost, r, cipher, newSessionKey)",
  "def getKerberosType3(cipher, sessionKey, auth_data):\n    negTokenResp = SPNEGO_NegTokenResp(auth_data)\n    # If DCE_STYLE = FALSE\n    #ap_rep = decoder.decode(negTokenResp['ResponseToken'][16:], asn1Spec=AP_REP())[0]\n    try:\n        krbError = KerberosError(packet = decoder.decode(negTokenResp['ResponseToken'][15:], asn1Spec = KRB_ERROR())[0])\n    except Exception:\n        pass\n    else:\n        raise krbError\n\n    ap_rep = decoder.decode(negTokenResp['ResponseToken'], asn1Spec=AP_REP())[0]\n\n    cipherText = ap_rep['enc-part']['cipher']\n\n    # Key Usage 12\n    # AP-REP encrypted part (includes application session\n    # subkey), encrypted with the application session key\n    # (Section 5.5.2)\n    plainText = cipher.decrypt(sessionKey, 12, cipherText)\n\n    encAPRepPart = decoder.decode(plainText, asn1Spec = EncAPRepPart())[0]\n\n    cipher = _enctype_table[int(encAPRepPart['subkey']['keytype'])]()\n    sessionKey2 = Key(cipher.enctype, encAPRepPart['subkey']['keyvalue'].asOctets())\n\n    sequenceNumber = int(encAPRepPart['seq-number'])\n\n    encAPRepPart['subkey'].clear()\n    encAPRepPart = encAPRepPart.clone()\n\n    now = datetime.datetime.utcnow()\n    encAPRepPart['cusec'] = now.microsecond\n    encAPRepPart['ctime'] = KerberosTime.to_asn1(now)\n    encAPRepPart['seq-number'] = sequenceNumber\n    encodedAuthenticator = encoder.encode(encAPRepPart)\n\n    encryptedEncodedAuthenticator = cipher.encrypt(sessionKey, 12, encodedAuthenticator, None)\n\n    ap_rep['enc-part'].clear()\n    ap_rep['enc-part']['etype'] = cipher.enctype\n    ap_rep['enc-part']['cipher'] = encryptedEncodedAuthenticator\n\n    resp = SPNEGO_NegTokenResp()\n    resp['ResponseToken'] = encoder.encode(ap_rep)\n\n    return cipher, sessionKey2, resp.getData()",
  "def getKerberosType1(username, password, domain, lmhash, nthash, aesKey='', TGT = None, TGS = None, targetName='',\n                     kdcHost = None, useCache = True):\n\n    # Convert to binary form, just in case we're receiving strings\n    if isinstance(lmhash, str):\n        try:\n            lmhash = unhexlify(lmhash)\n        except TypeError:\n            pass\n    if isinstance(nthash, str):\n        try:\n            nthash = unhexlify(nthash)\n        except TypeError:\n            pass\n    if isinstance(aesKey, str):\n        try:\n            aesKey = unhexlify(aesKey)\n        except TypeError:\n            pass\n\n    targetName = 'host/%s' % targetName\n    if TGT is None and TGS is None:\n        if useCache:\n            domain, username, TGT, TGS = CCache.parseFile(domain, username, targetName)\n\n    # First of all, we need to get a TGT for the user\n    userName = Principal(username, type=constants.PrincipalNameType.NT_PRINCIPAL.value)\n    while True:\n        if TGT is None:\n            if TGS is None:\n                try:\n                    tgt, cipher, oldSessionKey, sessionKey = getKerberosTGT(userName, password, domain, lmhash, nthash, aesKey, kdcHost)\n                except KerberosError as e:\n                    if e.getErrorCode() == constants.ErrorCodes.KDC_ERR_ETYPE_NOSUPP.value:\n                        # We might face this if the target does not support AES \n                        # So, if that's the case we'll force using RC4 by converting\n                        # the password to lm/nt hashes and hope for the best. If that's already\n                        # done, byebye.\n                        if lmhash == b'' and nthash == b'' and (aesKey == b'' or aesKey is None) and TGT is None and TGS is None:\n                            from impacket.ntlm import compute_lmhash, compute_nthash\n                            LOG.debug('Got KDC_ERR_ETYPE_NOSUPP, fallback to RC4')\n                            lmhash = compute_lmhash(password)\n                            nthash = compute_nthash(password) \n                            continue\n                        else:\n                            raise \n                    else:\n                        raise\n\n        else:\n            tgt = TGT['KDC_REP']\n            cipher = TGT['cipher']\n            sessionKey = TGT['sessionKey']\n\n        # Now that we have the TGT, we should ask for a TGS for cifs\n        if TGS is None:\n            serverName = Principal(targetName, type=constants.PrincipalNameType.NT_SRV_INST.value)\n            try:\n                tgs, cipher, oldSessionKey, sessionKey = getKerberosTGS(serverName, domain, kdcHost, tgt, cipher, sessionKey)\n            except KerberosError as e:\n                if e.getErrorCode() == constants.ErrorCodes.KDC_ERR_ETYPE_NOSUPP.value:\n                    # We might face this if the target does not support AES \n                    # So, if that's the case we'll force using RC4 by converting\n                    # the password to lm/nt hashes and hope for the best. If that's already\n                    # done, byebye.\n                    if lmhash == b'' and nthash == b'' and (aesKey == b'' or aesKey is None) and TGT is None and TGS is None:\n                        from impacket.ntlm import compute_lmhash, compute_nthash\n                        LOG.debug('Got KDC_ERR_ETYPE_NOSUPP, fallback to RC4')\n                        lmhash = compute_lmhash(password)\n                        nthash = compute_nthash(password) \n                    else:\n                        raise \n                else:\n                    raise \n            else:\n                break\n        else:\n            tgs = TGS['KDC_REP']\n            cipher = TGS['cipher']\n            sessionKey = TGS['sessionKey'] \n            break\n\n    # Let's build a NegTokenInit with a Kerberos REQ_AP\n\n    blob = SPNEGO_NegTokenInit() \n\n    # Kerberos\n    blob['MechTypes'] = [TypesMech['MS KRB5 - Microsoft Kerberos 5']]\n\n    # Let's extract the ticket from the TGS\n    tgs = decoder.decode(tgs, asn1Spec = TGS_REP())[0]\n    ticket = Ticket()\n    ticket.from_asn1(tgs['ticket'])\n    \n    # Now let's build the AP_REQ\n    apReq = AP_REQ()\n    apReq['pvno'] = 5\n    apReq['msg-type'] = int(constants.ApplicationTagNumbers.AP_REQ.value)\n\n    opts = list()\n    opts.append(constants.APOptions.mutual_required.value)\n    apReq['ap-options'] = constants.encodeFlags(opts)\n    seq_set(apReq,'ticket', ticket.to_asn1)\n\n    authenticator = Authenticator()\n    authenticator['authenticator-vno'] = 5\n    authenticator['crealm'] = domain\n    seq_set(authenticator, 'cname', userName.components_to_asn1)\n    now = datetime.datetime.utcnow()\n\n    authenticator['cusec'] = now.microsecond\n    authenticator['ctime'] = KerberosTime.to_asn1(now)\n\n    \n    authenticator['cksum'] = noValue\n    authenticator['cksum']['cksumtype'] = 0x8003\n\n    chkField = CheckSumField()\n    chkField['Lgth'] = 16\n\n    chkField['Flags'] = GSS_C_CONF_FLAG | GSS_C_INTEG_FLAG | GSS_C_SEQUENCE_FLAG | GSS_C_REPLAY_FLAG | GSS_C_MUTUAL_FLAG | GSS_C_DCE_STYLE\n    #chkField['Flags'] = GSS_C_INTEG_FLAG | GSS_C_SEQUENCE_FLAG | GSS_C_REPLAY_FLAG | GSS_C_MUTUAL_FLAG | GSS_C_DCE_STYLE\n    authenticator['cksum']['checksum'] = chkField.getData()\n    authenticator['seq-number'] = 0\n    encodedAuthenticator = encoder.encode(authenticator)\n\n    # Key Usage 11\n    # AP-REQ Authenticator (includes application authenticator\n    # subkey), encrypted with the application session key\n    # (Section 5.5.1)\n    encryptedEncodedAuthenticator = cipher.encrypt(sessionKey, 11, encodedAuthenticator, None)\n\n    apReq['authenticator'] = noValue\n    apReq['authenticator']['etype'] = cipher.enctype\n    apReq['authenticator']['cipher'] = encryptedEncodedAuthenticator\n\n    blob['MechToken'] = struct.pack('B', ASN1_AID) + asn1encode( struct.pack('B', ASN1_OID) + asn1encode(\n            TypesMech['KRB5 - Kerberos 5'] ) + KRB5_AP_REQ + encoder.encode(apReq))\n\n    return cipher, sessionKey, blob.getData()",
  "class SessionKeyDecryptionError(Exception):\n    \"\"\"\n    Exception risen when we fail to decrypt a session key within an AS-REP\n    message.\n    It provides context information such as full AS-REP message but also the\n    cipher, key and cipherText used when the error occurred.\n    \"\"\"\n    def __init__( self, message, asRep, cipher, key, cipherText):\n        self.message = message\n        self.asRep = asRep\n        self.cipher = cipher\n        self.key = key\n        self.cipherText = cipherText\n\n    def __str__ ( self):\n        return \"SessionKeyDecryptionError: %s\" % self.message",
  "class KerberosError(SessionError):\n    \"\"\"\n    This is the exception every client should catch regardless of the underlying\n    SMB version used. We'll take care of that. NETBIOS exceptions are NOT included,\n    since all SMB versions share the same NETBIOS instances.\n    \"\"\"\n    def __init__( self, error = 0, packet=0):\n        SessionError.__init__(self)\n        self.error = error\n        self.packet = packet\n        if packet != 0:\n            self.error = self.packet['error-code']\n       \n    def getErrorCode( self ):\n        return self.error\n\n    def getErrorPacket( self ):\n        return self.packet\n\n    def getErrorString( self ):\n        return constants.ERROR_MESSAGES[self.error]\n\n    def __str__( self ):\n        retString = 'Kerberos SessionError: %s(%s)' % (constants.ERROR_MESSAGES[self.error])\n        try:\n            # Let's try to get the NT ERROR, if not, we quit and give the general one\n            if self.error == constants.ErrorCodes.KRB_ERR_GENERIC.value:\n                eData = decoder.decode(self.packet['e-data'], asn1Spec = KERB_ERROR_DATA())[0]\n                nt_error = struct.unpack('<L', eData['data-value'].asOctets()[:4])[0]\n                retString += '\\nNT ERROR: %s(%s)' % (nt_errors.ERROR_MESSAGES[nt_error])\n        except:\n            pass\n\n        return retString",
  "def __init__( self, message, asRep, cipher, key, cipherText):\n        self.message = message\n        self.asRep = asRep\n        self.cipher = cipher\n        self.key = key\n        self.cipherText = cipherText",
  "def __str__ ( self):\n        return \"SessionKeyDecryptionError: %s\" % self.message",
  "def __init__( self, error = 0, packet=0):\n        SessionError.__init__(self)\n        self.error = error\n        self.packet = packet\n        if packet != 0:\n            self.error = self.packet['error-code']",
  "def getErrorCode( self ):\n        return self.error",
  "def getErrorPacket( self ):\n        return self.packet",
  "def getErrorString( self ):\n        return constants.ERROR_MESSAGES[self.error]",
  "def __str__( self ):\n        retString = 'Kerberos SessionError: %s(%s)' % (constants.ERROR_MESSAGES[self.error])\n        try:\n            # Let's try to get the NT ERROR, if not, we quit and give the general one\n            if self.error == constants.ErrorCodes.KRB_ERR_GENERIC.value:\n                eData = decoder.decode(self.packet['e-data'], asn1Spec = KERB_ERROR_DATA())[0]\n                nt_error = struct.unpack('<L', eData['data-value'].asOctets()[:4])[0]\n                retString += '\\nNT ERROR: %s(%s)' % (nt_errors.ERROR_MESSAGES[nt_error])\n        except:\n            pass\n\n        return retString",
  "class KPasswdResultCodes(Enum):\n    SUCCESS = 0\n    MALFORMED = 1\n    HARDERROR = 2\n    AUTHERROR = 3\n    SOFTERROR = 4\n    ACCESSDENIED = 5\n    BAD_VERSION = 6\n    INITIAL_FLAG_NEEDED = 7\n    UNKNOWN = 0xFFFF",
  "class ChangePasswdData(univ.Sequence):\n    componentType = namedtype.NamedTypes(\n        _sequence_component(\"newpasswd\", 0, univ.OctetString()),  # cleartext password\n        _sequence_optional_component(\"targname\", 1, PrincipalName()),\n        _sequence_optional_component(\"targrealm\", 2, Realm()),\n    )",
  "class PasswordPolicyFlags(Enum):\n    Complex = 0x1\n    NoAnonChange = 0x2\n    NoClearChange = 0x4\n    LockoutAdmins = 0x8\n    StoreCleartext = 0x10\n    RefusePasswordChange = 0x20",
  "def _decodePasswordPolicy(ppolicyString):\n    ppolicyStruct = \"!HIIIQQ\"\n    ticksInADay = 86400 * 10_000_000\n\n    if len(ppolicyString) != struct.calcsize(ppolicyStruct) or ppolicyString[0:2] != b\"\\x00\\x00\":\n        raise ValueError\n\n    properties = struct.unpack(ppolicyStruct, ppolicyString)\n    passwordPolicy = {\n        \"minLength\": properties[1],\n        \"history\": properties[2],\n        \"maxAge\": properties[4] / ticksInADay,\n        \"minAge\": properties[5] / ticksInADay,\n        \"flags\": [flag.name for flag in PasswordPolicyFlags if flag.value & properties[3]],\n    }\n    return passwordPolicy",
  "class KPasswdError(Exception):\n    pass",
  "def createKPasswdRequest(principal, domain, newPasswd, tgs, cipher, sessionKey, subKey,\n                         targetPrincipal=None, targetDomain=None, sequenceNumber=None,\n                         now=None, hostname=b\"localhost\"):\n\n    # Generate the parameters that we need\n    if sequenceNumber is None:\n        sequenceNumber = int.from_bytes(get_random_bytes(4), \"big\")\n\n    if now is None:\n        now = datetime.datetime.utcnow()\n\n    if not isinstance(newPasswd, bytes):\n        newPasswd = newPasswd.encode(\"utf-8\")\n\n    # Build the Authenticator\n    authenticator = Authenticator()\n    authenticator[\"authenticator-vno\"] = 5\n    authenticator[\"crealm\"] = domain\n    seq_set(authenticator, \"cname\", principal.components_to_asn1)\n    authenticator[\"cusec\"] = now.microsecond\n    authenticator[\"ctime\"] = KerberosTime.to_asn1(now)\n    authenticator[\"seq-number\"] = sequenceNumber\n    authenticator[\"subkey\"] = univ.noValue\n    authenticator[\"subkey\"][\"keytype\"] = subKey.enctype\n    authenticator[\"subkey\"][\"keyvalue\"] = subKey.contents\n\n    encodedAuthenticator = encoder.encode(authenticator)\n    encryptedEncodedAuthenticator = cipher.encrypt(sessionKey, 11, encodedAuthenticator, None)\n\n    LOG.debug(\"b64(authenticator): {}\".format(base64.b64encode(encodedAuthenticator)))\n\n    # Build the AP_REQ\n    apReq = AP_REQ()\n    apReq[\"pvno\"] = 5\n    apReq[\"msg-type\"] = int(ApplicationTagNumbers.AP_REQ.value)\n    apReq[\"ap-options\"] = encodeFlags(list())\n    seq_set(apReq, \"ticket\", tgs.to_asn1)\n    apReq[\"authenticator\"] = univ.noValue\n    apReq[\"authenticator\"][\"etype\"] = cipher.enctype\n    apReq[\"authenticator\"][\"cipher\"] = encryptedEncodedAuthenticator\n\n    apReqEncoded = encoder.encode(apReq)\n\n    # Build the ChangePasswdData structure\n    changePasswdData = ChangePasswdData()\n    changePasswdData[\"newpasswd\"] = newPasswd\n    if targetDomain and targetPrincipal:\n        changePasswdData[\"targrealm\"] = targetDomain.upper()\n        changePasswdData[\"targname\"] = univ.noValue\n        changePasswdData[\"targname\"][\"name-type\"] = PrincipalNameType.NT_PRINCIPAL.value\n        changePasswdData[\"targname\"][\"name-string\"][0] = targetPrincipal\n\n    encodedChangePasswdData = encoder.encode(changePasswdData)\n\n    LOG.debug(\"b64(changePasswdData): {}\".format(base64.b64encode(encodedChangePasswdData)))\n\n    # Build the EncKrbPrivPart structure\n    encKrbPrivPart = EncKrbPrivPart()\n    encKrbPrivPart[\"user-data\"] = encoder.encode(changePasswdData)\n    encKrbPrivPart[\"seq-number\"] = sequenceNumber\n    encKrbPrivPart[\"s-address\"] = univ.noValue\n    encKrbPrivPart[\"s-address\"][\"addr-type\"] = AddressType.IPv4.value\n    encKrbPrivPart[\"s-address\"][\"address\"] = hostname\n\n    # Key Usage 13.\n    # KRB-PRIV encrypted part, encrypted with a key chosen by\n    # the application (Section 5.7.1)\n    encodedEncKrbPrivPart = encoder.encode(encKrbPrivPart)\n    encryptedEncKrbPrivPart = cipher.encrypt(subKey, 13, encodedEncKrbPrivPart, None)\n\n    LOG.debug(\"b64(encKrbPrivPart): {}\".format(base64.b64encode(encodedEncKrbPrivPart)))\n\n    # Build the KRB_PRIV\n    krbPriv = KRB_PRIV()\n    krbPriv[\"pvno\"] = 5\n    krbPriv[\"msg-type\"] = int(ApplicationTagNumbers.KRB_PRIV.value)\n    krbPriv[\"enc-part\"] = univ.noValue\n    krbPriv[\"enc-part\"][\"etype\"] = cipher.enctype\n    krbPriv[\"enc-part\"][\"cipher\"] = encryptedEncKrbPrivPart\n\n    krbPrivEncoded = encoder.encode(krbPriv)\n\n    # Assemble the Kpasswd Request packet\n    apReqLen = len(apReqEncoded)\n    krbPrivLen = len(krbPrivEncoded)\n    messageLen = 2 + 2 + 2 + apReqLen + krbPrivLen\n\n    encoded = struct.pack(\"!HHH\", messageLen, KRB5_KPASSWD_PROTOCOL_VERSION, apReqLen)\n    encoded = encoded + apReqEncoded + krbPrivEncoded\n    return encoded",
  "def decodeKPasswdReply(encoded, cipher, subKey):\n    # Extract the AP_REP and KRB_PRIV\n    headerStruct = \"!HHH\"\n    headerLen = struct.calcsize(headerStruct)\n    try:\n        headers = encoded[:headerLen]\n        _, _, apRepLen = struct.unpack(headerStruct, headers)\n        apRepEncoded = encoded[headerLen : headerLen + apRepLen]\n        krbPrivEncoded = encoded[headerLen + apRepLen :]\n    except:\n        raise KPasswdError(\"kpasswd: malformed reply from the server\")\n\n    # Decode the ASN.1\n    try:\n        apRep = decoder.decode(apRepEncoded, asn1Spec=AP_REP())[0]\n        krbPriv = decoder.decode(krbPrivEncoded, asn1Spec=KRB_PRIV())[0]\n    except:\n        raise KPasswdError(\"kpasswd: malformed AP_REP or KRB_PRIV in the reply from the server\")\n\n    # Decrypt the KRB_PRIV\n    encryptedEncKrbPrivPart = krbPriv[\"enc-part\"][\"cipher\"]\n    try:\n        # Key Usage 13.\n        # KRB-PRIV encrypted part, encrypted with a key chosen by\n        # the application (Section 5.7.1)\n        encodedEncKrbPrivPart = cipher.decrypt(subKey, 13, encryptedEncKrbPrivPart)\n    except:\n        raise KPasswdError(\"kpasswd: cannot decrypt KRB_PRIV in the reply from the server\")\n\n    LOG.debug(\"b64(encKrbPrivPart): {}\".format(base64.b64encode(encodedEncKrbPrivPart)))\n\n    # Decode the result\n    try:\n        encKrbPrivPart = decoder.decode(encodedEncKrbPrivPart, asn1Spec=EncKrbPrivPart())[0]\n        result = encKrbPrivPart[\"user-data\"].asOctets()\n        resultCode, message = int.from_bytes(result[:2], \"big\"), result[2:]\n    except:\n        raise KPasswdError(\"kpasswd: malformed EncKrbPrivPart in the KRB_PRIV in the reply from the server\")\n\n    # Interpret the return code and string\n    LOG.debug(\"resultCode: {}, message: {}\".format(resultCode, message))\n\n    try:\n        resultCodeMessage = RESULT_MESSAGES[resultCode]\n    except KeyError:\n        resultCodeMessage = RESULT_MESSAGES[0xFFFF]\n\n    try:\n        ppolicy = _decodePasswordPolicy(message)\n        message = (\n            \"Password policy:\"\n            \"\\n\\tMinimum length: {minLength}\"\n            \"\\n\\tPassword history: {history}\"\n            \"\\n\\tFlags: {flags}\"\n            \"\\n\\tMaximum password age: {maxAge} days\"\n            \"\\n\\tMinimum password age: {minAge} days\"\n        ).format(**ppolicy)\n    except (ValueError, struct.error):\n        try:\n            message = message.decode(\"utf-8\")\n        except UnicodeDecodeError:\n            message = binascii.hexlify(message).decode(\"latin-1\")\n\n    success = resultCode == KPasswdResultCodes.SUCCESS.value\n    return success, resultCode, resultCodeMessage, message",
  "def changePassword(clientName, domain, newPasswd,\n                   oldPasswd=\"\", oldLmhash=\"\", oldNthash=\"\", aesKey=\"\", TGT=None,\n                   kdcHost=None, kpasswdHost=None, kpasswdPort=KRB5_KPASSWD_PORT, subKey=None):\n    \"\"\"\n    Change the password of the requesting user with RFC 3244 Kerberos Change-Password protocol.\n\n    At least one of oldPasswd, (oldLmhash, oldNthash) or (TGT, aesKey) should be defined.\n\n    :param string clientName:   username of the account changing their password\n    :param string domain:       domain of the account changing their password\n    :param string newPasswd:    new password for the account\n    :param string oldPasswd:    current password of the account\n    :param string oldLmhash:    current LM hash of the account\n    :param string oldNthash:    current NT hash of the account\n    :param string aesKey:       current AES key of the account\n    :param string TGT:          TGT of the account. It must be a TGT with a SPN of kadmin/changepw\n    :param string kdcHost:      KDC address/hostname, used for Kerberos authentication\n    :param string kpasswdHost:  KDC exposing the kpasswd service (TCP/464, UDP/464),\n                                used when sending the password change requests\n                                (Default: same as kdcHost)\n    :param int kpasswdPort:     TCP port where kpasswd is exposed (Default: 464)\n    :param string subKey:       Subkey to use to encrypt the password change request\n                                (Default: generate a random one)\n\n    :return void:               Raise an KPasswdError exception on error.\n    \"\"\"\n    setPassword(\n        clientName, domain, None, None, newPasswd,\n        oldPasswd, oldLmhash, oldNthash, aesKey, TGT,\n        kdcHost, kpasswdHost, kpasswdPort, subKey\n    )",
  "def setPassword(clientName, domain, targetName, targetDomain, newPasswd,\n                oldPasswd=\"\", oldLmhash=\"\", oldNthash=\"\", aesKey=\"\", TGT=None,\n                kdcHost=None, kpasswdHost=None, kpasswdPort=KRB5_KPASSWD_PORT, subKey=None):\n    \"\"\"\n    Set the password of a target account with RFC 3244 Kerberos Set-Password protocol.\n    Requires \"Reset password\" permission on the target, for the user.\n\n    At least one of oldPasswd, (oldLmhash, oldNthash) or (TGT, aesKey) should be defined.\n\n    :param string clientName:   username of the account performing the reset\n    :param string domain:       domain of the account performing the reset\n    :param string targetName:   username of the account whose password will be changed\n    :param string targetDomain: domain of the account whose password will be changed\n    :param string newPasswd:    new password for the target account\n    :param string oldPasswd:    current password of the account performing the reset\n    :param string oldLmhash:    current LM hash of the account performing the reset\n    :param string oldNthash:    current NT hash of the account performing the reset\n    :param string aesKey:       current AES key of the account performing the reset\n    :param string TGT:          TGT of the account performing the reset\n                                It must be a TGT with a SPN of kadmin/changepw\n    :param string kdcHost:      KDC address/hostname, used for Kerberos authentication\n    :param string kpasswdHost:  KDC exposing the kpasswd service (TCP/464, UDP/464),\n                                used when sending the password change requests\n                                (Default: same as kdcHost)\n    :param int kpasswdPort:     TCP port where kpasswd is exposed (Default: 464)\n    :param string subKey:       Subkey to use to encrypt the password change request\n                                (Default: generate a random one)\n\n    :return bool:               True if successful, raise an KPasswdError exception on error.\n    \"\"\"\n\n    if kpasswdHost is None:\n        kpasswdHost = kdcHost\n\n    # Get a TGT for clientName\n    userName = Principal(clientName, type=PrincipalNameType.NT_PRINCIPAL.value)\n    if TGT is None and os.getenv(\"KRB5CCNAME\"):\n        KRB5CCNAME = os.getenv(\"KRB5CCNAME\")\n        try:\n            ccache = CCache.loadFile(KRB5CCNAME)\n        except:\n            # No cache present\n            pass\n        else:\n            LOG.debug(\"Using Kerberos cache: {}\".format(KRB5CCNAME))\n            principal = KRB5_KPASSWD_TGT_SPN\n            creds = ccache.getCredential(principal, False)\n\n            if creds is not None:\n                TGT = creds.toTGT()\n                LOG.info(\"Using TGT for {} from cache {}\".format(principal, KRB5CCNAME))\n            else:\n                LOG.info(\"No valid TGT for {} found in cache {}\".format(principal, KRB5CCNAME))\n\n    if TGT is None:\n        tgt, cipher, oldSessionKey, sessionKey = getKerberosTGT(\n            userName, oldPasswd, domain, oldLmhash, oldNthash, aesKey, kdcHost, serverName=KRB5_KPASSWD_TGT_SPN\n        )\n    else:\n        tgt = TGT[\"KDC_REP\"]\n        cipher = TGT[\"cipher\"]\n        sessionKey = TGT[\"sessionKey\"]\n\n    # Extract the raw ticket from the TGT\n    tgt = decoder.decode(tgt, asn1Spec=AS_REP())[0]\n    ticket = Ticket()\n    ticket.from_asn1(tgt[\"ticket\"])\n\n    # Generate a random subkey (if not provided)\n    if subKey is None:\n        subKeyBytes = get_random_bytes(cipher.keysize)\n        subKey = Key(cipher.enctype, subKeyBytes)\n\n    # Generate the Request packet\n    kpasswordReq = createKPasswdRequest(\n        userName, domain, newPasswd, ticket, cipher, sessionKey, subKey, targetName, targetDomain\n    )\n\n    # Send the request to KPASSWD\n    kpasswordRep = sendReceive(kpasswordReq, domain, kpasswdHost, kpasswdPort)\n\n    # Decode the result\n    success, resultCode, resultCodeMessage, message = decodeKPasswdReply(kpasswordRep, cipher, subKey)\n\n    if success:\n        return\n\n    errorMessage = resultCodeMessage\n    if message:\n        errorMessage += \": \" + message\n    raise KPasswdError(errorMessage)",
  "class DCERPCSessionError(DCERPCException):\n    def __init__(self, error_string=None, error_code=None, packet=None):\n        DCERPCException.__init__(self, error_string, error_code, packet)\n\n    def __str__( self ):\n        key = self.error_code\n        if key in hresult_errors.ERROR_MESSAGES:\n            error_msg_short = hresult_errors.ERROR_MESSAGES[key][0]\n            error_msg_verbose = hresult_errors.ERROR_MESSAGES[key][1]\n            return 'IPHLP SessionError: code: 0x%x - %s - %s' % (self.error_code, error_msg_short, error_msg_verbose)\n        else:\n            return 'IPHLP SessionError: unknown error code: 0x%x' % self.error_code",
  "class BYTE_ARRAY(NDRUniConformantArray):\n    item = 'c'",
  "class IpTransitionProtocolApplyConfigChanges(NDRCALL):\n    opnum = 0\n    structure = (\n       ('NotificationNum', BYTE),\n    )",
  "class IpTransitionProtocolApplyConfigChangesResponse(NDRCALL):\n    structure = (\n       ('ErrorCode', ULONG),\n    )",
  "class IpTransitionProtocolApplyConfigChangesEx(NDRCALL):\n    opnum = 1\n    structure = (\n       ('NotificationNum', BYTE),\n       ('DataLength', ULONG),\n       ('Data', BYTE_ARRAY),\n    )",
  "class IpTransitionProtocolApplyConfigChangesExResponse(NDRCALL):\n    structure = (\n       ('ErrorCode', ULONG),\n    )",
  "class IpTransitionCreatev6Inv4Tunnel(NDRCALL):\n    opnum = 2\n    structure = (\n       ('LocalAddress', \"4s=''\"),\n       ('RemoteAddress', \"4s=''\"),\n       ('InterfaceName', WSTR),\n    )",
  "class IpTransitionCreatev6Inv4TunnelResponse(NDRCALL):\n    structure = (\n       ('ErrorCode', ULONG),\n    )",
  "class IpTransitionDeletev6Inv4Tunnel(NDRCALL):\n    opnum = 3\n    structure = (\n       ('TunnelGuid', GUID),\n    )",
  "class IpTransitionDeletev6Inv4TunnelResponse(NDRCALL):\n    structure = (\n       ('ErrorCode', ULONG),\n    )",
  "def checkNullString(string):\n    if string == NULL:\n        return string\n\n    if string[-1:] != '\\x00':\n        return string + '\\x00'\n    else:\n        return string",
  "def hIpTransitionProtocolApplyConfigChanges(dce, notification_num):\n    request = IpTransitionProtocolApplyConfigChanges()\n    request['NotificationNum'] = notification_num\n\n    return dce.request(request)",
  "def hIpTransitionProtocolApplyConfigChangesEx(dce, notification_num, notification_data):\n    request = IpTransitionProtocolApplyConfigChangesEx()\n    request['NotificationNum'] = notification_num\n    request['DataLength'] = len(notification_data)\n    request['Data'] = notification_data\n\n    return dce.request(request)",
  "def hIpTransitionCreatev6Inv4Tunnel(dce, local_address, remote_address, interface_name):\n    request = IpTransitionCreatev6Inv4Tunnel()\n    request['LocalAddress'] = inet_aton(local_address)\n    request['RemoteAddress'] = inet_aton(remote_address)\n\n    request['InterfaceName'] = checkNullString(interface_name)\n    request.fields['InterfaceName'].fields['MaximumCount'] = 256\n\n    return dce.request(request)",
  "def hIpTransitionDeletev6Inv4Tunnel(dce, tunnel_guid):\n    request = IpTransitionDeletev6Inv4Tunnel()\n    request['TunnelGuid'] = uuid.string_to_bin(tunnel_guid)\n\n    return dce.request(request)",
  "def __init__(self, error_string=None, error_code=None, packet=None):\n        DCERPCException.__init__(self, error_string, error_code, packet)",
  "def __str__( self ):\n        key = self.error_code\n        if key in hresult_errors.ERROR_MESSAGES:\n            error_msg_short = hresult_errors.ERROR_MESSAGES[key][0]\n            error_msg_verbose = hresult_errors.ERROR_MESSAGES[key][1]\n            return 'IPHLP SessionError: code: 0x%x - %s - %s' % (self.error_code, error_msg_short, error_msg_verbose)\n        else:\n            return 'IPHLP SessionError: unknown error code: 0x%x' % self.error_code",
  "class DCERPCSessionError(DCERPCException):\n    def __init__(self, error_string=None, error_code=None, packet=None):\n        DCERPCException.__init__(self, error_string, error_code, packet)\n\n    def __str__( self ):\n        key = self.error_code\n        if key in system_errors.ERROR_MESSAGES:\n            error_msg_short = system_errors.ERROR_MESSAGES[key][0]\n            error_msg_verbose = system_errors.ERROR_MESSAGES[key][1] \n            return 'RPRN SessionError: code: 0x%x - %s - %s' % (self.error_code, error_msg_short, error_msg_verbose)\n        else:\n            return 'RPRN SessionError: unknown error code: 0x%x' % self.error_code",
  "class PSTRING_HANDLE(NDRPOINTER):\n    referent = (\n        ('Data', STRING_HANDLE),\n    )",
  "class PRINTER_HANDLE(NDRSTRUCT):\n    structure =  (\n        ('Data','20s=b\"\"'),\n    )\n    def getAlignment(self):\n        if self._isNDR64 is True:\n            return 8\n        else:\n            return 4",
  "class BYTE_ARRAY(NDRUniConformantArray):\n    item = 'c'",
  "class PBYTE_ARRAY(NDRPOINTER):\n    referent = (\n        ('Data', BYTE_ARRAY),\n    )",
  "class DEVMODE_CONTAINER(NDRSTRUCT):\n    structure =  (\n        ('cbBuf',DWORD),\n        ('pDevMode',PBYTE_ARRAY),\n    )",
  "class SPLCLIENT_INFO_1(NDRSTRUCT):\n    structure =  (\n        ('dwSize',DWORD),\n        ('pMachineName',LPWSTR),\n        ('pUserName',LPWSTR),\n        ('dwBuildNum',DWORD),\n        ('dwMajorVersion',DWORD),\n        ('dwMinorVersion',DWORD),\n        ('wProcessorArchitecture',USHORT),\n    )",
  "class PSPLCLIENT_INFO_1(NDRPOINTER):\n    referent = (\n        ('Data', SPLCLIENT_INFO_1),\n    )",
  "class SPLCLIENT_INFO_2(NDRSTRUCT):\n    structure =  (\n        ('notUsed',ULONGLONG),\n    )",
  "class PSPLCLIENT_INFO_2(NDRPOINTER):\n    referent = (\n        ('Data', SPLCLIENT_INFO_2),\n    )",
  "class SPLCLIENT_INFO_3(NDRSTRUCT):\n    structure =  (\n        ('cbSize',UINT),\n        ('dwFlags',DWORD),\n        ('dwFlags',DWORD),\n        ('pMachineName',LPWSTR),\n        ('pUserName',LPWSTR),\n        ('dwBuildNum',DWORD),\n        ('dwMajorVersion',DWORD),\n        ('dwMinorVersion',DWORD),\n        ('wProcessorArchitecture',USHORT),\n        ('hSplPrinter',ULONGLONG),\n    )",
  "class PSPLCLIENT_INFO_3(NDRPOINTER):\n    referent = (\n        ('Data', SPLCLIENT_INFO_3),\n    )",
  "class DRIVER_INFO_1(NDRSTRUCT):\n    structure = (\n        ('pName', STRING_HANDLE ),\n    )",
  "class PDRIVER_INFO_1(NDRPOINTER):\n    referent = (\n        ('Data', DRIVER_INFO_1),\n    )",
  "class DRIVER_INFO_2(NDRSTRUCT):\n    structure = (\n        ('cVersion',DWORD),\n        ('pName', LPWSTR),\n        ('pEnvironment', LPWSTR),\n        ('pDriverPath', LPWSTR),\n        ('pDataFile', LPWSTR),\n        ('pConfigFile', LPWSTR),\n    )",
  "class PDRIVER_INFO_2(NDRPOINTER):\n    referent = (\n        ('Data', DRIVER_INFO_2),\n    )",
  "class DRIVER_INFO_UNION(NDRUNION):\n    commonHdr = (\n        ('tag', ULONG),\n    )\n    union = {\n        1 : ('pNotUsed', PDRIVER_INFO_1),\n        2 : ('Level2', PDRIVER_INFO_2),\n    }",
  "class DRIVER_CONTAINER(NDRSTRUCT):\n    structure =  (\n        ('Level', DWORD),\n        ('DriverInfo', DRIVER_INFO_UNION),\n    )",
  "class CLIENT_INFO_UNION(NDRUNION):\n    commonHdr = (\n        ('tag', ULONG),\n    )\n    union = {\n        1 : ('pClientInfo1', PSPLCLIENT_INFO_1),\n        2 : ('pNotUsed1', PSPLCLIENT_INFO_2),\n        3 : ('pNotUsed2', PSPLCLIENT_INFO_3),\n    }",
  "class SPLCLIENT_CONTAINER(NDRSTRUCT):\n    structure =  (\n        ('Level',DWORD),\n        ('ClientInfo',CLIENT_INFO_UNION),\n    )",
  "class USHORT_ARRAY(NDRUniConformantArray):\n    item = '<H'",
  "class PUSHORT_ARRAY(NDRPOINTER):\n    referent = (\n        ('Data', USHORT_ARRAY),\n    )",
  "class RpcAsync_V2_NOTIFY_OPTIONS_TYPE(NDRSTRUCT):\n    structure =  (\n        ('Type',USHORT),\n        ('Reserved0',USHORT),\n        ('Reserved1',DWORD),\n        ('Reserved2',DWORD),\n        ('Count',DWORD),\n        ('pFields',PUSHORT_ARRAY),\n    )",
  "class PRPC_V2_NOTIFY_OPTIONS_TYPE_ARRAY(NDRPOINTER):\n    referent = (\n        ('Data', RpcAsync_V2_NOTIFY_OPTIONS_TYPE),\n    )",
  "class RpcAsync_V2_NOTIFY_OPTIONS(NDRSTRUCT):\n    structure =  (\n        ('Version',DWORD),\n        ('Reserved',DWORD),\n        ('Count',DWORD),\n        ('pTypes',PRPC_V2_NOTIFY_OPTIONS_TYPE_ARRAY),\n    )",
  "class PRPC_V2_NOTIFY_OPTIONS(NDRPOINTER):\n    referent = (\n        ('Data', RpcAsync_V2_NOTIFY_OPTIONS),\n    )",
  "class RpcAsyncEnumPrinters(NDRCALL):\n    opnum = 38\n    structure = (\n       ('Flags', DWORD),\n       ('Name', STRING_HANDLE),\n       ('Level', DWORD),\n       ('pPrinterEnum', PBYTE_ARRAY),\n       ('cbBuf', DWORD),\n    )",
  "class RpcAsyncEnumPrintersResponse(NDRCALL):\n    structure = (\n       ('pPrinterEnum', PBYTE_ARRAY),\n       ('pcbNeeded', DWORD),\n       ('pcReturned', DWORD),\n       ('ErrorCode', ULONG),\n    )",
  "class RpcAsyncOpenPrinter(NDRCALL):\n    opnum = 0\n    structure = (\n       ('pPrinterName', STRING_HANDLE),\n       ('pDatatype', LPWSTR),\n       ('pDevModeContainer', DEVMODE_CONTAINER),\n       ('AccessRequired', DWORD),\n       ('pClientInfo', SPLCLIENT_CONTAINER),\n    )",
  "class RpcAsyncOpenPrinterResponse(NDRCALL):\n    structure = (\n       ('pHandle', PRINTER_HANDLE),\n       ('ErrorCode', ULONG),\n    )",
  "class RpcAsyncClosePrinter(NDRCALL):\n    opnum = 20\n    structure = (\n       ('phPrinter', PRINTER_HANDLE),\n    )",
  "class RpcAsyncClosePrinterResponse(NDRCALL):\n    structure = (\n       ('phPrinter', PRINTER_HANDLE),\n       ('ErrorCode', ULONG),\n    )",
  "class RpcAsyncEnumPrinterDrivers(NDRCALL):\n    opnum = 40\n    structure = (\n       ('pName', STRING_HANDLE),\n       ('pEnvironment', LPWSTR),\n       ('Level', DWORD),\n       ('pDrivers', PBYTE_ARRAY),\n       ('cbBuf', DWORD),\n    )",
  "class RpcAsyncEnumPrinterDriversResponse(NDRCALL):\n    structure = (\n       ('pDrivers', PBYTE_ARRAY),\n       ('pcbNeeded', DWORD),\n       ('pcReturned', DWORD),\n       ('ErrorCode', ULONG),\n    )",
  "class RpcAsyncGetPrinterDriverDirectory(NDRCALL):\n   opnum = 41\n   structure = (\n       ('pName', STRING_HANDLE),\n       ('pEnvironment', LPWSTR),\n       ('Level', DWORD),\n       ('pDriverDirectory', PBYTE_ARRAY),\n       ('cbBuf', DWORD)\n   )",
  "class RpcAsyncGetPrinterDriverDirectoryResponse(NDRCALL):\n    structure = (\n       ('pDriverDirectory', PBYTE_ARRAY),\n       ('pcbNeeded', DWORD),\n       ('ErrorCode', ULONG)\n    )",
  "class RpcAsyncAddPrinterDriver(NDRCALL):\n    opnum = 39\n    structure = (\n       ('pName', STRING_HANDLE),\n       ('pDriverContainer', DRIVER_CONTAINER),\n       ('dwFileCopyFlags', DWORD),\n    )",
  "class RpcAsyncAddPrinterDriverResponse(NDRCALL):\n    structure = (\n       ('ErrorCode', ULONG),\n    )",
  "def checkNullString(string):\n    if string == NULL:\n        return string\n\n    if string[-1:] != '\\x00':\n        return string + '\\x00'\n    else:\n        return string",
  "def hRpcAsyncClosePrinter(dce, phPrinter):\n    \"\"\"\n    RpcClosePrinter closes a handle to a printer object, server object, job object, or port object.\n    Full Documentation: https://msdn.microsoft.com/en-us/library/cc244768.aspx\n\n    :param DCERPC_v5 dce: a connected DCE instance.\n    :param PRINTER_HANDLE phPrinter: A handle to a printer object, server object, job object, or port object.\n\n    :return: a RpcClosePrinterResponse instance, raises DCERPCSessionError on error.\n    \"\"\"\n    request = RpcAsyncClosePrinter()\n    request['phPrinter'] = phPrinter\n    return dce.request(request, MSRPC_UUID_WINSPOOL)",
  "def hRpcAsyncOpenPrinter(dce, printerName, pDatatype=NULL, pDevModeContainer=NULL, accessRequired=SERVER_READ,\n                      pClientInfo=NULL):\n    \"\"\"\n    RpcOpenPrinterEx retrieves a handle for a printer, port, port monitor, print job, or print server\n    Full Documentation: https://msdn.microsoft.com/en-us/library/cc244809.aspx\n\n    :param DCERPC_v5 dce: a connected DCE instance.\n    :param string printerName: A string for a printer connection, printer object, server object, job object, port\n    object, or port monitor object. This MUST be a Domain Name System (DNS), NetBIOS, Internet Protocol version 4\n    (IPv4), Internet Protocol version 6 (IPv6), or Universal Naming Convention (UNC) name that remote procedure\n    call (RpcAsync) binds to, and it MUST uniquely identify a print server on the network.\n    :param string pDatatype: A string that specifies the data type to be associated with the printer handle.\n    :param DEVMODE_CONTAINER pDevModeContainer: A DEVMODE_CONTAINER structure. This parameter MUST adhere to the specification in\n    DEVMODE_CONTAINER Parameters (section 3.1.4.1.8.1).\n    :param int accessRequired: The access level that the client requires for interacting with the object to which a\n    handle is being opened.\n    :param SPLCLIENT_CONTAINER pClientInfo: This parameter MUST adhere to the specification in SPLCLIENT_CONTAINER Parameters.\n\n    :return: a RpcOpenPrinterExResponse instance, raises DCERPCSessionError on error.\n    \"\"\"\n    request = RpcAsyncOpenPrinter()\n    request['pPrinterName'] = checkNullString(printerName)\n    request['pDatatype'] = pDatatype\n    if pDevModeContainer is NULL:\n        request['pDevModeContainer']['pDevMode'] = NULL\n    else:\n        request['pDevModeContainer'] = pDevModeContainer\n\n    request['AccessRequired'] = accessRequired\n    if pClientInfo is NULL:\n        raise Exception('pClientInfo cannot be NULL')\n\n    request['pClientInfo'] = pClientInfo\n    return dce.request(request, MSRPC_UUID_WINSPOOL)",
  "def hRpcAsyncEnumPrinters(dce, flags, name = NULL, level = 1):\n    \"\"\"\n    RpcEnumPrinters enumerates available printers, print servers, domains, or print providers.\n    Full Documentation: https://msdn.microsoft.com/en-us/library/cc244794.aspx\n\n    :param DCERPC_v5 dce: a connected DCE instance.\n    :param int flags: The types of print objects that this method enumerates. The value of this parameter is the\n    result of a bitwise OR of one or more of the Printer Enumeration Flags (section 2.2.3.7).\n    :param string name: NULL or a server name parameter as specified in Printer Server Name Parameters (section 3.1.4.1.4).\n    :param level: The level of printer information structure.\n\n    :return: a RpcEnumPrintersResponse instance, raises DCERPCSessionError on error.\n    \"\"\"\n    request = RpcAsyncEnumPrinters()\n    request['Flags'] = flags\n    request['Name'] = name\n    request['pPrinterEnum'] = NULL\n    request['Level'] = level\n    bytesNeeded = 0\n    try:\n        dce.request(request, MSRPC_UUID_WINSPOOL)\n    except DCERPCSessionError as e:\n        if str(e).find('ERROR_INSUFFICIENT_BUFFER') < 0:\n            raise\n        bytesNeeded = e.get_packet()['pcbNeeded']\n\n    request = RpcAsyncEnumPrinters()\n    request['Flags'] = flags\n    request['Name'] = name\n    request['Level'] = level\n\n    request['cbBuf'] = bytesNeeded\n    request['pPrinterEnum'] = b'a' * bytesNeeded\n    return dce.request(request, MSRPC_UUID_WINSPOOL)",
  "def hRpcAsyncAddPrinterDriver(dce, pName, pDriverContainer, dwFileCopyFlags):\n    \"\"\"\n    RpcAddPrinterDriverEx installs a printer driver on the print server\n    Full Documentation: https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-rprn/b96cc497-59e5-4510-ab04-5484993b259b\n\n    :param DCERPC_v5 dce: a connected DCE instance.\n    :param pName\n    :param pDriverContainer\n    :param dwFileCopyFlags\n\n    :return: raises DCERPCSessionError on error.\n    \"\"\"\n    request = RpcAsyncAddPrinterDriver()\n    request['pName'] = checkNullString(pName)\n    request['pDriverContainer'] = pDriverContainer\n    request['dwFileCopyFlags'] = dwFileCopyFlags\n\n    #return request\n    return dce.request(request, MSRPC_UUID_WINSPOOL)",
  "def hRpcAsyncEnumPrinterDrivers(dce, pName, pEnvironment, Level):\n    \"\"\"\n    RpcEnumPrinterDrivers enumerates the printer drivers installed on a specified print server.\n    Full Documentation: https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-rprn/857d00ac-3682-4a0d-86ca-3d3c372e5e4a\n\n    :param DCERPC_v5 dce: a connected DCE instance.\n    :param pName\n    :param pEnvironment\n    :param Level\n    :param pDrivers\n    :param cbBuf\n    :param pcbNeeded\n    :param pcReturned\n\n    :return: raises DCERPCSessionError on error.\n    \"\"\"\n    # get value for cbBuf\n    request = RpcAsyncEnumPrinterDrivers()\n    request['pName']        = checkNullString(pName)\n    request['pEnvironment'] = pEnvironment\n    request['Level']        = Level\n    request['pDrivers']     = NULL\n    request['cbBuf']        = 0\n    try:\n        dce.request(request, MSRPC_UUID_WINSPOOL)\n    except DCERPCSessionError as e:\n        if str(e).find('ERROR_INSUFFICIENT_BUFFER') < 0:\n            raise\n        bytesNeeded = e.get_packet()['pcbNeeded']\n\n    # now do RpcEnumPrinterDrivers again\n    request = RpcAsyncEnumPrinterDrivers()\n    request['pName']        = checkNullString(pName)\n    request['pEnvironment'] = pEnvironment\n    request['Level']        = Level\n    request['pDrivers']     = b'a' * bytesNeeded\n    request['cbBuf']        = bytesNeeded\n\n    #return request\n    return dce.request(request, MSRPC_UUID_WINSPOOL)",
  "def hRpcAsyncGetPrinterDriverDirectory(dce, pName, pEnvironment, Level):\n    \"\"\"\n    RpcAsyncGetPrinterDriverDirectory retrieves the path of the printer driver directory.\n    Full Documentation: https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-par/92206fb2-dd31-47f4-8d12-4cd239b71d78\n\n    :param DCERPC_v5 dce: a connected DCE instance.\n    :param pName\n    :param pEnvironment\n    :param Level\n    :param pDriverDirectory\n    :param cbBuf\n    :param pcbNeeded\n\n    :return: raises DCERPCSessionError on error.\n    \"\"\"\n    # get value for cbBuf\n    request = RpcAsyncGetPrinterDriverDirectory()\n    request['pName']            = checkNullString(pName)\n    request['pEnvironment']     = pEnvironment\n    request['Level']            = Level\n    request['pDriverDirectory'] = NULL\n    request['cbBuf']            = 0\n    try:\n        dce.request(request, MSRPC_UUID_WINSPOOL)\n    except DCERPCSessionError as e:\n        if str(e).find('ERROR_INSUFFICIENT_BUFFER') < 0:\n            raise\n        bytesNeeded = e.get_packet()['pcbNeeded']\n    \n    # now do RpcGetPrinterDriverDirectory again\n    request = RpcAsyncGetPrinterDriverDirectory()\n    request['pName']            = checkNullString(pName)\n    request['pEnvironment']     = pEnvironment\n    request['Level']            = Level\n    request['pDriverDirectory'] = b'a' * bytesNeeded\n    request['cbBuf']            = bytesNeeded\n    \n    return dce.request(request, MSRPC_UUID_WINSPOOL)",
  "def __init__(self, error_string=None, error_code=None, packet=None):\n        DCERPCException.__init__(self, error_string, error_code, packet)",
  "def __str__( self ):\n        key = self.error_code\n        if key in system_errors.ERROR_MESSAGES:\n            error_msg_short = system_errors.ERROR_MESSAGES[key][0]\n            error_msg_verbose = system_errors.ERROR_MESSAGES[key][1] \n            return 'RPRN SessionError: code: 0x%x - %s - %s' % (self.error_code, error_msg_short, error_msg_verbose)\n        else:\n            return 'RPRN SessionError: unknown error code: 0x%x' % self.error_code",
  "def getAlignment(self):\n        if self._isNDR64 is True:\n            return 8\n        else:\n            return 4",
  "class DCERPCSessionError(DCERPCException):\n    def __init__(self, error_string=None, error_code=None, packet=None):\n        DCERPCException.__init__(self, error_string, error_code, packet)\n\n    def __str__( self ):\n        key = self.error_code\n        if key in system_errors.ERROR_MESSAGES:\n            error_msg_short = system_errors.ERROR_MESSAGES[key][0]\n            error_msg_verbose = system_errors.ERROR_MESSAGES[key][1] \n            return 'DSSP SessionError: code: 0x%x - %s - %s' % (self.error_code, error_msg_short, error_msg_verbose)\n        else:\n            return 'DSSP SessionError: unknown error code: 0x%x' % self.error_code",
  "class DSROLE_MACHINE_ROLE(NDRENUM):\n    class enumItems(Enum):\n        DsRole_RoleStandaloneWorkstation   = 0\n        DsRole_RoleMemberWorkstation       = 1\n        DsRole_RoleStandaloneServer        = 2\n        DsRole_RoleMemberServer            = 3\n        DsRole_RoleBackupDomainController  = 4\n        DsRole_RolePrimaryDomainController = 5",
  "class DSROLER_PRIMARY_DOMAIN_INFO_BASIC(NDRSTRUCT):\n    structure = (\n        ('MachineRole', DSROLE_MACHINE_ROLE),\n        ('Flags', UINT),\n        ('DomainNameFlat', LPWSTR),\n        ('DomainNameDns', LPWSTR),\n        ('DomainForestName', LPWSTR),\n        ('DomainGuid', GUID),\n    )",
  "class PDSROLER_PRIMARY_DOMAIN_INFO_BASIC(NDRPOINTER):\n    referent = (\n        ('Data', DSROLER_PRIMARY_DOMAIN_INFO_BASIC),\n    )",
  "class DSROLE_OPERATION_STATE(NDRENUM):\n    class enumItems(Enum):\n        DsRoleOperationIdle       = 0\n        DsRoleOperationActive     = 1\n        DsRoleOperationNeedReboot = 2",
  "class DSROLE_OPERATION_STATE_INFO(NDRSTRUCT):\n    structure = (\n        ('OperationState', DSROLE_OPERATION_STATE),\n    )",
  "class PDSROLE_OPERATION_STATE_INFO(NDRPOINTER):\n    referent = (\n        ('Data', DSROLE_OPERATION_STATE_INFO),\n    )",
  "class DSROLE_SERVER_STATE(NDRENUM):\n    class enumItems(Enum):\n        DsRoleServerUnknown = 0\n        DsRoleServerPrimary = 1\n        DsRoleServerBackup  = 2",
  "class PDSROLE_SERVER_STATE(NDRPOINTER):\n    referent = (\n        ('Data', DSROLE_SERVER_STATE),\n    )",
  "class DSROLE_UPGRADE_STATUS_INFO(NDRSTRUCT):\n    structure = (\n        ('OperationState', UINT),\n        ('PreviousServerState', DSROLE_SERVER_STATE),\n    )",
  "class PDSROLE_UPGRADE_STATUS_INFO(NDRPOINTER):\n    referent = (\n        ('Data', DSROLE_UPGRADE_STATUS_INFO),\n    )",
  "class DSROLE_PRIMARY_DOMAIN_INFO_LEVEL(NDRENUM):\n    class enumItems(Enum):\n        DsRolePrimaryDomainInfoBasic = 1\n        DsRoleUpgradeStatus          = 2\n        DsRoleOperationState         = 3",
  "class DSROLER_PRIMARY_DOMAIN_INFORMATION(NDRUNION):\n    commonHdr = (\n        ('tag', DSROLE_PRIMARY_DOMAIN_INFO_LEVEL),\n    )\n    \n    union = {\n        DSROLE_PRIMARY_DOMAIN_INFO_LEVEL.DsRolePrimaryDomainInfoBasic : ('DomainInfoBasic', DSROLER_PRIMARY_DOMAIN_INFO_BASIC),\n        DSROLE_PRIMARY_DOMAIN_INFO_LEVEL.DsRoleUpgradeStatus          : ('UpgradStatusInfo', DSROLE_UPGRADE_STATUS_INFO),\n        DSROLE_PRIMARY_DOMAIN_INFO_LEVEL.DsRoleOperationState         : ('OperationStateInfo', DSROLE_OPERATION_STATE_INFO),\n    }",
  "class PDSROLER_PRIMARY_DOMAIN_INFORMATION(NDRPOINTER):\n    referent = (\n        ('Data', DSROLER_PRIMARY_DOMAIN_INFORMATION),\n    )",
  "class DsRolerGetPrimaryDomainInformation(NDRCALL):\n    opnum = 0\n    structure = (\n       ('InfoLevel', DSROLE_PRIMARY_DOMAIN_INFO_LEVEL),\n    )",
  "class DsRolerGetPrimaryDomainInformationResponse(NDRCALL):\n    structure = (\n       ('DomainInfo', PDSROLER_PRIMARY_DOMAIN_INFORMATION),\n    )",
  "def hDsRolerGetPrimaryDomainInformation(dce, infoLevel):\n    request = DsRolerGetPrimaryDomainInformation()\n    request['InfoLevel'] = infoLevel\n    return dce.request(request)",
  "def __init__(self, error_string=None, error_code=None, packet=None):\n        DCERPCException.__init__(self, error_string, error_code, packet)",
  "def __str__( self ):\n        key = self.error_code\n        if key in system_errors.ERROR_MESSAGES:\n            error_msg_short = system_errors.ERROR_MESSAGES[key][0]\n            error_msg_verbose = system_errors.ERROR_MESSAGES[key][1] \n            return 'DSSP SessionError: code: 0x%x - %s - %s' % (self.error_code, error_msg_short, error_msg_verbose)\n        else:\n            return 'DSSP SessionError: unknown error code: 0x%x' % self.error_code",
  "class enumItems(Enum):\n        DsRole_RoleStandaloneWorkstation   = 0\n        DsRole_RoleMemberWorkstation       = 1\n        DsRole_RoleStandaloneServer        = 2\n        DsRole_RoleMemberServer            = 3\n        DsRole_RoleBackupDomainController  = 4\n        DsRole_RolePrimaryDomainController = 5",
  "class enumItems(Enum):\n        DsRoleOperationIdle       = 0\n        DsRoleOperationActive     = 1\n        DsRoleOperationNeedReboot = 2",
  "class enumItems(Enum):\n        DsRoleServerUnknown = 0\n        DsRoleServerPrimary = 1\n        DsRoleServerBackup  = 2",
  "class enumItems(Enum):\n        DsRolePrimaryDomainInfoBasic = 1\n        DsRoleUpgradeStatus          = 2\n        DsRoleOperationState         = 3",
  "class DCERPCSessionError(DCERPCException):\n    def __init__(self, error_string=None, error_code=None, packet=None):\n        DCERPCException.__init__(self, error_string, error_code, packet)\n\n    def __str__( self ):\n        key = self.error_code\n        if key in nt_errors.ERROR_MESSAGES:\n            error_msg_short = nt_errors.ERROR_MESSAGES[key][0]\n            error_msg_verbose = nt_errors.ERROR_MESSAGES[key][1] \n            return 'LSAT SessionError: code: 0x%x - %s - %s' % (self.error_code, error_msg_short, error_msg_verbose)\n        else:\n            return 'LSAT SessionError: unknown error code: 0x%x' % self.error_code",
  "class LSAPR_REFERENCED_DOMAIN_LIST(NDRSTRUCT):\n    structure = (\n        ('Entries', ULONG),\n        ('Domains', PLSAPR_TRUST_INFORMATION_ARRAY),\n        ('MaxEntries', ULONG),\n    )",
  "class PLSAPR_REFERENCED_DOMAIN_LIST(NDRPOINTER):\n    referent = (\n        ('Data', LSAPR_REFERENCED_DOMAIN_LIST),\n    )",
  "class LSA_TRANSLATED_SID(NDRSTRUCT):\n    structure = (\n        ('Use', SID_NAME_USE),\n        ('RelativeId', ULONG),\n        ('DomainIndex', LONG),\n    )",
  "class LSA_TRANSLATED_SID_ARRAY(NDRUniConformantArray):\n    item = LSA_TRANSLATED_SID",
  "class PLSA_TRANSLATED_SID_ARRAY(NDRPOINTER):\n    referent = (\n        ('Data', LSA_TRANSLATED_SID_ARRAY),\n    )",
  "class LSAPR_TRANSLATED_SIDS(NDRSTRUCT):\n    structure = (\n        ('Entries', ULONG),\n        ('Sids', PLSA_TRANSLATED_SID_ARRAY),\n    )",
  "class LSAP_LOOKUP_LEVEL(NDRENUM):\n    class enumItems(Enum):\n        LsapLookupWksta                = 1\n        LsapLookupPDC                  = 2\n        LsapLookupTDL                  = 3\n        LsapLookupGC                   = 4\n        LsapLookupXForestReferral      = 5\n        LsapLookupXForestResolve       = 6\n        LsapLookupRODCReferralToFullDC = 7",
  "class LSAPR_SID_INFORMATION(NDRSTRUCT):\n    structure = (\n        ('Sid', PRPC_SID),\n    )",
  "class LSAPR_SID_INFORMATION_ARRAY(NDRUniConformantArray):\n    item = LSAPR_SID_INFORMATION",
  "class PLSAPR_SID_INFORMATION_ARRAY(NDRPOINTER):\n    referent = (\n        ('Data', LSAPR_SID_INFORMATION_ARRAY),\n    )",
  "class LSAPR_SID_ENUM_BUFFER(NDRSTRUCT):\n    structure = (\n        ('Entries', ULONG),\n        ('SidInfo', PLSAPR_SID_INFORMATION_ARRAY),\n    )",
  "class LSAPR_TRANSLATED_NAME(NDRSTRUCT):\n    structure = (\n        ('Use', SID_NAME_USE),\n        ('Name', RPC_UNICODE_STRING),\n        ('DomainIndex', LONG),\n    )",
  "class LSAPR_TRANSLATED_NAME_ARRAY(NDRUniConformantArray):\n    item = LSAPR_TRANSLATED_NAME",
  "class PLSAPR_TRANSLATED_NAME_ARRAY(NDRPOINTER):\n    referent = (\n        ('Data', LSAPR_TRANSLATED_NAME_ARRAY),\n    )",
  "class LSAPR_TRANSLATED_NAMES(NDRSTRUCT):\n    structure = (\n        ('Entries', ULONG),\n        ('Names', PLSAPR_TRANSLATED_NAME_ARRAY),\n    )",
  "class LSAPR_TRANSLATED_NAME_EX(NDRSTRUCT):\n    structure = (\n        ('Use', SID_NAME_USE),\n        ('Name', RPC_UNICODE_STRING),\n        ('DomainIndex', LONG),\n        ('Flags', ULONG),\n    )",
  "class LSAPR_TRANSLATED_NAME_EX_ARRAY(NDRUniConformantArray):\n    item = LSAPR_TRANSLATED_NAME_EX",
  "class PLSAPR_TRANSLATED_NAME_EX_ARRAY(NDRPOINTER):\n    referent = (\n        ('Data', LSAPR_TRANSLATED_NAME_EX_ARRAY),\n    )",
  "class LSAPR_TRANSLATED_NAMES_EX(NDRSTRUCT):\n    structure = (\n        ('Entries', ULONG),\n        ('Names', PLSAPR_TRANSLATED_NAME_EX_ARRAY),\n    )",
  "class LSAPR_TRANSLATED_SID_EX(NDRSTRUCT):\n    structure = (\n        ('Use', SID_NAME_USE),\n        ('RelativeId', ULONG),\n        ('DomainIndex', LONG),\n        ('Flags', ULONG),\n    )",
  "class LSAPR_TRANSLATED_SID_EX_ARRAY(NDRUniConformantArray):\n    item = LSAPR_TRANSLATED_SID_EX",
  "class PLSAPR_TRANSLATED_SID_EX_ARRAY(NDRPOINTER):\n    referent = (\n        ('Data', LSAPR_TRANSLATED_SID_EX_ARRAY),\n    )",
  "class LSAPR_TRANSLATED_SIDS_EX(NDRSTRUCT):\n    structure = (\n        ('Entries', ULONG),\n        ('Sids', PLSAPR_TRANSLATED_SID_EX_ARRAY),\n    )",
  "class LSAPR_TRANSLATED_SID_EX2(NDRSTRUCT):\n    structure = (\n        ('Use', SID_NAME_USE),\n        ('Sid', PRPC_SID),\n        ('DomainIndex', LONG),\n        ('Flags', ULONG),\n    )",
  "class LSAPR_TRANSLATED_SID_EX2_ARRAY(NDRUniConformantArray):\n    item = LSAPR_TRANSLATED_SID_EX2",
  "class PLSAPR_TRANSLATED_SID_EX2_ARRAY(NDRPOINTER):\n    referent = (\n        ('Data', LSAPR_TRANSLATED_SID_EX2_ARRAY),\n    )",
  "class LSAPR_TRANSLATED_SIDS_EX2(NDRSTRUCT):\n    structure = (\n        ('Entries', ULONG),\n        ('Sids', PLSAPR_TRANSLATED_SID_EX2_ARRAY),\n    )",
  "class RPC_UNICODE_STRING_ARRAY(NDRUniConformantArray):\n    item = RPC_UNICODE_STRING",
  "class LsarGetUserName(NDRCALL):\n    opnum = 45\n    structure = (\n       ('SystemName', LPWSTR),\n       ('UserName', PRPC_UNICODE_STRING),\n       ('DomainName', PRPC_UNICODE_STRING),\n    )",
  "class LsarGetUserNameResponse(NDRCALL):\n    structure = (\n       ('UserName', PRPC_UNICODE_STRING),\n       ('DomainName', PRPC_UNICODE_STRING),\n       ('ErrorCode', NTSTATUS),\n    )",
  "class LsarLookupNames4(NDRCALL):\n    opnum = 77\n    structure = (\n       ('Count', ULONG),\n       ('Names', RPC_UNICODE_STRING_ARRAY),\n       ('TranslatedSids', LSAPR_TRANSLATED_SIDS_EX2),\n       ('LookupLevel', LSAP_LOOKUP_LEVEL),\n       ('MappedCount', ULONG),\n       ('LookupOptions', ULONG),\n       ('ClientRevision', ULONG),\n    )",
  "class LsarLookupNames4Response(NDRCALL):\n    structure = (\n       ('ReferencedDomains', PLSAPR_REFERENCED_DOMAIN_LIST),\n       ('TranslatedSids', LSAPR_TRANSLATED_SIDS_EX2),\n       ('MappedCount', ULONG),\n       ('ErrorCode', NTSTATUS),\n    )",
  "class LsarLookupNames3(NDRCALL):\n    opnum = 68\n    structure = (\n       ('PolicyHandle', LSAPR_HANDLE),\n       ('Count', ULONG),\n       ('Names', RPC_UNICODE_STRING_ARRAY),\n       ('TranslatedSids', LSAPR_TRANSLATED_SIDS_EX2),\n       ('LookupLevel', LSAP_LOOKUP_LEVEL),\n       ('MappedCount', ULONG),\n       ('LookupOptions', ULONG),\n       ('ClientRevision', ULONG),\n    )",
  "class LsarLookupNames3Response(NDRCALL):\n    structure = (\n       ('ReferencedDomains', PLSAPR_REFERENCED_DOMAIN_LIST),\n       ('TranslatedSids', LSAPR_TRANSLATED_SIDS_EX2),\n       ('MappedCount', ULONG),\n       ('ErrorCode', NTSTATUS),\n    )",
  "class LsarLookupNames2(NDRCALL):\n    opnum = 58\n    structure = (\n       ('PolicyHandle', LSAPR_HANDLE),\n       ('Count', ULONG),\n       ('Names', RPC_UNICODE_STRING_ARRAY),\n       ('TranslatedSids', LSAPR_TRANSLATED_SIDS_EX),\n       ('LookupLevel', LSAP_LOOKUP_LEVEL),\n       ('MappedCount', ULONG),\n       ('LookupOptions', ULONG),\n       ('ClientRevision', ULONG),\n    )",
  "class LsarLookupNames2Response(NDRCALL):\n    structure = (\n       ('ReferencedDomains', PLSAPR_REFERENCED_DOMAIN_LIST),\n       ('TranslatedSids', LSAPR_TRANSLATED_SIDS_EX),\n       ('MappedCount', ULONG),\n       ('ErrorCode', NTSTATUS),\n    )",
  "class LsarLookupNames(NDRCALL):\n    opnum = 14\n    structure = (\n       ('PolicyHandle', LSAPR_HANDLE),\n       ('Count', ULONG),\n       ('Names', RPC_UNICODE_STRING_ARRAY),\n       ('TranslatedSids', LSAPR_TRANSLATED_SIDS),\n       ('LookupLevel', LSAP_LOOKUP_LEVEL),\n       ('MappedCount', ULONG),\n    )",
  "class LsarLookupNamesResponse(NDRCALL):\n    structure = (\n       ('ReferencedDomains', PLSAPR_REFERENCED_DOMAIN_LIST),\n       ('TranslatedSids', LSAPR_TRANSLATED_SIDS),\n       ('MappedCount', ULONG),\n       ('ErrorCode', NTSTATUS),\n    )",
  "class LsarLookupSids3(NDRCALL):\n    opnum = 76\n    structure = (\n       ('SidEnumBuffer', LSAPR_SID_ENUM_BUFFER),\n       ('TranslatedNames', LSAPR_TRANSLATED_NAMES_EX),\n       ('LookupLevel', LSAP_LOOKUP_LEVEL),\n       ('MappedCount', ULONG),\n       ('LookupOptions', ULONG),\n       ('ClientRevision', ULONG),\n    )",
  "class LsarLookupSids3Response(NDRCALL):\n    structure = (\n       ('ReferencedDomains', PLSAPR_REFERENCED_DOMAIN_LIST),\n       ('TranslatedNames', LSAPR_TRANSLATED_NAMES_EX),\n       ('MappedCount', ULONG),\n       ('ErrorCode', NTSTATUS),\n    )",
  "class LsarLookupSids2(NDRCALL):\n    opnum = 57\n    structure = (\n       ('PolicyHandle', LSAPR_HANDLE),\n       ('SidEnumBuffer', LSAPR_SID_ENUM_BUFFER),\n       ('TranslatedNames', LSAPR_TRANSLATED_NAMES_EX),\n       ('LookupLevel', LSAP_LOOKUP_LEVEL),\n       ('MappedCount', ULONG),\n       ('LookupOptions', ULONG),\n       ('ClientRevision', ULONG),\n    )",
  "class LsarLookupSids2Response(NDRCALL):\n    structure = (\n       ('ReferencedDomains', PLSAPR_REFERENCED_DOMAIN_LIST),\n       ('TranslatedNames', LSAPR_TRANSLATED_NAMES_EX),\n       ('MappedCount', ULONG),\n       ('ErrorCode', NTSTATUS),\n    )",
  "class LsarLookupSids(NDRCALL):\n    opnum = 15\n    structure = (\n       ('PolicyHandle', LSAPR_HANDLE),\n       ('SidEnumBuffer', LSAPR_SID_ENUM_BUFFER),\n       ('TranslatedNames', LSAPR_TRANSLATED_NAMES),\n       ('LookupLevel', LSAP_LOOKUP_LEVEL),\n       ('MappedCount', ULONG),\n    )",
  "class LsarLookupSidsResponse(NDRCALL):\n    structure = (\n       ('ReferencedDomains', PLSAPR_REFERENCED_DOMAIN_LIST),\n       ('TranslatedNames', LSAPR_TRANSLATED_NAMES),\n       ('MappedCount', ULONG),\n       ('ErrorCode', NTSTATUS),\n    )",
  "def hLsarGetUserName(dce, userName = NULL, domainName = NULL):\n    request = LsarGetUserName()\n    request['SystemName'] = NULL\n    request['UserName'] = userName\n    request['DomainName'] = domainName\n    return dce.request(request)",
  "def hLsarLookupNames4(dce, names, lookupLevel = LSAP_LOOKUP_LEVEL.LsapLookupWksta, lookupOptions=0x00000000, clientRevision=0x00000001):\n    request = LsarLookupNames4()\n    request['Count'] = len(names)\n    for name in names:\n        itemn = RPC_UNICODE_STRING()\n        itemn['Data'] = name\n        request['Names'].append(itemn)\n    request['TranslatedSids']['Sids'] = NULL\n    request['LookupLevel'] = lookupLevel\n    request['LookupOptions'] = lookupOptions\n    request['ClientRevision'] = clientRevision\n\n    return dce.request(request)",
  "def hLsarLookupNames3(dce, policyHandle, names, lookupLevel = LSAP_LOOKUP_LEVEL.LsapLookupWksta, lookupOptions=0x00000000, clientRevision=0x00000001):\n    request = LsarLookupNames3()\n    request['PolicyHandle'] = policyHandle\n    request['Count'] = len(names)\n    for name in names:\n        itemn = RPC_UNICODE_STRING()\n        itemn['Data'] = name\n        request['Names'].append(itemn)\n    request['TranslatedSids']['Sids'] = NULL\n    request['LookupLevel'] = lookupLevel\n    request['LookupOptions'] = lookupOptions\n    request['ClientRevision'] = clientRevision\n\n    return dce.request(request)",
  "def hLsarLookupNames2(dce, policyHandle, names, lookupLevel = LSAP_LOOKUP_LEVEL.LsapLookupWksta, lookupOptions=0x00000000, clientRevision=0x00000001):\n    request = LsarLookupNames2()\n    request['PolicyHandle'] = policyHandle\n    request['Count'] = len(names)\n    for name in names:\n        itemn = RPC_UNICODE_STRING()\n        itemn['Data'] = name\n        request['Names'].append(itemn)\n    request['TranslatedSids']['Sids'] = NULL\n    request['LookupLevel'] = lookupLevel\n    request['LookupOptions'] = lookupOptions\n    request['ClientRevision'] = clientRevision\n\n    return dce.request(request)",
  "def hLsarLookupNames(dce, policyHandle, names, lookupLevel = LSAP_LOOKUP_LEVEL.LsapLookupWksta):\n    request = LsarLookupNames()\n    request['PolicyHandle'] = policyHandle\n    request['Count'] = len(names)\n    for name in names:\n        itemn = RPC_UNICODE_STRING()\n        itemn['Data'] = name\n        request['Names'].append(itemn)\n    request['TranslatedSids']['Sids'] = NULL\n    request['LookupLevel'] = lookupLevel\n\n    return dce.request(request)",
  "def hLsarLookupSids2(dce, policyHandle, sids, lookupLevel = LSAP_LOOKUP_LEVEL.LsapLookupWksta, lookupOptions=0x00000000, clientRevision=0x00000001):\n    request = LsarLookupSids2()\n    request['PolicyHandle'] = policyHandle\n    request['SidEnumBuffer']['Entries'] = len(sids)\n    for sid in sids:\n        itemn = LSAPR_SID_INFORMATION()\n        itemn['Sid'].fromCanonical(sid)\n        request['SidEnumBuffer']['SidInfo'].append(itemn)\n\n    request['TranslatedNames']['Names'] = NULL\n    request['LookupLevel'] = lookupLevel\n    request['LookupOptions'] = lookupOptions\n    request['ClientRevision'] = clientRevision\n\n    return dce.request(request)",
  "def hLsarLookupSids(dce, policyHandle, sids, lookupLevel = LSAP_LOOKUP_LEVEL.LsapLookupWksta):\n    request = LsarLookupSids()\n    request['PolicyHandle'] = policyHandle\n    request['SidEnumBuffer']['Entries'] = len(sids)\n    for sid in sids:\n        itemn = LSAPR_SID_INFORMATION()\n        itemn['Sid'].fromCanonical(sid)\n        request['SidEnumBuffer']['SidInfo'].append(itemn)\n\n    request['TranslatedNames']['Names'] = NULL\n    request['LookupLevel'] = lookupLevel\n\n    return dce.request(request)",
  "def __init__(self, error_string=None, error_code=None, packet=None):\n        DCERPCException.__init__(self, error_string, error_code, packet)",
  "def __str__( self ):\n        key = self.error_code\n        if key in nt_errors.ERROR_MESSAGES:\n            error_msg_short = nt_errors.ERROR_MESSAGES[key][0]\n            error_msg_verbose = nt_errors.ERROR_MESSAGES[key][1] \n            return 'LSAT SessionError: code: 0x%x - %s - %s' % (self.error_code, error_msg_short, error_msg_verbose)\n        else:\n            return 'LSAT SessionError: unknown error code: 0x%x' % self.error_code",
  "class enumItems(Enum):\n        LsapLookupWksta                = 1\n        LsapLookupPDC                  = 2\n        LsapLookupTDL                  = 3\n        LsapLookupGC                   = 4\n        LsapLookupXForestReferral      = 5\n        LsapLookupXForestResolve       = 6\n        LsapLookupRODCReferralToFullDC = 7",
  "class DCERPCSessionError(DCERPCException):\n    def __init__(self, error_string=None, error_code=None, packet=None):\n        DCERPCException.__init__(self, error_string, error_code, packet)\n\n    def __str__( self ):\n        key = self.error_code\n        if key in system_errors.ERROR_MESSAGES:\n            error_msg_short = system_errors.ERROR_MESSAGES[key][0]\n            error_msg_verbose = system_errors.ERROR_MESSAGES[key][1]\n            return 'NRPC SessionError: code: 0x%x - %s - %s' % (self.error_code, error_msg_short, error_msg_verbose)\n        elif key in nt_errors.ERROR_MESSAGES:\n            error_msg_short = nt_errors.ERROR_MESSAGES[key][0]\n            error_msg_verbose = nt_errors.ERROR_MESSAGES[key][1]\n            return 'NRPC SessionError: code: 0x%x - %s - %s' % (self.error_code, error_msg_short, error_msg_verbose)\n        else:\n            return 'NRPC SessionError: unknown error code: 0x%x' % (self.error_code)",
  "class CYPHER_BLOCK(NDRSTRUCT):\n    structure = (\n        ('Data', '8s=b\"\"'),\n    )\n    def getAlignment(self):\n        return 1",
  "class CYPHER_BLOCK_ARRAY(NDRUniFixedArray):\n    def getDataLen(self, data, offset=0):\n        return len(CYPHER_BLOCK())*2",
  "class LM_OWF_PASSWORD(NDRSTRUCT):\n    structure = (\n        ('Data', CYPHER_BLOCK_ARRAY),\n    )",
  "class UCHAR_FIXED_ARRAY(NDRUniFixedArray):\n    align = 1\n    def getDataLen(self, data, offset=0):\n        return len(CYPHER_BLOCK())",
  "class NETLOGON_CREDENTIAL(NDRSTRUCT):\n    structure = (\n        ('Data',UCHAR_FIXED_ARRAY),\n    )\n    def getAlignment(self):\n        return 1",
  "class NETLOGON_AUTHENTICATOR(NDRSTRUCT):\n    structure = (\n        ('Credential', NETLOGON_CREDENTIAL),\n        ('Timestamp', DWORD),\n    )",
  "class PNETLOGON_AUTHENTICATOR(NDRPOINTER):\n    referent = (\n        ('Data', NETLOGON_AUTHENTICATOR),\n    )",
  "class DOMAIN_CONTROLLER_INFOW(NDRSTRUCT):\n    structure = (\n        ('DomainControllerName', LPWSTR),\n        ('DomainControllerAddress', LPWSTR),\n        ('DomainControllerAddressType', ULONG),\n        ('DomainGuid', GUID),\n        ('DomainName', LPWSTR),\n        ('DnsForestName', LPWSTR),\n        ('Flags', ULONG),\n        ('DcSiteName', LPWSTR),\n        ('ClientSiteName', LPWSTR),\n    )",
  "class PDOMAIN_CONTROLLER_INFOW(NDRPOINTER):\n    referent = (\n        ('Data', DOMAIN_CONTROLLER_INFOW),\n    )",
  "class RPC_UNICODE_STRING_ARRAY(NDRUniConformantArray):\n    item = RPC_UNICODE_STRING",
  "class PRPC_UNICODE_STRING_ARRAY(NDRPOINTER):\n    referent = (\n        ('Data', RPC_UNICODE_STRING_ARRAY),\n    )",
  "class NL_SITE_NAME_ARRAY(NDRSTRUCT):\n    structure = (\n        ('EntryCount', ULONG),\n        ('SiteNames', PRPC_UNICODE_STRING_ARRAY),\n    )",
  "class PNL_SITE_NAME_ARRAY(NDRPOINTER):\n    referent = (\n        ('Data', NL_SITE_NAME_ARRAY),\n    )",
  "class RPC_UNICODE_STRING_ARRAY(NDRUniConformantArray):\n    item = RPC_UNICODE_STRING",
  "class NL_SITE_NAME_EX_ARRAY(NDRSTRUCT):\n    structure = (\n        ('EntryCount', ULONG),\n        ('SiteNames', PRPC_UNICODE_STRING_ARRAY),\n        ('SubnetNames', PRPC_UNICODE_STRING_ARRAY),\n    )",
  "class PNL_SITE_NAME_EX_ARRAY(NDRPOINTER):\n    referent = (\n        ('Data', NL_SITE_NAME_EX_ARRAY),\n    )",
  "class IPv4Address(Structure):\n    structure = (\n        ('AddressFamily', '<H=0'),\n        ('Port', '<H=0'),\n        ('Address', '<L=0'),\n        ('Padding', '<L=0'),\n    )",
  "class UCHAR_ARRAY(NDRUniConformantArray):\n    item = 'c'",
  "class PUCHAR_ARRAY(NDRPOINTER):\n    referent = (\n        ('Data', UCHAR_ARRAY),\n    )",
  "class NL_SOCKET_ADDRESS(NDRSTRUCT):\n    structure = (\n        ('lpSockaddr', PUCHAR_ARRAY),\n        ('iSockaddrLength', ULONG),\n    )",
  "class NL_SOCKET_ADDRESS_ARRAY(NDRUniConformantArray):\n    item = NL_SOCKET_ADDRESS",
  "class NL_DNS_NAME_INFO(NDRSTRUCT):\n    structure = (\n        ('Type', ULONG),\n        ('DnsDomainInfoType', WSTR),\n        ('Priority', ULONG),\n        ('Weight', ULONG),\n        ('Port', ULONG),\n        ('Register', UCHAR),\n        ('Status', ULONG),\n    )",
  "class NL_DNS_NAME_INFO_ARRAY(NDRUniConformantArray):\n    item = NL_DNS_NAME_INFO",
  "class PNL_DNS_NAME_INFO_ARRAY(NDRPOINTER):\n    referent = (\n        ('Data', NL_DNS_NAME_INFO_ARRAY),\n    )",
  "class NL_DNS_NAME_INFO_ARRAY(NDRSTRUCT):\n    structure = (\n        ('EntryCount', ULONG),\n        ('DnsNamesInfo', PNL_DNS_NAME_INFO_ARRAY),\n    )",
  "class NETLOGON_LSA_POLICY_INFO(NDRSTRUCT):\n    structure = (\n        ('LsaPolicySize', ULONG),\n        ('LsaPolicy', PUCHAR_ARRAY),\n    )",
  "class PNETLOGON_LSA_POLICY_INFO(NDRPOINTER):\n    referent = (\n        ('Data', NETLOGON_LSA_POLICY_INFO),\n    )",
  "class NETLOGON_WORKSTATION_INFO(NDRSTRUCT):\n    structure = (\n        ('LsaPolicy', NETLOGON_LSA_POLICY_INFO),\n        ('DnsHostName', LPWSTR),\n        ('SiteName', LPWSTR),\n        ('Dummy1', LPWSTR),\n        ('Dummy2', LPWSTR),\n        ('Dummy3', LPWSTR),\n        ('Dummy4', LPWSTR),\n        ('OsVersion', RPC_UNICODE_STRING),\n        ('OsName', RPC_UNICODE_STRING),\n        ('DummyString3', RPC_UNICODE_STRING),\n        ('DummyString4', RPC_UNICODE_STRING),\n        ('WorkstationFlags', ULONG),\n        ('KerberosSupportedEncryptionTypes', ULONG),\n        ('DummyLong3', ULONG),\n        ('DummyLong4', ULONG),\n    )",
  "class PNETLOGON_WORKSTATION_INFO(NDRPOINTER):\n    referent = (\n        ('Data', NETLOGON_WORKSTATION_INFO),\n    )",
  "class NL_TRUST_PASSWORD_FIXED_ARRAY(NDRUniFixedArray):\n    def getDataLen(self, data, offset=0):\n        return 512+4\n\n    def getAlignment(self):\n        return 1",
  "class WCHAR_ARRAY(NDRUniFixedArray):\n    def getDataLen(self, data, offset=0):\n        return 512",
  "class NL_TRUST_PASSWORD(NDRSTRUCT):\n    structure = (\n        ('Buffer', WCHAR_ARRAY),\n        ('Length', ULONG),\n    )",
  "class PNL_TRUST_PASSWORD(NDRPOINTER):\n    referent = (\n        ('Data', NL_TRUST_PASSWORD),\n    )",
  "class NL_PASSWORD_VERSION(NDRSTRUCT):\n    structure = (\n        ('ReservedField', ULONG),\n        ('PasswordVersionNumber', ULONG),\n        ('PasswordVersionPresent', ULONG),\n    )",
  "class NETLOGON_WORKSTATION_INFORMATION(NDRUNION):\n    commonHdr = (\n        ('tag', DWORD),\n    )\n\n    union = {\n        1 : ('WorkstationInfo', PNETLOGON_WORKSTATION_INFO),\n        2 : ('LsaPolicyInfo', PNETLOGON_LSA_POLICY_INFO),\n    }",
  "class NETLOGON_ONE_DOMAIN_INFO(NDRSTRUCT):\n    structure = (\n        ('DomainName', RPC_UNICODE_STRING),\n        ('DnsDomainName', RPC_UNICODE_STRING),\n        ('DnsForestName', RPC_UNICODE_STRING),\n        ('DomainGuid', GUID),\n        ('DomainSid', PRPC_SID),\n        ('TrustExtension', RPC_UNICODE_STRING),\n        ('DummyString2', RPC_UNICODE_STRING),\n        ('DummyString3', RPC_UNICODE_STRING),\n        ('DummyString4', RPC_UNICODE_STRING),\n        ('DummyLong1', ULONG),\n        ('DummyLong2', ULONG),\n        ('DummyLong3', ULONG),\n        ('DummyLong4', ULONG),\n    )",
  "class NETLOGON_ONE_DOMAIN_INFO_ARRAY(NDRUniConformantArray):\n    item = NETLOGON_ONE_DOMAIN_INFO",
  "class PNETLOGON_ONE_DOMAIN_INFO_ARRAY(NDRPOINTER):\n    referent = (\n        ('Data', NETLOGON_ONE_DOMAIN_INFO_ARRAY),\n    )",
  "class NETLOGON_DOMAIN_INFO(NDRSTRUCT):\n    structure = (\n        ('PrimaryDomain', NETLOGON_ONE_DOMAIN_INFO),\n        ('TrustedDomainCount', ULONG),\n        ('TrustedDomains', PNETLOGON_ONE_DOMAIN_INFO_ARRAY),\n        ('LsaPolicy', NETLOGON_LSA_POLICY_INFO),\n        ('DnsHostNameInDs', RPC_UNICODE_STRING),\n        ('DummyString2', RPC_UNICODE_STRING),\n        ('DummyString3', RPC_UNICODE_STRING),\n        ('DummyString4', RPC_UNICODE_STRING),\n        ('WorkstationFlags', ULONG),\n        ('SupportedEncTypes', ULONG),\n        ('DummyLong3', ULONG),\n        ('DummyLong4', ULONG),\n    )",
  "class PNETLOGON_DOMAIN_INFO(NDRPOINTER):\n    referent = (\n        ('Data', NETLOGON_DOMAIN_INFO),\n    )",
  "class NETLOGON_DOMAIN_INFORMATION(NDRUNION):\n    commonHdr = (\n        ('tag', DWORD),\n    )\n\n    union = {\n        1 : ('DomainInfo', PNETLOGON_DOMAIN_INFO),\n        2 : ('LsaPolicyInfo', PNETLOGON_LSA_POLICY_INFO),\n    }",
  "class NETLOGON_SECURE_CHANNEL_TYPE(NDRENUM):\n    class enumItems(Enum):\n        NullSecureChannel             = 0\n        MsvApSecureChannel            = 1\n        WorkstationSecureChannel      = 2\n        TrustedDnsDomainSecureChannel = 3\n        TrustedDomainSecureChannel    = 4\n        UasServerSecureChannel        = 5\n        ServerSecureChannel           = 6\n        CdcServerSecureChannel        = 7",
  "class NETLOGON_CAPABILITIES(NDRUNION):\n    commonHdr = (\n        ('tag', DWORD),\n    )\n\n    union = {\n        1 : ('ServerCapabilities', ULONG),\n    }",
  "class UCHAR_FIXED_ARRAY(NDRUniFixedArray):\n    def getDataLen(self, data, offset=0):\n        return 128",
  "class NL_OSVERSIONINFO_V1(NDRSTRUCT):\n    structure = (\n        ('dwOSVersionInfoSize', DWORD),\n        ('dwMajorVersion', DWORD),\n        ('dwMinorVersion', DWORD),\n        ('dwBuildNumber', DWORD),\n        ('dwPlatformId', DWORD),\n        ('szCSDVersion', UCHAR_FIXED_ARRAY),\n        ('wServicePackMajor', USHORT),\n        ('wServicePackMinor', USHORT),\n        ('wSuiteMask', USHORT),\n        ('wProductType', UCHAR),\n        ('wReserved', UCHAR),\n    )",
  "class PNL_OSVERSIONINFO_V1(NDRPOINTER):\n    referent = (\n        ('Data', NL_OSVERSIONINFO_V1),\n    )",
  "class PLPWSTR(NDRPOINTER):\n    referent = (\n        ('Data', LPWSTR),\n    )",
  "class NL_IN_CHAIN_SET_CLIENT_ATTRIBUTES_V1(NDRSTRUCT):\n    structure = (\n        ('ClientDnsHostName', PLPWSTR),\n        ('OsVersionInfo', PNL_OSVERSIONINFO_V1),\n        ('OsName', PLPWSTR),\n    )",
  "class NL_IN_CHAIN_SET_CLIENT_ATTRIBUTES(NDRUNION):\n    commonHdr = (\n        ('tag', DWORD),\n    )\n\n    union = {\n        1 : ('V1', NL_IN_CHAIN_SET_CLIENT_ATTRIBUTES_V1),\n    }",
  "class NL_OUT_CHAIN_SET_CLIENT_ATTRIBUTES_V1(NDRSTRUCT):\n    structure = (\n        ('HubName', PLPWSTR),\n        ('OldDnsHostName', PLPWSTR),\n        ('SupportedEncTypes', LPULONG),\n    )",
  "class NL_OUT_CHAIN_SET_CLIENT_ATTRIBUTES(NDRUNION):\n    commonHdr = (\n        ('tag', DWORD),\n    )\n\n    union = {\n        1 : ('V1', NL_OUT_CHAIN_SET_CLIENT_ATTRIBUTES_V1),\n    }",
  "class CHAR_FIXED_8_ARRAY(NDRUniFixedArray):\n    def getDataLen(self, data, offset=0):\n        return 8",
  "class LM_CHALLENGE(NDRSTRUCT):\n    structure = (\n        ('Data', CHAR_FIXED_8_ARRAY),\n    )",
  "class NETLOGON_LOGON_IDENTITY_INFO(NDRSTRUCT):\n    structure = (\n        ('LogonDomainName', RPC_UNICODE_STRING),\n        ('ParameterControl', ULONG),\n        ('Reserved', OLD_LARGE_INTEGER),\n        ('UserName', RPC_UNICODE_STRING),\n        ('Workstation', RPC_UNICODE_STRING),\n    )",
  "class PNETLOGON_LOGON_IDENTITY_INFO(NDRPOINTER):\n    referent = (\n        ('Data', NETLOGON_LOGON_IDENTITY_INFO),\n    )",
  "class NETLOGON_GENERIC_INFO(NDRSTRUCT):\n    structure = (\n        ('Identity', NETLOGON_LOGON_IDENTITY_INFO),\n        ('PackageName', RPC_UNICODE_STRING),\n        ('DataLength', ULONG),\n        ('LogonData', PUCHAR_ARRAY),\n    )",
  "class PNETLOGON_GENERIC_INFO(NDRPOINTER):\n    referent = (\n        ('Data', NETLOGON_GENERIC_INFO),\n    )",
  "class NETLOGON_INTERACTIVE_INFO(NDRSTRUCT):\n    structure = (\n        ('Identity', NETLOGON_LOGON_IDENTITY_INFO),\n        ('LmOwfPassword', LM_OWF_PASSWORD),\n        ('NtOwfPassword', NT_OWF_PASSWORD),\n    )",
  "class PNETLOGON_INTERACTIVE_INFO(NDRPOINTER):\n    referent = (\n        ('Data', NETLOGON_INTERACTIVE_INFO),\n    )",
  "class NETLOGON_SERVICE_INFO(NDRSTRUCT):\n    structure = (\n        ('Identity', NETLOGON_LOGON_IDENTITY_INFO),\n        ('LmOwfPassword', LM_OWF_PASSWORD),\n        ('NtOwfPassword', NT_OWF_PASSWORD),\n    )",
  "class PNETLOGON_SERVICE_INFO(NDRPOINTER):\n    referent = (\n        ('Data', NETLOGON_SERVICE_INFO),\n    )",
  "class NETLOGON_NETWORK_INFO(NDRSTRUCT):\n    structure = (\n        ('Identity', NETLOGON_LOGON_IDENTITY_INFO),\n        ('LmChallenge', LM_CHALLENGE),\n        ('NtChallengeResponse', STRING),\n        ('LmChallengeResponse', STRING),\n    )",
  "class PNETLOGON_NETWORK_INFO(NDRPOINTER):\n    referent = (\n        ('Data', NETLOGON_NETWORK_INFO),\n    )",
  "class NETLOGON_LOGON_INFO_CLASS(NDRENUM):\n    class enumItems(Enum):\n        NetlogonInteractiveInformation           = 1\n        NetlogonNetworkInformation               = 2\n        NetlogonServiceInformation               = 3\n        NetlogonGenericInformation               = 4\n        NetlogonInteractiveTransitiveInformation = 5\n        NetlogonNetworkTransitiveInformation     = 6\n        NetlogonServiceTransitiveInformation     = 7",
  "class NETLOGON_LEVEL(NDRUNION):\n    union = {\n        NETLOGON_LOGON_INFO_CLASS.NetlogonInteractiveInformation           : ('LogonInteractive', PNETLOGON_INTERACTIVE_INFO),\n        NETLOGON_LOGON_INFO_CLASS.NetlogonInteractiveTransitiveInformation : ('LogonInteractiveTransitive', PNETLOGON_INTERACTIVE_INFO),\n        NETLOGON_LOGON_INFO_CLASS.NetlogonServiceInformation               : ('LogonService', PNETLOGON_SERVICE_INFO),\n        NETLOGON_LOGON_INFO_CLASS.NetlogonServiceTransitiveInformation     : ('LogonServiceTransitive', PNETLOGON_SERVICE_INFO),\n        NETLOGON_LOGON_INFO_CLASS.NetlogonNetworkInformation               : ('LogonNetwork', PNETLOGON_NETWORK_INFO),\n        NETLOGON_LOGON_INFO_CLASS.NetlogonNetworkTransitiveInformation     : ('LogonNetworkTransitive', PNETLOGON_NETWORK_INFO),\n        NETLOGON_LOGON_INFO_CLASS.NetlogonGenericInformation               : ('LogonGeneric', PNETLOGON_GENERIC_INFO),\n    }",
  "class NETLOGON_SID_AND_ATTRIBUTES(NDRSTRUCT):\n    structure = (\n        ('Sid', PRPC_SID),\n        ('Attributes', ULONG),\n    )",
  "class NETLOGON_VALIDATION_GENERIC_INFO2(NDRSTRUCT):\n    structure = (\n        ('DataLength', ULONG),\n        ('ValidationData', PUCHAR_ARRAY),\n    )",
  "class PNETLOGON_VALIDATION_GENERIC_INFO2(NDRPOINTER):\n    referent = (\n        ('Data', NETLOGON_VALIDATION_GENERIC_INFO2),\n    )",
  "class GROUP_MEMBERSHIP(NDRSTRUCT):\n    structure = (\n        ('RelativeId', ULONG),\n        ('Attributes', ULONG),\n    )",
  "class GROUP_MEMBERSHIP_ARRAY(NDRUniConformantArray):\n    item = GROUP_MEMBERSHIP",
  "class PGROUP_MEMBERSHIP_ARRAY(NDRPOINTER):\n    referent = (\n        ('Data', GROUP_MEMBERSHIP_ARRAY),\n    )",
  "class LONG_ARRAY(NDRUniFixedArray):\n    def getDataLen(self, data, offset=0):\n        return 4*10",
  "class NETLOGON_VALIDATION_SAM_INFO(NDRSTRUCT):\n    structure = (\n        ('LogonTime', OLD_LARGE_INTEGER),\n        ('LogoffTime', OLD_LARGE_INTEGER),\n        ('KickOffTime', OLD_LARGE_INTEGER),\n        ('PasswordLastSet', OLD_LARGE_INTEGER),\n        ('PasswordCanChange', OLD_LARGE_INTEGER),\n        ('PasswordMustChange', OLD_LARGE_INTEGER),\n        ('EffectiveName', RPC_UNICODE_STRING),\n        ('FullName', RPC_UNICODE_STRING),\n        ('LogonScript', RPC_UNICODE_STRING),\n        ('ProfilePath', RPC_UNICODE_STRING),\n        ('HomeDirectory', RPC_UNICODE_STRING),\n        ('HomeDirectoryDrive', RPC_UNICODE_STRING),\n        ('LogonCount', USHORT),\n        ('BadPasswordCount', USHORT),\n        ('UserId', ULONG),\n        ('PrimaryGroupId', ULONG),\n        ('GroupCount', ULONG),\n        ('GroupIds', PGROUP_MEMBERSHIP_ARRAY),\n        ('UserFlags', ULONG),\n        ('UserSessionKey', USER_SESSION_KEY),\n        ('LogonServer', RPC_UNICODE_STRING),\n        ('LogonDomainName', RPC_UNICODE_STRING),\n        ('LogonDomainId', PRPC_SID),\n        ('ExpansionRoom', LONG_ARRAY),\n    )",
  "class PNETLOGON_VALIDATION_SAM_INFO(NDRPOINTER):\n    referent = (\n        ('Data', NETLOGON_VALIDATION_SAM_INFO),\n    )",
  "class NETLOGON_SID_AND_ATTRIBUTES_ARRAY(NDRUniConformantArray):\n    item = NETLOGON_SID_AND_ATTRIBUTES",
  "class PNETLOGON_SID_AND_ATTRIBUTES_ARRAY(NDRPOINTER):\n    referent = (\n        ('Data', NETLOGON_SID_AND_ATTRIBUTES_ARRAY),\n    )",
  "class NETLOGON_VALIDATION_SAM_INFO2(NDRSTRUCT):\n    structure = (\n        ('LogonTime', OLD_LARGE_INTEGER),\n        ('LogoffTime', OLD_LARGE_INTEGER),\n        ('KickOffTime', OLD_LARGE_INTEGER),\n        ('PasswordLastSet', OLD_LARGE_INTEGER),\n        ('PasswordCanChange', OLD_LARGE_INTEGER),\n        ('PasswordMustChange', OLD_LARGE_INTEGER),\n        ('EffectiveName', RPC_UNICODE_STRING),\n        ('FullName', RPC_UNICODE_STRING),\n        ('LogonScript', RPC_UNICODE_STRING),\n        ('ProfilePath', RPC_UNICODE_STRING),\n        ('HomeDirectory', RPC_UNICODE_STRING),\n        ('HomeDirectoryDrive', RPC_UNICODE_STRING),\n        ('LogonCount', USHORT),\n        ('BadPasswordCount', USHORT),\n        ('UserId', ULONG),\n        ('PrimaryGroupId', ULONG),\n        ('GroupCount', ULONG),\n        ('GroupIds', PGROUP_MEMBERSHIP_ARRAY),\n        ('UserFlags', ULONG),\n        ('UserSessionKey', USER_SESSION_KEY),\n        ('LogonServer', RPC_UNICODE_STRING),\n        ('LogonDomainName', RPC_UNICODE_STRING),\n        ('LogonDomainId', PRPC_SID),\n        ('ExpansionRoom', LONG_ARRAY),\n        ('SidCount', ULONG),\n        ('ExtraSids', PNETLOGON_SID_AND_ATTRIBUTES_ARRAY),\n    )",
  "class PNETLOGON_VALIDATION_SAM_INFO2(NDRPOINTER):\n    referent = (\n        ('Data', NETLOGON_VALIDATION_SAM_INFO2),\n    )",
  "class NETLOGON_VALIDATION_SAM_INFO4(NDRSTRUCT):\n    structure = (\n        ('LogonTime', OLD_LARGE_INTEGER),\n        ('LogoffTime', OLD_LARGE_INTEGER),\n        ('KickOffTime', OLD_LARGE_INTEGER),\n        ('PasswordLastSet', OLD_LARGE_INTEGER),\n        ('PasswordCanChange', OLD_LARGE_INTEGER),\n        ('PasswordMustChange', OLD_LARGE_INTEGER),\n        ('EffectiveName', RPC_UNICODE_STRING),\n        ('FullName', RPC_UNICODE_STRING),\n        ('LogonScript', RPC_UNICODE_STRING),\n        ('ProfilePath', RPC_UNICODE_STRING),\n        ('HomeDirectory', RPC_UNICODE_STRING),\n        ('HomeDirectoryDrive', RPC_UNICODE_STRING),\n        ('LogonCount', USHORT),\n        ('BadPasswordCount', USHORT),\n        ('UserId', ULONG),\n        ('PrimaryGroupId', ULONG),\n        ('GroupCount', ULONG),\n        ('GroupIds', PGROUP_MEMBERSHIP_ARRAY),\n        ('UserFlags', ULONG),\n        ('UserSessionKey', USER_SESSION_KEY),\n        ('LogonServer', RPC_UNICODE_STRING),\n        ('LogonDomainName', RPC_UNICODE_STRING),\n        ('LogonDomainId', PRPC_SID),\n\n        ('LMKey', CHAR_FIXED_8_ARRAY),\n        ('UserAccountControl', ULONG),\n        ('SubAuthStatus', ULONG),\n        ('LastSuccessfulILogon', OLD_LARGE_INTEGER),\n        ('LastFailedILogon', OLD_LARGE_INTEGER),\n        ('FailedILogonCount', ULONG),\n        ('Reserved4', ULONG),\n\n        ('SidCount', ULONG),\n        ('ExtraSids', PNETLOGON_SID_AND_ATTRIBUTES_ARRAY),\n        ('DnsLogonDomainName', RPC_UNICODE_STRING),\n        ('Upn', RPC_UNICODE_STRING),\n        ('ExpansionString1', RPC_UNICODE_STRING),\n        ('ExpansionString2', RPC_UNICODE_STRING),\n        ('ExpansionString3', RPC_UNICODE_STRING),\n        ('ExpansionString4', RPC_UNICODE_STRING),\n        ('ExpansionString5', RPC_UNICODE_STRING),\n        ('ExpansionString6', RPC_UNICODE_STRING),\n        ('ExpansionString7', RPC_UNICODE_STRING),\n        ('ExpansionString8', RPC_UNICODE_STRING),\n        ('ExpansionString9', RPC_UNICODE_STRING),\n        ('ExpansionString10', RPC_UNICODE_STRING),\n    )",
  "class PNETLOGON_VALIDATION_SAM_INFO4(NDRPOINTER):\n    referent = (\n        ('Data', NETLOGON_VALIDATION_SAM_INFO4),\n    )",
  "class NETLOGON_VALIDATION_INFO_CLASS(NDRENUM):\n    class enumItems(Enum):\n        NetlogonValidationUasInfo      = 1\n        NetlogonValidationSamInfo      = 2\n        NetlogonValidationSamInfo2     = 3\n        NetlogonValidationGenericInfo  = 4\n        NetlogonValidationGenericInfo2 = 5\n        NetlogonValidationSamInfo4     = 6",
  "class NETLOGON_VALIDATION(NDRUNION):\n    union = {\n        NETLOGON_VALIDATION_INFO_CLASS.NetlogonValidationSamInfo     : ('ValidationSam', PNETLOGON_VALIDATION_SAM_INFO),\n        NETLOGON_VALIDATION_INFO_CLASS.NetlogonValidationSamInfo2    : ('ValidationSam2', PNETLOGON_VALIDATION_SAM_INFO2),\n        NETLOGON_VALIDATION_INFO_CLASS.NetlogonValidationGenericInfo2: ('ValidationGeneric2', PNETLOGON_VALIDATION_GENERIC_INFO2),\n        NETLOGON_VALIDATION_INFO_CLASS.NetlogonValidationSamInfo4    : ('ValidationSam4', PNETLOGON_VALIDATION_SAM_INFO4),\n    }",
  "class NLPR_QUOTA_LIMITS(NDRSTRUCT):\n    structure = (\n        ('PagedPoolLimit', ULONG),\n        ('NonPagedPoolLimit', ULONG),\n        ('MinimumWorkingSetSize', ULONG),\n        ('MaximumWorkingSetSize', ULONG),\n        ('PagefileLimit', ULONG),\n        ('Reserved', OLD_LARGE_INTEGER),\n    )",
  "class ULONG_ARRAY(NDRUniConformantArray):\n    item = ULONG",
  "class PULONG_ARRAY(NDRPOINTER):\n    referent = (\n        ('Data', ULONG_ARRAY),\n    )",
  "class NETLOGON_DELTA_ACCOUNTS(NDRSTRUCT):\n    structure = (\n        ('PrivilegeEntries', ULONG),\n        ('PrivilegeControl', ULONG),\n        ('PrivilegeAttributes', PULONG_ARRAY),\n        ('PrivilegeNames', PRPC_UNICODE_STRING_ARRAY),\n        ('QuotaLimits', NLPR_QUOTA_LIMITS),\n        ('SystemAccessFlags', ULONG),\n        ('SecurityInformation', SECURITY_INFORMATION),\n        ('SecuritySize', ULONG),\n        ('SecurityDescriptor', PUCHAR_ARRAY),\n        ('DummyString1', RPC_UNICODE_STRING),\n        ('DummyString2', RPC_UNICODE_STRING),\n        ('DummyString3', RPC_UNICODE_STRING),\n        ('DummyString4', RPC_UNICODE_STRING),\n        ('DummyLong1', ULONG),\n        ('DummyLong2', ULONG),\n        ('DummyLong3', ULONG),\n        ('DummyLong4', ULONG),\n    )",
  "class PNETLOGON_DELTA_ACCOUNTS(NDRPOINTER):\n    referent = (\n        ('Data', NETLOGON_DELTA_ACCOUNTS),\n    )",
  "class NLPR_SID_INFORMATION(NDRSTRUCT):\n    structure = (\n        ('SidPointer', PRPC_SID),\n    )",
  "class NLPR_SID_INFORMATION_ARRAY(NDRUniConformantArray):\n    item = NLPR_SID_INFORMATION",
  "class PNLPR_SID_INFORMATION_ARRAY(NDRPOINTER):\n    referent = (\n        ('Data', NLPR_SID_INFORMATION_ARRAY),\n    )",
  "class NLPR_SID_ARRAY(NDRSTRUCT):\n    referent = (\n        ('Count', ULONG),\n        ('Sids', PNLPR_SID_INFORMATION_ARRAY),\n    )",
  "class NETLOGON_DELTA_ALIAS_MEMBER(NDRSTRUCT):\n    structure = (\n        ('Members', NLPR_SID_ARRAY),\n        ('DummyLong1', ULONG),\n        ('DummyLong2', ULONG),\n        ('DummyLong3', ULONG),\n        ('DummyLong4', ULONG),\n    )",
  "class PNETLOGON_DELTA_ALIAS_MEMBER(NDRPOINTER):\n    referent = (\n        ('Data', NETLOGON_DELTA_ALIAS_MEMBER),\n    )",
  "class NETLOGON_DELTA_DELETE_GROUP(NDRSTRUCT):\n    structure = (\n        ('AccountName', LPWSTR),\n        ('DummyString1', RPC_UNICODE_STRING),\n        ('DummyString2', RPC_UNICODE_STRING),\n        ('DummyString3', RPC_UNICODE_STRING),\n        ('DummyString4', RPC_UNICODE_STRING),\n        ('DummyLong1', ULONG),\n        ('DummyLong2', ULONG),\n        ('DummyLong3', ULONG),\n        ('DummyLong4', ULONG),\n    )",
  "class PNETLOGON_DELTA_DELETE_GROUP(NDRPOINTER):\n    referent = (\n        ('Data', NETLOGON_DELTA_DELETE_GROUP),\n    )",
  "class NETLOGON_DELTA_DELETE_USER(NDRSTRUCT):\n    structure = (\n        ('AccountName', LPWSTR),\n        ('DummyString1', RPC_UNICODE_STRING),\n        ('DummyString2', RPC_UNICODE_STRING),\n        ('DummyString3', RPC_UNICODE_STRING),\n        ('DummyString4', RPC_UNICODE_STRING),\n        ('DummyLong1', ULONG),\n        ('DummyLong2', ULONG),\n        ('DummyLong3', ULONG),\n        ('DummyLong4', ULONG),\n    )",
  "class PNETLOGON_DELTA_DELETE_USER(NDRPOINTER):\n    referent = (\n        ('Data', NETLOGON_DELTA_DELETE_USER),\n    )",
  "class NETLOGON_DELTA_DOMAIN(NDRSTRUCT):\n    structure = (\n        ('DomainName', RPC_UNICODE_STRING),\n        ('OemInformation', RPC_UNICODE_STRING),\n        ('ForceLogoff', OLD_LARGE_INTEGER),\n        ('MinPasswordLength', USHORT),\n        ('PasswordHistoryLength', USHORT),\n        ('MaxPasswordAge', OLD_LARGE_INTEGER),\n        ('MinPasswordAge', OLD_LARGE_INTEGER),\n        ('DomainModifiedCount', OLD_LARGE_INTEGER),\n        ('DomainCreationTime', OLD_LARGE_INTEGER),\n        ('SecurityInformation', SECURITY_INFORMATION),\n        ('SecuritySize', ULONG),\n        ('SecurityDescriptor', PUCHAR_ARRAY),\n        ('DomainLockoutInformation', RPC_UNICODE_STRING),\n        ('DummyString2', RPC_UNICODE_STRING),\n        ('DummyString3', RPC_UNICODE_STRING),\n        ('DummyString4', RPC_UNICODE_STRING),\n        ('PasswordProperties', ULONG),\n        ('DummyLong2', ULONG),\n        ('DummyLong3', ULONG),\n        ('DummyLong4', ULONG),\n    )",
  "class PNETLOGON_DELTA_DOMAIN(NDRPOINTER):\n    referent = (\n        ('Data', NETLOGON_DELTA_DOMAIN),\n    )",
  "class NETLOGON_DELTA_GROUP(NDRSTRUCT):\n    structure = (\n        ('Name', RPC_UNICODE_STRING),\n        ('RelativeId', ULONG),\n        ('Attributes', ULONG),\n        ('AdminComment', RPC_UNICODE_STRING),\n        ('SecurityInformation', USHORT),\n        ('SecuritySize', ULONG),\n        ('SecurityDescriptor', SECURITY_INFORMATION),\n        ('DummyString1', RPC_UNICODE_STRING),\n        ('DummyString2', RPC_UNICODE_STRING),\n        ('DummyString3', RPC_UNICODE_STRING),\n        ('DummyString4', RPC_UNICODE_STRING),\n        ('DummyLong1', ULONG),\n        ('DummyLong2', ULONG),\n        ('DummyLong3', ULONG),\n        ('DummyLong4', ULONG),\n    )",
  "class PNETLOGON_DELTA_GROUP(NDRPOINTER):\n    referent = (\n        ('Data', NETLOGON_DELTA_GROUP),\n    )",
  "class NETLOGON_RENAME_GROUP(NDRSTRUCT):\n    structure = (\n        ('OldName', RPC_UNICODE_STRING),\n        ('NewName', RPC_UNICODE_STRING),\n        ('DummyString1', RPC_UNICODE_STRING),\n        ('DummyString2', RPC_UNICODE_STRING),\n        ('DummyString3', RPC_UNICODE_STRING),\n        ('DummyString4', RPC_UNICODE_STRING),\n        ('DummyLong1', ULONG),\n        ('DummyLong2', ULONG),\n        ('DummyLong3', ULONG),\n        ('DummyLong4', ULONG),\n    )",
  "class PNETLOGON_DELTA_RENAME_GROUP(NDRPOINTER):\n    referent = (\n        ('Data', NETLOGON_RENAME_GROUP),\n    )",
  "class NLPR_USER_PRIVATE_INFO(NDRSTRUCT):\n    structure = (\n        ('SensitiveData', UCHAR),\n        ('DataLength', ULONG),\n        ('Data', PUCHAR_ARRAY),\n    )",
  "class NETLOGON_DELTA_USER(NDRSTRUCT):\n    structure = (\n        ('UserName', RPC_UNICODE_STRING),\n        ('FullName', RPC_UNICODE_STRING),\n        ('UserId', ULONG),\n        ('PrimaryGroupId', ULONG),\n        ('HomeDirectory', RPC_UNICODE_STRING),\n        ('HomeDirectoryDrive', RPC_UNICODE_STRING),\n        ('ScriptPath', RPC_UNICODE_STRING),\n        ('AdminComment', RPC_UNICODE_STRING),\n        ('WorkStations', RPC_UNICODE_STRING),\n        ('LastLogon', OLD_LARGE_INTEGER),\n        ('LastLogoff', OLD_LARGE_INTEGER),\n        ('LogonHours', NLPR_LOGON_HOURS),\n        ('BadPasswordCount', USHORT),\n        ('LogonCount', USHORT),\n        ('PasswordLastSet', OLD_LARGE_INTEGER),\n        ('AccountExpires', OLD_LARGE_INTEGER),\n        ('UserAccountControl', ULONG),\n        ('EncryptedNtOwfPassword', PUCHAR_ARRAY),\n        ('EncryptedLmOwfPassword', PUCHAR_ARRAY),\n        ('NtPasswordPresent', UCHAR),\n        ('LmPasswordPresent', UCHAR),\n        ('PasswordExpired', UCHAR),\n        ('UserComment', RPC_UNICODE_STRING),\n        ('Parameters', RPC_UNICODE_STRING),\n        ('CountryCode', USHORT),\n        ('CodePage', USHORT),\n        ('PrivateData', NLPR_USER_PRIVATE_INFO),\n        ('SecurityInformation', SECURITY_INFORMATION),\n        ('SecuritySize', ULONG),\n        ('SecurityDescriptor', PUCHAR_ARRAY),\n        ('ProfilePath', RPC_UNICODE_STRING),\n        ('DummyString2', RPC_UNICODE_STRING),\n        ('DummyString3', RPC_UNICODE_STRING),\n        ('DummyString4', RPC_UNICODE_STRING),\n        ('DummyLong1', ULONG),\n        ('DummyLong2', ULONG),\n        ('DummyLong3', ULONG),\n        ('DummyLong4', ULONG),\n    )",
  "class PNETLOGON_DELTA_USER(NDRPOINTER):\n    referent = (\n        ('Data', NETLOGON_DELTA_USER),\n    )",
  "class NETLOGON_RENAME_USER(NDRSTRUCT):\n    structure = (\n        ('OldName', RPC_UNICODE_STRING),\n        ('NewName', RPC_UNICODE_STRING),\n        ('DummyString1', RPC_UNICODE_STRING),\n        ('DummyString2', RPC_UNICODE_STRING),\n        ('DummyString3', RPC_UNICODE_STRING),\n        ('DummyString4', RPC_UNICODE_STRING),\n        ('DummyLong1', ULONG),\n        ('DummyLong2', ULONG),\n        ('DummyLong3', ULONG),\n        ('DummyLong4', ULONG),\n    )",
  "class PNETLOGON_DELTA_RENAME_USER(NDRPOINTER):\n    referent = (\n        ('Data', NETLOGON_RENAME_USER),\n    )",
  "class NETLOGON_DELTA_GROUP_MEMBER(NDRSTRUCT):\n    structure = (\n        ('Members', PULONG_ARRAY),\n        ('Attributes', PULONG_ARRAY),\n        ('MemberCount', ULONG),\n        ('DummyLong1', ULONG),\n        ('DummyLong2', ULONG),\n        ('DummyLong3', ULONG),\n        ('DummyLong4', ULONG),\n    )",
  "class PNETLOGON_DELTA_GROUP_MEMBER(NDRPOINTER):\n    referent = (\n        ('Data', NETLOGON_DELTA_GROUP_MEMBER),\n    )",
  "class NETLOGON_DELTA_ALIAS(NDRSTRUCT):\n    structure = (\n        ('Name', RPC_UNICODE_STRING),\n        ('RelativeId', ULONG),\n        ('SecurityInformation', SECURITY_INFORMATION),\n        ('SecuritySize', ULONG),\n        ('SecurityDescriptor', PUCHAR_ARRAY),\n        ('Comment', RPC_UNICODE_STRING),\n        ('DummyString2', RPC_UNICODE_STRING),\n        ('DummyString3', RPC_UNICODE_STRING),\n        ('DummyString4', RPC_UNICODE_STRING),\n        ('DummyLong1', ULONG),\n        ('DummyLong2', ULONG),\n        ('DummyLong3', ULONG),\n        ('DummyLong4', ULONG),\n    )",
  "class PNETLOGON_DELTA_ALIAS(NDRPOINTER):\n    referent = (\n        ('Data', NETLOGON_DELTA_ALIAS),\n    )",
  "class NETLOGON_RENAME_ALIAS(NDRSTRUCT):\n    structure = (\n        ('OldName', RPC_UNICODE_STRING),\n        ('NewName', RPC_UNICODE_STRING),\n        ('DummyString1', RPC_UNICODE_STRING),\n        ('DummyString2', RPC_UNICODE_STRING),\n        ('DummyString3', RPC_UNICODE_STRING),\n        ('DummyString4', RPC_UNICODE_STRING),\n        ('DummyLong1', ULONG),\n        ('DummyLong2', ULONG),\n        ('DummyLong3', ULONG),\n        ('DummyLong4', ULONG),\n    )",
  "class PNETLOGON_DELTA_RENAME_ALIAS(NDRPOINTER):\n    referent = (\n        ('Data', NETLOGON_RENAME_ALIAS),\n    )",
  "class NETLOGON_DELTA_POLICY(NDRSTRUCT):\n    structure = (\n        ('MaximumLogSize', ULONG),\n        ('AuditRetentionPeriod', OLD_LARGE_INTEGER),\n        ('AuditingMode', UCHAR),\n        ('MaximumAuditEventCount', ULONG),\n        ('EventAuditingOptions', PULONG_ARRAY),\n        ('PrimaryDomainName', RPC_UNICODE_STRING),\n        ('PrimaryDomainSid', PRPC_SID),\n        ('QuotaLimits', NLPR_QUOTA_LIMITS),\n        ('ModifiedId', OLD_LARGE_INTEGER),\n        ('DatabaseCreationTime', OLD_LARGE_INTEGER),\n        ('SecurityInformation', SECURITY_INFORMATION),\n        ('SecuritySize', ULONG),\n        ('SecurityDescriptor', PUCHAR_ARRAY),\n        ('DummyString1', RPC_UNICODE_STRING),\n        ('DummyString2', RPC_UNICODE_STRING),\n        ('DummyString3', RPC_UNICODE_STRING),\n        ('DummyString4', RPC_UNICODE_STRING),\n        ('DummyLong1', ULONG),\n        ('DummyLong2', ULONG),\n        ('DummyLong3', ULONG),\n        ('DummyLong4', ULONG),\n    )",
  "class PNETLOGON_DELTA_POLICY(NDRPOINTER):\n    referent = (\n        ('Data', NETLOGON_DELTA_POLICY),\n    )",
  "class NETLOGON_DELTA_TRUSTED_DOMAINS(NDRSTRUCT):\n    structure = (\n        ('DomainName', RPC_UNICODE_STRING),\n        ('NumControllerEntries', ULONG),\n        ('ControllerNames', PRPC_UNICODE_STRING_ARRAY),\n        ('SecurityInformation', SECURITY_INFORMATION),\n        ('SecuritySize', ULONG),\n        ('SecurityDescriptor', PUCHAR_ARRAY),\n        ('DummyString1', RPC_UNICODE_STRING),\n        ('DummyString2', RPC_UNICODE_STRING),\n        ('DummyString3', RPC_UNICODE_STRING),\n        ('DummyString4', RPC_UNICODE_STRING),\n        ('DummyLong1', ULONG),\n        ('DummyLong2', ULONG),\n        ('DummyLong3', ULONG),\n        ('DummyLong4', ULONG),\n    )",
  "class PNETLOGON_DELTA_TRUSTED_DOMAINS(NDRPOINTER):\n    referent = (\n        ('Data', NETLOGON_DELTA_TRUSTED_DOMAINS),\n    )",
  "class UCHAR_ARRAY2(NDRUniConformantVaryingArray):\n    item = UCHAR",
  "class PUCHAR_ARRAY2(NDRPOINTER):\n    referent = (\n        ('Data', UCHAR_ARRAY2),\n    )",
  "class NLPR_CR_CIPHER_VALUE(NDRSTRUCT):\n    structure = (\n        ('Length', ULONG),\n        ('MaximumLength', ULONG),\n        ('Buffer', PUCHAR_ARRAY2),\n    )",
  "class NETLOGON_DELTA_SECRET(NDRSTRUCT):\n    structure = (\n        ('CurrentValue', NLPR_CR_CIPHER_VALUE),\n        ('CurrentValueSetTime', OLD_LARGE_INTEGER),\n        ('OldValue', NLPR_CR_CIPHER_VALUE),\n        ('OldValueSetTime', OLD_LARGE_INTEGER),\n        ('SecurityInformation', SECURITY_INFORMATION),\n        ('SecuritySize', ULONG),\n        ('SecurityDescriptor', PUCHAR_ARRAY),\n        ('DummyString1', RPC_UNICODE_STRING),\n        ('DummyString2', RPC_UNICODE_STRING),\n        ('DummyString3', RPC_UNICODE_STRING),\n        ('DummyString4', RPC_UNICODE_STRING),\n        ('DummyLong1', ULONG),\n        ('DummyLong2', ULONG),\n        ('DummyLong3', ULONG),\n        ('DummyLong4', ULONG),\n    )",
  "class PNETLOGON_DELTA_SECRET(NDRPOINTER):\n    referent = (\n        ('Data', NETLOGON_DELTA_SECRET),\n    )",
  "class NLPR_MODIFIED_COUNT(NDRSTRUCT):\n    structure = (\n        ('ModifiedCount', OLD_LARGE_INTEGER),\n    )",
  "class PNLPR_MODIFIED_COUNT(NDRPOINTER):\n    referent = (\n        ('Data', NLPR_MODIFIED_COUNT),\n    )",
  "class NETLOGON_DELTA_TYPE(NDRENUM):\n    class enumItems(Enum):\n        AddOrChangeDomain     = 1\n        AddOrChangeGroup      = 2\n        DeleteGroup           = 3\n        RenameGroup           = 4\n        AddOrChangeUser       = 5\n        DeleteUser            = 6\n        RenameUser            = 7\n        ChangeGroupMembership = 8\n        AddOrChangeAlias      = 9\n        DeleteAlias           = 10\n        RenameAlias           = 11\n        ChangeAliasMembership = 12\n        AddOrChangeLsaPolicy  = 13\n        AddOrChangeLsaTDomain = 14\n        DeleteLsaTDomain      = 15\n        AddOrChangeLsaAccount = 16\n        DeleteLsaAccount      = 17\n        AddOrChangeLsaSecret  = 18\n        DeleteLsaSecret       = 19\n        DeleteGroupByName     = 20\n        DeleteUserByName      = 21\n        SerialNumberSkip      = 22",
  "class NETLOGON_DELTA_UNION(NDRUNION):\n    union = {\n        NETLOGON_DELTA_TYPE.AddOrChangeDomain     : ('DeltaDomain', PNETLOGON_DELTA_DOMAIN),\n        NETLOGON_DELTA_TYPE.AddOrChangeGroup      : ('DeltaGroup', PNETLOGON_DELTA_GROUP),\n        NETLOGON_DELTA_TYPE.RenameGroup           : ('DeltaRenameGroup', PNETLOGON_DELTA_RENAME_GROUP),\n        NETLOGON_DELTA_TYPE.AddOrChangeUser       : ('DeltaUser', PNETLOGON_DELTA_USER),\n        NETLOGON_DELTA_TYPE.RenameUser            : ('DeltaRenameUser', PNETLOGON_DELTA_RENAME_USER),\n        NETLOGON_DELTA_TYPE.ChangeGroupMembership : ('DeltaGroupMember', PNETLOGON_DELTA_GROUP_MEMBER),\n        NETLOGON_DELTA_TYPE.AddOrChangeAlias      : ('DeltaAlias', PNETLOGON_DELTA_ALIAS),\n        NETLOGON_DELTA_TYPE.RenameAlias           : ('DeltaRenameAlias', PNETLOGON_DELTA_RENAME_ALIAS),\n        NETLOGON_DELTA_TYPE.ChangeAliasMembership : ('DeltaAliasMember', PNETLOGON_DELTA_ALIAS_MEMBER),\n        NETLOGON_DELTA_TYPE.AddOrChangeLsaPolicy  : ('DeltaPolicy', PNETLOGON_DELTA_POLICY),\n        NETLOGON_DELTA_TYPE.AddOrChangeLsaTDomain : ('DeltaTDomains', PNETLOGON_DELTA_TRUSTED_DOMAINS),\n        NETLOGON_DELTA_TYPE.AddOrChangeLsaAccount : ('DeltaAccounts', PNETLOGON_DELTA_ACCOUNTS),\n        NETLOGON_DELTA_TYPE.AddOrChangeLsaSecret  : ('DeltaSecret', PNETLOGON_DELTA_SECRET),\n        NETLOGON_DELTA_TYPE.DeleteGroupByName     : ('DeltaDeleteGroup', PNETLOGON_DELTA_DELETE_GROUP),\n        NETLOGON_DELTA_TYPE.DeleteUserByName      : ('DeltaDeleteUser', PNETLOGON_DELTA_DELETE_USER),\n        NETLOGON_DELTA_TYPE.SerialNumberSkip      : ('DeltaSerialNumberSkip', PNLPR_MODIFIED_COUNT),\n    }",
  "class NETLOGON_DELTA_ID_UNION(NDRUNION):\n    union = {\n        NETLOGON_DELTA_TYPE.AddOrChangeDomain     : ('Rid', ULONG),\n        NETLOGON_DELTA_TYPE.AddOrChangeGroup      : ('Rid', ULONG),\n        NETLOGON_DELTA_TYPE.DeleteGroup           : ('Rid', ULONG),\n        NETLOGON_DELTA_TYPE.RenameGroup           : ('Rid', ULONG),\n        NETLOGON_DELTA_TYPE.AddOrChangeUser       : ('Rid', ULONG),\n        NETLOGON_DELTA_TYPE.DeleteUser            : ('Rid', ULONG),\n        NETLOGON_DELTA_TYPE.RenameUser            : ('Rid', ULONG),\n        NETLOGON_DELTA_TYPE.ChangeGroupMembership : ('Rid', ULONG),\n        NETLOGON_DELTA_TYPE.AddOrChangeAlias      : ('Rid', ULONG),\n        NETLOGON_DELTA_TYPE.DeleteAlias           : ('Rid', ULONG),\n        NETLOGON_DELTA_TYPE.RenameAlias           : ('Rid', ULONG),\n        NETLOGON_DELTA_TYPE.ChangeAliasMembership : ('Rid', ULONG),\n        NETLOGON_DELTA_TYPE.DeleteGroupByName     : ('Rid', ULONG),\n        NETLOGON_DELTA_TYPE.DeleteUserByName      : ('Rid', ULONG),\n        NETLOGON_DELTA_TYPE.AddOrChangeLsaPolicy  : ('Sid', PRPC_SID),\n        NETLOGON_DELTA_TYPE.AddOrChangeLsaTDomain : ('Sid', PRPC_SID),\n        NETLOGON_DELTA_TYPE.DeleteLsaTDomain      : ('Sid', PRPC_SID),\n        NETLOGON_DELTA_TYPE.AddOrChangeLsaAccount : ('Sid', PRPC_SID),\n        NETLOGON_DELTA_TYPE.DeleteLsaAccount      : ('Sid', PRPC_SID),\n        NETLOGON_DELTA_TYPE.AddOrChangeLsaSecret  : ('Name', LPWSTR),\n        NETLOGON_DELTA_TYPE.DeleteLsaSecret       : ('Name', LPWSTR),\n    }",
  "class NETLOGON_DELTA_ENUM(NDRSTRUCT):\n    structure = (\n        ('DeltaType', NETLOGON_DELTA_TYPE),\n        ('DeltaID', NETLOGON_DELTA_ID_UNION),\n        ('DeltaUnion', NETLOGON_DELTA_UNION),\n    )",
  "class NETLOGON_DELTA_ENUM_ARRAY_ARRAY(NDRUniConformantArray):\n    item = NETLOGON_DELTA_ENUM",
  "class PNETLOGON_DELTA_ENUM_ARRAY_ARRAY(NDRSTRUCT):\n    referent = (\n        ('Data', NETLOGON_DELTA_ENUM_ARRAY_ARRAY),\n    )",
  "class PNETLOGON_DELTA_ENUM_ARRAY(NDRPOINTER):\n    structure = (\n        ('CountReturned', DWORD),\n        ('Deltas', PNETLOGON_DELTA_ENUM_ARRAY_ARRAY),\n    )",
  "class SYNC_STATE(NDRENUM):\n    class enumItems(Enum):\n        NormalState          = 0\n        DomainState          = 1\n        GroupState           = 2\n        UasBuiltInGroupState = 3\n        UserState            = 4\n        GroupMemberState     = 5\n        AliasState           = 6\n        AliasMemberState     = 7\n        SamDoneState         = 8",
  "class DOMAIN_NAME_BUFFER(NDRSTRUCT):\n    structure = (\n        ('DomainNameByteCount', ULONG),\n        ('DomainNames', PUCHAR_ARRAY),\n    )",
  "class DS_DOMAIN_TRUSTSW(NDRSTRUCT):\n    structure = (\n        ('NetbiosDomainName', LPWSTR),\n        ('DnsDomainName', LPWSTR),\n        ('Flags', ULONG),\n        ('ParentIndex', ULONG),\n        ('TrustType', ULONG),\n        ('TrustAttributes', ULONG),\n        ('DomainSid', PRPC_SID),\n        ('DomainGuid', GUID),\n    )",
  "class DS_DOMAIN_TRUSTSW_ARRAY(NDRUniConformantArray):\n    item = DS_DOMAIN_TRUSTSW",
  "class PDS_DOMAIN_TRUSTSW_ARRAY(NDRPOINTER):\n    referent = (\n        ('Data', DS_DOMAIN_TRUSTSW_ARRAY),\n    )",
  "class NETLOGON_TRUSTED_DOMAIN_ARRAY(NDRSTRUCT):\n    structure = (\n        ('DomainCount', DWORD),\n        ('Domains', PDS_DOMAIN_TRUSTSW_ARRAY),\n    )",
  "class NL_GENERIC_RPC_DATA(NDRSTRUCT):\n    structure = (\n        ('UlongEntryCount', ULONG),\n        ('UlongData', PULONG_ARRAY),\n        ('UnicodeStringEntryCount', ULONG),\n        ('UnicodeStringData', PRPC_UNICODE_STRING_ARRAY),\n    )",
  "class PNL_GENERIC_RPC_DATA(NDRPOINTER):\n    referent = (\n        ('Data', NL_GENERIC_RPC_DATA),\n    )",
  "class NETLOGON_CONTROL_DATA_INFORMATION(NDRUNION):\n    commonHdr = (\n        ('tag', DWORD),\n    )\n\n    union = {\n        5 : ('TrustedDomainName', LPWSTR),\n        6 : ('TrustedDomainName', LPWSTR),\n        9 : ('TrustedDomainName', LPWSTR),\n        10 : ('TrustedDomainName', LPWSTR),\n        65534 : ('DebugFlag', DWORD),\n        8: ('UserName', LPWSTR),\n    }",
  "class NETLOGON_INFO_1(NDRSTRUCT):\n    structure = (\n        ('netlog1_flags', DWORD),\n        ('netlog1_pdc_connection_status', NET_API_STATUS),\n    )",
  "class PNETLOGON_INFO_1(NDRPOINTER):\n    referent = (\n        ('Data', NETLOGON_INFO_1),\n    )",
  "class NETLOGON_INFO_2(NDRSTRUCT):\n    structure = (\n        ('netlog2_flags', DWORD),\n        ('netlog2_pdc_connection_status', NET_API_STATUS),\n        ('netlog2_trusted_dc_name', LPWSTR),\n        ('netlog2_tc_connection_status', NET_API_STATUS),\n    )",
  "class PNETLOGON_INFO_2(NDRPOINTER):\n    referent = (\n        ('Data', NETLOGON_INFO_2),\n    )",
  "class NETLOGON_INFO_3(NDRSTRUCT):\n    structure = (\n        ('netlog3_flags', DWORD),\n        ('netlog3_logon_attempts', DWORD),\n        ('netlog3_reserved1', DWORD),\n        ('netlog3_reserved2', DWORD),\n        ('netlog3_reserved3', DWORD),\n        ('netlog3_reserved4', DWORD),\n        ('netlog3_reserved5', DWORD),\n    )",
  "class PNETLOGON_INFO_3(NDRPOINTER):\n    referent = (\n        ('Data', NETLOGON_INFO_3),\n    )",
  "class NETLOGON_INFO_4(NDRSTRUCT):\n    structure = (\n        ('netlog4_trusted_dc_name', LPWSTR),\n        ('netlog4_trusted_domain_name', LPWSTR),\n    )",
  "class PNETLOGON_INFO_4(NDRPOINTER):\n    referent = (\n        ('Data', NETLOGON_INFO_4),\n    )",
  "class NETLOGON_CONTROL_QUERY_INFORMATION(NDRUNION):\n    commonHdr = (\n        ('tag', DWORD),\n    )\n\n    union = {\n        1 : ('NetlogonInfo1', PNETLOGON_INFO_1),\n        2 : ('NetlogonInfo2', PNETLOGON_INFO_2),\n        3 : ('NetlogonInfo3', PNETLOGON_INFO_3),\n        4 : ('NetlogonInfo4', PNETLOGON_INFO_4),\n    }",
  "class NETLOGON_VALIDATION_UAS_INFO(NDRSTRUCT):\n    structure = (\n        ('usrlog1_eff_name', DWORD),\n        ('usrlog1_priv', DWORD),\n        ('usrlog1_auth_flags', DWORD),\n        ('usrlog1_num_logons', DWORD),\n        ('usrlog1_bad_pw_count', DWORD),\n        ('usrlog1_last_logon', DWORD),\n        ('usrlog1_last_logoff', DWORD),\n        ('usrlog1_logoff_time', DWORD),\n        ('usrlog1_kickoff_time', DWORD),\n        ('usrlog1_password_age', DWORD),\n        ('usrlog1_pw_can_change', DWORD),\n        ('usrlog1_pw_must_change', DWORD),\n        ('usrlog1_computer', LPWSTR),\n        ('usrlog1_domain', LPWSTR),\n        ('usrlog1_script_path', LPWSTR),\n        ('usrlog1_reserved1', DWORD),\n    )",
  "class PNETLOGON_VALIDATION_UAS_INFO(NDRPOINTER):\n    referent = (\n        ('Data', NETLOGON_VALIDATION_UAS_INFO),\n    )",
  "class NETLOGON_LOGOFF_UAS_INFO(NDRSTRUCT):\n    structure = (\n        ('Duration', DWORD),\n        ('LogonCount', USHORT),\n    )",
  "class UAS_INFO_0(NDRSTRUCT):\n    structure = (\n        ('ComputerName', '16s=\"\"'),\n        ('TimeCreated', ULONG),\n        ('SerialNumber', ULONG),\n    )\n    def getAlignment(self):\n        return 4",
  "class NETLOGON_DUMMY1(NDRUNION):\n    commonHdr = (\n        ('tag', DWORD),\n    )\n\n    union = {\n        1 : ('Dummy', ULONG),\n    }",
  "class CHAR_FIXED_16_ARRAY(NDRUniFixedArray):\n    def getDataLen(self, data, offset=0):\n        return 16",
  "class NL_AUTH_MESSAGE(Structure):\n    structure = (\n        ('MessageType','<L=0'),\n        ('Flags','<L=0'),\n        ('Buffer',':'),\n    )\n    def __init__(self, data = None, alignment = 0):\n        Structure.__init__(self, data, alignment)\n        if data is None:\n            self['Buffer'] = b'\\x00'*4",
  "class NL_AUTH_SIGNATURE(Structure):\n    structure = (\n        ('SignatureAlgorithm','<H=0'),\n        ('SealAlgorithm','<H=0'),\n        ('Pad','<H=0xffff'),\n        ('Flags','<H=0'),\n        ('SequenceNumber','8s=\"\"'),\n        ('Checksum','8s=\"\"'),\n        ('_Confounder','_-Confounder','8'),\n        ('Confounder',':'),\n    )\n    def __init__(self, data = None, alignment = 0):\n        Structure.__init__(self, data, alignment)\n        if data is None:\n            self['Confounder'] = ''",
  "class NL_AUTH_SHA2_SIGNATURE(Structure):\n    structure = (\n        ('SignatureAlgorithm','<H=0'),\n        ('SealAlgorithm','<H=0'),\n        ('Pad','<H=0xffff'),\n        ('Flags','<H=0'),\n        ('SequenceNumber','8s=\"\"'),\n        ('Checksum','32s=\"\"'),\n        ('_Confounder','_-Confounder','8'),\n        ('Confounder',':'),\n    )\n    def __init__(self, data = None, alignment = 0):\n        Structure.__init__(self, data, alignment)\n        if data is None:\n            self['Confounder'] = ''",
  "def ComputeNetlogonCredential(inputData, Sk):\n    k1 = Sk[:7]\n    k3 = crypto.transformKey(k1)\n    k2 = Sk[7:14]\n    k4 = crypto.transformKey(k2)\n    Crypt1 = DES.new(k3, DES.MODE_ECB)\n    Crypt2 = DES.new(k4, DES.MODE_ECB)\n    cipherText = Crypt1.encrypt(inputData)\n    return Crypt2.encrypt(cipherText)",
  "def ComputeNetlogonCredentialAES(inputData, Sk):\n    IV=b'\\x00'*16\n    Crypt1 = AES.new(Sk, AES.MODE_CFB, IV)\n    return Crypt1.encrypt(inputData)",
  "def ComputeSessionKeyAES(sharedSecret, clientChallenge, serverChallenge, sharedSecretHash = None):\n    # added the ability to receive hashes already\n    if sharedSecretHash is None:\n        M4SS = ntlm.NTOWFv1(sharedSecret)\n    else:\n        M4SS = sharedSecretHash\n\n    hm = hmac.new(key=M4SS, digestmod=hashlib.sha256)\n    hm.update(clientChallenge)\n    hm.update(serverChallenge)\n    sessionKey = hm.digest()\n\n    return sessionKey[:16]",
  "def ComputeSessionKeyStrongKey(sharedSecret, clientChallenge, serverChallenge, sharedSecretHash = None):\n    # added the ability to receive hashes already\n\n    if sharedSecretHash is None:\n        M4SS = ntlm.NTOWFv1(sharedSecret)\n    else:\n        M4SS = sharedSecretHash\n\n    md5 = hashlib.new('md5')\n    md5.update(b'\\x00'*4)\n    md5.update(clientChallenge)\n    md5.update(serverChallenge)\n    finalMD5 = md5.digest()\n    hm = hmac.new(M4SS, digestmod=hashlib.md5)\n    hm.update(finalMD5)\n    return hm.digest()",
  "def deriveSequenceNumber(sequenceNum):\n    sequenceLow = sequenceNum & 0xffffffff\n    sequenceHigh = (sequenceNum >> 32) & 0xffffffff\n    sequenceHigh |= 0x80000000\n\n    res = pack('>L', sequenceLow)\n    res += pack('>L', sequenceHigh)\n    return res",
  "def ComputeNetlogonSignatureAES(authSignature, message, confounder, sessionKey):\n    # [MS-NRPC] Section 3.3.4.2.1, point 7\n    hm = hmac.new(key=sessionKey, digestmod=hashlib.sha256)\n    hm.update(authSignature.getData()[:8])\n    # If no confidentiality requested, it should be ''\n    hm.update(confounder)\n    hm.update(bytes(message))\n    return hm.digest()[:8]+'\\x00'*24",
  "def ComputeNetlogonSignatureMD5(authSignature, message, confounder, sessionKey):\n    # [MS-NRPC] Section 3.3.4.2.1, point 7\n    md5 = hashlib.new('md5')\n    md5.update(b'\\x00'*4)\n    md5.update(authSignature.getData()[:8])\n    # If no confidentiality requested, it should be ''\n    md5.update(confounder)\n    md5.update(bytes(message))\n    finalMD5 = md5.digest()\n    hm = hmac.new(sessionKey, digestmod=hashlib.md5)\n    hm.update(finalMD5)\n    return hm.digest()[:8]",
  "def ComputeNetlogonAuthenticator(clientStoredCredential, sessionKey):\n    # [MS-NRPC] Section 3.1.4.5\n    timestamp = int(time.time())\n\n    authenticator = NETLOGON_AUTHENTICATOR()\n    authenticator['Timestamp'] = timestamp\n\n    credential = unpack('<I', clientStoredCredential[:4])[0] + timestamp\n    if credential > 0xffffffff:\n        credential &= 0xffffffff\n    credential = pack('<I', credential)\n\n    authenticator['Credential'] = ComputeNetlogonCredential(credential + clientStoredCredential[4:], sessionKey)\n    return authenticator",
  "def encryptSequenceNumberRC4(sequenceNum, checkSum, sessionKey):\n    # [MS-NRPC] Section 3.3.4.2.1, point 9\n\n    hm = hmac.new(sessionKey, digestmod=hashlib.md5)\n    hm.update(b'\\x00'*4)\n    hm2 = hmac.new(hm.digest(), digestmod=hashlib.md5)\n    hm2.update(checkSum)\n    encryptionKey = hm2.digest()\n\n    cipher = ARC4.new(encryptionKey)\n    return cipher.encrypt(sequenceNum)",
  "def decryptSequenceNumberRC4(sequenceNum, checkSum, sessionKey):\n    # [MS-NRPC] Section 3.3.4.2.2, point 5\n\n    return encryptSequenceNumberRC4(sequenceNum, checkSum, sessionKey)",
  "def encryptSequenceNumberAES(sequenceNum, checkSum, sessionKey):\n    # [MS-NRPC] Section 3.3.4.2.1, point 9\n    IV = checkSum[:8] + checkSum[:8]\n    Cipher = AES.new(sessionKey, AES.MODE_CFB, IV)\n    return Cipher.encrypt(sequenceNum)",
  "def decryptSequenceNumberAES(sequenceNum, checkSum, sessionKey):\n    # [MS-NRPC] Section 3.3.4.2.1, point 9\n    IV = checkSum[:8] + checkSum[:8]\n    Cipher = AES.new(sessionKey, AES.MODE_CFB, IV)\n    return Cipher.decrypt(sequenceNum)",
  "def SIGN(data, confounder, sequenceNum, key, aes = False):\n    if aes is False:\n        signature = NL_AUTH_SIGNATURE()\n        signature['SignatureAlgorithm'] = NL_SIGNATURE_HMAC_MD5\n        if confounder == '':\n            signature['SealAlgorithm'] = NL_SEAL_NOT_ENCRYPTED\n        else:\n            signature['SealAlgorithm'] = NL_SEAL_RC4\n        signature['Checksum'] = ComputeNetlogonSignatureMD5(signature, data, confounder, key)\n        signature['SequenceNumber'] = encryptSequenceNumberRC4(deriveSequenceNumber(sequenceNum), signature['Checksum'], key)\n        return signature\n    else:\n        signature = NL_AUTH_SIGNATURE()\n        signature['SignatureAlgorithm'] = NL_SIGNATURE_HMAC_SHA256\n        if confounder == '':\n            signature['SealAlgorithm'] = NL_SEAL_NOT_ENCRYPTED\n        else:\n            signature['SealAlgorithm'] = NL_SEAL_AES128\n        signature['Checksum'] = ComputeNetlogonSignatureAES(signature, data, confounder, key)\n        signature['SequenceNumber'] = encryptSequenceNumberAES(deriveSequenceNumber(sequenceNum), signature['Checksum'], key)\n        return signature",
  "def SEAL(data, confounder, sequenceNum, key, aes = False):\n    signature = SIGN(data, confounder, sequenceNum, key, aes)\n    sequenceNum = deriveSequenceNumber(sequenceNum)\n\n    XorKey = bytearray(key)\n    for i in range(len(XorKey)):\n        XorKey[i] = XorKey[i] ^ 0xf0\n\n    XorKey = bytes(XorKey)\n\n    if aes is False:\n        hm = hmac.new(XorKey, digestmod=hashlib.md5)\n        hm.update(b'\\x00'*4)\n        hm2 = hmac.new(hm.digest(), digestmod=hashlib.md5)\n        hm2.update(sequenceNum)\n        encryptionKey = hm2.digest()\n\n        cipher = ARC4.new(encryptionKey)\n        cfounder = cipher.encrypt(confounder)\n        cipher = ARC4.new(encryptionKey)\n        encrypted = cipher.encrypt(data)\n\n        signature['Confounder'] = cfounder\n\n        return encrypted, signature\n    else:\n        IV = sequenceNum + sequenceNum\n        cipher = AES.new(XorKey, AES.MODE_CFB, IV)\n        cfounder = cipher.encrypt(confounder)\n        encrypted = cipher.encrypt(data)\n\n        signature['Confounder'] = cfounder\n\n        return encrypted, signature",
  "def UNSEAL(data, auth_data, key, aes = False):\n    auth_data = NL_AUTH_SIGNATURE(auth_data)\n    XorKey = bytearray(key)\n    for i in range(len(XorKey)):\n        XorKey[i] = XorKey[i] ^ 0xf0\n\n    XorKey = bytes(XorKey)\n\n    if aes is False:\n        sequenceNum = decryptSequenceNumberRC4(auth_data['SequenceNumber'], auth_data['Checksum'],  key)\n        hm = hmac.new(XorKey, digestmod=hashlib.md5)\n        hm.update(b'\\x00'*4)\n        hm2 = hmac.new(hm.digest(), digestmod=hashlib.md5)\n        hm2.update(sequenceNum)\n        encryptionKey = hm2.digest()\n\n        cipher = ARC4.new(encryptionKey)\n        cfounder = cipher.encrypt(auth_data['Confounder'])\n        cipher = ARC4.new(encryptionKey)\n        plain = cipher.encrypt(data)\n\n        return plain, cfounder\n    else:\n        sequenceNum = decryptSequenceNumberAES(auth_data['SequenceNumber'], auth_data['Checksum'],  key)\n        IV = sequenceNum + sequenceNum\n        cipher = AES.new(XorKey, AES.MODE_CFB, IV)\n        cfounder = cipher.decrypt(auth_data['Confounder'])\n        plain = cipher.decrypt(data)\n        return plain, cfounder",
  "def getSSPType1(workstation='', domain='', signingRequired=False):\n    auth = NL_AUTH_MESSAGE()\n    auth['Flags'] = 0\n    auth['Buffer'] = b''\n    auth['Flags'] |= NL_AUTH_MESSAGE_NETBIOS_DOMAIN\n    if domain != '':\n        auth['Buffer'] = auth['Buffer'] + b(domain) + b'\\x00'\n    else:\n        auth['Buffer'] += b'WORKGROUP\\x00'\n\n    auth['Flags'] |= NL_AUTH_MESSAGE_NETBIOS_HOST\n\n    if workstation != '':\n        auth['Buffer'] = auth['Buffer'] + b(workstation) + b'\\x00'\n    else:\n        auth['Buffer'] += b'MYHOST\\x00'\n\n    auth['Flags'] |= NL_AUTH_MESSAGE_NETBIOS_HOST_UTF8\n\n    if workstation != '':\n        auth['Buffer'] += pack('<B',len(workstation)) + b(workstation) + b'\\x00'\n    else:\n        auth['Buffer'] += b'\\x06MYHOST\\x00'\n\n    return auth",
  "class DsrGetDcNameEx2(NDRCALL):\n    opnum = 34\n    structure = (\n       ('ComputerName',PLOGONSRV_HANDLE),\n       ('AccountName', LPWSTR),\n       ('AllowableAccountControlBits', ULONG),\n       ('DomainName',LPWSTR),\n       ('DomainGuid',PGUID),\n       ('SiteName',LPWSTR),\n       ('Flags',ULONG),\n    )",
  "class DsrGetDcNameEx2Response(NDRCALL):\n    structure = (\n       ('DomainControllerInfo',PDOMAIN_CONTROLLER_INFOW),\n       ('ErrorCode',NET_API_STATUS),\n    )",
  "class DsrGetDcNameEx(NDRCALL):\n    opnum = 27\n    structure = (\n       ('ComputerName',PLOGONSRV_HANDLE),\n       ('DomainName',LPWSTR),\n       ('DomainGuid',PGUID),\n       ('SiteName',LPWSTR),\n       ('Flags',ULONG),\n    )",
  "class DsrGetDcNameExResponse(NDRCALL):\n    structure = (\n       ('DomainControllerInfo',PDOMAIN_CONTROLLER_INFOW),\n       ('ErrorCode',NET_API_STATUS),\n    )",
  "class DsrGetDcName(NDRCALL):\n    opnum = 20\n    structure = (\n       ('ComputerName',PLOGONSRV_HANDLE),\n       ('DomainName',LPWSTR),\n       ('DomainGuid',PGUID),\n       ('SiteGuid',PGUID),\n       ('Flags',ULONG),\n    )",
  "class DsrGetDcNameResponse(NDRCALL):\n    structure = (\n       ('DomainControllerInfo',PDOMAIN_CONTROLLER_INFOW),\n       ('ErrorCode',NET_API_STATUS),\n    )",
  "class NetrGetDCName(NDRCALL):\n    opnum = 11\n    structure = (\n       ('ServerName',LOGONSRV_HANDLE),\n       ('DomainName',LPWSTR),\n    )",
  "class NetrGetDCNameResponse(NDRCALL):\n    structure = (\n       ('Buffer',LPWSTR),\n       ('ErrorCode',NET_API_STATUS),\n    )",
  "class NetrGetAnyDCName(NDRCALL):\n    opnum = 13\n    structure = (\n       ('ServerName',PLOGONSRV_HANDLE),\n       ('DomainName',LPWSTR),\n    )",
  "class NetrGetAnyDCNameResponse(NDRCALL):\n    structure = (\n       ('Buffer',LPWSTR),\n       ('ErrorCode',NET_API_STATUS),\n    )",
  "class DsrGetSiteName(NDRCALL):\n    opnum = 28\n    structure = (\n       ('ComputerName',PLOGONSRV_HANDLE),\n    )",
  "class DsrGetSiteNameResponse(NDRCALL):\n    structure = (\n       ('SiteName',LPWSTR),\n       ('ErrorCode',NET_API_STATUS),\n    )",
  "class DsrGetDcSiteCoverageW(NDRCALL):\n    opnum = 38\n    structure = (\n       ('ServerName',PLOGONSRV_HANDLE),\n    )",
  "class DsrGetDcSiteCoverageWResponse(NDRCALL):\n    structure = (\n       ('SiteNames',PNL_SITE_NAME_ARRAY),\n       ('ErrorCode',NET_API_STATUS),\n    )",
  "class DsrAddressToSiteNamesW(NDRCALL):\n    opnum = 33\n    structure = (\n       ('ComputerName',PLOGONSRV_HANDLE),\n       ('EntryCount',ULONG),\n       ('SocketAddresses',NL_SOCKET_ADDRESS_ARRAY),\n    )",
  "class DsrAddressToSiteNamesWResponse(NDRCALL):\n    structure = (\n       ('SiteNames',PNL_SITE_NAME_ARRAY),\n       ('ErrorCode',NET_API_STATUS),\n    )",
  "class DsrAddressToSiteNamesExW(NDRCALL):\n    opnum = 37\n    structure = (\n       ('ComputerName',PLOGONSRV_HANDLE),\n       ('EntryCount',ULONG),\n       ('SocketAddresses',NL_SOCKET_ADDRESS_ARRAY),\n    )",
  "class DsrAddressToSiteNamesExWResponse(NDRCALL):\n    structure = (\n       ('SiteNames',PNL_SITE_NAME_EX_ARRAY),\n       ('ErrorCode',NET_API_STATUS),\n    )",
  "class DsrDeregisterDnsHostRecords(NDRCALL):\n    opnum = 41\n    structure = (\n       ('ServerName',PLOGONSRV_HANDLE),\n       ('DnsDomainName',LPWSTR),\n       ('DomainGuid',PGUID),\n       ('DsaGuid',PGUID),\n       ('DnsHostName',WSTR),\n    )",
  "class DsrDeregisterDnsHostRecordsResponse(NDRCALL):\n    structure = (\n       ('ErrorCode',NET_API_STATUS),\n    )",
  "class DSRUpdateReadOnlyServerDnsRecords(NDRCALL):\n    opnum = 48\n    structure = (\n       ('ServerName',PLOGONSRV_HANDLE),\n       ('ComputerName',WSTR),\n       ('Authenticator',NETLOGON_AUTHENTICATOR),\n       ('SiteName',LPWSTR),\n       ('DnsTtl',ULONG),\n       ('DnsNames',NL_DNS_NAME_INFO_ARRAY),\n    )",
  "class DSRUpdateReadOnlyServerDnsRecordsResponse(NDRCALL):\n    structure = (\n       ('ReturnAuthenticator',NETLOGON_AUTHENTICATOR),\n       ('DnsNames',NL_DNS_NAME_INFO_ARRAY),\n       ('ErrorCode',NTSTATUS),\n    )",
  "class NetrServerReqChallenge(NDRCALL):\n    opnum = 4\n    structure = (\n       ('PrimaryName',PLOGONSRV_HANDLE),\n       ('ComputerName',WSTR),\n       ('ClientChallenge',NETLOGON_CREDENTIAL),\n    )",
  "class NetrServerReqChallengeResponse(NDRCALL):\n    structure = (\n       ('ServerChallenge',NETLOGON_CREDENTIAL),\n       ('ErrorCode',NTSTATUS),\n    )",
  "class NetrServerAuthenticate3(NDRCALL):\n    opnum = 26\n    structure = (\n       ('PrimaryName',PLOGONSRV_HANDLE),\n       ('AccountName',WSTR),\n       ('SecureChannelType',NETLOGON_SECURE_CHANNEL_TYPE),\n       ('ComputerName',WSTR),\n       ('ClientCredential',NETLOGON_CREDENTIAL),\n       ('NegotiateFlags',ULONG),\n    )",
  "class NetrServerAuthenticate3Response(NDRCALL):\n    structure = (\n       ('ServerCredential',NETLOGON_CREDENTIAL),\n       ('NegotiateFlags',ULONG),\n       ('AccountRid',ULONG),\n       ('ErrorCode',NTSTATUS),\n    )",
  "class NetrServerAuthenticate2(NDRCALL):\n    opnum = 15\n    structure = (\n       ('PrimaryName',PLOGONSRV_HANDLE),\n       ('AccountName',WSTR),\n       ('SecureChannelType',NETLOGON_SECURE_CHANNEL_TYPE),\n       ('ComputerName',WSTR),\n       ('ClientCredential',NETLOGON_CREDENTIAL),\n       ('NegotiateFlags',ULONG),\n    )",
  "class NetrServerAuthenticate2Response(NDRCALL):\n    structure = (\n       ('ServerCredential',NETLOGON_CREDENTIAL),\n       ('NegotiateFlags',ULONG),\n       ('ErrorCode',NTSTATUS),\n    )",
  "class NetrServerAuthenticate(NDRCALL):\n    opnum = 5\n    structure = (\n       ('PrimaryName',PLOGONSRV_HANDLE),\n       ('AccountName',WSTR),\n       ('SecureChannelType',NETLOGON_SECURE_CHANNEL_TYPE),\n       ('ComputerName',WSTR),\n       ('ClientCredential',NETLOGON_CREDENTIAL),\n    )",
  "class NetrServerAuthenticateResponse(NDRCALL):\n    structure = (\n       ('ServerCredential',NETLOGON_CREDENTIAL),\n       ('ErrorCode',NTSTATUS),\n    )",
  "class NetrServerPasswordSet2(NDRCALL):\n    opnum = 30\n    structure = (\n       ('PrimaryName',PLOGONSRV_HANDLE),\n       ('AccountName',WSTR),\n       ('SecureChannelType',NETLOGON_SECURE_CHANNEL_TYPE),\n       ('ComputerName',WSTR),\n       ('Authenticator',NETLOGON_AUTHENTICATOR),\n       #('ClearNewPassword',NL_TRUST_PASSWORD),\n       ('ClearNewPassword',NL_TRUST_PASSWORD_FIXED_ARRAY),\n    )",
  "class NetrServerPasswordSet2Response(NDRCALL):\n    structure = (\n       ('ReturnAuthenticator',NETLOGON_AUTHENTICATOR),\n       ('ErrorCode',NTSTATUS),\n    )",
  "class NetrServerPasswordGet(NDRCALL):\n    opnum = 31\n    structure = (\n       ('PrimaryName',PLOGONSRV_HANDLE),\n       ('AccountName',WSTR),\n       ('AccountType',NETLOGON_SECURE_CHANNEL_TYPE),\n       ('ComputerName',WSTR),\n       ('Authenticator',NETLOGON_AUTHENTICATOR),\n    )",
  "class NetrServerPasswordGetResponse(NDRCALL):\n    structure = (\n       ('ReturnAuthenticator',NETLOGON_AUTHENTICATOR),\n       ('EncryptedNtOwfPassword',ENCRYPTED_NT_OWF_PASSWORD),\n       ('ErrorCode',NTSTATUS),\n    )",
  "class NetrServerTrustPasswordsGet(NDRCALL):\n    opnum = 42\n    structure = (\n       ('TrustedDcName',PLOGONSRV_HANDLE),\n       ('AccountName',WSTR),\n       ('SecureChannelType',NETLOGON_SECURE_CHANNEL_TYPE),\n       ('ComputerName',WSTR),\n       ('Authenticator',NETLOGON_AUTHENTICATOR),\n    )",
  "class NetrServerTrustPasswordsGetResponse(NDRCALL):\n    structure = (\n       ('ReturnAuthenticator',NETLOGON_AUTHENTICATOR),\n       ('EncryptedNewOwfPassword',ENCRYPTED_NT_OWF_PASSWORD),\n       ('EncryptedOldOwfPassword',ENCRYPTED_NT_OWF_PASSWORD),\n       ('ErrorCode',NTSTATUS),\n    )",
  "class NetrLogonGetDomainInfo(NDRCALL):\n    opnum = 29\n    structure = (\n       ('ServerName',LOGONSRV_HANDLE),\n       ('ComputerName',LPWSTR),\n       ('Authenticator',NETLOGON_AUTHENTICATOR),\n       ('ReturnAuthenticator',NETLOGON_AUTHENTICATOR),\n       ('Level',DWORD),\n       ('WkstaBuffer',NETLOGON_WORKSTATION_INFORMATION),\n    )",
  "class NetrLogonGetDomainInfoResponse(NDRCALL):\n    structure = (\n       ('ReturnAuthenticator',NETLOGON_AUTHENTICATOR),\n       ('DomBuffer',NETLOGON_DOMAIN_INFORMATION),\n       ('ErrorCode',NTSTATUS),\n    )",
  "class NetrLogonGetCapabilities(NDRCALL):\n    opnum = 21\n    structure = (\n       ('ServerName',LOGONSRV_HANDLE),\n       ('ComputerName',LPWSTR),\n       ('Authenticator',NETLOGON_AUTHENTICATOR),\n       ('ReturnAuthenticator',NETLOGON_AUTHENTICATOR),\n       ('QueryLevel',DWORD),\n    )",
  "class NetrLogonGetCapabilitiesResponse(NDRCALL):\n    structure = (\n       ('ReturnAuthenticator',NETLOGON_AUTHENTICATOR),\n       ('ServerCapabilities',NETLOGON_CAPABILITIES),\n       ('ErrorCode',NTSTATUS),\n    )",
  "class NetrLogonSamLogonEx(NDRCALL):\n    opnum = 39\n    structure = (\n       ('LogonServer',LPWSTR),\n       ('ComputerName',LPWSTR),\n       ('LogonLevel',NETLOGON_LOGON_INFO_CLASS),\n       ('LogonInformation',NETLOGON_LEVEL),\n       ('ValidationLevel',NETLOGON_VALIDATION_INFO_CLASS),\n       ('ExtraFlags',ULONG),\n    )",
  "class NetrLogonSamLogonExResponse(NDRCALL):\n    structure = (\n       ('ValidationInformation',NETLOGON_VALIDATION),\n       ('Authoritative',UCHAR),\n       ('ExtraFlags',ULONG),\n       ('ErrorCode',NTSTATUS),\n    )",
  "class NetrLogonSamLogonWithFlags(NDRCALL):\n    opnum = 45\n    structure = (\n       ('LogonServer',LPWSTR),\n       ('ComputerName',LPWSTR),\n       ('Authenticator',PNETLOGON_AUTHENTICATOR),\n       ('ReturnAuthenticator',PNETLOGON_AUTHENTICATOR),\n       ('LogonLevel',NETLOGON_LOGON_INFO_CLASS),\n       ('LogonInformation',NETLOGON_LEVEL),\n       ('ValidationLevel',NETLOGON_VALIDATION_INFO_CLASS),\n       ('ExtraFlags',ULONG),\n    )",
  "class NetrLogonSamLogonWithFlagsResponse(NDRCALL):\n    structure = (\n       ('ReturnAuthenticator',PNETLOGON_AUTHENTICATOR),\n       ('ValidationInformation',NETLOGON_VALIDATION),\n       ('Authoritative',UCHAR),\n       ('ExtraFlags',ULONG),\n       ('ErrorCode',NTSTATUS),\n    )",
  "class NetrLogonSamLogon(NDRCALL):\n    opnum = 2\n    structure = (\n       ('LogonServer',LPWSTR),\n       ('ComputerName',LPWSTR),\n       ('Authenticator',PNETLOGON_AUTHENTICATOR),\n       ('ReturnAuthenticator',PNETLOGON_AUTHENTICATOR),\n       ('LogonLevel',NETLOGON_LOGON_INFO_CLASS),\n       ('LogonInformation',NETLOGON_LEVEL),\n       ('ValidationLevel',NETLOGON_VALIDATION_INFO_CLASS),\n    )",
  "class NetrLogonSamLogonResponse(NDRCALL):\n    structure = (\n       ('ReturnAuthenticator',PNETLOGON_AUTHENTICATOR),\n       ('ValidationInformation',NETLOGON_VALIDATION),\n       ('Authoritative',UCHAR),\n       ('ErrorCode',NTSTATUS),\n    )",
  "class NetrLogonSamLogoff(NDRCALL):\n    opnum = 3\n    structure = (\n       ('LogonServer',LPWSTR),\n       ('ComputerName',LPWSTR),\n       ('Authenticator',PNETLOGON_AUTHENTICATOR),\n       ('ReturnAuthenticator',PNETLOGON_AUTHENTICATOR),\n       ('LogonLevel',NETLOGON_LOGON_INFO_CLASS),\n       ('LogonInformation',NETLOGON_LEVEL),\n    )",
  "class NetrLogonSamLogoffResponse(NDRCALL):\n    structure = (\n       ('ReturnAuthenticator',PNETLOGON_AUTHENTICATOR),\n       ('ErrorCode',NTSTATUS),\n    )",
  "class NetrDatabaseDeltas(NDRCALL):\n    opnum = 7\n    structure = (\n       ('PrimaryName',LOGONSRV_HANDLE),\n       ('ComputerName',WSTR),\n       ('Authenticator',NETLOGON_AUTHENTICATOR),\n       ('ReturnAuthenticator',NETLOGON_AUTHENTICATOR),\n       ('DatabaseID',DWORD),\n       ('DomainModifiedCount',NLPR_MODIFIED_COUNT),\n       ('PreferredMaximumLength',DWORD),\n    )",
  "class NetrDatabaseDeltasResponse(NDRCALL):\n    structure = (\n       ('ReturnAuthenticator',NETLOGON_AUTHENTICATOR),\n       ('DomainModifiedCount',NLPR_MODIFIED_COUNT),\n       ('DeltaArray',PNETLOGON_DELTA_ENUM_ARRAY),\n       ('ErrorCode',NTSTATUS),\n    )",
  "class NetrDatabaseSync2(NDRCALL):\n    opnum = 16\n    structure = (\n       ('PrimaryName',LOGONSRV_HANDLE),\n       ('ComputerName',WSTR),\n       ('Authenticator',NETLOGON_AUTHENTICATOR),\n       ('ReturnAuthenticator',NETLOGON_AUTHENTICATOR),\n       ('DatabaseID',DWORD),\n       ('RestartState',SYNC_STATE),\n       ('SyncContext',ULONG),\n       ('PreferredMaximumLength',DWORD),\n    )",
  "class NetrDatabaseSync2Response(NDRCALL):\n    structure = (\n       ('ReturnAuthenticator',NETLOGON_AUTHENTICATOR),\n       ('SyncContext',ULONG),\n       ('DeltaArray',PNETLOGON_DELTA_ENUM_ARRAY),\n       ('ErrorCode',NTSTATUS),\n    )",
  "class NetrDatabaseSync(NDRCALL):\n    opnum = 8\n    structure = (\n       ('PrimaryName',LOGONSRV_HANDLE),\n       ('ComputerName',WSTR),\n       ('Authenticator',NETLOGON_AUTHENTICATOR),\n       ('ReturnAuthenticator',NETLOGON_AUTHENTICATOR),\n       ('DatabaseID',DWORD),\n       ('SyncContext',ULONG),\n       ('PreferredMaximumLength',DWORD),\n    )",
  "class NetrDatabaseSyncResponse(NDRCALL):\n    structure = (\n       ('ReturnAuthenticator',NETLOGON_AUTHENTICATOR),\n       ('SyncContext',ULONG),\n       ('DeltaArray',PNETLOGON_DELTA_ENUM_ARRAY),\n       ('ErrorCode',NTSTATUS),\n    )",
  "class NetrDatabaseRedo(NDRCALL):\n    opnum = 17\n    structure = (\n       ('PrimaryName',LOGONSRV_HANDLE),\n       ('ComputerName',WSTR),\n       ('Authenticator',NETLOGON_AUTHENTICATOR),\n       ('ReturnAuthenticator',NETLOGON_AUTHENTICATOR),\n       ('ChangeLogEntry',PUCHAR_ARRAY),\n       ('ChangeLogEntrySize',DWORD),\n    )",
  "class NetrDatabaseRedoResponse(NDRCALL):\n    structure = (\n       ('ReturnAuthenticator',NETLOGON_AUTHENTICATOR),\n       ('DeltaArray',PNETLOGON_DELTA_ENUM_ARRAY),\n       ('ErrorCode',NTSTATUS),\n    )",
  "class DsrEnumerateDomainTrusts(NDRCALL):\n    opnum = 40\n    structure = (\n       ('ServerName',PLOGONSRV_HANDLE),\n       ('Flags',ULONG),\n    )",
  "class DsrEnumerateDomainTrustsResponse(NDRCALL):\n    structure = (\n       ('Domains',NETLOGON_TRUSTED_DOMAIN_ARRAY),\n       ('ErrorCode',NTSTATUS),\n    )",
  "class NetrEnumerateTrustedDomainsEx(NDRCALL):\n    opnum = 36\n    structure = (\n       ('ServerName',PLOGONSRV_HANDLE),\n    )",
  "class NetrEnumerateTrustedDomainsExResponse(NDRCALL):\n    structure = (\n       ('Domains',NETLOGON_TRUSTED_DOMAIN_ARRAY),\n       ('ErrorCode',NTSTATUS),\n    )",
  "class NetrEnumerateTrustedDomains(NDRCALL):\n    opnum = 19\n    structure = (\n       ('ServerName',PLOGONSRV_HANDLE),\n    )",
  "class NetrEnumerateTrustedDomainsResponse(NDRCALL):\n    structure = (\n       ('DomainNameBuffer',DOMAIN_NAME_BUFFER),\n       ('ErrorCode',NTSTATUS),\n    )",
  "class NetrGetForestTrustInformation(NDRCALL):\n    opnum = 44\n    structure = (\n       ('ServerName',PLOGONSRV_HANDLE),\n       ('ComputerName',WSTR),\n       ('Authenticator',NETLOGON_AUTHENTICATOR),\n       ('ReturnAuthenticator',NETLOGON_AUTHENTICATOR),\n       ('Flags',DWORD),\n    )",
  "class NetrGetForestTrustInformationResponse(NDRCALL):\n    structure = (\n       ('ReturnAuthenticator',NETLOGON_AUTHENTICATOR),\n       ('ForestTrustInfo',PLSA_FOREST_TRUST_INFORMATION),\n       ('ErrorCode',NTSTATUS),\n    )",
  "class DsrGetForestTrustInformation(NDRCALL):\n    opnum = 43\n    structure = (\n       ('ServerName',PLOGONSRV_HANDLE),\n       ('TrustedDomainName',LPWSTR),\n       ('Flags',DWORD),\n    )",
  "class DsrGetForestTrustInformationResponse(NDRCALL):\n    structure = (\n       ('ForestTrustInfo',PLSA_FOREST_TRUST_INFORMATION),\n       ('ErrorCode',NTSTATUS),\n    )",
  "class NetrServerGetTrustInfo(NDRCALL):\n    opnum = 46\n    structure = (\n       ('TrustedDcName',PLOGONSRV_HANDLE),\n       ('AccountName',WSTR),\n       ('SecureChannelType',NETLOGON_SECURE_CHANNEL_TYPE),\n       ('ComputerName',WSTR),\n       ('Authenticator',NETLOGON_AUTHENTICATOR),\n    )",
  "class NetrServerGetTrustInfoResponse(NDRCALL):\n    structure = (\n       ('ReturnAuthenticator',NETLOGON_AUTHENTICATOR),\n       ('EncryptedNewOwfPassword',ENCRYPTED_NT_OWF_PASSWORD),\n       ('EncryptedOldOwfPassword',ENCRYPTED_NT_OWF_PASSWORD),\n       ('TrustInfo',PNL_GENERIC_RPC_DATA),\n       ('ErrorCode',NTSTATUS),\n    )",
  "class NetrLogonGetTrustRid(NDRCALL):\n    opnum = 23\n    structure = (\n       ('ServerName',PLOGONSRV_HANDLE),\n       ('DomainName',LPWSTR),\n    )",
  "class NetrLogonGetTrustRidResponse(NDRCALL):\n    structure = (\n       ('Rid',ULONG),\n       ('ErrorCode',NTSTATUS),\n    )",
  "class NetrLogonComputeServerDigest(NDRCALL):\n    opnum = 24\n    structure = (\n       ('ServerName',PLOGONSRV_HANDLE),\n       ('Rid',ULONG),\n       ('Message',UCHAR_ARRAY),\n       ('MessageSize',ULONG),\n    )",
  "class NetrLogonComputeServerDigestResponse(NDRCALL):\n    structure = (\n       ('NewMessageDigest',CHAR_FIXED_16_ARRAY),\n       ('OldMessageDigest',CHAR_FIXED_16_ARRAY),\n       ('ErrorCode',NTSTATUS),\n    )",
  "class NetrLogonComputeClientDigest(NDRCALL):\n    opnum = 25\n    structure = (\n       ('ServerName',PLOGONSRV_HANDLE),\n       ('DomainName',LPWSTR),\n       ('Message',UCHAR_ARRAY),\n       ('MessageSize',ULONG),\n    )",
  "class NetrLogonComputeClientDigestResponse(NDRCALL):\n    structure = (\n       ('NewMessageDigest',CHAR_FIXED_16_ARRAY),\n       ('OldMessageDigest',CHAR_FIXED_16_ARRAY),\n       ('ErrorCode',NTSTATUS),\n    )",
  "class NetrLogonSendToSam(NDRCALL):\n    opnum = 32\n    structure = (\n       ('PrimaryName',PLOGONSRV_HANDLE),\n       ('ComputerName',WSTR),\n       ('Authenticator',NETLOGON_AUTHENTICATOR),\n       ('OpaqueBuffer',UCHAR_ARRAY),\n       ('OpaqueBufferSize',ULONG),\n    )",
  "class NetrLogonSendToSamResponse(NDRCALL):\n    structure = (\n       ('ReturnAuthenticator',NETLOGON_AUTHENTICATOR),\n       ('ErrorCode',NTSTATUS),\n    )",
  "class NetrLogonSetServiceBits(NDRCALL):\n    opnum = 22\n    structure = (\n       ('ServerName',PLOGONSRV_HANDLE),\n       ('ServiceBitsOfInterest',DWORD),\n       ('ServiceBits',DWORD),\n    )",
  "class NetrLogonSetServiceBitsResponse(NDRCALL):\n    structure = (\n       ('ErrorCode',NTSTATUS),\n    )",
  "class NetrLogonGetTimeServiceParentDomain(NDRCALL):\n    opnum = 35\n    structure = (\n       ('ServerName',PLOGONSRV_HANDLE),\n    )",
  "class NetrLogonGetTimeServiceParentDomainResponse(NDRCALL):\n    structure = (\n       ('DomainName',LPWSTR),\n       ('PdcSameSite',LONG),\n       ('ErrorCode',NET_API_STATUS),\n    )",
  "class NetrLogonControl2Ex(NDRCALL):\n    opnum = 18\n    structure = (\n       ('ServerName',PLOGONSRV_HANDLE),\n       ('FunctionCode',DWORD),\n       ('QueryLevel',DWORD),\n       ('Data',NETLOGON_CONTROL_DATA_INFORMATION),\n    )",
  "class NetrLogonControl2ExResponse(NDRCALL):\n    structure = (\n       ('Buffer', NETLOGON_CONTROL_QUERY_INFORMATION),\n       ('ErrorCode',NET_API_STATUS),\n    )",
  "class NetrLogonControl2(NDRCALL):\n    opnum = 14\n    structure = (\n       ('ServerName',PLOGONSRV_HANDLE),\n       ('FunctionCode',DWORD),\n       ('QueryLevel',DWORD),\n       ('Data',NETLOGON_CONTROL_DATA_INFORMATION),\n    )",
  "class NetrLogonControl2Response(NDRCALL):\n    structure = (\n       ('Buffer', NETLOGON_CONTROL_QUERY_INFORMATION),\n       ('ErrorCode',NET_API_STATUS),\n    )",
  "class NetrLogonControl(NDRCALL):\n    opnum = 12\n    structure = (\n       ('ServerName',PLOGONSRV_HANDLE),\n       ('FunctionCode',DWORD),\n       ('QueryLevel',DWORD),\n       ('Data',NETLOGON_CONTROL_DATA_INFORMATION),\n    )",
  "class NetrLogonControlResponse(NDRCALL):\n    structure = (\n       ('Buffer',NETLOGON_CONTROL_DATA_INFORMATION),\n       ('ErrorCode',NET_API_STATUS),\n    )",
  "class NetrLogonUasLogon(NDRCALL):\n    opnum = 0\n    structure = (\n       ('ServerName',PLOGONSRV_HANDLE),\n       ('UserName',WSTR),\n       ('Workstation',WSTR),\n    )",
  "class NetrLogonUasLogonResponse(NDRCALL):\n    structure = (\n       ('ValidationInformation',PNETLOGON_VALIDATION_UAS_INFO),\n       ('ErrorCode',NET_API_STATUS),\n    )",
  "class NetrLogonUasLogoff(NDRCALL):\n    opnum = 1\n    structure = (\n       ('ServerName',PLOGONSRV_HANDLE),\n       ('UserName',WSTR),\n       ('Workstation',WSTR),\n    )",
  "class NetrLogonUasLogoffResponse(NDRCALL):\n    structure = (\n       ('LogoffInformation',NETLOGON_LOGOFF_UAS_INFO),\n       ('ErrorCode',NET_API_STATUS),\n    )",
  "def checkNullString(string):\n    if string == NULL:\n        return string\n\n    if string[-1:] != '\\x00':\n        return string + '\\x00'\n    else:\n        return string",
  "def hNetrServerReqChallenge(dce, primaryName, computerName, clientChallenge):\n    request = NetrServerReqChallenge()\n    request['PrimaryName'] = checkNullString(primaryName)\n    request['ComputerName'] = checkNullString(computerName)\n    request['ClientChallenge'] = clientChallenge\n    return dce.request(request)",
  "def hNetrServerAuthenticate3(dce, primaryName, accountName, secureChannelType, computerName, clientCredential, negotiateFlags):\n    request = NetrServerAuthenticate3()\n    request['PrimaryName'] = checkNullString(primaryName)\n    request['AccountName'] = checkNullString(accountName)\n    request['SecureChannelType'] = secureChannelType\n    request['ClientCredential'] = clientCredential\n    request['ComputerName'] = checkNullString(computerName)\n    request['NegotiateFlags'] = negotiateFlags\n    return dce.request(request)",
  "def hDsrGetDcNameEx2(dce, computerName, accountName, allowableAccountControlBits, domainName, domainGuid, siteName, flags):\n    request = DsrGetDcNameEx2()\n    request['ComputerName'] = checkNullString(computerName)\n    request['AccountName'] = checkNullString(accountName)\n    request['AllowableAccountControlBits'] = allowableAccountControlBits\n    request['DomainName'] = checkNullString(domainName)\n    request['DomainGuid'] = domainGuid\n    request['SiteName'] = checkNullString(siteName)\n    request['Flags'] = flags\n    return dce.request(request)",
  "def hDsrGetDcNameEx(dce, computerName, domainName, domainGuid, siteName, flags):\n    request = DsrGetDcNameEx()\n    request['ComputerName'] = checkNullString(computerName)\n    request['DomainName'] = checkNullString(domainName)\n    request['DomainGuid'] = domainGuid\n    request['SiteName'] = siteName\n    request['Flags'] = flags\n    return dce.request(request)",
  "def hDsrGetDcName(dce, computerName, domainName, domainGuid, siteGuid, flags):\n    request = DsrGetDcName()\n    request['ComputerName'] = checkNullString(computerName)\n    request['DomainName'] = checkNullString(domainName)\n    request['DomainGuid'] = domainGuid\n    request['SiteGuid'] = siteGuid\n    request['Flags'] = flags\n    return dce.request(request)",
  "def hNetrGetAnyDCName(dce, serverName, domainName):\n    request = NetrGetAnyDCName()\n    request['ServerName'] = checkNullString(serverName)\n    request['DomainName'] = checkNullString(domainName)\n    return dce.request(request)",
  "def hNetrGetDCName(dce, serverName, domainName):\n    request = NetrGetDCName()\n    request['ServerName'] = checkNullString(serverName)\n    request['DomainName'] = checkNullString(domainName)\n    return dce.request(request)",
  "def hDsrGetSiteName(dce, computerName):\n    request = DsrGetSiteName()\n    request['ComputerName'] = checkNullString(computerName)\n    return dce.request(request)",
  "def hDsrGetDcSiteCoverageW(dce, serverName):\n    request = DsrGetDcSiteCoverageW()\n    request['ServerName'] = checkNullString(serverName)\n    return dce.request(request)",
  "def hNetrServerAuthenticate2(dce, primaryName, accountName, secureChannelType, computerName, clientCredential, negotiateFlags):\n    request = NetrServerAuthenticate2()\n    request['PrimaryName'] = checkNullString(primaryName)\n    request['AccountName'] = checkNullString(accountName)\n    request['SecureChannelType'] = secureChannelType\n    request['ClientCredential'] = clientCredential\n    request['ComputerName'] = checkNullString(computerName)\n    request['NegotiateFlags'] = negotiateFlags\n    return dce.request(request)",
  "def hNetrServerAuthenticate(dce, primaryName, accountName, secureChannelType, computerName, clientCredential):\n    request = NetrServerAuthenticate()\n    request['PrimaryName'] = checkNullString(primaryName)\n    request['AccountName'] = checkNullString(accountName)\n    request['SecureChannelType'] = secureChannelType\n    request['ClientCredential'] = clientCredential\n    request['ComputerName'] = checkNullString(computerName)\n    return dce.request(request)",
  "def hNetrServerPasswordGet(dce, primaryName, accountName, accountType, computerName, authenticator):\n    request = NetrServerPasswordGet()\n    request['PrimaryName'] = checkNullString(primaryName)\n    request['AccountName'] = checkNullString(accountName)\n    request['AccountType'] = accountType\n    request['ComputerName'] = checkNullString(computerName)\n    request['Authenticator'] = authenticator\n    return dce.request(request)",
  "def hNetrServerTrustPasswordsGet(dce, trustedDcName, accountName, secureChannelType, computerName, authenticator):\n    request = NetrServerTrustPasswordsGet()\n    request['TrustedDcName'] = checkNullString(trustedDcName)\n    request['AccountName'] = checkNullString(accountName)\n    request['SecureChannelType'] = secureChannelType\n    request['ComputerName'] = checkNullString(computerName)\n    request['Authenticator'] = authenticator\n    return dce.request(request)",
  "def hNetrServerPasswordSet2(dce, primaryName, accountName, secureChannelType, computerName, authenticator, clearNewPasswordBlob):\n    request = NetrServerPasswordSet2()\n    request['PrimaryName'] = checkNullString(primaryName)\n    request['AccountName'] = checkNullString(accountName)\n    request['SecureChannelType'] = secureChannelType\n    request['ComputerName'] = checkNullString(computerName)\n    request['Authenticator'] = authenticator\n    request['ClearNewPassword'] = clearNewPasswordBlob\n    return dce.request(request)",
  "def hNetrLogonGetDomainInfo(dce, serverName, computerName, authenticator, returnAuthenticator=0, level=1):\n    request = NetrLogonGetDomainInfo()\n    request['ServerName'] = checkNullString(serverName)\n    request['ComputerName'] = checkNullString(computerName)\n    request['Authenticator'] = authenticator\n    if returnAuthenticator == 0:\n        request['ReturnAuthenticator']['Credential'] = b'\\x00'*8\n        request['ReturnAuthenticator']['Timestamp'] = 0\n    else:\n        request['ReturnAuthenticator'] = returnAuthenticator\n\n    request['Level'] = 1\n    if level == 1:\n        request['WkstaBuffer']['tag'] = 1\n        request['WkstaBuffer']['WorkstationInfo']['DnsHostName'] = NULL\n        request['WkstaBuffer']['WorkstationInfo']['SiteName'] = NULL\n        request['WkstaBuffer']['WorkstationInfo']['OsName'] = ''\n        request['WkstaBuffer']['WorkstationInfo']['Dummy1'] = NULL\n        request['WkstaBuffer']['WorkstationInfo']['Dummy2'] = NULL\n        request['WkstaBuffer']['WorkstationInfo']['Dummy3'] = NULL\n        request['WkstaBuffer']['WorkstationInfo']['Dummy4'] = NULL\n    else:\n        request['WkstaBuffer']['tag'] = 2\n        request['WkstaBuffer']['LsaPolicyInfo']['LsaPolicy'] = NULL\n    return dce.request(request)",
  "def hNetrLogonGetCapabilities(dce, serverName, computerName, authenticator, returnAuthenticator=0, queryLevel=1):\n    request = NetrLogonGetCapabilities()\n    request['ServerName'] = checkNullString(serverName)\n    request['ComputerName'] = checkNullString(computerName)\n    request['Authenticator'] = authenticator\n    if returnAuthenticator == 0:\n        request['ReturnAuthenticator']['Credential'] = b'\\x00'*8\n        request['ReturnAuthenticator']['Timestamp'] = 0\n    else:\n        request['ReturnAuthenticator'] = returnAuthenticator\n    request['QueryLevel'] = queryLevel\n    return dce.request(request)",
  "def hNetrServerGetTrustInfo(dce, trustedDcName, accountName, secureChannelType, computerName, authenticator):\n    request = NetrServerGetTrustInfo()\n    request['TrustedDcName'] = checkNullString(trustedDcName)\n    request['AccountName'] = checkNullString(accountName)\n    request['SecureChannelType'] = secureChannelType\n    request['ComputerName'] = checkNullString(computerName)\n    request['Authenticator'] = authenticator\n    return dce.request(request)",
  "def __init__(self, error_string=None, error_code=None, packet=None):\n        DCERPCException.__init__(self, error_string, error_code, packet)",
  "def __str__( self ):\n        key = self.error_code\n        if key in system_errors.ERROR_MESSAGES:\n            error_msg_short = system_errors.ERROR_MESSAGES[key][0]\n            error_msg_verbose = system_errors.ERROR_MESSAGES[key][1]\n            return 'NRPC SessionError: code: 0x%x - %s - %s' % (self.error_code, error_msg_short, error_msg_verbose)\n        elif key in nt_errors.ERROR_MESSAGES:\n            error_msg_short = nt_errors.ERROR_MESSAGES[key][0]\n            error_msg_verbose = nt_errors.ERROR_MESSAGES[key][1]\n            return 'NRPC SessionError: code: 0x%x - %s - %s' % (self.error_code, error_msg_short, error_msg_verbose)\n        else:\n            return 'NRPC SessionError: unknown error code: 0x%x' % (self.error_code)",
  "def getAlignment(self):\n        return 1",
  "def getDataLen(self, data, offset=0):\n        return len(CYPHER_BLOCK())*2",
  "def getDataLen(self, data, offset=0):\n        return len(CYPHER_BLOCK())",
  "def getAlignment(self):\n        return 1",
  "def getDataLen(self, data, offset=0):\n        return 512+4",
  "def getAlignment(self):\n        return 1",
  "def getDataLen(self, data, offset=0):\n        return 512",
  "class enumItems(Enum):\n        NullSecureChannel             = 0\n        MsvApSecureChannel            = 1\n        WorkstationSecureChannel      = 2\n        TrustedDnsDomainSecureChannel = 3\n        TrustedDomainSecureChannel    = 4\n        UasServerSecureChannel        = 5\n        ServerSecureChannel           = 6\n        CdcServerSecureChannel        = 7",
  "def getDataLen(self, data, offset=0):\n        return 128",
  "def getDataLen(self, data, offset=0):\n        return 8",
  "class enumItems(Enum):\n        NetlogonInteractiveInformation           = 1\n        NetlogonNetworkInformation               = 2\n        NetlogonServiceInformation               = 3\n        NetlogonGenericInformation               = 4\n        NetlogonInteractiveTransitiveInformation = 5\n        NetlogonNetworkTransitiveInformation     = 6\n        NetlogonServiceTransitiveInformation     = 7",
  "def getDataLen(self, data, offset=0):\n        return 4*10",
  "class enumItems(Enum):\n        NetlogonValidationUasInfo      = 1\n        NetlogonValidationSamInfo      = 2\n        NetlogonValidationSamInfo2     = 3\n        NetlogonValidationGenericInfo  = 4\n        NetlogonValidationGenericInfo2 = 5\n        NetlogonValidationSamInfo4     = 6",
  "class enumItems(Enum):\n        AddOrChangeDomain     = 1\n        AddOrChangeGroup      = 2\n        DeleteGroup           = 3\n        RenameGroup           = 4\n        AddOrChangeUser       = 5\n        DeleteUser            = 6\n        RenameUser            = 7\n        ChangeGroupMembership = 8\n        AddOrChangeAlias      = 9\n        DeleteAlias           = 10\n        RenameAlias           = 11\n        ChangeAliasMembership = 12\n        AddOrChangeLsaPolicy  = 13\n        AddOrChangeLsaTDomain = 14\n        DeleteLsaTDomain      = 15\n        AddOrChangeLsaAccount = 16\n        DeleteLsaAccount      = 17\n        AddOrChangeLsaSecret  = 18\n        DeleteLsaSecret       = 19\n        DeleteGroupByName     = 20\n        DeleteUserByName      = 21\n        SerialNumberSkip      = 22",
  "class enumItems(Enum):\n        NormalState          = 0\n        DomainState          = 1\n        GroupState           = 2\n        UasBuiltInGroupState = 3\n        UserState            = 4\n        GroupMemberState     = 5\n        AliasState           = 6\n        AliasMemberState     = 7\n        SamDoneState         = 8",
  "def getAlignment(self):\n        return 4",
  "def getDataLen(self, data, offset=0):\n        return 16",
  "def __init__(self, data = None, alignment = 0):\n        Structure.__init__(self, data, alignment)\n        if data is None:\n            self['Buffer'] = b'\\x00'*4",
  "def __init__(self, data = None, alignment = 0):\n        Structure.__init__(self, data, alignment)\n        if data is None:\n            self['Confounder'] = ''",
  "def __init__(self, data = None, alignment = 0):\n        Structure.__init__(self, data, alignment)\n        if data is None:\n            self['Confounder'] = ''",
  "class DCERPCSessionError(DCERPCException):\n    def __init__(self, error_string=None, error_code=None, packet=None):\n        DCERPCException.__init__(self, error_string, error_code, packet)\n\n    def __str__( self ):\n        key = self.error_code\n        if key in nt_errors.ERROR_MESSAGES:\n            error_msg_short = nt_errors.ERROR_MESSAGES[key][0]\n            error_msg_verbose = nt_errors.ERROR_MESSAGES[key][1] \n            return 'LSAD SessionError: code: 0x%x - %s - %s' % (self.error_code, error_msg_short, error_msg_verbose)\n        else:\n            return 'LSAD SessionError: unknown error code: 0x%x' % self.error_code",
  "class LSAPR_HANDLE(NDRSTRUCT):\n    align = 1\n    structure =  (\n        ('Data','20s=\"\"'),\n    )",
  "class STRING(NDRSTRUCT):\n    commonHdr = (\n        ('MaximumLength','<H=len(Data)-12'),\n        ('Length','<H=len(Data)-12'),\n        ('ReferentID','<L=0xff'),\n    )\n    commonHdr64 = (\n        ('MaximumLength','<H=len(Data)-24'),\n        ('Length','<H=len(Data)-24'),\n        ('ReferentID','<Q=0xff'),\n    )\n\n    referent = (\n        ('Data',STR),\n    )\n\n    def dump(self, msg = None, indent = 0):\n        if msg is None:\n            msg = self.__class__.__name__\n        if msg != '':\n            print(\"%s\" % msg, end=' ')\n        # Here just print the data\n        print(\" %r\" % (self['Data']), end=' ')\n\n    def __setitem__(self, key, value):\n        if key == 'Data':\n            self.fields['MaximumLength'] = None\n            self.fields['Length'] = None\n            self.data = None        # force recompute\n        return NDR.__setitem__(self, key, value)",
  "class LSAPR_ACL(NDRSTRUCT):\n    structure =  (\n        ('AclRevision', UCHAR),\n        ('Sbz1', UCHAR),\n        ('AclSize', USHORT),\n        ('Dummy1',NDRUniConformantArray),\n    )",
  "class PLSAPR_SECURITY_DESCRIPTOR(NDRPOINTER):\n    referent = (\n        ('Data', LSAPR_SECURITY_DESCRIPTOR),\n    )",
  "class SECURITY_IMPERSONATION_LEVEL(NDRENUM):\n    class enumItems(Enum):\n        SecurityAnonymous      = 0\n        SecurityIdentification = 1\n        SecurityImpersonation  = 2\n        SecurityDelegation     = 3",
  "class SECURITY_QUALITY_OF_SERVICE(NDRSTRUCT):\n    structure = (\n        ('Length', DWORD), \n        ('ImpersonationLevel', SECURITY_IMPERSONATION_LEVEL), \n        ('ContextTrackingMode', SECURITY_CONTEXT_TRACKING_MODE), \n        ('EffectiveOnly', UCHAR), \n    )",
  "class PSECURITY_QUALITY_OF_SERVICE(NDRPOINTER):\n    referent = (\n        ('Data', SECURITY_QUALITY_OF_SERVICE),\n    )",
  "class LSAPR_OBJECT_ATTRIBUTES(NDRSTRUCT):\n    structure = (\n        ('Length', DWORD), \n        ('RootDirectory', LPWSTR), \n        ('ObjectName', LPWSTR), \n        ('Attributes', DWORD), \n        ('SecurityDescriptor', PLSAPR_SECURITY_DESCRIPTOR), \n        ('SecurityQualityOfService', PSECURITY_QUALITY_OF_SERVICE), \n    )",
  "class LSAPR_SR_SECURITY_DESCRIPTOR(NDRSTRUCT):\n    structure = (\n        ('Length', DWORD), \n        ('SecurityDescriptor', LPBYTE), \n    )",
  "class PLSAPR_SR_SECURITY_DESCRIPTOR(NDRPOINTER):\n    referent = (\n        ('Data', LSAPR_SR_SECURITY_DESCRIPTOR),\n    )",
  "class POLICY_INFORMATION_CLASS(NDRENUM):\n    class enumItems(Enum):\n        PolicyAuditLogInformation           = 1\n        PolicyAuditEventsInformation        = 2\n        PolicyPrimaryDomainInformation      = 3\n        PolicyPdAccountInformation          = 4\n        PolicyAccountDomainInformation      = 5\n        PolicyLsaServerRoleInformation      = 6\n        PolicyReplicaSourceInformation      = 7\n        PolicyInformationNotUsedOnWire      = 8\n        PolicyModificationInformation       = 9\n        PolicyAuditFullSetInformation       = 10\n        PolicyAuditFullQueryInformation     = 11\n        PolicyDnsDomainInformation          = 12\n        PolicyDnsDomainInformationInt       = 13\n        PolicyLocalAccountDomainInformation = 14\n        PolicyLastEntry                     = 15",
  "class POLICY_AUDIT_LOG_INFO(NDRSTRUCT):\n    structure = (\n        ('AuditLogPercentFull', DWORD), \n        ('MaximumLogSize', DWORD), \n        ('AuditRetentionPeriod', LARGE_INTEGER), \n        ('AuditLogFullShutdownInProgress', UCHAR), \n        ('TimeToShutdown', LARGE_INTEGER), \n        ('NextAuditRecordId', DWORD), \n    )",
  "class DWORD_ARRAY(NDRUniConformantArray):\n    item = DWORD",
  "class PDWORD_ARRAY(NDRPOINTER):\n    referent = (\n        ('Data', DWORD_ARRAY),\n    )",
  "class LSAPR_POLICY_AUDIT_EVENTS_INFO(NDRSTRUCT):\n    structure = (\n        ('AuditingMode', UCHAR), \n        ('EventAuditingOptions', PDWORD_ARRAY), \n        ('MaximumAuditEventCount', DWORD), \n    )",
  "class LSAPR_POLICY_PRIMARY_DOM_INFO(NDRSTRUCT):\n    structure = (\n        ('Name', RPC_UNICODE_STRING), \n        ('Sid', PRPC_SID), \n    )",
  "class LSAPR_POLICY_ACCOUNT_DOM_INFO(NDRSTRUCT):\n    structure = (\n        ('DomainName', RPC_UNICODE_STRING), \n        ('DomainSid', PRPC_SID), \n    )",
  "class LSAPR_POLICY_PD_ACCOUNT_INFO(NDRSTRUCT):\n    structure = (\n        ('Name', RPC_UNICODE_STRING), \n    )",
  "class POLICY_LSA_SERVER_ROLE(NDRENUM):\n    class enumItems(Enum):\n        PolicyServerRoleBackup   = 2\n        PolicyServerRolePrimary  = 3",
  "class POLICY_LSA_SERVER_ROLE_INFO(NDRSTRUCT):\n    structure = (\n        ('LsaServerRole', POLICY_LSA_SERVER_ROLE), \n    )",
  "class LSAPR_POLICY_REPLICA_SRCE_INFO(NDRSTRUCT):\n    structure = (\n        ('ReplicaSource', RPC_UNICODE_STRING), \n        ('ReplicaAccountName', RPC_UNICODE_STRING), \n    )",
  "class POLICY_MODIFICATION_INFO(NDRSTRUCT):\n    structure = (\n        ('ModifiedId', LARGE_INTEGER), \n        ('DatabaseCreationTime', LARGE_INTEGER), \n    )",
  "class POLICY_AUDIT_FULL_SET_INFO(NDRSTRUCT):\n    structure = (\n        ('ShutDownOnFull', UCHAR), \n    )",
  "class POLICY_AUDIT_FULL_QUERY_INFO(NDRSTRUCT):\n    structure = (\n        ('ShutDownOnFull', UCHAR), \n        ('LogIsFull', UCHAR), \n    )",
  "class LSAPR_POLICY_DNS_DOMAIN_INFO(NDRSTRUCT):\n    structure = (\n        ('Name', RPC_UNICODE_STRING), \n        ('DnsDomainName', RPC_UNICODE_STRING), \n        ('DnsForestName', RPC_UNICODE_STRING), \n        ('DomainGuid', GUID), \n        ('Sid', PRPC_SID), \n    )",
  "class LSAPR_POLICY_INFORMATION(NDRUNION):\n    union = {\n        POLICY_INFORMATION_CLASS.PolicyAuditLogInformation          : ('PolicyAuditLogInfo', POLICY_AUDIT_LOG_INFO),\n        POLICY_INFORMATION_CLASS.PolicyAuditEventsInformation       : ('PolicyAuditEventsInfo', LSAPR_POLICY_AUDIT_EVENTS_INFO),\n        POLICY_INFORMATION_CLASS.PolicyPrimaryDomainInformation     : ('PolicyPrimaryDomainInfo', LSAPR_POLICY_PRIMARY_DOM_INFO),\n        POLICY_INFORMATION_CLASS.PolicyAccountDomainInformation     : ('PolicyAccountDomainInfo', LSAPR_POLICY_ACCOUNT_DOM_INFO),\n        POLICY_INFORMATION_CLASS.PolicyPdAccountInformation         : ('PolicyPdAccountInfo', LSAPR_POLICY_PD_ACCOUNT_INFO),\n        POLICY_INFORMATION_CLASS.PolicyLsaServerRoleInformation     : ('PolicyServerRoleInfo', POLICY_LSA_SERVER_ROLE_INFO),\n        POLICY_INFORMATION_CLASS.PolicyReplicaSourceInformation     : ('PolicyReplicaSourceInfo', LSAPR_POLICY_REPLICA_SRCE_INFO),\n        POLICY_INFORMATION_CLASS.PolicyModificationInformation      : ('PolicyModificationInfo', POLICY_MODIFICATION_INFO),\n        POLICY_INFORMATION_CLASS.PolicyAuditFullSetInformation      : ('PolicyAuditFullSetInfo', POLICY_AUDIT_FULL_SET_INFO),\n        POLICY_INFORMATION_CLASS.PolicyAuditFullQueryInformation    : ('PolicyAuditFullQueryInfo', POLICY_AUDIT_FULL_QUERY_INFO),\n        POLICY_INFORMATION_CLASS.PolicyDnsDomainInformation         : ('PolicyDnsDomainInfo', LSAPR_POLICY_DNS_DOMAIN_INFO),\n        POLICY_INFORMATION_CLASS.PolicyDnsDomainInformationInt      : ('PolicyDnsDomainInfoInt', LSAPR_POLICY_DNS_DOMAIN_INFO),\n        POLICY_INFORMATION_CLASS.PolicyLocalAccountDomainInformation: ('PolicyLocalAccountDomainInfo', LSAPR_POLICY_ACCOUNT_DOM_INFO),\n    }",
  "class PLSAPR_POLICY_INFORMATION(NDRPOINTER):\n    referent = (\n       ('Data', LSAPR_POLICY_INFORMATION),\n    )",
  "class POLICY_DOMAIN_INFORMATION_CLASS(NDRENUM):\n    class enumItems(Enum):\n        PolicyDomainQualityOfServiceInformation = 1\n        PolicyDomainEfsInformation              = 2\n        PolicyDomainKerberosTicketInformation   = 3",
  "class POLICY_DOMAIN_QUALITY_OF_SERVICE_INFO(NDRSTRUCT):\n    structure = (\n        ('QualityOfService', DWORD), \n    )",
  "class LSAPR_POLICY_DOMAIN_EFS_INFO(NDRSTRUCT):\n    structure = (\n        ('InfoLength', DWORD), \n        ('EfsBlob', LPBYTE), \n    )",
  "class POLICY_DOMAIN_KERBEROS_TICKET_INFO(NDRSTRUCT):\n    structure = (\n        ('AuthenticationOptions', DWORD), \n        ('MaxServiceTicketAge', LARGE_INTEGER), \n        ('MaxTicketAge', LARGE_INTEGER), \n        ('MaxRenewAge', LARGE_INTEGER), \n        ('MaxClockSkew', LARGE_INTEGER), \n        ('Reserved', LARGE_INTEGER), \n    )",
  "class LSAPR_POLICY_DOMAIN_INFORMATION(NDRUNION):\n    union = {\n        POLICY_DOMAIN_INFORMATION_CLASS.PolicyDomainQualityOfServiceInformation : ('PolicyDomainQualityOfServiceInfo', POLICY_DOMAIN_QUALITY_OF_SERVICE_INFO ),\n        POLICY_DOMAIN_INFORMATION_CLASS.PolicyDomainEfsInformation              : ('PolicyDomainEfsInfo', LSAPR_POLICY_DOMAIN_EFS_INFO),\n        POLICY_DOMAIN_INFORMATION_CLASS.PolicyDomainKerberosTicketInformation   : ('PolicyDomainKerbTicketInfo', POLICY_DOMAIN_KERBEROS_TICKET_INFO),\n    }",
  "class PLSAPR_POLICY_DOMAIN_INFORMATION(NDRPOINTER):\n    referent = (\n        ('Data', LSAPR_POLICY_DOMAIN_INFORMATION),\n    )",
  "class POLICY_AUDIT_EVENT_TYPE(NDRENUM):\n    class enumItems(Enum):\n        AuditCategorySystem                 = 0\n        AuditCategoryLogon                  = 1\n        AuditCategoryObjectAccess           = 2\n        AuditCategoryPrivilegeUse           = 3\n        AuditCategoryDetailedTracking       = 4\n        AuditCategoryPolicyChange           = 5\n        AuditCategoryAccountManagement      = 6\n        AuditCategoryDirectoryServiceAccess = 7\n        AuditCategoryAccountLogon           = 8",
  "class LSAPR_ACCOUNT_INFORMATION(NDRSTRUCT):\n    structure = (\n        ('Sid', PRPC_SID), \n    )",
  "class LSAPR_ACCOUNT_INFORMATION_ARRAY(NDRUniConformantArray):\n    item = LSAPR_ACCOUNT_INFORMATION",
  "class PLSAPR_ACCOUNT_INFORMATION_ARRAY(NDRPOINTER):\n    referent = (\n        ('Data', LSAPR_ACCOUNT_INFORMATION_ARRAY),\n    )",
  "class LSAPR_ACCOUNT_ENUM_BUFFER(NDRSTRUCT):\n    structure = (\n        ('EntriesRead', ULONG), \n        ('Information', PLSAPR_ACCOUNT_INFORMATION_ARRAY), \n    )",
  "class RPC_UNICODE_STRING_ARRAY(NDRUniConformantArray):\n    item = RPC_UNICODE_STRING",
  "class PRPC_UNICODE_STRING_ARRAY(NDRPOINTER):\n    referent = (\n        ('Data', RPC_UNICODE_STRING_ARRAY),\n    )",
  "class LSAPR_USER_RIGHT_SET(NDRSTRUCT):\n    structure = (\n        ('EntriesRead', ULONG), \n        ('UserRights', PRPC_UNICODE_STRING_ARRAY), \n    )",
  "class LSAPR_LUID_AND_ATTRIBUTES(NDRSTRUCT):\n    structure = (\n        ('Luid', LUID), \n        ('Attributes', ULONG), \n    )",
  "class LSAPR_LUID_AND_ATTRIBUTES_ARRAY(NDRUniConformantArray):\n    item = LSAPR_LUID_AND_ATTRIBUTES",
  "class LSAPR_PRIVILEGE_SET(NDRSTRUCT):\n    structure = (\n        ('PrivilegeCount', ULONG), \n        ('Control', ULONG), \n        ('Privilege', LSAPR_LUID_AND_ATTRIBUTES_ARRAY), \n    )",
  "class PLSAPR_PRIVILEGE_SET(NDRPOINTER):\n    referent = (\n        ('Data', LSAPR_PRIVILEGE_SET),\n    )",
  "class PCHAR_ARRAY(NDRPOINTER):\n    referent = (\n        ('Data', NDRUniConformantVaryingArray),\n    )",
  "class LSAPR_CR_CIPHER_VALUE(NDRSTRUCT):\n    structure = (\n        ('Length', LONG), \n        ('MaximumLength', LONG), \n        ('Buffer', PCHAR_ARRAY), \n    )",
  "class PLSAPR_CR_CIPHER_VALUE(NDRPOINTER):\n    referent = (\n        ('Data', LSAPR_CR_CIPHER_VALUE), \n    )",
  "class PPLSAPR_CR_CIPHER_VALUE(NDRPOINTER):\n    referent = (\n        ('Data', PLSAPR_CR_CIPHER_VALUE),\n    )",
  "class LSAPR_TRUST_INFORMATION(NDRSTRUCT):\n    structure = (\n        ('Name', RPC_UNICODE_STRING), \n        ('Sid', PRPC_SID), \n    )",
  "class TRUSTED_INFORMATION_CLASS(NDRENUM):\n    class enumItems(Enum):\n        TrustedDomainNameInformation          = 1\n        TrustedControllersInformation         = 2\n        TrustedPosixOffsetInformation         = 3\n        TrustedPasswordInformation            = 4\n        TrustedDomainInformationBasic         = 5\n        TrustedDomainInformationEx            = 6\n        TrustedDomainAuthInformation          = 7\n        TrustedDomainFullInformation          = 8\n        TrustedDomainAuthInformationInternal  = 9\n        TrustedDomainFullInformationInternal  = 10\n        TrustedDomainInformationEx2Internal   = 11\n        TrustedDomainFullInformation2Internal = 12\n        TrustedDomainSupportedEncryptionTypes = 13",
  "class LSAPR_TRUSTED_DOMAIN_NAME_INFO(NDRSTRUCT):\n    structure = (\n        ('Name', RPC_UNICODE_STRING), \n    )",
  "class LSAPR_TRUSTED_CONTROLLERS_INFO(NDRSTRUCT):\n    structure = (\n        ('Entries', ULONG), \n        ('Names', PRPC_UNICODE_STRING_ARRAY), \n    )",
  "class TRUSTED_POSIX_OFFSET_INFO(NDRSTRUCT):\n    structure = (\n        ('Offset', ULONG), \n    )",
  "class LSAPR_TRUSTED_PASSWORD_INFO(NDRSTRUCT):\n    structure = (\n        ('Password', PLSAPR_CR_CIPHER_VALUE), \n        ('OldPassword', PLSAPR_CR_CIPHER_VALUE), \n    )",
  "class LSAPR_TRUSTED_DOMAIN_INFORMATION_EX(NDRSTRUCT):\n    structure = (\n        ('Name', RPC_UNICODE_STRING), \n        ('FlatName', RPC_UNICODE_STRING), \n        ('Sid', PRPC_SID), \n        ('TrustDirection', ULONG), \n        ('TrustType', ULONG), \n        ('TrustAttributes', ULONG), \n    )",
  "class LSAPR_TRUSTED_DOMAIN_INFORMATION_EX2(NDRSTRUCT):\n    structure = (\n        ('Name', RPC_UNICODE_STRING), \n        ('FlatName', RPC_UNICODE_STRING), \n        ('Sid', PRPC_SID), \n        ('TrustDirection', ULONG), \n        ('TrustType', ULONG), \n        ('TrustAttributes', ULONG), \n        ('ForestTrustLength', ULONG), \n        ('ForestTrustInfo', LPBYTE), \n    )",
  "class LSAPR_AUTH_INFORMATION(NDRSTRUCT):\n    structure = (\n        ('LastUpdateTime', LARGE_INTEGER), \n        ('AuthType', ULONG), \n        ('AuthInfoLength', ULONG), \n        ('AuthInfo', LPBYTE), \n    )",
  "class PLSAPR_AUTH_INFORMATION(NDRPOINTER):\n    referent = (\n        ('Data', LSAPR_AUTH_INFORMATION),\n    )",
  "class LSAPR_TRUSTED_DOMAIN_AUTH_INFORMATION(NDRSTRUCT):\n    structure = (\n        ('IncomingAuthInfos', ULONG), \n        ('IncomingAuthenticationInformation', PLSAPR_AUTH_INFORMATION), \n        ('IncomingPreviousAuthenticationInformation', PLSAPR_AUTH_INFORMATION), \n        ('OutgoingAuthInfos', ULONG), \n        ('OutgoingAuthenticationInformation', PLSAPR_AUTH_INFORMATION), \n        ('OutgoingPreviousAuthenticationInformation', PLSAPR_AUTH_INFORMATION), \n    )",
  "class LSAPR_TRUSTED_DOMAIN_AUTH_BLOB(NDRSTRUCT):\n    structure = (\n        ('AuthSize', ULONG), \n        ('AuthBlob', LPBYTE), \n    )",
  "class LSAPR_TRUSTED_DOMAIN_AUTH_INFORMATION_INTERNAL(NDRSTRUCT):\n    structure = (\n        ('AuthBlob', LSAPR_TRUSTED_DOMAIN_AUTH_BLOB), \n    )",
  "class LSAPR_TRUSTED_DOMAIN_FULL_INFORMATION(NDRSTRUCT):\n    structure = (\n        ('Information', LSAPR_TRUSTED_DOMAIN_INFORMATION_EX), \n        ('PosixOffset', TRUSTED_POSIX_OFFSET_INFO), \n        ('AuthInformation', LSAPR_TRUSTED_DOMAIN_AUTH_INFORMATION), \n    )",
  "class LSAPR_TRUSTED_DOMAIN_FULL_INFORMATION_INTERNAL(NDRSTRUCT):\n    structure = (\n        ('Information', LSAPR_TRUSTED_DOMAIN_INFORMATION_EX), \n        ('PosixOffset', TRUSTED_POSIX_OFFSET_INFO), \n        ('AuthInformation', LSAPR_TRUSTED_DOMAIN_AUTH_INFORMATION_INTERNAL), \n    )",
  "class LSAPR_TRUSTED_DOMAIN_FULL_INFORMATION2(NDRSTRUCT):\n    structure = (\n        ('Information', LSAPR_TRUSTED_DOMAIN_INFORMATION_EX), \n        ('PosixOffset', TRUSTED_POSIX_OFFSET_INFO), \n        ('AuthInformation', LSAPR_TRUSTED_DOMAIN_AUTH_INFORMATION), \n    )",
  "class TRUSTED_DOMAIN_SUPPORTED_ENCRYPTION_TYPES(NDRSTRUCT):\n    structure = (\n        ('SupportedEncryptionTypes', ULONG), \n    )",
  "class LSAPR_TRUSTED_DOMAIN_INFO(NDRUNION):\n    union = {\n        TRUSTED_INFORMATION_CLASS.TrustedDomainNameInformation          : ('TrustedDomainNameInfo', LSAPR_TRUSTED_DOMAIN_NAME_INFO ),\n        TRUSTED_INFORMATION_CLASS.TrustedControllersInformation         : ('TrustedControllersInfo', LSAPR_TRUSTED_CONTROLLERS_INFO),\n        TRUSTED_INFORMATION_CLASS.TrustedPosixOffsetInformation         : ('TrustedPosixOffsetInfo', TRUSTED_POSIX_OFFSET_INFO),\n        TRUSTED_INFORMATION_CLASS.TrustedPasswordInformation            : ('TrustedPasswordInfo', LSAPR_TRUSTED_PASSWORD_INFO ),\n        TRUSTED_INFORMATION_CLASS.TrustedDomainInformationBasic         : ('TrustedDomainInfoBasic', LSAPR_TRUSTED_DOMAIN_INFORMATION_BASIC),\n        TRUSTED_INFORMATION_CLASS.TrustedDomainInformationEx            : ('TrustedDomainInfoEx', LSAPR_TRUSTED_DOMAIN_INFORMATION_EX),\n        TRUSTED_INFORMATION_CLASS.TrustedDomainAuthInformation          : ('TrustedAuthInfo', LSAPR_TRUSTED_DOMAIN_AUTH_INFORMATION),\n        TRUSTED_INFORMATION_CLASS.TrustedDomainFullInformation          : ('TrustedFullInfo', LSAPR_TRUSTED_DOMAIN_FULL_INFORMATION),\n        TRUSTED_INFORMATION_CLASS.TrustedDomainAuthInformationInternal  : ('TrustedAuthInfoInternal', LSAPR_TRUSTED_DOMAIN_AUTH_INFORMATION_INTERNAL),\n        TRUSTED_INFORMATION_CLASS.TrustedDomainFullInformationInternal  : ('TrustedFullInfoInternal', LSAPR_TRUSTED_DOMAIN_FULL_INFORMATION_INTERNAL),\n        TRUSTED_INFORMATION_CLASS.TrustedDomainInformationEx2Internal   : ('TrustedDomainInfoEx2', LSAPR_TRUSTED_DOMAIN_INFORMATION_EX2),\n        TRUSTED_INFORMATION_CLASS.TrustedDomainFullInformation2Internal : ('TrustedFullInfo2', LSAPR_TRUSTED_DOMAIN_FULL_INFORMATION2),\n        TRUSTED_INFORMATION_CLASS.TrustedDomainSupportedEncryptionTypes : ('TrustedDomainSETs', TRUSTED_DOMAIN_SUPPORTED_ENCRYPTION_TYPES),\n    }",
  "class LSAPR_TRUST_INFORMATION_ARRAY(NDRUniConformantArray):\n    item = LSAPR_TRUST_INFORMATION",
  "class PLSAPR_TRUST_INFORMATION_ARRAY(NDRPOINTER):\n    referent = (\n        ('Data', LSAPR_TRUST_INFORMATION_ARRAY),\n    )",
  "class LSAPR_TRUSTED_ENUM_BUFFER(NDRSTRUCT):\n    structure = (\n        ('Entries', ULONG), \n        ('Information', PLSAPR_TRUST_INFORMATION_ARRAY), \n    )",
  "class LSAPR_TRUSTED_DOMAIN_INFORMATION_EX_ARRAY(NDRUniConformantArray):\n    item = LSAPR_TRUSTED_DOMAIN_INFORMATION_EX",
  "class PLSAPR_TRUSTED_DOMAIN_INFORMATION_EX_ARRAY(NDRPOINTER):\n    referent = (\n        ('Data', LSAPR_TRUSTED_DOMAIN_INFORMATION_EX_ARRAY),\n    )",
  "class LSAPR_TRUSTED_ENUM_BUFFER_EX(NDRSTRUCT):\n    structure = (\n        ('Entries', ULONG), \n        ('EnumerationBuffer', PLSAPR_TRUSTED_DOMAIN_INFORMATION_EX_ARRAY), \n    )",
  "class LSA_FOREST_TRUST_RECORD_TYPE(NDRENUM):\n    class enumItems(Enum):\n        ForestTrustTopLevelName   = 0\n        ForestTrustTopLevelNameEx = 1\n        ForestTrustDomainInfo     = 2",
  "class LSA_FOREST_TRUST_DOMAIN_INFO(NDRSTRUCT):\n    structure = (\n        ('Sid', PRPC_SID), \n        ('DnsName', LSA_UNICODE_STRING), \n        ('NetbiosName', LSA_UNICODE_STRING), \n    )",
  "class LSA_FOREST_TRUST_DATA_UNION(NDRUNION):\n    union = {\n        LSA_FOREST_TRUST_RECORD_TYPE.ForestTrustTopLevelName   : ('TopLevelName', LSA_UNICODE_STRING ),\n        LSA_FOREST_TRUST_RECORD_TYPE.ForestTrustTopLevelNameEx : ('TopLevelName', LSA_UNICODE_STRING),\n        LSA_FOREST_TRUST_RECORD_TYPE.ForestTrustDomainInfo     : ('DomainInfo', LSA_FOREST_TRUST_DOMAIN_INFO),\n    }",
  "class LSA_FOREST_TRUST_RECORD(NDRSTRUCT):\n    structure = (\n        ('Flags', ULONG), \n        ('ForestTrustType', LSA_FOREST_TRUST_RECORD_TYPE), \n        ('Time', LARGE_INTEGER), \n        ('ForestTrustData', LSA_FOREST_TRUST_DATA_UNION), \n    )",
  "class PLSA_FOREST_TRUST_RECORD(NDRPOINTER):\n    referent = (\n        ('Data', LSA_FOREST_TRUST_RECORD),\n    )",
  "class LSA_FOREST_TRUST_BINARY_DATA(NDRSTRUCT):\n    structure = (\n        ('Length', ULONG), \n        ('Buffer', LPBYTE), \n    )",
  "class LSA_FOREST_TRUST_RECORD_ARRAY(NDRUniConformantArray):\n    item = PLSA_FOREST_TRUST_RECORD",
  "class PLSA_FOREST_TRUST_RECORD_ARRAY(NDRPOINTER):\n    referent = (\n        ('Data', LSA_FOREST_TRUST_RECORD_ARRAY),\n    )",
  "class LSA_FOREST_TRUST_INFORMATION(NDRSTRUCT):\n    structure = (\n        ('RecordCount', ULONG), \n        ('Entries', PLSA_FOREST_TRUST_RECORD_ARRAY), \n    )",
  "class PLSA_FOREST_TRUST_INFORMATION(NDRPOINTER):\n    referent = (\n        ('Data', LSA_FOREST_TRUST_INFORMATION),\n    )",
  "class LSA_FOREST_TRUST_COLLISION_RECORD_TYPE(NDRENUM):\n    class enumItems(Enum):\n        CollisionTdo   = 0\n        CollisionXref  = 1\n        CollisionOther = 2",
  "class LSA_FOREST_TRUST_COLLISION_RECORD(NDRSTRUCT):\n    structure = (\n        ('Index', ULONG), \n        ('Type', LSA_FOREST_TRUST_COLLISION_RECORD_TYPE), \n        ('Flags', ULONG), \n        ('Name', LSA_UNICODE_STRING), \n    )",
  "class LSAPR_POLICY_PRIVILEGE_DEF(NDRSTRUCT):\n    structure = (\n        ('Name', RPC_UNICODE_STRING), \n        ('LocalValue', LUID), \n    )",
  "class LSAPR_POLICY_PRIVILEGE_DEF_ARRAY(NDRUniConformantArray):\n    item = LSAPR_POLICY_PRIVILEGE_DEF",
  "class PLSAPR_POLICY_PRIVILEGE_DEF_ARRAY(NDRPOINTER):\n    referent = (\n        ('Data', LSAPR_POLICY_PRIVILEGE_DEF_ARRAY),\n    )",
  "class LSAPR_PRIVILEGE_ENUM_BUFFER(NDRSTRUCT):\n    structure = (\n        ('Entries', ULONG), \n        ('Privileges', PLSAPR_POLICY_PRIVILEGE_DEF_ARRAY), \n    )",
  "class LsarOpenPolicy2(NDRCALL):\n    opnum = 44\n    structure = (\n       ('SystemName', LPWSTR),\n       ('ObjectAttributes',LSAPR_OBJECT_ATTRIBUTES),\n       ('DesiredAccess',ACCESS_MASK),\n    )",
  "class LsarOpenPolicy2Response(NDRCALL):\n    structure = (\n       ('PolicyHandle',LSAPR_HANDLE),\n       ('ErrorCode', NTSTATUS),\n    )",
  "class LsarOpenPolicy(NDRCALL):\n    opnum = 6\n    structure = (\n       ('SystemName', LPWSTR),\n       ('ObjectAttributes',LSAPR_OBJECT_ATTRIBUTES),\n       ('DesiredAccess',ACCESS_MASK),\n    )",
  "class LsarOpenPolicyResponse(NDRCALL):\n    structure = (\n       ('PolicyHandle',LSAPR_HANDLE),\n       ('ErrorCode', NTSTATUS),\n    )",
  "class LsarQueryInformationPolicy2(NDRCALL):\n    opnum = 46\n    structure = (\n       ('PolicyHandle', LSAPR_HANDLE),\n       ('InformationClass',POLICY_INFORMATION_CLASS),\n    )",
  "class LsarQueryInformationPolicy2Response(NDRCALL):\n    structure = (\n       ('PolicyInformation',PLSAPR_POLICY_INFORMATION),\n       ('ErrorCode', NTSTATUS),\n    )",
  "class LsarQueryInformationPolicy(NDRCALL):\n    opnum = 7\n    structure = (\n       ('PolicyHandle', LSAPR_HANDLE),\n       ('InformationClass',POLICY_INFORMATION_CLASS),\n    )",
  "class LsarQueryInformationPolicyResponse(NDRCALL):\n    structure = (\n       ('PolicyInformation',PLSAPR_POLICY_INFORMATION),\n       ('ErrorCode', NTSTATUS),\n    )",
  "class LsarSetInformationPolicy2(NDRCALL):\n    opnum = 47\n    structure = (\n       ('PolicyHandle', LSAPR_HANDLE),\n       ('InformationClass',POLICY_INFORMATION_CLASS),\n       ('PolicyInformation',LSAPR_POLICY_INFORMATION),\n    )",
  "class LsarSetInformationPolicy2Response(NDRCALL):\n    structure = (\n       ('ErrorCode', NTSTATUS),\n    )",
  "class LsarSetInformationPolicy(NDRCALL):\n    opnum = 8\n    structure = (\n       ('PolicyHandle', LSAPR_HANDLE),\n       ('InformationClass',POLICY_INFORMATION_CLASS),\n       ('PolicyInformation',LSAPR_POLICY_INFORMATION),\n    )",
  "class LsarSetInformationPolicyResponse(NDRCALL):\n    structure = (\n       ('ErrorCode', NTSTATUS),\n    )",
  "class LsarQueryDomainInformationPolicy(NDRCALL):\n    opnum = 53\n    structure = (\n       ('PolicyHandle', LSAPR_HANDLE),\n       ('InformationClass',POLICY_DOMAIN_INFORMATION_CLASS),\n    )",
  "class LsarQueryDomainInformationPolicyResponse(NDRCALL):\n    structure = (\n       ('PolicyDomainInformation',PLSAPR_POLICY_DOMAIN_INFORMATION),\n       ('ErrorCode', NTSTATUS),\n    )",
  "class LsarCreateAccount(NDRCALL):\n    opnum = 10\n    structure = (\n       ('PolicyHandle', LSAPR_HANDLE),\n       ('AccountSid',RPC_SID),\n       ('DesiredAccess',ACCESS_MASK),\n    )",
  "class LsarCreateAccountResponse(NDRCALL):\n    structure = (\n       ('AccountHandle',LSAPR_HANDLE),\n       ('ErrorCode', NTSTATUS),\n    )",
  "class LsarEnumerateAccounts(NDRCALL):\n    opnum = 11\n    structure = (\n       ('PolicyHandle', LSAPR_HANDLE),\n       ('EnumerationContext',ULONG),\n       ('PreferedMaximumLength',ULONG),\n    )",
  "class LsarEnumerateAccountsResponse(NDRCALL):\n    structure = (\n       ('EnumerationContext',ULONG),\n       ('EnumerationBuffer',LSAPR_ACCOUNT_ENUM_BUFFER),\n       ('ErrorCode', NTSTATUS),\n    )",
  "class LsarOpenAccount(NDRCALL):\n    opnum = 17\n    structure = (\n       ('PolicyHandle', LSAPR_HANDLE),\n       ('AccountSid',RPC_SID),\n       ('DesiredAccess',ACCESS_MASK),\n    )",
  "class LsarOpenAccountResponse(NDRCALL):\n    structure = (\n       ('AccountHandle',LSAPR_HANDLE),\n       ('ErrorCode', NTSTATUS),\n    )",
  "class LsarEnumeratePrivilegesAccount(NDRCALL):\n    opnum = 18\n    structure = (\n       ('AccountHandle', LSAPR_HANDLE),\n    )",
  "class LsarEnumeratePrivilegesAccountResponse(NDRCALL):\n    structure = (\n       ('Privileges',PLSAPR_PRIVILEGE_SET),\n       ('ErrorCode', NTSTATUS),\n    )",
  "class LsarAddPrivilegesToAccount(NDRCALL):\n    opnum = 19\n    structure = (\n       ('AccountHandle', LSAPR_HANDLE),\n       ('Privileges', LSAPR_PRIVILEGE_SET),\n    )",
  "class LsarAddPrivilegesToAccountResponse(NDRCALL):\n    structure = (\n       ('ErrorCode', NTSTATUS),\n    )",
  "class LsarRemovePrivilegesFromAccount(NDRCALL):\n    opnum = 20\n    structure = (\n       ('AccountHandle', LSAPR_HANDLE),\n       ('AllPrivileges', UCHAR),\n       ('Privileges', PLSAPR_PRIVILEGE_SET),\n    )",
  "class LsarRemovePrivilegesFromAccountResponse(NDRCALL):\n    structure = (\n       ('ErrorCode', NTSTATUS),\n    )",
  "class LsarGetSystemAccessAccount(NDRCALL):\n    opnum = 23\n    structure = (\n       ('AccountHandle', LSAPR_HANDLE),\n    )",
  "class LsarGetSystemAccessAccountResponse(NDRCALL):\n    structure = (\n       ('SystemAccess', ULONG),\n       ('ErrorCode', NTSTATUS),\n    )",
  "class LsarSetSystemAccessAccount(NDRCALL):\n    opnum = 24\n    structure = (\n       ('AccountHandle', LSAPR_HANDLE),\n       ('SystemAccess', ULONG),\n    )",
  "class LsarSetSystemAccessAccountResponse(NDRCALL):\n    structure = (\n       ('ErrorCode', NTSTATUS),\n    )",
  "class LsarEnumerateAccountsWithUserRight(NDRCALL):\n    opnum = 35\n    structure = (\n       ('PolicyHandle', LSAPR_HANDLE),\n       ('UserRight', PRPC_UNICODE_STRING),\n    )",
  "class LsarEnumerateAccountsWithUserRightResponse(NDRCALL):\n    structure = (\n       ('EnumerationBuffer',LSAPR_ACCOUNT_ENUM_BUFFER),\n       ('ErrorCode', NTSTATUS),\n    )",
  "class LsarEnumerateAccountRights(NDRCALL):\n    opnum = 36\n    structure = (\n       ('PolicyHandle', LSAPR_HANDLE),\n       ('AccountSid', RPC_SID),\n    )",
  "class LsarEnumerateAccountRightsResponse(NDRCALL):\n    structure = (\n       ('UserRights',LSAPR_USER_RIGHT_SET),\n       ('ErrorCode', NTSTATUS),\n    )",
  "class LsarAddAccountRights(NDRCALL):\n    opnum = 37\n    structure = (\n       ('PolicyHandle', LSAPR_HANDLE),\n       ('AccountSid', RPC_SID),\n       ('UserRights',LSAPR_USER_RIGHT_SET),\n    )",
  "class LsarAddAccountRightsResponse(NDRCALL):\n    structure = (\n       ('ErrorCode', NTSTATUS),\n    )",
  "class LsarRemoveAccountRights(NDRCALL):\n    opnum = 38\n    structure = (\n       ('PolicyHandle', LSAPR_HANDLE),\n       ('AccountSid', RPC_SID),\n       ('AllRights', UCHAR),\n       ('UserRights',LSAPR_USER_RIGHT_SET),\n    )",
  "class LsarRemoveAccountRightsResponse(NDRCALL):\n    structure = (\n       ('ErrorCode', NTSTATUS),\n    )",
  "class LsarCreateSecret(NDRCALL):\n    opnum = 16\n    structure = (\n       ('PolicyHandle', LSAPR_HANDLE),\n       ('SecretName', RPC_UNICODE_STRING),\n       ('DesiredAccess', ACCESS_MASK),\n    )",
  "class LsarCreateSecretResponse(NDRCALL):\n    structure = (\n       ('SecretHandle', LSAPR_HANDLE),\n       ('ErrorCode', NTSTATUS),\n    )",
  "class LsarOpenSecret(NDRCALL):\n    opnum = 28\n    structure = (\n       ('PolicyHandle', LSAPR_HANDLE),\n       ('SecretName', RPC_UNICODE_STRING),\n       ('DesiredAccess', ACCESS_MASK),\n    )",
  "class LsarOpenSecretResponse(NDRCALL):\n    structure = (\n       ('SecretHandle', LSAPR_HANDLE),\n       ('ErrorCode', NTSTATUS),\n    )",
  "class LsarSetSecret(NDRCALL):\n    opnum = 29\n    structure = (\n       ('SecretHandle', LSAPR_HANDLE),\n       ('EncryptedCurrentValue', PLSAPR_CR_CIPHER_VALUE),\n       ('EncryptedOldValue', PLSAPR_CR_CIPHER_VALUE),\n    )",
  "class LsarSetSecretResponse(NDRCALL):\n    structure = (\n       ('ErrorCode', NTSTATUS),\n    )",
  "class LsarQuerySecret(NDRCALL):\n    opnum = 30\n    structure = (\n       ('SecretHandle', LSAPR_HANDLE),\n       ('EncryptedCurrentValue', PPLSAPR_CR_CIPHER_VALUE),\n       ('CurrentValueSetTime', PLARGE_INTEGER),\n       ('EncryptedOldValue', PPLSAPR_CR_CIPHER_VALUE),\n       ('OldValueSetTime', PLARGE_INTEGER),\n    )",
  "class LsarQuerySecretResponse(NDRCALL):\n    structure = (\n       ('EncryptedCurrentValue', PPLSAPR_CR_CIPHER_VALUE),\n       ('CurrentValueSetTime', PLARGE_INTEGER),\n       ('EncryptedOldValue', PPLSAPR_CR_CIPHER_VALUE),\n       ('OldValueSetTime', PLARGE_INTEGER),\n       ('ErrorCode', NTSTATUS),\n    )",
  "class LsarStorePrivateData(NDRCALL):\n    opnum = 42\n    structure = (\n       ('PolicyHandle', LSAPR_HANDLE),\n       ('KeyName', RPC_UNICODE_STRING),\n       ('EncryptedData', PLSAPR_CR_CIPHER_VALUE),\n    )",
  "class LsarStorePrivateDataResponse(NDRCALL):\n    structure = (\n       ('ErrorCode', NTSTATUS),\n    )",
  "class LsarRetrievePrivateData(NDRCALL):\n    opnum = 43\n    structure = (\n       ('PolicyHandle', LSAPR_HANDLE),\n       ('KeyName', RPC_UNICODE_STRING),\n       ('EncryptedData', PLSAPR_CR_CIPHER_VALUE),\n    )",
  "class LsarRetrievePrivateDataResponse(NDRCALL):\n    structure = (\n       ('EncryptedData', PLSAPR_CR_CIPHER_VALUE),\n       ('ErrorCode', NTSTATUS),\n    )",
  "class LsarEnumerateTrustedDomainsEx(NDRCALL):\n    opnum = 50\n    structure = (\n       ('PolicyHandle', LSAPR_HANDLE),\n       ('EnumerationContext', ULONG),\n       ('PreferedMaximumLength', ULONG),\n    )",
  "class LsarEnumerateTrustedDomainsExResponse(NDRCALL):\n    structure = (\n       ('EnumerationContext', ULONG),\n       ('EnumerationBuffer',LSAPR_TRUSTED_ENUM_BUFFER_EX),\n       ('ErrorCode', NTSTATUS),\n    )",
  "class LsarEnumerateTrustedDomains(NDRCALL):\n    opnum = 13\n    structure = (\n       ('PolicyHandle', LSAPR_HANDLE),\n       ('EnumerationContext', ULONG),\n       ('PreferedMaximumLength', ULONG),\n    )",
  "class LsarEnumerateTrustedDomainsResponse(NDRCALL):\n    structure = (\n       ('EnumerationContext', ULONG),\n       ('EnumerationBuffer',LSAPR_TRUSTED_ENUM_BUFFER),\n       ('ErrorCode', NTSTATUS),\n    )",
  "class LsarQueryForestTrustInformation(NDRCALL):\n    opnum = 73\n    structure = (\n       ('PolicyHandle', LSAPR_HANDLE),\n       ('TrustedDomainName', LSA_UNICODE_STRING),\n       ('HighestRecordType', LSA_FOREST_TRUST_RECORD_TYPE),\n    )",
  "class LsarQueryForestTrustInformationResponse(NDRCALL):\n    structure = (\n       ('ForestTrustInfo', PLSA_FOREST_TRUST_INFORMATION),\n       ('ErrorCode', NTSTATUS),\n    )",
  "class LsarEnumeratePrivileges(NDRCALL):\n    opnum = 2\n    structure = (\n       ('PolicyHandle', LSAPR_HANDLE),\n       ('EnumerationContext', ULONG),\n       ('PreferedMaximumLength', ULONG),\n    )",
  "class LsarEnumeratePrivilegesResponse(NDRCALL):\n    structure = (\n       ('EnumerationContext', ULONG),\n       ('EnumerationBuffer', LSAPR_PRIVILEGE_ENUM_BUFFER),\n       ('ErrorCode', NTSTATUS),\n    )",
  "class LsarLookupPrivilegeValue(NDRCALL):\n    opnum = 31\n    structure = (\n       ('PolicyHandle', LSAPR_HANDLE),\n       ('Name', RPC_UNICODE_STRING),\n    )",
  "class LsarLookupPrivilegeValueResponse(NDRCALL):\n    structure = (\n       ('Value', LUID),\n       ('ErrorCode', NTSTATUS),\n    )",
  "class LsarLookupPrivilegeName(NDRCALL):\n    opnum = 32\n    structure = (\n       ('PolicyHandle', LSAPR_HANDLE),\n       ('Value', LUID),\n    )",
  "class LsarLookupPrivilegeNameResponse(NDRCALL):\n    structure = (\n       ('Name', PRPC_UNICODE_STRING),\n       ('ErrorCode', NTSTATUS),\n    )",
  "class LsarLookupPrivilegeDisplayName(NDRCALL):\n    opnum = 33\n    structure = (\n       ('PolicyHandle', LSAPR_HANDLE),\n       ('Name', RPC_UNICODE_STRING),\n       ('ClientLanguage', USHORT),\n       ('ClientSystemDefaultLanguage', USHORT),\n    )",
  "class LsarLookupPrivilegeDisplayNameResponse(NDRCALL):\n    structure = (\n       ('Name', PRPC_UNICODE_STRING),\n       ('LanguageReturned', UCHAR),\n       ('ErrorCode', NTSTATUS),\n    )",
  "class LsarQuerySecurityObject(NDRCALL):\n    opnum = 3\n    structure = (\n       ('PolicyHandle', LSAPR_HANDLE),\n       ('SecurityInformation', SECURITY_INFORMATION),\n    )",
  "class LsarQuerySecurityObjectResponse(NDRCALL):\n    structure = (\n       ('SecurityDescriptor', PLSAPR_SR_SECURITY_DESCRIPTOR),\n       ('ErrorCode', NTSTATUS),\n    )",
  "class LsarSetSecurityObject(NDRCALL):\n    opnum = 4\n    structure = (\n       ('PolicyHandle', LSAPR_HANDLE),\n       ('SecurityInformation', SECURITY_INFORMATION),\n       ('SecurityDescriptor', LSAPR_SR_SECURITY_DESCRIPTOR),\n    )",
  "class LsarSetSecurityObjectResponse(NDRCALL):\n    structure = (\n       ('ErrorCode', NTSTATUS),\n    )",
  "class LsarDeleteObject(NDRCALL):\n    opnum = 34\n    structure = (\n       ('ObjectHandle', LSAPR_HANDLE),\n    )",
  "class LsarDeleteObjectResponse(NDRCALL):\n    structure = (\n       ('ObjectHandle', LSAPR_HANDLE),\n       ('ErrorCode', NTSTATUS),\n    )",
  "class LsarClose(NDRCALL):\n    opnum = 0\n    structure = (\n       ('ObjectHandle', LSAPR_HANDLE),\n    )",
  "class LsarCloseResponse(NDRCALL):\n    structure = (\n       ('ObjectHandle', LSAPR_HANDLE),\n       ('ErrorCode', NTSTATUS),\n    )",
  "def hLsarOpenPolicy2(dce, desiredAccess = MAXIMUM_ALLOWED):\n    request = LsarOpenPolicy2()\n    request['SystemName'] = NULL\n    request['ObjectAttributes']['RootDirectory'] = NULL\n    request['ObjectAttributes']['ObjectName'] = NULL\n    request['ObjectAttributes']['SecurityDescriptor'] = NULL\n    request['ObjectAttributes']['SecurityQualityOfService'] = NULL\n    request['DesiredAccess'] = desiredAccess\n    return dce.request(request)",
  "def hLsarOpenPolicy(dce, desiredAccess = MAXIMUM_ALLOWED):\n    request = LsarOpenPolicy()\n    request['SystemName'] = NULL\n    request['ObjectAttributes']['RootDirectory'] = NULL\n    request['ObjectAttributes']['ObjectName'] = NULL\n    request['ObjectAttributes']['SecurityDescriptor'] = NULL\n    request['ObjectAttributes']['SecurityQualityOfService'] = NULL\n    request['DesiredAccess'] = desiredAccess\n    return dce.request(request)",
  "def hLsarQueryInformationPolicy2(dce, policyHandle, informationClass):\n    request = LsarQueryInformationPolicy2()\n    request['PolicyHandle'] = policyHandle\n    request['InformationClass'] = informationClass\n    return dce.request(request)",
  "def hLsarQueryInformationPolicy(dce, policyHandle, informationClass):\n    request = LsarQueryInformationPolicy()\n    request['PolicyHandle'] = policyHandle\n    request['InformationClass'] = informationClass\n    return dce.request(request)",
  "def hLsarQueryDomainInformationPolicy(dce, policyHandle, informationClass):\n    request = LsarQueryInformationPolicy()\n    request['PolicyHandle'] = policyHandle\n    request['InformationClass'] = informationClass\n    return dce.request(request)",
  "def hLsarEnumerateAccounts(dce, policyHandle, preferedMaximumLength=0xffffffff):\n    request = LsarEnumerateAccounts()\n    request['PolicyHandle'] = policyHandle\n    request['PreferedMaximumLength'] = preferedMaximumLength\n    return dce.request(request)",
  "def hLsarEnumerateAccountsWithUserRight(dce, policyHandle, UserRight):\n    request = LsarEnumerateAccountsWithUserRight()\n    request['PolicyHandle'] = policyHandle\n    request['UserRight'] = UserRight\n    return dce.request(request)",
  "def hLsarEnumerateTrustedDomainsEx(dce, policyHandle, enumerationContext=0, preferedMaximumLength=0xffffffff):\n    request = LsarEnumerateTrustedDomainsEx()\n    request['PolicyHandle'] = policyHandle\n    request['EnumerationContext'] = enumerationContext\n    request['PreferedMaximumLength'] = preferedMaximumLength\n    return dce.request(request)",
  "def hLsarEnumerateTrustedDomains(dce, policyHandle, enumerationContext=0, preferedMaximumLength=0xffffffff):\n    request = LsarEnumerateTrustedDomains()\n    request['PolicyHandle'] = policyHandle\n    request['EnumerationContext'] = enumerationContext\n    request['PreferedMaximumLength'] = preferedMaximumLength\n    return dce.request(request)",
  "def hLsarOpenAccount(dce, policyHandle, accountSid, desiredAccess=MAXIMUM_ALLOWED):\n    request = LsarOpenAccount()\n    request['PolicyHandle'] = policyHandle\n    request['AccountSid'].fromCanonical(accountSid)\n    request['DesiredAccess'] = desiredAccess\n    return dce.request(request)",
  "def hLsarClose(dce, objectHandle):\n    request = LsarClose()\n    request['ObjectHandle'] = objectHandle\n    return dce.request(request)",
  "def hLsarCreateAccount(dce, policyHandle, accountSid, desiredAccess=MAXIMUM_ALLOWED):\n    request = LsarCreateAccount()\n    request['PolicyHandle'] = policyHandle\n    request['AccountSid'].fromCanonical(accountSid)\n    request['DesiredAccess'] = desiredAccess\n    return dce.request(request)",
  "def hLsarDeleteObject(dce, objectHandle):\n    request = LsarDeleteObject()\n    request['ObjectHandle'] = objectHandle\n    return dce.request(request)",
  "def hLsarEnumeratePrivilegesAccount(dce, accountHandle):\n    request = LsarEnumeratePrivilegesAccount()\n    request['AccountHandle'] = accountHandle\n    return dce.request(request)",
  "def hLsarGetSystemAccessAccount(dce, accountHandle):\n    request = LsarGetSystemAccessAccount()\n    request['AccountHandle'] = accountHandle\n    return dce.request(request)",
  "def hLsarSetSystemAccessAccount(dce, accountHandle, systemAccess):\n    request = LsarSetSystemAccessAccount()\n    request['AccountHandle'] = accountHandle\n    request['SystemAccess'] = systemAccess\n    return dce.request(request)",
  "def hLsarAddPrivilegesToAccount(dce, accountHandle, privileges):\n    request = LsarAddPrivilegesToAccount()\n    request['AccountHandle'] = accountHandle\n    request['Privileges']['PrivilegeCount'] = len(privileges)\n    request['Privileges']['Control'] = 0\n    for priv in privileges:\n        request['Privileges']['Privilege'].append(priv)\n\n    return dce.request(request)",
  "def hLsarRemovePrivilegesFromAccount(dce, accountHandle, privileges, allPrivileges = False):\n    request = LsarRemovePrivilegesFromAccount()\n    request['AccountHandle'] = accountHandle\n    request['Privileges']['Control'] = 0\n    if privileges != NULL:\n        request['Privileges']['PrivilegeCount'] = len(privileges)\n        for priv in privileges:\n            request['Privileges']['Privilege'].append(priv)\n    else:\n        request['Privileges']['PrivilegeCount'] = NULL\n    request['AllPrivileges'] = allPrivileges\n\n    return dce.request(request)",
  "def hLsarEnumerateAccountRights(dce, policyHandle, accountSid):\n    request = LsarEnumerateAccountRights()\n    request['PolicyHandle'] = policyHandle\n    request['AccountSid'].fromCanonical(accountSid)\n    return dce.request(request)",
  "def hLsarAddAccountRights(dce, policyHandle, accountSid, userRights):\n    request = LsarAddAccountRights()\n    request['PolicyHandle'] = policyHandle\n    request['AccountSid'].fromCanonical(accountSid)\n    request['UserRights']['EntriesRead'] = len(userRights)\n    for userRight in userRights:\n        right = RPC_UNICODE_STRING()\n        right['Data'] = userRight\n        request['UserRights']['UserRights'].append(right)\n\n    return dce.request(request)",
  "def hLsarRemoveAccountRights(dce, policyHandle, accountSid, userRights):\n    request = LsarRemoveAccountRights()\n    request['PolicyHandle'] = policyHandle\n    request['AccountSid'].fromCanonical(accountSid)\n    request['UserRights']['EntriesRead'] = len(userRights)\n    for userRight in userRights:\n        right = RPC_UNICODE_STRING()\n        right['Data'] = userRight\n        request['UserRights']['UserRights'].append(right)\n\n    return dce.request(request)",
  "def hLsarCreateSecret(dce, policyHandle, secretName, desiredAccess=MAXIMUM_ALLOWED):\n    request = LsarCreateSecret()\n    request['PolicyHandle'] = policyHandle\n    request['SecretName'] = secretName\n    request['DesiredAccess'] = desiredAccess\n    return dce.request(request)",
  "def hLsarOpenSecret(dce, policyHandle, secretName, desiredAccess=MAXIMUM_ALLOWED):\n    request = LsarOpenSecret()\n    request['PolicyHandle'] = policyHandle\n    request['SecretName'] = secretName\n    request['DesiredAccess'] = desiredAccess\n    return dce.request(request)",
  "def hLsarSetSecret(dce, secretHandle, encryptedCurrentValue, encryptedOldValue):\n    request = LsarOpenSecret()\n    request['SecretHandle'] = secretHandle\n    if encryptedCurrentValue != NULL:\n        request['EncryptedCurrentValue']['Length'] = len(encryptedCurrentValue)\n        request['EncryptedCurrentValue']['MaximumLength'] = len(encryptedCurrentValue)\n        request['EncryptedCurrentValue']['Buffer'] = list(encryptedCurrentValue)\n    if encryptedOldValue != NULL:\n        request['EncryptedOldValue']['Length'] = len(encryptedOldValue)\n        request['EncryptedOldValue']['MaximumLength'] = len(encryptedOldValue)\n        request['EncryptedOldValue']['Buffer'] = list(encryptedOldValue)\n    return dce.request(request)",
  "def hLsarQuerySecret(dce, secretHandle):\n    request = LsarQuerySecret()\n    request['SecretHandle'] = secretHandle\n    request['EncryptedCurrentValue']['Buffer'] = NULL\n    request['EncryptedOldValue']['Buffer'] = NULL\n    request['OldValueSetTime'] = NULL\n    return dce.request(request)",
  "def hLsarRetrievePrivateData(dce, policyHandle, keyName):\n    request = LsarRetrievePrivateData()\n    request['PolicyHandle'] = policyHandle\n    request['KeyName'] = keyName\n    retVal = dce.request(request)\n    return b''.join(retVal['EncryptedData']['Buffer'])",
  "def hLsarStorePrivateData(dce, policyHandle, keyName, encryptedData):\n    request = LsarStorePrivateData()\n    request['PolicyHandle'] = policyHandle\n    request['KeyName'] = keyName\n    if encryptedData != NULL:\n        request['EncryptedData']['Length'] = len(encryptedData)\n        request['EncryptedData']['MaximumLength'] = len(encryptedData)\n        request['EncryptedData']['Buffer'] = list(encryptedData)\n    else:\n        request['EncryptedData'] = NULL\n    return dce.request(request)",
  "def hLsarEnumeratePrivileges(dce, policyHandle, enumerationContext = 0, preferedMaximumLength = 0xffffffff):\n    request = LsarEnumeratePrivileges()\n    request['PolicyHandle'] = policyHandle\n    request['EnumerationContext'] = enumerationContext\n    request['PreferedMaximumLength'] = preferedMaximumLength\n    return dce.request(request)",
  "def hLsarLookupPrivilegeValue(dce, policyHandle, name):\n    request = LsarLookupPrivilegeValue()\n    request['PolicyHandle'] = policyHandle\n    request['Name'] = name\n    return dce.request(request)",
  "def hLsarLookupPrivilegeName(dce, policyHandle, luid):\n    request = LsarLookupPrivilegeName()\n    request['PolicyHandle'] = policyHandle\n    request['Value'] = luid\n    return dce.request(request)",
  "def hLsarQuerySecurityObject(dce, policyHandle, securityInformation = OWNER_SECURITY_INFORMATION):\n    request = LsarQuerySecurityObject()\n    request['PolicyHandle'] = policyHandle\n    request['SecurityInformation'] = securityInformation\n    retVal =  dce.request(request)\n    return b''.join(retVal['SecurityDescriptor']['SecurityDescriptor'])",
  "def hLsarSetSecurityObject(dce, policyHandle, securityInformation, securityDescriptor):\n    request = LsarSetSecurityObject()\n    request['PolicyHandle'] = policyHandle\n    request['SecurityInformation'] = securityInformation\n    request['SecurityDescriptor']['Length'] = len(securityDescriptor)\n    request['SecurityDescriptor']['SecurityDescriptor'] = list(securityDescriptor)\n    return dce.request(request)",
  "def hLsarSetInformationPolicy2(dce, policyHandle, informationClass, policyInformation):\n    request = LsarSetInformationPolicy2()\n    request['PolicyHandle'] = policyHandle\n    request['InformationClass'] = informationClass\n    request['PolicyInformation'] = policyInformation\n    return dce.request(request)",
  "def hLsarSetInformationPolicy(dce, policyHandle, informationClass, policyInformation):\n    request = LsarSetInformationPolicy()\n    request['PolicyHandle'] = policyHandle\n    request['InformationClass'] = informationClass\n    request['PolicyInformation'] = policyInformation\n    return dce.request(request)",
  "def __init__(self, error_string=None, error_code=None, packet=None):\n        DCERPCException.__init__(self, error_string, error_code, packet)",
  "def __str__( self ):\n        key = self.error_code\n        if key in nt_errors.ERROR_MESSAGES:\n            error_msg_short = nt_errors.ERROR_MESSAGES[key][0]\n            error_msg_verbose = nt_errors.ERROR_MESSAGES[key][1] \n            return 'LSAD SessionError: code: 0x%x - %s - %s' % (self.error_code, error_msg_short, error_msg_verbose)\n        else:\n            return 'LSAD SessionError: unknown error code: 0x%x' % self.error_code",
  "def dump(self, msg = None, indent = 0):\n        if msg is None:\n            msg = self.__class__.__name__\n        if msg != '':\n            print(\"%s\" % msg, end=' ')\n        # Here just print the data\n        print(\" %r\" % (self['Data']), end=' ')",
  "def __setitem__(self, key, value):\n        if key == 'Data':\n            self.fields['MaximumLength'] = None\n            self.fields['Length'] = None\n            self.data = None        # force recompute\n        return NDR.__setitem__(self, key, value)",
  "class enumItems(Enum):\n        SecurityAnonymous      = 0\n        SecurityIdentification = 1\n        SecurityImpersonation  = 2\n        SecurityDelegation     = 3",
  "class enumItems(Enum):\n        PolicyAuditLogInformation           = 1\n        PolicyAuditEventsInformation        = 2\n        PolicyPrimaryDomainInformation      = 3\n        PolicyPdAccountInformation          = 4\n        PolicyAccountDomainInformation      = 5\n        PolicyLsaServerRoleInformation      = 6\n        PolicyReplicaSourceInformation      = 7\n        PolicyInformationNotUsedOnWire      = 8\n        PolicyModificationInformation       = 9\n        PolicyAuditFullSetInformation       = 10\n        PolicyAuditFullQueryInformation     = 11\n        PolicyDnsDomainInformation          = 12\n        PolicyDnsDomainInformationInt       = 13\n        PolicyLocalAccountDomainInformation = 14\n        PolicyLastEntry                     = 15",
  "class enumItems(Enum):\n        PolicyServerRoleBackup   = 2\n        PolicyServerRolePrimary  = 3",
  "class enumItems(Enum):\n        PolicyDomainQualityOfServiceInformation = 1\n        PolicyDomainEfsInformation              = 2\n        PolicyDomainKerberosTicketInformation   = 3",
  "class enumItems(Enum):\n        AuditCategorySystem                 = 0\n        AuditCategoryLogon                  = 1\n        AuditCategoryObjectAccess           = 2\n        AuditCategoryPrivilegeUse           = 3\n        AuditCategoryDetailedTracking       = 4\n        AuditCategoryPolicyChange           = 5\n        AuditCategoryAccountManagement      = 6\n        AuditCategoryDirectoryServiceAccess = 7\n        AuditCategoryAccountLogon           = 8",
  "class enumItems(Enum):\n        TrustedDomainNameInformation          = 1\n        TrustedControllersInformation         = 2\n        TrustedPosixOffsetInformation         = 3\n        TrustedPasswordInformation            = 4\n        TrustedDomainInformationBasic         = 5\n        TrustedDomainInformationEx            = 6\n        TrustedDomainAuthInformation          = 7\n        TrustedDomainFullInformation          = 8\n        TrustedDomainAuthInformationInternal  = 9\n        TrustedDomainFullInformationInternal  = 10\n        TrustedDomainInformationEx2Internal   = 11\n        TrustedDomainFullInformation2Internal = 12\n        TrustedDomainSupportedEncryptionTypes = 13",
  "class enumItems(Enum):\n        ForestTrustTopLevelName   = 0\n        ForestTrustTopLevelNameEx = 1\n        ForestTrustDomainInfo     = 2",
  "class enumItems(Enum):\n        CollisionTdo   = 0\n        CollisionXref  = 1\n        CollisionOther = 2",
  "class DCERPCSessionError(DCERPCException):\n    ERROR_MESSAGES = {\n        ERROR_DHCP_JET_ERROR: (\"ERROR_DHCP_JET_ERROR\",\n                               \"An error occurred while accessing the DHCP server database.\"),\n        ERROR_DHCP_SUBNET_NOT_PRESENT: (\"ERROR_DHCP_SUBNET_NOT_PRESENT\",\n                                        \"The specified IPv4 subnet does not exist.\"),\n        ERROR_DHCP_SUBNET_EXISTS: (\"ERROR_DHCP_SUBNET_EXISTS\",\n                                   \"The IPv4 scope parameters are incorrect. Either the IPv4 scope already\"\n                                   \" exists, corresponding to the SubnetAddress and SubnetMask members of \"\n                                   \"the structure DHCP_SUBNET_INFO (section 2.2.1.2.8), or there is a \"\n                                   \"range overlap of IPv4 addresses between those associated with the \"\n                                   \"SubnetAddress and SubnetMask fields of the new IPv4 scope and the \"\n                                   \"subnet address and mask of an already existing IPv4 scope\"),\n        ERROR_DHCP_INVALID_DHCP_CLIENT: (\"ERROR_DHCP_INVALID_DHCP_CLIENT\",\n                                         \"The DHCP server received an invalid message from the client.\"),\n    }\n\n    def __init__(self, error_string=None, error_code=None, packet=None):\n        DCERPCException.__init__(self, error_string, error_code, packet)\n\n    def __str__(self):\n        key = self.error_code\n        if key in system_errors.ERROR_MESSAGES:\n            error_msg_short = system_errors.ERROR_MESSAGES[key][0]\n            error_msg_verbose = system_errors.ERROR_MESSAGES[key][1]\n            return 'DHCPM SessionError: code: 0x%x - %s - %s' % (self.error_code, error_msg_short, error_msg_verbose)\n        elif key in self.ERROR_MESSAGES:\n            error_msg_short = self.ERROR_MESSAGES[key][0]\n            error_msg_verbose = self.ERROR_MESSAGES[key][1]\n            return 'DHCPM SessionError: code: 0x%x - %s - %s' % (self.error_code, error_msg_short, error_msg_verbose)\n        else:\n            return 'DHCPM SessionError: unknown error code: 0x%x' % self.error_code",
  "class DHCP_SEARCH_INFO_TYPE(NDRENUM):\n    class enumItems(Enum):\n        DhcpClientIpAddress       = 0\n        DhcpClientHardwareAddress = 1\n        DhcpClientName            = 2",
  "class QuarantineStatus(NDRENUM):\n    class enumItems(Enum):\n        NOQUARANTINE        = 0\n        RESTRICTEDACCESS    = 1\n        DROPPACKET          = 2\n        PROBATION           = 3\n        EXEMPT              = 4\n        DEFAULTQUARSETTING  = 5\n        NOQUARINFO          = 6",
  "class DHCP_HOST_INFO(NDRSTRUCT):\n    structure = (\n        ('IpAddress', DHCP_IP_ADDRESS),\n        ('NetBiosName', LPWSTR),\n        ('HostName', LPWSTR),\n    )",
  "class BYTE_ARRAY(NDRUniConformantArray):\n    item = 'c'",
  "class PBYTE_ARRAY(NDRPOINTER):\n    referent = (\n        ('Data', BYTE_ARRAY),\n    )",
  "class DHCP_BINARY_DATA(NDRSTRUCT):\n    structure = (\n        ('DataLength', DWORD),\n        ('Data_', PBYTE_ARRAY),\n    )",
  "class DATE_TIME(NDRSTRUCT):\n    structure = (\n        ('dwLowDateTime', DWORD),\n        ('dwHighDateTime', DWORD),\n    )",
  "class DHCP_CLIENT_INFO_VQ(NDRSTRUCT):\n    structure = (\n        ('ClientIpAddress', DHCP_IP_ADDRESS),\n        ('SubnetMask', DHCP_IP_MASK),\n        ('ClientHardwareAddress', DHCP_CLIENT_UID),\n        ('ClientName', LPWSTR),\n        ('ClientComment', LPWSTR),\n        ('ClientLeaseExpires', DATE_TIME),\n        ('OwnerHost', DHCP_HOST_INFO),\n        ('bClientType', BYTE),\n        ('AddressState', BYTE),\n        ('Status', QuarantineStatus),\n        ('ProbationEnds', DATE_TIME),\n        ('QuarantineCapable', BOOL),\n    )",
  "class DHCP_CLIENT_SEARCH_UNION(NDRUNION):\n    union = {\n        DHCP_SEARCH_INFO_TYPE.DhcpClientIpAddress:       ('ClientIpAddress', DHCP_IP_ADDRESS),\n        DHCP_SEARCH_INFO_TYPE.DhcpClientHardwareAddress: ('ClientHardwareAddress', DHCP_CLIENT_UID),\n        DHCP_SEARCH_INFO_TYPE.DhcpClientName:            ('ClientName', LPWSTR),\n    }",
  "class DHCP_SEARCH_INFO(NDRSTRUCT):\n    structure = (\n        ('SearchType', DHCP_SEARCH_INFO_TYPE),\n        ('SearchInfo', DHCP_CLIENT_SEARCH_UNION),\n    )",
  "class DHCP_CLIENT_INFO_V4(NDRSTRUCT):\n    structure = (\n        ('ClientIpAddress', DHCP_IP_ADDRESS),\n        ('SubnetMask', DHCP_IP_MASK),\n        ('ClientHardwareAddress', DHCP_CLIENT_UID),\n        ('ClientName', LPWSTR),\n        ('ClientComment', LPWSTR),\n        ('ClientLeaseExpires', DATE_TIME),\n        ('OwnerHost', DHCP_HOST_INFO),\n        ('bClientType', BYTE),\n    )",
  "class DHCP_CLIENT_INFO_V5(NDRSTRUCT):\n    structure = (\n        ('ClientIpAddress', DHCP_IP_ADDRESS),\n        ('SubnetMask', DHCP_IP_MASK),\n        ('ClientHardwareAddress', DHCP_CLIENT_UID),\n        ('ClientName', LPWSTR),\n        ('ClientComment', LPWSTR),\n        ('ClientLeaseExpires', DATE_TIME),\n        ('OwnerHost', DHCP_HOST_INFO),\n        ('bClientType', BYTE),\n        ('AddressState', BYTE),\n    )",
  "class LPDHCP_CLIENT_INFO_V4(NDRPOINTER):\n    referent = (\n        ('Data', DHCP_CLIENT_INFO_V4),\n    )",
  "class LPDHCP_CLIENT_INFO_V5(NDRPOINTER):\n    referent = (\n        ('Data', DHCP_CLIENT_INFO_V5),\n    )",
  "class DHCP_CLIENT_INFO_PB(NDRSTRUCT):\n    structure = (\n        ('ClientIpAddress', DHCP_IP_ADDRESS),\n        ('SubnetMask', DHCP_IP_MASK),\n        ('ClientHardwareAddress', DHCP_CLIENT_UID),\n        ('ClientName', LPWSTR),\n        ('ClientComment', LPWSTR),\n        ('ClientLeaseExpires', DATE_TIME),\n        ('OwnerHost', DHCP_HOST_INFO),\n        ('bClientType', BYTE),\n        ('AddressState', BYTE),\n        ('Status', QuarantineStatus),\n        ('ProbationEnds', DATE_TIME),\n        ('QuarantineCapable', BOOL),\n        ('FilterStatus', DWORD),\n        ('PolicyName', LPWSTR),\n    )",
  "class LPDHCP_CLIENT_INFO_PB(NDRPOINTER):\n    referent = (\n        ('Data', DHCP_CLIENT_INFO_PB),\n    )",
  "class LPDHCP_CLIENT_INFO_VQ(NDRPOINTER):\n    referent = (\n        ('Data', DHCP_CLIENT_INFO_VQ),\n    )",
  "class DHCP_CLIENT_INFO_VQ_ARRAY(NDRUniConformantArray):\n    item = LPDHCP_CLIENT_INFO_VQ",
  "class LPDHCP_CLIENT_INFO_VQ_ARRAY(NDRPOINTER):\n    referent = (\n        ('Data', DHCP_CLIENT_INFO_VQ_ARRAY),\n    )",
  "class DHCP_CLIENT_INFO_ARRAY_VQ(NDRSTRUCT):\n    structure = (\n        ('NumElements', DWORD),\n        ('Clients', LPDHCP_CLIENT_INFO_VQ_ARRAY),\n    )",
  "class LPDHCP_CLIENT_INFO_ARRAY_VQ(NDRPOINTER):\n    referent = (\n        ('Data', DHCP_CLIENT_INFO_ARRAY_VQ),\n    )",
  "class DHCP_CLIENT_INFO_V4_ARRAY(NDRUniConformantArray):\n    item = LPDHCP_CLIENT_INFO_V4",
  "class DHCP_CLIENT_INFO_V5_ARRAY(NDRUniConformantArray):\n    item = LPDHCP_CLIENT_INFO_V5",
  "class LPDHCP_CLIENT_INFO_V4_ARRAY(NDRPOINTER):\n    referent = (\n        ('Data', DHCP_CLIENT_INFO_V4_ARRAY),\n    )",
  "class LPDHCP_CLIENT_INFO_V5_ARRAY(NDRPOINTER):\n    referent = (\n        ('Data', DHCP_CLIENT_INFO_V5_ARRAY),\n    )",
  "class DHCP_CLIENT_INFO_ARRAY_V4(NDRSTRUCT):\n    structure = (\n        ('NumElements', DWORD),\n        ('Clients', LPDHCP_CLIENT_INFO_V4_ARRAY),\n    )",
  "class DHCP_CLIENT_INFO_ARRAY_V5(NDRSTRUCT):\n    structure = (\n        ('NumElements', DWORD),\n        ('Clients', LPDHCP_CLIENT_INFO_V5_ARRAY),\n    )",
  "class LPDHCP_CLIENT_INFO_ARRAY_V5(NDRPOINTER):\n    referent = (\n        ('Data', DHCP_CLIENT_INFO_ARRAY_V5),\n    )",
  "class LPDHCP_CLIENT_INFO_ARRAY_V4(NDRPOINTER):\n    referent = (\n        ('Data', DHCP_CLIENT_INFO_ARRAY_V4),\n    )",
  "class DHCP_IP_ADDRESS_ARRAY(NDRUniConformantArray):\n    item = DHCP_IP_ADDRESS",
  "class LPDHCP_IP_ADDRESS_ARRAY(NDRPOINTER):\n    referent = (\n        ('Data', DHCP_IP_ADDRESS_ARRAY),\n    )",
  "class DHCP_IP_ARRAY(NDRSTRUCT):\n    structure = (\n        ('NumElements', DWORD),\n        ('Elements', LPDHCP_IP_ADDRESS_ARRAY),\n    )",
  "class DHCP_SUBNET_STATE(NDRENUM):\n    class enumItems(Enum):\n        DhcpSubnetEnabled           = 0\n        DhcpSubnetDisabled          = 1\n        DhcpSubnetEnabledSwitched   = 2\n        DhcpSubnetDisabledSwitched  = 3\n        DhcpSubnetInvalidState      = 4",
  "class DHCP_SUBNET_INFO(NDRSTRUCT):\n    structure = (\n        ('SubnetAddress', DHCP_IP_ADDRESS),\n        ('SubnetMask', DHCP_IP_MASK),\n        ('SubnetName', LPWSTR),\n        ('SubnetComment', LPWSTR),\n        ('PrimaryHost', DHCP_HOST_INFO),\n        ('SubnetState', DHCP_SUBNET_STATE),\n    )",
  "class LPDHCP_SUBNET_INFO(NDRPOINTER):\n    referent = (\n        ('Data', DHCP_SUBNET_INFO),\n    )",
  "class DHCP_OPTION_SCOPE_TYPE(NDRENUM):\n    class enumItems(Enum):\n        DhcpDefaultOptions  = 0\n        DhcpGlobalOptions   = 1\n        DhcpSubnetOptions   = 2\n        DhcpReservedOptions = 3\n        DhcpMScopeOptions   = 4",
  "class DHCP_RESERVED_SCOPE(NDRSTRUCT):\n    structure = (\n        ('ReservedIpAddress', DHCP_IP_ADDRESS),\n        ('ReservedIpSubnetAddress', DHCP_IP_ADDRESS),\n    )",
  "class DHCP_OPTION_SCOPE_UNION(NDRUNION):\n    union = {\n        DHCP_OPTION_SCOPE_TYPE.DhcpDefaultOptions   : (),\n        DHCP_OPTION_SCOPE_TYPE.DhcpGlobalOptions    : (),\n        DHCP_OPTION_SCOPE_TYPE.DhcpSubnetOptions    : ('SubnetScopeInfo', DHCP_IP_ADDRESS),\n        DHCP_OPTION_SCOPE_TYPE.DhcpReservedOptions  : ('ReservedScopeInfo', DHCP_RESERVED_SCOPE),\n        DHCP_OPTION_SCOPE_TYPE.DhcpMScopeOptions    : ('MScopeInfo', LPWSTR),\n    }",
  "class DHCP_OPTION_SCOPE_INFO(NDRSTRUCT):\n    structure = (\n        ('ScopeType', DHCP_OPTION_SCOPE_TYPE),\n        ('ScopeInfo', DHCP_OPTION_SCOPE_UNION),\n    )",
  "class LPDHCP_OPTION_SCOPE_INFO(NDRPOINTER):\n    referent = (\n        ('Data', DHCP_OPTION_SCOPE_INFO)\n    )",
  "class DWORD_DWORD(NDRSTRUCT):\n    structure = (\n        ('DWord1', DWORD),\n        ('DWord2', DWORD),\n    )",
  "class DHCP_BOOTP_IP_RANGE(NDRSTRUCT):\n    structure = (\n        ('StartAddress', DHCP_IP_ADDRESS),\n        ('EndAddress', DHCP_IP_ADDRESS),\n        ('BootpAllocated', ULONG),\n        ('MaxBootpAllowed', DHCP_IP_ADDRESS),\n        ('MaxBootpAllowed', ULONG ),\n    )",
  "class DHCP_IP_RESERVATION_V4(NDRSTRUCT):\n    structure = (\n        ('ReservedIpAddress', DHCP_IP_ADDRESS),\n        ('ReservedForClient', DHCP_CLIENT_UID),\n        ('bAllowedClientTypes', BYTE),\n    )",
  "class DHCP_IP_RANGE(NDRSTRUCT):\n    structure = (\n        ('StartAddress', DHCP_IP_ADDRESS),\n        ('EndAddress', DHCP_IP_ADDRESS),\n    )",
  "class DHCP_IP_CLUSTER(NDRSTRUCT):\n    structure = (\n        ('ClusterAddress', DHCP_IP_ADDRESS),\n        ('ClusterMask', DWORD),\n    )",
  "class DHCP_SUBNET_ELEMENT_TYPE(NDRENUM):\n    class enumItems(Enum):\n        DhcpIpRanges           = 0\n        DhcpSecondaryHosts     = 1\n        DhcpReservedIps        = 2\n        DhcpExcludedIpRanges   = 3\n        DhcpIpUsedClusters     = 4\n        DhcpIpRangesDhcpOnly   = 5\n        DhcpIpRangesDhcpBootp  = 6\n        DhcpIpRangesBootpOnly  = 7",
  "class DHCP_SUBNET_ELEMENT_UNION_V5(NDRUNION):\n    union = {\n        DHCP_SUBNET_ELEMENT_TYPE.DhcpIpRanges           : ('IpRange', DHCP_BOOTP_IP_RANGE),\n        DHCP_SUBNET_ELEMENT_TYPE.DhcpSecondaryHosts     : ('SecondaryHost', DHCP_HOST_INFO),\n        DHCP_SUBNET_ELEMENT_TYPE.DhcpReservedIps        : ('ReservedIp', DHCP_IP_RESERVATION_V4),\n        DHCP_SUBNET_ELEMENT_TYPE.DhcpExcludedIpRanges   : ('ExcludeIpRange', DHCP_IP_RANGE),\n        DHCP_SUBNET_ELEMENT_TYPE.DhcpIpUsedClusters     : ('IpUsedCluster', DHCP_IP_CLUSTER),\n    }",
  "class DHCP_SUBNET_ELEMENT_DATA_V5(NDRSTRUCT):\n    structure = (\n        ('ElementType', DHCP_SUBNET_ELEMENT_TYPE),\n        ('Element', DHCP_SUBNET_ELEMENT_UNION_V5),\n    )",
  "class LPDHCP_SUBNET_ELEMENT_DATA_V5(NDRUniConformantArray):\n    item = DHCP_SUBNET_ELEMENT_DATA_V5",
  "class DHCP_SUBNET_ELEMENT_INFO_ARRAY_V5(NDRSTRUCT):\n    structure = (\n        ('NumElements', DWORD),\n        ('Elements', LPDHCP_SUBNET_ELEMENT_DATA_V5),\n    )",
  "class LPDHCP_SUBNET_ELEMENT_INFO_ARRAY_V5(NDRPOINTER):\n    referent = (\n        ('Data', DHCP_SUBNET_ELEMENT_INFO_ARRAY_V5)\n    )",
  "class DHCP_OPTION_DATA_TYPE(NDRENUM):\n    class enumItems(Enum):\n        DhcpByteOption              = 0\n        DhcpWordOption              = 1\n        DhcpDWordOption             = 2\n        DhcpDWordDWordOption        = 3\n        DhcpIpAddressOption         = 4\n        DhcpStringDataOption        = 5\n        DhcpBinaryDataOption        = 6\n        DhcpEncapsulatedDataOption  = 7\n        DhcpIpv6AddressOption       = 8",
  "class DHCP_OPTION_ELEMENT_UNION(NDRUNION):\n    commonHdr = (\n        ('tag', DHCP_OPTION_DATA_TYPE),\n    )\n    union = {\n        DHCP_OPTION_DATA_TYPE.DhcpByteOption            : ('ByteOption', BYTE),\n        DHCP_OPTION_DATA_TYPE.DhcpWordOption            : ('WordOption', WORD),\n        DHCP_OPTION_DATA_TYPE.DhcpDWordOption           : ('DWordOption', DWORD),\n        DHCP_OPTION_DATA_TYPE.DhcpDWordDWordOption      : ('DWordDWordOption', DWORD_DWORD),\n        DHCP_OPTION_DATA_TYPE.DhcpIpAddressOption       : ('IpAddressOption', DHCP_IP_ADDRESS),\n        DHCP_OPTION_DATA_TYPE.DhcpStringDataOption      : ('StringDataOption', LPWSTR),\n        DHCP_OPTION_DATA_TYPE.DhcpBinaryDataOption      : ('BinaryDataOption', DHCP_BINARY_DATA),\n        DHCP_OPTION_DATA_TYPE.DhcpEncapsulatedDataOption: ('EncapsulatedDataOption', DHCP_BINARY_DATA),\n        DHCP_OPTION_DATA_TYPE.DhcpIpv6AddressOption     : ('Ipv6AddressDataOption', LPWSTR),\n    }",
  "class DHCP_OPTION_DATA_ELEMENT(NDRSTRUCT):\n    structure = (\n        ('OptionType', DHCP_OPTION_DATA_TYPE),\n        ('Element', DHCP_OPTION_ELEMENT_UNION),\n    )",
  "class DHCP_OPTION_DATA_ELEMENT_ARRAY2(NDRUniConformantArray):\n    item = DHCP_OPTION_DATA_ELEMENT",
  "class LPDHCP_OPTION_DATA_ELEMENT(NDRPOINTER):\n    referent = (\n        ('Data', DHCP_OPTION_DATA_ELEMENT_ARRAY2),\n    )",
  "class DHCP_OPTION_DATA(NDRSTRUCT):\n    structure = (\n        ('NumElements', DWORD),\n        ('Elements', LPDHCP_OPTION_DATA_ELEMENT),\n    )",
  "class DHCP_OPTION_VALUE(NDRSTRUCT):\n    structure = (\n        ('OptionID', DHCP_OPTION_ID),\n        ('Value', DHCP_OPTION_DATA),\n    )",
  "class PDHCP_OPTION_VALUE(NDRPOINTER):\n    referent = (\n        ('Data', DHCP_OPTION_VALUE),\n    )",
  "class DHCP_OPTION_VALUE_ARRAY2(NDRUniConformantArray):\n    item = DHCP_OPTION_VALUE",
  "class LPDHCP_OPTION_VALUE(NDRPOINTER):\n    referent = (\n        ('Data', DHCP_OPTION_VALUE_ARRAY2),\n    )",
  "class DHCP_OPTION_VALUE_ARRAY(NDRSTRUCT):\n    structure = (\n        ('NumElements', DWORD),\n        ('Values', LPDHCP_OPTION_VALUE),\n    )",
  "class LPDHCP_OPTION_VALUE_ARRAY(NDRPOINTER):\n    referent = (\n        ('Data', DHCP_OPTION_VALUE_ARRAY),\n    )",
  "class DHCP_ALL_OPTION_VALUES(NDRSTRUCT):\n    structure = (\n        ('ClassName', LPWSTR),\n        ('VendorName', LPWSTR),\n        ('IsVendor', BOOL),\n        ('OptionsArray', LPDHCP_OPTION_VALUE_ARRAY),\n    )",
  "class OPTION_VALUES_ARRAY(NDRUniConformantArray):\n    item = DHCP_ALL_OPTION_VALUES",
  "class LPOPTION_VALUES_ARRAY(NDRPOINTER):\n    referent = (\n        ('Data', OPTION_VALUES_ARRAY),\n    )",
  "class DHCP_ALL_OPTIONS_VALUES(NDRSTRUCT):\n    structure = (\n        ('Flags', DWORD),\n        ('NumElements', DWORD),\n        ('Options', LPOPTION_VALUES_ARRAY),\n    )",
  "class LPDHCP_ALL_OPTION_VALUES(NDRPOINTER):\n    referent = (\n        ('Data', DHCP_ALL_OPTIONS_VALUES),\n    )",
  "class DhcpGetSubnetInfo(NDRCALL):\n    opnum = 2\n    structure = (\n        ('ServerIpAddress', DHCP_SRV_HANDLE),\n        ('SubnetAddress', DHCP_IP_ADDRESS),\n    )",
  "class DhcpGetSubnetInfoResponse(NDRCALL):\n    structure = (\n        ('SubnetInfo', LPDHCP_SUBNET_INFO),\n        ('ErrorCode', ULONG),\n    )",
  "class DhcpEnumSubnets(NDRCALL):\n    opnum = 3\n    structure = (\n        ('ServerIpAddress', DHCP_SRV_HANDLE),\n        ('ResumeHandle', LPDWORD),\n        ('PreferredMaximum', DWORD),\n    )",
  "class DhcpEnumSubnetsResponse(NDRCALL):\n    structure = (\n        ('ResumeHandle', LPDWORD),\n        ('EnumInfo', DHCP_IP_ARRAY),\n        ('EnumRead', DWORD),\n        ('EnumTotal', DWORD),\n        ('ErrorCode', ULONG),\n    )",
  "class DhcpGetOptionValue(NDRCALL):\n    opnum = 13\n    structure = (\n        ('ServerIpAddress', DHCP_SRV_HANDLE),\n        ('OptionID', DHCP_OPTION_ID),\n        ('ScopeInfo', DHCP_OPTION_SCOPE_INFO),\n    )",
  "class DhcpGetOptionValueResponse(NDRCALL):\n    structure = (\n        ('OptionValue', PDHCP_OPTION_VALUE),\n        ('ErrorCode', ULONG),\n    )",
  "class DhcpEnumOptionValues(NDRCALL):\n    opnum = 14\n    structure = (\n        ('ServerIpAddress', DHCP_SRV_HANDLE),\n        ('ScopeInfo', DHCP_OPTION_SCOPE_INFO),\n        ('ResumeHandle', LPDWORD),\n        ('PreferredMaximum', DWORD),\n    )",
  "class DhcpEnumOptionValuesResponse(NDRCALL):\n    structure = (\n        ('ResumeHandle', DWORD),\n        ('OptionValues', LPDHCP_OPTION_VALUE_ARRAY),\n        ('OptionsRead', DWORD),\n        ('OptionsTotal', DWORD),\n        ('ErrorCode', ULONG),\n    )",
  "class DhcpGetClientInfoV4(NDRCALL):\n    opnum = 34\n    structure = (\n        ('ServerIpAddress', DHCP_SRV_HANDLE),\n        ('SearchInfo', DHCP_SEARCH_INFO),\n    )",
  "class DhcpGetClientInfoV4Response(NDRCALL):\n    structure = (\n        ('ClientInfo', LPDHCP_CLIENT_INFO_V4),\n        ('ErrorCode', ULONG),\n    )",
  "class DhcpEnumSubnetClientsV4(NDRCALL):\n    opnum = 35\n    structure = (\n        ('ServerIpAddress', DHCP_SRV_HANDLE),\n        ('SubnetAddress', DHCP_IP_ADDRESS),\n        ('ResumeHandle', DWORD),\n        ('PreferredMaximum', DWORD),\n    )",
  "class DhcpEnumSubnetClientsV4Response(NDRCALL):\n    structure = (\n        ('ResumeHandle', LPDWORD),\n        ('ClientInfo', LPDHCP_CLIENT_INFO_ARRAY_V4),\n        ('ClientsRead', DWORD),\n        ('ClientsTotal', DWORD),\n        ('ErrorCode', ULONG),\n    )",
  "class DhcpEnumSubnetClientsV5(NDRCALL):\n    opnum = 0\n    structure = (\n        ('ServerIpAddress', DHCP_SRV_HANDLE),\n        ('SubnetAddress', DHCP_IP_ADDRESS),\n        ('ResumeHandle', LPDWORD),\n        ('PreferredMaximum', DWORD),\n    )",
  "class DhcpEnumSubnetClientsV5Response(NDRCALL):\n    structure = (\n        ('ResumeHandle', DWORD),\n        ('ClientsInfo', LPDHCP_CLIENT_INFO_ARRAY_V5),\n        ('ClientsRead', DWORD),\n        ('ClientsTotal', DWORD),\n    )",
  "class DhcpGetOptionValueV5(NDRCALL):\n    opnum = 21\n    structure = (\n        ('ServerIpAddress', DHCP_SRV_HANDLE),\n        ('Flags', DWORD),\n        ('OptionID', DHCP_OPTION_ID),\n        ('ClassName', LPWSTR),\n        ('VendorName', LPWSTR),\n        ('ScopeInfo', DHCP_OPTION_SCOPE_INFO),\n    )",
  "class DhcpGetOptionValueV5Response(NDRCALL):\n    structure = (\n        ('OptionValue', PDHCP_OPTION_VALUE),\n        ('ErrorCode', ULONG),\n    )",
  "class DhcpEnumOptionValuesV5(NDRCALL):\n    opnum = 22\n    structure = (\n        ('ServerIpAddress', DHCP_SRV_HANDLE),\n        ('Flags', DWORD),\n        ('ClassName', LPWSTR),\n        ('VendorName', LPWSTR),\n        ('ScopeInfo', DHCP_OPTION_SCOPE_INFO),\n        ('ResumeHandle', LPDWORD),\n        ('PreferredMaximum', DWORD),\n    )",
  "class DhcpEnumOptionValuesV5Response(NDRCALL):\n    structure = (\n        ('ResumeHandle', DWORD),\n        ('OptionValues', LPDHCP_OPTION_VALUE_ARRAY),\n        ('OptionsRead', DWORD),\n        ('OptionsTotal', DWORD),\n        ('ErrorCode', ULONG),\n    )",
  "class DhcpGetAllOptionValues(NDRCALL):\n    opnum = 30\n    structure = (\n        ('ServerIpAddress', DHCP_SRV_HANDLE),\n        ('Flags', DWORD),\n        ('ScopeInfo', DHCP_OPTION_SCOPE_INFO),\n    )",
  "class DhcpGetAllOptionValuesResponse(NDRCALL):\n    structure = (\n        ('Values', LPDHCP_ALL_OPTION_VALUES),\n        ('ErrorCode', ULONG),\n    )",
  "class DhcpEnumSubnetElementsV5(NDRCALL):\n    opnum = 38\n    structure = (\n        ('ServerIpAddress', DHCP_SRV_HANDLE),\n        ('SubnetAddress', DHCP_IP_ADDRESS),\n        ('EnumElementType', DHCP_SUBNET_ELEMENT_TYPE),\n        ('ResumeHandle', LPDWORD),\n        ('PreferredMaximum', DWORD),\n    )",
  "class DhcpEnumSubnetElementsV5Response(NDRCALL):\n    structure = (\n        ('ResumeHandle', DWORD),\n        ('EnumElementInfo', LPDHCP_SUBNET_ELEMENT_INFO_ARRAY_V5),\n        ('ElementsRead', DWORD),\n        ('ElementsTotal', DWORD),\n        ('ErrorCode', ULONG),\n    )",
  "class DhcpEnumSubnetClientsVQ(NDRCALL):\n    opnum = 47\n    structure = (\n        ('ServerIpAddress', DHCP_SRV_HANDLE),\n        ('SubnetAddress', DHCP_IP_ADDRESS),\n        ('ResumeHandle', LPDWORD),\n        ('PreferredMaximum', DWORD),\n    )",
  "class DhcpEnumSubnetClientsVQResponse(NDRCALL):\n    structure = (\n        ('ResumeHandle', LPDWORD),\n        ('ClientInfo', LPDHCP_CLIENT_INFO_ARRAY_VQ),\n        ('ClientsRead', DWORD),\n        ('ClientsTotal', DWORD),\n        ('ErrorCode', ULONG),\n    )",
  "class DhcpV4GetClientInfo(NDRCALL):\n    opnum = 123\n    structure = (\n        ('ServerIpAddress', DHCP_SRV_HANDLE),\n        ('SearchInfo', DHCP_SEARCH_INFO),\n    )",
  "class DhcpV4GetClientInfoResponse(NDRCALL):\n    structure = (\n        ('ClientInfo', LPDHCP_CLIENT_INFO_PB),\n        ('ErrorCode', ULONG),\n    )",
  "def hDhcpGetClientInfoV4(dce, searchType, searchValue):\n    request = DhcpGetClientInfoV4()\n\n    request['ServerIpAddress'] = NULL\n    request['SearchInfo']['SearchType'] = searchType\n    request['SearchInfo']['SearchInfo']['tag'] = searchType\n    if searchType == DHCP_SEARCH_INFO_TYPE.DhcpClientIpAddress:\n        request['SearchInfo']['SearchInfo']['ClientIpAddress'] = searchValue\n    elif searchType == DHCP_SEARCH_INFO_TYPE.DhcpClientHardwareAddress:\n        # This should be a DHCP_BINARY_DATA\n        request['SearchInfo']['SearchInfo']['ClientHardwareAddress'] = searchValue\n    else:\n        request['SearchInfo']['SearchInfo']['ClientName'] = searchValue\n\n    return dce.request(request)",
  "def hDhcpGetSubnetInfo(dce, subnetaddress):\n    request = DhcpGetSubnetInfo()\n\n    request['ServerIpAddress'] = NULL\n    request['SubnetAddress'] = subnetaddress\n    resp = dce.request(request)\n\n    return resp",
  "def hDhcpGetOptionValue(dce, optionID, scopetype=DHCP_OPTION_SCOPE_TYPE.DhcpDefaultOptions, options=NULL):\n    request = DhcpGetOptionValue()\n\n    request['ServerIpAddress'] = NULL\n    request['OptionID'] = optionID\n    request['ScopeInfo']['ScopeType'] = scopetype\n    if scopetype != DHCP_OPTION_SCOPE_TYPE.DhcpDefaultOptions and scopetype != DHCP_OPTION_SCOPE_TYPE.DhcpGlobalOptions:\n        request['ScopeInfo']['ScopeInfo']['tag'] = scopetype\n    if scopetype == DHCP_OPTION_SCOPE_TYPE.DhcpSubnetOptions:\n        request['ScopeInfo']['ScopeInfo']['SubnetScopeInfo'] = options\n    elif scopetype == DHCP_OPTION_SCOPE_TYPE.DhcpReservedOptions:\n        request['ScopeInfo']['ScopeInfo']['ReservedScopeInfo'] = options\n    elif scopetype == DHCP_OPTION_SCOPE_TYPE.DhcpMScopeOptions:\n        request['ScopeInfo']['ScopeInfo']['MScopeInfo'] = options\n\n    status = system_errors.ERROR_MORE_DATA\n    while status == system_errors.ERROR_MORE_DATA:\n        try:\n            resp = dce.request(request)\n        except DCERPCException as e:\n            if str(e).find('ERROR_NO_MORE_ITEMS') < 0:\n                raise\n            resp = e.get_packet()\n        return resp",
  "def hDhcpEnumOptionValues(dce, scopetype=DHCP_OPTION_SCOPE_TYPE.DhcpDefaultOptions, options=NULL,\n                          preferredMaximum=0xffffffff):\n    request = DhcpEnumOptionValues()\n\n    request['ServerIpAddress'] = NULL\n    request['ScopeInfo']['ScopeType'] = scopetype\n    if scopetype != DHCP_OPTION_SCOPE_TYPE.DhcpDefaultOptions and scopetype != DHCP_OPTION_SCOPE_TYPE.DhcpGlobalOptions:\n        request['ScopeInfo']['ScopeInfo']['tag'] = scopetype\n    if scopetype == DHCP_OPTION_SCOPE_TYPE.DhcpSubnetOptions:\n        request['ScopeInfo']['ScopeInfo']['SubnetScopeInfo'] = options\n    elif scopetype == DHCP_OPTION_SCOPE_TYPE.DhcpReservedOptions:\n        request['ScopeInfo']['ScopeInfo']['ReservedScopeInfo'] = options\n    elif scopetype == DHCP_OPTION_SCOPE_TYPE.DhcpMScopeOptions:\n        request['ScopeInfo']['ScopeInfo']['MScopeInfo'] = options\n    request['ResumeHandle'] = NULL\n    request['PreferredMaximum'] = preferredMaximum\n\n    status = system_errors.ERROR_MORE_DATA\n    while status == system_errors.ERROR_MORE_DATA:\n        try:\n            resp = dce.request(request)\n        except DCERPCException as e:\n            if str(e).find('ERROR_NO_MORE_ITEMS') < 0:\n                raise\n            resp = e.get_packet()\n        return resp",
  "def hDhcpEnumOptionValuesV5(dce, flags=DHCP_FLAGS_OPTION_DEFAULT, classname=NULL, vendorname=NULL,\n                            scopetype=DHCP_OPTION_SCOPE_TYPE.DhcpDefaultOptions, options=NULL,\n                            preferredMaximum=0xffffffff):\n    request = DhcpEnumOptionValuesV5()\n\n    request['ServerIpAddress'] = NULL\n    request['Flags'] = flags\n    request['ClassName'] = classname\n    request['VendorName'] = vendorname\n    request['ScopeInfo']['ScopeType'] = scopetype\n    request['ScopeInfo']['ScopeInfo']['tag'] = scopetype\n    if scopetype == DHCP_OPTION_SCOPE_TYPE.DhcpSubnetOptions:\n        request['ScopeInfo']['ScopeInfo']['SubnetScopeInfo'] = options\n    elif scopetype == DHCP_OPTION_SCOPE_TYPE.DhcpReservedOptions:\n        request['ScopeInfo']['ScopeInfo']['ReservedScopeInfo'] = options\n    elif scopetype == DHCP_OPTION_SCOPE_TYPE.DhcpMScopeOptions:\n        request['ScopeInfo']['ScopeInfo']['MScopeInfo'] = options\n    request['ResumeHandle'] = NULL\n    request['PreferredMaximum'] = preferredMaximum\n\n    status = system_errors.ERROR_MORE_DATA\n    while status == system_errors.ERROR_MORE_DATA:\n        try:\n            resp = dce.request(request)\n        except DCERPCException as e:\n            if str(e).find('ERROR_NO_MORE_ITEMS') < 0:\n                raise\n            resp = e.get_packet()\n        return resp",
  "def hDhcpGetOptionValueV5(dce, option_id, flags=DHCP_FLAGS_OPTION_DEFAULT, classname=NULL, vendorname=NULL,\n                            scopetype=DHCP_OPTION_SCOPE_TYPE.DhcpDefaultOptions, options=NULL):\n    request = DhcpGetOptionValueV5()\n\n    request['ServerIpAddress'] = NULL\n    request['Flags'] = flags\n    request['OptionID'] = option_id\n    request['ClassName'] = classname\n    request['VendorName'] = vendorname\n    request['ScopeInfo']['ScopeType'] = scopetype\n    request['ScopeInfo']['ScopeInfo']['tag'] = scopetype\n    if scopetype == DHCP_OPTION_SCOPE_TYPE.DhcpSubnetOptions:\n        request['ScopeInfo']['ScopeInfo']['SubnetScopeInfo'] = options\n    elif scopetype == DHCP_OPTION_SCOPE_TYPE.DhcpReservedOptions:\n        request['ScopeInfo']['ScopeInfo']['ReservedScopeInfo'] = options\n    elif scopetype == DHCP_OPTION_SCOPE_TYPE.DhcpMScopeOptions:\n        request['ScopeInfo']['ScopeInfo']['MScopeInfo'] = options\n\n    status = system_errors.ERROR_MORE_DATA\n    while status == system_errors.ERROR_MORE_DATA:\n        try:\n            resp = dce.request(request)\n        except DCERPCException as e:\n            if str(e).find('ERROR_NO_MORE_ITEMS') < 0:\n                raise\n            resp = e.get_packet()\n        return resp",
  "def hDhcpGetAllOptionValues(dce, scopetype=DHCP_OPTION_SCOPE_TYPE.DhcpDefaultOptions, options=NULL):\n    request = DhcpGetAllOptionValues()\n\n    request['ServerIpAddress'] = NULL\n    request['Flags'] = NULL\n    request['ScopeInfo']['ScopeType'] = scopetype\n    request['ScopeInfo']['ScopeInfo']['tag'] = scopetype\n    if scopetype == DHCP_OPTION_SCOPE_TYPE.DhcpSubnetOptions:\n        request['ScopeInfo']['ScopeInfo']['SubnetScopeInfo'] = options\n    elif scopetype == DHCP_OPTION_SCOPE_TYPE.DhcpReservedOptions:\n        request['ScopeInfo']['ScopeInfo']['ReservedScopeInfo'] = options\n    elif scopetype == DHCP_OPTION_SCOPE_TYPE.DhcpMScopeOptions:\n        request['ScopeInfo']['ScopeInfo']['MScopeInfo'] = options\n\n    status = system_errors.ERROR_MORE_DATA\n    while status == system_errors.ERROR_MORE_DATA:\n        try:\n            resp = dce.request(request)\n        except DCERPCException as e:\n            if str(e).find('ERROR_NO_MORE_ITEMS') < 0:\n                raise\n            resp = e.get_packet()\n        return resp",
  "def hDhcpEnumSubnets(dce, preferredMaximum=0xffffffff):\n    request = DhcpEnumSubnets()\n\n    request['ServerIpAddress'] = NULL\n    request['ResumeHandle'] = NULL\n    request['PreferredMaximum'] = preferredMaximum\n    status = system_errors.ERROR_MORE_DATA\n    while status == system_errors.ERROR_MORE_DATA:\n        try:\n            resp = dce.request(request)\n        except DCERPCException as e:\n            if str(e).find('STATUS_MORE_ENTRIES') < 0:\n                raise\n            resp = e.get_packet()\n        return resp",
  "def hDhcpEnumSubnetClientsVQ(dce, preferredMaximum=0xffffffff):\n    request = DhcpEnumSubnetClientsVQ()\n\n    request['ServerIpAddress'] = NULL\n    request['SubnetAddress'] = NULL\n    request['ResumeHandle'] = NULL\n    request['PreferredMaximum'] = preferredMaximum\n    status = system_errors.ERROR_MORE_DATA\n    while status == system_errors.ERROR_MORE_DATA:\n        try:\n            resp = dce.request(request)\n        except DCERPCException as e:\n            if str(e).find('STATUS_MORE_ENTRIES') < 0:\n                raise\n            resp = e.get_packet()\n        return resp",
  "def hDhcpEnumSubnetClientsV4(dce, preferredMaximum=0xffffffff):\n    request = DhcpEnumSubnetClientsV4()\n\n    request['ServerIpAddress'] = NULL\n    request['SubnetAddress'] = NULL\n    request['ResumeHandle'] = NULL\n    request['PreferredMaximum'] = preferredMaximum\n    status = system_errors.ERROR_MORE_DATA\n    while status == system_errors.ERROR_MORE_DATA:\n        try:\n            resp = dce.request(request)\n        except DCERPCException as e:\n            if str(e).find('STATUS_MORE_ENTRIES') < 0:\n                raise\n            resp = e.get_packet()\n        return resp",
  "def hDhcpEnumSubnetClientsV5(dce, subnetAddress=0, preferredMaximum=0xffffffff):\n    request = DhcpEnumSubnetClientsV5()\n\n    request['ServerIpAddress'] = NULL\n    request['SubnetAddress'] = subnetAddress\n    request['ResumeHandle'] = NULL\n    request['PreferredMaximum'] = preferredMaximum\n    status = system_errors.ERROR_MORE_DATA\n    while status == system_errors.ERROR_MORE_DATA:\n        try:\n            resp = dce.request(request)\n        except DCERPCSessionError as e:\n            if str(e).find('STATUS_MORE_ENTRIES') < 0:\n                raise\n            resp = e.get_packet()\n        return resp",
  "def hDhcpEnumSubnetElementsV5(dce, subnet_address, element_type=DHCP_SUBNET_ELEMENT_TYPE.DhcpIpRanges, preferredMaximum=0xffffffff):\n    request = DhcpEnumSubnetElementsV5()\n\n    request['ServerIpAddress'] = NULL\n    request['SubnetAddress'] = subnet_address\n    request['EnumElementType'] = element_type\n    request['ResumeHandle'] = NULL\n    request['PreferredMaximum'] = preferredMaximum\n\n    status = system_errors.ERROR_MORE_DATA\n    while status == system_errors.ERROR_MORE_DATA:\n        try:\n            resp = dce.request(request)\n        except DCERPCException as e:\n            if str(e).find('ERROR_NO_MORE_ITEMS') < 0:\n                raise\n            resp = e.get_packet()\n        return resp",
  "def __init__(self, error_string=None, error_code=None, packet=None):\n        DCERPCException.__init__(self, error_string, error_code, packet)",
  "def __str__(self):\n        key = self.error_code\n        if key in system_errors.ERROR_MESSAGES:\n            error_msg_short = system_errors.ERROR_MESSAGES[key][0]\n            error_msg_verbose = system_errors.ERROR_MESSAGES[key][1]\n            return 'DHCPM SessionError: code: 0x%x - %s - %s' % (self.error_code, error_msg_short, error_msg_verbose)\n        elif key in self.ERROR_MESSAGES:\n            error_msg_short = self.ERROR_MESSAGES[key][0]\n            error_msg_verbose = self.ERROR_MESSAGES[key][1]\n            return 'DHCPM SessionError: code: 0x%x - %s - %s' % (self.error_code, error_msg_short, error_msg_verbose)\n        else:\n            return 'DHCPM SessionError: unknown error code: 0x%x' % self.error_code",
  "class enumItems(Enum):\n        DhcpClientIpAddress       = 0\n        DhcpClientHardwareAddress = 1\n        DhcpClientName            = 2",
  "class enumItems(Enum):\n        NOQUARANTINE        = 0\n        RESTRICTEDACCESS    = 1\n        DROPPACKET          = 2\n        PROBATION           = 3\n        EXEMPT              = 4\n        DEFAULTQUARSETTING  = 5\n        NOQUARINFO          = 6",
  "class enumItems(Enum):\n        DhcpSubnetEnabled           = 0\n        DhcpSubnetDisabled          = 1\n        DhcpSubnetEnabledSwitched   = 2\n        DhcpSubnetDisabledSwitched  = 3\n        DhcpSubnetInvalidState      = 4",
  "class enumItems(Enum):\n        DhcpDefaultOptions  = 0\n        DhcpGlobalOptions   = 1\n        DhcpSubnetOptions   = 2\n        DhcpReservedOptions = 3\n        DhcpMScopeOptions   = 4",
  "class enumItems(Enum):\n        DhcpIpRanges           = 0\n        DhcpSecondaryHosts     = 1\n        DhcpReservedIps        = 2\n        DhcpExcludedIpRanges   = 3\n        DhcpIpUsedClusters     = 4\n        DhcpIpRangesDhcpOnly   = 5\n        DhcpIpRangesDhcpBootp  = 6\n        DhcpIpRangesBootpOnly  = 7",
  "class enumItems(Enum):\n        DhcpByteOption              = 0\n        DhcpWordOption              = 1\n        DhcpDWordOption             = 2\n        DhcpDWordDWordOption        = 3\n        DhcpIpAddressOption         = 4\n        DhcpStringDataOption        = 5\n        DhcpBinaryDataOption        = 6\n        DhcpEncapsulatedDataOption  = 7\n        DhcpIpv6AddressOption       = 8",
  "class DCERPCSessionError(DCERPCException):\n    def __init__(self, error_string=None, error_code=None, packet=None):\n        DCERPCException.__init__(self, error_string, error_code, packet)\n\n    def __str__( self ):\n        key = self.error_code\n        if key in mapi_constants.ERROR_MESSAGES:\n            error_msg_short = mapi_constants.ERROR_MESSAGES[key]\n            return 'OXABREF SessionError: code: 0x%x - %s' % (self.error_code, error_msg_short)\n        elif key in hresult_errors.ERROR_MESSAGES:\n            error_msg_short = hresult_errors.ERROR_MESSAGES[key][0]\n            error_msg_verbose = hresult_errors.ERROR_MESSAGES[key][1]\n            return 'OXABREF SessionError: code: 0x%x - %s - %s' % (self.error_code, error_msg_short, error_msg_verbose)\n        else:\n            return 'OXABREF SessionError: unknown error code: 0x%x' % self.error_code",
  "class PUCHAR_ARRAY(NDRPOINTER):\n    referent = (\n        ('Data', STR),\n    )",
  "class PPUCHAR_ARRAY(NDRPOINTER):\n    referent = (\n        ('Data', PUCHAR_ARRAY),\n    )",
  "class RfrGetNewDSA(NDRCALL):\n    opnum = 0\n    structure = (\n       ('ulFlags', ULONG),\n       ('pUserDN', STR),\n       ('ppszUnused', PPUCHAR_ARRAY),\n       ('ppszServer', PPUCHAR_ARRAY),\n    )",
  "class RfrGetNewDSAResponse(NDRCALL):\n    structure = (\n       ('ppszUnused', PPUCHAR_ARRAY),\n       ('ppszServer', PPUCHAR_ARRAY),\n    )",
  "class RfrGetFQDNFromServerDN(NDRCALL):\n    opnum = 1\n    structure = (\n       ('ulFlags', ULONG),\n       ('cbMailboxServerDN', ULONG),\n       ('szMailboxServerDN', STR),\n    )",
  "class RfrGetFQDNFromServerDNResponse(NDRCALL):\n    structure = (\n       ('ppszServerFQDN', PUCHAR_ARRAY),\n       ('ErrorCode', ULONG),\n    )",
  "def checkNullString(string):\n    if string == NULL:\n        return string\n\n    if string[-1:] != '\\x00':\n        return string + '\\x00'\n    else:\n        return string",
  "def hRfrGetNewDSA(dce, pUserDN=''):\n    request = RfrGetNewDSA()\n    request['ulFlags'] = 0\n    request['pUserDN'] = checkNullString(pUserDN)\n    request['ppszUnused'] = NULL\n    request['ppszServer'] = '\\x00'\n\n    resp = dce.request(request)\n    resp['ppszServer'] = resp['ppszServer'][:-1]\n\n    if request['ppszUnused'] != NULL:\n        resp['ppszUnused'] = resp['ppszUnused'][:-1]\n\n    return resp",
  "def hRfrGetFQDNFromServerDN(dce, szMailboxServerDN):\n    szMailboxServerDN = checkNullString(szMailboxServerDN)\n    request = RfrGetFQDNFromServerDN()\n    request['ulFlags'] = 0\n    request['szMailboxServerDN'] = szMailboxServerDN\n    request['cbMailboxServerDN'] = len(szMailboxServerDN)\n\n    resp = dce.request(request)\n    resp['ppszServerFQDN'] = resp['ppszServerFQDN'][:-1]\n\n    return resp",
  "def __init__(self, error_string=None, error_code=None, packet=None):\n        DCERPCException.__init__(self, error_string, error_code, packet)",
  "def __str__( self ):\n        key = self.error_code\n        if key in mapi_constants.ERROR_MESSAGES:\n            error_msg_short = mapi_constants.ERROR_MESSAGES[key]\n            return 'OXABREF SessionError: code: 0x%x - %s' % (self.error_code, error_msg_short)\n        elif key in hresult_errors.ERROR_MESSAGES:\n            error_msg_short = hresult_errors.ERROR_MESSAGES[key][0]\n            error_msg_verbose = hresult_errors.ERROR_MESSAGES[key][1]\n            return 'OXABREF SessionError: code: 0x%x - %s - %s' % (self.error_code, error_msg_short, error_msg_verbose)\n        else:\n            return 'OXABREF SessionError: unknown error code: 0x%x' % self.error_code",
  "class DCERPCSessionError(DCERPCException):\n    def __init__(self, error_string=None, error_code=None, packet=None):\n        DCERPCException.__init__(self, error_string, error_code, packet)\n\n    def __str__( self ):\n        key = self.error_code\n        if key in nt_errors.ERROR_MESSAGES:\n            error_msg_short = nt_errors.ERROR_MESSAGES[key][0]\n            error_msg_verbose = nt_errors.ERROR_MESSAGES[key][1]\n            return 'EVEN SessionError: code: 0x%x - %s - %s' % (self.error_code, error_msg_short, error_msg_verbose)\n        else:\n            return 'EVEN SessionError: unknown error code: 0x%x' % self.error_code",
  "class IELF_HANDLE(NDRSTRUCT):\n    structure =  (\n        ('Data','20s=\"\"'),\n    )\n    def getAlignment(self):\n        return 1",
  "class EVENTLOGRECORD(Structure):\n    structure = (\n        ('Length','<L=0'),\n        ('Reserved','<L=0'),\n        ('RecordNumber','<L=0'),\n        ('TimeGenerated','<L=0'),\n        ('TimeWritten','<L=0'),\n        ('EventID','<L=0'),\n        ('EventType','<H=0'),\n        ('NumStrings','<H=0'),\n        ('EventCategory','<H=0'),\n        ('ReservedFlags','<H=0'),\n        ('ClosingRecordNumber','<L=0'),\n        ('StringOffset','<L=0'),\n        ('UserSidLength','<L=0'),\n        ('UserSidOffset','<L=0'),\n        ('DataLength','<L=0'),\n        ('DataOffset','<L=0'),\n        ('SourceName','z'),\n        ('Computername','z'),\n        ('UserSidPadding',':'),\n        ('_UserSid','_-UserSid', 'self[\"UserSidLength\"]'),\n        ('UserSid',':'),\n        ('Strings',':'),\n        ('_Data','_-Data', 'self[\"DataLength\"]'),\n        ('Data',':'),\n        ('Padding',':'),\n        ('Length2','<L=0'),\n    )",
  "class EVENTLOG_FULL_INFORMATION(NDRSTRUCT):\n    structure = (\n        ('dwFull', ULONG),\n    )",
  "class RPC_CLIENT_ID(NDRSTRUCT):\n    structure = (\n        ('UniqueProcess', ULONG),\n        ('UniqueThread', ULONG),\n    )",
  "class RPC_STRING(NDRSTRUCT):\n    structure = (\n        ('Length','<H=0'),\n        ('MaximumLength','<H=0'),\n        ('Data',LPSTR),\n    )\n\n    def __setitem__(self, key, value):\n        if key == 'Data' and isinstance(value, NDR) is False:\n            self['Length'] = len(value)\n            self['MaximumLength'] = len(value)\n        return NDRSTRUCT.__setitem__(self, key, value)\n\n    def dump(self, msg = None, indent = 0):\n        if msg is None: msg = self.__class__.__name__\n        if msg != '':\n            print(\"%s\" % msg, end=' ')\n\n        if isinstance(self.fields['Data'] , NDRPOINTERNULL):\n            print(\" NULL\", end=' ')\n        elif self.fields['Data']['ReferentID'] == 0:\n            print(\" NULL\", end=' ')\n        else:\n            return self.fields['Data'].dump('',indent)",
  "class ElfrClearELFW(NDRCALL):\n    opnum = 0\n    structure = (\n       ('LogHandle', IELF_HANDLE),\n       ('BackupFileName', PRPC_UNICODE_STRING),\n    )",
  "class ElfrClearELFWResponse(NDRCALL):\n    structure = (\n       ('ErrorCode', NTSTATUS),\n    )",
  "class ElfrBackupELFW(NDRCALL):\n    opnum = 1\n    structure = (\n       ('LogHandle', IELF_HANDLE),\n       ('BackupFileName', RPC_UNICODE_STRING),\n    )",
  "class ElfrBackupELFWResponse(NDRCALL):\n    structure = (\n       ('ErrorCode', NTSTATUS),\n    )",
  "class ElfrCloseEL(NDRCALL):\n    opnum = 2\n    structure = (\n        ('LogHandle', IELF_HANDLE),\n    )",
  "class ElfrCloseELResponse(NDRCALL):\n    structure = (\n        ('LogHandle', IELF_HANDLE),\n        ('ErrorCode', NTSTATUS),\n    )",
  "class ElfrNumberOfRecords(NDRCALL):\n    opnum = 4\n    structure = (\n        ('LogHandle', IELF_HANDLE),\n    )",
  "class ElfrNumberOfRecordsResponse(NDRCALL):\n    structure = (\n        ('NumberOfRecords', ULONG),\n        ('ErrorCode', NTSTATUS),\n    )",
  "class ElfrOldestRecord(NDRCALL):\n    opnum = 5\n    structure = (\n        ('LogHandle', IELF_HANDLE),\n    )",
  "class ElfrOldestRecordResponse(NDRCALL):\n    structure = (\n        ('OldestRecordNumber', ULONG),\n        ('ErrorCode', NTSTATUS),\n    )",
  "class ElfrOpenELW(NDRCALL):\n    opnum = 7\n    structure = (\n       ('UNCServerName', EVENTLOG_HANDLE_W),\n       ('ModuleName', RPC_UNICODE_STRING),\n       ('RegModuleName', RPC_UNICODE_STRING),\n       ('MajorVersion', ULONG),\n       ('MinorVersion', ULONG),\n    )",
  "class ElfrOpenELWResponse(NDRCALL):\n    structure = (\n       ('LogHandle', IELF_HANDLE),\n       ('ErrorCode', NTSTATUS),\n    )",
  "class ElfrRegisterEventSourceW(NDRCALL):\n    opnum = 8\n    structure = (\n       ('UNCServerName', EVENTLOG_HANDLE_W),\n       ('ModuleName', RPC_UNICODE_STRING),\n       ('RegModuleName', RPC_UNICODE_STRING),\n       ('MajorVersion', ULONG),\n       ('MinorVersion', ULONG),\n    )",
  "class ElfrRegisterEventSourceWResponse(NDRCALL):\n    structure = (\n       ('LogHandle', IELF_HANDLE),\n       ('ErrorCode', NTSTATUS),\n    )",
  "class ElfrOpenBELW(NDRCALL):\n    opnum = 9\n    structure = (\n       ('UNCServerName', EVENTLOG_HANDLE_W),\n       ('BackupFileName', RPC_UNICODE_STRING),\n       ('MajorVersion', ULONG),\n       ('MinorVersion', ULONG),\n    )",
  "class ElfrOpenBELWResponse(NDRCALL):\n    structure = (\n       ('LogHandle', IELF_HANDLE),\n       ('ErrorCode', NTSTATUS),\n    )",
  "class ElfrReadELW(NDRCALL):\n    opnum = 10\n    structure = (\n       ('LogHandle', IELF_HANDLE),\n       ('ReadFlags', ULONG),\n       ('RecordOffset', ULONG),\n       ('NumberOfBytesToRead', ULONG),\n    )",
  "class ElfrReadELWResponse(NDRCALL):\n    structure = (\n       ('Buffer', NDRUniConformantArray),\n       ('NumberOfBytesRead', ULONG),\n       ('MinNumberOfBytesNeeded', ULONG),\n       ('ErrorCode', NTSTATUS),\n    )",
  "class ElfrReportEventW(NDRCALL):\n    opnum = 11\n    structure = (\n       ('LogHandle', IELF_HANDLE),\n       ('Time', ULONG),\n       ('EventType', USHORT),\n       ('EventCategory', USHORT),\n       ('EventID', ULONG),\n       ('NumStrings', USHORT),\n       ('DataSize', ULONG),\n       ('ComputerName', RPC_UNICODE_STRING),\n       ('UserSID', PRPC_SID),\n       ('Strings', PRPC_UNICODE_STRING_ARRAY),\n       ('Data', LPBYTE),\n       ('Flags', USHORT),\n       ('RecordNumber', PULONG),\n       ('TimeWritten', PULONG),\n    )",
  "class ElfrReportEventWResponse(NDRCALL):\n    structure = (\n       ('RecordNumber', PULONG),\n       ('TimeWritten', PULONG),\n       ('ErrorCode', NTSTATUS),\n    )",
  "def hElfrOpenBELW(dce, backupFileName = NULL):\n    request = ElfrOpenBELW()\n    request['UNCServerName'] = NULL\n    request['BackupFileName'] = backupFileName\n    request['MajorVersion'] = 1\n    request['MinorVersion'] = 1\n    return dce.request(request)",
  "def hElfrOpenELW(dce, moduleName = NULL, regModuleName = NULL):\n    request = ElfrOpenELW()\n    request['UNCServerName'] = NULL\n    request['ModuleName'] = moduleName\n    request['RegModuleName'] = regModuleName\n    request['MajorVersion'] = 1\n    request['MinorVersion'] = 1\n    return dce.request(request)",
  "def hElfrCloseEL(dce, logHandle):\n    request = ElfrCloseEL()\n    request['LogHandle'] = logHandle\n    resp = dce.request(request)\n    return resp",
  "def hElfrRegisterEventSourceW(dce, moduleName = NULL, regModuleName = NULL):\n    request = ElfrRegisterEventSourceW()\n    request['UNCServerName'] = NULL\n    request['ModuleName'] = moduleName\n    request['RegModuleName'] = regModuleName\n    request['MajorVersion'] = 1\n    request['MinorVersion'] = 1\n    return dce.request(request)",
  "def hElfrReadELW(dce, logHandle = '', readFlags = EVENTLOG_SEEK_READ|EVENTLOG_FORWARDS_READ,\n                 recordOffset = 0, numberOfBytesToRead = MAX_BATCH_BUFF):\n    request = ElfrReadELW()\n    request['LogHandle'] = logHandle\n    request['ReadFlags'] = readFlags\n    request['RecordOffset'] = recordOffset\n    request['NumberOfBytesToRead'] = numberOfBytesToRead\n    return dce.request(request)",
  "def hElfrClearELFW(dce, logHandle = '', backupFileName = NULL):\n    request = ElfrClearELFW()\n    request['LogHandle'] = logHandle\n    request['BackupFileName'] = backupFileName\n    return dce.request(request)",
  "def hElfrBackupELFW(dce, logHandle = '', backupFileName = NULL):\n    request = ElfrBackupELFW()\n    request['LogHandle'] = logHandle\n    request['BackupFileName'] = backupFileName\n    return dce.request(request)",
  "def hElfrNumberOfRecords(dce, logHandle):\n    request = ElfrNumberOfRecords()\n    request['LogHandle'] = logHandle\n    resp = dce.request(request)\n    return resp",
  "def hElfrOldestRecordNumber(dce, logHandle):\n    request = ElfrOldestRecord()\n    request['LogHandle'] = logHandle\n    resp = dce.request(request)\n    return resp",
  "def __init__(self, error_string=None, error_code=None, packet=None):\n        DCERPCException.__init__(self, error_string, error_code, packet)",
  "def __str__( self ):\n        key = self.error_code\n        if key in nt_errors.ERROR_MESSAGES:\n            error_msg_short = nt_errors.ERROR_MESSAGES[key][0]\n            error_msg_verbose = nt_errors.ERROR_MESSAGES[key][1]\n            return 'EVEN SessionError: code: 0x%x - %s - %s' % (self.error_code, error_msg_short, error_msg_verbose)\n        else:\n            return 'EVEN SessionError: unknown error code: 0x%x' % self.error_code",
  "def getAlignment(self):\n        return 1",
  "def __setitem__(self, key, value):\n        if key == 'Data' and isinstance(value, NDR) is False:\n            self['Length'] = len(value)\n            self['MaximumLength'] = len(value)\n        return NDRSTRUCT.__setitem__(self, key, value)",
  "def dump(self, msg = None, indent = 0):\n        if msg is None: msg = self.__class__.__name__\n        if msg != '':\n            print(\"%s\" % msg, end=' ')\n\n        if isinstance(self.fields['Data'] , NDRPOINTERNULL):\n            print(\" NULL\", end=' ')\n        elif self.fields['Data']['ReferentID'] == 0:\n            print(\" NULL\", end=' ')\n        else:\n            return self.fields['Data'].dump('',indent)",
  "class DCERPCSessionError(DCERPCException):\n    def __init__(self, error_string=None, error_code=None, packet=None):\n        DCERPCException.__init__(self, error_string, error_code, packet)\n\n    def __str__( self ):\n        key = self.error_code\n        if key in system_errors.ERROR_MESSAGES:\n            error_msg_short = system_errors.ERROR_MESSAGES[key][0]\n            error_msg_verbose = system_errors.ERROR_MESSAGES[key][1] \n            return 'BKRP SessionError: code: 0x%x - %s - %s' % (self.error_code, error_msg_short, error_msg_verbose)\n        else:\n            return 'BKRP SessionError: unknown error code: 0x%x' % self.error_code",
  "class BYTE_ARRAY(NDRUniConformantArray):\n    item = 'c'",
  "class PBYTE_ARRAY(NDRPOINTER):\n    referent = (\n        ('Data', BYTE_ARRAY),\n    )",
  "class Rc4EncryptedPayload(Structure):\n    structure = (\n        ('R3', '32s=\"\"'),\n        ('MAC', '20s=\"\"'),\n        ('SID', ':', RPC_SID),\n        ('Secret', ':'),\n    )",
  "class WRAPPED_SECRET(Structure):\n    structure = (\n        ('SIGNATURE', '<L=1'),\n        ('Payload_Length', '<L=0'),\n        ('Ciphertext_Length', '<L=0'),\n        ('GUID_of_Wrapping_Key', '16s=\"\"'),\n        ('R2', '68s=\"\"'),\n        ('_Rc4EncryptedPayload', '_-Rc4EncryptedPayload', 'self[\"Payload_Length\"]'),\n        ('Rc4EncryptedPayload', ':'),\n    )",
  "class BackuprKey(NDRCALL):\n    opnum = 0\n    structure = (\n       ('pguidActionAgent', GUID),\n       ('pDataIn', BYTE_ARRAY),\n       ('cbDataIn', DWORD),\n       ('dwParam', DWORD),\n    )",
  "class BackuprKeyResponse(NDRCALL):\n    structure = (\n       ('ppDataOut', PBYTE_ARRAY),\n       ('pcbDataOut', DWORD),\n       ('ErrorCode', NTSTATUS),\n    )",
  "def hBackuprKey(dce, pguidActionAgent, pDataIn, dwParam=0):\n    request = BackuprKey()\n    request['pguidActionAgent'] = pguidActionAgent\n    request['pDataIn'] = pDataIn\n    if pDataIn == NULL:\n        request['cbDataIn'] = 0\n    else:\n        request['cbDataIn'] = len(pDataIn)\n    request['dwParam'] = dwParam\n    return dce.request(request)",
  "def __init__(self, error_string=None, error_code=None, packet=None):\n        DCERPCException.__init__(self, error_string, error_code, packet)",
  "def __str__( self ):\n        key = self.error_code\n        if key in system_errors.ERROR_MESSAGES:\n            error_msg_short = system_errors.ERROR_MESSAGES[key][0]\n            error_msg_verbose = system_errors.ERROR_MESSAGES[key][1] \n            return 'BKRP SessionError: code: 0x%x - %s - %s' % (self.error_code, error_msg_short, error_msg_verbose)\n        else:\n            return 'BKRP SessionError: unknown error code: 0x%x' % self.error_code",
  "class DCERPCStringBinding:\n    parser = re.compile(r\"(?:([a-fA-F0-9-]{8}(?:-[a-fA-F0-9-]{4}){3}-[a-fA-F0-9-]{12})@)?\" +  # UUID (opt.)\n                        r\"([_a-zA-Z0-9]*):\" +  # Protocol Sequence\n                        r\"([^\\[]*)\" +  # Network Address (opt.)\n                        r\"(?:\\[([^]]*)])?\")  # Endpoint and options (opt.)\n\n    def __init__(self, stringbinding):\n        match = DCERPCStringBinding.parser.match(stringbinding)\n        self.__uuid = match.group(1)\n        self.__ps = match.group(2)\n        self.__na = match.group(3)\n        options = match.group(4)\n        if options:\n            options = options.split(',')\n            \n            self.__endpoint = options[0]\n            try:\n                self.__endpoint.index('endpoint=')\n                self.__endpoint = self.__endpoint[len('endpoint='):]\n            except:\n                pass\n\n            self.__options = {}\n            for option in options[1:]:\n                vv = option.split('=', 1)\n                self.__options[vv[0]] = vv[1] if len(vv) > 1 else ''\n        else:\n            self.__endpoint = ''\n            self.__options = {}\n\n    def get_uuid(self):\n        return self.__uuid\n\n    def get_protocol_sequence(self):\n        return self.__ps\n\n    def get_network_address(self):\n        return self.__na\n\n    def set_network_address(self, addr):\n        self.__na = addr\n\n    def get_endpoint(self):\n        return self.__endpoint\n\n    def get_options(self):\n        return self.__options\n\n    def get_option(self, option_name):\n        return self.__options[option_name]\n\n    def is_option_set(self, option_name):\n        return option_name in self.__options\n\n    def unset_option(self, option_name):\n        del self.__options[option_name]\n\n    def __str__(self):\n        return DCERPCStringBindingCompose(self.__uuid, self.__ps, self.__na, self.__endpoint, self.__options)",
  "def DCERPCStringBindingCompose(uuid=None, protocol_sequence='', network_address='', endpoint='', options={}):\n    s = ''\n    if uuid:\n        s += uuid + '@'\n    s += protocol_sequence + ':'\n    if network_address:\n        s += network_address\n    if endpoint or options:\n        s += '[' + endpoint\n        if options:\n            s += ',' + ','.join([key if str(val) == '' else \"=\".join([key, str(val)]) for key, val in options.items()])\n        s += ']'\n\n    return s",
  "def DCERPCTransportFactory(stringbinding):\n    sb = DCERPCStringBinding(stringbinding)\n\n    na = sb.get_network_address()\n    ps = sb.get_protocol_sequence()\n    if 'ncadg_ip_udp' == ps:\n        port = sb.get_endpoint()\n        if port:\n            rpctransport = UDPTransport(na, int(port))\n        else:\n            rpctransport = UDPTransport(na)\n    elif 'ncacn_ip_tcp' == ps:\n        port = sb.get_endpoint()\n        if port:\n            rpctransport = TCPTransport(na, int(port))\n        else:\n            rpctransport = TCPTransport(na)\n    elif 'ncacn_http' == ps:\n        port = sb.get_endpoint()\n        if port:\n            rpctransport = HTTPTransport(na, int(port))\n        else:\n            rpctransport = HTTPTransport(na)\n    elif 'ncacn_np' == ps:\n        named_pipe = sb.get_endpoint()\n        if named_pipe:\n            named_pipe = named_pipe[len(r'\\pipe'):]\n            rpctransport = SMBTransport(na, filename = named_pipe)\n        else:\n            rpctransport = SMBTransport(na)\n    elif 'ncalocal' == ps:\n        named_pipe = sb.get_endpoint()\n        rpctransport = LOCALTransport(filename = named_pipe)\n    else:\n        raise DCERPCException(\"Unknown protocol sequence.\")\n\n    rpctransport.set_stringbinding(sb)\n    return rpctransport",
  "class DCERPCTransport:\n\n    DCERPC_class = DCERPC_v5\n\n    def __init__(self, remoteName, dstport):\n        self.__remoteName = remoteName\n        self.__remoteHost = remoteName\n        self.__dstport = dstport\n        self._stringbinding = None\n        self._max_send_frag = None\n        self._max_recv_frag = None\n        self._domain = ''\n        self._lmhash = ''\n        self._nthash = ''\n        self.__connect_timeout = None\n        self._doKerberos = False\n        self._username = ''\n        self._password = ''\n        self._domain   = ''\n        self._aesKey   = None\n        self._TGT      = None\n        self._TGS      = None\n        self._kdcHost  = None\n        self.set_credentials('','')\n        # Strict host validation - off by default and currently only for\n        # SMBTransport\n        self._strict_hostname_validation = False\n        self._validation_allow_absent = True\n        self._accepted_hostname = ''\n\n    def connect(self):\n        raise RuntimeError('virtual function')\n    def send(self,data=0, forceWriteAndx = 0, forceRecv = 0):\n        raise RuntimeError('virtual function')\n    def recv(self, forceRecv = 0, count = 0):\n        raise RuntimeError('virtual function')\n    def disconnect(self):\n        raise RuntimeError('virtual function')\n    def get_socket(self):\n        raise RuntimeError('virtual function')\n\n    def get_connect_timeout(self):\n        return self.__connect_timeout\n    def set_connect_timeout(self, timeout):\n        self.__connect_timeout = timeout\n\n    def getRemoteName(self):\n        return self.__remoteName\n\n    def setRemoteName(self, remoteName):\n        \"\"\"This method only makes sense before connection for most protocols.\"\"\"\n        self.__remoteName = remoteName\n\n    def getRemoteHost(self):\n        return self.__remoteHost\n\n    def setRemoteHost(self, remoteHost):\n        \"\"\"This method only makes sense before connection for most protocols.\"\"\"\n        self.__remoteHost = remoteHost\n\n    def get_dport(self):\n        return self.__dstport\n    def set_dport(self, dport):\n        \"\"\"This method only makes sense before connection for most protocols.\"\"\"\n        self.__dstport = dport\n\n    def get_stringbinding(self):\n        return self._stringbinding\n\n    def set_stringbinding(self, stringbinding):\n        self._stringbinding = stringbinding\n\n    def get_addr(self):\n        return self.getRemoteHost(), self.get_dport()\n    def set_addr(self, addr):\n        \"\"\"This method only makes sense before connection for most protocols.\"\"\"\n        self.setRemoteHost(addr[0])\n        self.set_dport(addr[1])\n\n    def set_kerberos(self, flag, kdcHost = None):\n        self._doKerberos = flag\n        self._kdcHost = kdcHost\n\n    def get_kerberos(self):\n        return self._doKerberos\n\n    def get_kdcHost(self):\n        return self._kdcHost\n\n    def set_max_fragment_size(self, send_fragment_size):\n        # -1 is default fragment size: 0 (don't fragment)\n        #  0 is don't fragment\n        #    other values are max fragment size\n        if send_fragment_size == -1:\n            self.set_default_max_fragment_size()\n        else:\n            self._max_send_frag = send_fragment_size\n\n    def set_hostname_validation(self, validate, accept_empty, hostname):\n        self._strict_hostname_validation = validate\n        self._validation_allow_absent = accept_empty\n        self._accepted_hostname = hostname\n\n    def set_default_max_fragment_size(self):\n        # default is 0: don't fragment.\n        # subclasses may override this method\n        self._max_send_frag = 0\n\n    def get_credentials(self):\n        return (\n            self._username,\n            self._password,\n            self._domain,\n            self._lmhash,\n            self._nthash,\n            self._aesKey,\n            self._TGT,\n            self._TGS)\n\n    def set_credentials(self, username, password, domain='', lmhash='', nthash='', aesKey='', TGT=None, TGS=None):\n        self._username = username\n        self._password = password\n        self._domain   = domain\n        self._aesKey   = aesKey\n        self._TGT      = TGT\n        self._TGS      = TGS\n        if lmhash != '' or nthash != '':\n            if len(lmhash) % 2:\n                lmhash = '0%s' % lmhash\n            if len(nthash) % 2:\n                nthash = '0%s' % nthash\n            try: # just in case they were converted already\n               self._lmhash = binascii.unhexlify(lmhash)\n               self._nthash = binascii.unhexlify(nthash)\n            except:\n               self._lmhash = lmhash\n               self._nthash = nthash\n               pass\n\n    def doesSupportNTLMv2(self):\n        # By default we'll be returning the library's default. Only on SMB Transports we might be able to know it beforehand\n        return ntlm.USE_NTLMv2\n\n    def get_dce_rpc(self):\n        return DCERPC_v5(self)",
  "class UDPTransport(DCERPCTransport):\n    \"Implementation of ncadg_ip_udp protocol sequence\"\n\n    DCERPC_class = DCERPC_v4\n\n    def __init__(self, remoteName, dstport = 135):\n        DCERPCTransport.__init__(self, remoteName, dstport)\n        self.__socket = 0\n        self.set_connect_timeout(30)\n        self.__recv_addr = ''\n\n    def connect(self):\n        try:\n            af, socktype, proto, canonname, sa = socket.getaddrinfo(self.getRemoteHost(), self.get_dport(), 0, socket.SOCK_DGRAM)[0]\n            self.__socket = socket.socket(af, socktype, proto)\n            self.__socket.settimeout(self.get_connect_timeout())\n        except socket.error as msg:\n            self.__socket = None\n            raise DCERPCException(\"Could not connect: %s\" % msg)\n\n        return 1\n\n    def disconnect(self):\n        try:\n            self.__socket.close()\n        except socket.error:\n            self.__socket = None\n            return 0\n        return 1\n\n    def send(self,data, forceWriteAndx = 0, forceRecv = 0):\n        self.__socket.sendto(data, (self.getRemoteHost(), self.get_dport()))\n\n    def recv(self, forceRecv = 0, count = 0):\n        buffer, self.__recv_addr = self.__socket.recvfrom(8192)\n        return buffer\n\n    def get_recv_addr(self):\n        return self.__recv_addr\n\n    def get_socket(self):\n        return self.__socket",
  "class TCPTransport(DCERPCTransport):\n    \"\"\"Implementation of ncacn_ip_tcp protocol sequence\"\"\"\n\n    def __init__(self, remoteName, dstport = 135):\n        DCERPCTransport.__init__(self, remoteName, dstport)\n        self.__socket = 0\n        self.set_connect_timeout(30)\n\n    def connect(self):\n        af, socktype, proto, canonname, sa = socket.getaddrinfo(self.getRemoteHost(), self.get_dport(), 0, socket.SOCK_STREAM)[0]\n        self.__socket = socket.socket(af, socktype, proto)\n        try:\n            self.__socket.settimeout(self.get_connect_timeout())\n            self.__socket.connect(sa)\n        except socket.error as msg:\n            self.__socket.close()\n            raise DCERPCException(\"Could not connect: %s\" % msg)\n        return 1\n\n    def disconnect(self):\n        try:\n            self.__socket.close()\n        except socket.error:\n            self.__socket = None\n            return 0\n        return 1\n\n    def send(self,data, forceWriteAndx = 0, forceRecv = 0):\n        if self._max_send_frag:\n            offset = 0\n            while 1:\n                toSend = data[offset:offset+self._max_send_frag]\n                if not toSend:\n                    break\n                self.__socket.send(toSend)\n                offset += len(toSend)\n        else:\n            self.__socket.send(data)\n\n    def recv(self, forceRecv = 0, count = 0):\n        if count:\n            buffer = b''\n            while len(buffer) < count:\n               buffer += self.__socket.recv(count-len(buffer))\n        else:\n            buffer = self.__socket.recv(8192)\n        return buffer\n\n    def get_socket(self):\n        return self.__socket",
  "class HTTPTransport(TCPTransport, RPCProxyClient):\n    \"\"\"Implementation of ncacn_http protocol sequence\"\"\"\n\n    def __init__(self, remoteName=None, dstport=593):\n        self._useRpcProxy = False\n        self._rpcProxyUrl = None\n        self._transport   = TCPTransport\n        self._version     = RPC_OVER_HTTP_v2\n\n        DCERPCTransport.__init__(self, remoteName, dstport)\n        RPCProxyClient.__init__(self, remoteName, dstport)\n        self.set_connect_timeout(30)\n\n    def set_credentials(self, username, password, domain='', lmhash='', nthash='', aesKey='', TGT=None, TGS=None):\n        return self._transport.set_credentials(self, username, password,\n            domain, lmhash, nthash, aesKey, TGT, TGS)\n\n    def rpc_proxy_init(self):\n        self._useRpcProxy = True\n        self._transport   = RPCProxyClient\n\n    def set_rpc_proxy_url(self, url):\n        self.rpc_proxy_init()\n        self._rpcProxyUrl = urlparse(url)\n\n    def get_rpc_proxy_url(self):\n        return urlunparse(self._rpcProxyUrl)\n\n    def set_stringbinding(self, set_stringbinding):\n        DCERPCTransport.set_stringbinding(self, set_stringbinding)\n\n        if self._stringbinding.is_option_set(\"RpcProxy\"):\n            self.rpc_proxy_init()\n\n            rpcproxy = self._stringbinding.get_option(\"RpcProxy\").split(\":\")\n\n            if rpcproxy[1] == '443':\n                self.set_rpc_proxy_url('https://%s/rpc/rpcproxy.dll' % rpcproxy[0])\n            elif rpcproxy[1] == '80':\n                self.set_rpc_proxy_url('http://%s/rpc/rpcproxy.dll' % rpcproxy[0])\n            else:\n                # 2.1.2.1\n                # RPC over HTTP always uses port 80 for HTTP traffic and port 443 for HTTPS traffic.\n                # But you can use set_rpc_proxy_url method to set any URL / query you want.\n                raise DCERPCException(\"RPC Proxy port must be 80 or 443\")\n\n    def connect(self):\n        if self._useRpcProxy == False:\n            # Connecting directly to the ncacn_http port\n            #\n            # Here we using RPC over HTTPv1 instead complex RPC over HTTP v2 syntax\n            # RPC over HTTP v2 here can be implemented in the future\n            self._version = RPC_OVER_HTTP_v1\n\n            TCPTransport.connect(self)\n\n            # Reading legacy server response\n            data = self.get_socket().recv(8192)\n\n            if data != b'ncacn_http/1.0':\n                raise DCERPCException(\"%s:%s service is not ncacn_http\" % (self.__remoteName, self.__dstport))\n        else:\n            RPCProxyClient.connect(self)\n\n    def send(self, data, forceWriteAndx=0, forceRecv=0):\n        return self._transport.send(self, data, forceWriteAndx, forceRecv)\n\n    def recv(self, forceRecv=0, count=0):\n        return self._transport.recv(self, forceRecv, count)\n\n    def get_socket(self):\n        if self._useRpcProxy == False:\n            return TCPTransport.get_socket(self)\n        else:\n            raise DCERPCException(\"This method is not supported for RPC Proxy connections\")\n\n    def disconnect(self):\n        return self._transport.disconnect(self)",
  "class SMBTransport(DCERPCTransport):\n    \"\"\"Implementation of ncacn_np protocol sequence\"\"\"\n\n    def __init__(self, remoteName, dstport=445, filename='', username='', password='', domain='', lmhash='', nthash='',\n                 aesKey='', TGT=None, TGS=None, remote_host='', smb_connection=0, doKerberos=False, kdcHost=None):\n        DCERPCTransport.__init__(self, remoteName, dstport)\n        self.__socket = None\n        self.__tid = 0\n        self.__filename = filename\n        self.__handle = 0\n        self.__pending_recv = 0\n        self.set_credentials(username, password, domain, lmhash, nthash, aesKey, TGT, TGS)\n        self._doKerberos = doKerberos\n        self._kdcHost = kdcHost\n\n        if remote_host != '':\n            self.setRemoteHost(remote_host)\n\n        if smb_connection == 0:\n            self.__existing_smb = False\n        else:\n            self.__existing_smb = True\n            self.set_credentials(*smb_connection.getCredentials())\n\n        self.__prefDialect = None\n        self.__smb_connection = smb_connection\n        self.set_connect_timeout(30)\n\n    def preferred_dialect(self, dialect):\n        self.__prefDialect = dialect\n\n    def setup_smb_connection(self):\n        if not self.__smb_connection:\n            self.__smb_connection = SMBConnection(self.getRemoteName(), self.getRemoteHost(), sess_port=self.get_dport(),\n                                                  preferredDialect=self.__prefDialect, timeout=self.get_connect_timeout())\n            if self._strict_hostname_validation:\n                self.__smb_connection.setHostnameValidation(self._strict_hostname_validation, self._validation_allow_absent, self._accepted_hostname)\n\n    def connect(self):\n        # Check if we have a smb connection already setup\n        if self.__smb_connection == 0:\n            self.setup_smb_connection()\n            if self._doKerberos is False:\n                self.__smb_connection.login(self._username, self._password, self._domain, self._lmhash, self._nthash)\n            else:\n                self.__smb_connection.kerberosLogin(self._username, self._password, self._domain, self._lmhash,\n                                                    self._nthash, self._aesKey, kdcHost=self._kdcHost, TGT=self._TGT,\n                                                    TGS=self._TGS)\n        self.__tid = self.__smb_connection.connectTree('IPC$')\n        self.__handle = self.__smb_connection.openFile(self.__tid, self.__filename)\n        self.__socket = self.__smb_connection.getSMBServer().get_socket()\n        return 1\n\n    def disconnect(self):\n        self.__smb_connection.disconnectTree(self.__tid)\n        # If we created the SMB connection, we close it, otherwise\n        # that's up for the caller\n        if self.__existing_smb is False:\n            self.__smb_connection.logoff()\n            self.__smb_connection.close()\n            self.__smb_connection = 0\n\n    def send(self,data, forceWriteAndx = 0, forceRecv = 0):\n        if self._max_send_frag:\n            offset = 0\n            while 1:\n                toSend = data[offset:offset+self._max_send_frag]\n                if not toSend:\n                    break\n                self.__smb_connection.writeFile(self.__tid, self.__handle, toSend, offset = offset)\n                offset += len(toSend)\n        else:\n            self.__smb_connection.writeFile(self.__tid, self.__handle, data)\n        if forceRecv:\n            self.__pending_recv += 1\n\n    def recv(self, forceRecv = 0, count = 0 ):\n        if self._max_send_frag or self.__pending_recv:\n            # _max_send_frag is checked because it's the same condition we checked\n            # to decide whether to use write_andx() or send_trans() in send() above.\n            if self.__pending_recv:\n                self.__pending_recv -= 1\n            return self.__smb_connection.readFile(self.__tid, self.__handle, bytesToRead = self._max_recv_frag)\n        else:\n            return self.__smb_connection.readFile(self.__tid, self.__handle)\n\n    def get_smb_connection(self):\n        return self.__smb_connection\n\n    def set_smb_connection(self, smb_connection):\n        self.__smb_connection = smb_connection\n        self.set_credentials(*smb_connection.getCredentials())\n        self.__existing_smb = True\n\n    def get_smb_server(self):\n        # Raw Access to the SMBServer (whatever type it is)\n        return self.__smb_connection.getSMBServer()\n\n    def get_socket(self):\n        return self.__socket\n\n    def doesSupportNTLMv2(self):\n        return self.__smb_connection.doesSupportNTLMv2()",
  "class LOCALTransport(DCERPCTransport):\n    \"\"\"\n    Implementation of ncalocal protocol sequence, not the same\n    as ncalrpc (I'm not doing LPC just opening the local pipe)\n    \"\"\"\n\n    def __init__(self, filename = ''):\n        DCERPCTransport.__init__(self, '', 0)\n        self.__filename = filename\n        self.__handle = 0\n\n    def connect(self):\n        if self.__filename.upper().find('PIPE') < 0:\n            self.__filename = '\\\\PIPE\\\\%s' % self.__filename\n        self.__handle = os.open('\\\\\\\\.\\\\%s' % self.__filename, os.O_RDWR|os.O_BINARY)\n        return 1\n\n    def disconnect(self):\n        os.close(self.__handle)\n\n    def send(self,data, forceWriteAndx = 0, forceRecv = 0):\n        os.write(self.__handle, data)\n\n    def recv(self, forceRecv = 0, count = 0 ):\n        data = os.read(self.__handle, 65535)\n        return data",
  "def __init__(self, stringbinding):\n        match = DCERPCStringBinding.parser.match(stringbinding)\n        self.__uuid = match.group(1)\n        self.__ps = match.group(2)\n        self.__na = match.group(3)\n        options = match.group(4)\n        if options:\n            options = options.split(',')\n            \n            self.__endpoint = options[0]\n            try:\n                self.__endpoint.index('endpoint=')\n                self.__endpoint = self.__endpoint[len('endpoint='):]\n            except:\n                pass\n\n            self.__options = {}\n            for option in options[1:]:\n                vv = option.split('=', 1)\n                self.__options[vv[0]] = vv[1] if len(vv) > 1 else ''\n        else:\n            self.__endpoint = ''\n            self.__options = {}",
  "def get_uuid(self):\n        return self.__uuid",
  "def get_protocol_sequence(self):\n        return self.__ps",
  "def get_network_address(self):\n        return self.__na",
  "def set_network_address(self, addr):\n        self.__na = addr",
  "def get_endpoint(self):\n        return self.__endpoint",
  "def get_options(self):\n        return self.__options",
  "def get_option(self, option_name):\n        return self.__options[option_name]",
  "def is_option_set(self, option_name):\n        return option_name in self.__options",
  "def unset_option(self, option_name):\n        del self.__options[option_name]",
  "def __str__(self):\n        return DCERPCStringBindingCompose(self.__uuid, self.__ps, self.__na, self.__endpoint, self.__options)",
  "def __init__(self, remoteName, dstport):\n        self.__remoteName = remoteName\n        self.__remoteHost = remoteName\n        self.__dstport = dstport\n        self._stringbinding = None\n        self._max_send_frag = None\n        self._max_recv_frag = None\n        self._domain = ''\n        self._lmhash = ''\n        self._nthash = ''\n        self.__connect_timeout = None\n        self._doKerberos = False\n        self._username = ''\n        self._password = ''\n        self._domain   = ''\n        self._aesKey   = None\n        self._TGT      = None\n        self._TGS      = None\n        self._kdcHost  = None\n        self.set_credentials('','')\n        # Strict host validation - off by default and currently only for\n        # SMBTransport\n        self._strict_hostname_validation = False\n        self._validation_allow_absent = True\n        self._accepted_hostname = ''",
  "def connect(self):\n        raise RuntimeError('virtual function')",
  "def send(self,data=0, forceWriteAndx = 0, forceRecv = 0):\n        raise RuntimeError('virtual function')",
  "def recv(self, forceRecv = 0, count = 0):\n        raise RuntimeError('virtual function')",
  "def disconnect(self):\n        raise RuntimeError('virtual function')",
  "def get_socket(self):\n        raise RuntimeError('virtual function')",
  "def get_connect_timeout(self):\n        return self.__connect_timeout",
  "def set_connect_timeout(self, timeout):\n        self.__connect_timeout = timeout",
  "def getRemoteName(self):\n        return self.__remoteName",
  "def setRemoteName(self, remoteName):\n        \"\"\"This method only makes sense before connection for most protocols.\"\"\"\n        self.__remoteName = remoteName",
  "def getRemoteHost(self):\n        return self.__remoteHost",
  "def setRemoteHost(self, remoteHost):\n        \"\"\"This method only makes sense before connection for most protocols.\"\"\"\n        self.__remoteHost = remoteHost",
  "def get_dport(self):\n        return self.__dstport",
  "def set_dport(self, dport):\n        \"\"\"This method only makes sense before connection for most protocols.\"\"\"\n        self.__dstport = dport",
  "def get_stringbinding(self):\n        return self._stringbinding",
  "def set_stringbinding(self, stringbinding):\n        self._stringbinding = stringbinding",
  "def get_addr(self):\n        return self.getRemoteHost(), self.get_dport()",
  "def set_addr(self, addr):\n        \"\"\"This method only makes sense before connection for most protocols.\"\"\"\n        self.setRemoteHost(addr[0])\n        self.set_dport(addr[1])",
  "def set_kerberos(self, flag, kdcHost = None):\n        self._doKerberos = flag\n        self._kdcHost = kdcHost",
  "def get_kerberos(self):\n        return self._doKerberos",
  "def get_kdcHost(self):\n        return self._kdcHost",
  "def set_max_fragment_size(self, send_fragment_size):\n        # -1 is default fragment size: 0 (don't fragment)\n        #  0 is don't fragment\n        #    other values are max fragment size\n        if send_fragment_size == -1:\n            self.set_default_max_fragment_size()\n        else:\n            self._max_send_frag = send_fragment_size",
  "def set_hostname_validation(self, validate, accept_empty, hostname):\n        self._strict_hostname_validation = validate\n        self._validation_allow_absent = accept_empty\n        self._accepted_hostname = hostname",
  "def set_default_max_fragment_size(self):\n        # default is 0: don't fragment.\n        # subclasses may override this method\n        self._max_send_frag = 0",
  "def get_credentials(self):\n        return (\n            self._username,\n            self._password,\n            self._domain,\n            self._lmhash,\n            self._nthash,\n            self._aesKey,\n            self._TGT,\n            self._TGS)",
  "def set_credentials(self, username, password, domain='', lmhash='', nthash='', aesKey='', TGT=None, TGS=None):\n        self._username = username\n        self._password = password\n        self._domain   = domain\n        self._aesKey   = aesKey\n        self._TGT      = TGT\n        self._TGS      = TGS\n        if lmhash != '' or nthash != '':\n            if len(lmhash) % 2:\n                lmhash = '0%s' % lmhash\n            if len(nthash) % 2:\n                nthash = '0%s' % nthash\n            try: # just in case they were converted already\n               self._lmhash = binascii.unhexlify(lmhash)\n               self._nthash = binascii.unhexlify(nthash)\n            except:\n               self._lmhash = lmhash\n               self._nthash = nthash\n               pass",
  "def doesSupportNTLMv2(self):\n        # By default we'll be returning the library's default. Only on SMB Transports we might be able to know it beforehand\n        return ntlm.USE_NTLMv2",
  "def get_dce_rpc(self):\n        return DCERPC_v5(self)",
  "def __init__(self, remoteName, dstport = 135):\n        DCERPCTransport.__init__(self, remoteName, dstport)\n        self.__socket = 0\n        self.set_connect_timeout(30)\n        self.__recv_addr = ''",
  "def connect(self):\n        try:\n            af, socktype, proto, canonname, sa = socket.getaddrinfo(self.getRemoteHost(), self.get_dport(), 0, socket.SOCK_DGRAM)[0]\n            self.__socket = socket.socket(af, socktype, proto)\n            self.__socket.settimeout(self.get_connect_timeout())\n        except socket.error as msg:\n            self.__socket = None\n            raise DCERPCException(\"Could not connect: %s\" % msg)\n\n        return 1",
  "def disconnect(self):\n        try:\n            self.__socket.close()\n        except socket.error:\n            self.__socket = None\n            return 0\n        return 1",
  "def send(self,data, forceWriteAndx = 0, forceRecv = 0):\n        self.__socket.sendto(data, (self.getRemoteHost(), self.get_dport()))",
  "def recv(self, forceRecv = 0, count = 0):\n        buffer, self.__recv_addr = self.__socket.recvfrom(8192)\n        return buffer",
  "def get_recv_addr(self):\n        return self.__recv_addr",
  "def get_socket(self):\n        return self.__socket",
  "def __init__(self, remoteName, dstport = 135):\n        DCERPCTransport.__init__(self, remoteName, dstport)\n        self.__socket = 0\n        self.set_connect_timeout(30)",
  "def connect(self):\n        af, socktype, proto, canonname, sa = socket.getaddrinfo(self.getRemoteHost(), self.get_dport(), 0, socket.SOCK_STREAM)[0]\n        self.__socket = socket.socket(af, socktype, proto)\n        try:\n            self.__socket.settimeout(self.get_connect_timeout())\n            self.__socket.connect(sa)\n        except socket.error as msg:\n            self.__socket.close()\n            raise DCERPCException(\"Could not connect: %s\" % msg)\n        return 1",
  "def disconnect(self):\n        try:\n            self.__socket.close()\n        except socket.error:\n            self.__socket = None\n            return 0\n        return 1",
  "def send(self,data, forceWriteAndx = 0, forceRecv = 0):\n        if self._max_send_frag:\n            offset = 0\n            while 1:\n                toSend = data[offset:offset+self._max_send_frag]\n                if not toSend:\n                    break\n                self.__socket.send(toSend)\n                offset += len(toSend)\n        else:\n            self.__socket.send(data)",
  "def recv(self, forceRecv = 0, count = 0):\n        if count:\n            buffer = b''\n            while len(buffer) < count:\n               buffer += self.__socket.recv(count-len(buffer))\n        else:\n            buffer = self.__socket.recv(8192)\n        return buffer",
  "def get_socket(self):\n        return self.__socket",
  "def __init__(self, remoteName=None, dstport=593):\n        self._useRpcProxy = False\n        self._rpcProxyUrl = None\n        self._transport   = TCPTransport\n        self._version     = RPC_OVER_HTTP_v2\n\n        DCERPCTransport.__init__(self, remoteName, dstport)\n        RPCProxyClient.__init__(self, remoteName, dstport)\n        self.set_connect_timeout(30)",
  "def set_credentials(self, username, password, domain='', lmhash='', nthash='', aesKey='', TGT=None, TGS=None):\n        return self._transport.set_credentials(self, username, password,\n            domain, lmhash, nthash, aesKey, TGT, TGS)",
  "def rpc_proxy_init(self):\n        self._useRpcProxy = True\n        self._transport   = RPCProxyClient",
  "def set_rpc_proxy_url(self, url):\n        self.rpc_proxy_init()\n        self._rpcProxyUrl = urlparse(url)",
  "def get_rpc_proxy_url(self):\n        return urlunparse(self._rpcProxyUrl)",
  "def set_stringbinding(self, set_stringbinding):\n        DCERPCTransport.set_stringbinding(self, set_stringbinding)\n\n        if self._stringbinding.is_option_set(\"RpcProxy\"):\n            self.rpc_proxy_init()\n\n            rpcproxy = self._stringbinding.get_option(\"RpcProxy\").split(\":\")\n\n            if rpcproxy[1] == '443':\n                self.set_rpc_proxy_url('https://%s/rpc/rpcproxy.dll' % rpcproxy[0])\n            elif rpcproxy[1] == '80':\n                self.set_rpc_proxy_url('http://%s/rpc/rpcproxy.dll' % rpcproxy[0])\n            else:\n                # 2.1.2.1\n                # RPC over HTTP always uses port 80 for HTTP traffic and port 443 for HTTPS traffic.\n                # But you can use set_rpc_proxy_url method to set any URL / query you want.\n                raise DCERPCException(\"RPC Proxy port must be 80 or 443\")",
  "def connect(self):\n        if self._useRpcProxy == False:\n            # Connecting directly to the ncacn_http port\n            #\n            # Here we using RPC over HTTPv1 instead complex RPC over HTTP v2 syntax\n            # RPC over HTTP v2 here can be implemented in the future\n            self._version = RPC_OVER_HTTP_v1\n\n            TCPTransport.connect(self)\n\n            # Reading legacy server response\n            data = self.get_socket().recv(8192)\n\n            if data != b'ncacn_http/1.0':\n                raise DCERPCException(\"%s:%s service is not ncacn_http\" % (self.__remoteName, self.__dstport))\n        else:\n            RPCProxyClient.connect(self)",
  "def send(self, data, forceWriteAndx=0, forceRecv=0):\n        return self._transport.send(self, data, forceWriteAndx, forceRecv)",
  "def recv(self, forceRecv=0, count=0):\n        return self._transport.recv(self, forceRecv, count)",
  "def get_socket(self):\n        if self._useRpcProxy == False:\n            return TCPTransport.get_socket(self)\n        else:\n            raise DCERPCException(\"This method is not supported for RPC Proxy connections\")",
  "def disconnect(self):\n        return self._transport.disconnect(self)",
  "def __init__(self, remoteName, dstport=445, filename='', username='', password='', domain='', lmhash='', nthash='',\n                 aesKey='', TGT=None, TGS=None, remote_host='', smb_connection=0, doKerberos=False, kdcHost=None):\n        DCERPCTransport.__init__(self, remoteName, dstport)\n        self.__socket = None\n        self.__tid = 0\n        self.__filename = filename\n        self.__handle = 0\n        self.__pending_recv = 0\n        self.set_credentials(username, password, domain, lmhash, nthash, aesKey, TGT, TGS)\n        self._doKerberos = doKerberos\n        self._kdcHost = kdcHost\n\n        if remote_host != '':\n            self.setRemoteHost(remote_host)\n\n        if smb_connection == 0:\n            self.__existing_smb = False\n        else:\n            self.__existing_smb = True\n            self.set_credentials(*smb_connection.getCredentials())\n\n        self.__prefDialect = None\n        self.__smb_connection = smb_connection\n        self.set_connect_timeout(30)",
  "def preferred_dialect(self, dialect):\n        self.__prefDialect = dialect",
  "def setup_smb_connection(self):\n        if not self.__smb_connection:\n            self.__smb_connection = SMBConnection(self.getRemoteName(), self.getRemoteHost(), sess_port=self.get_dport(),\n                                                  preferredDialect=self.__prefDialect, timeout=self.get_connect_timeout())\n            if self._strict_hostname_validation:\n                self.__smb_connection.setHostnameValidation(self._strict_hostname_validation, self._validation_allow_absent, self._accepted_hostname)",
  "def connect(self):\n        # Check if we have a smb connection already setup\n        if self.__smb_connection == 0:\n            self.setup_smb_connection()\n            if self._doKerberos is False:\n                self.__smb_connection.login(self._username, self._password, self._domain, self._lmhash, self._nthash)\n            else:\n                self.__smb_connection.kerberosLogin(self._username, self._password, self._domain, self._lmhash,\n                                                    self._nthash, self._aesKey, kdcHost=self._kdcHost, TGT=self._TGT,\n                                                    TGS=self._TGS)\n        self.__tid = self.__smb_connection.connectTree('IPC$')\n        self.__handle = self.__smb_connection.openFile(self.__tid, self.__filename)\n        self.__socket = self.__smb_connection.getSMBServer().get_socket()\n        return 1",
  "def disconnect(self):\n        self.__smb_connection.disconnectTree(self.__tid)\n        # If we created the SMB connection, we close it, otherwise\n        # that's up for the caller\n        if self.__existing_smb is False:\n            self.__smb_connection.logoff()\n            self.__smb_connection.close()\n            self.__smb_connection = 0",
  "def send(self,data, forceWriteAndx = 0, forceRecv = 0):\n        if self._max_send_frag:\n            offset = 0\n            while 1:\n                toSend = data[offset:offset+self._max_send_frag]\n                if not toSend:\n                    break\n                self.__smb_connection.writeFile(self.__tid, self.__handle, toSend, offset = offset)\n                offset += len(toSend)\n        else:\n            self.__smb_connection.writeFile(self.__tid, self.__handle, data)\n        if forceRecv:\n            self.__pending_recv += 1",
  "def recv(self, forceRecv = 0, count = 0 ):\n        if self._max_send_frag or self.__pending_recv:\n            # _max_send_frag is checked because it's the same condition we checked\n            # to decide whether to use write_andx() or send_trans() in send() above.\n            if self.__pending_recv:\n                self.__pending_recv -= 1\n            return self.__smb_connection.readFile(self.__tid, self.__handle, bytesToRead = self._max_recv_frag)\n        else:\n            return self.__smb_connection.readFile(self.__tid, self.__handle)",
  "def get_smb_connection(self):\n        return self.__smb_connection",
  "def set_smb_connection(self, smb_connection):\n        self.__smb_connection = smb_connection\n        self.set_credentials(*smb_connection.getCredentials())\n        self.__existing_smb = True",
  "def get_smb_server(self):\n        # Raw Access to the SMBServer (whatever type it is)\n        return self.__smb_connection.getSMBServer()",
  "def get_socket(self):\n        return self.__socket",
  "def doesSupportNTLMv2(self):\n        return self.__smb_connection.doesSupportNTLMv2()",
  "def __init__(self, filename = ''):\n        DCERPCTransport.__init__(self, '', 0)\n        self.__filename = filename\n        self.__handle = 0",
  "def connect(self):\n        if self.__filename.upper().find('PIPE') < 0:\n            self.__filename = '\\\\PIPE\\\\%s' % self.__filename\n        self.__handle = os.open('\\\\\\\\.\\\\%s' % self.__filename, os.O_RDWR|os.O_BINARY)\n        return 1",
  "def disconnect(self):\n        os.close(self.__handle)",
  "def send(self,data, forceWriteAndx = 0, forceRecv = 0):\n        os.write(self.__handle, data)",
  "def recv(self, forceRecv = 0, count = 0 ):\n        data = os.read(self.__handle, 65535)\n        return data",
  "class DCERPCException(Exception):\n    \"\"\"\n    This is the exception every client should catch regardless of the underlying\n    DCERPC Transport used.\n    \"\"\"\n    def __init__(self, error_string=None, error_code=None, packet=None):\n        \"\"\"\n        :param string error_string: A string you want to show explaining the exception. Otherwise the default ones will be used\n        :param integer error_code: the error_code if we're using a dictionary with error's descriptions\n        :param NDR packet: if successfully decoded, the NDR packet of the response call. This could probably have useful\n        information\n        \"\"\"\n        Exception.__init__(self)\n        self.packet = packet\n        self.error_string = error_string\n        if packet is not None:\n            try:\n                self.error_code = packet['ErrorCode']\n            except:\n                self.error_code = error_code\n        else:\n            self.error_code = error_code\n\n    def get_error_code( self ):\n        return self.error_code\n \n    def get_packet( self ):\n        return self.packet\n\n    def __str__( self ):\n        key = self.error_code\n        if self.error_string is not None:\n            return self.error_string\n        if key in rpc_status_codes:\n            error_msg_short = rpc_status_codes[key]\n            return 'DCERPC Runtime Error: code: 0x%x - %s ' % (self.error_code, error_msg_short)\n        else:\n            return 'DCERPC Runtime Error: unknown error code: 0x%x' % self.error_code",
  "class CtxItem(Structure):\n    structure = (\n        ('ContextID','<H=0'),\n        ('TransItems','B=0'),\n        ('Pad','B=0'),\n        ('AbstractSyntax','20s=\"\"'),\n        ('TransferSyntax','20s=\"\"'),\n    )",
  "class CtxItemResult(Structure):\n    structure = (\n        ('Result','<H=0'),\n        ('Reason','<H=0'),\n        ('TransferSyntax','20s=\"\"'),\n    )",
  "class SEC_TRAILER(Structure):\n    commonHdr = (\n        ('auth_type', 'B=10'),\n        ('auth_level','B=0'),\n        ('auth_pad_len','B=0'),\n        ('auth_rsvrd','B=0'),\n        ('auth_ctx_id','<L=747920'),\n    )",
  "class MSRPCHeader(Structure):\n    _SIZE = 16\n    commonHdr = ( \n        ('ver_major','B=5'),                              # 0\n        ('ver_minor','B=0'),                              # 1\n        ('type','B=0'),                                   # 2\n        ('flags','B=0'),                                  # 3\n        ('representation','<L=0x10'),                     # 4\n        ('frag_len','<H=self._SIZE+len(auth_data)+(16 if (self[\"flags\"] & 0x80) > 0 else 0)+len(pduData)+len(pad)+len(sec_trailer)'),  # 8\n        ('auth_len','<H=len(auth_data)'),                 # 10\n        ('call_id','<L=1'),                               # 12    <-- Common up to here (including this)\n    )\n\n    structure = ( \n        ('dataLen','_-pduData','self[\"frag_len\"]-self[\"auth_len\"]-self._SIZE-(8 if self[\"auth_len\"] > 0 else 0)'),\n        ('pduData',':'),                                \n        ('_pad', '_-pad','(4 - ((self._SIZE + (16 if (self[\"flags\"] & 0x80) > 0 else 0) + len(self[\"pduData\"])) & 3) & 3)'),\n        ('pad', ':'),\n        ('_sec_trailer', '_-sec_trailer', '8 if self[\"auth_len\"] > 0 else 0'),\n        ('sec_trailer',':'),\n        ('auth_dataLen','_-auth_data','self[\"auth_len\"]'),\n        ('auth_data',':'),\n    )\n\n    def __init__(self, data = None, alignment = 0):\n        Structure.__init__(self,data, alignment)\n        if data is None:\n            self['ver_major'] = 5\n            self['ver_minor'] = 0\n            self['flags'] = PFC_FIRST_FRAG | PFC_LAST_FRAG\n            self['type'] = MSRPC_REQUEST\n            self.__frag_len_set = 0\n            self['auth_len'] = 0\n            self['pduData'] = b''\n            self['auth_data'] = b''\n            self['sec_trailer'] = b''\n            self['pad'] = b''\n\n    def get_header_size(self):\n        return self._SIZE + (16 if (self[\"flags\"] & PFC_OBJECT_UUID) > 0 else 0)\n\n    def get_packet(self):\n        if self['auth_data'] != b'':\n            self['auth_len'] = len(self['auth_data'])\n        # The sec_trailer structure MUST be 4-byte aligned with respect to \n        # the beginning of the PDU. Padding octets MUST be used to align the \n        # sec_trailer structure if its natural beginning is not already 4-byte aligned\n        ##self['pad'] = '\\xAA' * (4 - ((self._SIZE + len(self['pduData'])) & 3) & 3)\n\n        return self.getData()",
  "class MSRPCRequestHeader(MSRPCHeader):\n    _SIZE = 24\n    commonHdr = MSRPCHeader.commonHdr + ( \n        ('alloc_hint','<L=0'),                            # 16\n        ('ctx_id','<H=0'),                                # 20\n        ('op_num','<H=0'),                                # 22\n        ('_uuid','_-uuid','16 if self[\"flags\"] & 0x80 > 0 else 0' ), # 22\n        ('uuid',':'),                                # 22\n    )\n\n    def __init__(self, data = None, alignment = 0):\n        MSRPCHeader.__init__(self, data, alignment)\n        if data is None:\n           self['type'] = MSRPC_REQUEST\n           self['ctx_id'] = 0\n           self['uuid'] = b''",
  "class MSRPCRespHeader(MSRPCHeader):\n    _SIZE = 24\n    commonHdr = MSRPCHeader.commonHdr + ( \n        ('alloc_hint','<L=0'),                          # 16   \n        ('ctx_id','<H=0'),                              # 20\n        ('cancel_count','<B=0'),                        # 22\n        ('padding','<B=0'),                             # 23\n    )\n\n    def __init__(self, aBuffer = None, alignment = 0):\n        MSRPCHeader.__init__(self, aBuffer, alignment)\n        if aBuffer is None:\n            self['type'] = MSRPC_RESPONSE\n            self['ctx_id'] = 0",
  "class MSRPCBind(Structure):\n    _CTX_ITEM_LEN = len(CtxItem())\n    structure = ( \n        ('max_tfrag','<H=4280'),\n        ('max_rfrag','<H=4280'),\n        ('assoc_group','<L=0'),\n        ('ctx_num','B=0'),\n        ('Reserved','B=0'),\n        ('Reserved2','<H=0'),\n        ('_ctx_items', '_-ctx_items', 'self[\"ctx_num\"]*self._CTX_ITEM_LEN'),\n        ('ctx_items',':'),\n    )\n \n    def __init__(self, data = None, alignment = 0):\n        Structure.__init__(self, data, alignment)\n        if data is None:\n            self['max_tfrag'] = 4280\n            self['max_rfrag'] = 4280\n            self['assoc_group'] = 0\n            self['ctx_num'] = 1\n            self['ctx_items'] = b''\n        self.__ctx_items = []\n\n    def addCtxItem(self, item):\n        self.__ctx_items.append(item)\n    \n    def getData(self):\n        self['ctx_num'] = len(self.__ctx_items)\n        for i in self.__ctx_items:\n            self['ctx_items'] += i.getData()\n        return Structure.getData(self)",
  "class MSRPCBindAck(MSRPCHeader):\n    _SIZE = 26 # Up to SecondaryAddr\n    _CTX_ITEM_LEN = len(CtxItemResult())\n    structure = ( \n        ('max_tfrag','<H=0'),\n        ('max_rfrag','<H=0'),\n        ('assoc_group','<L=0'),\n        ('SecondaryAddrLen','<H&SecondaryAddr'), \n        ('SecondaryAddr','z'),                          # Optional if SecondaryAddrLen == 0\n        ('PadLen','_-Pad','(4-((self[\"SecondaryAddrLen\"]+self._SIZE) % 4))%4'),\n        ('Pad',':'),\n        ('ctx_num','B=0'),\n        ('Reserved','B=0'),\n        ('Reserved2','<H=0'),\n        ('_ctx_items','_-ctx_items','self[\"ctx_num\"]*self._CTX_ITEM_LEN'),\n        ('ctx_items',':'),\n        ('_sec_trailer', '_-sec_trailer', '8 if self[\"auth_len\"] > 0 else 0'),\n        ('sec_trailer',':'),\n        ('auth_dataLen','_-auth_data','self[\"auth_len\"]'),\n        ('auth_data',':'),\n    )\n    def __init__(self, data = None, alignment = 0):\n        self.__ctx_items = []\n        MSRPCHeader.__init__(self,data,alignment)\n        if data is None:\n            self['Pad'] = b''\n            self['ctx_items'] = b''\n            self['sec_trailer'] = b''\n            self['auth_data'] = b''\n\n    def getCtxItems(self):\n        return self.__ctx_items\n\n    def getCtxItem(self,index):\n        return self.__ctx_items[index-1]\n\n    def fromString(self, data):\n        Structure.fromString(self,data)\n        # Parse the ctx_items\n        data = self['ctx_items']\n        for i in range(self['ctx_num']):\n            item = CtxItemResult(data)\n            self.__ctx_items.append(item)\n            data = data[len(item):]",
  "class MSRPCBindNak(Structure):\n    structure = ( \n        ('RejectedReason','<H=0'),\n        ('SupportedVersions',':'),\n    )\n    def __init__(self, data = None, alignment = 0):\n        Structure.__init__(self,data,alignment)\n        if data is None:\n            self['SupportedVersions'] = b''",
  "class DCERPC:\n    # Standard NDR Representation\n    NDRSyntax   = uuidtup_to_bin(('8a885d04-1ceb-11c9-9fe8-08002b104860', '2.0'))\n    # NDR 64\n    NDR64Syntax = uuidtup_to_bin(('71710533-BEBA-4937-8319-B5DBEF9CCC36', '1.0'))\n    transfer_syntax =  NDRSyntax\n\n    def __init__(self,transport):\n        self._transport = transport\n        self.set_ctx_id(0)\n        self._max_user_frag = None\n        self.set_default_max_fragment_size()\n        self._ctx = None\n\n    def get_rpc_transport(self):\n        return self._transport\n\n    def set_ctx_id(self, ctx_id):\n        self._ctx = ctx_id\n\n    def connect(self):\n        return self._transport.connect()\n\n    def disconnect(self):\n        return self._transport.disconnect()\n\n    def set_max_fragment_size(self, fragment_size):\n        # -1 is default fragment size: 0 for v5, 1300 y pico for v4\n        #  0 is don't fragment\n        #    other values are max fragment size\n        if fragment_size == -1:\n            self.set_default_max_fragment_size()\n        else:\n            self._max_user_frag = fragment_size\n\n    def set_default_max_fragment_size(self):\n        # default is 0: don'fragment. v4 will override this method\n        self._max_user_frag = 0\n\n    def send(self, data):\n        raise RuntimeError ('virtual method. Not implemented in subclass')\n\n    def recv(self):\n        raise RuntimeError ('virtual method. Not implemented in subclass')\n\n    def alter_ctx(self, newUID, bogus_binds=''):\n        raise RuntimeError ('virtual method. Not implemented in subclass')\n\n    def set_credentials(self, username, password, domain='', lmhash='', nthash='', aesKey='', TGT=None, TGS=None):\n        pass\n\n    def set_auth_level(self, auth_level):\n        pass\n\n    def set_auth_type(self, auth_type, callback=None):\n        pass\n\n    def get_idempotent(self):\n        return 0\n\n    def set_idempotent(self, flag):\n        pass\n\n    def call(self, function, body, uuid=None):\n        if hasattr(body, 'getData'):\n            return self.send(DCERPC_RawCall(function, body.getData(), uuid))\n        else:\n            return self.send(DCERPC_RawCall(function, body, uuid))\n\n    def request(self, request, uuid=None, checkError=True):\n        if self.transfer_syntax == self.NDR64Syntax:\n            request.changeTransferSyntax(self.NDR64Syntax)\n            isNDR64 = True\n        else:\n            isNDR64 = False\n\n        self.call(request.opnum, request, uuid)\n        answer = self.recv()\n\n        __import__(request.__module__)\n        module = sys.modules[request.__module__]\n        respClass = getattr(module, request.__class__.__name__ + 'Response')\n\n        if  answer[-4:] != b'\\x00\\x00\\x00\\x00' and checkError is True:\n            error_code = unpack('<L', answer[-4:])[0]\n            if error_code in rpc_status_codes:\n                # This is an error we can handle\n                exception = DCERPCException(error_code = error_code)\n            else:    \n                sessionErrorClass = getattr(module, 'DCERPCSessionError')\n                try:\n                    # Try to unpack the answer, even if it is an error, it works most of the times\n                    response =  respClass(answer, isNDR64 = isNDR64)\n                except:\n                    # No luck :(\n                    exception = sessionErrorClass(error_code = error_code)\n                else:\n                    exception = sessionErrorClass(packet = response, error_code = error_code)\n            raise exception\n        else:\n            response =  respClass(answer, isNDR64 = isNDR64)\n            return response",
  "class DCERPC_v4(DCERPC):\n    pass",
  "class DCERPC_v5(DCERPC):\n    def __init__(self, transport):\n        DCERPC.__init__(self, transport)\n        self.__auth_level = RPC_C_AUTHN_LEVEL_NONE\n        self.__auth_type = RPC_C_AUTHN_WINNT\n        self.__auth_type_callback = None\n        # Flags of the authenticated session. We will need them throughout the connection\n        self.__auth_flags = 0\n        self.__username = None\n        self.__password = None\n        self.__domain = ''\n        self.__lmhash = ''\n        self.__nthash = ''\n        self.__aesKey = ''\n        self.__TGT    = None\n        self.__TGS    = None\n        \n        self.__clientSigningKey = b''\n        self.__serverSigningKey = b''\n        self.__clientSealingKey = b''\n        self.__clientSealingHandle = b''\n        self.__serverSealingKey = b''\n        self.__serverSealingHandle = b''\n        self.__sequence = 0   \n\n        self.transfer_syntax = uuidtup_to_bin(('8a885d04-1ceb-11c9-9fe8-08002b104860', '2.0'))\n        self.__callid = 1\n        self._ctx = 0\n        self.__sessionKey = None\n        self.__max_xmit_size  = 0\n        self.__flags = 0\n        self.__cipher = None\n        self.__confounder = b''\n        self.__gss = None\n\n    def set_session_key(self, session_key):\n        self.__sessionKey = session_key\n\n    def get_session_key(self):\n        return self.__sessionKey\n\n    def set_auth_level(self, auth_level):\n        self.__auth_level = auth_level\n\n    def set_auth_type(self, auth_type, callback = None):\n        self.__auth_type = auth_type\n        self.__auth_type_callback = callback\n\n    def get_auth_type(self):\n        return self.__auth_type\n\n    def set_max_tfrag(self, size):\n        self.__max_xmit_size = size\n    \n    def get_credentials(self):\n        return self.__username, self.__password, self.__domain, self.__lmhash, self.__nthash, self.__aesKey, self.__TGT, self.__TGS\n\n    def set_credentials(self, username, password, domain = '', lmhash = '', nthash = '', aesKey = '', TGT = None, TGS = None):\n        self.set_auth_level(RPC_C_AUTHN_LEVEL_CONNECT)\n        self.__username = username\n        self.__password = password\n        self.__domain   = domain\n        self.__aesKey   = aesKey\n        self.__TGT      = TGT\n        self.__TGS      = TGS\n        if lmhash != '' or nthash != '':\n            if len(lmhash) % 2:\n                lmhash = '0%s' % lmhash\n            if len(nthash) % 2:\n                nthash = '0%s' % nthash\n            try: # just in case they were converted already\n                self.__lmhash = unhexlify(lmhash)\n                self.__nthash = unhexlify(nthash)\n            except:\n                self.__lmhash = lmhash\n                self.__nthash = nthash\n                pass\n\n    def bind(self, iface_uuid, alter = 0, bogus_binds = 0, transfer_syntax = ('8a885d04-1ceb-11c9-9fe8-08002b104860', '2.0')):\n        bind = MSRPCBind()\n        #item['TransferSyntax']['Version'] = 1\n        ctx = self._ctx\n        for i in range(bogus_binds):\n            item = CtxItem()\n            item['ContextID'] = ctx\n            item['TransItems'] = 1\n            item['ContextID'] = ctx\n            # We generate random UUIDs for bogus binds\n            item['AbstractSyntax'] = generate() + stringver_to_bin('2.0')\n            item['TransferSyntax'] = uuidtup_to_bin(transfer_syntax)\n            bind.addCtxItem(item)\n            self._ctx += 1\n            ctx += 1\n\n        # The true one :)\n        item = CtxItem()\n        item['AbstractSyntax'] = iface_uuid\n        item['TransferSyntax'] = uuidtup_to_bin(transfer_syntax)\n        item['ContextID'] = ctx\n        item['TransItems'] = 1\n        bind.addCtxItem(item)\n\n        packet = MSRPCHeader()\n        packet['type'] = MSRPC_BIND\n        packet['pduData'] = bind.getData()\n        packet['call_id'] = self.__callid\n\n        if alter:\n            packet['type'] = MSRPC_ALTERCTX\n\n        if self.__auth_level != RPC_C_AUTHN_LEVEL_NONE:\n            if (self.__username is None) or (self.__password is None):\n                self.__username, self.__password, self.__domain, self.__lmhash, self.__nthash, self.__aesKey, self.__TGT, self.__TGS = self._transport.get_credentials()\n\n            if self.__auth_type == RPC_C_AUTHN_WINNT:\n                auth = ntlm.getNTLMSSPType1('', '', signingRequired=True,\n                                            use_ntlmv2=self._transport.doesSupportNTLMv2())\n            elif self.__auth_type == RPC_C_AUTHN_NETLOGON:\n                from impacket.dcerpc.v5 import nrpc\n                auth = nrpc.getSSPType1(self.__username[:-1], self.__domain, signingRequired=True)\n            elif self.__auth_type == RPC_C_AUTHN_GSS_NEGOTIATE:\n                self.__cipher, self.__sessionKey, auth = kerberosv5.getKerberosType1(self.__username, self.__password,\n                                                                                     self.__domain, self.__lmhash,\n                                                                                     self.__nthash, self.__aesKey,\n                                                                                     self.__TGT, self.__TGS,\n                                                                                     self._transport.getRemoteName(),\n                                                                                     self._transport.get_kdcHost())\n            else:\n                raise DCERPCException('Unsupported auth_type 0x%x' % self.__auth_type)\n\n            sec_trailer = SEC_TRAILER()\n            sec_trailer['auth_type']   = self.__auth_type\n            sec_trailer['auth_level']  = self.__auth_level\n            sec_trailer['auth_ctx_id'] = self._ctx + 79231 \n\n            pad = (4 - (len(packet.get_packet()) % 4)) % 4\n            if pad != 0:\n               packet['pduData'] += b'\\xFF'*pad\n               sec_trailer['auth_pad_len']=pad\n\n            packet['sec_trailer'] = sec_trailer\n            packet['auth_data'] = auth\n\n        self._transport.send(packet.get_packet())\n\n        s = self._transport.recv()\n\n        if s != 0:\n            resp = MSRPCHeader(s)\n        else:\n            return 0 #mmm why not None?\n\n        if resp['type'] == MSRPC_BINDACK or resp['type'] == MSRPC_ALTERCTX_R:\n            bindResp = MSRPCBindAck(resp.getData())\n        elif resp['type'] == MSRPC_BINDNAK or resp['type'] == MSRPC_FAULT:\n            if resp['type'] == MSRPC_FAULT:\n                resp = MSRPCRespHeader(resp.getData())\n                status_code = unpack('<L', resp['pduData'][:4])[0]\n            else:\n                resp = MSRPCBindNak(resp['pduData'])\n                status_code = resp['RejectedReason']\n            if status_code in rpc_status_codes:\n                raise DCERPCException(error_code = status_code)\n            elif status_code in rpc_provider_reason:\n                raise DCERPCException(\"Bind context rejected: %s\" % rpc_provider_reason[status_code])\n            else:\n                raise DCERPCException('Unknown DCE RPC fault status code: %.8x' % status_code)\n        else:\n            raise DCERPCException('Unknown DCE RPC packet type received: %d' % resp['type'])\n\n        # check ack results for each context, except for the bogus ones\n        for ctx in range(bogus_binds+1,bindResp['ctx_num']+1):\n            ctxItems = bindResp.getCtxItem(ctx)\n            if ctxItems['Result'] != 0:\n                msg = \"Bind context %d rejected: \" % ctx\n                msg += rpc_cont_def_result.get(ctxItems['Result'], 'Unknown DCE RPC context result code: %.4x' % ctxItems['Result'])\n                msg += \"; \"\n                reason = bindResp.getCtxItem(ctx)['Reason']\n                msg += rpc_provider_reason.get(reason, 'Unknown reason code: %.4x' % reason)\n                if (ctxItems['Result'], reason) == (2, 1): # provider_rejection, abstract syntax not supported\n                    msg += \" (this usually means the interface isn't listening on the given endpoint)\"\n                raise DCERPCException(msg)\n\n            # Save the transfer syntax for later use\n            self.transfer_syntax = ctxItems['TransferSyntax'] \n\n        # The received transmit size becomes the client's receive size, and the received receive size becomes the client's transmit size.\n        self.__max_xmit_size = bindResp['max_rfrag']\n\n        if self.__auth_level != RPC_C_AUTHN_LEVEL_NONE:\n            if self.__auth_type == RPC_C_AUTHN_WINNT:\n                response, self.__sessionKey = ntlm.getNTLMSSPType3(auth, bindResp['auth_data'], self.__username,\n                                                                   self.__password, self.__domain, self.__lmhash,\n                                                                   self.__nthash,\n                                                                   use_ntlmv2=self._transport.doesSupportNTLMv2())\n                self.__flags = response['flags']\n            elif self.__auth_type == RPC_C_AUTHN_NETLOGON:\n                response = None\n            elif self.__auth_type == RPC_C_AUTHN_GSS_NEGOTIATE:\n                self.__cipher, self.__sessionKey, response = kerberosv5.getKerberosType3(self.__cipher,\n                                                                                         self.__sessionKey,\n                                                                                         bindResp['auth_data'])\n\n            self.__sequence = 0\n\n            if self.__auth_level in (RPC_C_AUTHN_LEVEL_CONNECT, RPC_C_AUTHN_LEVEL_PKT_INTEGRITY, RPC_C_AUTHN_LEVEL_PKT_PRIVACY):\n                if self.__auth_type == RPC_C_AUTHN_WINNT:\n                    if self.__flags & ntlm.NTLMSSP_NEGOTIATE_EXTENDED_SESSIONSECURITY:\n                        self.__clientSigningKey = ntlm.SIGNKEY(self.__flags, self.__sessionKey)\n                        self.__serverSigningKey = ntlm.SIGNKEY(self.__flags, self.__sessionKey,b\"Server\")\n                        self.__clientSealingKey = ntlm.SEALKEY(self.__flags, self.__sessionKey)\n                        self.__serverSealingKey = ntlm.SEALKEY(self.__flags, self.__sessionKey,b\"Server\")\n                        # Preparing the keys handle states\n                        cipher3 = ARC4.new(self.__clientSealingKey)\n                        self.__clientSealingHandle = cipher3.encrypt\n                        cipher4 = ARC4.new(self.__serverSealingKey)\n                        self.__serverSealingHandle = cipher4.encrypt\n                    else:\n                        # Same key for everything\n                        self.__clientSigningKey = self.__sessionKey\n                        self.__serverSigningKey = self.__sessionKey\n                        self.__clientSealingKey = self.__sessionKey\n                        self.__serverSealingKey = self.__sessionKey\n                        cipher = ARC4.new(self.__clientSigningKey)\n                        self.__clientSealingHandle = cipher.encrypt\n                        self.__serverSealingHandle = cipher.encrypt\n                elif self.__auth_type == RPC_C_AUTHN_NETLOGON:\n                    if self.__auth_level == RPC_C_AUTHN_LEVEL_PKT_INTEGRITY:\n                        self.__confounder = b''\n                    else:\n                        self.__confounder = b'12345678'\n\n            sec_trailer = SEC_TRAILER()\n            sec_trailer['auth_type'] = self.__auth_type\n            sec_trailer['auth_level'] = self.__auth_level\n            sec_trailer['auth_ctx_id'] = self._ctx + 79231 \n\n            if response is not None:\n                if self.__auth_type == RPC_C_AUTHN_GSS_NEGOTIATE:\n                    alter_ctx = MSRPCHeader()\n                    alter_ctx['type'] = MSRPC_ALTERCTX\n                    alter_ctx['pduData'] = bind.getData()\n                    alter_ctx['sec_trailer'] = sec_trailer\n                    alter_ctx['auth_data'] = response\n                    self._transport.send(alter_ctx.get_packet(), forceWriteAndx = 1)\n                    self.__gss = gssapi.GSSAPI(self.__cipher)\n                    self.__sequence = 0\n                    self.recv()\n                    self.__sequence = 0\n                else:\n                    auth3 = MSRPCHeader()\n                    auth3['type'] = MSRPC_AUTH3\n                    # pad (4 bytes): Can be set to any arbitrary value when set and MUST be \n                    # ignored on receipt. The pad field MUST be immediately followed by a \n                    # sec_trailer structure whose layout, location, and alignment are as \n                    # specified in section 2.2.2.11\n                    auth3['pduData'] = b'    '\n                    auth3['sec_trailer'] = sec_trailer\n                    auth3['auth_data'] = response.getData()\n\n                    # Use the same call_id\n                    self.__callid = resp['call_id']\n                    auth3['call_id'] = self.__callid\n                    self._transport.send(auth3.get_packet(), forceWriteAndx = 1)\n\n            self.__callid += 1\n\n        return resp     # means packet is signed, if verifier is wrong it fails\n\n    def _transport_send(self, rpc_packet, forceWriteAndx = 0, forceRecv = 0):\n        rpc_packet['ctx_id'] = self._ctx\n        rpc_packet['sec_trailer'] = b''\n        rpc_packet['auth_data'] = b''\n\n        if self.__auth_level in [RPC_C_AUTHN_LEVEL_PKT_INTEGRITY, RPC_C_AUTHN_LEVEL_PKT_PRIVACY]:\n            # Dummy verifier, just for the calculations\n            sec_trailer = SEC_TRAILER()\n            sec_trailer['auth_type'] = self.__auth_type\n            sec_trailer['auth_level'] = self.__auth_level\n            sec_trailer['auth_pad_len'] = 0\n            sec_trailer['auth_ctx_id'] = self._ctx + 79231 \n\n            pad = (4 - (len(rpc_packet.get_packet()) % 4)) % 4\n            if pad != 0:\n                rpc_packet['pduData'] += b'\\xBB'*pad\n                sec_trailer['auth_pad_len']=pad\n\n            rpc_packet['sec_trailer'] = sec_trailer.getData()\n            rpc_packet['auth_data'] = b' '*16\n\n            plain_data = rpc_packet['pduData']\n            if self.__auth_level == RPC_C_AUTHN_LEVEL_PKT_PRIVACY:\n                if self.__auth_type == RPC_C_AUTHN_WINNT:\n                    if self.__flags & ntlm.NTLMSSP_NEGOTIATE_EXTENDED_SESSIONSECURITY:\n                        # When NTLM2 is on, we sign the whole pdu, but encrypt just\n                        # the data, not the dcerpc header. Weird..\n                        sealedMessage, signature =  ntlm.SEAL(self.__flags, \n                               self.__clientSigningKey, \n                               self.__clientSealingKey,  \n                               rpc_packet.get_packet()[:-16], \n                               plain_data, \n                               self.__sequence, \n                               self.__clientSealingHandle)\n                    else:\n                        sealedMessage, signature =  ntlm.SEAL(self.__flags, \n                               self.__clientSigningKey, \n                               self.__clientSealingKey,  \n                               plain_data, \n                               plain_data, \n                               self.__sequence, \n                               self.__clientSealingHandle)\n                elif self.__auth_type == RPC_C_AUTHN_NETLOGON:\n                    from impacket.dcerpc.v5 import nrpc\n                    sealedMessage, signature = nrpc.SEAL(plain_data, self.__confounder, self.__sequence, self.__sessionKey, False)\n                elif self.__auth_type == RPC_C_AUTHN_GSS_NEGOTIATE:\n                    sealedMessage, signature = self.__gss.GSS_Wrap(self.__sessionKey, plain_data, self.__sequence)\n\n                rpc_packet['pduData'] = sealedMessage\n            elif self.__auth_level == RPC_C_AUTHN_LEVEL_PKT_INTEGRITY: \n                if self.__auth_type == RPC_C_AUTHN_WINNT:\n                    if self.__flags & ntlm.NTLMSSP_NEGOTIATE_EXTENDED_SESSIONSECURITY:\n                        # Interesting thing.. with NTLM2, what is is signed is the \n                        # whole PDU, not just the data\n                        signature =  ntlm.SIGN(self.__flags,\n                               self.__clientSigningKey, \n                               rpc_packet.get_packet()[:-16], \n                               self.__sequence, \n                               self.__clientSealingHandle)\n                    else:\n                        signature =  ntlm.SIGN(self.__flags, \n                               self.__clientSigningKey, \n                               plain_data, \n                               self.__sequence, \n                               self.__clientSealingHandle)\n                elif self.__auth_type == RPC_C_AUTHN_NETLOGON:\n                    from impacket.dcerpc.v5 import nrpc\n                    signature = nrpc.SIGN(plain_data, \n                           self.__confounder, \n                           self.__sequence, \n                           self.__sessionKey, \n                           False)\n                elif self.__auth_type == RPC_C_AUTHN_GSS_NEGOTIATE:\n                    signature = self.__gss.GSS_GetMIC(self.__sessionKey, plain_data, self.__sequence)\n\n            rpc_packet['sec_trailer'] = sec_trailer.getData()\n            rpc_packet['auth_data'] = signature\n\n            self.__sequence += 1\n\n        self._transport.send(rpc_packet.get_packet(), forceWriteAndx = forceWriteAndx, forceRecv = forceRecv)\n\n    def send(self, data):\n        if isinstance(data, MSRPCHeader) is not True:\n            # Must be an Impacket, transform to structure\n            data = DCERPC_RawCall(data.OP_NUM, data.get_packet())\n\n        try:\n            if data['uuid'] != b'':\n                data['flags'] |= PFC_OBJECT_UUID\n        except:\n            # Structure doesn't have uuid\n            pass\n        data['ctx_id'] = self._ctx\n        data['call_id'] = self.__callid\n        data['alloc_hint'] = len(data['pduData'])\n        # We should fragment PDUs if:\n        # 1) Payload exceeds __max_xmit_size received during BIND response\n        # 2) We'e explicitly fragmenting packets with lower values\n        should_fragment = False\n\n        # Let's decide what will drive fragmentation for this request\n        if self._max_user_frag > 0:\n            # User set a frag size, let's compare it with the max transmit size agreed when binding the interface\n            fragment_size = min(self._max_user_frag, self.__max_xmit_size)\n        else:\n            fragment_size = self.__max_xmit_size\n\n        # Sanity check. Fragmentation can't be too low, otherwise sec_trailer won't fit\n\n        if self.__auth_level in [RPC_C_AUTHN_LEVEL_PKT_INTEGRITY, RPC_C_AUTHN_LEVEL_PKT_PRIVACY]:\n            if fragment_size <= 8:\n                # Minimum pdu fragment size is 8, important when doing PKT_INTEGRITY/PRIVACY. We need a minimum size of 8\n                # (Kerberos)\n                fragment_size = 8\n\n        # ToDo: Better calculate the size needed. Now I'm setting a number that surely is enough for Kerberos and NTLM\n        # ToDo: trailers, both for INTEGRITY and PRIVACY. This means we're not truly honoring the user's frag request.\n        if len(data['pduData']) + 128 > fragment_size:\n            should_fragment = True\n            if fragment_size+128 > self.__max_xmit_size:\n                fragment_size = self.__max_xmit_size - 128\n\n        if should_fragment:\n            packet = data['pduData']\n            offset = 0\n\n            while 1:\n                toSend = packet[offset:offset+fragment_size]\n                if not toSend:\n                    break\n                if offset == 0:\n                    data['flags'] |= PFC_FIRST_FRAG\n                else:\n                    data['flags'] &= (~PFC_FIRST_FRAG)\n                offset += len(toSend)\n                if offset >= len(packet):\n                    data['flags'] |= PFC_LAST_FRAG\n                else:\n                    data['flags'] &= (~PFC_LAST_FRAG)\n                data['pduData'] = toSend\n                self._transport_send(data, forceWriteAndx = 1, forceRecv =data['flags'] & PFC_LAST_FRAG)\n        else:\n            self._transport_send(data)\n        self.__callid += 1\n\n    def recv(self):\n        finished = False\n        forceRecv = 0\n        retAnswer = b''\n        while not finished:\n            # At least give me the MSRPCRespHeader, especially important for \n            # TCP/UDP Transports\n            response_data = self._transport.recv(forceRecv, count=MSRPCRespHeader._SIZE)\n            response_header = MSRPCRespHeader(response_data)\n            # Ok, there might be situation, especially with large packets, that \n            # the transport layer didn't send us the full packet's contents\n            # So we gotta check we received it all\n            while len(response_data) < response_header['frag_len']:\n               response_data += self._transport.recv(forceRecv, count=(response_header['frag_len']-len(response_data)))\n\n            off = response_header.get_header_size()\n\n            if response_header['type'] == MSRPC_FAULT and response_header['frag_len'] >= off+4:\n                status_code = unpack(\"<L\",response_data[off:off+4])[0]\n                if status_code in rpc_status_codes:\n                    raise DCERPCException(rpc_status_codes[status_code])\n                elif status_code & 0xffff in rpc_status_codes:\n                    raise DCERPCException(rpc_status_codes[status_code & 0xffff])\n                else:\n                    if status_code in hresult_errors.ERROR_MESSAGES:\n                        error_msg_short = hresult_errors.ERROR_MESSAGES[status_code][0]\n                        error_msg_verbose = hresult_errors.ERROR_MESSAGES[status_code][1] \n                        raise DCERPCException('%s - %s' % (error_msg_short, error_msg_verbose))\n                    else:\n                        raise DCERPCException('Unknown DCE RPC fault status code: %.8x' % status_code)\n\n            if response_header['flags'] & PFC_LAST_FRAG:\n                # No need to reassembly DCERPC\n                finished = True\n            else:\n                # Forcing Read Recv, we need more packets!\n                forceRecv = 1\n\n            answer = response_data[off:]\n            auth_len = response_header['auth_len']\n            if auth_len:\n                auth_len += 8\n                auth_data = answer[-auth_len:]\n                sec_trailer = SEC_TRAILER(data = auth_data)\n                answer = answer[:-auth_len]\n\n                if sec_trailer['auth_level'] == RPC_C_AUTHN_LEVEL_PKT_PRIVACY:\n                    if self.__auth_type == RPC_C_AUTHN_WINNT:\n                        if self.__flags & ntlm.NTLMSSP_NEGOTIATE_EXTENDED_SESSIONSECURITY:\n                            # TODO: FIX THIS, it's not calculating the signature well\n                            # Since I'm not testing it we don't care... yet\n                            answer, signature =  ntlm.SEAL(self.__flags, \n                                    self.__serverSigningKey, \n                                    self.__serverSealingKey,  \n                                    answer, \n                                    answer, \n                                    self.__sequence, \n                                    self.__serverSealingHandle)\n                        else:\n                            answer, signature = ntlm.SEAL(self.__flags, \n                                    self.__serverSigningKey, \n                                    self.__serverSealingKey, \n                                    answer, \n                                    answer, \n                                    self.__sequence, \n                                    self.__serverSealingHandle)\n                            self.__sequence += 1\n                    elif self.__auth_type == RPC_C_AUTHN_NETLOGON:\n                        from impacket.dcerpc.v5 import nrpc\n                        answer, cfounder = nrpc.UNSEAL(answer, \n                               auth_data[len(sec_trailer):],\n                               self.__sessionKey, \n                               False)\n                        self.__sequence += 1\n                    elif self.__auth_type == RPC_C_AUTHN_GSS_NEGOTIATE:\n                        if self.__sequence > 0:\n                            answer, cfounder = self.__gss.GSS_Unwrap(self.__sessionKey, answer, self.__sequence,\n                                                                     direction='init', authData=auth_data)\n\n                elif sec_trailer['auth_level'] == RPC_C_AUTHN_LEVEL_PKT_INTEGRITY:\n                    if self.__auth_type == RPC_C_AUTHN_WINNT:\n                        ntlmssp = auth_data[12:]\n                        if self.__flags & ntlm.NTLMSSP_NEGOTIATE_EXTENDED_SESSIONSECURITY:\n                            signature =  ntlm.SIGN(self.__flags, \n                                    self.__serverSigningKey, \n                                    answer, \n                                    self.__sequence, \n                                    self.__serverSealingHandle)\n                        else:\n                            signature = ntlm.SIGN(self.__flags, \n                                    self.__serverSigningKey, \n                                    ntlmssp, \n                                    self.__sequence, \n                                    self.__serverSealingHandle)\n                            # Yes.. NTLM2 doesn't increment sequence when receiving\n                            # the packet :P\n                            self.__sequence += 1\n                    elif self.__auth_type == RPC_C_AUTHN_NETLOGON:\n                        from impacket.dcerpc.v5 import nrpc\n                        ntlmssp = auth_data[12:]\n                        signature = nrpc.SIGN(ntlmssp, \n                               self.__confounder, \n                               self.__sequence, \n                               self.__sessionKey, \n                               False)\n                        self.__sequence += 1\n                    elif self.__auth_type == RPC_C_AUTHN_GSS_NEGOTIATE:\n                        # Do NOT increment the sequence number when Signing Kerberos\n                        #self.__sequence += 1\n                        pass\n\n                \n                if sec_trailer['auth_pad_len']:\n                    answer = answer[:-sec_trailer['auth_pad_len']]\n              \n            retAnswer += answer\n        return retAnswer\n\n    def alter_ctx(self, newUID, bogus_binds = 0):\n        answer = self.__class__(self._transport)\n\n        answer.set_credentials(self.__username, self.__password, self.__domain, self.__lmhash, self.__nthash,\n                               self.__aesKey, self.__TGT, self.__TGS)\n        answer.set_auth_type(self.__auth_type)\n        answer.set_auth_level(self.__auth_level)\n\n        answer.set_ctx_id(self._ctx+1)\n        answer.__callid = self.__callid\n        answer.bind(newUID, alter = 1, bogus_binds = bogus_binds, transfer_syntax = bin_to_uuidtup(self.transfer_syntax))\n        return answer",
  "class DCERPC_RawCall(MSRPCRequestHeader):\n    def __init__(self, op_num, data = b'', uuid=None):\n        MSRPCRequestHeader.__init__(self)\n        self['op_num'] = op_num\n        self['pduData'] = data\n        if uuid is not None:\n            self['flags'] |= PFC_OBJECT_UUID\n            self['uuid'] = uuid\n\n    def setData(self, data):\n        self['pduData'] = data",
  "class CommonHeader(NDRSTRUCT):\n    structure = (\n        ('Version', UCHAR),\n        ('Endianness', UCHAR),\n        ('CommonHeaderLength', USHORT),\n        ('Filler', ULONG),\n    )\n    def __init__(self, data = None,isNDR64 = False):\n        NDRSTRUCT.__init__(self, data, isNDR64)\n        if data is None:\n            self['Version'] = 1\n            self['Endianness'] = 0x10\n            self['CommonHeaderLength'] = 8\n            self['Filler'] = 0xcccccccc",
  "class PrivateHeader(NDRSTRUCT):\n    structure = (\n        ('ObjectBufferLength', ULONG),\n        ('Filler', ULONG),\n    )\n    def __init__(self, data = None,isNDR64 = False):\n        NDRSTRUCT.__init__(self, data, isNDR64)\n        if data is None:\n            self['Filler'] = 0xcccccccc",
  "class TypeSerialization1(NDRSTRUCT):\n    commonHdr = (\n        ('CommonHeader', CommonHeader),\n        ('PrivateHeader', PrivateHeader),\n    )\n    def getData(self, soFar = 0):\n        self['PrivateHeader']['ObjectBufferLength'] = len(NDRSTRUCT.getData(self, soFar)) + len(\n            NDRSTRUCT.getDataReferents(self, soFar)) - len(self['CommonHeader']) - len(self['PrivateHeader'])\n        return NDRSTRUCT.getData(self, soFar)",
  "class DCERPCServer(Thread):\n    \"\"\"\n    A minimalistic DCERPC Server, mainly used by the smbserver, for now. Might be useful\n    for other purposes in the future, but we should do it way stronger.\n    If you want to implement a DCE Interface Server, use this class as the base class\n    \"\"\"\n    def __init__(self):\n        Thread.__init__(self)\n        self._listenPort    = 0\n        self._listenAddress = '127.0.0.1'\n        self._listenUUIDS   = {}\n        self._boundUUID     = b''\n        self._sock          = None\n        self._clientSock    = None\n        self._callid        = 1\n        self._max_frag       = None\n        self._max_xmit_size = 4280\n        self.__log = LOG\n        self._sock = socket.socket()\n        self._sock.bind((self._listenAddress,self._listenPort))\n\n    def log(self, msg, level=logging.INFO):\n        self.__log.log(level,msg)\n\n    def addCallbacks(self, ifaceUUID, secondaryAddr, callbacks):\n        \"\"\"\n        adds a call back to a UUID/opnum call\n        \n        :param uuid ifaceUUID: the interface UUID\n        :param string secondaryAddr: the secondary address to answer as part of the bind request (e.g. \\\\\\\\PIPE\\\\\\\\srvsvc)\n        :param dict callbacks: the callbacks for each opnum. Format is [opnum] = callback\n        \"\"\"\n        self._listenUUIDS[uuidtup_to_bin(ifaceUUID)] = {}\n        self._listenUUIDS[uuidtup_to_bin(ifaceUUID)]['SecondaryAddr'] = secondaryAddr\n        self._listenUUIDS[uuidtup_to_bin(ifaceUUID)]['CallBacks'] = callbacks\n        self.log(\"Callback added for UUID %s V:%s\" % ifaceUUID)\n\n    def setListenPort(self, portNum):\n        self._listenPort = portNum\n        self._sock = socket.socket()\n        self._sock.bind((self._listenAddress,self._listenPort))\n\n    def getListenPort(self):\n        return self._sock.getsockname()[1]\n\n    def recv(self):\n        finished = False\n        retAnswer = b''\n        response_data = b''\n        while not finished:\n            # At least give me the MSRPCRespHeader, especially important for TCP/UDP Transports\n            response_data = self._clientSock.recv(MSRPCRespHeader._SIZE)\n            # No data?, connection might have closed\n            if response_data == b'':\n                return None\n            response_header = MSRPCRespHeader(response_data)\n            # Ok, there might be situation, especially with large packets, \n            # that the transport layer didn't send us the full packet's contents\n            # So we gotta check we received it all\n            while len(response_data) < response_header['frag_len']:\n               response_data += self._clientSock.recv(response_header['frag_len']-len(response_data))\n            response_header = MSRPCRespHeader(response_data)\n            if response_header['flags'] & PFC_LAST_FRAG:\n                # No need to reassembly DCERPC\n                finished = True\n            answer = response_header['pduData']\n            auth_len = response_header['auth_len']\n            if auth_len:\n                auth_len += 8\n                auth_data = answer[-auth_len:]\n                sec_trailer = SEC_TRAILER(data = auth_data)\n                answer = answer[:-auth_len]\n                if sec_trailer['auth_pad_len']:\n                    answer = answer[:-sec_trailer['auth_pad_len']]\n              \n            retAnswer += answer\n        return response_data\n    \n    def run(self):\n        self._sock.listen(10)\n        while True:\n            self._clientSock, address = self._sock.accept()\n            try:\n                while True:\n                    data = self.recv()\n                    if data is None:\n                        # No data.. connection closed\n                        break\n                    answer = self.processRequest(data)\n                    if answer is not None:\n                        self.send(answer)\n            except Exception:\n                #import traceback\n                #traceback.print_exc()\n                pass\n            self._clientSock.close()\n\n    def send(self, data):\n        max_frag       = self._max_frag\n        if len(data['pduData']) > self._max_xmit_size - 32:\n            max_frag   = self._max_xmit_size - 32    # XXX: 32 is a safe margin for auth data\n\n        if self._max_frag:\n            max_frag   = min(max_frag, self._max_frag)\n        if max_frag and len(data['pduData']) > 0:\n            packet     = data['pduData']\n            offset     = 0\n            while 1:\n                toSend = packet[offset:offset+max_frag]\n                if not toSend:\n                    break\n                flags  = 0\n                if offset == 0:\n                    flags |= PFC_FIRST_FRAG\n                offset += len(toSend)\n                if offset == len(packet):\n                    flags |= PFC_LAST_FRAG\n                data['flags']   = flags\n                data['pduData'] = toSend\n                self._clientSock.send(data.get_packet())\n        else:\n            self._clientSock.send(data.get_packet())\n        self._callid += 1\n\n    def bind(self,packet, bind):\n        # Standard NDR Representation\n        NDRSyntax   = ('8a885d04-1ceb-11c9-9fe8-08002b104860', '2.0')\n        resp = MSRPCBindAck()\n\n        resp['type']             = MSRPC_BINDACK\n        resp['flags']            = packet['flags']\n        resp['frag_len']         = 0\n        resp['auth_len']         = 0\n        resp['auth_data']        = b''\n        resp['call_id']          = packet['call_id'] \n        resp['max_tfrag']        = bind['max_tfrag']\n        resp['max_rfrag']        = bind['max_rfrag']\n        resp['assoc_group']      = 0x1234\n        resp['ctx_num']          = 0\n\n        data      = bind['ctx_items']\n        ctx_items = b''\n        resp['SecondaryAddrLen'] = 0\n        for i in range(bind['ctx_num']):\n            result = MSRPC_CONT_RESULT_USER_REJECT\n            item   = CtxItem(data)\n            data   = data[len(item):]\n\n            # First we check the Transfer Syntax is NDR32, what we support\n            if item['TransferSyntax'] == uuidtup_to_bin(NDRSyntax):\n                # Now Check if the interface is what we listen\n                reason = 1 # Default, Abstract Syntax not supported\n                for j in self._listenUUIDS:\n                    if item['AbstractSyntax'] == j:\n                        # Match, we accept the bind request\n                        resp['SecondaryAddr']    = self._listenUUIDS[item['AbstractSyntax']]['SecondaryAddr']\n                        resp['SecondaryAddrLen'] = len(resp['SecondaryAddr'])+1\n                        reason           = 0\n                        self._boundUUID = j\n            else:\n                # Fail the bind request for this context\n                reason = 2 # Transfer Syntax not supported\n            if reason == 0:\n               result = MSRPC_CONT_RESULT_ACCEPT\n            if reason == 1:\n                LOG.error('Bind request for an unsupported interface %s' % bin_to_uuidtup(item['AbstractSyntax']))\n\n            resp['ctx_num']             += 1\n            itemResult                   = CtxItemResult()\n            itemResult['Result']         = result\n            itemResult['Reason']         = reason\n            itemResult['TransferSyntax'] = uuidtup_to_bin(NDRSyntax)\n            ctx_items                   += itemResult.getData()\n\n        resp['Pad']              ='A'*((4-((resp[\"SecondaryAddrLen\"]+MSRPCBindAck._SIZE) % 4))%4)\n        resp['ctx_items'] = ctx_items\n        resp['frag_len']  = len(resp.getData())\n\n        self._clientSock.send(resp.getData())\n        return None\n\n    def processRequest(self,data):\n        packet = MSRPCHeader(data)\n        if packet['type'] == MSRPC_BIND:\n            bind   = MSRPCBind(packet['pduData'])\n            self.bind(packet, bind)\n            packet = None\n        elif packet['type'] == MSRPC_REQUEST:\n            request          = MSRPCRequestHeader(data)\n            response         = MSRPCRespHeader(data)\n            response['type'] = MSRPC_RESPONSE\n            # Serve the opnum requested, if not, fails\n            if request['op_num'] in self._listenUUIDS[self._boundUUID]['CallBacks']:\n                # Call the function \n                returnData          = self._listenUUIDS[self._boundUUID]['CallBacks'][request['op_num']](request['pduData'])\n                response['pduData'] = returnData\n            else:\n                LOG.error('Unsupported DCERPC opnum %d called for interface %s' % (request['op_num'], bin_to_uuidtup(self._boundUUID)))\n                response['type']    = MSRPC_FAULT\n                response['pduData'] = pack('<L',0x000006E4)\n            response['frag_len'] = len(response)\n            return response\n        else:\n            # Defaults to a fault\n            packet         = MSRPCRespHeader(data)\n            packet['type'] = MSRPC_FAULT\n\n        return packet",
  "def __init__(self, error_string=None, error_code=None, packet=None):\n        \"\"\"\n        :param string error_string: A string you want to show explaining the exception. Otherwise the default ones will be used\n        :param integer error_code: the error_code if we're using a dictionary with error's descriptions\n        :param NDR packet: if successfully decoded, the NDR packet of the response call. This could probably have useful\n        information\n        \"\"\"\n        Exception.__init__(self)\n        self.packet = packet\n        self.error_string = error_string\n        if packet is not None:\n            try:\n                self.error_code = packet['ErrorCode']\n            except:\n                self.error_code = error_code\n        else:\n            self.error_code = error_code",
  "def get_error_code( self ):\n        return self.error_code",
  "def get_packet( self ):\n        return self.packet",
  "def __str__( self ):\n        key = self.error_code\n        if self.error_string is not None:\n            return self.error_string\n        if key in rpc_status_codes:\n            error_msg_short = rpc_status_codes[key]\n            return 'DCERPC Runtime Error: code: 0x%x - %s ' % (self.error_code, error_msg_short)\n        else:\n            return 'DCERPC Runtime Error: unknown error code: 0x%x' % self.error_code",
  "def __init__(self, data = None, alignment = 0):\n        Structure.__init__(self,data, alignment)\n        if data is None:\n            self['ver_major'] = 5\n            self['ver_minor'] = 0\n            self['flags'] = PFC_FIRST_FRAG | PFC_LAST_FRAG\n            self['type'] = MSRPC_REQUEST\n            self.__frag_len_set = 0\n            self['auth_len'] = 0\n            self['pduData'] = b''\n            self['auth_data'] = b''\n            self['sec_trailer'] = b''\n            self['pad'] = b''",
  "def get_header_size(self):\n        return self._SIZE + (16 if (self[\"flags\"] & PFC_OBJECT_UUID) > 0 else 0)",
  "def get_packet(self):\n        if self['auth_data'] != b'':\n            self['auth_len'] = len(self['auth_data'])\n        # The sec_trailer structure MUST be 4-byte aligned with respect to \n        # the beginning of the PDU. Padding octets MUST be used to align the \n        # sec_trailer structure if its natural beginning is not already 4-byte aligned\n        ##self['pad'] = '\\xAA' * (4 - ((self._SIZE + len(self['pduData'])) & 3) & 3)\n\n        return self.getData()",
  "def __init__(self, data = None, alignment = 0):\n        MSRPCHeader.__init__(self, data, alignment)\n        if data is None:\n           self['type'] = MSRPC_REQUEST\n           self['ctx_id'] = 0\n           self['uuid'] = b''",
  "def __init__(self, aBuffer = None, alignment = 0):\n        MSRPCHeader.__init__(self, aBuffer, alignment)\n        if aBuffer is None:\n            self['type'] = MSRPC_RESPONSE\n            self['ctx_id'] = 0",
  "def __init__(self, data = None, alignment = 0):\n        Structure.__init__(self, data, alignment)\n        if data is None:\n            self['max_tfrag'] = 4280\n            self['max_rfrag'] = 4280\n            self['assoc_group'] = 0\n            self['ctx_num'] = 1\n            self['ctx_items'] = b''\n        self.__ctx_items = []",
  "def addCtxItem(self, item):\n        self.__ctx_items.append(item)",
  "def getData(self):\n        self['ctx_num'] = len(self.__ctx_items)\n        for i in self.__ctx_items:\n            self['ctx_items'] += i.getData()\n        return Structure.getData(self)",
  "def __init__(self, data = None, alignment = 0):\n        self.__ctx_items = []\n        MSRPCHeader.__init__(self,data,alignment)\n        if data is None:\n            self['Pad'] = b''\n            self['ctx_items'] = b''\n            self['sec_trailer'] = b''\n            self['auth_data'] = b''",
  "def getCtxItems(self):\n        return self.__ctx_items",
  "def getCtxItem(self,index):\n        return self.__ctx_items[index-1]",
  "def fromString(self, data):\n        Structure.fromString(self,data)\n        # Parse the ctx_items\n        data = self['ctx_items']\n        for i in range(self['ctx_num']):\n            item = CtxItemResult(data)\n            self.__ctx_items.append(item)\n            data = data[len(item):]",
  "def __init__(self, data = None, alignment = 0):\n        Structure.__init__(self,data,alignment)\n        if data is None:\n            self['SupportedVersions'] = b''",
  "def __init__(self,transport):\n        self._transport = transport\n        self.set_ctx_id(0)\n        self._max_user_frag = None\n        self.set_default_max_fragment_size()\n        self._ctx = None",
  "def get_rpc_transport(self):\n        return self._transport",
  "def set_ctx_id(self, ctx_id):\n        self._ctx = ctx_id",
  "def connect(self):\n        return self._transport.connect()",
  "def disconnect(self):\n        return self._transport.disconnect()",
  "def set_max_fragment_size(self, fragment_size):\n        # -1 is default fragment size: 0 for v5, 1300 y pico for v4\n        #  0 is don't fragment\n        #    other values are max fragment size\n        if fragment_size == -1:\n            self.set_default_max_fragment_size()\n        else:\n            self._max_user_frag = fragment_size",
  "def set_default_max_fragment_size(self):\n        # default is 0: don'fragment. v4 will override this method\n        self._max_user_frag = 0",
  "def send(self, data):\n        raise RuntimeError ('virtual method. Not implemented in subclass')",
  "def recv(self):\n        raise RuntimeError ('virtual method. Not implemented in subclass')",
  "def alter_ctx(self, newUID, bogus_binds=''):\n        raise RuntimeError ('virtual method. Not implemented in subclass')",
  "def set_credentials(self, username, password, domain='', lmhash='', nthash='', aesKey='', TGT=None, TGS=None):\n        pass",
  "def set_auth_level(self, auth_level):\n        pass",
  "def set_auth_type(self, auth_type, callback=None):\n        pass",
  "def get_idempotent(self):\n        return 0",
  "def set_idempotent(self, flag):\n        pass",
  "def call(self, function, body, uuid=None):\n        if hasattr(body, 'getData'):\n            return self.send(DCERPC_RawCall(function, body.getData(), uuid))\n        else:\n            return self.send(DCERPC_RawCall(function, body, uuid))",
  "def request(self, request, uuid=None, checkError=True):\n        if self.transfer_syntax == self.NDR64Syntax:\n            request.changeTransferSyntax(self.NDR64Syntax)\n            isNDR64 = True\n        else:\n            isNDR64 = False\n\n        self.call(request.opnum, request, uuid)\n        answer = self.recv()\n\n        __import__(request.__module__)\n        module = sys.modules[request.__module__]\n        respClass = getattr(module, request.__class__.__name__ + 'Response')\n\n        if  answer[-4:] != b'\\x00\\x00\\x00\\x00' and checkError is True:\n            error_code = unpack('<L', answer[-4:])[0]\n            if error_code in rpc_status_codes:\n                # This is an error we can handle\n                exception = DCERPCException(error_code = error_code)\n            else:    \n                sessionErrorClass = getattr(module, 'DCERPCSessionError')\n                try:\n                    # Try to unpack the answer, even if it is an error, it works most of the times\n                    response =  respClass(answer, isNDR64 = isNDR64)\n                except:\n                    # No luck :(\n                    exception = sessionErrorClass(error_code = error_code)\n                else:\n                    exception = sessionErrorClass(packet = response, error_code = error_code)\n            raise exception\n        else:\n            response =  respClass(answer, isNDR64 = isNDR64)\n            return response",
  "def __init__(self, transport):\n        DCERPC.__init__(self, transport)\n        self.__auth_level = RPC_C_AUTHN_LEVEL_NONE\n        self.__auth_type = RPC_C_AUTHN_WINNT\n        self.__auth_type_callback = None\n        # Flags of the authenticated session. We will need them throughout the connection\n        self.__auth_flags = 0\n        self.__username = None\n        self.__password = None\n        self.__domain = ''\n        self.__lmhash = ''\n        self.__nthash = ''\n        self.__aesKey = ''\n        self.__TGT    = None\n        self.__TGS    = None\n        \n        self.__clientSigningKey = b''\n        self.__serverSigningKey = b''\n        self.__clientSealingKey = b''\n        self.__clientSealingHandle = b''\n        self.__serverSealingKey = b''\n        self.__serverSealingHandle = b''\n        self.__sequence = 0   \n\n        self.transfer_syntax = uuidtup_to_bin(('8a885d04-1ceb-11c9-9fe8-08002b104860', '2.0'))\n        self.__callid = 1\n        self._ctx = 0\n        self.__sessionKey = None\n        self.__max_xmit_size  = 0\n        self.__flags = 0\n        self.__cipher = None\n        self.__confounder = b''\n        self.__gss = None",
  "def set_session_key(self, session_key):\n        self.__sessionKey = session_key",
  "def get_session_key(self):\n        return self.__sessionKey",
  "def set_auth_level(self, auth_level):\n        self.__auth_level = auth_level",
  "def set_auth_type(self, auth_type, callback = None):\n        self.__auth_type = auth_type\n        self.__auth_type_callback = callback",
  "def get_auth_type(self):\n        return self.__auth_type",
  "def set_max_tfrag(self, size):\n        self.__max_xmit_size = size",
  "def get_credentials(self):\n        return self.__username, self.__password, self.__domain, self.__lmhash, self.__nthash, self.__aesKey, self.__TGT, self.__TGS",
  "def set_credentials(self, username, password, domain = '', lmhash = '', nthash = '', aesKey = '', TGT = None, TGS = None):\n        self.set_auth_level(RPC_C_AUTHN_LEVEL_CONNECT)\n        self.__username = username\n        self.__password = password\n        self.__domain   = domain\n        self.__aesKey   = aesKey\n        self.__TGT      = TGT\n        self.__TGS      = TGS\n        if lmhash != '' or nthash != '':\n            if len(lmhash) % 2:\n                lmhash = '0%s' % lmhash\n            if len(nthash) % 2:\n                nthash = '0%s' % nthash\n            try: # just in case they were converted already\n                self.__lmhash = unhexlify(lmhash)\n                self.__nthash = unhexlify(nthash)\n            except:\n                self.__lmhash = lmhash\n                self.__nthash = nthash\n                pass",
  "def bind(self, iface_uuid, alter = 0, bogus_binds = 0, transfer_syntax = ('8a885d04-1ceb-11c9-9fe8-08002b104860', '2.0')):\n        bind = MSRPCBind()\n        #item['TransferSyntax']['Version'] = 1\n        ctx = self._ctx\n        for i in range(bogus_binds):\n            item = CtxItem()\n            item['ContextID'] = ctx\n            item['TransItems'] = 1\n            item['ContextID'] = ctx\n            # We generate random UUIDs for bogus binds\n            item['AbstractSyntax'] = generate() + stringver_to_bin('2.0')\n            item['TransferSyntax'] = uuidtup_to_bin(transfer_syntax)\n            bind.addCtxItem(item)\n            self._ctx += 1\n            ctx += 1\n\n        # The true one :)\n        item = CtxItem()\n        item['AbstractSyntax'] = iface_uuid\n        item['TransferSyntax'] = uuidtup_to_bin(transfer_syntax)\n        item['ContextID'] = ctx\n        item['TransItems'] = 1\n        bind.addCtxItem(item)\n\n        packet = MSRPCHeader()\n        packet['type'] = MSRPC_BIND\n        packet['pduData'] = bind.getData()\n        packet['call_id'] = self.__callid\n\n        if alter:\n            packet['type'] = MSRPC_ALTERCTX\n\n        if self.__auth_level != RPC_C_AUTHN_LEVEL_NONE:\n            if (self.__username is None) or (self.__password is None):\n                self.__username, self.__password, self.__domain, self.__lmhash, self.__nthash, self.__aesKey, self.__TGT, self.__TGS = self._transport.get_credentials()\n\n            if self.__auth_type == RPC_C_AUTHN_WINNT:\n                auth = ntlm.getNTLMSSPType1('', '', signingRequired=True,\n                                            use_ntlmv2=self._transport.doesSupportNTLMv2())\n            elif self.__auth_type == RPC_C_AUTHN_NETLOGON:\n                from impacket.dcerpc.v5 import nrpc\n                auth = nrpc.getSSPType1(self.__username[:-1], self.__domain, signingRequired=True)\n            elif self.__auth_type == RPC_C_AUTHN_GSS_NEGOTIATE:\n                self.__cipher, self.__sessionKey, auth = kerberosv5.getKerberosType1(self.__username, self.__password,\n                                                                                     self.__domain, self.__lmhash,\n                                                                                     self.__nthash, self.__aesKey,\n                                                                                     self.__TGT, self.__TGS,\n                                                                                     self._transport.getRemoteName(),\n                                                                                     self._transport.get_kdcHost())\n            else:\n                raise DCERPCException('Unsupported auth_type 0x%x' % self.__auth_type)\n\n            sec_trailer = SEC_TRAILER()\n            sec_trailer['auth_type']   = self.__auth_type\n            sec_trailer['auth_level']  = self.__auth_level\n            sec_trailer['auth_ctx_id'] = self._ctx + 79231 \n\n            pad = (4 - (len(packet.get_packet()) % 4)) % 4\n            if pad != 0:\n               packet['pduData'] += b'\\xFF'*pad\n               sec_trailer['auth_pad_len']=pad\n\n            packet['sec_trailer'] = sec_trailer\n            packet['auth_data'] = auth\n\n        self._transport.send(packet.get_packet())\n\n        s = self._transport.recv()\n\n        if s != 0:\n            resp = MSRPCHeader(s)\n        else:\n            return 0 #mmm why not None?\n\n        if resp['type'] == MSRPC_BINDACK or resp['type'] == MSRPC_ALTERCTX_R:\n            bindResp = MSRPCBindAck(resp.getData())\n        elif resp['type'] == MSRPC_BINDNAK or resp['type'] == MSRPC_FAULT:\n            if resp['type'] == MSRPC_FAULT:\n                resp = MSRPCRespHeader(resp.getData())\n                status_code = unpack('<L', resp['pduData'][:4])[0]\n            else:\n                resp = MSRPCBindNak(resp['pduData'])\n                status_code = resp['RejectedReason']\n            if status_code in rpc_status_codes:\n                raise DCERPCException(error_code = status_code)\n            elif status_code in rpc_provider_reason:\n                raise DCERPCException(\"Bind context rejected: %s\" % rpc_provider_reason[status_code])\n            else:\n                raise DCERPCException('Unknown DCE RPC fault status code: %.8x' % status_code)\n        else:\n            raise DCERPCException('Unknown DCE RPC packet type received: %d' % resp['type'])\n\n        # check ack results for each context, except for the bogus ones\n        for ctx in range(bogus_binds+1,bindResp['ctx_num']+1):\n            ctxItems = bindResp.getCtxItem(ctx)\n            if ctxItems['Result'] != 0:\n                msg = \"Bind context %d rejected: \" % ctx\n                msg += rpc_cont_def_result.get(ctxItems['Result'], 'Unknown DCE RPC context result code: %.4x' % ctxItems['Result'])\n                msg += \"; \"\n                reason = bindResp.getCtxItem(ctx)['Reason']\n                msg += rpc_provider_reason.get(reason, 'Unknown reason code: %.4x' % reason)\n                if (ctxItems['Result'], reason) == (2, 1): # provider_rejection, abstract syntax not supported\n                    msg += \" (this usually means the interface isn't listening on the given endpoint)\"\n                raise DCERPCException(msg)\n\n            # Save the transfer syntax for later use\n            self.transfer_syntax = ctxItems['TransferSyntax'] \n\n        # The received transmit size becomes the client's receive size, and the received receive size becomes the client's transmit size.\n        self.__max_xmit_size = bindResp['max_rfrag']\n\n        if self.__auth_level != RPC_C_AUTHN_LEVEL_NONE:\n            if self.__auth_type == RPC_C_AUTHN_WINNT:\n                response, self.__sessionKey = ntlm.getNTLMSSPType3(auth, bindResp['auth_data'], self.__username,\n                                                                   self.__password, self.__domain, self.__lmhash,\n                                                                   self.__nthash,\n                                                                   use_ntlmv2=self._transport.doesSupportNTLMv2())\n                self.__flags = response['flags']\n            elif self.__auth_type == RPC_C_AUTHN_NETLOGON:\n                response = None\n            elif self.__auth_type == RPC_C_AUTHN_GSS_NEGOTIATE:\n                self.__cipher, self.__sessionKey, response = kerberosv5.getKerberosType3(self.__cipher,\n                                                                                         self.__sessionKey,\n                                                                                         bindResp['auth_data'])\n\n            self.__sequence = 0\n\n            if self.__auth_level in (RPC_C_AUTHN_LEVEL_CONNECT, RPC_C_AUTHN_LEVEL_PKT_INTEGRITY, RPC_C_AUTHN_LEVEL_PKT_PRIVACY):\n                if self.__auth_type == RPC_C_AUTHN_WINNT:\n                    if self.__flags & ntlm.NTLMSSP_NEGOTIATE_EXTENDED_SESSIONSECURITY:\n                        self.__clientSigningKey = ntlm.SIGNKEY(self.__flags, self.__sessionKey)\n                        self.__serverSigningKey = ntlm.SIGNKEY(self.__flags, self.__sessionKey,b\"Server\")\n                        self.__clientSealingKey = ntlm.SEALKEY(self.__flags, self.__sessionKey)\n                        self.__serverSealingKey = ntlm.SEALKEY(self.__flags, self.__sessionKey,b\"Server\")\n                        # Preparing the keys handle states\n                        cipher3 = ARC4.new(self.__clientSealingKey)\n                        self.__clientSealingHandle = cipher3.encrypt\n                        cipher4 = ARC4.new(self.__serverSealingKey)\n                        self.__serverSealingHandle = cipher4.encrypt\n                    else:\n                        # Same key for everything\n                        self.__clientSigningKey = self.__sessionKey\n                        self.__serverSigningKey = self.__sessionKey\n                        self.__clientSealingKey = self.__sessionKey\n                        self.__serverSealingKey = self.__sessionKey\n                        cipher = ARC4.new(self.__clientSigningKey)\n                        self.__clientSealingHandle = cipher.encrypt\n                        self.__serverSealingHandle = cipher.encrypt\n                elif self.__auth_type == RPC_C_AUTHN_NETLOGON:\n                    if self.__auth_level == RPC_C_AUTHN_LEVEL_PKT_INTEGRITY:\n                        self.__confounder = b''\n                    else:\n                        self.__confounder = b'12345678'\n\n            sec_trailer = SEC_TRAILER()\n            sec_trailer['auth_type'] = self.__auth_type\n            sec_trailer['auth_level'] = self.__auth_level\n            sec_trailer['auth_ctx_id'] = self._ctx + 79231 \n\n            if response is not None:\n                if self.__auth_type == RPC_C_AUTHN_GSS_NEGOTIATE:\n                    alter_ctx = MSRPCHeader()\n                    alter_ctx['type'] = MSRPC_ALTERCTX\n                    alter_ctx['pduData'] = bind.getData()\n                    alter_ctx['sec_trailer'] = sec_trailer\n                    alter_ctx['auth_data'] = response\n                    self._transport.send(alter_ctx.get_packet(), forceWriteAndx = 1)\n                    self.__gss = gssapi.GSSAPI(self.__cipher)\n                    self.__sequence = 0\n                    self.recv()\n                    self.__sequence = 0\n                else:\n                    auth3 = MSRPCHeader()\n                    auth3['type'] = MSRPC_AUTH3\n                    # pad (4 bytes): Can be set to any arbitrary value when set and MUST be \n                    # ignored on receipt. The pad field MUST be immediately followed by a \n                    # sec_trailer structure whose layout, location, and alignment are as \n                    # specified in section 2.2.2.11\n                    auth3['pduData'] = b'    '\n                    auth3['sec_trailer'] = sec_trailer\n                    auth3['auth_data'] = response.getData()\n\n                    # Use the same call_id\n                    self.__callid = resp['call_id']\n                    auth3['call_id'] = self.__callid\n                    self._transport.send(auth3.get_packet(), forceWriteAndx = 1)\n\n            self.__callid += 1\n\n        return resp",
  "def _transport_send(self, rpc_packet, forceWriteAndx = 0, forceRecv = 0):\n        rpc_packet['ctx_id'] = self._ctx\n        rpc_packet['sec_trailer'] = b''\n        rpc_packet['auth_data'] = b''\n\n        if self.__auth_level in [RPC_C_AUTHN_LEVEL_PKT_INTEGRITY, RPC_C_AUTHN_LEVEL_PKT_PRIVACY]:\n            # Dummy verifier, just for the calculations\n            sec_trailer = SEC_TRAILER()\n            sec_trailer['auth_type'] = self.__auth_type\n            sec_trailer['auth_level'] = self.__auth_level\n            sec_trailer['auth_pad_len'] = 0\n            sec_trailer['auth_ctx_id'] = self._ctx + 79231 \n\n            pad = (4 - (len(rpc_packet.get_packet()) % 4)) % 4\n            if pad != 0:\n                rpc_packet['pduData'] += b'\\xBB'*pad\n                sec_trailer['auth_pad_len']=pad\n\n            rpc_packet['sec_trailer'] = sec_trailer.getData()\n            rpc_packet['auth_data'] = b' '*16\n\n            plain_data = rpc_packet['pduData']\n            if self.__auth_level == RPC_C_AUTHN_LEVEL_PKT_PRIVACY:\n                if self.__auth_type == RPC_C_AUTHN_WINNT:\n                    if self.__flags & ntlm.NTLMSSP_NEGOTIATE_EXTENDED_SESSIONSECURITY:\n                        # When NTLM2 is on, we sign the whole pdu, but encrypt just\n                        # the data, not the dcerpc header. Weird..\n                        sealedMessage, signature =  ntlm.SEAL(self.__flags, \n                               self.__clientSigningKey, \n                               self.__clientSealingKey,  \n                               rpc_packet.get_packet()[:-16], \n                               plain_data, \n                               self.__sequence, \n                               self.__clientSealingHandle)\n                    else:\n                        sealedMessage, signature =  ntlm.SEAL(self.__flags, \n                               self.__clientSigningKey, \n                               self.__clientSealingKey,  \n                               plain_data, \n                               plain_data, \n                               self.__sequence, \n                               self.__clientSealingHandle)\n                elif self.__auth_type == RPC_C_AUTHN_NETLOGON:\n                    from impacket.dcerpc.v5 import nrpc\n                    sealedMessage, signature = nrpc.SEAL(plain_data, self.__confounder, self.__sequence, self.__sessionKey, False)\n                elif self.__auth_type == RPC_C_AUTHN_GSS_NEGOTIATE:\n                    sealedMessage, signature = self.__gss.GSS_Wrap(self.__sessionKey, plain_data, self.__sequence)\n\n                rpc_packet['pduData'] = sealedMessage\n            elif self.__auth_level == RPC_C_AUTHN_LEVEL_PKT_INTEGRITY: \n                if self.__auth_type == RPC_C_AUTHN_WINNT:\n                    if self.__flags & ntlm.NTLMSSP_NEGOTIATE_EXTENDED_SESSIONSECURITY:\n                        # Interesting thing.. with NTLM2, what is is signed is the \n                        # whole PDU, not just the data\n                        signature =  ntlm.SIGN(self.__flags,\n                               self.__clientSigningKey, \n                               rpc_packet.get_packet()[:-16], \n                               self.__sequence, \n                               self.__clientSealingHandle)\n                    else:\n                        signature =  ntlm.SIGN(self.__flags, \n                               self.__clientSigningKey, \n                               plain_data, \n                               self.__sequence, \n                               self.__clientSealingHandle)\n                elif self.__auth_type == RPC_C_AUTHN_NETLOGON:\n                    from impacket.dcerpc.v5 import nrpc\n                    signature = nrpc.SIGN(plain_data, \n                           self.__confounder, \n                           self.__sequence, \n                           self.__sessionKey, \n                           False)\n                elif self.__auth_type == RPC_C_AUTHN_GSS_NEGOTIATE:\n                    signature = self.__gss.GSS_GetMIC(self.__sessionKey, plain_data, self.__sequence)\n\n            rpc_packet['sec_trailer'] = sec_trailer.getData()\n            rpc_packet['auth_data'] = signature\n\n            self.__sequence += 1\n\n        self._transport.send(rpc_packet.get_packet(), forceWriteAndx = forceWriteAndx, forceRecv = forceRecv)",
  "def send(self, data):\n        if isinstance(data, MSRPCHeader) is not True:\n            # Must be an Impacket, transform to structure\n            data = DCERPC_RawCall(data.OP_NUM, data.get_packet())\n\n        try:\n            if data['uuid'] != b'':\n                data['flags'] |= PFC_OBJECT_UUID\n        except:\n            # Structure doesn't have uuid\n            pass\n        data['ctx_id'] = self._ctx\n        data['call_id'] = self.__callid\n        data['alloc_hint'] = len(data['pduData'])\n        # We should fragment PDUs if:\n        # 1) Payload exceeds __max_xmit_size received during BIND response\n        # 2) We'e explicitly fragmenting packets with lower values\n        should_fragment = False\n\n        # Let's decide what will drive fragmentation for this request\n        if self._max_user_frag > 0:\n            # User set a frag size, let's compare it with the max transmit size agreed when binding the interface\n            fragment_size = min(self._max_user_frag, self.__max_xmit_size)\n        else:\n            fragment_size = self.__max_xmit_size\n\n        # Sanity check. Fragmentation can't be too low, otherwise sec_trailer won't fit\n\n        if self.__auth_level in [RPC_C_AUTHN_LEVEL_PKT_INTEGRITY, RPC_C_AUTHN_LEVEL_PKT_PRIVACY]:\n            if fragment_size <= 8:\n                # Minimum pdu fragment size is 8, important when doing PKT_INTEGRITY/PRIVACY. We need a minimum size of 8\n                # (Kerberos)\n                fragment_size = 8\n\n        # ToDo: Better calculate the size needed. Now I'm setting a number that surely is enough for Kerberos and NTLM\n        # ToDo: trailers, both for INTEGRITY and PRIVACY. This means we're not truly honoring the user's frag request.\n        if len(data['pduData']) + 128 > fragment_size:\n            should_fragment = True\n            if fragment_size+128 > self.__max_xmit_size:\n                fragment_size = self.__max_xmit_size - 128\n\n        if should_fragment:\n            packet = data['pduData']\n            offset = 0\n\n            while 1:\n                toSend = packet[offset:offset+fragment_size]\n                if not toSend:\n                    break\n                if offset == 0:\n                    data['flags'] |= PFC_FIRST_FRAG\n                else:\n                    data['flags'] &= (~PFC_FIRST_FRAG)\n                offset += len(toSend)\n                if offset >= len(packet):\n                    data['flags'] |= PFC_LAST_FRAG\n                else:\n                    data['flags'] &= (~PFC_LAST_FRAG)\n                data['pduData'] = toSend\n                self._transport_send(data, forceWriteAndx = 1, forceRecv =data['flags'] & PFC_LAST_FRAG)\n        else:\n            self._transport_send(data)\n        self.__callid += 1",
  "def recv(self):\n        finished = False\n        forceRecv = 0\n        retAnswer = b''\n        while not finished:\n            # At least give me the MSRPCRespHeader, especially important for \n            # TCP/UDP Transports\n            response_data = self._transport.recv(forceRecv, count=MSRPCRespHeader._SIZE)\n            response_header = MSRPCRespHeader(response_data)\n            # Ok, there might be situation, especially with large packets, that \n            # the transport layer didn't send us the full packet's contents\n            # So we gotta check we received it all\n            while len(response_data) < response_header['frag_len']:\n               response_data += self._transport.recv(forceRecv, count=(response_header['frag_len']-len(response_data)))\n\n            off = response_header.get_header_size()\n\n            if response_header['type'] == MSRPC_FAULT and response_header['frag_len'] >= off+4:\n                status_code = unpack(\"<L\",response_data[off:off+4])[0]\n                if status_code in rpc_status_codes:\n                    raise DCERPCException(rpc_status_codes[status_code])\n                elif status_code & 0xffff in rpc_status_codes:\n                    raise DCERPCException(rpc_status_codes[status_code & 0xffff])\n                else:\n                    if status_code in hresult_errors.ERROR_MESSAGES:\n                        error_msg_short = hresult_errors.ERROR_MESSAGES[status_code][0]\n                        error_msg_verbose = hresult_errors.ERROR_MESSAGES[status_code][1] \n                        raise DCERPCException('%s - %s' % (error_msg_short, error_msg_verbose))\n                    else:\n                        raise DCERPCException('Unknown DCE RPC fault status code: %.8x' % status_code)\n\n            if response_header['flags'] & PFC_LAST_FRAG:\n                # No need to reassembly DCERPC\n                finished = True\n            else:\n                # Forcing Read Recv, we need more packets!\n                forceRecv = 1\n\n            answer = response_data[off:]\n            auth_len = response_header['auth_len']\n            if auth_len:\n                auth_len += 8\n                auth_data = answer[-auth_len:]\n                sec_trailer = SEC_TRAILER(data = auth_data)\n                answer = answer[:-auth_len]\n\n                if sec_trailer['auth_level'] == RPC_C_AUTHN_LEVEL_PKT_PRIVACY:\n                    if self.__auth_type == RPC_C_AUTHN_WINNT:\n                        if self.__flags & ntlm.NTLMSSP_NEGOTIATE_EXTENDED_SESSIONSECURITY:\n                            # TODO: FIX THIS, it's not calculating the signature well\n                            # Since I'm not testing it we don't care... yet\n                            answer, signature =  ntlm.SEAL(self.__flags, \n                                    self.__serverSigningKey, \n                                    self.__serverSealingKey,  \n                                    answer, \n                                    answer, \n                                    self.__sequence, \n                                    self.__serverSealingHandle)\n                        else:\n                            answer, signature = ntlm.SEAL(self.__flags, \n                                    self.__serverSigningKey, \n                                    self.__serverSealingKey, \n                                    answer, \n                                    answer, \n                                    self.__sequence, \n                                    self.__serverSealingHandle)\n                            self.__sequence += 1\n                    elif self.__auth_type == RPC_C_AUTHN_NETLOGON:\n                        from impacket.dcerpc.v5 import nrpc\n                        answer, cfounder = nrpc.UNSEAL(answer, \n                               auth_data[len(sec_trailer):],\n                               self.__sessionKey, \n                               False)\n                        self.__sequence += 1\n                    elif self.__auth_type == RPC_C_AUTHN_GSS_NEGOTIATE:\n                        if self.__sequence > 0:\n                            answer, cfounder = self.__gss.GSS_Unwrap(self.__sessionKey, answer, self.__sequence,\n                                                                     direction='init', authData=auth_data)\n\n                elif sec_trailer['auth_level'] == RPC_C_AUTHN_LEVEL_PKT_INTEGRITY:\n                    if self.__auth_type == RPC_C_AUTHN_WINNT:\n                        ntlmssp = auth_data[12:]\n                        if self.__flags & ntlm.NTLMSSP_NEGOTIATE_EXTENDED_SESSIONSECURITY:\n                            signature =  ntlm.SIGN(self.__flags, \n                                    self.__serverSigningKey, \n                                    answer, \n                                    self.__sequence, \n                                    self.__serverSealingHandle)\n                        else:\n                            signature = ntlm.SIGN(self.__flags, \n                                    self.__serverSigningKey, \n                                    ntlmssp, \n                                    self.__sequence, \n                                    self.__serverSealingHandle)\n                            # Yes.. NTLM2 doesn't increment sequence when receiving\n                            # the packet :P\n                            self.__sequence += 1\n                    elif self.__auth_type == RPC_C_AUTHN_NETLOGON:\n                        from impacket.dcerpc.v5 import nrpc\n                        ntlmssp = auth_data[12:]\n                        signature = nrpc.SIGN(ntlmssp, \n                               self.__confounder, \n                               self.__sequence, \n                               self.__sessionKey, \n                               False)\n                        self.__sequence += 1\n                    elif self.__auth_type == RPC_C_AUTHN_GSS_NEGOTIATE:\n                        # Do NOT increment the sequence number when Signing Kerberos\n                        #self.__sequence += 1\n                        pass\n\n                \n                if sec_trailer['auth_pad_len']:\n                    answer = answer[:-sec_trailer['auth_pad_len']]\n              \n            retAnswer += answer\n        return retAnswer",
  "def alter_ctx(self, newUID, bogus_binds = 0):\n        answer = self.__class__(self._transport)\n\n        answer.set_credentials(self.__username, self.__password, self.__domain, self.__lmhash, self.__nthash,\n                               self.__aesKey, self.__TGT, self.__TGS)\n        answer.set_auth_type(self.__auth_type)\n        answer.set_auth_level(self.__auth_level)\n\n        answer.set_ctx_id(self._ctx+1)\n        answer.__callid = self.__callid\n        answer.bind(newUID, alter = 1, bogus_binds = bogus_binds, transfer_syntax = bin_to_uuidtup(self.transfer_syntax))\n        return answer",
  "def __init__(self, op_num, data = b'', uuid=None):\n        MSRPCRequestHeader.__init__(self)\n        self['op_num'] = op_num\n        self['pduData'] = data\n        if uuid is not None:\n            self['flags'] |= PFC_OBJECT_UUID\n            self['uuid'] = uuid",
  "def setData(self, data):\n        self['pduData'] = data",
  "def __init__(self, data = None,isNDR64 = False):\n        NDRSTRUCT.__init__(self, data, isNDR64)\n        if data is None:\n            self['Version'] = 1\n            self['Endianness'] = 0x10\n            self['CommonHeaderLength'] = 8\n            self['Filler'] = 0xcccccccc",
  "def __init__(self, data = None,isNDR64 = False):\n        NDRSTRUCT.__init__(self, data, isNDR64)\n        if data is None:\n            self['Filler'] = 0xcccccccc",
  "def getData(self, soFar = 0):\n        self['PrivateHeader']['ObjectBufferLength'] = len(NDRSTRUCT.getData(self, soFar)) + len(\n            NDRSTRUCT.getDataReferents(self, soFar)) - len(self['CommonHeader']) - len(self['PrivateHeader'])\n        return NDRSTRUCT.getData(self, soFar)",
  "def __init__(self):\n        Thread.__init__(self)\n        self._listenPort    = 0\n        self._listenAddress = '127.0.0.1'\n        self._listenUUIDS   = {}\n        self._boundUUID     = b''\n        self._sock          = None\n        self._clientSock    = None\n        self._callid        = 1\n        self._max_frag       = None\n        self._max_xmit_size = 4280\n        self.__log = LOG\n        self._sock = socket.socket()\n        self._sock.bind((self._listenAddress,self._listenPort))",
  "def log(self, msg, level=logging.INFO):\n        self.__log.log(level,msg)",
  "def addCallbacks(self, ifaceUUID, secondaryAddr, callbacks):\n        \"\"\"\n        adds a call back to a UUID/opnum call\n        \n        :param uuid ifaceUUID: the interface UUID\n        :param string secondaryAddr: the secondary address to answer as part of the bind request (e.g. \\\\\\\\PIPE\\\\\\\\srvsvc)\n        :param dict callbacks: the callbacks for each opnum. Format is [opnum] = callback\n        \"\"\"\n        self._listenUUIDS[uuidtup_to_bin(ifaceUUID)] = {}\n        self._listenUUIDS[uuidtup_to_bin(ifaceUUID)]['SecondaryAddr'] = secondaryAddr\n        self._listenUUIDS[uuidtup_to_bin(ifaceUUID)]['CallBacks'] = callbacks\n        self.log(\"Callback added for UUID %s V:%s\" % ifaceUUID)",
  "def setListenPort(self, portNum):\n        self._listenPort = portNum\n        self._sock = socket.socket()\n        self._sock.bind((self._listenAddress,self._listenPort))",
  "def getListenPort(self):\n        return self._sock.getsockname()[1]",
  "def recv(self):\n        finished = False\n        retAnswer = b''\n        response_data = b''\n        while not finished:\n            # At least give me the MSRPCRespHeader, especially important for TCP/UDP Transports\n            response_data = self._clientSock.recv(MSRPCRespHeader._SIZE)\n            # No data?, connection might have closed\n            if response_data == b'':\n                return None\n            response_header = MSRPCRespHeader(response_data)\n            # Ok, there might be situation, especially with large packets, \n            # that the transport layer didn't send us the full packet's contents\n            # So we gotta check we received it all\n            while len(response_data) < response_header['frag_len']:\n               response_data += self._clientSock.recv(response_header['frag_len']-len(response_data))\n            response_header = MSRPCRespHeader(response_data)\n            if response_header['flags'] & PFC_LAST_FRAG:\n                # No need to reassembly DCERPC\n                finished = True\n            answer = response_header['pduData']\n            auth_len = response_header['auth_len']\n            if auth_len:\n                auth_len += 8\n                auth_data = answer[-auth_len:]\n                sec_trailer = SEC_TRAILER(data = auth_data)\n                answer = answer[:-auth_len]\n                if sec_trailer['auth_pad_len']:\n                    answer = answer[:-sec_trailer['auth_pad_len']]\n              \n            retAnswer += answer\n        return response_data",
  "def run(self):\n        self._sock.listen(10)\n        while True:\n            self._clientSock, address = self._sock.accept()\n            try:\n                while True:\n                    data = self.recv()\n                    if data is None:\n                        # No data.. connection closed\n                        break\n                    answer = self.processRequest(data)\n                    if answer is not None:\n                        self.send(answer)\n            except Exception:\n                #import traceback\n                #traceback.print_exc()\n                pass\n            self._clientSock.close()",
  "def send(self, data):\n        max_frag       = self._max_frag\n        if len(data['pduData']) > self._max_xmit_size - 32:\n            max_frag   = self._max_xmit_size - 32    # XXX: 32 is a safe margin for auth data\n\n        if self._max_frag:\n            max_frag   = min(max_frag, self._max_frag)\n        if max_frag and len(data['pduData']) > 0:\n            packet     = data['pduData']\n            offset     = 0\n            while 1:\n                toSend = packet[offset:offset+max_frag]\n                if not toSend:\n                    break\n                flags  = 0\n                if offset == 0:\n                    flags |= PFC_FIRST_FRAG\n                offset += len(toSend)\n                if offset == len(packet):\n                    flags |= PFC_LAST_FRAG\n                data['flags']   = flags\n                data['pduData'] = toSend\n                self._clientSock.send(data.get_packet())\n        else:\n            self._clientSock.send(data.get_packet())\n        self._callid += 1",
  "def bind(self,packet, bind):\n        # Standard NDR Representation\n        NDRSyntax   = ('8a885d04-1ceb-11c9-9fe8-08002b104860', '2.0')\n        resp = MSRPCBindAck()\n\n        resp['type']             = MSRPC_BINDACK\n        resp['flags']            = packet['flags']\n        resp['frag_len']         = 0\n        resp['auth_len']         = 0\n        resp['auth_data']        = b''\n        resp['call_id']          = packet['call_id'] \n        resp['max_tfrag']        = bind['max_tfrag']\n        resp['max_rfrag']        = bind['max_rfrag']\n        resp['assoc_group']      = 0x1234\n        resp['ctx_num']          = 0\n\n        data      = bind['ctx_items']\n        ctx_items = b''\n        resp['SecondaryAddrLen'] = 0\n        for i in range(bind['ctx_num']):\n            result = MSRPC_CONT_RESULT_USER_REJECT\n            item   = CtxItem(data)\n            data   = data[len(item):]\n\n            # First we check the Transfer Syntax is NDR32, what we support\n            if item['TransferSyntax'] == uuidtup_to_bin(NDRSyntax):\n                # Now Check if the interface is what we listen\n                reason = 1 # Default, Abstract Syntax not supported\n                for j in self._listenUUIDS:\n                    if item['AbstractSyntax'] == j:\n                        # Match, we accept the bind request\n                        resp['SecondaryAddr']    = self._listenUUIDS[item['AbstractSyntax']]['SecondaryAddr']\n                        resp['SecondaryAddrLen'] = len(resp['SecondaryAddr'])+1\n                        reason           = 0\n                        self._boundUUID = j\n            else:\n                # Fail the bind request for this context\n                reason = 2 # Transfer Syntax not supported\n            if reason == 0:\n               result = MSRPC_CONT_RESULT_ACCEPT\n            if reason == 1:\n                LOG.error('Bind request for an unsupported interface %s' % bin_to_uuidtup(item['AbstractSyntax']))\n\n            resp['ctx_num']             += 1\n            itemResult                   = CtxItemResult()\n            itemResult['Result']         = result\n            itemResult['Reason']         = reason\n            itemResult['TransferSyntax'] = uuidtup_to_bin(NDRSyntax)\n            ctx_items                   += itemResult.getData()\n\n        resp['Pad']              ='A'*((4-((resp[\"SecondaryAddrLen\"]+MSRPCBindAck._SIZE) % 4))%4)\n        resp['ctx_items'] = ctx_items\n        resp['frag_len']  = len(resp.getData())\n\n        self._clientSock.send(resp.getData())\n        return None",
  "def processRequest(self,data):\n        packet = MSRPCHeader(data)\n        if packet['type'] == MSRPC_BIND:\n            bind   = MSRPCBind(packet['pduData'])\n            self.bind(packet, bind)\n            packet = None\n        elif packet['type'] == MSRPC_REQUEST:\n            request          = MSRPCRequestHeader(data)\n            response         = MSRPCRespHeader(data)\n            response['type'] = MSRPC_RESPONSE\n            # Serve the opnum requested, if not, fails\n            if request['op_num'] in self._listenUUIDS[self._boundUUID]['CallBacks']:\n                # Call the function \n                returnData          = self._listenUUIDS[self._boundUUID]['CallBacks'][request['op_num']](request['pduData'])\n                response['pduData'] = returnData\n            else:\n                LOG.error('Unsupported DCERPC opnum %d called for interface %s' % (request['op_num'], bin_to_uuidtup(self._boundUUID)))\n                response['type']    = MSRPC_FAULT\n                response['pduData'] = pack('<L',0x000006E4)\n            response['frag_len'] = len(response)\n            return response\n        else:\n            # Defaults to a fault\n            packet         = MSRPCRespHeader(data)\n            packet['type'] = MSRPC_FAULT\n\n        return packet",
  "class DCERPCSessionError(DCERPCException):\n    def __init__(self, error_string=None, error_code=None, packet=None):\n        DCERPCException.__init__(self, error_string, error_code, packet)\n\n    def __str__(self):\n        key = self.error_code\n        if key in system_errors.ERROR_MESSAGES:\n            error_msg_short = system_errors.ERROR_MESSAGES[key][0]\n            error_msg_verbose = system_errors.ERROR_MESSAGES[key][1]\n            return 'EVEN6 SessionError: code: 0x%x - %s - %s' % (self.error_code, error_msg_short, error_msg_verbose)\n        else:\n            return 'EVEN6 SessionError: unknown error code: 0x%x' % self.error_code",
  "class CONTEXT_HANDLE_LOG_HANDLE(NDRSTRUCT):\n    align = 1\n    structure = (\n        ('Data', '20s=\"\"'),\n    )",
  "class PCONTEXT_HANDLE_LOG_HANDLE(NDRPOINTER):\n    referent = (\n        ('Data', CONTEXT_HANDLE_LOG_HANDLE),\n    )",
  "class CONTEXT_HANDLE_LOG_QUERY(NDRSTRUCT):\n    align = 1\n    structure = (\n        ('Data', '20s=\"\"'),\n    )",
  "class PCONTEXT_HANDLE_LOG_QUERY(NDRPOINTER):\n    referent = (\n        ('Data', CONTEXT_HANDLE_LOG_QUERY),\n    )",
  "class LPPCONTEXT_HANDLE_LOG_QUERY(NDRPOINTER):\n    referent = (\n        ('Data', PCONTEXT_HANDLE_LOG_QUERY),\n    )",
  "class CONTEXT_HANDLE_OPERATION_CONTROL(NDRSTRUCT):\n    align = 1\n    structure = (\n        ('Data', '20s=\"\"'),\n    )",
  "class PCONTEXT_HANDLE_OPERATION_CONTROL(NDRPOINTER):\n    referent = (\n        ('Data', CONTEXT_HANDLE_OPERATION_CONTROL),\n    )",
  "class EvtRpcQueryChannelInfo(NDRSTRUCT):\n    structure = (\n        ('Name', LPWSTR),\n        ('Status', DWORD),\n    )",
  "class EvtRpcQueryChannelInfoArray(NDRUniVaryingArray):\n    item = EvtRpcQueryChannelInfo",
  "class LPEvtRpcQueryChannelInfoArray(NDRPOINTER):\n    referent = (\n        ('Data', EvtRpcQueryChannelInfoArray)\n    )",
  "class RPC_INFO(NDRSTRUCT):\n    structure = (\n        ('Error', DWORD),\n        ('SubError', DWORD),\n        ('SubErrorParam', DWORD),\n    )",
  "class PRPC_INFO(NDRPOINTER):\n    referent = (\n        ('Data', RPC_INFO)\n    )",
  "class WSTR_ARRAY(NDRUniVaryingArray):\n    item = WSTR",
  "class DWORD_ARRAY(NDRUniVaryingArray):\n    item = DWORD",
  "class LPDWORD_ARRAY(NDRPOINTER):\n    referent = (\n        ('Data', DWORD_ARRAY)\n    )",
  "class BYTE_ARRAY(NDRUniVaryingArray):\n    item = 'c'",
  "class CBYTE_ARRAY(NDRUniVaryingArray):\n    item = BYTE",
  "class CDWORD_ARRAY(NDRUniConformantArray):\n    item = DWORD",
  "class LPBYTE_ARRAY(NDRPOINTER):\n    referent = (\n        ('Data', CBYTE_ARRAY)\n    )",
  "class ULONG_ARRAY(NDRUniVaryingArray):\n    item = ULONG",
  "class EVENT_DESCRIPTOR(NDRSTRUCT):\n    structure = (\n        ('Id', WORD),\n        ('Version', BYTE),\n        ('Channel', BYTE),\n        ('LevelSeverity', BYTE),\n        ('Opcode', BYTE),\n        ('Task', WORD),\n        ('Keyword', ULONG),\n    )",
  "class BOOKMARK(NDRSTRUCT):\n    structure = (\n        ('BookmarkSize', DWORD),\n        ('HeaderSize', '<L=0x18'),\n        ('ChannelSize', DWORD),\n        ('CurrentChannel', DWORD),\n        ('ReadDirection', DWORD),\n        ('RecordIdsOffset', DWORD),\n        ('LogRecordNumbers', ULONG_ARRAY),\n    )",
  "class RESULT_SET(NDRSTRUCT):\n    structure = (\n        ('TotalSize', DWORD),\n        ('HeaderSize', DWORD),\n        ('EventOffset', DWORD),\n        ('BookmarkOffset', DWORD),\n        ('BinXmlSize', DWORD),\n        ('EventData', BYTE_ARRAY),\n        #('NumberOfSubqueryIDs', '<L=0'),\n        #('SubqueryIDs', BYTE_ARRAY),\n        #('BookMarkData', BOOKMARK),\n    )",
  "class EvtRpcRegisterLogQuery(NDRCALL):\n    opnum = 5\n    structure = (\n        ('Path', LPWSTR),\n        ('Query', WSTR),\n        ('Flags', DWORD),\n    )",
  "class EvtRpcRegisterLogQueryResponse(NDRCALL):\n    structure = (\n        ('Handle', CONTEXT_HANDLE_LOG_QUERY),\n        ('OpControl', CONTEXT_HANDLE_OPERATION_CONTROL),\n        ('QueryChannelInfoSize', DWORD),\n        ('QueryChannelInfo', EvtRpcQueryChannelInfoArray),\n        ('Error', RPC_INFO),\n        )",
  "class EvtRpcQueryNext(NDRCALL):\n    opnum = 11\n    structure = (\n        ('LogQuery', CONTEXT_HANDLE_LOG_QUERY),\n        ('NumRequestedRecords', DWORD),\n        ('TimeOutEnd', DWORD),\n        ('Flags', DWORD),\n    )",
  "class EvtRpcQueryNextResponse(NDRCALL):\n    structure = (\n        ('NumActualRecords', DWORD),\n        ('EventDataIndices', DWORD_ARRAY),\n        ('EventDataSizes', DWORD_ARRAY),\n        ('ResultBufferSize', DWORD),\n        ('ResultBuffer', BYTE_ARRAY),\n        ('ErrorCode', ULONG),\n    )",
  "class EvtRpcQuerySeek(NDRCALL):\n    opnum = 12\n    structure = (\n        ('LogQuery', CONTEXT_HANDLE_LOG_QUERY),\n        ('Pos', LARGE_INTEGER),\n        ('BookmarkXML', LPWSTR),\n        ('Flags', DWORD),\n    )",
  "class EvtRpcQuerySeekResponse(NDRCALL):\n    structure = (\n        ('Error', RPC_INFO),\n    )",
  "class EvtRpcClose(NDRCALL):\n    opnum = 13\n    structure = (\n        (\"Handle\", CONTEXT_HANDLE_LOG_HANDLE),\n    )",
  "class EvtRpcCloseResponse(NDRCALL):\n    structure = (\n        (\"Handle\", PCONTEXT_HANDLE_LOG_HANDLE),\n        ('ErrorCode', ULONG),\n    )",
  "class EvtRpcOpenLogHandle(NDRCALL):\n    opnum = 17\n    structure = (\n        ('Channel', WSTR),\n        ('Flags', DWORD),\n    )",
  "class EvtRpcOpenLogHandleResponse(NDRCALL):\n    structure = (\n        ('Handle', PCONTEXT_HANDLE_LOG_HANDLE),\n        ('Error', RPC_INFO),\n    )",
  "class EvtRpcGetChannelList(NDRCALL):\n    opnum = 19\n    structure = (\n        ('Flags', DWORD),\n    )",
  "class EvtRpcGetChannelListResponse(NDRCALL):\n    structure = (\n        ('NumChannelPaths', DWORD),\n        ('ChannelPaths', WSTR_ARRAY),\n        ('ErrorCode', ULONG),\n    )",
  "def hEvtRpcRegisterLogQuery(dce, path, flags, query='*\\x00'):\n    request = EvtRpcRegisterLogQuery()\n\n    request['Path'] = path\n    request['Query'] = query\n    request['Flags'] = flags\n    resp = dce.request(request)\n    return resp",
  "def hEvtRpcQueryNext(dce, handle, numRequestedRecords, timeOutEnd=1000):\n    request = EvtRpcQueryNext()\n\n    request['LogQuery'] = handle\n    request['NumRequestedRecords'] = numRequestedRecords\n    request['TimeOutEnd'] = timeOutEnd\n    request['Flags'] = 0\n    status = system_errors.ERROR_MORE_DATA\n    resp = dce.request(request)\n    while status == system_errors.ERROR_MORE_DATA:\n        try:\n            resp = dce.request(request)\n        except DCERPCException as e:\n            if str(e).find('ERROR_NO_MORE_ITEMS') < 0:\n                raise\n            elif str(e).find('ERROR_TIMEOUT') < 0:\n                raise\n            resp = e.get_packet()\n        return resp",
  "def hEvtRpcClose(dce, handle):\n    request = EvtRpcClose()\n    request['Handle'] = handle\n    resp = dce.request(request)\n    return resp",
  "def hEvtRpcOpenLogHandle(dce, channel, flags):\n    request = EvtRpcOpenLogHandle()\n\n    request['Channel'] = channel\n    request['Flags'] = flags\n    return dce.request(request)",
  "def hEvtRpcGetChannelList(dce):\n    request = EvtRpcGetChannelList()\n\n    request['Flags'] = 0\n    resp = dce.request(request)\n    return resp",
  "def __init__(self, error_string=None, error_code=None, packet=None):\n        DCERPCException.__init__(self, error_string, error_code, packet)",
  "def __str__(self):\n        key = self.error_code\n        if key in system_errors.ERROR_MESSAGES:\n            error_msg_short = system_errors.ERROR_MESSAGES[key][0]\n            error_msg_verbose = system_errors.ERROR_MESSAGES[key][1]\n            return 'EVEN6 SessionError: code: 0x%x - %s - %s' % (self.error_code, error_msg_short, error_msg_verbose)\n        else:\n            return 'EVEN6 SessionError: unknown error code: 0x%x' % self.error_code",
  "class _RouteClassAttributeToGetattr(object):\n    \"\"\"Route attribute access on a class to __getattr__.\n\n    This is a descriptor, used to define attributes that act differently when\n    accessed through an instance and through a class.  Instance access remains\n    normal, but access to an attribute through a class will be routed to the\n    class's __getattr__ method; this is done by raising AttributeError.\n\n    \"\"\"\n    def __init__(self, fget=None):\n        self.fget = fget\n\n    def __get__(self, instance, ownerclass=None):\n        if instance is None:\n            raise AttributeError()\n        return self.fget(instance)\n\n    def __set__(self, instance, value):\n        raise AttributeError(\"can't set attribute\")\n\n    def __delete__(self, instance):\n        raise AttributeError(\"can't delete attribute\")",
  "def _is_descriptor(obj):\n    \"\"\"Returns True if obj is a descriptor, False otherwise.\"\"\"\n    return (\n            hasattr(obj, '__get__') or\n            hasattr(obj, '__set__') or\n            hasattr(obj, '__delete__'))",
  "def _is_dunder(name):\n    \"\"\"Returns True if a __dunder__ name, False otherwise.\"\"\"\n    return (name[:2] == name[-2:] == '__' and\n            name[2:3] != '_' and\n            name[-3:-2] != '_' and\n            len(name) > 4)",
  "def _is_sunder(name):\n    \"\"\"Returns True if a _sunder_ name, False otherwise.\"\"\"\n    return (name[0] == name[-1] == '_' and \n            name[1:2] != '_' and\n            name[-2:-1] != '_' and\n            len(name) > 2)",
  "def _make_class_unpicklable(cls):\n    \"\"\"Make the given class un-picklable.\"\"\"\n    def _break_on_call_reduce(self):\n        raise TypeError('%r cannot be pickled' % self)\n    cls.__reduce__ = _break_on_call_reduce\n    cls.__module__ = '<unknown>'",
  "class _EnumDict(dict):\n    \"\"\"Track enum member order and ensure member names are not reused.\n\n    EnumMeta will use the names found in self._member_names as the\n    enumeration member names.\n\n    \"\"\"\n    def __init__(self):\n        super(_EnumDict, self).__init__()\n        self._member_names = []\n\n    def __setitem__(self, key, value):\n        \"\"\"Changes anything not dundered or not a descriptor.\n\n        If a descriptor is added with the same name as an enum member, the name\n        is removed from _member_names (this may leave a hole in the numerical\n        sequence of values).\n\n        If an enum member name is used twice, an error is raised; duplicate\n        values are not checked for.\n\n        Single underscore (sunder) names are reserved.\n\n        Note:   in 3.x __order__ is simply discarded as a not necessary piece\n                leftover from 2.x\n\n        \"\"\"\n        if pyver >= 3.0 and key == '__order__':\n                return\n        if _is_sunder(key):\n            raise ValueError('_names_ are reserved for future Enum use')\n        elif _is_dunder(key):\n            pass\n        elif key in self._member_names:\n            # descriptor overwriting an enum?\n            raise TypeError('Attempted to reuse key: %r' % key)\n        elif not _is_descriptor(value):\n            if key in self:\n                # enum overwriting a descriptor?\n                raise TypeError('Key already defined as: %r' % self[key])\n            self._member_names.append(key)\n        super(_EnumDict, self).__setitem__(key, value)",
  "class EnumMeta(type):\n    \"\"\"Metaclass for Enum\"\"\"\n    @classmethod\n    def __prepare__(metacls, cls, bases):\n        return _EnumDict()\n\n    def __new__(metacls, cls, bases, classdict):\n        # an Enum class is final once enumeration items have been defined; it\n        # cannot be mixed with other types (int, float, etc.) if it has an\n        # inherited __new__ unless a new __new__ is defined (or the resulting\n        # class will fail).\n        if type(classdict) is dict:\n            original_dict = classdict\n            classdict = _EnumDict()\n            for k, v in original_dict.items():\n                classdict[k] = v\n\n        member_type, first_enum = metacls._get_mixins_(bases)\n        #if member_type is object:\n        #    use_args = False\n        #else:\n        #    use_args = True\n        __new__, save_new, use_args = metacls._find_new_(classdict, member_type,\n                                                        first_enum)\n        # save enum items into separate mapping so they don't get baked into\n        # the new class\n        members = dict((k, classdict[k]) for k in classdict._member_names)\n        for name in classdict._member_names:\n            del classdict[name]\n\n        # py2 support for definition order\n        __order__ = classdict.get('__order__')\n        if __order__ is None:\n            __order__ = classdict._member_names\n            if pyver < 3.0:\n                order_specified = False\n            else:\n                order_specified = True\n        else:\n            del classdict['__order__']\n            order_specified = True\n            if pyver < 3.0:\n                __order__ = __order__.replace(',', ' ').split()\n                aliases = [name for name in members if name not in __order__]\n                __order__ += aliases\n\n        # check for illegal enum names (any others?)\n        invalid_names = set(members) & set(['mro'])\n        if invalid_names:\n            raise ValueError('Invalid enum member name(s): %s' % (\n                ', '.join(invalid_names), ))\n\n        # create our new Enum type\n        enum_class = super(EnumMeta, metacls).__new__(metacls, cls, bases, classdict)\n        enum_class._member_names_ = []               # names in random order\n        enum_class._member_map_ = {}                 # name->value map\n        enum_class._member_type_ = member_type\n\n        # Reverse value->name map for hashable values.\n        enum_class._value2member_map_ = {}\n\n        # check for a __getnewargs__, and if not present sabotage\n        # pickling, since it won't work anyway\n        if (member_type is not object and\n            member_type.__dict__.get('__getnewargs__') is None\n            ):\n            _make_class_unpicklable(enum_class)\n\n        # instantiate them, checking for duplicates as we go\n        # we instantiate first instead of checking for duplicates first in case\n        # a custom __new__ is doing something funky with the values -- such as\n        # auto-numbering ;)\n        if __new__ is None:\n            __new__ = enum_class.__new__\n        for member_name in __order__:\n            value = members[member_name]\n            if not isinstance(value, tuple):\n                args = (value, )\n            else:\n                args = value\n            if member_type is tuple:   # special case for tuple enums\n                args = (args, )     # wrap it one more time\n            if not use_args or not args:\n                enum_member = __new__(enum_class)\n                if not hasattr(enum_member, '_value_'):\n                    enum_member._value_ = value\n            else:\n                enum_member = __new__(enum_class, *args)\n                if not hasattr(enum_member, '_value_'):\n                    enum_member._value_ = member_type(*args)\n            value = enum_member._value_\n            enum_member._name_ = member_name\n            enum_member.__objclass__ = enum_class\n            enum_member.__init__(*args)\n            # If another member with the same value was already defined, the\n            # new member becomes an alias to the existing one.\n            for name, canonical_member in enum_class._member_map_.items():\n                if canonical_member.value == enum_member._value_:\n                    enum_member = canonical_member\n                    break\n            else:\n                # Aliases don't appear in member names (only in __members__).\n                enum_class._member_names_.append(member_name)\n            enum_class._member_map_[member_name] = enum_member\n            try:\n                # This may fail if value is not hashable. We can't add the value\n                # to the map, and by-value lookups for this value will be\n                # linear.\n                enum_class._value2member_map_[value] = enum_member\n            except TypeError:\n                pass\n\n        # in Python2.x we cannot know definition order, so go with value order\n        # unless __order__ was specified in the class definition\n        if not order_specified:\n            enum_class._member_names_ = [\n                e[0] for e in sorted(\n                [(name, enum_class._member_map_[name]) for name in enum_class._member_names_],\n                 key=lambda t: t[1]._value_\n                        )]\n\n        # double check that repr and friends are not the mixin's or various\n        # things break (such as pickle)\n        if Enum is not None:\n            setattr(enum_class, '__getnewargs__', Enum.__getnewargs__)\n        for name in ('__repr__', '__str__', '__format__'):\n            class_method = getattr(enum_class, name)\n            obj_method = getattr(member_type, name, None)\n            enum_method = getattr(first_enum, name, None)\n            if obj_method is not None and obj_method is class_method:\n                setattr(enum_class, name, enum_method)\n\n        # method resolution and int's are not playing nice\n        # Python's less than 2.6 use __cmp__\n\n        if pyver < 2.6:\n\n            if issubclass(enum_class, int):\n                setattr(enum_class, '__cmp__', getattr(int, '__cmp__'))\n\n        elif pyver < 3.0:\n\n            if issubclass(enum_class, int):\n                for method in (\n                        '__le__',\n                        '__lt__',\n                        '__gt__',\n                        '__ge__',\n                        '__eq__',\n                        '__ne__',\n                        '__hash__',\n                        ):\n                    setattr(enum_class, method, getattr(int, method))\n\n        # replace any other __new__ with our own (as long as Enum is not None,\n        # anyway) -- again, this is to support pickle\n        if Enum is not None:\n            # if the user defined their own __new__, save it before it gets\n            # clobbered in case they subclass later\n            if save_new:\n                setattr(enum_class, '__member_new__', enum_class.__dict__['__new__'])\n            setattr(enum_class, '__new__', Enum.__dict__['__new__'])\n        return enum_class\n\n    def __call__(cls, value, names=None, module=None, type=None):\n        \"\"\"Either returns an existing member, or creates a new enum class.\n\n        This method is used both when an enum class is given a value to match\n        to an enumeration member (i.e. Color(3)) and for the functional API\n        (i.e. Color = Enum('Color', names='red green blue')).\n\n        When used for the functional API: `module`, if set, will be stored in\n        the new class' __module__ attribute; `type`, if set, will be mixed in\n        as the first base class.\n\n        Note: if `module` is not set this routine will attempt to discover the\n        calling module by walking the frame stack; if this is unsuccessful\n        the resulting class will not be pickleable.\n\n        \"\"\"\n        if names is None:  # simple value lookup\n            return cls.__new__(cls, value)\n        # otherwise, functional API: we're creating a new Enum type\n        return cls._create_(value, names, module=module, type=type)\n\n    def __contains__(cls, member):\n        return isinstance(member, cls) and member.name in cls._member_map_\n\n    def __delattr__(cls, attr):\n        # nicer error message when someone tries to delete an attribute\n        # (see issue19025).\n        if attr in cls._member_map_:\n            raise AttributeError(\n                    \"%s: cannot delete Enum member.\" % cls.__name__)\n        super(EnumMeta, cls).__delattr__(attr)\n\n    def __dir__(self):\n        return (['__class__', '__doc__', '__members__', '__module__'] +\n                self._member_names_)\n\n    @property\n    def __members__(cls):\n        \"\"\"Returns a mapping of member name->value.\n\n        This mapping lists all enum members, including aliases. Note that this\n        is a copy of the internal mapping.\n\n        \"\"\"\n        return cls._member_map_.copy()\n\n    def __getattr__(cls, name):\n        \"\"\"Return the enum member matching `name`\n\n        We use __getattr__ instead of descriptors or inserting into the enum\n        class' __dict__ in order to support `name` and `value` being both\n        properties for enum members (which live in the class' __dict__) and\n        enum members themselves.\n\n        \"\"\"\n        if _is_dunder(name):\n            raise AttributeError(name)\n        try:\n            return cls._member_map_[name]\n        except KeyError:\n            raise AttributeError(name)\n\n    def __getitem__(cls, name):\n        return cls._member_map_[name]\n\n    def __iter__(cls):\n        return (cls._member_map_[name] for name in cls._member_names_)\n\n    def __reversed__(cls):\n        return (cls._member_map_[name] for name in reversed(cls._member_names_))\n\n    def __len__(cls):\n        return len(cls._member_names_)\n\n    def __repr__(cls):\n        return \"<enum %r>\" % cls.__name__\n\n    def __setattr__(cls, name, value):\n        \"\"\"Block attempts to reassign Enum members.\n\n        A simple assignment to the class namespace only changes one of the\n        several possible ways to get an Enum member from the Enum class,\n        resulting in an inconsistent Enumeration.\n\n        \"\"\"\n        member_map = cls.__dict__.get('_member_map_', {})\n        if name in member_map:\n            raise AttributeError('Cannot reassign members.')\n        super(EnumMeta, cls).__setattr__(name, value)\n\n    def _create_(cls, class_name, names=None, module=None, type=None):\n        \"\"\"Convenience method to create a new Enum class.\n\n        `names` can be:\n\n        * A string containing member names, separated either with spaces or\n          commas.  Values are auto-numbered from 1.\n        * An iterable of member names.  Values are auto-numbered from 1.\n        * An iterable of (member name, value) pairs.\n        * A mapping of member name -> value.\n\n        \"\"\"\n        metacls = cls.__class__\n        if type is None:\n            bases = (cls, )\n        else:\n            bases = (type, cls)\n        classdict = metacls.__prepare__(class_name, bases)\n        __order__ = []\n\n        # special processing needed for names?\n        if isinstance(names, str):\n            names = names.replace(',', ' ').split()\n        if isinstance(names, (tuple, list)) and isinstance(names[0], str):\n            names = [(e, i+1) for (i, e) in enumerate(names)]\n\n        # Here, names is either an iterable of (name, value) or a mapping.\n        for item in names:\n            if isinstance(item, str):\n                member_name, member_value = item, names[item]\n            else:\n                member_name, member_value = item\n            classdict[member_name] = member_value\n            __order__.append(member_name)\n        # only set __order__ in classdict if name/value was not from a mapping\n        if not isinstance(item, str):\n            classdict['__order__'] = ' '.join(__order__)\n        enum_class = metacls.__new__(metacls, class_name, bases, classdict)\n\n        # TODO: replace the frame hack if a blessed way to know the calling\n        # module is ever developed\n        if module is None:\n            try:\n                module = _sys._getframe(2).f_globals['__name__']\n            except (AttributeError, ValueError):\n                pass\n        if module is None:\n            _make_class_unpicklable(enum_class)\n        else:\n            enum_class.__module__ = module\n\n        return enum_class\n\n    @staticmethod\n    def _get_mixins_(bases):\n        \"\"\"Returns the type for creating enum members, and the first inherited\n        enum class.\n\n        bases: the tuple of bases that was given to __new__\n\n        \"\"\"\n        if not bases or Enum is None:\n            return object, Enum\n        \n\n        # double check that we are not subclassing a class with existing\n        # enumeration members; while we're at it, see if any other data\n        # type has been mixed in so we can use the correct __new__\n        member_type = first_enum = None\n        for base in bases:\n            if  (base is not Enum and\n                    issubclass(base, Enum) and\n                    base._member_names_):\n                raise TypeError(\"Cannot extend enumerations\")\n        # base is now the last base in bases\n        if not issubclass(base, Enum):\n            raise TypeError(\"new enumerations must be created as \"\n                    \"`ClassName([mixin_type,] enum_type)`\")\n\n        # get correct mix-in type (either mix-in type of Enum subclass, or\n        # first base if last base is Enum)\n        if not issubclass(bases[0], Enum):\n            member_type = bases[0]     # first data type\n            first_enum = bases[-1]  # enum type\n        else:\n            for base in bases[0].__mro__:\n                # most common: (IntEnum, int, Enum, object)\n                # possible:    (<Enum 'AutoIntEnum'>, <Enum 'IntEnum'>,\n                #               <class 'int'>, <Enum 'Enum'>,\n                #               <class 'object'>)\n                if issubclass(base, Enum):\n                    if first_enum is None:\n                        first_enum = base\n                else:\n                    if member_type is None:\n                        member_type = base\n\n        return member_type, first_enum\n\n    if pyver < 3.0:\n        @staticmethod\n        def _find_new_(classdict, member_type, first_enum):\n            \"\"\"Returns the __new__ to be used for creating the enum members.\n\n            classdict: the class dictionary given to __new__\n            member_type: the data type whose __new__ will be used by default\n            first_enum: enumeration to check for an overriding __new__\n\n            \"\"\"\n            # now find the correct __new__, checking to see of one was defined\n            # by the user; also check earlier enum classes in case a __new__ was\n            # saved as __member_new__\n            __new__ = classdict.get('__new__', None)\n            if __new__:\n                return None, True, True      # __new__, save_new, use_args\n\n            N__new__ = getattr(None, '__new__')\n            O__new__ = getattr(object, '__new__')\n            if Enum is None:\n                E__new__ = N__new__\n            else:\n                E__new__ = Enum.__dict__['__new__']\n            # check all possibles for __member_new__ before falling back to\n            # __new__\n            for method in ('__member_new__', '__new__'):\n                for possible in (member_type, first_enum):\n                    try:\n                        target = possible.__dict__[method]\n                    except (AttributeError, KeyError):\n                        target = getattr(possible, method, None)\n                    if target not in [\n                            None,\n                            N__new__,\n                            O__new__,\n                            E__new__,\n                            ]:\n                        if method == '__member_new__':\n                            classdict['__new__'] = target\n                            return None, False, True\n                        if isinstance(target, staticmethod):\n                            target = target.__get__(member_type)\n                        __new__ = target\n                        break\n                if __new__ is not None:\n                    break\n            else:\n                __new__ = object.__new__\n\n            # if a non-object.__new__ is used then whatever value/tuple was\n            # assigned to the enum member name will be passed to __new__ and to the\n            # new enum member's __init__\n            if __new__ is object.__new__:\n                use_args = False\n            else:\n                use_args = True\n\n            return __new__, False, use_args\n    else:\n        @staticmethod\n        def _find_new_(classdict, member_type, first_enum):\n            \"\"\"Returns the __new__ to be used for creating the enum members.\n\n            classdict: the class dictionary given to __new__\n            member_type: the data type whose __new__ will be used by default\n            first_enum: enumeration to check for an overriding __new__\n\n            \"\"\"\n            # now find the correct __new__, checking to see of one was defined\n            # by the user; also check earlier enum classes in case a __new__ was\n            # saved as __member_new__\n            __new__ = classdict.get('__new__', None)\n\n            # should __new__ be saved as __member_new__ later?\n            save_new = __new__ is not None\n\n            if __new__ is None:\n                # check all possibles for __member_new__ before falling back to\n                # __new__\n                for method in ('__member_new__', '__new__'):\n                    for possible in (member_type, first_enum):\n                        target = getattr(possible, method, None)\n                        if target not in (\n                                None,\n                                None.__new__,\n                                object.__new__,\n                                Enum.__new__,\n                                ):\n                            __new__ = target\n                            break\n                    if __new__ is not None:\n                        break\n                else:\n                    __new__ = object.__new__\n\n            # if a non-object.__new__ is used then whatever value/tuple was\n            # assigned to the enum member name will be passed to __new__ and to the\n            # new enum member's __init__\n            if __new__ is object.__new__:\n                use_args = False\n            else:\n                use_args = True\n\n            return __new__, save_new, use_args",
  "def __new__(cls, value):\n    # all enum instances are actually created during class construction\n    # without calling this method; this method is called by the metaclass'\n    # __call__ (i.e. Color(3) ), and by pickle\n    if type(value) is cls:\n        # For lookups like Color(Color.red)\n        value = value.value\n        #return value\n    # by-value search for a matching enum member\n    # see if it's in the reverse mapping (for hashable values)\n    try:\n        if value in cls._value2member_map_:\n            return cls._value2member_map_[value]\n    except TypeError:\n        # not there, now do long search -- O(n) behavior\n        for member in cls._member_map_.values():\n            if member.value == value:\n                return member\n    raise ValueError(\"%s is not a valid %s\" % (value, cls.__name__))",
  "def __repr__(self):\n    return \"<%s.%s: %r>\" % (\n            self.__class__.__name__, self._name_, self._value_)",
  "def __str__(self):\n    return \"%s.%s\" % (self.__class__.__name__, self._name_)",
  "def __dir__(self):\n    added_behavior = [m for m in self.__class__.__dict__ if m[0] != '_']\n    return (['__class__', '__doc__', '__module__', 'name', 'value'] + added_behavior)",
  "def __format__(self, format_spec):\n    # mixed-in Enums should use the mixed-in type's __format__, otherwise\n    # we can get strange results with the Enum name showing up instead of\n    # the value\n\n    # pure Enum branch\n    if self._member_type_ is object:\n        cls = str\n        val = str(self)\n    # mix-in branch\n    else:\n        cls = self._member_type_\n        val = self.value\n    return cls.__format__(val, format_spec)",
  "def __eq__(self, other):\n    if type(other) is self.__class__:\n        return self is other\n    return NotImplemented",
  "def __ne__(self, other):\n    if type(other) is self.__class__:\n        return self is not other\n    return NotImplemented",
  "def __getnewargs__(self):\n    return (self._value_, )",
  "def __hash__(self):\n    return hash(self._name_)",
  "def name(self):\n    return self._name_",
  "def value(self):\n    return self._value_",
  "class IntEnum(int, Enum):\n    \"\"\"Enum where members are also (and must be) ints\"\"\"",
  "def unique(enumeration):\n    \"\"\"Class decorator that ensures only unique members exist in an enumeration.\"\"\"\n    duplicates = []\n    for name, member in enumeration.__members__.items():\n        if name != member.name:\n            duplicates.append((name, member.name))\n    if duplicates:\n        duplicate_names = ', '.join(\n                [\"%s -> %s\" % (alias, name) for (alias, name) in duplicates]\n                )\n        raise ValueError('duplicate names found in %r: %s' %\n                (enumeration, duplicate_names)\n                )\n    return enumeration",
  "def __init__(self, fget=None):\n        self.fget = fget",
  "def __get__(self, instance, ownerclass=None):\n        if instance is None:\n            raise AttributeError()\n        return self.fget(instance)",
  "def __set__(self, instance, value):\n        raise AttributeError(\"can't set attribute\")",
  "def __delete__(self, instance):\n        raise AttributeError(\"can't delete attribute\")",
  "def _break_on_call_reduce(self):\n        raise TypeError('%r cannot be pickled' % self)",
  "def __init__(self):\n        super(_EnumDict, self).__init__()\n        self._member_names = []",
  "def __setitem__(self, key, value):\n        \"\"\"Changes anything not dundered or not a descriptor.\n\n        If a descriptor is added with the same name as an enum member, the name\n        is removed from _member_names (this may leave a hole in the numerical\n        sequence of values).\n\n        If an enum member name is used twice, an error is raised; duplicate\n        values are not checked for.\n\n        Single underscore (sunder) names are reserved.\n\n        Note:   in 3.x __order__ is simply discarded as a not necessary piece\n                leftover from 2.x\n\n        \"\"\"\n        if pyver >= 3.0 and key == '__order__':\n                return\n        if _is_sunder(key):\n            raise ValueError('_names_ are reserved for future Enum use')\n        elif _is_dunder(key):\n            pass\n        elif key in self._member_names:\n            # descriptor overwriting an enum?\n            raise TypeError('Attempted to reuse key: %r' % key)\n        elif not _is_descriptor(value):\n            if key in self:\n                # enum overwriting a descriptor?\n                raise TypeError('Key already defined as: %r' % self[key])\n            self._member_names.append(key)\n        super(_EnumDict, self).__setitem__(key, value)",
  "def __prepare__(metacls, cls, bases):\n        return _EnumDict()",
  "def __new__(metacls, cls, bases, classdict):\n        # an Enum class is final once enumeration items have been defined; it\n        # cannot be mixed with other types (int, float, etc.) if it has an\n        # inherited __new__ unless a new __new__ is defined (or the resulting\n        # class will fail).\n        if type(classdict) is dict:\n            original_dict = classdict\n            classdict = _EnumDict()\n            for k, v in original_dict.items():\n                classdict[k] = v\n\n        member_type, first_enum = metacls._get_mixins_(bases)\n        #if member_type is object:\n        #    use_args = False\n        #else:\n        #    use_args = True\n        __new__, save_new, use_args = metacls._find_new_(classdict, member_type,\n                                                        first_enum)\n        # save enum items into separate mapping so they don't get baked into\n        # the new class\n        members = dict((k, classdict[k]) for k in classdict._member_names)\n        for name in classdict._member_names:\n            del classdict[name]\n\n        # py2 support for definition order\n        __order__ = classdict.get('__order__')\n        if __order__ is None:\n            __order__ = classdict._member_names\n            if pyver < 3.0:\n                order_specified = False\n            else:\n                order_specified = True\n        else:\n            del classdict['__order__']\n            order_specified = True\n            if pyver < 3.0:\n                __order__ = __order__.replace(',', ' ').split()\n                aliases = [name for name in members if name not in __order__]\n                __order__ += aliases\n\n        # check for illegal enum names (any others?)\n        invalid_names = set(members) & set(['mro'])\n        if invalid_names:\n            raise ValueError('Invalid enum member name(s): %s' % (\n                ', '.join(invalid_names), ))\n\n        # create our new Enum type\n        enum_class = super(EnumMeta, metacls).__new__(metacls, cls, bases, classdict)\n        enum_class._member_names_ = []               # names in random order\n        enum_class._member_map_ = {}                 # name->value map\n        enum_class._member_type_ = member_type\n\n        # Reverse value->name map for hashable values.\n        enum_class._value2member_map_ = {}\n\n        # check for a __getnewargs__, and if not present sabotage\n        # pickling, since it won't work anyway\n        if (member_type is not object and\n            member_type.__dict__.get('__getnewargs__') is None\n            ):\n            _make_class_unpicklable(enum_class)\n\n        # instantiate them, checking for duplicates as we go\n        # we instantiate first instead of checking for duplicates first in case\n        # a custom __new__ is doing something funky with the values -- such as\n        # auto-numbering ;)\n        if __new__ is None:\n            __new__ = enum_class.__new__\n        for member_name in __order__:\n            value = members[member_name]\n            if not isinstance(value, tuple):\n                args = (value, )\n            else:\n                args = value\n            if member_type is tuple:   # special case for tuple enums\n                args = (args, )     # wrap it one more time\n            if not use_args or not args:\n                enum_member = __new__(enum_class)\n                if not hasattr(enum_member, '_value_'):\n                    enum_member._value_ = value\n            else:\n                enum_member = __new__(enum_class, *args)\n                if not hasattr(enum_member, '_value_'):\n                    enum_member._value_ = member_type(*args)\n            value = enum_member._value_\n            enum_member._name_ = member_name\n            enum_member.__objclass__ = enum_class\n            enum_member.__init__(*args)\n            # If another member with the same value was already defined, the\n            # new member becomes an alias to the existing one.\n            for name, canonical_member in enum_class._member_map_.items():\n                if canonical_member.value == enum_member._value_:\n                    enum_member = canonical_member\n                    break\n            else:\n                # Aliases don't appear in member names (only in __members__).\n                enum_class._member_names_.append(member_name)\n            enum_class._member_map_[member_name] = enum_member\n            try:\n                # This may fail if value is not hashable. We can't add the value\n                # to the map, and by-value lookups for this value will be\n                # linear.\n                enum_class._value2member_map_[value] = enum_member\n            except TypeError:\n                pass\n\n        # in Python2.x we cannot know definition order, so go with value order\n        # unless __order__ was specified in the class definition\n        if not order_specified:\n            enum_class._member_names_ = [\n                e[0] for e in sorted(\n                [(name, enum_class._member_map_[name]) for name in enum_class._member_names_],\n                 key=lambda t: t[1]._value_\n                        )]\n\n        # double check that repr and friends are not the mixin's or various\n        # things break (such as pickle)\n        if Enum is not None:\n            setattr(enum_class, '__getnewargs__', Enum.__getnewargs__)\n        for name in ('__repr__', '__str__', '__format__'):\n            class_method = getattr(enum_class, name)\n            obj_method = getattr(member_type, name, None)\n            enum_method = getattr(first_enum, name, None)\n            if obj_method is not None and obj_method is class_method:\n                setattr(enum_class, name, enum_method)\n\n        # method resolution and int's are not playing nice\n        # Python's less than 2.6 use __cmp__\n\n        if pyver < 2.6:\n\n            if issubclass(enum_class, int):\n                setattr(enum_class, '__cmp__', getattr(int, '__cmp__'))\n\n        elif pyver < 3.0:\n\n            if issubclass(enum_class, int):\n                for method in (\n                        '__le__',\n                        '__lt__',\n                        '__gt__',\n                        '__ge__',\n                        '__eq__',\n                        '__ne__',\n                        '__hash__',\n                        ):\n                    setattr(enum_class, method, getattr(int, method))\n\n        # replace any other __new__ with our own (as long as Enum is not None,\n        # anyway) -- again, this is to support pickle\n        if Enum is not None:\n            # if the user defined their own __new__, save it before it gets\n            # clobbered in case they subclass later\n            if save_new:\n                setattr(enum_class, '__member_new__', enum_class.__dict__['__new__'])\n            setattr(enum_class, '__new__', Enum.__dict__['__new__'])\n        return enum_class",
  "def __call__(cls, value, names=None, module=None, type=None):\n        \"\"\"Either returns an existing member, or creates a new enum class.\n\n        This method is used both when an enum class is given a value to match\n        to an enumeration member (i.e. Color(3)) and for the functional API\n        (i.e. Color = Enum('Color', names='red green blue')).\n\n        When used for the functional API: `module`, if set, will be stored in\n        the new class' __module__ attribute; `type`, if set, will be mixed in\n        as the first base class.\n\n        Note: if `module` is not set this routine will attempt to discover the\n        calling module by walking the frame stack; if this is unsuccessful\n        the resulting class will not be pickleable.\n\n        \"\"\"\n        if names is None:  # simple value lookup\n            return cls.__new__(cls, value)\n        # otherwise, functional API: we're creating a new Enum type\n        return cls._create_(value, names, module=module, type=type)",
  "def __contains__(cls, member):\n        return isinstance(member, cls) and member.name in cls._member_map_",
  "def __delattr__(cls, attr):\n        # nicer error message when someone tries to delete an attribute\n        # (see issue19025).\n        if attr in cls._member_map_:\n            raise AttributeError(\n                    \"%s: cannot delete Enum member.\" % cls.__name__)\n        super(EnumMeta, cls).__delattr__(attr)",
  "def __dir__(self):\n        return (['__class__', '__doc__', '__members__', '__module__'] +\n                self._member_names_)",
  "def __members__(cls):\n        \"\"\"Returns a mapping of member name->value.\n\n        This mapping lists all enum members, including aliases. Note that this\n        is a copy of the internal mapping.\n\n        \"\"\"\n        return cls._member_map_.copy()",
  "def __getattr__(cls, name):\n        \"\"\"Return the enum member matching `name`\n\n        We use __getattr__ instead of descriptors or inserting into the enum\n        class' __dict__ in order to support `name` and `value` being both\n        properties for enum members (which live in the class' __dict__) and\n        enum members themselves.\n\n        \"\"\"\n        if _is_dunder(name):\n            raise AttributeError(name)\n        try:\n            return cls._member_map_[name]\n        except KeyError:\n            raise AttributeError(name)",
  "def __getitem__(cls, name):\n        return cls._member_map_[name]",
  "def __iter__(cls):\n        return (cls._member_map_[name] for name in cls._member_names_)",
  "def __reversed__(cls):\n        return (cls._member_map_[name] for name in reversed(cls._member_names_))",
  "def __len__(cls):\n        return len(cls._member_names_)",
  "def __repr__(cls):\n        return \"<enum %r>\" % cls.__name__",
  "def __setattr__(cls, name, value):\n        \"\"\"Block attempts to reassign Enum members.\n\n        A simple assignment to the class namespace only changes one of the\n        several possible ways to get an Enum member from the Enum class,\n        resulting in an inconsistent Enumeration.\n\n        \"\"\"\n        member_map = cls.__dict__.get('_member_map_', {})\n        if name in member_map:\n            raise AttributeError('Cannot reassign members.')\n        super(EnumMeta, cls).__setattr__(name, value)",
  "def _create_(cls, class_name, names=None, module=None, type=None):\n        \"\"\"Convenience method to create a new Enum class.\n\n        `names` can be:\n\n        * A string containing member names, separated either with spaces or\n          commas.  Values are auto-numbered from 1.\n        * An iterable of member names.  Values are auto-numbered from 1.\n        * An iterable of (member name, value) pairs.\n        * A mapping of member name -> value.\n\n        \"\"\"\n        metacls = cls.__class__\n        if type is None:\n            bases = (cls, )\n        else:\n            bases = (type, cls)\n        classdict = metacls.__prepare__(class_name, bases)\n        __order__ = []\n\n        # special processing needed for names?\n        if isinstance(names, str):\n            names = names.replace(',', ' ').split()\n        if isinstance(names, (tuple, list)) and isinstance(names[0], str):\n            names = [(e, i+1) for (i, e) in enumerate(names)]\n\n        # Here, names is either an iterable of (name, value) or a mapping.\n        for item in names:\n            if isinstance(item, str):\n                member_name, member_value = item, names[item]\n            else:\n                member_name, member_value = item\n            classdict[member_name] = member_value\n            __order__.append(member_name)\n        # only set __order__ in classdict if name/value was not from a mapping\n        if not isinstance(item, str):\n            classdict['__order__'] = ' '.join(__order__)\n        enum_class = metacls.__new__(metacls, class_name, bases, classdict)\n\n        # TODO: replace the frame hack if a blessed way to know the calling\n        # module is ever developed\n        if module is None:\n            try:\n                module = _sys._getframe(2).f_globals['__name__']\n            except (AttributeError, ValueError):\n                pass\n        if module is None:\n            _make_class_unpicklable(enum_class)\n        else:\n            enum_class.__module__ = module\n\n        return enum_class",
  "def _get_mixins_(bases):\n        \"\"\"Returns the type for creating enum members, and the first inherited\n        enum class.\n\n        bases: the tuple of bases that was given to __new__\n\n        \"\"\"\n        if not bases or Enum is None:\n            return object, Enum\n        \n\n        # double check that we are not subclassing a class with existing\n        # enumeration members; while we're at it, see if any other data\n        # type has been mixed in so we can use the correct __new__\n        member_type = first_enum = None\n        for base in bases:\n            if  (base is not Enum and\n                    issubclass(base, Enum) and\n                    base._member_names_):\n                raise TypeError(\"Cannot extend enumerations\")\n        # base is now the last base in bases\n        if not issubclass(base, Enum):\n            raise TypeError(\"new enumerations must be created as \"\n                    \"`ClassName([mixin_type,] enum_type)`\")\n\n        # get correct mix-in type (either mix-in type of Enum subclass, or\n        # first base if last base is Enum)\n        if not issubclass(bases[0], Enum):\n            member_type = bases[0]     # first data type\n            first_enum = bases[-1]  # enum type\n        else:\n            for base in bases[0].__mro__:\n                # most common: (IntEnum, int, Enum, object)\n                # possible:    (<Enum 'AutoIntEnum'>, <Enum 'IntEnum'>,\n                #               <class 'int'>, <Enum 'Enum'>,\n                #               <class 'object'>)\n                if issubclass(base, Enum):\n                    if first_enum is None:\n                        first_enum = base\n                else:\n                    if member_type is None:\n                        member_type = base\n\n        return member_type, first_enum",
  "def __cmp__(self, other):\n        if type(other) is self.__class__:\n            if self is other:\n                return 0\n            return -1\n        return NotImplemented\n        raise TypeError(\"unorderable types: %s() and %s()\" % (self.__class__.__name__, other.__class__.__name__))",
  "def __le__(self, other):\n        raise TypeError(\"unorderable types: %s() <= %s()\" % (self.__class__.__name__, other.__class__.__name__))",
  "def __lt__(self, other):\n        raise TypeError(\"unorderable types: %s() < %s()\" % (self.__class__.__name__, other.__class__.__name__))",
  "def __ge__(self, other):\n        raise TypeError(\"unorderable types: %s() >= %s()\" % (self.__class__.__name__, other.__class__.__name__))",
  "def __gt__(self, other):\n        raise TypeError(\"unorderable types: %s() > %s()\" % (self.__class__.__name__, other.__class__.__name__))",
  "def any(iterable):\n        for element in iterable:\n            if element:\n                return True\n        return False",
  "def _find_new_(classdict, member_type, first_enum):\n            \"\"\"Returns the __new__ to be used for creating the enum members.\n\n            classdict: the class dictionary given to __new__\n            member_type: the data type whose __new__ will be used by default\n            first_enum: enumeration to check for an overriding __new__\n\n            \"\"\"\n            # now find the correct __new__, checking to see of one was defined\n            # by the user; also check earlier enum classes in case a __new__ was\n            # saved as __member_new__\n            __new__ = classdict.get('__new__', None)\n            if __new__:\n                return None, True, True      # __new__, save_new, use_args\n\n            N__new__ = getattr(None, '__new__')\n            O__new__ = getattr(object, '__new__')\n            if Enum is None:\n                E__new__ = N__new__\n            else:\n                E__new__ = Enum.__dict__['__new__']\n            # check all possibles for __member_new__ before falling back to\n            # __new__\n            for method in ('__member_new__', '__new__'):\n                for possible in (member_type, first_enum):\n                    try:\n                        target = possible.__dict__[method]\n                    except (AttributeError, KeyError):\n                        target = getattr(possible, method, None)\n                    if target not in [\n                            None,\n                            N__new__,\n                            O__new__,\n                            E__new__,\n                            ]:\n                        if method == '__member_new__':\n                            classdict['__new__'] = target\n                            return None, False, True\n                        if isinstance(target, staticmethod):\n                            target = target.__get__(member_type)\n                        __new__ = target\n                        break\n                if __new__ is not None:\n                    break\n            else:\n                __new__ = object.__new__\n\n            # if a non-object.__new__ is used then whatever value/tuple was\n            # assigned to the enum member name will be passed to __new__ and to the\n            # new enum member's __init__\n            if __new__ is object.__new__:\n                use_args = False\n            else:\n                use_args = True\n\n            return __new__, False, use_args",
  "def _find_new_(classdict, member_type, first_enum):\n            \"\"\"Returns the __new__ to be used for creating the enum members.\n\n            classdict: the class dictionary given to __new__\n            member_type: the data type whose __new__ will be used by default\n            first_enum: enumeration to check for an overriding __new__\n\n            \"\"\"\n            # now find the correct __new__, checking to see of one was defined\n            # by the user; also check earlier enum classes in case a __new__ was\n            # saved as __member_new__\n            __new__ = classdict.get('__new__', None)\n\n            # should __new__ be saved as __member_new__ later?\n            save_new = __new__ is not None\n\n            if __new__ is None:\n                # check all possibles for __member_new__ before falling back to\n                # __new__\n                for method in ('__member_new__', '__new__'):\n                    for possible in (member_type, first_enum):\n                        target = getattr(possible, method, None)\n                        if target not in (\n                                None,\n                                None.__new__,\n                                object.__new__,\n                                Enum.__new__,\n                                ):\n                            __new__ = target\n                            break\n                    if __new__ is not None:\n                        break\n                else:\n                    __new__ = object.__new__\n\n            # if a non-object.__new__ is used then whatever value/tuple was\n            # assigned to the enum member name will be passed to __new__ and to the\n            # new enum member's __init__\n            if __new__ is object.__new__:\n                use_args = False\n            else:\n                use_args = True\n\n            return __new__, save_new, use_args",
  "class DCERPCSessionError(DCERPCException):\n    def __init__(self, error_string=None, error_code=None, packet=None):\n        DCERPCException.__init__(self, error_string, error_code, packet)\n\n    def __str__( self ):\n        key = self.error_code\n        if key in system_errors.ERROR_MESSAGES:\n            error_msg_short = system_errors.ERROR_MESSAGES[key][0]\n            error_msg_verbose = system_errors.ERROR_MESSAGES[key][1] \n            return 'RPRN SessionError: code: 0x%x - %s - %s' % (self.error_code, error_msg_short, error_msg_verbose)\n        else:\n            return 'RPRN SessionError: unknown error code: 0x%x' % self.error_code",
  "class PSTRING_HANDLE(NDRPOINTER):\n    referent = (\n        ('Data', STRING_HANDLE),\n    )",
  "class PRINTER_HANDLE(NDRSTRUCT):\n    structure =  (\n        ('Data','20s=b\"\"'),\n    )\n    def getAlignment(self):\n        if self._isNDR64 is True:\n            return 8\n        else:\n            return 4",
  "class BYTE_ARRAY(NDRUniConformantArray):\n    item = 'c'",
  "class PBYTE_ARRAY(NDRPOINTER):\n    referent = (\n        ('Data', BYTE_ARRAY),\n    )",
  "class DEVMODE_CONTAINER(NDRSTRUCT):\n    structure =  (\n        ('cbBuf',DWORD),\n        ('pDevMode',PBYTE_ARRAY),\n    )",
  "class SPLCLIENT_INFO_1(NDRSTRUCT):\n    structure =  (\n        ('dwSize',DWORD),\n        ('pMachineName',LPWSTR),\n        ('pUserName',LPWSTR),\n        ('dwBuildNum',DWORD),\n        ('dwMajorVersion',DWORD),\n        ('dwMinorVersion',DWORD),\n        ('wProcessorArchitecture',USHORT),\n    )",
  "class PSPLCLIENT_INFO_1(NDRPOINTER):\n    referent = (\n        ('Data', SPLCLIENT_INFO_1),\n    )",
  "class SPLCLIENT_INFO_2(NDRSTRUCT):\n    structure =  (\n        ('notUsed',ULONGLONG),\n    )",
  "class PSPLCLIENT_INFO_2(NDRPOINTER):\n    referent = (\n        ('Data', SPLCLIENT_INFO_2),\n    )",
  "class SPLCLIENT_INFO_3(NDRSTRUCT):\n    structure =  (\n        ('cbSize',UINT),\n        ('dwFlags',DWORD),\n        ('dwFlags',DWORD),\n        ('pMachineName',LPWSTR),\n        ('pUserName',LPWSTR),\n        ('dwBuildNum',DWORD),\n        ('dwMajorVersion',DWORD),\n        ('dwMinorVersion',DWORD),\n        ('wProcessorArchitecture',USHORT),\n        ('hSplPrinter',ULONGLONG),\n    )",
  "class PSPLCLIENT_INFO_3(NDRPOINTER):\n    referent = (\n        ('Data', SPLCLIENT_INFO_3),\n    )",
  "class DRIVER_INFO_1(NDRSTRUCT):\n    structure = (\n        ('pName', STRING_HANDLE ),\n    )",
  "class PDRIVER_INFO_1(NDRPOINTER):\n    referent = (\n        ('Data', DRIVER_INFO_1),\n    )",
  "class DRIVER_INFO_2(NDRSTRUCT):\n    structure = (\n        ('cVersion',DWORD),\n        ('pName', LPWSTR),\n        ('pEnvironment', LPWSTR),\n        ('pDriverPath', LPWSTR),\n        ('pDataFile', LPWSTR),\n        ('pConfigFile', LPWSTR),\n    )",
  "class PDRIVER_INFO_2(NDRPOINTER):\n    referent = (\n        ('Data', DRIVER_INFO_2),\n    )",
  "class DRIVER_INFO_UNION(NDRUNION):\n    commonHdr = (\n        ('tag', ULONG),\n    )\n    union = {\n        1 : ('pNotUsed', PDRIVER_INFO_1),\n        2 : ('Level2', PDRIVER_INFO_2),\n    }",
  "class DRIVER_CONTAINER(NDRSTRUCT):\n    structure =  (\n        ('Level', DWORD),\n        ('DriverInfo', DRIVER_INFO_UNION),\n    )",
  "class CLIENT_INFO_UNION(NDRUNION):\n    commonHdr = (\n        ('tag', ULONG),\n    )\n    union = {\n        1 : ('pClientInfo1', PSPLCLIENT_INFO_1),\n        2 : ('pNotUsed1', PSPLCLIENT_INFO_2),\n        3 : ('pNotUsed2', PSPLCLIENT_INFO_3),\n    }",
  "class SPLCLIENT_CONTAINER(NDRSTRUCT):\n    structure =  (\n        ('Level',DWORD),\n        ('ClientInfo',CLIENT_INFO_UNION),\n    )",
  "class USHORT_ARRAY(NDRUniConformantArray):\n    item = '<H'",
  "class PUSHORT_ARRAY(NDRPOINTER):\n    referent = (\n        ('Data', USHORT_ARRAY),\n    )",
  "class RPC_V2_NOTIFY_OPTIONS_TYPE(NDRSTRUCT):\n    structure =  (\n        ('Type',USHORT),\n        ('Reserved0',USHORT),\n        ('Reserved1',DWORD),\n        ('Reserved2',DWORD),\n        ('Count',DWORD),\n        ('pFields',PUSHORT_ARRAY),\n    )",
  "class PRPC_V2_NOTIFY_OPTIONS_TYPE_ARRAY(NDRPOINTER):\n    referent = (\n        ('Data', RPC_V2_NOTIFY_OPTIONS_TYPE),\n    )",
  "class RPC_V2_NOTIFY_OPTIONS(NDRSTRUCT):\n    structure =  (\n        ('Version',DWORD),\n        ('Reserved',DWORD),\n        ('Count',DWORD),\n        ('pTypes',PRPC_V2_NOTIFY_OPTIONS_TYPE_ARRAY),\n    )",
  "class PRPC_V2_NOTIFY_OPTIONS(NDRPOINTER):\n    referent = (\n        ('Data', RPC_V2_NOTIFY_OPTIONS),\n    )",
  "class RpcEnumPrinters(NDRCALL):\n    opnum = 0\n    structure = (\n       ('Flags', DWORD),\n       ('Name', STRING_HANDLE),\n       ('Level', DWORD),\n       ('pPrinterEnum', PBYTE_ARRAY),\n       ('cbBuf', DWORD),\n    )",
  "class RpcEnumPrintersResponse(NDRCALL):\n    structure = (\n       ('pPrinterEnum', PBYTE_ARRAY),\n       ('pcbNeeded', DWORD),\n       ('pcReturned', DWORD),\n       ('ErrorCode', ULONG),\n    )",
  "class RpcOpenPrinter(NDRCALL):\n    opnum = 1\n    structure = (\n       ('pPrinterName', STRING_HANDLE),\n       ('pDatatype', LPWSTR),\n       ('pDevModeContainer', DEVMODE_CONTAINER),\n       ('AccessRequired', DWORD),\n    )",
  "class RpcOpenPrinterResponse(NDRCALL):\n    structure = (\n       ('pHandle', PRINTER_HANDLE),\n       ('ErrorCode', ULONG),\n    )",
  "class RpcClosePrinter(NDRCALL):\n    opnum = 29\n    structure = (\n       ('phPrinter', PRINTER_HANDLE),\n    )",
  "class RpcClosePrinterResponse(NDRCALL):\n    structure = (\n       ('phPrinter', PRINTER_HANDLE),\n       ('ErrorCode', ULONG),\n    )",
  "class RpcRemoteFindFirstPrinterChangeNotificationEx(NDRCALL):\n    opnum = 65\n    structure = (\n       ('hPrinter', PRINTER_HANDLE),\n       ('fdwFlags', DWORD),\n       ('fdwOptions', DWORD),\n       ('pszLocalMachine', LPWSTR),\n       ('dwPrinterLocal', DWORD),\n       ('pOptions', PRPC_V2_NOTIFY_OPTIONS),\n    )",
  "class RpcRemoteFindFirstPrinterChangeNotificationExResponse(NDRCALL):\n    structure = (\n       ('ErrorCode', ULONG),\n    )",
  "class RpcOpenPrinterEx(NDRCALL):\n    opnum = 69\n    structure = (\n       ('pPrinterName', STRING_HANDLE),\n       ('pDatatype', LPWSTR),\n       ('pDevModeContainer', DEVMODE_CONTAINER),\n       ('AccessRequired', DWORD),\n       ('pClientInfo', SPLCLIENT_CONTAINER),\n    )",
  "class RpcOpenPrinterExResponse(NDRCALL):\n    structure = (\n       ('pHandle', PRINTER_HANDLE),\n       ('ErrorCode', ULONG),\n    )",
  "class RpcEnumPrinterDrivers(NDRCALL):\n    opnum = 10\n    structure = (\n       ('pName', STRING_HANDLE),\n       ('pEnvironment', LPWSTR),\n       ('Level', DWORD),\n       ('pDrivers', PBYTE_ARRAY),\n       ('cbBuf', DWORD),\n    )",
  "class RpcEnumPrinterDriversResponse(NDRCALL):\n    structure = (\n       ('pDrivers', PBYTE_ARRAY),\n       ('pcbNeeded', DWORD),\n       ('pcReturned', DWORD),\n       ('ErrorCode', ULONG),\n    )",
  "class RpcGetPrinterDriverDirectory(NDRCALL):\n   opnum = 12\n   structure = (\n       ('pName', STRING_HANDLE),\n       ('pEnvironment', LPWSTR),\n       ('Level', DWORD),\n       ('pDriverDirectory', PBYTE_ARRAY),\n       ('cbBuf', DWORD)\n   )",
  "class RpcGetPrinterDriverDirectoryResponse(NDRCALL):\n    structure = (\n       ('pDriverDirectory', PBYTE_ARRAY),\n       ('pcbNeeded', DWORD),\n       ('ErrorCode', ULONG)\n    )",
  "class RpcAddPrinterDriverEx(NDRCALL):\n    opnum = 89\n    structure = (\n       ('pName', STRING_HANDLE),\n       ('pDriverContainer', DRIVER_CONTAINER),\n       ('dwFileCopyFlags', DWORD),\n    )",
  "class RpcAddPrinterDriverExResponse(NDRCALL):\n    structure = (\n       ('ErrorCode', ULONG),\n    )",
  "def checkNullString(string):\n    if string == NULL:\n        return string\n\n    if string[-1:] != '\\x00':\n        return string + '\\x00'\n    else:\n        return string",
  "def hRpcOpenPrinter(dce, printerName, pDatatype = NULL, pDevModeContainer = NULL, accessRequired = SERVER_READ):\n    \"\"\"\n    RpcOpenPrinter retrieves a handle for a printer, port, port monitor, print job, or print server.\n    Full Documentation: https://msdn.microsoft.com/en-us/library/cc244808.aspx\n\n    :param DCERPC_v5 dce: a connected DCE instance.\n    :param string printerName: A string for a printer connection, printer object, server object, job object, port\n    object, or port monitor object. This MUST be a Domain Name System (DNS), NetBIOS, Internet Protocol version 4\n    (IPv4), Internet Protocol version 6 (IPv6), or Universal Naming Convention (UNC) name that remote procedure\n    call (RPC) binds to, and it MUST uniquely identify a print server on the network.\n    :param string pDatatype: A string that specifies the data type to be associated with the printer handle.\n    :param DEVMODE_CONTAINER pDevModeContainer: A DEVMODE_CONTAINER structure. This parameter MUST adhere to the specification in\n    DEVMODE_CONTAINER Parameters (section 3.1.4.1.8.1).\n    :param int accessRequired: The access level that the client requires for interacting with the object to which a\n    handle is being opened.\n\n    :return: a RpcOpenPrinterResponse instance, raises DCERPCSessionError on error.\n    \"\"\"\n    request = RpcOpenPrinter()\n    request['pPrinterName'] = checkNullString(printerName)\n    request['pDatatype'] = pDatatype\n    if pDevModeContainer is NULL:\n        request['pDevModeContainer']['pDevMode'] = NULL\n    else:\n        request['pDevModeContainer'] = pDevModeContainer\n\n    request['AccessRequired'] = accessRequired\n    return dce.request(request)",
  "def hRpcClosePrinter(dce, phPrinter):\n    \"\"\"\n    RpcClosePrinter closes a handle to a printer object, server object, job object, or port object.\n    Full Documentation: https://msdn.microsoft.com/en-us/library/cc244768.aspx\n\n    :param DCERPC_v5 dce: a connected DCE instance.\n    :param PRINTER_HANDLE phPrinter: A handle to a printer object, server object, job object, or port object.\n\n    :return: a RpcClosePrinterResponse instance, raises DCERPCSessionError on error.\n    \"\"\"\n    request = RpcClosePrinter()\n    request['phPrinter'] = phPrinter\n    return dce.request(request)",
  "def hRpcOpenPrinterEx(dce, printerName, pDatatype=NULL, pDevModeContainer=NULL, accessRequired=SERVER_READ,\n                      pClientInfo=NULL):\n    \"\"\"\n    RpcOpenPrinterEx retrieves a handle for a printer, port, port monitor, print job, or print server\n    Full Documentation: https://msdn.microsoft.com/en-us/library/cc244809.aspx\n\n    :param DCERPC_v5 dce: a connected DCE instance.\n    :param string printerName: A string for a printer connection, printer object, server object, job object, port\n    object, or port monitor object. This MUST be a Domain Name System (DNS), NetBIOS, Internet Protocol version 4\n    (IPv4), Internet Protocol version 6 (IPv6), or Universal Naming Convention (UNC) name that remote procedure\n    call (RPC) binds to, and it MUST uniquely identify a print server on the network.\n    :param string pDatatype: A string that specifies the data type to be associated with the printer handle.\n    :param DEVMODE_CONTAINER pDevModeContainer: A DEVMODE_CONTAINER structure. This parameter MUST adhere to the specification in\n    DEVMODE_CONTAINER Parameters (section 3.1.4.1.8.1).\n    :param int accessRequired: The access level that the client requires for interacting with the object to which a\n    handle is being opened.\n    :param SPLCLIENT_CONTAINER pClientInfo: This parameter MUST adhere to the specification in SPLCLIENT_CONTAINER Parameters.\n\n    :return: a RpcOpenPrinterExResponse instance, raises DCERPCSessionError on error.\n    \"\"\"\n    request = RpcOpenPrinterEx()\n    request['pPrinterName'] = checkNullString(printerName)\n    request['pDatatype'] = pDatatype\n    if pDevModeContainer is NULL:\n        request['pDevModeContainer']['pDevMode'] = NULL\n    else:\n        request['pDevModeContainer'] = pDevModeContainer\n\n    request['AccessRequired'] = accessRequired\n    if pClientInfo is NULL:\n        raise Exception('pClientInfo cannot be NULL')\n\n    request['pClientInfo'] = pClientInfo\n    return dce.request(request)",
  "def hRpcRemoteFindFirstPrinterChangeNotificationEx(dce, hPrinter, fdwFlags, fdwOptions=0, pszLocalMachine=NULL,\n                                                   dwPrinterLocal=0, pOptions=NULL):\n    \"\"\"\n    creates a remote change notification object that monitors changes to printer objects and sends change notifications\n    to a print client using either RpcRouterReplyPrinter (section 3.2.4.1.2) or RpcRouterReplyPrinterEx (section 3.2.4.1.4)\n    Full Documentation: https://msdn.microsoft.com/en-us/library/cc244813.aspx\n\n    :param DCERPC_v5 dce: a connected DCE instance.\n    :param PRINTER_HANDLE hPrinter: A handle to a printer or server object.\n    :param int fdwFlags: Flags that specify the conditions that are required for a change notification object to enter a signaled state.\n    :param int fdwOptions: The category of printers for which change notifications are returned.\n    :param string pszLocalMachine: A string that represents the name of the client computer.\n    :param int dwPrinterLocal: An implementation-specific unique value that MUST be sufficient for the client to determine\n    whether a call to RpcReplyOpenPrinter by the server is associated with the hPrinter parameter in this call.\n    :param RPC_V2_NOTIFY_OPTIONS pOptions:  An RPC_V2_NOTIFY_OPTIONS structure that specifies printer or job members that the client listens to for notifications.\n\n    :return: a RpcRemoteFindFirstPrinterChangeNotificationExResponse instance, raises DCERPCSessionError on error.\n    \"\"\"\n    request = RpcRemoteFindFirstPrinterChangeNotificationEx()\n\n    request['hPrinter'] = hPrinter\n    request['fdwFlags'] = fdwFlags\n    request['fdwOptions'] = fdwOptions\n    request['dwPrinterLocal'] = dwPrinterLocal\n    if pszLocalMachine is NULL:\n        raise Exception('pszLocalMachine cannot be NULL')\n    request['pszLocalMachine'] = checkNullString(pszLocalMachine)\n    request['pOptions'] = pOptions\n    return dce.request(request)",
  "def hRpcEnumPrinters(dce, flags, name = NULL, level = 1):\n    \"\"\"\n    RpcEnumPrinters enumerates available printers, print servers, domains, or print providers.\n    Full Documentation: https://msdn.microsoft.com/en-us/library/cc244794.aspx\n\n    :param DCERPC_v5 dce: a connected DCE instance.\n    :param int flags: The types of print objects that this method enumerates. The value of this parameter is the\n    result of a bitwise OR of one or more of the Printer Enumeration Flags (section 2.2.3.7).\n    :param string name: NULL or a server name parameter as specified in Printer Server Name Parameters (section 3.1.4.1.4).\n    :param level: The level of printer information structure.\n\n    :return: a RpcEnumPrintersResponse instance, raises DCERPCSessionError on error.\n    \"\"\"\n    request = RpcEnumPrinters()\n    request['Flags'] = flags\n    request['Name'] = name\n    request['pPrinterEnum'] = NULL\n    request['Level'] = level\n    bytesNeeded = 0\n    try:\n        dce.request(request)\n    except DCERPCSessionError as e:\n        if str(e).find('ERROR_INSUFFICIENT_BUFFER') < 0:\n            raise\n        bytesNeeded = e.get_packet()['pcbNeeded']\n\n    request = RpcEnumPrinters()\n    request['Flags'] = flags\n    request['Name'] = name\n    request['Level'] = level\n\n    request['cbBuf'] = bytesNeeded\n    request['pPrinterEnum'] = b'a' * bytesNeeded\n    return dce.request(request)",
  "def hRpcAddPrinterDriverEx(dce, pName, pDriverContainer, dwFileCopyFlags):\n    \"\"\"\n    RpcAddPrinterDriverEx installs a printer driver on the print server\n    Full Documentation: https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-rprn/b96cc497-59e5-4510-ab04-5484993b259b\n\n    :param DCERPC_v5 dce: a connected DCE instance.\n    :param pName\n    :param pDriverContainer\n    :param dwFileCopyFlags\n\n    :return: raises DCERPCSessionError on error.\n    \"\"\"\n    request = RpcAddPrinterDriverEx()\n    request['pName'] = checkNullString(pName)\n    request['pDriverContainer'] = pDriverContainer\n    request['dwFileCopyFlags'] = dwFileCopyFlags\n\n    #return request\n    return dce.request(request)",
  "def hRpcEnumPrinterDrivers(dce, pName, pEnvironment, Level):\n    \"\"\"\n    RpcEnumPrinterDrivers enumerates the printer drivers installed on a specified print server.\n    Full Documentation: https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-rprn/857d00ac-3682-4a0d-86ca-3d3c372e5e4a\n\n    :param DCERPC_v5 dce: a connected DCE instance.\n    :param pName\n    :param pEnvironment\n    :param Level\n    :param pDrivers\n    :param cbBuf\n    :param pcbNeeded\n    :param pcReturned\n\n    :return: raises DCERPCSessionError on error.\n    \"\"\"\n    # get value for cbBuf\n    request = RpcEnumPrinterDrivers()\n    request['pName']        = checkNullString(pName)\n    request['pEnvironment'] = pEnvironment\n    request['Level']        = Level\n    request['pDrivers']     = NULL\n    request['cbBuf']        = 0\n    try:\n        dce.request(request)\n    except DCERPCSessionError as e:\n        if str(e).find('ERROR_INSUFFICIENT_BUFFER') < 0:\n            raise\n        bytesNeeded = e.get_packet()['pcbNeeded']\n\n    # now do RpcEnumPrinterDrivers again\n    request = RpcEnumPrinterDrivers()\n    request['pName']        = checkNullString(pName)\n    request['pEnvironment'] = pEnvironment\n    request['Level']        = Level\n    request['pDrivers']     = b'a' * bytesNeeded\n    request['cbBuf']        = bytesNeeded\n\n    #return request\n    return dce.request(request)",
  "def hRpcGetPrinterDriverDirectory(dce, pName, pEnvironment, Level):\n    \"\"\"\n    RpcGetPrinterDriverDirectory retrieves the path of the printer driver directory.\n    Full Documentation: https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-rprn/9df11cf4-4098-4852-ad72-d1f75a82bffe\n\n    :param DCERPC_v5 dce: a connected DCE instance.\n    :param pName\n    :param pEnvironment\n    :param Level\n    :param pDriverDirectory\n    :param cbBuf\n    :param pcbNeeded\n\n    :return: raises DCERPCSessionError on error.\n    \"\"\"\n    # get value for cbBuf\n    request = RpcGetPrinterDriverDirectory()\n    request['pName']            = checkNullString(pName)\n    request['pEnvironment']     = pEnvironment\n    request['Level']            = Level\n    request['pDriverDirectory'] = NULL\n    request['cbBuf']            = 0\n    try:\n        dce.request(request)\n    except DCERPCSessionError as e:\n        if str(e).find('ERROR_INSUFFICIENT_BUFFER') < 0:\n            raise\n        bytesNeeded = e.get_packet()['pcbNeeded']\n    \n    # now do RpcGetPrinterDriverDirectory again\n    request = RpcGetPrinterDriverDirectory()\n    request['pName']            = checkNullString(pName)\n    request['pEnvironment']     = pEnvironment\n    request['Level']            = Level\n    request['pDriverDirectory'] = b'a' * bytesNeeded\n    request['cbBuf']            = bytesNeeded\n    \n    return dce.request(request)",
  "def __init__(self, error_string=None, error_code=None, packet=None):\n        DCERPCException.__init__(self, error_string, error_code, packet)",
  "def __str__( self ):\n        key = self.error_code\n        if key in system_errors.ERROR_MESSAGES:\n            error_msg_short = system_errors.ERROR_MESSAGES[key][0]\n            error_msg_verbose = system_errors.ERROR_MESSAGES[key][1] \n            return 'RPRN SessionError: code: 0x%x - %s - %s' % (self.error_code, error_msg_short, error_msg_verbose)\n        else:\n            return 'RPRN SessionError: unknown error code: 0x%x' % self.error_code",
  "def getAlignment(self):\n        if self._isNDR64 is True:\n            return 8\n        else:\n            return 4",
  "class RPCProxyClientException(DCERPCException):\n    parser = re.compile(r'RPC Error: ([a-fA-F0-9]{1,8})')\n\n    def __init__(self, error_string=None, proxy_error=None):\n        rpc_error_code = None\n\n        if proxy_error is not None:\n            try:\n                search = self.parser.search(proxy_error)\n                rpc_error_code = int(search.group(1), 16)\n            except:\n                error_string += ': ' + proxy_error\n\n        DCERPCException.__init__(self, error_string, rpc_error_code)\n\n    def __str__(self):\n        if self.error_code is not None:\n            key = self.error_code\n            if key in system_errors.ERROR_MESSAGES:\n                error_msg_short = system_errors.ERROR_MESSAGES[key][0]\n                return '%s, code: 0x%x - %s' % (self.error_string, self.error_code, error_msg_short)\n            elif key in nt_errors.ERROR_MESSAGES:\n                error_msg_short = nt_errors.ERROR_MESSAGES[key][0]\n                return '%s, code: 0x%x - %s' % (self.error_string, self.error_code, error_msg_short)\n            else:\n                return '%s: unknown code: 0x%x' % (self.error_string, self.error_code)\n        else:\n            return self.error_string",
  "class RTSCookie(Structure):\n    structure = (\n        ('Cookie','16s=b\"\\\\x00\"*16'),\n    )",
  "class EncodedClientAddress(Structure):\n    structure = (\n        ('AddressType','<L=(0 if len(ClientAddress) == 4 else 1)'),\n        ('_ClientAddress','_-ClientAddress','4 if AddressType == 0 else 16'),\n        ('ClientAddress',':'),\n        ('Padding','12s=b\"\\\\x00\"*12'),\n    )",
  "class Ack(Structure):\n    structure = (\n        ('BytesReceived','<L=0'),\n        ('AvailableWindow','<L=0'),\n        ('ChannelCookie',':',RTSCookie),\n    )",
  "class ReceiveWindowSize(Structure):\n    structure = (\n        ('CommandType','<L=0'),\n        ('ReceiveWindowSize','<L=262144'),\n    )",
  "class FlowControlAck(Structure):\n    structure = (\n        ('CommandType','<L=1'),\n        ('Ack',':',Ack),\n    )",
  "class ConnectionTimeout(Structure):\n    structure = (\n        ('CommandType','<L=2'),\n        ('ConnectionTimeout','<L=120000'),\n    )",
  "class Cookie(Structure):\n    structure = (\n        ('CommandType','<L=3'),\n        ('Cookie',':',RTSCookie),\n    )",
  "class ChannelLifetime(Structure):\n    structure = (\n        ('CommandType','<L=4'),\n        ('ChannelLifetime','<L=1073741824'),\n    )",
  "class ClientKeepalive(Structure):\n    structure = (\n        ('CommandType','<L=5'),\n        ('ClientKeepalive','<L=300000'),\n    )",
  "class Version(Structure):\n    structure = (\n        ('CommandType','<L=6'),\n        ('Version','<L=1'),\n    )",
  "class Empty(Structure):\n    structure = (\n        ('CommandType','<L=7'),\n    )",
  "class Padding(Structure):\n    structure = (\n        ('CommandType','<L=8'),\n        ('ConformanceCount','<L=len(Padding)'),\n        ('Padding','*ConformanceCount'),\n    )",
  "class NegativeANCE(Structure):\n    structure = (\n        ('CommandType','<L=9'),\n    )",
  "class ANCE(Structure):\n    structure = (\n        ('CommandType','<L=0xA'),\n    )",
  "class ClientAddress(Structure):\n    structure = (\n        ('CommandType','<L=0xB'),\n        ('ClientAddress',':',EncodedClientAddress),\n    )",
  "class AssociationGroupId(Structure):\n    structure = (\n        ('CommandType','<L=0xC'),\n        ('AssociationGroupId',':',RTSCookie),\n    )",
  "class Destination(Structure):\n    structure = (\n        ('CommandType','<L=0xD'),\n        ('Destination','<L'),\n    )",
  "class PingTrafficSentNotify(Structure):\n    structure = (\n        ('CommandType','<L=0xE'),\n        ('PingTrafficSent','<L'),\n    )",
  "class RTSHeader(MSRPCHeader):\n    _SIZE = 20\n    commonHdr = MSRPCHeader.commonHdr + (\n        ('Flags','<H=0'),             # 16\n        ('NumberOfCommands','<H=0'),  # 18\n    )\n\n    def __init__(self, data=None, alignment=0):\n        MSRPCHeader.__init__(self, data, alignment)\n        self['type'] = MSRPC_RTS\n        self['flags'] = PFC_FIRST_FRAG | PFC_LAST_FRAG\n        self['auth_length'] = 0\n        self['call_id'] = 0",
  "class CONN_A1_RTS_PDU(Structure):\n    structure = (\n        ('Version',':',Version),\n        ('VirtualConnectionCookie',':',Cookie),\n        ('OutChannelCookie',':',Cookie),\n        ('ReceiveWindowSize',':',ReceiveWindowSize),\n    )",
  "class CONN_B1_RTS_PDU(Structure):\n    structure = (\n        ('Version',':',Version),\n        ('VirtualConnectionCookie',':',Cookie),\n        ('INChannelCookie',':',Cookie),\n        ('ChannelLifetime',':',ChannelLifetime),\n        ('ClientKeepalive',':',ClientKeepalive),\n        ('AssociationGroupId',':',AssociationGroupId),\n    )",
  "class CONN_A3_RTS_PDU(Structure):\n    structure = (\n        ('ConnectionTimeout',':',ConnectionTimeout),\n    )",
  "class CONN_C2_RTS_PDU(Structure):\n    structure = (\n        ('Version',':',Version),\n        ('ReceiveWindowSize',':',ReceiveWindowSize),\n        ('ConnectionTimeout',':',ConnectionTimeout),\n    )",
  "class FlowControlAckWithDestination_RTS_PDU(Structure):\n    structure = (\n        ('Destination',':',Destination),\n        ('FlowControlAck',':',FlowControlAck),\n    )",
  "def hCONN_A1(virtualConnectionCookie=EMPTY_UUID, outChannelCookie=EMPTY_UUID, receiveWindowSize=262144):\n    conn_a1 = CONN_A1_RTS_PDU()\n    conn_a1['Version'] = Version()\n    conn_a1['VirtualConnectionCookie'] = Cookie()\n    conn_a1['VirtualConnectionCookie']['Cookie'] = virtualConnectionCookie\n    conn_a1['OutChannelCookie'] = Cookie()\n    conn_a1['OutChannelCookie']['Cookie'] = outChannelCookie\n    conn_a1['ReceiveWindowSize'] = ReceiveWindowSize()\n    conn_a1['ReceiveWindowSize']['ReceiveWindowSize'] = receiveWindowSize\n\n    packet = RTSHeader()\n    packet['Flags'] = RTS_FLAG_NONE\n    packet['NumberOfCommands'] = len(conn_a1.structure)\n    packet['pduData'] = conn_a1.getData()\n\n    return packet.getData()",
  "def hCONN_B1(virtualConnectionCookie=EMPTY_UUID, inChannelCookie=EMPTY_UUID, associationGroupId=EMPTY_UUID):\n    conn_b1 = CONN_B1_RTS_PDU()\n    conn_b1['Version'] = Version()\n    conn_b1['VirtualConnectionCookie'] = Cookie()\n    conn_b1['VirtualConnectionCookie']['Cookie'] = virtualConnectionCookie\n    conn_b1['INChannelCookie'] = Cookie()\n    conn_b1['INChannelCookie']['Cookie'] = inChannelCookie\n    conn_b1['ChannelLifetime'] = ChannelLifetime()\n    conn_b1['ClientKeepalive'] = ClientKeepalive()\n    conn_b1['AssociationGroupId'] = AssociationGroupId()\n    conn_b1['AssociationGroupId']['AssociationGroupId'] = RTSCookie()\n    conn_b1['AssociationGroupId']['AssociationGroupId']['Cookie'] = associationGroupId\n\n    packet = RTSHeader()\n    packet['Flags'] = RTS_FLAG_NONE\n    packet['NumberOfCommands'] = len(conn_b1.structure)\n    packet['pduData'] = conn_b1.getData()\n\n    return packet.getData()",
  "def hFlowControlAckWithDestination(destination, bytesReceived, availableWindow, channelCookie):\n    rts_pdu = FlowControlAckWithDestination_RTS_PDU()\n    rts_pdu['Destination'] = Destination()\n    rts_pdu['Destination']['Destination'] = destination\n    rts_pdu['FlowControlAck'] = FlowControlAck()\n    rts_pdu['FlowControlAck']['Ack'] = Ack()\n    rts_pdu['FlowControlAck']['Ack']['BytesReceived'] = bytesReceived\n    rts_pdu['FlowControlAck']['Ack']['AvailableWindow'] = availableWindow\n\n    # Cookie of the channel for which the traffic received is being acknowledged\n    rts_pdu['FlowControlAck']['Ack']['ChannelCookie'] = RTSCookie()\n    rts_pdu['FlowControlAck']['Ack']['ChannelCookie']['Cookie'] = channelCookie\n\n    packet = RTSHeader()\n    packet['Flags'] = RTS_FLAG_OTHER_CMD\n    packet['NumberOfCommands'] = len(rts_pdu.structure)\n    packet['pduData'] = rts_pdu.getData()\n\n    return packet.getData()",
  "def hPing():\n    packet = RTSHeader()\n    packet['Flags'] = RTS_FLAG_PING\n\n    return packet.getData()",
  "class RPCProxyClient(HTTPClientSecurityProvider):\n    RECV_SIZE = 8192\n    default_headers = {'User-Agent'   : 'MSRPC',\n                       'Cache-Control': 'no-cache',\n                       'Connection'   : 'Keep-Alive',\n                       'Expect'       : '100-continue',\n                       'Accept'       : 'application/rpc',\n                       'Pragma'       : 'No-cache'\n                      }\n\n    def __init__(self, remoteName=None, dstport=593):\n        HTTPClientSecurityProvider.__init__(self)\n        self.__remoteName  = remoteName\n        self.__dstport     = dstport\n\n        # Chosen auth type\n        self.__auth_type = None\n\n        self.init_state()\n\n    def init_state(self):\n        self.__channels    = {}\n\n        self.__inChannelCookie         = uuid.generate()\n        self.__outChannelCookie        = uuid.generate()\n        self.__associationGroupId      = uuid.generate()\n        self.__virtualConnectionCookie = uuid.generate()\n\n        self.__serverConnectionTimeout = None\n        self.__serverReceiveWindowSize = None\n        self.__availableWindowAdvertised = 262144 # 256k\n        self.__receiverAvailableWindow = self.__availableWindowAdvertised\n        self.__bytesReceived = 0\n\n        self.__serverChunked = False\n        self.__readBuffer = b''\n        self.__chunkLeft = 0\n\n        self.rts_ping_received = False\n\n    def set_proxy_credentials(self, username, password, domain='', lmhash='', nthash=''):\n        LOG.error(\"DeprecationWarning: Call to deprecated method set_proxy_credentials (use set_credentials).\")\n        self.set_credentials(username, password, domain, lmhash, nthash)\n\n    def set_credentials(self, username, password, domain='', lmhash='', nthash='', aesKey='', TGT=None, TGS=None):\n        HTTPClientSecurityProvider.set_credentials(self, username, password,\n            domain, lmhash, nthash, aesKey, TGT, TGS)\n\n    def create_rpc_in_channel(self):\n        headers = self.default_headers.copy()\n        headers['Content-Length'] = '1073741824'\n\n        self.create_channel('RPC_IN_DATA', headers)\n\n    def create_rpc_out_channel(self):\n        headers = self.default_headers.copy()\n        headers['Content-Length'] = '76'\n\n        self.create_channel('RPC_OUT_DATA', headers)\n\n    def create_channel(self, method, headers):\n        self.__channels[method] = HTTPClientSecurityProvider.connect(self, self._rpcProxyUrl.scheme,\n                                    self._rpcProxyUrl.netloc)\n\n        auth_headers = HTTPClientSecurityProvider.get_auth_headers(self, self.__channels[method],\n                           method, self._rpcProxyUrl.path, headers)[0]\n\n        headers_final = {}\n        headers_final.update(headers)\n        headers_final.update(auth_headers)\n\n        self.__auth_type = HTTPClientSecurityProvider.get_auth_type(self)\n\n        # To connect to an RPC Server, we need to let the RPC Proxy know\n        # where to connect. The target RPC Server name and its port are passed\n        # in the query of the HTTP request. The target RPC Server must be the ncacn_http\n        # service.\n        #\n        # The utilized format: /rpc/rpcproxy.dll?RemoteName:RemotePort\n        #\n        # For RDG servers, you can specify localhost:3388, but in other cases you cannot\n        # use localhost as there will be no ACL for it.\n        #\n        # To know what RemoteName to use, we rely on Default ACL. It's specified\n        # in the HKLM\\SOFTWARE\\Microsoft\\Rpc\\RpcProxy key:\n        #\n        # ValidPorts    REG_SZ   COMPANYSERVER04:593;COMPANYSERVER04:49152-65535\n        #\n        # In this way, we can at least connect to the endpoint mapper on port 593.\n        # So, if the caller set remoteName to an empty string, we assume the target\n        # is the RPC Proxy server itself, and get its NetBIOS name from the NTLMSSP.\n        #\n        # Interestingly, if the administrator renames the server after RPC Proxy installation\n        # or joins the server to the domain after RPC Proxy installation, the ACL will remain\n        # the original. So, sometimes the ValidPorts values have the format WIN-JCKEDQVDOQU, and\n        # we are not able to use them.\n        #\n        # For Exchange servers, the value of the default ACL doesn't matter as they\n        # allow connections by their own mechanisms:\n        # - Exchange 2003 / 2007 / 2010 servers add their own ACL, which includes\n        #   NetBIOS names of all Exchange servers (and some other servers).\n        #   This ACL is regularly and automatically updated on each server.\n        #   Allowed ports: 6001-6004\n        #\n        #   6001 is used for MS-OXCRPC\n        #   6002 is used for MS-OXABREF\n        #   6003 is not used\n        #   6004 is used for MS-OXNSPI\n        #\n        #   Tests on Exchange 2010 show that MS-OXNSPI and MS-OXABREF are available\n        #   on both 6002 and 6004.\n        #\n        # - Exchange 2013 / 2016 / 2019 servers process RemoteName on their own\n        #   (via RpcProxyShim.dll), and the NetBIOS name format is supported only for\n        #   backward compatibility.\n        #\n        #   ! Default ACL is never used, so there is no way to connect to the endpoint mapper!\n        #\n        #   Allowed ports: 6001-6004\n        #\n        #   6001 is used for MS-OXCRPC\n        #   6002 is used for MS-OXABREF\n        #   6003 is not used\n        #   6004 is used for MS-OXNSPI\n        #\n        # Tests show that all protocols are available on the 6001 / 6002 / 6004 ports via\n        # RPC over HTTP v2, and the separation is only used for backward compatibility.\n        #\n        # The pure ncacn_http endpoint is available only on the 6001 TCP/IP port.\n        #\n        # RpcProxyShim.dll allows you to skip authentication on the RPC level to get\n        # a faster connection, and it makes Exchange 2013 / 2016 / 2019 RPC over HTTP v2\n        # endpoints vulnerable to NTLM-Relaying attacks.\n        #\n        # If the target is Exchange behind Microsoft TMG, you most likely need to specify\n        # the remote name manually using the value from /autodiscover/autodiscover.xml.\n        # Note that /autodiscover/autodiscover.xml might not be available with\n        # a non-outlook User-Agent.\n        #\n        # There may be multiple RPC Proxy servers with different NetBIOS names on\n        # a single external IP. We store the first one's NetBIOS name and use it for all\n        # the following channels.\n        # It's acceptable to assume all RPC Proxies have the same ACLs (true for Exchange).\n        if not self.__remoteName and self.__auth_type == AUTH_BASIC:\n            raise RPCProxyClientException(RPC_PROXY_REMOTE_NAME_NEEDED_ERR)\n\n        if not self.__remoteName:\n            ntlmssp = self.get_ntlmssp_info()\n            self.__remoteName = ntlmssp[ntlm.NTLMSSP_AV_HOSTNAME][1].decode('utf-16le')\n            self._stringbinding.set_network_address(self.__remoteName)\n            LOG.debug('StringBinding has been changed to %s' % self._stringbinding)\n\n        if not self._rpcProxyUrl.query:\n            query = self.__remoteName + ':' + str(self.__dstport)\n            self._rpcProxyUrl = self._rpcProxyUrl._replace(query=query)\n\n        path = self._rpcProxyUrl.path + '?' + self._rpcProxyUrl.query\n\n        self.__channels[method].request(method, path, headers=headers_final)\n        self._read_100_continue(method)\n\n    def _read_100_continue(self, method):\n        resp = self.__channels[method].sock.recv(self.RECV_SIZE)\n\n        while resp.find(b'\\r\\n\\r\\n') == -1:\n            resp += self.__channels[method].sock.recv(self.RECV_SIZE)\n\n        # Continue responses can have multiple lines, for example:\n        #\n        # HTTP/1.1 100 Continue\n        # Via: 1.1 FIREWALL1\n        #\n        # Don't expect the response to contain \"100 Continue\\r\\n\\r\\n\"\n        if resp[9:23] != b'100 Continue\\r\\n':\n            try:\n                # The server (IIS) may return localized error messages in\n                # the first line. Tests shown they are in UTF-8.\n                resp = resp.split(b'\\r\\n')[0].decode(\"UTF-8\", errors='replace')\n\n                raise RPCProxyClientException('RPC Proxy Client: %s authentication failed in %s channel' %\n                    (self.__auth_type, method), proxy_error=resp)\n            except (IndexError, KeyError, AttributeError):\n                raise RPCProxyClientException('RPC Proxy Client: %s authentication failed in %s channel' %\n                    (self.__auth_type, method))\n\n    def create_tunnel(self):\n        # 3.2.1.5.3.1 Connection Establishment\n        packet = hCONN_A1(self.__virtualConnectionCookie, self.__outChannelCookie, self.__availableWindowAdvertised)\n        self.get_socket_out().send(packet)\n\n        packet = hCONN_B1(self.__virtualConnectionCookie, self.__inChannelCookie, self.__associationGroupId)\n        self.get_socket_in().send(packet)\n\n        resp = self.get_socket_out().recv(self.RECV_SIZE)\n\n        while resp.find(b'\\r\\n\\r\\n') == -1:\n            resp += self.get_socket_out().recv(self.RECV_SIZE)\n\n        if resp[9:12] != b'200':\n            try:\n                # The server (IIS) may return localized error messages in\n                # the first line. Tests shown they are in UTF-8.\n                resp = resp.split(b'\\r\\n')[0].decode(\"UTF-8\", errors='replace')\n\n                raise RPCProxyClientException('RPC Proxy CONN/A1 request failed', proxy_error=resp)\n            except (IndexError, KeyError, AttributeError):\n                raise RPCProxyClientException('RPC Proxy CONN/A1 request failed')\n\n        resp_ascii = resp.decode(\"ASCII\", errors='replace')\n        if \"transfer-encoding: chunked\" in resp_ascii.lower():\n            self.__serverChunked = True\n\n        # If the body is here, let's send it to rpc_out_recv1()\n        self.__readBuffer = resp[resp.find(b'\\r\\n\\r\\n') + 4:]\n\n        # Recieving and parsing CONN/A3\n        conn_a3_rpc = self.rpc_out_read_pkt()\n        conn_a3_pdu = RTSHeader(conn_a3_rpc)['pduData']\n        conn_a3 = CONN_A3_RTS_PDU(conn_a3_pdu)\n        self.__serverConnectionTimeout = conn_a3['ConnectionTimeout']['ConnectionTimeout']\n\n        # Recieving and parsing CONN/C2\n        conn_c2_rpc = self.rpc_out_read_pkt()\n        conn_c2_pdu = RTSHeader(conn_c2_rpc)['pduData']\n        conn_c2 = CONN_C2_RTS_PDU(conn_c2_pdu)\n        self.__serverReceiveWindowSize = conn_c2['ReceiveWindowSize']['ReceiveWindowSize']\n\n    def get_socket_in(self):\n        return self.__channels['RPC_IN_DATA'].sock\n\n    def get_socket_out(self):\n        return self.__channels['RPC_OUT_DATA'].sock\n\n    def close_rpc_in_channel(self):\n        return self.__channels['RPC_IN_DATA'].close()\n\n    def close_rpc_out_channel(self):\n        return self.__channels['RPC_OUT_DATA'].close()\n\n    def check_http_error(self, buffer):\n        if buffer[:22] == b'HTTP/1.0 503 RPC Error':\n            raise RPCProxyClientException('RPC Proxy request failed', proxy_error=buffer)\n\n    def rpc_out_recv1(self, amt=None):\n        # Read with at most one underlying system call.\n        # The function MUST return the maximum amt bytes.\n        #\n        # Strictly speaking, it may cause more than one read,\n        # but that is ok, since that is to satisfy the chunked protocol.\n        sock = self.get_socket_out()\n\n        if self.__serverChunked is False:\n            if len(self.__readBuffer) > 0:\n                buffer = self.__readBuffer\n                self.__readBuffer = b''\n            else:\n                # Let's read RECV_SIZE bytes and not amt bytes.\n                # We would need to check the answer for HTTP errors, as\n                # they can just appear in the middle of the stream.\n                buffer = sock.recv(self.RECV_SIZE)\n\n            self.check_http_error(buffer)\n\n            if len(buffer) <= amt:\n                return buffer\n\n            # We received more than we need\n            self.__readBuffer = buffer[amt:]\n            return buffer[:amt]\n\n        # Check if the previous chunk is still there\n        if self.__chunkLeft > 0:\n            # If the previous chunk is still there,\n            # just give the caller what we already have\n            if amt >= self.__chunkLeft:\n                buffer = self.__readBuffer[:self.__chunkLeft]\n                # We may have recieved a part of a new chunk\n                self.__readBuffer = self.__readBuffer[self.__chunkLeft + 2:]\n                self.__chunkLeft = 0\n\n                return buffer\n            else:\n                buffer = self.__readBuffer[:amt]\n                self.__readBuffer = self.__readBuffer[amt:]\n                self.__chunkLeft -= amt\n\n                return buffer\n\n        # Let's start to process a new chunk\n        buffer = self.__readBuffer\n        self.__readBuffer = b''\n\n        self.check_http_error(buffer)\n\n        # Let's receive a chunk size field which ends with CRLF\n        # For Microsoft TMG 2010 it can cause more than one read\n        while buffer.find(b'\\r\\n') == -1:\n            buffer += sock.recv(self.RECV_SIZE)\n            self.check_http_error(buffer)\n\n        chunksize = int(buffer[:buffer.find(b'\\r\\n')], 16)\n        buffer = buffer[buffer.find(b'\\r\\n') + 2:]\n\n        # Let's read at least our chunk including final CRLF\n        while len(buffer) - 2 < chunksize:\n            buffer += sock.recv(chunksize - len(buffer) + 2)\n\n        # We should not be using any information from\n        # the TCP level to determine HTTP boundaries.\n        # So, we may have received more than we need.\n        if len(buffer) - 2 > chunksize:\n            self.__readBuffer = buffer[chunksize + 2:]\n            buffer = buffer[:chunksize + 2]\n\n        # Checking the amt\n        if len(buffer) - 2 > amt:\n            self.__chunkLeft = chunksize - amt\n            # We may have recieved a part of a new chunk before,\n            # so the concatenation is crucual\n            self.__readBuffer = buffer[amt:] + self.__readBuffer\n\n            return buffer[:amt]\n        else:\n            # Removing CRLF\n            return buffer[:-2]\n\n    def send(self, data, forceWriteAndx=0, forceRecv=0):\n        # We don't use chunked encoding for IN channel as\n        # Microsoft software is developed this way.\n        # If you do this, it may fail.\n        self.get_socket_in().send(data)\n\n    def rpc_out_read_pkt(self, handle_rts=False):\n        while True:\n            response_data = b''\n\n            # Let's receive common RPC header and no more\n            #\n            # C706\n            # 12.4 Common Fields\n            # Header encodings differ between connectionless and connection-oriented PDUs.\n            # However, certain fields use common sets of values with a consistent\n            # interpretation across the two protocols.\n            #\n            # This MUST recv MSRPCHeader._SIZE bytes, and not MSRPCRespHeader._SIZE bytes!\n            #\n            while len(response_data) < MSRPCHeader._SIZE:\n                response_data += self.rpc_out_recv1(MSRPCHeader._SIZE - len(response_data))\n\n            response_header = MSRPCHeader(response_data)\n\n            # frag_len contains the full length of the packet for both\n            # MSRPC and RTS\n            frag_len = response_header['frag_len']\n\n            # Receiving the full pkt and no more\n            while len(response_data) < frag_len:\n               response_data += self.rpc_out_recv1(frag_len - len(response_data))\n\n            # We need to do the Flow Control procedures\n            #\n            # 3.2.1.1.4\n            # This protocol specifies that only RPC PDUs are subject to the flow control abstract data\n            # model. RTS PDUs and the HTTP request and response headers are not subject to flow control.\n            if response_header['type'] != MSRPC_RTS:\n                self.flow_control(frag_len)\n\n            if handle_rts is True and response_header['type'] == MSRPC_RTS:\n                self.handle_out_of_sequence_rts(response_data)\n            else:\n                return response_data\n\n    def recv(self, forceRecv=0, count=0):\n        return self.rpc_out_read_pkt(handle_rts=True)\n\n    def handle_out_of_sequence_rts(self, response_data):\n        packet = RTSHeader(response_data)\n\n        #print(\"=========== RTS PKT ===========\")\n        #print(\"RAW: %s\" % binascii.hexlify(response_data))\n        #packet.dump()\n        #\n        #pduData = packet['pduData']\n        #numberOfCommands = packet['NumberOfCommands']\n        #\n        #server_cmds = []\n        #while numberOfCommands > 0:\n        #    numberOfCommands -= 1\n        #\n        #    cmd_type = unpack('<L', pduData[:4])[0]\n        #    cmd = COMMANDS[cmd_type](pduData)\n        #    server_cmds.append(cmd)\n        #    pduData = pduData[len(cmd):]\n        #\n        #for cmd in server_cmds:\n        #    cmd.dump()\n        #print(\"=========== / RTS PKT ===========\")\n\n        # 2.2.4.49 Ping RTS PDU\n        if packet['Flags'] == RTS_FLAG_PING:\n            # 3.2.1.2.1 PingTimer\n            #\n            # If the SendingChannel is part of a Virtual Connection in the Outbound Proxy or Client roles, the\n            # SendingChannel maintains a PingTimer that on expiration indicates a PING PDU must be sent to the\n            # receiving channel. The PING PDU is sent to the receiving channel when no data has been sent within\n            # half of the value of the KeepAliveInterval.\n\n            # As we do not do long-term connections with no data transfer,\n            # it means something on the server-side is going wrong.\n            self.rts_ping_received = True\n            LOG.error(\"Ping RTS PDU packet received. Is the RPC Server alive?\")\n\n            # Just in case it's a long operation, let's send PING PDU to IN Channel like in xfreerdp\n            # It's better to send more than one PING packet as it only 20 bytes long\n            packet = hPing()\n            self.send(packet)\n            self.send(packet)\n        # 2.2.4.24 OUT_R1/A2 RTS PDU\n        elif packet['Flags'] == RTS_FLAG_RECYCLE_CHANNEL:\n            raise RPCProxyClientException(\"The server requested recycling of a virtual OUT channel, \" \\\n                \"but this function is not supported!\")\n        # Ignore all other messages, most probably flow control acknowledgments\n        else:\n            pass\n\n    def flow_control(self, frag_len):\n        self.__bytesReceived += frag_len\n        self.__receiverAvailableWindow -= frag_len\n\n        if (self.__receiverAvailableWindow < self.__availableWindowAdvertised // 2):\n            self.__receiverAvailableWindow = self.__availableWindowAdvertised\n            packet = hFlowControlAckWithDestination(FDOutProxy, self.__bytesReceived,\n                self.__availableWindowAdvertised, self.__outChannelCookie)\n            self.send(packet)\n\n    def connect(self):\n        self.create_rpc_in_channel()\n        self.create_rpc_out_channel()\n        self.create_tunnel()\n\n    def disconnect(self):\n        self.close_rpc_in_channel()\n        self.close_rpc_out_channel()\n        self.init_state()",
  "def __init__(self, error_string=None, proxy_error=None):\n        rpc_error_code = None\n\n        if proxy_error is not None:\n            try:\n                search = self.parser.search(proxy_error)\n                rpc_error_code = int(search.group(1), 16)\n            except:\n                error_string += ': ' + proxy_error\n\n        DCERPCException.__init__(self, error_string, rpc_error_code)",
  "def __str__(self):\n        if self.error_code is not None:\n            key = self.error_code\n            if key in system_errors.ERROR_MESSAGES:\n                error_msg_short = system_errors.ERROR_MESSAGES[key][0]\n                return '%s, code: 0x%x - %s' % (self.error_string, self.error_code, error_msg_short)\n            elif key in nt_errors.ERROR_MESSAGES:\n                error_msg_short = nt_errors.ERROR_MESSAGES[key][0]\n                return '%s, code: 0x%x - %s' % (self.error_string, self.error_code, error_msg_short)\n            else:\n                return '%s: unknown code: 0x%x' % (self.error_string, self.error_code)\n        else:\n            return self.error_string",
  "def __init__(self, data=None, alignment=0):\n        MSRPCHeader.__init__(self, data, alignment)\n        self['type'] = MSRPC_RTS\n        self['flags'] = PFC_FIRST_FRAG | PFC_LAST_FRAG\n        self['auth_length'] = 0\n        self['call_id'] = 0",
  "def __init__(self, remoteName=None, dstport=593):\n        HTTPClientSecurityProvider.__init__(self)\n        self.__remoteName  = remoteName\n        self.__dstport     = dstport\n\n        # Chosen auth type\n        self.__auth_type = None\n\n        self.init_state()",
  "def init_state(self):\n        self.__channels    = {}\n\n        self.__inChannelCookie         = uuid.generate()\n        self.__outChannelCookie        = uuid.generate()\n        self.__associationGroupId      = uuid.generate()\n        self.__virtualConnectionCookie = uuid.generate()\n\n        self.__serverConnectionTimeout = None\n        self.__serverReceiveWindowSize = None\n        self.__availableWindowAdvertised = 262144 # 256k\n        self.__receiverAvailableWindow = self.__availableWindowAdvertised\n        self.__bytesReceived = 0\n\n        self.__serverChunked = False\n        self.__readBuffer = b''\n        self.__chunkLeft = 0\n\n        self.rts_ping_received = False",
  "def set_proxy_credentials(self, username, password, domain='', lmhash='', nthash=''):\n        LOG.error(\"DeprecationWarning: Call to deprecated method set_proxy_credentials (use set_credentials).\")\n        self.set_credentials(username, password, domain, lmhash, nthash)",
  "def set_credentials(self, username, password, domain='', lmhash='', nthash='', aesKey='', TGT=None, TGS=None):\n        HTTPClientSecurityProvider.set_credentials(self, username, password,\n            domain, lmhash, nthash, aesKey, TGT, TGS)",
  "def create_rpc_in_channel(self):\n        headers = self.default_headers.copy()\n        headers['Content-Length'] = '1073741824'\n\n        self.create_channel('RPC_IN_DATA', headers)",
  "def create_rpc_out_channel(self):\n        headers = self.default_headers.copy()\n        headers['Content-Length'] = '76'\n\n        self.create_channel('RPC_OUT_DATA', headers)",
  "def create_channel(self, method, headers):\n        self.__channels[method] = HTTPClientSecurityProvider.connect(self, self._rpcProxyUrl.scheme,\n                                    self._rpcProxyUrl.netloc)\n\n        auth_headers = HTTPClientSecurityProvider.get_auth_headers(self, self.__channels[method],\n                           method, self._rpcProxyUrl.path, headers)[0]\n\n        headers_final = {}\n        headers_final.update(headers)\n        headers_final.update(auth_headers)\n\n        self.__auth_type = HTTPClientSecurityProvider.get_auth_type(self)\n\n        # To connect to an RPC Server, we need to let the RPC Proxy know\n        # where to connect. The target RPC Server name and its port are passed\n        # in the query of the HTTP request. The target RPC Server must be the ncacn_http\n        # service.\n        #\n        # The utilized format: /rpc/rpcproxy.dll?RemoteName:RemotePort\n        #\n        # For RDG servers, you can specify localhost:3388, but in other cases you cannot\n        # use localhost as there will be no ACL for it.\n        #\n        # To know what RemoteName to use, we rely on Default ACL. It's specified\n        # in the HKLM\\SOFTWARE\\Microsoft\\Rpc\\RpcProxy key:\n        #\n        # ValidPorts    REG_SZ   COMPANYSERVER04:593;COMPANYSERVER04:49152-65535\n        #\n        # In this way, we can at least connect to the endpoint mapper on port 593.\n        # So, if the caller set remoteName to an empty string, we assume the target\n        # is the RPC Proxy server itself, and get its NetBIOS name from the NTLMSSP.\n        #\n        # Interestingly, if the administrator renames the server after RPC Proxy installation\n        # or joins the server to the domain after RPC Proxy installation, the ACL will remain\n        # the original. So, sometimes the ValidPorts values have the format WIN-JCKEDQVDOQU, and\n        # we are not able to use them.\n        #\n        # For Exchange servers, the value of the default ACL doesn't matter as they\n        # allow connections by their own mechanisms:\n        # - Exchange 2003 / 2007 / 2010 servers add their own ACL, which includes\n        #   NetBIOS names of all Exchange servers (and some other servers).\n        #   This ACL is regularly and automatically updated on each server.\n        #   Allowed ports: 6001-6004\n        #\n        #   6001 is used for MS-OXCRPC\n        #   6002 is used for MS-OXABREF\n        #   6003 is not used\n        #   6004 is used for MS-OXNSPI\n        #\n        #   Tests on Exchange 2010 show that MS-OXNSPI and MS-OXABREF are available\n        #   on both 6002 and 6004.\n        #\n        # - Exchange 2013 / 2016 / 2019 servers process RemoteName on their own\n        #   (via RpcProxyShim.dll), and the NetBIOS name format is supported only for\n        #   backward compatibility.\n        #\n        #   ! Default ACL is never used, so there is no way to connect to the endpoint mapper!\n        #\n        #   Allowed ports: 6001-6004\n        #\n        #   6001 is used for MS-OXCRPC\n        #   6002 is used for MS-OXABREF\n        #   6003 is not used\n        #   6004 is used for MS-OXNSPI\n        #\n        # Tests show that all protocols are available on the 6001 / 6002 / 6004 ports via\n        # RPC over HTTP v2, and the separation is only used for backward compatibility.\n        #\n        # The pure ncacn_http endpoint is available only on the 6001 TCP/IP port.\n        #\n        # RpcProxyShim.dll allows you to skip authentication on the RPC level to get\n        # a faster connection, and it makes Exchange 2013 / 2016 / 2019 RPC over HTTP v2\n        # endpoints vulnerable to NTLM-Relaying attacks.\n        #\n        # If the target is Exchange behind Microsoft TMG, you most likely need to specify\n        # the remote name manually using the value from /autodiscover/autodiscover.xml.\n        # Note that /autodiscover/autodiscover.xml might not be available with\n        # a non-outlook User-Agent.\n        #\n        # There may be multiple RPC Proxy servers with different NetBIOS names on\n        # a single external IP. We store the first one's NetBIOS name and use it for all\n        # the following channels.\n        # It's acceptable to assume all RPC Proxies have the same ACLs (true for Exchange).\n        if not self.__remoteName and self.__auth_type == AUTH_BASIC:\n            raise RPCProxyClientException(RPC_PROXY_REMOTE_NAME_NEEDED_ERR)\n\n        if not self.__remoteName:\n            ntlmssp = self.get_ntlmssp_info()\n            self.__remoteName = ntlmssp[ntlm.NTLMSSP_AV_HOSTNAME][1].decode('utf-16le')\n            self._stringbinding.set_network_address(self.__remoteName)\n            LOG.debug('StringBinding has been changed to %s' % self._stringbinding)\n\n        if not self._rpcProxyUrl.query:\n            query = self.__remoteName + ':' + str(self.__dstport)\n            self._rpcProxyUrl = self._rpcProxyUrl._replace(query=query)\n\n        path = self._rpcProxyUrl.path + '?' + self._rpcProxyUrl.query\n\n        self.__channels[method].request(method, path, headers=headers_final)\n        self._read_100_continue(method)",
  "def _read_100_continue(self, method):\n        resp = self.__channels[method].sock.recv(self.RECV_SIZE)\n\n        while resp.find(b'\\r\\n\\r\\n') == -1:\n            resp += self.__channels[method].sock.recv(self.RECV_SIZE)\n\n        # Continue responses can have multiple lines, for example:\n        #\n        # HTTP/1.1 100 Continue\n        # Via: 1.1 FIREWALL1\n        #\n        # Don't expect the response to contain \"100 Continue\\r\\n\\r\\n\"\n        if resp[9:23] != b'100 Continue\\r\\n':\n            try:\n                # The server (IIS) may return localized error messages in\n                # the first line. Tests shown they are in UTF-8.\n                resp = resp.split(b'\\r\\n')[0].decode(\"UTF-8\", errors='replace')\n\n                raise RPCProxyClientException('RPC Proxy Client: %s authentication failed in %s channel' %\n                    (self.__auth_type, method), proxy_error=resp)\n            except (IndexError, KeyError, AttributeError):\n                raise RPCProxyClientException('RPC Proxy Client: %s authentication failed in %s channel' %\n                    (self.__auth_type, method))",
  "def create_tunnel(self):\n        # 3.2.1.5.3.1 Connection Establishment\n        packet = hCONN_A1(self.__virtualConnectionCookie, self.__outChannelCookie, self.__availableWindowAdvertised)\n        self.get_socket_out().send(packet)\n\n        packet = hCONN_B1(self.__virtualConnectionCookie, self.__inChannelCookie, self.__associationGroupId)\n        self.get_socket_in().send(packet)\n\n        resp = self.get_socket_out().recv(self.RECV_SIZE)\n\n        while resp.find(b'\\r\\n\\r\\n') == -1:\n            resp += self.get_socket_out().recv(self.RECV_SIZE)\n\n        if resp[9:12] != b'200':\n            try:\n                # The server (IIS) may return localized error messages in\n                # the first line. Tests shown they are in UTF-8.\n                resp = resp.split(b'\\r\\n')[0].decode(\"UTF-8\", errors='replace')\n\n                raise RPCProxyClientException('RPC Proxy CONN/A1 request failed', proxy_error=resp)\n            except (IndexError, KeyError, AttributeError):\n                raise RPCProxyClientException('RPC Proxy CONN/A1 request failed')\n\n        resp_ascii = resp.decode(\"ASCII\", errors='replace')\n        if \"transfer-encoding: chunked\" in resp_ascii.lower():\n            self.__serverChunked = True\n\n        # If the body is here, let's send it to rpc_out_recv1()\n        self.__readBuffer = resp[resp.find(b'\\r\\n\\r\\n') + 4:]\n\n        # Recieving and parsing CONN/A3\n        conn_a3_rpc = self.rpc_out_read_pkt()\n        conn_a3_pdu = RTSHeader(conn_a3_rpc)['pduData']\n        conn_a3 = CONN_A3_RTS_PDU(conn_a3_pdu)\n        self.__serverConnectionTimeout = conn_a3['ConnectionTimeout']['ConnectionTimeout']\n\n        # Recieving and parsing CONN/C2\n        conn_c2_rpc = self.rpc_out_read_pkt()\n        conn_c2_pdu = RTSHeader(conn_c2_rpc)['pduData']\n        conn_c2 = CONN_C2_RTS_PDU(conn_c2_pdu)\n        self.__serverReceiveWindowSize = conn_c2['ReceiveWindowSize']['ReceiveWindowSize']",
  "def get_socket_in(self):\n        return self.__channels['RPC_IN_DATA'].sock",
  "def get_socket_out(self):\n        return self.__channels['RPC_OUT_DATA'].sock",
  "def close_rpc_in_channel(self):\n        return self.__channels['RPC_IN_DATA'].close()",
  "def close_rpc_out_channel(self):\n        return self.__channels['RPC_OUT_DATA'].close()",
  "def check_http_error(self, buffer):\n        if buffer[:22] == b'HTTP/1.0 503 RPC Error':\n            raise RPCProxyClientException('RPC Proxy request failed', proxy_error=buffer)",
  "def rpc_out_recv1(self, amt=None):\n        # Read with at most one underlying system call.\n        # The function MUST return the maximum amt bytes.\n        #\n        # Strictly speaking, it may cause more than one read,\n        # but that is ok, since that is to satisfy the chunked protocol.\n        sock = self.get_socket_out()\n\n        if self.__serverChunked is False:\n            if len(self.__readBuffer) > 0:\n                buffer = self.__readBuffer\n                self.__readBuffer = b''\n            else:\n                # Let's read RECV_SIZE bytes and not amt bytes.\n                # We would need to check the answer for HTTP errors, as\n                # they can just appear in the middle of the stream.\n                buffer = sock.recv(self.RECV_SIZE)\n\n            self.check_http_error(buffer)\n\n            if len(buffer) <= amt:\n                return buffer\n\n            # We received more than we need\n            self.__readBuffer = buffer[amt:]\n            return buffer[:amt]\n\n        # Check if the previous chunk is still there\n        if self.__chunkLeft > 0:\n            # If the previous chunk is still there,\n            # just give the caller what we already have\n            if amt >= self.__chunkLeft:\n                buffer = self.__readBuffer[:self.__chunkLeft]\n                # We may have recieved a part of a new chunk\n                self.__readBuffer = self.__readBuffer[self.__chunkLeft + 2:]\n                self.__chunkLeft = 0\n\n                return buffer\n            else:\n                buffer = self.__readBuffer[:amt]\n                self.__readBuffer = self.__readBuffer[amt:]\n                self.__chunkLeft -= amt\n\n                return buffer\n\n        # Let's start to process a new chunk\n        buffer = self.__readBuffer\n        self.__readBuffer = b''\n\n        self.check_http_error(buffer)\n\n        # Let's receive a chunk size field which ends with CRLF\n        # For Microsoft TMG 2010 it can cause more than one read\n        while buffer.find(b'\\r\\n') == -1:\n            buffer += sock.recv(self.RECV_SIZE)\n            self.check_http_error(buffer)\n\n        chunksize = int(buffer[:buffer.find(b'\\r\\n')], 16)\n        buffer = buffer[buffer.find(b'\\r\\n') + 2:]\n\n        # Let's read at least our chunk including final CRLF\n        while len(buffer) - 2 < chunksize:\n            buffer += sock.recv(chunksize - len(buffer) + 2)\n\n        # We should not be using any information from\n        # the TCP level to determine HTTP boundaries.\n        # So, we may have received more than we need.\n        if len(buffer) - 2 > chunksize:\n            self.__readBuffer = buffer[chunksize + 2:]\n            buffer = buffer[:chunksize + 2]\n\n        # Checking the amt\n        if len(buffer) - 2 > amt:\n            self.__chunkLeft = chunksize - amt\n            # We may have recieved a part of a new chunk before,\n            # so the concatenation is crucual\n            self.__readBuffer = buffer[amt:] + self.__readBuffer\n\n            return buffer[:amt]\n        else:\n            # Removing CRLF\n            return buffer[:-2]",
  "def send(self, data, forceWriteAndx=0, forceRecv=0):\n        # We don't use chunked encoding for IN channel as\n        # Microsoft software is developed this way.\n        # If you do this, it may fail.\n        self.get_socket_in().send(data)",
  "def rpc_out_read_pkt(self, handle_rts=False):\n        while True:\n            response_data = b''\n\n            # Let's receive common RPC header and no more\n            #\n            # C706\n            # 12.4 Common Fields\n            # Header encodings differ between connectionless and connection-oriented PDUs.\n            # However, certain fields use common sets of values with a consistent\n            # interpretation across the two protocols.\n            #\n            # This MUST recv MSRPCHeader._SIZE bytes, and not MSRPCRespHeader._SIZE bytes!\n            #\n            while len(response_data) < MSRPCHeader._SIZE:\n                response_data += self.rpc_out_recv1(MSRPCHeader._SIZE - len(response_data))\n\n            response_header = MSRPCHeader(response_data)\n\n            # frag_len contains the full length of the packet for both\n            # MSRPC and RTS\n            frag_len = response_header['frag_len']\n\n            # Receiving the full pkt and no more\n            while len(response_data) < frag_len:\n               response_data += self.rpc_out_recv1(frag_len - len(response_data))\n\n            # We need to do the Flow Control procedures\n            #\n            # 3.2.1.1.4\n            # This protocol specifies that only RPC PDUs are subject to the flow control abstract data\n            # model. RTS PDUs and the HTTP request and response headers are not subject to flow control.\n            if response_header['type'] != MSRPC_RTS:\n                self.flow_control(frag_len)\n\n            if handle_rts is True and response_header['type'] == MSRPC_RTS:\n                self.handle_out_of_sequence_rts(response_data)\n            else:\n                return response_data",
  "def recv(self, forceRecv=0, count=0):\n        return self.rpc_out_read_pkt(handle_rts=True)",
  "def handle_out_of_sequence_rts(self, response_data):\n        packet = RTSHeader(response_data)\n\n        #print(\"=========== RTS PKT ===========\")\n        #print(\"RAW: %s\" % binascii.hexlify(response_data))\n        #packet.dump()\n        #\n        #pduData = packet['pduData']\n        #numberOfCommands = packet['NumberOfCommands']\n        #\n        #server_cmds = []\n        #while numberOfCommands > 0:\n        #    numberOfCommands -= 1\n        #\n        #    cmd_type = unpack('<L', pduData[:4])[0]\n        #    cmd = COMMANDS[cmd_type](pduData)\n        #    server_cmds.append(cmd)\n        #    pduData = pduData[len(cmd):]\n        #\n        #for cmd in server_cmds:\n        #    cmd.dump()\n        #print(\"=========== / RTS PKT ===========\")\n\n        # 2.2.4.49 Ping RTS PDU\n        if packet['Flags'] == RTS_FLAG_PING:\n            # 3.2.1.2.1 PingTimer\n            #\n            # If the SendingChannel is part of a Virtual Connection in the Outbound Proxy or Client roles, the\n            # SendingChannel maintains a PingTimer that on expiration indicates a PING PDU must be sent to the\n            # receiving channel. The PING PDU is sent to the receiving channel when no data has been sent within\n            # half of the value of the KeepAliveInterval.\n\n            # As we do not do long-term connections with no data transfer,\n            # it means something on the server-side is going wrong.\n            self.rts_ping_received = True\n            LOG.error(\"Ping RTS PDU packet received. Is the RPC Server alive?\")\n\n            # Just in case it's a long operation, let's send PING PDU to IN Channel like in xfreerdp\n            # It's better to send more than one PING packet as it only 20 bytes long\n            packet = hPing()\n            self.send(packet)\n            self.send(packet)\n        # 2.2.4.24 OUT_R1/A2 RTS PDU\n        elif packet['Flags'] == RTS_FLAG_RECYCLE_CHANNEL:\n            raise RPCProxyClientException(\"The server requested recycling of a virtual OUT channel, \" \\\n                \"but this function is not supported!\")\n        # Ignore all other messages, most probably flow control acknowledgments\n        else:\n            pass",
  "def flow_control(self, frag_len):\n        self.__bytesReceived += frag_len\n        self.__receiverAvailableWindow -= frag_len\n\n        if (self.__receiverAvailableWindow < self.__availableWindowAdvertised // 2):\n            self.__receiverAvailableWindow = self.__availableWindowAdvertised\n            packet = hFlowControlAckWithDestination(FDOutProxy, self.__bytesReceived,\n                self.__availableWindowAdvertised, self.__outChannelCookie)\n            self.send(packet)",
  "def connect(self):\n        self.create_rpc_in_channel()\n        self.create_rpc_out_channel()\n        self.create_tunnel()",
  "def disconnect(self):\n        self.close_rpc_in_channel()\n        self.close_rpc_out_channel()\n        self.init_state()",
  "class DCERPCSessionError(DCERPCException):\n    def __init__(self, error_string=None, error_code=None, packet=None):\n        DCERPCException.__init__(self, error_string, error_code, packet)\n\n    def __str__( self ):\n        key = self.error_code\n        if key in hresult_errors.ERROR_MESSAGES:\n            error_msg_short = hresult_errors.ERROR_MESSAGES[key][0]\n            error_msg_verbose = hresult_errors.ERROR_MESSAGES[key][1]\n            return 'DRSR SessionError: code: 0x%x - %s - %s' % (self.error_code, error_msg_short, error_msg_verbose)\n        elif key & 0xffff in system_errors.ERROR_MESSAGES:\n            error_msg_short = system_errors.ERROR_MESSAGES[key & 0xffff][0]\n            error_msg_verbose = system_errors.ERROR_MESSAGES[key & 0xffff][1]\n            return 'DRSR SessionError: code: 0x%x - %s - %s' % (self.error_code, error_msg_short, error_msg_verbose)\n        else:\n            return 'DRSR SessionError: unknown error code: 0x%x' % self.error_code",
  "class EXOP_ERR(NDRENUM):\n    align = 4\n    align64 = 4\n    structure = (\n        ('Data', '<L'),\n    )\n    class enumItems(Enum):\n        EXOP_ERR_SUCCESS               = 0x00000001\n        EXOP_ERR_UNKNOWN_OP            = 0x00000002\n        EXOP_ERR_FSMO_NOT_OWNER        = 0x00000003\n        EXOP_ERR_UPDATE_ERR            = 0x00000004\n        EXOP_ERR_EXCEPTION             = 0x00000005\n        EXOP_ERR_UNKNOWN_CALLER        = 0x00000006\n        EXOP_ERR_RID_ALLOC             = 0x00000007\n        EXOP_ERR_FSMO_OWNER_DELETED    = 0x00000008\n        EXOP_ERR_FSMO_PENDING_OP       = 0x00000009\n        EXOP_ERR_MISMATCH              = 0x0000000A\n        EXOP_ERR_COULDNT_CONTACT       = 0x0000000B\n        EXOP_ERR_FSMO_REFUSING_ROLES   = 0x0000000C\n        EXOP_ERR_DIR_ERROR             = 0x0000000D\n        EXOP_ERR_FSMO_MISSING_SETTINGS = 0x0000000E\n        EXOP_ERR_ACCESS_DENIED         = 0x0000000F\n        EXOP_ERR_PARAM_ERROR           = 0x00000010\n\n    def dump(self, msg = None, indent = 0):\n        if msg is None:\n            msg = self.__class__.__name__\n        if msg != '':\n            print(msg, end=' ')\n\n        try:\n            print(\" %s\" % self.enumItems(self.fields['Data']).name, end=' ')\n        except ValueError:\n            print(\" %d\" % self.fields['Data'])",
  "class ENCRYPTED_PAYLOAD(Structure):\n    structure = (\n        ('Salt','16s'),\n        ('CheckSum','<L'),\n        ('EncryptedData',':'),\n    )",
  "class NT4SID(NDRSTRUCT):\n    structure =  (\n        ('Data','28s=b\"\"'),\n    )\n    def getAlignment(self):\n        return 4",
  "class DRS_HANDLE(NDRSTRUCT):\n    structure =  (\n        ('Data','20s=b\"\"'),\n    )\n    def getAlignment(self):\n        return 4",
  "class PDRS_HANDLE(NDRPOINTER):\n    referent = (\n        ('Data',DRS_HANDLE),\n    )",
  "class BYTE_ARRAY(NDRUniConformantArray):\n    item = 'c'",
  "class PBYTE_ARRAY(NDRPOINTER):\n    referent = (\n        ('Data',BYTE_ARRAY),\n    )",
  "class DRS_EXTENSIONS(NDRSTRUCT):\n    structure =  (\n        ('cb',DWORD),\n        ('rgb',BYTE_ARRAY),\n    )",
  "class PDRS_EXTENSIONS(NDRPOINTER):\n    referent = (\n        ('Data',DRS_EXTENSIONS),\n    )",
  "class DRS_EXTENSIONS_INT(Structure):\n    structure =  (\n        ('dwFlags','<L=0'),\n        ('SiteObjGuid','16s=b\"\"'),\n        ('Pid','<L=0'),\n        ('dwReplEpoch','<L=0'),\n        ('dwFlagsExt','<L=0'),\n        ('ConfigObjGUID','16s=b\"\"'),\n        ('dwExtCaps','<L=0'),\n    )",
  "class DRS_MSG_DCINFOREQ_V1(NDRSTRUCT):\n    structure =  (\n        ('Domain',LPWSTR),\n        ('InfoLevel',DWORD),\n    )",
  "class DRS_MSG_DCINFOREQ(NDRUNION):\n    commonHdr = (\n        ('tag', DWORD),\n    )\n    union = {\n        1  : ('V1', DRS_MSG_DCINFOREQ_V1),\n    }",
  "class DS_DOMAIN_CONTROLLER_INFO_1W(NDRSTRUCT):\n    structure =  (\n        ('NetbiosName',LPWSTR),\n        ('DnsHostName',LPWSTR),\n        ('SiteName',LPWSTR),\n        ('ComputerObjectName',LPWSTR),\n        ('ServerObjectName',LPWSTR),\n        ('fIsPdc',BOOL),\n        ('fDsEnabled',BOOL),\n    )",
  "class DS_DOMAIN_CONTROLLER_INFO_1W_ARRAY(NDRUniConformantArray):\n    item = DS_DOMAIN_CONTROLLER_INFO_1W",
  "class PDS_DOMAIN_CONTROLLER_INFO_1W_ARRAY(NDRPOINTER):\n    referent = (\n        ('Data',DS_DOMAIN_CONTROLLER_INFO_1W_ARRAY),\n    )",
  "class DRS_MSG_DCINFOREPLY_V1(NDRSTRUCT):\n    structure =  (\n        ('cItems',DWORD),\n        ('rItems',PDS_DOMAIN_CONTROLLER_INFO_1W_ARRAY),\n    )",
  "class DS_DOMAIN_CONTROLLER_INFO_2W(NDRSTRUCT):\n    structure =  (\n        ('NetbiosName',LPWSTR),\n        ('DnsHostName',LPWSTR),\n        ('SiteName',LPWSTR),\n        ('SiteObjectName',LPWSTR),\n        ('ComputerObjectName',LPWSTR),\n        ('ServerObjectName',LPWSTR),\n        ('NtdsDsaObjectName',LPWSTR),\n        ('fIsPdc',BOOL),\n        ('fDsEnabled',BOOL),\n        ('fIsGc',BOOL),\n        ('SiteObjectGuid',GUID),\n        ('ComputerObjectGuid',GUID),\n        ('ServerObjectGuid',GUID),\n        ('NtdsDsaObjectGuid',GUID),\n    )",
  "class DS_DOMAIN_CONTROLLER_INFO_2W_ARRAY(NDRUniConformantArray):\n    item = DS_DOMAIN_CONTROLLER_INFO_2W",
  "class PDS_DOMAIN_CONTROLLER_INFO_2W_ARRAY(NDRPOINTER):\n    referent = (\n        ('Data',DS_DOMAIN_CONTROLLER_INFO_2W_ARRAY),\n    )",
  "class DRS_MSG_DCINFOREPLY_V2(NDRSTRUCT):\n    structure =  (\n        ('cItems',DWORD),\n        ('rItems',PDS_DOMAIN_CONTROLLER_INFO_2W_ARRAY),\n    )",
  "class DS_DOMAIN_CONTROLLER_INFO_3W(NDRSTRUCT):\n    structure =  (\n        ('NetbiosName',LPWSTR),\n        ('DnsHostName',LPWSTR),\n        ('SiteName',LPWSTR),\n        ('SiteObjectName',LPWSTR),\n        ('ComputerObjectName',LPWSTR),\n        ('ServerObjectName',LPWSTR),\n        ('NtdsDsaObjectName',LPWSTR),\n        ('fIsPdc',BOOL),\n        ('fDsEnabled',BOOL),\n        ('fIsGc',BOOL),\n        ('fIsRodc',BOOL),\n        ('SiteObjectGuid',GUID),\n        ('ComputerObjectGuid',GUID),\n        ('ServerObjectGuid',GUID),\n        ('NtdsDsaObjectGuid',GUID),\n    )",
  "class DS_DOMAIN_CONTROLLER_INFO_3W_ARRAY(NDRUniConformantArray):\n    item = DS_DOMAIN_CONTROLLER_INFO_3W",
  "class PDS_DOMAIN_CONTROLLER_INFO_3W_ARRAY(NDRPOINTER):\n    referent = (\n        ('Data',DS_DOMAIN_CONTROLLER_INFO_3W_ARRAY),\n    )",
  "class DRS_MSG_DCINFOREPLY_V3(NDRSTRUCT):\n    structure =  (\n        ('cItems',DWORD),\n        ('rItems',PDS_DOMAIN_CONTROLLER_INFO_3W_ARRAY),\n    )",
  "class DS_DOMAIN_CONTROLLER_INFO_FFFFFFFFW(NDRSTRUCT):\n    structure =  (\n        ('IPAddress',DWORD),\n        ('NotificationCount',DWORD),\n        ('secTimeConnected',DWORD),\n        ('Flags',DWORD),\n        ('TotalRequests',DWORD),\n        ('Reserved1',DWORD),\n        ('UserName',LPWSTR),\n    )",
  "class DS_DOMAIN_CONTROLLER_INFO_FFFFFFFFW_ARRAY(NDRUniConformantArray):\n    item = DS_DOMAIN_CONTROLLER_INFO_FFFFFFFFW",
  "class PDS_DOMAIN_CONTROLLER_INFO_FFFFFFFFW_ARRAY(NDRPOINTER):\n    referent = (\n        ('Data',DS_DOMAIN_CONTROLLER_INFO_FFFFFFFFW_ARRAY),\n    )",
  "class DRS_MSG_DCINFOREPLY_VFFFFFFFF(NDRSTRUCT):\n    structure =  (\n        ('cItems',DWORD),\n        ('rItems',PDS_DOMAIN_CONTROLLER_INFO_FFFFFFFFW_ARRAY),\n    )",
  "class DRS_MSG_DCINFOREPLY(NDRUNION):\n    commonHdr = (\n        ('tag', DWORD),\n    )\n    union = {\n        1  : ('V1', DRS_MSG_DCINFOREPLY_V1),\n        2  : ('V2', DRS_MSG_DCINFOREPLY_V2),\n        3  : ('V3', DRS_MSG_DCINFOREPLY_V3),\n        0xffffffff  : ('V1', DRS_MSG_DCINFOREPLY_VFFFFFFFF),\n    }",
  "class LPWSTR_ARRAY(NDRUniConformantArray):\n    item = LPWSTR",
  "class PLPWSTR_ARRAY(NDRPOINTER):\n    referent = (\n        ('Data',LPWSTR_ARRAY),\n    )",
  "class DRS_MSG_CRACKREQ_V1(NDRSTRUCT):\n    structure =  (\n        ('CodePage',ULONG),\n        ('LocaleId',ULONG),\n        ('dwFlags',DWORD),\n        ('formatOffered',DWORD),\n        ('formatDesired',DWORD),\n        ('cNames',DWORD),\n        ('rpNames',PLPWSTR_ARRAY),\n    )",
  "class DRS_MSG_CRACKREQ(NDRUNION):\n    commonHdr = (\n        ('tag', DWORD),\n    )\n    union = {\n        1  : ('V1', DRS_MSG_CRACKREQ_V1),\n    }",
  "class DS_NAME_FORMAT(NDRENUM):\n    class enumItems(Enum):\n        DS_UNKNOWN_NAME            = 0\n        DS_FQDN_1779_NAME          = 1\n        DS_NT4_ACCOUNT_NAME        = 2\n        DS_DISPLAY_NAME            = 3\n        DS_UNIQUE_ID_NAME          = 6\n        DS_CANONICAL_NAME          = 7\n        DS_USER_PRINCIPAL_NAME     = 8\n        DS_CANONICAL_NAME_EX       = 9\n        DS_SERVICE_PRINCIPAL_NAME  = 10\n        DS_SID_OR_SID_HISTORY_NAME = 11\n        DS_DNS_DOMAIN_NAME         = 12",
  "class DS_NAME_RESULT_ITEMW(NDRSTRUCT):\n    structure =  (\n        ('status',DWORD),\n        ('pDomain',LPWSTR),\n        ('pName',LPWSTR),\n    )",
  "class DS_NAME_RESULT_ITEMW_ARRAY(NDRUniConformantArray):\n    item = DS_NAME_RESULT_ITEMW",
  "class PDS_NAME_RESULT_ITEMW_ARRAY(NDRPOINTER):\n    referent = (\n        ('Data',DS_NAME_RESULT_ITEMW_ARRAY),\n    )",
  "class DS_NAME_RESULTW(NDRSTRUCT):\n    structure =  (\n        ('cItems',DWORD),\n        ('rItems',PDS_NAME_RESULT_ITEMW_ARRAY),\n    )",
  "class PDS_NAME_RESULTW(NDRPOINTER):\n    referent = (\n        ('Data',DS_NAME_RESULTW),\n    )",
  "class DRS_MSG_CRACKREPLY_V1(NDRSTRUCT):\n    structure =  (\n        ('pResult',PDS_NAME_RESULTW),\n    )",
  "class DRS_MSG_CRACKREPLY(NDRUNION):\n    commonHdr = (\n        ('tag', DWORD),\n    )\n    union = {\n        1  : ('V1', DRS_MSG_CRACKREPLY_V1),\n    }",
  "class UPTODATE_CURSOR_V1(NDRSTRUCT):\n    structure =  (\n        ('uuidDsa',UUID),\n        ('usnHighPropUpdate',USN),\n    )",
  "class UPTODATE_CURSOR_V1_ARRAY(NDRUniConformantArray):\n    item = UPTODATE_CURSOR_V1",
  "class UPTODATE_VECTOR_V1_EXT(NDRSTRUCT):\n    structure =  (\n        ('dwVersion',DWORD),\n        ('dwReserved1',DWORD),\n        ('cNumCursors',DWORD),\n        ('dwReserved2',DWORD),\n        ('rgCursors',UPTODATE_CURSOR_V1_ARRAY),\n    )",
  "class PUPTODATE_VECTOR_V1_EXT(NDRPOINTER):\n    referent = (\n        ('Data',UPTODATE_VECTOR_V1_EXT),\n    )",
  "class USN_VECTOR(NDRSTRUCT):\n    structure =  (\n        ('usnHighObjUpdate',USN),\n        ('usnReserved',USN),\n        ('usnHighPropUpdate',USN),\n    )",
  "class WCHAR_ARRAY(NDRUniConformantArray):\n    item  = 'H'\n\n    def __setitem__(self, key, value):\n        self.fields['MaximumCount'] = None\n        self.data = None        # force recompute\n        return NDRUniConformantArray.__setitem__(self, key, [ord(c) for c in value])\n\n    def __getitem__(self, key):\n        if key == 'Data':\n            try:\n                return ''.join([six.unichr(i) for i in self.fields[key]])\n            except ValueError as e:\n                LOG.debug(\"ValueError Exception\", exc_info=True)\n                LOG.error(str(e))\n        else:\n            return NDR.__getitem__(self,key)",
  "class DSNAME(NDRSTRUCT):\n    structure =  (\n        ('structLen',ULONG),\n        ('SidLen',ULONG),\n        ('Guid',GUID),\n        ('Sid',NT4SID),\n        ('NameLen',ULONG),\n        ('StringName', WCHAR_ARRAY),\n    )\n    def getDataLen(self, data, offset=0):\n        return self['NameLen']\n    def getData(self, soFar = 0):\n        return NDRSTRUCT.getData(self, soFar)",
  "class PDSNAME(NDRPOINTER):\n    referent = (\n        ('Data',DSNAME),\n    )",
  "class PDSNAME_ARRAY(NDRUniConformantArray):\n    item = PDSNAME",
  "class PPDSNAME_ARRAY(NDRPOINTER):\n    referent = (\n        ('Data',PDSNAME_ARRAY),\n    )",
  "class ATTRTYP_ARRAY(NDRUniConformantArray):\n    item = ATTRTYP",
  "class PARTIAL_ATTR_VECTOR_V1_EXT(NDRSTRUCT):\n    structure =  (\n        ('dwVersion',DWORD),\n        ('dwReserved1',DWORD),\n        ('cAttrs',DWORD),\n        ('rgPartialAttr',ATTRTYP_ARRAY),\n    )",
  "class PPARTIAL_ATTR_VECTOR_V1_EXT(NDRPOINTER):\n    referent = (\n        ('Data',PARTIAL_ATTR_VECTOR_V1_EXT),\n    )",
  "class OID_t(NDRSTRUCT):\n    structure =  (\n        ('length',ULONG),\n        ('elements',PBYTE_ARRAY),\n    )",
  "class PrefixTableEntry(NDRSTRUCT):\n    structure =  (\n        ('ndx',ULONG),\n        ('prefix',OID_t),\n    )",
  "class PrefixTableEntry_ARRAY(NDRUniConformantArray):\n    item = PrefixTableEntry",
  "class PPrefixTableEntry_ARRAY(NDRPOINTER):\n    referent = (\n        ('Data',PrefixTableEntry_ARRAY),\n    )",
  "class SCHEMA_PREFIX_TABLE(NDRSTRUCT):\n    structure =  (\n        ('PrefixCount',DWORD),\n        ('pPrefixEntry',PPrefixTableEntry_ARRAY),\n    )",
  "class DRS_MSG_GETCHGREQ_V3(NDRSTRUCT):\n    structure =  (\n        ('uuidDsaObjDest',UUID),\n        ('uuidInvocIdSrc',UUID),\n        ('pNC',PDSNAME),\n        ('usnvecFrom',USN_VECTOR),\n        ('pUpToDateVecDestV1',PUPTODATE_VECTOR_V1_EXT),\n        ('pPartialAttrVecDestV1',PPARTIAL_ATTR_VECTOR_V1_EXT),\n        ('PrefixTableDest',SCHEMA_PREFIX_TABLE),\n        ('ulFlags',ULONG),\n        ('cMaxObjects',ULONG),\n        ('cMaxBytes',ULONG),\n        ('ulExtendedOp',ULONG),\n    )",
  "class MTX_ADDR(NDRSTRUCT):\n    structure =  (\n        ('mtx_namelen',ULONG),\n        ('mtx_name',PBYTE_ARRAY),\n    )",
  "class PMTX_ADDR(NDRPOINTER):\n    referent = (\n        ('Data',MTX_ADDR),\n    )",
  "class DRS_MSG_GETCHGREQ_V4(NDRSTRUCT):\n    structure =  (\n        ('uuidTransportObj',UUID),\n        ('pmtxReturnAddress',PMTX_ADDR),\n        ('V3',DRS_MSG_GETCHGREQ_V3),\n    )",
  "class DRS_MSG_GETCHGREQ_V5(NDRSTRUCT):\n    structure =  (\n        ('uuidDsaObjDest',UUID),\n        ('uuidInvocIdSrc',UUID),\n        ('pNC',PDSNAME),\n        ('usnvecFrom',USN_VECTOR),\n        ('pUpToDateVecDestV1',PUPTODATE_VECTOR_V1_EXT),\n        ('ulFlags',ULONG),\n        ('cMaxObjects',ULONG),\n        ('cMaxBytes',ULONG),\n        ('ulExtendedOp',ULONG),\n        ('liFsmoInfo',ULARGE_INTEGER),\n    )",
  "class DRS_MSG_GETCHGREQ_V7(NDRSTRUCT):\n    structure =  (\n        ('uuidTransportObj',UUID),\n        ('pmtxReturnAddress',PMTX_ADDR),\n        ('V3',DRS_MSG_GETCHGREQ_V3),\n        ('pPartialAttrSet',PPARTIAL_ATTR_VECTOR_V1_EXT),\n        ('pPartialAttrSetEx1',PPARTIAL_ATTR_VECTOR_V1_EXT),\n        ('PrefixTableDest',SCHEMA_PREFIX_TABLE),\n    )",
  "class DRS_MSG_GETCHGREQ_V8(NDRSTRUCT):\n    structure =  (\n        ('uuidDsaObjDest',UUID),\n        ('uuidInvocIdSrc',UUID),\n        ('pNC',PDSNAME),\n        ('usnvecFrom',USN_VECTOR),\n        ('pUpToDateVecDest',PUPTODATE_VECTOR_V1_EXT),\n        ('ulFlags',ULONG),\n        ('cMaxObjects',ULONG),\n        ('cMaxBytes',ULONG),\n        ('ulExtendedOp',ULONG),\n        ('liFsmoInfo',ULARGE_INTEGER),\n        ('pPartialAttrSet',PPARTIAL_ATTR_VECTOR_V1_EXT),\n        ('pPartialAttrSetEx1',PPARTIAL_ATTR_VECTOR_V1_EXT),\n        ('PrefixTableDest',SCHEMA_PREFIX_TABLE),\n    )",
  "class DRS_MSG_GETCHGREQ_V10(NDRSTRUCT):\n    structure =  (\n        ('uuidDsaObjDest',UUID),\n        ('uuidInvocIdSrc',UUID),\n        ('pNC',PDSNAME),\n        ('usnvecFrom',USN_VECTOR),\n        ('pUpToDateVecDest',PUPTODATE_VECTOR_V1_EXT),\n        ('ulFlags',ULONG),\n        ('cMaxObjects',ULONG),\n        ('cMaxBytes',ULONG),\n        ('ulExtendedOp',ULONG),\n        ('liFsmoInfo',ULARGE_INTEGER),\n        ('pPartialAttrSet',PPARTIAL_ATTR_VECTOR_V1_EXT),\n        ('pPartialAttrSetEx1',PPARTIAL_ATTR_VECTOR_V1_EXT),\n        ('PrefixTableDest',SCHEMA_PREFIX_TABLE),\n        ('ulMoreFlags',ULONG),\n    )",
  "class DRS_MSG_GETCHGREQ(NDRUNION):\n    commonHdr = (\n        ('tag', DWORD),\n    )\n    union = {\n        4  : ('V4', DRS_MSG_GETCHGREQ_V4),\n        5  : ('V5', DRS_MSG_GETCHGREQ_V5),\n        7  : ('V7', DRS_MSG_GETCHGREQ_V7),\n        8  : ('V8', DRS_MSG_GETCHGREQ_V8),\n        10 : ('V10', DRS_MSG_GETCHGREQ_V10),\n    }",
  "class ATTRVAL(NDRSTRUCT):\n    structure =  (\n        ('valLen',ULONG),\n        ('pVal',PBYTE_ARRAY),\n    )",
  "class ATTRVAL_ARRAY(NDRUniConformantArray):\n    item = ATTRVAL",
  "class PATTRVAL_ARRAY(NDRPOINTER):\n    referent = (\n        ('Data',ATTRVAL_ARRAY),\n    )",
  "class ATTRVALBLOCK(NDRSTRUCT):\n    structure =  (\n        ('valCount',ULONG),\n        ('pAVal',PATTRVAL_ARRAY),\n    )",
  "class ATTR(NDRSTRUCT):\n    structure =  (\n        ('attrTyp',ATTRTYP),\n        ('AttrVal',ATTRVALBLOCK),\n    )",
  "class ATTR_ARRAY(NDRUniConformantArray):\n    item = ATTR",
  "class PATTR_ARRAY(NDRPOINTER):\n    referent = (\n        ('Data',ATTR_ARRAY),\n    )",
  "class ATTRBLOCK(NDRSTRUCT):\n    structure =  (\n        ('attrCount',ULONG),\n        ('pAttr',PATTR_ARRAY),\n    )",
  "class ENTINF(NDRSTRUCT):\n    structure =  (\n        ('pName',PDSNAME),\n        ('ulFlags',ULONG),\n        ('AttrBlock',ATTRBLOCK),\n    )",
  "class ENTINF_ARRAY(NDRUniConformantArray):\n    item = ENTINF",
  "class PENTINF_ARRAY(NDRPOINTER):\n    referent = (\n        ('Data',ENTINF_ARRAY),\n    )",
  "class PROPERTY_META_DATA_EXT(NDRSTRUCT):\n    structure =  (\n        ('dwVersion',DWORD),\n        ('timeChanged',DSTIME),\n        ('uuidDsaOriginating',UUID),\n        ('usnOriginating',USN),\n    )",
  "class PROPERTY_META_DATA_EXT_ARRAY(NDRUniConformantArray):\n    item = PROPERTY_META_DATA_EXT",
  "class PROPERTY_META_DATA_EXT_VECTOR(NDRSTRUCT):\n    structure =  (\n        ('cNumProps',DWORD),\n        ('rgMetaData',PROPERTY_META_DATA_EXT_ARRAY),\n    )",
  "class PPROPERTY_META_DATA_EXT_VECTOR(NDRPOINTER):\n    referent = (\n        ('Data',PROPERTY_META_DATA_EXT_VECTOR),\n    )",
  "class REPLENTINFLIST(NDRSTRUCT):\n    structure =  (\n        ('pNextEntInf',NDRPOINTER),\n        ('Entinf',ENTINF),\n        ('fIsNCPrefix',BOOL),\n        ('pParentGuidm',PUUID),\n        ('pMetaDataExt',PPROPERTY_META_DATA_EXT_VECTOR),\n    )\n    # ToDo: Here we should work with getData and fromString because we're cheating with pNextEntInf\n    def fromString(self, data, soFar = 0 ):\n        # Here we're changing the struct so we can represent a linked list with NDR\n        self.fields['pNextEntInf'] = PREPLENTINFLIST(isNDR64 = self._isNDR64)\n        retVal = NDRSTRUCT.fromString(self, data, soFar)\n        return retVal",
  "class PREPLENTINFLIST(NDRPOINTER):\n    referent = (\n        ('Data',REPLENTINFLIST),\n    )",
  "class DRS_MSG_GETCHGREPLY_V1(NDRSTRUCT):\n    structure =  (\n        ('uuidDsaObjSrc',UUID),\n        ('uuidInvocIdSrc',UUID),\n        ('pNC',PDSNAME),\n        ('usnvecFrom',USN_VECTOR),\n        ('usnvecTo',USN_VECTOR),\n        ('pUpToDateVecSrcV1',PUPTODATE_VECTOR_V1_EXT),\n        ('PrefixTableSrc',SCHEMA_PREFIX_TABLE),\n        ('ulExtendedRet',EXOP_ERR),\n        ('cNumObjects',ULONG),\n        ('cNumBytes',ULONG),\n        ('pObjects',PREPLENTINFLIST),\n        ('fMoreData',BOOL),\n    )",
  "class DRS_COMPRESSED_BLOB(NDRSTRUCT):\n    structure =  (\n        ('cbUncompressedSize',DWORD),\n        ('cbCompressedSize',DWORD),\n        ('pbCompressedData',BYTE_ARRAY),\n    )",
  "class DRS_MSG_GETCHGREPLY_V2(NDRSTRUCT):\n    structure =  (\n        ('CompressedV1',DRS_COMPRESSED_BLOB),\n    )",
  "class UPTODATE_CURSOR_V2(NDRSTRUCT):\n    structure =  (\n        ('uuidDsa',UUID),\n        ('usnHighPropUpdate',USN),\n        ('timeLastSyncSuccess',DSTIME),\n    )",
  "class UPTODATE_CURSOR_V2_ARRAY(NDRUniConformantArray):\n    item = UPTODATE_CURSOR_V2",
  "class UPTODATE_VECTOR_V2_EXT(NDRSTRUCT):\n    structure =  (\n        ('dwVersion',DWORD),\n        ('dwReserved1',DWORD),\n        ('cNumCursors',DWORD),\n        ('dwReserved2',DWORD),\n        ('rgCursors',UPTODATE_CURSOR_V2_ARRAY),\n    )",
  "class PUPTODATE_VECTOR_V2_EXT(NDRPOINTER):\n    referent = (\n        ('Data',UPTODATE_VECTOR_V2_EXT),\n    )",
  "class VALUE_META_DATA_EXT_V1(NDRSTRUCT):\n    structure =  (\n        ('timeCreated',DSTIME),\n        ('MetaData',PROPERTY_META_DATA_EXT),\n    )",
  "class VALUE_META_DATA_EXT_V3(NDRSTRUCT):\n    structure =  (\n        ('timeCreated',DSTIME),\n        ('MetaData',PROPERTY_META_DATA_EXT),\n        ('unused1',DWORD),\n        ('unused1',DWORD),\n        ('unused1',DWORD),\n        ('timeExpired',DSTIME),\n    )",
  "class REPLVALINF_V1(NDRSTRUCT):\n    structure =  (\n        ('pObject',PDSNAME),\n        ('attrTyp',ATTRTYP),\n        ('Aval',ATTRVAL),\n        ('fIsPresent',BOOL),\n        ('MetaData',VALUE_META_DATA_EXT_V1),\n    )\n\n    def fromString(self, data, soFar = 0):\n        retVal = NDRSTRUCT.fromString(self, data, soFar)\n        #self.dumpRaw()\n        return retVal",
  "class REPLVALINF_V1_ARRAY(NDRUniConformantArray):\n    item = REPLVALINF_V1",
  "class PREPLVALINF_V1_ARRAY(NDRPOINTER):\n    referent = (\n        ('Data', REPLVALINF_V1_ARRAY),\n    )",
  "class REPLVALINF_V3(NDRSTRUCT):\n    structure = (\n        ('pObject', PDSNAME),\n        ('attrTyp', ATTRTYP),\n        ('Aval', ATTRVAL),\n        ('fIsPresent', BOOL),\n        ('MetaData', VALUE_META_DATA_EXT_V3),\n    )\n\n    def fromString(self, data, soFar=0):\n        retVal = NDRSTRUCT.fromString(self, data, soFar)\n        # self.dumpRaw()\n        return retVal",
  "class REPLVALINF_V3_ARRAY(NDRUniConformantArray):\n    item = REPLVALINF_V3",
  "class PREPLVALINF_V3_ARRAY(NDRPOINTER):\n    referent = (\n        ('Data', REPLVALINF_V3_ARRAY),\n    )",
  "class DRS_MSG_GETCHGREPLY_V6(NDRSTRUCT):\n    structure =  (\n        ('uuidDsaObjSrc',UUID),\n        ('uuidInvocIdSrc',UUID),\n        ('pNC',PDSNAME),\n        ('usnvecFrom',USN_VECTOR),\n        ('usnvecTo',USN_VECTOR),\n        ('pUpToDateVecSrc',PUPTODATE_VECTOR_V2_EXT),\n        ('PrefixTableSrc',SCHEMA_PREFIX_TABLE),\n        ('ulExtendedRet',EXOP_ERR),\n        ('cNumObjects',ULONG),\n        ('cNumBytes',ULONG),\n        ('pObjects',PREPLENTINFLIST),\n        ('fMoreData',BOOL),\n        ('cNumNcSizeObjectsc',ULONG),\n        ('cNumNcSizeValues',ULONG),\n        ('cNumValues',DWORD),\n        #('rgValues',PREPLVALINF_V1_ARRAY),\n        # ToDo: Once we find out what's going on with PREPLVALINF_ARRAY get it back\n        # Seems there's something in there that is not being parsed correctly\n        ('rgValues',DWORD),\n        ('dwDRSError',DWORD),\n    )",
  "class DRS_COMP_ALG_TYPE(NDRENUM):\n    class enumItems(Enum):\n        DRS_COMP_ALG_NONE   = 0\n        DRS_COMP_ALG_UNUSED = 1\n        DRS_COMP_ALG_MSZIP  = 2\n        DRS_COMP_ALG_WIN2K3 = 3",
  "class DRS_MSG_GETCHGREPLY_V7(NDRSTRUCT):\n    structure =  (\n        ('dwCompressedVersion',DWORD),\n        ('CompressionAlg',DRS_COMP_ALG_TYPE),\n        ('CompressedAny',DRS_COMPRESSED_BLOB),\n    )",
  "class DRS_MSG_GETCHGREPLY_V9(NDRSTRUCT):\n    structure =  (\n        ('uuidDsaObjSrc',UUID),\n        ('uuidInvocIdSrc',UUID),\n        ('pNC',PDSNAME),\n        ('usnvecFrom',USN_VECTOR),\n        ('usnvecTo',USN_VECTOR),\n        ('pUpToDateVecSrc',PUPTODATE_VECTOR_V2_EXT),\n        ('PrefixTableSrc',SCHEMA_PREFIX_TABLE),\n        ('ulExtendedRet',EXOP_ERR),\n        ('cNumObjects',ULONG),\n        ('cNumBytes',ULONG),\n        ('pObjects',PREPLENTINFLIST),\n        ('fMoreData',BOOL),\n        ('cNumNcSizeObjectsc',ULONG),\n        ('cNumNcSizeValues',ULONG),\n        ('cNumValues',DWORD),\n        #('rgValues',PREPLVALINF_V3_ARRAY),\n        # ToDo: Once we find out what's going on with PREPLVALINF_ARRAY get it back\n        # Seems there's something in there that is not being parsed correctly\n        ('rgValues',DWORD),\n        ('dwDRSError',DWORD),\n    )",
  "class DRS_MSG_GETCHGREPLY(NDRUNION):\n    commonHdr = (\n        ('tag', DWORD),\n    )\n    union = {\n        1  : ('V1', DRS_MSG_GETCHGREPLY_V1),\n        2  : ('V2', DRS_MSG_GETCHGREPLY_V2),\n        6  : ('V6', DRS_MSG_GETCHGREPLY_V6),\n        7  : ('V7', DRS_MSG_GETCHGREPLY_V7),\n        9  : ('V9', DRS_MSG_GETCHGREPLY_V9),\n    }",
  "class DRS_MSG_VERIFYREQ_V1(NDRSTRUCT):\n    structure =  (\n        ('dwFlags',DWORD),\n        ('cNames',DWORD),\n        ('rpNames',PPDSNAME_ARRAY),\n        ('RequiredAttrs',ATTRBLOCK),\n        ('PrefixTable',SCHEMA_PREFIX_TABLE),\n    )",
  "class DRS_MSG_VERIFYREQ(NDRUNION):\n    commonHdr = (\n        ('tag', DWORD),\n    )\n    union = {\n        1  : ('V1', DRS_MSG_VERIFYREQ_V1),\n    }",
  "class DRS_MSG_VERIFYREPLY_V1(NDRSTRUCT):\n    structure =  (\n        ('error',DWORD),\n        ('cNames',DWORD),\n        ('rpEntInf',PENTINF_ARRAY),\n        ('PrefixTable',SCHEMA_PREFIX_TABLE),\n    )",
  "class DRS_MSG_VERIFYREPLY(NDRUNION):\n    commonHdr = (\n        ('tag', DWORD),\n    )\n    union = {\n        1  : ('V1', DRS_MSG_VERIFYREPLY_V1),\n    }",
  "class DRS_MSG_NT4_CHGLOG_REQ_V1(NDRSTRUCT):\n    structure =  (\n        ('dwFlags',DWORD),\n        ('PreferredMaximumLength',DWORD),\n        ('cbRestart',DWORD),\n        ('pRestart',PBYTE_ARRAY),\n    )",
  "class DRS_MSG_NT4_CHGLOG_REQ(NDRUNION):\n    commonHdr = (\n        ('tag', DWORD),\n    )\n    union = {\n        1  : ('V1', DRS_MSG_NT4_CHGLOG_REQ_V1),\n    }",
  "class NT4_REPLICATION_STATE(NDRSTRUCT):\n    structure =  (\n        ('SamSerialNumber',LARGE_INTEGER),\n        ('SamCreationTime',LARGE_INTEGER),\n        ('BuiltinSerialNumber',LARGE_INTEGER),\n        ('BuiltinCreationTime',LARGE_INTEGER),\n        ('LsaSerialNumber',LARGE_INTEGER),\n        ('LsaCreationTime',LARGE_INTEGER),\n    )",
  "class DRS_MSG_NT4_CHGLOG_REPLY_V1(NDRSTRUCT):\n    structure =  (\n        ('cbRestart',DWORD),\n        ('cbLog',DWORD),\n        ('ReplicationState',NT4_REPLICATION_STATE),\n        ('ActualNtStatus',DWORD),\n        ('pRestart',PBYTE_ARRAY),\n        ('pLog',PBYTE_ARRAY),\n    )",
  "class DRS_MSG_NT4_CHGLOG_REPLY(NDRUNION):\n    commonHdr = (\n        ('tag', DWORD),\n    )\n    union = {\n        1  : ('V1', DRS_MSG_NT4_CHGLOG_REPLY_V1),\n    }",
  "class DRSBind(NDRCALL):\n    opnum = 0\n    structure = (\n        ('puuidClientDsa', PUUID),\n        ('pextClient', PDRS_EXTENSIONS),\n    )",
  "class DRSBindResponse(NDRCALL):\n    structure = (\n        ('ppextServer', PDRS_EXTENSIONS),\n        ('phDrs', DRS_HANDLE),\n        ('ErrorCode',DWORD),\n    )",
  "class DRSUnbind(NDRCALL):\n    opnum = 1\n    structure = (\n        ('phDrs', DRS_HANDLE),\n    )",
  "class DRSUnbindResponse(NDRCALL):\n    structure = (\n        ('phDrs', DRS_HANDLE),\n        ('ErrorCode',DWORD),\n    )",
  "class DRSGetNCChanges(NDRCALL):\n    opnum = 3\n    structure = (\n        ('hDrs', DRS_HANDLE),\n        ('dwInVersion', DWORD),\n        ('pmsgIn', DRS_MSG_GETCHGREQ),\n    )",
  "class DRSGetNCChangesResponse(NDRCALL):\n    structure = (\n        ('pdwOutVersion', DWORD),\n        ('pmsgOut', DRS_MSG_GETCHGREPLY),\n        ('ErrorCode',DWORD),\n    )",
  "class DRSVerifyNames(NDRCALL):\n    opnum = 8\n    structure = (\n        ('hDrs', DRS_HANDLE),\n        ('dwInVersion', DWORD),\n        ('pmsgIn', DRS_MSG_VERIFYREQ),\n    )",
  "class DRSVerifyNamesResponse(NDRCALL):\n    structure = (\n        ('pdwOutVersion', DWORD),\n        ('pmsgOut', DRS_MSG_VERIFYREPLY),\n        ('ErrorCode',DWORD),\n    )",
  "class DRSGetNT4ChangeLog(NDRCALL):\n    opnum = 11\n    structure = (\n        ('hDrs', DRS_HANDLE),\n        ('dwInVersion', DWORD),\n        ('pmsgIn', DRS_MSG_NT4_CHGLOG_REQ),\n    )",
  "class DRSGetNT4ChangeLogResponse(NDRCALL):\n    structure = (\n        ('pdwOutVersion', DWORD),\n        ('pmsgOut', DRS_MSG_NT4_CHGLOG_REPLY),\n        ('ErrorCode',DWORD),\n    )",
  "class DRSCrackNames(NDRCALL):\n    opnum = 12\n    structure = (\n        ('hDrs', DRS_HANDLE),\n        ('dwInVersion', DWORD),\n        ('pmsgIn', DRS_MSG_CRACKREQ),\n    )",
  "class DRSCrackNamesResponse(NDRCALL):\n    structure = (\n        ('pdwOutVersion', DWORD),\n        ('pmsgOut', DRS_MSG_CRACKREPLY),\n        ('ErrorCode',DWORD),\n    )",
  "class DRSDomainControllerInfo(NDRCALL):\n    opnum = 16\n    structure = (\n        ('hDrs', DRS_HANDLE),\n        ('dwInVersion', DWORD),\n        ('pmsgIn', DRS_MSG_DCINFOREQ),\n    )",
  "class DRSDomainControllerInfoResponse(NDRCALL):\n    structure = (\n        ('pdwOutVersion', DWORD),\n        ('pmsgOut', DRS_MSG_DCINFOREPLY),\n        ('ErrorCode',DWORD),\n    )",
  "def checkNullString(string):\n    if string == NULL:\n        return string\n\n    if string[-1:] != '\\x00':\n        return string + '\\x00'\n    else:\n        return string",
  "def hDRSUnbind(dce, hDrs):\n    request = DRSUnbind()\n    request['phDrs'] = hDrs\n    return dce.request(request)",
  "def hDRSDomainControllerInfo(dce, hDrs, domain, infoLevel):\n    request = DRSDomainControllerInfo()\n    request['hDrs'] = hDrs\n    request['dwInVersion'] = 1\n\n    request['pmsgIn']['tag'] = 1\n    request['pmsgIn']['V1']['Domain'] = checkNullString(domain)\n    request['pmsgIn']['V1']['InfoLevel'] = infoLevel\n    return dce.request(request)",
  "def hDRSCrackNames(dce, hDrs, flags, formatOffered, formatDesired, rpNames = ()):\n    request = DRSCrackNames()\n    request['hDrs'] = hDrs\n    request['dwInVersion'] = 1\n\n    request['pmsgIn']['tag'] = 1\n    request['pmsgIn']['V1']['CodePage'] = 0\n    request['pmsgIn']['V1']['LocaleId'] = 0\n    request['pmsgIn']['V1']['dwFlags'] = flags\n    request['pmsgIn']['V1']['formatOffered'] = formatOffered\n    request['pmsgIn']['V1']['formatDesired'] = formatDesired\n    request['pmsgIn']['V1']['cNames'] = len(rpNames)\n    for name in rpNames:\n        record = LPWSTR()\n        record['Data'] = checkNullString(name)\n        request['pmsgIn']['V1']['rpNames'].append(record)\n\n    return dce.request(request)",
  "def deriveKey(baseKey):\n        # 2.2.11.1.3 Deriving Key1 and Key2 from a Little-Endian, Unsigned Integer Key\n        # Let I be the little-endian, unsigned integer.\n        # Let I[X] be the Xth byte of I, where I is interpreted as a zero-base-index array of bytes.\n        # Note that because I is in little-endian byte order, I[0] is the least significant byte.\n        # Key1 is a concatenation of the following values: I[0], I[1], I[2], I[3], I[0], I[1], I[2].\n        # Key2 is a concatenation of the following values: I[3], I[0], I[1], I[2], I[3], I[0], I[1]\n        key = pack('<L',baseKey)\n        key1 = [key[0] , key[1] , key[2] , key[3] , key[0] , key[1] , key[2]]\n        key2 = [key[3] , key[0] , key[1] , key[2] , key[3] , key[0] , key[1]]\n        if PY2:\n            return transformKey(b''.join(key1)),transformKey(b''.join(key2))\n        else:\n            return transformKey(bytes(key1)),transformKey(bytes(key2))",
  "def removeDESLayer(cryptedHash, rid):\n        Key1,Key2 = deriveKey(rid)\n\n        Crypt1 = DES.new(Key1, DES.MODE_ECB)\n        Crypt2 = DES.new(Key2, DES.MODE_ECB)\n\n        decryptedHash = Crypt1.decrypt(cryptedHash[:8]) + Crypt2.decrypt(cryptedHash[8:])\n\n        return decryptedHash",
  "def DecryptAttributeValue(dce, attribute):\n    sessionKey = dce.get_session_key()\n    # Is it a Kerberos Session Key?\n    if isinstance(sessionKey, crypto.Key):\n        # Extract its contents and move on\n        sessionKey = sessionKey.contents\n\n    encryptedPayload = ENCRYPTED_PAYLOAD(attribute)\n\n    md5 = hashlib.new('md5')\n    md5.update(sessionKey)\n    md5.update(encryptedPayload['Salt'])\n    finalMD5 = md5.digest()\n\n    cipher = ARC4.new(finalMD5)\n    plainText = cipher.decrypt(attribute[16:])\n\n    #chkSum = (binascii.crc32(plainText[4:])) & 0xffffffff\n    #if unpack('<L',plainText[:4])[0] != chkSum:\n    #    print \"RECEIVED 0x%x\" % unpack('<L',plainText[:4])[0]\n    #    print \"CALCULATED 0x%x\" % chkSum\n\n    return plainText[4:]",
  "def MakeAttid(prefixTable, oid):\n    # get the last value in the original OID: the value * after the last '.'\n    lastValue = int(oid.split('.')[-1])\n\n    # convert the dotted form of OID into a BER encoded binary * format.\n    # The BER encoding of OID is described in section * 8.19 of [ITUX690]\n    from pyasn1.type import univ\n    from pyasn1.codec.ber import encoder\n    binaryOID = encoder.encode(univ.ObjectIdentifier(oid))[2:]\n\n    # get the prefix of the OID\n    if lastValue < 128:\n        oidPrefix = list(binaryOID[:-1])\n    else:\n        oidPrefix = list(binaryOID[:-2])\n\n    # search the prefix in the prefix table, if none found, add\n    # one entry for the new prefix.\n    fToAdd = True\n    pos = len(prefixTable)\n    for j, item in enumerate(prefixTable):\n        if item['prefix']['elements'] == oidPrefix:\n            fToAdd = False\n            pos = j\n            break\n\n    if fToAdd is True:\n        entry = PrefixTableEntry()\n        entry['ndx'] = pos\n        entry['prefix']['length'] = len(oidPrefix)\n        entry['prefix']['elements'] = oidPrefix\n        prefixTable.append(entry)\n\n    # compose the attid\n    lowerWord = lastValue % 16384\n    if lastValue >= 16384:\n        # mark it so that it is known to not be the whole lastValue\n        lowerWord += 32768\n\n    upperWord = pos\n\n    attrTyp = ATTRTYP()\n    attrTyp['Data'] = (upperWord << 16) + lowerWord\n    return attrTyp",
  "def OidFromAttid(prefixTable, attr):\n    # separate the ATTRTYP into two parts\n    upperWord = attr // 65536\n    lowerWord = attr % 65536\n\n    # search in the prefix table to find the upperWord, if found,\n    # construct the binary OID by appending lowerWord to the end of\n    # found prefix.\n\n    binaryOID = None\n    for j, item in enumerate(prefixTable):\n        if item['ndx'] == upperWord:\n            binaryOID = item['prefix']['elements'][:item['prefix']['length']]\n            if lowerWord < 128:\n                binaryOID.append(pack('B',lowerWord))\n            else:\n                if lowerWord >= 32768:\n                    lowerWord -= 32768\n                binaryOID.append(pack('B',(((lowerWord//128) % 128)+128)))\n                binaryOID.append(pack('B',(lowerWord%128)))\n            break\n\n    if binaryOID is None:\n        return None\n    return str(decoder.decode(b'\\x06' + pack('B',(len(binaryOID))) + b''.join(binaryOID), asn1Spec = univ.ObjectIdentifier())[0])",
  "def __init__(self, error_string=None, error_code=None, packet=None):\n        DCERPCException.__init__(self, error_string, error_code, packet)",
  "def __str__( self ):\n        key = self.error_code\n        if key in hresult_errors.ERROR_MESSAGES:\n            error_msg_short = hresult_errors.ERROR_MESSAGES[key][0]\n            error_msg_verbose = hresult_errors.ERROR_MESSAGES[key][1]\n            return 'DRSR SessionError: code: 0x%x - %s - %s' % (self.error_code, error_msg_short, error_msg_verbose)\n        elif key & 0xffff in system_errors.ERROR_MESSAGES:\n            error_msg_short = system_errors.ERROR_MESSAGES[key & 0xffff][0]\n            error_msg_verbose = system_errors.ERROR_MESSAGES[key & 0xffff][1]\n            return 'DRSR SessionError: code: 0x%x - %s - %s' % (self.error_code, error_msg_short, error_msg_verbose)\n        else:\n            return 'DRSR SessionError: unknown error code: 0x%x' % self.error_code",
  "class enumItems(Enum):\n        EXOP_ERR_SUCCESS               = 0x00000001\n        EXOP_ERR_UNKNOWN_OP            = 0x00000002\n        EXOP_ERR_FSMO_NOT_OWNER        = 0x00000003\n        EXOP_ERR_UPDATE_ERR            = 0x00000004\n        EXOP_ERR_EXCEPTION             = 0x00000005\n        EXOP_ERR_UNKNOWN_CALLER        = 0x00000006\n        EXOP_ERR_RID_ALLOC             = 0x00000007\n        EXOP_ERR_FSMO_OWNER_DELETED    = 0x00000008\n        EXOP_ERR_FSMO_PENDING_OP       = 0x00000009\n        EXOP_ERR_MISMATCH              = 0x0000000A\n        EXOP_ERR_COULDNT_CONTACT       = 0x0000000B\n        EXOP_ERR_FSMO_REFUSING_ROLES   = 0x0000000C\n        EXOP_ERR_DIR_ERROR             = 0x0000000D\n        EXOP_ERR_FSMO_MISSING_SETTINGS = 0x0000000E\n        EXOP_ERR_ACCESS_DENIED         = 0x0000000F\n        EXOP_ERR_PARAM_ERROR           = 0x00000010",
  "def dump(self, msg = None, indent = 0):\n        if msg is None:\n            msg = self.__class__.__name__\n        if msg != '':\n            print(msg, end=' ')\n\n        try:\n            print(\" %s\" % self.enumItems(self.fields['Data']).name, end=' ')\n        except ValueError:\n            print(\" %d\" % self.fields['Data'])",
  "def getAlignment(self):\n        return 4",
  "def getAlignment(self):\n        return 4",
  "class enumItems(Enum):\n        DS_UNKNOWN_NAME            = 0\n        DS_FQDN_1779_NAME          = 1\n        DS_NT4_ACCOUNT_NAME        = 2\n        DS_DISPLAY_NAME            = 3\n        DS_UNIQUE_ID_NAME          = 6\n        DS_CANONICAL_NAME          = 7\n        DS_USER_PRINCIPAL_NAME     = 8\n        DS_CANONICAL_NAME_EX       = 9\n        DS_SERVICE_PRINCIPAL_NAME  = 10\n        DS_SID_OR_SID_HISTORY_NAME = 11\n        DS_DNS_DOMAIN_NAME         = 12",
  "def __setitem__(self, key, value):\n        self.fields['MaximumCount'] = None\n        self.data = None        # force recompute\n        return NDRUniConformantArray.__setitem__(self, key, [ord(c) for c in value])",
  "def __getitem__(self, key):\n        if key == 'Data':\n            try:\n                return ''.join([six.unichr(i) for i in self.fields[key]])\n            except ValueError as e:\n                LOG.debug(\"ValueError Exception\", exc_info=True)\n                LOG.error(str(e))\n        else:\n            return NDR.__getitem__(self,key)",
  "def getDataLen(self, data, offset=0):\n        return self['NameLen']",
  "def getData(self, soFar = 0):\n        return NDRSTRUCT.getData(self, soFar)",
  "def fromString(self, data, soFar = 0 ):\n        # Here we're changing the struct so we can represent a linked list with NDR\n        self.fields['pNextEntInf'] = PREPLENTINFLIST(isNDR64 = self._isNDR64)\n        retVal = NDRSTRUCT.fromString(self, data, soFar)\n        return retVal",
  "def fromString(self, data, soFar = 0):\n        retVal = NDRSTRUCT.fromString(self, data, soFar)\n        #self.dumpRaw()\n        return retVal",
  "def fromString(self, data, soFar=0):\n        retVal = NDRSTRUCT.fromString(self, data, soFar)\n        # self.dumpRaw()\n        return retVal",
  "class enumItems(Enum):\n        DRS_COMP_ALG_NONE   = 0\n        DRS_COMP_ALG_UNUSED = 1\n        DRS_COMP_ALG_MSZIP  = 2\n        DRS_COMP_ALG_WIN2K3 = 3",
  "class DCERPCSessionError(DCERPCException):\n    def __init__(self, error_string=None, error_code=None, packet=None):\n        DCERPCException.__init__(self, error_string, error_code, packet)\n\n    def __str__( self ):\n        if self.error_code in hresult_errors.ERROR_MESSAGES:\n            error_msg_short = hresult_errors.ERROR_MESSAGES[self.error_code][0]\n            error_msg_verbose = hresult_errors.ERROR_MESSAGES[self.error_code][1]\n            return 'DCOM SessionError: code: 0x%x - %s - %s' % (self.error_code, error_msg_short, error_msg_verbose)\n        else:\n            return 'DCOM SessionError: unknown error code: 0x%x' % self.error_code",
  "class OID_ARRAY(NDRUniConformantArray):\n    item = OID",
  "class POID_ARRAY(NDRPOINTER):\n    referent = (\n        ('Data', OID_ARRAY),\n    )",
  "class handle_t(NDRSTRUCT):\n    structure =  (\n        ('context_handle_attributes',ULONG),\n        ('context_handle_uuid',UUID),\n    )\n\n    def __init__(self, data=None, isNDR64=False):\n        NDRSTRUCT.__init__(self, data, isNDR64)\n        self['context_handle_uuid'] = b'\\x00'*16\n\n    def isNull(self):\n        return self['context_handle_uuid'] == b'\\x00'*16",
  "class COMVERSION(NDRSTRUCT):\n    default_major_version = 5\n    default_minor_version = 7\n\n    structure = (\n        ('MajorVersion',USHORT),\n        ('MinorVersion',USHORT),\n    )\n\n    @classmethod\n    def set_default_version(cls, major_version=None, minor_version=None):\n        # Set default dcom version for all new COMVERSION objects.\n        if major_version is not None:\n            cls.default_major_version = major_version\n        if minor_version is not None:\n            cls.default_minor_version = minor_version\n\n    def __init__(self, data = None,isNDR64 = False):\n        NDRSTRUCT.__init__(self, data, isNDR64)\n        if data is None:\n            self['MajorVersion'] = self.default_major_version\n            self['MinorVersion'] = self.default_minor_version",
  "class PCOMVERSION(NDRPOINTER):\n    referent = (\n        ('Data', COMVERSION),\n    )",
  "class BYTE_ARRAY(NDRUniConformantArray):\n    item = 'c'",
  "class ORPC_EXTENT(NDRSTRUCT):\n    structure = (\n        ('id',GUID),\n        ('size',ULONG),\n        ('data',BYTE_ARRAY),\n    )",
  "class PORPC_EXTENT(NDRPOINTER):\n    referent = (\n        ('Data', ORPC_EXTENT),\n    )",
  "class EXTENT_ARRAY(NDRUniConformantArray):\n    item = PORPC_EXTENT",
  "class PEXTENT_ARRAY(NDRPOINTER):\n    referent = (\n        ('Data', EXTENT_ARRAY),\n    )",
  "class ORPC_EXTENT_ARRAY(NDRSTRUCT):\n    structure = (\n        ('size',ULONG),\n        ('reserved',ULONG),\n        ('extent',PEXTENT_ARRAY),\n    )",
  "class PORPC_EXTENT_ARRAY(NDRPOINTER):\n    referent = (\n        ('Data', ORPC_EXTENT_ARRAY),\n    )",
  "class ORPCTHIS(NDRSTRUCT):\n    structure = (\n        ('version',COMVERSION),\n        ('flags',ULONG),\n        ('reserved1',ULONG),\n        ('cid',CID),\n        ('extensions',PORPC_EXTENT_ARRAY),\n    )",
  "class ORPCTHAT(NDRSTRUCT):\n    structure = (\n        ('flags',ULONG),\n        ('extensions',PORPC_EXTENT_ARRAY),\n    )",
  "class MInterfacePointer(NDRSTRUCT):\n    structure = (\n        ('ulCntData',ULONG),\n        ('abData',BYTE_ARRAY),\n    )",
  "class PMInterfacePointerInternal(NDRPOINTER):\n    referent = (\n        ('Data', MInterfacePointer),\n    )",
  "class PMInterfacePointer(NDRPOINTER):\n    referent = (\n        ('Data', MInterfacePointer),\n    )",
  "class PPMInterfacePointer(NDRPOINTER):\n    referent = (\n        ('Data', PMInterfacePointer),\n    )",
  "class OBJREF(NDRSTRUCT):\n    commonHdr = (\n        ('signature',ULONG),\n        ('flags',ULONG),\n        ('iid',GUID),\n    )\n    def __init__(self, data = None,isNDR64 = False):\n        NDRSTRUCT.__init__(self, data, isNDR64)\n        if data is None:\n            self['signature'] = 0x574F454D",
  "class STDOBJREF(NDRSTRUCT):\n    structure = (\n        ('flags',ULONG),\n        ('cPublicRefs',ULONG),\n        ('oxid',OXID),\n        ('oid',OID),\n        ('ipid',IPID),\n    )",
  "class OBJREF_STANDARD(OBJREF):\n    structure = (\n        ('std',STDOBJREF),\n        ('saResAddr',':'),\n    )\n    def __init__(self, data = None,isNDR64 = False):\n        OBJREF.__init__(self, data, isNDR64)\n        if data is None:\n            self['flags'] = FLAGS_OBJREF_STANDARD",
  "class OBJREF_HANDLER(OBJREF):\n    structure = (\n        ('std',STDOBJREF),\n        ('clsid',CLSID),\n        ('saResAddr',':'),\n    )\n    def __init__(self, data = None,isNDR64 = False):\n        OBJREF.__init__(self, data, isNDR64)\n        if data is None:\n            self['flags'] = FLAGS_OBJREF_HANDLER",
  "class OBJREF_CUSTOM(OBJREF):\n    structure = (\n        ('clsid',CLSID),\n        ('cbExtension',ULONG),\n        ('ObjectReferenceSize',ULONG),\n        ('pObjectData',':'),\n    )\n    def __init__(self, data = None,isNDR64 = False):\n        OBJREF.__init__(self, data, isNDR64)\n        if data is None:\n            self['flags'] = FLAGS_OBJREF_CUSTOM",
  "class DATAELEMENT(NDRSTRUCT):\n    structure = (\n        ('dataID',GUID),\n        ('cbSize',ULONG),\n        ('cbRounded',ULONG),\n        ('Data',':'),\n    )",
  "class DUALSTRINGARRAYPACKED(NDRSTRUCT):\n    structure = (\n        ('wNumEntries',USHORT),\n        ('wSecurityOffset',USHORT),\n        ('aStringArray',':'),\n    )\n    def getDataLen(self, data, offset=0):\n        return self['wNumEntries']*2",
  "class OBJREF_EXTENDED(OBJREF):\n    structure = (\n        ('std',STDOBJREF),\n        ('Signature1',ULONG),\n        ('saResAddr',DUALSTRINGARRAYPACKED),\n        ('nElms',ULONG),\n        ('Signature2',ULONG),\n        ('ElmArray',DATAELEMENT),\n    )\n    def __init__(self, data = None, isNDR64 = False):\n        OBJREF.__init__(self, data, isNDR64)\n        if data is None:\n            self['flags'] = FLAGS_OBJREF_EXTENDED\n            self['Signature1'] = 0x4E535956\n            self['Signature1'] = 0x4E535956\n            self['nElms'] = 0x4E535956",
  "class USHORT_ARRAY(NDRUniConformantArray):\n    item = '<H'",
  "class PUSHORT_ARRAY(NDRPOINTER):\n    referent = (\n        ('Data', USHORT_ARRAY),\n    )",
  "class DUALSTRINGARRAY(NDRSTRUCT):\n    structure = (\n        ('wNumEntries',USHORT),\n        ('wSecurityOffset',USHORT),\n        ('aStringArray',USHORT_ARRAY),\n    )",
  "class PDUALSTRINGARRAY(NDRPOINTER):\n    referent = (\n        ('Data',DUALSTRINGARRAY),\n    )",
  "class STRINGBINDING(NDRSTRUCT):\n    structure = (\n        ('wTowerId',USHORT),\n        ('aNetworkAddr',WIDESTR),\n    )",
  "class SECURITYBINDING(NDRSTRUCT):\n    structure = (\n        ('wAuthnSvc',USHORT),\n        ('Reserved',USHORT),\n        ('aPrincName',WIDESTR),\n    )",
  "class PROPMARSHALHEADER(NDRSTRUCT):\n    structure = (\n        ('clsid',CLSID),\n        ('policyId',GUID),\n        ('flags',ULONG),\n        ('cb',ULONG),\n        ('ctxProperty',':'),\n    )",
  "class PROPMARSHALHEADER_ARRAY(NDRUniConformantArray):\n    item = PROPMARSHALHEADER",
  "class Context(NDRSTRUCT):\n    structure = (\n        ('MajorVersion',USHORT),\n        ('MinVersion',USHORT),\n        ('ContextId',GUID),\n        ('Flags',ULONG),\n        ('Reserved',ULONG),\n        ('dwNumExtents',ULONG),\n        ('cbExtents',ULONG),\n        ('MshlFlags',ULONG),\n        ('Count',ULONG),\n        ('Frozen',ULONG),\n        ('PropMarshalHeader',PROPMARSHALHEADER_ARRAY),\n    )",
  "class ErrorInfoString(NDRSTRUCT):\n    structure = (\n        ('dwMax',ULONG),\n        ('dwOffSet',ULONG),\n        ('dwActual',IID),\n        ('Name',WSTR),\n    )",
  "class ORPC_ERROR_INFORMATION(NDRSTRUCT):\n    structure = (\n        ('dwVersion',ULONG),\n        ('dwHelpContext',ULONG),\n        ('iid',IID),\n        ('dwSourceSignature',ULONG),\n        ('Source',ErrorInfoString),\n        ('dwDescriptionSignature',ULONG),\n        ('Description',ErrorInfoString),\n        ('dwHelpFileSignature',ULONG),\n        ('HelpFile',ErrorInfoString),\n    )",
  "class EntryHeader(NDRSTRUCT):\n    structure = (\n        ('Signature',ULONG),\n        ('cbEHBuffer',ULONG),\n        ('cbSize',ULONG),\n        ('reserved',ULONG),\n        ('policyID',GUID),\n    )",
  "class EntryHeader_ARRAY(NDRUniConformantArray):\n    item = EntryHeader",
  "class ORPC_CONTEXT(NDRSTRUCT):\n    structure = (\n        ('SignatureVersion',ULONG),\n        ('Version',ULONG),\n        ('cPolicies',ULONG),\n        ('cbBuffer',ULONG),\n        ('cbSize',ULONG),\n        ('hr',ULONG),\n        ('hrServer',ULONG),\n        ('reserved',ULONG),\n        ('EntryHeader',EntryHeader_ARRAY),\n        ('PolicyData',':'),\n    )\n    def __init__(self, data = None, isNDR64 = False):\n        NDRSTRUCT.__init__(self, data, isNDR64)\n        if data is None:\n            self['SignatureVersion'] = 0x414E554B",
  "class CLSID_ARRAY(NDRUniConformantArray):\n    item = CLSID",
  "class PCLSID_ARRAY(NDRPOINTER):\n    referent = (\n        ('Data', CLSID_ARRAY),\n    )",
  "class DWORD_ARRAY(NDRUniConformantArray):\n    item = DWORD",
  "class PDWORD_ARRAY(NDRPOINTER):\n    referent = (\n        ('Data', DWORD_ARRAY),\n    )",
  "class CustomHeader(TypeSerialization1):\n    structure = (\n        ('totalSize',DWORD),\n        ('headerSize',DWORD),\n        ('dwReserved',DWORD),\n        ('destCtx',DWORD),\n        ('cIfs',DWORD),\n        ('classInfoClsid',CLSID),\n        ('pclsid',PCLSID_ARRAY),\n        ('pSizes',PDWORD_ARRAY),\n        ('pdwReserved',LPLONG),\n        #('pdwReserved',LONG),\n    )\n    def getData(self, soFar = 0):\n        self['headerSize'] = len(TypeSerialization1.getData(self, soFar)) + len(\n            TypeSerialization1.getDataReferents(self, soFar))\n        self['cIfs'] = len(self['pclsid'])\n        return TypeSerialization1.getData(self, soFar)",
  "class ACTIVATION_BLOB(NDRTLSTRUCT):\n    structure = (\n        ('dwSize',ULONG),\n        ('dwReserved',ULONG),\n        ('CustomHeader',CustomHeader),\n        ('Property',UNKNOWNDATA),\n    )\n    def getData(self, soFar = 0):\n        self['dwSize'] = len(self['CustomHeader'].getData(soFar)) + len(\n            self['CustomHeader'].getDataReferents(soFar)) + len(self['Property'])\n        self['CustomHeader']['totalSize'] = self['dwSize']\n        return NDRTLSTRUCT.getData(self)",
  "class IID_ARRAY(NDRUniConformantArray):\n    item = IID",
  "class PIID_ARRAY(NDRPOINTER):\n    referent = (\n        ('Data', IID_ARRAY),\n    )",
  "class InstantiationInfoData(TypeSerialization1):\n    structure = (\n        ('classId',CLSID),\n        ('classCtx',DWORD),\n        ('actvflags',DWORD),\n        ('fIsSurrogate',LONG),\n        ('cIID',DWORD),\n        ('instFlag',DWORD),\n        ('pIID',PIID_ARRAY),\n        ('thisSize',DWORD),\n        ('clientCOMVersion',COMVERSION),\n    )",
  "class SpecialPropertiesData(TypeSerialization1):\n    structure = (\n        ('dwSessionId',ULONG),\n        ('fRemoteThisSessionId',LONG),\n        ('fClientImpersonating',LONG),\n        ('fPartitionIDPresent',LONG),\n        ('dwDefaultAuthnLvl',DWORD),\n        ('guidPartition',GUID),\n        ('dwPRTFlags',DWORD),\n        ('dwOrigClsctx',DWORD),\n        ('dwFlags',DWORD),\n        ('Reserved0',DWORD),\n        ('Reserved0',DWORD),\n        ('Reserved', '32s=\"\"'),\n        #('Reserved1',DWORD),\n        #('Reserved2',ULONGLONG),\n        #('Reserved3_1',DWORD),\n        #('Reserved3_2',DWORD),\n        #('Reserved3_3',DWORD),\n        #('Reserved3_4',DWORD),\n        #('Reserved3_5',DWORD),\n    )",
  "class InstanceInfoData(TypeSerialization1):\n    structure = (\n        ('fileName',LPWSTR),\n        ('mode',DWORD),\n        ('ifdROT',PMInterfacePointer),\n        ('ifdStg',PMInterfacePointer),\n    )",
  "class customREMOTE_REQUEST_SCM_INFO(NDRSTRUCT):\n    structure = (\n        ('ClientImpLevel',DWORD),\n        ('cRequestedProtseqs',USHORT),\n        ('pRequestedProtseqs',PUSHORT_ARRAY),\n    )",
  "class PcustomREMOTE_REQUEST_SCM_INFO(NDRPOINTER):\n    referent = (\n        ('Data', customREMOTE_REQUEST_SCM_INFO),\n    )",
  "class ScmRequestInfoData(TypeSerialization1):\n    structure = (\n        ('pdwReserved',LPLONG),\n        ('remoteRequest',PcustomREMOTE_REQUEST_SCM_INFO),\n    )",
  "class ActivationContextInfoData(TypeSerialization1):\n    structure = (\n        ('clientOK',LONG),\n        ('bReserved1',LONG),\n        ('dwReserved1',DWORD),\n        ('dwReserved2',DWORD),\n        ('pIFDClientCtx',PMInterfacePointer),\n        ('pIFDPrototypeCtx',PMInterfacePointer),\n    )",
  "class LocationInfoData(TypeSerialization1):\n    structure = (\n        ('machineName',LPWSTR),\n        ('processId',DWORD),\n        ('apartmentId',DWORD),\n        ('contextId',DWORD),\n    )",
  "class COSERVERINFO(NDRSTRUCT):\n    structure = (\n        ('dwReserved1',DWORD),\n        ('pwszName',LPWSTR),\n        ('pdwReserved',LPLONG),\n        ('dwReserved2',DWORD),\n    )",
  "class PCOSERVERINFO(NDRPOINTER):\n    referent = (\n        ('Data', COSERVERINFO),\n    )",
  "class SecurityInfoData(TypeSerialization1):\n    structure = (\n        ('dwAuthnFlags',DWORD),\n        ('pServerInfo',PCOSERVERINFO),\n        ('pdwReserved',LPLONG),\n    )",
  "class customREMOTE_REPLY_SCM_INFO(NDRSTRUCT):\n    structure = (\n        ('Oxid',OXID),\n        ('pdsaOxidBindings',PDUALSTRINGARRAY),\n        ('ipidRemUnknown',IPID),\n        ('authnHint',DWORD),\n        ('serverVersion',COMVERSION),\n    )",
  "class PcustomREMOTE_REPLY_SCM_INFO(NDRPOINTER):\n    referent = (\n        ('Data', customREMOTE_REPLY_SCM_INFO),\n    )",
  "class ScmReplyInfoData(TypeSerialization1):\n    structure = (\n        ('pdwReserved',DWORD),\n        ('remoteReply',PcustomREMOTE_REPLY_SCM_INFO),\n    )",
  "class HRESULT_ARRAY(NDRUniConformantArray):\n    item = HRESULT",
  "class PHRESULT_ARRAY(NDRPOINTER):\n    referent = (\n        ('Data', HRESULT_ARRAY),\n    )",
  "class MInterfacePointer_ARRAY(NDRUniConformantArray):\n    item = MInterfacePointer",
  "class PMInterfacePointer_ARRAY(NDRUniConformantArray):\n    item = PMInterfacePointer",
  "class PPMInterfacePointer_ARRAY(NDRPOINTER):\n    referent = (\n        ('Data', PMInterfacePointer_ARRAY),\n    )",
  "class PropsOutInfo(TypeSerialization1):\n    structure = (\n        ('cIfs',DWORD),\n        ('piid',PIID_ARRAY),\n        ('phresults',PHRESULT_ARRAY),\n        ('ppIntfData',PPMInterfacePointer_ARRAY),\n    )",
  "class REMINTERFACEREF(NDRSTRUCT):\n    structure = (\n        ('ipid',IPID),\n        ('cPublicRefs',LONG),\n        ('cPrivateRefs',LONG),\n    )",
  "class REMINTERFACEREF_ARRAY(NDRUniConformantArray):\n    item = REMINTERFACEREF",
  "class REMQIRESULT(NDRSTRUCT):\n    structure = (\n        ('hResult',HRESULT),\n        ('std',STDOBJREF),\n    )",
  "class PREMQIRESULT(NDRPOINTER):\n    referent = (\n        ('Data', REMQIRESULT),\n    )",
  "class DCOMCALL(NDRCALL):\n    commonHdr = (\n       ('ORPCthis', ORPCTHIS),\n    )",
  "class DCOMANSWER(NDRCALL):\n    commonHdr = (\n       ('ORPCthat', ORPCTHAT),\n    )",
  "class ResolveOxid(NDRCALL):\n    opnum = 0\n    structure = (\n       ('pOxid', OXID),\n       ('cRequestedProtseqs', USHORT),\n       ('arRequestedProtseqs', USHORT_ARRAY),\n    )",
  "class ResolveOxidResponse(NDRCALL):\n    structure = (\n       ('ppdsaOxidBindings', PDUALSTRINGARRAY),\n       ('pipidRemUnknown', IPID),\n       ('pAuthnHint', DWORD),\n       ('ErrorCode', error_status_t),\n    )",
  "class SimplePing(NDRCALL):\n    opnum = 1\n    structure = (\n       ('pSetId', SETID),\n    )",
  "class SimplePingResponse(NDRCALL):\n    structure = (\n       ('ErrorCode', error_status_t),\n    )",
  "class ComplexPing(NDRCALL):\n    opnum = 2\n    structure = (\n       ('pSetId', SETID),\n       ('SequenceNum', USHORT),\n       ('cAddToSet', USHORT),\n       ('cDelFromSet', USHORT),\n       ('AddToSet', POID_ARRAY),\n       ('DelFromSet', POID_ARRAY),\n    )",
  "class ComplexPingResponse(NDRCALL):\n    structure = (\n       ('pSetId', SETID),\n       ('pPingBackoffFactor', USHORT),\n       ('ErrorCode', error_status_t),\n    )",
  "class ServerAlive(NDRCALL):\n    opnum = 3\n    structure = (\n    )",
  "class ServerAliveResponse(NDRCALL):\n    structure = (\n       ('ErrorCode', error_status_t),\n    )",
  "class ResolveOxid2(NDRCALL):\n    opnum = 4\n    structure = (\n       ('pOxid', OXID),\n       ('cRequestedProtseqs', USHORT),\n       ('arRequestedProtseqs', USHORT_ARRAY),\n    )",
  "class ResolveOxid2Response(NDRCALL):\n    structure = (\n       ('ppdsaOxidBindings', PDUALSTRINGARRAY),\n       ('pipidRemUnknown', IPID),\n       ('pAuthnHint', DWORD),\n       ('pComVersion', COMVERSION),\n       ('ErrorCode', error_status_t),\n    )",
  "class ServerAlive2(NDRCALL):\n    opnum = 5\n    structure = (\n    )",
  "class ServerAlive2Response(NDRCALL):\n    structure = (\n       ('pComVersion', COMVERSION),\n       ('ppdsaOrBindings', PDUALSTRINGARRAY),\n       ('pReserved', LPLONG),\n       ('ErrorCode', error_status_t),\n    )",
  "class RemoteActivation(NDRCALL):\n    opnum = 0\n    structure = (\n       ('ORPCthis', ORPCTHIS),\n       ('Clsid', GUID),\n       ('pwszObjectName', LPWSTR),\n       ('pObjectStorage', PMInterfacePointer),\n       ('ClientImpLevel', DWORD),\n       ('Mode', DWORD),\n       ('Interfaces', DWORD),\n       ('pIIDs', PIID_ARRAY),\n       ('cRequestedProtseqs', USHORT),\n       ('aRequestedProtseqs', USHORT_ARRAY),\n    )",
  "class RemoteActivationResponse(NDRCALL):\n    structure = (\n       ('ORPCthat', ORPCTHAT),\n       ('pOxid', OXID),\n       ('ppdsaOxidBindings', PDUALSTRINGARRAY),\n       ('pipidRemUnknown', IPID),\n       ('pAuthnHint', DWORD),\n       ('pServerVersion', COMVERSION),\n       ('phr', HRESULT),\n       ('ppInterfaceData', PMInterfacePointer_ARRAY),\n       ('pResults', HRESULT_ARRAY),\n       ('ErrorCode', error_status_t),\n    )",
  "class RemoteGetClassObject(NDRCALL):\n    opnum = 3\n    structure = (\n       ('ORPCthis', ORPCTHIS),\n       ('pActProperties', PMInterfacePointer),\n    )",
  "class RemoteGetClassObjectResponse(NDRCALL):\n    structure = (\n       ('ORPCthat', ORPCTHAT),\n       ('ppActProperties', PMInterfacePointer),\n       ('ErrorCode', error_status_t),\n    )",
  "class RemoteCreateInstance(NDRCALL):\n    opnum = 4\n    structure = (\n       ('ORPCthis', ORPCTHIS),\n       ('pUnkOuter', PMInterfacePointer),\n       ('pActProperties', PMInterfacePointer),\n    )",
  "class RemoteCreateInstanceResponse(NDRCALL):\n    structure = (\n       ('ORPCthat', ORPCTHAT),\n       ('ppActProperties', PMInterfacePointer),\n       ('ErrorCode', error_status_t),\n    )",
  "class RemQueryInterface(DCOMCALL):\n    opnum = 3\n    structure = (\n       ('ripid', REFIPID),\n       ('cRefs', ULONG),\n       ('cIids', USHORT),\n       ('iids', IID_ARRAY),\n    )",
  "class RemQueryInterfaceResponse(DCOMANSWER):\n    structure = (\n       ('ppQIResults', PREMQIRESULT),\n       ('ErrorCode', error_status_t),\n    )",
  "class RemAddRef(DCOMCALL):\n    opnum = 4\n    structure = (\n       ('cInterfaceRefs', USHORT),\n       ('InterfaceRefs', REMINTERFACEREF_ARRAY),\n    )",
  "class RemAddRefResponse(DCOMANSWER):\n    structure = (\n       ('pResults', DWORD_ARRAY),\n       ('ErrorCode', error_status_t),\n    )",
  "class RemRelease(DCOMCALL):\n    opnum = 5\n    structure = (\n       ('cInterfaceRefs', USHORT),\n       ('InterfaceRefs', REMINTERFACEREF_ARRAY),\n    )",
  "class RemReleaseResponse(DCOMANSWER):\n    structure = (\n       ('ErrorCode', error_status_t),\n    )",
  "class DCOMConnection:\n    \"\"\"\n    This class represents a DCOM Connection. It is in charge of establishing the \n    DCE connection against the portmap, and then launch a thread that will be \n    pinging the objects created against the target.\n    In theory, there should be a single instance of this class for every target\n    \"\"\"\n    PINGTIMER = None\n    OID_ADD = {}\n    OID_DEL = {}\n    OID_SET = {}\n    PORTMAPS = {}\n\n    def __init__(self, target, username='', password='', domain='', lmhash='', nthash='', aesKey='', TGT=None, TGS=None,\n                 authLevel=RPC_C_AUTHN_LEVEL_PKT_PRIVACY, oxidResolver=False, doKerberos=False, kdcHost=None):\n        self.__target = target\n        self.__userName = username\n        self.__password = password\n        self.__domain = domain\n        self.__lmhash = lmhash\n        self.__nthash = nthash\n        self.__aesKey = aesKey\n        self.__TGT    = TGT\n        self.__TGS    = TGS\n        self.__authLevel = authLevel\n        self.__portmap = None\n        self.__oxidResolver = oxidResolver\n        self.__doKerberos = doKerberos\n        self.__kdcHost = kdcHost\n        self.initConnection()\n\n    @classmethod\n    def addOid(cls, target, oid):\n        if (target in DCOMConnection.OID_ADD) is False:\n            DCOMConnection.OID_ADD[target] = set()\n        DCOMConnection.OID_ADD[target].add(oid)\n        if (target in DCOMConnection.OID_SET) is False:\n            DCOMConnection.OID_SET[target] = {}\n            DCOMConnection.OID_SET[target]['oids'] = set()\n            DCOMConnection.OID_SET[target]['setid'] = 0\n\n    @classmethod\n    def delOid(cls, target, oid):\n        if (target in DCOMConnection.OID_DEL) is False:\n            DCOMConnection.OID_DEL[target] = set()\n        DCOMConnection.OID_DEL[target].add(oid)\n        if (target in DCOMConnection.OID_SET) is False:\n            DCOMConnection.OID_SET[target] = {}\n            DCOMConnection.OID_SET[target]['oids'] = set()\n            DCOMConnection.OID_SET[target]['setid'] = 0\n\n    @classmethod\n    def pingServer(cls):\n        # Here we need to go through all the objects opened and ping them.\n        # ToDo: locking for avoiding race conditions\n        #print DCOMConnection.PORTMAPS\n        #print DCOMConnection.OID_SET\n        try:\n            for target in DCOMConnection.OID_SET:\n                addedOids = set()\n                deletedOids = set()\n                if target in DCOMConnection.OID_ADD:\n                    addedOids = DCOMConnection.OID_ADD[target]\n                    del(DCOMConnection.OID_ADD[target])\n\n                if target in DCOMConnection.OID_DEL:\n                    deletedOids = DCOMConnection.OID_DEL[target]\n                    del(DCOMConnection.OID_DEL[target])\n\n                objExporter = IObjectExporter(DCOMConnection.PORTMAPS[target])\n\n                if len(addedOids) > 0 or len(deletedOids) > 0:\n                    if 'setid' in DCOMConnection.OID_SET[target]:\n                        setId = DCOMConnection.OID_SET[target]['setid']\n                    else:\n                        setId = 0\n                    resp = objExporter.ComplexPing(setId, 0, addedOids, deletedOids)\n                    DCOMConnection.OID_SET[target]['oids'] -= deletedOids\n                    DCOMConnection.OID_SET[target]['oids'] |= addedOids\n                    DCOMConnection.OID_SET[target]['setid'] = resp['pSetId']\n                else:\n                    objExporter.SimplePing(DCOMConnection.OID_SET[target]['setid'])\n        except Exception as e:\n            # There might be exceptions when sending packets \n            # We should try to continue tho.\n            LOG.error(str(e))\n            pass\n\n        DCOMConnection.PINGTIMER = Timer(120,DCOMConnection.pingServer)\n        try:\n            DCOMConnection.PINGTIMER.start()\n        except Exception as e:\n            if str(e).find('threads can only be started once') < 0:\n                raise e\n\n    def initTimer(self):\n        if self.__oxidResolver is True:\n            if DCOMConnection.PINGTIMER is None:\n                DCOMConnection.PINGTIMER = Timer(120, DCOMConnection.pingServer)\n            try:\n                DCOMConnection.PINGTIMER.start()\n            except Exception as e:\n                if str(e).find('threads can only be started once') < 0:\n                    raise e\n\n    def initConnection(self):\n        stringBinding = r'ncacn_ip_tcp:%s' % self.__target\n        rpctransport = transport.DCERPCTransportFactory(stringBinding)\n\n        if hasattr(rpctransport, 'set_credentials') and len(self.__userName) >=0:\n            # This method exists only for selected protocol sequences.\n            rpctransport.set_credentials(self.__userName, self.__password, self.__domain, self.__lmhash, self.__nthash,\n                                         self.__aesKey, self.__TGT, self.__TGS)\n            rpctransport.set_kerberos(self.__doKerberos, self.__kdcHost)\n        self.__portmap = rpctransport.get_dce_rpc()\n        self.__portmap.set_auth_level(self.__authLevel)\n        if self.__doKerberos is True:\n            self.__portmap.set_auth_type(RPC_C_AUTHN_GSS_NEGOTIATE)\n        self.__portmap.connect()\n        DCOMConnection.PORTMAPS[self.__target] = self.__portmap\n\n    def CoCreateInstanceEx(self, clsid, iid):\n        scm = IRemoteSCMActivator(self.__portmap)\n        iInterface = scm.RemoteCreateInstance(clsid, iid)\n        self.initTimer()\n        return iInterface\n\n    def get_dce_rpc(self):\n        return DCOMConnection.PORTMAPS[self.__target]\n\n    def disconnect(self):\n        if DCOMConnection.PINGTIMER is not None:\n            del(DCOMConnection.PORTMAPS[self.__target])\n            del(DCOMConnection.OID_SET[self.__target])\n            if len(DCOMConnection.PORTMAPS) == 0:\n                # This means there are no more clients using this object, kill it\n                DCOMConnection.PINGTIMER.cancel()\n                DCOMConnection.PINGTIMER.join()\n                DCOMConnection.PINGTIMER = None\n        if self.__target in INTERFACE.CONNECTIONS:\n            del(INTERFACE.CONNECTIONS[self.__target][current_thread().name])\n        self.__portmap.disconnect()",
  "class CLASS_INSTANCE:\n    def __init__(self, ORPCthis, stringBinding):\n        self.__stringBindings = stringBinding\n        self.__ORPCthis = ORPCthis\n        self.__authType = RPC_C_AUTHN_WINNT\n        self.__authLevel = RPC_C_AUTHN_LEVEL_PKT_PRIVACY\n    def get_ORPCthis(self):\n        return self.__ORPCthis\n    def get_string_bindings(self):\n        return self.__stringBindings\n    def get_auth_level(self):\n        if RPC_C_AUTHN_LEVEL_NONE < self.__authLevel < RPC_C_AUTHN_LEVEL_PKT_PRIVACY:\n            if self.__authType == RPC_C_AUTHN_WINNT:\n                return RPC_C_AUTHN_LEVEL_PKT_INTEGRITY\n            else:\n                return RPC_C_AUTHN_LEVEL_PKT_PRIVACY\n        return self.__authLevel\n    def set_auth_level(self, level):\n        self.__authLevel = level\n    def get_auth_type(self):\n        return self.__authType\n    def set_auth_type(self, authType):\n        self.__authType = authType",
  "class INTERFACE:\n    # class variable holding the transport connections, organized by target IP\n    CONNECTIONS = {}\n\n    def __init__(self, cinstance=None, objRef=None, ipidRemUnknown=None, iPid=None, oxid=None, oid=None, target=None,\n                 interfaceInstance=None):\n        if interfaceInstance is not None:\n            self.__target = interfaceInstance.get_target()\n            self.__iPid = interfaceInstance.get_iPid()\n            self.__oid  = interfaceInstance.get_oid()\n            self.__oxid = interfaceInstance.get_oxid()\n            self.__cinstance = interfaceInstance.get_cinstance()\n            self.__objRef = interfaceInstance.get_objRef()\n            self.__ipidRemUnknown = interfaceInstance.get_ipidRemUnknown()\n        else:\n            if target is None:\n                raise Exception('No target')\n            self.__target = target\n            self.__iPid = iPid\n            self.__oid  = oid\n            self.__oxid = oxid\n            self.__cinstance = cinstance\n            self.__objRef = objRef\n            self.__ipidRemUnknown = ipidRemUnknown\n            # We gotta check if we have a container inside our connection list, if not, create\n            if (self.__target in INTERFACE.CONNECTIONS) is not True:\n                INTERFACE.CONNECTIONS[self.__target] = {}\n                INTERFACE.CONNECTIONS[self.__target][current_thread().name] = {}\n\n            if objRef is not None:\n                self.process_interface(objRef)\n\n    def process_interface(self, data):\n        objRefType = OBJREF(data)['flags']\n        objRef = None\n        if objRefType == FLAGS_OBJREF_CUSTOM:\n            objRef = OBJREF_CUSTOM(data)\n        elif objRefType == FLAGS_OBJREF_HANDLER:\n            objRef = OBJREF_HANDLER(data)\n        elif objRefType == FLAGS_OBJREF_STANDARD:\n            objRef = OBJREF_STANDARD(data)\n        elif objRefType == FLAGS_OBJREF_EXTENDED:\n            objRef = OBJREF_EXTENDED(data)\n        else:\n            LOG.error(\"Unknown OBJREF Type! 0x%x\" % objRefType)\n\n        if objRefType != FLAGS_OBJREF_CUSTOM:\n            if objRef['std']['flags'] & SORF_NOPING == 0:\n                DCOMConnection.addOid(self.__target, objRef['std']['oid'])\n            self.__iPid = objRef['std']['ipid']\n            self.__oid  = objRef['std']['oid']\n            self.__oxid = objRef['std']['oxid']\n            if self.__oxid is None:\n                objRef.dump()\n                raise Exception('OXID is None')\n\n    def get_oxid(self):\n        return self.__oxid\n\n    def set_oxid(self, oxid):\n        self.__oxid = oxid\n\n    def get_oid(self):\n        return self.__oid\n\n    def set_oid(self, oid):\n        self.__oid = oid\n\n    def get_target(self):\n        return self.__target\n\n    def get_iPid(self):\n        return self.__iPid\n\n    def set_iPid(self, iPid):\n        self.__iPid = iPid\n\n    def get_objRef(self):\n        return self.__objRef\n\n    def set_objRef(self, objRef):\n        self.__objRef = objRef\n\n    def get_ipidRemUnknown(self):\n        return self.__ipidRemUnknown\n\n    def get_dce_rpc(self):\n        return INTERFACE.CONNECTIONS[self.__target][current_thread().name][self.__oxid]['dce']\n\n    def get_cinstance(self):\n        return self.__cinstance\n\n    def set_cinstance(self, cinstance):\n        self.__cinstance = cinstance\n\n    def is_fqdn(self):\n        # I will assume the following\n        # If I can't socket.inet_aton() then it's not an IPv4 address\n        # Same for ipv6, but since socket.inet_pton is not available in Windows, I'll look for ':'. There can't be\n        # an FQDN with ':'\n        # Is it isn't both, then it is a FQDN\n        try:\n            socket.inet_aton(self.__target)\n        except:\n            # Not an IPv4\n            try:\n                self.__target.index(':')\n            except:\n                # Not an IPv6, it's a FQDN\n                return True\n        return False\n\n    def connect(self, iid = None):\n        if (self.__target in INTERFACE.CONNECTIONS) is True:\n            if current_thread().name in INTERFACE.CONNECTIONS[self.__target] and \\\n                            (self.__oxid in INTERFACE.CONNECTIONS[self.__target][current_thread().name]) is True:\n                dce = INTERFACE.CONNECTIONS[self.__target][current_thread().name][self.__oxid]['dce']\n                currentBinding = INTERFACE.CONNECTIONS[self.__target][current_thread().name][self.__oxid]['currentBinding']\n                if currentBinding == iid:\n                    # We don't need to alter_ctx\n                    pass\n                else:\n                    newDce = dce.alter_ctx(iid)\n                    INTERFACE.CONNECTIONS[self.__target][current_thread().name][self.__oxid]['dce'] = newDce\n                    INTERFACE.CONNECTIONS[self.__target][current_thread().name][self.__oxid]['currentBinding'] = iid\n            else:\n                stringBindings = self.get_cinstance().get_string_bindings()\n                # No OXID present, we should create a new connection and store it\n                stringBinding = None\n                isTargetFQDN = self.is_fqdn()\n                LOG.debug('Target system is %s and isFQDN is %s' % (self.get_target(), isTargetFQDN))\n                for strBinding in stringBindings:\n                    # Here, depending on the get_target() value several things can happen\n                    # 1) it's an IPv4 address\n                    # 2) it's an IPv6 address\n                    # 3) it's a NetBios Name\n                    # we should handle all this cases accordingly\n                    # Does this match exactly what get_target() returns?\n                    LOG.debug('StringBinding: %s' % strBinding['aNetworkAddr'])\n                    if strBinding['wTowerId'] == 7:\n                        # If there's port information, let's strip it for now.\n                        if strBinding['aNetworkAddr'].find('[') >= 0:\n                            binding, _, bindingPort = strBinding['aNetworkAddr'].partition('[')\n                            bindingPort = '[' + bindingPort\n                        else:\n                            binding = strBinding['aNetworkAddr']\n                            bindingPort = ''\n\n                        if binding.upper().find(self.get_target().upper()) >= 0:\n                            stringBinding = 'ncacn_ip_tcp:' + strBinding['aNetworkAddr'][:-1]\n                            break\n                        # If get_target() is a FQDN, does it match the hostname?\n                        elif isTargetFQDN and binding.upper().find(self.get_target().upper().partition('.')[0]) >= 0:\n                            # Here we replace the aNetworkAddr with self.get_target()\n                            # This is to help resolving the target system name.\n                            # self.get_target() has been resolved already otherwise we wouldn't be here whereas\n                            # aNetworkAddr is usually the NetBIOS name and unless you have your DNS resolver\n                            # with the right suffixes it will probably not resolve right.\n                            stringBinding = 'ncacn_ip_tcp:%s%s' % (self.get_target(), bindingPort)\n                            break\n\n                LOG.debug('StringBinding chosen: %s' % stringBinding)\n                if stringBinding is None:\n                    # Something wen't wrong, let's just report it\n                    raise Exception('Can\\'t find a valid stringBinding to connect')\n\n                dcomInterface = transport.DCERPCTransportFactory(stringBinding)\n                if hasattr(dcomInterface, 'set_credentials'):\n                    # This method exists only for selected protocol sequences.\n                    dcomInterface.set_credentials(*DCOMConnection.PORTMAPS[self.__target].get_credentials())\n                    dcomInterface.set_kerberos(DCOMConnection.PORTMAPS[self.__target].get_rpc_transport().get_kerberos(),\n                                               DCOMConnection.PORTMAPS[self.__target].get_rpc_transport().get_kdcHost())\n                dcomInterface.set_connect_timeout(300)\n                dce = dcomInterface.get_dce_rpc()\n\n                if iid is None:\n                    raise Exception('IID is None')\n                else:\n                    dce.set_auth_level(self.__cinstance.get_auth_level())\n                    dce.set_auth_type(self.__cinstance.get_auth_type())\n\n                dce.connect()\n\n                if iid is None:\n                    raise Exception('IID is None')\n                else:\n                    dce.bind(iid)\n\n                if self.__oxid is None:\n                    #import traceback\n                    #traceback.print_stack()\n                    raise Exception(\"OXID NONE, something wrong!!!\")\n\n                INTERFACE.CONNECTIONS[self.__target][current_thread().name] = {}\n                INTERFACE.CONNECTIONS[self.__target][current_thread().name][self.__oxid] = {}\n                INTERFACE.CONNECTIONS[self.__target][current_thread().name][self.__oxid]['dce'] = dce\n                INTERFACE.CONNECTIONS[self.__target][current_thread().name][self.__oxid]['currentBinding'] = iid\n        else:\n            # No connection created\n            raise Exception('No connection created')\n\n    def request(self, req, iid = None, uuid = None):\n        req['ORPCthis'] = self.get_cinstance().get_ORPCthis()\n        req['ORPCthis']['flags'] = 0\n        self.connect(iid)\n        dce = self.get_dce_rpc()\n        try:\n            resp = dce.request(req, uuid)\n        except Exception as e:\n            if str(e).find('RPC_E_DISCONNECTED') >= 0:\n                msg = str(e) + '\\n'\n                msg += \"DCOM keep-alive pinging it might not be working as expected. You can't be idle for more than 14 minutes!\\n\"\n                msg += \"You should exit the app and start again\\n\"\n                raise DCERPCException(msg)\n            else:\n                raise\n        return resp\n\n    def disconnect(self):\n        return INTERFACE.CONNECTIONS[self.__target][current_thread().name][self.__oxid]['dce'].disconnect()",
  "class IRemUnknown(INTERFACE):\n    def __init__(self, interface):\n        self._iid = IID_IRemUnknown\n        #INTERFACE.__init__(self, interface.get_cinstance(), interface.get_objRef(), interface.get_ipidRemUnknown(),\n        #                   interface.get_iPid(), target=interface.get_target())\n        INTERFACE.__init__(self, interfaceInstance=interface)\n        self.set_oxid(interface.get_oxid())\n\n    def RemQueryInterface(self, cRefs, iids):\n        # For now, it only supports a single IID\n        request = RemQueryInterface()\n        request['ORPCthis'] = self.get_cinstance().get_ORPCthis()\n        request['ORPCthis']['flags'] = 0\n        request['ripid'] = self.get_iPid()\n        request['cRefs'] = cRefs\n        request['cIids'] = len(iids)\n        for iid in iids:\n            _iid = IID()\n            _iid['Data'] = iid\n            request['iids'].append(_iid)\n        resp = self.request(request, IID_IRemUnknown, self.get_ipidRemUnknown())\n        #resp.dump()\n\n        return IRemUnknown2(\n            INTERFACE(self.get_cinstance(), None, self.get_ipidRemUnknown(), resp['ppQIResults']['std']['ipid'],\n                      oxid=resp['ppQIResults']['std']['oxid'], oid=resp['ppQIResults']['std']['oxid'],\n                      target=self.get_target()))\n\n    def RemAddRef(self):\n        request = RemAddRef()\n        request['ORPCthis'] = self.get_cinstance().get_ORPCthis()\n        request['ORPCthis']['flags'] = 0\n        request['cInterfaceRefs'] = 1\n        element = REMINTERFACEREF()\n        element['ipid'] = self.get_iPid()\n        element['cPublicRefs'] = 1\n        request['InterfaceRefs'].append(element)\n        resp = self.request(request, IID_IRemUnknown, self.get_ipidRemUnknown())\n        return resp\n\n    def RemRelease(self):\n        request = RemRelease()\n        request['ORPCthis'] = self.get_cinstance().get_ORPCthis()\n        request['ORPCthis']['flags'] = 0\n        request['cInterfaceRefs'] = 1\n        element = REMINTERFACEREF()\n        element['ipid'] = self.get_iPid()\n        element['cPublicRefs'] = 1\n        request['InterfaceRefs'].append(element)\n        resp = self.request(request, IID_IRemUnknown, self.get_ipidRemUnknown())\n        DCOMConnection.delOid(self.get_target(), self.get_oid())\n        return resp",
  "class IRemUnknown2(IRemUnknown):\n    def __init__(self, interface):\n        IRemUnknown.__init__(self, interface)\n        self._iid = IID_IRemUnknown2",
  "class IObjectExporter:\n    def __init__(self, dce):\n        self.__portmap = dce\n\n    # 3.1.2.5.1.1 IObjectExporter::ResolveOxid (Opnum 0)\n    def ResolveOxid(self, pOxid, arRequestedProtseqs):\n        self.__portmap.connect()\n        self.__portmap.bind(IID_IObjectExporter)\n        request = ResolveOxid()\n        request['pOxid'] = pOxid\n        request['cRequestedProtseqs'] = len(arRequestedProtseqs)\n        for protSeq in arRequestedProtseqs:\n            request['arRequestedProtseqs'].append(protSeq)\n        resp = self.__portmap.request(request)\n        Oxids = b''.join(pack('<H', x) for x in resp['ppdsaOxidBindings']['aStringArray'])\n        strBindings = Oxids[:resp['ppdsaOxidBindings']['wSecurityOffset']*2]\n\n        done = False\n        stringBindings = list()\n        while not done:\n            if strBindings[0:1] == b'\\x00' and strBindings[1:2] == b'\\x00':\n                done = True\n            else:\n                binding = STRINGBINDING(strBindings)\n                stringBindings.append(binding)\n                strBindings = strBindings[len(binding):]\n\n        return stringBindings\n\n    # 3.1.2.5.1.2 IObjectExporter::SimplePing (Opnum 1)\n    def SimplePing(self, setId):\n        self.__portmap.connect()\n        self.__portmap.bind(IID_IObjectExporter)\n        request = SimplePing()\n        request['pSetId'] = setId\n        resp = self.__portmap.request(request)\n        return resp\n\n    # 3.1.2.5.1.3 IObjectExporter::ComplexPing (Opnum 2)\n    def ComplexPing(self, setId = 0, sequenceNum = 0, addToSet = [], delFromSet = []):\n        self.__portmap.connect()\n        #self.__portmap.set_auth_level(RPC_C_AUTHN_LEVEL_PKT_INTEGRITY)\n        self.__portmap.bind(IID_IObjectExporter)\n        request = ComplexPing()\n        request['pSetId'] = setId\n        request['SequenceNum'] = setId\n        request['cAddToSet'] = len(addToSet)\n        request['cDelFromSet'] = len(delFromSet)\n        if len(addToSet) > 0:\n            for oid in addToSet:\n                oidn = OID()\n                oidn['Data'] = oid\n                request['AddToSet'].append(oidn)\n        else:\n            request['AddToSet'] = NULL\n\n        if len(delFromSet) > 0:\n            for oid in delFromSet:\n                oidn = OID()\n                oidn['Data'] = oid\n                request['DelFromSet'].append(oidn)\n        else:\n            request['DelFromSet'] = NULL\n        resp = self.__portmap.request(request)\n        return resp\n\n    # 3.1.2.5.1.4 IObjectExporter::ServerAlive (Opnum 3)\n    def ServerAlive(self):\n        self.__portmap.connect()\n        self.__portmap.bind(IID_IObjectExporter)\n        request = ServerAlive()\n        resp = self.__portmap.request(request)\n        return resp\n\n    # 3.1.2.5.1.5 IObjectExporter::ResolveOxid2 (Opnum 4)\n    def ResolveOxid2(self,pOxid, arRequestedProtseqs):\n        self.__portmap.connect()\n        self.__portmap.bind(IID_IObjectExporter)\n        request = ResolveOxid2()\n        request['pOxid'] = pOxid\n        request['cRequestedProtseqs'] = len(arRequestedProtseqs)\n        for protSeq in arRequestedProtseqs:\n            request['arRequestedProtseqs'].append(protSeq)\n        resp = self.__portmap.request(request)\n        Oxids = b''.join(pack('<H', x) for x in resp['ppdsaOxidBindings']['aStringArray'])\n        strBindings = Oxids[:resp['ppdsaOxidBindings']['wSecurityOffset']*2]\n\n        done = False\n        stringBindings = list()\n        while not done:\n            if strBindings[0:1] == b'\\x00' and strBindings[1:2] == b'\\x00':\n                done = True\n            else:\n                binding = STRINGBINDING(strBindings)\n                stringBindings.append(binding)\n                strBindings = strBindings[len(binding):]\n\n        return stringBindings\n\n    # 3.1.2.5.1.6 IObjectExporter::ServerAlive2 (Opnum 5)\n    def ServerAlive2(self):\n        self.__portmap.connect()\n        self.__portmap.bind(IID_IObjectExporter)\n        request = ServerAlive2()\n        resp = self.__portmap.request(request)\n\n        Oxids = b''.join(pack('<H', x) for x in resp['ppdsaOrBindings']['aStringArray'])\n        strBindings = Oxids[:resp['ppdsaOrBindings']['wSecurityOffset']*2]\n\n        done = False\n        stringBindings = list()\n        while not done:\n            if strBindings[0:1] == b'\\x00' and strBindings[1:2] == b'\\x00':\n                done = True\n            else:\n                binding = STRINGBINDING(strBindings)\n                stringBindings.append(binding)\n                strBindings = strBindings[len(binding):]\n\n        return stringBindings",
  "class IActivation:\n    def __init__(self, dce):\n        self.__portmap = dce\n\n    # 3.1.2.5.2.3.1 IActivation:: RemoteActivation (Opnum 0)\n    def RemoteActivation(self, clsId, iid):\n        # Only supports one interface at a time\n        self.__portmap.bind(IID_IActivation)\n        ORPCthis = ORPCTHIS()\n        ORPCthis['cid'] = generate()\n        ORPCthis['extensions'] = NULL\n        ORPCthis['flags'] = 1\n\n        request = RemoteActivation()\n        request['Clsid'] = clsId\n        request['pwszObjectName'] = NULL\n        request['pObjectStorage'] = NULL\n        request['ClientImpLevel'] = 2\n        request['Mode'] = 0\n        request['Interfaces'] = 1\n\n        _iid = IID()\n        _iid['Data'] = iid\n\n        request['pIIDs'].append(_iid)\n        request['cRequestedProtseqs'] = 1\n        request['aRequestedProtseqs'].append(7)\n\n        resp = self.__portmap.request(request)\n\n        # Now let's parse the answer and build an Interface instance\n\n        ipidRemUnknown = resp['pipidRemUnknown']\n\n        Oxids = b''.join(pack('<H', x) for x in resp['ppdsaOxidBindings']['aStringArray'])\n        strBindings = Oxids[:resp['ppdsaOxidBindings']['wSecurityOffset']*2]\n        securityBindings = Oxids[resp['ppdsaOxidBindings']['wSecurityOffset']*2:]\n\n        done = False\n        stringBindings = list()\n        while not done:\n            if strBindings[0:1] == b'\\x00' and strBindings[1:2] == b'\\x00':\n                done = True\n            else:\n                binding = STRINGBINDING(strBindings)\n                stringBindings.append(binding)\n                strBindings = strBindings[len(binding):]\n\n        done = False\n        while not done:\n            if len(securityBindings) < 2:\n                done = True\n            elif securityBindings[0:1] == b'\\x00' and securityBindings[1:2 ]== b'\\x00':\n                done = True\n            else:\n                secBinding = SECURITYBINDING(securityBindings)\n                securityBindings = securityBindings[len(secBinding):]\n\n        classInstance = CLASS_INSTANCE(ORPCthis, stringBindings)\n        return IRemUnknown2(INTERFACE(classInstance, b''.join(resp['ppInterfaceData'][0]['abData']), ipidRemUnknown,\n                                      target=self.__portmap.get_rpc_transport().getRemoteHost()))",
  "class IRemoteSCMActivator:\n    def __init__(self, dce):\n        self.__portmap = dce\n\n    def RemoteGetClassObject(self, clsId, iid):\n        #  iid should be IID_IClassFactory\n        self.__portmap.bind(IID_IRemoteSCMActivator)\n        ORPCthis = ORPCTHIS()\n        ORPCthis['cid'] = generate()\n        ORPCthis['extensions'] = NULL\n        ORPCthis['flags'] = 1\n\n        request = RemoteGetClassObject()\n        request['ORPCthis'] = ORPCthis\n        activationBLOB = ACTIVATION_BLOB()\n        activationBLOB['CustomHeader']['destCtx'] = 2\n        activationBLOB['CustomHeader']['pdwReserved'] = NULL\n        clsid = CLSID()\n        clsid['Data'] = CLSID_InstantiationInfo\n        activationBLOB['CustomHeader']['pclsid'].append(clsid)\n        clsid = CLSID()\n        clsid['Data'] = CLSID_ActivationContextInfo\n        activationBLOB['CustomHeader']['pclsid'].append(clsid)\n        clsid = CLSID()\n        clsid['Data'] = CLSID_ServerLocationInfo\n        activationBLOB['CustomHeader']['pclsid'].append(clsid)\n        clsid = CLSID()\n        clsid['Data'] = CLSID_ScmRequestInfo\n        activationBLOB['CustomHeader']['pclsid'].append(clsid)\n\n        properties = b''\n        # InstantiationInfo\n        instantiationInfo = InstantiationInfoData()\n        instantiationInfo['classId'] = clsId\n        instantiationInfo['cIID'] = 1\n\n        _iid = IID()\n        _iid['Data'] = iid\n\n        instantiationInfo['pIID'].append(_iid)\n\n        dword = DWORD()\n        marshaled = instantiationInfo.getData()+instantiationInfo.getDataReferents()\n        pad = (8 - (len(marshaled) % 8)) % 8\n        dword['Data'] = len(marshaled) + pad\n        activationBLOB['CustomHeader']['pSizes'].append(dword)\n        instantiationInfo['thisSize'] = dword['Data']\n\n        properties += marshaled + b'\\xFA'*pad\n\n        # ActivationContextInfoData\n        activationInfo = ActivationContextInfoData()\n        activationInfo['pIFDClientCtx'] = NULL\n        activationInfo['pIFDPrototypeCtx'] = NULL\n\n        dword = DWORD()\n        marshaled = activationInfo.getData()+activationInfo.getDataReferents()\n        pad = (8 - (len(marshaled) % 8)) % 8\n        dword['Data'] = len(marshaled) + pad\n        activationBLOB['CustomHeader']['pSizes'].append(dword)\n\n        properties += marshaled + b'\\xFA'*pad\n\n        # ServerLocation\n        locationInfo = LocationInfoData()\n        locationInfo['machineName'] = NULL\n\n        dword = DWORD()\n        dword['Data'] = len(locationInfo.getData())\n        activationBLOB['CustomHeader']['pSizes'].append(dword)\n\n        properties += locationInfo.getData()+locationInfo.getDataReferents()\n\n        # ScmRequestInfo\n        scmInfo = ScmRequestInfoData()\n        scmInfo['pdwReserved'] = NULL\n        #scmInfo['remoteRequest']['ClientImpLevel'] = 2\n        scmInfo['remoteRequest']['cRequestedProtseqs'] = 1\n        scmInfo['remoteRequest']['pRequestedProtseqs'].append(7)\n\n        dword = DWORD()\n        marshaled = scmInfo.getData()+scmInfo.getDataReferents()\n        pad = (8 - (len(marshaled) % 8)) % 8\n        dword['Data'] = len(marshaled) + pad\n        activationBLOB['CustomHeader']['pSizes'].append(dword)\n\n        properties += marshaled + b'\\xFA'*pad\n\n        activationBLOB['Property'] = properties\n\n\n        objrefcustom = OBJREF_CUSTOM()\n        objrefcustom['iid'] = IID_IActivationPropertiesIn[:-4]\n        objrefcustom['clsid'] = CLSID_ActivationPropertiesIn\n\n        objrefcustom['pObjectData'] = activationBLOB.getData()\n        objrefcustom['ObjectReferenceSize'] = len(objrefcustom['pObjectData'])+8\n\n        request['pActProperties']['ulCntData'] = len(objrefcustom.getData())\n        request['pActProperties']['abData'] = list(objrefcustom.getData())\n        resp = self.__portmap.request(request)\n        # Now let's parse the answer and build an Interface instance\n\n        objRefType = OBJREF(b''.join(resp['ppActProperties']['abData']))['flags']\n        objRef = None\n        if objRefType == FLAGS_OBJREF_CUSTOM:\n            objRef = OBJREF_CUSTOM(b''.join(resp['ppActProperties']['abData']))\n        elif objRefType == FLAGS_OBJREF_HANDLER:\n            objRef = OBJREF_HANDLER(b''.join(resp['ppActProperties']['abData']))\n        elif objRefType == FLAGS_OBJREF_STANDARD:\n            objRef = OBJREF_STANDARD(b''.join(resp['ppActProperties']['abData']))\n        elif objRefType == FLAGS_OBJREF_EXTENDED:\n            objRef = OBJREF_EXTENDED(b''.join(resp['ppActProperties']['abData']))\n        else:\n            LOG.error(\"Unknown OBJREF Type! 0x%x\" % objRefType)\n\n\n        activationBlob = ACTIVATION_BLOB(objRef['pObjectData'])\n\n        propOutput = activationBlob['Property'][:activationBlob['CustomHeader']['pSizes'][0]['Data']]\n        scmReply = activationBlob['Property'][\n                   activationBlob['CustomHeader']['pSizes'][0]['Data']:activationBlob['CustomHeader']['pSizes'][0]['Data'] +\n                                                                       activationBlob['CustomHeader']['pSizes'][1]['Data']]\n\n        scmr = ScmReplyInfoData()\n        size = scmr.fromString(scmReply)\n        # Processing the scmReply\n        scmr.fromStringReferents(scmReply[size:])\n        ipidRemUnknown = scmr['remoteReply']['ipidRemUnknown']\n        Oxids = b''.join(pack('<H', x) for x in scmr['remoteReply']['pdsaOxidBindings']['aStringArray'])\n        strBindings = Oxids[:scmr['remoteReply']['pdsaOxidBindings']['wSecurityOffset']*2]\n        securityBindings = Oxids[scmr['remoteReply']['pdsaOxidBindings']['wSecurityOffset']*2:]\n\n        done = False\n        stringBindings = list()\n        while not done:\n            if strBindings[0:1] == b'\\x00' and strBindings[1:2] == b'\\x00':\n                done = True\n            else:\n                binding = STRINGBINDING(strBindings)\n                stringBindings.append(binding)\n                strBindings = strBindings[len(binding):]\n\n        done = False\n        while not done:\n            if len(securityBindings) < 2:\n                done = True\n            elif securityBindings[0:1] == b'\\x00' and securityBindings[1:2] == b'\\x00':\n                done = True\n            else:\n                secBinding = SECURITYBINDING(securityBindings)\n                securityBindings = securityBindings[len(secBinding):]\n\n        # Processing the Properties Output\n        propsOut = PropsOutInfo()\n        size = propsOut.fromString(propOutput)\n        propsOut.fromStringReferents(propOutput[size:])\n\n        classInstance = CLASS_INSTANCE(ORPCthis, stringBindings)\n        classInstance.set_auth_level(scmr['remoteReply']['authnHint'])\n        classInstance.set_auth_type(self.__portmap.get_auth_type())\n        return IRemUnknown2(INTERFACE(classInstance, b''.join(propsOut['ppIntfData'][0]['abData']), ipidRemUnknown,\n                                      target=self.__portmap.get_rpc_transport().getRemoteHost()))\n\n    def RemoteCreateInstance(self, clsId, iid):\n        # Only supports one interface at a time\n        self.__portmap.bind(IID_IRemoteSCMActivator)\n\n        ORPCthis = ORPCTHIS()\n        ORPCthis['cid'] = generate()\n        ORPCthis['extensions'] = NULL\n        ORPCthis['flags'] = 1\n\n        request = RemoteCreateInstance()\n        request['ORPCthis'] = ORPCthis\n        request['pUnkOuter'] = NULL\n\n        activationBLOB = ACTIVATION_BLOB()\n        activationBLOB['CustomHeader']['destCtx'] = 2\n        activationBLOB['CustomHeader']['pdwReserved'] = NULL\n        clsid = CLSID()\n        clsid['Data'] = CLSID_InstantiationInfo\n        activationBLOB['CustomHeader']['pclsid'].append(clsid)\n        clsid = CLSID()\n        clsid['Data'] = CLSID_ActivationContextInfo\n        activationBLOB['CustomHeader']['pclsid'].append(clsid)\n        clsid = CLSID()\n        clsid['Data'] = CLSID_ServerLocationInfo\n        activationBLOB['CustomHeader']['pclsid'].append(clsid)\n        clsid = CLSID()\n        clsid['Data'] = CLSID_ScmRequestInfo\n        activationBLOB['CustomHeader']['pclsid'].append(clsid)\n\n        properties = b''\n        # InstantiationInfo\n        instantiationInfo = InstantiationInfoData()\n        instantiationInfo['classId'] = clsId\n        instantiationInfo['cIID'] = 1\n\n        _iid = IID()\n        _iid['Data'] = iid\n\n        instantiationInfo['pIID'].append(_iid)\n\n        dword = DWORD()\n        marshaled = instantiationInfo.getData()+instantiationInfo.getDataReferents()\n        pad = (8 - (len(marshaled) % 8)) % 8\n        dword['Data'] = len(marshaled) + pad\n        activationBLOB['CustomHeader']['pSizes'].append(dword)\n        instantiationInfo['thisSize'] = dword['Data']\n\n        properties += marshaled + b'\\xFA'*pad\n\n        # ActivationContextInfoData\n        activationInfo = ActivationContextInfoData()\n        activationInfo['pIFDClientCtx'] = NULL\n        activationInfo['pIFDPrototypeCtx'] = NULL\n\n        dword = DWORD()\n        marshaled = activationInfo.getData()+activationInfo.getDataReferents()\n        pad = (8 - (len(marshaled) % 8)) % 8\n        dword['Data'] = len(marshaled) + pad\n        activationBLOB['CustomHeader']['pSizes'].append(dword)\n\n        properties += marshaled + b'\\xFA'*pad\n\n        # ServerLocation\n        locationInfo = LocationInfoData()\n        locationInfo['machineName'] = NULL\n\n        dword = DWORD()\n        dword['Data'] = len(locationInfo.getData())\n        activationBLOB['CustomHeader']['pSizes'].append(dword)\n\n        properties += locationInfo.getData()+locationInfo.getDataReferents()\n\n        # ScmRequestInfo\n        scmInfo = ScmRequestInfoData()\n        scmInfo['pdwReserved'] = NULL\n        #scmInfo['remoteRequest']['ClientImpLevel'] = 2\n        scmInfo['remoteRequest']['cRequestedProtseqs'] = 1\n        scmInfo['remoteRequest']['pRequestedProtseqs'].append(7)\n\n        dword = DWORD()\n        marshaled = scmInfo.getData()+scmInfo.getDataReferents()\n        pad = (8 - (len(marshaled) % 8)) % 8\n        dword['Data'] = len(marshaled) + pad\n        activationBLOB['CustomHeader']['pSizes'].append(dword)\n\n        properties += marshaled + b'\\xFA'*pad\n\n        activationBLOB['Property'] = properties\n\n\n        objrefcustom = OBJREF_CUSTOM()\n        objrefcustom['iid'] = IID_IActivationPropertiesIn[:-4]\n        objrefcustom['clsid'] = CLSID_ActivationPropertiesIn\n\n        objrefcustom['pObjectData'] = activationBLOB.getData()\n        objrefcustom['ObjectReferenceSize'] = len(objrefcustom['pObjectData'])+8\n\n        request['pActProperties']['ulCntData'] = len(objrefcustom.getData())\n        request['pActProperties']['abData'] = list(objrefcustom.getData())\n        resp = self.__portmap.request(request)\n\n        # Now let's parse the answer and build an Interface instance\n\n        objRefType = OBJREF(b''.join(resp['ppActProperties']['abData']))['flags']\n        objRef = None\n        if objRefType == FLAGS_OBJREF_CUSTOM:\n            objRef = OBJREF_CUSTOM(b''.join(resp['ppActProperties']['abData']))\n        elif objRefType == FLAGS_OBJREF_HANDLER:\n            objRef = OBJREF_HANDLER(b''.join(resp['ppActProperties']['abData']))\n        elif objRefType == FLAGS_OBJREF_STANDARD:\n            objRef = OBJREF_STANDARD(b''.join(resp['ppActProperties']['abData']))\n        elif objRefType == FLAGS_OBJREF_EXTENDED:\n            objRef = OBJREF_EXTENDED(b''.join(resp['ppActProperties']['abData']))\n        else:\n            LOG.error(\"Unknown OBJREF Type! 0x%x\" % objRefType)\n\n\n        activationBlob = ACTIVATION_BLOB(objRef['pObjectData'])\n\n        propOutput = activationBlob['Property'][:activationBlob['CustomHeader']['pSizes'][0]['Data']]\n        scmReply = activationBlob['Property'][\n                   activationBlob['CustomHeader']['pSizes'][0]['Data']:activationBlob['CustomHeader']['pSizes'][0]['Data'] +\n                                                                       activationBlob['CustomHeader']['pSizes'][1]['Data']]\n\n        scmr = ScmReplyInfoData()\n        size = scmr.fromString(scmReply)\n        # Processing the scmReply\n        scmr.fromStringReferents(scmReply[size:])\n        ipidRemUnknown = scmr['remoteReply']['ipidRemUnknown']\n        Oxids = b''.join(pack('<H', x) for x in scmr['remoteReply']['pdsaOxidBindings']['aStringArray'])\n        strBindings = Oxids[:scmr['remoteReply']['pdsaOxidBindings']['wSecurityOffset']*2]\n        securityBindings = Oxids[scmr['remoteReply']['pdsaOxidBindings']['wSecurityOffset']*2:]\n\n        done = False\n        stringBindings = list()\n        while not done:\n            if strBindings[0:1] == b'\\x00' and strBindings[1:2] == b'\\x00':\n                done = True\n            else:\n                binding = STRINGBINDING(strBindings)\n                stringBindings.append(binding)\n                strBindings = strBindings[len(binding):]\n\n        done = False\n        while not done:\n            if len(securityBindings) < 2:\n                done = True\n            elif securityBindings[0:1] == b'\\x00' and securityBindings[1:2] == b'\\x00':\n                done = True\n            else:\n                secBinding = SECURITYBINDING(securityBindings)\n                securityBindings = securityBindings[len(secBinding):]\n\n        # Processing the Properties Output\n        propsOut = PropsOutInfo()\n        size = propsOut.fromString(propOutput)\n        propsOut.fromStringReferents(propOutput[size:])\n\n        classInstance = CLASS_INSTANCE(ORPCthis, stringBindings)\n        classInstance.set_auth_level(scmr['remoteReply']['authnHint'])\n        classInstance.set_auth_type(self.__portmap.get_auth_type())\n        return IRemUnknown2(INTERFACE(classInstance, b''.join(propsOut['ppIntfData'][0]['abData']), ipidRemUnknown,\n                                      target=self.__portmap.get_rpc_transport().getRemoteHost()))",
  "def __init__(self, error_string=None, error_code=None, packet=None):\n        DCERPCException.__init__(self, error_string, error_code, packet)",
  "def __str__( self ):\n        if self.error_code in hresult_errors.ERROR_MESSAGES:\n            error_msg_short = hresult_errors.ERROR_MESSAGES[self.error_code][0]\n            error_msg_verbose = hresult_errors.ERROR_MESSAGES[self.error_code][1]\n            return 'DCOM SessionError: code: 0x%x - %s - %s' % (self.error_code, error_msg_short, error_msg_verbose)\n        else:\n            return 'DCOM SessionError: unknown error code: 0x%x' % self.error_code",
  "def __init__(self, data=None, isNDR64=False):\n        NDRSTRUCT.__init__(self, data, isNDR64)\n        self['context_handle_uuid'] = b'\\x00'*16",
  "def isNull(self):\n        return self['context_handle_uuid'] == b'\\x00'*16",
  "def set_default_version(cls, major_version=None, minor_version=None):\n        # Set default dcom version for all new COMVERSION objects.\n        if major_version is not None:\n            cls.default_major_version = major_version\n        if minor_version is not None:\n            cls.default_minor_version = minor_version",
  "def __init__(self, data = None,isNDR64 = False):\n        NDRSTRUCT.__init__(self, data, isNDR64)\n        if data is None:\n            self['MajorVersion'] = self.default_major_version\n            self['MinorVersion'] = self.default_minor_version",
  "def __init__(self, data = None,isNDR64 = False):\n        NDRSTRUCT.__init__(self, data, isNDR64)\n        if data is None:\n            self['signature'] = 0x574F454D",
  "def __init__(self, data = None,isNDR64 = False):\n        OBJREF.__init__(self, data, isNDR64)\n        if data is None:\n            self['flags'] = FLAGS_OBJREF_STANDARD",
  "def __init__(self, data = None,isNDR64 = False):\n        OBJREF.__init__(self, data, isNDR64)\n        if data is None:\n            self['flags'] = FLAGS_OBJREF_HANDLER",
  "def __init__(self, data = None,isNDR64 = False):\n        OBJREF.__init__(self, data, isNDR64)\n        if data is None:\n            self['flags'] = FLAGS_OBJREF_CUSTOM",
  "def getDataLen(self, data, offset=0):\n        return self['wNumEntries']*2",
  "def __init__(self, data = None, isNDR64 = False):\n        OBJREF.__init__(self, data, isNDR64)\n        if data is None:\n            self['flags'] = FLAGS_OBJREF_EXTENDED\n            self['Signature1'] = 0x4E535956\n            self['Signature1'] = 0x4E535956\n            self['nElms'] = 0x4E535956",
  "def __init__(self, data = None, isNDR64 = False):\n        NDRSTRUCT.__init__(self, data, isNDR64)\n        if data is None:\n            self['SignatureVersion'] = 0x414E554B",
  "def getData(self, soFar = 0):\n        self['headerSize'] = len(TypeSerialization1.getData(self, soFar)) + len(\n            TypeSerialization1.getDataReferents(self, soFar))\n        self['cIfs'] = len(self['pclsid'])\n        return TypeSerialization1.getData(self, soFar)",
  "def getData(self, soFar = 0):\n        self['dwSize'] = len(self['CustomHeader'].getData(soFar)) + len(\n            self['CustomHeader'].getDataReferents(soFar)) + len(self['Property'])\n        self['CustomHeader']['totalSize'] = self['dwSize']\n        return NDRTLSTRUCT.getData(self)",
  "def __init__(self, target, username='', password='', domain='', lmhash='', nthash='', aesKey='', TGT=None, TGS=None,\n                 authLevel=RPC_C_AUTHN_LEVEL_PKT_PRIVACY, oxidResolver=False, doKerberos=False, kdcHost=None):\n        self.__target = target\n        self.__userName = username\n        self.__password = password\n        self.__domain = domain\n        self.__lmhash = lmhash\n        self.__nthash = nthash\n        self.__aesKey = aesKey\n        self.__TGT    = TGT\n        self.__TGS    = TGS\n        self.__authLevel = authLevel\n        self.__portmap = None\n        self.__oxidResolver = oxidResolver\n        self.__doKerberos = doKerberos\n        self.__kdcHost = kdcHost\n        self.initConnection()",
  "def addOid(cls, target, oid):\n        if (target in DCOMConnection.OID_ADD) is False:\n            DCOMConnection.OID_ADD[target] = set()\n        DCOMConnection.OID_ADD[target].add(oid)\n        if (target in DCOMConnection.OID_SET) is False:\n            DCOMConnection.OID_SET[target] = {}\n            DCOMConnection.OID_SET[target]['oids'] = set()\n            DCOMConnection.OID_SET[target]['setid'] = 0",
  "def delOid(cls, target, oid):\n        if (target in DCOMConnection.OID_DEL) is False:\n            DCOMConnection.OID_DEL[target] = set()\n        DCOMConnection.OID_DEL[target].add(oid)\n        if (target in DCOMConnection.OID_SET) is False:\n            DCOMConnection.OID_SET[target] = {}\n            DCOMConnection.OID_SET[target]['oids'] = set()\n            DCOMConnection.OID_SET[target]['setid'] = 0",
  "def pingServer(cls):\n        # Here we need to go through all the objects opened and ping them.\n        # ToDo: locking for avoiding race conditions\n        #print DCOMConnection.PORTMAPS\n        #print DCOMConnection.OID_SET\n        try:\n            for target in DCOMConnection.OID_SET:\n                addedOids = set()\n                deletedOids = set()\n                if target in DCOMConnection.OID_ADD:\n                    addedOids = DCOMConnection.OID_ADD[target]\n                    del(DCOMConnection.OID_ADD[target])\n\n                if target in DCOMConnection.OID_DEL:\n                    deletedOids = DCOMConnection.OID_DEL[target]\n                    del(DCOMConnection.OID_DEL[target])\n\n                objExporter = IObjectExporter(DCOMConnection.PORTMAPS[target])\n\n                if len(addedOids) > 0 or len(deletedOids) > 0:\n                    if 'setid' in DCOMConnection.OID_SET[target]:\n                        setId = DCOMConnection.OID_SET[target]['setid']\n                    else:\n                        setId = 0\n                    resp = objExporter.ComplexPing(setId, 0, addedOids, deletedOids)\n                    DCOMConnection.OID_SET[target]['oids'] -= deletedOids\n                    DCOMConnection.OID_SET[target]['oids'] |= addedOids\n                    DCOMConnection.OID_SET[target]['setid'] = resp['pSetId']\n                else:\n                    objExporter.SimplePing(DCOMConnection.OID_SET[target]['setid'])\n        except Exception as e:\n            # There might be exceptions when sending packets \n            # We should try to continue tho.\n            LOG.error(str(e))\n            pass\n\n        DCOMConnection.PINGTIMER = Timer(120,DCOMConnection.pingServer)\n        try:\n            DCOMConnection.PINGTIMER.start()\n        except Exception as e:\n            if str(e).find('threads can only be started once') < 0:\n                raise e",
  "def initTimer(self):\n        if self.__oxidResolver is True:\n            if DCOMConnection.PINGTIMER is None:\n                DCOMConnection.PINGTIMER = Timer(120, DCOMConnection.pingServer)\n            try:\n                DCOMConnection.PINGTIMER.start()\n            except Exception as e:\n                if str(e).find('threads can only be started once') < 0:\n                    raise e",
  "def initConnection(self):\n        stringBinding = r'ncacn_ip_tcp:%s' % self.__target\n        rpctransport = transport.DCERPCTransportFactory(stringBinding)\n\n        if hasattr(rpctransport, 'set_credentials') and len(self.__userName) >=0:\n            # This method exists only for selected protocol sequences.\n            rpctransport.set_credentials(self.__userName, self.__password, self.__domain, self.__lmhash, self.__nthash,\n                                         self.__aesKey, self.__TGT, self.__TGS)\n            rpctransport.set_kerberos(self.__doKerberos, self.__kdcHost)\n        self.__portmap = rpctransport.get_dce_rpc()\n        self.__portmap.set_auth_level(self.__authLevel)\n        if self.__doKerberos is True:\n            self.__portmap.set_auth_type(RPC_C_AUTHN_GSS_NEGOTIATE)\n        self.__portmap.connect()\n        DCOMConnection.PORTMAPS[self.__target] = self.__portmap",
  "def CoCreateInstanceEx(self, clsid, iid):\n        scm = IRemoteSCMActivator(self.__portmap)\n        iInterface = scm.RemoteCreateInstance(clsid, iid)\n        self.initTimer()\n        return iInterface",
  "def get_dce_rpc(self):\n        return DCOMConnection.PORTMAPS[self.__target]",
  "def disconnect(self):\n        if DCOMConnection.PINGTIMER is not None:\n            del(DCOMConnection.PORTMAPS[self.__target])\n            del(DCOMConnection.OID_SET[self.__target])\n            if len(DCOMConnection.PORTMAPS) == 0:\n                # This means there are no more clients using this object, kill it\n                DCOMConnection.PINGTIMER.cancel()\n                DCOMConnection.PINGTIMER.join()\n                DCOMConnection.PINGTIMER = None\n        if self.__target in INTERFACE.CONNECTIONS:\n            del(INTERFACE.CONNECTIONS[self.__target][current_thread().name])\n        self.__portmap.disconnect()",
  "def __init__(self, ORPCthis, stringBinding):\n        self.__stringBindings = stringBinding\n        self.__ORPCthis = ORPCthis\n        self.__authType = RPC_C_AUTHN_WINNT\n        self.__authLevel = RPC_C_AUTHN_LEVEL_PKT_PRIVACY",
  "def get_ORPCthis(self):\n        return self.__ORPCthis",
  "def get_string_bindings(self):\n        return self.__stringBindings",
  "def get_auth_level(self):\n        if RPC_C_AUTHN_LEVEL_NONE < self.__authLevel < RPC_C_AUTHN_LEVEL_PKT_PRIVACY:\n            if self.__authType == RPC_C_AUTHN_WINNT:\n                return RPC_C_AUTHN_LEVEL_PKT_INTEGRITY\n            else:\n                return RPC_C_AUTHN_LEVEL_PKT_PRIVACY\n        return self.__authLevel",
  "def set_auth_level(self, level):\n        self.__authLevel = level",
  "def get_auth_type(self):\n        return self.__authType",
  "def set_auth_type(self, authType):\n        self.__authType = authType",
  "def __init__(self, cinstance=None, objRef=None, ipidRemUnknown=None, iPid=None, oxid=None, oid=None, target=None,\n                 interfaceInstance=None):\n        if interfaceInstance is not None:\n            self.__target = interfaceInstance.get_target()\n            self.__iPid = interfaceInstance.get_iPid()\n            self.__oid  = interfaceInstance.get_oid()\n            self.__oxid = interfaceInstance.get_oxid()\n            self.__cinstance = interfaceInstance.get_cinstance()\n            self.__objRef = interfaceInstance.get_objRef()\n            self.__ipidRemUnknown = interfaceInstance.get_ipidRemUnknown()\n        else:\n            if target is None:\n                raise Exception('No target')\n            self.__target = target\n            self.__iPid = iPid\n            self.__oid  = oid\n            self.__oxid = oxid\n            self.__cinstance = cinstance\n            self.__objRef = objRef\n            self.__ipidRemUnknown = ipidRemUnknown\n            # We gotta check if we have a container inside our connection list, if not, create\n            if (self.__target in INTERFACE.CONNECTIONS) is not True:\n                INTERFACE.CONNECTIONS[self.__target] = {}\n                INTERFACE.CONNECTIONS[self.__target][current_thread().name] = {}\n\n            if objRef is not None:\n                self.process_interface(objRef)",
  "def process_interface(self, data):\n        objRefType = OBJREF(data)['flags']\n        objRef = None\n        if objRefType == FLAGS_OBJREF_CUSTOM:\n            objRef = OBJREF_CUSTOM(data)\n        elif objRefType == FLAGS_OBJREF_HANDLER:\n            objRef = OBJREF_HANDLER(data)\n        elif objRefType == FLAGS_OBJREF_STANDARD:\n            objRef = OBJREF_STANDARD(data)\n        elif objRefType == FLAGS_OBJREF_EXTENDED:\n            objRef = OBJREF_EXTENDED(data)\n        else:\n            LOG.error(\"Unknown OBJREF Type! 0x%x\" % objRefType)\n\n        if objRefType != FLAGS_OBJREF_CUSTOM:\n            if objRef['std']['flags'] & SORF_NOPING == 0:\n                DCOMConnection.addOid(self.__target, objRef['std']['oid'])\n            self.__iPid = objRef['std']['ipid']\n            self.__oid  = objRef['std']['oid']\n            self.__oxid = objRef['std']['oxid']\n            if self.__oxid is None:\n                objRef.dump()\n                raise Exception('OXID is None')",
  "def get_oxid(self):\n        return self.__oxid",
  "def set_oxid(self, oxid):\n        self.__oxid = oxid",
  "def get_oid(self):\n        return self.__oid",
  "def set_oid(self, oid):\n        self.__oid = oid",
  "def get_target(self):\n        return self.__target",
  "def get_iPid(self):\n        return self.__iPid",
  "def set_iPid(self, iPid):\n        self.__iPid = iPid",
  "def get_objRef(self):\n        return self.__objRef",
  "def set_objRef(self, objRef):\n        self.__objRef = objRef",
  "def get_ipidRemUnknown(self):\n        return self.__ipidRemUnknown",
  "def get_dce_rpc(self):\n        return INTERFACE.CONNECTIONS[self.__target][current_thread().name][self.__oxid]['dce']",
  "def get_cinstance(self):\n        return self.__cinstance",
  "def set_cinstance(self, cinstance):\n        self.__cinstance = cinstance",
  "def is_fqdn(self):\n        # I will assume the following\n        # If I can't socket.inet_aton() then it's not an IPv4 address\n        # Same for ipv6, but since socket.inet_pton is not available in Windows, I'll look for ':'. There can't be\n        # an FQDN with ':'\n        # Is it isn't both, then it is a FQDN\n        try:\n            socket.inet_aton(self.__target)\n        except:\n            # Not an IPv4\n            try:\n                self.__target.index(':')\n            except:\n                # Not an IPv6, it's a FQDN\n                return True\n        return False",
  "def connect(self, iid = None):\n        if (self.__target in INTERFACE.CONNECTIONS) is True:\n            if current_thread().name in INTERFACE.CONNECTIONS[self.__target] and \\\n                            (self.__oxid in INTERFACE.CONNECTIONS[self.__target][current_thread().name]) is True:\n                dce = INTERFACE.CONNECTIONS[self.__target][current_thread().name][self.__oxid]['dce']\n                currentBinding = INTERFACE.CONNECTIONS[self.__target][current_thread().name][self.__oxid]['currentBinding']\n                if currentBinding == iid:\n                    # We don't need to alter_ctx\n                    pass\n                else:\n                    newDce = dce.alter_ctx(iid)\n                    INTERFACE.CONNECTIONS[self.__target][current_thread().name][self.__oxid]['dce'] = newDce\n                    INTERFACE.CONNECTIONS[self.__target][current_thread().name][self.__oxid]['currentBinding'] = iid\n            else:\n                stringBindings = self.get_cinstance().get_string_bindings()\n                # No OXID present, we should create a new connection and store it\n                stringBinding = None\n                isTargetFQDN = self.is_fqdn()\n                LOG.debug('Target system is %s and isFQDN is %s' % (self.get_target(), isTargetFQDN))\n                for strBinding in stringBindings:\n                    # Here, depending on the get_target() value several things can happen\n                    # 1) it's an IPv4 address\n                    # 2) it's an IPv6 address\n                    # 3) it's a NetBios Name\n                    # we should handle all this cases accordingly\n                    # Does this match exactly what get_target() returns?\n                    LOG.debug('StringBinding: %s' % strBinding['aNetworkAddr'])\n                    if strBinding['wTowerId'] == 7:\n                        # If there's port information, let's strip it for now.\n                        if strBinding['aNetworkAddr'].find('[') >= 0:\n                            binding, _, bindingPort = strBinding['aNetworkAddr'].partition('[')\n                            bindingPort = '[' + bindingPort\n                        else:\n                            binding = strBinding['aNetworkAddr']\n                            bindingPort = ''\n\n                        if binding.upper().find(self.get_target().upper()) >= 0:\n                            stringBinding = 'ncacn_ip_tcp:' + strBinding['aNetworkAddr'][:-1]\n                            break\n                        # If get_target() is a FQDN, does it match the hostname?\n                        elif isTargetFQDN and binding.upper().find(self.get_target().upper().partition('.')[0]) >= 0:\n                            # Here we replace the aNetworkAddr with self.get_target()\n                            # This is to help resolving the target system name.\n                            # self.get_target() has been resolved already otherwise we wouldn't be here whereas\n                            # aNetworkAddr is usually the NetBIOS name and unless you have your DNS resolver\n                            # with the right suffixes it will probably not resolve right.\n                            stringBinding = 'ncacn_ip_tcp:%s%s' % (self.get_target(), bindingPort)\n                            break\n\n                LOG.debug('StringBinding chosen: %s' % stringBinding)\n                if stringBinding is None:\n                    # Something wen't wrong, let's just report it\n                    raise Exception('Can\\'t find a valid stringBinding to connect')\n\n                dcomInterface = transport.DCERPCTransportFactory(stringBinding)\n                if hasattr(dcomInterface, 'set_credentials'):\n                    # This method exists only for selected protocol sequences.\n                    dcomInterface.set_credentials(*DCOMConnection.PORTMAPS[self.__target].get_credentials())\n                    dcomInterface.set_kerberos(DCOMConnection.PORTMAPS[self.__target].get_rpc_transport().get_kerberos(),\n                                               DCOMConnection.PORTMAPS[self.__target].get_rpc_transport().get_kdcHost())\n                dcomInterface.set_connect_timeout(300)\n                dce = dcomInterface.get_dce_rpc()\n\n                if iid is None:\n                    raise Exception('IID is None')\n                else:\n                    dce.set_auth_level(self.__cinstance.get_auth_level())\n                    dce.set_auth_type(self.__cinstance.get_auth_type())\n\n                dce.connect()\n\n                if iid is None:\n                    raise Exception('IID is None')\n                else:\n                    dce.bind(iid)\n\n                if self.__oxid is None:\n                    #import traceback\n                    #traceback.print_stack()\n                    raise Exception(\"OXID NONE, something wrong!!!\")\n\n                INTERFACE.CONNECTIONS[self.__target][current_thread().name] = {}\n                INTERFACE.CONNECTIONS[self.__target][current_thread().name][self.__oxid] = {}\n                INTERFACE.CONNECTIONS[self.__target][current_thread().name][self.__oxid]['dce'] = dce\n                INTERFACE.CONNECTIONS[self.__target][current_thread().name][self.__oxid]['currentBinding'] = iid\n        else:\n            # No connection created\n            raise Exception('No connection created')",
  "def request(self, req, iid = None, uuid = None):\n        req['ORPCthis'] = self.get_cinstance().get_ORPCthis()\n        req['ORPCthis']['flags'] = 0\n        self.connect(iid)\n        dce = self.get_dce_rpc()\n        try:\n            resp = dce.request(req, uuid)\n        except Exception as e:\n            if str(e).find('RPC_E_DISCONNECTED') >= 0:\n                msg = str(e) + '\\n'\n                msg += \"DCOM keep-alive pinging it might not be working as expected. You can't be idle for more than 14 minutes!\\n\"\n                msg += \"You should exit the app and start again\\n\"\n                raise DCERPCException(msg)\n            else:\n                raise\n        return resp",
  "def disconnect(self):\n        return INTERFACE.CONNECTIONS[self.__target][current_thread().name][self.__oxid]['dce'].disconnect()",
  "def __init__(self, interface):\n        self._iid = IID_IRemUnknown\n        #INTERFACE.__init__(self, interface.get_cinstance(), interface.get_objRef(), interface.get_ipidRemUnknown(),\n        #                   interface.get_iPid(), target=interface.get_target())\n        INTERFACE.__init__(self, interfaceInstance=interface)\n        self.set_oxid(interface.get_oxid())",
  "def RemQueryInterface(self, cRefs, iids):\n        # For now, it only supports a single IID\n        request = RemQueryInterface()\n        request['ORPCthis'] = self.get_cinstance().get_ORPCthis()\n        request['ORPCthis']['flags'] = 0\n        request['ripid'] = self.get_iPid()\n        request['cRefs'] = cRefs\n        request['cIids'] = len(iids)\n        for iid in iids:\n            _iid = IID()\n            _iid['Data'] = iid\n            request['iids'].append(_iid)\n        resp = self.request(request, IID_IRemUnknown, self.get_ipidRemUnknown())\n        #resp.dump()\n\n        return IRemUnknown2(\n            INTERFACE(self.get_cinstance(), None, self.get_ipidRemUnknown(), resp['ppQIResults']['std']['ipid'],\n                      oxid=resp['ppQIResults']['std']['oxid'], oid=resp['ppQIResults']['std']['oxid'],\n                      target=self.get_target()))",
  "def RemAddRef(self):\n        request = RemAddRef()\n        request['ORPCthis'] = self.get_cinstance().get_ORPCthis()\n        request['ORPCthis']['flags'] = 0\n        request['cInterfaceRefs'] = 1\n        element = REMINTERFACEREF()\n        element['ipid'] = self.get_iPid()\n        element['cPublicRefs'] = 1\n        request['InterfaceRefs'].append(element)\n        resp = self.request(request, IID_IRemUnknown, self.get_ipidRemUnknown())\n        return resp",
  "def RemRelease(self):\n        request = RemRelease()\n        request['ORPCthis'] = self.get_cinstance().get_ORPCthis()\n        request['ORPCthis']['flags'] = 0\n        request['cInterfaceRefs'] = 1\n        element = REMINTERFACEREF()\n        element['ipid'] = self.get_iPid()\n        element['cPublicRefs'] = 1\n        request['InterfaceRefs'].append(element)\n        resp = self.request(request, IID_IRemUnknown, self.get_ipidRemUnknown())\n        DCOMConnection.delOid(self.get_target(), self.get_oid())\n        return resp",
  "def __init__(self, interface):\n        IRemUnknown.__init__(self, interface)\n        self._iid = IID_IRemUnknown2",
  "def __init__(self, dce):\n        self.__portmap = dce",
  "def ResolveOxid(self, pOxid, arRequestedProtseqs):\n        self.__portmap.connect()\n        self.__portmap.bind(IID_IObjectExporter)\n        request = ResolveOxid()\n        request['pOxid'] = pOxid\n        request['cRequestedProtseqs'] = len(arRequestedProtseqs)\n        for protSeq in arRequestedProtseqs:\n            request['arRequestedProtseqs'].append(protSeq)\n        resp = self.__portmap.request(request)\n        Oxids = b''.join(pack('<H', x) for x in resp['ppdsaOxidBindings']['aStringArray'])\n        strBindings = Oxids[:resp['ppdsaOxidBindings']['wSecurityOffset']*2]\n\n        done = False\n        stringBindings = list()\n        while not done:\n            if strBindings[0:1] == b'\\x00' and strBindings[1:2] == b'\\x00':\n                done = True\n            else:\n                binding = STRINGBINDING(strBindings)\n                stringBindings.append(binding)\n                strBindings = strBindings[len(binding):]\n\n        return stringBindings",
  "def SimplePing(self, setId):\n        self.__portmap.connect()\n        self.__portmap.bind(IID_IObjectExporter)\n        request = SimplePing()\n        request['pSetId'] = setId\n        resp = self.__portmap.request(request)\n        return resp",
  "def ComplexPing(self, setId = 0, sequenceNum = 0, addToSet = [], delFromSet = []):\n        self.__portmap.connect()\n        #self.__portmap.set_auth_level(RPC_C_AUTHN_LEVEL_PKT_INTEGRITY)\n        self.__portmap.bind(IID_IObjectExporter)\n        request = ComplexPing()\n        request['pSetId'] = setId\n        request['SequenceNum'] = setId\n        request['cAddToSet'] = len(addToSet)\n        request['cDelFromSet'] = len(delFromSet)\n        if len(addToSet) > 0:\n            for oid in addToSet:\n                oidn = OID()\n                oidn['Data'] = oid\n                request['AddToSet'].append(oidn)\n        else:\n            request['AddToSet'] = NULL\n\n        if len(delFromSet) > 0:\n            for oid in delFromSet:\n                oidn = OID()\n                oidn['Data'] = oid\n                request['DelFromSet'].append(oidn)\n        else:\n            request['DelFromSet'] = NULL\n        resp = self.__portmap.request(request)\n        return resp",
  "def ServerAlive(self):\n        self.__portmap.connect()\n        self.__portmap.bind(IID_IObjectExporter)\n        request = ServerAlive()\n        resp = self.__portmap.request(request)\n        return resp",
  "def ResolveOxid2(self,pOxid, arRequestedProtseqs):\n        self.__portmap.connect()\n        self.__portmap.bind(IID_IObjectExporter)\n        request = ResolveOxid2()\n        request['pOxid'] = pOxid\n        request['cRequestedProtseqs'] = len(arRequestedProtseqs)\n        for protSeq in arRequestedProtseqs:\n            request['arRequestedProtseqs'].append(protSeq)\n        resp = self.__portmap.request(request)\n        Oxids = b''.join(pack('<H', x) for x in resp['ppdsaOxidBindings']['aStringArray'])\n        strBindings = Oxids[:resp['ppdsaOxidBindings']['wSecurityOffset']*2]\n\n        done = False\n        stringBindings = list()\n        while not done:\n            if strBindings[0:1] == b'\\x00' and strBindings[1:2] == b'\\x00':\n                done = True\n            else:\n                binding = STRINGBINDING(strBindings)\n                stringBindings.append(binding)\n                strBindings = strBindings[len(binding):]\n\n        return stringBindings",
  "def ServerAlive2(self):\n        self.__portmap.connect()\n        self.__portmap.bind(IID_IObjectExporter)\n        request = ServerAlive2()\n        resp = self.__portmap.request(request)\n\n        Oxids = b''.join(pack('<H', x) for x in resp['ppdsaOrBindings']['aStringArray'])\n        strBindings = Oxids[:resp['ppdsaOrBindings']['wSecurityOffset']*2]\n\n        done = False\n        stringBindings = list()\n        while not done:\n            if strBindings[0:1] == b'\\x00' and strBindings[1:2] == b'\\x00':\n                done = True\n            else:\n                binding = STRINGBINDING(strBindings)\n                stringBindings.append(binding)\n                strBindings = strBindings[len(binding):]\n\n        return stringBindings",
  "def __init__(self, dce):\n        self.__portmap = dce",
  "def RemoteActivation(self, clsId, iid):\n        # Only supports one interface at a time\n        self.__portmap.bind(IID_IActivation)\n        ORPCthis = ORPCTHIS()\n        ORPCthis['cid'] = generate()\n        ORPCthis['extensions'] = NULL\n        ORPCthis['flags'] = 1\n\n        request = RemoteActivation()\n        request['Clsid'] = clsId\n        request['pwszObjectName'] = NULL\n        request['pObjectStorage'] = NULL\n        request['ClientImpLevel'] = 2\n        request['Mode'] = 0\n        request['Interfaces'] = 1\n\n        _iid = IID()\n        _iid['Data'] = iid\n\n        request['pIIDs'].append(_iid)\n        request['cRequestedProtseqs'] = 1\n        request['aRequestedProtseqs'].append(7)\n\n        resp = self.__portmap.request(request)\n\n        # Now let's parse the answer and build an Interface instance\n\n        ipidRemUnknown = resp['pipidRemUnknown']\n\n        Oxids = b''.join(pack('<H', x) for x in resp['ppdsaOxidBindings']['aStringArray'])\n        strBindings = Oxids[:resp['ppdsaOxidBindings']['wSecurityOffset']*2]\n        securityBindings = Oxids[resp['ppdsaOxidBindings']['wSecurityOffset']*2:]\n\n        done = False\n        stringBindings = list()\n        while not done:\n            if strBindings[0:1] == b'\\x00' and strBindings[1:2] == b'\\x00':\n                done = True\n            else:\n                binding = STRINGBINDING(strBindings)\n                stringBindings.append(binding)\n                strBindings = strBindings[len(binding):]\n\n        done = False\n        while not done:\n            if len(securityBindings) < 2:\n                done = True\n            elif securityBindings[0:1] == b'\\x00' and securityBindings[1:2 ]== b'\\x00':\n                done = True\n            else:\n                secBinding = SECURITYBINDING(securityBindings)\n                securityBindings = securityBindings[len(secBinding):]\n\n        classInstance = CLASS_INSTANCE(ORPCthis, stringBindings)\n        return IRemUnknown2(INTERFACE(classInstance, b''.join(resp['ppInterfaceData'][0]['abData']), ipidRemUnknown,\n                                      target=self.__portmap.get_rpc_transport().getRemoteHost()))",
  "def __init__(self, dce):\n        self.__portmap = dce",
  "def RemoteGetClassObject(self, clsId, iid):\n        #  iid should be IID_IClassFactory\n        self.__portmap.bind(IID_IRemoteSCMActivator)\n        ORPCthis = ORPCTHIS()\n        ORPCthis['cid'] = generate()\n        ORPCthis['extensions'] = NULL\n        ORPCthis['flags'] = 1\n\n        request = RemoteGetClassObject()\n        request['ORPCthis'] = ORPCthis\n        activationBLOB = ACTIVATION_BLOB()\n        activationBLOB['CustomHeader']['destCtx'] = 2\n        activationBLOB['CustomHeader']['pdwReserved'] = NULL\n        clsid = CLSID()\n        clsid['Data'] = CLSID_InstantiationInfo\n        activationBLOB['CustomHeader']['pclsid'].append(clsid)\n        clsid = CLSID()\n        clsid['Data'] = CLSID_ActivationContextInfo\n        activationBLOB['CustomHeader']['pclsid'].append(clsid)\n        clsid = CLSID()\n        clsid['Data'] = CLSID_ServerLocationInfo\n        activationBLOB['CustomHeader']['pclsid'].append(clsid)\n        clsid = CLSID()\n        clsid['Data'] = CLSID_ScmRequestInfo\n        activationBLOB['CustomHeader']['pclsid'].append(clsid)\n\n        properties = b''\n        # InstantiationInfo\n        instantiationInfo = InstantiationInfoData()\n        instantiationInfo['classId'] = clsId\n        instantiationInfo['cIID'] = 1\n\n        _iid = IID()\n        _iid['Data'] = iid\n\n        instantiationInfo['pIID'].append(_iid)\n\n        dword = DWORD()\n        marshaled = instantiationInfo.getData()+instantiationInfo.getDataReferents()\n        pad = (8 - (len(marshaled) % 8)) % 8\n        dword['Data'] = len(marshaled) + pad\n        activationBLOB['CustomHeader']['pSizes'].append(dword)\n        instantiationInfo['thisSize'] = dword['Data']\n\n        properties += marshaled + b'\\xFA'*pad\n\n        # ActivationContextInfoData\n        activationInfo = ActivationContextInfoData()\n        activationInfo['pIFDClientCtx'] = NULL\n        activationInfo['pIFDPrototypeCtx'] = NULL\n\n        dword = DWORD()\n        marshaled = activationInfo.getData()+activationInfo.getDataReferents()\n        pad = (8 - (len(marshaled) % 8)) % 8\n        dword['Data'] = len(marshaled) + pad\n        activationBLOB['CustomHeader']['pSizes'].append(dword)\n\n        properties += marshaled + b'\\xFA'*pad\n\n        # ServerLocation\n        locationInfo = LocationInfoData()\n        locationInfo['machineName'] = NULL\n\n        dword = DWORD()\n        dword['Data'] = len(locationInfo.getData())\n        activationBLOB['CustomHeader']['pSizes'].append(dword)\n\n        properties += locationInfo.getData()+locationInfo.getDataReferents()\n\n        # ScmRequestInfo\n        scmInfo = ScmRequestInfoData()\n        scmInfo['pdwReserved'] = NULL\n        #scmInfo['remoteRequest']['ClientImpLevel'] = 2\n        scmInfo['remoteRequest']['cRequestedProtseqs'] = 1\n        scmInfo['remoteRequest']['pRequestedProtseqs'].append(7)\n\n        dword = DWORD()\n        marshaled = scmInfo.getData()+scmInfo.getDataReferents()\n        pad = (8 - (len(marshaled) % 8)) % 8\n        dword['Data'] = len(marshaled) + pad\n        activationBLOB['CustomHeader']['pSizes'].append(dword)\n\n        properties += marshaled + b'\\xFA'*pad\n\n        activationBLOB['Property'] = properties\n\n\n        objrefcustom = OBJREF_CUSTOM()\n        objrefcustom['iid'] = IID_IActivationPropertiesIn[:-4]\n        objrefcustom['clsid'] = CLSID_ActivationPropertiesIn\n\n        objrefcustom['pObjectData'] = activationBLOB.getData()\n        objrefcustom['ObjectReferenceSize'] = len(objrefcustom['pObjectData'])+8\n\n        request['pActProperties']['ulCntData'] = len(objrefcustom.getData())\n        request['pActProperties']['abData'] = list(objrefcustom.getData())\n        resp = self.__portmap.request(request)\n        # Now let's parse the answer and build an Interface instance\n\n        objRefType = OBJREF(b''.join(resp['ppActProperties']['abData']))['flags']\n        objRef = None\n        if objRefType == FLAGS_OBJREF_CUSTOM:\n            objRef = OBJREF_CUSTOM(b''.join(resp['ppActProperties']['abData']))\n        elif objRefType == FLAGS_OBJREF_HANDLER:\n            objRef = OBJREF_HANDLER(b''.join(resp['ppActProperties']['abData']))\n        elif objRefType == FLAGS_OBJREF_STANDARD:\n            objRef = OBJREF_STANDARD(b''.join(resp['ppActProperties']['abData']))\n        elif objRefType == FLAGS_OBJREF_EXTENDED:\n            objRef = OBJREF_EXTENDED(b''.join(resp['ppActProperties']['abData']))\n        else:\n            LOG.error(\"Unknown OBJREF Type! 0x%x\" % objRefType)\n\n\n        activationBlob = ACTIVATION_BLOB(objRef['pObjectData'])\n\n        propOutput = activationBlob['Property'][:activationBlob['CustomHeader']['pSizes'][0]['Data']]\n        scmReply = activationBlob['Property'][\n                   activationBlob['CustomHeader']['pSizes'][0]['Data']:activationBlob['CustomHeader']['pSizes'][0]['Data'] +\n                                                                       activationBlob['CustomHeader']['pSizes'][1]['Data']]\n\n        scmr = ScmReplyInfoData()\n        size = scmr.fromString(scmReply)\n        # Processing the scmReply\n        scmr.fromStringReferents(scmReply[size:])\n        ipidRemUnknown = scmr['remoteReply']['ipidRemUnknown']\n        Oxids = b''.join(pack('<H', x) for x in scmr['remoteReply']['pdsaOxidBindings']['aStringArray'])\n        strBindings = Oxids[:scmr['remoteReply']['pdsaOxidBindings']['wSecurityOffset']*2]\n        securityBindings = Oxids[scmr['remoteReply']['pdsaOxidBindings']['wSecurityOffset']*2:]\n\n        done = False\n        stringBindings = list()\n        while not done:\n            if strBindings[0:1] == b'\\x00' and strBindings[1:2] == b'\\x00':\n                done = True\n            else:\n                binding = STRINGBINDING(strBindings)\n                stringBindings.append(binding)\n                strBindings = strBindings[len(binding):]\n\n        done = False\n        while not done:\n            if len(securityBindings) < 2:\n                done = True\n            elif securityBindings[0:1] == b'\\x00' and securityBindings[1:2] == b'\\x00':\n                done = True\n            else:\n                secBinding = SECURITYBINDING(securityBindings)\n                securityBindings = securityBindings[len(secBinding):]\n\n        # Processing the Properties Output\n        propsOut = PropsOutInfo()\n        size = propsOut.fromString(propOutput)\n        propsOut.fromStringReferents(propOutput[size:])\n\n        classInstance = CLASS_INSTANCE(ORPCthis, stringBindings)\n        classInstance.set_auth_level(scmr['remoteReply']['authnHint'])\n        classInstance.set_auth_type(self.__portmap.get_auth_type())\n        return IRemUnknown2(INTERFACE(classInstance, b''.join(propsOut['ppIntfData'][0]['abData']), ipidRemUnknown,\n                                      target=self.__portmap.get_rpc_transport().getRemoteHost()))",
  "def RemoteCreateInstance(self, clsId, iid):\n        # Only supports one interface at a time\n        self.__portmap.bind(IID_IRemoteSCMActivator)\n\n        ORPCthis = ORPCTHIS()\n        ORPCthis['cid'] = generate()\n        ORPCthis['extensions'] = NULL\n        ORPCthis['flags'] = 1\n\n        request = RemoteCreateInstance()\n        request['ORPCthis'] = ORPCthis\n        request['pUnkOuter'] = NULL\n\n        activationBLOB = ACTIVATION_BLOB()\n        activationBLOB['CustomHeader']['destCtx'] = 2\n        activationBLOB['CustomHeader']['pdwReserved'] = NULL\n        clsid = CLSID()\n        clsid['Data'] = CLSID_InstantiationInfo\n        activationBLOB['CustomHeader']['pclsid'].append(clsid)\n        clsid = CLSID()\n        clsid['Data'] = CLSID_ActivationContextInfo\n        activationBLOB['CustomHeader']['pclsid'].append(clsid)\n        clsid = CLSID()\n        clsid['Data'] = CLSID_ServerLocationInfo\n        activationBLOB['CustomHeader']['pclsid'].append(clsid)\n        clsid = CLSID()\n        clsid['Data'] = CLSID_ScmRequestInfo\n        activationBLOB['CustomHeader']['pclsid'].append(clsid)\n\n        properties = b''\n        # InstantiationInfo\n        instantiationInfo = InstantiationInfoData()\n        instantiationInfo['classId'] = clsId\n        instantiationInfo['cIID'] = 1\n\n        _iid = IID()\n        _iid['Data'] = iid\n\n        instantiationInfo['pIID'].append(_iid)\n\n        dword = DWORD()\n        marshaled = instantiationInfo.getData()+instantiationInfo.getDataReferents()\n        pad = (8 - (len(marshaled) % 8)) % 8\n        dword['Data'] = len(marshaled) + pad\n        activationBLOB['CustomHeader']['pSizes'].append(dword)\n        instantiationInfo['thisSize'] = dword['Data']\n\n        properties += marshaled + b'\\xFA'*pad\n\n        # ActivationContextInfoData\n        activationInfo = ActivationContextInfoData()\n        activationInfo['pIFDClientCtx'] = NULL\n        activationInfo['pIFDPrototypeCtx'] = NULL\n\n        dword = DWORD()\n        marshaled = activationInfo.getData()+activationInfo.getDataReferents()\n        pad = (8 - (len(marshaled) % 8)) % 8\n        dword['Data'] = len(marshaled) + pad\n        activationBLOB['CustomHeader']['pSizes'].append(dword)\n\n        properties += marshaled + b'\\xFA'*pad\n\n        # ServerLocation\n        locationInfo = LocationInfoData()\n        locationInfo['machineName'] = NULL\n\n        dword = DWORD()\n        dword['Data'] = len(locationInfo.getData())\n        activationBLOB['CustomHeader']['pSizes'].append(dword)\n\n        properties += locationInfo.getData()+locationInfo.getDataReferents()\n\n        # ScmRequestInfo\n        scmInfo = ScmRequestInfoData()\n        scmInfo['pdwReserved'] = NULL\n        #scmInfo['remoteRequest']['ClientImpLevel'] = 2\n        scmInfo['remoteRequest']['cRequestedProtseqs'] = 1\n        scmInfo['remoteRequest']['pRequestedProtseqs'].append(7)\n\n        dword = DWORD()\n        marshaled = scmInfo.getData()+scmInfo.getDataReferents()\n        pad = (8 - (len(marshaled) % 8)) % 8\n        dword['Data'] = len(marshaled) + pad\n        activationBLOB['CustomHeader']['pSizes'].append(dword)\n\n        properties += marshaled + b'\\xFA'*pad\n\n        activationBLOB['Property'] = properties\n\n\n        objrefcustom = OBJREF_CUSTOM()\n        objrefcustom['iid'] = IID_IActivationPropertiesIn[:-4]\n        objrefcustom['clsid'] = CLSID_ActivationPropertiesIn\n\n        objrefcustom['pObjectData'] = activationBLOB.getData()\n        objrefcustom['ObjectReferenceSize'] = len(objrefcustom['pObjectData'])+8\n\n        request['pActProperties']['ulCntData'] = len(objrefcustom.getData())\n        request['pActProperties']['abData'] = list(objrefcustom.getData())\n        resp = self.__portmap.request(request)\n\n        # Now let's parse the answer and build an Interface instance\n\n        objRefType = OBJREF(b''.join(resp['ppActProperties']['abData']))['flags']\n        objRef = None\n        if objRefType == FLAGS_OBJREF_CUSTOM:\n            objRef = OBJREF_CUSTOM(b''.join(resp['ppActProperties']['abData']))\n        elif objRefType == FLAGS_OBJREF_HANDLER:\n            objRef = OBJREF_HANDLER(b''.join(resp['ppActProperties']['abData']))\n        elif objRefType == FLAGS_OBJREF_STANDARD:\n            objRef = OBJREF_STANDARD(b''.join(resp['ppActProperties']['abData']))\n        elif objRefType == FLAGS_OBJREF_EXTENDED:\n            objRef = OBJREF_EXTENDED(b''.join(resp['ppActProperties']['abData']))\n        else:\n            LOG.error(\"Unknown OBJREF Type! 0x%x\" % objRefType)\n\n\n        activationBlob = ACTIVATION_BLOB(objRef['pObjectData'])\n\n        propOutput = activationBlob['Property'][:activationBlob['CustomHeader']['pSizes'][0]['Data']]\n        scmReply = activationBlob['Property'][\n                   activationBlob['CustomHeader']['pSizes'][0]['Data']:activationBlob['CustomHeader']['pSizes'][0]['Data'] +\n                                                                       activationBlob['CustomHeader']['pSizes'][1]['Data']]\n\n        scmr = ScmReplyInfoData()\n        size = scmr.fromString(scmReply)\n        # Processing the scmReply\n        scmr.fromStringReferents(scmReply[size:])\n        ipidRemUnknown = scmr['remoteReply']['ipidRemUnknown']\n        Oxids = b''.join(pack('<H', x) for x in scmr['remoteReply']['pdsaOxidBindings']['aStringArray'])\n        strBindings = Oxids[:scmr['remoteReply']['pdsaOxidBindings']['wSecurityOffset']*2]\n        securityBindings = Oxids[scmr['remoteReply']['pdsaOxidBindings']['wSecurityOffset']*2:]\n\n        done = False\n        stringBindings = list()\n        while not done:\n            if strBindings[0:1] == b'\\x00' and strBindings[1:2] == b'\\x00':\n                done = True\n            else:\n                binding = STRINGBINDING(strBindings)\n                stringBindings.append(binding)\n                strBindings = strBindings[len(binding):]\n\n        done = False\n        while not done:\n            if len(securityBindings) < 2:\n                done = True\n            elif securityBindings[0:1] == b'\\x00' and securityBindings[1:2] == b'\\x00':\n                done = True\n            else:\n                secBinding = SECURITYBINDING(securityBindings)\n                securityBindings = securityBindings[len(secBinding):]\n\n        # Processing the Properties Output\n        propsOut = PropsOutInfo()\n        size = propsOut.fromString(propOutput)\n        propsOut.fromStringReferents(propOutput[size:])\n\n        classInstance = CLASS_INSTANCE(ORPCthis, stringBindings)\n        classInstance.set_auth_level(scmr['remoteReply']['authnHint'])\n        classInstance.set_auth_type(self.__portmap.get_auth_type())\n        return IRemUnknown2(INTERFACE(classInstance, b''.join(propsOut['ppIntfData'][0]['abData']), ipidRemUnknown,\n                                      target=self.__portmap.get_rpc_transport().getRemoteHost()))",
  "class DCERPCSessionError(DCERPCException):\n    def __init__(self, error_string=None, error_code=None, packet=None):\n        DCERPCException.__init__(self, error_string, error_code, packet)\n\n    def __str__( self ):\n        key = self.error_code\n        if key in nt_errors.ERROR_MESSAGES:\n            error_msg_short = nt_errors.ERROR_MESSAGES[key][0]\n            error_msg_verbose = nt_errors.ERROR_MESSAGES[key][1] \n            return 'MGMT SessionError: code: 0x%x - %s - %s' % (self.error_code, error_msg_short, error_msg_verbose)\n        else:\n            return 'MGMT SessionError: unknown error code: 0x%x' % self.error_code",
  "class rpc_if_id_p_t_array(NDRUniConformantArray):\n    item = PRPC_IF_ID",
  "class rpc_if_id_vector_t(NDRSTRUCT):\n    structure = (\n        ('count',ULONG),\n        ('if_id',rpc_if_id_p_t_array),\n    )\n    structure64 = (\n        ('count',ULONGLONG),\n        ('if_id',rpc_if_id_p_t_array),\n    )",
  "class rpc_if_id_vector_p_t(NDRPOINTER):\n    referent = (\n        ('Data', rpc_if_id_vector_t),\n    )",
  "class inq_if_ids(NDRCALL):\n    opnum = 0\n    structure = (\n    )",
  "class inq_if_idsResponse(NDRCALL):\n    structure = (\n       ('if_id_vector', rpc_if_id_vector_p_t),\n       ('status', error_status),\n    )",
  "class inq_stats(NDRCALL):\n    opnum = 1\n    structure = (\n       ('count', ULONG),\n    )",
  "class inq_statsResponse(NDRCALL):\n    structure = (\n       ('count', ULONG),\n       ('statistics', DWORD_ARRAY),\n       ('status', error_status),\n    )",
  "class is_server_listening(NDRCALL):\n    opnum = 2\n    structure = (\n    )",
  "class is_server_listeningResponse(NDRCALL):\n    structure = (\n       ('status', error_status),\n    )",
  "class stop_server_listening(NDRCALL):\n    opnum = 3\n    structure = (\n    )",
  "class stop_server_listeningResponse(NDRCALL):\n    structure = (\n       ('status', error_status),\n    )",
  "class inq_princ_name(NDRCALL):\n    opnum = 4\n    structure = (\n       ('authn_proto', ULONG),\n       ('princ_name_size', ULONG),\n    )",
  "class inq_princ_nameResponse(NDRCALL):\n    structure = (\n       ('princ_name', NDRUniConformantVaryingArray),\n       ('status', error_status),\n    )",
  "def hinq_if_ids(dce):\n    request = inq_if_ids()\n    return dce.request(request)",
  "def hinq_stats(dce, count = 4):\n    request = inq_stats()\n    request['count'] = count\n    return dce.request(request)",
  "def his_server_listening(dce):\n    request = is_server_listening()\n    return dce.request(request, checkError=False)",
  "def hstop_server_listening(dce):\n    request = stop_server_listening()\n    return dce.request(request)",
  "def hinq_princ_name(dce, authn_proto=0, princ_name_size=1):\n    request = inq_princ_name()\n    request['authn_proto'] = authn_proto\n    request['princ_name_size'] = princ_name_size\n    return dce.request(request, checkError=False)",
  "def __init__(self, error_string=None, error_code=None, packet=None):\n        DCERPCException.__init__(self, error_string, error_code, packet)",
  "def __str__( self ):\n        key = self.error_code\n        if key in nt_errors.ERROR_MESSAGES:\n            error_msg_short = nt_errors.ERROR_MESSAGES[key][0]\n            error_msg_verbose = nt_errors.ERROR_MESSAGES[key][1] \n            return 'MGMT SessionError: code: 0x%x - %s - %s' % (self.error_code, error_msg_short, error_msg_verbose)\n        else:\n            return 'MGMT SessionError: unknown error code: 0x%x' % self.error_code",
  "class NDRENUM(_NDRENUM):\n    def dump(self, msg = None, indent = 0):\n        if msg is None:\n            msg = self.__class__.__name__\n        if msg != '':\n            print(msg, end=' ')\n\n        try:\n            print(\" %s\" % self.enumItems(self.fields['Data']).name, end=' ')\n        except:\n            print(\" %s\" % hex(self.fields['Data']), end=' ')",
  "class TS_WCHAR(WSTR):\n    commonHdr = (\n        ('ActualCount','<L=len(Data)//2'),\n    )\n    commonHdr64 = (\n        ('ActualCount','<Q=len(Data)//2'),\n    )\n    structure = (\n        ('Data',':'),\n    )\n    def __getitem__(self, key):\n        if key == 'Data':\n            return self.fields[key].decode('utf-16le')\n        else:\n            return NDR.__getitem__(self,key)",
  "class TS_LPWCHAR(NDRPOINTER):\n    referent = (\n        ('Data', TS_WCHAR),\n    )",
  "class TS_CHAR(STR):\n    commonHdr = (\n        ('ActualCount','<L=len(Data)'),\n    )\n    commonHdr64 = (\n        ('ActualCount','<Q=len(Data)'),\n    )\n    structure = (\n        ('Data',':'),\n    )\n    def __getitem__(self, key):\n        if key == 'Data':\n            return self.fields[key]\n        else:\n            return NDR.__getitem__(self,key)",
  "class SYSTEM_TIMESTAMP(NDRHYPER):\n    def __getitem__(self, key):\n        if key == 'Data':\n            return datetime.fromtimestamp(getUnixTime(int(str(self.fields[key]))))\n        else:\n            return NDR.__getitem__(self,key)",
  "class TS_UNICODE_STRING(NDRSTRUCT):\n    '''\n    typedef struct _TS_UNICODE_STRING {\n        USHORT Length;\n        USHORT MaximumLength;\n        #ifdef __midl\n            [size_is(MaximumLength),length_is(Length)]PWSTR Buffer;\n        #else\n            PWSTR Buffer;\n        #endif\n    } TS_UNICODE_STRING;\n    '''\n    structure = (\n        ('Length', USHORT),\n        ('MaximumLength', USHORT),\n        ('Buffer', LPWSTR),\n    )",
  "class TS_LPCHAR(NDRPOINTER):\n    referent = (\n        ('Data', TS_CHAR),\n    )",
  "class TS_WCHAR_STRIPPED(TS_WCHAR):\n    def __getitem__(self, key):\n        if key == 'Data':\n            return self.fields[key].decode('utf-16le').strip('\\x00')\n        else:\n            return NDR.__getitem__(self,key)",
  "class WIDESTR_STRIPPED(WIDESTR):\n    length = None\n    def __getitem__(self, key):\n        if key == 'Data':\n            return self.fields[key].decode('utf-16le').rstrip('\\x00')\n        else:\n            return NDR.__getitem__(self,key)\n    def getDataLen(self, data, offset=0):\n        if self.length is None:\n            return super().getDataLen(data, offset)\n        return self.length * 2",
  "class WSTR_STRIPPED(WSTR):\n    def __getitem__(self, key):\n        if key == 'Data':\n            return self.fields[key].decode('utf-16le').rstrip('\\x00')\n        else:\n            return NDR.__getitem__(self,key)",
  "class LPWCHAR_STRIPPED(NDRPOINTER):\n    referent = ( \n        ('Data', WIDESTR_STRIPPED),\n    )",
  "class LONG_ARRAY(NDRUniConformantArray):\n    item = 'L'\n    def __getitem__(self, key):\n        if key == 'Data':\n            return b''.join(self.fields[key])\n        else:\n            return NDR.__getitem__(self,key)",
  "class UCHAR_ARRAY(NDRUniConformantArray):\n    item = 'c'",
  "class LPUCHAR_ARRAY(NDRPOINTER):\n    referent = (\n        ('Data', UCHAR_ARRAY),\n    )",
  "class WCHAR_ARRAY_32(WIDESTR_STRIPPED):\n    length = 32",
  "class WCHAR_ARRAY_256(WIDESTR_STRIPPED):\n    length = 256",
  "class WCHAR_ARRAY_33(WIDESTR_STRIPPED):\n    length = 33",
  "class WCHAR_ARRAY_21(WIDESTR_STRIPPED):\n    length = 21",
  "class WCHAR_ARRAY_18(WIDESTR_STRIPPED):\n    length = 18",
  "class WCHAR_ARRAY_4(WIDESTR_STRIPPED):\n    length = 4",
  "class WCHAR_CLIENTNAME_LENGTH(WIDESTR_STRIPPED):\n    length = CLIENTNAME_LENGTH + 1",
  "class WCHAR_DOMAIN_LENGTH(WIDESTR_STRIPPED):\n    length = DOMAIN_LENGTH + 1",
  "class WCHAR_USERNAME_LENGTH(WIDESTR_STRIPPED):\n    length = USERNAME_LENGTH + 1",
  "class WCHAR_PASSWORD_LENGTH(WIDESTR_STRIPPED):\n    length = PASSWORD_LENGTH + 1",
  "class WCHAR_DIRECTORY_LENGTH(WIDESTR_STRIPPED):\n    length = DIRECTORY_LENGTH + 1",
  "class WCHAR_INITIALPROGRAM_LENGTH(WIDESTR_STRIPPED):\n    length = INITIALPROGRAM_LENGTH + 1",
  "class WCHAR_CLIENTADDRESS_LENGTH(WIDESTR_STRIPPED):\n    length = CLIENTADDRESS_LENGTH + 1",
  "class WCHAR_IMEFILENAME_LENGTH(WIDESTR_STRIPPED):\n    length = IMEFILENAME_LENGTH + 1",
  "class WCHAR_CLIENTLICENSE_LENGTH(WIDESTR_STRIPPED):\n    length = CLIENTLICENSE_LENGTH + 1",
  "class WCHAR_CLIENTMODEM_LENGTH(WIDESTR_STRIPPED):\n    length = CLIENTMODEM_LENGTH + 1",
  "class WCHAR_AUDIODRIVENAME_LENGTH(WIDESTR_STRIPPED):\n    length = AUDIODRIVENAME_LENGTH",
  "class WCHAR_CLIENT_PRODUCT_ID_LENGTH(WIDESTR_STRIPPED):\n    length = CLIENT_PRODUCT_ID_LENGTH",
  "class WCHAR_NASIFILESERVER_LENGTH(WIDESTR_STRIPPED):\n    length = NASIFILESERVER_LENGTH + 1",
  "class WCHAR_CALLBACK_LENGTH(WIDESTR_STRIPPED):\n    length = CALLBACK_LENGTH + 1",
  "class WCHAR_MAX_BR_NAME(WIDESTR_STRIPPED):\n    length = MAX_BR_NAME",
  "class WCHAR_WINSTATIONCOMMENT_LENGTH(WIDESTR_STRIPPED):\n    length = WINSTATIONCOMMENT_LENGTH + 1",
  "class DCERPCSessionError(DCERPCException):\n    def __init__(self, error_string=None, error_code=None, packet=None):\n        DCERPCException.__init__(self, error_string, error_code, packet)\n    def __str__( self ):\n        key = self.error_code & 0xffff\n        if key in system_errors.ERROR_MESSAGES:\n            error_msg_short = system_errors.ERROR_MESSAGES[key][0]\n            error_msg_verbose = system_errors.ERROR_MESSAGES[key][1] \n            return 'TSTS SessionError: code: 0x%x - %s - %s' % (self.error_code, error_msg_short, error_msg_verbose)\n        else:\n            return 'TSTS SessionError: unknown error code: 0x%x' % self.error_code",
  "def ZEROPAD(data, size = None):\n    if size is None:\n        size = len(data)+1\n    assert len(data) <= size, 'Invalid data size!'\n    data += '\\0' * ( size - len(data) )\n    return data",
  "def getUnixTime(t):\n    t -= 116444736000000000\n    t /= 10000000\n    return t",
  "def enum2value(enum, key):\n    return enum.enumItems._value2member_map_[key]._name_",
  "class SID(TS_CHAR):\n    def known_sid(self, sid):\n        knownSids = {\n            'S-1-5-10': r'SELF',\n            'S-1-5-13': r'TERMINAL SERVER USER',\n            'S-1-5-11': r'Authenticated Users',\n            'S-1-5-12': r'RESTRICTED',\n            'S-1-5-14': r'Authenticated Users',\n            'S-1-5-15': r'This Organization',\n            'S-1-5-17': r'IUSR',\n            'S-1-5-18': r'SYSTEM',\n            'S-1-5-19': r'LOCAL SERVICE',\n            'S-1-5-20': r'NETWORK SERVICE',\n        }\n        if sid.startswith('S-1-5-90-0-') and len(sid.split('-')) == 6:\n            return 'DWM-{}'.format(int(sid.split('-')[-1]))\n        elif sid.startswith('S-1-5-96-0-') and len(sid.split('-')) == 6:\n            return 'UMFD-{}'.format(int(sid.split('-')[-1]))\n        elif sid in knownSids:\n            return knownSids[sid]\n        return sid\n    def __getitem__(self, key):\n        if key == 'Data':\n            sid = format_sid(self.fields[key])\n            if not len(sid):\n                return ''\n            return self.known_sid(sid)\n        else:\n            return NDR.__getitem__(self,key)",
  "class context_handle(NDRSTRUCT):\n    structure = (\n         ('context_handle_attributes',ULONG),\n         ('context_handle_uuid',UUID),\n    )\n    def getUUID(self):\n        return bin_to_string(self['context_handle_uuid'])\n    def tuple(self):\n        return (bin_to_string(self['context_handle_uuid']),self['context_handle_attributes'])\n    def from_tuple(self, tup):\n        self['context_handle_uuid'], self['context_handle_attributes'] = (string_to_bin(tup[0]), tup[1])\n    def __init__(self, data=None, isNDR64=False):\n        NDRSTRUCT.__init__(self, data, isNDR64)\n        self['context_handle_uuid'] = b'\\x00'*16\n    def isNull(self):\n        return self['context_handle_uuid'] == b'\\x00'*16\n    def __str__(self):\n        return bin_to_string(self['context_handle_uuid'])",
  "class handle_t(NDRSTRUCT):\n    structure =  (\n        ('Data','20s=b\"\"'),\n    )\n    def getAlignment(self):\n        if self._isNDR64 is True:\n            return 8\n        else:\n            return 4",
  "class pHandle(NDRPOINTER):\n    referent =  (\n        ('Data', handle_t),\n    )",
  "class MSGBOX_ENUM(NDRENUM):\n    class enumItems(Enum):\n        IDABORT     = 3     # The Abort button was selected.\n        IDCANCEL    = 2     # The Cancel button was selected.\n        IDIGNORE    = 5     # The Ignore button was selected.\n        IDNO        = 7     # The No button was selected.\n        IDOK        = 1     # The OK button was selected.\n        IDRETRY     = 4     # The Retry button was selected.\n        IDYES       = 6     # The Yes button was selected.\n        IDASYNC     = 32001 # The bDoNotWait parameter was TRUE, so the function returned without waiting for a response.\n        IDTIMEOUT   = 32000",
  "class ShutdownFlags(NDRENUM):\n    structure = (\n        ('Data','<L'),\n    )\n    class enumItems(Enum):\n        WSD_LOGOFF   = 0x00000001 # Forces sessions to logoff.\n        WSD_SHUTDOWN = 0x00000002 # Shuts down the system.\n        WSD_REBOOT   = 0x00000004 # Reboots after shutdown.\n        WSD_POWEROFF = 0x00000008",
  "class HotKeyModifiers(NDRENUM):\n    structure = (\n        ('Data', '<H'),\n    )\n    NONE        = 0\n    Alt         = 1     # MOD_ALT\n    Control     = 2     # MOD_CONTROL\n    Shift       = 4     # MOD_SHIFT\n    WindowsKey  = 8",
  "class EventFlags(NDRENUM):\n    structure = (\n        ('Data','<L'),\n    )\n    class enumItems(Enum):\n        WEVENT_NONE         = 0x00000000    # The client requests to clear its event wait block. This MUST be called when completing waiting for the event. When RpcWinStationCloseServer is called for hServer, this method and mask value is called on the client's behalf.\n        WEVENT_CREATE       = 0x00000001    # Wait for a new session to be created.\n        WEVENT_DELETE       = 0x00000002    # Wait for an existing session to be deleted.\n        WEVENT_RENAME       = 0x00000004    # Wait for a session to be renamed.\n        WEVENT_CONNECT      = 0x00000008    # The session connected to a client.\n        WEVENT_DISCONNECT   = 0x00000010    # A client disconnected from the session.\n        WEVENT_LOGON        = 0x00000020    # A user logged on to the session.\n        WEVENT_LOGOFF       = 0x00000040    # A user logged off from the session.\n        WEVENT_STATECHANGE  = 0x00000080    # The session state changed.\n        WEVENT_LICENSE      = 0x00000100    # The license state changed.<183>\n        WEVENT_ALL          = 0x7fffffff    # Wait for all event types.\n        WEVENT_FLUSH        = 0x80000000",
  "class ADDRESSFAMILY_ENUM(NDRENUM):\n    structure = (\n        ('Data','<L'),\n    )\n    class enumItems(Enum):\n        AppleTalk               = 16\n        Atm                     = 22\n        Banyan                  = 21\n        Ccitt                   = 10\n        Chaos                   = 5\n        Cluster                 = 24\n        ControllerAreaNetwork   = 65537\n        DataKit                 = 9\n        DataLink                = 13\n        DecNet                  = 12\n        Ecma                    = 8\n        FireFox                 = 19\n        HyperChannel            = 15\n        Ieee12844               = 25\n        ImpLink                 = 3\n        InterNetwork            = 2\n        InterNetworkV6          = 23\n        Ipx                     = 6\n        Irda                    = 26\n        Iso                     = 7\n        Lat                     = 14\n        Max                     = 29\n        NetBios                 = 17\n        NetworkDesigners        = 28\n        NS                      = 6\n        Osi                     = 7\n        Packet                  = 65536\n        Pup                     = 4\n        Sna                     = 11\n        Unix\t                = 1\t\n        Unspecified             = 0\n        VoiceView               = 18",
  "class WINSTATIONNAME(WIDESTR_STRIPPED):\n    length = WINSTATIONNAME_LENGTH + 1",
  "class DLLNAME(WIDESTR):\n    def getDataLen(self, data, offset=0):\n        return DLLNAME_LENGTH + 1",
  "class PDLLNAME(NDRPOINTER):\n    referent = (\n        ('Data', DLLNAME),\n    )",
  "class DEVICENAME(WIDESTR):\n    def getDataLen(self, data, offset=0):\n        return DEVICENAME_LENGTH + 1",
  "class PDEVICENAME(NDRPOINTER):\n    referent = (\n        ('Data', DEVICENAME),\n    )",
  "class CLIENTDATANAME(STR):\n    def getDataLen(self, data, offset=0):\n        return CLIENTDATANAME_LENGTH + 1",
  "class PCLIENTDATANAME(NDRPOINTER):\n    referent = (\n        ('Data', CLIENTDATANAME),\n    )",
  "class WINSTATIONINFOCLASS(NDRENUM):\n    class enumItems(Enum):\n        WinStationCreateData                = 0\n        WinStationConfiguration             = 1\n        WinStationPdParams                  = 2\n        WinStationWd                        = 3\n        WinStationPd                        = 4\n        WinStationPrinter                   = 5\n        WinStationClient                    = 6\n        WinStationModules                   = 7\n        WinStationInformation               = 8\n        WinStationTrace                     = 9\n        WinStationBeep                      = 10\n        WinStationEncryptionOff             = 11\n        WinStationEncryptionPerm            = 12\n        WinStationNtSecurity                = 13\n        WinStationUserToken                 = 14\n        WinStationUnused1                   = 15\n        WinStationVideoData                 = 16\n        WinStationInitialProgram            = 17\n        WinStationCd                        = 18\n        WinStationSystemTrace               = 19\n        WinStationVirtualData               = 20\n        WinStationClientData                = 21\n        WinStationSecureDesktopEnter        = 22\n        WinStationSecureDesktopExit         = 23\n        WinStationLoadBalanceSessionTarget  = 24\n        WinStationLoadIndicator             = 25\n        WinStationShadowInfo                = 26\n        WinStationDigProductId              = 27\n        WinStationLockedState               = 28\n        WinStationRemoteAddress             = 29\n        WinStationIdleTime                  = 30\n        WinStationLastReconnectType         = 31\n        WinStationDisallowAutoReconnect     = 32\n        WinStationUnused2                   = 33\n        WinStationUnused3                   = 34\n        WinStationUnused4                   = 35\n        WinStationUnused5                   = 36\n        WinStationReconnectedFromId         = 37\n        WinStationEffectsPolicy             = 38\n        WinStationType                      = 39\n        WinStationInformationEx             = 40",
  "class WINSTATIONSTATECLASS(NDRENUM):\n    structure = (\n        ('Data', '<L'),\n    )\n    class enumItems(Enum):\n        State_Active        = 0 # A user is logged on to a session and the client is connected.\n        State_Connected     = 1 # A client is connected to a session but the user has not yet logged on.\n        State_ConnectQuery  = 2 # A session is in the process of connecting to a client.\n        State_Shadow        = 3 # A session is shadowing another session\n        State_Disconnected  = 4 # A user is logged on to the session but the client is currently disconnected from the server.\n        State_Idle          = 5 # A session is waiting for a client to connect to the server.\n        State_Listen        = 6 # A listener is waiting for connections from the Terminal Services client.\n        State_Reset         = 7 # A session is being reset. As a result, the user is logged off, the session is terminated, and the client is disconnected.\n        State_Down          = 8 # A session is currently tearing down or is in the down state, indicating an error.\n        State_Init          = 9",
  "class SDCLASS(NDRENUM):\n    class enumItems(Enum):\n        SdNone          = 0\n        SdConsole       = 1\n        SdNetwork       = 2\n        SdAsync         = 3\n        SdOemTransport  = 4",
  "class SHADOWCLASS(NDRENUM):\n    class enumItems(Enum):\n        Shadow_Disable                  = 0\n        Shadow_EnableInputNotify        = 1\n        Shadow_EnableInputNoNotify      = 2\n        Shadow_EnableNoInputNotify      = 3\n        Shadow_EnableNoInputNoNotify    = 4",
  "class RECONNECT_TYPE(NDRENUM):\n    class enumItems(Enum):\n        NeverReconnected = 0\n        ManualReconnect  = 1\n        AutoReconnect    = 2",
  "class PRECONNECT_TYPE(NDRPOINTER):\n    referent = (\n        ('Data', RECONNECT_TYPE),\n    )",
  "class UINT_PTR(NDRPOINTER):\n    referent = ( \n        ('Data', UINT),\n    )",
  "class SESSIONTYPE(NDRENUM):\n    class enumItems(Enum):\n        SESSIONTYPE_UNKNOWN         = 0 # The type of the session cannot be determined.\n        SESSIONTYPE_SERVICES        = 1 # The session is used only to run the operating system services, and that no user can be logged on to the session.\n        SESSIONTYPE_LISTENER        = 2 # The session is used only to run the Terminal Services listeners, and that no user can be logged on to the session.\n        SESSIONTYPE_REGULARDESKTOP  = 3 # The session is connected by using Terminal Services and is running the standard shell.\n        SESSIONTYPE_ALTERNATESHELL  = 4 # The session is connected by using Terminal Services and is running an alternate shell instead of the standard shell\n        SESSIONTYPE_REMOTEAPP       = 5 # The session is a RAIL (Remote Applications Integrated Locally) session as defined in [MS-RDPERP].\n        SESSIONTYPE_MEDIACENTEREXT  = 6",
  "class SHADOW_CONTROL_REQUEST(NDRENUM):\n    class enumItems(Enum):\n        SHADOW_CONTROL_REQUEST_VIEW         = 0 # The shadow request is for a view-only session. User input is not being requested.\n        SHADOW_CONTROL_REQUEST_TAKECONTROL  = 1 # User input control is being requested.\n        SHADOW_CONTROL_REQUEST_Count        = 2",
  "class SHADOW_PERMISSION_REQUEST(NDRENUM):\n    class enumItems(Enum):\n        SHADOW_PERMISSION_REQUEST_SILENT            = 0 # Permission is not requested.\n        SHADOW_PERMISSION_REQUEST_REQUESTPERMISSION = 1 # User permission will be requested before the shadow session begins.\n        SHADOW_PERMISSION_REQUEST_Count             = 2",
  "class SHADOW_REQUEST_RESPONSE(NDRENUM):\n    class enumItems(Enum):\n        SHADOW_REQUEST_RESPONSE_ALLOW                                   = 0 # The user has granted the request for permission to shadow the session.\n        SHADOW_REQUEST_RESPONSE_DECLINE                                 = 1 # The user has declined the request for permission to shadow the session.\n        SHADOW_REQUEST_RESPONSE_POLICY_PERMISSION_REQUIRED              = 2 # Permission was not requested, but group policy specifies that permission is required.\n        SHADOW_REQUEST_RESPONSE_POLICY_DISABLED                         = 3 # Shadowing has been disabled by group policy.\n        SHADOW_REQUEST_RESPONSE_POLICY_VIEW_ONLY                        = 4 # A request for control was made, but group policy exclusively allows view-only shadowing.\n        SHADOW_REQUEST_RESPONSE_POLICY_VIEW_ONLY_PERMISSION_REQUIRED    = 5 # A request was made to take control without requesting permission,\n                                                                            # but group policy exclusively allows viewonly shadowing and also requires permission.\n        SHADOW_REQUEST_RESPONSE_SESSION_ALREADY_CONTROLLED              = 6",
  "class SESSION_FILTER(NDRENUM):\n    class enumItems(Enum):\n        SF_SERVICES_SESSION_POPUP = 0",
  "class PROTOCOLSTATUS_INFO_TYPE(NDRENUM):\n    class enumItems(Enum):\n        PROTOCOLSTATUS_INFO_BASIC    = 0\n        PROTOCOLSTATUS_INFO_EXTENDED = 1",
  "class QUERY_SESSION_DATA_TYPE(NDRENUM):\n    class enumItems(Enum):\n        QUERY_SESSION_DATA_MODULE               = 0\n        QUERY_SESSION_DATA_WDCONFIG             = 1\n        QUERY_SESSION_DATA_VIRTUALDATA          = 2\n        QUERY_SESSION_DATA_LICENSE              = 3\n        QUERY_SESSION_DATA_DEVICEID             = 4\n        QUERY_SESSION_DATA_LICENSE_VALIDATION   = 5",
  "class SESSIONENUM_LEVEL1(NDRSTRUCT):\n    structure = (\n        ('SessionId', LONG),\n        ('State', WINSTATIONSTATECLASS),\n        ('Name', WCHAR_ARRAY_33)\n    )",
  "class SESSIONENUM_LEVEL2(NDRSTRUCT):\n    structure = (\n        ('SessionId', LONG),\n        ('State', WINSTATIONSTATECLASS),\n        ('Name', WCHAR_ARRAY_33), # WCHAR Name[33]\n        ('Source', ULONG),\n        ('bFullDesktop', BOOLEAN),\n        ('SessionType', GUID),\n    )",
  "class SESSIONENUM_LEVEL3(NDRSTRUCT):\n    structure = (\n        ('SessionId', LONG),\n        ('State', WINSTATIONSTATECLASS),\n        ('Name', WCHAR_ARRAY_33),\n        ('Source', ULONG),\n        ('bFullDesktop', BOOLEAN),\n        ('SessionType', GUID),\n        ('ProtoDataSize', ULONG),\n        ('pProtocolData', UCHAR),\n    )",
  "class SessionInfo(NDRUNION):\n    commonHdr = (\n        ('tag', DWORD),\n    )\n    union = {\n        1: ('SessionEnum_Level1', SESSIONENUM_LEVEL1),\n        2: ('SessionEnum_Level2', SESSIONENUM_LEVEL2),\n        3: ('SessionEnum_Level3', SESSIONENUM_LEVEL3),\n    }",
  "class SessionInfo_STRUCT(NDRSTRUCT):\n    structure = (\n        ('Level', DWORD),\n        ('SessionInfo', SessionInfo),\n    )",
  "class SESSIONENUM(NDRUniConformantArray):\n    item = SessionInfo_STRUCT",
  "class PSESSIONENUM(NDRPOINTER):\n    referent = (\n        ('Data', SESSIONENUM),\n    )",
  "class EXECENVDATA_LEVEL1(NDRSTRUCT):\n    structure = (\n        ('ExecEnvId', LONG),\n        ('State', WINSTATIONSTATECLASS),\n        ('SessionName', WCHAR_ARRAY_33),\n    )",
  "class PEXECENVDATA_LEVEL1(NDRPOINTER):\n    referent =  ( \n        ('Data', EXECENVDATA_LEVEL1),\n    )",
  "class EXECENVDATA_LEVEL2(NDRSTRUCT):\n    structure = (\n        ('ExecEnvId', LONG),\n        ('State', WINSTATIONSTATECLASS),\n        ('SessionName', WCHAR_ARRAY_33),\n        ('AbsSessionId', LONG),\n        ('HostName', WCHAR_ARRAY_33),\n        ('UserName', WCHAR_ARRAY_33),\n        ('DomainName', WCHAR_ARRAY_33),\n        ('FarmName', WCHAR_ARRAY_33),\n    )",
  "class PEXECENVDATA_LEVEL2(NDRPOINTER):\n    referent =  ( \n        ('Data', EXECENVDATA_LEVEL2),\n    )",
  "class ExecEnvData(NDRUNION):\n    commonHdr = (\n        ('tag', DWORD),\n    )\n    union = {\n        1: ('ExecEnvEnum_Level1', EXECENVDATA_LEVEL1),\n        2: ('ExecEnvEnum_Level2', EXECENVDATA_LEVEL2),\n    }",
  "class ExecEnvData_STRUCT(NDRSTRUCT):\n    structure = (\n        ('Level', DWORD),\n        ('ExecEnvData', ExecEnvData),\n    )",
  "class EXECENVDATA(NDRUniConformantArray):\n    item = ExecEnvData_STRUCT",
  "class PEXECENVDATA(NDRPOINTER):\n    referent =  ( \n        ('Data', EXECENVDATA),\n    )",
  "class EXECENVDATAEX_LEVEL1(NDRSTRUCT):\n    #FIXME this structure does not work :(\n    '''\n        structure = (\n            ('ExecEnvId', LONG),\n            ('State', WINSTATIONSTATECLASS),\n            ('AbsSessionId', LONG),\n            ('pszSessionName', WIDESTR),\n            ('pszHostName', WIDESTR),\n            ('pszUserName', WIDESTR),\n            ('pszFarmName', WIDESTR),\n        )\n    '''\n    pass",
  "class ExecEnvDataEx(NDRUNION):\n    commonHdr = (\n        ('tag', DWORD),\n    )\n    union = {\n        1: ('ExecEnvEnum_Level1', EXECENVDATAEX_LEVEL1),\n    }",
  "class EXECENVDATAEX(NDRUniConformantArray):\n    item = ExecEnvDataEx",
  "class PEXECENVDATAEX(NDRPOINTER):\n    referent =  ( \n        ('Data', EXECENVDATAEX),\n    )",
  "class LISTENERENUM_LEVEL1(NDRSTRUCT):\n    structure = (\n        ('Id', LONG),\n        ('bListening', BOOL),\n        ('Name', WCHAR_ARRAY_33),\n    )",
  "class ListenerInfo(NDRUNION):\n    commonHdr = (\n        ('tag', DWORD),\n    )\n    union = {\n        1: ('ListenerEnum_Level1', LISTENERENUM_LEVEL1),\n    }",
  "class ListenerInfo_STRUCT(NDRSTRUCT):\n    structure = (\n        ('Level', DWORD),\n        ('ListenerInfo', ListenerInfo),\n    )",
  "class LISTENERENUM(NDRUniConformantArray):\n    item = ListenerInfo_STRUCT",
  "class PLISTENERENUM(NDRPOINTER):\n    referent = (\n        ('Data', LISTENERENUM),\n    )",
  "class LSMSESSIONINFORMATION(NDRSTRUCT):\n    structure = (\n        ('pszUserName', LPWCHAR_STRIPPED),\n        ('pszDomain', LPWCHAR_STRIPPED),\n        ('pszTerminalName', LPWCHAR_STRIPPED),\n        ('SessionState', WINSTATIONSTATECLASS),\n        ('DesktopLocked', BOOLEAN),\n        ('ConnectTime', SYSTEM_TIMESTAMP),\n        ('DisconnectTime', SYSTEM_TIMESTAMP),\n        ('LogonTime', SYSTEM_TIMESTAMP),\n    )",
  "class TS_SYSTEMTIME(NDRSTRUCT):\n    structure = (\n        ('wYear', USHORT),\n        ('wMonth', USHORT),\n        ('wDayOfWeek', USHORT),\n        ('wDay', USHORT),\n        ('wHour', USHORT),\n        ('wMinute', USHORT),\n        ('wSecond', USHORT),\n        ('wMilliseconds', USHORT),\n    )",
  "class TS_TIME_ZONE_INFORMATION(NDRSTRUCT):\n    structure = (\n        ('Bias', ULONG),\n        ('StandardName', WCHAR_ARRAY_32),\n        ('StandardDate', TS_SYSTEMTIME),\n        ('StandardBias', ULONG),\n        ('DaylightName', WCHAR_ARRAY_32),\n        ('DaylightDate', TS_SYSTEMTIME),\n        ('DaylightBias', ULONG),\n    )",
  "class WINSTATIONCLIENT(NDRSTRUCT):\n    class FLAGS(NDRSTRUCT):\n        # a little hack to extrack bit flags\n        structure = (\n            ('flags','6s=b\"\"'),\n        )\n        def __getitem__(self, key):\n            if key == 'flags':\n                flagsInt = int.from_bytes(self.fields[key][2:],'little')\n                keys = {'fTextOnly'           : False,\n                        'fDisableCtrlAltDel'  : False,\n                        'fMouse'              : False,\n                        'fDoubleClickDetect'  : False,\n                        'fINetClient'         : False,\n                        'fPromptForPassword'  : False,\n                        'fMaximizeShell'      : False,\n                        'fEnableWindowsKey'   : False,\n                        'fRemoteConsoleAudio' : False,\n                        'fPasswordIsScPin'    : False,\n                        'fNoAudioPlayback'    : False,\n                        'fUsingSavedCreds'    : False,\n                        'fRestrictedLogon'    : False\n                }\n                for k in keys:\n                    keys[k] = bool(flagsInt & 1)\n                    flagsInt >>= 1\n                return keys\n            else:\n                return NDR.__getitem__(self,key)\n\n    structure = (\n        # I have no idea to to do it properly, so i'm parsing bit flags inside another structure class\n        ('flags', FLAGS),\n        ('ClientName', WCHAR_CLIENTNAME_LENGTH),\n        ('Domain', WCHAR_DOMAIN_LENGTH),\n        ('UserName', WCHAR_USERNAME_LENGTH),\n        ('Password', WCHAR_PASSWORD_LENGTH),\n        ('WorkDirectory', WCHAR_DIRECTORY_LENGTH),\n        ('InitialProgram', WCHAR_INITIALPROGRAM_LENGTH),\n        ('SerialNumber', ULONG),\n        ('EncryptionLevel', BYTE),\n        ('ClientAddressFamily', ADDRESSFAMILY_ENUM),\n        ('ClientAddress', WCHAR_CLIENTADDRESS_LENGTH),\n        ('HRes', USHORT),\n        ('VRes', USHORT),\n        ('ColorDepth', USHORT),\n        ('ProtocolType', USHORT),\n        ('KeyboardLayout', ULONG),\n        ('KeyboardType', ULONG),\n        ('KeyboardSubType', ULONG),\n        ('KeyboardFunctionKey', ULONG),\n        ('imeFileName', WCHAR_IMEFILENAME_LENGTH),\n        ('ClientDirectory', WCHAR_DIRECTORY_LENGTH),\n        ('ClientLicense', WCHAR_CLIENTLICENSE_LENGTH),\n        ('ClientModem', WCHAR_CLIENTMODEM_LENGTH),\n        ('ClientBuildNumber', ULONG),\n        ('ClientHardwareId', ULONG),\n        ('ClientProductId', USHORT),\n        ('OutBufCountHost', USHORT),\n        ('OutBufCountClient', USHORT),\n        ('OutBufLength', USHORT),\n        ('AudioDriverName', WCHAR_AUDIODRIVENAME_LENGTH),\n        ('ClientTimeZone', TS_TIME_ZONE_INFORMATION),\n        ('ClientSessionId', ULONG),\n        ('clientDigProductId', WCHAR_CLIENT_PRODUCT_ID_LENGTH),\n        ('PerformanceFlags', ULONG),\n        ('ActiveInputLocale', ULONG),\n    )",
  "class PWINSTATIONCLIENT(NDRPOINTER):\n    referent = (\n        ('Data', WINSTATIONCLIENT),\n    )",
  "class TS_COUNTER_HEADER(NDRSTRUCT):\n    structure = (\n        ('dwCounterID', DWORD),\n        ('bResult', BOOLEAN),\n    )",
  "class TS_COUNTER(NDRSTRUCT):\n    structure = (\n        ('counterHead', TS_COUNTER_HEADER),\n        ('dwValue', DWORD),\n        ('startTime', LARGE_INTEGER),\n    )",
  "class TS_COUNTER_ARRAY(NDRUniConformantArray):\n    item = TS_COUNTER",
  "class PTS_COUNTER(NDRPOINTER):\n    referent = (\n        ('Data', TS_COUNTER_ARRAY),\n    )",
  "class SESSIONFLAGS(NDRENUM):\n    structure = (\n        ('Data', '<L'),\n    )\n    class enumItems(Enum):\n        WTS_SESSIONSTATE_UNKNOWN    = 0xFFFFFFFF\n        WTS_SESSIONSTATE_LOCK       = 0x00000000\n        WTS_SESSIONSTATE_UNLOCK     = 0x00000001",
  "class LSM_SESSIONINFO_EX_LEVEL1(NDRSTRUCT):\n    structure = (\n        ('SessionState', WINSTATIONSTATECLASS),\n        ('SessionFlags', SESSIONFLAGS),\n        ('SessionName', WCHAR_ARRAY_33),\n        ('DomainName', WCHAR_ARRAY_18),\n        ('UserName', WCHAR_ARRAY_21),\n        ('ConnectTime', SYSTEM_TIMESTAMP),\n        ('DisconnectTime', SYSTEM_TIMESTAMP),\n        ('LogonTime', SYSTEM_TIMESTAMP),\n        ('LastInputTime', SYSTEM_TIMESTAMP),\n        ('ProtocolDataSize', ULONG),\n        ('ProtocolData', TS_LPCHAR),\n    )",
  "class LSM_SESSIONINFO_EX(NDRUNION):\n    commonHdr = (\n        ('tag', DWORD),\n    )\n    union = {\n        1: ('LSM_SessionInfo_Level1', LSM_SESSIONINFO_EX_LEVEL1),\n    }",
  "class PLSMSESSIONINFORMATION_EX(NDRPOINTER):\n    referent = (\n        ('Data', LSM_SESSIONINFO_EX ),\n    )",
  "class TNotificationId(NDRENUM):\n    structure = (\n        ('Data', '<L'),\n    )\n    class enumItems(Enum):\n        WTS_NOTIFY_NONE                 = 0x0        #No notification\n        WTS_NOTIFY_CREATE               = 0x1        #Session creation notification\n        WTS_NOTIFY_CONNECT              = 0x2        #Session connection notification\n        WTS_NOTIFY_DISCONNECT           = 0x4        #Session disconnection notification\n        WTS_NOTIFY_LOGON                = 0x8        #Session logon notification\n        WTS_NOTIFY_LOGOFF               = 0x10       #Session logoff notification\n        WTS_NOTIFY_SHADOW_START         = 0x20       #Session shadow start notification\n        WTS_NOTIFY_SHADOW_STOP          = 0x40       #Session shadow stop notification \n        WTS_NOTIFY_TERMINATE            = 0x80       #Session termination notification\n        WTS_NOTIFY_CONSOLE_CONNECT      = 0x100      #Console session connection notification\n        WTS_NOTIFY_CONSOLE_DISCONNECT   = 0x200      #Console session disconnect notification\n        WTS_NOTIFY_LOCK                 = 0x400      #Session lock notification\n        WTS_NOTIFY_UNLOCK               = 0x800      #Session unlock notification\n        WTS_NOTIFY_ALL                  = 0xffffffff",
  "class SESSION_CHANGE(NDRSTRUCT):\n    structure = (\n        ('SessionId', LONG),\n        ('TNotificationId', TNotificationId),\n    )",
  "class SESSION_CHANGE_ARRAY(NDRUniConformantArray):\n    item = SESSION_CHANGE",
  "class PSESSION_CHANGE(NDRPOINTER):\n    referent = (\n        ('Data', SESSION_CHANGE_ARRAY),\n    )",
  "class CALLBACKCLASS(NDRENUM):\n    structure = (\n        ('Data', '<L'),\n    )\n    class enumItems(Enum):\n        Callback_Disable = 0\n        Callback_Roving  = 1\n        Callback_Fixed   = 2",
  "class USERCONFIG(NDRSTRUCT):\n    class FLAGS(NDRSTRUCT):\n        # a little hack to extrack bit flags\n        structure = (\n            ('flags','7s=b\"\"'),\n        )\n        def __getitem__(self, key):\n            if key == 'flags':\n                # Hope that works as intended. If no, try to parse less data in that 7byte array\n                flagsInt = int.from_bytes(self.fields[key][:],'little')\n                tmp  = [('fInheritAutoLogon'             ,1),\n                        ('fInheritResetBroken'           ,1),\n                        ('fInheritReconnectSame'         ,1),\n                        ('fInheritInitialProgram'        ,1),\n                        ('fInheritCallback'              ,1),\n                        ('fInheritCallbackNumber'        ,1),\n                        ('fInheritShadow'                ,1),\n                        ('fInheritMaxSessionTime'        ,1),\n                        ('fInheritMaxDisconnectionTime'  ,1),\n                        ('fInheritMaxIdleTime'           ,1),\n                        ('fInheritAutoClient'            ,1),\n                        ('fInheritSecurity'              ,1),\n                        ('fPromptForPassword'            ,1),\n                        ('fResetBroken'                  ,1),\n                        ('fReconnectSame'                ,1),\n                        ('fLogonDisabled'                ,1),\n                        ('fWallPaperDisabled'            ,1),\n                        ('fAutoClientDrives'             ,1),\n                        ('fAutoClientLpts'               ,1),\n                        ('fForceClientLptDef'            ,1),\n                        ('fRequireEncryption'            ,1),\n                        ('fDisableEncryption'            ,1),\n                        ('fUnused1'                      ,1),\n                        ('fHomeDirectoryMapRoot'         ,1),\n                        ('fUseDefaultGina'               ,1),\n                        ('fCursorBlinkDisabled'          ,1),\n                        ('fPublishedApp'                 ,1),\n                        ('fHideTitleBar'                 ,1),\n                        ('fMaximize'                     ,1),\n                        ('fDisableCpm'                   ,1),\n                        ('fDisableCdm'                   ,1),\n                        ('fDisableCcm'                   ,1),\n                        ('fDisableLPT'                   ,1),\n                        ('fDisableClip'                  ,1),\n                        ('fDisableExe'                   ,1),\n                        ('fDisableCam'                   ,1),\n                        ('fDisableAutoReconnect'         ,1),\n                        ('ColorDepth'                    ,3),\n                        ('fInheritColorDepth'            ,1),\n                        ('fErrorInvalidProfile'          ,1),\n                        ('fPasswordIsScPin'              ,1),\n                        ('fDisablePNPRedir'              ,1)\n                    ]\n                keys = {}\n                for k,bits in tmp:\n                    if bits == 1:\n                        keys[k] = flagsInt & 1\n                    else:\n                        keys[k] = flagsInt & ((1<<bits)-1)\n                    flagsInt >>= bits\n                return keys\n            else:\n                return NDR.__getitem__(self,key)\n\n    structure = (\n        # I have no idea to to do it properly, so i'm parsing bit flags inside another structure class\n        ('flags', FLAGS),\n        ('UserName', WCHAR_USERNAME_LENGTH),\n        ('Domain', WCHAR_DOMAIN_LENGTH),\n        ('Password', WCHAR_PASSWORD_LENGTH),\n        ('WorkDirectory', WCHAR_DIRECTORY_LENGTH),\n        ('InitialProgram', WCHAR_INITIALPROGRAM_LENGTH),\n        ('CallbackNumber', WCHAR_CALLBACK_LENGTH),\n        ('Callback', CALLBACKCLASS),\n        ('Shadow', SHADOWCLASS),\n        ('MaxConnectionTime', ULONG),\n        ('MaxDisconnectionTime', ULONG),\n        ('MaxIdleTime', ULONG),\n        ('KeyboardLayout', ULONG),\n        ('MinEncryptionLevel', BYTE),\n        ('NWLogonServer', WCHAR_NASIFILESERVER_LENGTH),\n        ('PublishedName', WCHAR_MAX_BR_NAME),\n        ('WFProfilePath', WCHAR_DIRECTORY_LENGTH),\n        ('WFHomeDir', WCHAR_DIRECTORY_LENGTH),\n        ('WFHomeDirDrive', WCHAR_ARRAY_4),\n    )",
  "class OEMId(NDRSTRUCT):\n    structure = (\n        ('OEMId', '4s=\"\"'),\n    )",
  "class WINSTATIONCONFIG(NDRSTRUCT):\n    pass\n    structure = (\n        ('Comment', WCHAR_WINSTATIONCOMMENT_LENGTH),\n        ('User', USERCONFIG),\n        ('OEMId', OEMId),\n    )",
  "class PWINSTATIONCONFIG(NDRPOINTER):\n    referent = (\n        ('Data', WINSTATIONCONFIG),\n    )",
  "class PROTOCOLCOUNTERS(NDRSTRUCT):\n    pass",
  "class CACHE_STATISTICS(NDRSTRUCT):\n    pass",
  "class PROTOCOLSTATUS(NDRSTRUCT):\n    pass",
  "class PPROTOCOLSTATUS(NDRPOINTER):\n    referent = (\n        ('Data', PROTOCOLSTATUS),\n    )",
  "class IPv4ADDRESS(NDRSTRUCT):\n    structure = (\n        ('Data', '<L'),\n    )\n    def __getitem__(self, key):\n        if key == 'Data':\n            x = self.fields[key]\n            y = []\n            while x:\n               y += [str(x & 0xff)]\n               x >>= 8\n            return '.'.join(y)\n        else:\n            return super().__getitem__(key)",
  "class RCM_REMOTEADDRESS_UNION_CASE_IPV4(NDRSTRUCT):\n    class _4CHAR(NDRSTRUCT):\n        structure = (\n            ('sin_zero', '4s=b\"\"'),\n        )    \n    structure = (\n        ('sin_port', USHORT),\n        ('sin_port2', USHORT),\n        ('in_addr', IPv4ADDRESS),\n        ('sin_zero', _4CHAR),\n    )",
  "class RCM_REMOTEADDRESS_UNION_CASE_IPV6(NDRSTRUCT):\n    class _8CHAR(NDRSTRUCT):\n        structure = (\n            ('sin_zero', '8s=b\"\"'),\n        )    \n    structure = (\n        ('sin_port', USHORT),\n        ('in_addr', ULONG),\n        ('sin_zero', _8CHAR),\n        ('sin6_scope_id', ULONG),\n    )",
  "class RCM_REMOTEADDRESS(NDRUNION):\n    commonHdr = (\n        ('tag', USHORT),\n    )\n    union = {\n        2 : ('ipv4', RCM_REMOTEADDRESS_UNION_CASE_IPV4),\n        23: ('ipv6', RCM_REMOTEADDRESS_UNION_CASE_IPV6),\n    }",
  "class pResult_ENUM(NDRENUM):\n    structure = (\n        ('Data', '<L'),\n    )\n    class enumItems(Enum):\n        STATUS_SUCCESS                                      = 0x00000000     # Successful call.\n        STATUS_INVALID_PARAMETER                            = 0xC000000D\n        STATUS_CANCELLED                                    = 0xC0000120     # The server is shutting down.\n        STATUS_INVALID_INFO_CLASS                           = 0xC0000003\n        STATUS_NO_MEMORY                                    = 0xC0000017     # Not enough memory to complete the operation\n        STATUS_ACCESS_DENIED                                = 0xC0000022\n        STATUS_BUFFER_TOO_SMALL                             = 0xC0000023\n        STATUS_NOT_IMPLEMENTED                              = 0xC0000002\n        STATUS_INFO_LENGTH_MISMATCH                         = 0xC0000004\n        STATUS_UNSUCCESSFUL                                 = 0xC0000001\n        STATUS_CTX_WINSTATION_NOT_FOUND                     = 0xC00A0015\n        STATUS_WRONG_PASSWORD                               = 0xC000006A\n        DOES_NOT_EXISTS_OR_INSUFFICIENT_PERMISSIONS         = 0x80071B6E\n        INVALID_PARAMETER2                                  = 0x80070057\n        ERROR_ACCESS_DENIED                                 = 0x80070005\n        ERROR_INVALID_STATE                                 = 0x8007139f\n        ERROR_LOGON_FAILURE                                 = 0x8007052e\n        ERROR_FILE_NOT_FOUND                                = 0x80070002\n        ERROR_STATUS_BUFFER_TOO_SMALL                       = 0x8007007A",
  "class TS_SYS_PROCESS_INFORMATION(NDRSTRUCT):\n    structure = (\n         ('NextEntryOffset', ULONG),\n         ('NumberOfThreads', ULONG),\n         ('SpareLi1', LARGE_INTEGER),\n         ('SpareLi2', LARGE_INTEGER),\n         ('SpareLi3', LARGE_INTEGER),\n         ('CreateTime', LARGE_INTEGER),\n         ('UserTime', LARGE_INTEGER),\n         ('KernelTime', LARGE_INTEGER),\n         ('ImageNameSize', RPC_UNICODE_STRING), \n         ('BasePriority', LONG),\n         ('UniqueProcessId', DWORD),\n         ('InheritedFromUniqueProcessId', DWORD),\n         ('HandleCount', ULONG),\n         ('SessionId', ULONG),\n         ('SpareUl3', ULONG),\n         ('PeakVirtualSize', ULONG), #SIZE_T\n         ('VirtualSize', ULONG), #SIZE_T\n         ('PageFaultCount', ULONG),\n         ('PeakWorkingSetSize', ULONG),\n         ('WorkingSetSize', ULONG),\n         ('QuotaPeakPagedPoolUsage', ULONG), #SIZE_T\n         ('QuotaPagedPoolUsage', ULONG), #SIZE_T\n         ('QuotaPeakNonPagedPoolUsage', ULONG), #SIZE_T\n         ('QuotaNonPagedPoolUsage', ULONG), #SIZE_T\n         ('PagefileUsage', ULONG), #SIZE_T\n         ('PeakPagefileUsage', ULONG), #SIZE_T\n         ('PrivatePageCount', ULONG), #SIZE_T\n         ('ImageName', WSTR_STRIPPED), # THIS SHOULD NOT BE HERE\n         ('pSid', SID), # THIS SHOULD NOT BE HERE\n    )",
  "class PTS_SYS_PROCESS_INFORMATION(NDRPOINTER):\n    referent = (\n        ('Data', TS_SYS_PROCESS_INFORMATION),\n    )",
  "class TS_ALL_PROCESSES_INFO(NDRSTRUCT):\n    structure = (\n        ('pTsProcessInfo', TS_SYS_PROCESS_INFORMATION),\n        ('SizeOfSid', DWORD),\n        ('pSid', TS_CHAR),\n    )",
  "class TS_ALL_PROCESSES_INFO_ARRAY(NDRUniConformantVaryingArray):\n    item = TS_SYS_PROCESS_INFORMATION",
  "class PTS_ALL_PROCESSES_INFO(NDRPOINTER):\n    referent = (\n        ('Data', TS_ALL_PROCESSES_INFO_ARRAY),\n    )",
  "class WINSTATIONCONFIG2(NDRSTRUCT):\n    pass",
  "class CLIENT_STACK_ADDRESS(NDRSTRUCT):\n    pass",
  "class RpcOpenSession(NDRCALL):\n    opnum = 0\n    structure = (\n        ('SessionId', ULONG),\n        ('phSession', handle_t),\n    )",
  "class RpcOpenSessionResponse(NDRCALL):\n    structure = (\n        ('phSession', SESSION_HANDLE),\n        ('ErrorCode', ULONG),\n    )",
  "class RpcCloseSession(NDRCALL):\n    opnum = 1\n    structure = (\n        ('phSession', SESSION_HANDLE),\n    )",
  "class RpcCloseSessionResponse(NDRCALL):\n    structure = (\n        ('ErrorCode', ULONG),\n    )",
  "class RpcConnect(NDRCALL):\n    opnum = 2\n    structure = (\n        ('hSession', SESSION_HANDLE),\n        ('TargetSessionId', LONG),\n        ('szPassword', WSTR)\n    )",
  "class RpcConnectResponse(NDRCALL):\n    structure = (\n        ('ErrorCode', ULONG),\n    )",
  "class RpcDisconnect(NDRCALL):\n    opnum = 3\n    structure = (\n        ('hSession', SESSION_HANDLE),\n    )",
  "class RpcDisconnectResponse(NDRCALL):\n    structure = (\n        ('ErrorCode', ULONG),\n    )",
  "class RpcLogoff(NDRCALL):\n    opnum = 4\n    structure = (\n        ('hSession', SESSION_HANDLE),\n    )",
  "class RpcLogoffResponse(NDRCALL):\n    structure = (\n        ('ErrorCode', ULONG),\n    )",
  "class RpcGetUserName(NDRCALL):\n    opnum = 5\n    structure = (\n        ('hSession', SESSION_HANDLE),\n    )",
  "class RpcGetUserNameResponse(NDRCALL):\n    structure = (\n        ('pszUserName', LPWCHAR_STRIPPED\n        ),\n        ('pszDomain', LPWCHAR_STRIPPED),\n        ('ErrorCode', ULONG),\n    )",
  "class RpcGetTerminalName(NDRCALL):\n    opnum = 6\n    structure = (\n        ('hSession', SESSION_HANDLE),\n    )",
  "class RpcGetTerminalNameResponse(NDRCALL):\n    structure = (\n        ('pszTerminalName', LPWCHAR_STRIPPED),\n        ('ErrorCode', ULONG),\n    )",
  "class RpcGetState(NDRCALL):\n    opnum = 7\n    structure = (\n        ('hSession', SESSION_HANDLE),\n    )",
  "class RpcGetStateResponse(NDRCALL):\n    structure = (\n        ('plState', WINSTATIONSTATECLASS),\n        ('ErrorCode', ULONG),\n    )",
  "class RpcIsSessionDesktopLocked(NDRCALL):\n    opnum = 8\n    structure = (\n        ('hSession', SESSION_HANDLE),\n    )",
  "class RpcIsSessionDesktopLockedResponse(NDRCALL):\n    structure = (\n        ('ErrorCode', ULONG),\n    )",
  "class RpcShowMessageBox(NDRCALL):\n    opnum = 9\n    structure = (\n        ('hSession', SESSION_HANDLE),\n        ('szTitle', WSTR),\n        ('szMessage', WSTR),\n        ('ulStyle', ULONG),\n        ('ulTimeout', ULONG),\n        ('bDoNotWait', BOOL),\n    )",
  "class RpcShowMessageBoxResponse(NDRCALL):\n    structure = (\n        ('pulResponse', MSGBOX_ENUM),\n        ('ErrorCode', ULONG),\n    )",
  "class RpcGetTimes(NDRCALL):\n    opnum = 10\n    structure = (\n        ('hSession', SESSION_HANDLE),\n    )",
  "class RpcGetTimesResponse(NDRCALL):\n    structure = (\n        ('pConnectTime', SYSTEM_TIMESTAMP),\n        ('pDisconnectTime', SYSTEM_TIMESTAMP),\n        ('pLogonTime', SYSTEM_TIMESTAMP),\n        ('ErrorCode', ULONG),\n    )",
  "class RpcGetSessionCounters(NDRCALL):\n    opnum = 11\n    structure = (\n        ('hBinding', handle_t),\n        ('uEntries', LONG),\n    )",
  "class RpcGetSessionCountersResponse(NDRCALL):\n    structure = (\n        ('pCounter', PTS_COUNTER),\n        ('ErrorCode', ULONG),\n    )",
  "class RpcGetSessionInformation(NDRCALL):\n    opnum = 12\n    structure = (\n        ('SessionId', LONG),\n    )",
  "class RpcGetSessionInformationResponse(NDRCALL):\n    structure = (\n        ('pSessionInfo', LSMSESSIONINFORMATION),\n        ('ErrorCode', ULONG),\n    )",
  "class RpcSwitchToServicesSession(NDRCALL):\n    opnum = 13\n    structure = (\n        ('hBinding', handle_t),\n    )",
  "class RpcSwitchToServicesSessionResponse(NDRCALL):\n    structure = (\n        ('ErrorCode', ULONG),\n    )",
  "class RpcRevertFromServicesSession(NDRCALL):\n    opnum = 14\n    structure = (\n        ('hBinding', handle_t),\n    )",
  "class RpcRevertFromServicesSessionResponse(NDRCALL):\n    structure = (\n        ('ErrorCode', ULONG),\n    )",
  "class RpcGetLoggedOnCount(NDRCALL):\n    opnum = 15\n    structure = (\n        ('hBinding', handle_t),\n    )",
  "class RpcGetLoggedOnCountResponse(NDRCALL):\n    structure = (\n        ('pUserSessions', ULONG),\n        ('pDeviceSessions', ULONG),\n        ('ErrorCode', ULONG),\n    )",
  "class RpcGetSessionType(NDRCALL):\n    opnum = 16\n    structure = (\n        ('SessionId', LONG),\n    )",
  "class RpcGetSessionTypeResponse(NDRCALL):\n    structure = (\n        ('pSessionType', SESSIONTYPE),\n        ('ErrorCode', ULONG),\n    )",
  "class RpcGetSessionInformationEx(NDRCALL):\n    opnum = 17\n    structure = (\n        ('SessionId', LONG),\n        ('Level', DWORD),\n    )",
  "class RpcGetSessionInformationExResponse(NDRCALL):\n    structure = (\n        ('LSMSessionInfoExPtr', PLSMSESSIONINFORMATION_EX),\n        ('ErrorCode', ULONG),\n    )",
  "class RpcWaitForSessionState(NDRCALL):\n    opnum = 0\n    structure = (\n        ('SessionId', LONG),\n        ('State', LONG),\n        ('Timeout', ULONG),\n    )",
  "class RpcWaitForSessionStateResponse(NDRCALL):\n    structure = (\n        ('ErrorCode', ULONG),\n    )",
  "class RpcRegisterAsyncNotification(NDRCALL):\n    opnum = 1\n    structure = (\n        ('SessionId', LONG),\n        ('Mask', ULONG),\n    )",
  "class RpcRegisterAsyncNotificationResponse(NDRCALL):\n    structure = (\n        ('phNotify', NOTIFY_HANDLE),\n        ('ErrorCode', ULONG),\n    )",
  "class RpcWaitAsyncNotification(NDRCALL):\n    opnum = 2\n    structure = (\n        ('hNotify', context_handle),\n    )",
  "class RpcWaitAsyncNotificationResponse(NDRCALL):\n    structure = (\n        ('SessionChange', PSESSION_CHANGE),\n        ('pEntries', ULONG),\n        ('ErrorCode', ULONG),\n    )",
  "class RpcUnRegisterAsyncNotification(NDRCALL):\n    opnum = 3\n    structure = (\n        ('hNotify', NOTIFY_HANDLE),\n    )",
  "class RpcUnRegisterAsyncNotificationResponse(NDRCALL):\n    structure = (\n        ('hNotify', NOTIFY_HANDLE),\n        ('ErrorCode', ULONG),\n    )",
  "class RpcOpenEnum(NDRCALL):\n    opnum = 0\n    structure = (\n        ('hBinding', handle_t),\n    )",
  "class RpcOpenEnumResponse(NDRCALL):\n    structure = (\n        ('phEnum', ENUM_HANDLE),\n        ('ErrorCode', ULONG),\n    )",
  "class RpcCloseEnum(NDRCALL):\n    opnum = 1\n    structure = (\n        ('phEnum', ENUM_HANDLE),\n    )",
  "class RpcCloseEnumResponse(NDRCALL):\n    structure = (\n        ('phEnum', ENUM_HANDLE),\n        ('ErrorCode', ULONG),\n    )",
  "class RpcFilterByState(NDRCALL):\n    opnum = 2\n    structure = (\n        ('hEnum', ENUM_HANDLE),\n        ('State', LONG),\n        ('bInvert', BOOL),\n    )",
  "class RpcFilterByStateResponse(NDRCALL):\n    structure = (\n        ('ErrorCode', ULONG),\n    )",
  "class RpcFilterByCallersName(NDRCALL):\n    opnum = 3\n    structure = (\n        ('hEnum', ENUM_HANDLE),\n    )",
  "class RpcFilterByCallersNameResponse(NDRCALL):\n    structure = (\n        ('ErrorCode', ULONG),\n    )",
  "class RpcEnumAddFilter(NDRCALL):\n    opnum = 4\n    structure = (\n        ('hEnum', ENUM_HANDLE),\n        ('hSubEnum', ENUM_HANDLE),\n    )",
  "class RpcEnumAddFilterResponse(NDRCALL):\n    structure = (\n        ('ErrorCode', ULONG),\n    )",
  "class RpcGetEnumResult(NDRCALL):\n    opnum = 5\n    structure = (\n        ('hEnum', ENUM_HANDLE),\n        ('Level', DWORD),\n    )",
  "class RpcGetEnumResultResponse(NDRCALL): # strange double tag in union\n    structure = (\n        ('ppSessionEnumResult', PSESSIONENUM),\n        ('pEntries', ULONG),\n        ('ErrorCode', ULONG),\n    )",
  "class RpcFilterBySessionType(NDRCALL):\n    opnum = 6\n    structure = (\n        ('hEnum', ENUM_HANDLE),\n        ('pSessionType', GUID), # The session GUID to be used to filter out the enumeration result.\n                                # Only the session with the specified GUID will be returned\n    )",
  "class RpcFilterBySessionTypeResponse(NDRCALL):\n    structure = (\n        ('ErrorCode', ULONG),\n    )",
  "class RpcGetSessionIds(NDRCALL):\n    opnum = 8\n    structure = (\n        ('handle_t', handle_t),\n        ('Filter', SESSION_FILTER), # who knows... \n        ('MaxEntries', ULONG),\n    )",
  "class RpcGetSessionIdsResponse(NDRCALL):\n    structure = (\n        ('pSessionIds', LONG_ARRAY),\n        ('pcSessionIds', ULONG),\n        ('ErrorCode', ULONG),\n    )",
  "class RpcGetEnumResultEx(NDRCALL):\n    opnum = 9\n    structure = (\n        ('hEnum', ENUM_HANDLE),\n        ('Level', DWORD),\n    )",
  "class RpcGetEnumResultExResponse(NDRCALL):\n    structure = (\n        ('ppSessionEnumResult', PSESSIONENUM),\n        ('pEntries', ULONG),\n        ('ErrorCode', ULONG),\n    )",
  "class RpcGetAllSessions(NDRCALL):\n    opnum = 10\n    structure = (\n        ('pLevel', ULONG),\n    )",
  "class RpcGetAllSessionsResponse(NDRCALL):\n    # strange double tag in union\n    structure = (\n        ('pLevel', ULONG),\n        ('ppSessionData', PEXECENVDATA),\n        ('pcEntries', ULONG),\n        ('ErrorCode', ULONG),\n    )",
  "class RpcGetAllSessionsEx(NDRCALL):\n    opnum = 11\n    structure = (\n        ('Level', ULONG),\n    )",
  "class RpcGetAllSessionsExResponse(NDRCALL):\n    # giving up to parse it\n    structure = (\n        ('Buffer', UNKNOWNDATA),\n    )",
  "class RpcGetClientData(NDRCALL):\n    opnum = 0\n    structure = (\n        ('SessionId', ULONG),\n    )",
  "class RpcGetClientDataResponse(NDRCALL):\n    structure = (\n        ('ppBuff', PWINSTATIONCLIENT),\n        ('pOutBuffByteLen', ULONG),\n        ('ErrorCode', ULONG),\n    )",
  "class RpcGetConfigData(NDRCALL):\n    opnum = 1\n    structure = (\n        ('SessionId', ULONG),\n    )",
  "class RpcGetConfigDataResponse(NDRCALL):\n    # Note: there is a probability of wrong flags parsing.\n    structure = (\n        ('ppBuff', PWINSTATIONCONFIG),\n        ('pOutBuffByteLen', ULONG),\n        ('ErrorCode', ULONG),\n    )",
  "class RpcGetProtocolStatus(NDRCALL):\n    opnum = 2\n    structure = (\n        ('SessionId', ULONG),\n        ('InfoType', PROTOCOLSTATUS_INFO_TYPE),\n    )",
  "class RpcGetProtocolStatusResponse(NDRCALL):\n    structure = (\n        ('ppProtoStatus', PROTOCOLSTATUS_INFO_TYPE),\n        ('pcbProtoStatus', PPROTOCOLSTATUS),\n        ('ErrorCode', ULONG),\n    )",
  "class RpcGetLastInputTime(NDRCALL):\n    opnum = 3\n    structure = (\n        ('SessionId', ULONG),\n    )",
  "class RpcGetLastInputTimeResponse(NDRCALL):\n    structure = (\n        ('pLastInputTime', SYSTEM_TIMESTAMP),\n        ('ErrorCode', ULONG),\n    )",
  "class RpcGetRemoteAddress(NDRCALL):\n    opnum = 4\n    structure = (\n        ('SessionId', ULONG),\n    )",
  "class RpcGetRemoteAddressResponse(NDRCALL):\n    structure = (\n        ('pRemoteAddress', RCM_REMOTEADDRESS),\n        ('ErrorCode', ULONG),\n    )",
  "class RpcShadow(NDRCALL):\n    opnum = 5\n    structure = (\n        ('szTargetServerName', WSTR),\n        ('TargetSessionId', ULONG),\n        ('HotKeyVk', BYTE),\n        ('HotkeyModifiers', USHORT),\n    )",
  "class RpcShadowResponse(NDRCALL):\n    structure = (\n        ('ErrorCode', ULONG),\n    )",
  "class RpcShadowTarget(NDRCALL):\n    '''\n    HRESULT RpcShadowTarget(\n    [in] handle_t hBinding,\n    [in] ULONG SessionId,\n    [in, size_is(ConfigSize)] PBYTE pConfig,\n    [in, range(0, 0x8000)] ULONG ConfigSize,\n    [in, size_is(AddressSize)] PBYTE pAddress,\n    [in, range(0, 0x1000)] ULONG AddressSize,\n    [in, size_is(ModuleDataSize)] PBYTE pModuleData,\n    [in, range(0, 0x1000)] ULONG ModuleDataSize,\n    [in, size_is(ThinwireDataSize)]\n    PBYTE pThinwireData,\n    [in, range(0, 0x1000)] ULONG ThinwireDataSize,\n    [in, string] WCHAR* szClientName\n    );\n    '''\n    opnum = 6",
  "class RpcShadowTargetResponse(NDRCALL):\n    structure = (\n        ('Buffer', UNKNOWNDATA),\n    )",
  "class RpcShadowStop(NDRCALL):\n    opnum = 7\n    structure = (\n        ('SessionId', ULONG),\n    )",
  "class RpcShadowStopResponse(NDRCALL):\n    structure = (\n        ('ErrorCode', ULONG),\n    )",
  "class RpcGetAllListeners(NDRCALL):\n    opnum = 8\n    structure = (\n        ('Level', DWORD),\n    )",
  "class RpcGetAllListenersResponse(NDRCALL):\n    structure = (\n        ('ppListeners', PLISTENERENUM),\n        ('pNumListeners', ULONG),\n        ('ErrorCode', ULONG),\n    )",
  "class RpcGetSessionProtocolLastInputTime(NDRCALL):\n    opnum = 9\n    '''\n    HRESULT RpcGetSessionProtocolLastInputTime(\n    [in] handle_t hBinding,\n    [in] ULONG SessionId,\n    [in] PROTOCOLSTATUS_INFO_TYPE InfoType,\n    [out, size_is(,*pcbProtoStatus )]\n    unsigned char** ppProtoStatus,\n    [out] ULONG* pcbProtoStatus,\n    [out] hyper* pLastInputTime\n    );\n    '''",
  "class RpcGetSessionProtocolLastInputTimeResponse(NDRCALL):\n    structure = (\n        ('Data', UNKNOWNDATA),\n    )",
  "class RpcGetUserCertificates(NDRCALL):\n    opnum = 10\n    '''\n    HRESULT RpcGetUserCertificates(\n    [in] handle_t hBinding,\n    [in] ULONG SessionId,\n    [out] ULONG* pcCerts,\n    [out, size_is(, *pcbCerts)] byte** ppbCerts,\n    [out] ULONG* pcbCerts\n    );'''",
  "class RpcGetUserCertificatesResponse(NDRCALL):\n    structure = (\n        ('Data', UNKNOWNDATA),\n    )",
  "class RpcQuerySessionData(NDRCALL):\n    # Was unsuccess to implement this\n    '''\n    HRESULT RpcQuerySessionData(\n        [in] handle_t hBinding,\n        [in] ULONG SessionId,\n        [in] QUERY_SESSION_DATA_TYPE type,\n        [in, unique, size_is(cbInputData )] byte* pbInputData,\n        [in, range(0, 8192)] DWORD cbInputData,\n        [out, ref, size_is(cbSessionData), length_is(*pcbReturnLength)] byte* pbSessionData,\n        [in, range(0, 8192)] ULONG cbSessionData,\n        [out, ref] ULONG* pcbReturnLength,\n        [out, ref] ULONG* pcbRequireBufferSize\n    );\n    '''\n    opnum = 11",
  "class RpcQuerySessionDataResponse(NDRCALL):\n    structure = (\n        ('Buffer', UNKNOWNDATA),\n    )",
  "class RpcOpenListener(NDRCALL):\n    opnum = 0\n    structure = (\n        ('szListenerName', WSTR),\n    )",
  "class RpcOpenListenerResponse(NDRCALL):\n    structure = (\n        ('phListener', HLISTENER),\n        ('ErrorCode', ULONG),\n    )",
  "class RpcCloseListener(NDRCALL):\n    opnum = 1\n    structure = (\n        ('phListener', HLISTENER),\n    )",
  "class RpcCloseListenerResponse(NDRCALL):\n    structure = (\n        ('phListener', HLISTENER),\n        ('ErrorCode', ULONG),\n    )",
  "class RpcStopListener(NDRCALL):\n    opnum = 2\n    structure = (\n        ('phListener', HLISTENER),\n    )",
  "class RpcStopListenerResponse(NDRCALL):\n    structure = (\n        ('ErrorCode', ULONG),\n    )",
  "class RpcStartListener(NDRCALL):\n    opnum = 3\n    structure = (\n        ('phListener', HLISTENER),\n    )",
  "class RpcStartListenerResponse(NDRCALL):\n    structure = (\n        ('ErrorCode', ULONG),\n    )",
  "class RpcIsListening(NDRCALL):\n    opnum = 4\n    structure = (\n        ('phListener', HLISTENER),\n    )",
  "class RpcIsListeningResponse(NDRCALL):\n    structure = (\n        ('pbIsListening', BOOLEAN),\n        ('ErrorCode', ULONG),\n    )",
  "class RpcWinStationOpenServer(NDRCALL):\n    opnum = 0\n    structure = (\n        ('hBinding', handle_t),\n    )",
  "class RpcWinStationOpenServerResponse(NDRCALL):\n    structure = (\n        ('pResult', pResult_ENUM),\n        ('phServer', SERVER_HANDLE),\n        ('ErrorCode', BOOLEAN),\n    )",
  "class RpcWinStationCloseServer(NDRCALL):\n    opnum = 1\n    structure = (\n        ('hServer', SERVER_HANDLE),\n    )",
  "class RpcWinStationCloseServerResponse(NDRCALL):\n    structure = (\n        ('pResult', pResult_ENUM),\n        ('ErrorCode', BOOLEAN),\n    )",
  "class RpcIcaServerPing(NDRCALL):\n    opnum = 2\n    structure = (\n        ('hServer', SERVER_HANDLE),\n    )",
  "class RpcIcaServerPingResponse(NDRCALL):\n    structure = (\n        ('pResult', pResult_ENUM),\n        ('ErrorCode', BOOLEAN),\n    )",
  "class RpcWinStationEnumerate(NDRCALL):\n    '''\n    BOOLEAN RpcWinStationEnumerate(\n    [in] SERVER_HANDLE hServer,\n    [out] DWORD* pResult,\n    [in, out] PULONG pEntries,\n    [in, out, unique, size_is(*pByteCount)]\n    PCHAR pLogonId,\n    [in, out] PULONG pByteCount,\n    [in, out] PULONG pIndex\n    );\n    '''    \n    opnum = 3\n    structure = (\n        ('hServer', SERVER_HANDLE),\n        ('pEntries', PULONG),\n        ('pLogonId', PCHAR),\n        ('pByteCount', PULONG),\n        ('pIndex', PULONG),\n    )",
  "class RpcWinStationEnumerateResponse(NDRCALL):\n    structure = (\n        ('pResult', UNKNOWNDATA),\n    )",
  "class RpcWinStationRename(NDRCALL):\n    '''\n    BOOLEAN RpcWinStationRename(\n        [in] SERVER_HANDLE hServer,\n        [out] DWORD* pResult,\n        [in, size_is(NameOldSize)] PWCHAR pWinStationNameOld,\n        [in, range(0, 256)] DWORD NameOldSize,\n        [in, size_is(NameNewSize)] PWCHAR pWinStationNameNew,\n        [in, range(0, 256)] DWORD NameNewSize\n    );\n    '''\n    opnum = 4\n    structure = (\n        ('hServer', SERVER_HANDLE),\n        ('pWinStationNameOld', TS_WCHAR),\n        ('NameOldSize', '<L=len(pWinStationNameOld[\"Data\"])'),\n        ('pWinStationNameNew', TS_WCHAR),\n        ('NameNewSize', '<L=len(pWinStationNameNew[\"Data\"])'),\n    )",
  "class RpcWinStationRenameResponse(NDRCALL):\n    structure = (\n        ('pResult', pResult_ENUM),\n        ('ErrorCode', BOOLEAN),\n    )",
  "class RpcWinStationQueryInformation(NDRCALL):\n    '''\n    BOOLEAN RpcWinStationQueryInformation(\n        [in] SERVER_HANDLE hServer,\n        [out] DWORD* pResult,\n        [in] DWORD LogonId,\n        [in] DWORD WinStationInformationClass,\n        [in, out, unique, size_is(WinStationInformationLength)]\n        PCHAR pWinStationInformation,\n        [in, range(0, 0x8000)] DWORD WinStationInformationLength,\n        [out] DWORD* pReturnLength\n    );\n    '''\n    opnum = 5\n    structure = (\n        ('hServer', SERVER_HANDLE),\n        ('LogonId', DWORD),\n        ('WinStationInformationClass', DWORD),\n        # ('pWinStationInformation', TS_WCHAR),\n        # ('WinStationInformationLength', DWORD),\n        ('buff', ':'),\n    )",
  "class RpcWinStationQueryInformationResponse(NDRCALL):\n    structure = (\n        ('Buffer', UNKNOWNDATA),\n    )",
  "class RpcWinStationSetInformation(NDRCALL):\n    '''\n    BOOLEAN RpcWinStationSetInformation(\n    [in] SERVER_HANDLE hServer,\n    [out] DWORD* pResult,\n    [in] DWORD LogonId,\n    [in] DWORD WinStationInformationClass,\n    [in, out, unique, size_is(WinStationInformationLength)]\n    PCHAR pWinStationInformation,\n    [in, range(0, 0x8000)] DWORD WinStationInformationLength\n    );\n    '''\n    opnum = 6",
  "class RpcWinStationSetInformationResponse(NDRCALL):\n    structure = (\n        ('Buffer', UNKNOWNDATA),\n    )",
  "class RpcWinStationSendMessage(NDRCALL):\n    opnum = 7\n    structure = (\n        ('hServer', SERVER_HANDLE),\n        ('LogonId', DWORD),\n        ('pTitle', TS_WCHAR),\n        ('TitleLength', '<L=len(pTitle[\"Data\"])'),\n        ('pMessage', TS_WCHAR),\n        ('MessageLength', '<L=len(pMessage[\"Data\"])'),\n        ('Style', DWORD),\n        ('Timeout', DWORD),\n        ('DoNotWait', BOOLEAN),\n    )",
  "class RpcWinStationSendMessageResponse(NDRCALL):\n    structure = (\n        ('pResult', pResult_ENUM),\n        ('pResponse', DWORD),\n        ('ErrorCode', BOOLEAN),\n    )",
  "class RpcLogonIdFromWinStationName(NDRCALL):\n    opnum = 8\n    structure = (\n        ('hServer', SERVER_HANDLE),\n        ('pWinStationName', TS_WCHAR),\n        ('NameSize', '<L=len(pWinStationName[\"Data\"])'),\n    )",
  "class RpcLogonIdFromWinStationNameResponse(NDRCALL):\n    structure = (\n        ('pResult', pResult_ENUM),\n        ('pLogonId', DWORD),\n        ('ErrorCode', BOOLEAN),\n    )",
  "class RpcWinStationNameFromLogonId(NDRCALL):\n    opnum = 9\n    structure = (\n        ('hServer', SERVER_HANDLE),\n        ('LoginId', DWORD),\n        ('pWinStationName', TS_WCHAR),\n        ('NameSize', '<L=%d' % (WINSTATIONNAME_LENGTH+1)),\n    )",
  "class RpcWinStationNameFromLogonIdResponse(NDRCALL):\n    structure = (\n        ('pResult', pResult_ENUM),\n        ('pWinStationName', TS_WCHAR_STRIPPED),\n        ('ErrorCode', BOOLEAN),\n    )",
  "class RpcWinStationConnect(NDRCALL):\n    opnum = 10\n    structure = (\n        ('hServer', SERVER_HANDLE),\n        ('ClientLogonId', DWORD),\n        ('ConnectLogonId', DWORD),\n        ('TargetLogonId', DWORD),\n        ('pPassword', TS_WCHAR),\n        ('PasswordSize', '<L=len(pPassword[\"Data\"])'),\n        ('Wait', BOOLEAN),\n    )",
  "class RpcWinStationConnectResponse(NDRCALL):\n    structure = (\n        ('pResult', pResult_ENUM),\n        ('ErrorCode', BOOLEAN),\n    )",
  "class RpcWinStationVirtualOpen(NDRCALL):\n    opnum = 11\n    structure = (\n        ('hServer', SERVER_HANDLE),\n        ('LogonId', DWORD),\n        ('Pid', DWORD),\n        ('pVirtualName', TS_CHAR),\n        ('NameSize', '<L=len(pVirtualName[\"Data\"])'),\n    )",
  "class RpcWinStationVirtualOpenResponse(NDRCALL):\n    structure = (\n        ('pResult', pResult_ENUM),\n        ('pHandle', ULONG),\n        ('ErrorCode', BOOLEAN),\n    )",
  "class RpcWinStationBeepOpen(NDRCALL):\n    opnum = 12\n    structure = (\n        ('hServer', SERVER_HANDLE),\n        ('LogonId', DWORD),\n        ('Pid', DWORD),\n    )",
  "class RpcWinStationBeepOpenResponse(NDRCALL):\n    structure = (\n        ('pResult', pResult_ENUM),\n        ('pHandle', ULONG),\n        ('ErrorCode', BOOLEAN),\n    )",
  "class RpcWinStationDisconnect(NDRCALL):\n    opnum = 13\n    structure = (\n        ('hServer', SERVER_HANDLE),\n        ('LoginId', DWORD),\n        ('bWait', BOOLEAN),\n    )",
  "class RpcWinStationDisconnectResponse(NDRCALL):\n    structure = (\n        ('pResult', pResult_ENUM),\n        ('ErrorCode', BOOLEAN),\n    )",
  "class RpcWinStationReset(NDRCALL):\n    opnum = 14\n    structure = (\n        ('hServer', SERVER_HANDLE),\n        ('LogonId', DWORD),\n        ('bWait', BOOLEAN),\n    )",
  "class RpcWinStationResetResponse(NDRCALL):\n    structure = (\n        ('pResult', pResult_ENUM),\n        ('ErrorCode', BOOLEAN),\n    )",
  "class RpcWinStationShutdownSystem(NDRCALL):\n    opnum = 15\n    structure = (\n        ('hServer', SERVER_HANDLE),\n        ('ClientLogonId', DWORD),\n        ('ShutdownFlags', DWORD),\n    )",
  "class RpcWinStationShutdownSystemResponse(NDRCALL):\n    structure = (\n        ('pResult', pResult_ENUM),\n        ('ErrorCode', BOOLEAN),\n    )",
  "class RpcWinStationWaitSystemEvent(NDRCALL):\n    opnum = 16\n    structure = (\n        ('hServer', SERVER_HANDLE),\n        ('EventMask', DWORD),\n    )",
  "class RpcWinStationWaitSystemEventResponse(NDRCALL):\n    structure = (\n        ('pResult', pResult_ENUM),\n        ('pEventFlags', DWORD),\n        ('ErrorCode', BOOLEAN),\n    )",
  "class RpcWinStationShadow(NDRCALL):\n    opnum = 17\n    structure = (\n        ('hServer', SERVER_HANDLE),\n        ('LogonId', DWORD),\n        ('pTargetServerName', TS_LPWCHAR),\n        ('NameSize', '<L=len(pTargetServerName[\"Data\"])'),\n        ('TargetLogonId', DWORD),\n        ('HotKeyVk', BYTE),\n        ('HotkeyModifiers', USHORT),\n    )",
  "class RpcWinStationShadowResponse(NDRCALL):\n    structure = (\n        ('pResult', pResult_ENUM),\n        ('ErrorCode', BOOLEAN),\n    )",
  "class RpcWinStationShadowTargetSetup(NDRCALL):\n    opnum = 18\n    structure = (\n        ('hServer', SERVER_HANDLE),\n        ('LogonId', DWORD),\n    )",
  "class RpcWinStationShadowTargetSetupResponse(NDRCALL):\n    structure = (\n        ('pResult', pResult_ENUM),\n        ('ErrorCode', BOOLEAN),\n    )",
  "class RpcWinStationShadowTarget(NDRCALL):\n    opnum = 19\n    '''\n    BOOLEAN RpcWinStationShadowTarget(\n        [in] SERVER_HANDLE hServer,\n        [out] DWORD* pResult,\n        [in] DWORD LogonId,\n        [in, size_is(ConfigSize)] PBYTE pConfig,\n        [in, range(0, 0x8000)] DWORD ConfigSize,\n        [in, size_is(AddressSize)] PBYTE pAddress,\n        [in, range(0, 0x1000 )] DWORD AddressSize,\n        [in, size_is(ModuleDataSize)] PBYTE pModuleData,\n        [in, range(0, 0x1000 )] DWORD ModuleDataSize,\n        [in, size_is(ThinwireDataSize)]\n        PBYTE pThinwireData,\n        [in] DWORD ThinwireDataSize,\n        [in, size_is(ClientNameSize)] PBYTE pClientName,\n        [in, range(0, 1024 )] DWORD ClientNameSize\n    );\n    '''\n    structure = (\n        ('hServer', SERVER_HANDLE),\n        ('LogonId', DWORD),\n        ('pConfig', PBYTE),\n        ('ConfigSize', DWORD),\n        ('pAddress', PBYTE),\n        ('AddressSize', DWORD),\n        ('pModuleData', PBYTE),\n        ('ModuleDataSize', DWORD),\n        ('pThinwireData', PBYTE),\n        ('ThinwireDataSize', DWORD),\n        ('pClientName', STR),\n        ('ClientNameSize', DWORD),\n    )",
  "class RpcWinStationShadowTargetResponse(NDRCALL):\n    structure = (\n        ('pResult', pResult_ENUM),\n        ('ErrorCode', BOOLEAN),\n    )",
  "class RpcWinStationSetPoolCount(NDRCALL):\n    opnum = 26\n    structure = (\n        ('hServer', SERVER_HANDLE),\n        ('pLicense', TS_CHAR),\n        ('LicenseSize', '<L=len(pLicense[\"Data\"])'),\n    )",
  "class RpcWinStationSetPoolCountResponse(NDRCALL):\n    structure = (\n        ('pResult', pResult_ENUM),\n        ('ErrorCode', BOOLEAN),\n    )",
  "class RpcWinStationQueryUpdateRequired(NDRCALL):\n    opnum = 27\n    structure = (\n        ('hServer', SERVER_HANDLE),\n    )",
  "class RpcWinStationQueryUpdateRequiredResponse(NDRCALL):\n    structure = (\n        ('pResult', pResult_ENUM),\n        ('pUpdateFlag', DWORD),\n        ('ErrorCode', BOOLEAN),\n    )",
  "class RpcWinStationCallback(NDRCALL):\n    opnum = 28\n    '''\n    BOOLEAN RpcWinStationCallback(\n        [in] SERVER_HANDLE hServer,\n        [out] DWORD* pResult,\n        [in] DWORD LogonId,\n        [in, size_is(PhoneNumberSize)]\n        PWCHAR pPhoneNumber,\n        [in, range(0, 0x1000 )] DWORD PhoneNumberSize\n    );\n    '''\n    structure = (\n        ('hServer', SERVER_HANDLE),\n        ('LogonId', DWORD),\n        ('pPhoneNumber', TS_WCHAR),\n        ('PhoneNumberSize', '<L=len(pPhoneNumber[\"Data\"])'),\n    )",
  "class RpcWinStationCallbackResponse(NDRCALL):\n    structure = (\n        ('pResult', pResult_ENUM),\n        ('ErrorCode', BOOLEAN),\n    )",
  "class RpcWinStationBreakPoint(NDRCALL):\n    opnum = 29\n    structure = (\n        ('hServer', SERVER_HANDLE),\n        ('LogonId', DWORD),\n        ('KernelFlag', BOOLEAN),\n    )",
  "class RpcWinStationBreakPointResponse(NDRCALL):\n    structure = (\n        ('pResult', pResult_ENUM),\n        ('ErrorCode', BOOLEAN),\n    )",
  "class RpcWinStationReadRegistry(NDRCALL):\n    opnum = 30\n    structure = (\n        ('hServer', SERVER_HANDLE),\n    )",
  "class RpcWinStationReadRegistryResponse(NDRCALL):\n    structure = (\n        ('pResult', pResult_ENUM),\n        ('ErrorCode', BOOLEAN),\n    )",
  "class RpcWinStationWaitForConnect(NDRCALL):\n    opnum = 31\n    structure = (\n        ('hServer', SERVER_HANDLE),\n        ('ClientLogonId', DWORD),\n        ('ClientProcessId', DWORD),\n    )",
  "class RpcWinStationWaitForConnectResponse(NDRCALL): \n    structure = (\n        ('pResult', pResult_ENUM),\n        ('ErrorCode', BOOLEAN),\n    )",
  "class RpcWinStationNotifyLogon(NDRCALL):\n    opnum = 32\n    structure = (\n        ('hServer', SERVER_HANDLE),\n        ('ClientLogonId', DWORD),\n        ('ClientProcessId', DWORD),\n        ('fUserIsAdmin', BOOLEAN),\n        ('UserToken', DWORD),\n        ('pDomain', TS_WCHAR),\n        ('DomainSize', '<L=len(pDomain[\"Data\"])'),\n        ('pUserName', TS_WCHAR),\n        ('UserNameSize', '<L=len(pUserName[\"Data\"])'),\n        ('pPassword', TS_WCHAR),\n        ('PasswordSize', '<L=len(pPassword[\"Data\"])'),\n        ('Seed', UCHAR),\n        ('pUserConfig', TS_CHAR),\n        ('ConfigSize', '<L=len(pUserConfig[\"Data\"])'),\n        ('pfIsRedirected', DWORD),\n    )",
  "class RpcWinStationNotifyLogonResponse(NDRCALL): \n    structure = (\n        ('pResult', pResult_ENUM),\n        ('pfIsRedirected', BOOLEAN),\n        ('ErrorCode', BOOLEAN),\n    )",
  "class RpcWinStationNotifyLogoff(NDRCALL):\n    opnum = 33\n    structure = (\n        ('hServer', SERVER_HANDLE),\n        ('ClientLogonId', DWORD),\n        ('ClientProcessId', DWORD),\n    )",
  "class RpcWinStationNotifyLogoffResponse(NDRCALL): \n    structure = (\n        ('pResult', pResult_ENUM),\n        ('ErrorCode', BOOLEAN),\n    )",
  "class OldRpcWinStationEnumerateProcesses(NDRCALL):\n    opnum = 34\n    structure = (\n        ('hServer', SERVER_HANDLE),\n        ('ByteCount', DWORD),\n    )",
  "class OldRpcWinStationEnumerateProcessesResponse(NDRCALL):\n    structure = (\n        ('pResult', pResult_ENUM),\n        ('pProcessBuffer', TS_CHAR),\n        ('ErrorCode', BOOLEAN),\n    )",
  "class RpcWinStationAnnoyancePopup(NDRCALL):\n    opnum = 35\n    structure = (\n        ('hServer', SERVER_HANDLE),\n        ('LogonIdld', DWORD),\n    )",
  "class RpcWinStationAnnoyancePopupResponse(NDRCALL):\n    structure = (\n        ('pResult', pResult_ENUM),\n        ('ErrorCode', BOOLEAN),\n        ('buff', UNKNOWNDATA),\n    )",
  "class RpcWinStationEnumerateProcesses(NDRCALL):\n    opnum = 36\n    structure = (\n        ('hServer', SERVER_HANDLE),\n        ('ByteCount', DWORD),\n    )",
  "class RpcWinStationEnumerateProcessesResponse(NDRCALL):\n    structure = (\n        ('pResult', pResult_ENUM),\n        ('pProcessBuffer', TS_CHAR),\n        ('ErrorCode', BOOLEAN),\n    )",
  "class RpcWinStationTerminateProcess(NDRCALL):\n    opnum = 37\n    structure = (\n        ('hServer', SERVER_HANDLE),\n        ('ProcessId', DWORD),\n        ('ExitCode', DWORD),\n    )",
  "class RpcWinStationTerminateProcessResponse(NDRCALL):\n    structure = (\n        ('pResult', pResult_ENUM),\n        ('ErrorCode', BOOLEAN),\n    )",
  "class RpcWinStationNtsdDebug(NDRCALL):\n    opnum = 42\n    structure = (\n        ('hServer', SERVER_HANDLE),\n        ('LogonId', DWORD),\n        ('ProcessId', LONG),\n        ('DbgProcessId', ULONG),\n        ('DbgThreadId', ULONG),\n        ('AttachCompletionRoutine', LPDWORD),\n    )",
  "class RpcWinStationNtsdDebugResponse(NDRCALL):\n    structure = (\n        ('pResult', pResult_ENUM),\n        ('ErrorCode', BOOLEAN),\n    )",
  "class RpcWinStationGetAllProcesses(NDRCALL):\n    opnum = 43\n    structure = (\n        ('hServer', SERVER_HANDLE),\n        ('Level', ULONG),\n        ('pNumberOfProcesses', BOUNDED_ULONG),\n    )",
  "class RpcWinStationGetAllProcessesResponse(NDRCALL):\n    structure = (\n        ('pResult', pResult_ENUM),\n        ('pNumberOfProcesses', BOUNDED_ULONG),\n        ('buffer',':'),\n    )",
  "class RpcWinStationGetProcessSid(NDRCALL):\n    opnum = 44\n    structure = (\n        ('hServer', SERVER_HANDLE),\n        ('dwUniqueProcessId', DWORD),\n        ('ProcessStartTime', LARGE_INTEGER),\n        ('pProcessUserSid', TS_PBYTE),\n        ('dwSidSize', '<L=len(pProcessUserSid[\"Data\"])'),\n        ('pdwSizeNeeded', DWORD),\n    )",
  "class RpcWinStationGetProcessSidResponse(NDRCALL):\n    structure = (\n        ('pResult', pResult_ENUM),\n        ('pProcessUserSid', TS_PBYTE),\n        ('pdwSizeNeeded', DWORD),\n        ('ErrorCode', BOOLEAN),\n    )",
  "class RpcWinStationGetTermSrvCountersValue(NDRCALL):\n    '''\n    BOOLEAN RpcWinStationGetTermSrvCountersValue(\n        [in] SERVER_HANDLE hServer,\n        [out] DWORD* pResult,\n        [in, range(0, 0x1000)] DWORD dwEntries,\n        [in, out, size_is(dwEntries)] PTS_COUNTER pCounter\n    );\n    '''\n    opnum = 45\n    structure = (\n        ('hServer', SERVER_HANDLE),\n        ('dwEntries', DWORD),\n        ('pCounter', PTS_COUNTER),\n    )",
  "class RpcWinStationGetTermSrvCountersValueResponse(NDRCALL):\n    structure = (\n        ('pResult', pResult_ENUM),\n        ('pCounter', PTS_COUNTER),\n        ('ErrorCode', BOOLEAN),\n    )",
  "class RpcWinStationReInitializeSecurity(NDRCALL):\n    opnum = 46\n    structure = (\n        ('hServer', SERVER_HANDLE),\n    )",
  "class RpcWinStationReInitializeSecurityResponse(NDRCALL):\n    structure = (\n        ('pResult', pResult_ENUM),\n        ('ErrorCode', BOOLEAN),\n    )",
  "class RpcWinStationGetLanAdapterName(NDRCALL):\n    '''\n    BOOLEAN RpcWinStationGetLanAdapterName(\n        [in] SERVER_HANDLE hServer,\n        [out] DWORD* pResult,\n        [in, range(0, 0x1000)] DWORD PdNameSize,\n        [in, size_is(PdNameSize)] PWCHAR pPdName,\n        [in, range(0, 1024)] ULONG LanAdapter,\n        [out] ULONG* pLength,\n        [out, size_is(,*pLength)] PWCHAR* ppLanAdapter\n    );\n    '''\n    opnum = 53\n    structure = (\n        ('hServer', SERVER_HANDLE),\n        ('PdNameSize', '<L=len(pPdName[\"Data\"])'),\n        ('pPdName', TS_WCHAR),\n        ('LanAdapter', ULONG),\n    )",
  "class RpcWinStationGetLanAdapterNameResponse(NDRCALL):\n    structure = (\n        ('pResult', pResult_ENUM),\n        ('ppLanAdapter', TS_WCHAR),\n        ('ErrorCode', BOOLEAN),\n    )",
  "class RpcWinStationQueryLogonCredentials(NDRCALL):\n    '''\n    BOOLEAN RpcWinStationQueryLogonCredentials(\n        [in] SERVER_HANDLE hServer,\n        [in] ULONG LogonId,\n        [out, size_is(,*pcbCredentials)]\n        PCHAR* ppCredentials,\n        [in, out] ULONG* pcbCredentials\n    );\n    '''\n    opnum = 55\n    structure = (\n        ('hServer', SERVER_HANDLE),\n        ('LogonId', ULONG),\n        ('pcbCredentials', ULONG),\n    )",
  "class RpcWinStationQueryLogonCredentialsResponse(NDRCALL):\n    structure = (\n        ('pResult', UNKNOWNDATA),\n    )",
  "class RpcWinStationUpdateSettings(NDRCALL):\n    '''\n    BOOLEAN RpcWinStationUnRegisterConsoleNotification(\n        [in] SERVER_HANDLE hServer,\n        [out] DWORD* pResult,\n        [in] ULONG SessionId,\n        [in] ULONG hWnd\n    );\n    '''\n    opnum = 58\n    structure = (\n        ('hServer', SERVER_HANDLE),\n        ('SettingsClass', DWORD),\n        ('SettingsParameters', DWORD),\n    )",
  "class RpcWinStationUpdateSettingsResponse(NDRCALL):\n    structure = (\n        ('pResult', UNKNOWNDATA),\n    )",
  "class RpcWinStationShadowStop(NDRCALL):\n    opnum = 59\n    structure = (\n        ('hServer', SERVER_HANDLE),\n        ('LogonId', DWORD),\n        ('bWait', BOOLEAN),\n    )",
  "class RpcWinStationShadowStopResponse(NDRCALL):\n    structure = (\n        ('pResult', pResult_ENUM),\n        ('ErrorCode', BOOLEAN),\n    )",
  "class RpcWinStationCloseServerEx(NDRCALL):\n    opnum = 60\n    structure = (\n        ('hServer', SERVER_HANDLE),\n    )",
  "class RpcWinStationCloseServerExResponse(NDRCALL):\n    structure = (\n        ('phServer', SERVER_HANDLE),\n        ('pResult', pResult_ENUM),\n        ('ErrorCode', BOOLEAN),\n    )",
  "class RpcWinStationIsHelpAssistantSession(NDRCALL):\n    opnum = 61\n    structure = (\n        ('hServer', SERVER_HANDLE),\n        ('SessionId', ULONG),\n    )",
  "class RpcWinStationIsHelpAssistantSessionResponse(NDRCALL):\n    structure = (\n        ('pResult', pResult_ENUM),\n        ('ErrorCode', BOOLEAN),\n    )",
  "class RpcConnectCallback(NDRCALL):\n    '''\n    BOOLEAN RpcConnectCallback(\n        [in] SERVER_HANDLE hServer,\n        [out] DWORD* pResult,\n        [in] DWORD TimeOut,\n        [in] ULONG AddressType,\n        [in, size_is(AddressSize)] PBYTE pAddress,\n        [in, range(0, 0x1000 )] ULONG AddressSize\n    );\n    '''\n    opnum = 61\n    structure = (\n        ('hServer', SERVER_HANDLE),\n        ('TimeOut', DWORD),\n        ('AddressType', ULONG),\n        ('pAddress', TS_PBYTE),\n        ('AddressSize', '<L=len(pAddress[\"Data\"])'),\n    )",
  "class RpcConnectCallbackResponse(NDRCALL):\n    structure = (\n        ('pResult', pResult_ENUM),\n        ('ErrorCode', BOOLEAN),\n        ('out', UNKNOWNDATA),\n    )",
  "class RpcWinStationOpenSessionDirectory(NDRCALL):\n    opnum = 75\n    structure = (\n        ('hServer', SERVER_HANDLE),\n        ('pszServerName', WSTR),\n    )",
  "class RpcWinStationOpenSessionDirectoryResponse(NDRCALL):\n    structure = (\n        ('pResult', pResult_ENUM),\n        ('ErrorCode', BOOLEAN),\n    )",
  "def hRpcOpenSession(dce, SessionId):\n    request = RpcOpenSession()\n    request['SessionId'] = SessionId\n    return dce.request(request)['phSession']",
  "def hRpcCloseSession(dce, phSession):\n    request = RpcCloseSession()\n    request['phSession'] = phSession\n    return dce.request(request)",
  "def hRpcConnect(dce, hSession, TargetSessionId, Password = None):\n    if Password is None:\n        Password = ''\n    request = RpcConnect()\n    request['hSession'] = hSession\n    request['TargetSessionId'] = TargetSessionId\n    request['szPassword'] = Password + '\\0'\n    try:\n        return dce.request(request)\n    except DCERPCSessionError as e:\n        if e.error_code == 0x1: # Strange, but this error_code is returned on success\n            resp = RpcConnectResponse()\n            resp['ErrorCode'] = 0\n            return resp\n        raise e",
  "def hRpcDisconnect(dce, hSession):\n    request = RpcDisconnect()\n    request['hSession'] = hSession\n    return dce.request(request)",
  "def hRpcLogoff(dce, hSession):\n    request = RpcLogoff()\n    request['hSession'] = hSession\n    try:\n        return dce.request(request)\n    except DCERPCSessionError as e:\n        if e.error_code == 0x10000000: # Strange, but this error_code is returned on success\n            resp = RpcLogoffResponse()\n            resp['ErrorCode'] = 0\n            return resp\n        raise e\n        \n    return dce.request(request)",
  "def hRpcGetUserName(dce, hSession):\n    request = RpcGetUserName()\n    request['hSession'] = hSession\n    return dce.request(request)",
  "def hRpcGetTerminalName(dce, hSession):\n    request = RpcGetTerminalName()\n    request['hSession'] = hSession\n    return dce.request(request)",
  "def hRpcGetState(dce, hSession):\n    request = RpcGetState()\n    request['hSession'] = hSession\n    return dce.request(request)",
  "def hRpcIsSessionDesktopLocked(dce, hSession):\n    request = RpcIsSessionDesktopLocked()\n    request['hSession'] = hSession\n    return dce.request(request)",
  "def hRpcShowMessageBox(dce, hSession, Title, Message, Style = 0, Timeout = 0, DoNotWait = True):\n    Title = Title if Title is not None else ' '\n    Message = Message if Message is not None else ''\n\n    request = RpcShowMessageBox()\n    request['hSession'] = hSession\n    request['szTitle'] = Title + '\\0'\n    request['szMessage'] = Message + '\\0'\n    request['ulStyle'] = Style\n    request['ulTimeout'] = Timeout\n    request['bDoNotWait'] = DoNotWait\n    return dce.request(request)",
  "def hRpcGetTimes(dce, hSession):\n    request = RpcGetTimes()\n    request['hSession'] = hSession\n    return dce.request(request)",
  "def hRpcGetSessionCounters(dce, Entries):\n    request = RpcGetSessionCounters()\n    request['uEntries'] = Entries\n    return dce.request(request)",
  "def hRpcGetSessionInformation(dce, SessionId):\n    request = RpcGetSessionInformation()\n    request['SessionId'] = SessionId\n    return dce.request(request)",
  "def hRpcGetLoggedOnCount(dce):\n    request = RpcGetLoggedOnCount()\n    return dce.request(request)",
  "def hRpcGetSessionType(dce, SessionId):\n    request = RpcGetSessionType()\n    request['SessionId'] = SessionId\n    return dce.request(request)",
  "def hRpcGetSessionInformationEx(dce, SessionId):\n    request = RpcGetSessionInformationEx()\n    request['SessionId'] = SessionId\n    request['Level'] = 1\n    return dce.request(request)\n    '''\n    RpcGetSessionInformationExResponse \n    LSMSessionInfoExPtr:            \n    tag:                             1 \n    LSM_SessionInfo_Level1:         \n        SessionState:                    State_Active \n        SessionFlags:                    WTS_SESSIONSTATE_UNLOCK \n        SessionName:                     'RDP-Tcp#0' \n        DomainName:                      'W11-WKS' \n        UserName:                        'john' \n        ConnectTime:                     datetime.datetime(2022, 5, 9, 2, 34, 48, 700543) \n        DisconnectTime:                  datetime.datetime(2022, 5, 9, 2, 34, 48, 547684) \n        LogonTime:                       datetime.datetime(2022, 5, 9, 2, 23, 31, 119361) \n        LastInputTime:                   datetime.datetime(1601, 1, 1, 2, 20, 54) \n        ProtocolDataSize:                1816 \n        ProtocolData:                    \n    '''",
  "def hRpcWaitForSessionState(dce, SessionId, State, Timeout):\n    # State from WINSTATIONSTATECLASS class\n    request = RpcWaitForSessionState()\n    request['SessionId'] = SessionId\n    request['State'] = State\n    request['Timeout'] = Timeout\n    return dce.request(request)",
  "def hRpcRegisterAsyncNotification(dce, SessionId, Mask):\n    request = RpcRegisterAsyncNotification()\n    request['SessionId'] = SessionId\n    request['Mask'] = Mask\n    return dce.request(request)['phNotify']",
  "def hRpcWaitAsyncNotification(dce, hNotify):\n    request = RpcWaitAsyncNotification()\n    request['hNotify'] = hNotify\n    return dce.request(request)",
  "def hRpcUnRegisterAsyncNotification(dce, hNotify):\n    request = RpcUnRegisterAsyncNotification()\n    request['hNotify'] = hNotify\n    return dce.request(request)",
  "def hRpcOpenEnum(dce):\n    request = RpcOpenEnum()\n    return dce.request(request)['phEnum']",
  "def hRpcCloseEnum(dce, phEnum):\n    request = RpcCloseEnum()\n    request['phEnum'] = phEnum\n    return dce.request(request)",
  "def hRpcGetEnumResult(dce, hEnum, Level = 1):\n    request = RpcGetEnumResult()\n    request['hEnum'] = hEnum\n    request['Level'] = Level\n    return dce.request(request)",
  "def hRpcGetEnumResultEx(dce, hEnum, Level = 1):\n    request = RpcGetEnumResultEx()\n    request['hEnum'] = hEnum\n    request['Level'] = Level\n    return dce.request(request)",
  "def hRpcGetAllSessions(dce, Level = 1):\n    request = RpcGetAllSessions()\n    request['pLevel'] = Level\n    return dce.request(request)",
  "def hRpcGetClientData(dce, SessionId):\n    request = RpcGetClientData()\n    request['SessionId'] = SessionId\n    try:\n        return dce.request(request)\n    except:\n        return None",
  "def hRpcGetConfigData(dce, SessionId):\n    request = RpcGetConfigData()\n    request['SessionId'] = SessionId\n    return dce.request(request)",
  "def hRpcGetLastInputTime(dce, SessionId):\n    request = RpcGetLastInputTime()\n    request['SessionId'] = SessionId\n    return dce.request(request)",
  "def hRpcGetRemoteAddress(dce, SessionId):\n    request = RpcGetRemoteAddress()\n    request['SessionId'] = SessionId\n    try:\n        return dce.request(request)\n    except:\n        return None",
  "def hRpcGetAllListeners(dce):\n    request = RpcGetAllListeners()\n    request['Level'] = 1\n    return dce.request(request)",
  "def hRpcOpenListener(dce, ListenerName):\n    request = RpcOpenListener()\n    request['szListenerName'] = ListenerName + '\\0'\n    return dce.request(request)['phListener']",
  "def hRpcCloseListener(dce, phListener):\n    request = RpcCloseListener()\n    request['phListener'] = phListener\n    return dce.request(request)",
  "def hRpcStopListener(dce, phListener):\n    request = RpcStopListener()\n    request['phListener'] = phListener\n    return dce.request(request)",
  "def hRpcStartListener(dce, phListener):\n    request = RpcStartListener()\n    request['phListener'] = phListener\n    return dce.request(request)",
  "def hRpcIsListening(dce, phListener):\n    request = RpcIsListening()\n    request['phListener'] = phListener\n    return dce.request(request)",
  "def hRpcWinStationOpenServer(dce):\n    request = RpcWinStationOpenServer()\n    resp = dce.request(request, checkError=False)\n    if resp['ErrorCode']:\n        return resp['phServer']\n    return None",
  "def hRpcWinStationCloseServer(dce, hServer):\n    request = RpcWinStationCloseServer()\n    request['hServer'] = hServer\n    return dce.request(request, checkError=False)",
  "def hRpcIcaServerPing(dce, hServer):\n    request = RpcIcaServerPing()\n    request['hServer'] = hServer\n    return dce.request(request, checkError=False)",
  "def hRpcWinStationSendMessage(dce, hServer, LogonId, Title, Message, DoNotWait = True):\n    request = RpcWinStationSendMessage()\n    request['hServer'] = hServer\n    request['LogonId'] = LogonId\n    request['pTitle'] = ZEROPAD(Title,1024)\n    request['pMessage'] = ZEROPAD(Message,1024)\n    request['DoNotWait'] = DoNotWait\n    return dce.request(request, checkError=False)",
  "def hRpcLogonIdFromWinStationName(dce, hServer, WinStationName):\n    request = RpcLogonIdFromWinStationName()\n    request['hServer'] = hServer\n    request['pWinStationName'] = ZEROPAD(WinStationName, WINSTATIONNAME_LENGTH + 1)\n    return dce.request(request, checkError=False)",
  "def hRpcWinStationNameFromLogonId(dce, hServer, LoginId):\n    request = RpcWinStationNameFromLogonId()\n    request['hServer'] = hServer\n    request['LoginId'] = LoginId\n    request['pWinStationName'] = ZEROPAD('', WINSTATIONNAME_LENGTH + 1)\n    return dce.request(request, checkError=False)",
  "def hRpcWinStationConnect(dce, hServer, ClientLogonId, ConnectLogonId, TargetLogonId, Password, Wait = False):\n    # Session #1 in disconnected state\n    # You want to attach session #1 to your session and you know\n    # the password of the logged in user in session #1\n    # Your session ID: 3\n    # Parameters:\n    # ClientLogonId = 1\n    # ConnectLogonId = d\n    # TargetLogonId = 3\n    request = RpcWinStationConnect()\n    request['hServer'] = hServer\n    request['ClientLogonId'] = ClientLogonId\n    request['ConnectLogonId'] = ConnectLogonId\n    request['TargetLogonId'] = TargetLogonId\n    request['pPassword'] = Password + '\\0'\n    request['Wait'] = Wait\n    return dce.request(request, checkError=False)",
  "def hRpcWinStationDisconnect(dce, hServer, LoginId, bWait = False):\n    request = RpcWinStationDisconnect()\n    request['hServer'] = hServer\n    request['LoginId'] = LoginId\n    request['bWait'] = bWait\n    return dce.request(request, checkError=False)",
  "def hRpcWinStationReset(dce, hServer, LogonId, bWait = False):\n    request = RpcWinStationReset()\n    request['hServer'] = hServer\n    request['LogonId'] = LogonId\n    request['bWait'] = bWait\n    return dce.request(request, checkError=False)",
  "def hRpcWinStationShutdownSystem(dce, hServer, ClientLogonId, ShutdownFlags):\n    request = RpcWinStationShutdownSystem()\n    request['hServer'] = hServer\n    request['ClientLogonId'] = ClientLogonId\n    request['ShutdownFlags'] = ShutdownFlags\n    return dce.request(request, checkError=False)",
  "def hRpcWinStationWaitSystemEvent(dce, hServer, EventMask):\n    request = RpcWinStationWaitSystemEvent()\n    request['hServer'] = hServer\n    request['EventMask'] = EventMask\n    return dce.request(request, checkError=False)",
  "def hRpcWinStationShadow(dce, hServer, LogonId, pTargetServerName, TargetLogonId, HotKeyVk, HotkeyModifiers):\n    request = RpcWinStationShadow()\n    request['hServer'] = hServer\n    request['LogonId'] = LogonId\n    request['pTargetServerName'] = pTargetServerName\n    request['TargetLogonId'] = TargetLogonId\n    request['HotKeyVk'] = HotKeyVk\n    request['HotkeyModifiers'] = HotkeyModifiers\n    return dce.request(request, checkError=False)",
  "def hRpcWinStationShadowTargetSetup(dce, hServer, LogonId):\n    request = RpcWinStationShadowTargetSetup()\n    request['hServer'] = hServer\n    request['LogonId'] = LogonId\n    return dce.request(request, checkError=False)",
  "def hRpcWinStationBreakPoint(dce, hServer, LogonId, KernelFlag):\n    request = RpcWinStationBreakPoint()\n    request['hServer'] = hServer\n    request['LogonId'] = LogonId\n    request['KernelFlag'] = KernelFlag\n    return dce.request(request, checkError=False)",
  "def hRpcWinStationReadRegistry(dce, hServer):\n    request = RpcWinStationReadRegistry()\n    request['hServer'] = hServer\n    return dce.request(request, checkError=False)",
  "def hOldRpcWinStationEnumerateProcesses(dce, hServer, ByteCount):\n    request = OldRpcWinStationEnumerateProcesses()\n    request['hServer'] = hServer\n    request['ByteCount'] = ByteCount\n    return dce.request(request, checkError=False)",
  "def hRpcWinStationEnumerateProcesses(dce, hServer, ByteCount):\n    request = RpcWinStationEnumerateProcesses()\n    request['hServer'] = hServer\n    request['ByteCount'] = ByteCount\n    return dce.request(request, checkError=False)",
  "def hRpcWinStationTerminateProcess(dce, hServer, ProcessId, ExitCode = 0):\n    request = RpcWinStationTerminateProcess()\n    request['hServer'] = hServer\n    request['ProcessId'] = ProcessId\n    request['ExitCode'] = ExitCode\n    return dce.request(request, checkError=False)",
  "def hRpcWinStationGetAllProcesses(dce, hServer):\n    # i'm giving up constructing legitimate structures for this method\n    # Going to parse raw response:\n    # 1. Skip ndrpointers\n    # 2. Create TS_SYS_PROCESS_INFORMATION structure one by one\n    # Tested and seems to work well on WIN11, WIN10, WIN2012R2, WIN7\n    request = RpcWinStationGetAllProcesses()\n    request['hServer'] = hServer\n    request['Level'] = 0\n    request['pNumberOfProcesses'] = 0x8000\n    resp = dce.request(request, checkError=False)\n    data = resp.getData()\n    bResult = bool(data[-1])\n    if not bResult:\n        raise DCERPCSessionError(error_code=resp['pResult'])\n    data = data[:-1]\n    procs = []\n    if not resp['pNumberOfProcesses']:\n        return procs\n    offset = 0\n    arrayOffset = 0\n    while 1:\n        offset = data.find(b'\\x02\\x00')\n        if offset > 12:\n            break\n        data = data[offset+2:]\n        arrayOffset = arrayOffset + offset + 2\n    procInfo = ''\n    while len(data)>1:\n        if len(data[len(procInfo):]) < 16:\n            break\n        # I think there some alignment problems...\n        # in the structure, second DWORD is thread count, i'm looking for the second DWORD\n        # in order to align the data correctly\n        # There is no proper errors handling!\n        b,c,d,e = struct.unpack('<LLLL',data[len(procInfo):len(procInfo)+16])\n        if b:\n            data = data[len(procInfo)-4:]\n        elif c:\n            data = data[len(procInfo):]\n        elif d:\n            data = data[len(procInfo)+4:]\n        elif e:\n            data = data[len(procInfo)+8:]\n            \n        procInfo = TS_SYS_PROCESS_INFORMATION()\n        procInfo.fromString(data)\n        procs.append(procInfo)\n    return procs",
  "def hRpcWinStationGetProcessSid(dce, hServer, dwUniqueProcessId, ProcessStartTime):\n    request = RpcWinStationGetProcessSid()\n    request['hServer'] = hServer\n    request['dwUniqueProcessId'] = dwUniqueProcessId\n    request['ProcessStartTime'] = ProcessStartTime\n    request['pProcessUserSid'] = b'\\0' * 28\n    resp = dce.request(request, checkError=False)\n    if resp['pResult'] == pResult_ENUM.ERROR_STATUS_BUFFER_TOO_SMALL:\n        sizeNeeded = resp['pdwSizeNeeded']\n        request['pProcessUserSid'] = b'\\0' * sizeNeeded\n        request['dwSidSize'] = sizeNeeded\n        resp = dce.request(request, checkError=False)\n    if resp['ErrorCode']:\n        return format_sid(resp['pProcessUserSid'])",
  "def hRpcWinStationReInitializeSecurity(dce, hServer):\n    request = RpcWinStationReInitializeSecurity()\n    request['hServer'] = hServer\n    return dce.request(request, checkError=False)",
  "def hRpcWinStationGetLanAdapterName(dce, hServer, pPdName, LanAdapter):\n    request = RpcWinStationGetLanAdapterName()\n    request['hServer'] = hServer\n    request['pPdName'] = hServer\n    request['LanAdapter'] = hServer\n    return dce.request(request, checkError=False)",
  "def hRpcWinStationUpdateSettings(dce, hServer, SettingsClass, SettingsParameters):\n    request = RpcWinStationUpdateSettings()\n    request['hServer'] = hServer\n    request['SettingsClass'] = hServer\n    request['SettingsParameters'] = hServer\n    return dce.request(request, checkError=False)",
  "def hRpcWinStationShadowStop(dce, hServer, LogonId, bWait):\n    request = RpcWinStationShadowStop()\n    request['hServer'] = hServer\n    request['LogonId'] = LogonId\n    request['bWait'] = bWait\n    return dce.request(request, checkError=False)",
  "def hRpcWinStationCloseServerEx(dce, hServer):\n    request = RpcWinStationShadowStop()\n    request['hServer'] = hServer\n    return dce.request(request, checkError=False)",
  "def hRpcWinStationIsHelpAssistantSession(dce, hServer, SessionId):\n    request = RpcWinStationShadowStop()\n    request['hServer'] = hServer\n    request['SessionId'] = SessionId\n    return dce.request(request, checkError=False)",
  "def hRpcWinStationOpenSessionDirectory(dce, hServer, pszServerName):\n    request = RpcWinStationShadowStop()\n    request['hServer'] = hServer\n    request['pszServerName'] = pszServerName\n    return dce.request(request, checkError=False)",
  "class TSTSEndpoint:\n    def __init__(self, smb, target_ip, stringbinding, endpoint, kerberos = False):\n        self._stringbinding = stringbinding.format(target_ip)\n        self._endpoint = endpoint\n        self._smbconnection = smb\n        self._bind()\n\n        # Little hack to pass 'this' as 'dce' variable to a helper function\n        self.request = self._dce.request\n    def _bind(self):\n        self._rpctransport = transport.DCERPCTransportFactory(self._stringbinding)\n        self._rpctransport.set_smb_connection(self._smbconnection)\n        self._dce = self._rpctransport.get_dce_rpc()\n        self._dce.set_credentials(*self._rpctransport.get_credentials())\n        self._dce.connect()\n        self._dce.set_auth_level(RPC_C_AUTHN_LEVEL_PKT_PRIVACY)\n        self._dce.bind(self._endpoint)\n        return self._dce\n    def _disconnect(self):\n        self._dce.disconnect()\n    def __enter__(self):\n        return self\n    def __exit__(self, type, value, traceback):\n        self._disconnect()",
  "class TermSrvSession(TSTSEndpoint):\n    def __init__(self, smb, target_ip):\n        super().__init__(smb, target_ip,\n                            stringbinding = r'ncacn_np:{}[\\pipe\\LSM_API_service]',\n                            endpoint = TermSrvSession_UUID\n        )\n    hRpcOpenSession             = hRpcOpenSession\n    hRpcCloseSession            = hRpcCloseSession\n    hRpcConnect                 = hRpcConnect\n    hRpcDisconnect              = hRpcDisconnect\n    hRpcLogoff                  = hRpcLogoff\n    hRpcGetUserName             = hRpcGetUserName\n    hRpcGetTerminalName         = hRpcGetTerminalName\n    hRpcGetState                = hRpcGetState\n    hRpcIsSessionDesktopLocked  = hRpcIsSessionDesktopLocked\n    hRpcShowMessageBox          = hRpcShowMessageBox\n    hRpcGetTimes                = hRpcGetTimes\n    hRpcGetSessionCounters      = hRpcGetSessionCounters\n    hRpcGetSessionInformation   = hRpcGetSessionInformation\n    hRpcGetLoggedOnCount        = hRpcGetLoggedOnCount\n    hRpcGetSessionType          = hRpcGetSessionType\n    hRpcGetSessionInformationEx = hRpcGetSessionInformationEx",
  "class TermSrvNotification(TSTSEndpoint):\n    def __init__(self, smb, target_ip):\n        super().__init__(smb, target_ip,\n                            stringbinding = r'ncacn_np:{}[\\pipe\\LSM_API_service]',\n                            endpoint = TermSrvNotification_UUID\n        )\n    hRpcWaitForSessionState         = hRpcWaitForSessionState\n    hRpcRegisterAsyncNotification   = hRpcRegisterAsyncNotification\n    hRpcWaitAsyncNotification       = hRpcWaitAsyncNotification\n    hRpcUnRegisterAsyncNotification = hRpcUnRegisterAsyncNotification",
  "class TermSrvEnumeration(TSTSEndpoint):\n    def __init__(self, smb, target_ip):\n        super().__init__(smb, target_ip,\n                            stringbinding = r'ncacn_np:{}[\\pipe\\LSM_API_service]',\n                            endpoint      = TermSrvEnumeration_UUID\n        )\n    hRpcOpenEnum        = hRpcOpenEnum\n    hRpcCloseEnum       = hRpcCloseEnum\n    hRpcGetEnumResult   = hRpcGetEnumResult\n    hRpcGetEnumResultEx = hRpcGetEnumResultEx\n    hRpcGetAllSessions  = hRpcGetAllSessions",
  "class RCMPublic(TSTSEndpoint):\n    def __init__(self, smb, target_ip):\n        super().__init__(smb, target_ip,\n                            stringbinding = r'ncacn_np:{}[\\pipe\\TermSrv_API_service]',\n                            endpoint = RCMPublic_UUID\n        )\n    hRpcGetClientData    = hRpcGetClientData\n    hRpcGetConfigData    = hRpcGetConfigData\n    hRpcGetLastInputTime = hRpcGetLastInputTime\n    hRpcGetRemoteAddress = hRpcGetRemoteAddress\n    hRpcGetAllListeners  = hRpcGetAllListeners",
  "class RcmListener(TSTSEndpoint):\n    def __init__(self, smb, target_ip):\n        super().__init__(smb, target_ip,\n                            stringbinding = r'ncacn_np:{}[\\pipe\\TermSrv_API_service]',\n                            endpoint = RcmListener_UUID\n        )\n    hRpcOpenListener  = hRpcOpenListener\n    hRpcCloseListener = hRpcCloseListener\n    hRpcStopListener  = hRpcStopListener\n    hRpcStartListener = hRpcStartListener\n    hRpcIsListening   = hRpcIsListening",
  "class LegacyAPI(TSTSEndpoint):\n    def __init__(self, smb, target_ip):\n        super().__init__(smb, target_ip,\n                            stringbinding = r'ncacn_np:{}[\\pipe\\Ctx_WinStation_API_service]',\n                            endpoint = LegacyAPI_UUID\n        )\n    hRpcWinStationOpenServer             = hRpcWinStationOpenServer\n    hRpcWinStationCloseServer            = hRpcWinStationCloseServer\n    hRpcIcaServerPing                    = hRpcIcaServerPing\n    hRpcWinStationSendMessage            = hRpcWinStationSendMessage\n    hRpcLogonIdFromWinStationName        = hRpcLogonIdFromWinStationName\n    hRpcWinStationNameFromLogonId        = hRpcWinStationNameFromLogonId\n    hRpcWinStationConnect                = hRpcWinStationConnect\n    hRpcWinStationDisconnect             = hRpcWinStationDisconnect\n    hRpcWinStationReset                  = hRpcWinStationReset\n    hRpcWinStationShutdownSystem         = hRpcWinStationShutdownSystem\n    hRpcWinStationWaitSystemEvent        = hRpcWinStationWaitSystemEvent\n    hRpcWinStationShadow                 = hRpcWinStationShadow\n    hRpcWinStationShadowTargetSetup      = hRpcWinStationShadowTargetSetup\n    hRpcWinStationBreakPoint             = hRpcWinStationBreakPoint\n    hRpcWinStationReadRegistry           = hRpcWinStationReadRegistry\n    hOldRpcWinStationEnumerateProcesses  = hOldRpcWinStationEnumerateProcesses\n    hRpcWinStationEnumerateProcesses     = hRpcWinStationEnumerateProcesses\n    hRpcWinStationTerminateProcess       = hRpcWinStationTerminateProcess\n    hRpcWinStationGetAllProcesses        = hRpcWinStationGetAllProcesses\n    hRpcWinStationGetProcessSid          = hRpcWinStationGetProcessSid\n    hRpcWinStationReInitializeSecurity   = hRpcWinStationReInitializeSecurity\n    hRpcWinStationGetLanAdapterName      = hRpcWinStationGetLanAdapterName\n    hRpcWinStationUpdateSettings         = hRpcWinStationUpdateSettings\n    hRpcWinStationShadowStop             = hRpcWinStationShadowStop\n    hRpcWinStationCloseServerEx          = hRpcWinStationCloseServerEx\n    hRpcWinStationIsHelpAssistantSession = hRpcWinStationIsHelpAssistantSession",
  "def dump(self, msg = None, indent = 0):\n        if msg is None:\n            msg = self.__class__.__name__\n        if msg != '':\n            print(msg, end=' ')\n\n        try:\n            print(\" %s\" % self.enumItems(self.fields['Data']).name, end=' ')\n        except:\n            print(\" %s\" % hex(self.fields['Data']), end=' ')",
  "def __getitem__(self, key):\n        if key == 'Data':\n            return self.fields[key].decode('utf-16le')\n        else:\n            return NDR.__getitem__(self,key)",
  "def __getitem__(self, key):\n        if key == 'Data':\n            return self.fields[key]\n        else:\n            return NDR.__getitem__(self,key)",
  "def __getitem__(self, key):\n        if key == 'Data':\n            return datetime.fromtimestamp(getUnixTime(int(str(self.fields[key]))))\n        else:\n            return NDR.__getitem__(self,key)",
  "def __getitem__(self, key):\n        if key == 'Data':\n            return self.fields[key].decode('utf-16le').strip('\\x00')\n        else:\n            return NDR.__getitem__(self,key)",
  "def __getitem__(self, key):\n        if key == 'Data':\n            return self.fields[key].decode('utf-16le').rstrip('\\x00')\n        else:\n            return NDR.__getitem__(self,key)",
  "def getDataLen(self, data, offset=0):\n        if self.length is None:\n            return super().getDataLen(data, offset)\n        return self.length * 2",
  "def __getitem__(self, key):\n        if key == 'Data':\n            return self.fields[key].decode('utf-16le').rstrip('\\x00')\n        else:\n            return NDR.__getitem__(self,key)",
  "def __getitem__(self, key):\n        if key == 'Data':\n            return b''.join(self.fields[key])\n        else:\n            return NDR.__getitem__(self,key)",
  "def __init__(self, error_string=None, error_code=None, packet=None):\n        DCERPCException.__init__(self, error_string, error_code, packet)",
  "def __str__( self ):\n        key = self.error_code & 0xffff\n        if key in system_errors.ERROR_MESSAGES:\n            error_msg_short = system_errors.ERROR_MESSAGES[key][0]\n            error_msg_verbose = system_errors.ERROR_MESSAGES[key][1] \n            return 'TSTS SessionError: code: 0x%x - %s - %s' % (self.error_code, error_msg_short, error_msg_verbose)\n        else:\n            return 'TSTS SessionError: unknown error code: 0x%x' % self.error_code",
  "def known_sid(self, sid):\n        knownSids = {\n            'S-1-5-10': r'SELF',\n            'S-1-5-13': r'TERMINAL SERVER USER',\n            'S-1-5-11': r'Authenticated Users',\n            'S-1-5-12': r'RESTRICTED',\n            'S-1-5-14': r'Authenticated Users',\n            'S-1-5-15': r'This Organization',\n            'S-1-5-17': r'IUSR',\n            'S-1-5-18': r'SYSTEM',\n            'S-1-5-19': r'LOCAL SERVICE',\n            'S-1-5-20': r'NETWORK SERVICE',\n        }\n        if sid.startswith('S-1-5-90-0-') and len(sid.split('-')) == 6:\n            return 'DWM-{}'.format(int(sid.split('-')[-1]))\n        elif sid.startswith('S-1-5-96-0-') and len(sid.split('-')) == 6:\n            return 'UMFD-{}'.format(int(sid.split('-')[-1]))\n        elif sid in knownSids:\n            return knownSids[sid]\n        return sid",
  "def __getitem__(self, key):\n        if key == 'Data':\n            sid = format_sid(self.fields[key])\n            if not len(sid):\n                return ''\n            return self.known_sid(sid)\n        else:\n            return NDR.__getitem__(self,key)",
  "def getUUID(self):\n        return bin_to_string(self['context_handle_uuid'])",
  "def tuple(self):\n        return (bin_to_string(self['context_handle_uuid']),self['context_handle_attributes'])",
  "def from_tuple(self, tup):\n        self['context_handle_uuid'], self['context_handle_attributes'] = (string_to_bin(tup[0]), tup[1])",
  "def __init__(self, data=None, isNDR64=False):\n        NDRSTRUCT.__init__(self, data, isNDR64)\n        self['context_handle_uuid'] = b'\\x00'*16",
  "def isNull(self):\n        return self['context_handle_uuid'] == b'\\x00'*16",
  "def __str__(self):\n        return bin_to_string(self['context_handle_uuid'])",
  "def getAlignment(self):\n        if self._isNDR64 is True:\n            return 8\n        else:\n            return 4",
  "class enumItems(Enum):\n        IDABORT     = 3     # The Abort button was selected.\n        IDCANCEL    = 2     # The Cancel button was selected.\n        IDIGNORE    = 5     # The Ignore button was selected.\n        IDNO        = 7     # The No button was selected.\n        IDOK        = 1     # The OK button was selected.\n        IDRETRY     = 4     # The Retry button was selected.\n        IDYES       = 6     # The Yes button was selected.\n        IDASYNC     = 32001 # The bDoNotWait parameter was TRUE, so the function returned without waiting for a response.\n        IDTIMEOUT   = 32000",
  "class enumItems(Enum):\n        WSD_LOGOFF   = 0x00000001 # Forces sessions to logoff.\n        WSD_SHUTDOWN = 0x00000002 # Shuts down the system.\n        WSD_REBOOT   = 0x00000004 # Reboots after shutdown.\n        WSD_POWEROFF = 0x00000008",
  "class enumItems(Enum):\n        WEVENT_NONE         = 0x00000000    # The client requests to clear its event wait block. This MUST be called when completing waiting for the event. When RpcWinStationCloseServer is called for hServer, this method and mask value is called on the client's behalf.\n        WEVENT_CREATE       = 0x00000001    # Wait for a new session to be created.\n        WEVENT_DELETE       = 0x00000002    # Wait for an existing session to be deleted.\n        WEVENT_RENAME       = 0x00000004    # Wait for a session to be renamed.\n        WEVENT_CONNECT      = 0x00000008    # The session connected to a client.\n        WEVENT_DISCONNECT   = 0x00000010    # A client disconnected from the session.\n        WEVENT_LOGON        = 0x00000020    # A user logged on to the session.\n        WEVENT_LOGOFF       = 0x00000040    # A user logged off from the session.\n        WEVENT_STATECHANGE  = 0x00000080    # The session state changed.\n        WEVENT_LICENSE      = 0x00000100    # The license state changed.<183>\n        WEVENT_ALL          = 0x7fffffff    # Wait for all event types.\n        WEVENT_FLUSH        = 0x80000000",
  "class enumItems(Enum):\n        AppleTalk               = 16\n        Atm                     = 22\n        Banyan                  = 21\n        Ccitt                   = 10\n        Chaos                   = 5\n        Cluster                 = 24\n        ControllerAreaNetwork   = 65537\n        DataKit                 = 9\n        DataLink                = 13\n        DecNet                  = 12\n        Ecma                    = 8\n        FireFox                 = 19\n        HyperChannel            = 15\n        Ieee12844               = 25\n        ImpLink                 = 3\n        InterNetwork            = 2\n        InterNetworkV6          = 23\n        Ipx                     = 6\n        Irda                    = 26\n        Iso                     = 7\n        Lat                     = 14\n        Max                     = 29\n        NetBios                 = 17\n        NetworkDesigners        = 28\n        NS                      = 6\n        Osi                     = 7\n        Packet                  = 65536\n        Pup                     = 4\n        Sna                     = 11\n        Unix\t                = 1\t\n        Unspecified             = 0\n        VoiceView               = 18",
  "def getDataLen(self, data, offset=0):\n        return DLLNAME_LENGTH + 1",
  "def getDataLen(self, data, offset=0):\n        return DEVICENAME_LENGTH + 1",
  "def getDataLen(self, data, offset=0):\n        return CLIENTDATANAME_LENGTH + 1",
  "class enumItems(Enum):\n        WinStationCreateData                = 0\n        WinStationConfiguration             = 1\n        WinStationPdParams                  = 2\n        WinStationWd                        = 3\n        WinStationPd                        = 4\n        WinStationPrinter                   = 5\n        WinStationClient                    = 6\n        WinStationModules                   = 7\n        WinStationInformation               = 8\n        WinStationTrace                     = 9\n        WinStationBeep                      = 10\n        WinStationEncryptionOff             = 11\n        WinStationEncryptionPerm            = 12\n        WinStationNtSecurity                = 13\n        WinStationUserToken                 = 14\n        WinStationUnused1                   = 15\n        WinStationVideoData                 = 16\n        WinStationInitialProgram            = 17\n        WinStationCd                        = 18\n        WinStationSystemTrace               = 19\n        WinStationVirtualData               = 20\n        WinStationClientData                = 21\n        WinStationSecureDesktopEnter        = 22\n        WinStationSecureDesktopExit         = 23\n        WinStationLoadBalanceSessionTarget  = 24\n        WinStationLoadIndicator             = 25\n        WinStationShadowInfo                = 26\n        WinStationDigProductId              = 27\n        WinStationLockedState               = 28\n        WinStationRemoteAddress             = 29\n        WinStationIdleTime                  = 30\n        WinStationLastReconnectType         = 31\n        WinStationDisallowAutoReconnect     = 32\n        WinStationUnused2                   = 33\n        WinStationUnused3                   = 34\n        WinStationUnused4                   = 35\n        WinStationUnused5                   = 36\n        WinStationReconnectedFromId         = 37\n        WinStationEffectsPolicy             = 38\n        WinStationType                      = 39\n        WinStationInformationEx             = 40",
  "class enumItems(Enum):\n        State_Active        = 0 # A user is logged on to a session and the client is connected.\n        State_Connected     = 1 # A client is connected to a session but the user has not yet logged on.\n        State_ConnectQuery  = 2 # A session is in the process of connecting to a client.\n        State_Shadow        = 3 # A session is shadowing another session\n        State_Disconnected  = 4 # A user is logged on to the session but the client is currently disconnected from the server.\n        State_Idle          = 5 # A session is waiting for a client to connect to the server.\n        State_Listen        = 6 # A listener is waiting for connections from the Terminal Services client.\n        State_Reset         = 7 # A session is being reset. As a result, the user is logged off, the session is terminated, and the client is disconnected.\n        State_Down          = 8 # A session is currently tearing down or is in the down state, indicating an error.\n        State_Init          = 9",
  "class enumItems(Enum):\n        SdNone          = 0\n        SdConsole       = 1\n        SdNetwork       = 2\n        SdAsync         = 3\n        SdOemTransport  = 4",
  "class enumItems(Enum):\n        Shadow_Disable                  = 0\n        Shadow_EnableInputNotify        = 1\n        Shadow_EnableInputNoNotify      = 2\n        Shadow_EnableNoInputNotify      = 3\n        Shadow_EnableNoInputNoNotify    = 4",
  "class enumItems(Enum):\n        NeverReconnected = 0\n        ManualReconnect  = 1\n        AutoReconnect    = 2",
  "class enumItems(Enum):\n        SESSIONTYPE_UNKNOWN         = 0 # The type of the session cannot be determined.\n        SESSIONTYPE_SERVICES        = 1 # The session is used only to run the operating system services, and that no user can be logged on to the session.\n        SESSIONTYPE_LISTENER        = 2 # The session is used only to run the Terminal Services listeners, and that no user can be logged on to the session.\n        SESSIONTYPE_REGULARDESKTOP  = 3 # The session is connected by using Terminal Services and is running the standard shell.\n        SESSIONTYPE_ALTERNATESHELL  = 4 # The session is connected by using Terminal Services and is running an alternate shell instead of the standard shell\n        SESSIONTYPE_REMOTEAPP       = 5 # The session is a RAIL (Remote Applications Integrated Locally) session as defined in [MS-RDPERP].\n        SESSIONTYPE_MEDIACENTEREXT  = 6",
  "class enumItems(Enum):\n        SHADOW_CONTROL_REQUEST_VIEW         = 0 # The shadow request is for a view-only session. User input is not being requested.\n        SHADOW_CONTROL_REQUEST_TAKECONTROL  = 1 # User input control is being requested.\n        SHADOW_CONTROL_REQUEST_Count        = 2",
  "class enumItems(Enum):\n        SHADOW_PERMISSION_REQUEST_SILENT            = 0 # Permission is not requested.\n        SHADOW_PERMISSION_REQUEST_REQUESTPERMISSION = 1 # User permission will be requested before the shadow session begins.\n        SHADOW_PERMISSION_REQUEST_Count             = 2",
  "class enumItems(Enum):\n        SHADOW_REQUEST_RESPONSE_ALLOW                                   = 0 # The user has granted the request for permission to shadow the session.\n        SHADOW_REQUEST_RESPONSE_DECLINE                                 = 1 # The user has declined the request for permission to shadow the session.\n        SHADOW_REQUEST_RESPONSE_POLICY_PERMISSION_REQUIRED              = 2 # Permission was not requested, but group policy specifies that permission is required.\n        SHADOW_REQUEST_RESPONSE_POLICY_DISABLED                         = 3 # Shadowing has been disabled by group policy.\n        SHADOW_REQUEST_RESPONSE_POLICY_VIEW_ONLY                        = 4 # A request for control was made, but group policy exclusively allows view-only shadowing.\n        SHADOW_REQUEST_RESPONSE_POLICY_VIEW_ONLY_PERMISSION_REQUIRED    = 5 # A request was made to take control without requesting permission,\n                                                                            # but group policy exclusively allows viewonly shadowing and also requires permission.\n        SHADOW_REQUEST_RESPONSE_SESSION_ALREADY_CONTROLLED              = 6",
  "class enumItems(Enum):\n        SF_SERVICES_SESSION_POPUP = 0",
  "class enumItems(Enum):\n        PROTOCOLSTATUS_INFO_BASIC    = 0\n        PROTOCOLSTATUS_INFO_EXTENDED = 1",
  "class enumItems(Enum):\n        QUERY_SESSION_DATA_MODULE               = 0\n        QUERY_SESSION_DATA_WDCONFIG             = 1\n        QUERY_SESSION_DATA_VIRTUALDATA          = 2\n        QUERY_SESSION_DATA_LICENSE              = 3\n        QUERY_SESSION_DATA_DEVICEID             = 4\n        QUERY_SESSION_DATA_LICENSE_VALIDATION   = 5",
  "class FLAGS(NDRSTRUCT):\n        # a little hack to extrack bit flags\n        structure = (\n            ('flags','6s=b\"\"'),\n        )\n        def __getitem__(self, key):\n            if key == 'flags':\n                flagsInt = int.from_bytes(self.fields[key][2:],'little')\n                keys = {'fTextOnly'           : False,\n                        'fDisableCtrlAltDel'  : False,\n                        'fMouse'              : False,\n                        'fDoubleClickDetect'  : False,\n                        'fINetClient'         : False,\n                        'fPromptForPassword'  : False,\n                        'fMaximizeShell'      : False,\n                        'fEnableWindowsKey'   : False,\n                        'fRemoteConsoleAudio' : False,\n                        'fPasswordIsScPin'    : False,\n                        'fNoAudioPlayback'    : False,\n                        'fUsingSavedCreds'    : False,\n                        'fRestrictedLogon'    : False\n                }\n                for k in keys:\n                    keys[k] = bool(flagsInt & 1)\n                    flagsInt >>= 1\n                return keys\n            else:\n                return NDR.__getitem__(self,key)",
  "class enumItems(Enum):\n        WTS_SESSIONSTATE_UNKNOWN    = 0xFFFFFFFF\n        WTS_SESSIONSTATE_LOCK       = 0x00000000\n        WTS_SESSIONSTATE_UNLOCK     = 0x00000001",
  "class enumItems(Enum):\n        WTS_NOTIFY_NONE                 = 0x0        #No notification\n        WTS_NOTIFY_CREATE               = 0x1        #Session creation notification\n        WTS_NOTIFY_CONNECT              = 0x2        #Session connection notification\n        WTS_NOTIFY_DISCONNECT           = 0x4        #Session disconnection notification\n        WTS_NOTIFY_LOGON                = 0x8        #Session logon notification\n        WTS_NOTIFY_LOGOFF               = 0x10       #Session logoff notification\n        WTS_NOTIFY_SHADOW_START         = 0x20       #Session shadow start notification\n        WTS_NOTIFY_SHADOW_STOP          = 0x40       #Session shadow stop notification \n        WTS_NOTIFY_TERMINATE            = 0x80       #Session termination notification\n        WTS_NOTIFY_CONSOLE_CONNECT      = 0x100      #Console session connection notification\n        WTS_NOTIFY_CONSOLE_DISCONNECT   = 0x200      #Console session disconnect notification\n        WTS_NOTIFY_LOCK                 = 0x400      #Session lock notification\n        WTS_NOTIFY_UNLOCK               = 0x800      #Session unlock notification\n        WTS_NOTIFY_ALL                  = 0xffffffff",
  "class enumItems(Enum):\n        Callback_Disable = 0\n        Callback_Roving  = 1\n        Callback_Fixed   = 2",
  "class FLAGS(NDRSTRUCT):\n        # a little hack to extrack bit flags\n        structure = (\n            ('flags','7s=b\"\"'),\n        )\n        def __getitem__(self, key):\n            if key == 'flags':\n                # Hope that works as intended. If no, try to parse less data in that 7byte array\n                flagsInt = int.from_bytes(self.fields[key][:],'little')\n                tmp  = [('fInheritAutoLogon'             ,1),\n                        ('fInheritResetBroken'           ,1),\n                        ('fInheritReconnectSame'         ,1),\n                        ('fInheritInitialProgram'        ,1),\n                        ('fInheritCallback'              ,1),\n                        ('fInheritCallbackNumber'        ,1),\n                        ('fInheritShadow'                ,1),\n                        ('fInheritMaxSessionTime'        ,1),\n                        ('fInheritMaxDisconnectionTime'  ,1),\n                        ('fInheritMaxIdleTime'           ,1),\n                        ('fInheritAutoClient'            ,1),\n                        ('fInheritSecurity'              ,1),\n                        ('fPromptForPassword'            ,1),\n                        ('fResetBroken'                  ,1),\n                        ('fReconnectSame'                ,1),\n                        ('fLogonDisabled'                ,1),\n                        ('fWallPaperDisabled'            ,1),\n                        ('fAutoClientDrives'             ,1),\n                        ('fAutoClientLpts'               ,1),\n                        ('fForceClientLptDef'            ,1),\n                        ('fRequireEncryption'            ,1),\n                        ('fDisableEncryption'            ,1),\n                        ('fUnused1'                      ,1),\n                        ('fHomeDirectoryMapRoot'         ,1),\n                        ('fUseDefaultGina'               ,1),\n                        ('fCursorBlinkDisabled'          ,1),\n                        ('fPublishedApp'                 ,1),\n                        ('fHideTitleBar'                 ,1),\n                        ('fMaximize'                     ,1),\n                        ('fDisableCpm'                   ,1),\n                        ('fDisableCdm'                   ,1),\n                        ('fDisableCcm'                   ,1),\n                        ('fDisableLPT'                   ,1),\n                        ('fDisableClip'                  ,1),\n                        ('fDisableExe'                   ,1),\n                        ('fDisableCam'                   ,1),\n                        ('fDisableAutoReconnect'         ,1),\n                        ('ColorDepth'                    ,3),\n                        ('fInheritColorDepth'            ,1),\n                        ('fErrorInvalidProfile'          ,1),\n                        ('fPasswordIsScPin'              ,1),\n                        ('fDisablePNPRedir'              ,1)\n                    ]\n                keys = {}\n                for k,bits in tmp:\n                    if bits == 1:\n                        keys[k] = flagsInt & 1\n                    else:\n                        keys[k] = flagsInt & ((1<<bits)-1)\n                    flagsInt >>= bits\n                return keys\n            else:\n                return NDR.__getitem__(self,key)",
  "def __getitem__(self, key):\n        if key == 'Data':\n            x = self.fields[key]\n            y = []\n            while x:\n               y += [str(x & 0xff)]\n               x >>= 8\n            return '.'.join(y)\n        else:\n            return super().__getitem__(key)",
  "class _4CHAR(NDRSTRUCT):\n        structure = (\n            ('sin_zero', '4s=b\"\"'),\n        )",
  "class _8CHAR(NDRSTRUCT):\n        structure = (\n            ('sin_zero', '8s=b\"\"'),\n        )",
  "class enumItems(Enum):\n        STATUS_SUCCESS                                      = 0x00000000     # Successful call.\n        STATUS_INVALID_PARAMETER                            = 0xC000000D\n        STATUS_CANCELLED                                    = 0xC0000120     # The server is shutting down.\n        STATUS_INVALID_INFO_CLASS                           = 0xC0000003\n        STATUS_NO_MEMORY                                    = 0xC0000017     # Not enough memory to complete the operation\n        STATUS_ACCESS_DENIED                                = 0xC0000022\n        STATUS_BUFFER_TOO_SMALL                             = 0xC0000023\n        STATUS_NOT_IMPLEMENTED                              = 0xC0000002\n        STATUS_INFO_LENGTH_MISMATCH                         = 0xC0000004\n        STATUS_UNSUCCESSFUL                                 = 0xC0000001\n        STATUS_CTX_WINSTATION_NOT_FOUND                     = 0xC00A0015\n        STATUS_WRONG_PASSWORD                               = 0xC000006A\n        DOES_NOT_EXISTS_OR_INSUFFICIENT_PERMISSIONS         = 0x80071B6E\n        INVALID_PARAMETER2                                  = 0x80070057\n        ERROR_ACCESS_DENIED                                 = 0x80070005\n        ERROR_INVALID_STATE                                 = 0x8007139f\n        ERROR_LOGON_FAILURE                                 = 0x8007052e\n        ERROR_FILE_NOT_FOUND                                = 0x80070002\n        ERROR_STATUS_BUFFER_TOO_SMALL                       = 0x8007007A",
  "def __init__(self, smb, target_ip, stringbinding, endpoint, kerberos = False):\n        self._stringbinding = stringbinding.format(target_ip)\n        self._endpoint = endpoint\n        self._smbconnection = smb\n        self._bind()\n\n        # Little hack to pass 'this' as 'dce' variable to a helper function\n        self.request = self._dce.request",
  "def _bind(self):\n        self._rpctransport = transport.DCERPCTransportFactory(self._stringbinding)\n        self._rpctransport.set_smb_connection(self._smbconnection)\n        self._dce = self._rpctransport.get_dce_rpc()\n        self._dce.set_credentials(*self._rpctransport.get_credentials())\n        self._dce.connect()\n        self._dce.set_auth_level(RPC_C_AUTHN_LEVEL_PKT_PRIVACY)\n        self._dce.bind(self._endpoint)\n        return self._dce",
  "def _disconnect(self):\n        self._dce.disconnect()",
  "def __enter__(self):\n        return self",
  "def __exit__(self, type, value, traceback):\n        self._disconnect()",
  "def __init__(self, smb, target_ip):\n        super().__init__(smb, target_ip,\n                            stringbinding = r'ncacn_np:{}[\\pipe\\LSM_API_service]',\n                            endpoint = TermSrvSession_UUID\n        )",
  "def __init__(self, smb, target_ip):\n        super().__init__(smb, target_ip,\n                            stringbinding = r'ncacn_np:{}[\\pipe\\LSM_API_service]',\n                            endpoint = TermSrvNotification_UUID\n        )",
  "def __init__(self, smb, target_ip):\n        super().__init__(smb, target_ip,\n                            stringbinding = r'ncacn_np:{}[\\pipe\\LSM_API_service]',\n                            endpoint      = TermSrvEnumeration_UUID\n        )",
  "def __init__(self, smb, target_ip):\n        super().__init__(smb, target_ip,\n                            stringbinding = r'ncacn_np:{}[\\pipe\\TermSrv_API_service]',\n                            endpoint = RCMPublic_UUID\n        )",
  "def __init__(self, smb, target_ip):\n        super().__init__(smb, target_ip,\n                            stringbinding = r'ncacn_np:{}[\\pipe\\TermSrv_API_service]',\n                            endpoint = RcmListener_UUID\n        )",
  "def __init__(self, smb, target_ip):\n        super().__init__(smb, target_ip,\n                            stringbinding = r'ncacn_np:{}[\\pipe\\Ctx_WinStation_API_service]',\n                            endpoint = LegacyAPI_UUID\n        )",
  "def __getitem__(self, key):\n            if key == 'flags':\n                flagsInt = int.from_bytes(self.fields[key][2:],'little')\n                keys = {'fTextOnly'           : False,\n                        'fDisableCtrlAltDel'  : False,\n                        'fMouse'              : False,\n                        'fDoubleClickDetect'  : False,\n                        'fINetClient'         : False,\n                        'fPromptForPassword'  : False,\n                        'fMaximizeShell'      : False,\n                        'fEnableWindowsKey'   : False,\n                        'fRemoteConsoleAudio' : False,\n                        'fPasswordIsScPin'    : False,\n                        'fNoAudioPlayback'    : False,\n                        'fUsingSavedCreds'    : False,\n                        'fRestrictedLogon'    : False\n                }\n                for k in keys:\n                    keys[k] = bool(flagsInt & 1)\n                    flagsInt >>= 1\n                return keys\n            else:\n                return NDR.__getitem__(self,key)",
  "def __getitem__(self, key):\n            if key == 'flags':\n                # Hope that works as intended. If no, try to parse less data in that 7byte array\n                flagsInt = int.from_bytes(self.fields[key][:],'little')\n                tmp  = [('fInheritAutoLogon'             ,1),\n                        ('fInheritResetBroken'           ,1),\n                        ('fInheritReconnectSame'         ,1),\n                        ('fInheritInitialProgram'        ,1),\n                        ('fInheritCallback'              ,1),\n                        ('fInheritCallbackNumber'        ,1),\n                        ('fInheritShadow'                ,1),\n                        ('fInheritMaxSessionTime'        ,1),\n                        ('fInheritMaxDisconnectionTime'  ,1),\n                        ('fInheritMaxIdleTime'           ,1),\n                        ('fInheritAutoClient'            ,1),\n                        ('fInheritSecurity'              ,1),\n                        ('fPromptForPassword'            ,1),\n                        ('fResetBroken'                  ,1),\n                        ('fReconnectSame'                ,1),\n                        ('fLogonDisabled'                ,1),\n                        ('fWallPaperDisabled'            ,1),\n                        ('fAutoClientDrives'             ,1),\n                        ('fAutoClientLpts'               ,1),\n                        ('fForceClientLptDef'            ,1),\n                        ('fRequireEncryption'            ,1),\n                        ('fDisableEncryption'            ,1),\n                        ('fUnused1'                      ,1),\n                        ('fHomeDirectoryMapRoot'         ,1),\n                        ('fUseDefaultGina'               ,1),\n                        ('fCursorBlinkDisabled'          ,1),\n                        ('fPublishedApp'                 ,1),\n                        ('fHideTitleBar'                 ,1),\n                        ('fMaximize'                     ,1),\n                        ('fDisableCpm'                   ,1),\n                        ('fDisableCdm'                   ,1),\n                        ('fDisableCcm'                   ,1),\n                        ('fDisableLPT'                   ,1),\n                        ('fDisableClip'                  ,1),\n                        ('fDisableExe'                   ,1),\n                        ('fDisableCam'                   ,1),\n                        ('fDisableAutoReconnect'         ,1),\n                        ('ColorDepth'                    ,3),\n                        ('fInheritColorDepth'            ,1),\n                        ('fErrorInvalidProfile'          ,1),\n                        ('fPasswordIsScPin'              ,1),\n                        ('fDisablePNPRedir'              ,1)\n                    ]\n                keys = {}\n                for k,bits in tmp:\n                    if bits == 1:\n                        keys[k] = flagsInt & 1\n                    else:\n                        keys[k] = flagsInt & ((1<<bits)-1)\n                    flagsInt >>= bits\n                return keys\n            else:\n                return NDR.__getitem__(self,key)",
  "class DCERPCSessionError(DCERPCException):\n    def __init__(self, error_string=None, error_code=None, packet=None):\n        DCERPCException.__init__(self, error_string, error_code, packet)\n\n    def __str__( self ):\n        key = self.error_code\n        if key in hresult_errors.ERROR_MESSAGES:\n            error_msg_short = hresult_errors.ERROR_MESSAGES[key][0]\n            error_msg_verbose = hresult_errors.ERROR_MESSAGES[key][1]\n            return 'TSCH SessionError: code: 0x%x - %s - %s' % (self.error_code, error_msg_short, error_msg_verbose)\n        else:\n            return 'TSCH SessionError: unknown error code: 0x%x' % self.error_code",
  "class AT_INFO(NDRSTRUCT):\n    structure =  (\n        ('JobTime',DWORD),\n        ('DaysOfMonth',DWORD),\n        ('DaysOfWeek',UCHAR),\n        ('Flags',UCHAR),\n        ('Command',LPWSTR),\n    )",
  "class LPAT_INFO(NDRPOINTER):\n    referent = (\n        ('Data',AT_INFO),\n    )",
  "class AT_ENUM(NDRSTRUCT):\n    structure =  (\n        ('JobId',DWORD),\n        ('JobTime',DWORD),\n        ('DaysOfMonth',DWORD),\n        ('DaysOfWeek',UCHAR),\n        ('Flags',UCHAR),\n        ('Command',LPWSTR),\n    )",
  "class AT_ENUM_ARRAY(NDRUniConformantArray):\n    item = AT_ENUM",
  "class LPAT_ENUM_ARRAY(NDRPOINTER):\n    referent = (\n        ('Data',AT_ENUM_ARRAY),\n    )",
  "class AT_ENUM_CONTAINER(NDRSTRUCT):\n    structure =  (\n        ('EntriesRead',DWORD),\n        ('Buffer',LPAT_ENUM_ARRAY),\n    )",
  "class NetrJobAdd(NDRCALL):\n    opnum = 0\n    structure = (\n        ('ServerName',ATSVC_HANDLE),\n        ('pAtInfo', AT_INFO),\n    )",
  "class NetrJobAddResponse(NDRCALL):\n    structure = (\n        ('pJobId',DWORD),\n        ('ErrorCode',ULONG),\n    )",
  "class NetrJobDel(NDRCALL):\n    opnum = 1\n    structure = (\n        ('ServerName',ATSVC_HANDLE),\n        ('MinJobId', DWORD),\n        ('MaxJobId', DWORD),\n    )",
  "class NetrJobDelResponse(NDRCALL):\n    structure = (\n        ('ErrorCode',ULONG),\n    )",
  "class NetrJobEnum(NDRCALL):\n    opnum = 2\n    structure = (\n        ('ServerName',ATSVC_HANDLE),\n        ('pEnumContainer', AT_ENUM_CONTAINER),\n        ('PreferedMaximumLength', DWORD),\n        ('pResumeHandle', LPDWORD),\n    )",
  "class NetrJobEnumResponse(NDRCALL):\n    structure = (\n        ('pEnumContainer', AT_ENUM_CONTAINER),\n        ('pTotalEntries', DWORD),\n        ('pResumeHandle',LPDWORD),\n        ('ErrorCode',ULONG),\n    )",
  "class NetrJobGetInfo(NDRCALL):\n    opnum = 3\n    structure = (\n        ('ServerName',ATSVC_HANDLE),\n        ('JobId', DWORD),\n    )",
  "class NetrJobGetInfoResponse(NDRCALL):\n    structure = (\n        ('ppAtInfo', LPAT_INFO),\n        ('ErrorCode',ULONG),\n    )",
  "def hNetrJobAdd(dce, serverName = NULL, atInfo = NULL):\n    netrJobAdd = NetrJobAdd()\n    netrJobAdd['ServerName'] = serverName\n    netrJobAdd['pAtInfo'] = atInfo\n    return dce.request(netrJobAdd)",
  "def hNetrJobDel(dce, serverName = NULL, minJobId = 0, maxJobId = 0):\n    netrJobDel = NetrJobDel()\n    netrJobDel['ServerName'] = serverName\n    netrJobDel['MinJobId'] = minJobId\n    netrJobDel['MaxJobId'] = maxJobId\n    return dce.request(netrJobDel)",
  "def hNetrJobEnum(dce, serverName = NULL, pEnumContainer = NULL, preferedMaximumLength = 0xffffffff):\n    netrJobEnum = NetrJobEnum()\n    netrJobEnum['ServerName'] = serverName\n    netrJobEnum['pEnumContainer']['Buffer'] = pEnumContainer\n    netrJobEnum['PreferedMaximumLength'] = preferedMaximumLength\n    return dce.request(netrJobEnum)",
  "def hNetrJobGetInfo(dce, serverName = NULL, jobId = 0):\n    netrJobGetInfo = NetrJobGetInfo()\n    netrJobGetInfo['ServerName'] = serverName\n    netrJobGetInfo['JobId'] = jobId\n    return dce.request(netrJobGetInfo)",
  "def __init__(self, error_string=None, error_code=None, packet=None):\n        DCERPCException.__init__(self, error_string, error_code, packet)",
  "def __str__( self ):\n        key = self.error_code\n        if key in hresult_errors.ERROR_MESSAGES:\n            error_msg_short = hresult_errors.ERROR_MESSAGES[key][0]\n            error_msg_verbose = hresult_errors.ERROR_MESSAGES[key][1]\n            return 'TSCH SessionError: code: 0x%x - %s - %s' % (self.error_code, error_msg_short, error_msg_verbose)\n        else:\n            return 'TSCH SessionError: unknown error code: 0x%x' % self.error_code",
  "class DCERPCSessionError(DCERPCException):\n    def __init__(self, error_string=None, error_code=None, packet=None):\n        DCERPCException.__init__(self, error_string, error_code, packet)\n\n    def __str__( self ):\n        key = self.error_code\n        if key in hresult_errors.ERROR_MESSAGES:\n            error_msg_short = hresult_errors.ERROR_MESSAGES[key][0]\n            error_msg_verbose = hresult_errors.ERROR_MESSAGES[key][1]\n            return 'TSCH SessionError: code: 0x%x - %s - %s' % (self.error_code, error_msg_short, error_msg_verbose)\n        elif key & 0xffff in system_errors.ERROR_MESSAGES:\n            error_msg_short = system_errors.ERROR_MESSAGES[key & 0xffff][0]\n            error_msg_verbose = system_errors.ERROR_MESSAGES[key & 0xffff][1]\n            return 'TSCH SessionError: code: 0x%x - %s - %s' % (self.error_code, error_msg_short, error_msg_verbose)\n        else:\n            return 'TSCH SessionError: unknown error code: 0x%x' % self.error_code",
  "class TASK_NAMES_ARRAY(NDRUniConformantArray):\n    item = TASK_NAMES",
  "class PTASK_NAMES_ARRAY(NDRPOINTER):\n    referent = (\n        ('Data',TASK_NAMES_ARRAY),\n    )",
  "class WSTR_ARRAY(NDRUniConformantArray):\n    item = WSTR",
  "class PWSTR_ARRAY(NDRPOINTER):\n    referent = (\n        ('Data',WSTR_ARRAY),\n    )",
  "class GUID_ARRAY(NDRUniConformantArray):\n    item = GUID",
  "class PGUID_ARRAY(NDRPOINTER):\n    referent = (\n        ('Data',GUID_ARRAY),\n    )",
  "class SYSTEMTIME_ARRAY(NDRUniConformantArray):\n    item = SYSTEMTIME",
  "class PSYSTEMTIME_ARRAY(NDRPOINTER):\n    referent = (\n        ('Data',SYSTEMTIME_ARRAY),\n    )",
  "class TASK_USER_CRED(NDRSTRUCT):\n    structure =  (\n        ('userId',LPWSTR),\n        ('password',LPWSTR),\n        ('flags',DWORD),\n    )",
  "class TASK_USER_CRED_ARRAY(NDRUniConformantArray):\n    item = TASK_USER_CRED",
  "class LPTASK_USER_CRED_ARRAY(NDRPOINTER):\n    referent = (\n        ('Data',TASK_USER_CRED_ARRAY),\n    )",
  "class TASK_XML_ERROR_INFO(NDRSTRUCT):\n    structure =  (\n        ('line',DWORD),\n        ('column',DWORD),\n        ('node',LPWSTR),\n        ('value',LPWSTR),\n    )",
  "class PTASK_XML_ERROR_INFO(NDRPOINTER):\n    referent = (\n        ('Data',TASK_XML_ERROR_INFO),\n    )",
  "class FIXDLEN_DATA(Structure):\n    structure = (\n        ('Product Version','<H=0'),\n        ('File Version','<H=0'),\n        ('Job uuid','16s=\"'),\n        ('App Name Len Offset','<H=0'),\n        ('Trigger Offset','<H=0'),\n        ('Error Retry Count','<H=0'),\n        ('Error Retry Interval','<H=0'),\n        ('Idle Deadline','<H=0'),\n        ('Idle Wait','<H=0'),\n        ('Priority','<L=0'),\n        ('Maximum Run Time','<L=0'),\n        ('Exit Code','<L=0'),\n        ('Status','<L=0'),\n        ('Flags','<L=0'),\n    )",
  "class TRIGGERS(Structure):\n    structure = (\n        ('Trigger Size','<H=0'),\n        ('Reserved1','<H=0'),\n        ('Begin Year','<H=0'),\n        ('Begin Month','<H=0'),\n        ('Begin Day','<H=0'),\n        ('End Year','<H=0'),\n        ('End Month','<H=0'),\n        ('End Day','<H=0'),\n        ('Start Hour','<H=0'),\n        ('Start Minute','<H=0'),\n        ('Minutes Duration','<L=0'),\n        ('Minutes Interval','<L=0'),\n        ('Flags','<L=0'),\n        ('Trigger Type','<L=0'),\n        ('TriggerSpecific0','<H=0'),\n        ('TriggerSpecific1','<H=0'),\n        ('TriggerSpecific2','<H=0'),\n        ('Padding','<H=0'),\n        ('Reserved2','<H=0'),\n        ('Reserved3','<H=0'),\n    )",
  "class WEEKLY(Structure):\n    structure = (\n        ('Trigger Type','<L=0'),\n        ('Weeks Interval','<H=0'),\n        ('DaysOfTheWeek','<H=0'),\n        ('Unused','<H=0'),\n        ('Padding','<H=0'),\n    )",
  "class MONTHLYDATE(Structure):\n    structure = (\n        ('Trigger Type','<L=0'),\n        ('Days','<L=0'),\n        ('Months','<H=0'),\n        ('Padding','<H=0'),\n    )",
  "class MONTHLYDOW(Structure):\n    structure = (\n        ('Trigger Type','<L=0'),\n        ('WhichWeek','<H=0'),\n        ('DaysOfTheWeek','<H=0'),\n        ('Months','<H=0'),\n        ('Padding','<H=0'),\n        ('Reserved2','<H=0'),\n        ('Reserved3','<H=0'),\n    )",
  "class JOB_SIGNATURE(Structure):\n    structure = (\n        ('SignatureVersion','<HH0'),\n        ('MinClientVersion','<H=0'),\n        ('Signature','64s=\"'),\n    )",
  "class SchRpcHighestVersion(NDRCALL):\n    opnum = 0\n    structure = (\n    )",
  "class SchRpcHighestVersionResponse(NDRCALL):\n    structure = (\n        ('pVersion', DWORD),\n        ('ErrorCode',ULONG),\n    )",
  "class SchRpcRegisterTask(NDRCALL):\n    opnum = 1\n    structure = (\n        ('path', LPWSTR),\n        ('xml', WSTR),\n        ('flags', DWORD),\n        ('sddl', LPWSTR),\n        ('logonType', DWORD),\n        ('cCreds', DWORD),\n        ('pCreds', LPTASK_USER_CRED_ARRAY),\n    )",
  "class SchRpcRegisterTaskResponse(NDRCALL):\n    structure = (\n        ('pActualPath', LPWSTR),\n        ('pErrorInfo', PTASK_XML_ERROR_INFO),\n        ('ErrorCode',ULONG),\n    )",
  "class SchRpcRetrieveTask(NDRCALL):\n    opnum = 2\n    structure = (\n        ('path', WSTR),\n        ('lpcwszLanguagesBuffer', WSTR),\n        ('pulNumLanguages', DWORD),\n    )",
  "class SchRpcRetrieveTaskResponse(NDRCALL):\n    structure = (\n        ('pXml', LPWSTR),\n        ('ErrorCode',ULONG),\n    )",
  "class SchRpcCreateFolder(NDRCALL):\n    opnum = 3\n    structure = (\n        ('path', WSTR),\n        ('sddl', LPWSTR),\n        ('flags', DWORD),\n    )",
  "class SchRpcCreateFolderResponse(NDRCALL):\n    structure = (\n        ('ErrorCode',ULONG),\n    )",
  "class SchRpcSetSecurity(NDRCALL):\n    opnum = 4\n    structure = (\n        ('path', WSTR),\n        ('sddl', WSTR),\n        ('flags', DWORD),\n    )",
  "class SchRpcSetSecurityResponse(NDRCALL):\n    structure = (\n        ('ErrorCode',ULONG),\n    )",
  "class SchRpcGetSecurity(NDRCALL):\n    opnum = 5\n    structure = (\n        ('path', WSTR),\n        ('securityInformation', DWORD),\n    )",
  "class SchRpcGetSecurityResponse(NDRCALL):\n    structure = (\n        ('sddl',LPWSTR),\n        ('ErrorCode',ULONG),\n    )",
  "class SchRpcEnumFolders(NDRCALL):\n    opnum = 6\n    structure = (\n        ('path', WSTR),\n        ('flags', DWORD),\n        ('startIndex', DWORD),\n        ('cRequested', DWORD),\n    )",
  "class SchRpcEnumFoldersResponse(NDRCALL):\n    structure = (\n        ('startIndex', DWORD),\n        ('pcNames', DWORD),\n        ('pNames', PTASK_NAMES_ARRAY),\n        ('ErrorCode',ULONG),\n    )",
  "class SchRpcEnumTasks(NDRCALL):\n    opnum = 7\n    structure = (\n        ('path', WSTR),\n        ('flags', DWORD),\n        ('startIndex', DWORD),\n        ('cRequested', DWORD),\n    )",
  "class SchRpcEnumTasksResponse(NDRCALL):\n    structure = (\n        ('startIndex', DWORD),\n        ('pcNames', DWORD),\n        ('pNames', PTASK_NAMES_ARRAY),\n        ('ErrorCode',ULONG),\n    )",
  "class SchRpcEnumInstances(NDRCALL):\n    opnum = 8\n    structure = (\n        ('path', LPWSTR),\n        ('flags', DWORD),\n    )",
  "class SchRpcEnumInstancesResponse(NDRCALL):\n    structure = (\n        ('pcGuids', DWORD),\n        ('pGuids', PGUID_ARRAY),\n        ('ErrorCode',ULONG),\n    )",
  "class SchRpcGetInstanceInfo(NDRCALL):\n    opnum = 9\n    structure = (\n        ('guid', GUID),\n    )",
  "class SchRpcGetInstanceInfoResponse(NDRCALL):\n    structure = (\n        ('pPath', LPWSTR),\n        ('pState', DWORD),\n        ('pCurrentAction', LPWSTR),\n        ('pInfo', LPWSTR),\n        ('pcGroupInstances', DWORD),\n        ('pGroupInstances', PGUID_ARRAY),\n        ('pEnginePID', DWORD),\n        ('ErrorCode',ULONG),\n    )",
  "class SchRpcStopInstance(NDRCALL):\n    opnum = 10\n    structure = (\n        ('guid', GUID),\n        ('flags', DWORD),\n    )",
  "class SchRpcStopInstanceResponse(NDRCALL):\n    structure = (\n        ('ErrorCode',ULONG),\n    )",
  "class SchRpcStop(NDRCALL):\n    opnum = 11\n    structure = (\n        ('path', LPWSTR),\n        ('flags', DWORD),\n    )",
  "class SchRpcStopResponse(NDRCALL):\n    structure = (\n        ('ErrorCode',ULONG),\n    )",
  "class SchRpcRun(NDRCALL):\n    opnum = 12\n    structure = (\n        ('path', WSTR),\n        ('cArgs', DWORD),\n        ('pArgs', PWSTR_ARRAY),\n        ('flags', DWORD),\n        ('sessionId', DWORD),\n        ('user', LPWSTR),\n    )",
  "class SchRpcRunResponse(NDRCALL):\n    structure = (\n        ('pGuid', GUID),\n        ('ErrorCode',ULONG),\n    )",
  "class SchRpcDelete(NDRCALL):\n    opnum = 13\n    structure = (\n        ('path', WSTR),\n        ('flags', DWORD),\n    )",
  "class SchRpcDeleteResponse(NDRCALL):\n    structure = (\n        ('ErrorCode',ULONG),\n    )",
  "class SchRpcRename(NDRCALL):\n    opnum = 14\n    structure = (\n        ('path', WSTR),\n        ('newName', WSTR),\n        ('flags', DWORD),\n    )",
  "class SchRpcRenameResponse(NDRCALL):\n    structure = (\n        ('ErrorCode',ULONG),\n    )",
  "class SchRpcScheduledRuntimes(NDRCALL):\n    opnum = 15\n    structure = (\n        ('path', WSTR),\n        ('start', PSYSTEMTIME),\n        ('end', PSYSTEMTIME),\n        ('flags', DWORD),\n        ('cRequested', DWORD),\n    )",
  "class SchRpcScheduledRuntimesResponse(NDRCALL):\n    structure = (\n        ('pcRuntimes',DWORD),\n        ('pRuntimes',PSYSTEMTIME_ARRAY),\n        ('ErrorCode',ULONG),\n    )",
  "class SchRpcGetLastRunInfo(NDRCALL):\n    opnum = 16\n    structure = (\n        ('path', WSTR),\n    )",
  "class SchRpcGetLastRunInfoResponse(NDRCALL):\n    structure = (\n        ('pLastRuntime',SYSTEMTIME),\n        ('pLastReturnCode',DWORD),\n        ('ErrorCode',ULONG),\n    )",
  "class SchRpcGetTaskInfo(NDRCALL):\n    opnum = 17\n    structure = (\n        ('path', WSTR),\n        ('flags', DWORD),\n    )",
  "class SchRpcGetTaskInfoResponse(NDRCALL):\n    structure = (\n        ('pEnabled',DWORD),\n        ('pState',DWORD),\n        ('ErrorCode',ULONG),\n    )",
  "class SchRpcGetNumberOfMissedRuns(NDRCALL):\n    opnum = 18\n    structure = (\n        ('path', WSTR),\n    )",
  "class SchRpcGetNumberOfMissedRunsResponse(NDRCALL):\n    structure = (\n        ('pNumberOfMissedRuns',DWORD),\n        ('ErrorCode',ULONG),\n    )",
  "class SchRpcEnableTask(NDRCALL):\n    opnum = 19\n    structure = (\n        ('path', WSTR),\n        ('enabled', DWORD),\n    )",
  "class SchRpcEnableTaskResponse(NDRCALL):\n    structure = (\n        ('ErrorCode',ULONG),\n    )",
  "def checkNullString(string):\n    if string == NULL:\n        return string\n\n    if string[-1:] != '\\x00':\n        return string + '\\x00'\n    else:\n        return string",
  "def hSchRpcHighestVersion(dce):\n    return dce.request(SchRpcHighestVersion())",
  "def hSchRpcRegisterTask(dce, path, xml, flags, sddl, logonType, pCreds = ()):\n    request = SchRpcRegisterTask()\n    request['path'] = checkNullString(path)\n    request['xml'] = checkNullString(xml)\n    request['flags'] = flags\n    request['sddl'] = sddl\n    request['logonType'] = logonType\n    request['cCreds'] = len(pCreds)\n    if len(pCreds) == 0:\n        request['pCreds'] = NULL\n    else:\n        for cred in pCreds:\n            request['pCreds'].append(cred)\n    return dce.request(request)",
  "def hSchRpcRetrieveTask(dce, path, lpcwszLanguagesBuffer = '\\x00', pulNumLanguages=0 ):\n    schRpcRetrieveTask = SchRpcRetrieveTask()\n    schRpcRetrieveTask['path'] = checkNullString(path)\n    schRpcRetrieveTask['lpcwszLanguagesBuffer'] = lpcwszLanguagesBuffer\n    schRpcRetrieveTask['pulNumLanguages'] = pulNumLanguages\n    return dce.request(schRpcRetrieveTask)",
  "def hSchRpcCreateFolder(dce, path, sddl = NULL):\n    schRpcCreateFolder = SchRpcCreateFolder()\n    schRpcCreateFolder['path'] = checkNullString(path)\n    schRpcCreateFolder['sddl'] = sddl\n    schRpcCreateFolder['flags'] = 0\n    return dce.request(schRpcCreateFolder)",
  "def hSchRpcSetSecurity(dce, path, sddl, flags):\n    schRpcSetSecurity = SchRpcSetSecurity()\n    schRpcSetSecurity['path'] = checkNullString(path)\n    schRpcSetSecurity['sddl'] = checkNullString(sddl)\n    schRpcSetSecurity['flags'] = flags\n    return dce.request(schRpcSetSecurity)",
  "def hSchRpcGetSecurity(dce, path, securityInformation=0xffffffff):\n    schRpcGetSecurity = SchRpcGetSecurity()\n    schRpcGetSecurity['path'] = checkNullString(path)\n    schRpcGetSecurity['securityInformation'] = securityInformation\n    return dce.request(schRpcGetSecurity)",
  "def hSchRpcEnumFolders(dce, path, flags=TASK_ENUM_HIDDEN, startIndex=0, cRequested=0xffffffff):\n    schRpcEnumFolders = SchRpcEnumFolders()\n    schRpcEnumFolders['path'] = checkNullString(path)\n    schRpcEnumFolders['flags'] = flags\n    schRpcEnumFolders['startIndex'] = startIndex\n    schRpcEnumFolders['cRequested'] = cRequested\n    return dce.request(schRpcEnumFolders)",
  "def hSchRpcEnumTasks(dce, path, flags=TASK_ENUM_HIDDEN, startIndex=0, cRequested=0xffffffff):\n    schRpcEnumTasks = SchRpcEnumTasks()\n    schRpcEnumTasks['path'] = checkNullString(path)\n    schRpcEnumTasks['flags'] = flags\n    schRpcEnumTasks['startIndex'] = startIndex\n    schRpcEnumTasks['cRequested'] = cRequested\n    return dce.request(schRpcEnumTasks)",
  "def hSchRpcEnumInstances(dce, path, flags=TASK_ENUM_HIDDEN):\n    schRpcEnumInstances = SchRpcEnumInstances()\n    schRpcEnumInstances['path'] = checkNullString(path)\n    schRpcEnumInstances['flags'] = flags\n    return dce.request(schRpcEnumInstances)",
  "def hSchRpcGetInstanceInfo(dce, guid):\n    schRpcGetInstanceInfo = SchRpcGetInstanceInfo()\n    schRpcGetInstanceInfo['guid'] = guid\n    return dce.request(schRpcGetInstanceInfo)",
  "def hSchRpcStopInstance(dce, guid, flags = 0):\n    schRpcStopInstance = SchRpcStopInstance()\n    schRpcStopInstance['guid'] = guid\n    schRpcStopInstance['flags'] = flags\n    return dce.request(schRpcStopInstance)",
  "def hSchRpcStop(dce, path, flags = 0):\n    schRpcStop= SchRpcStop()\n    schRpcStop['path'] = checkNullString(path)\n    schRpcStop['flags'] = flags\n    return dce.request(schRpcStop)",
  "def hSchRpcRun(dce, path, pArgs=(), flags=0, sessionId=0, user = NULL):\n    schRpcRun = SchRpcRun()\n    schRpcRun['path'] = checkNullString(path)\n    schRpcRun['cArgs'] = len(pArgs)\n    for arg in pArgs:\n        argn = LPWSTR()\n        argn['Data'] = checkNullString(arg)\n        schRpcRun['pArgs'].append(argn)\n    schRpcRun['flags'] = flags\n    schRpcRun['sessionId'] = sessionId\n    schRpcRun['user'] = user\n    return dce.request(schRpcRun)",
  "def hSchRpcDelete(dce, path, flags = 0):\n    schRpcDelete = SchRpcDelete()\n    schRpcDelete['path'] = checkNullString(path)\n    schRpcDelete['flags'] = flags\n    return dce.request(schRpcDelete)",
  "def hSchRpcRename(dce, path, newName, flags = 0):\n    schRpcRename = SchRpcRename()\n    schRpcRename['path'] = checkNullString(path)\n    schRpcRename['newName'] = checkNullString(newName)\n    schRpcRename['flags'] = flags\n    return dce.request(schRpcRename)",
  "def hSchRpcScheduledRuntimes(dce, path, start = NULL, end = NULL, flags = 0, cRequested = 10):\n    schRpcScheduledRuntimes = SchRpcScheduledRuntimes()\n    schRpcScheduledRuntimes['path'] = checkNullString(path)\n    schRpcScheduledRuntimes['start'] = start\n    schRpcScheduledRuntimes['end'] = end\n    schRpcScheduledRuntimes['flags'] = flags\n    schRpcScheduledRuntimes['cRequested'] = cRequested\n    return dce.request(schRpcScheduledRuntimes)",
  "def hSchRpcGetLastRunInfo(dce, path):\n    schRpcGetLastRunInfo = SchRpcGetLastRunInfo()\n    schRpcGetLastRunInfo['path'] = checkNullString(path)\n    return dce.request(schRpcGetLastRunInfo)",
  "def hSchRpcGetTaskInfo(dce, path, flags = 0):\n    schRpcGetTaskInfo = SchRpcGetTaskInfo()\n    schRpcGetTaskInfo['path'] = checkNullString(path)\n    schRpcGetTaskInfo['flags'] = flags\n    return dce.request(schRpcGetTaskInfo)",
  "def hSchRpcGetNumberOfMissedRuns(dce, path):\n    schRpcGetNumberOfMissedRuns = SchRpcGetNumberOfMissedRuns()\n    schRpcGetNumberOfMissedRuns['path'] = checkNullString(path)\n    return dce.request(schRpcGetNumberOfMissedRuns)",
  "def hSchRpcEnableTask(dce, path, enabled = True):\n    schRpcEnableTask = SchRpcEnableTask()\n    schRpcEnableTask['path'] = checkNullString(path)\n    if enabled is True:\n        schRpcEnableTask['enabled'] = 1\n    else:\n        schRpcEnableTask['enabled'] = 0\n    return dce.request(schRpcEnableTask)",
  "def __init__(self, error_string=None, error_code=None, packet=None):\n        DCERPCException.__init__(self, error_string, error_code, packet)",
  "def __str__( self ):\n        key = self.error_code\n        if key in hresult_errors.ERROR_MESSAGES:\n            error_msg_short = hresult_errors.ERROR_MESSAGES[key][0]\n            error_msg_verbose = hresult_errors.ERROR_MESSAGES[key][1]\n            return 'TSCH SessionError: code: 0x%x - %s - %s' % (self.error_code, error_msg_short, error_msg_verbose)\n        elif key & 0xffff in system_errors.ERROR_MESSAGES:\n            error_msg_short = system_errors.ERROR_MESSAGES[key & 0xffff][0]\n            error_msg_verbose = system_errors.ERROR_MESSAGES[key & 0xffff][1]\n            return 'TSCH SessionError: code: 0x%x - %s - %s' % (self.error_code, error_msg_short, error_msg_verbose)\n        else:\n            return 'TSCH SessionError: unknown error code: 0x%x' % self.error_code",
  "class DCERPCSessionError(DCERPCException):\n    def __init__(self, error_string=None, error_code=None, packet=None):\n        DCERPCException.__init__(self, error_string, error_code, packet)\n\n    def __str__( self ):\n        key = self.error_code\n        if key in system_errors.ERROR_MESSAGES:\n            error_msg_short = system_errors.ERROR_MESSAGES[key][0]\n            error_msg_verbose = system_errors.ERROR_MESSAGES[key][1] \n            return 'SRVS SessionError: code: 0x%x - %s - %s' % (self.error_code, error_msg_short, error_msg_verbose)\n        else:\n            return 'SRVS SessionError: unknown error code: 0x%x' % self.error_code",
  "class PSRVSVC_HANDLE(NDRPOINTER):\n    referent = (\n        ('Data', SRVSVC_HANDLE),\n    )",
  "class SHARE_DEL_HANDLE(NDRSTRUCT):\n    align = 1\n    structure =  (\n        ('Data','20s=\"\"'),\n    )",
  "class PSHARE_DEL_HANDLE(NDRPOINTER):\n    referent = (\n        ('Data', SHARE_DEL_HANDLE),\n    )",
  "class CONNECTION_INFO_0(NDRSTRUCT):\n    structure = (\n        ('coni0_id', DWORD),\n    )",
  "class CONNECTION_INFO_0_ARRAY(NDRUniConformantArray):\n    item = CONNECTION_INFO_0",
  "class LPCONNECTION_INFO_0_ARRAY(NDRPOINTER):\n    referent = (\n        ('Data', CONNECTION_INFO_0_ARRAY),\n    )",
  "class CONNECTION_INFO_1(NDRSTRUCT):\n    structure = (\n        ('coni1_id', DWORD),\n        ('coni1_type', DWORD),\n        ('coni1_num_opens', DWORD),\n        ('coni1_num_users', DWORD),\n        ('coni1_time', DWORD),\n        ('coni1_username', LPWSTR),\n        ('coni1_netname', LPWSTR),\n    )",
  "class CONNECTION_INFO_1_ARRAY(NDRUniConformantArray):\n    item = CONNECTION_INFO_1",
  "class LPCONNECTION_INFO_1_ARRAY(NDRPOINTER):\n    referent = (\n        ('Data', CONNECTION_INFO_1_ARRAY),\n    )",
  "class CONNECT_INFO_0_CONTAINER(NDRSTRUCT):\n    structure = (\n        ('EntriesRead', DWORD),\n        ('Buffer', LPCONNECTION_INFO_0_ARRAY),\n    )",
  "class LPCONNECT_INFO_0_CONTAINER(NDRPOINTER):\n    referent = (\n        ('Data', CONNECT_INFO_0_CONTAINER),\n    )",
  "class CONNECT_INFO_1_CONTAINER(NDRSTRUCT):\n    structure = (\n        ('EntriesRead', DWORD),\n        ('Buffer', LPCONNECTION_INFO_1_ARRAY),\n    )",
  "class LPCONNECT_INFO_1_CONTAINER(NDRPOINTER):\n    referent = (\n        ('Data', CONNECT_INFO_1_CONTAINER),\n    )",
  "class CONNECT_ENUM_UNION(NDRUNION):\n    commonHdr = (\n        ('tag', DWORD),\n    )\n\n    union = {\n        0: ('Level0', LPCONNECT_INFO_0_CONTAINER),\n        1: ('Level1', LPCONNECT_INFO_1_CONTAINER),\n    }",
  "class CONNECT_ENUM_STRUCT(NDRSTRUCT):\n    structure = (\n        ('Level', DWORD),\n        ('ConnectInfo', CONNECT_ENUM_UNION),\n    )",
  "class FILE_INFO_2(NDRSTRUCT):\n    structure = (\n        ('fi2_id', DWORD),\n    )",
  "class LPFILE_INFO_2(NDRPOINTER):\n    referent = (\n        ('Data', FILE_INFO_2),\n    )",
  "class FILE_INFO_2_ARRAY(NDRUniConformantArray):\n    item = FILE_INFO_2",
  "class LPFILE_INFO_2_ARRAY(NDRPOINTER):\n    referent = (\n        ('Data', FILE_INFO_2_ARRAY),\n    )",
  "class FILE_INFO_3(NDRSTRUCT):\n    structure = (\n        ('fi3_id', DWORD),\n        ('fi3_permissions', DWORD),\n        ('fi3_num_locks', DWORD),\n        ('fi3_path_name', LPWSTR),\n        ('fi3_username', LPWSTR),\n    )",
  "class LPFILE_INFO_3(NDRPOINTER):\n    referent = (\n        ('Data', FILE_INFO_3),\n    )",
  "class FILE_INFO_3_ARRAY(NDRUniConformantArray):\n    item = FILE_INFO_3",
  "class LPFILE_INFO_3_ARRAY(NDRPOINTER):\n    referent = (\n        ('Data', FILE_INFO_3_ARRAY),\n    )",
  "class FILE_INFO_2_CONTAINER(NDRSTRUCT):\n    structure = (\n        ('EntriesRead', DWORD),\n        ('Buffer', LPFILE_INFO_2_ARRAY),\n    )",
  "class LPFILE_INFO_2_CONTAINER(NDRPOINTER):\n    referent = (\n        ('Data', FILE_INFO_2_CONTAINER),\n    )",
  "class FILE_INFO_3_CONTAINER(NDRSTRUCT):\n    structure = (\n        ('EntriesRead', DWORD),\n        ('Buffer', LPFILE_INFO_3_ARRAY),\n    )",
  "class LPFILE_INFO_3_CONTAINER(NDRPOINTER):\n    referent = (\n        ('Data', FILE_INFO_3_CONTAINER),\n    )",
  "class FILE_ENUM_UNION(NDRUNION):\n    commonHdr = (\n        ('tag', DWORD),\n    )\n\n    union = {\n        2: ('Level2', LPFILE_INFO_2_CONTAINER),\n        3: ('Level3', LPFILE_INFO_3_CONTAINER),\n    }",
  "class FILE_ENUM_STRUCT(NDRSTRUCT):\n    structure = (\n        ('Level', DWORD),\n        ('FileInfo', FILE_ENUM_UNION),\n    )",
  "class SESSION_INFO_0(NDRSTRUCT):\n    structure = (\n        ('sesi0_cname', LPWSTR),\n    )",
  "class LPSESSION_INFO_0(NDRPOINTER):\n    referent = (\n        ('Data', SESSION_INFO_0),\n    )",
  "class SESSION_INFO_0_ARRAY(NDRUniConformantArray):\n    item = SESSION_INFO_0",
  "class LPSESSION_INFO_0_ARRAY(NDRPOINTER):\n    referent = (\n        ('Data', SESSION_INFO_0_ARRAY),\n    )",
  "class SESSION_INFO_1(NDRSTRUCT):\n    structure = (\n        ('sesi1_cname', LPWSTR),\n        ('sesi1_username', LPWSTR),\n        ('sesi1_num_opens', DWORD),\n        ('sesi1_time', DWORD),\n        ('sesi1_idle_time', DWORD),\n        ('sesi1_user_flags', DWORD),\n    )",
  "class LPSESSION_INFO_1(NDRPOINTER):\n    referent = (\n        ('Data', SESSION_INFO_1),\n    )",
  "class SESSION_INFO_1_ARRAY(NDRUniConformantArray):\n    item = SESSION_INFO_1",
  "class LPSESSION_INFO_1_ARRAY(NDRPOINTER):\n    referent = (\n        ('Data', SESSION_INFO_1_ARRAY),\n    )",
  "class SESSION_INFO_2(NDRSTRUCT):\n    structure = (\n        ('sesi2_cname', LPWSTR),\n        ('sesi2_username', LPWSTR),\n        ('sesi2_num_opens', DWORD),\n        ('sesi2_time', DWORD),\n        ('sesi2_idle_time', DWORD),\n        ('sesi2_user_flags', DWORD),\n        ('sesi2_cltype_name', LPWSTR),\n    )",
  "class LPSESSION_INFO_2(NDRPOINTER):\n    referent = (\n        ('Data', SESSION_INFO_2),\n    )",
  "class SESSION_INFO_2_ARRAY(NDRUniConformantArray):\n    item = SESSION_INFO_2",
  "class LPSESSION_INFO_2_ARRAY(NDRPOINTER):\n    referent = (\n        ('Data', SESSION_INFO_2_ARRAY),\n    )",
  "class SESSION_INFO_10(NDRSTRUCT):\n    structure = (\n        ('sesi10_cname', LPWSTR),\n        ('sesi10_username', LPWSTR),\n        ('sesi10_time', DWORD),\n        ('sesi10_idle_time', DWORD),\n    )",
  "class LPSESSION_INFO_10(NDRPOINTER):\n    referent = (\n        ('Data', SESSION_INFO_10),\n    )",
  "class SESSION_INFO_10_ARRAY(NDRUniConformantArray):\n    item = SESSION_INFO_10",
  "class LPSESSION_INFO_10_ARRAY(NDRPOINTER):\n    referent = (\n        ('Data', SESSION_INFO_10_ARRAY),\n    )",
  "class SESSION_INFO_502(NDRSTRUCT):\n    structure = (\n        ('sesi502_cname', LPWSTR),\n        ('sesi502_username', LPWSTR),\n        ('sesi502_num_opens', DWORD),\n        ('sesi502_time', DWORD),\n        ('sesi502_idle_time', DWORD),\n        ('sesi502_user_flags', DWORD),\n        ('sesi502_cltype_name', LPWSTR),\n        ('sesi502_transport', LPWSTR),\n    )",
  "class LPSESSION_INFO_502(NDRPOINTER):\n    referent = (\n        ('Data', SESSION_INFO_502),\n    )",
  "class SESSION_INFO_502_ARRAY(NDRUniConformantArray):\n    item = SESSION_INFO_502",
  "class LPSESSION_INFO_502_ARRAY(NDRPOINTER):\n    referent = (\n        ('Data', SESSION_INFO_502_ARRAY),\n    )",
  "class SESSION_INFO_0_CONTAINER(NDRSTRUCT):\n    structure = (\n        ('EntriesRead', DWORD),\n        ('Buffer', LPSESSION_INFO_0_ARRAY),\n    )",
  "class LPSESSION_INFO_0_CONTAINER(NDRPOINTER):\n    referent = (\n        ('Data', SESSION_INFO_0_CONTAINER),\n    )",
  "class SESSION_INFO_1_CONTAINER(NDRSTRUCT):\n    structure = (\n        ('EntriesRead', DWORD),\n        ('Buffer', LPSESSION_INFO_1_ARRAY),\n    )",
  "class LPSESSION_INFO_1_CONTAINER(NDRPOINTER):\n    referent = (\n        ('Data', SESSION_INFO_1_CONTAINER),\n    )",
  "class SESSION_INFO_2_CONTAINER(NDRSTRUCT):\n    structure = (\n        ('EntriesRead', DWORD),\n        ('Buffer', LPSESSION_INFO_2_ARRAY),\n    )",
  "class LPSESSION_INFO_2_CONTAINER(NDRPOINTER):\n    referent = (\n        ('Data', SESSION_INFO_2_CONTAINER),\n    )",
  "class SESSION_INFO_10_CONTAINER(NDRSTRUCT):\n    structure = (\n        ('EntriesRead', DWORD),\n        ('Buffer', LPSESSION_INFO_10_ARRAY),\n    )",
  "class LPSESSION_INFO_10_CONTAINER(NDRPOINTER):\n    referent = (\n        ('Data', SESSION_INFO_10_CONTAINER),\n    )",
  "class SESSION_INFO_502_CONTAINER(NDRSTRUCT):\n    structure = (\n        ('EntriesRead', DWORD),\n        ('Buffer', LPSESSION_INFO_502_ARRAY),\n    )",
  "class LPSESSION_INFO_502_CONTAINER(NDRPOINTER):\n    referent = (\n        ('Data', SESSION_INFO_502_CONTAINER),\n    )",
  "class SESSION_ENUM_UNION(NDRUNION):\n    commonHdr = (\n        ('tag', DWORD),\n    )\n\n    union = {\n        0: ('Level0', LPSESSION_INFO_0_CONTAINER),\n        1: ('Level1', LPSESSION_INFO_1_CONTAINER),\n        2: ('Level2', LPSESSION_INFO_2_CONTAINER),\n        10: ('Level10', LPSESSION_INFO_10_CONTAINER),\n        502: ('Level502', LPSESSION_INFO_502_CONTAINER),\n    }",
  "class SESSION_ENUM_STRUCT(NDRSTRUCT):\n    structure = (\n        ('Level', DWORD),\n        ('SessionInfo', SESSION_ENUM_UNION),\n    )",
  "class SHARE_INFO_0(NDRSTRUCT):\n    structure = (\n        ('shi0_netname', LPWSTR),\n    )",
  "class LPSHARE_INFO_0(NDRPOINTER):\n    referent = (\n        ('Data', SHARE_INFO_0),\n    )",
  "class SHARE_INFO_0_ARRAY(NDRUniConformantArray):\n    item = SHARE_INFO_0",
  "class LPSHARE_INFO_0_ARRAY(NDRPOINTER):\n    referent = (\n        ('Data', SHARE_INFO_0_ARRAY),\n    )",
  "class SHARE_INFO_1(NDRSTRUCT):\n    structure = (\n        ('shi1_netname', LPWSTR),\n        ('shi1_type', DWORD),\n        ('shi1_remark', LPWSTR),\n    )",
  "class LPSHARE_INFO_1(NDRPOINTER):\n    referent = (\n        ('Data', SHARE_INFO_1),\n    )",
  "class SHARE_INFO_1_ARRAY(NDRUniConformantArray):\n    item = SHARE_INFO_1",
  "class LPSHARE_INFO_1_ARRAY(NDRPOINTER):\n    referent = (\n        ('Data', SHARE_INFO_1_ARRAY),\n    )",
  "class SHARE_INFO_2(NDRSTRUCT):\n    structure = (\n        ('shi2_netname', LPWSTR),\n        ('shi2_type', DWORD),\n        ('shi2_remark', LPWSTR),\n        ('shi2_permissions', DWORD),\n        ('shi2_max_uses', DWORD),\n        ('shi2_current_uses', DWORD),\n        ('shi2_path', LPWSTR),\n        ('shi2_passwd', LPWSTR),\n    )",
  "class LPSHARE_INFO_2(NDRPOINTER):\n    referent = (\n        ('Data', SHARE_INFO_2),\n    )",
  "class SHARE_INFO_2_ARRAY(NDRUniConformantArray):\n    item = SHARE_INFO_2",
  "class LPSHARE_INFO_2_ARRAY(NDRPOINTER):\n    referent = (\n        ('Data', SHARE_INFO_2_ARRAY),\n    )",
  "class SHARE_INFO_501(NDRSTRUCT):\n    structure = (\n        ('shi501_netname', LPWSTR),\n        ('shi501_type', DWORD),\n        ('shi501_remark', LPWSTR),\n        ('shi501_flags', DWORD),\n    )",
  "class LPSHARE_INFO_501(NDRPOINTER):\n    referent = (\n        ('Data', SHARE_INFO_501),\n    )",
  "class SHARE_INFO_501_ARRAY(NDRUniConformantArray):\n    item = SHARE_INFO_501",
  "class LPSHARE_INFO_501_ARRAY(NDRPOINTER):\n    referent = (\n        ('Data', SHARE_INFO_501_ARRAY),\n    )",
  "class SHARE_INFO_502(NDRSTRUCT):\n    structure = (\n        ('shi502_netname', LPWSTR),\n        ('shi502_type', DWORD),\n        ('shi502_remark', LPWSTR),\n        ('shi502_permissions', DWORD),\n        ('shi502_max_uses', DWORD),\n        ('shi502_current_uses', DWORD),\n        ('shi502_path', LPWSTR),\n        ('shi502_passwd', LPWSTR),\n        ('shi502_reserved', DWORD),\n        ('shi502_security_descriptor', LPBYTE),\n    )",
  "class LPSHARE_INFO_502(NDRPOINTER):\n    referent = (\n        ('Data', SHARE_INFO_502),\n    )",
  "class SHARE_INFO_502_ARRAY(NDRUniConformantArray):\n    item = SHARE_INFO_502",
  "class LPSHARE_INFO_502_ARRAY(NDRPOINTER):\n    referent = (\n        ('Data', SHARE_INFO_502_ARRAY),\n    )",
  "class SHARE_INFO_503(NDRSTRUCT):\n    structure = (\n        ('shi503_netname', LPWSTR),\n        ('shi503_type', DWORD),\n        ('shi503_remark', LPWSTR),\n        ('shi503_permissions', DWORD),\n        ('shi503_max_uses', DWORD),\n        ('shi503_current_uses', DWORD),\n        ('shi503_path', LPWSTR),\n        ('shi503_passwd', LPWSTR),\n        ('shi503_servername', LPWSTR),\n        ('shi503_reserved', DWORD),\n        ('shi503_security_descriptor', LPBYTE),\n    )",
  "class LPSHARE_INFO_503(NDRPOINTER):\n    referent = (\n        ('Data', SHARE_INFO_503),\n    )",
  "class SHARE_INFO_503_ARRAY(NDRUniConformantArray):\n    item = SHARE_INFO_503",
  "class LPSHARE_INFO_503_ARRAY(NDRPOINTER):\n    referent = (\n        ('Data', SHARE_INFO_503_ARRAY),\n    )",
  "class SHARE_INFO_1004(NDRSTRUCT):\n    structure = (\n        ('shi1004_remark', LPWSTR),\n    )",
  "class LPSHARE_INFO_1004(NDRPOINTER):\n    referent = (\n        ('Data', SHARE_INFO_1004),\n    )",
  "class SHARE_INFO_1004_ARRAY(NDRUniConformantArray):\n    item = SHARE_INFO_1004",
  "class LPSHARE_INFO_1004_ARRAY(NDRPOINTER):\n    referent = (\n        ('Data', SHARE_INFO_1004_ARRAY),\n    )",
  "class SHARE_INFO_1005(NDRSTRUCT):\n    structure = (\n        ('shi1005_flags', DWORD),\n    )",
  "class LPSHARE_INFO_1005(NDRPOINTER):\n    referent = (\n        ('Data', SHARE_INFO_1005),\n    )",
  "class SHARE_INFO_1005_ARRAY(NDRUniConformantArray):\n    item = SHARE_INFO_1004",
  "class LPSHARE_INFO_1005_ARRAY(NDRPOINTER):\n    referent = (\n        ('Data', SHARE_INFO_1005_ARRAY),\n    )",
  "class SHARE_INFO_1006(NDRSTRUCT):\n    structure = (\n        ('shi1006_max_uses', DWORD),\n    )",
  "class LPSHARE_INFO_1006(NDRPOINTER):\n    referent = (\n        ('Data', SHARE_INFO_1006),\n    )",
  "class SHARE_INFO_1006_ARRAY(NDRUniConformantArray):\n    item = SHARE_INFO_1006",
  "class LPSHARE_INFO_1006_ARRAY(NDRPOINTER):\n    referent = (\n        ('Data', SHARE_INFO_1006_ARRAY),\n    )",
  "class SHARE_INFO_1501(NDRSTRUCT):\n    structure = (\n        ('shi1501_reserved', DWORD),\n        ('shi1501_security_descriptor', NDRUniConformantArray),\n    )",
  "class LPSHARE_INFO_1501(NDRPOINTER):\n    referent = (\n        ('Data', SHARE_INFO_1501),\n    )",
  "class SHARE_INFO_1501_ARRAY(NDRUniConformantArray):\n    item = SHARE_INFO_1501",
  "class LPSHARE_INFO_1501_ARRAY(NDRPOINTER):\n    referent = (\n        ('Data', SHARE_INFO_1501_ARRAY),\n    )",
  "class SHARE_INFO_0_CONTAINER(NDRSTRUCT):\n    structure = (\n        ('EntriesRead', DWORD),\n        ('Buffer', LPSHARE_INFO_0_ARRAY),\n    )",
  "class LPSHARE_INFO_0_CONTAINER(NDRPOINTER):\n    referent = (\n        ('Data', SHARE_INFO_0_CONTAINER),\n    )",
  "class SHARE_INFO_1_CONTAINER(NDRSTRUCT):\n    structure = (\n        ('EntriesRead', DWORD),\n        ('Buffer', LPSHARE_INFO_1_ARRAY),\n    )",
  "class LPSHARE_INFO_1_CONTAINER(NDRPOINTER):\n    referent = (\n        ('Data', SHARE_INFO_1_CONTAINER),\n    )",
  "class SHARE_INFO_2_CONTAINER(NDRSTRUCT):\n    structure = (\n        ('EntriesRead', DWORD),\n        ('Buffer', LPSHARE_INFO_2_ARRAY),\n    )",
  "class LPSHARE_INFO_2_CONTAINER(NDRPOINTER):\n    referent = (\n        ('Data', SHARE_INFO_2_CONTAINER),\n    )",
  "class SHARE_INFO_501_CONTAINER(NDRSTRUCT):\n    structure = (\n        ('EntriesRead', DWORD),\n        ('Buffer', LPSHARE_INFO_501_ARRAY),\n    )",
  "class LPSHARE_INFO_501_CONTAINER(NDRPOINTER):\n    referent = (\n        ('Data', SHARE_INFO_501_CONTAINER),\n    )",
  "class SHARE_INFO_502_CONTAINER(NDRSTRUCT):\n    structure = (\n        ('EntriesRead', DWORD),\n        ('Buffer', LPSHARE_INFO_502_ARRAY),\n    )",
  "class LPSHARE_INFO_502_CONTAINER(NDRPOINTER):\n    referent = (\n        ('Data', SHARE_INFO_502_CONTAINER),\n    )",
  "class SHARE_INFO_503_CONTAINER(NDRSTRUCT):\n    structure = (\n        ('EntriesRead', DWORD),\n        ('Buffer', LPSHARE_INFO_503_ARRAY),\n    )",
  "class LPSHARE_INFO_503_CONTAINER(NDRPOINTER):\n    referent = (\n        ('Data', SHARE_INFO_503_CONTAINER),\n    )",
  "class SHARE_ENUM_UNION(NDRUNION):\n    commonHdr = (\n        ('tag', DWORD),\n    )\n\n    union = {\n        0: ('Level0', LPSHARE_INFO_0_CONTAINER),\n        1: ('Level1', LPSHARE_INFO_1_CONTAINER),\n        2: ('Level2', LPSHARE_INFO_2_CONTAINER),\n        501: ('Level501', LPSHARE_INFO_501_CONTAINER),\n        502: ('Level502', LPSHARE_INFO_502_CONTAINER),\n        503: ('Level503', LPSHARE_INFO_503_CONTAINER),\n    }",
  "class SHARE_ENUM_STRUCT(NDRSTRUCT):\n    structure = (\n        ('Level', DWORD),\n        ('ShareInfo', SHARE_ENUM_UNION),\n    )",
  "class STAT_SERVER_0(NDRSTRUCT):\n    structure = (\n        ('sts0_start', DWORD),\n        ('sts0_fopens', DWORD),\n        ('sts0_devopens', DWORD),\n        ('sts0_jobsqueued', DWORD),\n        ('sts0_sopens', DWORD),\n        ('sts0_stimedout', DWORD),\n        ('sts0_serrorout', DWORD),\n        ('sts0_pwerrors', DWORD),\n        ('sts0_permerrors', DWORD),\n        ('sts0_syserrors', DWORD),\n        ('sts0_bytessent_low', DWORD),\n        ('sts0_bytessent_high', DWORD),\n        ('sts0_bytesrcvd_low', DWORD),\n        ('sts0_bytesrcvd_high', DWORD),\n        ('sts0_avresponse', DWORD),\n        ('sts0_reqbufneed', DWORD),\n        ('sts0_bigbufneed', DWORD),\n    )",
  "class LPSTAT_SERVER_0(NDRPOINTER):\n    referent = (\n        ('Data', STAT_SERVER_0),\n    )",
  "class SERVER_INFO_100(NDRSTRUCT):\n    structure = (\n        ('sv100_platform_id', DWORD),\n        ('sv100_name', LPWSTR),\n    )",
  "class LPSERVER_INFO_100(NDRPOINTER):\n    referent = (\n        ('Data', SERVER_INFO_100),\n    )",
  "class SERVER_INFO_101(NDRSTRUCT):\n    structure = (\n        ('sv101_platform_id', DWORD),\n        ('sv101_name', LPWSTR),\n        ('sv101_version_major', DWORD),\n        ('sv101_version_minor', DWORD),\n        ('sv101_type', DWORD),\n        ('sv101_comment', LPWSTR),\n    )",
  "class LPSERVER_INFO_101(NDRPOINTER):\n    referent = (\n        ('Data', SERVER_INFO_101),\n    )",
  "class SERVER_INFO_102(NDRSTRUCT):\n    structure = (\n        ('sv102_platform_id', DWORD),\n        ('sv102_name', LPWSTR),\n        ('sv102_version_major', DWORD),\n        ('sv102_version_minor', DWORD),\n        ('sv102_type', DWORD),\n        ('sv102_comment', LPWSTR),\n        ('sv102_users', DWORD),\n        ('sv102_disc', DWORD),\n        ('sv102_hidden', DWORD),\n        ('sv102_announce', DWORD),\n        ('sv102_anndelta', DWORD),\n        ('sv102_licenses', DWORD),\n        ('sv102_userpath', LPWSTR),\n    )",
  "class LPSERVER_INFO_102(NDRPOINTER):\n    referent = (\n        ('Data', SERVER_INFO_102),\n    )",
  "class SERVER_INFO_103(NDRSTRUCT):\n    structure = (\n        ('sv103_platform_id', DWORD),\n        ('sv103_name', LPWSTR),\n        ('sv103_version_major', DWORD),\n        ('sv103_version_minor', DWORD),\n        ('sv103_type', DWORD),\n        ('sv103_comment', LPWSTR),\n        ('sv103_users', DWORD),\n        ('sv103_disc', DWORD),\n        ('sv103_hidden', DWORD),\n        ('sv103_announce', DWORD),\n        ('sv103_anndelta', DWORD),\n        ('sv103_licenses', DWORD),\n        ('sv103_userpath', LPWSTR),\n        ('sv103_capabilities', DWORD),\n    )",
  "class LPSERVER_INFO_103(NDRPOINTER):\n    referent = (\n        ('Data', SERVER_INFO_103),\n    )",
  "class SERVER_INFO_502(NDRSTRUCT):\n    structure = (\n        ('sv502_sessopens', DWORD),\n        ('sv502_sessvcs', DWORD),\n        ('sv502_opensearch', DWORD),\n        ('sv502_sizreqbuf', DWORD),\n        ('sv502_initworkitems', DWORD),\n        ('sv502_maxworkitems', DWORD),\n        ('sv502_rawworkitems', DWORD),\n        ('sv502_irpstacksize', DWORD),\n        ('sv502_maxrawbuflen', DWORD),\n        ('sv502_sessusers', DWORD),\n        ('sv502_sessconns', DWORD),\n        ('sv502_maxpagedmemoryusage', DWORD),\n        ('sv502_maxnonpagedmemoryusage', DWORD),\n        ('sv502_enablesoftcompat', DWORD),\n        ('sv502_enableforcedlogoff', DWORD),\n        ('sv502_timesource', DWORD),\n        ('sv502_acceptdownlevelapis', DWORD),\n        ('sv502_lmannounce', DWORD),\n    )",
  "class LPSERVER_INFO_502(NDRPOINTER):\n    referent = (\n        ('Data', SERVER_INFO_502),\n    )",
  "class SERVER_INFO_503(NDRSTRUCT):\n    structure = (\n        ('sv503_sessopens', DWORD),\n        ('sv503_sessvcs', DWORD),\n        ('sv503_opensearch', DWORD),\n        ('sv503_sizreqbuf', DWORD),\n        ('sv503_initworkitems', DWORD),\n        ('sv503_maxworkitems', DWORD),\n        ('sv503_rawworkitems', DWORD),\n        ('sv503_irpstacksize', DWORD),\n        ('sv503_maxrawbuflen', DWORD),\n        ('sv503_sessusers', DWORD),\n        ('sv503_sessconns', DWORD),\n        ('sv503_maxpagedmemoryusage', DWORD),\n        ('sv503_maxnonpagedmemoryusage', DWORD),\n        ('sv503_enablesoftcompat', DWORD),\n        ('sv503_enableforcedlogoff', DWORD),\n        ('sv503_timesource', DWORD),\n        ('sv503_acceptdownlevelapis', DWORD),\n        ('sv503_lmannounce', DWORD),\n        ('sv503_domain', LPWSTR),\n        ('sv503_maxcopyreadlen', DWORD),\n        ('sv503_maxcopywritelen', DWORD),\n        ('sv503_minkeepsearch', DWORD),\n        ('sv503_maxkeepsearch', DWORD),\n        ('sv503_minkeepcomplsearch', DWORD),\n        ('sv503_maxkeepcomplsearch', DWORD),\n        ('sv503_threadcountadd', DWORD),\n        ('sv503_numblockthreads', DWORD),\n        ('sv503_scavtimeout', DWORD),\n        ('sv503_minrcvqueue', DWORD),\n        ('sv503_minfreeworkitems', DWORD),\n        ('sv503_xactmemsize', DWORD),\n        ('sv503_threadpriority', DWORD),\n        ('sv503_maxmpxct', DWORD),\n        ('sv503_oplockbreakwait', DWORD),\n        ('sv503_oplockbreakresponsewait', DWORD),\n        ('sv503_enableoplocks', DWORD),\n        ('sv503_enableoplockforceclose', DWORD),\n        ('sv503_enablefcbopens', DWORD),\n        ('sv503_enableraw', DWORD),\n        ('sv503_enablesharednetdrives', DWORD),\n        ('sv503_minfreeconnections', DWORD),\n        ('sv503_maxfreeconnections', DWORD),\n    )",
  "class LPSERVER_INFO_503(NDRPOINTER):\n    referent = (\n        ('Data', SERVER_INFO_503),\n    )",
  "class SERVER_INFO_599(NDRSTRUCT):\n    structure = (\n        ('sv599_sessopens', DWORD),\n        ('sv599_sessvcs', DWORD),\n        ('sv599_opensearch', DWORD),\n        ('sv599_sizreqbuf', DWORD),\n        ('sv599_initworkitems', DWORD),\n        ('sv599_maxworkitems', DWORD),\n        ('sv599_rawworkitems', DWORD),\n        ('sv599_irpstacksize', DWORD),\n        ('sv599_maxrawbuflen', DWORD),\n        ('sv599_sessusers', DWORD),\n        ('sv599_sessconns', DWORD),\n        ('sv599_maxpagedmemoryusage', DWORD),\n        ('sv599_maxnonpagedmemoryusage', DWORD),\n        ('sv599_enablesoftcompat', DWORD),\n        ('sv599_enableforcedlogoff', DWORD),\n        ('sv599_timesource', DWORD),\n        ('sv599_acceptdownlevelapis', DWORD),\n        ('sv599_lmannounce', DWORD),\n        ('sv599_domain', LPWSTR),\n        ('sv599_maxcopyreadlen', DWORD),\n        ('sv599_maxcopywritelen', DWORD),\n        ('sv599_minkeepsearch', DWORD),\n        ('sv599_maxkeepsearch', DWORD),\n        ('sv599_minkeepcomplsearch', DWORD),\n        ('sv599_maxkeepcomplsearch', DWORD),\n        ('sv599_threadcountadd', DWORD),\n        ('sv599_numblockthreads', DWORD),\n        ('sv599_scavtimeout', DWORD),\n        ('sv599_minrcvqueue', DWORD),\n        ('sv599_minfreeworkitems', DWORD),\n        ('sv599_xactmemsize', DWORD),\n        ('sv599_threadpriority', DWORD),\n        ('sv599_maxmpxct', DWORD),\n        ('sv599_oplockbreakwait', DWORD),\n        ('sv599_oplockbreakresponsewait', DWORD),\n        ('sv599_enableoplocks', DWORD),\n        ('sv599_enableoplockforceclose', DWORD),\n        ('sv599_enablefcbopens', DWORD),\n        ('sv599_enableraw', DWORD),\n        ('sv599_enablesharednetdrives', DWORD),\n        ('sv599_minfreeconnections', DWORD),\n        ('sv599_maxfreeconnections', DWORD),\n        ('sv599_initsesstable', DWORD),\n        ('sv599_initconntable', DWORD),\n        ('sv599_initfiletable', DWORD),\n        ('sv599_initsearchtable', DWORD),\n        ('sv599_alertschedule', DWORD),\n        ('sv599_errorthreshold', DWORD),\n        ('sv599_networkerrorthreshold', DWORD),\n        ('sv599_diskspacethreshold', DWORD),\n        ('sv599_reserved', DWORD),\n        ('sv599_maxlinkdelay', DWORD),\n        ('sv599_minlinkthroughput', DWORD),\n        ('sv599_linkinfovalidtime', DWORD),\n        ('sv599_scavqosinfoupdatetime', DWORD),\n        ('sv599_maxworkitemidletime', DWORD),\n    )",
  "class LPSERVER_INFO_599(NDRPOINTER):\n    referent = (\n        ('Data', SERVER_INFO_599),\n    )",
  "class SERVER_INFO_1005(NDRSTRUCT):\n    structure = (\n        ('sv1005_comment', LPWSTR),\n    )",
  "class LPSERVER_INFO_1005(NDRPOINTER):\n    referent = (\n        ('Data', SERVER_INFO_1005),\n    )",
  "class SERVER_INFO_1107(NDRSTRUCT):\n    structure = (\n        ('sv1107_users', DWORD),\n    )",
  "class LPSERVER_INFO_1107(NDRPOINTER):\n    referent = (\n        ('Data', SERVER_INFO_1107),\n    )",
  "class SERVER_INFO_1010(NDRSTRUCT):\n    structure = (\n        ('sv1010_disc', DWORD),\n    )",
  "class LPSERVER_INFO_1010(NDRPOINTER):\n    referent = (\n        ('Data', SERVER_INFO_1010),\n    )",
  "class SERVER_INFO_1016(NDRSTRUCT):\n    structure = (\n        ('sv1016_hidden', DWORD),\n    )",
  "class LPSERVER_INFO_1016(NDRPOINTER):\n    referent = (\n        ('Data', SERVER_INFO_1016),\n    )",
  "class SERVER_INFO_1017(NDRSTRUCT):\n    structure = (\n        ('sv1017_announce', DWORD),\n    )",
  "class LPSERVER_INFO_1017(NDRPOINTER):\n    referent = (\n        ('Data', SERVER_INFO_1017),\n    )",
  "class SERVER_INFO_1018(NDRSTRUCT):\n    structure = (\n        ('sv1018_anndelta', DWORD),\n    )",
  "class LPSERVER_INFO_1018(NDRPOINTER):\n    referent = (\n        ('Data', SERVER_INFO_1018),\n    )",
  "class SERVER_INFO_1501(NDRSTRUCT):\n    structure = (\n        ('sv1501_sessopens', DWORD),\n    )",
  "class LPSERVER_INFO_1501(NDRPOINTER):\n    referent = (\n        ('Data', SERVER_INFO_1501),\n    )",
  "class SERVER_INFO_1502(NDRSTRUCT):\n    structure = (\n        ('sv1502_sessvcs', DWORD),\n    )",
  "class LPSERVER_INFO_1502(NDRPOINTER):\n    referent = (\n        ('Data', SERVER_INFO_1502),\n    )",
  "class SERVER_INFO_1503(NDRSTRUCT):\n    structure = (\n        ('sv1503_opensearch', DWORD),\n    )",
  "class LPSERVER_INFO_1503(NDRPOINTER):\n    referent = (\n        ('Data', SERVER_INFO_1503),\n    )",
  "class SERVER_INFO_1506(NDRSTRUCT):\n    structure = (\n        ('sv1506_maxworkitems', DWORD),\n    )",
  "class LPSERVER_INFO_1506(NDRPOINTER):\n    referent = (\n        ('Data', SERVER_INFO_1506),\n    )",
  "class SERVER_INFO_1510(NDRSTRUCT):\n    structure = (\n        ('sv1510_sessusers', DWORD),\n    )",
  "class LPSERVER_INFO_1510(NDRPOINTER):\n    referent = (\n        ('Data', SERVER_INFO_1510),\n    )",
  "class SERVER_INFO_1511(NDRSTRUCT):\n    structure = (\n        ('sv1511_sessconns', DWORD),\n    )",
  "class LPSERVER_INFO_1511(NDRPOINTER):\n    referent = (\n        ('Data', SERVER_INFO_1511),\n    )",
  "class SERVER_INFO_1512(NDRSTRUCT):\n    structure = (\n        ('sv1512_maxnonpagedmemoryusage', DWORD),\n    )",
  "class LPSERVER_INFO_1512(NDRPOINTER):\n    referent = (\n        ('Data', SERVER_INFO_1512),\n    )",
  "class SERVER_INFO_1513(NDRSTRUCT):\n    structure = (\n        ('sv1513_maxpagedmemoryusage', DWORD),\n    )",
  "class LPSERVER_INFO_1513(NDRPOINTER):\n    referent = (\n        ('Data', SERVER_INFO_1513),\n    )",
  "class SERVER_INFO_1514(NDRSTRUCT):\n    structure = (\n        ('sv1514_enablesoftcompat', DWORD),\n    )",
  "class LPSERVER_INFO_1514(NDRPOINTER):\n    referent = (\n        ('Data', SERVER_INFO_1514),\n    )",
  "class SERVER_INFO_1515(NDRSTRUCT):\n    structure = (\n        ('sv1515_enableforcedlogoff', DWORD),\n    )",
  "class LPSERVER_INFO_1515(NDRPOINTER):\n    referent = (\n        ('Data', SERVER_INFO_1515),\n    )",
  "class SERVER_INFO_1516(NDRSTRUCT):\n    structure = (\n        ('sv1516_timesource', DWORD),\n    )",
  "class LPSERVER_INFO_1516(NDRPOINTER):\n    referent = (\n        ('Data', SERVER_INFO_1516),\n    )",
  "class SERVER_INFO_1518(NDRSTRUCT):\n    structure = (\n        ('sv1518_lmannounce', DWORD),\n    )",
  "class LPSERVER_INFO_1518(NDRPOINTER):\n    referent = (\n        ('Data', SERVER_INFO_1518),\n    )",
  "class SERVER_INFO_1523(NDRSTRUCT):\n    structure = (\n        ('sv1523_maxkeepsearch', DWORD),\n    )",
  "class LPSERVER_INFO_1523(NDRPOINTER):\n    referent = (\n        ('Data', SERVER_INFO_1523),\n    )",
  "class SERVER_INFO_1528(NDRSTRUCT):\n    structure = (\n        ('sv1528_scavtimeout', DWORD),\n    )",
  "class LPSERVER_INFO_1528(NDRPOINTER):\n    referent = (\n        ('Data', SERVER_INFO_1528),\n    )",
  "class SERVER_INFO_1529(NDRSTRUCT):\n    structure = (\n        ('sv1529_minrcvqueue', DWORD),\n    )",
  "class LPSERVER_INFO_1529(NDRPOINTER):\n    referent = (\n        ('Data', SERVER_INFO_1529),\n    )",
  "class SERVER_INFO_1530(NDRSTRUCT):\n    structure = (\n        ('sv1530_minfreeworkitems', DWORD),\n    )",
  "class LPSERVER_INFO_1530(NDRPOINTER):\n    referent = (\n        ('Data', SERVER_INFO_1530),\n    )",
  "class SERVER_INFO_1533(NDRSTRUCT):\n    structure = (\n        ('sv1533_maxmpxct', DWORD),\n    )",
  "class LPSERVER_INFO_1533(NDRPOINTER):\n    referent = (\n        ('Data', SERVER_INFO_1533),\n    )",
  "class SERVER_INFO_1534(NDRSTRUCT):\n    structure = (\n        ('sv1534_oplockbreakwait', DWORD),\n    )",
  "class LPSERVER_INFO_1534(NDRPOINTER):\n    referent = (\n        ('Data', SERVER_INFO_1534),\n    )",
  "class SERVER_INFO_1535(NDRSTRUCT):\n    structure = (\n        ('sv1535_oplockbreakresponsewait', DWORD),\n    )",
  "class LPSERVER_INFO_1535(NDRPOINTER):\n    referent = (\n        ('Data', SERVER_INFO_1535),\n    )",
  "class SERVER_INFO_1536(NDRSTRUCT):\n    structure = (\n        ('sv1536_enableoplocks', DWORD),\n    )",
  "class LPSERVER_INFO_1536(NDRPOINTER):\n    referent = (\n        ('Data', SERVER_INFO_1536),\n    )",
  "class SERVER_INFO_1538(NDRSTRUCT):\n    structure = (\n        ('sv1538_enablefcbopens', DWORD),\n    )",
  "class LPSERVER_INFO_1538(NDRPOINTER):\n    referent = (\n        ('Data', SERVER_INFO_1538),\n    )",
  "class SERVER_INFO_1539(NDRSTRUCT):\n    structure = (\n        ('sv1539_enableraw', DWORD),\n    )",
  "class LPSERVER_INFO_1539(NDRPOINTER):\n    referent = (\n        ('Data', SERVER_INFO_1539),\n    )",
  "class SERVER_INFO_1540(NDRSTRUCT):\n    structure = (\n        ('sv1540_enablesharednetdrives', DWORD),\n    )",
  "class LPSERVER_INFO_1540(NDRPOINTER):\n    referent = (\n        ('Data', SERVER_INFO_1540),\n    )",
  "class SERVER_INFO_1541(NDRSTRUCT):\n    structure = (\n        ('sv1541_minfreeconnections', DWORD),\n    )",
  "class LPSERVER_INFO_1541(NDRPOINTER):\n    referent = (\n        ('Data', SERVER_INFO_1541),\n    )",
  "class SERVER_INFO_1542(NDRSTRUCT):\n    structure = (\n        ('sv1542_maxfreeconnections', DWORD),\n    )",
  "class LPSERVER_INFO_1542(NDRPOINTER):\n    referent = (\n        ('Data', SERVER_INFO_1542),\n    )",
  "class SERVER_INFO_1543(NDRSTRUCT):\n    structure = (\n        ('sv1543_initsesstable', DWORD),\n    )",
  "class LPSERVER_INFO_1543(NDRPOINTER):\n    referent = (\n        ('Data', SERVER_INFO_1543),\n    )",
  "class SERVER_INFO_1544(NDRSTRUCT):\n    structure = (\n        ('sv1544_initconntable', DWORD),\n    )",
  "class LPSERVER_INFO_1544(NDRPOINTER):\n    referent = (\n        ('Data', SERVER_INFO_1544),\n    )",
  "class SERVER_INFO_1545(NDRSTRUCT):\n    structure = (\n        ('sv1545_initfiletable', DWORD),\n    )",
  "class LPSERVER_INFO_1545(NDRPOINTER):\n    referent = (\n        ('Data', SERVER_INFO_1545),\n    )",
  "class SERVER_INFO_1546(NDRSTRUCT):\n    structure = (\n        ('sv1546_initsearchtable', DWORD),\n    )",
  "class LPSERVER_INFO_1546(NDRPOINTER):\n    referent = (\n        ('Data', SERVER_INFO_1546),\n    )",
  "class SERVER_INFO_1547(NDRSTRUCT):\n    structure = (\n        ('sv1547_alertschedule', DWORD),\n    )",
  "class LPSERVER_INFO_1547(NDRPOINTER):\n    referent = (\n        ('Data', SERVER_INFO_1547),\n    )",
  "class SERVER_INFO_1548(NDRSTRUCT):\n    structure = (\n        ('sv1548_errorthreshold', DWORD),\n    )",
  "class LPSERVER_INFO_1548(NDRPOINTER):\n    referent = (\n        ('Data', SERVER_INFO_1548),\n    )",
  "class SERVER_INFO_1549(NDRSTRUCT):\n    structure = (\n        ('sv1549_networkerrorthreshold', DWORD),\n    )",
  "class LPSERVER_INFO_1549(NDRPOINTER):\n    referent = (\n        ('Data', SERVER_INFO_1549),\n    )",
  "class SERVER_INFO_1550(NDRSTRUCT):\n    structure = (\n        ('sv1550_diskspacethreshold', DWORD),\n    )",
  "class LPSERVER_INFO_1550(NDRPOINTER):\n    referent = (\n        ('Data', SERVER_INFO_1550),\n    )",
  "class SERVER_INFO_1552(NDRSTRUCT):\n    structure = (\n        ('sv1552_maxlinkdelay', DWORD),\n    )",
  "class LPSERVER_INFO_1552(NDRPOINTER):\n    referent = (\n        ('Data', SERVER_INFO_1552),\n    )",
  "class SERVER_INFO_1553(NDRSTRUCT):\n    structure = (\n        ('sv1553_minlinkthroughput', DWORD),\n    )",
  "class LPSERVER_INFO_1553(NDRPOINTER):\n    referent = (\n        ('Data', SERVER_INFO_1553),\n    )",
  "class SERVER_INFO_1554(NDRSTRUCT):\n    structure = (\n        ('sv1554_linkinfovalidtime', DWORD),\n    )",
  "class LPSERVER_INFO_1554(NDRPOINTER):\n    referent = (\n        ('Data', SERVER_INFO_1554),\n    )",
  "class SERVER_INFO_1555(NDRSTRUCT):\n    structure = (\n        ('sv1555_scavqosinfoupdatetime', DWORD),\n    )",
  "class LPSERVER_INFO_1555(NDRPOINTER):\n    referent = (\n        ('Data', SERVER_INFO_1555),\n    )",
  "class SERVER_INFO_1556(NDRSTRUCT):\n    structure = (\n        ('sv1556_maxworkitemidletime', DWORD),\n    )",
  "class LPSERVER_INFO_1556(NDRPOINTER):\n    referent = (\n        ('Data', SERVER_INFO_1556),\n    )",
  "class WCHAR_ARRAY(NDRSTRUCT):\n    commonHdr = (\n        ('Offset','<L=0'),\n        ('ActualCount','<L=len(Data)//2'),\n    )\n    commonHdr64 = (\n        ('Offset','<Q=0'),\n        ('ActualCount','<Q=len(Data)//2'),\n    )\n    structure = (\n        ('Data',':'),\n    )\n\n    def dump(self, msg = None, indent = 0):\n        if msg is None:\n            msg = self.__class__.__name__\n        if msg != '':\n            print(\"%s\" % msg, end=' ')\n        # Here just print the data\n        print(\" %r\" % (self['Data']), end=' ')\n\n    def __setitem__(self, key, value):\n        if key == 'Data':\n            try:\n                self.fields[key] = value.encode('utf-16le')\n            except UnicodeDecodeError:\n                import sys\n                self.fields[key] = value.decode(sys.getfilesystemencoding()).encode('utf-16le')\n            self.fields['ActualCount'] = None\n            self.data = None        # force recompute\n        else:\n            return NDR.__setitem__(self, key, value)\n\n    def __getitem__(self, key):\n        if key == 'Data':\n            return self.fields[key].decode('utf-16le')\n        else:\n            return NDR.__getitem__(self,key)\n\n    def getDataLen(self, data, offset=0):\n        return self[\"ActualCount\"]*2",
  "class DISK_INFO(NDRSTRUCT):\n    structure = (\n        ('Disk', WCHAR_ARRAY),\n    )",
  "class LPDISK_INFO(NDRPOINTER):\n    referent = (\n        ('Data', DISK_INFO),\n    )",
  "class DISK_INFO_ARRAY(NDRUniConformantVaryingArray):\n    item = DISK_INFO",
  "class LPDISK_INFO_ARRAY(NDRPOINTER):\n    referent = (\n        ('Data', DISK_INFO_ARRAY),\n    )",
  "class DISK_ENUM_CONTAINER(NDRSTRUCT):\n    structure = (\n        ('EntriesRead', DWORD),\n        ('Buffer', LPDISK_INFO_ARRAY),\n    )",
  "class LPDISK_ENUM_CONTAINER(NDRPOINTER):\n    referent = (\n        ('Data', DISK_ENUM_CONTAINER),\n    )",
  "class SERVER_TRANSPORT_INFO_0(NDRSTRUCT):\n    structure = (\n        ('svti0_numberofvcs', DWORD),\n        ('svti0_transportname', LPWSTR),\n        ('svti0_transportaddress', PNDRUniConformantArray),\n        ('svti0_transportaddresslength', DWORD),\n        ('svti0_networkaddress', LPWSTR),\n    )",
  "class LPSERVER_TRANSPORT_INFO_0(NDRPOINTER):\n    referent = (\n        ('Data', SERVER_TRANSPORT_INFO_0),\n    )",
  "class SERVER_TRANSPORT_INFO_0_ARRAY(NDRUniConformantArray):\n    item = SERVER_TRANSPORT_INFO_0",
  "class LPSERVER_TRANSPORT_INFO_0_ARRAY(NDRPOINTER):\n    referent = (\n        ('Data', SERVER_TRANSPORT_INFO_0_ARRAY),\n    )",
  "class SERVER_TRANSPORT_INFO_1(NDRSTRUCT):\n    structure = (\n        ('svti1_numberofvcs', DWORD),\n        ('svti1_transportname', LPWSTR),\n        ('svti1_transportaddress', PNDRUniConformantArray),\n        ('svti1_transportaddresslength', DWORD),\n        ('svti1_networkaddress', LPWSTR),\n        ('svti1_domain', LPWSTR),\n    )",
  "class LPSERVER_TRANSPORT_INFO_1(NDRPOINTER):\n    referent = (\n        ('Data', SERVER_TRANSPORT_INFO_1),\n    )",
  "class SERVER_TRANSPORT_INFO_1_ARRAY(NDRUniConformantArray):\n    item = SERVER_TRANSPORT_INFO_1",
  "class LPSERVER_TRANSPORT_INFO_1_ARRAY(NDRPOINTER):\n    referent = (\n        ('Data', SERVER_TRANSPORT_INFO_1_ARRAY),\n    )",
  "class SERVER_TRANSPORT_INFO_2(NDRSTRUCT):\n    structure = (\n        ('svti2_numberofvcs', DWORD),\n        ('svti2_transportname', LPWSTR),\n        ('svti2_transportaddress', PNDRUniConformantArray),\n        ('svti2_transportaddresslength', DWORD),\n        ('svti2_networkaddress', LPWSTR),\n        ('svti2_domain', LPWSTR),\n        ('svti2_flags', DWORD),\n    )",
  "class LPSERVER_TRANSPORT_INFO_2(NDRPOINTER):\n    referent = (\n        ('Data', SERVER_TRANSPORT_INFO_2),\n    )",
  "class SERVER_TRANSPORT_INFO_2_ARRAY(NDRUniConformantArray):\n    item = SERVER_TRANSPORT_INFO_2",
  "class LPSERVER_TRANSPORT_INFO_2_ARRAY(NDRPOINTER):\n    referent = (\n        ('Data', SERVER_TRANSPORT_INFO_2_ARRAY),\n    )",
  "class PASSWORD_ARRAY(NDRUniFixedArray):\n    def getDataLen(self, data, offset=0):\n        return 256",
  "class SERVER_TRANSPORT_INFO_3(NDRSTRUCT):\n    structure = (\n        ('svti3_numberofvcs', DWORD),\n        ('svti3_transportname', LPWSTR),\n        ('svti3_transportaddress', PNDRUniConformantArray),\n        ('svti3_transportaddresslength', DWORD),\n        ('svti3_networkaddress', LPWSTR),\n        ('svti3_domain', LPWSTR),\n        ('svti3_flags', DWORD),\n        ('svti3_passwordlength', DWORD),\n        ('svti3_password', PASSWORD_ARRAY),\n    )",
  "class LPSERVER_TRANSPORT_INFO_3(NDRPOINTER):\n    referent = (\n        ('Data', SERVER_TRANSPORT_INFO_3),\n    )",
  "class SERVER_TRANSPORT_INFO_3_ARRAY(NDRUniConformantArray):\n    item = SERVER_TRANSPORT_INFO_3",
  "class LPSERVER_TRANSPORT_INFO_3_ARRAY(NDRPOINTER):\n    referent = (\n        ('Data', SERVER_TRANSPORT_INFO_3_ARRAY),\n    )",
  "class SERVER_XPORT_INFO_0_CONTAINER(NDRSTRUCT):\n    structure = (\n        ('EntriesRead', DWORD),\n        ('Buffer', LPSERVER_TRANSPORT_INFO_0_ARRAY),\n    )",
  "class LPSERVER_XPORT_INFO_0_CONTAINER(NDRPOINTER):\n    referent = (\n        ('Data', SERVER_XPORT_INFO_0_CONTAINER),\n    )",
  "class SERVER_XPORT_INFO_1_CONTAINER(NDRSTRUCT):\n    structure = (\n        ('EntriesRead', DWORD),\n        ('Buffer', LPSERVER_TRANSPORT_INFO_1_ARRAY),\n    )",
  "class LPSERVER_XPORT_INFO_1_CONTAINER(NDRPOINTER):\n    referent = (\n        ('Data', SERVER_XPORT_INFO_1_CONTAINER),\n    )",
  "class SERVER_XPORT_INFO_2_CONTAINER(NDRSTRUCT):\n    structure = (\n        ('EntriesRead', DWORD),\n        ('Buffer', LPSERVER_TRANSPORT_INFO_2_ARRAY),\n    )",
  "class LPSERVER_XPORT_INFO_2_CONTAINER(NDRPOINTER):\n    referent = (\n        ('Data', SERVER_XPORT_INFO_2_CONTAINER),\n    )",
  "class SERVER_XPORT_INFO_3_CONTAINER(NDRSTRUCT):\n    structure = (\n        ('EntriesRead', DWORD),\n        ('Buffer', LPSERVER_TRANSPORT_INFO_3_ARRAY),\n    )",
  "class LPSERVER_XPORT_INFO_3_CONTAINER(NDRPOINTER):\n    referent = (\n        ('Data', SERVER_XPORT_INFO_3_CONTAINER),\n    )",
  "class SERVER_XPORT_ENUM_UNION(NDRUNION):\n    commonHdr = (\n        ('tag', DWORD),\n    )\n\n    union = {\n        0: ('Level0', LPSERVER_XPORT_INFO_0_CONTAINER),\n        1: ('Level1', LPSERVER_XPORT_INFO_1_CONTAINER),\n        2: ('Level2', LPSERVER_XPORT_INFO_2_CONTAINER),\n        3: ('Level3', LPSERVER_XPORT_INFO_3_CONTAINER),\n    }",
  "class SERVER_XPORT_ENUM_STRUCT(NDRSTRUCT):\n    structure = (\n        ('Level', DWORD),\n        ('XportInfo', SERVER_XPORT_ENUM_UNION),\n    )",
  "class SERVER_ALIAS_INFO_0(NDRSTRUCT):\n    structure = (\n        ('srvai0_alias', LMSTR),\n        ('srvai0_target', LMSTR),\n        ('srvai0_default', NDRBOOLEAN),\n        ('srvai0_reserved', ULONG),\n    )",
  "class LPSERVER_ALIAS_INFO_0(NDRPOINTER):\n    referent = (\n        ('Data', SERVER_ALIAS_INFO_0),\n    )",
  "class SERVER_ALIAS_INFO_0_ARRAY(NDRUniConformantArray):\n    item = SERVER_ALIAS_INFO_0",
  "class LPSERVER_ALIAS_INFO_0_ARRAY(NDRPOINTER):\n    referent = (\n        ('Data', SERVER_ALIAS_INFO_0_ARRAY),\n    )",
  "class SERVER_ALIAS_INFO_0_CONTAINER(NDRSTRUCT):\n    structure = (\n        ('EntriesRead', DWORD),\n        ('Buffer', LPSERVER_ALIAS_INFO_0_ARRAY),\n    )",
  "class LPSERVER_ALIAS_INFO_0_CONTAINER(NDRPOINTER):\n    referent = (\n        ('Data', SERVER_ALIAS_INFO_0_CONTAINER),\n    )",
  "class SERVER_ALIAS_ENUM_UNION(NDRUNION):\n    commonHdr = (\n        ('tag', DWORD),\n    )\n\n    union = {\n        0: ('Level0', LPSERVER_ALIAS_INFO_0_CONTAINER),\n    }",
  "class SERVER_ALIAS_ENUM_STRUCT(NDRSTRUCT):\n    structure = (\n        ('Level', DWORD),\n        ('ServerAliasInfo', SERVER_ALIAS_ENUM_UNION),\n    )",
  "class TIME_OF_DAY_INFO(NDRSTRUCT):\n    structure = (\n        ('tod_elapsedt', DWORD),\n        ('tod_msecs', DWORD),\n        ('tod_hours', DWORD),\n        ('tod_mins', DWORD),\n        ('tod_secs', DWORD),\n        ('tod_hunds', DWORD),\n        ('tod_timezone', DWORD),\n        ('tod_tinterval', DWORD),\n        ('tod_day', DWORD),\n        ('tod_month', DWORD),\n        ('tod_year', DWORD),\n        ('tod_weekday', DWORD),\n    )",
  "class LPTIME_OF_DAY_INFO(NDRPOINTER):\n    referent = (\n        ('Data', TIME_OF_DAY_INFO),\n    )",
  "class ADT_SECURITY_DESCRIPTOR(NDRSTRUCT):\n    structure = (\n        ('Length', DWORD),\n        ('Buffer', PNDRUniConformantArray),\n    )",
  "class PADT_SECURITY_DESCRIPTOR(NDRPOINTER):\n    referent = (\n        ('Data', ADT_SECURITY_DESCRIPTOR),\n    )",
  "class NET_DFS_ENTRY_ID(NDRSTRUCT):\n    structure = (\n        ('Uid', GUID),\n        ('Prefix', LPWSTR),\n    )",
  "class NET_DFS_ENTRY_ID_ARRAY(NDRUniConformantArray):\n    item = NET_DFS_ENTRY_ID",
  "class LPNET_DFS_ENTRY_ID_ARRAY(NDRPOINTER):\n     referent = (\n         ('Data', NET_DFS_ENTRY_ID_ARRAY),\n     )",
  "class NET_DFS_ENTRY_ID_CONTAINER(NDRSTRUCT):\n    structure = (\n        ('Count', DWORD),\n        ('Buffer', LPNET_DFS_ENTRY_ID_ARRAY),\n    )",
  "class DFS_SITENAME_INFO(NDRSTRUCT):\n    structure = (\n        ('SiteFlags', DWORD),\n        ('SiteName', LPWSTR),\n    )",
  "class DFS_SITENAME_INFO_ARRAY(NDRUniConformantArray):\n    item = DFS_SITENAME_INFO",
  "class DFS_SITELIST_INFO(NDRSTRUCT):\n    structure = (\n        ('cSites', DWORD),\n        ('Site', DFS_SITENAME_INFO_ARRAY),\n    )",
  "class LPDFS_SITELIST_INFO(NDRPOINTER):\n    referent = (\n        ('Data', DFS_SITELIST_INFO),\n    )",
  "class FILE_INFO(NDRUNION):\n    commonHdr = (\n        ('tag', DWORD),\n    )\n\n    union = {\n        2: ('FileInfo2', LPFILE_INFO_2),\n        3: ('FileInfo3', LPFILE_INFO_3),\n    }",
  "class SHARE_INFO(NDRUNION):\n    commonHdr = (\n        ('tag', DWORD),\n    )\n\n    union = {\n        0: ('ShareInfo0', LPSHARE_INFO_0),\n        1: ('ShareInfo1', LPSHARE_INFO_1),\n        2: ('ShareInfo2', LPSHARE_INFO_2),\n        502: ('ShareInfo502', LPSHARE_INFO_502),\n        1004: ('ShareInfo1004', LPSHARE_INFO_1004),\n        1006: ('ShareInfo1006', LPSHARE_INFO_1006),\n        1501: ('ShareInfo1501', LPSHARE_INFO_1501),\n        1005: ('ShareInfo1005', LPSHARE_INFO_1005),\n        501: ('ShareInfo501', LPSHARE_INFO_501),\n        503: ('ShareInfo503', LPSHARE_INFO_503),\n    }",
  "class SERVER_INFO(NDRUNION):\n    commonHdr = (\n        ('tag', DWORD),\n    )\n\n    union = {\n        100: ('ServerInfo100', LPSERVER_INFO_100),\n        101: ('ServerInfo101', LPSERVER_INFO_101),\n        102: ('ServerInfo102', LPSERVER_INFO_102),\n        103: ('ServerInfo103', LPSERVER_INFO_103),\n        502: ('ServerInfo502', LPSERVER_INFO_502),\n        503: ('ServerInfo503', LPSERVER_INFO_503),\n        599: ('ServerInfo599', LPSERVER_INFO_599),\n        1005: ('ServerInfo1005', LPSERVER_INFO_1005),\n        1107: ('ServerInfo1107', LPSERVER_INFO_1107),\n        1010: ('ServerInfo1010', LPSERVER_INFO_1010),\n        1016: ('ServerInfo1016', LPSERVER_INFO_1016),\n        1017: ('ServerInfo1017', LPSERVER_INFO_1017),\n        1018: ('ServerInfo1018', LPSERVER_INFO_1018),\n        1501: ('ServerInfo1501', LPSERVER_INFO_1501),\n        1502: ('ServerInfo1502', LPSERVER_INFO_1502),\n        1503: ('ServerInfo1503', LPSERVER_INFO_1503),\n        1506: ('ServerInfo1506', LPSERVER_INFO_1506),\n        1510: ('ServerInfo1510', LPSERVER_INFO_1510),\n        1511: ('ServerInfo1511', LPSERVER_INFO_1511),\n        1512: ('ServerInfo1512', LPSERVER_INFO_1512),\n        1513: ('ServerInfo1513', LPSERVER_INFO_1513),\n        1514: ('ServerInfo1514', LPSERVER_INFO_1514),\n        1515: ('ServerInfo1515', LPSERVER_INFO_1515),\n        1516: ('ServerInfo1516', LPSERVER_INFO_1516),\n        1518: ('ServerInfo1518', LPSERVER_INFO_1518),\n        1523: ('ServerInfo1523', LPSERVER_INFO_1523),\n        1528: ('ServerInfo1528', LPSERVER_INFO_1528),\n        1529: ('ServerInfo1529', LPSERVER_INFO_1529),\n        1530: ('ServerInfo1530', LPSERVER_INFO_1530),\n        1533: ('ServerInfo1533', LPSERVER_INFO_1533),\n        1534: ('ServerInfo1534', LPSERVER_INFO_1534),\n        1535: ('ServerInfo1535', LPSERVER_INFO_1535),\n        1536: ('ServerInfo1536', LPSERVER_INFO_1536),\n        1538: ('ServerInfo1538', LPSERVER_INFO_1538),\n        1539: ('ServerInfo1539', LPSERVER_INFO_1539),\n        1540: ('ServerInfo1540', LPSERVER_INFO_1540),\n        1541: ('ServerInfo1541', LPSERVER_INFO_1541),\n        1542: ('ServerInfo1542', LPSERVER_INFO_1542),\n        1543: ('ServerInfo1543', LPSERVER_INFO_1543),\n        1544: ('ServerInfo1544', LPSERVER_INFO_1544),\n        1545: ('ServerInfo1545', LPSERVER_INFO_1545),\n        1546: ('ServerInfo1546', LPSERVER_INFO_1546),\n        1547: ('ServerInfo1547', LPSERVER_INFO_1547),\n        1548: ('ServerInfo1548', LPSERVER_INFO_1548),\n        1549: ('ServerInfo1549', LPSERVER_INFO_1549),\n        1550: ('ServerInfo1550', LPSERVER_INFO_1550),\n        1552: ('ServerInfo1552', LPSERVER_INFO_1552),\n        1553: ('ServerInfo1553', LPSERVER_INFO_1553),\n        1554: ('ServerInfo1554', LPSERVER_INFO_1554),\n        1555: ('ServerInfo1555', LPSERVER_INFO_1555),\n        1556: ('ServerInfo1556', LPSERVER_INFO_1556),\n    }",
  "class TRANSPORT_INFO(NDRUNION):\n    commonHdr = (\n        ('tag', DWORD),\n    )\n\n    union = {\n        0: ('Transport0', SERVER_TRANSPORT_INFO_0),\n        1: ('Transport1', SERVER_TRANSPORT_INFO_1),\n        2: ('Transport2', SERVER_TRANSPORT_INFO_2),\n        3: ('Transport3', SERVER_TRANSPORT_INFO_3),\n    }",
  "class SERVER_ALIAS_INFO(NDRUNION):\n    commonHdr = (\n        ('tag', DWORD),\n    )\n\n    union = {\n        0: ('ServerAliasInfo0', LPSERVER_ALIAS_INFO_0),\n    }",
  "class NetrConnectionEnum(NDRCALL):\n    opnum = 8\n    structure = (\n       ('ServerName', PSRVSVC_HANDLE),\n       ('Qualifier', LPWSTR),\n       ('InfoStruct', CONNECT_ENUM_STRUCT),\n       ('PreferedMaximumLength', DWORD),\n       ('ResumeHandle', LPLONG),\n    )",
  "class NetrConnectionEnumResponse(NDRCALL):\n    structure = (\n       ('InfoStruct',CONNECT_ENUM_STRUCT),\n       ('TotalEntries',DWORD),\n       ('ResumeHandle',LPLONG),\n       ('ErrorCode',ULONG),\n    )",
  "class NetrFileEnum(NDRCALL):\n    opnum = 9\n    structure = (\n       ('ServerName', PSRVSVC_HANDLE),\n       ('BasePath', LPWSTR),\n       ('UserName', LPWSTR),\n       ('InfoStruct', FILE_ENUM_STRUCT),\n       ('PreferedMaximumLength', DWORD),\n       ('ResumeHandle', LPLONG),\n    )",
  "class NetrFileEnumResponse(NDRCALL):\n    structure = (\n       ('InfoStruct',FILE_ENUM_STRUCT),\n       ('TotalEntries',DWORD),\n       ('ResumeHandle',LPLONG),\n       ('ErrorCode',ULONG),\n    )",
  "class NetrFileGetInfo(NDRCALL):\n    opnum = 10\n    structure = (\n       ('ServerName', PSRVSVC_HANDLE),\n       ('FileId', DWORD),\n       ('Level', DWORD),\n    )",
  "class NetrFileGetInfoResponse(NDRCALL):\n    structure = (\n       ('InfoStruct',FILE_INFO),\n       ('ErrorCode',ULONG),\n    )",
  "class NetrFileClose(NDRCALL):\n    opnum = 11\n    structure = (\n       ('ServerName', PSRVSVC_HANDLE),\n       ('FileId', DWORD),\n    )",
  "class NetrFileCloseResponse(NDRCALL):\n    structure = (\n       ('ErrorCode',ULONG),\n    )",
  "class NetrSessionEnum(NDRCALL):\n    opnum = 12\n    structure = (\n       ('ServerName', PSRVSVC_HANDLE),\n       ('ClientName', LPWSTR),\n       ('UserName', LPWSTR),\n       ('InfoStruct', SESSION_ENUM_STRUCT),\n       ('PreferedMaximumLength', DWORD),\n       ('ResumeHandle', LPLONG),\n    )",
  "class NetrSessionEnumResponse(NDRCALL):\n    structure = (\n       ('InfoStruct',SESSION_ENUM_STRUCT),\n       ('TotalEntries',DWORD),\n       ('ResumeHandle',LPLONG),\n       ('ErrorCode',ULONG),\n    )",
  "class NetrSessionDel(NDRCALL):\n    opnum = 13\n    structure = (\n       ('ServerName', PSRVSVC_HANDLE),\n       ('ClientName', LPWSTR),\n       ('UserName', LPWSTR),\n    )",
  "class NetrSessionDelResponse(NDRCALL):\n    structure = (\n       ('ErrorCode',ULONG),\n    )",
  "class NetrShareAdd(NDRCALL):\n    opnum = 14\n    structure = (\n       ('ServerName', PSRVSVC_HANDLE),\n       ('Level', DWORD),\n       ('InfoStruct', SHARE_INFO),\n       ('ParmErr', LPLONG),\n    )",
  "class NetrShareAddResponse(NDRCALL):\n    structure = (\n       ('ParmErr', LPLONG),\n       ('ErrorCode',ULONG),\n    )",
  "class NetrShareEnum(NDRCALL):\n    opnum = 15\n    structure = (\n       ('ServerName', PSRVSVC_HANDLE),\n       ('InfoStruct', SHARE_ENUM_STRUCT),\n       ('PreferedMaximumLength', DWORD),\n       ('ResumeHandle', LPLONG),\n    )",
  "class NetrShareEnumResponse(NDRCALL):\n    structure = (\n       ('InfoStruct', SHARE_ENUM_STRUCT),\n       ('TotalEntries',DWORD),\n       ('ResumeHandle',LPLONG),\n       ('ErrorCode',ULONG),\n    )",
  "class NetrShareEnumSticky(NDRCALL):\n    opnum = 36\n    structure = (\n       ('ServerName', PSRVSVC_HANDLE),\n       ('InfoStruct', SHARE_ENUM_STRUCT),\n       ('PreferedMaximumLength', DWORD),\n       ('ResumeHandle', LPLONG),\n    )",
  "class NetrShareEnumStickyResponse(NDRCALL):\n    structure = (\n       ('InfoStruct', SHARE_ENUM_STRUCT),\n       ('TotalEntries',DWORD),\n       ('ResumeHandle',LPLONG),\n       ('ErrorCode',ULONG),\n    )",
  "class NetrShareGetInfo(NDRCALL):\n    opnum = 16\n    structure = (\n       ('ServerName', PSRVSVC_HANDLE),\n       ('NetName', WSTR),\n       ('Level', DWORD),\n    )",
  "class NetrShareGetInfoResponse(NDRCALL):\n    structure = (\n       ('InfoStruct', SHARE_INFO),\n       ('ErrorCode',ULONG),\n    )",
  "class NetrShareSetInfo(NDRCALL):\n    opnum = 17\n    structure = (\n       ('ServerName', PSRVSVC_HANDLE),\n       ('NetName', WSTR),\n       ('Level', DWORD),\n       ('ShareInfo', SHARE_INFO),\n       ('ParmErr', LPLONG),\n    )",
  "class NetrShareSetInfoResponse(NDRCALL):\n    structure = (\n       ('ParmErr', LPLONG),\n       ('ErrorCode',ULONG),\n    )",
  "class NetrShareDel(NDRCALL):\n    opnum = 18\n    structure = (\n       ('ServerName', PSRVSVC_HANDLE),\n       ('NetName', WSTR),\n       ('Reserved', DWORD),\n    )",
  "class NetrShareDelResponse(NDRCALL):\n    structure = (\n       ('ErrorCode',ULONG),\n    )",
  "class NetrShareDelSticky(NDRCALL):\n    opnum = 19\n    structure = (\n       ('ServerName', PSRVSVC_HANDLE),\n       ('NetName', WSTR),\n       ('Reserved', DWORD),\n    )",
  "class NetrShareDelStickyResponse(NDRCALL):\n    structure = (\n       ('ErrorCode',ULONG),\n    )",
  "class NetrShareDelStart(NDRCALL):\n    opnum = 37\n    structure = (\n       ('ServerName', PSRVSVC_HANDLE),\n       ('NetName', WSTR),\n       ('Reserved', DWORD),\n    )",
  "class NetrShareDelStartResponse(NDRCALL):\n    structure = (\n       ('ContextHandle',SHARE_DEL_HANDLE),\n       ('ErrorCode',ULONG),\n    )",
  "class NetrShareDelCommit(NDRCALL):\n    opnum = 38\n    structure = (\n       ('ContextHandle',SHARE_DEL_HANDLE),\n    )",
  "class NetrShareDelCommitResponse(NDRCALL):\n    structure = (\n       ('ErrorCode',ULONG),\n    )",
  "class NetrShareCheck(NDRCALL):\n    opnum = 20\n    structure = (\n       ('ServerName', PSRVSVC_HANDLE),\n       ('Device', WSTR),\n    )",
  "class NetrShareCheckResponse(NDRCALL):\n    structure = (\n       ('Type',DWORD),\n       ('ErrorCode',ULONG),\n    )",
  "class NetrServerGetInfo(NDRCALL):\n    opnum = 21\n    structure = (\n       ('ServerName', PSRVSVC_HANDLE),\n       ('Level', DWORD),\n    )",
  "class NetrServerGetInfoResponse(NDRCALL):\n    structure = (\n       ('InfoStruct', SERVER_INFO),\n       ('ErrorCode',ULONG),\n    )",
  "class NetrServerSetInfo(NDRCALL):\n    opnum = 22\n    structure = (\n       ('ServerName', PSRVSVC_HANDLE),\n       ('Level', DWORD),\n       ('InfoStruct', SERVER_INFO),\n    )",
  "class NetrServerSetInfoResponse(NDRCALL):\n    structure = (\n       ('ParmErr', LPLONG),\n       ('ErrorCode',ULONG),\n    )",
  "class NetrServerDiskEnum(NDRCALL):\n    opnum = 23\n    structure = (\n       ('ServerName', PSRVSVC_HANDLE),\n       ('Level', DWORD),\n       ('DiskInfoStruct', DISK_ENUM_CONTAINER),\n       ('PreferedMaximumLength', DWORD),\n       ('ResumeHandle', LPLONG),\n    )",
  "class NetrServerDiskEnumResponse(NDRCALL):\n    structure = (\n       ('DiskInfoStruct', DISK_ENUM_CONTAINER),\n       ('TotalEntries', DWORD),\n       ('ResumeHandle', LPLONG),\n       ('ErrorCode',ULONG),\n    )",
  "class NetrServerStatisticsGet(NDRCALL):\n    opnum = 24\n    structure = (\n       ('ServerName', PSRVSVC_HANDLE),\n       ('Service', LPWSTR),\n       ('Level', DWORD),\n       ('Options', DWORD),\n    )",
  "class NetrServerStatisticsGetResponse(NDRCALL):\n    structure = (\n       ('InfoStruct', LPSTAT_SERVER_0),\n       ('ErrorCode',ULONG),\n    )",
  "class NetrRemoteTOD(NDRCALL):\n    opnum = 28\n    structure = (\n       ('ServerName', PSRVSVC_HANDLE),\n    )",
  "class NetrRemoteTODResponse(NDRCALL):\n    structure = (\n       ('BufferPtr', LPTIME_OF_DAY_INFO),\n       ('ErrorCode',ULONG),\n    )",
  "class NetrServerTransportAdd(NDRCALL):\n    opnum = 25\n    structure = (\n       ('ServerName', PSRVSVC_HANDLE),\n       ('Level', DWORD),\n       ('Buffer', SERVER_TRANSPORT_INFO_0),\n    )",
  "class NetrServerTransportAddResponse(NDRCALL):\n    structure = (\n       ('ErrorCode',ULONG),\n    )",
  "class NetrServerTransportAddEx(NDRCALL):\n    opnum = 41\n    structure = (\n       ('ServerName', PSRVSVC_HANDLE),\n       ('Level', DWORD),\n       ('Buffer', TRANSPORT_INFO),\n    )",
  "class NetrServerTransportAddExResponse(NDRCALL):\n    structure = (\n       ('ErrorCode',ULONG),\n    )",
  "class NetrServerTransportEnum(NDRCALL):\n    opnum = 26\n    structure = (\n       ('ServerName', PSRVSVC_HANDLE),\n       ('InfoStruct', SERVER_XPORT_ENUM_STRUCT),\n       ('PreferedMaximumLength', DWORD),\n       ('ResumeHandle', LPLONG),\n    )",
  "class NetrServerTransportEnumResponse(NDRCALL):\n    structure = (\n       ('InfoStruct', SERVER_XPORT_ENUM_STRUCT),\n       ('TotalEntries', DWORD),\n       ('ResumeHandle', LPLONG),\n       ('ErrorCode',ULONG),\n    )",
  "class NetrServerTransportDel(NDRCALL):\n    opnum = 27\n    structure = (\n       ('ServerName', PSRVSVC_HANDLE),\n       ('Level', DWORD),\n       ('Buffer', SERVER_TRANSPORT_INFO_0),\n    )",
  "class NetrServerTransportDelResponse(NDRCALL):\n    structure = (\n       ('ErrorCode',ULONG),\n    )",
  "class NetrServerTransportDelEx(NDRCALL):\n    opnum = 53\n    structure = (\n       ('ServerName', PSRVSVC_HANDLE),\n       ('Level', DWORD),\n       ('Buffer', TRANSPORT_INFO),\n    )",
  "class NetrServerTransportDelExResponse(NDRCALL):\n    structure = (\n       ('ErrorCode',ULONG),\n    )",
  "class NetrpGetFileSecurity(NDRCALL):\n    opnum = 39\n    structure = (\n       ('ServerName', PSRVSVC_HANDLE),\n       ('ShareName', LPWSTR),\n       ('lpFileName', WSTR),\n       ('RequestedInformation', SECURITY_INFORMATION),\n    )",
  "class NetrpGetFileSecurityResponse(NDRCALL):\n    structure = (\n       ('SecurityDescriptor', PADT_SECURITY_DESCRIPTOR),\n       ('ErrorCode',ULONG),\n    )",
  "class NetrpSetFileSecurity(NDRCALL):\n    opnum = 40\n    structure = (\n       ('ServerName', PSRVSVC_HANDLE),\n       ('ShareName', LPWSTR),\n       ('lpFileName', WSTR),\n       ('SecurityInformation', SECURITY_INFORMATION),\n       ('SecurityDescriptor', ADT_SECURITY_DESCRIPTOR),\n    )",
  "class NetrpSetFileSecurityResponse(NDRCALL):\n    structure = (\n       ('ErrorCode',ULONG),\n    )",
  "class NetprPathType(NDRCALL):\n    opnum = 30\n    structure = (\n       ('ServerName', PSRVSVC_HANDLE),\n       ('PathName', WSTR),\n       ('Flags', DWORD),\n    )",
  "class NetprPathTypeResponse(NDRCALL):\n    structure = (\n       ('PathType', DWORD),\n       ('ErrorCode',ULONG),\n    )",
  "class NetprPathCanonicalize(NDRCALL):\n    opnum = 31\n    structure = (\n       ('ServerName', PSRVSVC_HANDLE),\n       ('PathName', WSTR),\n       ('OutbufLen', DWORD),\n       ('Prefix', WSTR),\n       ('PathType', DWORD),\n       ('Flags', DWORD),\n    )",
  "class NetprPathCanonicalizeResponse(NDRCALL):\n    structure = (\n       ('Outbuf', NDRUniConformantArray),\n       ('PathType', DWORD),\n       ('ErrorCode',ULONG),\n    )",
  "class NetprPathCompare(NDRCALL):\n    opnum = 32\n    structure = (\n       ('ServerName', PSRVSVC_HANDLE),\n       ('PathName1', WSTR),\n       ('PathName2', WSTR),\n       ('PathType', DWORD),\n       ('Flags', DWORD),\n    )",
  "class NetprPathCompareResponse(NDRCALL):\n    structure = (\n       ('ErrorCode',ULONG),\n    )",
  "class NetprNameValidate(NDRCALL):\n    opnum = 33\n    structure = (\n       ('ServerName', PSRVSVC_HANDLE),\n       ('Name', WSTR),\n       ('NameType', DWORD),\n       ('Flags', DWORD),\n    )",
  "class NetprNameValidateResponse(NDRCALL):\n    structure = (\n       ('ErrorCode',ULONG),\n    )",
  "class NetprNameCanonicalize(NDRCALL):\n    opnum = 34\n    structure = (\n       ('ServerName', PSRVSVC_HANDLE),\n       ('Name', WSTR),\n       ('OutbufLen', DWORD),\n       ('NameType', DWORD),\n       ('Flags', DWORD),\n    )",
  "class NetprNameCanonicalizeResponse(NDRCALL):\n    structure = (\n       ('Outbuf', NDRUniConformantArray),\n       ('NameType', DWORD),\n       ('ErrorCode',ULONG),\n    )",
  "class NetprNameCompare(NDRCALL):\n    opnum = 35\n    structure = (\n       ('ServerName', PSRVSVC_HANDLE),\n       ('Name1', WSTR),\n       ('Name2', WSTR),\n       ('NameType', DWORD),\n       ('Flags', DWORD),\n    )",
  "class NetprNameCompareResponse(NDRCALL):\n    structure = (\n       ('ErrorCode',ULONG),\n    )",
  "class NetrDfsGetVersion(NDRCALL):\n    opnum = 43\n    structure = (\n       ('ServerName', PSRVSVC_HANDLE),\n    )",
  "class NetrDfsGetVersionResponse(NDRCALL):\n    structure = (\n       ('Version', DWORD),\n       ('ErrorCode',ULONG),\n    )",
  "class NetrDfsCreateLocalPartition(NDRCALL):\n    opnum = 44\n    structure = (\n       ('ServerName', PSRVSVC_HANDLE),\n       ('ShareName', WSTR),\n       ('EntryUid', GUID),\n       ('EntryPrefix', WSTR),\n       ('ShortName', WSTR),\n       ('RelationInfo', NET_DFS_ENTRY_ID_CONTAINER),\n       ('Force', DWORD),\n    )",
  "class NetrDfsCreateLocalPartitionResponse(NDRCALL):\n    structure = (\n       ('ErrorCode',ULONG),\n    )",
  "class NetrDfsDeleteLocalPartition(NDRCALL):\n    opnum = 45\n    structure = (\n       ('ServerName', PSRVSVC_HANDLE),\n       ('Uid', GUID),\n       ('Prefix', WSTR),\n    )",
  "class NetrDfsDeleteLocalPartitionResponse(NDRCALL):\n    structure = (\n       ('ErrorCode',ULONG),\n    )",
  "class NetrDfsSetLocalVolumeState(NDRCALL):\n    opnum = 46\n    structure = (\n       ('ServerName', PSRVSVC_HANDLE),\n       ('Uid', GUID),\n       ('Prefix', WSTR),\n       ('State', DWORD),\n    )",
  "class NetrDfsSetLocalVolumeStateResponse(NDRCALL):\n    structure = (\n       ('ErrorCode',ULONG),\n    )",
  "class NetrDfsCreateExitPoint(NDRCALL):\n    opnum = 48\n    structure = (\n       ('ServerName', PSRVSVC_HANDLE),\n       ('Uid', GUID),\n       ('Prefix', WSTR),\n       ('Type', DWORD),\n       ('ShortPrefixLen', DWORD),\n    )",
  "class NetrDfsCreateExitPointResponse(NDRCALL):\n    structure = (\n       ('ShortPrefix',WCHAR_ARRAY),\n       ('ErrorCode',ULONG),\n    )",
  "class NetrDfsModifyPrefix(NDRCALL):\n    opnum = 50\n    structure = (\n       ('ServerName', PSRVSVC_HANDLE),\n       ('Uid', GUID),\n       ('Prefix', WSTR),\n    )",
  "class NetrDfsModifyPrefixResponse(NDRCALL):\n    structure = (\n       ('ErrorCode',ULONG),\n    )",
  "class NetrDfsDeleteExitPoint(NDRCALL):\n    opnum = 49\n    structure = (\n       ('ServerName', PSRVSVC_HANDLE),\n       ('Uid', GUID),\n       ('Prefix', WSTR),\n       ('Type', DWORD),\n    )",
  "class NetrDfsDeleteExitPointResponse(NDRCALL):\n    structure = (\n       ('ErrorCode',ULONG),\n    )",
  "class NetrDfsFixLocalVolume(NDRCALL):\n    opnum = 51\n    structure = (\n       ('ServerName', PSRVSVC_HANDLE),\n       ('VolumeName', WSTR),\n       ('EntryType', DWORD),\n       ('ServiceType', DWORD),\n       ('StgId', WSTR),\n       ('EntryUid', GUID),\n       ('EntryPrefix', WSTR),\n       ('RelationInfo', NET_DFS_ENTRY_ID_CONTAINER),\n       ('CreateDisposition', DWORD),\n    )",
  "class NetrDfsFixLocalVolumeResponse(NDRCALL):\n    structure = (\n       ('ErrorCode',ULONG),\n    )",
  "class NetrDfsManagerReportSiteInfo(NDRCALL):\n    opnum = 52\n    structure = (\n       ('ServerName', PSRVSVC_HANDLE),\n       ('ppSiteInfo', LPDFS_SITELIST_INFO),\n    )",
  "class NetrDfsManagerReportSiteInfoResponse(NDRCALL):\n    structure = (\n       ('ppSiteInfo', LPDFS_SITELIST_INFO),\n       ('ErrorCode',ULONG),\n    )",
  "class NetrServerAliasAdd(NDRCALL):\n    opnum = 54\n    structure = (\n       ('ServerName', PSRVSVC_HANDLE),\n       ('Level', DWORD),\n       ('InfoStruct', SERVER_ALIAS_INFO),\n    )",
  "class NetrServerAliasAddResponse(NDRCALL):\n    structure = (\n       ('ErrorCode',ULONG),\n    )",
  "class NetrServerAliasEnum(NDRCALL):\n    opnum = 55\n    structure = (\n       ('ServerName', PSRVSVC_HANDLE),\n       ('InfoStruct', SERVER_ALIAS_ENUM_STRUCT),\n       ('PreferedMaximumLength', DWORD),\n       ('ResumeHandle', LPLONG),\n    )",
  "class NetrServerAliasEnumResponse(NDRCALL):\n    structure = (\n       ('InfoStruct',SERVER_ALIAS_ENUM_STRUCT),\n       ('TotalEntries',DWORD),\n       ('ResumeHandle',LPLONG),\n       ('ErrorCode',ULONG),\n    )",
  "class NetrServerAliasDel(NDRCALL):\n    opnum = 56\n    structure = (\n       ('ServerName', PSRVSVC_HANDLE),\n       ('Level', DWORD),\n       ('InfoStruct', SERVER_ALIAS_INFO),\n    )",
  "class NetrServerAliasDelResponse(NDRCALL):\n    structure = (\n       ('ErrorCode',ULONG),\n    )",
  "class NetrShareDelEx(NDRCALL):\n    opnum = 57\n    structure = (\n       ('ServerName', PSRVSVC_HANDLE),\n       ('Level', DWORD),\n       ('ShareInfo', SHARE_INFO),\n    )",
  "class NetrShareDelExResponse(NDRCALL):\n    structure = (\n       ('ErrorCode',ULONG),\n    )",
  "def hNetrConnectionEnum(dce, qualifier, level, resumeHandle = 0, preferedMaximumLength = 0xffffffff):\n    request = NetrConnectionEnum()\n    request['ServerName'] = NULL\n    request['Qualifier'] = qualifier \n    request['InfoStruct']['Level'] = level\n    request['InfoStruct']['ConnectInfo']['tag'] = level\n    request['PreferedMaximumLength'] = preferedMaximumLength\n    request['ResumeHandle'] = resumeHandle\n    return dce.request(request)",
  "def hNetrFileEnum(dce, basePath, userName, level, resumeHandle = 0, preferedMaximumLength = 0xffffffff):\n    request = NetrFileEnum()\n    request['ServerName'] = NULL\n    request['BasePath'] = basePath\n    request['UserName'] = userName\n    request['InfoStruct']['Level'] = level\n    request['InfoStruct']['FileInfo']['tag'] = level\n    request['PreferedMaximumLength'] = preferedMaximumLength\n    request['ResumeHandle'] = resumeHandle\n    return dce.request(request)",
  "def hNetrFileGetInfo(dce, fileId, level):\n    request = NetrFileGetInfo()\n    request['ServerName'] = NULL\n    request['FileId'] = fileId\n    request['Level'] = level\n    return dce.request(request)",
  "def hNetrFileClose(dce, fileId):\n    request = NetrFileClose()\n    request['ServerName'] = NULL\n    request['FileId'] = fileId\n    return dce.request(request)",
  "def hNetrSessionEnum(dce, clientName, userName, level, resumeHandle = 0, preferedMaximumLength = 0xffffffff):\n    request = NetrSessionEnum()\n    request['ServerName'] = NULL\n    request['ClientName'] = clientName\n    request['UserName'] = userName\n    request['InfoStruct']['Level'] = level\n    request['InfoStruct']['SessionInfo']['tag'] = level\n    request['InfoStruct']['SessionInfo']['Level%d'%level]['Buffer'] = NULL\n    request['PreferedMaximumLength'] = preferedMaximumLength\n    request['ResumeHandle'] = resumeHandle\n\n    return dce.request(request)",
  "def hNetrSessionDel(dce, clientName, userName):\n    request = NetrSessionDel()\n    request['ServerName'] = NULL\n    request['ClientName'] = clientName\n    request['UserName'] = userName\n    return dce.request(request)",
  "def hNetrShareAdd(dce, level, infoStruct):\n    request = NetrShareAdd()\n    request['ServerName'] = NULL\n    request['Level'] = level\n    request['InfoStruct']['tag'] = level\n    request['InfoStruct']['ShareInfo%d'%level] = infoStruct\n    return dce.request(request)",
  "def hNetrShareDel(dce, netName):\n    request = NetrShareDel()\n    request['ServerName'] = NULL\n    request['NetName'] = netName\n    return dce.request(request)",
  "def hNetrShareEnum(dce, level, resumeHandle = 0, preferedMaximumLength = 0xffffffff):\n    request = NetrShareEnum()\n    request['ServerName'] = '\\x00'\n    request['PreferedMaximumLength'] = preferedMaximumLength\n    request['ResumeHandle'] = resumeHandle\n    request['InfoStruct']['Level'] = level\n    request['InfoStruct']['ShareInfo']['tag'] = level\n    request['InfoStruct']['ShareInfo']['Level%d'%level]['Buffer'] = NULL\n\n    return dce.request(request)",
  "def hNetrShareEnumSticky(dce, level, resumeHandle = 0, preferedMaximumLength = 0xffffffff):\n    request = NetrShareEnumSticky()\n    request['ServerName'] = NULL\n    request['PreferedMaximumLength'] = preferedMaximumLength\n    request['ResumeHandle'] = resumeHandle\n    request['InfoStruct']['Level'] = level\n    request['InfoStruct']['ShareInfo']['tag'] = level\n    request['InfoStruct']['ShareInfo']['Level%d'%level]['Buffer'] = NULL\n\n    return dce.request(request)",
  "def hNetrShareGetInfo(dce, netName, level):\n    request = NetrShareGetInfo()\n    request['ServerName'] = NULL\n    request['NetName'] = netName\n    request['Level'] = level\n    return dce.request(request)",
  "def hNetrShareSetInfo(dce, netName, level, shareInfo):\n    request = NetrShareSetInfo()\n    request['ServerName'] = NULL\n    request['NetName'] = netName\n    request['Level'] = level\n    request['ShareInfo']['tag'] = level\n    request['ShareInfo']['ShareInfo%d'%level] = shareInfo\n\n    return dce.request(request)",
  "def hNetrShareDelSticky(dce, netName):\n    request = NetrShareDelSticky()\n    request['ServerName'] = NULL\n    request['NetName'] = netName\n    return dce.request(request)",
  "def hNetrShareDelStart(dce, netName):\n    request = NetrShareDelStart()\n    request['ServerName'] = NULL\n    request['NetName'] = netName\n    return dce.request(request)",
  "def hNetrShareDelCommit(dce, contextHandle):\n    request = NetrShareDelCommit()\n    request['ContextHandle'] = contextHandle\n    return dce.request(request)",
  "def hNetrShareCheck(dce, device):\n    request = NetrShareCheck()\n    request['ServerName'] = NULL\n    request['Device'] = device\n    return dce.request(request)",
  "def hNetrServerGetInfo(dce, level):\n    request = NetrServerGetInfo()\n    request['ServerName'] = NULL\n    request['Level'] = level\n    return dce.request(request)",
  "def hNetrServerDiskEnum(dce, level, resumeHandle = 0, preferedMaximumLength = 0xffffffff):\n    request = NetrServerDiskEnum()\n    request['ServerName'] = NULL\n    request['PreferedMaximumLength'] = preferedMaximumLength\n    request['ResumeHandle'] = resumeHandle\n    request['Level'] = level\n    request['DiskInfoStruct']['Buffer'] = NULL\n    return dce.request(request)",
  "def hNetrServerStatisticsGet(dce, service, level, options):\n    request = NetrServerStatisticsGet()\n    request['ServerName'] = NULL\n    request['Service'] = service\n    request['Level'] = level\n    request['Options'] = options\n    return dce.request(request)",
  "def hNetrRemoteTOD(dce):\n    request = NetrRemoteTOD()\n    request['ServerName'] = NULL\n    return dce.request(request)",
  "def hNetrServerTransportEnum(dce, level, resumeHandle = 0, preferedMaximumLength = 0xffffffff):\n    request = NetrServerTransportEnum()\n    request['ServerName'] = NULL\n    request['PreferedMaximumLength'] = preferedMaximumLength\n    request['ResumeHandle'] = resumeHandle\n    request['InfoStruct']['Level'] = level\n    request['InfoStruct']['XportInfo']['tag'] = level\n    request['InfoStruct']['XportInfo']['Level%d' % level]['Buffer'] = NULL\n    return dce.request(request)",
  "def hNetrpGetFileSecurity(dce, shareName, lpFileName, requestedInformation):\n    request = NetrpGetFileSecurity()\n    request['ServerName'] = NULL\n    request['ShareName'] = shareName\n    request['lpFileName'] = lpFileName\n    request['RequestedInformation'] = requestedInformation\n    retVal = dce.request(request)\n    return b''.join(retVal['SecurityDescriptor']['Buffer'])",
  "def hNetrpSetFileSecurity(dce, shareName, lpFileName, securityInformation, securityDescriptor):\n    request = NetrpSetFileSecurity()\n    request['ServerName'] = NULL\n    request['ShareName'] = shareName\n    request['lpFileName'] = lpFileName\n    request['SecurityInformation'] = securityInformation\n    request['SecurityDescriptor']['Length'] = len(securityDescriptor)\n    request['SecurityDescriptor']['Buffer'] = list(securityDescriptor)\n    return dce.request(request)",
  "def hNetprPathType(dce, pathName, flags):\n    request = NetprPathType()\n    request['ServerName'] = NULL\n    request['PathName'] = pathName\n    request['Flags'] = flags\n    return dce.request(request)",
  "def hNetprPathCanonicalize(dce, pathName, prefix, outbufLen=50, pathType=0, flags=0):\n    request = NetprPathCanonicalize()\n    request['ServerName'] = NULL\n    request['PathName'] = pathName\n    request['OutbufLen'] = outbufLen\n    request['Prefix'] = prefix\n    request['PathType'] = pathType\n    request['Flags'] = flags\n    return dce.request(request)",
  "def hNetprPathCompare(dce, pathName1, pathName2, pathType=0, flags=0):\n    request = NetprPathCompare()\n    request['ServerName'] = NULL\n    request['PathName1'] = pathName1\n    request['PathName2'] = pathName2\n    request['PathType'] = pathType\n    request['Flags'] = flags\n    return dce.request(request)",
  "def hNetprNameValidate(dce, name, nameType, flags=0):\n    request = NetprNameValidate()\n    request['ServerName'] = NULL\n    request['Name'] = name\n    request['NameType'] = nameType\n    request['Flags'] = flags\n    return dce.request(request)",
  "def hNetprNameCanonicalize(dce, name, outbufLen=50, nameType=0, flags=0):\n    request = NetprNameCanonicalize()\n    request['ServerName'] = NULL\n    request['Name'] = name\n    request['OutbufLen'] = outbufLen\n    request['NameType'] = nameType\n    request['Flags'] = flags\n    return dce.request(request)",
  "def hNetprNameCompare(dce, name1, name2, nameType=0, flags=0):\n    request = NetprNameCompare()\n    request['ServerName'] = NULL\n    request['Name1'] = name1\n    request['Name2'] = name2\n    request['NameType'] = nameType\n    request['Flags'] = flags\n    return dce.request(request)",
  "def hNetrDfsGetVersion(dce):\n    request = NetrDfsGetVersion()\n    request['ServerName'] = NULL\n    return dce.request(request)",
  "def hNetrServerAliasAdd(dce, level, aliasInfo):\n    request = NetrServerAliasAdd()\n    request['ServerName'] = NULL\n    request['Level'] = level\n    request['InfoStruct']['tag'] = level\n    request['InfoStruct']['ServerAliasInfo%d'%level] = aliasInfo\n    return dce.request(request)",
  "def hNetrServerAliasDel(dce, level, aliasInfo):\n    request = NetrServerAliasDel()\n    request['ServerName'] = NULL\n    request['Level'] = level\n    request['InfoStruct']['tag'] = level\n    request['InfoStruct']['ServerAliasInfo%d'%level] = aliasInfo\n    return dce.request(request)",
  "def hNetrServerAliasEnum(dce, level, resumeHandle = 0, preferedMaximumLength = 0xffffffff):\n    request = NetrServerAliasEnum()\n    request['ServerName'] = NULL\n    request['InfoStruct']['Level'] = level\n    request['InfoStruct']['ServerAliasInfo']['tag'] = level\n    request['InfoStruct']['ServerAliasInfo']['Level%d' % level]['Buffer'] = NULL\n    request['PreferedMaximumLength'] = preferedMaximumLength\n    request['ResumeHandle'] = resumeHandle\n    return dce.request(request)",
  "def __init__(self, error_string=None, error_code=None, packet=None):\n        DCERPCException.__init__(self, error_string, error_code, packet)",
  "def __str__( self ):\n        key = self.error_code\n        if key in system_errors.ERROR_MESSAGES:\n            error_msg_short = system_errors.ERROR_MESSAGES[key][0]\n            error_msg_verbose = system_errors.ERROR_MESSAGES[key][1] \n            return 'SRVS SessionError: code: 0x%x - %s - %s' % (self.error_code, error_msg_short, error_msg_verbose)\n        else:\n            return 'SRVS SessionError: unknown error code: 0x%x' % self.error_code",
  "def dump(self, msg = None, indent = 0):\n        if msg is None:\n            msg = self.__class__.__name__\n        if msg != '':\n            print(\"%s\" % msg, end=' ')\n        # Here just print the data\n        print(\" %r\" % (self['Data']), end=' ')",
  "def __setitem__(self, key, value):\n        if key == 'Data':\n            try:\n                self.fields[key] = value.encode('utf-16le')\n            except UnicodeDecodeError:\n                import sys\n                self.fields[key] = value.decode(sys.getfilesystemencoding()).encode('utf-16le')\n            self.fields['ActualCount'] = None\n            self.data = None        # force recompute\n        else:\n            return NDR.__setitem__(self, key, value)",
  "def __getitem__(self, key):\n        if key == 'Data':\n            return self.fields[key].decode('utf-16le')\n        else:\n            return NDR.__getitem__(self,key)",
  "def getDataLen(self, data, offset=0):\n        return self[\"ActualCount\"]*2",
  "def getDataLen(self, data, offset=0):\n        return 256",
  "class DCERPCSessionError(DCERPCException):\n    error_messages = {}\n    def __init__(self, error_string=None, error_code=None, packet=None):\n        DCERPCException.__init__(self, error_string, error_code, packet)\n        self.error_code = packet['status']\n\n    def __str__( self ):\n        key = self.error_code\n        if key in self.error_messages:\n            error_msg_short = self.error_messages[key]\n            return 'EPM SessionError: code: 0x%x - %s ' % (self.error_code, error_msg_short)\n        else:\n            return 'EPM SessionError: unknown error code: %s' % (str(self.error_code))",
  "class EPMFloor(Structure):\n    structure = (\n        ('LHSByteCount','<H=0'),\n        ('_ProtocolData','_-ProtocolData','self[\"LHSByteCount\"]'),\n        ('ProtocolData',':'),\n        ('RHSByteCount','<H=0'),\n        ('_RelatedData','_-RelatedData','self[\"RHSByteCount\"]'),\n        ('RelatedData',':'),\n    )",
  "class EPMRPCInterface(EPMFloor):\n    structure = (\n        ('LHSByteCount','<H=19'),\n        ('InterfaceIdent','B=0x0d'),\n        ('InterfaceUUID','16s=\"\"'),\n        ('MajorVersion','<H=0'),\n        ('RHSByteCount','<H=2'),\n        ('MinorVersion','<H=0'),\n    )\n    def __init__(self, data = None):\n        EPMFloor.__init__(self, data)\n\n    def __str__(self):\n        aUuid = bin_to_string(self[\"InterfaceUUID\"])\n        return \"%s v%d.%d\" % (aUuid,self[\"MajorVersion\"],self[\"MinorVersion\"])\n\n    def __len__(self):\n       return 25",
  "class EPMRPCDataRepresentation(EPMFloor):\n    structure = (\n        ('LHSByteCount','<H=19'),\n        ('DrepIdentifier','B=0x0d'),\n        ('DataRepUuid','16s=\"\"'),\n        ('MajorVersion','<H=0'),\n        ('RHSByteCount','<H=2'),\n        ('MinorVersion','<H=0'),\n    )\n    def __init__(self, data = None):\n        EPMFloor.__init__(self, data)\n\n    def __str__(self):\n        aUuid = bin_to_string(self[\"DataRepUuid\"])\n        return \"%s v%d.%d\" % (aUuid,self[\"MajorVersion\"],self[\"MinorVersion\"])\n\n    def __len__(self):\n       return 25",
  "class EPMProtocolIdentifier(EPMFloor):\n    structure = (\n        ('LHSByteCount','<H=1'),\n        ('ProtIdentifier','B=0'),\n        ('RHSByteCount','<H=2'),\n        ('MinorVersion','<H=0'),\n    )\n    def __init__(self, data = None):\n        EPMFloor.__init__(self, data)\n\n    def __len__(self):\n       return 6",
  "class EPMPipeName(EPMFloor):\n    structure = (\n        ('LHSByteCount','<H=1'),\n        ('PipeIdentifier','B=15'),\n        ('RHSByteCount','<H=len(PipeName)'),\n        ('PipeName',':'),\n    )",
  "class EPMHostName(EPMFloor):\n    structure = (\n        ('LHSByteCount','<H=1'),\n        ('HostNameIdentifier','B=17'),\n        ('RHSByteCount','<H=len(HostName)'),\n        ('HostName',':'),\n    )",
  "class EPMHostAddr(EPMFloor):\n    structure = (\n        ('LHSByteCount','<H=1'),\n        ('HostAddressId','B=9'),\n        ('RHSByteCount','<H=len(Ip4addr)'),\n        ('Ip4addr','4s=\"\"'),\n    )",
  "class EPMPortAddr(EPMFloor):\n    structure = (\n        ('LHSByteCount','<H=1'),\n        ('PortIdentifier','B=7'),\n        ('RHSByteCount','<H=2'),\n        ('IpPort','>H=0'),\n    )",
  "class EPMTower(Structure):\n    structure = (\n        ('NumberOfFloors','<H'),\n        ('Floors',':'),\n    )\n    def fromString(self,data):\n        Structure.fromString(self,data)\n        floors = self['Floors']\n        fList = []\n        for f in range(self['NumberOfFloors']):\n            floor = EPMFloors[f](floors)\n            floors = floors[len(floor):]\n            fList.append(floor) \n        self['Floors'] = fList",
  "class RPC_IF_ID(NDRSTRUCT):\n    structure = (\n        ('Uuid', UUID ),\n        ('VersMajor', USHORT),\n        ('VersMinor', USHORT),\n    )",
  "class PRPC_IF_ID(NDRPOINTER):\n    referent = (\n        ('Data', RPC_IF_ID),\n    )",
  "class ept_lookup_handle_t(NDRSTRUCT):\n    structure =  (\n        ('context_handle_attributes',ULONG),\n        ('context_handle_uuid',UUID),\n    )\n\n    def __init__(self, data=None, isNDR64=False):\n        NDRSTRUCT.__init__(self, data, isNDR64)\n        self['context_handle_uuid'] = b'\\x00'*16\n\n    def isNull(self):\n        return self['context_handle_uuid'] == b'\\x00'*16",
  "class twr_t(NDRSTRUCT):\n    structure = (\n        ('tower_length', ULONG),\n        ('tower_octet_string', NDRUniConformantArray),\n    )",
  "class twr_p_t(NDRPOINTER):\n    referent = (\n        ('Data', twr_t),\n    )",
  "class octet_string_t(NDRSTRUCT):\n    structure = (\n        ('count', USHORT),\n        ('value', LPBYTE),\n    )",
  "class prot_and_addr_t(NDRSTRUCT):\n    structure = (\n        ('protocol_id', octet_string_t),\n        ('address', octet_string_t),\n    )",
  "class protocol_tower_t(NDRSTRUCT):\n    structure = (\n        ('count', USHORT),\n        ('floors', prot_and_addr_t ),\n    )",
  "class ept_entry_t(NDRSTRUCT):\n    structure = (\n        ('object',UUID),\n        ('tower',twr_p_t),\n        ('annotation', NDRUniVaryingArray),\n    )",
  "class ept_entry_t_array(NDRUniConformantVaryingArray):\n    item = ept_entry_t",
  "class twr_p_t_array(NDRUniConformantVaryingArray):\n    item = twr_p_t",
  "class ept_lookup(NDRCALL):\n    opnum = 2\n    structure = (\n        ('inquiry_type',ULONG),\n        ('object',PUUID),\n        ('Ifid',PRPC_IF_ID),\n        ('vers_option',ULONG),\n        ('entry_handle',ept_lookup_handle_t),\n        ('max_ents',ULONG),\n    )",
  "class ept_lookupResponse(NDRCALL):\n    structure = (\n        ('entry_handle',ept_lookup_handle_t),\n        ('num_ents',ULONG),\n        ('entries',ept_entry_t_array),\n        ('status',error_status),\n    )",
  "class ept_map(NDRCALL):\n    opnum = 3\n    structure = (\n        ('obj',PUUID),\n        ('map_tower',twr_p_t),\n        ('entry_handle',ept_lookup_handle_t),\n        ('max_towers',ULONG),\n    )",
  "class ept_mapResponse(NDRCALL):\n    structure = (\n        ('entry_handle',ept_lookup_handle_t),\n        ('num_towers',ULONG),\n        ('ITowers',twr_p_t_array),\n        ('status',error_status),\n    )",
  "def hept_lookup(destHost, inquiry_type = RPC_C_EP_ALL_ELTS, objectUUID = NULL, ifId = NULL, vers_option = RPC_C_VERS_ALL, dce = None):\n    if dce is None:\n        stringBinding = r'ncacn_ip_tcp:%s[135]' % destHost\n        rpctransport = transport.DCERPCTransportFactory(stringBinding)\n        dce = rpctransport.get_dce_rpc()\n        dce.connect()\n        disconnect = True\n    else:\n        disconnect = False\n\n    dce.bind(MSRPC_UUID_PORTMAP)\n\n    entries = []\n    entry_handle = ept_lookup_handle_t()\n\n    while True:\n        request = ept_lookup()\n        request['inquiry_type'] = inquiry_type\n        request['object'] = objectUUID\n        if ifId != NULL:\n            request['Ifid']['Uuid'] = ifId[:16]\n            request['Ifid']['VersMajor'] = ifId[16:][:2]\n            request['Ifid']['VersMinor'] = ifId[18:]\n        else:\n            request['Ifid'] = ifId\n        request['vers_option'] = vers_option\n        request['entry_handle'] = entry_handle\n        request['max_ents'] = 500\n\n        resp = dce.request(request)\n\n        for i in range(resp['num_ents']):\n            tmpEntry = {}\n            entry = resp['entries'][i]\n            tmpEntry['object'] = entry['object']\n            tmpEntry['annotation'] = b''.join(entry['annotation'])\n            tmpEntry['tower'] = EPMTower(b''.join(entry['tower']['tower_octet_string']))\n            entries.append(tmpEntry)\n\n        entry_handle = resp['entry_handle']\n        if entry_handle.isNull():\n            break\n\n    if disconnect is True:\n        dce.disconnect()\n\n    return entries",
  "def hept_map(destHost, remoteIf, dataRepresentation = uuidtup_to_bin(('8a885d04-1ceb-11c9-9fe8-08002b104860', '2.0')), protocol = 'ncacn_np', dce=None):\n\n    if dce is None:\n        stringBinding = r'ncacn_ip_tcp:%s[135]' % destHost\n        rpctransport = transport.DCERPCTransportFactory(stringBinding)\n        dce = rpctransport.get_dce_rpc()\n        dce.connect()\n        disconnect = True\n    else:\n        disconnect = False\n\n\n    dce.bind(MSRPC_UUID_PORTMAP)\n\n    tower = EPMTower()\n    interface = EPMRPCInterface()\n\n    interface['InterfaceUUID'] = remoteIf[:16]\n    interface['MajorVersion'] = unpack('<H', remoteIf[16:][:2])[0]\n    interface['MinorVersion'] = unpack('<H', remoteIf[18:])[0]\n\n    dataRep = EPMRPCDataRepresentation()\n    dataRep['DataRepUuid'] = dataRepresentation[:16]\n    dataRep['MajorVersion'] = unpack('<H', dataRepresentation[16:][:2])[0]\n    dataRep['MinorVersion'] = unpack('<H', dataRepresentation[18:])[0]\n\n    protId = EPMProtocolIdentifier()\n    protId['ProtIdentifier'] = FLOOR_RPCV5_IDENTIFIER\n\n    if protocol == 'ncacn_np':\n        pipeName = EPMPipeName()\n        pipeName['PipeName'] = b'\\x00'\n\n        hostName = EPMHostName()\n        hostName['HostName'] = b('%s\\x00' % destHost)\n        transportData = pipeName.getData() + hostName.getData()\n\n    elif protocol == 'ncacn_ip_tcp':\n        portAddr = EPMPortAddr()\n        portAddr['IpPort'] = 0\n\n        hostAddr = EPMHostAddr()\n        import socket\n        hostAddr['Ip4addr'] = socket.inet_aton('0.0.0.0')\n        transportData = portAddr.getData() + hostAddr.getData()\n    elif protocol == 'ncacn_http':\n        portAddr = EPMPortAddr()\n        portAddr['PortIdentifier'] = FLOOR_HTTP_IDENTIFIER\n        portAddr['IpPort'] = 0\n\n        hostAddr = EPMHostAddr()\n        import socket\n        hostAddr['Ip4addr'] = socket.inet_aton('0.0.0.0')\n        transportData = portAddr.getData() + hostAddr.getData()\n\n    else:\n        LOG.error('%s not support for hetp_map()' % protocol)\n        if disconnect is True:\n            dce.disconnect()\n        return None\n\n    tower['NumberOfFloors'] = 5\n    tower['Floors'] = interface.getData() + dataRep.getData() + protId.getData() + transportData\n\n    request = ept_map()\n    request['max_towers'] = 1\n    request['map_tower']['tower_length'] = len(tower)\n    request['map_tower']['tower_octet_string'] = tower.getData()\n\n    # Under Windows 2003 the Referent IDs cannot be random\n    # they must have the following specific values\n    # otherwise we get a rpc_x_bad_stub_data exception\n    request.fields['obj'].fields['ReferentID'] = 1\n    request.fields['map_tower'].fields['ReferentID'] = 2\n\n    resp = dce.request(request)\n\n    tower = EPMTower(b''.join(resp['ITowers'][0]['Data']['tower_octet_string']))\n    # Now let's parse the result and return an stringBinding\n    result = None\n    if protocol == 'ncacn_np':\n        # Pipe Name should be the 4th floor\n        pipeName = EPMPipeName(tower['Floors'][3].getData())\n        result = 'ncacn_np:%s[%s]' % (destHost, pipeName['PipeName'].decode('utf-8')[:-1])\n    elif protocol == 'ncacn_ip_tcp':\n        # Port Number should be the 4th floor\n        portAddr = EPMPortAddr(tower['Floors'][3].getData())\n        result = 'ncacn_ip_tcp:%s[%s]' % (destHost, portAddr['IpPort'])\n    elif protocol == 'ncacn_http':\n        # Port Number should be the 4th floor\n        portAddr = EPMPortAddr(tower['Floors'][3].getData())\n        result = 'ncacn_http:%s[%s]' % (destHost, portAddr['IpPort'])\n    if disconnect is True:\n        dce.disconnect()\n    return result",
  "def PrintStringBinding(floors):\n    tmp_address = ''\n    for floor in floors[3:]:\n        if floor['ProtocolData'] == b'\\x07':\n            tmp_address = 'ncacn_ip_tcp:%%s[%d]' % unpack('!H',floor['RelatedData'])\n        elif floor['ProtocolData'] == b'\\x08':\n            tmp_address = 'ncadg_ip_udp:%%s[%d]' % unpack('!H',floor['RelatedData'])\n        elif floor['ProtocolData'] == b'\\x09':\n            tmp_address2 = socket.inet_ntoa(floor['RelatedData'])\n            if tmp_address != '':\n                return tmp_address % tmp_address2\n            else:\n                return 'IP: %s' % tmp_address2\n        elif floor['ProtocolData'] == b'\\x0c':\n            tmp_address = 'ncacn_spx:~%%s[%d]' % unpack('!H',floor['RelatedData'])\n        elif floor['ProtocolData'] == b'\\x0d':\n            n = len(floor['RelatedData'])\n            tmp_address2 = ('%02X' * n) % unpack(\"%dB\" % n, floor['RelatedData'])\n\n            if tmp_address != '':\n                return tmp_address % tmp_address2\n            else:\n                return 'SPX: %s' % tmp_address2\n        elif floor['ProtocolData'] == b'\\x0e':\n            tmp_address = 'ncadg_ipx:~%%s[%d]' % unpack('!H',floor['RelatedData'])\n        elif floor['ProtocolData'] == b'\\x0f':\n            tmp_address = 'ncacn_np:%%s[%s]' % floor['RelatedData'][:len(floor['RelatedData'])-1].decode('utf-8')\n        elif floor['ProtocolData'] == b'\\x10':\n            return 'ncalrpc:[%s]' % floor['RelatedData'][:len(floor['RelatedData'])-1].decode('utf-8')\n        elif floor['ProtocolData'] == b'\\x01' or floor['ProtocolData'] == b'\\x11':\n            if tmp_address != '':\n                return tmp_address % floor['RelatedData'][:len(floor['RelatedData'])-1].decode('utf-8')\n            else:\n                return 'NetBIOS: %s' % floor['RelatedData'].decode('utf-8')\n        elif floor['ProtocolData'] == b'\\x1f':\n            tmp_address = 'ncacn_http:%%s[%d]' % unpack('!H',floor['RelatedData'])\n        else:\n            return 'unknown_proto_0x%x:[0]' % ord(floor['ProtocolData'] )",
  "def __init__(self, error_string=None, error_code=None, packet=None):\n        DCERPCException.__init__(self, error_string, error_code, packet)\n        self.error_code = packet['status']",
  "def __str__( self ):\n        key = self.error_code\n        if key in self.error_messages:\n            error_msg_short = self.error_messages[key]\n            return 'EPM SessionError: code: 0x%x - %s ' % (self.error_code, error_msg_short)\n        else:\n            return 'EPM SessionError: unknown error code: %s' % (str(self.error_code))",
  "def __init__(self, data = None):\n        EPMFloor.__init__(self, data)",
  "def __str__(self):\n        aUuid = bin_to_string(self[\"InterfaceUUID\"])\n        return \"%s v%d.%d\" % (aUuid,self[\"MajorVersion\"],self[\"MinorVersion\"])",
  "def __len__(self):\n       return 25",
  "def __init__(self, data = None):\n        EPMFloor.__init__(self, data)",
  "def __str__(self):\n        aUuid = bin_to_string(self[\"DataRepUuid\"])\n        return \"%s v%d.%d\" % (aUuid,self[\"MajorVersion\"],self[\"MinorVersion\"])",
  "def __len__(self):\n       return 25",
  "def __init__(self, data = None):\n        EPMFloor.__init__(self, data)",
  "def __len__(self):\n       return 6",
  "def fromString(self,data):\n        Structure.fromString(self,data)\n        floors = self['Floors']\n        fList = []\n        for f in range(self['NumberOfFloors']):\n            floor = EPMFloors[f](floors)\n            floors = floors[len(floor):]\n            fList.append(floor) \n        self['Floors'] = fList",
  "def __init__(self, data=None, isNDR64=False):\n        NDRSTRUCT.__init__(self, data, isNDR64)\n        self['context_handle_uuid'] = b'\\x00'*16",
  "def isNull(self):\n        return self['context_handle_uuid'] == b'\\x00'*16",
  "class LPDWORD(NDRPOINTER):\n    referent = (\n        ('Data', DWORD),\n    )",
  "class PSHORT(NDRPOINTER):\n    referent = (\n        ('Data', SHORT),\n    )",
  "class PBOOL(NDRPOINTER):\n    referent = (\n        ('Data', BOOL),\n    )",
  "class LPBYTE(NDRPOINTER):\n    referent = (\n        ('Data', NDRUniConformantArray),\n    )",
  "class PCHAR(NDRPOINTER):\n    referent = (\n        ('Data', CHAR),\n    )",
  "class WIDESTR(NDRUniFixedArray):\n    def getDataLen(self, data, offset=0):\n        return data.find(b'\\x00\\x00\\x00', offset)+3-offset\n\n    def __setitem__(self, key, value):\n        if key == 'Data':\n            try:\n                self.fields[key] = value.encode('utf-16le')\n            except UnicodeDecodeError:\n                import sys\n                self.fields[key] = value.decode(sys.getfilesystemencoding()).encode('utf-16le')\n\n            self.data = None        # force recompute\n        else:\n            return NDR.__setitem__(self, key, value)\n\n    def __getitem__(self, key):\n        if key == 'Data':\n            return self.fields[key].decode('utf-16le')\n        else:\n            return NDR.__getitem__(self,key)",
  "class STR(NDRSTRUCT):\n    commonHdr = (\n        ('MaximumCount', '<L=len(Data)'),\n        ('Offset','<L=0'),\n        ('ActualCount','<L=len(Data)'),\n    )\n    commonHdr64 = (\n        ('MaximumCount', '<Q=len(Data)'),\n        ('Offset','<Q=0'),\n        ('ActualCount','<Q=len(Data)'),\n    )\n    structure = (\n        ('Data',':'),\n    )\n\n    def dump(self, msg = None, indent = 0):\n        if msg is None:\n            msg = self.__class__.__name__\n        if msg != '':\n            print(\"%s\" % msg, end=' ')\n        # Here just print the data\n        print(\" %r\" % (self['Data']), end=' ')\n\n    def __setitem__(self, key, value):\n        if key == 'Data':\n            try:\n                if not isinstance(value, binary_type):\n                    self.fields[key] = value.encode('utf-8')\n                else:\n                    # if it is a binary type (str in Python 2, bytes in Python 3), then we assume it is a raw buffer\n                    self.fields[key] = value\n            except UnicodeDecodeError:\n                import sys\n                self.fields[key] = value.decode(sys.getfilesystemencoding()).encode('utf-8')\n            self.fields['MaximumCount'] = None\n            self.fields['ActualCount'] = None\n            self.data = None        # force recompute\n        else:\n            return NDR.__setitem__(self, key, value)\n\n    def __getitem__(self, key):\n        if key == 'Data':\n            try:\n                return self.fields[key].decode('utf-8')\n            except UnicodeDecodeError:\n                # if we could't decode it, we assume it is a raw buffer\n                return self.fields[key]\n        else:\n            return NDR.__getitem__(self,key)\n\n    def getDataLen(self, data, offset=0):\n        return self[\"ActualCount\"]",
  "class LPSTR(NDRPOINTER):\n    referent = (\n        ('Data', STR),\n    )",
  "class WSTR(NDRSTRUCT):\n    commonHdr = (\n        ('MaximumCount', '<L=len(Data)//2'),\n        ('Offset','<L=0'),\n        ('ActualCount','<L=len(Data)//2'),\n    )\n    commonHdr64 = (\n        ('MaximumCount', '<Q=len(Data)//2'),\n        ('Offset','<Q=0'),\n        ('ActualCount','<Q=len(Data)//2'),\n    )\n    structure = (\n        ('Data',':'),\n    )\n\n    def dump(self, msg = None, indent = 0):\n        if msg is None:\n            msg = self.__class__.__name__\n        if msg != '':\n            print(\"%s\" % msg, end=' ')\n        # Here just print the data\n        print(\" %r\" % (self['Data']), end=' ')\n\n    def getDataLen(self, data, offset=0):\n        return self[\"ActualCount\"]*2 \n\n    def __setitem__(self, key, value):\n        if key == 'Data':\n            try:\n                self.fields[key] = value.encode('utf-16le')\n            except UnicodeDecodeError:\n                import sys\n                self.fields[key] = value.decode(sys.getfilesystemencoding()).encode('utf-16le')\n            self.fields['MaximumCount'] = None\n            self.fields['ActualCount'] = None\n            self.data = None        # force recompute\n        else:\n            return NDR.__setitem__(self, key, value)\n\n    def __getitem__(self, key):\n        if key == 'Data':\n            return self.fields[key].decode('utf-16le')\n        else:\n            return NDR.__getitem__(self,key)",
  "class LPWSTR(NDRPOINTER):\n    referent = (\n        ('Data', WSTR),\n    )",
  "class PDOUBLE(NDRPOINTER):\n    referent = (\n        ('Data', DOUBLE),\n    )",
  "class PFLOAT(NDRPOINTER):\n    referent = (\n        ('Data', FLOAT),\n    )",
  "class PHRESULT(NDRPOINTER):\n    referent = (\n        ('Data', HRESULT),\n    )",
  "class PINT(NDRPOINTER):\n    referent = (\n        ('Data', INT),\n    )",
  "class LPLONG(NDRPOINTER):\n    referent = (\n        ('Data', LONG),\n    )",
  "class PLONGLONG(NDRPOINTER):\n    referent = (\n        ('Data', LONGLONG),\n    )",
  "class PLONG64(NDRPOINTER):\n    referent = (\n        ('Data', LONG64),\n    )",
  "class GUID(NDRSTRUCT):\n    structure = (\n        ('Data','16s=b\"\"'),\n    )\n\n    def getAlignment(self):\n        return 4",
  "class PGUID(NDRPOINTER):\n    referent = (\n        ('Data', GUID),\n    )",
  "class PUINT(NDRPOINTER):\n    referent = (\n        ('Data', UINT),\n    )",
  "class PULONG(NDRPOINTER):\n    referent = (\n        ('Data', ULONG),\n    )",
  "class PULONGLONG(NDRPOINTER):\n    referent = (\n        ('Data', ULONGLONG),\n    )",
  "class PUSHORT(NDRPOINTER):\n    referent = (\n        ('Data', USHORT),\n    )",
  "class PWORD(NDRPOINTER):\n    referent = (\n        ('Data', WORD),\n    )",
  "class FILETIME(NDRSTRUCT):\n    structure = (\n        ('dwLowDateTime', DWORD),\n        ('dwHighDateTime', LONG),\n    )",
  "class PFILETIME(NDRPOINTER):\n    referent = (\n        ('Data', FILETIME),\n    )",
  "class PLARGE_INTEGER(NDRPOINTER):\n    referent = (\n        ('Data', LARGE_INTEGER),\n    )",
  "class LUID(NDRSTRUCT):\n    structure = (\n        ('LowPart', DWORD),\n        ('HighPart', LONG),\n    )",
  "class RPC_UNICODE_STRING(NDRSTRUCT):\n    # Here we're doing some tricks to make this data type\n    # easier to use. It's exactly the same as defined. I changed the\n    # Buffer name for Data, so users can write directly to the datatype\n    # instead of writing to datatype['Buffer'].\n    # The drawback is you cannot directly access the Length and \n    # MaximumLength fields. \n    # If you really need it, you will need to do it this way:\n    # class TT(NDRCALL):\n    # structure = (\n    #     ('str1', RPC_UNICODE_STRING),\n    #  )\n    # \n    # nn = TT()\n    # nn.fields['str1'].fields['MaximumLength'] = 30\n    structure = (\n        ('Length','<H=0'),\n        ('MaximumLength','<H=0'),\n        ('Data',LPWSTR),\n    )\n\n    def __setitem__(self, key, value):\n        if key == 'Data' and isinstance(value, NDR) is False:\n            try:\n                value.encode('utf-16le')\n            except UnicodeDecodeError:\n                import sys\n                value = value.decode(sys.getfilesystemencoding())\n            self['Length'] = len(value)*2\n            self['MaximumLength'] = len(value)*2\n        return NDRSTRUCT.__setitem__(self, key, value)\n\n    def dump(self, msg = None, indent = 0):\n        if msg is None:\n            msg = self.__class__.__name__\n        if msg != '':\n            print(\"%s\" % msg, end=' ')\n\n        if isinstance(self.fields['Data'] , NDRPOINTERNULL):\n            print(\" NULL\", end=' ')\n        elif self.fields['Data']['ReferentID'] == 0:\n            print(\" NULL\", end=' ')\n        else:\n            return self.fields['Data'].dump('',indent)",
  "class PRPC_UNICODE_STRING(NDRPOINTER):\n    referent = (\n       ('Data', RPC_UNICODE_STRING ),\n    )",
  "class OBJECT_TYPE_LIST(NDRSTRUCT):\n    structure = (\n        ('Level', WORD),\n        ('Remaining',ACCESS_MASK),\n        ('ObjectType',PGUID),\n    )",
  "class POBJECT_TYPE_LIST(NDRPOINTER):\n    referent = (\n       ('Data', OBJECT_TYPE_LIST ),\n    )",
  "class SYSTEMTIME(NDRSTRUCT):\n    structure = (\n        ('wYear', WORD),\n        ('wMonth', WORD),\n        ('wDayOfWeek', WORD),\n        ('wDay', WORD),\n        ('wHour', WORD),\n        ('wMinute', WORD),\n        ('wSecond', WORD),\n        ('wMilliseconds', WORD),\n    )",
  "class PSYSTEMTIME(NDRPOINTER):\n    referent = (\n       ('Data', SYSTEMTIME ),\n    )",
  "class ULARGE_INTEGER(NDRSTRUCT):\n    structure = (\n        ('QuadPart', LONG64),\n    )",
  "class PULARGE_INTEGER(NDRPOINTER):\n    referent = (\n        ('Data', ULARGE_INTEGER),\n    )",
  "class SID_IDENTIFIER_AUTHORITY(Structure):\n    structure = (\n        ('Value', '6s'),\n    )",
  "class SID(Structure):\n    structure = (\n        ('Revision', '<B'),\n        ('SubAuthorityCount', '<B'),\n        ('IdentifierAuthority', ':', SID_IDENTIFIER_AUTHORITY),\n        ('SubLen', '_-SubAuthority', 'self[\"SubAuthorityCount\"]*4'),\n        ('SubAuthority', ':'),\n    )\n\n    def formatCanonical(self):\n        ans = 'S-%d-%d' % (self['Revision'], ord(self['IdentifierAuthority']['Value'][5:6]))\n        for i in range(self['SubAuthorityCount']):\n            ans += '-%d' % (unpack('<L', self['SubAuthority'][i * 4:i * 4 + 4])[0])\n        return ans\n\n    def fromCanonical(self, canonical):\n        items = canonical.split('-')\n        self['Revision'] = int(items[1])\n        self['IdentifierAuthority'] = SID_IDENTIFIER_AUTHORITY()\n        self['IdentifierAuthority']['Value'] = b'\\x00\\x00\\x00\\x00\\x00' + pack('B', int(items[2]))\n        self['SubAuthorityCount'] = len(items) - 3\n        self['SubAuthority'] = b''\n        for i in range(self['SubAuthorityCount']):\n            self['SubAuthority'] += pack('<L', int(items[i + 3]))",
  "class DWORD_ARRAY(NDRUniConformantArray):\n    item = '<L'",
  "class RPC_SID_IDENTIFIER_AUTHORITY(NDRUniFixedArray):\n    align = 1\n    align64 = 1\n    def getDataLen(self, data, offset=0):\n        return 6",
  "class RPC_SID(NDRSTRUCT):\n    structure = (\n        ('Revision',NDRSMALL),\n        ('SubAuthorityCount',NDRSMALL),\n        ('IdentifierAuthority',RPC_SID_IDENTIFIER_AUTHORITY),\n        ('SubAuthority',DWORD_ARRAY),\n    )\n    def getData(self, soFar = 0):\n        self['SubAuthorityCount'] = len(self['SubAuthority'])\n        return NDRSTRUCT.getData(self, soFar)\n\n    def fromCanonical(self, canonical):\n        items = canonical.split('-')\n        self['Revision'] = int(items[1])\n        self['IdentifierAuthority'] = b'\\x00\\x00\\x00\\x00\\x00' + pack('B',int(items[2]))\n        self['SubAuthorityCount'] = len(items) - 3\n        for i in range(self['SubAuthorityCount']):\n            self['SubAuthority'].append(int(items[i+3]))\n\n    def formatCanonical(self):\n        ans = 'S-%d-%d' % (self['Revision'], ord(self['IdentifierAuthority'][5:6]))\n        for i in range(self['SubAuthorityCount']):\n            ans += '-%d' % self['SubAuthority'][i]\n        return ans",
  "class PRPC_SID(NDRPOINTER):\n    referent = (\n        ('Data', RPC_SID),\n    )",
  "class ACL(NDRSTRUCT):\n    structure = (\n        ('AclRevision',NDRSMALL),\n        ('Sbz1',NDRSMALL),\n        ('AclSize',NDRSHORT),\n        ('AceCount',NDRSHORT),\n        ('Sbz2',NDRSHORT),\n    )",
  "class PACL(NDRPOINTER):\n    referent = (\n        ('Data', ACL),\n    )",
  "class SECURITY_DESCRIPTOR(NDRSTRUCT):\n    structure = (\n        ('Revision',UCHAR),\n        ('Sbz1',UCHAR),\n        ('Control',USHORT),\n        ('Owner',PSID),\n        ('Group',PSID),\n        ('Sacl',PACL),\n        ('Dacl',PACL),\n    )",
  "class PSECURITY_INFORMATION(NDRPOINTER):\n    referent = (\n        ('Data', SECURITY_INFORMATION),\n    )",
  "def getDataLen(self, data, offset=0):\n        return data.find(b'\\x00\\x00\\x00', offset)+3-offset",
  "def __setitem__(self, key, value):\n        if key == 'Data':\n            try:\n                self.fields[key] = value.encode('utf-16le')\n            except UnicodeDecodeError:\n                import sys\n                self.fields[key] = value.decode(sys.getfilesystemencoding()).encode('utf-16le')\n\n            self.data = None        # force recompute\n        else:\n            return NDR.__setitem__(self, key, value)",
  "def __getitem__(self, key):\n        if key == 'Data':\n            return self.fields[key].decode('utf-16le')\n        else:\n            return NDR.__getitem__(self,key)",
  "def dump(self, msg = None, indent = 0):\n        if msg is None:\n            msg = self.__class__.__name__\n        if msg != '':\n            print(\"%s\" % msg, end=' ')\n        # Here just print the data\n        print(\" %r\" % (self['Data']), end=' ')",
  "def __setitem__(self, key, value):\n        if key == 'Data':\n            try:\n                if not isinstance(value, binary_type):\n                    self.fields[key] = value.encode('utf-8')\n                else:\n                    # if it is a binary type (str in Python 2, bytes in Python 3), then we assume it is a raw buffer\n                    self.fields[key] = value\n            except UnicodeDecodeError:\n                import sys\n                self.fields[key] = value.decode(sys.getfilesystemencoding()).encode('utf-8')\n            self.fields['MaximumCount'] = None\n            self.fields['ActualCount'] = None\n            self.data = None        # force recompute\n        else:\n            return NDR.__setitem__(self, key, value)",
  "def __getitem__(self, key):\n        if key == 'Data':\n            try:\n                return self.fields[key].decode('utf-8')\n            except UnicodeDecodeError:\n                # if we could't decode it, we assume it is a raw buffer\n                return self.fields[key]\n        else:\n            return NDR.__getitem__(self,key)",
  "def getDataLen(self, data, offset=0):\n        return self[\"ActualCount\"]",
  "def dump(self, msg = None, indent = 0):\n        if msg is None:\n            msg = self.__class__.__name__\n        if msg != '':\n            print(\"%s\" % msg, end=' ')\n        # Here just print the data\n        print(\" %r\" % (self['Data']), end=' ')",
  "def getDataLen(self, data, offset=0):\n        return self[\"ActualCount\"]*2",
  "def __setitem__(self, key, value):\n        if key == 'Data':\n            try:\n                self.fields[key] = value.encode('utf-16le')\n            except UnicodeDecodeError:\n                import sys\n                self.fields[key] = value.decode(sys.getfilesystemencoding()).encode('utf-16le')\n            self.fields['MaximumCount'] = None\n            self.fields['ActualCount'] = None\n            self.data = None        # force recompute\n        else:\n            return NDR.__setitem__(self, key, value)",
  "def __getitem__(self, key):\n        if key == 'Data':\n            return self.fields[key].decode('utf-16le')\n        else:\n            return NDR.__getitem__(self,key)",
  "def getAlignment(self):\n        return 4",
  "def __setitem__(self, key, value):\n        if key == 'Data' and isinstance(value, NDR) is False:\n            try:\n                value.encode('utf-16le')\n            except UnicodeDecodeError:\n                import sys\n                value = value.decode(sys.getfilesystemencoding())\n            self['Length'] = len(value)*2\n            self['MaximumLength'] = len(value)*2\n        return NDRSTRUCT.__setitem__(self, key, value)",
  "def dump(self, msg = None, indent = 0):\n        if msg is None:\n            msg = self.__class__.__name__\n        if msg != '':\n            print(\"%s\" % msg, end=' ')\n\n        if isinstance(self.fields['Data'] , NDRPOINTERNULL):\n            print(\" NULL\", end=' ')\n        elif self.fields['Data']['ReferentID'] == 0:\n            print(\" NULL\", end=' ')\n        else:\n            return self.fields['Data'].dump('',indent)",
  "def formatCanonical(self):\n        ans = 'S-%d-%d' % (self['Revision'], ord(self['IdentifierAuthority']['Value'][5:6]))\n        for i in range(self['SubAuthorityCount']):\n            ans += '-%d' % (unpack('<L', self['SubAuthority'][i * 4:i * 4 + 4])[0])\n        return ans",
  "def fromCanonical(self, canonical):\n        items = canonical.split('-')\n        self['Revision'] = int(items[1])\n        self['IdentifierAuthority'] = SID_IDENTIFIER_AUTHORITY()\n        self['IdentifierAuthority']['Value'] = b'\\x00\\x00\\x00\\x00\\x00' + pack('B', int(items[2]))\n        self['SubAuthorityCount'] = len(items) - 3\n        self['SubAuthority'] = b''\n        for i in range(self['SubAuthorityCount']):\n            self['SubAuthority'] += pack('<L', int(items[i + 3]))",
  "def getDataLen(self, data, offset=0):\n        return 6",
  "def getData(self, soFar = 0):\n        self['SubAuthorityCount'] = len(self['SubAuthority'])\n        return NDRSTRUCT.getData(self, soFar)",
  "def fromCanonical(self, canonical):\n        items = canonical.split('-')\n        self['Revision'] = int(items[1])\n        self['IdentifierAuthority'] = b'\\x00\\x00\\x00\\x00\\x00' + pack('B',int(items[2]))\n        self['SubAuthorityCount'] = len(items) - 3\n        for i in range(self['SubAuthorityCount']):\n            self['SubAuthority'].append(int(items[i+3]))",
  "def formatCanonical(self):\n        ans = 'S-%d-%d' % (self['Revision'], ord(self['IdentifierAuthority'][5:6]))\n        for i in range(self['SubAuthorityCount']):\n            ans += '-%d' % self['SubAuthority'][i]\n        return ans",
  "class NDR(object):\n    \"\"\"\n    This will be the base class for all DCERPC NDR Types and represents a NDR Primitive Type\n    \"\"\"\n    referent       = ()\n    commonHdr      = ()\n    commonHdr64    = ()\n    structure      = ()\n    structure64    = ()\n    align          = 4\n    item           = None\n    _isNDR64       = False\n\n    def __init__(self, data = None, isNDR64 = False):\n        object.__init__(self)\n        self._isNDR64 = isNDR64\n        self.fields = {}\n\n        if isNDR64 is True:\n            if self.commonHdr64 != ():\n                self.commonHdr = self.commonHdr64\n            if self.structure64 != ():\n                self.structure = self.structure64\n            if hasattr(self, 'align64'):\n                self.align = self.align64\n\n        for fieldName, fieldTypeOrClass in self.commonHdr+self.structure+self.referent:\n            if self.isNDR(fieldTypeOrClass):\n               self.fields[fieldName] = fieldTypeOrClass(isNDR64 = self._isNDR64)\n            elif fieldTypeOrClass == ':':\n               self.fields[fieldName] = b''\n            elif len(fieldTypeOrClass.split('=')) == 2: \n               try:\n                   self.fields[fieldName] = eval(fieldTypeOrClass.split('=')[1])\n               except:\n                   self.fields[fieldName] = None\n            else:\n               self.fields[fieldName] = []\n\n        if data is not None:\n            self.fromString(data)\n\n    def changeTransferSyntax(self, newSyntax): \n        NDR64Syntax = uuidtup_to_bin(('71710533-BEBA-4937-8319-B5DBEF9CCC36', '1.0'))\n        if newSyntax == NDR64Syntax:\n            if self._isNDR64 is False:\n                # Ok, let's change everything\n                self._isNDR64 = True\n                for fieldName in list(self.fields.keys()):\n                    if isinstance(self.fields[fieldName], NDR):\n                        self.fields[fieldName].changeTransferSyntax(newSyntax)\n                # Finally, I change myself\n                if self.commonHdr64 != ():\n                    self.commonHdr = self.commonHdr64\n                if self.structure64 != ():\n                    self.structure = self.structure64\n                if hasattr(self, 'align64'):\n                    self.align = self.align64\n                # And check whether the changes changed the data types\n                # if so, I need to instantiate the new ones and copy the\n                # old values\n                for fieldName, fieldTypeOrClass in self.commonHdr+self.structure+self.referent:\n                    if isinstance(self.fields[fieldName], NDR):\n                        if fieldTypeOrClass != self.fields[fieldName].__class__ and isinstance(self.fields[fieldName], NDRPOINTERNULL) is False:\n                            backupData = self[fieldName]\n                            self.fields[fieldName] = fieldTypeOrClass(isNDR64 = self._isNDR64)\n                            if 'Data' in self.fields[fieldName].fields:\n                                self.fields[fieldName].fields['Data'] = backupData\n                            else:\n                                self[fieldName] = backupData\n  \n        else:\n            if self._isNDR64 is True:\n                # Ok, nothing for now\n                raise Exception('Shouldn\\'t be here')\n\n    def __setitem__(self, key, value):\n        if isinstance(value, NDRPOINTERNULL):\n            value = NDRPOINTERNULL(isNDR64 = self._isNDR64)\n            if isinstance(self.fields[key], NDRPOINTER):\n                self.fields[key] = value\n            elif 'Data' in self.fields[key].fields:\n                if isinstance(self.fields[key].fields['Data'], NDRPOINTER):\n                    self.fields[key].fields['Data'] = value\n        elif isinstance(value, NDR):\n            # It's not a null pointer, ok. Another NDR type, but it \n            # must be the same same as the iteam already in place\n            if self.fields[key].__class__.__name__ == value.__class__.__name__:\n                self.fields[key] = value\n            elif isinstance(self.fields[key]['Data'], NDR):\n                if self.fields[key]['Data'].__class__.__name__ == value.__class__.__name__:\n                    self.fields[key]['Data'] = value\n                else:\n                    LOG.error(\"Can't setitem with class specified, should be %s\" % self.fields[key]['Data'].__class__.__name__)\n            else:\n                LOG.error(\"Can't setitem with class specified, should be %s\" % self.fields[key].__class__.__name__)\n        elif isinstance(self.fields[key], NDR):\n            self.fields[key]['Data'] = value\n        else:\n            self.fields[key] = value\n\n    def __getitem__(self, key):\n        if isinstance(self.fields[key], NDR):\n            if 'Data' in self.fields[key].fields:\n                return self.fields[key]['Data']\n        return self.fields[key]\n\n    def __str__(self):\n        return self.getData()\n\n    def __len__(self):\n        # XXX: improve\n        return len(self.getData())\n\n    def getDataLen(self, data, offset=0):\n        return len(data) - offset\n\n    @staticmethod\n    def isNDR(field):\n        if inspect.isclass(field):\n            myClass = field\n            if issubclass(myClass, NDR):\n                return True\n        return False\n\n    def dumpRaw(self, msg = None, indent = 0):\n        if msg is None:\n            msg = self.__class__.__name__\n        ind = ' '*indent\n        print(\"\\n%s\" % msg)\n        for field in self.commonHdr+self.structure+self.referent:\n            i = field[0] \n            if i in self.fields:\n                if isinstance(self.fields[i], NDR):\n                    self.fields[i].dumpRaw('%s%s:{' % (ind,i), indent = indent + 4)\n                    print(\"%s}\" % ind)\n\n                elif isinstance(self.fields[i], list):\n                    print(\"%s[\" % ind)\n                    for num,j in enumerate(self.fields[i]):\n                       if isinstance(j, NDR):\n                           j.dumpRaw('%s%s:' % (ind,i), indent = indent + 4)\n                           print(\"%s,\" % ind)\n                       else:\n                           print(\"%s%s: {%r},\" % (ind, i, j))\n                    print(\"%s]\" % ind)\n\n                else:\n                    print(\"%s%s: {%r}\" % (ind,i,self[i]))\n\n    def dump(self, msg = None, indent = 0):\n        if msg is None:\n            msg = self.__class__.__name__\n        ind = ' '*indent\n        if msg != '':\n            print(\"%s\" % msg, end=' ')\n        for fieldName, fieldType in self.commonHdr+self.structure+self.referent:\n            if fieldName in self.fields:\n                if isinstance(self.fields[fieldName], NDR):\n                    self.fields[fieldName].dump('\\n%s%-31s' % (ind, fieldName+':'), indent = indent + 4),\n                else:\n                    print(\" %r\" % (self[fieldName]), end=' ')\n\n    def getAlignment(self):\n        return self.align\n\n    @staticmethod\n    def calculatePad(fieldType, soFar):\n        if isinstance(fieldType, str):\n            try:\n                alignment = calcsize(fieldType.split('=')[0])\n            except:\n                alignment = 0\n        else:\n            alignment = 0\n\n        if alignment > 0:\n            pad = (alignment - (soFar % alignment)) % alignment\n        else:\n            pad = 0\n\n        return pad\n\n    def getData(self, soFar = 0):\n        data = b''\n        for fieldName, fieldTypeOrClass in self.commonHdr+self.structure:\n            try:\n                # Alignment of Primitive Types\n\n                # NDR enforces NDR alignment of primitive data; that is, any primitive of size n\n                # octets is aligned at a octet stream index that is a multiple of n.\n                # (In this version of NDR, n is one of {1, 2, 4, 8}.) An octet stream index indicates\n                # the number of an octet in an octet stream when octets are numbered, beginning with 0,\n                # from the first octet in the stream. Where necessary, an alignment gap, consisting of\n                # octets of unspecified value, precedes the representation of a primitive. The gap is\n                # of the smallest size sufficient to align the primitive.\n                pad = self.calculatePad(fieldTypeOrClass, soFar)\n                if pad > 0:\n                    soFar += pad\n                    data += b'\\xbf'*pad\n\n                res = self.pack(fieldName, fieldTypeOrClass, soFar)\n\n                data += res\n                soFar += len(res)\n            except Exception as e:\n                LOG.error(str(e))\n                LOG.error(\"Error packing field '%s | %s' in %s\" % (fieldName, fieldTypeOrClass, self.__class__))\n                raise\n\n        return data\n\n    def fromString(self, data, offset=0):\n        offset0 = offset\n        for fieldName, fieldTypeOrClass in self.commonHdr+self.structure:\n            try:\n                # Alignment of Primitive Types\n\n                # NDR enforces NDR alignment of primitive data; that is, any primitive of size n\n                # octets is aligned at a octet stream index that is a multiple of n.\n                # (In this version of NDR, n is one of {1, 2, 4, 8}.) An octet stream index indicates\n                # the number of an octet in an octet stream when octets are numbered, beginning with 0,\n                # from the first octet in the stream. Where necessary, an alignment gap, consisting of\n                # octets of unspecified value, precedes the representation of a primitive. The gap is\n                # of the smallest size sufficient to align the primitive.\n                offset += self.calculatePad(fieldTypeOrClass, offset)\n\n                offset += self.unpack(fieldName, fieldTypeOrClass, data, offset)\n            except Exception as e:\n                LOG.error(str(e))\n                LOG.error(\"Error unpacking field '%s | %s | %r'\" % (fieldName, fieldTypeOrClass, data[offset:offset+256]))\n                raise\n        return offset - offset0\n\n    def pack(self, fieldName, fieldTypeOrClass, soFar = 0):\n        if isinstance(self.fields[fieldName], NDR):\n            return self.fields[fieldName].getData(soFar)\n\n        data = self.fields[fieldName]\n        # void specifier\n        if fieldTypeOrClass[:1] == '_':\n            return b''\n\n        # code specifier\n        two = fieldTypeOrClass.split('=')\n        if len(two) >= 2:\n            try:\n                return self.pack(fieldName, two[0], soFar)\n            except:\n                self.fields[fieldName] = eval(two[1], {}, self.fields)\n                return self.pack(fieldName, two[0], soFar)\n\n        if data is None:\n            raise Exception('Trying to pack None')\n\n        # literal specifier\n        if fieldTypeOrClass[:1] == ':':\n            if hasattr(data, 'getData'):\n                return data.getData()\n            return data\n\n        # struct like specifier\n        return pack(fieldTypeOrClass, data)\n\n    def unpack(self, fieldName, fieldTypeOrClass, data, offset=0):\n        if isinstance(self.fields[fieldName], NDR):\n            return self.fields[fieldName].fromString(data, offset)\n\n        # code specifier\n        two = fieldTypeOrClass.split('=')\n        if len(two) >= 2:\n            return self.unpack(fieldName, two[0], data, offset)\n\n        # literal specifier\n        if fieldTypeOrClass == ':':\n            if isinstance(fieldTypeOrClass, NDR):\n                return self.fields[fieldName].fromString(data, offset)\n            else:\n                dataLen = self.getDataLen(data, offset)\n                self.fields[fieldName] =  data[offset:offset+dataLen]\n                return dataLen\n\n        # struct like specifier\n        self.fields[fieldName] = unpack_from(fieldTypeOrClass, data, offset)[0]\n\n        return calcsize(fieldTypeOrClass)\n\n    def calcPackSize(self, fieldTypeOrClass, data):\n        if isinstance(fieldTypeOrClass, str) is False:\n            return len(data)\n\n        # code specifier\n        two = fieldTypeOrClass.split('=')\n        if len(two) >= 2:\n            return self.calcPackSize(two[0], data)\n\n        # literal specifier\n        if fieldTypeOrClass[:1] == ':':\n            return len(data)\n\n        # struct like specifier\n        return calcsize(fieldTypeOrClass)\n\n    def calcUnPackSize(self, fieldTypeOrClass, data, offset=0):\n        if isinstance(fieldTypeOrClass, str) is False:\n            return len(data) - offset\n\n        # code specifier\n        two = fieldTypeOrClass.split('=')\n        if len(two) >= 2:\n            return self.calcUnPackSize(two[0], data, offset)\n\n        # array specifier\n        two = fieldTypeOrClass.split('*')\n        if len(two) == 2:\n            return len(data) - offset\n\n        # literal specifier\n        if fieldTypeOrClass[:1] == ':':\n            return len(data) - offset\n\n        # struct like specifier\n        return calcsize(fieldTypeOrClass)",
  "class NDRSMALL(NDR):\n    align = 1\n    structure = (\n        ('Data', 'b=0'),\n    )",
  "class NDRUSMALL(NDR):\n    align = 1\n    structure = (\n        ('Data', 'B=0'),\n    )",
  "class NDRBOOLEAN(NDRSMALL):\n    def dump(self, msg = None, indent = 0):\n        if msg is None:\n            msg = self.__class__.__name__\n        if msg != '':\n            print(msg, end=' ')\n\n        if self['Data'] > 0:\n            print(\" TRUE\")\n        else:\n            print(\" FALSE\")",
  "class NDRCHAR(NDR):\n    align = 1\n    structure = (\n        ('Data', 'c'),\n    )",
  "class NDRSHORT(NDR):\n    align = 2\n    structure = (\n        ('Data', '<h=0'),\n    )",
  "class NDRUSHORT(NDR):\n    align = 2\n    structure = (\n        ('Data', '<H=0'),\n    )",
  "class NDRLONG(NDR):\n    align = 4\n    structure = (\n        ('Data', '<l=0'),\n    )",
  "class NDRULONG(NDR):\n    align = 4\n    structure = (\n        ('Data', '<L=0'),\n    )",
  "class NDRHYPER(NDR):\n    align = 8\n    structure = (\n        ('Data', '<q=0'),\n    )",
  "class NDRUHYPER(NDR):\n    align = 8\n    structure = (\n        ('Data', '<Q=0'),\n    )",
  "class NDRFLOAT(NDR):\n    align = 4\n    structure = (\n        ('Data', '<f=0'),\n    )",
  "class NDRDOUBLEFLOAT(NDR):\n    align = 8\n    structure = (\n        ('Data', '<d=0'),\n    )",
  "class EnumType(type):\n    def __getattr__(self, attr):\n        return self.enumItems[attr].value",
  "class NDRENUM(with_metaclass(EnumType, NDR)):\n    align = 2\n    align64 = 4\n    structure = (\n        ('Data', '<H'),\n    )\n\n    # 2.2.5.2 NDR64 Simple Data Types\n    # NDR64 supports all simple types defined by NDR (as specified in [C706] section 14.2)\n    # with the same alignment requirements except for enumerated types, which MUST be \n    # represented as signed long integers (4 octets) in NDR64.\n    structure64 = (\n        ('Data', '<L'),\n    )\n    # enum MUST be an python enum (see enum.py)\n    class enumItems(Enum):\n        pass\n\n    def __setitem__(self, key, value):\n       if isinstance(value, Enum):\n           self['Data'] = value.value\n       else:\n           return NDR.__setitem__(self,key,value)\n\n    def dump(self, msg = None, indent = 0):\n        if msg is None:\n            msg = self.__class__.__name__\n        if msg != '':\n            print(msg, end=' ')\n\n        print(\" %s\" % self.enumItems(self.fields['Data']).name, end=' ')",
  "class NDRCONSTRUCTEDTYPE(NDR):\n    @staticmethod\n    def isPointer(field):\n        if inspect.isclass(field):\n            myClass = field\n            if issubclass(myClass, NDRPOINTER):\n                return True\n        return False\n\n    @staticmethod\n    def isUnion(field):\n        if inspect.isclass(field):\n            myClass = field\n            if issubclass(myClass, NDRUNION):\n                return True\n        return False\n\n    def getDataReferents(self, soFar = 0):\n        data = b''\n        for fieldName, fieldTypeOrClass in self.commonHdr+self.structure:\n            if isinstance(self.fields[fieldName], NDRCONSTRUCTEDTYPE):\n               data += self.fields[fieldName].getDataReferents(len(data)+soFar)\n               data += self.fields[fieldName].getDataReferent(len(data)+soFar)\n        return data\n\n    def getDataReferent(self, soFar=0):\n        data = b''\n        soFar0 = soFar\n        if hasattr(self,'referent') is False:\n            return b''\n\n        if 'ReferentID' in self.fields:\n            if self['ReferentID'] == 0:\n                return b''\n\n        for fieldName, fieldTypeOrClass in self.referent:\n            try:\n                if isinstance(self.fields[fieldName], NDRUniConformantArray) or isinstance(self.fields[fieldName], NDRUniConformantVaryingArray):\n                    # So we have an array, first item in the structure must be the array size, although we\n                    # will need to build it later.\n                    if self._isNDR64:\n                        arrayItemSize = 8\n                        arrayPackStr = '<Q'\n                    else:\n                        arrayItemSize = 4\n                        arrayPackStr = '<L'\n\n                    # The size information is itself aligned according to the alignment rules for\n                    # primitive data types. (See Section 14.2.2 on page 620.) The data of the constructed\n                    # type is then aligned according to the alignment rules for the constructed type.\n                    # In other words, the size information precedes the structure and is aligned\n                    # independently of the structure alignment.\n                    # We need to check whether we need padding or not\n                    pad0 = (arrayItemSize - (soFar % arrayItemSize)) % arrayItemSize\n                    if pad0 > 0:\n                        soFar += pad0\n                        arrayPadding = b'\\xef'*pad0\n                    else:\n                        arrayPadding = b''\n                    # And now, let's pretend we put the item in\n                    soFar += arrayItemSize\n                    data = self.fields[fieldName].getData(soFar)\n                    data = arrayPadding + pack(arrayPackStr, self.getArrayMaximumSize(fieldName)) + data\n                else:\n                    pad = self.calculatePad(fieldTypeOrClass, soFar)\n                    if pad > 0:\n                        soFar += pad\n                        data += b'\\xcc'*pad\n\n                    data += self.pack(fieldName, fieldTypeOrClass, soFar)\n\n                # Any referent information to pack?\n                if isinstance(self.fields[fieldName], NDRCONSTRUCTEDTYPE):\n                    data += self.fields[fieldName].getDataReferents(soFar0 + len(data))\n                    data += self.fields[fieldName].getDataReferent(soFar0 + len(data))\n                soFar = soFar0 + len(data)\n\n            except Exception as e:\n                LOG.error(str(e))\n                LOG.error(\"Error packing field '%s | %s' in %s\" % (fieldName, fieldTypeOrClass, self.__class__))\n                raise\n\n        return data\n\n    def calcPackSize(self, fieldTypeOrClass, data):\n        if isinstance(fieldTypeOrClass, str) is False:\n            return len(data)\n\n        # array specifier\n        two = fieldTypeOrClass.split('*')\n        if len(two) == 2:\n            answer = 0\n            for each in data:\n                if self.isNDR(self.item):\n                    item = ':'\n                else:\n                    item = self.item\n                answer += self.calcPackSize(item, each)\n            return answer\n        else:\n            return NDR.calcPackSize(self, fieldTypeOrClass, data)\n\n    def getArrayMaximumSize(self, fieldName):\n        if self.fields[fieldName].fields['MaximumCount'] is not None and self.fields[fieldName].fields['MaximumCount'] > 0:\n            return self.fields[fieldName].fields['MaximumCount']\n        else:\n            return self.fields[fieldName].getArraySize()\n\n    def getArraySize(self, fieldName, data, offset=0):\n        if self._isNDR64:\n            arrayItemSize = 8\n            arrayUnPackStr = '<Q'\n        else:\n            arrayItemSize = 4\n            arrayUnPackStr = '<L'\n\n        pad = (arrayItemSize - (offset % arrayItemSize)) % arrayItemSize\n        offset += pad\n\n        if isinstance(self.fields[fieldName], NDRUniConformantArray):\n            # Array Size is at the very beginning\n            arraySize = unpack_from(arrayUnPackStr, data, offset)[0]\n        elif isinstance(self.fields[fieldName], NDRUniConformantVaryingArray):\n            # NDRUniConformantVaryingArray Array\n            # Unpack the Maximum Count\n            maximumCount = unpack_from(arrayUnPackStr, data, offset)[0]\n            # Let's store the Maximum Count for later use\n            self.fields[fieldName].fields['MaximumCount'] = maximumCount\n            # Unpack the Actual Count\n            arraySize = unpack_from(arrayUnPackStr, data, offset+arrayItemSize*2)[0]\n        else:\n            # NDRUniVaryingArray Array\n            arraySize = unpack_from(arrayUnPackStr, data, offset+arrayItemSize)[0]\n\n        return arraySize, arrayItemSize+pad\n\n    def fromStringReferents(self, data, offset=0):\n        offset0 = offset\n        for fieldName, fieldTypeOrClass in self.commonHdr+self.structure:\n            if isinstance(self.fields[fieldName], NDRCONSTRUCTEDTYPE):\n                offset += self.fields[fieldName].fromStringReferents(data, offset)\n                offset += self.fields[fieldName].fromStringReferent(data, offset)\n        return offset - offset0\n\n    def fromStringReferent(self, data, offset=0):\n        if hasattr(self, 'referent') is not True:\n            return 0\n\n        offset0 = offset\n\n        if 'ReferentID' in self.fields:\n            if self['ReferentID'] == 0:\n                # NULL Pointer, there's no referent for it\n                return 0\n\n        for fieldName, fieldTypeOrClass in self.referent:\n            try:\n                if isinstance(self.fields[fieldName], NDRUniConformantArray) or isinstance(self.fields[fieldName], NDRUniConformantVaryingArray):\n                    # Get the array size\n                    arraySize, advanceStream = self.getArraySize(fieldName, data, offset)\n                    offset += advanceStream\n\n                    # Let's tell the array how many items are available\n                    self.fields[fieldName].setArraySize(arraySize)\n                    size = self.fields[fieldName].fromString(data, offset)\n                else:\n                    # ToDo: Align only if not NDR\n                    offset += self.calculatePad(fieldTypeOrClass, offset)\n\n                    size = self.unpack(fieldName, fieldTypeOrClass, data, offset)\n\n                if isinstance(self.fields[fieldName], NDRCONSTRUCTEDTYPE):\n                    size += self.fields[fieldName].fromStringReferents(data, offset+size)\n                    size += self.fields[fieldName].fromStringReferent(data, offset+size)\n                offset += size\n            except Exception as e:\n                LOG.error(str(e))\n                LOG.error(\"Error unpacking field '%s | %s | %r'\" % (fieldName, fieldTypeOrClass, data[offset:offset+256]))\n                raise\n\n        return offset-offset0\n\n    def calcUnPackSize(self, fieldTypeOrClass, data, offset=0):\n        if isinstance(fieldTypeOrClass, str) is False:\n            return len(data) - offset\n\n        two = fieldTypeOrClass.split('*')\n        if len(two) == 2:\n            return len(data) - offset\n        else:\n            return NDR.calcUnPackSize(self, fieldTypeOrClass, data, offset)",
  "class NDRArray(NDRCONSTRUCTEDTYPE):\n    def dump(self, msg = None, indent = 0):\n        if msg is None:\n            msg = self.__class__.__name__\n        ind = ' '*indent\n        if msg != '':\n            print(msg, end=' ')\n\n        if isinstance(self['Data'], list):\n            print(\"\\n%s[\" % ind)\n            ind += ' '*4\n            for num,j in enumerate(self.fields['Data']):\n               if isinstance(j, NDR):\n                   j.dump('%s' % ind, indent = indent + 4),\n                   print(\",\") \n               else:\n                   print(\"%s %r,\" % (ind,j))\n            print(\"%s]\" % ind[:-4], end=' ')\n        else:\n            print(\" %r\" % self['Data'], end=' ')\n\n    def setArraySize(self, size):\n        self.arraySize = size\n\n    def getArraySize(self):\n        return self.arraySize\n\n    def changeTransferSyntax(self, newSyntax): \n        # Here we gotta go over each item in the array and change the TS \n        # Only if the item type is NDR\n        if hasattr(self, 'item') and self.item is not None:\n            if self.isNDR(self.item):\n                for item in self.fields['Data']:\n                    item.changeTransferSyntax(newSyntax)\n        return NDRCONSTRUCTEDTYPE.changeTransferSyntax(self, newSyntax)\n\n    def getAlignment(self):\n        # Array alignment is the largest alignment of the array element type and \n        # the size information type, if any.\n        align = 0\n        # And now the item\n        if hasattr(self, \"item\") and self.item is not None:\n            if self.isNDR(self.item):\n                tmpAlign = self.item().getAlignment()\n            else:\n                tmpAlign = self.calcPackSize(self.item, b'')\n            if tmpAlign > align:\n                align = tmpAlign\n        return align\n\n    def getData(self, soFar = 0):\n        data = b''\n        soFar0 = soFar\n        for fieldName, fieldTypeOrClass in self.structure:\n            try:\n                if self.isNDR(fieldTypeOrClass) is False:\n                    # If the item is not NDR (e.g. ('MaximumCount', '<L=len(Data)'))\n                    # we have to align it\n                    pad = self.calculatePad(fieldTypeOrClass, soFar)\n                    if pad > 0:\n                        soFar += pad\n                        data += b'\\xca'*pad\n\n                res = self.pack(fieldName, fieldTypeOrClass, soFar)\n                data += res\n                soFar = soFar0 + len(data)\n            except Exception as e:\n                LOG.error(str(e))\n                LOG.error(\"Error packing field '%s | %s' in %s\" % (fieldName, fieldTypeOrClass, self.__class__))\n                raise\n\n        return data\n\n    def pack(self, fieldName, fieldTypeOrClass, soFar = 0):\n        # array specifier\n        two = fieldTypeOrClass.split('*')\n        if len(two) == 2:\n            answer = b''\n            if self.isNDR(self.item):\n                item = ':'\n                dataClass = self.item\n                self.fields['_tmpItem'] = dataClass(isNDR64=self._isNDR64)\n            else:\n                item = self.item\n                dataClass = None\n                self.fields['_tmpItem'] = item\n\n            for each in (self.fields[fieldName]):\n                pad = self.calculatePad(self.item, len(answer)+soFar)\n                if pad > 0:\n                    answer += b'\\xdd' * pad\n                if dataClass is None:\n                    if item == 'c' and PY3 and isinstance(each, int):\n                        # Special case when dealing with PY3, here we have an integer we need to convert\n                        each = bytes([each])\n                    answer += pack(item, each)\n                else:\n                    answer += each.getData(len(answer)+soFar)\n\n            if dataClass is not None:\n                for each in self.fields[fieldName]:\n                    if isinstance(each, NDRCONSTRUCTEDTYPE):\n                        answer += each.getDataReferents(len(answer)+soFar)\n                        answer += each.getDataReferent(len(answer)+soFar)\n\n            del(self.fields['_tmpItem'])\n            if isinstance(self, NDRUniConformantArray) or isinstance(self, NDRUniConformantVaryingArray):\n                # First field points to a field with the amount of items\n                self.setArraySize(len(self.fields[fieldName]))\n            else:\n                self.fields[two[1]] = len(self.fields[fieldName])\n\n            return answer\n        else:\n            return NDRCONSTRUCTEDTYPE.pack(self, fieldName, fieldTypeOrClass, soFar)\n\n    def fromString(self, data, offset=0):\n        offset0 = offset\n        for fieldName, fieldTypeOrClass in self.commonHdr+self.structure:\n            try:\n                if self.isNDR(fieldTypeOrClass) is False:\n                    # If the item is not NDR (e.g. ('MaximumCount', '<L=len(Data)'))\n                    # we have to align it\n                    offset += self.calculatePad(fieldTypeOrClass, offset)\n\n                size = self.unpack(fieldName, fieldTypeOrClass, data, offset)\n                offset += size\n            except Exception as e:\n                LOG.error(str(e))\n                LOG.error(\"Error unpacking field '%s | %s | %r'\" % (fieldName, fieldTypeOrClass, data[offset:offset+256]))\n                raise\n        return offset - offset0\n\n    def unpack(self, fieldName, fieldTypeOrClass, data, offset=0):\n        # array specifier\n        two = fieldTypeOrClass.split('*')\n        answer = []\n        soFarItems = 0\n        offset0 = offset\n        if len(two) == 2:\n            if isinstance(self, NDRUniConformantArray):\n                # First field points to a field with the amount of items\n                numItems = self.getArraySize()\n            elif isinstance(self, NDRUniConformantVaryingArray):\n                # In this case we have the MaximumCount but it could be different from the ActualCount.\n                # Let's make the unpack figure this out.\n                #self.fields['MaximumCount'] = self.getArraySize()\n                numItems = self[two[1]]\n            else:\n                numItems = self[two[1]]\n\n            # The item type is determined by self.item\n            if self.isNDR(self.item):\n                item = ':'\n                dataClassOrCode = self.item\n                self.fields['_tmpItem'] = dataClassOrCode(isNDR64=self._isNDR64)\n            else:\n                item = self.item\n                dataClassOrCode = None\n                self.fields['_tmpItem'] = item\n\n            nsofar = 0\n            while numItems and soFarItems < len(data) - offset:\n                pad = self.calculatePad(self.item, soFarItems+offset)\n                if pad > 0:\n                    soFarItems +=pad\n                if dataClassOrCode is None:\n                    nsofar = soFarItems + calcsize(item)\n                    answer.append(unpack_from(item, data, offset+soFarItems)[0])\n                else:\n                    itemn = dataClassOrCode(isNDR64=self._isNDR64)\n                    size = itemn.fromString(data, offset+soFarItems)\n                    answer.append(itemn)\n                    nsofar += size + pad\n                numItems -= 1\n                soFarItems = nsofar\n\n            if dataClassOrCode is not None and isinstance(dataClassOrCode(), NDRCONSTRUCTEDTYPE):\n                # We gotta go over again, asking for the referents\n                answer2 = []\n                for itemn in answer:\n                    size = itemn.fromStringReferents(data, soFarItems+offset)\n                    soFarItems += size\n                    size = itemn.fromStringReferent(data, soFarItems+offset)\n                    soFarItems += size\n                    answer2.append(itemn)\n                answer = answer2\n                del answer2\n\n            del(self.fields['_tmpItem'])\n\n            self.fields[fieldName] = answer\n            return soFarItems + offset - offset0\n        else:\n            return NDRCONSTRUCTEDTYPE.unpack(self, fieldName, fieldTypeOrClass, data, offset)",
  "class NDRUniFixedArray(NDRArray):\n    structure = (\n        ('Data',':'),\n    )",
  "class NDRUniConformantArray(NDRArray):\n    item = 'c'\n    structure = (\n        #('MaximumCount', '<L=len(Data)'),\n        ('Data', '*MaximumCount'),\n    )\n\n    structure64 = (\n        #('MaximumCount', '<Q=len(Data)'),\n        ('Data', '*MaximumCount'),\n    )\n\n    def __init__(self, data = None, isNDR64 = False):\n        NDRArray.__init__(self, data, isNDR64)\n        # Let's store the hidden MaximumCount field\n        self.fields['MaximumCount'] = 0\n\n    def __setitem__(self, key, value):\n        self.fields['MaximumCount'] = None\n        return NDRArray.__setitem__(self, key, value)",
  "class NDRUniVaryingArray(NDRArray):\n    item = 'c'\n    structure = (\n        ('Offset','<L=0'),\n        ('ActualCount','<L=len(Data)'),\n        ('Data','*ActualCount'),\n    )\n    structure64 = (\n        ('Offset','<Q=0'),\n        ('ActualCount','<Q=len(Data)'),\n        ('Data','*ActualCount'),\n    )\n\n    def __setitem__(self, key, value):\n        self.fields['ActualCount'] = None\n        return NDRArray.__setitem__(self, key, value)",
  "class NDRUniConformantVaryingArray(NDRArray):\n    item = 'c'\n    commonHdr = (\n        #('MaximumCount', '<L=len(Data)'),\n        ('Offset','<L=0'),\n        ('ActualCount','<L=len(Data)'),\n    )\n    commonHdr64 = (\n        #('MaximumCount', '<Q=len(Data)'),\n        ('Offset','<Q=0'),\n        ('ActualCount','<Q=len(Data)'),\n    )\n\n    structure = (\n        ('Data','*ActualCount'),\n    )\n\n    def __init__(self, data = None, isNDR64 = False):\n        NDRArray.__init__(self, data, isNDR64)\n        # Let's store the hidden MaximumCount field\n        self.fields['MaximumCount'] = 0\n\n    def __setitem__(self, key, value):\n        self.fields['MaximumCount'] = None\n        self.fields['ActualCount'] = None\n        return NDRArray.__setitem__(self, key, value)\n\n    def getData(self, soFar = 0):\n        data = b''\n        soFar0 = soFar\n        for fieldName, fieldTypeOrClass in self.commonHdr+self.structure:\n            try:\n                pad = self.calculatePad(fieldTypeOrClass, soFar)\n                if pad > 0:\n                    soFar += pad\n                    data += b'\\xcb'*pad\n\n                res = self.pack(fieldName, fieldTypeOrClass, soFar)\n                data += res\n                soFar = soFar0 + len(data)\n            except Exception as e:\n                LOG.error(str(e))\n                LOG.error(\"Error packing field '%s | %s' in %s\" % (fieldName, fieldTypeOrClass, self.__class__))\n                raise\n\n        return data",
  "class NDRVaryingString(NDRUniVaryingArray):\n    def getData(self, soFar = 0):\n        # The last element of a string is a terminator of the same size as the other elements. \n        # If the string element size is one octet, the terminator is a NULL character. \n        # The terminator for a string of multi-byte characters is the array element zero (0).\n        if self[\"Data\"][-1:] != b'\\x00':\n            if PY3 and isinstance(self[\"Data\"],list) is False:\n                self[\"Data\"] = self[\"Data\"] + b'\\x00'\n            else:\n                self[\"Data\"] = b''.join(self[\"Data\"]) + b'\\x00'\n        return NDRUniVaryingArray.getData(self, soFar)\n\n    def fromString(self, data, offset = 0):\n        ret = NDRUniVaryingArray.fromString(self, data, offset)\n        # Let's take out the last item\n        self[\"Data\"] = self[\"Data\"][:-1] \n        return ret",
  "class NDRConformantVaryingString(NDRUniConformantVaryingArray):\n    pass",
  "class NDRSTRUCT(NDRCONSTRUCTEDTYPE):\n    def getData(self, soFar = 0):\n        data = b''\n        arrayPadding = b''\n        soFar0 = soFar\n        # 14.3.7.1 Structures Containing a Conformant Array\n        # A structure can contain a conformant array only as its last member.\n        # In the NDR representation of a structure that contains a conformant array, \n        # the unsigned long integers that give maximum element counts for dimensions of the array \n        # are moved to the beginning of the structure, and the array elements appear in place at \n        # the end of the structure.\n        # 14.3.7.2 Structures Containing a Conformant and Varying Array\n        # A structure can contain a conformant and varying array only as its last member.\n        # In the NDR representation of a structure that contains a conformant and varying array, \n        # the maximum counts for dimensions of the array are moved to the beginning of the structure, \n        # but the offsets and actual counts remain in place at the end of the structure, \n        # immediately preceding the array elements\n        lastItem = (self.commonHdr+self.structure)[-1][0]\n        if isinstance(self.fields[lastItem], NDRUniConformantArray) or isinstance(self.fields[lastItem], NDRUniConformantVaryingArray):\n            # So we have an array, first item in the structure must be the array size, although we\n            # will need to build it later.\n            if self._isNDR64:\n                arrayItemSize = 8\n                arrayPackStr = '<Q'\n            else:\n                arrayItemSize = 4\n                arrayPackStr = '<L'\n\n            # The size information is itself aligned according to the alignment rules for \n            # primitive data types. (See Section 14.2.2 on page 620.) The data of the constructed \n            # type is then aligned according to the alignment rules for the constructed type. \n            # In other words, the size information precedes the structure and is aligned \n            # independently of the structure alignment.\n            # We need to check whether we need padding or not\n            pad0 = (arrayItemSize - (soFar % arrayItemSize)) % arrayItemSize \n            if pad0 > 0:\n                soFar += pad0\n                arrayPadding = b'\\xee'*pad0\n            else:\n                arrayPadding = b''\n            # And now, let's pretend we put the item in\n            soFar += arrayItemSize\n        else:\n            arrayItemSize = 0\n\n        # Now we need to align the structure \n        # The alignment of a structure in the octet stream is the largest of the alignments of the fields it\n        # contains. These fields may also be constructed types. The same alignment rules apply \n        # recursively to nested constructed types.\n        alignment = self.getAlignment()\n\n        if alignment > 0:\n            pad = (alignment - (soFar % alignment)) % alignment\n            if pad > 0:\n                soFar += pad\n                data += b'\\xAB'*pad\n\n        for fieldName, fieldTypeOrClass in self.commonHdr+self.structure:\n            try:\n                if isinstance(self.fields[fieldName], NDRUniConformantArray) or isinstance(self.fields[fieldName], NDRUniConformantVaryingArray):\n                    res = self.fields[fieldName].getData(soFar)\n                    if isinstance(self, NDRPOINTER):\n                        pointerData = data[:arrayItemSize]\n                        data = data[arrayItemSize:]\n                        data = pointerData + arrayPadding + pack(arrayPackStr ,self.getArrayMaximumSize(fieldName)) + data\n                    else:\n                        data = arrayPadding + pack(arrayPackStr, self.getArrayMaximumSize(fieldName)) + data\n                    arrayPadding = b''\n                    arrayItemSize = 0\n                else:\n                    res = self.pack(fieldName, fieldTypeOrClass, soFar)\n                data += res\n                soFar = soFar0 + len(data) + len(arrayPadding) + arrayItemSize\n            except Exception as e:\n                LOG.error(str(e))\n                LOG.error(\"Error packing field '%s | %s' in %s\" % (fieldName, fieldTypeOrClass, self.__class__))\n                raise\n\n        # 2.2.5.3.4.1 Structure with Trailing Gap\n        # NDR64 represents a structure as an ordered sequence of representations of the\n        # structure members. The trailing gap from the last nonconformant and nonvarying\n        # field to the alignment of the structure MUST be represented as a trailing pad.\n        # The size of the structure MUST be a multiple of its alignment.\n        # See the following figure.\n\n        # 4.8 Example of Structure with Trailing Gap in NDR64\n        # This example shows a structure with a trailing gap in NDR64.\n        #     typedef struct _StructWithPad\n        #     {\n        #         long l;\n        #         short s;\n        #     } StructWithPad;\n        # The size of the structure in the octet stream MUST contain a 2-byte trailing\n        # gap to make its size 8, a multiple of the structure's alignment, 4.\n#        if self._isNDR64 is True:\n#            # ToDo add trailing gap here\n#            if alignment > 0:\n#                pad = (alignment - (soFar % alignment)) % alignment\n#                if pad > 0:\n#                    soFar += pad\n#                    data += '\\xcd'*pad\n#            print self.__class__ , alignment, pad, hex(soFar)\n        return data\n\n    def fromString(self, data, offset = 0 ):\n        offset0 = offset\n        # 14.3.7.1 Structures Containing a Conformant Array\n        # A structure can contain a conformant array only as its last member.\n        # In the NDR representation of a structure that contains a conformant array, \n        # the unsigned long integers that give maximum element counts for dimensions of the array \n        # are moved to the beginning of the structure, and the array elements appear in place at \n        # the end of the structure.\n        # 14.3.7.2 Structures Containing a Conformant and Varying Array\n        # A structure can contain a conformant and varying array only as its last member.\n        # In the NDR representation of a structure that contains a conformant and varying array, \n        # the maximum counts for dimensions of the array are moved to the beginning of the structure, \n        # but the offsets and actual counts remain in place at the end of the structure, \n        # immediately preceding the array elements\n        lastItem = (self.commonHdr+self.structure)[-1][0]\n\n        # If it's a pointer, let's parse it here because\n        # we are going to parse the next MaximumCount field(s) manually\n        # when it's a Conformant or Conformant and Varying array\n        if isinstance(self, NDRPOINTER):\n            structureFields = self.structure\n\n            alignment = self.getAlignment()\n            if alignment > 0:\n                offset += (alignment - (offset % alignment)) % alignment\n\n            for fieldName, fieldTypeOrClass in self.commonHdr:\n                offset += self.unpack(fieldName, fieldTypeOrClass, data, offset)\n        else:\n            structureFields = self.commonHdr+self.structure\n\n        if isinstance(self.fields[lastItem], NDRUniConformantArray) or isinstance(self.fields[lastItem], NDRUniConformantVaryingArray):\n            # So we have an array, first item in the structure must be the array size, although we\n            # will need to build it later.\n            if self._isNDR64:\n                arrayItemSize = 8\n                arrayUnPackStr = '<Q'\n            else:\n                arrayItemSize = 4\n                arrayUnPackStr = '<L'\n\n            # The size information is itself aligned according to the alignment rules for\n            # primitive data types. (See Section 14.2.2 on page 620.) The data of the constructed \n            # type is then aligned according to the alignment rules for the constructed type. \n            # In other words, the size information precedes the structure and is aligned \n            # independently of the structure alignment.\n            # We need to check whether we need padding or not\n            offset += (arrayItemSize - (offset % arrayItemSize)) % arrayItemSize\n\n            # And let's extract the array size for later use\n            if isinstance(self.fields[lastItem], NDRUniConformantArray):\n                # NDRUniConformantArray\n                arraySize = unpack_from(arrayUnPackStr, data, offset)[0]\n                self.fields[lastItem].setArraySize(arraySize)\n            else:\n                # NDRUniConformantVaryingArray\n                maximumCount = unpack_from(arrayUnPackStr, data, offset)[0]\n                self.fields[lastItem].fields['MaximumCount'] = maximumCount\n\n            offset += arrayItemSize\n\n        # Now we need to align the structure\n        # The alignment of a structure in the octet stream is the largest of the alignments of the fields it\n        # contains. These fields may also be constructed types. The same alignment rules apply \n        # recursively to nested constructed types.\n        alignment = self.getAlignment()\n        if alignment > 0:\n            offset += (alignment - (offset % alignment)) % alignment\n\n        for fieldName, fieldTypeOrClass in structureFields:\n            try:\n                offset += self.unpack(fieldName, fieldTypeOrClass, data, offset)\n            except Exception as e:\n                LOG.error(str(e))\n                LOG.error(\"Error unpacking field '%s | %s | %r'\" % (fieldName, fieldTypeOrClass, data[offset:offset+256]))\n                raise\n\n        return offset - offset0\n\n    def getAlignment(self):\n        # Alignment of Constructed Types\n        #\n        # NDR enforces NDR alignment of structured data. As with primitive data types, an alignment, n, is determined\n        # for the structure. Where necessary, an alignment gap of octets of unspecified value precedes the data in\n        # the NDR octet stream. This gap is the smallest size sufficient to align the first field of the structure\n        # on an NDR octet stream index of n.\n\n        # The rules for calculating the alignment of constructed types are as follows:\n\n        # 1) If a conformant structure-that is, a conformant or conformant varying array, or a structure containing\n        # a conformant or conformant varying array-is embedded in the constructed type, and is the outermost\n        # structure-that is, is not contained in another structure-then the size information from the contained\n        # conformant structure is positioned so that it precedes both the containing constructed type and any\n        # alignment gap for the constructed type. (See Section 14.3.7 for information about structures containing\n        # arrays.) The size information is itself aligned according to the alignment rules for primitive data\n        # types. (See Section 14.2.2 on page 620.) The data of the constructed type is then aligned according to\n        # the alignment rules for the constructed type. In other words, the size information precedes the structure\n        # and is aligned independently of the structure alignment.\n\n        # 2) The alignment of a structure in the octet stream is the largest of the alignments of the fields it\n        # contains. These fields may also be constructed types. The same alignment rules apply recursively to nested\n        # constructed types.\n\n        align = 0\n        for fieldName, fieldTypeOrClass in self.commonHdr+self.structure+self.referent:\n            if isinstance(self.fields[fieldName], NDR):\n                tmpAlign = self.fields[fieldName].getAlignment()\n            else:\n                tmpAlign = self.calcPackSize(fieldTypeOrClass, b'')\n            if tmpAlign > align:\n                align = tmpAlign\n        return align",
  "class NDRUNION(NDRCONSTRUCTEDTYPE):\n    commonHdr = (\n        ('tag', NDRUSHORT),\n    )\n    commonHdr64 = (\n        ('tag', NDRULONG),\n    )\n   \n    union = {\n        # For example\n        #1: ('pStatusChangeParam1', PSERVICE_NOTIFY_STATUS_CHANGE_PARAMS_1),\n        #2: ('pStatusChangeParams', PSERVICE_NOTIFY_STATUS_CHANGE_PARAMS_2),\n    }\n    def __init__(self, data = None, isNDR64=False, topLevel = False):\n        #ret = NDR.__init__(self,None, isNDR64=isNDR64)\n        self.topLevel = topLevel\n        self._isNDR64 = isNDR64\n        self.fields = {}\n\n        if isNDR64 is True:\n            if self.commonHdr64 != ():\n                self.commonHdr = self.commonHdr64\n            if self.structure64 != ():\n                self.structure = self.structure64\n            if hasattr(self, 'align64'):\n                self.align = self.align64\n\n        for fieldName, fieldTypeOrClass in self.commonHdr+self.structure+self.referent:\n            if self.isNDR(fieldTypeOrClass):\n               if self.isPointer(fieldTypeOrClass):\n                   self.fields[fieldName] = fieldTypeOrClass(isNDR64 = self._isNDR64, topLevel = topLevel)\n               elif self.isUnion(fieldTypeOrClass):\n                   self.fields[fieldName] = fieldTypeOrClass(isNDR64 = self._isNDR64, topLevel = topLevel)\n               else:\n                   self.fields[fieldName] = fieldTypeOrClass(isNDR64 = self._isNDR64)\n            elif fieldTypeOrClass == ':':\n               self.fields[fieldName] = None\n            elif len(fieldTypeOrClass.split('=')) == 2: \n               try:\n                   self.fields[fieldName] = eval(fieldTypeOrClass.split('=')[1])\n               except:\n                   self.fields[fieldName] = None\n            else:\n               self.fields[fieldName] = 0\n\n        if data is not None:\n            self.fromString(data)\n\n    def __setitem__(self, key, value):\n        if key == 'tag':\n            # We're writing the tag, we now should set the right item for the structure\n            self.structure = ()\n            if value in self.union:\n                self.structure = (self.union[value]),\n                # Init again the structure\n                self.__init__(None, isNDR64=self._isNDR64, topLevel = self.topLevel)\n                self.fields['tag']['Data'] = value\n            else:\n                # Let's see if we have a default value\n                if 'default' in self.union:\n                    if self.union['default'] is None:\n                        self.structure = ()\n                    else:\n                        self.structure = (self.union['default']),\n                        # Init again the structure\n                        self.__init__(None, isNDR64=self._isNDR64, topLevel = self.topLevel)\n                    self.fields['tag']['Data'] = 0xffff\n                else:\n                    raise Exception(\"Unknown tag %d for union!\" % value)\n        else:\n            return NDRCONSTRUCTEDTYPE.__setitem__(self,key,value)\n\n    def getData(self, soFar = 0):\n        data = b''\n        soFar0 = soFar\n\n        # Let's align ourselves\n        alignment = self.getAlignment()\n        if alignment > 0:\n            pad = (alignment - (soFar % alignment)) % alignment\n        else:\n            pad = 0\n        if pad > 0:\n            soFar += pad\n            data += b'\\xbc'*pad\n\n        for fieldName, fieldTypeOrClass in self.commonHdr:\n            try:\n                pad = self.calculatePad(fieldTypeOrClass, soFar)\n                if pad > 0:\n                    soFar += pad\n                    data += b'\\xbb'*pad\n\n                res = self.pack(fieldName, fieldTypeOrClass, soFar)\n                data += res\n                soFar = soFar0 + len(data)\n            except Exception as e:\n                LOG.error(str(e))\n                LOG.error(\"Error packing field '%s | %s' in %s\" % (fieldName, fieldTypeOrClass, self.__class__))\n                raise\n\n        # WARNING\n        # Now we need to align what's coming next.\n        # This doesn't come from the documentation but from seeing the packets in the wire\n        # for some reason, even if the next field is a SHORT, it should be aligned to\n        # a DWORD, or HYPER if NDR64. \n        if self._isNDR64:\n            align = 8\n        else:\n            if hasattr(self, 'notAlign'):\n                align = 1\n            else:\n                align = 4\n\n        pad = (align - (soFar % align)) % align\n        if pad > 0:\n            data += b'\\xbd'*pad\n            soFar += pad\n\n        if self.structure == ():\n            return data\n\n        for fieldName, fieldTypeOrClass in self.structure:\n            try:\n                pad = self.calculatePad(fieldTypeOrClass, soFar)\n                if pad > 0:\n                    soFar += pad\n                    data += b'\\xbe'*pad\n\n                res = self.pack(fieldName, fieldTypeOrClass, soFar)\n                data += res\n                soFar = soFar0 + len(data)\n            except Exception as e:\n                LOG.error(str(e))\n                LOG.error(\"Error packing field '%s | %s' in %s\" % (fieldName, fieldTypeOrClass, self.__class__))\n                raise\n\n        return data\n\n    def fromString(self, data, offset=0):\n        offset0 = offset\n        # Let's align ourselves\n        alignment = self.getAlignment()\n        if alignment > 0:\n            pad = (alignment - (offset % alignment)) % alignment\n        else:\n            pad = 0\n        if pad > 0:\n            offset += pad\n\n        if len(data)-offset > 4:\n            # First off, let's see what the tag is:\n            # We need to know the tag type and unpack it\n            tagtype = self.commonHdr[0][1].structure[0][1].split('=')[0]\n            tag = unpack_from(tagtype, data, offset)[0]\n            if tag in self.union:\n                self.structure = (self.union[tag]),\n                self.__init__(None, isNDR64=self._isNDR64, topLevel = self.topLevel)\n            else:\n                # Let's see if we have a default value\n                if 'default' in self.union:\n                    if self.union['default'] is None:\n                        self.structure = ()\n                    else:\n                        self.structure = (self.union['default']),\n                        # Init again the structure\n                        self.__init__(None, isNDR64=self._isNDR64, topLevel = self.topLevel)\n                    self.fields['tag']['Data'] = 0xffff\n                else:\n                    raise Exception(\"Unknown tag %d for union!\" % tag)\n\n        for fieldName, fieldTypeOrClass in self.commonHdr:\n            try:\n                offset += self.calculatePad(fieldTypeOrClass, offset)\n                offset += self.unpack(fieldName, fieldTypeOrClass, data, offset)\n            except Exception as e:\n                LOG.error(str(e))\n                LOG.error(\"Error unpacking field '%s | %s | %r'\" % (fieldName, fieldTypeOrClass, data[offset:offset+256]))\n                raise\n\n        # WARNING\n        # Now we need to align what's coming next.\n        # This doesn't come from the documentation but from seeing the packets in the wire\n        # for some reason, even if the next field is a SHORT, it should be aligned to\n        # a DWORD, or HYPER if NDR64. \n        if self._isNDR64:\n            align = 8\n        else:\n            if hasattr(self, 'notAlign'):\n                align = 1\n            else:\n                align = 4\n\n        offset += (align - (offset % align)) % align\n\n        if self.structure == ():\n            return offset-offset0\n\n        for fieldName, fieldTypeOrClass in self.structure:\n            try:\n                offset += self.calculatePad(fieldTypeOrClass, offset)\n                offset += self.unpack(fieldName, fieldTypeOrClass, data, offset)\n            except Exception as e:\n                LOG.error(str(e))\n                LOG.error(\"Error unpacking field '%s | %s | %r'\" % (fieldName, fieldTypeOrClass, data[offset:offset+256]))\n                raise\n\n        return offset - offset0\n\n    def getAlignment(self):\n        # Union alignment is the largest alignment of the union discriminator \n        # and all of the union arms.\n        # WRONG, I'm calculating it just with the tag, if I do it with the \n        # arms I get bad stub data. Something wrong I'm doing or the standard\n        # is wrong (most probably it's me :s )\n        align = 0\n        if self._isNDR64:\n            fields =  self.commonHdr+self.structure\n        else: \n            fields =  self.commonHdr\n        for fieldName, fieldTypeOrClass in fields:\n            if isinstance(self.fields[fieldName], NDR):\n                tmpAlign = self.fields[fieldName].getAlignment()\n            else:\n                tmpAlign = self.calcPackSize(fieldTypeOrClass, b'')\n            if tmpAlign > align:\n                align = tmpAlign\n\n        if self._isNDR64:\n            for fieldName, fieldTypeOrClass in self.union.values():\n                tmpAlign = fieldTypeOrClass(isNDR64 = self._isNDR64).getAlignment()\n                if tmpAlign > align:\n                    align = tmpAlign\n        return align",
  "class NDRPOINTERNULL(NDR):\n    align = 4\n    align64 = 8\n    structure = (\n        ('Data', '<L=0'),\n    )\n    structure64 = (\n        ('Data', '<Q=0'),\n    )\n\n    def dump(self, msg = None, indent = 0):\n        if msg is None:\n            msg = self.__class__.__name__\n        if msg != '':\n            print(\"%s\" % msg, end=' ')\n        # Here we just print NULL\n        print(\" NULL\", end=' ')",
  "class NDRPOINTER(NDRSTRUCT):\n    align = 4\n    align64 = 8\n    commonHdr = (\n        ('ReferentID','<L=0xff'),\n    )\n    commonHdr64 = (\n        ('ReferentID','<Q=0xff'),\n    )\n\n    referent = (\n        # This is the representation of the Referent\n        ('Data',':'),\n    )\n    def __init__(self, data = None, isNDR64=False, topLevel = False):\n        NDRSTRUCT.__init__(self,None, isNDR64=isNDR64)\n        # If we are being called from a NDRCALL, it's a TopLevelPointer,\n        # if not, it's a embeeded pointer.\n        # It is *very* important, for every subclass of NDRPointer\n        # you have to declare the referent in the referent variable\n        # Not in the structure one!\n        if topLevel is True:\n            self.structure = self.referent\n            self.referent = ()\n       \n        if data is None:\n            self.fields['ReferentID'] = random.randint(1,65535)\n        else:\n           self.fromString(data)\n\n    def __setitem__(self, key, value):\n        if (key in self.fields) is False:\n            # Key not found.. let's send it to the referent to handle, maybe it's there\n            return self.fields['Data'].__setitem__(key,value)\n        else:\n            return NDRSTRUCT.__setitem__(self,key,value)\n\n    def __getitem__(self, key):\n        if key in self.fields:\n            if isinstance(self.fields[key], NDR):\n                if 'Data' in self.fields[key].fields:\n                    return self.fields[key]['Data']\n            return self.fields[key]\n        else:\n            # Key not found, let's send it to the referent, maybe it's there\n            return self.fields['Data'].__getitem__(key)\n\n    def getData(self, soFar = 0):\n        # First of all we need to align ourselves\n        data = b''\n        pad = self.calculatePad(self.commonHdr[0][1], soFar)\n        if pad > 0:\n            soFar += pad\n            data = b'\\xaa'*pad\n        # If we have a ReferentID == 0, means there's no data\n        if self.fields['ReferentID'] == 0:\n            if len(self.referent) > 0:\n                self['Data'] = b''\n            else:\n                if self._isNDR64 is True:\n                    return data+b'\\x00'*8\n                else:\n                    return data+b'\\x00'*4\n\n        return data + NDRSTRUCT.getData(self, soFar)\n\n    def fromString(self, data, offset=0):\n        # First of all we need to align ourselves\n        pad = self.calculatePad(self.commonHdr[0][1], offset)\n        offset += pad\n\n        # Do we have a Referent ID == 0?\n        if self._isNDR64 is True:\n            unpackStr = '<Q'\n        else:\n            unpackStr = '<L'\n\n        if unpack_from(unpackStr, data, offset)[0] == 0:\n            # Let's save the value\n            self['ReferentID'] = 0\n            self.fields['Data'] = b''\n            if self._isNDR64 is True:\n                return pad + 8\n            else:\n                return pad + 4\n        else:\n            retVal = NDRSTRUCT.fromString(self, data, offset)\n            return retVal + pad\n\n    def dump(self, msg = None, indent = 0):\n        if msg is None:\n            msg = self.__class__.__name__\n        if msg != '':\n            print(\"%s\" % msg, end=' ')\n        # Here we just print the referent\n        if isinstance(self.fields['Data'], NDR):\n            self.fields['Data'].dump('', indent = indent)\n        else:\n            if self['ReferentID'] == 0:\n                print(\" NULL\", end=' ')\n            else:\n                print(\" %r\" % (self['Data']), end=' ')\n\n    def getAlignment(self):\n        if self._isNDR64 is True:\n            return 8\n        else:\n            return 4",
  "class PNDRUniConformantVaryingArray(NDRPOINTER):\n    referent = (\n        ('Data', NDRUniConformantVaryingArray),\n    )",
  "class PNDRUniConformantArray(NDRPOINTER):\n    referent = (\n        ('Data', NDRUniConformantArray),\n    )\n    def __init__(self, data = None, isNDR64 = False, topLevel = False):\n        NDRPOINTER.__init__(self,data,isNDR64,topLevel)",
  "class NDRCALL(NDRCONSTRUCTEDTYPE):\n    # This represents a group of NDR instances that conforms an NDR Call.\n    # The only different between a regular NDR instance is a NDR call must\n    # represent the referents when building the final octet stream\n    referent       = ()\n    commonHdr      = ()\n    commonHdr64    = ()\n    structure      = ()\n    structure64    = ()\n    align          = 4\n    def __init__(self, data = None, isNDR64 = False):\n        self._isNDR64 = isNDR64\n        self.fields = {}\n\n        if isNDR64 is True:\n            if self.commonHdr64 != ():\n                self.commonHdr = self.commonHdr64\n            if self.structure64 != ():\n                self.structure = self.structure64\n            if hasattr(self, 'align64'):\n                self.align = self.align64\n\n        for fieldName, fieldTypeOrClass in self.commonHdr+self.structure+self.referent:\n            if self.isNDR(fieldTypeOrClass):\n               if self.isPointer(fieldTypeOrClass):\n                   self.fields[fieldName] = fieldTypeOrClass(isNDR64 = self._isNDR64, topLevel = True)\n               elif self.isUnion(fieldTypeOrClass):\n                   self.fields[fieldName] = fieldTypeOrClass(isNDR64 = self._isNDR64, topLevel = True)\n               else:\n                   self.fields[fieldName] = fieldTypeOrClass(isNDR64 = self._isNDR64)\n            elif fieldTypeOrClass == ':':\n               self.fields[fieldName] = None\n            elif len(fieldTypeOrClass.split('=')) == 2:\n               try:\n                   self.fields[fieldName] = eval(fieldTypeOrClass.split('=')[1])\n               except:\n                   self.fields[fieldName] = None\n            else:\n               self.fields[fieldName] = 0\n\n        if data is not None:\n            self.fromString(data)\n\n    def dump(self, msg = None, indent = 0):\n        NDRCONSTRUCTEDTYPE.dump(self, msg, indent)\n        print('\\n\\n')\n\n    def getData(self, soFar = 0):\n        data = b''\n        soFar0 = soFar\n        for fieldName, fieldTypeOrClass in self.commonHdr+self.structure:\n            try:\n                pad = self.calculatePad(fieldTypeOrClass, soFar)\n                if pad > 0:\n                    soFar += pad\n                    data += b'\\xab'*pad\n\n                # Are we dealing with an array?\n                if isinstance(self.fields[fieldName], NDRUniConformantArray) or isinstance(self.fields[fieldName],\n                              NDRUniConformantVaryingArray):\n                    # Align size item\n                    if self._isNDR64:\n                        pad = (8 - (soFar % 8)) % 8\n                    else:\n                        pad = (4 - (soFar % 4)) % 4\n                    # Pack the item\n                    res = self.pack(fieldName, fieldTypeOrClass, soFar+pad)\n                    # Yes, get the array size\n                    arraySize = self.getArrayMaximumSize(fieldName)\n                    if self._isNDR64:\n                        pad = (8 - (soFar % 8)) % 8\n                        data += b'\\xce'*pad + pack('<Q', arraySize) + res\n                    else:\n                        pad = (4 - (soFar % 4)) % 4\n                        data += b'\\xce'*pad + pack('<L', arraySize) + res\n                else:\n                    data += self.pack(fieldName, fieldTypeOrClass, soFar)\n\n                soFar = soFar0 + len(data)\n                # Any referent information to pack?\n                # I'm still not sure whether this should go after processing\n                # all the fields at the call level.\n                # Guess we'll figure it out testing.\n                if isinstance(self.fields[fieldName], NDRCONSTRUCTEDTYPE):\n                    data += self.fields[fieldName].getDataReferents(soFar)\n                    soFar = soFar0 + len(data)\n                    data += self.fields[fieldName].getDataReferent(soFar)\n                    soFar = soFar0 + len(data)\n            except Exception as e:\n                LOG.error(str(e))\n                LOG.error(\"Error packing field '%s | %s' in %s\" % (fieldName, fieldTypeOrClass, self.__class__))\n                raise\n\n        return data\n\n    def fromString(self, data, offset=0):\n        offset0 = offset\n        for fieldName, fieldTypeOrClass in self.commonHdr+self.structure:\n            try:\n                # Are we dealing with an array?\n                if isinstance(self.fields[fieldName], NDRUniConformantArray) or isinstance(self.fields[fieldName],\n                              NDRUniConformantVaryingArray):\n                    # Yes, get the array size\n                    arraySize, advanceStream = self.getArraySize(fieldName, data, offset)\n                    self.fields[fieldName].setArraySize(arraySize)\n                    offset += advanceStream\n\n                size = self.unpack(fieldName, fieldTypeOrClass, data, offset)\n\n                # Any referent information to unpack?\n                if isinstance(self.fields[fieldName], NDRCONSTRUCTEDTYPE):\n                    size += self.fields[fieldName].fromStringReferents(data, offset+size)\n                    size += self.fields[fieldName].fromStringReferent(data, offset+size)\n                offset += size\n            except Exception as e:\n                LOG.error(str(e))\n                LOG.error(\"Error unpacking field '%s | %s | %r'\" % (fieldName, fieldTypeOrClass, data[offset:offset+256]))\n                raise\n\n        return offset - offset0",
  "class UNKNOWNDATA(NDR):\n    align = 1\n    structure = (\n        ('Data', ':'),\n    )",
  "def __init__(self, data = None, isNDR64 = False):\n        object.__init__(self)\n        self._isNDR64 = isNDR64\n        self.fields = {}\n\n        if isNDR64 is True:\n            if self.commonHdr64 != ():\n                self.commonHdr = self.commonHdr64\n            if self.structure64 != ():\n                self.structure = self.structure64\n            if hasattr(self, 'align64'):\n                self.align = self.align64\n\n        for fieldName, fieldTypeOrClass in self.commonHdr+self.structure+self.referent:\n            if self.isNDR(fieldTypeOrClass):\n               self.fields[fieldName] = fieldTypeOrClass(isNDR64 = self._isNDR64)\n            elif fieldTypeOrClass == ':':\n               self.fields[fieldName] = b''\n            elif len(fieldTypeOrClass.split('=')) == 2: \n               try:\n                   self.fields[fieldName] = eval(fieldTypeOrClass.split('=')[1])\n               except:\n                   self.fields[fieldName] = None\n            else:\n               self.fields[fieldName] = []\n\n        if data is not None:\n            self.fromString(data)",
  "def changeTransferSyntax(self, newSyntax): \n        NDR64Syntax = uuidtup_to_bin(('71710533-BEBA-4937-8319-B5DBEF9CCC36', '1.0'))\n        if newSyntax == NDR64Syntax:\n            if self._isNDR64 is False:\n                # Ok, let's change everything\n                self._isNDR64 = True\n                for fieldName in list(self.fields.keys()):\n                    if isinstance(self.fields[fieldName], NDR):\n                        self.fields[fieldName].changeTransferSyntax(newSyntax)\n                # Finally, I change myself\n                if self.commonHdr64 != ():\n                    self.commonHdr = self.commonHdr64\n                if self.structure64 != ():\n                    self.structure = self.structure64\n                if hasattr(self, 'align64'):\n                    self.align = self.align64\n                # And check whether the changes changed the data types\n                # if so, I need to instantiate the new ones and copy the\n                # old values\n                for fieldName, fieldTypeOrClass in self.commonHdr+self.structure+self.referent:\n                    if isinstance(self.fields[fieldName], NDR):\n                        if fieldTypeOrClass != self.fields[fieldName].__class__ and isinstance(self.fields[fieldName], NDRPOINTERNULL) is False:\n                            backupData = self[fieldName]\n                            self.fields[fieldName] = fieldTypeOrClass(isNDR64 = self._isNDR64)\n                            if 'Data' in self.fields[fieldName].fields:\n                                self.fields[fieldName].fields['Data'] = backupData\n                            else:\n                                self[fieldName] = backupData\n  \n        else:\n            if self._isNDR64 is True:\n                # Ok, nothing for now\n                raise Exception('Shouldn\\'t be here')",
  "def __setitem__(self, key, value):\n        if isinstance(value, NDRPOINTERNULL):\n            value = NDRPOINTERNULL(isNDR64 = self._isNDR64)\n            if isinstance(self.fields[key], NDRPOINTER):\n                self.fields[key] = value\n            elif 'Data' in self.fields[key].fields:\n                if isinstance(self.fields[key].fields['Data'], NDRPOINTER):\n                    self.fields[key].fields['Data'] = value\n        elif isinstance(value, NDR):\n            # It's not a null pointer, ok. Another NDR type, but it \n            # must be the same same as the iteam already in place\n            if self.fields[key].__class__.__name__ == value.__class__.__name__:\n                self.fields[key] = value\n            elif isinstance(self.fields[key]['Data'], NDR):\n                if self.fields[key]['Data'].__class__.__name__ == value.__class__.__name__:\n                    self.fields[key]['Data'] = value\n                else:\n                    LOG.error(\"Can't setitem with class specified, should be %s\" % self.fields[key]['Data'].__class__.__name__)\n            else:\n                LOG.error(\"Can't setitem with class specified, should be %s\" % self.fields[key].__class__.__name__)\n        elif isinstance(self.fields[key], NDR):\n            self.fields[key]['Data'] = value\n        else:\n            self.fields[key] = value",
  "def __getitem__(self, key):\n        if isinstance(self.fields[key], NDR):\n            if 'Data' in self.fields[key].fields:\n                return self.fields[key]['Data']\n        return self.fields[key]",
  "def __str__(self):\n        return self.getData()",
  "def __len__(self):\n        # XXX: improve\n        return len(self.getData())",
  "def getDataLen(self, data, offset=0):\n        return len(data) - offset",
  "def isNDR(field):\n        if inspect.isclass(field):\n            myClass = field\n            if issubclass(myClass, NDR):\n                return True\n        return False",
  "def dumpRaw(self, msg = None, indent = 0):\n        if msg is None:\n            msg = self.__class__.__name__\n        ind = ' '*indent\n        print(\"\\n%s\" % msg)\n        for field in self.commonHdr+self.structure+self.referent:\n            i = field[0] \n            if i in self.fields:\n                if isinstance(self.fields[i], NDR):\n                    self.fields[i].dumpRaw('%s%s:{' % (ind,i), indent = indent + 4)\n                    print(\"%s}\" % ind)\n\n                elif isinstance(self.fields[i], list):\n                    print(\"%s[\" % ind)\n                    for num,j in enumerate(self.fields[i]):\n                       if isinstance(j, NDR):\n                           j.dumpRaw('%s%s:' % (ind,i), indent = indent + 4)\n                           print(\"%s,\" % ind)\n                       else:\n                           print(\"%s%s: {%r},\" % (ind, i, j))\n                    print(\"%s]\" % ind)\n\n                else:\n                    print(\"%s%s: {%r}\" % (ind,i,self[i]))",
  "def dump(self, msg = None, indent = 0):\n        if msg is None:\n            msg = self.__class__.__name__\n        ind = ' '*indent\n        if msg != '':\n            print(\"%s\" % msg, end=' ')\n        for fieldName, fieldType in self.commonHdr+self.structure+self.referent:\n            if fieldName in self.fields:\n                if isinstance(self.fields[fieldName], NDR):\n                    self.fields[fieldName].dump('\\n%s%-31s' % (ind, fieldName+':'), indent = indent + 4),\n                else:\n                    print(\" %r\" % (self[fieldName]), end=' ')",
  "def getAlignment(self):\n        return self.align",
  "def calculatePad(fieldType, soFar):\n        if isinstance(fieldType, str):\n            try:\n                alignment = calcsize(fieldType.split('=')[0])\n            except:\n                alignment = 0\n        else:\n            alignment = 0\n\n        if alignment > 0:\n            pad = (alignment - (soFar % alignment)) % alignment\n        else:\n            pad = 0\n\n        return pad",
  "def getData(self, soFar = 0):\n        data = b''\n        for fieldName, fieldTypeOrClass in self.commonHdr+self.structure:\n            try:\n                # Alignment of Primitive Types\n\n                # NDR enforces NDR alignment of primitive data; that is, any primitive of size n\n                # octets is aligned at a octet stream index that is a multiple of n.\n                # (In this version of NDR, n is one of {1, 2, 4, 8}.) An octet stream index indicates\n                # the number of an octet in an octet stream when octets are numbered, beginning with 0,\n                # from the first octet in the stream. Where necessary, an alignment gap, consisting of\n                # octets of unspecified value, precedes the representation of a primitive. The gap is\n                # of the smallest size sufficient to align the primitive.\n                pad = self.calculatePad(fieldTypeOrClass, soFar)\n                if pad > 0:\n                    soFar += pad\n                    data += b'\\xbf'*pad\n\n                res = self.pack(fieldName, fieldTypeOrClass, soFar)\n\n                data += res\n                soFar += len(res)\n            except Exception as e:\n                LOG.error(str(e))\n                LOG.error(\"Error packing field '%s | %s' in %s\" % (fieldName, fieldTypeOrClass, self.__class__))\n                raise\n\n        return data",
  "def fromString(self, data, offset=0):\n        offset0 = offset\n        for fieldName, fieldTypeOrClass in self.commonHdr+self.structure:\n            try:\n                # Alignment of Primitive Types\n\n                # NDR enforces NDR alignment of primitive data; that is, any primitive of size n\n                # octets is aligned at a octet stream index that is a multiple of n.\n                # (In this version of NDR, n is one of {1, 2, 4, 8}.) An octet stream index indicates\n                # the number of an octet in an octet stream when octets are numbered, beginning with 0,\n                # from the first octet in the stream. Where necessary, an alignment gap, consisting of\n                # octets of unspecified value, precedes the representation of a primitive. The gap is\n                # of the smallest size sufficient to align the primitive.\n                offset += self.calculatePad(fieldTypeOrClass, offset)\n\n                offset += self.unpack(fieldName, fieldTypeOrClass, data, offset)\n            except Exception as e:\n                LOG.error(str(e))\n                LOG.error(\"Error unpacking field '%s | %s | %r'\" % (fieldName, fieldTypeOrClass, data[offset:offset+256]))\n                raise\n        return offset - offset0",
  "def pack(self, fieldName, fieldTypeOrClass, soFar = 0):\n        if isinstance(self.fields[fieldName], NDR):\n            return self.fields[fieldName].getData(soFar)\n\n        data = self.fields[fieldName]\n        # void specifier\n        if fieldTypeOrClass[:1] == '_':\n            return b''\n\n        # code specifier\n        two = fieldTypeOrClass.split('=')\n        if len(two) >= 2:\n            try:\n                return self.pack(fieldName, two[0], soFar)\n            except:\n                self.fields[fieldName] = eval(two[1], {}, self.fields)\n                return self.pack(fieldName, two[0], soFar)\n\n        if data is None:\n            raise Exception('Trying to pack None')\n\n        # literal specifier\n        if fieldTypeOrClass[:1] == ':':\n            if hasattr(data, 'getData'):\n                return data.getData()\n            return data\n\n        # struct like specifier\n        return pack(fieldTypeOrClass, data)",
  "def unpack(self, fieldName, fieldTypeOrClass, data, offset=0):\n        if isinstance(self.fields[fieldName], NDR):\n            return self.fields[fieldName].fromString(data, offset)\n\n        # code specifier\n        two = fieldTypeOrClass.split('=')\n        if len(two) >= 2:\n            return self.unpack(fieldName, two[0], data, offset)\n\n        # literal specifier\n        if fieldTypeOrClass == ':':\n            if isinstance(fieldTypeOrClass, NDR):\n                return self.fields[fieldName].fromString(data, offset)\n            else:\n                dataLen = self.getDataLen(data, offset)\n                self.fields[fieldName] =  data[offset:offset+dataLen]\n                return dataLen\n\n        # struct like specifier\n        self.fields[fieldName] = unpack_from(fieldTypeOrClass, data, offset)[0]\n\n        return calcsize(fieldTypeOrClass)",
  "def calcPackSize(self, fieldTypeOrClass, data):\n        if isinstance(fieldTypeOrClass, str) is False:\n            return len(data)\n\n        # code specifier\n        two = fieldTypeOrClass.split('=')\n        if len(two) >= 2:\n            return self.calcPackSize(two[0], data)\n\n        # literal specifier\n        if fieldTypeOrClass[:1] == ':':\n            return len(data)\n\n        # struct like specifier\n        return calcsize(fieldTypeOrClass)",
  "def calcUnPackSize(self, fieldTypeOrClass, data, offset=0):\n        if isinstance(fieldTypeOrClass, str) is False:\n            return len(data) - offset\n\n        # code specifier\n        two = fieldTypeOrClass.split('=')\n        if len(two) >= 2:\n            return self.calcUnPackSize(two[0], data, offset)\n\n        # array specifier\n        two = fieldTypeOrClass.split('*')\n        if len(two) == 2:\n            return len(data) - offset\n\n        # literal specifier\n        if fieldTypeOrClass[:1] == ':':\n            return len(data) - offset\n\n        # struct like specifier\n        return calcsize(fieldTypeOrClass)",
  "def dump(self, msg = None, indent = 0):\n        if msg is None:\n            msg = self.__class__.__name__\n        if msg != '':\n            print(msg, end=' ')\n\n        if self['Data'] > 0:\n            print(\" TRUE\")\n        else:\n            print(\" FALSE\")",
  "def __getattr__(self, attr):\n        return self.enumItems[attr].value",
  "class enumItems(Enum):\n        pass",
  "def __setitem__(self, key, value):\n       if isinstance(value, Enum):\n           self['Data'] = value.value\n       else:\n           return NDR.__setitem__(self,key,value)",
  "def dump(self, msg = None, indent = 0):\n        if msg is None:\n            msg = self.__class__.__name__\n        if msg != '':\n            print(msg, end=' ')\n\n        print(\" %s\" % self.enumItems(self.fields['Data']).name, end=' ')",
  "def isPointer(field):\n        if inspect.isclass(field):\n            myClass = field\n            if issubclass(myClass, NDRPOINTER):\n                return True\n        return False",
  "def isUnion(field):\n        if inspect.isclass(field):\n            myClass = field\n            if issubclass(myClass, NDRUNION):\n                return True\n        return False",
  "def getDataReferents(self, soFar = 0):\n        data = b''\n        for fieldName, fieldTypeOrClass in self.commonHdr+self.structure:\n            if isinstance(self.fields[fieldName], NDRCONSTRUCTEDTYPE):\n               data += self.fields[fieldName].getDataReferents(len(data)+soFar)\n               data += self.fields[fieldName].getDataReferent(len(data)+soFar)\n        return data",
  "def getDataReferent(self, soFar=0):\n        data = b''\n        soFar0 = soFar\n        if hasattr(self,'referent') is False:\n            return b''\n\n        if 'ReferentID' in self.fields:\n            if self['ReferentID'] == 0:\n                return b''\n\n        for fieldName, fieldTypeOrClass in self.referent:\n            try:\n                if isinstance(self.fields[fieldName], NDRUniConformantArray) or isinstance(self.fields[fieldName], NDRUniConformantVaryingArray):\n                    # So we have an array, first item in the structure must be the array size, although we\n                    # will need to build it later.\n                    if self._isNDR64:\n                        arrayItemSize = 8\n                        arrayPackStr = '<Q'\n                    else:\n                        arrayItemSize = 4\n                        arrayPackStr = '<L'\n\n                    # The size information is itself aligned according to the alignment rules for\n                    # primitive data types. (See Section 14.2.2 on page 620.) The data of the constructed\n                    # type is then aligned according to the alignment rules for the constructed type.\n                    # In other words, the size information precedes the structure and is aligned\n                    # independently of the structure alignment.\n                    # We need to check whether we need padding or not\n                    pad0 = (arrayItemSize - (soFar % arrayItemSize)) % arrayItemSize\n                    if pad0 > 0:\n                        soFar += pad0\n                        arrayPadding = b'\\xef'*pad0\n                    else:\n                        arrayPadding = b''\n                    # And now, let's pretend we put the item in\n                    soFar += arrayItemSize\n                    data = self.fields[fieldName].getData(soFar)\n                    data = arrayPadding + pack(arrayPackStr, self.getArrayMaximumSize(fieldName)) + data\n                else:\n                    pad = self.calculatePad(fieldTypeOrClass, soFar)\n                    if pad > 0:\n                        soFar += pad\n                        data += b'\\xcc'*pad\n\n                    data += self.pack(fieldName, fieldTypeOrClass, soFar)\n\n                # Any referent information to pack?\n                if isinstance(self.fields[fieldName], NDRCONSTRUCTEDTYPE):\n                    data += self.fields[fieldName].getDataReferents(soFar0 + len(data))\n                    data += self.fields[fieldName].getDataReferent(soFar0 + len(data))\n                soFar = soFar0 + len(data)\n\n            except Exception as e:\n                LOG.error(str(e))\n                LOG.error(\"Error packing field '%s | %s' in %s\" % (fieldName, fieldTypeOrClass, self.__class__))\n                raise\n\n        return data",
  "def calcPackSize(self, fieldTypeOrClass, data):\n        if isinstance(fieldTypeOrClass, str) is False:\n            return len(data)\n\n        # array specifier\n        two = fieldTypeOrClass.split('*')\n        if len(two) == 2:\n            answer = 0\n            for each in data:\n                if self.isNDR(self.item):\n                    item = ':'\n                else:\n                    item = self.item\n                answer += self.calcPackSize(item, each)\n            return answer\n        else:\n            return NDR.calcPackSize(self, fieldTypeOrClass, data)",
  "def getArrayMaximumSize(self, fieldName):\n        if self.fields[fieldName].fields['MaximumCount'] is not None and self.fields[fieldName].fields['MaximumCount'] > 0:\n            return self.fields[fieldName].fields['MaximumCount']\n        else:\n            return self.fields[fieldName].getArraySize()",
  "def getArraySize(self, fieldName, data, offset=0):\n        if self._isNDR64:\n            arrayItemSize = 8\n            arrayUnPackStr = '<Q'\n        else:\n            arrayItemSize = 4\n            arrayUnPackStr = '<L'\n\n        pad = (arrayItemSize - (offset % arrayItemSize)) % arrayItemSize\n        offset += pad\n\n        if isinstance(self.fields[fieldName], NDRUniConformantArray):\n            # Array Size is at the very beginning\n            arraySize = unpack_from(arrayUnPackStr, data, offset)[0]\n        elif isinstance(self.fields[fieldName], NDRUniConformantVaryingArray):\n            # NDRUniConformantVaryingArray Array\n            # Unpack the Maximum Count\n            maximumCount = unpack_from(arrayUnPackStr, data, offset)[0]\n            # Let's store the Maximum Count for later use\n            self.fields[fieldName].fields['MaximumCount'] = maximumCount\n            # Unpack the Actual Count\n            arraySize = unpack_from(arrayUnPackStr, data, offset+arrayItemSize*2)[0]\n        else:\n            # NDRUniVaryingArray Array\n            arraySize = unpack_from(arrayUnPackStr, data, offset+arrayItemSize)[0]\n\n        return arraySize, arrayItemSize+pad",
  "def fromStringReferents(self, data, offset=0):\n        offset0 = offset\n        for fieldName, fieldTypeOrClass in self.commonHdr+self.structure:\n            if isinstance(self.fields[fieldName], NDRCONSTRUCTEDTYPE):\n                offset += self.fields[fieldName].fromStringReferents(data, offset)\n                offset += self.fields[fieldName].fromStringReferent(data, offset)\n        return offset - offset0",
  "def fromStringReferent(self, data, offset=0):\n        if hasattr(self, 'referent') is not True:\n            return 0\n\n        offset0 = offset\n\n        if 'ReferentID' in self.fields:\n            if self['ReferentID'] == 0:\n                # NULL Pointer, there's no referent for it\n                return 0\n\n        for fieldName, fieldTypeOrClass in self.referent:\n            try:\n                if isinstance(self.fields[fieldName], NDRUniConformantArray) or isinstance(self.fields[fieldName], NDRUniConformantVaryingArray):\n                    # Get the array size\n                    arraySize, advanceStream = self.getArraySize(fieldName, data, offset)\n                    offset += advanceStream\n\n                    # Let's tell the array how many items are available\n                    self.fields[fieldName].setArraySize(arraySize)\n                    size = self.fields[fieldName].fromString(data, offset)\n                else:\n                    # ToDo: Align only if not NDR\n                    offset += self.calculatePad(fieldTypeOrClass, offset)\n\n                    size = self.unpack(fieldName, fieldTypeOrClass, data, offset)\n\n                if isinstance(self.fields[fieldName], NDRCONSTRUCTEDTYPE):\n                    size += self.fields[fieldName].fromStringReferents(data, offset+size)\n                    size += self.fields[fieldName].fromStringReferent(data, offset+size)\n                offset += size\n            except Exception as e:\n                LOG.error(str(e))\n                LOG.error(\"Error unpacking field '%s | %s | %r'\" % (fieldName, fieldTypeOrClass, data[offset:offset+256]))\n                raise\n\n        return offset-offset0",
  "def calcUnPackSize(self, fieldTypeOrClass, data, offset=0):\n        if isinstance(fieldTypeOrClass, str) is False:\n            return len(data) - offset\n\n        two = fieldTypeOrClass.split('*')\n        if len(two) == 2:\n            return len(data) - offset\n        else:\n            return NDR.calcUnPackSize(self, fieldTypeOrClass, data, offset)",
  "def dump(self, msg = None, indent = 0):\n        if msg is None:\n            msg = self.__class__.__name__\n        ind = ' '*indent\n        if msg != '':\n            print(msg, end=' ')\n\n        if isinstance(self['Data'], list):\n            print(\"\\n%s[\" % ind)\n            ind += ' '*4\n            for num,j in enumerate(self.fields['Data']):\n               if isinstance(j, NDR):\n                   j.dump('%s' % ind, indent = indent + 4),\n                   print(\",\") \n               else:\n                   print(\"%s %r,\" % (ind,j))\n            print(\"%s]\" % ind[:-4], end=' ')\n        else:\n            print(\" %r\" % self['Data'], end=' ')",
  "def setArraySize(self, size):\n        self.arraySize = size",
  "def getArraySize(self):\n        return self.arraySize",
  "def changeTransferSyntax(self, newSyntax): \n        # Here we gotta go over each item in the array and change the TS \n        # Only if the item type is NDR\n        if hasattr(self, 'item') and self.item is not None:\n            if self.isNDR(self.item):\n                for item in self.fields['Data']:\n                    item.changeTransferSyntax(newSyntax)\n        return NDRCONSTRUCTEDTYPE.changeTransferSyntax(self, newSyntax)",
  "def getAlignment(self):\n        # Array alignment is the largest alignment of the array element type and \n        # the size information type, if any.\n        align = 0\n        # And now the item\n        if hasattr(self, \"item\") and self.item is not None:\n            if self.isNDR(self.item):\n                tmpAlign = self.item().getAlignment()\n            else:\n                tmpAlign = self.calcPackSize(self.item, b'')\n            if tmpAlign > align:\n                align = tmpAlign\n        return align",
  "def getData(self, soFar = 0):\n        data = b''\n        soFar0 = soFar\n        for fieldName, fieldTypeOrClass in self.structure:\n            try:\n                if self.isNDR(fieldTypeOrClass) is False:\n                    # If the item is not NDR (e.g. ('MaximumCount', '<L=len(Data)'))\n                    # we have to align it\n                    pad = self.calculatePad(fieldTypeOrClass, soFar)\n                    if pad > 0:\n                        soFar += pad\n                        data += b'\\xca'*pad\n\n                res = self.pack(fieldName, fieldTypeOrClass, soFar)\n                data += res\n                soFar = soFar0 + len(data)\n            except Exception as e:\n                LOG.error(str(e))\n                LOG.error(\"Error packing field '%s | %s' in %s\" % (fieldName, fieldTypeOrClass, self.__class__))\n                raise\n\n        return data",
  "def pack(self, fieldName, fieldTypeOrClass, soFar = 0):\n        # array specifier\n        two = fieldTypeOrClass.split('*')\n        if len(two) == 2:\n            answer = b''\n            if self.isNDR(self.item):\n                item = ':'\n                dataClass = self.item\n                self.fields['_tmpItem'] = dataClass(isNDR64=self._isNDR64)\n            else:\n                item = self.item\n                dataClass = None\n                self.fields['_tmpItem'] = item\n\n            for each in (self.fields[fieldName]):\n                pad = self.calculatePad(self.item, len(answer)+soFar)\n                if pad > 0:\n                    answer += b'\\xdd' * pad\n                if dataClass is None:\n                    if item == 'c' and PY3 and isinstance(each, int):\n                        # Special case when dealing with PY3, here we have an integer we need to convert\n                        each = bytes([each])\n                    answer += pack(item, each)\n                else:\n                    answer += each.getData(len(answer)+soFar)\n\n            if dataClass is not None:\n                for each in self.fields[fieldName]:\n                    if isinstance(each, NDRCONSTRUCTEDTYPE):\n                        answer += each.getDataReferents(len(answer)+soFar)\n                        answer += each.getDataReferent(len(answer)+soFar)\n\n            del(self.fields['_tmpItem'])\n            if isinstance(self, NDRUniConformantArray) or isinstance(self, NDRUniConformantVaryingArray):\n                # First field points to a field with the amount of items\n                self.setArraySize(len(self.fields[fieldName]))\n            else:\n                self.fields[two[1]] = len(self.fields[fieldName])\n\n            return answer\n        else:\n            return NDRCONSTRUCTEDTYPE.pack(self, fieldName, fieldTypeOrClass, soFar)",
  "def fromString(self, data, offset=0):\n        offset0 = offset\n        for fieldName, fieldTypeOrClass in self.commonHdr+self.structure:\n            try:\n                if self.isNDR(fieldTypeOrClass) is False:\n                    # If the item is not NDR (e.g. ('MaximumCount', '<L=len(Data)'))\n                    # we have to align it\n                    offset += self.calculatePad(fieldTypeOrClass, offset)\n\n                size = self.unpack(fieldName, fieldTypeOrClass, data, offset)\n                offset += size\n            except Exception as e:\n                LOG.error(str(e))\n                LOG.error(\"Error unpacking field '%s | %s | %r'\" % (fieldName, fieldTypeOrClass, data[offset:offset+256]))\n                raise\n        return offset - offset0",
  "def unpack(self, fieldName, fieldTypeOrClass, data, offset=0):\n        # array specifier\n        two = fieldTypeOrClass.split('*')\n        answer = []\n        soFarItems = 0\n        offset0 = offset\n        if len(two) == 2:\n            if isinstance(self, NDRUniConformantArray):\n                # First field points to a field with the amount of items\n                numItems = self.getArraySize()\n            elif isinstance(self, NDRUniConformantVaryingArray):\n                # In this case we have the MaximumCount but it could be different from the ActualCount.\n                # Let's make the unpack figure this out.\n                #self.fields['MaximumCount'] = self.getArraySize()\n                numItems = self[two[1]]\n            else:\n                numItems = self[two[1]]\n\n            # The item type is determined by self.item\n            if self.isNDR(self.item):\n                item = ':'\n                dataClassOrCode = self.item\n                self.fields['_tmpItem'] = dataClassOrCode(isNDR64=self._isNDR64)\n            else:\n                item = self.item\n                dataClassOrCode = None\n                self.fields['_tmpItem'] = item\n\n            nsofar = 0\n            while numItems and soFarItems < len(data) - offset:\n                pad = self.calculatePad(self.item, soFarItems+offset)\n                if pad > 0:\n                    soFarItems +=pad\n                if dataClassOrCode is None:\n                    nsofar = soFarItems + calcsize(item)\n                    answer.append(unpack_from(item, data, offset+soFarItems)[0])\n                else:\n                    itemn = dataClassOrCode(isNDR64=self._isNDR64)\n                    size = itemn.fromString(data, offset+soFarItems)\n                    answer.append(itemn)\n                    nsofar += size + pad\n                numItems -= 1\n                soFarItems = nsofar\n\n            if dataClassOrCode is not None and isinstance(dataClassOrCode(), NDRCONSTRUCTEDTYPE):\n                # We gotta go over again, asking for the referents\n                answer2 = []\n                for itemn in answer:\n                    size = itemn.fromStringReferents(data, soFarItems+offset)\n                    soFarItems += size\n                    size = itemn.fromStringReferent(data, soFarItems+offset)\n                    soFarItems += size\n                    answer2.append(itemn)\n                answer = answer2\n                del answer2\n\n            del(self.fields['_tmpItem'])\n\n            self.fields[fieldName] = answer\n            return soFarItems + offset - offset0\n        else:\n            return NDRCONSTRUCTEDTYPE.unpack(self, fieldName, fieldTypeOrClass, data, offset)",
  "def __init__(self, data = None, isNDR64 = False):\n        NDRArray.__init__(self, data, isNDR64)\n        # Let's store the hidden MaximumCount field\n        self.fields['MaximumCount'] = 0",
  "def __setitem__(self, key, value):\n        self.fields['MaximumCount'] = None\n        return NDRArray.__setitem__(self, key, value)",
  "def __setitem__(self, key, value):\n        self.fields['ActualCount'] = None\n        return NDRArray.__setitem__(self, key, value)",
  "def __init__(self, data = None, isNDR64 = False):\n        NDRArray.__init__(self, data, isNDR64)\n        # Let's store the hidden MaximumCount field\n        self.fields['MaximumCount'] = 0",
  "def __setitem__(self, key, value):\n        self.fields['MaximumCount'] = None\n        self.fields['ActualCount'] = None\n        return NDRArray.__setitem__(self, key, value)",
  "def getData(self, soFar = 0):\n        data = b''\n        soFar0 = soFar\n        for fieldName, fieldTypeOrClass in self.commonHdr+self.structure:\n            try:\n                pad = self.calculatePad(fieldTypeOrClass, soFar)\n                if pad > 0:\n                    soFar += pad\n                    data += b'\\xcb'*pad\n\n                res = self.pack(fieldName, fieldTypeOrClass, soFar)\n                data += res\n                soFar = soFar0 + len(data)\n            except Exception as e:\n                LOG.error(str(e))\n                LOG.error(\"Error packing field '%s | %s' in %s\" % (fieldName, fieldTypeOrClass, self.__class__))\n                raise\n\n        return data",
  "def getData(self, soFar = 0):\n        # The last element of a string is a terminator of the same size as the other elements. \n        # If the string element size is one octet, the terminator is a NULL character. \n        # The terminator for a string of multi-byte characters is the array element zero (0).\n        if self[\"Data\"][-1:] != b'\\x00':\n            if PY3 and isinstance(self[\"Data\"],list) is False:\n                self[\"Data\"] = self[\"Data\"] + b'\\x00'\n            else:\n                self[\"Data\"] = b''.join(self[\"Data\"]) + b'\\x00'\n        return NDRUniVaryingArray.getData(self, soFar)",
  "def fromString(self, data, offset = 0):\n        ret = NDRUniVaryingArray.fromString(self, data, offset)\n        # Let's take out the last item\n        self[\"Data\"] = self[\"Data\"][:-1] \n        return ret",
  "def getData(self, soFar = 0):\n        data = b''\n        arrayPadding = b''\n        soFar0 = soFar\n        # 14.3.7.1 Structures Containing a Conformant Array\n        # A structure can contain a conformant array only as its last member.\n        # In the NDR representation of a structure that contains a conformant array, \n        # the unsigned long integers that give maximum element counts for dimensions of the array \n        # are moved to the beginning of the structure, and the array elements appear in place at \n        # the end of the structure.\n        # 14.3.7.2 Structures Containing a Conformant and Varying Array\n        # A structure can contain a conformant and varying array only as its last member.\n        # In the NDR representation of a structure that contains a conformant and varying array, \n        # the maximum counts for dimensions of the array are moved to the beginning of the structure, \n        # but the offsets and actual counts remain in place at the end of the structure, \n        # immediately preceding the array elements\n        lastItem = (self.commonHdr+self.structure)[-1][0]\n        if isinstance(self.fields[lastItem], NDRUniConformantArray) or isinstance(self.fields[lastItem], NDRUniConformantVaryingArray):\n            # So we have an array, first item in the structure must be the array size, although we\n            # will need to build it later.\n            if self._isNDR64:\n                arrayItemSize = 8\n                arrayPackStr = '<Q'\n            else:\n                arrayItemSize = 4\n                arrayPackStr = '<L'\n\n            # The size information is itself aligned according to the alignment rules for \n            # primitive data types. (See Section 14.2.2 on page 620.) The data of the constructed \n            # type is then aligned according to the alignment rules for the constructed type. \n            # In other words, the size information precedes the structure and is aligned \n            # independently of the structure alignment.\n            # We need to check whether we need padding or not\n            pad0 = (arrayItemSize - (soFar % arrayItemSize)) % arrayItemSize \n            if pad0 > 0:\n                soFar += pad0\n                arrayPadding = b'\\xee'*pad0\n            else:\n                arrayPadding = b''\n            # And now, let's pretend we put the item in\n            soFar += arrayItemSize\n        else:\n            arrayItemSize = 0\n\n        # Now we need to align the structure \n        # The alignment of a structure in the octet stream is the largest of the alignments of the fields it\n        # contains. These fields may also be constructed types. The same alignment rules apply \n        # recursively to nested constructed types.\n        alignment = self.getAlignment()\n\n        if alignment > 0:\n            pad = (alignment - (soFar % alignment)) % alignment\n            if pad > 0:\n                soFar += pad\n                data += b'\\xAB'*pad\n\n        for fieldName, fieldTypeOrClass in self.commonHdr+self.structure:\n            try:\n                if isinstance(self.fields[fieldName], NDRUniConformantArray) or isinstance(self.fields[fieldName], NDRUniConformantVaryingArray):\n                    res = self.fields[fieldName].getData(soFar)\n                    if isinstance(self, NDRPOINTER):\n                        pointerData = data[:arrayItemSize]\n                        data = data[arrayItemSize:]\n                        data = pointerData + arrayPadding + pack(arrayPackStr ,self.getArrayMaximumSize(fieldName)) + data\n                    else:\n                        data = arrayPadding + pack(arrayPackStr, self.getArrayMaximumSize(fieldName)) + data\n                    arrayPadding = b''\n                    arrayItemSize = 0\n                else:\n                    res = self.pack(fieldName, fieldTypeOrClass, soFar)\n                data += res\n                soFar = soFar0 + len(data) + len(arrayPadding) + arrayItemSize\n            except Exception as e:\n                LOG.error(str(e))\n                LOG.error(\"Error packing field '%s | %s' in %s\" % (fieldName, fieldTypeOrClass, self.__class__))\n                raise\n\n        # 2.2.5.3.4.1 Structure with Trailing Gap\n        # NDR64 represents a structure as an ordered sequence of representations of the\n        # structure members. The trailing gap from the last nonconformant and nonvarying\n        # field to the alignment of the structure MUST be represented as a trailing pad.\n        # The size of the structure MUST be a multiple of its alignment.\n        # See the following figure.\n\n        # 4.8 Example of Structure with Trailing Gap in NDR64\n        # This example shows a structure with a trailing gap in NDR64.\n        #     typedef struct _StructWithPad\n        #     {\n        #         long l;\n        #         short s;\n        #     } StructWithPad;\n        # The size of the structure in the octet stream MUST contain a 2-byte trailing\n        # gap to make its size 8, a multiple of the structure's alignment, 4.\n#        if self._isNDR64 is True:\n#            # ToDo add trailing gap here\n#            if alignment > 0:\n#                pad = (alignment - (soFar % alignment)) % alignment\n#                if pad > 0:\n#                    soFar += pad\n#                    data += '\\xcd'*pad\n#            print self.__class__ , alignment, pad, hex(soFar)\n        return data",
  "def fromString(self, data, offset = 0 ):\n        offset0 = offset\n        # 14.3.7.1 Structures Containing a Conformant Array\n        # A structure can contain a conformant array only as its last member.\n        # In the NDR representation of a structure that contains a conformant array, \n        # the unsigned long integers that give maximum element counts for dimensions of the array \n        # are moved to the beginning of the structure, and the array elements appear in place at \n        # the end of the structure.\n        # 14.3.7.2 Structures Containing a Conformant and Varying Array\n        # A structure can contain a conformant and varying array only as its last member.\n        # In the NDR representation of a structure that contains a conformant and varying array, \n        # the maximum counts for dimensions of the array are moved to the beginning of the structure, \n        # but the offsets and actual counts remain in place at the end of the structure, \n        # immediately preceding the array elements\n        lastItem = (self.commonHdr+self.structure)[-1][0]\n\n        # If it's a pointer, let's parse it here because\n        # we are going to parse the next MaximumCount field(s) manually\n        # when it's a Conformant or Conformant and Varying array\n        if isinstance(self, NDRPOINTER):\n            structureFields = self.structure\n\n            alignment = self.getAlignment()\n            if alignment > 0:\n                offset += (alignment - (offset % alignment)) % alignment\n\n            for fieldName, fieldTypeOrClass in self.commonHdr:\n                offset += self.unpack(fieldName, fieldTypeOrClass, data, offset)\n        else:\n            structureFields = self.commonHdr+self.structure\n\n        if isinstance(self.fields[lastItem], NDRUniConformantArray) or isinstance(self.fields[lastItem], NDRUniConformantVaryingArray):\n            # So we have an array, first item in the structure must be the array size, although we\n            # will need to build it later.\n            if self._isNDR64:\n                arrayItemSize = 8\n                arrayUnPackStr = '<Q'\n            else:\n                arrayItemSize = 4\n                arrayUnPackStr = '<L'\n\n            # The size information is itself aligned according to the alignment rules for\n            # primitive data types. (See Section 14.2.2 on page 620.) The data of the constructed \n            # type is then aligned according to the alignment rules for the constructed type. \n            # In other words, the size information precedes the structure and is aligned \n            # independently of the structure alignment.\n            # We need to check whether we need padding or not\n            offset += (arrayItemSize - (offset % arrayItemSize)) % arrayItemSize\n\n            # And let's extract the array size for later use\n            if isinstance(self.fields[lastItem], NDRUniConformantArray):\n                # NDRUniConformantArray\n                arraySize = unpack_from(arrayUnPackStr, data, offset)[0]\n                self.fields[lastItem].setArraySize(arraySize)\n            else:\n                # NDRUniConformantVaryingArray\n                maximumCount = unpack_from(arrayUnPackStr, data, offset)[0]\n                self.fields[lastItem].fields['MaximumCount'] = maximumCount\n\n            offset += arrayItemSize\n\n        # Now we need to align the structure\n        # The alignment of a structure in the octet stream is the largest of the alignments of the fields it\n        # contains. These fields may also be constructed types. The same alignment rules apply \n        # recursively to nested constructed types.\n        alignment = self.getAlignment()\n        if alignment > 0:\n            offset += (alignment - (offset % alignment)) % alignment\n\n        for fieldName, fieldTypeOrClass in structureFields:\n            try:\n                offset += self.unpack(fieldName, fieldTypeOrClass, data, offset)\n            except Exception as e:\n                LOG.error(str(e))\n                LOG.error(\"Error unpacking field '%s | %s | %r'\" % (fieldName, fieldTypeOrClass, data[offset:offset+256]))\n                raise\n\n        return offset - offset0",
  "def getAlignment(self):\n        # Alignment of Constructed Types\n        #\n        # NDR enforces NDR alignment of structured data. As with primitive data types, an alignment, n, is determined\n        # for the structure. Where necessary, an alignment gap of octets of unspecified value precedes the data in\n        # the NDR octet stream. This gap is the smallest size sufficient to align the first field of the structure\n        # on an NDR octet stream index of n.\n\n        # The rules for calculating the alignment of constructed types are as follows:\n\n        # 1) If a conformant structure-that is, a conformant or conformant varying array, or a structure containing\n        # a conformant or conformant varying array-is embedded in the constructed type, and is the outermost\n        # structure-that is, is not contained in another structure-then the size information from the contained\n        # conformant structure is positioned so that it precedes both the containing constructed type and any\n        # alignment gap for the constructed type. (See Section 14.3.7 for information about structures containing\n        # arrays.) The size information is itself aligned according to the alignment rules for primitive data\n        # types. (See Section 14.2.2 on page 620.) The data of the constructed type is then aligned according to\n        # the alignment rules for the constructed type. In other words, the size information precedes the structure\n        # and is aligned independently of the structure alignment.\n\n        # 2) The alignment of a structure in the octet stream is the largest of the alignments of the fields it\n        # contains. These fields may also be constructed types. The same alignment rules apply recursively to nested\n        # constructed types.\n\n        align = 0\n        for fieldName, fieldTypeOrClass in self.commonHdr+self.structure+self.referent:\n            if isinstance(self.fields[fieldName], NDR):\n                tmpAlign = self.fields[fieldName].getAlignment()\n            else:\n                tmpAlign = self.calcPackSize(fieldTypeOrClass, b'')\n            if tmpAlign > align:\n                align = tmpAlign\n        return align",
  "def __init__(self, data = None, isNDR64=False, topLevel = False):\n        #ret = NDR.__init__(self,None, isNDR64=isNDR64)\n        self.topLevel = topLevel\n        self._isNDR64 = isNDR64\n        self.fields = {}\n\n        if isNDR64 is True:\n            if self.commonHdr64 != ():\n                self.commonHdr = self.commonHdr64\n            if self.structure64 != ():\n                self.structure = self.structure64\n            if hasattr(self, 'align64'):\n                self.align = self.align64\n\n        for fieldName, fieldTypeOrClass in self.commonHdr+self.structure+self.referent:\n            if self.isNDR(fieldTypeOrClass):\n               if self.isPointer(fieldTypeOrClass):\n                   self.fields[fieldName] = fieldTypeOrClass(isNDR64 = self._isNDR64, topLevel = topLevel)\n               elif self.isUnion(fieldTypeOrClass):\n                   self.fields[fieldName] = fieldTypeOrClass(isNDR64 = self._isNDR64, topLevel = topLevel)\n               else:\n                   self.fields[fieldName] = fieldTypeOrClass(isNDR64 = self._isNDR64)\n            elif fieldTypeOrClass == ':':\n               self.fields[fieldName] = None\n            elif len(fieldTypeOrClass.split('=')) == 2: \n               try:\n                   self.fields[fieldName] = eval(fieldTypeOrClass.split('=')[1])\n               except:\n                   self.fields[fieldName] = None\n            else:\n               self.fields[fieldName] = 0\n\n        if data is not None:\n            self.fromString(data)",
  "def __setitem__(self, key, value):\n        if key == 'tag':\n            # We're writing the tag, we now should set the right item for the structure\n            self.structure = ()\n            if value in self.union:\n                self.structure = (self.union[value]),\n                # Init again the structure\n                self.__init__(None, isNDR64=self._isNDR64, topLevel = self.topLevel)\n                self.fields['tag']['Data'] = value\n            else:\n                # Let's see if we have a default value\n                if 'default' in self.union:\n                    if self.union['default'] is None:\n                        self.structure = ()\n                    else:\n                        self.structure = (self.union['default']),\n                        # Init again the structure\n                        self.__init__(None, isNDR64=self._isNDR64, topLevel = self.topLevel)\n                    self.fields['tag']['Data'] = 0xffff\n                else:\n                    raise Exception(\"Unknown tag %d for union!\" % value)\n        else:\n            return NDRCONSTRUCTEDTYPE.__setitem__(self,key,value)",
  "def getData(self, soFar = 0):\n        data = b''\n        soFar0 = soFar\n\n        # Let's align ourselves\n        alignment = self.getAlignment()\n        if alignment > 0:\n            pad = (alignment - (soFar % alignment)) % alignment\n        else:\n            pad = 0\n        if pad > 0:\n            soFar += pad\n            data += b'\\xbc'*pad\n\n        for fieldName, fieldTypeOrClass in self.commonHdr:\n            try:\n                pad = self.calculatePad(fieldTypeOrClass, soFar)\n                if pad > 0:\n                    soFar += pad\n                    data += b'\\xbb'*pad\n\n                res = self.pack(fieldName, fieldTypeOrClass, soFar)\n                data += res\n                soFar = soFar0 + len(data)\n            except Exception as e:\n                LOG.error(str(e))\n                LOG.error(\"Error packing field '%s | %s' in %s\" % (fieldName, fieldTypeOrClass, self.__class__))\n                raise\n\n        # WARNING\n        # Now we need to align what's coming next.\n        # This doesn't come from the documentation but from seeing the packets in the wire\n        # for some reason, even if the next field is a SHORT, it should be aligned to\n        # a DWORD, or HYPER if NDR64. \n        if self._isNDR64:\n            align = 8\n        else:\n            if hasattr(self, 'notAlign'):\n                align = 1\n            else:\n                align = 4\n\n        pad = (align - (soFar % align)) % align\n        if pad > 0:\n            data += b'\\xbd'*pad\n            soFar += pad\n\n        if self.structure == ():\n            return data\n\n        for fieldName, fieldTypeOrClass in self.structure:\n            try:\n                pad = self.calculatePad(fieldTypeOrClass, soFar)\n                if pad > 0:\n                    soFar += pad\n                    data += b'\\xbe'*pad\n\n                res = self.pack(fieldName, fieldTypeOrClass, soFar)\n                data += res\n                soFar = soFar0 + len(data)\n            except Exception as e:\n                LOG.error(str(e))\n                LOG.error(\"Error packing field '%s | %s' in %s\" % (fieldName, fieldTypeOrClass, self.__class__))\n                raise\n\n        return data",
  "def fromString(self, data, offset=0):\n        offset0 = offset\n        # Let's align ourselves\n        alignment = self.getAlignment()\n        if alignment > 0:\n            pad = (alignment - (offset % alignment)) % alignment\n        else:\n            pad = 0\n        if pad > 0:\n            offset += pad\n\n        if len(data)-offset > 4:\n            # First off, let's see what the tag is:\n            # We need to know the tag type and unpack it\n            tagtype = self.commonHdr[0][1].structure[0][1].split('=')[0]\n            tag = unpack_from(tagtype, data, offset)[0]\n            if tag in self.union:\n                self.structure = (self.union[tag]),\n                self.__init__(None, isNDR64=self._isNDR64, topLevel = self.topLevel)\n            else:\n                # Let's see if we have a default value\n                if 'default' in self.union:\n                    if self.union['default'] is None:\n                        self.structure = ()\n                    else:\n                        self.structure = (self.union['default']),\n                        # Init again the structure\n                        self.__init__(None, isNDR64=self._isNDR64, topLevel = self.topLevel)\n                    self.fields['tag']['Data'] = 0xffff\n                else:\n                    raise Exception(\"Unknown tag %d for union!\" % tag)\n\n        for fieldName, fieldTypeOrClass in self.commonHdr:\n            try:\n                offset += self.calculatePad(fieldTypeOrClass, offset)\n                offset += self.unpack(fieldName, fieldTypeOrClass, data, offset)\n            except Exception as e:\n                LOG.error(str(e))\n                LOG.error(\"Error unpacking field '%s | %s | %r'\" % (fieldName, fieldTypeOrClass, data[offset:offset+256]))\n                raise\n\n        # WARNING\n        # Now we need to align what's coming next.\n        # This doesn't come from the documentation but from seeing the packets in the wire\n        # for some reason, even if the next field is a SHORT, it should be aligned to\n        # a DWORD, or HYPER if NDR64. \n        if self._isNDR64:\n            align = 8\n        else:\n            if hasattr(self, 'notAlign'):\n                align = 1\n            else:\n                align = 4\n\n        offset += (align - (offset % align)) % align\n\n        if self.structure == ():\n            return offset-offset0\n\n        for fieldName, fieldTypeOrClass in self.structure:\n            try:\n                offset += self.calculatePad(fieldTypeOrClass, offset)\n                offset += self.unpack(fieldName, fieldTypeOrClass, data, offset)\n            except Exception as e:\n                LOG.error(str(e))\n                LOG.error(\"Error unpacking field '%s | %s | %r'\" % (fieldName, fieldTypeOrClass, data[offset:offset+256]))\n                raise\n\n        return offset - offset0",
  "def getAlignment(self):\n        # Union alignment is the largest alignment of the union discriminator \n        # and all of the union arms.\n        # WRONG, I'm calculating it just with the tag, if I do it with the \n        # arms I get bad stub data. Something wrong I'm doing or the standard\n        # is wrong (most probably it's me :s )\n        align = 0\n        if self._isNDR64:\n            fields =  self.commonHdr+self.structure\n        else: \n            fields =  self.commonHdr\n        for fieldName, fieldTypeOrClass in fields:\n            if isinstance(self.fields[fieldName], NDR):\n                tmpAlign = self.fields[fieldName].getAlignment()\n            else:\n                tmpAlign = self.calcPackSize(fieldTypeOrClass, b'')\n            if tmpAlign > align:\n                align = tmpAlign\n\n        if self._isNDR64:\n            for fieldName, fieldTypeOrClass in self.union.values():\n                tmpAlign = fieldTypeOrClass(isNDR64 = self._isNDR64).getAlignment()\n                if tmpAlign > align:\n                    align = tmpAlign\n        return align",
  "def dump(self, msg = None, indent = 0):\n        if msg is None:\n            msg = self.__class__.__name__\n        if msg != '':\n            print(\"%s\" % msg, end=' ')\n        # Here we just print NULL\n        print(\" NULL\", end=' ')",
  "def __init__(self, data = None, isNDR64=False, topLevel = False):\n        NDRSTRUCT.__init__(self,None, isNDR64=isNDR64)\n        # If we are being called from a NDRCALL, it's a TopLevelPointer,\n        # if not, it's a embeeded pointer.\n        # It is *very* important, for every subclass of NDRPointer\n        # you have to declare the referent in the referent variable\n        # Not in the structure one!\n        if topLevel is True:\n            self.structure = self.referent\n            self.referent = ()\n       \n        if data is None:\n            self.fields['ReferentID'] = random.randint(1,65535)\n        else:\n           self.fromString(data)",
  "def __setitem__(self, key, value):\n        if (key in self.fields) is False:\n            # Key not found.. let's send it to the referent to handle, maybe it's there\n            return self.fields['Data'].__setitem__(key,value)\n        else:\n            return NDRSTRUCT.__setitem__(self,key,value)",
  "def __getitem__(self, key):\n        if key in self.fields:\n            if isinstance(self.fields[key], NDR):\n                if 'Data' in self.fields[key].fields:\n                    return self.fields[key]['Data']\n            return self.fields[key]\n        else:\n            # Key not found, let's send it to the referent, maybe it's there\n            return self.fields['Data'].__getitem__(key)",
  "def getData(self, soFar = 0):\n        # First of all we need to align ourselves\n        data = b''\n        pad = self.calculatePad(self.commonHdr[0][1], soFar)\n        if pad > 0:\n            soFar += pad\n            data = b'\\xaa'*pad\n        # If we have a ReferentID == 0, means there's no data\n        if self.fields['ReferentID'] == 0:\n            if len(self.referent) > 0:\n                self['Data'] = b''\n            else:\n                if self._isNDR64 is True:\n                    return data+b'\\x00'*8\n                else:\n                    return data+b'\\x00'*4\n\n        return data + NDRSTRUCT.getData(self, soFar)",
  "def fromString(self, data, offset=0):\n        # First of all we need to align ourselves\n        pad = self.calculatePad(self.commonHdr[0][1], offset)\n        offset += pad\n\n        # Do we have a Referent ID == 0?\n        if self._isNDR64 is True:\n            unpackStr = '<Q'\n        else:\n            unpackStr = '<L'\n\n        if unpack_from(unpackStr, data, offset)[0] == 0:\n            # Let's save the value\n            self['ReferentID'] = 0\n            self.fields['Data'] = b''\n            if self._isNDR64 is True:\n                return pad + 8\n            else:\n                return pad + 4\n        else:\n            retVal = NDRSTRUCT.fromString(self, data, offset)\n            return retVal + pad",
  "def dump(self, msg = None, indent = 0):\n        if msg is None:\n            msg = self.__class__.__name__\n        if msg != '':\n            print(\"%s\" % msg, end=' ')\n        # Here we just print the referent\n        if isinstance(self.fields['Data'], NDR):\n            self.fields['Data'].dump('', indent = indent)\n        else:\n            if self['ReferentID'] == 0:\n                print(\" NULL\", end=' ')\n            else:\n                print(\" %r\" % (self['Data']), end=' ')",
  "def getAlignment(self):\n        if self._isNDR64 is True:\n            return 8\n        else:\n            return 4",
  "def __init__(self, data = None, isNDR64 = False, topLevel = False):\n        NDRPOINTER.__init__(self,data,isNDR64,topLevel)",
  "def __init__(self, data = None, isNDR64 = False):\n        self._isNDR64 = isNDR64\n        self.fields = {}\n\n        if isNDR64 is True:\n            if self.commonHdr64 != ():\n                self.commonHdr = self.commonHdr64\n            if self.structure64 != ():\n                self.structure = self.structure64\n            if hasattr(self, 'align64'):\n                self.align = self.align64\n\n        for fieldName, fieldTypeOrClass in self.commonHdr+self.structure+self.referent:\n            if self.isNDR(fieldTypeOrClass):\n               if self.isPointer(fieldTypeOrClass):\n                   self.fields[fieldName] = fieldTypeOrClass(isNDR64 = self._isNDR64, topLevel = True)\n               elif self.isUnion(fieldTypeOrClass):\n                   self.fields[fieldName] = fieldTypeOrClass(isNDR64 = self._isNDR64, topLevel = True)\n               else:\n                   self.fields[fieldName] = fieldTypeOrClass(isNDR64 = self._isNDR64)\n            elif fieldTypeOrClass == ':':\n               self.fields[fieldName] = None\n            elif len(fieldTypeOrClass.split('=')) == 2:\n               try:\n                   self.fields[fieldName] = eval(fieldTypeOrClass.split('=')[1])\n               except:\n                   self.fields[fieldName] = None\n            else:\n               self.fields[fieldName] = 0\n\n        if data is not None:\n            self.fromString(data)",
  "def dump(self, msg = None, indent = 0):\n        NDRCONSTRUCTEDTYPE.dump(self, msg, indent)\n        print('\\n\\n')",
  "def getData(self, soFar = 0):\n        data = b''\n        soFar0 = soFar\n        for fieldName, fieldTypeOrClass in self.commonHdr+self.structure:\n            try:\n                pad = self.calculatePad(fieldTypeOrClass, soFar)\n                if pad > 0:\n                    soFar += pad\n                    data += b'\\xab'*pad\n\n                # Are we dealing with an array?\n                if isinstance(self.fields[fieldName], NDRUniConformantArray) or isinstance(self.fields[fieldName],\n                              NDRUniConformantVaryingArray):\n                    # Align size item\n                    if self._isNDR64:\n                        pad = (8 - (soFar % 8)) % 8\n                    else:\n                        pad = (4 - (soFar % 4)) % 4\n                    # Pack the item\n                    res = self.pack(fieldName, fieldTypeOrClass, soFar+pad)\n                    # Yes, get the array size\n                    arraySize = self.getArrayMaximumSize(fieldName)\n                    if self._isNDR64:\n                        pad = (8 - (soFar % 8)) % 8\n                        data += b'\\xce'*pad + pack('<Q', arraySize) + res\n                    else:\n                        pad = (4 - (soFar % 4)) % 4\n                        data += b'\\xce'*pad + pack('<L', arraySize) + res\n                else:\n                    data += self.pack(fieldName, fieldTypeOrClass, soFar)\n\n                soFar = soFar0 + len(data)\n                # Any referent information to pack?\n                # I'm still not sure whether this should go after processing\n                # all the fields at the call level.\n                # Guess we'll figure it out testing.\n                if isinstance(self.fields[fieldName], NDRCONSTRUCTEDTYPE):\n                    data += self.fields[fieldName].getDataReferents(soFar)\n                    soFar = soFar0 + len(data)\n                    data += self.fields[fieldName].getDataReferent(soFar)\n                    soFar = soFar0 + len(data)\n            except Exception as e:\n                LOG.error(str(e))\n                LOG.error(\"Error packing field '%s | %s' in %s\" % (fieldName, fieldTypeOrClass, self.__class__))\n                raise\n\n        return data",
  "def fromString(self, data, offset=0):\n        offset0 = offset\n        for fieldName, fieldTypeOrClass in self.commonHdr+self.structure:\n            try:\n                # Are we dealing with an array?\n                if isinstance(self.fields[fieldName], NDRUniConformantArray) or isinstance(self.fields[fieldName],\n                              NDRUniConformantVaryingArray):\n                    # Yes, get the array size\n                    arraySize, advanceStream = self.getArraySize(fieldName, data, offset)\n                    self.fields[fieldName].setArraySize(arraySize)\n                    offset += advanceStream\n\n                size = self.unpack(fieldName, fieldTypeOrClass, data, offset)\n\n                # Any referent information to unpack?\n                if isinstance(self.fields[fieldName], NDRCONSTRUCTEDTYPE):\n                    size += self.fields[fieldName].fromStringReferents(data, offset+size)\n                    size += self.fields[fieldName].fromStringReferent(data, offset+size)\n                offset += size\n            except Exception as e:\n                LOG.error(str(e))\n                LOG.error(\"Error unpacking field '%s | %s | %r'\" % (fieldName, fieldTypeOrClass, data[offset:offset+256]))\n                raise\n\n        return offset - offset0",
  "class DCERPCSessionError(DCERPCException):\n    def __init__(self, error_string=None, error_code=None, packet=None):\n        DCERPCException.__init__(self, error_string, error_code, packet)\n\n    def __str__( self ):\n        key = self.error_code\n        if key in system_errors.ERROR_MESSAGES:\n            error_msg_short = system_errors.ERROR_MESSAGES[key][0]\n            error_msg_verbose = system_errors.ERROR_MESSAGES[key][1] \n            return 'WKST SessionError: code: 0x%x - %s - %s' % (self.error_code, error_msg_short, error_msg_verbose)\n        else:\n            return 'WKST SessionError: unknown error code: 0x%x' % self.error_code",
  "class WKSSVC_IDENTIFY_HANDLE(NDRSTRUCT):\n    structure =  (\n        ('Data', WSTR),\n    )",
  "class LPWKSSVC_IDENTIFY_HANDLE(NDRPOINTER):\n    referent = (\n        ('Data', WKSSVC_IDENTIFY_HANDLE),\n    )",
  "class WKSSVC_IMPERSONATE_HANDLE(NDRSTRUCT):\n    structure =  (\n        ('Data',WSTR),\n    )",
  "class LPWKSSVC_IMPERSONATE_HANDLE(NDRPOINTER):\n    referent = (\n        ('Data', WKSSVC_IMPERSONATE_HANDLE),\n    )",
  "class NETSETUP_JOIN_STATUS(NDRENUM):\n    class enumItems(Enum):\n        NetSetupUnknownStatus = 0\n        NetSetupUnjoined      = 1\n        NetSetupWorkgroupName = 2\n        NetSetupDomainName    = 3",
  "class NETSETUP_NAME_TYPE(NDRENUM):\n    class enumItems(Enum):\n        NetSetupUnknown           = 0\n        NetSetupMachine           = 1\n        NetSetupWorkgroup         = 2\n        NetSetupDomain            = 3\n        NetSetupNonExistentDomain = 4\n        NetSetupDnsMachine        = 5",
  "class NET_COMPUTER_NAME_TYPE(NDRENUM):\n    class enumItems(Enum):\n        NetPrimaryComputerName    = 0\n        NetAlternateComputerNames = 1\n        NetAllComputerNames       = 2\n        NetComputerNameTypeMax    = 3",
  "class WKSTA_INFO_100(NDRSTRUCT):\n    structure = (\n        ('wki100_platform_id', ULONG),\n        ('wki100_computername', LPWSTR),\n        ('wki100_langroup', LPWSTR),\n        ('wki100_ver_major', ULONG),\n        ('wki100_ver_minor', ULONG),\n    )",
  "class LPWKSTA_INFO_100(NDRPOINTER):\n    referent = (\n        ('Data', WKSTA_INFO_100),\n    )",
  "class WKSTA_INFO_101(NDRSTRUCT):\n    structure = (\n        ('wki101_platform_id', ULONG),\n        ('wki101_computername', LPWSTR),\n        ('wki101_langroup', LPWSTR),\n        ('wki101_ver_major', ULONG),\n        ('wki101_ver_minor', ULONG),\n        ('wki101_lanroot', LPWSTR),\n    )",
  "class LPWKSTA_INFO_101(NDRPOINTER):\n    referent = (\n        ('Data', WKSTA_INFO_101),\n    )",
  "class WKSTA_INFO_102(NDRSTRUCT):\n    structure = (\n        ('wki102_platform_id', ULONG),\n        ('wki102_computername', LPWSTR),\n        ('wki102_langroup', LPWSTR),\n        ('wki102_ver_major', ULONG),\n        ('wki102_ver_minor', ULONG),\n        ('wki102_lanroot', LPWSTR),\n        ('wki102_logged_on_users', ULONG),\n    )",
  "class LPWKSTA_INFO_102(NDRPOINTER):\n    referent = (\n        ('Data', WKSTA_INFO_102),\n    )",
  "class WKSTA_INFO_502(NDRSTRUCT):\n    structure = (\n        ('wki502_char_wait', ULONG),\n        ('wki502_collection_time', ULONG),\n        ('wki502_maximum_collection_count', ULONG),\n        ('wki502_keep_conn', ULONG),\n        ('wki502_max_cmds', ULONG),\n        ('wki502_sess_timeout', ULONG),\n        ('wki502_siz_char_buf', ULONG),\n        ('wki502_max_threads', ULONG),\n        ('wki502_lock_quota', ULONG),\n        ('wki502_lock_increment', ULONG),\n        ('wki502_lock_maximum', ULONG),\n        ('wki502_pipe_increment', ULONG),\n        ('wki502_pipe_maximum', ULONG),\n        ('wki502_cache_file_timeout', ULONG),\n        ('wki502_dormant_file_limit', ULONG),\n        ('wki502_read_ahead_throughput', ULONG),\n        ('wki502_num_mailslot_buffers', ULONG),\n        ('wki502_num_srv_announce_buffers', ULONG),\n        ('wki502_max_illegal_datagram_events', ULONG),\n        ('wki502_illegal_datagram_event_reset_frequency', ULONG),\n        ('wki502_log_election_packets', LONG),\n        ('wki502_use_opportunistic_locking', LONG),\n        ('wki502_use_unlock_behind', LONG),\n        ('wki502_use_close_behind', LONG),\n        ('wki502_buf_named_pipes', LONG),\n        ('wki502_use_lock_read_unlock', LONG),\n        ('wki502_utilize_nt_caching', LONG),\n        ('wki502_use_raw_read', LONG),\n        ('wki502_use_raw_write', LONG),\n        ('wki502_use_write_raw_data', LONG),\n        ('wki502_use_encryption', LONG),\n        ('wki502_buf_files_deny_write', LONG),\n        ('wki502_buf_read_only_files', LONG),\n        ('wki502_force_core_create_mode', LONG),\n        ('wki502_use_512_byte_max_transfer', LONG),\n    )",
  "class LPWKSTA_INFO_502(NDRPOINTER):\n    referent = (\n        ('Data', WKSTA_INFO_502),\n    )",
  "class WKSTA_INFO_1013(NDRSTRUCT):\n    structure = (\n        ('wki1013_keep_conn', ULONG),\n    )",
  "class LPWKSTA_INFO_1013(NDRPOINTER):\n    referent = (\n        ('Data', WKSTA_INFO_1013),\n    )",
  "class WKSTA_INFO_1018(NDRSTRUCT):\n    structure = (\n        ('wki1018_sess_timeout', ULONG),\n    )",
  "class LPWKSTA_INFO_1018(NDRPOINTER):\n    referent = (\n        ('Data', WKSTA_INFO_1018),\n    )",
  "class WKSTA_INFO_1046(NDRSTRUCT):\n    structure = (\n        ('wki1046_dormant_file_limit', ULONG),\n    )",
  "class LPWKSTA_INFO_1046(NDRPOINTER):\n    referent = (\n        ('Data', WKSTA_INFO_1046),\n    )",
  "class WKSTA_INFO(NDRUNION):\n    commonHdr = (\n        ('tag', ULONG),\n    )\n    union = {\n        100: ('WkstaInfo100', LPWKSTA_INFO_100),\n        101: ('WkstaInfo101', LPWKSTA_INFO_101),\n        102: ('WkstaInfo102', LPWKSTA_INFO_102),\n        502: ('WkstaInfo502', LPWKSTA_INFO_502),\n        1013: ('WkstaInfo1013', LPWKSTA_INFO_1013),\n        1018: ('WkstaInfo1018', LPWKSTA_INFO_1018),\n        1046: ('WkstaInfo1046', LPWKSTA_INFO_1046),\n    }",
  "class LPWKSTA_INFO(NDRPOINTER):\n    referent = (\n        ('Data', WKSTA_INFO),\n    )",
  "class WKSTA_TRANSPORT_INFO_0(NDRSTRUCT):\n    structure = (\n        ('wkti0_quality_of_service', ULONG),\n        ('wkti0_number_of_vcs', ULONG),\n        ('wkti0_transport_name', LPWSTR),\n        ('wkti0_transport_address', LPWSTR),\n        ('wkti0_wan_ish', ULONG),\n    )",
  "class WKSTA_USER_INFO_0(NDRSTRUCT):\n    structure = (\n        ('wkui0_username', LPWSTR),\n    )",
  "class WKSTA_USER_INFO_1(NDRSTRUCT):\n    structure = (\n        ('wkui1_username', LPWSTR),\n        ('wkui1_logon_domain', LPWSTR),\n        ('wkui1_oth_domains', LPWSTR),\n        ('wkui1_logon_server', LPWSTR),\n    )",
  "class STAT_WORKSTATION_0(NDRSTRUCT):\n    structure = (\n        ('StatisticsStartTime', LARGE_INTEGER),\n        ('BytesReceived', LARGE_INTEGER),\n        ('SmbsReceived', LARGE_INTEGER),\n        ('PagingReadBytesRequested', LARGE_INTEGER),\n        ('NonPagingReadBytesRequested', LARGE_INTEGER),\n        ('CacheReadBytesRequested', LARGE_INTEGER),\n        ('NetworkReadBytesRequested', LARGE_INTEGER),\n        ('BytesTransmitted', LARGE_INTEGER),\n        ('SmbsTransmitted', LARGE_INTEGER),\n        ('PagingWriteBytesRequested', LARGE_INTEGER),\n        ('NonPagingWriteBytesRequested', LARGE_INTEGER),\n        ('CacheWriteBytesRequested', LARGE_INTEGER),\n        ('NetworkWriteBytesRequested', LARGE_INTEGER),\n        ('InitiallyFailedOperations', ULONG),\n        ('FailedCompletionOperations', ULONG),\n        ('ReadOperations', ULONG),\n        ('RandomReadOperations', ULONG),\n        ('ReadSmbs', ULONG),\n        ('LargeReadSmbs', ULONG),\n        ('SmallReadSmbs', ULONG),\n        ('WriteOperations', ULONG),\n        ('RandomWriteOperations', ULONG),\n        ('WriteSmbs', ULONG),\n        ('LargeWriteSmbs', ULONG),\n        ('SmallWriteSmbs', ULONG),\n        ('RawReadsDenied', ULONG),\n        ('RawWritesDenied', ULONG),\n        ('NetworkErrors', ULONG),\n        ('Sessions', ULONG),\n        ('FailedSessions', ULONG),\n        ('Reconnects', ULONG),\n        ('CoreConnects', ULONG),\n        ('Lanman20Connects', ULONG),\n        ('Lanman21Connects', ULONG),\n        ('LanmanNtConnects', ULONG),\n        ('ServerDisconnects', ULONG),\n        ('HungSessions', ULONG),\n        ('UseCount', ULONG),\n        ('FailedUseCount', ULONG),\n        ('CurrentCommands', ULONG),\n    )",
  "class LPSTAT_WORKSTATION_0(NDRPOINTER):\n    referent = (\n        ('Data', STAT_WORKSTATION_0),\n    )",
  "class WKSTA_USER_INFO_0_ARRAY(NDRUniConformantArray):\n    item = WKSTA_USER_INFO_0",
  "class LPWKSTA_USER_INFO_0_ARRAY(NDRPOINTER):\n    referent = (\n        ('Data', WKSTA_USER_INFO_0_ARRAY),\n    )",
  "class WKSTA_USER_INFO_0_CONTAINER(NDRSTRUCT):\n    structure = (\n        ('EntriesRead', ULONG),\n        ('Buffer', LPWKSTA_USER_INFO_0_ARRAY),\n    )",
  "class LPWKSTA_USER_INFO_0_CONTAINER(NDRPOINTER):\n    referent = (\n        ('Data', WKSTA_USER_INFO_0_CONTAINER),\n    )",
  "class WKSTA_USER_INFO_1_ARRAY(NDRUniConformantArray):\n    item = WKSTA_USER_INFO_1",
  "class LPWKSTA_USER_INFO_1_ARRAY(NDRPOINTER):\n    referent = (\n        ('Data', WKSTA_USER_INFO_1_ARRAY),\n    )",
  "class WKSTA_USER_INFO_1_CONTAINER(NDRSTRUCT):\n    structure = (\n        ('EntriesRead', ULONG),\n        ('Buffer', LPWKSTA_USER_INFO_1_ARRAY),\n    )",
  "class LPWKSTA_USER_INFO_1_CONTAINER(NDRPOINTER):\n    referent = (\n        ('Data', WKSTA_USER_INFO_1_CONTAINER),\n    )",
  "class WKSTA_USER_ENUM_UNION(NDRUNION):\n    commonHdr = (\n        ('tag', ULONG),\n    )\n\n    union = {\n        0: ('Level0', LPWKSTA_USER_INFO_0_CONTAINER),\n        1: ('Level1', LPWKSTA_USER_INFO_1_CONTAINER),\n    }",
  "class WKSTA_USER_ENUM_STRUCT(NDRSTRUCT):\n    structure = (\n        ('Level', ULONG),\n        ('WkstaUserInfo', WKSTA_USER_ENUM_UNION),\n    )",
  "class WKSTA_TRANSPORT_INFO_0_ARRAY(NDRUniConformantArray):\n    item = WKSTA_TRANSPORT_INFO_0",
  "class LPWKSTA_TRANSPORT_INFO_0_ARRAY(NDRPOINTER):\n    referent = (\n        ('Data', WKSTA_TRANSPORT_INFO_0_ARRAY),\n    )",
  "class WKSTA_TRANSPORT_INFO_0_CONTAINER(NDRSTRUCT):\n    structure = (\n        ('EntriesRead', ULONG),\n        ('Buffer', LPWKSTA_TRANSPORT_INFO_0_ARRAY),\n    )",
  "class LPWKSTA_TRANSPORT_INFO_0_CONTAINER(NDRPOINTER):\n    referent = (\n        ('Data', WKSTA_TRANSPORT_INFO_0_CONTAINER),\n    )",
  "class WKSTA_TRANSPORT_ENUM_UNION(NDRUNION):\n    commonHdr = (\n        ('tag', ULONG),\n    )\n\n    union = {\n        0: ('Level0', LPWKSTA_TRANSPORT_INFO_0_CONTAINER),\n    }",
  "class WKSTA_TRANSPORT_ENUM_STRUCT(NDRSTRUCT):\n    structure = (\n        ('Level', ULONG),\n        ('WkstaTransportInfo', WKSTA_TRANSPORT_ENUM_UNION),\n    )",
  "class WCHAR_ARRAY(WIDESTR):\n    def getDataLen(self, data, offset=0):\n        return JOIN_MAX_PASSWORD_LENGTH",
  "class CHAR_ARRAY(NDRUniFixedArray):\n    def getDataLen(self, data, offset=0):\n        return JOIN_OBFUSCATOR_LENGTH",
  "class JOINPR_USER_PASSWORD(NDRSTRUCT):\n    structure = (\n        ('Obfuscator', CHAR_ARRAY),\n        ('Buffer', WCHAR_ARRAY),\n    )",
  "class JOINPR_ENCRYPTED_USER_PASSWORD(NDRSTRUCT):\n    structure = (\n        ('Buffer', '524s=b\"\"'),\n    )\n    def getAlignment(self):\n        return 1",
  "class PJOINPR_ENCRYPTED_USER_PASSWORD(NDRPOINTER):\n    referent = (\n        ('Data', JOINPR_ENCRYPTED_USER_PASSWORD),\n    )",
  "class PUNICODE_STRING(NDRPOINTER):\n    referent = (\n        ('Data', UNICODE_STRING),\n    )",
  "class UNICODE_STRING_ARRAY(NDRUniConformantArray):\n    item = RPC_UNICODE_STRING",
  "class PUNICODE_STRING_ARRAY(NDRPOINTER):\n    referent = (\n        ('Data', UNICODE_STRING_ARRAY),\n    )",
  "class NET_COMPUTER_NAME_ARRAY(NDRSTRUCT):\n    structure = (\n        ('EntriesRead', ULONG),\n        ('ComputerNames', PUNICODE_STRING_ARRAY),\n    )",
  "class PNET_COMPUTER_NAME_ARRAY(NDRPOINTER):\n    referent = (\n        ('Data', NET_COMPUTER_NAME_ARRAY), \n    )",
  "class USE_INFO_0(NDRSTRUCT):\n    structure = (\n        ('ui0_local', LPWSTR),\n        ('ui0_remote', LPWSTR),\n    )",
  "class LPUSE_INFO_0(NDRPOINTER):\n    referent = (\n        ('Data', USE_INFO_0),\n    )",
  "class USE_INFO_1(NDRSTRUCT):\n    structure = (\n        ('ui1_local', LPWSTR),\n        ('ui1_remote', LPWSTR),\n        ('ui1_password', LPWSTR),\n        ('ui1_status', ULONG),\n        ('ui1_asg_type', ULONG),\n        ('ui1_refcount', ULONG),\n        ('ui1_usecount', ULONG),\n    )",
  "class LPUSE_INFO_1(NDRPOINTER):\n    referent = (\n        ('Data', USE_INFO_1),\n    )",
  "class USE_INFO_2(NDRSTRUCT):\n    structure = (\n        ('ui2_useinfo', USE_INFO_1),\n        ('ui2_username', LPWSTR),\n        ('ui2_domainname', LPWSTR),\n    )",
  "class LPUSE_INFO_2(NDRPOINTER):\n    referent = (\n        ('Data', USE_INFO_2),\n    )",
  "class USE_INFO_3(NDRSTRUCT):\n    structure = (\n        ('ui3_ui2', USE_INFO_2),\n        ('ui3_flags', ULONG),\n    )",
  "class LPUSE_INFO_3(NDRPOINTER):\n    referent = (\n        ('Data', USE_INFO_3),\n    )",
  "class USE_INFO(NDRUNION):\n    commonHdr = (\n        ('tag', ULONG),\n    )\n\n    union = {\n        0: ('UseInfo0', LPUSE_INFO_0),\n        1: ('UseInfo1', LPUSE_INFO_1),\n        2: ('UseInfo2', LPUSE_INFO_2),\n        3: ('UseInfo3', LPUSE_INFO_3),\n    }",
  "class USE_INFO_0_CONTAINER(NDRSTRUCT):\n    structure = (\n        ('EntriesRead', ULONG),\n        ('Buffer', LPUSE_INFO_0),\n    )",
  "class LPUSE_INFO_0_CONTAINER(NDRPOINTER):\n    referent = (\n        ('Data', USE_INFO_0_CONTAINER),\n    )",
  "class USE_INFO_1_CONTAINER(NDRSTRUCT):\n    structure = (\n        ('EntriesRead', ULONG),\n        ('Buffer', LPUSE_INFO_1),\n    )",
  "class LPUSE_INFO_1_CONTAINER(NDRPOINTER):\n    referent = (\n        ('Data', USE_INFO_1_CONTAINER),\n    )",
  "class USE_INFO_2_CONTAINER(NDRSTRUCT):\n    structure = (\n        ('EntriesRead', ULONG),\n        ('Buffer', LPUSE_INFO_2),\n    )",
  "class LPUSE_INFO_2_CONTAINER(NDRPOINTER):\n    referent = (\n        ('Data', USE_INFO_2_CONTAINER),\n    )",
  "class USE_ENUM_UNION(NDRUNION):\n    commonHdr = (\n        ('tag', ULONG),\n    )\n\n    union = {\n        0: ('Level0', LPUSE_INFO_0_CONTAINER),\n        1: ('Level1', LPUSE_INFO_1_CONTAINER),\n        2: ('Level2', LPUSE_INFO_2_CONTAINER),\n    }",
  "class USE_ENUM_STRUCT(NDRSTRUCT):\n    structure = (\n        ('Level', ULONG),\n        ('UseInfo', USE_ENUM_UNION),\n    )",
  "class NetrWkstaGetInfo(NDRCALL):\n    opnum = 0\n    structure = (\n       ('ServerName', LPWKSSVC_IDENTIFY_HANDLE),\n       ('Level', ULONG),\n    )",
  "class NetrWkstaGetInfoResponse(NDRCALL):\n    structure = (\n       ('WkstaInfo',WKSTA_INFO),\n       ('ErrorCode',ULONG),\n    )",
  "class NetrWkstaSetInfo(NDRCALL):\n    opnum = 1\n    structure = (\n       ('ServerName', LPWKSSVC_IDENTIFY_HANDLE),\n       ('Level', ULONG),\n       ('WkstaInfo',WKSTA_INFO),\n       ('ErrorParameter',LPULONG),\n    )",
  "class NetrWkstaSetInfoResponse(NDRCALL):\n    structure = (\n       ('ErrorParameter',LPULONG),\n       ('ErrorCode',ULONG),\n    )",
  "class NetrWkstaUserEnum(NDRCALL):\n    opnum = 2\n    structure = (\n       ('ServerName', LPWKSSVC_IDENTIFY_HANDLE),\n       ('UserInfo', WKSTA_USER_ENUM_STRUCT),\n       ('PreferredMaximumLength', ULONG),\n       ('ResumeHandle', LPULONG),\n    )",
  "class NetrWkstaUserEnumResponse(NDRCALL):\n    structure = (\n       ('UserInfo',WKSTA_USER_ENUM_STRUCT),\n       ('TotalEntries',ULONG),\n       ('ResumeHandle',ULONG),\n       ('ErrorCode',ULONG),\n    )",
  "class NetrWkstaTransportEnum(NDRCALL):\n    opnum = 5\n    structure = (\n       ('ServerName', LPWKSSVC_IDENTIFY_HANDLE),\n       ('TransportInfo', WKSTA_TRANSPORT_ENUM_STRUCT),\n       ('PreferredMaximumLength', ULONG),\n       ('ResumeHandle', LPULONG),\n    )",
  "class NetrWkstaTransportEnumResponse(NDRCALL):\n    structure = (\n       ('TransportInfo',WKSTA_TRANSPORT_ENUM_STRUCT),\n       ('TotalEntries',ULONG),\n       ('ResumeHandle',ULONG),\n       ('ErrorCode',ULONG),\n    )",
  "class NetrWkstaTransportAdd(NDRCALL):\n    opnum = 6\n    structure = (\n       ('ServerName', LPWKSSVC_IDENTIFY_HANDLE),\n       ('Level', ULONG),\n       ('TransportInfo',WKSTA_TRANSPORT_INFO_0),\n       ('ErrorParameter',LPULONG),\n    )",
  "class NetrWkstaTransportAddResponse(NDRCALL):\n    structure = (\n       ('ErrorParameter',LPULONG),\n       ('ErrorCode',ULONG),\n    )",
  "class NetrUseAdd(NDRCALL):\n    opnum = 8\n    structure = (\n       ('ServerName', LPWKSSVC_IMPERSONATE_HANDLE),\n       ('Level', ULONG),\n       ('InfoStruct',USE_INFO),\n       ('ErrorParameter',LPULONG),\n    )",
  "class NetrUseAddResponse(NDRCALL):\n    structure = (\n       ('ErrorParameter',LPULONG),\n       ('ErrorCode',ULONG),\n    )",
  "class NetrUseGetInfo(NDRCALL):\n    opnum = 9\n    structure = (\n       ('ServerName', LPWKSSVC_IMPERSONATE_HANDLE),\n       ('UseName', WSTR),\n       ('Level',ULONG),\n    )",
  "class NetrUseGetInfoResponse(NDRCALL):\n    structure = (\n       ('InfoStruct',USE_INFO),\n       ('ErrorCode',ULONG),\n    )",
  "class NetrUseDel(NDRCALL):\n    opnum = 10\n    structure = (\n       ('ServerName', LPWKSSVC_IMPERSONATE_HANDLE),\n       ('UseName', WSTR),\n       ('ForceLevel',ULONG),\n    )",
  "class NetrUseDelResponse(NDRCALL):\n    structure = (\n       ('ErrorCode',ULONG),\n    )",
  "class NetrUseEnum(NDRCALL):\n    opnum = 11\n    structure = (\n       ('ServerName', LPWKSSVC_IMPERSONATE_HANDLE),\n       ('InfoStruct', USE_ENUM_STRUCT),\n       ('PreferredMaximumLength',ULONG),\n       ('ResumeHandle',LPULONG),\n    )",
  "class NetrUseEnumResponse(NDRCALL):\n    structure = (\n       ('InfoStruct',USE_ENUM_STRUCT),\n       ('TotalEntries',ULONG),\n       ('ResumeHandle',LPULONG),\n       ('ErrorCode',ULONG),\n    )",
  "class NetrWorkstationStatisticsGet(NDRCALL):\n    opnum = 13\n    structure = (\n       ('ServerName', LPWKSSVC_IDENTIFY_HANDLE),\n       ('ServiceName', LPWSTR),\n       ('Level',ULONG),\n       ('Options',ULONG),\n    )",
  "class NetrWorkstationStatisticsGetResponse(NDRCALL):\n    structure = (\n       ('Buffer',LPSTAT_WORKSTATION_0),\n       ('ErrorCode',ULONG),\n    )",
  "class NetrGetJoinInformation(NDRCALL):\n    opnum = 20\n    structure = (\n       ('ServerName', LPWKSSVC_IMPERSONATE_HANDLE),\n       ('NameBuffer', LPWSTR),\n    )",
  "class NetrGetJoinInformationResponse(NDRCALL):\n    structure = (\n       ('NameBuffer',LPWSTR),\n       ('BufferType',NETSETUP_JOIN_STATUS),\n       ('ErrorCode',ULONG),\n    )",
  "class NetrJoinDomain2(NDRCALL):\n    opnum = 22\n    structure = (\n       ('ServerName', LPWSTR),\n       ('DomainNameParam', WSTR),\n       ('MachineAccountOU', LPWSTR),\n       ('AccountName', LPWSTR),\n       ('Password', PJOINPR_ENCRYPTED_USER_PASSWORD),\n       ('Options', ULONG),\n    )",
  "class NetrJoinDomain2Response(NDRCALL):\n    structure = (\n       ('ErrorCode',ULONG),\n    )",
  "class NetrUnjoinDomain2(NDRCALL):\n    opnum = 23\n    structure = (\n       ('ServerName', LPWSTR),\n       ('AccountName', LPWSTR),\n       ('Password', PJOINPR_ENCRYPTED_USER_PASSWORD),\n       ('Options', ULONG),\n    )",
  "class NetrUnjoinDomain2Response(NDRCALL):\n    structure = (\n       ('ErrorCode',ULONG),\n    )",
  "class NetrRenameMachineInDomain2(NDRCALL):\n    opnum = 24\n    structure = (\n       ('ServerName', LPWSTR),\n       ('MachineName', LPWSTR),\n       ('AccountName', LPWSTR),\n       ('Password', PJOINPR_ENCRYPTED_USER_PASSWORD),\n       ('Options', ULONG),\n    )",
  "class NetrRenameMachineInDomain2Response(NDRCALL):\n    structure = (\n       ('ErrorCode',ULONG),\n    )",
  "class NetrValidateName2(NDRCALL):\n    opnum = 25\n    structure = (\n       ('ServerName', LPWSTR),\n       ('NameToValidate', WSTR),\n       ('AccountName', LPWSTR),\n       ('Password', PJOINPR_ENCRYPTED_USER_PASSWORD),\n       ('NameType', NETSETUP_NAME_TYPE),\n    )",
  "class NetrValidateName2Response(NDRCALL):\n    structure = (\n       ('ErrorCode',ULONG),\n    )",
  "class NetrGetJoinableOUs2(NDRCALL):\n    opnum = 26\n    structure = (\n       ('ServerName', LPWSTR),\n       ('DomainNameParam', WSTR),\n       ('AccountName', LPWSTR),\n       ('Password', PJOINPR_ENCRYPTED_USER_PASSWORD),\n       ('OUCount', ULONG),\n    )",
  "class NetrGetJoinableOUs2Response(NDRCALL):\n    structure = (\n       ('OUCount', LPLONG),\n       ('OUs',PUNICODE_STRING_ARRAY),\n       ('ErrorCode',ULONG),\n    )",
  "class NetrAddAlternateComputerName(NDRCALL):\n    opnum = 27\n    structure = (\n       ('ServerName', LPWSTR),\n       ('AlternateName', LPWSTR),\n       ('DomainAccount', LPWSTR),\n       ('EncryptedPassword', PJOINPR_ENCRYPTED_USER_PASSWORD),\n       ('Reserved', ULONG),\n    )",
  "class NetrAddAlternateComputerNameResponse(NDRCALL):\n    structure = (\n       ('ErrorCode',ULONG),\n    )",
  "class NetrRemoveAlternateComputerName(NDRCALL):\n    opnum = 28\n    structure = (\n       ('ServerName', LPWSTR),\n       ('AlternateName', LPWSTR),\n       ('DomainAccount', LPWSTR),\n       ('EncryptedPassword', PJOINPR_ENCRYPTED_USER_PASSWORD),\n       ('Reserved', ULONG),\n    )",
  "class NetrRemoveAlternateComputerNameResponse(NDRCALL):\n    structure = (\n       ('ErrorCode',ULONG),\n    )",
  "class NetrSetPrimaryComputerName(NDRCALL):\n    opnum = 29\n    structure = (\n       ('ServerName', LPWSTR),\n       ('PrimaryName', LPWSTR),\n       ('DomainAccount', LPWSTR),\n       ('EncryptedPassword', PJOINPR_ENCRYPTED_USER_PASSWORD),\n       ('Reserved', ULONG),\n    )",
  "class NetrSetPrimaryComputerNameResponse(NDRCALL):\n    structure = (\n       ('ErrorCode',ULONG),\n    )",
  "class NetrEnumerateComputerNames(NDRCALL):\n    opnum = 30\n    structure = (\n       ('ServerName', LPWKSSVC_IMPERSONATE_HANDLE),\n       ('NameType', NET_COMPUTER_NAME_TYPE),\n       ('Reserved', ULONG),\n    )",
  "class NetrEnumerateComputerNamesResponse(NDRCALL):\n    structure = (\n       ('ComputerNames',PNET_COMPUTER_NAME_ARRAY),\n       ('ErrorCode',ULONG),\n    )",
  "def checkNullString(string):\n    if string == NULL:\n        return string\n\n    if string[-1:] != '\\x00':\n        return string + '\\x00'\n    else:\n        return string",
  "def hNetrWkstaGetInfo(dce, level):\n    request = NetrWkstaGetInfo()\n    request['ServerName'] = '\\x00'*10\n    request['Level'] = level\n    return dce.request(request)",
  "def hNetrWkstaUserEnum(dce, level, preferredMaximumLength=0xffffffff):\n    request = NetrWkstaUserEnum()\n    request['ServerName'] = '\\x00'*10\n    request['UserInfo']['Level'] = level\n    request['UserInfo']['WkstaUserInfo']['tag'] = level\n    request['PreferredMaximumLength'] = preferredMaximumLength\n    return dce.request(request)",
  "def hNetrWkstaTransportEnum(dce, level, resumeHandle = 0, preferredMaximumLength = 0xffffffff):\n    request = NetrWkstaTransportEnum()\n    request['ServerName'] = '\\x00'*10\n    request['TransportInfo']['Level'] = level\n    request['TransportInfo']['WkstaTransportInfo']['tag'] = level\n    request['ResumeHandle'] = resumeHandle\n    request['PreferredMaximumLength'] = preferredMaximumLength\n    return dce.request(request)",
  "def hNetrWkstaSetInfo(dce, level, wkstInfo):\n    request = NetrWkstaSetInfo()\n    request['ServerName'] = '\\x00'*10\n    request['Level'] = level\n    request['WkstaInfo']['tag'] = level\n    request['WkstaInfo']['WkstaInfo%d'% level] = wkstInfo\n    return dce.request(request)",
  "def hNetrWorkstationStatisticsGet(dce, serviceName, level, options):\n    request = NetrWorkstationStatisticsGet()\n    request['ServerName'] = '\\x00'*10\n    request['ServiceName'] = serviceName\n    request['Level'] = level\n    request['Options'] = options\n    return dce.request(request)",
  "def hNetrGetJoinInformation(dce, nameBuffer):\n    request = NetrGetJoinInformation()\n    request['ServerName'] = '\\x00'*10\n    request['NameBuffer'] = nameBuffer\n    return dce.request(request)",
  "def hNetrJoinDomain2(dce, domainNameParam, machineAccountOU, accountName, password, options):\n    request = NetrJoinDomain2()\n    request['ServerName'] = '\\x00'*10\n    request['DomainNameParam'] = checkNullString(domainNameParam)\n    request['MachineAccountOU'] = checkNullString(machineAccountOU)\n    request['AccountName'] = checkNullString(accountName)\n    if password == NULL:\n        request['Password'] = NULL\n    else:\n        request['Password']['Buffer'] = password\n    request['Options'] = options\n    return dce.request(request)",
  "def hNetrUnjoinDomain2(dce, accountName, password, options):\n    request = NetrUnjoinDomain2()\n    request['ServerName'] = '\\x00'*10\n    request['AccountName'] = checkNullString(accountName)\n    if password == NULL:\n        request['Password'] = NULL\n    else:\n        request['Password']['Buffer'] = password\n    request['Options'] = options\n    return dce.request(request)",
  "def hNetrRenameMachineInDomain2(dce, machineName, accountName, password, options):\n    request = NetrRenameMachineInDomain2()\n    request['ServerName'] = '\\x00'*10\n    request['MachineName'] = checkNullString(machineName)\n    request['AccountName'] = checkNullString(accountName)\n    if password == NULL:\n        request['Password'] = NULL\n    else:\n        request['Password']['Buffer'] = password\n    request['Options'] = options\n    return dce.request(request)",
  "def hNetrValidateName2(dce, nameToValidate, accountName, password, nameType):\n    request = NetrValidateName2()\n    request['ServerName'] = '\\x00'*10\n    request['NameToValidate'] = checkNullString(nameToValidate)\n    request['AccountName'] = checkNullString(accountName)\n    if password == NULL:\n        request['Password'] = NULL\n    else:\n        request['Password']['Buffer'] = password\n    request['NameType'] = nameType\n    return dce.request(request)",
  "def hNetrGetJoinableOUs2(dce, domainNameParam, accountName, password, OUCount):\n    request = NetrGetJoinableOUs2()\n    request['ServerName'] = '\\x00'*10\n    request['DomainNameParam'] = checkNullString(domainNameParam)\n    request['AccountName'] = checkNullString(accountName)\n    if password == NULL:\n        request['Password'] = NULL\n    else:\n        request['Password']['Buffer'] = password\n    request['OUCount'] = OUCount\n    return dce.request(request)",
  "def hNetrAddAlternateComputerName(dce, alternateName, domainAccount, encryptedPassword):\n    request = NetrAddAlternateComputerName()\n    request['ServerName'] = '\\x00'*10\n    request['AlternateName'] = checkNullString(alternateName)\n    request['DomainAccount'] = checkNullString(domainAccount)\n    if encryptedPassword == NULL:\n        request['EncryptedPassword'] = NULL\n    else:\n        request['EncryptedPassword']['Buffer'] = encryptedPassword\n    return dce.request(request)",
  "def hNetrRemoveAlternateComputerName(dce, alternateName, domainAccount, encryptedPassword):\n    request = NetrRemoveAlternateComputerName()\n    request['ServerName'] = '\\x00'*10\n    request['AlternateName'] = checkNullString(alternateName)\n    request['DomainAccount'] = checkNullString(domainAccount)\n    if encryptedPassword == NULL:\n        request['EncryptedPassword'] = NULL\n    else:\n        request['EncryptedPassword']['Buffer'] = encryptedPassword\n    return dce.request(request)",
  "def hNetrSetPrimaryComputerName(dce, primaryName, domainAccount, encryptedPassword):\n    request = NetrSetPrimaryComputerName()\n    request['ServerName'] = '\\x00'*10\n    request['PrimaryName'] = checkNullString(primaryName)\n    request['DomainAccount'] = checkNullString(domainAccount)\n    if encryptedPassword == NULL:\n        request['EncryptedPassword'] = NULL\n    else:\n        request['EncryptedPassword']['Buffer'] = encryptedPassword\n    return dce.request(request)",
  "def hNetrEnumerateComputerNames(dce, nameType):\n    request = NetrEnumerateComputerNames()\n    request['ServerName'] = '\\x00'*10\n    request['NameType'] = nameType\n    return dce.request(request)",
  "def hNetrUseAdd(dce, level, infoStruct):\n    request = NetrUseAdd()\n    request['ServerName'] = '\\x00'*10\n    request['Level'] = level\n    request['InfoStruct']['tag'] = level\n    request['InfoStruct']['UseInfo%d' % level] = infoStruct\n    return dce.request(request)",
  "def hNetrUseEnum(dce, level, resumeHandle = 0, preferredMaximumLength = 0xffffffff):\n    request = NetrUseEnum()\n    request['ServerName'] = '\\x00'*10\n    request['InfoStruct']['Level'] = level\n    request['InfoStruct']['UseInfo']['tag'] = level\n    request['InfoStruct']['UseInfo']['Level%d'%level]['Buffer'] = NULL\n    request['PreferredMaximumLength'] = preferredMaximumLength\n    request['ResumeHandle'] = resumeHandle\n    return dce.request(request)",
  "def hNetrUseGetInfo(dce, useName, level):\n    request = NetrUseGetInfo()\n    request['ServerName'] = '\\x00'*10\n    request['UseName'] = checkNullString(useName)\n    request['Level'] = level\n    return dce.request(request)",
  "def hNetrUseDel(dce, useName, forceLevel=USE_LOTS_OF_FORCE):\n    request = NetrUseDel()\n    request['ServerName'] = '\\x00'*10\n    request['UseName'] = checkNullString(useName)\n    request['ForceLevel'] = forceLevel\n    return dce.request(request)",
  "def __init__(self, error_string=None, error_code=None, packet=None):\n        DCERPCException.__init__(self, error_string, error_code, packet)",
  "def __str__( self ):\n        key = self.error_code\n        if key in system_errors.ERROR_MESSAGES:\n            error_msg_short = system_errors.ERROR_MESSAGES[key][0]\n            error_msg_verbose = system_errors.ERROR_MESSAGES[key][1] \n            return 'WKST SessionError: code: 0x%x - %s - %s' % (self.error_code, error_msg_short, error_msg_verbose)\n        else:\n            return 'WKST SessionError: unknown error code: 0x%x' % self.error_code",
  "class enumItems(Enum):\n        NetSetupUnknownStatus = 0\n        NetSetupUnjoined      = 1\n        NetSetupWorkgroupName = 2\n        NetSetupDomainName    = 3",
  "class enumItems(Enum):\n        NetSetupUnknown           = 0\n        NetSetupMachine           = 1\n        NetSetupWorkgroup         = 2\n        NetSetupDomain            = 3\n        NetSetupNonExistentDomain = 4\n        NetSetupDnsMachine        = 5",
  "class enumItems(Enum):\n        NetPrimaryComputerName    = 0\n        NetAlternateComputerNames = 1\n        NetAllComputerNames       = 2\n        NetComputerNameTypeMax    = 3",
  "def getDataLen(self, data, offset=0):\n        return JOIN_MAX_PASSWORD_LENGTH",
  "def getDataLen(self, data, offset=0):\n        return JOIN_OBFUSCATOR_LENGTH",
  "def getAlignment(self):\n        return 1",
  "class DCERPCSessionError(DCERPCException):\n    def __init__(self, error_string=None, error_code=None, packet=None):\n        DCERPCException.__init__(self, error_string, error_code, packet)\n\n    def __str__( self ):\n        key = self.error_code\n        if key in nt_errors.ERROR_MESSAGES:\n            error_msg_short = nt_errors.ERROR_MESSAGES[key][0]\n            error_msg_verbose = nt_errors.ERROR_MESSAGES[key][1]\n            return 'SAMR SessionError: code: 0x%x - %s - %s' % (self.error_code, error_msg_short, error_msg_verbose)\n        else:\n            return 'SAMR SessionError: unknown error code: 0x%x' % self.error_code",
  "class RPC_UNICODE_STRING_ARRAY(NDRUniConformantVaryingArray):\n    item = RPC_UNICODE_STRING",
  "class RPC_UNICODE_STRING_ARRAY_C(NDRUniConformantArray):\n    item = RPC_UNICODE_STRING",
  "class PRPC_UNICODE_STRING_ARRAY(NDRPOINTER):\n    referent = (\n        ('Data',RPC_UNICODE_STRING_ARRAY_C),\n    )",
  "class RPC_STRING(NDRSTRUCT):\n    commonHdr = (\n        ('MaximumLength','<H=len(Data)-12'),\n        ('Length','<H=len(Data)-12'),\n        ('ReferentID','<L=0xff'),\n    )\n    commonHdr64 = (\n        ('MaximumLength','<H=len(Data)-24'),\n        ('Length','<H=len(Data)-24'),\n        ('ReferentID','<Q=0xff'),\n    )\n\n    referent = (\n        ('Data',STR),\n    )\n\n    def dump(self, msg = None, indent = 0):\n        if msg is None:\n            msg = self.__class__.__name__\n        if msg != '':\n            print(\"%s\" % msg, end=' ')\n        # Here just print the data\n        print(\" %r\" % (self['Data']), end=' ')",
  "class PRPC_STRING(NDRPOINTER):\n    referent = (\n        ('Data', RPC_STRING),\n    )",
  "class OLD_LARGE_INTEGER(NDRSTRUCT):\n    structure = (\n        ('LowPart',ULONG),\n        ('HighPart',LONG),\n    )",
  "class SID_NAME_USE(NDRENUM):\n    class enumItems(Enum):\n        SidTypeUser            = 1\n        SidTypeGroup           = 2\n        SidTypeDomain          = 3\n        SidTypeAlias           = 4\n        SidTypeWellKnownGroup  = 5\n        SidTypeDeletedAccount  = 6\n        SidTypeInvalid         = 7\n        SidTypeUnknown         = 8\n        SidTypeComputer        = 9\n        SidTypeLabel           = 10",
  "class USHORT_ARRAY(NDRUniConformantVaryingArray):\n    item = '<H'\n    pass",
  "class PUSHORT_ARRAY(NDRPOINTER):\n    referent = (\n        ('Data', USHORT_ARRAY),\n    )",
  "class RPC_SHORT_BLOB(NDRSTRUCT):\n    structure = (\n        ('Length', USHORT),\n        ('MaximumLength', USHORT),\n        ('Buffer',PUSHORT_ARRAY),\n    )",
  "class SAMPR_HANDLE(NDRSTRUCT):\n    structure =  (\n        ('Data','20s=b\"\"'),\n    )\n    def getAlignment(self):\n        if self._isNDR64 is True:\n            return 8\n        else:\n            return 4",
  "class ENCRYPTED_LM_OWF_PASSWORD(NDRSTRUCT):\n    structure = (\n        ('Data', '16s=b\"\"'),\n    )\n    def getAlignment(self):\n        return 1",
  "class PENCRYPTED_LM_OWF_PASSWORD(NDRPOINTER):\n    referent = (\n        ('Data', ENCRYPTED_LM_OWF_PASSWORD),\n    )",
  "class ULONG_ARRAY(NDRUniConformantArray):\n    item = ULONG",
  "class PULONG_ARRAY(NDRPOINTER):\n    referent = (\n        ('Data', ULONG_ARRAY),\n    )",
  "class ULONG_ARRAY_CV(NDRUniConformantVaryingArray):\n    item = ULONG",
  "class SAMPR_ULONG_ARRAY(NDRSTRUCT):\n    structure = (\n        ('Count', ULONG),\n        ('Element', PULONG_ARRAY),\n    )",
  "class SAMPR_SID_INFORMATION(NDRSTRUCT):\n    structure = (\n        ('SidPointer', RPC_SID),\n    )",
  "class PSAMPR_SID_INFORMATION(NDRPOINTER):\n    referent = (\n        ('Data', SAMPR_SID_INFORMATION),\n    )",
  "class SAMPR_SID_INFORMATION_ARRAY(NDRUniConformantArray):\n    item = PSAMPR_SID_INFORMATION",
  "class PSAMPR_SID_INFORMATION_ARRAY(NDRPOINTER):\n    referent = (\n        ('Data', SAMPR_SID_INFORMATION_ARRAY),\n    )",
  "class SAMPR_PSID_ARRAY(NDRSTRUCT):\n    structure = (\n        ('Count', ULONG),\n        ('Sids', PSAMPR_SID_INFORMATION_ARRAY),\n    )",
  "class SAMPR_PSID_ARRAY_OUT(NDRSTRUCT):\n    structure = (\n        ('Count', ULONG),\n        ('Sids', PSAMPR_SID_INFORMATION_ARRAY),\n    )",
  "class SAMPR_RETURNED_USTRING_ARRAY(NDRSTRUCT):\n    structure = (\n        ('Count', ULONG),\n        ('Element', PRPC_UNICODE_STRING_ARRAY),\n    )",
  "class SAMPR_RID_ENUMERATION(NDRSTRUCT):\n    structure = (\n        ('RelativeId',ULONG),\n        ('Name',RPC_UNICODE_STRING),\n    )",
  "class SAMPR_RID_ENUMERATION_ARRAY(NDRUniConformantArray):\n    item = SAMPR_RID_ENUMERATION",
  "class PSAMPR_RID_ENUMERATION_ARRAY(NDRPOINTER):\n    referent = (\n        ('Data', SAMPR_RID_ENUMERATION_ARRAY),\n    )",
  "class SAMPR_ENUMERATION_BUFFER(NDRSTRUCT):\n    structure = (\n        ('EntriesRead',ULONG ),\n        ('Buffer',PSAMPR_RID_ENUMERATION_ARRAY ),\n    )",
  "class PSAMPR_ENUMERATION_BUFFER(NDRPOINTER):\n    referent = (\n        ('Data',SAMPR_ENUMERATION_BUFFER),\n    )",
  "class CHAR_ARRAY(NDRUniConformantArray):\n    pass",
  "class PCHAR_ARRAY(NDRPOINTER):\n    referent = (\n        ('Data', CHAR_ARRAY),\n    )",
  "class SAMPR_SR_SECURITY_DESCRIPTOR(NDRSTRUCT):\n    structure = (\n        ('Length', ULONG),\n        ('SecurityDescriptor', PCHAR_ARRAY),\n    )",
  "class PSAMPR_SR_SECURITY_DESCRIPTOR(NDRPOINTER):\n    referent = (\n        ('Data', SAMPR_SR_SECURITY_DESCRIPTOR),\n    )",
  "class GROUP_MEMBERSHIP(NDRSTRUCT):\n    structure = (\n        ('RelativeId',ULONG),\n        ('Attributes',ULONG),\n    )",
  "class GROUP_MEMBERSHIP_ARRAY(NDRUniConformantArray):\n    item = GROUP_MEMBERSHIP",
  "class PGROUP_MEMBERSHIP_ARRAY(NDRPOINTER):\n    referent = (\n        ('Data',GROUP_MEMBERSHIP_ARRAY),\n    )",
  "class SAMPR_GET_GROUPS_BUFFER(NDRSTRUCT):\n    structure = (\n        ('MembershipCount',ULONG),\n        ('Groups',PGROUP_MEMBERSHIP_ARRAY),\n    )",
  "class PSAMPR_GET_GROUPS_BUFFER(NDRPOINTER):\n    referent = (\n        ('Data',SAMPR_GET_GROUPS_BUFFER),\n    )",
  "class SAMPR_GET_MEMBERS_BUFFER(NDRSTRUCT):\n    structure = (\n        ('MemberCount', ULONG),\n        ('Members', PULONG_ARRAY),\n        ('Attributes', PULONG_ARRAY),\n    )",
  "class PSAMPR_GET_MEMBERS_BUFFER(NDRPOINTER):\n    referent = (\n        ('Data', SAMPR_GET_MEMBERS_BUFFER),\n    )",
  "class SAMPR_REVISION_INFO_V1(NDRSTRUCT):\n    structure = (\n       ('Revision',ULONG),\n       ('SupportedFeatures',ULONG),\n    )",
  "class SAMPR_REVISION_INFO(NDRUNION):\n    commonHdr = (\n        ('tag', ULONG),\n    )\n\n    union = {\n        1: ('V1', SAMPR_REVISION_INFO_V1),\n    }",
  "class USER_DOMAIN_PASSWORD_INFORMATION(NDRSTRUCT):\n    structure = (\n        ('MinPasswordLength', USHORT),\n        ('PasswordProperties', ULONG),\n    )",
  "class DOMAIN_SERVER_ENABLE_STATE(NDRENUM):\n    class enumItems(Enum):\n        DomainServerEnabled  = 1\n        DomainServerDisabled = 2",
  "class DOMAIN_STATE_INFORMATION(NDRSTRUCT):\n    structure = (\n        ('DomainServerState', DOMAIN_SERVER_ENABLE_STATE),\n    )",
  "class DOMAIN_SERVER_ROLE(NDRENUM):\n    class enumItems(Enum):\n        DomainServerRoleBackup  = 2\n        DomainServerRolePrimary = 3",
  "class DOMAIN_PASSWORD_INFORMATION(NDRSTRUCT):\n    structure = (\n        ('MinPasswordLength', USHORT),\n        ('PasswordHistoryLength', USHORT),\n        ('PasswordProperties', ULONG),\n        ('MaxPasswordAge', OLD_LARGE_INTEGER),\n        ('MinPasswordAge', OLD_LARGE_INTEGER),\n    )",
  "class DOMAIN_LOGOFF_INFORMATION(NDRSTRUCT):\n    structure = (\n        ('ForceLogoff', OLD_LARGE_INTEGER),\n    )",
  "class DOMAIN_SERVER_ROLE_INFORMATION(NDRSTRUCT):\n    structure = (\n        ('DomainServerRole', DOMAIN_SERVER_ROLE),\n    )",
  "class DOMAIN_MODIFIED_INFORMATION(NDRSTRUCT):\n    structure = (\n        ('DomainModifiedCount', OLD_LARGE_INTEGER),\n        ('CreationTime', OLD_LARGE_INTEGER),\n    )",
  "class DOMAIN_MODIFIED_INFORMATION2(NDRSTRUCT):\n    structure = (\n        ('DomainModifiedCount', OLD_LARGE_INTEGER),\n        ('CreationTime', OLD_LARGE_INTEGER),\n        ('ModifiedCountAtLastPromotion', OLD_LARGE_INTEGER),\n    )",
  "class SAMPR_DOMAIN_GENERAL_INFORMATION(NDRSTRUCT):\n    structure = (\n        ('ForceLogoff', OLD_LARGE_INTEGER),\n        ('OemInformation', RPC_UNICODE_STRING),\n        ('DomainName', RPC_UNICODE_STRING),\n        ('ReplicaSourceNodeName', RPC_UNICODE_STRING),\n        ('DomainModifiedCount', OLD_LARGE_INTEGER),\n        ('DomainServerState', ULONG),\n        ('DomainServerRole', ULONG),\n        ('UasCompatibilityRequired', UCHAR),\n        ('UserCount', ULONG),\n        ('GroupCount', ULONG),\n        ('AliasCount', ULONG),\n    )",
  "class SAMPR_DOMAIN_GENERAL_INFORMATION2(NDRSTRUCT):\n    structure = (\n        ('I1', SAMPR_DOMAIN_GENERAL_INFORMATION),\n        ('LockoutDuration', LARGE_INTEGER),\n        ('LockoutObservationWindow', LARGE_INTEGER),\n        ('LockoutThreshold', USHORT),\n    )",
  "class SAMPR_DOMAIN_OEM_INFORMATION(NDRSTRUCT):\n    structure = (\n        ('OemInformation', RPC_UNICODE_STRING),\n    )",
  "class SAMPR_DOMAIN_NAME_INFORMATION(NDRSTRUCT):\n    structure = (\n        ('DomainName', RPC_UNICODE_STRING),\n    )",
  "class SAMPR_DOMAIN_REPLICATION_INFORMATION(NDRSTRUCT):\n    structure = (\n        ('ReplicaSourceNodeName', RPC_UNICODE_STRING),\n    )",
  "class SAMPR_DOMAIN_LOCKOUT_INFORMATION(NDRSTRUCT):\n    structure = (\n        ('LockoutDuration', LARGE_INTEGER),\n        ('LockoutObservationWindow', LARGE_INTEGER),\n        ('LockoutThreshold', USHORT),\n    )",
  "class DOMAIN_INFORMATION_CLASS(NDRENUM):\n    class enumItems(Enum):\n        DomainPasswordInformation    = 1\n        DomainGeneralInformation     = 2\n        DomainLogoffInformation      = 3\n        DomainOemInformation         = 4\n        DomainNameInformation        = 5\n        DomainReplicationInformation = 6\n        DomainServerRoleInformation  = 7\n        DomainModifiedInformation    = 8\n        DomainStateInformation       = 9\n        DomainGeneralInformation2    = 11\n        DomainLockoutInformation     = 12\n        DomainModifiedInformation2   = 13",
  "class SAMPR_DOMAIN_INFO_BUFFER(NDRUNION):\n    union = {\n        DOMAIN_INFORMATION_CLASS.DomainPasswordInformation    : ('Password', DOMAIN_PASSWORD_INFORMATION),\n        DOMAIN_INFORMATION_CLASS.DomainGeneralInformation     : ('General', SAMPR_DOMAIN_GENERAL_INFORMATION),\n        DOMAIN_INFORMATION_CLASS.DomainLogoffInformation      : ('Logoff', DOMAIN_LOGOFF_INFORMATION),\n        DOMAIN_INFORMATION_CLASS.DomainOemInformation         : ('Oem', SAMPR_DOMAIN_OEM_INFORMATION),\n        DOMAIN_INFORMATION_CLASS.DomainNameInformation        : ('Name', SAMPR_DOMAIN_NAME_INFORMATION),\n        DOMAIN_INFORMATION_CLASS.DomainServerRoleInformation  : ('Role', DOMAIN_SERVER_ROLE_INFORMATION),\n        DOMAIN_INFORMATION_CLASS.DomainReplicationInformation : ('Replication', SAMPR_DOMAIN_REPLICATION_INFORMATION),\n        DOMAIN_INFORMATION_CLASS.DomainModifiedInformation    : ('Modified', DOMAIN_MODIFIED_INFORMATION),\n        DOMAIN_INFORMATION_CLASS.DomainStateInformation       : ('State', DOMAIN_STATE_INFORMATION),\n        DOMAIN_INFORMATION_CLASS.DomainGeneralInformation2    : ('General2', SAMPR_DOMAIN_GENERAL_INFORMATION2),\n        DOMAIN_INFORMATION_CLASS.DomainLockoutInformation     : ('Lockout', SAMPR_DOMAIN_LOCKOUT_INFORMATION),\n        DOMAIN_INFORMATION_CLASS.DomainModifiedInformation2   : ('Modified2', DOMAIN_MODIFIED_INFORMATION2),\n    }",
  "class PSAMPR_DOMAIN_INFO_BUFFER(NDRPOINTER):\n    referent = (\n        ('Data', SAMPR_DOMAIN_INFO_BUFFER),\n    )",
  "class GROUP_ATTRIBUTE_INFORMATION(NDRSTRUCT):\n    structure = (\n        ('Attributes', ULONG),\n    )",
  "class SAMPR_GROUP_GENERAL_INFORMATION(NDRSTRUCT):\n    structure = (\n        ('Name', RPC_UNICODE_STRING),\n        ('Attributes', ULONG),\n        ('MemberCount', ULONG),\n        ('AdminComment', RPC_UNICODE_STRING),\n    )",
  "class SAMPR_GROUP_NAME_INFORMATION(NDRSTRUCT):\n    structure = (\n        ('Name', RPC_UNICODE_STRING),\n    )",
  "class SAMPR_GROUP_ADM_COMMENT_INFORMATION(NDRSTRUCT):\n    structure = (\n        ('AdminComment', RPC_UNICODE_STRING),\n    )",
  "class GROUP_INFORMATION_CLASS(NDRENUM):\n    class enumItems(Enum):\n        GroupGeneralInformation      = 1\n        GroupNameInformation         = 2\n        GroupAttributeInformation    = 3\n        GroupAdminCommentInformation = 4\n        GroupReplicationInformation  = 5",
  "class SAMPR_GROUP_INFO_BUFFER(NDRUNION):\n    union = {\n        GROUP_INFORMATION_CLASS.GroupGeneralInformation      : ('General', SAMPR_GROUP_GENERAL_INFORMATION),\n        GROUP_INFORMATION_CLASS.GroupNameInformation         : ('Name', SAMPR_GROUP_NAME_INFORMATION),\n        GROUP_INFORMATION_CLASS.GroupAttributeInformation    : ('Attribute', GROUP_ATTRIBUTE_INFORMATION),\n        GROUP_INFORMATION_CLASS.GroupAdminCommentInformation : ('AdminComment', SAMPR_GROUP_ADM_COMMENT_INFORMATION),\n        GROUP_INFORMATION_CLASS.GroupReplicationInformation  : ('DoNotUse', SAMPR_GROUP_GENERAL_INFORMATION),\n    }",
  "class PSAMPR_GROUP_INFO_BUFFER(NDRPOINTER):\n    referent = (\n        ('Data', SAMPR_GROUP_INFO_BUFFER),\n    )",
  "class SAMPR_ALIAS_GENERAL_INFORMATION(NDRSTRUCT):\n    structure = (\n        ('Name', RPC_UNICODE_STRING),\n        ('MemberCount', ULONG),\n        ('AdminComment', RPC_UNICODE_STRING),\n    )",
  "class SAMPR_ALIAS_NAME_INFORMATION(NDRSTRUCT):\n    structure = (\n        ('Name', RPC_UNICODE_STRING),\n    )",
  "class SAMPR_ALIAS_ADM_COMMENT_INFORMATION(NDRSTRUCT):\n    structure = (\n        ('AdminComment', RPC_UNICODE_STRING),\n    )",
  "class ALIAS_INFORMATION_CLASS(NDRENUM):\n    class enumItems(Enum):\n        AliasGeneralInformation      = 1\n        AliasNameInformation         = 2\n        AliasAdminCommentInformation = 3",
  "class SAMPR_ALIAS_INFO_BUFFER(NDRUNION):\n    union = {\n        ALIAS_INFORMATION_CLASS.AliasGeneralInformation      : ('General', SAMPR_ALIAS_GENERAL_INFORMATION),\n        ALIAS_INFORMATION_CLASS.AliasNameInformation         : ('Name', SAMPR_ALIAS_NAME_INFORMATION),\n        ALIAS_INFORMATION_CLASS.AliasAdminCommentInformation : ('AdminComment', SAMPR_ALIAS_ADM_COMMENT_INFORMATION),\n    }",
  "class PSAMPR_ALIAS_INFO_BUFFER(NDRPOINTER):\n    referent = (\n        ('Data', SAMPR_ALIAS_INFO_BUFFER),\n    )",
  "class USER_PRIMARY_GROUP_INFORMATION(NDRSTRUCT):\n    structure = (\n        ('PrimaryGroupId', ULONG),\n    )",
  "class USER_CONTROL_INFORMATION(NDRSTRUCT):\n    structure = (\n        ('UserAccountControl', ULONG),\n    )",
  "class USER_EXPIRES_INFORMATION(NDRSTRUCT):\n    structure = (\n        ('AccountExpires', OLD_LARGE_INTEGER),\n    )",
  "class LOGON_HOURS_ARRAY(NDRUniConformantVaryingArray):\n    pass",
  "class PLOGON_HOURS_ARRAY(NDRPOINTER):\n    referent = (\n        ('Data', LOGON_HOURS_ARRAY),\n    )",
  "class SAMPR_LOGON_HOURS(NDRSTRUCT):\n    structure = (\n        #('UnitsPerWeek', NDRSHORT),\n        ('UnitsPerWeek', ULONG),\n        ('LogonHours', PLOGON_HOURS_ARRAY),\n    )\n\n    def getData(self, soFar = 0):\n        if self['LogonHours'] != 0:\n            self['UnitsPerWeek'] = len(self['LogonHours']) * 8\n        return NDR.getData(self, soFar)",
  "class SAMPR_USER_ALL_INFORMATION(NDRSTRUCT):\n    structure = (\n        ('LastLogon', OLD_LARGE_INTEGER),\n        ('LastLogoff', OLD_LARGE_INTEGER),\n        ('PasswordLastSet', OLD_LARGE_INTEGER),\n        ('AccountExpires', OLD_LARGE_INTEGER),\n        ('PasswordCanChange', OLD_LARGE_INTEGER),\n        ('PasswordMustChange', OLD_LARGE_INTEGER),\n        ('UserName', RPC_UNICODE_STRING),\n        ('FullName', RPC_UNICODE_STRING),\n        ('HomeDirectory', RPC_UNICODE_STRING),\n        ('HomeDirectoryDrive', RPC_UNICODE_STRING),\n        ('ScriptPath', RPC_UNICODE_STRING),\n        ('ProfilePath', RPC_UNICODE_STRING),\n        ('AdminComment', RPC_UNICODE_STRING),\n        ('WorkStations', RPC_UNICODE_STRING),\n        ('UserComment', RPC_UNICODE_STRING),\n        ('Parameters', RPC_UNICODE_STRING),\n\n        ('LmOwfPassword', RPC_SHORT_BLOB),\n        ('NtOwfPassword', RPC_SHORT_BLOB),\n        ('PrivateData', RPC_UNICODE_STRING),\n\n        ('SecurityDescriptor', SAMPR_SR_SECURITY_DESCRIPTOR),\n\n        ('UserId', ULONG),\n        ('PrimaryGroupId', ULONG),\n        ('UserAccountControl', ULONG),\n        ('WhichFields', ULONG),\n        ('LogonHours', SAMPR_LOGON_HOURS),\n        ('BadPasswordCount', USHORT),\n        ('LogonCount', USHORT),\n        ('CountryCode', USHORT),\n        ('CodePage', USHORT),\n        ('LmPasswordPresent', UCHAR),\n        ('NtPasswordPresent', UCHAR),\n        ('PasswordExpired', UCHAR),\n        ('PrivateDataSensitive', UCHAR),\n    )",
  "class SAMPR_USER_GENERAL_INFORMATION(NDRSTRUCT):\n    structure = (\n        ('UserName', RPC_UNICODE_STRING),\n        ('FullName', RPC_UNICODE_STRING),\n        ('PrimaryGroupId', ULONG),\n        ('AdminComment', RPC_UNICODE_STRING),\n        ('UserComment', RPC_UNICODE_STRING),\n    )",
  "class SAMPR_USER_PREFERENCES_INFORMATION(NDRSTRUCT):\n    structure = (\n        ('UserComment', RPC_UNICODE_STRING),\n        ('Reserved1', RPC_UNICODE_STRING),\n        ('CountryCode', USHORT),\n        ('CodePage', USHORT),\n    )",
  "class SAMPR_USER_PARAMETERS_INFORMATION(NDRSTRUCT):\n    structure = (\n        ('Parameters', RPC_UNICODE_STRING),\n    )",
  "class SAMPR_USER_LOGON_INFORMATION(NDRSTRUCT):\n    structure = (\n        ('UserName', RPC_UNICODE_STRING),\n        ('FullName', RPC_UNICODE_STRING),\n        ('UserId', ULONG),\n        ('PrimaryGroupId', ULONG),\n        ('HomeDirectory', RPC_UNICODE_STRING),\n        ('HomeDirectoryDrive', RPC_UNICODE_STRING),\n        ('ScriptPath', RPC_UNICODE_STRING),\n        ('ProfilePath', RPC_UNICODE_STRING),\n        ('WorkStations', RPC_UNICODE_STRING),\n        ('LastLogon', OLD_LARGE_INTEGER),\n        ('LastLogoff', OLD_LARGE_INTEGER),\n        ('PasswordLastSet', OLD_LARGE_INTEGER),\n        ('PasswordCanChange', OLD_LARGE_INTEGER),\n        ('PasswordMustChange', OLD_LARGE_INTEGER),\n        ('LogonHours', SAMPR_LOGON_HOURS),\n        ('BadPasswordCount', USHORT),\n        ('LogonCount', USHORT),\n        ('UserAccountControl', ULONG),\n    )",
  "class SAMPR_USER_ACCOUNT_INFORMATION(NDRSTRUCT):\n    structure = (\n        ('UserName', RPC_UNICODE_STRING),\n        ('FullName', RPC_UNICODE_STRING),\n        ('UserId', ULONG),\n        ('PrimaryGroupId', ULONG),\n        ('HomeDirectory', RPC_UNICODE_STRING),\n        ('HomeDirectoryDrive', RPC_UNICODE_STRING),\n        ('ScriptPath', RPC_UNICODE_STRING),\n        ('ProfilePath', RPC_UNICODE_STRING),\n        ('AdminComment', RPC_UNICODE_STRING),\n        ('WorkStations', RPC_UNICODE_STRING),\n        ('LastLogon', OLD_LARGE_INTEGER),\n        ('LastLogoff', OLD_LARGE_INTEGER),\n        ('LogonHours', SAMPR_LOGON_HOURS),\n        ('BadPasswordCount', USHORT),\n        ('LogonCount', USHORT),\n        ('PasswordLastSet', OLD_LARGE_INTEGER),\n        ('AccountExpires', OLD_LARGE_INTEGER),\n        ('UserAccountControl', ULONG)\n    )",
  "class SAMPR_USER_A_NAME_INFORMATION(NDRSTRUCT):\n    structure = (\n        ('UserName', RPC_UNICODE_STRING),\n    )",
  "class SAMPR_USER_F_NAME_INFORMATION(NDRSTRUCT):\n    structure = (\n        ('FullName', RPC_UNICODE_STRING),\n    )",
  "class SAMPR_USER_NAME_INFORMATION(NDRSTRUCT):\n    structure = (\n        ('UserName', RPC_UNICODE_STRING),\n        ('FullName', RPC_UNICODE_STRING),\n    )",
  "class SAMPR_USER_HOME_INFORMATION(NDRSTRUCT):\n    structure = (\n        ('HomeDirectory', RPC_UNICODE_STRING),\n        ('HomeDirectoryDrive', RPC_UNICODE_STRING),\n    )",
  "class SAMPR_USER_SCRIPT_INFORMATION(NDRSTRUCT):\n    structure = (\n        ('ScriptPath', RPC_UNICODE_STRING),\n    )",
  "class SAMPR_USER_PROFILE_INFORMATION(NDRSTRUCT):\n    structure = (\n        ('ProfilePath', RPC_UNICODE_STRING),\n    )",
  "class SAMPR_USER_ADMIN_COMMENT_INFORMATION(NDRSTRUCT):\n    structure = (\n        ('AdminComment', RPC_UNICODE_STRING),\n    )",
  "class SAMPR_USER_WORKSTATIONS_INFORMATION(NDRSTRUCT):\n    structure = (\n        ('WorkStations', RPC_UNICODE_STRING),\n    )",
  "class SAMPR_USER_LOGON_HOURS_INFORMATION(NDRSTRUCT):\n    structure = (\n        ('LogonHours', SAMPR_LOGON_HOURS),\n    )",
  "class SAMPR_USER_PASSWORD(NDRSTRUCT):\n    structure = (\n        ('Buffer', '512s=b\"\"'),\n        ('Length', ULONG),\n    )\n    def getAlignment(self):\n        return 4",
  "class SAMPR_ENCRYPTED_USER_PASSWORD(NDRSTRUCT):\n    structure = (\n        ('Buffer', '516s=b\"\"'),\n    )\n    def getAlignment(self):\n        return 1",
  "class PSAMPR_ENCRYPTED_USER_PASSWORD(NDRPOINTER):\n    referent = (\n        ('Data', SAMPR_ENCRYPTED_USER_PASSWORD),\n    )",
  "class SAMPR_ENCRYPTED_USER_PASSWORD_NEW(NDRSTRUCT):\n    structure = (\n        ('Buffer', '532s=b\"\"'),\n    )\n    def getAlignment(self):\n        return 1",
  "class SAMPR_USER_INTERNAL1_INFORMATION(NDRSTRUCT):\n    structure = (\n        ('EncryptedNtOwfPassword', ENCRYPTED_NT_OWF_PASSWORD),\n        ('EncryptedLmOwfPassword', ENCRYPTED_LM_OWF_PASSWORD),\n        ('NtPasswordPresent', UCHAR),\n        ('LmPasswordPresent', UCHAR),\n        ('PasswordExpired', UCHAR),\n    )",
  "class SAMPR_USER_INTERNAL4_INFORMATION(NDRSTRUCT):\n    structure = (\n        ('I1', SAMPR_USER_ALL_INFORMATION),\n        ('UserPassword', SAMPR_ENCRYPTED_USER_PASSWORD),\n    )",
  "class SAMPR_USER_INTERNAL4_INFORMATION_NEW(NDRSTRUCT):\n    structure = (\n        ('I1', SAMPR_USER_ALL_INFORMATION),\n        ('UserPassword', SAMPR_ENCRYPTED_USER_PASSWORD_NEW),\n    )",
  "class SAMPR_USER_INTERNAL5_INFORMATION(NDRSTRUCT):\n    structure = (\n        ('UserPassword', SAMPR_ENCRYPTED_USER_PASSWORD),\n        ('PasswordExpired', UCHAR),\n    )",
  "class SAMPR_USER_INTERNAL5_INFORMATION_NEW(NDRSTRUCT):\n    structure = (\n        ('UserPassword', SAMPR_ENCRYPTED_USER_PASSWORD_NEW),\n        ('PasswordExpired', UCHAR),\n    )",
  "class USER_INFORMATION_CLASS(NDRENUM):\n    class enumItems(Enum):\n        UserGeneralInformation      = 1\n        UserPreferencesInformation  = 2\n        UserLogonInformation        = 3\n        UserLogonHoursInformation   = 4\n        UserAccountInformation      = 5\n        UserNameInformation         = 6\n        UserAccountNameInformation  = 7\n        UserFullNameInformation     = 8\n        UserPrimaryGroupInformation = 9\n        UserHomeInformation         = 10\n        UserScriptInformation       = 11\n        UserProfileInformation      = 12\n        UserAdminCommentInformation = 13\n        UserWorkStationsInformation = 14\n        UserControlInformation      = 16\n        UserExpiresInformation      = 17\n        UserInternal1Information    = 18\n        UserParametersInformation   = 20\n        UserAllInformation          = 21\n        UserInternal4Information    = 23\n        UserInternal5Information    = 24\n        UserInternal4InformationNew = 25\n        UserInternal5InformationNew = 26",
  "class SAMPR_USER_INFO_BUFFER(NDRUNION):\n    union = {\n        USER_INFORMATION_CLASS.UserGeneralInformation     : ('General', SAMPR_USER_GENERAL_INFORMATION),\n        USER_INFORMATION_CLASS.UserPreferencesInformation : ('Preferences', SAMPR_USER_PREFERENCES_INFORMATION),\n        USER_INFORMATION_CLASS.UserLogonInformation       : ('Logon', SAMPR_USER_LOGON_INFORMATION),\n        USER_INFORMATION_CLASS.UserLogonHoursInformation  : ('LogonHours', SAMPR_USER_LOGON_HOURS_INFORMATION),\n        USER_INFORMATION_CLASS.UserAccountInformation     : ('Account', SAMPR_USER_ACCOUNT_INFORMATION),\n        USER_INFORMATION_CLASS.UserNameInformation        : ('Name', SAMPR_USER_NAME_INFORMATION),\n        USER_INFORMATION_CLASS.UserAccountNameInformation : ('AccountName', SAMPR_USER_A_NAME_INFORMATION),\n        USER_INFORMATION_CLASS.UserFullNameInformation    : ('FullName', SAMPR_USER_F_NAME_INFORMATION),\n        USER_INFORMATION_CLASS.UserPrimaryGroupInformation: ('PrimaryGroup', USER_PRIMARY_GROUP_INFORMATION),\n        USER_INFORMATION_CLASS.UserHomeInformation        : ('Home', SAMPR_USER_HOME_INFORMATION),\n        USER_INFORMATION_CLASS.UserScriptInformation      : ('Script', SAMPR_USER_SCRIPT_INFORMATION),\n        USER_INFORMATION_CLASS.UserProfileInformation     : ('Profile', SAMPR_USER_PROFILE_INFORMATION),\n        USER_INFORMATION_CLASS.UserAdminCommentInformation: ('AdminComment', SAMPR_USER_ADMIN_COMMENT_INFORMATION),\n        USER_INFORMATION_CLASS.UserWorkStationsInformation: ('WorkStations', SAMPR_USER_WORKSTATIONS_INFORMATION),\n        USER_INFORMATION_CLASS.UserControlInformation     : ('Control', USER_CONTROL_INFORMATION),\n        USER_INFORMATION_CLASS.UserExpiresInformation     : ('Expires', USER_EXPIRES_INFORMATION),\n        USER_INFORMATION_CLASS.UserInternal1Information   : ('Internal1', SAMPR_USER_INTERNAL1_INFORMATION),\n        USER_INFORMATION_CLASS.UserParametersInformation  : ('Parameters', SAMPR_USER_PARAMETERS_INFORMATION ),\n        USER_INFORMATION_CLASS.UserAllInformation         : ('All', SAMPR_USER_ALL_INFORMATION),\n        USER_INFORMATION_CLASS.UserInternal4Information   : ('Internal4', SAMPR_USER_INTERNAL4_INFORMATION),\n        USER_INFORMATION_CLASS.UserInternal5Information   : ('Internal5', SAMPR_USER_INTERNAL5_INFORMATION),\n        USER_INFORMATION_CLASS.UserInternal4InformationNew: ('Internal4New', SAMPR_USER_INTERNAL4_INFORMATION_NEW),\n        USER_INFORMATION_CLASS.UserInternal5InformationNew: ('Internal5New', SAMPR_USER_INTERNAL5_INFORMATION_NEW),\n    }",
  "class PSAMPR_USER_INFO_BUFFER(NDRPOINTER):\n    referent = (\n        ('Data', SAMPR_USER_INFO_BUFFER),\n    )",
  "class PSAMPR_SERVER_NAME2(NDRPOINTER):\n    referent = (\n        ('Data', '4s=b\"\"'),\n    )",
  "class SAMPR_DOMAIN_DISPLAY_USER(NDRSTRUCT):\n    structure = (\n        ('Index',ULONG),\n        ('Rid',ULONG),\n        ('AccountControl',ULONG),\n        ('AccountName',RPC_UNICODE_STRING),\n        ('AdminComment',RPC_UNICODE_STRING),\n        ('FullName',RPC_UNICODE_STRING),\n    )",
  "class SAMPR_DOMAIN_DISPLAY_USER_ARRAY(NDRUniConformantArray):\n    item = SAMPR_DOMAIN_DISPLAY_USER",
  "class PSAMPR_DOMAIN_DISPLAY_USER_ARRAY(NDRPOINTER):\n    referent = (\n        ('Data',SAMPR_DOMAIN_DISPLAY_USER_ARRAY),\n    )",
  "class SAMPR_DOMAIN_DISPLAY_MACHINE(NDRSTRUCT):\n    structure = (\n        ('Index',ULONG),\n        ('Rid',ULONG),\n        ('AccountControl',ULONG),\n        ('AccountName',RPC_UNICODE_STRING),\n        ('AdminComment',RPC_UNICODE_STRING),\n    )",
  "class SAMPR_DOMAIN_DISPLAY_MACHINE_ARRAY(NDRUniConformantArray):\n    item = SAMPR_DOMAIN_DISPLAY_MACHINE",
  "class PSAMPR_DOMAIN_DISPLAY_MACHINE_ARRAY(NDRPOINTER):\n    referent = (\n        ('Data',SAMPR_DOMAIN_DISPLAY_MACHINE_ARRAY),\n    )",
  "class SAMPR_DOMAIN_DISPLAY_GROUP(NDRSTRUCT):\n    structure = (\n        ('Index',ULONG),\n        ('Rid',ULONG),\n        ('AccountControl',ULONG),\n        ('AccountName',RPC_UNICODE_STRING),\n        ('AdminComment',RPC_UNICODE_STRING),\n    )",
  "class SAMPR_DOMAIN_DISPLAY_GROUP_ARRAY(NDRUniConformantArray):\n    item = SAMPR_DOMAIN_DISPLAY_GROUP",
  "class PSAMPR_DOMAIN_DISPLAY_GROUP_ARRAY(NDRPOINTER):\n    referent = (\n        ('Data',SAMPR_DOMAIN_DISPLAY_GROUP_ARRAY),\n    )",
  "class SAMPR_DOMAIN_DISPLAY_OEM_USER(NDRSTRUCT):\n    structure = (\n        ('Index',ULONG),\n        ('OemAccountName',RPC_STRING),\n    )",
  "class SAMPR_DOMAIN_DISPLAY_OEM_USER_ARRAY(NDRUniConformantArray):\n    item = SAMPR_DOMAIN_DISPLAY_OEM_USER",
  "class PSAMPR_DOMAIN_DISPLAY_OEM_USER_ARRAY(NDRPOINTER):\n    referent = (\n        ('Data',SAMPR_DOMAIN_DISPLAY_OEM_USER_ARRAY),\n    )",
  "class SAMPR_DOMAIN_DISPLAY_OEM_GROUP(NDRSTRUCT):\n    structure = (\n        ('Index',ULONG),\n        ('OemAccountName',RPC_STRING),\n    )",
  "class SAMPR_DOMAIN_DISPLAY_OEM_GROUP_ARRAY(NDRUniConformantArray):\n    item = SAMPR_DOMAIN_DISPLAY_OEM_GROUP",
  "class PSAMPR_DOMAIN_DISPLAY_OEM_GROUP_ARRAY(NDRPOINTER):\n    referent = (\n        ('Data',SAMPR_DOMAIN_DISPLAY_OEM_GROUP_ARRAY),\n    )",
  "class SAMPR_DOMAIN_DISPLAY_USER_BUFFER(NDRSTRUCT):\n    structure = (\n        ('EntriesRead', ULONG),\n        ('Buffer', PSAMPR_DOMAIN_DISPLAY_USER_ARRAY),\n    )",
  "class SAMPR_DOMAIN_DISPLAY_MACHINE_BUFFER(NDRSTRUCT):\n    structure = (\n        ('EntriesRead', ULONG),\n        ('Buffer', PSAMPR_DOMAIN_DISPLAY_MACHINE_ARRAY),\n    )",
  "class SAMPR_DOMAIN_DISPLAY_GROUP_BUFFER(NDRSTRUCT):\n    structure = (\n        ('EntriesRead', ULONG),\n        ('Buffer', PSAMPR_DOMAIN_DISPLAY_GROUP_ARRAY),\n    )",
  "class SAMPR_DOMAIN_DISPLAY_OEM_USER_BUFFER(NDRSTRUCT):\n    structure = (\n        ('EntriesRead', ULONG),\n        ('Buffer', PSAMPR_DOMAIN_DISPLAY_OEM_USER_ARRAY),\n    )",
  "class SAMPR_DOMAIN_DISPLAY_OEM_GROUP_BUFFER(NDRSTRUCT):\n    structure = (\n        ('EntriesRead', ULONG),\n        ('Buffer', PSAMPR_DOMAIN_DISPLAY_OEM_GROUP_ARRAY),\n    )",
  "class DOMAIN_DISPLAY_INFORMATION(NDRENUM):\n    class enumItems(Enum):\n        DomainDisplayUser     = 1\n        DomainDisplayMachine  = 2\n        DomainDisplayGroup    = 3\n        DomainDisplayOemUser  = 4\n        DomainDisplayOemGroup = 5",
  "class SAMPR_DISPLAY_INFO_BUFFER(NDRUNION):\n    union = {\n        DOMAIN_DISPLAY_INFORMATION.DomainDisplayUser     : ('UserInformation', SAMPR_DOMAIN_DISPLAY_USER_BUFFER),\n        DOMAIN_DISPLAY_INFORMATION.DomainDisplayMachine  : ('MachineInformation', SAMPR_DOMAIN_DISPLAY_MACHINE_BUFFER),\n        DOMAIN_DISPLAY_INFORMATION.DomainDisplayGroup    : ('GroupInformation', SAMPR_DOMAIN_DISPLAY_GROUP_BUFFER),\n        DOMAIN_DISPLAY_INFORMATION.DomainDisplayOemUser  : ('OemUserInformation', SAMPR_DOMAIN_DISPLAY_OEM_USER_BUFFER),\n        DOMAIN_DISPLAY_INFORMATION.DomainDisplayOemGroup : ('OemGroupInformation', SAMPR_DOMAIN_DISPLAY_OEM_GROUP_BUFFER),\n    }",
  "class SAM_VALIDATE_PASSWORD_HASH(NDRSTRUCT):\n    structure = (\n        ('Length', ULONG),\n        ('Hash', LPBYTE),\n    )",
  "class PSAM_VALIDATE_PASSWORD_HASH(NDRPOINTER):\n    referent = (\n        ('Data', SAM_VALIDATE_PASSWORD_HASH),\n    )",
  "class SAM_VALIDATE_PERSISTED_FIELDS(NDRSTRUCT):\n    structure = (\n        ('PresentFields', ULONG),\n        ('PasswordLastSet', LARGE_INTEGER),\n        ('BadPasswordTime', LARGE_INTEGER),\n        ('LockoutTime', LARGE_INTEGER),\n        ('BadPasswordCount', ULONG),\n        ('PasswordHistoryLength', ULONG),\n        ('PasswordHistory', PSAM_VALIDATE_PASSWORD_HASH),\n    )",
  "class SAM_VALIDATE_VALIDATION_STATUS(NDRENUM):\n    class enumItems(Enum):\n        SamValidateSuccess                  = 0\n        SamValidatePasswordMustChange       = 1\n        SamValidateAccountLockedOut         = 2\n        SamValidatePasswordExpired          = 3\n        SamValidatePasswordIncorrect        = 4\n        SamValidatePasswordIsInHistory      = 5\n        SamValidatePasswordTooShort         = 6\n        SamValidatePasswordTooLong          = 7\n        SamValidatePasswordNotComplexEnough = 8\n        SamValidatePasswordTooRecent        = 9\n        SamValidatePasswordFilterError      = 10",
  "class SAM_VALIDATE_STANDARD_OUTPUT_ARG(NDRSTRUCT):\n    structure = (\n        ('ChangedPersistedFields', SAM_VALIDATE_PERSISTED_FIELDS),\n        ('ValidationStatus', SAM_VALIDATE_VALIDATION_STATUS),\n    )",
  "class PSAM_VALIDATE_STANDARD_OUTPUT_ARG(NDRPOINTER):\n    referent = (\n        ('Data', SAM_VALIDATE_STANDARD_OUTPUT_ARG),\n    )",
  "class SAM_VALIDATE_AUTHENTICATION_INPUT_ARG(NDRSTRUCT):\n    structure = (\n        ('InputPersistedFields', SAM_VALIDATE_PERSISTED_FIELDS),\n        ('PasswordMatched', UCHAR),\n    )",
  "class SAM_VALIDATE_PASSWORD_CHANGE_INPUT_ARG(NDRSTRUCT):\n    structure = (\n        ('InputPersistedFields', SAM_VALIDATE_PERSISTED_FIELDS),\n        ('ClearPassword', RPC_UNICODE_STRING),\n        ('UserAccountName', RPC_UNICODE_STRING),\n        ('HashedPassword', SAM_VALIDATE_PASSWORD_HASH),\n        ('PasswordMatch', UCHAR),\n    )",
  "class SAM_VALIDATE_PASSWORD_RESET_INPUT_ARG(NDRSTRUCT):\n    structure = (\n        ('InputPersistedFields', SAM_VALIDATE_PERSISTED_FIELDS),\n        ('ClearPassword', RPC_UNICODE_STRING),\n        ('UserAccountName', RPC_UNICODE_STRING),\n        ('HashedPassword', SAM_VALIDATE_PASSWORD_HASH),\n        ('PasswordMustChangeAtNextLogon', UCHAR),\n        ('ClearLockout', UCHAR),\n    )",
  "class PASSWORD_POLICY_VALIDATION_TYPE(NDRENUM):\n    class enumItems(Enum):\n        SamValidateAuthentication   = 1\n        SamValidatePasswordChange   = 2\n        SamValidatePasswordReset    = 3",
  "class SAM_VALIDATE_INPUT_ARG(NDRUNION):\n    union = {\n        PASSWORD_POLICY_VALIDATION_TYPE.SamValidateAuthentication : ('ValidateAuthenticationInput', SAM_VALIDATE_AUTHENTICATION_INPUT_ARG),\n        PASSWORD_POLICY_VALIDATION_TYPE.SamValidatePasswordChange : ('ValidatePasswordChangeInput', SAM_VALIDATE_PASSWORD_CHANGE_INPUT_ARG),\n        PASSWORD_POLICY_VALIDATION_TYPE.SamValidatePasswordReset  : ('ValidatePasswordResetInput', SAM_VALIDATE_PASSWORD_RESET_INPUT_ARG),\n    }",
  "class SAM_VALIDATE_OUTPUT_ARG(NDRUNION):\n    union = {\n        PASSWORD_POLICY_VALIDATION_TYPE.SamValidateAuthentication : ('ValidateAuthenticationOutput', SAM_VALIDATE_STANDARD_OUTPUT_ARG),\n        PASSWORD_POLICY_VALIDATION_TYPE.SamValidatePasswordChange : ('ValidatePasswordChangeOutput', SAM_VALIDATE_STANDARD_OUTPUT_ARG),\n        PASSWORD_POLICY_VALIDATION_TYPE.SamValidatePasswordReset  : ('ValidatePasswordResetOutput', SAM_VALIDATE_STANDARD_OUTPUT_ARG),\n    }",
  "class PSAM_VALIDATE_OUTPUT_ARG(NDRPOINTER):\n    referent = (\n        ('Data', SAM_VALIDATE_OUTPUT_ARG),\n    )",
  "class USER_PROPERTIES(Structure):\n    structure = (\n        ('Reserved1','<L=0'),\n        ('Length','<L=0'),\n        ('Reserved2','<H=0'),\n        ('Reserved3','<H=0'),\n        ('Reserved4','96s=\"\"'),\n        ('PropertySignature','<H=0x50'),\n        ('PropertyCount','<H=0'),\n        ('UserProperties',':'),\n    )",
  "class USER_PROPERTY(Structure):\n    structure = (\n        ('NameLength','<H=0'),\n        ('ValueLength','<H=0'),\n        ('Reserved','<H=0'),\n        ('_PropertyName','_-PropertyName', \"self['NameLength']\"),\n        ('PropertyName',':'),\n        ('_PropertyValue','_-PropertyValue', \"self['ValueLength']\"),\n        ('PropertyValue',':'),\n    )",
  "class WDIGEST_CREDENTIALS(Structure):\n    structure = (\n        ('Reserved1','B=0'),\n        ('Reserved2','B=0'),\n        ('Version','B=1'),\n        ('NumberOfHashes','B=29'),\n        ('Reserved3','12s=\"\"'),\n        ('Hash1', '16s=\"\"'),\n        ('Hash2', '16s=\"\"'),\n        ('Hash3', '16s=\"\"'),\n        ('Hash4', '16s=\"\"'),\n        ('Hash5', '16s=\"\"'),\n        ('Hash6', '16s=\"\"'),\n        ('Hash7', '16s=\"\"'),\n        ('Hash8', '16s=\"\"'),\n        ('Hash9', '16s=\"\"'),\n        ('Hash10', '16s=\"\"'),\n        ('Hash11', '16s=\"\"'),\n        ('Hash12', '16s=\"\"'),\n        ('Hash13', '16s=\"\"'),\n        ('Hash14', '16s=\"\"'),\n        ('Hash15', '16s=\"\"'),\n        ('Hash16', '16s=\"\"'),\n        ('Hash17', '16s=\"\"'),\n        ('Hash18', '16s=\"\"'),\n        ('Hash19', '16s=\"\"'),\n        ('Hash20', '16s=\"\"'),\n        ('Hash21', '16s=\"\"'),\n        ('Hash22', '16s=\"\"'),\n        ('Hash23', '16s=\"\"'),\n        ('Hash24', '16s=\"\"'),\n        ('Hash25', '16s=\"\"'),\n        ('Hash26', '16s=\"\"'),\n        ('Hash27', '16s=\"\"'),\n        ('Hash28', '16s=\"\"'),\n        ('Hash29', '16s=\"\"'),\n    )",
  "class KERB_KEY_DATA(Structure):\n    structure = (\n        ('Reserved1','<H=0'),\n        ('Reserved2','<H=0'),\n        ('Reserved3','<H=0'),\n        ('KeyType','<L=0'),\n        ('KeyLength','<L=0'),\n        ('KeyOffset','<L=0'),\n    )",
  "class KERB_STORED_CREDENTIAL(Structure):\n    structure = (\n        ('Revision','<H=3'),\n        ('Flags','<H=0'),\n        ('CredentialCount','<H=0'),\n        ('OldCredentialCount','<H=0'),\n        ('DefaultSaltLength','<H=0'),\n        ('DefaultSaltMaximumLength','<H=0'),\n        ('DefaultSaltOffset','<L=0'),\n        #('Credentials',':'),\n        #('OldCredentials',':'),\n        #('DefaultSalt',':'),\n        #('KeyValues',':'),\n        # All the preceding stuff inside this Buffer\n        ('Buffer',':'),\n    )",
  "class KERB_KEY_DATA_NEW(Structure):\n    structure = (\n        ('Reserved1','<H=0'),\n        ('Reserved2','<H=0'),\n        ('Reserved3','<L=0'),\n        ('IterationCount','<L=0'),\n        ('KeyType','<L=0'),\n        ('KeyLength','<L=0'),\n        ('KeyOffset','<L=0'),\n    )",
  "class KERB_STORED_CREDENTIAL_NEW(Structure):\n    structure = (\n        ('Revision','<H=4'),\n        ('Flags','<H=0'),\n        ('CredentialCount','<H=0'),\n        ('ServiceCredentialCount','<H=0'),\n        ('OldCredentialCount','<H=0'),\n        ('OlderCredentialCount','<H=0'),\n        ('DefaultSaltLength','<H=0'),\n        ('DefaultSaltMaximumLength','<H=0'),\n        ('DefaultSaltOffset','<L=0'),\n        ('DefaultIterationCount','<L=0'),\n        #('Credentials',':'),\n        #('ServiceCredentials',':'),\n        #('OldCredentials',':'),\n        #('OlderCredentials',':'),\n        #('DefaultSalt',':'),\n        #('KeyValues',':'),\n        # All the preceding stuff inside this Buffer\n        ('Buffer',':'),\n    )",
  "class SamrConnect(NDRCALL):\n    opnum = 0\n    structure = (\n       ('ServerName',PSAMPR_SERVER_NAME2),\n       ('DesiredAccess', ULONG),\n    )",
  "class SamrConnectResponse(NDRCALL):\n    structure = (\n       ('ServerHandle',SAMPR_HANDLE),\n       ('ErrorCode',ULONG),\n    )",
  "class SamrCloseHandle(NDRCALL):\n    opnum = 1\n    structure = (\n       ('SamHandle',SAMPR_HANDLE),\n       ('DesiredAccess', LONG),\n    )",
  "class SamrCloseHandleResponse(NDRCALL):\n    structure = (\n       ('SamHandle',SAMPR_HANDLE),\n       ('ErrorCode',ULONG),\n    )",
  "class SamrSetSecurityObject(NDRCALL):\n    opnum = 2\n    structure = (\n       ('ObjectHandle',SAMPR_HANDLE),\n       ('SecurityInformation', SECURITY_INFORMATION),\n       ('SecurityDescriptor', SAMPR_SR_SECURITY_DESCRIPTOR),\n    )",
  "class SamrSetSecurityObjectResponse(NDRCALL):\n    structure = (\n       ('ErrorCode',ULONG),\n    )",
  "class SamrQuerySecurityObject(NDRCALL):\n    opnum = 3\n    structure = (\n       ('ObjectHandle',SAMPR_HANDLE),\n       ('SecurityInformation', SECURITY_INFORMATION),\n    )",
  "class SamrQuerySecurityObjectResponse(NDRCALL):\n    structure = (\n       ('SecurityDescriptor',PSAMPR_SR_SECURITY_DESCRIPTOR),\n       ('ErrorCode',ULONG),\n    )",
  "class SamrLookupDomainInSamServer(NDRCALL):\n    opnum = 5\n    structure = (\n       ('ServerHandle',SAMPR_HANDLE),\n       ('Name', RPC_UNICODE_STRING),\n    )",
  "class SamrLookupDomainInSamServerResponse(NDRCALL):\n    structure = (\n       ('DomainId',PRPC_SID),\n       ('ErrorCode',ULONG),\n    )",
  "class SamrEnumerateDomainsInSamServer(NDRCALL):\n    opnum = 6\n    structure = (\n       ('ServerHandle',SAMPR_HANDLE),\n       ('EnumerationContext', ULONG),\n       ('PreferedMaximumLength', ULONG),\n    )",
  "class SamrEnumerateDomainsInSamServerResponse(NDRCALL):\n    structure = (\n       ('EnumerationContext',ULONG),\n       ('Buffer',PSAMPR_ENUMERATION_BUFFER),\n       ('CountReturned',ULONG),\n       ('ErrorCode',ULONG),\n    )",
  "class SamrOpenDomain(NDRCALL):\n    opnum = 7\n    structure = (\n       ('ServerHandle',SAMPR_HANDLE),\n       ('DesiredAccess', ULONG),\n       ('DomainId', RPC_SID),\n    )",
  "class SamrOpenDomainResponse(NDRCALL):\n    structure = (\n       ('DomainHandle',SAMPR_HANDLE),\n       ('ErrorCode',ULONG),\n    )",
  "class SamrQueryInformationDomain(NDRCALL):\n    opnum = 8\n    structure = (\n       ('DomainHandle',SAMPR_HANDLE),\n       ('DomainInformationClass', DOMAIN_INFORMATION_CLASS),\n    )",
  "class SamrQueryInformationDomainResponse(NDRCALL):\n    structure = (\n       ('Buffer',PSAMPR_DOMAIN_INFO_BUFFER),\n       ('ErrorCode',ULONG),\n    )",
  "class SamrSetInformationDomain(NDRCALL):\n    opnum = 9\n    structure = (\n       ('DomainHandle',SAMPR_HANDLE),\n       ('DomainInformationClass', DOMAIN_INFORMATION_CLASS),\n       ('DomainInformation', SAMPR_DOMAIN_INFO_BUFFER),\n    )",
  "class SamrSetInformationDomainResponse(NDRCALL):\n    structure = (\n       ('ErrorCode',ULONG),\n    )",
  "class SamrCreateGroupInDomain(NDRCALL):\n    opnum = 10\n    structure = (\n       ('DomainHandle',SAMPR_HANDLE),\n       ('Name', RPC_UNICODE_STRING),\n       ('DesiredAccess', ULONG),\n    )",
  "class SamrCreateGroupInDomainResponse(NDRCALL):\n    structure = (\n       ('GroupHandle',SAMPR_HANDLE),\n       ('RelativeId',ULONG),\n       ('ErrorCode',ULONG),\n    )",
  "class SamrEnumerateGroupsInDomain(NDRCALL):\n    opnum = 11\n    structure = (\n       ('DomainHandle',SAMPR_HANDLE),\n       ('EnumerationContext', ULONG),\n       ('PreferedMaximumLength', ULONG),\n    )",
  "class SamrCreateUserInDomain(NDRCALL):\n    opnum = 12\n    structure = (\n       ('DomainHandle',SAMPR_HANDLE),\n       ('Name', RPC_UNICODE_STRING),\n       ('DesiredAccess', ULONG),\n    )",
  "class SamrCreateUserInDomainResponse(NDRCALL):\n    structure = (\n       ('UserHandle',SAMPR_HANDLE),\n       ('RelativeId',ULONG),\n       ('ErrorCode',ULONG),\n    )",
  "class SamrEnumerateGroupsInDomainResponse(NDRCALL):\n    structure = (\n       ('EnumerationContext',ULONG),\n       ('Buffer',PSAMPR_ENUMERATION_BUFFER),\n       ('CountReturned',ULONG),\n       ('ErrorCode',ULONG),\n    )",
  "class SamrEnumerateUsersInDomain(NDRCALL):\n    opnum = 13\n    structure = (\n       ('DomainHandle',SAMPR_HANDLE),\n       ('EnumerationContext', ULONG),\n       ('UserAccountControl', ULONG),\n       ('PreferedMaximumLength', ULONG),\n    )",
  "class SamrEnumerateUsersInDomainResponse(NDRCALL):\n    structure = (\n       ('EnumerationContext',ULONG),\n       ('Buffer',PSAMPR_ENUMERATION_BUFFER),\n       ('CountReturned',ULONG),\n       ('ErrorCode',ULONG),\n    )",
  "class SamrCreateAliasInDomain(NDRCALL):\n    opnum = 14\n    structure = (\n       ('DomainHandle',SAMPR_HANDLE),\n       ('AccountName', RPC_UNICODE_STRING),\n       ('DesiredAccess', ULONG),\n    )",
  "class SamrCreateAliasInDomainResponse(NDRCALL):\n    structure = (\n       ('AliasHandle',SAMPR_HANDLE),\n       ('RelativeId',ULONG),\n       ('ErrorCode',ULONG),\n    )",
  "class SamrEnumerateAliasesInDomain(NDRCALL):\n    opnum = 15\n    structure = (\n       ('DomainHandle',SAMPR_HANDLE),\n       ('EnumerationContext', ULONG),\n       ('PreferedMaximumLength', ULONG),\n    )",
  "class SamrEnumerateAliasesInDomainResponse(NDRCALL):\n    structure = (\n       ('EnumerationContext',ULONG),\n       ('Buffer',PSAMPR_ENUMERATION_BUFFER),\n       ('CountReturned',ULONG),\n       ('ErrorCode',ULONG),\n    )",
  "class SamrGetAliasMembership(NDRCALL):\n    opnum = 16\n    structure = (\n       ('DomainHandle',SAMPR_HANDLE),\n       ('SidArray',SAMPR_PSID_ARRAY),\n    )",
  "class SamrGetAliasMembershipResponse(NDRCALL):\n    structure = (\n       ('Membership',SAMPR_ULONG_ARRAY),\n       ('ErrorCode',ULONG),\n    )",
  "class SamrLookupNamesInDomain(NDRCALL):\n    opnum = 17\n    structure = (\n       ('DomainHandle',SAMPR_HANDLE),\n       ('Count',ULONG),\n       ('Names',RPC_UNICODE_STRING_ARRAY),\n    )",
  "class SamrLookupNamesInDomainResponse(NDRCALL):\n    structure = (\n       ('RelativeIds',SAMPR_ULONG_ARRAY),\n       ('Use',SAMPR_ULONG_ARRAY),\n       ('ErrorCode',ULONG),\n    )",
  "class SamrLookupIdsInDomain(NDRCALL):\n    opnum = 18\n    structure = (\n       ('DomainHandle',SAMPR_HANDLE),\n       ('Count',ULONG),\n       ('RelativeIds',ULONG_ARRAY_CV),\n    )",
  "class SamrLookupIdsInDomainResponse(NDRCALL):\n    structure = (\n       ('Names',SAMPR_RETURNED_USTRING_ARRAY),\n       ('Use',SAMPR_ULONG_ARRAY),\n       ('ErrorCode',ULONG),\n    )",
  "class SamrOpenGroup(NDRCALL):\n    opnum = 19\n    structure = (\n       ('DomainHandle',SAMPR_HANDLE),\n       ('DesiredAccess', ULONG),\n       ('GroupId', ULONG),\n    )",
  "class SamrOpenGroupResponse(NDRCALL):\n    structure = (\n       ('GroupHandle',SAMPR_HANDLE),\n       ('ErrorCode',ULONG),\n    )",
  "class SamrQueryInformationGroup(NDRCALL):\n    opnum = 20\n    structure = (\n       ('GroupHandle',SAMPR_HANDLE),\n       ('GroupInformationClass', GROUP_INFORMATION_CLASS),\n    )",
  "class SamrQueryInformationGroupResponse(NDRCALL):\n    structure = (\n       ('Buffer',PSAMPR_GROUP_INFO_BUFFER),\n       ('ErrorCode',ULONG),\n    )",
  "class SamrSetInformationGroup(NDRCALL):\n    opnum = 21\n    structure = (\n       ('GroupHandle',SAMPR_HANDLE),\n       ('GroupInformationClass', GROUP_INFORMATION_CLASS),\n       ('Buffer', SAMPR_GROUP_INFO_BUFFER),\n    )",
  "class SamrSetInformationGroupResponse(NDRCALL):\n    structure = (\n       ('ErrorCode',ULONG),\n    )",
  "class SamrAddMemberToGroup(NDRCALL):\n    opnum = 22\n    structure = (\n       ('GroupHandle',SAMPR_HANDLE),\n       ('MemberId', ULONG),\n       ('Attributes', ULONG),\n    )",
  "class SamrAddMemberToGroupResponse(NDRCALL):\n    structure = (\n       ('ErrorCode',ULONG),\n    )",
  "class SamrDeleteGroup(NDRCALL):\n    opnum = 23\n    structure = (\n       ('GroupHandle',SAMPR_HANDLE),\n    )",
  "class SamrDeleteGroupResponse(NDRCALL):\n    structure = (\n       ('GroupHandle',SAMPR_HANDLE),\n       ('ErrorCode',ULONG),\n    )",
  "class SamrRemoveMemberFromGroup(NDRCALL):\n    opnum = 24\n    structure = (\n       ('GroupHandle',SAMPR_HANDLE),\n       ('MemberId', ULONG),\n    )",
  "class SamrRemoveMemberFromGroupResponse(NDRCALL):\n    structure = (\n       ('ErrorCode',ULONG),\n    )",
  "class SamrGetMembersInGroup(NDRCALL):\n    opnum = 25\n    structure = (\n       ('GroupHandle',SAMPR_HANDLE),\n    )",
  "class SamrGetMembersInGroupResponse(NDRCALL):\n    structure = (\n       ('Members',PSAMPR_GET_MEMBERS_BUFFER),\n       ('ErrorCode',ULONG),\n    )",
  "class SamrSetMemberAttributesOfGroup(NDRCALL):\n    opnum = 26\n    structure = (\n       ('GroupHandle',SAMPR_HANDLE),\n       ('MemberId',ULONG),\n       ('Attributes',ULONG),\n    )",
  "class SamrSetMemberAttributesOfGroupResponse(NDRCALL):\n    structure = (\n       ('ErrorCode',ULONG),\n    )",
  "class SamrOpenAlias(NDRCALL):\n    opnum = 27\n    structure = (\n       ('DomainHandle',SAMPR_HANDLE),\n       ('DesiredAccess', ULONG),\n       ('AliasId', ULONG),\n    )",
  "class SamrOpenAliasResponse(NDRCALL):\n    structure = (\n       ('AliasHandle',SAMPR_HANDLE),\n       ('ErrorCode',ULONG),\n    )",
  "class SamrQueryInformationAlias(NDRCALL):\n    opnum = 28\n    structure = (\n       ('AliasHandle',SAMPR_HANDLE),\n       ('AliasInformationClass', ALIAS_INFORMATION_CLASS),\n    )",
  "class SamrQueryInformationAliasResponse(NDRCALL):\n    structure = (\n       ('Buffer',PSAMPR_ALIAS_INFO_BUFFER),\n       ('ErrorCode',ULONG),\n    )",
  "class SamrSetInformationAlias(NDRCALL):\n    opnum = 29\n    structure = (\n       ('AliasHandle',SAMPR_HANDLE),\n       ('AliasInformationClass', ALIAS_INFORMATION_CLASS),\n       ('Buffer',SAMPR_ALIAS_INFO_BUFFER),\n    )",
  "class SamrSetInformationAliasResponse(NDRCALL):\n    structure = (\n       ('ErrorCode',ULONG),\n    )",
  "class SamrDeleteAlias(NDRCALL):\n    opnum = 30\n    structure = (\n       ('AliasHandle',SAMPR_HANDLE),\n    )",
  "class SamrDeleteAliasResponse(NDRCALL):\n    structure = (\n       ('AliasHandle',SAMPR_HANDLE),\n       ('ErrorCode',ULONG),\n    )",
  "class SamrAddMemberToAlias(NDRCALL):\n    opnum = 31\n    structure = (\n       ('AliasHandle',SAMPR_HANDLE),\n       ('MemberId', RPC_SID),\n    )",
  "class SamrAddMemberToAliasResponse(NDRCALL):\n    structure = (\n       ('ErrorCode',ULONG),\n    )",
  "class SamrRemoveMemberFromAlias(NDRCALL):\n    opnum = 32\n    structure = (\n       ('AliasHandle',SAMPR_HANDLE),\n       ('MemberId', RPC_SID),\n    )",
  "class SamrRemoveMemberFromAliasResponse(NDRCALL):\n    structure = (\n       ('ErrorCode',ULONG),\n    )",
  "class SamrGetMembersInAlias(NDRCALL):\n    opnum = 33\n    structure = (\n       ('AliasHandle',SAMPR_HANDLE),\n    )",
  "class SamrGetMembersInAliasResponse(NDRCALL):\n    structure = (\n       ('Members',SAMPR_PSID_ARRAY_OUT),\n       ('ErrorCode',ULONG),\n    )",
  "class SamrOpenUser(NDRCALL):\n    opnum = 34\n    structure = (\n       ('DomainHandle',SAMPR_HANDLE),\n       ('DesiredAccess', ULONG),\n       ('UserId', ULONG),\n    )",
  "class SamrOpenUserResponse(NDRCALL):\n    structure = (\n       ('UserHandle',SAMPR_HANDLE),\n       ('ErrorCode',ULONG),\n    )",
  "class SamrDeleteUser(NDRCALL):\n    opnum = 35\n    structure = (\n       ('UserHandle',SAMPR_HANDLE),\n    )",
  "class SamrDeleteUserResponse(NDRCALL):\n    structure = (\n       ('UserHandle',SAMPR_HANDLE),\n       ('ErrorCode',ULONG),\n    )",
  "class SamrQueryInformationUser(NDRCALL):\n    opnum = 36\n    structure = (\n       ('UserHandle',SAMPR_HANDLE),\n       ('UserInformationClass', USER_INFORMATION_CLASS ),\n    )",
  "class SamrQueryInformationUserResponse(NDRCALL):\n    structure = (\n       ('Buffer',PSAMPR_USER_INFO_BUFFER),\n       ('ErrorCode',ULONG),\n    )",
  "class SamrSetInformationUser(NDRCALL):\n    opnum = 37\n    structure = (\n       ('UserHandle',SAMPR_HANDLE),\n       ('UserInformationClass', USER_INFORMATION_CLASS ),\n       ('Buffer',SAMPR_USER_INFO_BUFFER),\n    )",
  "class SamrSetInformationUserResponse(NDRCALL):\n    structure = (\n       ('ErrorCode',ULONG),\n    )",
  "class SamrChangePasswordUser(NDRCALL):\n    opnum = 38\n    structure = (\n       ('UserHandle',SAMPR_HANDLE),\n       ('LmPresent', UCHAR ),\n       ('OldLmEncryptedWithNewLm',PENCRYPTED_LM_OWF_PASSWORD),\n       ('NewLmEncryptedWithOldLm',PENCRYPTED_LM_OWF_PASSWORD),\n       ('NtPresent', UCHAR),\n       ('OldNtEncryptedWithNewNt',PENCRYPTED_NT_OWF_PASSWORD),\n       ('NewNtEncryptedWithOldNt',PENCRYPTED_NT_OWF_PASSWORD),\n       ('NtCrossEncryptionPresent',UCHAR),\n       ('NewNtEncryptedWithNewLm',PENCRYPTED_NT_OWF_PASSWORD),\n       ('LmCrossEncryptionPresent',UCHAR),\n       ('NewLmEncryptedWithNewNt',PENCRYPTED_NT_OWF_PASSWORD),\n    )",
  "class SamrChangePasswordUserResponse(NDRCALL):\n    structure = (\n       ('ErrorCode',ULONG),\n    )",
  "class SamrGetGroupsForUser(NDRCALL):\n    opnum = 39\n    structure = (\n       ('UserHandle',SAMPR_HANDLE),\n    )",
  "class SamrGetGroupsForUserResponse(NDRCALL):\n    structure = (\n       ('Groups',PSAMPR_GET_GROUPS_BUFFER),\n       ('ErrorCode',ULONG),\n    )",
  "class SamrQueryDisplayInformation(NDRCALL):\n    opnum = 40\n    structure = (\n       ('DomainHandle',SAMPR_HANDLE),\n       ('DisplayInformationClass', DOMAIN_DISPLAY_INFORMATION),\n       ('Index', ULONG),\n       ('EntryCount',ULONG),\n       ('PreferredMaximumLength',ULONG),\n    )",
  "class SamrQueryDisplayInformationResponse(NDRCALL):\n    structure = (\n       ('TotalAvailable',ULONG),\n       ('TotalReturned',ULONG),\n       ('Buffer',SAMPR_DISPLAY_INFO_BUFFER),\n       ('ErrorCode',ULONG),\n    )",
  "class SamrGetDisplayEnumerationIndex(NDRCALL):\n    opnum = 41\n    structure = (\n       ('DomainHandle',SAMPR_HANDLE),\n       ('DisplayInformationClass', DOMAIN_DISPLAY_INFORMATION),\n       ('Prefix', RPC_UNICODE_STRING),\n    )",
  "class SamrGetDisplayEnumerationIndexResponse(NDRCALL):\n    structure = (\n       ('Index',ULONG),\n       ('ErrorCode',ULONG),\n    )",
  "class SamrGetUserDomainPasswordInformation(NDRCALL):\n    opnum = 44\n    structure = (\n       ('UserHandle',SAMPR_HANDLE),\n    )",
  "class SamrGetUserDomainPasswordInformationResponse(NDRCALL):\n    structure = (\n       ('PasswordInformation',USER_DOMAIN_PASSWORD_INFORMATION),\n       ('ErrorCode',ULONG),\n    )",
  "class SamrRemoveMemberFromForeignDomain(NDRCALL):\n    opnum = 45\n    structure = (\n       ('DomainHandle',SAMPR_HANDLE),\n       ('MemberSid', RPC_SID),\n    )",
  "class SamrRemoveMemberFromForeignDomainResponse(NDRCALL):\n    structure = (\n       ('ErrorCode',ULONG),\n    )",
  "class SamrQueryInformationDomain2(NDRCALL):\n    opnum = 46\n    structure = (\n       ('DomainHandle',SAMPR_HANDLE),\n       ('DomainInformationClass', DOMAIN_INFORMATION_CLASS),\n    )",
  "class SamrQueryInformationDomain2Response(NDRCALL):\n    structure = (\n       ('Buffer',PSAMPR_DOMAIN_INFO_BUFFER),\n       ('ErrorCode',ULONG),\n    )",
  "class SamrQueryInformationUser2(NDRCALL):\n    opnum = 47\n    structure = (\n       ('UserHandle',SAMPR_HANDLE),\n       ('UserInformationClass', USER_INFORMATION_CLASS ),\n    )",
  "class SamrQueryInformationUser2Response(NDRCALL):\n    structure = (\n       ('Buffer',PSAMPR_USER_INFO_BUFFER),\n       ('ErrorCode',ULONG),\n    )",
  "class SamrQueryDisplayInformation2(NDRCALL):\n    opnum = 48\n    structure = (\n       ('DomainHandle',SAMPR_HANDLE),\n       ('DisplayInformationClass', DOMAIN_DISPLAY_INFORMATION),\n       ('Index', ULONG),\n       ('EntryCount',ULONG),\n       ('PreferredMaximumLength',ULONG),\n    )",
  "class SamrQueryDisplayInformation2Response(NDRCALL):\n    structure = (\n       ('TotalAvailable',ULONG),\n       ('TotalReturned',ULONG),\n       ('Buffer',SAMPR_DISPLAY_INFO_BUFFER),\n       ('ErrorCode',ULONG),\n    )",
  "class SamrGetDisplayEnumerationIndex2(NDRCALL):\n    opnum = 49\n    structure = (\n       ('DomainHandle',SAMPR_HANDLE),\n       ('DisplayInformationClass', DOMAIN_DISPLAY_INFORMATION),\n       ('Prefix', RPC_UNICODE_STRING),\n    )",
  "class SamrGetDisplayEnumerationIndex2Response(NDRCALL):\n    structure = (\n       ('Index',ULONG),\n       ('ErrorCode',ULONG),\n    )",
  "class SamrCreateUser2InDomain(NDRCALL):\n    opnum = 50\n    structure = (\n       ('DomainHandle',SAMPR_HANDLE),\n       ('Name', RPC_UNICODE_STRING),\n       ('AccountType', ULONG),\n       ('DesiredAccess', ULONG),\n    )",
  "class SamrCreateUser2InDomainResponse(NDRCALL):\n    structure = (\n       ('UserHandle',SAMPR_HANDLE),\n       ('GrantedAccess',ULONG),\n       ('RelativeId',ULONG),\n       ('ErrorCode',ULONG),\n    )",
  "class SamrQueryDisplayInformation3(NDRCALL):\n    opnum = 51\n    structure = (\n       ('DomainHandle',SAMPR_HANDLE),\n       ('DisplayInformationClass', DOMAIN_DISPLAY_INFORMATION),\n       ('Index', ULONG),\n       ('EntryCount',ULONG),\n       ('PreferredMaximumLength',ULONG),\n    )",
  "class SamrQueryDisplayInformation3Response(NDRCALL):\n    structure = (\n       ('TotalAvailable',ULONG),\n       ('TotalReturned',ULONG),\n       ('Buffer',SAMPR_DISPLAY_INFO_BUFFER),\n       ('ErrorCode',ULONG),\n    )",
  "class SamrAddMultipleMembersToAlias(NDRCALL):\n    opnum = 52\n    structure = (\n       ('AliasHandle',SAMPR_HANDLE),\n       ('MembersBuffer', SAMPR_PSID_ARRAY),\n    )",
  "class SamrAddMultipleMembersToAliasResponse(NDRCALL):\n    structure = (\n       ('ErrorCode',ULONG),\n    )",
  "class SamrRemoveMultipleMembersFromAlias(NDRCALL):\n    opnum = 53\n    structure = (\n       ('AliasHandle',SAMPR_HANDLE),\n       ('MembersBuffer', SAMPR_PSID_ARRAY),\n    )",
  "class SamrRemoveMultipleMembersFromAliasResponse(NDRCALL):\n    structure = (\n       ('ErrorCode',ULONG),\n    )",
  "class SamrOemChangePasswordUser2(NDRCALL):\n    opnum = 54\n    structure = (\n       ('ServerName', PRPC_STRING),\n       ('UserName', RPC_STRING),\n       ('NewPasswordEncryptedWithOldLm', PSAMPR_ENCRYPTED_USER_PASSWORD),\n       ('OldLmOwfPasswordEncryptedWithNewLm', PENCRYPTED_LM_OWF_PASSWORD),\n    )",
  "class SamrOemChangePasswordUser2Response(NDRCALL):\n    structure = (\n       ('ErrorCode',ULONG),\n    )",
  "class SamrUnicodeChangePasswordUser2(NDRCALL):\n    opnum = 55\n    structure = (\n       ('ServerName', PRPC_UNICODE_STRING),\n       ('UserName', RPC_UNICODE_STRING),\n       ('NewPasswordEncryptedWithOldNt',PSAMPR_ENCRYPTED_USER_PASSWORD),\n       ('OldNtOwfPasswordEncryptedWithNewNt',PENCRYPTED_NT_OWF_PASSWORD),\n       ('LmPresent',UCHAR),\n       ('NewPasswordEncryptedWithOldLm',PSAMPR_ENCRYPTED_USER_PASSWORD),\n       ('OldLmOwfPasswordEncryptedWithNewNt',PENCRYPTED_LM_OWF_PASSWORD),\n    )",
  "class SamrUnicodeChangePasswordUser2Response(NDRCALL):\n    structure = (\n       ('ErrorCode',ULONG),\n    )",
  "class SamrGetDomainPasswordInformation(NDRCALL):\n    opnum = 56\n    structure = (\n       #('BindingHandle',SAMPR_HANDLE),\n       ('Unused', PRPC_UNICODE_STRING),\n    )",
  "class SamrGetDomainPasswordInformationResponse(NDRCALL):\n    structure = (\n       ('PasswordInformation',USER_DOMAIN_PASSWORD_INFORMATION),\n       ('ErrorCode',ULONG),\n    )",
  "class SamrConnect2(NDRCALL):\n    opnum = 57\n    structure = (\n       ('ServerName',PSAMPR_SERVER_NAME),\n       ('DesiredAccess', ULONG),\n    )",
  "class SamrConnect2Response(NDRCALL):\n    structure = (\n       ('ServerHandle',SAMPR_HANDLE),\n       ('ErrorCode',ULONG),\n    )",
  "class SamrSetInformationUser2(NDRCALL):\n    opnum = 58\n    structure = (\n       ('UserHandle',SAMPR_HANDLE),\n       ('UserInformationClass', USER_INFORMATION_CLASS),\n       ('Buffer', SAMPR_USER_INFO_BUFFER),\n    )",
  "class SamrSetInformationUser2Response(NDRCALL):\n    structure = (\n       ('ErrorCode',ULONG),\n    )",
  "class SamrConnect4(NDRCALL):\n    opnum = 62\n    structure = (\n       ('ServerName',PSAMPR_SERVER_NAME),\n       ('ClientRevision', ULONG),\n       ('DesiredAccess', ULONG),\n    )",
  "class SamrConnect4Response(NDRCALL):\n    structure = (\n       ('ServerHandle',SAMPR_HANDLE),\n       ('ErrorCode',ULONG),\n    )",
  "class SamrConnect5(NDRCALL):\n    opnum = 64\n    structure = (\n       ('ServerName',PSAMPR_SERVER_NAME),\n       ('DesiredAccess', ULONG),\n       ('InVersion', ULONG),\n       ('InRevisionInfo',SAMPR_REVISION_INFO),\n    )",
  "class SamrConnect5Response(NDRCALL):\n    structure = (\n       ('OutVersion',ULONG),\n       ('OutRevisionInfo',SAMPR_REVISION_INFO),\n       ('ServerHandle',SAMPR_HANDLE),\n       ('ErrorCode',ULONG),\n    )",
  "class SamrRidToSid(NDRCALL):\n    opnum = 65\n    structure = (\n       ('ObjectHandle',SAMPR_HANDLE),\n       ('Rid', ULONG),\n    )",
  "class SamrRidToSidResponse(NDRCALL):\n    structure = (\n       ('Sid',PRPC_SID),\n       ('ErrorCode',ULONG),\n    )",
  "class SamrSetDSRMPassword(NDRCALL):\n    opnum = 66\n    structure = (\n       ('Unused', PRPC_UNICODE_STRING),\n       ('UserId',ULONG),\n       ('EncryptedNtOwfPassword',PENCRYPTED_NT_OWF_PASSWORD),\n    )",
  "class SamrSetDSRMPasswordResponse(NDRCALL):\n    structure = (\n       ('ErrorCode',ULONG),\n    )",
  "class SamrValidatePassword(NDRCALL):\n    opnum = 67\n    structure = (\n       ('ValidationType', PASSWORD_POLICY_VALIDATION_TYPE),\n       ('InputArg',SAM_VALIDATE_INPUT_ARG),\n    )",
  "class SamrValidatePasswordResponse(NDRCALL):\n    structure = (\n       ('OutputArg',PSAM_VALIDATE_OUTPUT_ARG),\n       ('ErrorCode',ULONG),\n    )",
  "def hSamrConnect5(dce, serverName='\\x00', desiredAccess=MAXIMUM_ALLOWED, inVersion=1, revision=3):\n    request = SamrConnect5()\n    request['ServerName'] = serverName\n    request['DesiredAccess'] = desiredAccess\n    request['InVersion'] = inVersion\n    request['InRevisionInfo']['tag'] = inVersion\n    request['InRevisionInfo']['V1']['Revision'] = revision\n    return dce.request(request)",
  "def hSamrConnect4(dce, serverName='\\x00', desiredAccess=MAXIMUM_ALLOWED, clientRevision=2):\n    request = SamrConnect4()\n    request['ServerName'] = serverName\n    request['DesiredAccess'] = desiredAccess\n    request['ClientRevision'] = clientRevision\n    return dce.request(request)",
  "def hSamrConnect2(dce, serverName='\\x00', desiredAccess=MAXIMUM_ALLOWED):\n    request = SamrConnect2()\n    request['ServerName'] = serverName\n    request['DesiredAccess'] = desiredAccess\n    return dce.request(request)",
  "def hSamrConnect(dce, serverName='\\x00', desiredAccess=MAXIMUM_ALLOWED):\n    request = SamrConnect()\n    request['ServerName'] = serverName\n    request['DesiredAccess'] = desiredAccess\n    return dce.request(request)",
  "def hSamrOpenDomain(dce, serverHandle, desiredAccess=MAXIMUM_ALLOWED, domainId=NULL):\n    request = SamrOpenDomain()\n    request['ServerHandle'] = serverHandle\n    request['DesiredAccess'] = desiredAccess\n    request['DomainId'] = domainId\n    return dce.request(request)",
  "def hSamrOpenGroup(dce, domainHandle, desiredAccess=MAXIMUM_ALLOWED, groupId=0):\n    request = SamrOpenGroup()\n    request['DomainHandle'] = domainHandle\n    request['DesiredAccess'] = desiredAccess\n    request['GroupId'] = groupId\n    return dce.request(request)",
  "def hSamrOpenAlias(dce, domainHandle, desiredAccess=MAXIMUM_ALLOWED, aliasId=0):\n    request = SamrOpenAlias()\n    request['DomainHandle'] = domainHandle\n    request['DesiredAccess'] = desiredAccess\n    request['AliasId'] = aliasId\n    return dce.request(request)",
  "def hSamrOpenUser(dce, domainHandle, desiredAccess=MAXIMUM_ALLOWED, userId=0):\n    request = SamrOpenUser()\n    request['DomainHandle'] = domainHandle\n    request['DesiredAccess'] = desiredAccess\n    request['UserId'] = userId\n    return dce.request(request)",
  "def hSamrEnumerateDomainsInSamServer(dce, serverHandle, enumerationContext=0, preferedMaximumLength=0xffffffff):\n    request = SamrEnumerateDomainsInSamServer()\n    request['ServerHandle'] = serverHandle\n    request['EnumerationContext'] = enumerationContext\n    request['PreferedMaximumLength'] = preferedMaximumLength\n    return dce.request(request)",
  "def hSamrEnumerateGroupsInDomain(dce, domainHandle, enumerationContext=0, preferedMaximumLength=0xffffffff):\n    request = SamrEnumerateGroupsInDomain()\n    request['DomainHandle'] = domainHandle\n    request['EnumerationContext'] = enumerationContext\n    request['PreferedMaximumLength'] = preferedMaximumLength\n    return dce.request(request)",
  "def hSamrEnumerateAliasesInDomain(dce, domainHandle, enumerationContext=0, preferedMaximumLength=0xffffffff):\n    request = SamrEnumerateAliasesInDomain()\n    request['DomainHandle'] = domainHandle\n    request['EnumerationContext'] = enumerationContext\n    request['PreferedMaximumLength'] = preferedMaximumLength\n    return dce.request(request)",
  "def hSamrEnumerateUsersInDomain(dce, domainHandle, userAccountControl=USER_NORMAL_ACCOUNT, enumerationContext=0, preferedMaximumLength=0xffffffff):\n    request = SamrEnumerateUsersInDomain()\n    request['DomainHandle'] = domainHandle\n    request['UserAccountControl'] = userAccountControl\n    request['EnumerationContext'] = enumerationContext\n    request['PreferedMaximumLength'] = preferedMaximumLength\n    return dce.request(request)",
  "def hSamrQueryDisplayInformation3(dce, domainHandle, displayInformationClass=DOMAIN_DISPLAY_INFORMATION.DomainDisplayUser, index=0, entryCount=0xffffffff, preferedMaximumLength=0xffffffff):\n    request = SamrQueryDisplayInformation3()\n    request['DomainHandle'] = domainHandle\n    request['DisplayInformationClass'] = displayInformationClass\n    request['Index'] = index\n    request['EntryCount'] = entryCount\n    request['PreferredMaximumLength'] = preferedMaximumLength\n    return dce.request(request)",
  "def hSamrQueryDisplayInformation2(dce, domainHandle, displayInformationClass=DOMAIN_DISPLAY_INFORMATION.DomainDisplayUser, index=0, entryCount=0xffffffff, preferedMaximumLength=0xffffffff):\n    request = SamrQueryDisplayInformation2()\n    request['DomainHandle'] = domainHandle\n    request['DisplayInformationClass'] = displayInformationClass\n    request['Index'] = index\n    request['EntryCount'] = entryCount\n    request['PreferredMaximumLength'] = preferedMaximumLength\n    return dce.request(request)",
  "def hSamrQueryDisplayInformation(dce, domainHandle, displayInformationClass=DOMAIN_DISPLAY_INFORMATION.DomainDisplayUser, index=0, entryCount=0xffffffff, preferedMaximumLength=0xffffffff):\n    request = SamrQueryDisplayInformation()\n    request['DomainHandle'] = domainHandle\n    request['DisplayInformationClass'] = displayInformationClass\n    request['Index'] = index\n    request['EntryCount'] = entryCount\n    request['PreferredMaximumLength'] = preferedMaximumLength\n    return dce.request(request)",
  "def hSamrGetDisplayEnumerationIndex2(dce, domainHandle, displayInformationClass=DOMAIN_DISPLAY_INFORMATION.DomainDisplayUser, prefix=''):\n    request = SamrGetDisplayEnumerationIndex2()\n    request['DomainHandle'] = domainHandle\n    request['DisplayInformationClass'] = displayInformationClass\n    request['Prefix'] = prefix\n    return dce.request(request)",
  "def hSamrGetDisplayEnumerationIndex(dce, domainHandle, displayInformationClass=DOMAIN_DISPLAY_INFORMATION.DomainDisplayUser, prefix=''):\n    request = SamrGetDisplayEnumerationIndex()\n    request['DomainHandle'] = domainHandle\n    request['DisplayInformationClass'] = displayInformationClass\n    request['Prefix'] = prefix\n    return dce.request(request)",
  "def hSamrCreateGroupInDomain(dce, domainHandle, name, desiredAccess=GROUP_ALL_ACCESS):\n    request = SamrCreateGroupInDomain()\n    request['DomainHandle'] = domainHandle\n    request['Name'] = name\n    request['DesiredAccess'] = desiredAccess\n    return dce.request(request)",
  "def hSamrCreateAliasInDomain(dce, domainHandle, accountName, desiredAccess=GROUP_ALL_ACCESS):\n    request = SamrCreateAliasInDomain()\n    request['DomainHandle'] = domainHandle\n    request['AccountName'] = accountName\n    request['DesiredAccess'] = desiredAccess\n    return dce.request(request)",
  "def hSamrCreateUser2InDomain(dce, domainHandle, name, accountType=USER_NORMAL_ACCOUNT, desiredAccess=GROUP_ALL_ACCESS):\n    request = SamrCreateUser2InDomain()\n    request['DomainHandle'] = domainHandle\n    request['Name'] = name\n    request['AccountType'] = accountType\n    request['DesiredAccess'] = desiredAccess\n    return dce.request(request)",
  "def hSamrCreateUserInDomain(dce, domainHandle, name, desiredAccess=GROUP_ALL_ACCESS):\n    request = SamrCreateUserInDomain()\n    request['DomainHandle'] = domainHandle\n    request['Name'] = name\n    request['DesiredAccess'] = desiredAccess\n    return dce.request(request)",
  "def hSamrQueryInformationDomain(dce, domainHandle, domainInformationClass=DOMAIN_INFORMATION_CLASS.DomainGeneralInformation2):\n    request = SamrQueryInformationDomain()\n    request['DomainHandle'] = domainHandle\n    request['DomainInformationClass'] = domainInformationClass\n    return dce.request(request)",
  "def hSamrQueryInformationDomain2(dce, domainHandle, domainInformationClass=DOMAIN_INFORMATION_CLASS.DomainGeneralInformation2):\n    request = SamrQueryInformationDomain2()\n    request['DomainHandle'] = domainHandle\n    request['DomainInformationClass'] = domainInformationClass\n    return dce.request(request)",
  "def hSamrQueryInformationGroup(dce, groupHandle, groupInformationClass=GROUP_INFORMATION_CLASS.GroupGeneralInformation):\n    request = SamrQueryInformationGroup()\n    request['GroupHandle'] = groupHandle\n    request['GroupInformationClass'] = groupInformationClass\n    return dce.request(request)",
  "def hSamrQueryInformationAlias(dce, aliasHandle, aliasInformationClass=ALIAS_INFORMATION_CLASS.AliasGeneralInformation):\n    request = SamrQueryInformationAlias()\n    request['AliasHandle'] = aliasHandle\n    request['AliasInformationClass'] = aliasInformationClass\n    return dce.request(request)",
  "def hSamrQueryInformationUser2(dce, userHandle, userInformationClass=USER_INFORMATION_CLASS.UserGeneralInformation):\n    request = SamrQueryInformationUser2()\n    request['UserHandle'] = userHandle\n    request['UserInformationClass'] = userInformationClass\n    return dce.request(request)",
  "def hSamrQueryInformationUser(dce, userHandle, userInformationClass=USER_INFORMATION_CLASS.UserGeneralInformation):\n    request = SamrQueryInformationUser()\n    request['UserHandle'] = userHandle\n    request['UserInformationClass'] = userInformationClass\n    return dce.request(request)",
  "def hSamrSetInformationDomain(dce, domainHandle, domainInformation):\n    request = SamrSetInformationDomain()\n    request['DomainHandle'] = domainHandle\n    request['DomainInformationClass'] = domainInformation['tag']\n    request['DomainInformation'] = domainInformation\n    return dce.request(request)",
  "def hSamrSetInformationGroup(dce, groupHandle, buffer):\n    request = SamrSetInformationGroup()\n    request['GroupHandle'] = groupHandle\n    request['GroupInformationClass'] = buffer['tag']\n    request['Buffer'] = buffer\n    return dce.request(request)",
  "def hSamrSetInformationAlias(dce, aliasHandle, buffer):\n    request = SamrSetInformationAlias()\n    request['AliasHandle'] = aliasHandle\n    request['AliasInformationClass'] = buffer['tag']\n    request['Buffer'] = buffer\n    return dce.request(request)",
  "def hSamrSetInformationUser2(dce, userHandle, buffer):\n    request = SamrSetInformationUser2()\n    request['UserHandle'] = userHandle\n    request['UserInformationClass'] = buffer['tag']\n    request['Buffer'] = buffer\n    return dce.request(request)",
  "def hSamrSetInformationUser(dce, userHandle, buffer):\n    request = SamrSetInformationUser()\n    request['UserHandle'] = userHandle\n    request['UserInformationClass'] = buffer['tag']\n    request['Buffer'] = buffer\n    return dce.request(request)",
  "def hSamrDeleteGroup(dce, groupHandle):\n    request = SamrDeleteGroup()\n    request['GroupHandle'] = groupHandle\n    return dce.request(request)",
  "def hSamrDeleteAlias(dce, aliasHandle):\n    request = SamrDeleteAlias()\n    request['AliasHandle'] = aliasHandle\n    return dce.request(request)",
  "def hSamrDeleteUser(dce, userHandle):\n    request = SamrDeleteUser()\n    request['UserHandle'] = userHandle\n    return dce.request(request)",
  "def hSamrAddMemberToGroup(dce, groupHandle, memberId, attributes):\n    request = SamrAddMemberToGroup()\n    request['GroupHandle'] = groupHandle\n    request['MemberId'] = memberId\n    request['Attributes'] = attributes\n    return dce.request(request)",
  "def hSamrRemoveMemberFromGroup(dce, groupHandle, memberId):\n    request = SamrRemoveMemberFromGroup()\n    request['GroupHandle'] = groupHandle\n    request['MemberId'] = memberId\n    return dce.request(request)",
  "def hSamrGetMembersInGroup(dce, groupHandle):\n    request = SamrGetMembersInGroup()\n    request['GroupHandle'] = groupHandle\n    return dce.request(request)",
  "def hSamrAddMemberToAlias(dce, aliasHandle, memberId):\n    request = SamrAddMemberToAlias()\n    request['AliasHandle'] = aliasHandle\n    request['MemberId'] = memberId\n    return dce.request(request)",
  "def hSamrRemoveMemberFromAlias(dce, aliasHandle, memberId):\n    request = SamrRemoveMemberFromAlias()\n    request['AliasHandle'] = aliasHandle\n    request['MemberId'] = memberId\n    return dce.request(request)",
  "def hSamrGetMembersInAlias(dce, aliasHandle):\n    request = SamrGetMembersInAlias()\n    request['AliasHandle'] = aliasHandle\n    return dce.request(request)",
  "def hSamrRemoveMemberFromForeignDomain(dce, domainHandle, memberSid):\n    request = SamrRemoveMemberFromForeignDomain()\n    request['DomainHandle'] = domainHandle\n    request['MemberSid'] = memberSid\n    return dce.request(request)",
  "def hSamrAddMultipleMembersToAlias(dce, aliasHandle, membersBuffer):\n    request = SamrAddMultipleMembersToAlias()\n    request['AliasHandle'] = aliasHandle\n    request['MembersBuffer'] = membersBuffer\n    request['MembersBuffer']['Count'] = len(membersBuffer['Sids'])\n    return dce.request(request)",
  "def hSamrRemoveMultipleMembersFromAlias(dce, aliasHandle, membersBuffer):\n    request = SamrRemoveMultipleMembersFromAlias()\n    request['AliasHandle'] = aliasHandle\n    request['MembersBuffer'] = membersBuffer\n    request['MembersBuffer']['Count'] = len(membersBuffer['Sids'])\n    return dce.request(request)",
  "def hSamrGetGroupsForUser(dce, userHandle):\n    request = SamrGetGroupsForUser()\n    request['UserHandle'] = userHandle\n    return dce.request(request)",
  "def hSamrGetAliasMembership(dce, domainHandle, sidArray):\n    request = SamrGetAliasMembership()\n    request['DomainHandle'] = domainHandle\n    request['SidArray'] = sidArray\n    request['SidArray']['Count'] = len(sidArray['Sids'])\n    return dce.request(request)",
  "def hSamrChangePasswordUser(dce, userHandle, oldPassword, newPassword, oldPwdHashNT='', newPwdHashLM='', newPwdHashNT=''):\n    request = SamrChangePasswordUser()\n    request['UserHandle'] = userHandle\n\n    from impacket import crypto, ntlm\n\n    if oldPwdHashNT == '':\n        oldPwdHashNT = ntlm.NTOWFv1(oldPassword)\n    else:\n        # Let's convert the hashes to binary form, if not yet\n        try:\n            oldPwdHashNT = unhexlify(oldPwdHashNT)\n        except:\n            pass\n\n    if newPwdHashLM == '':\n        newPwdHashLM = ntlm.LMOWFv1(newPassword)\n    else:\n        # Let's convert the hashes to binary form, if not yet\n        try:\n            newPwdHashLM = unhexlify(newPwdHashLM)\n        except:\n            pass\n\n    if newPwdHashNT == '':\n        newPwdHashNT = ntlm.NTOWFv1(newPassword)\n    else:\n        # Let's convert the hashes to binary form, if not yet\n        try:\n            newPwdHashNT = unhexlify(newPwdHashNT)\n        except:\n            pass\n\n    request['LmPresent'] = 0\n    request['OldLmEncryptedWithNewLm'] = NULL\n    request['NewLmEncryptedWithOldLm'] = NULL\n    request['NtPresent'] = 1\n    request['OldNtEncryptedWithNewNt'] = crypto.SamEncryptNTLMHash(oldPwdHashNT, newPwdHashNT)\n    request['NewNtEncryptedWithOldNt'] = crypto.SamEncryptNTLMHash(newPwdHashNT, oldPwdHashNT)\n    request['NtCrossEncryptionPresent'] = 0\n    request['NewNtEncryptedWithNewLm'] = NULL\n    request['LmCrossEncryptionPresent'] = 1\n    request['NewLmEncryptedWithNewNt'] = crypto.SamEncryptNTLMHash(newPwdHashLM, newPwdHashNT)\n\n    return dce.request(request)",
  "def hSamrUnicodeChangePasswordUser2(dce, serverName='\\x00', userName='', oldPassword='', newPassword='', oldPwdHashLM = '', oldPwdHashNT = ''):\n    request = SamrUnicodeChangePasswordUser2()\n    request['ServerName'] = serverName\n    request['UserName'] = userName\n\n    try:\n        from Cryptodome.Cipher import ARC4\n    except Exception:\n        LOG.critical(\"Warning: You don't have any crypto installed. You need pycryptodomex\")\n        LOG.critical(\"See https://pypi.org/project/pycryptodomex/\")\n    from impacket import crypto, ntlm\n\n    if oldPwdHashLM == '' and oldPwdHashNT == '':\n        oldPwdHashLM = ntlm.LMOWFv1(oldPassword)\n        oldPwdHashNT = ntlm.NTOWFv1(oldPassword)\n    else:\n        # Let's convert the hashes to binary form, if not yet\n        try:\n            oldPwdHashLM = unhexlify(oldPwdHashLM)\n        except:\n            pass\n        try:\n            oldPwdHashNT = unhexlify(oldPwdHashNT)\n        except:\n            pass\n\n    newPwdHashNT = ntlm.NTOWFv1(newPassword)\n\n    samUser = SAMPR_USER_PASSWORD()\n    try:\n        samUser['Buffer'] = b'A'*(512-len(newPassword)*2) + newPassword.encode('utf-16le')\n    except UnicodeDecodeError:\n        import sys\n        samUser['Buffer'] = b'A'*(512-len(newPassword)*2) + newPassword.decode(sys.getfilesystemencoding()).encode('utf-16le')\n\n    samUser['Length'] = len(newPassword)*2\n    pwdBuff = samUser.getData()\n\n    rc4 = ARC4.new(oldPwdHashNT)\n    encBuf = rc4.encrypt(pwdBuff)\n    request['NewPasswordEncryptedWithOldNt']['Buffer'] = encBuf\n    request['OldNtOwfPasswordEncryptedWithNewNt'] = crypto.SamEncryptNTLMHash(oldPwdHashNT, newPwdHashNT)\n    request['LmPresent'] = 0\n    request['NewPasswordEncryptedWithOldLm'] = NULL\n    request['OldLmOwfPasswordEncryptedWithNewNt'] = NULL\n\n    return dce.request(request)",
  "def hSamrLookupDomainInSamServer(dce, serverHandle, name):\n    request = SamrLookupDomainInSamServer()\n    request['ServerHandle'] = serverHandle\n    request['Name'] = name\n    return dce.request(request)",
  "def hSamrSetSecurityObject(dce, objectHandle, securityInformation, securityDescriptor):\n    request = SamrSetSecurityObject()\n    request['ObjectHandle'] =  objectHandle\n    request['SecurityInformation'] =  securityInformation\n    request['SecurityDescriptor'] = securityDescriptor\n    return dce.request(request)",
  "def hSamrQuerySecurityObject(dce, objectHandle, securityInformation):\n    request = SamrQuerySecurityObject()\n    request['ObjectHandle'] =  objectHandle\n    request['SecurityInformation'] =  securityInformation\n    return dce.request(request)",
  "def hSamrCloseHandle(dce, samHandle):\n    request = SamrCloseHandle()\n    request['SamHandle'] =  samHandle\n    return dce.request(request)",
  "def hSamrSetMemberAttributesOfGroup(dce, groupHandle, memberId, attributes):\n    request = SamrSetMemberAttributesOfGroup()\n    request['GroupHandle'] =  groupHandle\n    request['MemberId'] =  memberId\n    request['Attributes'] =  attributes\n    return dce.request(request)",
  "def hSamrGetUserDomainPasswordInformation(dce, userHandle):\n    request = SamrGetUserDomainPasswordInformation()\n    request['UserHandle'] =  userHandle\n    return dce.request(request)",
  "def hSamrGetDomainPasswordInformation(dce):\n    request = SamrGetDomainPasswordInformation()\n    request['Unused'] =  NULL\n    return dce.request(request)",
  "def hSamrRidToSid(dce, objectHandle, rid):\n    request = SamrRidToSid()\n    request['ObjectHandle'] = objectHandle\n    request['Rid'] =  rid\n    return dce.request(request)",
  "def hSamrValidatePassword(dce, inputArg):\n    request = SamrValidatePassword()\n    request['ValidationType'] =  inputArg['tag']\n    request['InputArg'] = inputArg\n    return dce.request(request)",
  "def hSamrLookupNamesInDomain(dce, domainHandle, names):\n    request = SamrLookupNamesInDomain()\n    request['DomainHandle'] =  domainHandle\n    request['Count'] = len(names)\n    for name in names:\n        entry = RPC_UNICODE_STRING()\n        entry['Data'] = name\n        request['Names'].append(entry)\n\n    request.fields['Names'].fields['MaximumCount'] = 1000\n\n    return dce.request(request)",
  "def hSamrLookupIdsInDomain(dce, domainHandle, ids):\n    request = SamrLookupIdsInDomain()\n    request['DomainHandle'] =  domainHandle\n    request['Count'] = len(ids)\n    for dId in ids:\n        entry = ULONG()\n        entry['Data'] = dId\n        request['RelativeIds'].append(entry)\n\n    request.fields['RelativeIds'].fields['MaximumCount'] = 1000\n\n    return dce.request(request)",
  "def hSamrSetPasswordInternal4New(dce, userHandle, password):\n    request = SamrSetInformationUser2()\n    request['UserHandle'] = userHandle\n    request['UserInformationClass'] = USER_INFORMATION_CLASS.UserInternal4InformationNew\n    request['Buffer']['tag'] = USER_INFORMATION_CLASS.UserInternal4InformationNew\n    request['Buffer']['Internal4New']['I1']['WhichFields'] = 0x01000000 | 0x08000000\n\n    request['Buffer']['Internal4New']['I1']['UserName'] = NULL\n    request['Buffer']['Internal4New']['I1']['FullName'] = NULL\n    request['Buffer']['Internal4New']['I1']['HomeDirectory'] = NULL\n    request['Buffer']['Internal4New']['I1']['HomeDirectoryDrive'] = NULL\n    request['Buffer']['Internal4New']['I1']['ScriptPath'] = NULL\n    request['Buffer']['Internal4New']['I1']['ProfilePath'] = NULL\n    request['Buffer']['Internal4New']['I1']['AdminComment'] = NULL\n    request['Buffer']['Internal4New']['I1']['WorkStations'] = NULL\n    request['Buffer']['Internal4New']['I1']['UserComment'] = NULL\n    request['Buffer']['Internal4New']['I1']['Parameters'] = NULL\n    request['Buffer']['Internal4New']['I1']['LmOwfPassword']['Buffer'] = NULL\n    request['Buffer']['Internal4New']['I1']['NtOwfPassword']['Buffer'] = NULL\n    request['Buffer']['Internal4New']['I1']['PrivateData'] = NULL\n    request['Buffer']['Internal4New']['I1']['SecurityDescriptor']['SecurityDescriptor'] = NULL\n    request['Buffer']['Internal4New']['I1']['LogonHours']['LogonHours'] = NULL\n    request['Buffer']['Internal4New']['I1']['PasswordExpired'] = 1\n\n    #crypto\n    pwdbuff = password.encode(\"utf-16le\")\n    bufflen = len(pwdbuff)\n    pwdbuff = pwdbuff.rjust(512, b'\\0')\n    pwdbuff += struct.pack('<I', bufflen)\n    salt = os.urandom(16)\n    session_key = dce.get_rpc_transport().get_smb_connection().getSessionKey()\n    keymd = md5()\n    keymd.update(salt)\n    keymd.update(session_key)\n    key = keymd.digest()\n\n    cipher = ARC4.new(key)\n    buffercrypt = cipher.encrypt(pwdbuff) + salt\n\n    request['Buffer']['Internal4New']['UserPassword']['Buffer'] = buffercrypt\n    return dce.request(request)",
  "def hSamrSetNTInternal1(dce, userHandle, password, hashNT=''):\n    request = SamrSetInformationUser()\n    request['UserHandle'] = userHandle\n    request['UserInformationClass'] = USER_INFORMATION_CLASS.UserInternal1Information\n    request['Buffer']['tag'] = USER_INFORMATION_CLASS.UserInternal1Information\n\n    from impacket import crypto, ntlm\n\n    if hashNT == '':\n        hashNT = ntlm.NTOWFv1(password)\n    else:\n        # Let's convert the hashes to binary form, if not yet\n        try:\n            hashNT = unhexlify(hashNT)\n        except:\n            pass\n\n    session_key = dce.get_rpc_transport().get_smb_connection().getSessionKey()\n\n    request['Buffer']['Internal1']['EncryptedNtOwfPassword'] = crypto.SamEncryptNTLMHash(hashNT, session_key)\n    request['Buffer']['Internal1']['EncryptedLmOwfPassword'] = NULL\n    request['Buffer']['Internal1']['NtPasswordPresent'] = 1\n    request['Buffer']['Internal1']['LmPasswordPresent'] = 0\n\n    return dce.request(request)",
  "def __init__(self, error_string=None, error_code=None, packet=None):\n        DCERPCException.__init__(self, error_string, error_code, packet)",
  "def __str__( self ):\n        key = self.error_code\n        if key in nt_errors.ERROR_MESSAGES:\n            error_msg_short = nt_errors.ERROR_MESSAGES[key][0]\n            error_msg_verbose = nt_errors.ERROR_MESSAGES[key][1]\n            return 'SAMR SessionError: code: 0x%x - %s - %s' % (self.error_code, error_msg_short, error_msg_verbose)\n        else:\n            return 'SAMR SessionError: unknown error code: 0x%x' % self.error_code",
  "def dump(self, msg = None, indent = 0):\n        if msg is None:\n            msg = self.__class__.__name__\n        if msg != '':\n            print(\"%s\" % msg, end=' ')\n        # Here just print the data\n        print(\" %r\" % (self['Data']), end=' ')",
  "class enumItems(Enum):\n        SidTypeUser            = 1\n        SidTypeGroup           = 2\n        SidTypeDomain          = 3\n        SidTypeAlias           = 4\n        SidTypeWellKnownGroup  = 5\n        SidTypeDeletedAccount  = 6\n        SidTypeInvalid         = 7\n        SidTypeUnknown         = 8\n        SidTypeComputer        = 9\n        SidTypeLabel           = 10",
  "def getAlignment(self):\n        if self._isNDR64 is True:\n            return 8\n        else:\n            return 4",
  "def getAlignment(self):\n        return 1",
  "class enumItems(Enum):\n        DomainServerEnabled  = 1\n        DomainServerDisabled = 2",
  "class enumItems(Enum):\n        DomainServerRoleBackup  = 2\n        DomainServerRolePrimary = 3",
  "class enumItems(Enum):\n        DomainPasswordInformation    = 1\n        DomainGeneralInformation     = 2\n        DomainLogoffInformation      = 3\n        DomainOemInformation         = 4\n        DomainNameInformation        = 5\n        DomainReplicationInformation = 6\n        DomainServerRoleInformation  = 7\n        DomainModifiedInformation    = 8\n        DomainStateInformation       = 9\n        DomainGeneralInformation2    = 11\n        DomainLockoutInformation     = 12\n        DomainModifiedInformation2   = 13",
  "class enumItems(Enum):\n        GroupGeneralInformation      = 1\n        GroupNameInformation         = 2\n        GroupAttributeInformation    = 3\n        GroupAdminCommentInformation = 4\n        GroupReplicationInformation  = 5",
  "class enumItems(Enum):\n        AliasGeneralInformation      = 1\n        AliasNameInformation         = 2\n        AliasAdminCommentInformation = 3",
  "def getData(self, soFar = 0):\n        if self['LogonHours'] != 0:\n            self['UnitsPerWeek'] = len(self['LogonHours']) * 8\n        return NDR.getData(self, soFar)",
  "def getAlignment(self):\n        return 4",
  "def getAlignment(self):\n        return 1",
  "def getAlignment(self):\n        return 1",
  "class enumItems(Enum):\n        UserGeneralInformation      = 1\n        UserPreferencesInformation  = 2\n        UserLogonInformation        = 3\n        UserLogonHoursInformation   = 4\n        UserAccountInformation      = 5\n        UserNameInformation         = 6\n        UserAccountNameInformation  = 7\n        UserFullNameInformation     = 8\n        UserPrimaryGroupInformation = 9\n        UserHomeInformation         = 10\n        UserScriptInformation       = 11\n        UserProfileInformation      = 12\n        UserAdminCommentInformation = 13\n        UserWorkStationsInformation = 14\n        UserControlInformation      = 16\n        UserExpiresInformation      = 17\n        UserInternal1Information    = 18\n        UserParametersInformation   = 20\n        UserAllInformation          = 21\n        UserInternal4Information    = 23\n        UserInternal5Information    = 24\n        UserInternal4InformationNew = 25\n        UserInternal5InformationNew = 26",
  "class enumItems(Enum):\n        DomainDisplayUser     = 1\n        DomainDisplayMachine  = 2\n        DomainDisplayGroup    = 3\n        DomainDisplayOemUser  = 4\n        DomainDisplayOemGroup = 5",
  "class enumItems(Enum):\n        SamValidateSuccess                  = 0\n        SamValidatePasswordMustChange       = 1\n        SamValidateAccountLockedOut         = 2\n        SamValidatePasswordExpired          = 3\n        SamValidatePasswordIncorrect        = 4\n        SamValidatePasswordIsInHistory      = 5\n        SamValidatePasswordTooShort         = 6\n        SamValidatePasswordTooLong          = 7\n        SamValidatePasswordNotComplexEnough = 8\n        SamValidatePasswordTooRecent        = 9\n        SamValidatePasswordFilterError      = 10",
  "class enumItems(Enum):\n        SamValidateAuthentication   = 1\n        SamValidatePasswordChange   = 2\n        SamValidatePasswordReset    = 3",
  "class DCERPCSessionError(DCERPCException):\n    def __init__(self, error_string=None, error_code=None, packet=None):\n        DCERPCException.__init__(self, error_string, error_code, packet)\n\n    def __str__( self ):\n        key = self.error_code\n        if key in system_errors.ERROR_MESSAGES:\n            error_msg_short = system_errors.ERROR_MESSAGES[key][0]\n            error_msg_verbose = system_errors.ERROR_MESSAGES[key][1]\n            return 'RRP SessionError: code: 0x%x - %s - %s' % (self.error_code, error_msg_short, error_msg_verbose)\n        else:\n            return 'RRP SessionError: unknown error code: 0x%x' % self.error_code",
  "class RPC_HKEY(NDRSTRUCT):\n    structure =  (\n        ('context_handle_attributes',ULONG),\n        ('context_handle_uuid',UUID),\n    )\n\n    def __init__(self, data=None, isNDR64=False):\n        NDRSTRUCT.__init__(self, data, isNDR64)\n        self['context_handle_uuid'] = b'\\x00'*16\n\n    def isNull(self):\n        return self['context_handle_uuid'] == b'\\x00'*16",
  "class RVALENT(NDRSTRUCT):\n    structure =  (\n        ('ve_valuename',PRRP_UNICODE_STRING),\n        ('ve_valuelen',DWORD),\n        ('ve_valueptr',DWORD),\n        ('ve_type',DWORD),\n    )",
  "class RVALENT_ARRAY(NDRUniConformantVaryingArray):\n    item = RVALENT",
  "class BYTE_ARRAY(NDRUniConformantVaryingArray):\n    pass",
  "class PBYTE_ARRAY(NDRPOINTER):\n    referent = (\n        ('Data', BYTE_ARRAY),\n    )",
  "class RPC_SECURITY_DESCRIPTOR(NDRSTRUCT):\n    structure =  (\n        ('lpSecurityDescriptor',PBYTE_ARRAY),\n        ('cbInSecurityDescriptor',DWORD),\n        ('cbOutSecurityDescriptor',DWORD),\n    )",
  "class RPC_SECURITY_ATTRIBUTES(NDRSTRUCT):\n    structure =  (\n        ('nLength',DWORD),\n        ('RpcSecurityDescriptor',RPC_SECURITY_DESCRIPTOR),\n        ('bInheritHandle',BOOLEAN),\n    )",
  "class PRPC_SECURITY_ATTRIBUTES(NDRPOINTER):\n    referent = (\n        ('Data', RPC_SECURITY_ATTRIBUTES),\n    )",
  "class OpenClassesRoot(NDRCALL):\n    opnum = 0\n    structure = (\n       ('ServerName', PREGISTRY_SERVER_NAME),\n       ('samDesired', REGSAM),\n    )",
  "class OpenClassesRootResponse(NDRCALL):\n    structure = (\n       ('phKey', RPC_HKEY),\n       ('ErrorCode', error_status_t),\n    )",
  "class OpenCurrentUser(NDRCALL):\n    opnum = 1\n    structure = (\n       ('ServerName', PREGISTRY_SERVER_NAME),\n       ('samDesired', REGSAM),\n    )",
  "class OpenCurrentUserResponse(NDRCALL):\n    structure = (\n       ('phKey', RPC_HKEY),\n       ('ErrorCode', error_status_t),\n    )",
  "class OpenLocalMachine(NDRCALL):\n    opnum = 2\n    structure = (\n       ('ServerName', PREGISTRY_SERVER_NAME),\n       ('samDesired', REGSAM),\n    )",
  "class OpenLocalMachineResponse(NDRCALL):\n    structure = (\n       ('phKey', RPC_HKEY),\n       ('ErrorCode', error_status_t),\n    )",
  "class OpenPerformanceData(NDRCALL):\n    opnum = 3\n    structure = (\n       ('ServerName', PREGISTRY_SERVER_NAME),\n       ('samDesired', REGSAM),\n    )",
  "class OpenPerformanceDataResponse(NDRCALL):\n    structure = (\n       ('phKey', RPC_HKEY),\n       ('ErrorCode', error_status_t),\n    )",
  "class OpenUsers(NDRCALL):\n    opnum = 4\n    structure = (\n       ('ServerName', PREGISTRY_SERVER_NAME),\n       ('samDesired', REGSAM),\n    )",
  "class OpenUsersResponse(NDRCALL):\n    structure = (\n       ('phKey', RPC_HKEY),\n       ('ErrorCode', error_status_t),\n    )",
  "class BaseRegCloseKey(NDRCALL):\n    opnum = 5\n    structure = (\n       ('hKey', RPC_HKEY),\n    )",
  "class BaseRegCloseKeyResponse(NDRCALL):\n    structure = (\n       ('hKey', RPC_HKEY),\n       ('ErrorCode', error_status_t),\n    )",
  "class BaseRegCreateKey(NDRCALL):\n    opnum = 6\n    structure = (\n       ('hKey', RPC_HKEY),\n       ('lpSubKey', RRP_UNICODE_STRING),\n       ('lpClass', RRP_UNICODE_STRING),\n       ('dwOptions', DWORD),\n       ('samDesired', REGSAM),\n       ('lpSecurityAttributes', PRPC_SECURITY_ATTRIBUTES),\n       ('lpdwDisposition', LPULONG),\n    )",
  "class BaseRegCreateKeyResponse(NDRCALL):\n    structure = (\n       ('phkResult', RPC_HKEY),\n       ('lpdwDisposition', LPULONG),\n       ('ErrorCode', error_status_t),\n    )",
  "class BaseRegDeleteKey(NDRCALL):\n    opnum = 7\n    structure = (\n       ('hKey', RPC_HKEY),\n       ('lpSubKey', RRP_UNICODE_STRING),\n    )",
  "class BaseRegDeleteKeyResponse(NDRCALL):\n    structure = (\n       ('ErrorCode', error_status_t),\n    )",
  "class BaseRegDeleteValue(NDRCALL):\n    opnum = 8\n    structure = (\n       ('hKey', RPC_HKEY),\n       ('lpValueName', RRP_UNICODE_STRING),\n    )",
  "class BaseRegDeleteValueResponse(NDRCALL):\n    structure = (\n       ('ErrorCode', error_status_t),\n    )",
  "class BaseRegEnumKey(NDRCALL):\n    opnum = 9\n    structure = (\n       ('hKey', RPC_HKEY),\n       ('dwIndex', DWORD),\n       ('lpNameIn', RRP_UNICODE_STRING),\n       ('lpClassIn', PRRP_UNICODE_STRING),\n       ('lpftLastWriteTime', PFILETIME),\n    )",
  "class BaseRegEnumKeyResponse(NDRCALL):\n    structure = (\n       ('lpNameOut', RRP_UNICODE_STRING),\n       ('lplpClassOut', PRRP_UNICODE_STRING),\n       ('lpftLastWriteTime', PFILETIME),\n       ('ErrorCode', error_status_t),\n    )",
  "class BaseRegEnumValue(NDRCALL):\n    opnum = 10\n    structure = (\n       ('hKey', RPC_HKEY),\n       ('dwIndex', DWORD),\n       ('lpValueNameIn', RRP_UNICODE_STRING),\n       ('lpType', LPULONG),\n       ('lpData', PBYTE_ARRAY),\n       ('lpcbData', LPULONG),\n       ('lpcbLen', LPULONG),\n    )",
  "class BaseRegEnumValueResponse(NDRCALL):\n    structure = (\n       ('lpValueNameOut', RRP_UNICODE_STRING),\n       ('lpType', LPULONG),\n       ('lpData', PBYTE_ARRAY),\n       ('lpcbData', LPULONG),\n       ('lpcbLen', LPULONG),\n       ('ErrorCode', error_status_t),\n    )",
  "class BaseRegFlushKey(NDRCALL):\n    opnum = 11\n    structure = (\n       ('hKey', RPC_HKEY),\n    )",
  "class BaseRegFlushKeyResponse(NDRCALL):\n    structure = (\n       ('ErrorCode', error_status_t),\n    )",
  "class BaseRegGetKeySecurity(NDRCALL):\n    opnum = 12\n    structure = (\n       ('hKey', RPC_HKEY),\n       ('SecurityInformation', SECURITY_INFORMATION),\n       ('pRpcSecurityDescriptorIn', RPC_SECURITY_DESCRIPTOR),\n    )",
  "class BaseRegGetKeySecurityResponse(NDRCALL):\n    structure = (\n       ('pRpcSecurityDescriptorOut', RPC_SECURITY_DESCRIPTOR),\n       ('ErrorCode', error_status_t),\n    )",
  "class BaseRegLoadKey(NDRCALL):\n    opnum = 13\n    structure = (\n       ('hKey', RPC_HKEY),\n       ('lpSubKey', RRP_UNICODE_STRING),\n       ('lpFile', RRP_UNICODE_STRING),\n    )",
  "class BaseRegLoadKeyResponse(NDRCALL):\n    structure = (\n       ('ErrorCode', error_status_t),\n    )",
  "class BaseRegOpenKey(NDRCALL):\n    opnum = 15\n    structure = (\n       ('hKey', RPC_HKEY),\n       ('lpSubKey', RRP_UNICODE_STRING),\n       ('dwOptions', DWORD),\n       ('samDesired', REGSAM),\n    )",
  "class BaseRegOpenKeyResponse(NDRCALL):\n    structure = (\n       ('phkResult', RPC_HKEY),\n       ('ErrorCode', error_status_t),\n    )",
  "class BaseRegQueryInfoKey(NDRCALL):\n    opnum = 16\n    structure = (\n       ('hKey', RPC_HKEY),\n       ('lpClassIn', RRP_UNICODE_STRING),\n    )",
  "class BaseRegQueryInfoKeyResponse(NDRCALL):\n    structure = (\n       ('lpClassOut', RPC_UNICODE_STRING),\n       ('lpcSubKeys', DWORD),\n       ('lpcbMaxSubKeyLen', DWORD),\n       ('lpcbMaxClassLen', DWORD),\n       ('lpcValues', DWORD),\n       ('lpcbMaxValueNameLen', DWORD),\n       ('lpcbMaxValueLen', DWORD),\n       ('lpcbSecurityDescriptor', DWORD),\n       ('lpftLastWriteTime', FILETIME),\n       ('ErrorCode', error_status_t),\n    )",
  "class BaseRegQueryValue(NDRCALL):\n    opnum = 17\n    structure = (\n       ('hKey', RPC_HKEY),\n       ('lpValueName', RRP_UNICODE_STRING),\n       ('lpType', LPULONG),\n       ('lpData', PBYTE_ARRAY),\n       ('lpcbData', LPULONG),\n       ('lpcbLen', LPULONG),\n    )",
  "class BaseRegQueryValueResponse(NDRCALL):\n    structure = (\n       ('lpType', LPULONG),\n       ('lpData', PBYTE_ARRAY),\n       ('lpcbData', LPULONG),\n       ('lpcbLen', LPULONG),\n       ('ErrorCode', error_status_t),\n    )",
  "class BaseRegReplaceKey(NDRCALL):\n    opnum = 18\n    structure = (\n       ('hKey', RPC_HKEY),\n       ('lpSubKey', RRP_UNICODE_STRING),\n       ('lpNewFile', RRP_UNICODE_STRING),\n       ('lpOldFile', RRP_UNICODE_STRING),\n    )",
  "class BaseRegReplaceKeyResponse(NDRCALL):\n    structure = (\n       ('ErrorCode', error_status_t),\n    )",
  "class BaseRegRestoreKey(NDRCALL):\n    opnum = 19\n    structure = (\n       ('hKey', RPC_HKEY),\n       ('lpFile', RRP_UNICODE_STRING),\n       ('Flags', DWORD),\n    )",
  "class BaseRegRestoreKeyResponse(NDRCALL):\n    structure = (\n       ('ErrorCode', error_status_t),\n    )",
  "class BaseRegSaveKey(NDRCALL):\n    opnum = 20\n    structure = (\n       ('hKey', RPC_HKEY),\n       ('lpFile', RRP_UNICODE_STRING),\n       ('pSecurityAttributes', PRPC_SECURITY_ATTRIBUTES),\n    )",
  "class BaseRegSaveKeyResponse(NDRCALL):\n    structure = (\n       ('ErrorCode', error_status_t),\n    )",
  "class BaseRegSetKeySecurity(NDRCALL):\n    opnum = 21\n    structure = (\n       ('hKey', RPC_HKEY),\n       ('SecurityInformation', SECURITY_INFORMATION),\n       ('pRpcSecurityDescriptor', RPC_SECURITY_DESCRIPTOR),\n    )",
  "class BaseRegSetKeySecurityResponse(NDRCALL):\n    structure = (\n       ('ErrorCode', error_status_t),\n    )",
  "class BaseRegSetValue(NDRCALL):\n    opnum = 22\n    structure = (\n       ('hKey', RPC_HKEY),\n       ('lpValueName', RRP_UNICODE_STRING),\n       ('dwType', DWORD),\n       ('lpData', NDRUniConformantArray),\n       ('cbData', DWORD),\n    )",
  "class BaseRegSetValueResponse(NDRCALL):\n    structure = (\n       ('ErrorCode', error_status_t),\n    )",
  "class BaseRegUnLoadKey(NDRCALL):\n    opnum = 23\n    structure = (\n       ('hKey', RPC_HKEY),\n       ('lpSubKey', RRP_UNICODE_STRING),\n    )",
  "class BaseRegUnLoadKeyResponse(NDRCALL):\n    structure = (\n       ('ErrorCode', error_status_t),\n    )",
  "class BaseRegGetVersion(NDRCALL):\n    opnum = 26\n    structure = (\n       ('hKey', RPC_HKEY),\n    )",
  "class BaseRegGetVersionResponse(NDRCALL):\n    structure = (\n       ('lpdwVersion', DWORD),\n       ('ErrorCode', error_status_t),\n    )",
  "class OpenCurrentConfig(NDRCALL):\n    opnum = 27\n    structure = (\n       ('ServerName', PREGISTRY_SERVER_NAME),\n       ('samDesired', REGSAM),\n    )",
  "class OpenCurrentConfigResponse(NDRCALL):\n    structure = (\n       ('phKey', RPC_HKEY),\n       ('ErrorCode', error_status_t),\n    )",
  "class BaseRegQueryMultipleValues(NDRCALL):\n    opnum = 29\n    structure = (\n       ('hKey', RPC_HKEY),\n       ('val_listIn', RVALENT_ARRAY),\n       ('num_vals', DWORD),\n       ('lpvalueBuf', PBYTE_ARRAY),\n       ('ldwTotsize', DWORD),\n    )",
  "class BaseRegQueryMultipleValuesResponse(NDRCALL):\n    structure = (\n       ('val_listOut', RVALENT_ARRAY),\n       ('lpvalueBuf', PBYTE_ARRAY),\n       ('ldwTotsize', DWORD),\n       ('ErrorCode', error_status_t),\n    )",
  "class BaseRegSaveKeyEx(NDRCALL):\n    opnum = 31\n    structure = (\n       ('hKey', RPC_HKEY),\n       ('lpFile', RRP_UNICODE_STRING),\n       ('pSecurityAttributes', PRPC_SECURITY_ATTRIBUTES),\n       ('Flags', DWORD),\n    )",
  "class BaseRegSaveKeyExResponse(NDRCALL):\n    structure = (\n       ('ErrorCode', error_status_t),\n    )",
  "class OpenPerformanceText(NDRCALL):\n    opnum = 32\n    structure = (\n       ('ServerName', PREGISTRY_SERVER_NAME),\n       ('samDesired', REGSAM),\n    )",
  "class OpenPerformanceTextResponse(NDRCALL):\n    structure = (\n       ('phKey', RPC_HKEY),\n       ('ErrorCode', error_status_t),\n    )",
  "class OpenPerformanceNlsText(NDRCALL):\n    opnum = 33\n    structure = (\n       ('ServerName', PREGISTRY_SERVER_NAME),\n       ('samDesired', REGSAM),\n    )",
  "class OpenPerformanceNlsTextResponse(NDRCALL):\n    structure = (\n       ('phKey', RPC_HKEY),\n       ('ErrorCode', error_status_t),\n    )",
  "class BaseRegQueryMultipleValues2(NDRCALL):\n    opnum = 34\n    structure = (\n       ('hKey', RPC_HKEY),\n       ('val_listIn', RVALENT_ARRAY),\n       ('num_vals', DWORD),\n       ('lpvalueBuf', PBYTE_ARRAY),\n       ('ldwTotsize', DWORD),\n    )",
  "class BaseRegQueryMultipleValues2Response(NDRCALL):\n    structure = (\n       ('val_listOut', RVALENT_ARRAY),\n       ('lpvalueBuf', PBYTE_ARRAY),\n       ('ldwRequiredSize', DWORD),\n       ('ErrorCode', error_status_t),\n    )",
  "class BaseRegDeleteKeyEx(NDRCALL):\n    opnum = 35\n    structure = (\n       ('hKey', RPC_HKEY),\n       ('lpSubKey', RRP_UNICODE_STRING),\n       ('AccessMask', REGSAM),\n       ('Reserved', DWORD),\n    )",
  "class BaseRegDeleteKeyExResponse(NDRCALL):\n    structure = (\n       ('ErrorCode', error_status_t),\n    )",
  "def checkNullString(string):\n    if string == NULL:\n        return string\n\n    if string[-1:] != '\\x00':\n        return string + '\\x00'\n    else:\n        return string",
  "def packValue(valueType, value):\n    if valueType == REG_DWORD:\n        retData = pack('<L', value)\n    elif valueType == REG_DWORD_BIG_ENDIAN:\n        retData = pack('>L', value)\n    elif valueType == REG_EXPAND_SZ:\n        try:\n            retData = value.encode('utf-16le')\n        except UnicodeDecodeError:\n            import sys\n            retData = value.decode(sys.getfilesystemencoding()).encode('utf-16le')\n    elif valueType == REG_MULTI_SZ:\n        try:\n            retData = value.encode('utf-16le')\n        except UnicodeDecodeError:\n            import sys\n            retData = value.decode(sys.getfilesystemencoding()).encode('utf-16le')\n    elif valueType == REG_QWORD:\n        retData = pack('<Q', value)\n    elif valueType == REG_QWORD_LITTLE_ENDIAN:\n        retData = pack('>Q', value)\n    elif valueType == REG_SZ:\n        try:\n            retData = value.encode('utf-16le')\n        except UnicodeDecodeError:\n            import sys\n            retData = value.decode(sys.getfilesystemencoding()).encode('utf-16le')\n    else:\n        retData = value\n\n    return retData",
  "def unpackValue(valueType, value):\n    if valueType == REG_DWORD:\n        retData = unpack('<L', b''.join(value))[0]\n    elif valueType == REG_DWORD_BIG_ENDIAN:\n        retData = unpack('>L', b''.join(value))[0]\n    elif valueType == REG_EXPAND_SZ:\n        retData = b''.join(value).decode('utf-16le')\n    elif valueType == REG_MULTI_SZ:\n        retData = b''.join(value).decode('utf-16le')\n    elif valueType == REG_QWORD:\n        retData = unpack('<Q', b''.join(value))[0]\n    elif valueType == REG_QWORD_LITTLE_ENDIAN:\n        retData = unpack('>Q', b''.join(value))[0]\n    elif valueType == REG_SZ:\n        retData = b''.join(value).decode('utf-16le')\n    else:\n        retData = b''.join(value)\n\n    return retData",
  "def hOpenClassesRoot(dce, samDesired = MAXIMUM_ALLOWED):\n    request = OpenClassesRoot()\n    request['ServerName'] = NULL\n    request['samDesired'] = samDesired\n    return dce.request(request)",
  "def hOpenCurrentUser(dce, samDesired = MAXIMUM_ALLOWED):\n    request = OpenCurrentUser()\n    request['ServerName'] = NULL\n    request['samDesired'] = samDesired\n    return dce.request(request)",
  "def hOpenLocalMachine(dce, samDesired = MAXIMUM_ALLOWED):\n    request = OpenLocalMachine()\n    request['ServerName'] = NULL\n    request['samDesired'] = samDesired\n    return dce.request(request)",
  "def hOpenPerformanceData(dce, samDesired = MAXIMUM_ALLOWED):\n    request = OpenPerformanceData()\n    request['ServerName'] = NULL\n    request['samDesired'] = samDesired\n    return dce.request(request)",
  "def hOpenUsers(dce, samDesired = MAXIMUM_ALLOWED):\n    request = OpenUsers()\n    request['ServerName'] = NULL\n    request['samDesired'] = samDesired\n    return dce.request(request)",
  "def hBaseRegCloseKey(dce, hKey):\n    request = BaseRegCloseKey()\n    request['hKey'] = hKey\n    return dce.request(request)",
  "def hBaseRegCreateKey(dce, hKey, lpSubKey, lpClass = NULL, dwOptions = 0x00000001, samDesired = MAXIMUM_ALLOWED, lpSecurityAttributes = NULL, lpdwDisposition = REG_CREATED_NEW_KEY):\n    request = BaseRegCreateKey()\n    request['hKey'] = hKey\n    request['lpSubKey'] = checkNullString(lpSubKey)\n    request['lpClass'] = checkNullString(lpClass)\n    request['dwOptions'] = dwOptions\n    request['samDesired'] = samDesired\n    if lpSecurityAttributes == NULL:\n        request['lpSecurityAttributes']['RpcSecurityDescriptor']['lpSecurityDescriptor'] = NULL\n    else:\n        request['lpSecurityAttributes'] = lpSecurityAttributes\n    request['lpdwDisposition'] = lpdwDisposition\n\n    return dce.request(request)",
  "def hBaseRegDeleteKey(dce, hKey, lpSubKey):\n    request = BaseRegDeleteKey()\n    request['hKey'] = hKey\n    request['lpSubKey'] = checkNullString(lpSubKey)\n    return dce.request(request)",
  "def hBaseRegEnumKey(dce, hKey, dwIndex, lpftLastWriteTime = NULL):\n    request = BaseRegEnumKey()\n    request['hKey'] = hKey\n    request['dwIndex'] = dwIndex\n    request.fields['lpNameIn'].fields['MaximumLength'] = 1024\n    request.fields['lpNameIn'].fields['Data'].fields['Data'].fields['MaximumCount'] = 1024//2\n    request['lpClassIn'] = ' '* 64\n    request['lpftLastWriteTime'] = lpftLastWriteTime\n\n    return dce.request(request)",
  "def hBaseRegEnumValue(dce, hKey, dwIndex, dataLen=256):\n    request = BaseRegEnumValue()\n    request['hKey'] = hKey\n    request['dwIndex'] = dwIndex\n    retries = 1\n\n    # We need to be aware the size might not be enough, so let's catch ERROR_MORE_DATA exception\n    while True:\n        try:\n            # Only the maximum length field of the lpValueNameIn is used to determine the buffer length to be allocated\n            # by the service. Specify a string with a zero length but maximum length set to the largest buffer size\n            # needed to hold the value names.\n            request.fields['lpValueNameIn'].fields['MaximumLength'] = dataLen*2\n            request.fields['lpValueNameIn'].fields['Data'].fields['Data'].fields['MaximumCount'] = dataLen\n\n            request['lpData'] = b' ' * dataLen\n            request['lpcbData'] = dataLen\n            request['lpcbLen'] = dataLen\n            resp = dce.request(request)\n        except DCERPCSessionError as e:\n            if retries > 1:\n                LOG.debug('Too many retries when calling hBaseRegEnumValue, aborting')\n                raise\n            if e.get_error_code() == system_errors.ERROR_MORE_DATA:\n                # We need to adjust the size\n                retries +=1\n                dataLen = e.get_packet()['lpcbData']\n                continue\n            else:\n                raise\n        else:\n            break\n\n    return resp",
  "def hBaseRegFlushKey(dce, hKey):\n    request = BaseRegFlushKey()\n    request['hKey'] = hKey\n    return dce.request(request)",
  "def hBaseRegGetKeySecurity(dce, hKey, securityInformation = OWNER_SECURITY_INFORMATION ):\n    request = BaseRegGetKeySecurity()\n    request['hKey'] = hKey\n    request['SecurityInformation'] = securityInformation\n    request['pRpcSecurityDescriptorIn']['lpSecurityDescriptor'] = NULL\n    request['pRpcSecurityDescriptorIn']['cbInSecurityDescriptor'] = 1024\n\n    return dce.request(request)",
  "def hBaseRegLoadKey(dce, hKey, lpSubKey, lpFile):\n    request = BaseRegLoadKey()\n    request['hKey'] = hKey\n    request['lpSubKey'] = checkNullString(lpSubKey)\n    request['lpFile'] = checkNullString(lpFile)\n    return dce.request(request)",
  "def hBaseRegUnLoadKey(dce, hKey, lpSubKey):\n    request = BaseRegUnLoadKey()\n    request['hKey'] = hKey\n    request['lpSubKey'] = checkNullString(lpSubKey)\n    return dce.request(request)",
  "def hBaseRegOpenKey(dce, hKey, lpSubKey, dwOptions=0x00000001, samDesired = MAXIMUM_ALLOWED):\n    request = BaseRegOpenKey()\n    request['hKey'] = hKey\n    request['lpSubKey'] = checkNullString(lpSubKey)\n    request['dwOptions'] = dwOptions\n    request['samDesired'] = samDesired\n    return dce.request(request)",
  "def hBaseRegQueryInfoKey(dce, hKey):\n    request = BaseRegQueryInfoKey()\n    request['hKey'] = hKey\n    # Not the cleanest way, but oh well\n    # Plus, Windows XP needs MaximumCount also set\n    request.fields['lpClassIn'].fields['MaximumLength'] = 1024\n    request.fields['lpClassIn'].fields['Data'].fields['Data'].fields['MaximumCount'] = 1024//2\n    return dce.request(request)",
  "def hBaseRegQueryValue(dce, hKey, lpValueName, dataLen=512):\n    request = BaseRegQueryValue()\n    request['hKey'] = hKey\n    request['lpValueName'] = checkNullString(lpValueName)\n    retries = 1\n\n    # We need to be aware the size might not be enough, so let's catch ERROR_MORE_DATA exception\n    while True:\n        try:\n            request['lpData'] =b' ' * dataLen\n            request['lpcbData'] = dataLen\n            request['lpcbLen'] = dataLen\n            resp = dce.request(request)\n        except DCERPCSessionError as e:\n            if retries > 1:\n                LOG.debug('Too many retries when calling hBaseRegQueryValue, aborting')\n                raise\n            if e.get_error_code() == system_errors.ERROR_MORE_DATA:\n                # We need to adjust the size\n                dataLen = e.get_packet()['lpcbData']\n                continue\n            else:\n                raise\n        else:\n            break\n\n    # Returns\n    # ( dataType, data )\n    return resp['lpType'], unpackValue(resp['lpType'], resp['lpData'])",
  "def hBaseRegReplaceKey(dce, hKey, lpSubKey, lpNewFile, lpOldFile):\n    request = BaseRegReplaceKey()\n    request['hKey'] = hKey\n    request['lpSubKey'] = checkNullString(lpSubKey)\n    request['lpNewFile'] = checkNullString(lpNewFile)\n    request['lpOldFile'] = checkNullString(lpOldFile)\n    return dce.request(request)",
  "def hBaseRegRestoreKey(dce, hKey, lpFile, flags=REG_REFRESH_HIVE):\n    request = BaseRegRestoreKey()\n    request['hKey'] = hKey\n    request['lpFile'] = checkNullString(lpFile)\n    request['Flags'] = flags\n    return dce.request(request)",
  "def hBaseRegSaveKey(dce, hKey, lpFile, pSecurityAttributes = NULL):\n    request = BaseRegSaveKey()\n    request['hKey'] = hKey\n    request['lpFile'] = checkNullString(lpFile)\n    request['pSecurityAttributes'] = pSecurityAttributes\n    return dce.request(request)",
  "def hBaseRegSetValue(dce, hKey, lpValueName, dwType, lpData):\n    request = BaseRegSetValue()\n    request['hKey'] = hKey\n    request['lpValueName'] = checkNullString(lpValueName)\n    request['dwType'] = dwType\n    request['lpData'] = packValue(dwType,lpData)\n    request['cbData'] = len(request['lpData'])\n    return dce.request(request)",
  "def hBaseRegGetVersion(dce, hKey):\n    request = BaseRegGetVersion()\n    request['hKey'] = hKey\n    return dce.request(request)",
  "def hOpenCurrentConfig(dce, samDesired = MAXIMUM_ALLOWED):\n    request = OpenCurrentConfig()\n    request['ServerName'] = NULL\n    request['samDesired'] = samDesired\n    return dce.request(request)",
  "def hBaseRegQueryMultipleValues(dce, hKey, val_listIn):\n    # ToDo, check the result to see whether we need to\n    # have a bigger buffer for the data to receive\n    request = BaseRegQueryMultipleValues()\n    request['hKey'] = hKey\n\n    for item in  val_listIn:\n        itemn = RVALENT()\n        itemn['ve_valuename'] = checkNullString(item['ValueName'])\n        itemn['ve_valuelen'] = len(itemn['ve_valuename'])\n        itemn['ve_valueptr'] = NULL\n        itemn['ve_type'] = item['ValueType']\n        request['val_listIn'].append(itemn)\n\n    request['num_vals'] = len(request['val_listIn'])\n    request['lpvalueBuf'] = list(b' '*128)\n    request['ldwTotsize'] = 128\n\n    resp = dce.request(request)\n    retVal = list()\n    for item in resp['val_listOut']:\n        itemn = dict()\n        itemn['ValueName'] = item['ve_valuename']\n        itemn['ValueData'] = unpackValue(item['ve_type'], resp['lpvalueBuf'][item['ve_valueptr'] : item['ve_valueptr']+item['ve_valuelen']])\n        retVal.append(itemn)\n\n    return retVal",
  "def hBaseRegSaveKeyEx(dce, hKey, lpFile, pSecurityAttributes = NULL, flags=1):\n    request = BaseRegSaveKeyEx()\n    request['hKey'] = hKey\n    request['lpFile'] = checkNullString(lpFile)\n    request['pSecurityAttributes'] = pSecurityAttributes\n    request['Flags'] = flags\n    return dce.request(request)",
  "def hOpenPerformanceText(dce, samDesired = MAXIMUM_ALLOWED):\n    request = OpenPerformanceText()\n    request['ServerName'] = NULL\n    request['samDesired'] = samDesired\n    return dce.request(request)",
  "def hOpenPerformanceNlsText(dce, samDesired = MAXIMUM_ALLOWED):\n    request = OpenPerformanceNlsText()\n    request['ServerName'] = NULL\n    request['samDesired'] = samDesired\n    return dce.request(request)",
  "def hBaseRegDeleteValue(dce, hKey, lpValueName):\n    request = BaseRegDeleteValue()\n    request['hKey'] = hKey\n    request['lpValueName'] = checkNullString(lpValueName)\n    return dce.request(request)",
  "def __init__(self, error_string=None, error_code=None, packet=None):\n        DCERPCException.__init__(self, error_string, error_code, packet)",
  "def __str__( self ):\n        key = self.error_code\n        if key in system_errors.ERROR_MESSAGES:\n            error_msg_short = system_errors.ERROR_MESSAGES[key][0]\n            error_msg_verbose = system_errors.ERROR_MESSAGES[key][1]\n            return 'RRP SessionError: code: 0x%x - %s - %s' % (self.error_code, error_msg_short, error_msg_verbose)\n        else:\n            return 'RRP SessionError: unknown error code: 0x%x' % self.error_code",
  "def __init__(self, data=None, isNDR64=False):\n        NDRSTRUCT.__init__(self, data, isNDR64)\n        self['context_handle_uuid'] = b'\\x00'*16",
  "def isNull(self):\n        return self['context_handle_uuid'] == b'\\x00'*16",
  "class DCERPCSessionError(DCERPCException):\n    def __init__(self, error_string=None, error_code=None, packet=None):\n        DCERPCException.__init__(self, error_string, error_code, packet)\n\n    def __str__( self ):\n        key = self.error_code\n        if key in nt_errors.ERROR_MESSAGES:\n            error_msg_short = nt_errors.ERROR_MESSAGES[key][0]\n            error_msg_verbose = nt_errors.ERROR_MESSAGES[key][1] \n            return 'Mimikatz SessionError: code: 0x%x - %s - %s' % (self.error_code, error_msg_short, error_msg_verbose)\n        else:\n            return 'Mimikatz SessionError: unknown error code: 0x%x' % self.error_code",
  "class PUBLICKEYSTRUC(Structure):\n    structure = (\n        ('bType','B=0'),\n        ('bVersion','B=0'),\n        ('reserved','<H=0'),\n        ('aiKeyAlg','<L=0'),\n    )\n    def __init__(self, data = None, alignment = 0):\n        Structure.__init__(self,data,alignment)\n        self['bType'] = TPUBLICKEYBLOB\n        self['bVersion'] = CUR_BLOB_VERSION\n        self['aiKeyAlg'] = CALG_DH_EPHEM",
  "class DHPUBKEY(Structure):\n    structure = (\n        ('magic','<L=0'),\n        ('bitlen','<L=0'),\n    )\n    def __init__(self, data = None, alignment = 0):\n        Structure.__init__(self,data,alignment)\n        self['magic'] = 0x31484400\n        self['bitlen'] = 1024",
  "class PUBLICKEYBLOB(Structure):\n    structure = (\n        ('publickeystruc',':', PUBLICKEYSTRUC),\n        ('dhpubkey',':', DHPUBKEY),\n        ('yLen', '_-y','128'),\n        ('y',':'),\n    )\n    def __init__(self, data = None, alignment = 0):\n        Structure.__init__(self,data,alignment)\n        self['publickeystruc'] = PUBLICKEYSTRUC().getData()\n        self['dhpubkey'] = DHPUBKEY().getData()",
  "class MIMI_HANDLE(NDRSTRUCT):\n    structure =  (\n        ('Data','20s=\"\"'),\n    )\n    def getAlignment(self):\n        if self._isNDR64 is True:\n            return 8\n        else:\n            return 4",
  "class BYTE_ARRAY(NDRUniConformantArray):\n    item = 'c'",
  "class PBYTE_ARRAY(NDRPOINTER):\n    referent = (\n        ('Data',BYTE_ARRAY),\n    )",
  "class MIMI_PUBLICKEY(NDRSTRUCT):\n    structure =  (\n        ('sessionType',ALG_ID),\n        ('cbPublicKey',DWORD),\n        ('pbPublicKey',PBYTE_ARRAY),\n    )",
  "class PMIMI_PUBLICKEY(NDRPOINTER):\n    referent = (\n        ('Data',MIMI_PUBLICKEY),\n    )",
  "class MimiBind(NDRCALL):\n    opnum = 0\n    structure = (\n       ('clientPublicKey',MIMI_PUBLICKEY),\n    )",
  "class MimiBindResponse(NDRCALL):\n    structure = (\n       ('serverPublicKey',MIMI_PUBLICKEY),\n       ('phMimi',MIMI_HANDLE),\n       ('ErrorCode',ULONG),\n    )",
  "class MimiUnbind(NDRCALL):\n    opnum = 1\n    structure = (\n       ('phMimi',MIMI_HANDLE),\n    )",
  "class MimiUnbindResponse(NDRCALL):\n    structure = (\n       ('phMimi',MIMI_HANDLE),\n       ('ErrorCode',ULONG),\n    )",
  "class MimiCommand(NDRCALL):\n    opnum = 2\n    structure = (\n        ('phMimi',MIMI_HANDLE),\n        ('szEncCommand',DWORD),\n        ('encCommand',PBYTE_ARRAY),\n    )",
  "class MimiCommandResponse(NDRCALL):\n    structure = (\n       ('szEncResult',DWORD),\n       ('encResult',PBYTE_ARRAY),\n       ('ErrorCode',ULONG),\n    )",
  "class MimiDiffeH:\n    def __init__(self):\n        self.G = 2\n        self.P = 0xFFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD129024E088A67CC74020BBEA63B139B22514A08798E3404DDEF9519B3CD3A431B302B0A6DF25F14374FE1356D6D51C245E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F406B7EDEE386BFB5A899FA5AE9F24117C4B1FE649286651ECE65381FFFFFFFFFFFFFFFF\n        self.privateKey = random.getrandbits(1024)\n        #self.privateKey = int('A'*128, base=16)\n\n    def genPublicKey(self):\n        self.publicKey = pow(self.G, self.privateKey, self.P)\n        tmp = hex(self.publicKey)[2:].rstrip('L')\n        if len(tmp) & 1:\n            tmp = '0' + tmp\n        return binascii.unhexlify(tmp)\n\n    def getSharedSecret(self, serverPublicKey):\n        pubKey = int(binascii.hexlify(serverPublicKey), base=16)\n        self.sharedSecret = pow(pubKey, self.privateKey, self.P)\n        tmp = hex(self.sharedSecret)[2:].rstrip('L')\n        if len(tmp) & 1:\n            tmp = '0' + tmp\n        return binascii.unhexlify(tmp)",
  "def hMimiBind(dce, clientPublicKey):\n    request = MimiBind()\n    request['clientPublicKey'] = clientPublicKey\n    return dce.request(request)",
  "def hMimiCommand(dce, phMimi, encCommand):\n    request = MimiCommand()\n    request['phMimi'] = phMimi\n    request['szEncCommand'] = len(encCommand)\n    request['encCommand'] = list(encCommand)\n    return dce.request(request)",
  "def __init__(self, error_string=None, error_code=None, packet=None):\n        DCERPCException.__init__(self, error_string, error_code, packet)",
  "def __str__( self ):\n        key = self.error_code\n        if key in nt_errors.ERROR_MESSAGES:\n            error_msg_short = nt_errors.ERROR_MESSAGES[key][0]\n            error_msg_verbose = nt_errors.ERROR_MESSAGES[key][1] \n            return 'Mimikatz SessionError: code: 0x%x - %s - %s' % (self.error_code, error_msg_short, error_msg_verbose)\n        else:\n            return 'Mimikatz SessionError: unknown error code: 0x%x' % self.error_code",
  "def __init__(self, data = None, alignment = 0):\n        Structure.__init__(self,data,alignment)\n        self['bType'] = TPUBLICKEYBLOB\n        self['bVersion'] = CUR_BLOB_VERSION\n        self['aiKeyAlg'] = CALG_DH_EPHEM",
  "def __init__(self, data = None, alignment = 0):\n        Structure.__init__(self,data,alignment)\n        self['magic'] = 0x31484400\n        self['bitlen'] = 1024",
  "def __init__(self, data = None, alignment = 0):\n        Structure.__init__(self,data,alignment)\n        self['publickeystruc'] = PUBLICKEYSTRUC().getData()\n        self['dhpubkey'] = DHPUBKEY().getData()",
  "def getAlignment(self):\n        if self._isNDR64 is True:\n            return 8\n        else:\n            return 4",
  "def __init__(self):\n        self.G = 2\n        self.P = 0xFFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD129024E088A67CC74020BBEA63B139B22514A08798E3404DDEF9519B3CD3A431B302B0A6DF25F14374FE1356D6D51C245E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F406B7EDEE386BFB5A899FA5AE9F24117C4B1FE649286651ECE65381FFFFFFFFFFFFFFFF\n        self.privateKey = random.getrandbits(1024)",
  "def genPublicKey(self):\n        self.publicKey = pow(self.G, self.privateKey, self.P)\n        tmp = hex(self.publicKey)[2:].rstrip('L')\n        if len(tmp) & 1:\n            tmp = '0' + tmp\n        return binascii.unhexlify(tmp)",
  "def getSharedSecret(self, serverPublicKey):\n        pubKey = int(binascii.hexlify(serverPublicKey), base=16)\n        self.sharedSecret = pow(pubKey, self.privateKey, self.P)\n        tmp = hex(self.sharedSecret)[2:].rstrip('L')\n        if len(tmp) & 1:\n            tmp = '0' + tmp\n        return binascii.unhexlify(tmp)",
  "class DCERPCSessionError(DCERPCException):\n    def __str__( self ):\n        key = self.error_code\n        if key in mapi_constants.ERROR_MESSAGES:\n            error_msg_short = mapi_constants.ERROR_MESSAGES[key]\n            return 'NSPI SessionError: code: 0x%x - %s' % (self.error_code, error_msg_short)\n        elif key in hresult_errors.ERROR_MESSAGES:\n            error_msg_short = hresult_errors.ERROR_MESSAGES[key][0]\n            error_msg_verbose = hresult_errors.ERROR_MESSAGES[key][1]\n            return 'NSPI SessionError: code: 0x%x - %s - %s' % (self.error_code, error_msg_short, error_msg_verbose)\n        else:\n            return 'NSPI SessionError: unknown error code: 0x%x' % self.error_code",
  "class handle_t(NDRSTRUCT):\n    structure = (\n         ('context_handle_attributes',ULONG),\n         ('context_handle_uuid',UUID),\n    )\n\n    def __init__(self, data=None, isNDR64=False):\n        NDRSTRUCT.__init__(self, data, isNDR64)\n        self['context_handle_uuid'] = b'\\x00'*16\n\n    def isNull(self):\n        return self['context_handle_uuid'] == b'\\x00'*16",
  "class PropertyTagArray(NDRUniConformantVaryingArray):\n    item = DWORD",
  "class PropertyTagArray_r(NDRSTRUCT):\n    structure = (\n         ('cValues', ULONG),\n         ('aulPropTag', PropertyTagArray)\n    )",
  "class PPropertyTagArray_r(NDRPOINTER):\n    referent = (\n         ('Data', PropertyTagArray_r),\n    )",
  "class Binary(NDRUniConformantArray):\n    item = 'c'",
  "class PBinary(NDRPOINTER):\n    referent = (\n         ('Data', Binary),\n    )",
  "class Binary_r(NDRSTRUCT):\n    structure = (\n         ('cValues', DWORD),\n         ('lpb', PBinary),\n    )",
  "class ShortArray(NDRUniConformantArray):\n    item = SHORT",
  "class PShortArray(NDRPOINTER):\n    referent = (\n         ('Data', ShortArray),\n    )",
  "class ShortArray_r(NDRSTRUCT):\n    structure = (\n         ('cValues', DWORD),\n         ('lpi', PShortArray),\n    )",
  "class LongArray(NDRUniConformantArray):\n    item = LONG",
  "class PLongArray(NDRPOINTER):\n    referent = (\n         ('Data', LongArray),\n    )",
  "class LongArray_r(NDRSTRUCT):\n    structure = (\n         ('cValues', DWORD),\n         ('lpl', PLongArray)\n    )",
  "class StringArray(NDRUniConformantArray):\n    item = LPSTR",
  "class PStringArray(NDRPOINTER):\n    referent = (\n         ('Data', StringArray),\n    )",
  "class StringArray_r(NDRSTRUCT):\n    structure = (\n         ('cValues', DWORD),\n         ('lppszA', PStringArray)\n    )",
  "class BinaryArray(NDRUniConformantArray):\n    item = Binary_r",
  "class PBinaryArray(NDRPOINTER):\n    referent = (\n         ('Data', BinaryArray),\n    )",
  "class BinaryArray_r(NDRSTRUCT):\n    structure = (\n         ('cValues', DWORD),\n         ('lpbin', PBinaryArray)\n    )",
  "class FlatUIDArray(NDRUniConformantArray):\n    item = PFlatUID_r",
  "class PFlatUIDArray(NDRPOINTER):\n    referent = (\n         ('Data', FlatUIDArray),\n    )",
  "class FlatUIDArray_r(NDRSTRUCT):\n    structure = (\n         ('cValues', DWORD),\n         ('lpguid', PFlatUIDArray)\n    )",
  "class WStringArray(NDRUniConformantArray):\n    item = LPWSTR",
  "class PWStringArray(NDRPOINTER):\n    referent = (\n         ('Data', WStringArray),\n    )",
  "class WStringArray_r(NDRSTRUCT):\n    structure = (\n         ('cValues', DWORD),\n         ('lppszW', PWStringArray)\n    )",
  "class DateTimeArray(NDRUniConformantArray):\n    item = PFILETIME",
  "class PDateTimeArray(NDRPOINTER):\n    referent = (\n         ('Data', DateTimeArray),\n    )",
  "class DateTimeArray_r(NDRSTRUCT):\n    structure = (\n         ('cValues', DWORD),\n         ('lpft', PDateTimeArray)\n    )",
  "class PROP_VAL_UNION(NDRUNION):\n    commonHdr = (\n         ('tag', DWORD),\n    )\n\n    union = {\n        0x0002: ('i', SHORT),               # PtypInteger16\n        0x0003: ('l', LONG),                # PtypInteger32\n        0x000B: ('b', USHORT),              # PtypBoolean\n        0x001E: ('lpszA', LPSTR),           # PtypString8\n        0x0102: ('bin', Binary_r),          # PtypBinary\n        0x001F: ('lpszW', LPWSTR),          # PtypString\n        0x0048: ('lpguid', PFlatUID_r),     # PtypGuid\n        0x0040: ('ft', FILETIME),           # PtypTime\n        0x000A: ('err', ULONG),             # PtypErrorCode\n        0x1002: ('MVi', ShortArray_r),      # PtypMultipleInteger16\n        0x1003: ('MVl', LongArray_r),       # PtypMultipleInteger32\n        0x101E: ('MVszA', StringArray_r),   # PtypMultipleString8\n        0x1102: ('MVbin', BinaryArray_r),   # PtypMultipleBinary\n        0x1048: ('MVguid', FlatUIDArray_r), # PtypMultipleGuid\n        0x101F: ('MVszW', WStringArray_r),  # PtypMultipleString\n        0x1040: ('MVft', DateTimeArray_r),  # PtypMultipleTime\n        0x0001: ('lReserved', LONG),        # PtypNull\n        0x000D: ('lReserved', LONG),        # PtypEmbeddedTable\n        0x0000: ('lReserved', LONG),        # PtypUnspecified\n    }",
  "class PropertyValue_r(NDRSTRUCT):\n    structure = (\n         ('ulPropTag', DWORD),\n         ('ulReserved', DWORD), # dwAlignPad\n         ('Value', PROP_VAL_UNION),\n    )",
  "class PPropertyValue_r(NDRPOINTER):\n    referent = (\n         ('Data', PropertyValue_r),\n    )",
  "class PropertyValue(NDRUniConformantArray):\n    item = PropertyValue_r",
  "class PPropertyValue(NDRPOINTER):\n    referent = (\n         ('Data', PropertyValue),\n    )",
  "class PropertyRow_r(NDRSTRUCT):\n    structure = (\n         ('Reserved', DWORD), # ulAdrEntryPad\n         ('cValues', DWORD),\n         ('lpProps', PPropertyValue)\n    )",
  "class PPropertyRow_r(NDRPOINTER):\n    referent = (\n         ('Data', PropertyRow_r),\n    )",
  "class PropertyRowSet(NDRUniConformantArray): \n    item = PropertyRow_r",
  "class PropertyRowSet_r(NDRSTRUCT):\n    structure = (\n         ('cRows', DWORD),\n         ('aRow', PropertyRowSet),\n    )",
  "class PPropertyRowSet_r(NDRPOINTER):\n    referent = (\n         ('Data', PropertyRowSet_r),\n    )",
  "class Restriction_r(NDRSTRUCT):\n    pass",
  "class PRestriction_r(NDRPOINTER):\n    referent = (\n         ('Data', Restriction_r),\n    )",
  "class AndRestriction(NDRUniConformantArray): \n    item = Restriction_r",
  "class PAndRestriction(NDRPOINTER):\n    referent = (\n         ('Data', AndRestriction),\n    )",
  "class AndRestriction_r(NDRSTRUCT):\n    structure = (\n         ('cRes', DWORD),\n         ('lpRes', PAndRestriction),\n    )",
  "class NotRestriction_r(NDRSTRUCT):\n    structure = (\n         ('lpRes', PRestriction_r),\n    )",
  "class ContentRestriction_r(NDRSTRUCT):\n    structure = (\n         ('ulFuzzyLevel', DWORD),\n         ('ulPropTag', DWORD),\n         ('lpProp', PPropertyValue_r),\n    )",
  "class BitMaskRestriction_r(NDRSTRUCT):\n    structure = (\n         ('relBMR', DWORD),\n         ('ulPropTag', DWORD),\n         ('ulMask', DWORD),\n    )",
  "class PropertyRestriction_r(NDRSTRUCT):\n    structure = (\n         ('relop', DWORD),\n         ('ulPropTag', DWORD),\n         ('lpProp', PPropertyValue_r),\n    )",
  "class ComparePropsRestriction_r(NDRSTRUCT):\n    structure = (\n         ('relop', DWORD),\n         ('ulPropTag1', DWORD),\n         ('ulPropTag2', DWORD),\n    )",
  "class SubRestriction_r(NDRSTRUCT):\n    structure = (\n         ('ulSubObject', DWORD),\n         ('lpRes', PRestriction_r),\n    )",
  "class SizeRestriction_r(NDRSTRUCT):\n    structure = (\n         ('relop', DWORD),\n         ('ulPropTag', DWORD),\n         ('cb', DWORD),\n    )",
  "class ExistRestriction_r(NDRSTRUCT):\n    structure = (\n         ('ulReserved1', DWORD),\n         ('ulPropTag', DWORD),\n         ('ulReserved2', DWORD),\n    )",
  "class RestrictionUnion_r(NDRUNION):\n    commonHdr = (\n         ('tag', DWORD),\n    )\n\n    union = {\n        0x00000000: ('resAnd', AndRestriction_r),\n        0x00000001: ('resOr', OrRestriction_r),\n        0x00000002: ('resNot', NotRestriction_r),\n        0x00000003: ('resContent', ContentRestriction_r),\n        0x00000004: ('resProperty', PropertyRestriction_r),\n        0x00000005: ('resCompareProps', ComparePropsRestriction_r),\n        0x00000006: ('resBitMask', BitMaskRestriction_r),\n        0x00000007: ('resSize', SizeRestriction_r),\n        0x00000008: ('resExist', ExistRestriction_r),\n        0x00000009: ('resSubRestriction', SubRestriction_r),\n    }",
  "class PropertyName_r(NDRSTRUCT):\n    structure = (\n         ('lpguid', PFlatUID_r),\n         ('ulReserved', DWORD),\n         ('lID', LONG),\n    )",
  "class PPropertyName_r(NDRPOINTER):\n    referent = (\n         ('Data', PropertyName_r),\n    )",
  "class PropertyNameSet(NDRUniConformantArray):\n    item = PropertyName_r",
  "class PropertyNameSet_r(NDRSTRUCT):\n    structure = (\n         ('cNames', DWORD),\n         ('aulPropTag', PropertyNameSet)\n    )",
  "class PPropertyNameSet_r(NDRPOINTER):\n    referent = (\n         ('Data', PropertyNameSet_r),\n    )",
  "class StringsArray(NDRUniConformantArray):\n    item = LPSTR",
  "class StringsArray_r(NDRSTRUCT):\n    structure = (\n         ('Count', DWORD),\n         ('Strings', StringsArray)\n    )",
  "class WStringsArray(NDRUniConformantArray):\n    item = LPWSTR",
  "class WStringsArray_r(NDRSTRUCT):\n    structure = (\n         ('Count', DWORD),\n         ('Strings', WStringsArray)\n    )",
  "class STAT(NDRSTRUCT):\n    structure = (\n         ('SortType', DWORD),\n         ('ContainerID', DWORD),\n         ('CurrentRec', DWORD),\n         ('Delta', LONG),\n         ('NumPos', DWORD),\n         ('TotalRecs', DWORD),\n         ('CodePage', DWORD),\n         ('TemplateLocale', DWORD),\n         ('SortLocale', DWORD),\n    )",
  "class PSTAT(NDRPOINTER):\n    referent = (\n         ('Data', STAT),\n    )",
  "class EphemeralEntryID(Structure):\n    structure = (\n         ('IDType','<B=0x87'),\n         ('R1','<B=0'),\n         ('R2','<B=0'),\n         ('R3','<B=0'),\n         ('ProviderUID','16s=b\"\\\\x00\"*16'),\n         ('R4','<L=0x0000001'),\n         ('DisplayType','<L'),\n         ('MId',MinEntryID),\n    )",
  "class PermanentEntryID(Structure):\n    default_guid = GUID_NSPI\n    structure = (\n         ('IDType','<B=0'),\n         ('R1','<B=0'),\n         ('R2','<B=0'),\n         ('R3','<B=0'),\n         ('ProviderUID','16s=self[\"default_guid\"]'),\n         ('R4','<L=0x0000001'),\n         ('DisplayType','<L'),\n         ('DistinguishedName','z'),\n    )\n\n    def __str__(self):\n        return self[\"DistinguishedName\"]",
  "class NspiBind(NDRCALL):\n    opnum = 0\n    structure = (\n        ('dwFlags', DWORD),\n        ('pStat', STAT),\n        ('pServerGuid', PFlatUID_r),\n    )",
  "class NspiBindResponse(NDRCALL):\n    structure = (\n        ('pServerGuid', PFlatUID_r),\n        ('contextHandle', handle_t),\n        ('ErrorCode', ULONG),\n    )",
  "class NspiUnbind(NDRCALL):\n    opnum = 1\n    structure = (\n        ('contextHandle', handle_t),\n        ('Reserved', DWORD), # flags\n    )",
  "class NspiUnbindResponse(NDRCALL):\n    structure = (\n        ('contextHandle', handle_t),\n        ('ErrorCode', ULONG),\n    )",
  "class NspiUpdateStat(NDRCALL):\n    opnum = 2\n    structure = (\n        ('hRpc', handle_t),\n        ('Reserved', DWORD), # flags\n        ('pStat', STAT),\n        ('plDelta', LPLONG),\n    )",
  "class NspiUpdateStatResponse(NDRCALL):\n    structure = (\n        ('pStat', STAT),\n        ('plDelta', LPLONG),\n        ('ErrorCode', ULONG),\n    )",
  "class DWORD_ARRAY(NDRUniConformantArray):\n    item = DWORD",
  "class PDWORD_ARRAY(NDRPOINTER):\n    referent = (\n         ('Data', DWORD_ARRAY),\n    )",
  "class NspiQueryRows(NDRCALL):\n    opnum = 3\n    structure = (\n        ('hRpc', handle_t),\n        ('dwFlags', DWORD),\n        ('pStat', STAT),\n        ('dwETableCount', DWORD),\n        ('lpETable', PDWORD_ARRAY),\n        ('Count', DWORD),\n        ('pPropTags', PPropertyTagArray_r),\n    )",
  "class NspiQueryRowsResponse(NDRCALL):\n    structure = (\n        ('pStat', STAT),\n        ('ppRows', PPropertyRowSet_r),\n        ('ErrorCode', ULONG),\n    )",
  "class NspiSeekEntries(NDRCALL):\n    opnum = 4\n    structure = (\n        ('hRpc', handle_t),\n        ('Reserved', DWORD), # flags\n        ('pStat', STAT),\n        ('pTarget', PropertyValue_r),\n        ('lpETable', PropertyTagArray_r),\n        ('pPropTags', PropertyTagArray_r),\n    )",
  "class NspiSeekEntriesResponse(NDRCALL):\n    structure = (\n        ('pStat', STAT),\n        ('ppRows', PPropertyRowSet_r),\n        ('ErrorCode', ULONG),\n    )",
  "class NspiDNToMId(NDRCALL):\n    opnum = 7\n    structure = (\n        ('hRpc', handle_t),\n        ('Reserved', DWORD), # flags\n        ('pNames', StringsArray_r),\n    )",
  "class NspiDNToMIdResponse(NDRCALL):\n    structure = (\n        ('ppOutMIds', PPropertyTagArray_r),\n        ('ErrorCode', ULONG),\n    )",
  "class NspiGetPropList(NDRCALL):\n    opnum = 8\n    structure = (\n        ('hRpc', handle_t),\n        ('dwFlags', DWORD),\n        ('dwMId', DWORD),\n        ('CodePage', DWORD),\n    )",
  "class NspiGetPropListResponse(NDRCALL):\n    structure = (\n        ('ppOutMIds', PPropertyTagArray_r),\n        ('ErrorCode', ULONG),\n    )",
  "class NspiGetProps(NDRCALL):\n    opnum = 9\n    structure = (\n        ('hRpc', handle_t),\n        ('dwFlags', DWORD),\n        ('pStat', PSTAT),\n        ('pPropTags', PPropertyTagArray_r),\n    )",
  "class NspiGetPropsResponse(NDRCALL):\n    structure = (\n        ('ppRows', PPropertyRow_r),\n        ('ErrorCode', ULONG),\n    )",
  "class NspiCompareMIds(NDRCALL):\n    opnum = 10\n    structure = (\n        ('hRpc', handle_t),\n        ('Reserved', DWORD), # flags\n        ('pStat', STAT),\n        ('MId1', DWORD),\n        ('MId2', DWORD),\n    )",
  "class NspiCompareMIdsResponse(NDRCALL):\n    structure = (\n        ('plResult', LONG),\n        ('ErrorCode', ULONG),\n    )",
  "class NspiGetSpecialTable(NDRCALL):\n    opnum = 12\n    structure = (\n        ('hRpc', handle_t),\n        ('dwFlags', DWORD),\n        ('pStat', PSTAT),\n        ('lpVersion', LPDWORD),\n    )",
  "class NspiGetSpecialTableResponse(NDRCALL):\n    structure = (\n        # In Exchange 2013 / 2016 / 2019 lpVersion is \n        # a RuntimeHelpers.GetHashCode value, and it will be\n        # different each call\n        ('lpVersion', DWORD), \n        ('ppRows', PPropertyRowSet_r),\n        ('ErrorCode', DWORD),\n    )",
  "class NspiGetTemplateInfo(NDRCALL):\n    opnum = 13\n    structure = (\n        ('hRpc', handle_t),\n        ('dwFlags', DWORD),\n        ('ulType', DWORD),\n        ('pDN', LPSTR),\n        ('dwCodePage', DWORD),\n        ('dwLocaleID', DWORD),\n    )",
  "class NspiGetTemplateInfoResponse(NDRCALL):\n    structure = (\n        ('ppData', PPropertyRow_r),\n        ('ErrorCode', ULONG),\n    )",
  "class NspiModLinkAtt(NDRCALL):\n    opnum = 14\n    structure = (\n        ('hRpc', handle_t),\n        ('dwFlags', DWORD),\n        ('ulPropTag', DWORD),\n        ('dwMId', DWORD),\n        ('lpEntryIds', BinaryArray_r),\n    )",
  "class NspiModLinkAttResponse(NDRCALL):\n    structure = (\n        ('ErrorCode', ULONG),\n    )",
  "class NspiQueryColumns(NDRCALL):\n    opnum = 16\n    structure = (\n        ('hRpc', handle_t),\n        ('Reserved', DWORD), # flags\n        ('dwFlags', DWORD),  # mapiFlags\n    )",
  "class NspiQueryColumnsResponse(NDRCALL):\n    structure = (\n        ('ppColumns', PPropertyTagArray_r),\n        ('ErrorCode', ULONG),\n    )",
  "class NspiGetNamesFromIDs(NDRCALL):\n    opnum = 17\n    structure = (\n        ('hRpc', handle_t),\n        ('Reserved', DWORD), # flags\n        ('lpguid', PFlatUID_r),\n        ('pPropTags', PPropertyTagArray_r),\n    )",
  "class NspiGetNamesFromIDsResponse(NDRCALL):\n    structure = (\n        ('ppReturnedPropTags', PPropertyTagArray_r),\n        ('ppNames', PPropertyNameSet_r),\n        ('ErrorCode', ULONG),\n    )",
  "class PropertyName_r_ARRAY(NDRUniConformantVaryingArray):\n    item = PropertyName_r",
  "class NspiGetIDsFromNames(NDRCALL):\n    opnum = 18\n    structure = (\n        ('hRpc', handle_t),\n        ('Reserved', DWORD), # flags\n        ('dwFlags', DWORD),  # mapiFlags\n        ('cPropNames', DWORD),\n        ('pNames', PropertyName_r_ARRAY),\n    )",
  "class NspiGetIDsFromNamesResponse(NDRCALL):\n    structure = (\n        ('ppPropTags', PPropertyTagArray_r),\n        ('ErrorCode', ULONG),\n    )",
  "class NspiResolveNames(NDRCALL):\n    opnum = 19\n    structure = (\n        ('hRpc', handle_t),\n        ('Reserved', DWORD), # flags\n        ('pStat', STAT),\n        ('pPropTags', PPropertyTagArray_r),\n        ('paStr', StringsArray_r),\n    )",
  "class NspiResolveNamesResponse(NDRCALL):\n    structure = (\n        ('ppMIds', PPropertyTagArray_r),\n        ('ppRows', PPropertyRowSet_r),\n        ('ErrorCode', ULONG),\n    )",
  "class NspiResolveNamesW(NDRCALL):\n    opnum = 20\n    structure = (\n        ('hRpc', handle_t),\n        ('Reserved', DWORD), # flags\n        ('pStat', STAT),\n        ('pPropTags', PPropertyTagArray_r),\n        ('paStr', WStringsArray_r),\n    )",
  "class NspiResolveNamesWResponse(NDRCALL):\n    structure = (\n        ('ppMIds', PPropertyTagArray_r),\n        ('ppRows', PPropertyRowSet_r),\n        ('ErrorCode', ULONG),\n    )",
  "def checkNullString(string):\n    if string == NULL:\n        return string\n\n    if string[-1:] != '\\x00':\n        return string + '\\x00'\n    else:\n        return string",
  "def get_guid_from_dn(legacyDN):\n    legacyDN = str(legacyDN)\n    guid = legacyDN[legacyDN.rfind(\"=\")+1:]\n\n    return uuid.string_to_bin(guid)",
  "def get_dn_from_guid(guid, minimize=False):\n    if minimize:\n        # MS-OXNSPI\n        dn_template = \"/guid=\"\n    else:\n        # MS-NSPI and MS-OXNSPI\n        dn_template = \"/o=NT5/ou=00000000000000000000000000000000/cn=\"\n\n    guid_bin = string_to_bin(guid)\n\n    if PY2:\n        return \"%s%s\" % (dn_template, binascii.hexlify(guid_bin))\n    else:\n        return \"%s%s\" % (dn_template, str(binascii.hexlify(guid_bin), 'ascii'))",
  "class EXCH_SID(LDAP_SID):\n    def __str__(self):\n        return self.formatCanonical()",
  "class ExchBinaryObject(bytes):\n    pass",
  "def getUnixTime(t):\n    t -= 116444736000000000\n    t //= 10000000\n    return t",
  "def simplifyPropertyRow(rowSetElem):\n    row = {}\n\n    for prop in rowSetElem['lpProps']:\n        prop_name_in_union = prop['Value'].structure[0][0]\n        prop_value = prop['Value'].fields[prop_name_in_union]\n\n        PropTag = prop['ulPropTag']\n\n        if isinstance(prop_value, SHORT) or \\\n           isinstance(prop_value, USHORT) or \\\n           isinstance(prop_value, LONG) or \\\n           isinstance(prop_value, ULONG):\n            row[PropTag] = int(prop_value['Data'])\n        elif isinstance(prop_value, LPWSTR):\n            if PropTag in [0x8c38001f]:\n                # What is this field for?\n                row[PropTag] = ExchBinaryObject(prop_value['Data'].encode(\"utf-16le\")[:-2])\n            else:\n                row[PropTag] = prop_value['Data'][:-1]\n        elif isinstance(prop_value, LPSTR):\n            row[PropTag] = prop_value['Data'][:-1]\n        elif isinstance(prop_value, Binary_r):\n            value = b''.join(prop_value['lpb'])\n\n            if PropTag in [0x80270102, 0x8c750102]:\n                value = EXCH_SID(value)\n            elif PropTag == 0x300b0102:\n                value = value[:-1].decode(\"utf-8\")\n            elif value[4:20] == GUID_NSPI and value[20:24] == b'\\x01\\x00\\x00\\x00' and value[:4] == b'\\x00\\x00\\x00\\x00':\n                value = PermanentEntryID(value)\n            elif value[:4] == b'\\x87\\x00\\x00\\x00' and value[20:24] == b'\\x01\\x00\\x00\\x00' and len(value) == 32:\n                value = EphemeralEntryID(value)\n            elif PropTag in [0x8c6d0102, 0x68c40102, 0x8c730102, 0x0ff80102]:\n                value = uuid.bin_to_string(value).lower()\n            elif PropTag == 0x0ff60102:\n                value = unpack('<l', value)[0]\n            else:\n                value = ExchBinaryObject(value)\n\n            row[PropTag] = value\n        elif isinstance(prop_value, BinaryArray_r):\n            array = []\n            for value in prop_value['lpbin']:\n                array.append(b''.join(value['lpb']))\n            row[PropTag] = array\n        elif isinstance(prop_value, StringArray_r):\n            array = []\n            for value in prop_value['lppszA']:\n                array.append(value['Data'][:-1])\n            row[PropTag] = array\n        elif isinstance(prop_value, WStringArray_r):\n            array = []\n            for value in prop_value['lppszW']:\n                array.append(value['Data'][:-1])\n            row[PropTag] = array\n        elif isinstance(prop_value, FILETIME):\n            row[PropTag] = datetime.fromtimestamp( \\\n                getUnixTime(unpack('<Q', prop_value.getData())[0]))\n        else:\n            row[PropTag] = prop_value\n\n    return row",
  "def simplifyPropertyRowSet(propertyRowSet):\n    ret = []\n\n    for rowSet in propertyRowSet['aRow']:\n        ret.append(simplifyPropertyRow(rowSet))\n\n    return ret",
  "def hNspiBind(dce, pStat=None):\n    request = NspiBind()\n\n    if pStat == None:\n        request['pStat']['CodePage'] = CP_TELETEX\n    else:\n        request['pStat'] = pStat\n\n    resp = dce.request(request)\n    return resp",
  "def hNspiUnbind(dce, handler):\n    request = NspiUnbind()\n    request['contextHandle'] = handler\n\n    resp = dce.request(request, checkError=False)\n    return resp",
  "def hNspiUpdateStat(dce, handler, pStat, plDelta=NULL):\n    request = NspiUpdateStat()\n    request['hRpc'] = handler\n    request['pStat'] = pStat\n    request['plDelta'] = plDelta\n\n    resp = dce.request(request, checkError=False)\n    return resp",
  "def hNspiQueryRows(dce, handler, dwFlags=fSkipObjects, pStat=None, ContainerID=0,\n        Count=50, pPropTags=[], pPropTagsRaw=NULL, lpETable=[]):\n    request = NspiQueryRows()\n    request['hRpc'] = handler\n    request['dwFlags'] = dwFlags\n    request['Count'] = Count\n\n    if pStat == None:\n        request['pStat']['ContainerID'] = ContainerID\n    else:\n        request['pStat'] = pStat\n\n    if len(pPropTags) > 0:\n        for aulPropTag in pPropTags:\n            prop = DWORD()\n            prop['Data'] = aulPropTag\n            request['pPropTags']['aulPropTag'].append(prop)\n        request['pPropTags']['cValues'] = len(pPropTags)\n        request.fields['pPropTags'].fields['Data'].fields['aulPropTag'].fields['MaximumCount'] = len(pPropTags) + 1\n    else:\n        request['pPropTags'] = pPropTagsRaw\n\n    if len(lpETable) > 0:\n        for mID in lpETable:\n            elem = DWORD()\n            elem['Data'] = mID\n            request['lpETable'].append(elem)\n        request['dwETableCount'] = len(lpETable)\n    else:\n        request['lpETable'] = NULL\n        request['dwETableCount'] = 0\n\n    resp = dce.request(request)\n    return resp",
  "def hNspiSeekEntries(dce, handler, displayName, ContainerID=0, SortType=0, \\\n        lpETable=[], lpETableRaw=NULL, pPropTags=[], pPropTagsRaw=NULL):\n    request = NspiSeekEntries()\n    request['hRpc'] = handler\n    request['pStat']['ContainerID'] = ContainerID\n\n    # MS-OXNSPI 3.1.4.1.9.9\n    # If the SortType field in the input parameter pStat has any value other than\n    # SortTypeDisplayName, the server MUST return the value GeneralFailure.\n    request['pStat']['SortType'] = SortTypeDisplayName\n\n    # MS-OXNSPI 3.1.4.1.9.10\n    # If the SortType field in the input parameter pStat is SortTypeDisplayName and the property\n    # specified in the input parameter pTarget is anything other than PidTagDisplayName (with either\n    # the Property Type PtypString8 or PtypString), the server MUST return the value\n    # GeneralFailure.\n    request['pTarget']['ulPropTag'] = 0x3001001F\n    request['pTarget']['Value']['tag'] = 0x0000001F\n    request['pTarget']['Value']['lpszW'] = checkNullString(displayName)\n\n    if len(lpETable) > 0:\n        for mID in lpETable:\n            elem = DWORD()\n            elem['Data'] = mID\n            request['lpETable'].append(elem)\n    else:\n        request['lpETable'] = lpETableRaw\n\n    if len(pPropTags) > 0:\n        for aulPropTag in pPropTags:\n            prop = DWORD()\n            prop['Data'] = aulPropTag\n            request['pPropTags']['aulPropTag'].append(prop)\n        request.fields['pPropTags'].fields['aulPropTag'].fields['MaximumCount'] = len(pPropTags) + 1\n    else:\n        request['pPropTags'] = pPropTagsRaw\n\n    resp = dce.request(request)\n    return resp",
  "def hNspiDNToMId(dce, handler, pNames=[]):\n    request = NspiDNToMId()\n    request['hRpc'] = handler\n    request['pNames']['Count'] = len(pNames)\n\n    for name in pNames:\n        lpstr = LPSTR()\n        lpstr['Data'] = checkNullString(name)\n        request['pNames']['Strings'].append(lpstr)\n\n    resp = dce.request(request)\n    return resp",
  "def hNspiGetPropList(dce, handler, dwMId=0, dwFlags=fSkipObjects, CodePage=CP_TELETEX):\n    request = NspiGetPropList()\n    request['hRpc'] = handler\n    request['dwMId'] = dwMId\n    request['dwFlags'] = dwFlags\n    request['CodePage'] = CodePage\n    resp = dce.request(request)\n\n    return resp",
  "def hNspiGetProps(dce, handler, ContainerID=0, CurrentRec=0, dwFlags=fSkipObjects, CodePage=CP_TELETEX, pPropTags=[]):\n    request = NspiGetProps()\n    request['hRpc'] = handler\n    request['dwFlags'] = dwFlags\n\n    request['pStat']['CurrentRec'] = CurrentRec\n    request['pStat']['ContainerID'] = ContainerID\n    request['pStat']['CodePage'] = CodePage\n\n    for aulPropTag in pPropTags:\n        prop = DWORD()\n        prop['Data'] = aulPropTag\n        request['pPropTags']['aulPropTag'].append(prop)\n    request['pPropTags']['cValues'] = len(pPropTags) + 1\n    request.fields['pPropTags'].fields['Data'].fields['aulPropTag'].fields['MaximumCount'] = len(pPropTags) + 1\n\n    resp = dce.request(request)\n    return resp",
  "def hNspiGetSpecialTable(dce, handler, dwFlags=NspiUnicodeStrings, pStat=STAT(), lpVersion=NULL):\n    request = NspiGetSpecialTable()\n    request['hRpc'] = handler\n    request['dwFlags'] = dwFlags\n    request['pStat'] = pStat\n    request['lpVersion'] = lpVersion\n\n    resp = dce.request(request)\n    return resp",
  "def hNspiGetTemplateInfo(dce, handler, pDN=NULL, dwLocaleID=0, ulType=0, dwCodePage=0, dwFlags=0xFFFFFFFF):\n    request = NspiGetTemplateInfo()\n    request['hRpc'] = handler\n    request['dwFlags'] = dwFlags\n    request['ulType'] = ulType\n    request['pDN'] = checkNullString(pDN)\n    request['dwCodePage'] = dwCodePage\n    request['dwLocaleID'] = dwLocaleID\n\n    resp = dce.request(request)\n    return resp",
  "def hNspiModLinkAtt(dce, handler, dwFlags, ulPropTag, dwMId, lpEntryIds):\n    request = NspiModLinkAtt()\n    request['hRpc'] = handler\n    request['dwFlags'] = dwFlags\n    request['ulPropTag'] = ulPropTag\n    request['dwMId'] = dwMId\n\n    for lpEntryId in lpEntryIds:\n        prop = Binary_r()\n        prop['lpb'] = lpEntryId.getData()\n        prop['cValues'] = len(prop['lpb'])\n        request['lpEntryIds']['lpbin'].append(prop)\n    request['lpEntryIds']['cValues'] = len(lpEntryIds)\n\n    resp = dce.request(request)\n    return resp",
  "def hNspiQueryColumns(dce, handler, dwFlags=NspiUnicodeProptypes):\n    request = NspiQueryColumns()\n    request['hRpc'] = handler\n    request['dwFlags'] = dwFlags\n\n    resp = dce.request(request)\n    return resp",
  "def hNspiGetNamesFromIDs(dce, handler, lpguid=EMPTY_UUID, pPropTags=[], pPropTagsRaw=NULL):\n    request = NspiGetNamesFromIDs()\n    request['hRpc'] = handler\n    request['lpguid'] = lpguid\n\n    if len(pPropTags) > 0:\n        for aulPropTag in pPropTags:\n            prop = DWORD()\n            prop['Data'] = aulPropTag\n            request['pPropTags']['aulPropTag'].append(prop)\n        request['pPropTags']['cValues'] = len(pPropTags)\n        request.fields['pPropTags'].fields['Data'].fields['aulPropTag'].fields['MaximumCount'] = len(pPropTags) + 1\n    elif pPropTagsRaw == NULL:\n        request.fields['pPropTags'] = NULL\n    else:\n        request['pPropTags'] = pPropTagsRaw\n\n    resp = dce.request(request)\n    return resp",
  "def hNspiResolveNames(dce, handler, ContainerID=0, pPropTags=[], pPropTagsRaw=NULL, paStr=[]):\n    request = NspiResolveNames()\n    request['hRpc'] = handler\n    request['pStat']['ContainerID'] = ContainerID\n\n    if len(pPropTags) > 0:\n        for aulPropTag in pPropTags:\n            prop = DWORD()\n            prop['Data'] = aulPropTag\n            request['pPropTags']['aulPropTag'].append(prop)\n        request['pPropTags']['cValues'] = len(pPropTags)\n        request.fields['pPropTags'].fields['Data'].fields['aulPropTag'].fields['MaximumCount'] = len(pPropTags) + 1\n    elif pPropTagsRaw == NULL:\n        request.fields['pPropTags'] = NULL\n    else:\n        request['pPropTags'] = pPropTagsRaw\n\n    if len(paStr) > 0:\n        for paStrElem in paStr:\n            value = LPSTR()\n            value['Data'] = checkNullString(paStrElem)\n            request['paStr']['Strings'].append(value)\n        request['paStr']['Count'] = len(paStr)\n\n    resp = dce.request(request)\n    return resp",
  "def hNspiResolveNamesW(dce, handler, ContainerID=0, pPropTags=[], pPropTagsRaw=NULL, paStr=[]):\n    request = NspiResolveNamesW()\n    request['hRpc'] = handler\n    request['pStat']['ContainerID'] = ContainerID\n\n    if len(pPropTags) > 0:\n        for aulPropTag in pPropTags:\n            prop = DWORD()\n            prop['Data'] = aulPropTag\n            request['pPropTags']['aulPropTag'].append(prop)\n        request['pPropTags']['cValues'] = len(pPropTags)\n        request.fields['pPropTags'].fields['Data'].fields['aulPropTag'].fields['MaximumCount'] = len(pPropTags) + 1\n    elif pPropTagsRaw == NULL:\n        request.fields['pPropTags'] = NULL\n    else:\n        request['pPropTags'] = pPropTagsRaw\n\n    if len(paStr) > 0:\n        for paStrElem in paStr:\n            value = LPWSTR()\n            value['Data'] = checkNullString(paStrElem)\n            request['paStr']['Strings'].append(value)\n        request['paStr']['Count'] = len(paStr)\n\n    resp = dce.request(request)\n    return resp",
  "def __str__( self ):\n        key = self.error_code\n        if key in mapi_constants.ERROR_MESSAGES:\n            error_msg_short = mapi_constants.ERROR_MESSAGES[key]\n            return 'NSPI SessionError: code: 0x%x - %s' % (self.error_code, error_msg_short)\n        elif key in hresult_errors.ERROR_MESSAGES:\n            error_msg_short = hresult_errors.ERROR_MESSAGES[key][0]\n            error_msg_verbose = hresult_errors.ERROR_MESSAGES[key][1]\n            return 'NSPI SessionError: code: 0x%x - %s - %s' % (self.error_code, error_msg_short, error_msg_verbose)\n        else:\n            return 'NSPI SessionError: unknown error code: 0x%x' % self.error_code",
  "def __init__(self, data=None, isNDR64=False):\n        NDRSTRUCT.__init__(self, data, isNDR64)\n        self['context_handle_uuid'] = b'\\x00'*16",
  "def isNull(self):\n        return self['context_handle_uuid'] == b'\\x00'*16",
  "def __str__(self):\n        return self[\"DistinguishedName\"]",
  "def __str__(self):\n        return self.formatCanonical()",
  "class DCERPCSessionError(DCERPCException):\n    def __init__(self, error_string=None, error_code=None, packet=None):\n        DCERPCException.__init__(self, error_string, error_code, packet)\n\n    def __str__( self ):\n        key = self.error_code\n        if key in hresult_errors.ERROR_MESSAGES:\n            error_msg_short = hresult_errors.ERROR_MESSAGES[key][0]\n            error_msg_verbose = hresult_errors.ERROR_MESSAGES[key][1]\n            return 'TSCH SessionError: code: 0x%x - %s - %s' % (self.error_code, error_msg_short, error_msg_verbose)\n        else:\n            return 'TSCH SessionError: unknown error code: 0x%x' % self.error_code",
  "class WORD_ARRAY(NDRUniConformantArray):\n    item = '<H'",
  "class SASetAccountInformation(NDRCALL):\n    opnum = 0\n    structure = (\n        ('Handle', PSASEC_HANDLE),\n        ('pwszJobName', WSTR),\n        ('pwszAccount', WSTR),\n        ('pwszPassword', LPWSTR),\n        ('dwJobFlags', DWORD),\n    )",
  "class SASetAccountInformationResponse(NDRCALL):\n    structure = (\n        ('ErrorCode',ULONG),\n    )",
  "class SASetNSAccountInformation(NDRCALL):\n    opnum = 1\n    structure = (\n        ('Handle', PSASEC_HANDLE),\n        ('pwszAccount', LPWSTR),\n        ('pwszPassword', LPWSTR),\n    )",
  "class SASetNSAccountInformationResponse(NDRCALL):\n    structure = (\n        ('ErrorCode',ULONG),\n    )",
  "class SAGetNSAccountInformation(NDRCALL):\n    opnum = 2\n    structure = (\n        ('Handle', PSASEC_HANDLE),\n        ('ccBufferSize', DWORD),\n        ('wszBuffer', WORD_ARRAY),\n    )",
  "class SAGetNSAccountInformationResponse(NDRCALL):\n    structure = (\n        ('wszBuffer',WORD_ARRAY),\n        ('ErrorCode',ULONG),\n    )",
  "class SAGetAccountInformation(NDRCALL):\n    opnum = 3\n    structure = (\n        ('Handle', PSASEC_HANDLE),\n        ('pwszJobName', WSTR),\n        ('ccBufferSize', DWORD),\n        ('wszBuffer', WORD_ARRAY),\n    )",
  "class SAGetAccountInformationResponse(NDRCALL):\n    structure = (\n        ('wszBuffer',WORD_ARRAY),\n        ('ErrorCode',ULONG),\n    )",
  "def checkNullString(string):\n    if string == NULL:\n        return string\n\n    if string[-1:] != '\\x00':\n        return string + '\\x00'\n    else:\n        return string",
  "def hSASetAccountInformation(dce, handle, pwszJobName, pwszAccount, pwszPassword, dwJobFlags=0):\n    request = SASetAccountInformation()\n    request['Handle'] = handle\n    request['pwszJobName'] = checkNullString(pwszJobName)\n    request['pwszAccount'] = checkNullString(pwszAccount)\n    request['pwszPassword'] = checkNullString(pwszPassword)\n    request['dwJobFlags'] = dwJobFlags\n    return dce.request(request)",
  "def hSASetNSAccountInformation(dce, handle, pwszAccount, pwszPassword):\n    request = SASetNSAccountInformation()\n    request['Handle'] = handle\n    request['pwszAccount'] = checkNullString(pwszAccount)\n    request['pwszPassword'] = checkNullString(pwszPassword)\n    return dce.request(request)",
  "def hSAGetNSAccountInformation(dce, handle, ccBufferSize = MAX_BUFFER_SIZE):\n    request = SAGetNSAccountInformation()\n    request['Handle'] = handle\n    request['ccBufferSize'] = ccBufferSize\n    for _ in range(ccBufferSize):\n        request['wszBuffer'].append(0)\n    return dce.request(request)",
  "def hSAGetAccountInformation(dce, handle, pwszJobName, ccBufferSize = MAX_BUFFER_SIZE):\n    request = SAGetAccountInformation()\n    request['Handle'] = handle\n    request['pwszJobName'] = checkNullString(pwszJobName)\n    request['ccBufferSize'] = ccBufferSize\n    for _ in range(ccBufferSize):\n        request['wszBuffer'].append(0)\n    return dce.request(request)",
  "def __init__(self, error_string=None, error_code=None, packet=None):\n        DCERPCException.__init__(self, error_string, error_code, packet)",
  "def __str__( self ):\n        key = self.error_code\n        if key in hresult_errors.ERROR_MESSAGES:\n            error_msg_short = hresult_errors.ERROR_MESSAGES[key][0]\n            error_msg_verbose = hresult_errors.ERROR_MESSAGES[key][1]\n            return 'TSCH SessionError: code: 0x%x - %s - %s' % (self.error_code, error_msg_short, error_msg_verbose)\n        else:\n            return 'TSCH SessionError: unknown error code: 0x%x' % self.error_code",
  "class DCERPCSessionError(DCERPCException):\n    def __init__(self, error_string=None, error_code=None, packet=None):\n        DCERPCException.__init__(self, error_string, error_code, packet)\n\n    def __str__( self ):\n        key = self.error_code\n        if key in system_errors.ERROR_MESSAGES:\n            error_msg_short = system_errors.ERROR_MESSAGES[key][0]\n            error_msg_verbose = system_errors.ERROR_MESSAGES[key][1] \n            return 'SCMR SessionError: code: 0x%x - %s - %s' % (self.error_code, error_msg_short, error_msg_verbose)\n        else:\n            return 'SCMR SessionError: unknown error code: 0x%x' % self.error_code",
  "class BYTE_ARRAY(NDRUniConformantArray):\n    item = 'c'",
  "class SC_RPC_HANDLE(NDRSTRUCT):\n    structure =  (\n        ('Data','20s=\"\"'),\n    )\n    def getAlignment(self):\n        return 1",
  "class SERVICE_STATUS(NDRSTRUCT):\n    structure =  (\n        ('dwServiceType',DWORD),\n        ('dwCurrentState',DWORD),\n        ('dwControlsAccepted',DWORD),\n        ('dwWin32ExitCode',DWORD),\n        ('dwServiceSpecificExitCode',DWORD),\n        ('dwCheckPoint',DWORD),\n        ('dwWaitHint',DWORD),\n    )",
  "class QUERY_SERVICE_CONFIGW(NDRSTRUCT):\n    structure = (\n        ('dwServiceType',DWORD),\n        ('dwStartType',DWORD),\n        ('dwErrorControl',DWORD),\n        ('lpBinaryPathName', LPWSTR),\n        ('lpLoadOrderGroup',LPWSTR),\n        ('dwTagId',DWORD),\n        ('lpDependencies',LPWSTR),\n        ('lpServiceStartName',LPWSTR),\n        ('lpDisplayName',LPWSTR),\n    )",
  "class SC_RPC_LOCK(NDRSTRUCT):\n    structure =  (\n        ('Data','20s=\"\"'),\n    )\n    def getAlignment(self):\n        return 1",
  "class LPSERVICE_STATUS(NDRPOINTER):\n    referent = (\n        ('Data',SERVICE_STATUS),\n    )",
  "class LPBOUNDED_DWORD_256K(NDRPOINTER):\n    referent = (\n        ('Data', BOUNDED_DWORD_256K),\n    )",
  "class ENUM_SERVICE_STATUSW(NDRSTRUCT):\n    structure = (\n        ('lpServiceName',LPWSTR),\n        ('lpDisplayName',LPWSTR),\n        ('ServiceStatus',SERVICE_STATUS),\n    )",
  "class LPQUERY_SERVICE_CONFIGW(NDRPOINTER):\n    referent = (\n        ('Data', QUERY_SERVICE_CONFIGW),\n    )",
  "class STRING_PTRSW(NDRSTRUCT):\n    structure = (\n        ('Data',NDRUniConformantArray),\n    )\n    def __init__(self, data = None, isNDR64 = False):\n        NDR.__init__(self,None,isNDR64)\n        self.fields['Data'].item = LPWSTR\n        if data is not None:\n            self.fromString(data)",
  "class UNIQUE_STRING_PTRSW(NDRPOINTER):\n    referent = (\n        ('Data', STRING_PTRSW),\n    )",
  "class QUERY_SERVICE_LOCK_STATUSW(NDRSTRUCT):\n    structure = (\n        ('fIsLocked',DWORD),\n        ('lpLockOwner',LPWSTR),\n        ('dwLockDuration',DWORD),\n    )",
  "class SERVICE_DESCRIPTION_WOW64(NDRSTRUCT):\n    structure = (\n        ('dwDescriptionOffset', DWORD),\n    )",
  "class SERVICE_DESCRIPTIONW(NDRSTRUCT):\n    structure = (\n        ('lpDescription', LPWSTR),\n    )",
  "class LPSERVICE_DESCRIPTIONW(NDRPOINTER):\n    referent = (\n        ('Data', SERVICE_DESCRIPTIONW),\n    )",
  "class SERVICE_FAILURE_ACTIONS_WOW64(NDRSTRUCT):\n    structure = (\n        ('dwResetPeriod', DWORD),\n        ('dwRebootMsgOffset', DWORD),\n        ('dwCommandOffset', DWORD),\n        ('cActions', DWORD),\n        ('dwsaActionsOffset', DWORD),\n    )",
  "class SC_ACTION(NDRSTRUCT):\n    structure = (\n        ('Type', DWORD), \n        ('Delay', DWORD) , \n    )",
  "class SC_ACTIONS(NDRSTRUCT):\n    structure = (\n       ('Data', NDRUniConformantArray),\n    )\n    def __init__(self, data = None, isNDR64 = False):\n        NDR.__init__(self,None,isNDR64)\n        self.fields['Data'].item = SC_ACTION\n        if data is not None:\n            self.fromString(data)",
  "class SERVICE_FAILURE_ACTIONSW(NDRSTRUCT):\n    structure = (\n        ('dwResetPeriod', DWORD), \n        ('lpRebootMsg', LPWSTR) , \n        ('lpCommand', LPWSTR) , \n        ('cActions', DWORD) , \n        ('lpsaActions', SC_ACTIONS) , \n    )",
  "class LPSERVICE_FAILURE_ACTIONSW(NDRPOINTER):\n    referent = (\n        ('Data', SERVICE_FAILURE_ACTIONSW),\n    )",
  "class SERVICE_FAILURE_ACTIONS_FLAG(NDRSTRUCT):\n    structure = (\n        ('fFailureActionsOnNonCrashFailures', BOOL),\n    )",
  "class LPSERVICE_FAILURE_ACTIONS_FLAG(NDRPOINTER):\n    referent = (\n        ('Data', SERVICE_FAILURE_ACTIONS_FLAG),\n    )",
  "class SERVICE_DELAYED_AUTO_START_INFO(NDRSTRUCT):\n    structure = (\n        ('fDelayedAutostart', BOOL),\n    )",
  "class LPSERVICE_DELAYED_AUTO_START_INFO(NDRPOINTER):\n    referent = (\n        ('Data', SERVICE_DELAYED_AUTO_START_INFO),\n    )",
  "class SERVICE_SID_INFO(NDRSTRUCT):\n    structure = (\n        ('dwServiceSidType', DWORD),\n    )",
  "class LPSERVICE_SID_INFO(NDRPOINTER):\n    referent = (\n        ('Data', SERVICE_SID_INFO),\n    )",
  "class SERVICE_RPC_REQUIRED_PRIVILEGES_INFO(NDRSTRUCT):\n    structure = (\n        ('cbRequiredPrivileges',DWORD),\n        ('pRequiredPrivileges',LPBYTE),\n    )\n    def getData(self, soFar = 0):\n        self['cbRequiredPrivileges'] = len(self['pRequiredPrivileges'])\n        return NDR.getData(self, soFar = 0)",
  "class LPSERVICE_RPC_REQUIRED_PRIVILEGES_INFO(NDRPOINTER):\n    referent = (\n        ('Data', SERVICE_RPC_REQUIRED_PRIVILEGES_INFO),\n    )",
  "class SERVICE_REQUIRED_PRIVILEGES_INFO_WOW64(NDRSTRUCT):\n    structure = (\n        ('dwRequiredPrivilegesOffset', DWORD),\n    )",
  "class SERVICE_PRESHUTDOWN_INFO(NDRSTRUCT):\n    structure = (\n        ('dwPreshutdownTimeout', DWORD),\n    )",
  "class LPSERVICE_PRESHUTDOWN_INFO(NDRPOINTER):\n    referent = (\n        ('Data', SERVICE_PRESHUTDOWN_INFO),\n    )",
  "class SERVICE_STATUS_PROCESS(NDRSTRUCT):\n    structure = (\n        ('dwServiceType', DWORD),\n        ('dwCurrentState', DWORD),\n        ('dwControlsAccepted', DWORD),\n        ('dwWin32ExitCode', DWORD),\n        ('dwServiceSpecificExitCode', DWORD),\n        ('dwCheckPoint', DWORD),\n        ('dwWaitHint', DWORD),\n        ('dwProcessId', DWORD),\n        ('dwServiceFlags', DWORD),\n    )",
  "class UCHAR_16(NDRSTRUCT):\n    structure = (\n        ('Data', '16s=\"\"'),\n    )\n    def getAlignment(self):\n        return 1",
  "class SERVICE_NOTIFY_STATUS_CHANGE_PARAMS_1(NDRSTRUCT):\n    structure = (\n        ('ullThreadId',ULONGLONG),\n        ('dwNotifyMask',DWORD),\n        ('CallbackAddressArray',UCHAR_16),\n        ('CallbackParamAddressArray',UCHAR_16),\n        ('ServiceStatus', SERVICE_STATUS_PROCESS),\n        ('dwNotificationStatus',DWORD),\n        ('dwSequence',DWORD),\n    )",
  "class SERVICE_NOTIFY_STATUS_CHANGE_PARAMS_2(NDRSTRUCT):\n    structure = (\n        ('ullThreadId',ULONGLONG),\n        ('dwNotifyMask',DWORD),\n        ('CallbackAddressArray',UCHAR_16),\n        ('CallbackParamAddressArray',UCHAR_16),\n        ('ServiceStatus',SERVICE_STATUS_PROCESS),\n        ('dwNotificationStatus',DWORD),\n        ('dwSequence',DWORD),\n        ('dwNotificationTriggered',DWORD),\n        ('pszServiceNames',LPWSTR),\n    )",
  "class PSERVICE_NOTIFY_STATUS_CHANGE_PARAMS_1(NDRPOINTER):\n    referent = (\n        ('Data', SERVICE_NOTIFY_STATUS_CHANGE_PARAMS_1),\n    )",
  "class PSERVICE_NOTIFY_STATUS_CHANGE_PARAMS_2(NDRPOINTER):\n    referent = (\n        ('Data', SERVICE_NOTIFY_STATUS_CHANGE_PARAMS_2),\n    )",
  "class SC_RPC_NOTIFY_PARAMS(NDRUNION):\n    union = {\n        1: ('pStatusChangeParam1', PSERVICE_NOTIFY_STATUS_CHANGE_PARAMS_1),\n        2: ('pStatusChangeParams', PSERVICE_NOTIFY_STATUS_CHANGE_PARAMS_2),\n    }",
  "class SC_RPC_NOTIFY_PARAMS_ARRAY(NDRUniConformantArray):\n     item = SC_RPC_NOTIFY_PARAMS",
  "class PSC_RPC_NOTIFY_PARAMS_LIST(NDRSTRUCT):\n    structure = (\n        ('cElements',BOUNDED_DWORD_4K),\n        ('NotifyParamsArray', SC_RPC_NOTIFY_PARAMS_ARRAY),\n    )",
  "class SERVICE_CONTROL_STATUS_REASON_IN_PARAMSW(NDRSTRUCT):\n    structure = (\n        ('dwReason', DWORD),\n        ('pszComment', LPWSTR),\n    )",
  "class SERVICE_TRIGGER_SPECIFIC_DATA_ITEM(NDRSTRUCT):\n    structure = (\n        ('dwDataType',DWORD ),\n        ('cbData',DWORD),\n        ('pData', LPBYTE),\n    )\n    def getData(self, soFar = 0):\n        if self['pData'] != 0:\n            self['cbData'] = len(self['pData'])\n        return NDR.getData(self, soFar)",
  "class SERVICE_TRIGGER_SPECIFIC_DATA_ITEM_ARRAY(NDRUniConformantArray):\n    item = SERVICE_TRIGGER_SPECIFIC_DATA_ITEM",
  "class PSERVICE_TRIGGER_SPECIFIC_DATA_ITEM(NDRPOINTER):\n    referent = (\n        ('Data', SERVICE_TRIGGER_SPECIFIC_DATA_ITEM_ARRAY),\n    )",
  "class SERVICE_TRIGGER(NDRSTRUCT):\n    structure = (\n        ('dwTriggerType', DWORD),\n        ('dwAction', DWORD),\n        ('pTriggerSubtype', PGUID),\n        ('cDataItems', DWORD),\n        ('pDataItems', PSERVICE_TRIGGER_SPECIFIC_DATA_ITEM),\n    )\n    def getData(self, soFar = 0):\n        if self['pDataItems'] != 0:\n            self['cDataItems'] = len(self['pDataItems'])\n        return NDR.getData(self, soFar)",
  "class SERVICE_TRIGGER_ARRAY(NDRUniConformantArray):\n    item = SERVICE_TRIGGER",
  "class PSERVICE_TRIGGER(NDRPOINTER):\n    referent = (\n        ('Data', SERVICE_TRIGGER_ARRAY),\n    )",
  "class SERVICE_CONTROL_STATUS_REASON_OUT_PARAMS(NDRSTRUCT):\n    structure = (\n       ('ServiceStatus', SERVICE_STATUS_PROCESS),\n    )",
  "class SERVICE_TRIGGER_INFO(NDRSTRUCT):\n    structure = (\n        ('cTriggers', DWORD),\n        ('pTriggers', PSERVICE_TRIGGER),\n        ('pReserved', NDRPOINTERNULL ),\n    )\n    def getData(self, soFar = 0):\n        if self['pTriggers'] != 0:\n            self['cTriggers'] = len(self['pTriggers'])\n        return NDR.getData(self, soFar)",
  "class PSERVICE_TRIGGER_INFO(NDRPOINTER):\n    referent = (\n        ('Data', SERVICE_TRIGGER_INFO),\n    )",
  "class SERVICE_PREFERRED_NODE_INFO(NDRSTRUCT):\n    structure = (\n        ('usPreferredNode', USHORT),\n        ('fDelete', BOOL),\n    )",
  "class LPSERVICE_PREFERRED_NODE_INFO(NDRPOINTER):\n    referent = (\n        ('Data', SERVICE_PREFERRED_NODE_INFO),\n    )",
  "class SERVICE_RUNLEVEL_INFO(NDRSTRUCT):\n    structure = (\n        ('eLowestRunLevel', DWORD),\n    )",
  "class PSERVICE_RUNLEVEL_INFO(NDRPOINTER):\n    referent = (\n        ('Data', SERVICE_RUNLEVEL_INFO),\n    )",
  "class SERVICE_MANAGEDACCOUNT_INFO(NDRSTRUCT):\n    structure = (\n        ('fIsManagedAccount', DWORD),\n    )",
  "class PSERVICE_MANAGEDACCOUNT_INFO(NDRPOINTER):\n    referent = (\n        ('Data', SERVICE_MANAGEDACCOUNT_INFO),\n    )",
  "class SC_RPC_CONFIG_INFOW_UNION(NDRUNION):\n    commonHdr = (\n        ('tag', ULONG),\n    )\n\n    union = {\n        1: ('psd', LPSERVICE_DESCRIPTIONW),\n        2: ('psfa',LPSERVICE_FAILURE_ACTIONSW ),\n        3: ('psda',LPSERVICE_DELAYED_AUTO_START_INFO),\n        4: ('psfaf',LPSERVICE_FAILURE_ACTIONS_FLAG),\n        5: ('pssid',LPSERVICE_SID_INFO),\n        6: ('psrp',LPSERVICE_RPC_REQUIRED_PRIVILEGES_INFO),\n        7: ('psps',LPSERVICE_PRESHUTDOWN_INFO),\n        8: ('psti',PSERVICE_TRIGGER_INFO),\n        9: ('pspn',LPSERVICE_PREFERRED_NODE_INFO),\n        10: ('psri',PSERVICE_RUNLEVEL_INFO),\n        11: ('psma',PSERVICE_MANAGEDACCOUNT_INFO),\n    }",
  "class SC_RPC_CONFIG_INFOW(NDRSTRUCT):\n    structure = (\n        ('dwInfoLevel', DWORD),\n        ('Union', SC_RPC_CONFIG_INFOW_UNION),\n    )",
  "class RCloseServiceHandle(NDRCALL):\n    opnum = 0\n    structure = (\n        ('hSCObject',SC_RPC_HANDLE),\n    )",
  "class RCloseServiceHandleResponse(NDRCALL):\n    structure = (\n        ('hSCObject',SC_RPC_HANDLE),\n        ('ErrorCode', DWORD),\n    )",
  "class RControlService(NDRCALL):\n    opnum = 1\n    structure = (\n        ('hService',SC_RPC_HANDLE),\n        ('dwControl',DWORD),\n    )",
  "class RControlServiceResponse(NDRCALL):\n    structure = (\n        ('lpServiceStatus',SERVICE_STATUS),\n        ('ErrorCode', DWORD),\n    )",
  "class RDeleteService(NDRCALL):\n    opnum = 2\n    structure = (\n        ('hService',SC_RPC_HANDLE),\n    )",
  "class RDeleteServiceResponse(NDRCALL):\n    structure = (\n        ('ErrorCode', DWORD),\n    )",
  "class RLockServiceDatabase(NDRCALL):\n    opnum = 3\n    structure = (\n        ('hSCManager',SC_RPC_HANDLE),\n    )",
  "class RLockServiceDatabaseResponse(NDRCALL):\n    structure = (\n        ('lpLock',SC_RPC_LOCK),\n        ('ErrorCode', DWORD),\n    )",
  "class RQueryServiceObjectSecurity(NDRCALL):\n    opnum = 4\n    structure = (\n        ('hService',SC_RPC_HANDLE),\n        ('dwSecurityInformation',SECURITY_INFORMATION),\n        ('cbBufSize',DWORD),\n    )",
  "class RQueryServiceObjectSecurityResponse(NDRCALL):\n    structure = (\n        ('lpSecurityDescriptor', BYTE_ARRAY),\n        ('pcbBytesNeeded',BOUNDED_DWORD_256K),\n        ('ErrorCode', DWORD),\n    )",
  "class RSetServiceObjectSecurity(NDRCALL):\n    opnum = 5\n    structure = (\n        ('hService',SC_RPC_HANDLE),\n        ('dwSecurityInformation',SECURITY_INFORMATION),\n        ('lpSecurityDescriptor',LPBYTE),\n        ('cbBufSize',DWORD),\n    )",
  "class RSetServiceObjectSecurityResponse(NDRCALL):\n    structure = (\n        ('ErrorCode', DWORD),\n    )",
  "class RQueryServiceStatus(NDRCALL):\n    opnum = 6\n    structure = (\n        ('hService',SC_RPC_HANDLE),\n    )",
  "class RQueryServiceStatusResponse(NDRCALL):\n    structure = (\n        ('lpServiceStatus',SERVICE_STATUS),\n        ('ErrorCode', DWORD),\n    )",
  "class RSetServiceStatus(NDRCALL):\n    opnum = 7\n    structure = (\n        ('hServiceStatus',SC_RPC_HANDLE),\n        ('lpServiceStatus',SERVICE_STATUS),\n    )",
  "class RSetServiceStatusResponse(NDRCALL):\n    structure = (\n        ('ErrorCode', DWORD),\n    )",
  "class RUnlockServiceDatabase(NDRCALL):\n    opnum = 8\n    structure = (\n        ('Lock',SC_RPC_LOCK),\n    )",
  "class RUnlockServiceDatabaseResponse(NDRCALL):\n    structure = (\n        ('Lock',SC_RPC_LOCK),\n        ('ErrorCode', DWORD),\n    )",
  "class RNotifyBootConfigStatus(NDRCALL):\n    opnum = 9\n    structure = (\n        ('lpMachineName',SVCCTL_HANDLEW),\n        ('BootAcceptable',DWORD),\n    )",
  "class RNotifyBootConfigStatusResponse(NDRCALL):\n    structure = (\n        ('ErrorCode', DWORD),\n    )",
  "class RChangeServiceConfigW(NDRCALL):\n    opnum = 11\n    structure = (\n        ('hService',SC_RPC_HANDLE),\n        ('dwServiceType',DWORD),\n        ('dwStartType',DWORD),\n        ('dwErrorControl',DWORD),\n        ('lpBinaryPathName',LPWSTR),\n        ('lpLoadOrderGroup',LPWSTR),\n        ('lpdwTagId',LPDWORD),\n        ('lpDependencies',LPBYTE),\n        ('dwDependSize',DWORD),\n        ('lpServiceStartName',LPWSTR),\n        ('lpPassword',LPBYTE),\n        ('dwPwSize',DWORD),\n        ('lpDisplayName',LPWSTR),\n    )",
  "class RChangeServiceConfigWResponse(NDRCALL):\n    structure = (\n        ('lpdwTagId',LPDWORD),\n        ('ErrorCode', DWORD),\n    )",
  "class RCreateServiceW(NDRCALL):\n    opnum = 12\n    structure = (\n        ('hSCManager',SC_RPC_HANDLE),\n        ('lpServiceName',WSTR),\n        ('lpDisplayName',LPWSTR),\n        ('dwDesiredAccess',DWORD),\n        ('dwServiceType',DWORD),\n        ('dwStartType',DWORD),\n        ('dwErrorControl',DWORD),\n        ('lpBinaryPathName',WSTR),\n        ('lpLoadOrderGroup',LPWSTR),\n        ('lpdwTagId',LPDWORD),\n        ('lpDependencies',LPBYTE),\n        ('dwDependSize',DWORD),\n        ('lpServiceStartName',LPWSTR),\n        ('lpPassword',LPBYTE),\n        ('dwPwSize',DWORD),\n    )",
  "class RCreateServiceWResponse(NDRCALL):\n    structure = (\n        ('lpdwTagId',LPWSTR),\n        ('lpServiceHandle',SC_RPC_HANDLE),\n        ('ErrorCode', DWORD),\n    )",
  "class REnumDependentServicesW(NDRCALL):\n    opnum = 13\n    structure = (\n        ('hService',SC_RPC_HANDLE),\n        ('dwServiceState',DWORD),\n        ('cbBufSize',DWORD),\n    )",
  "class REnumDependentServicesWResponse(NDRCALL):\n    structure = (\n        ('lpServices',NDRUniConformantArray),\n        ('pcbBytesNeeded',BOUNDED_DWORD_256K),\n        ('lpServicesReturned',BOUNDED_DWORD_256K),\n        ('ErrorCode', DWORD),\n    )",
  "class REnumServicesStatusW(NDRCALL):\n    opnum = 14\n    structure = (\n        ('hSCManager',SC_RPC_HANDLE),\n        ('dwServiceType',DWORD),\n        ('dwServiceState',DWORD),\n        ('cbBufSize',DWORD),\n        ('lpResumeIndex',LPBOUNDED_DWORD_256K),\n    )",
  "class REnumServicesStatusWResponse(NDRCALL):\n    structure = (\n        ('lpBuffer',NDRUniConformantArray),\n        ('pcbBytesNeeded',BOUNDED_DWORD_256K),\n        ('lpServicesReturned',BOUNDED_DWORD_256K),\n        ('lpResumeIndex',LPBOUNDED_DWORD_256K),\n        ('ErrorCode', DWORD),\n    )",
  "class ROpenSCManagerW(NDRCALL):\n    opnum = 15\n    structure = (\n        ('lpMachineName',SVCCTL_HANDLEW),\n        ('lpDatabaseName',LPWSTR),\n        ('dwDesiredAccess',DWORD),\n    )",
  "class ROpenSCManagerWResponse(NDRCALL):\n    structure = (\n        ('lpScHandle',SC_RPC_HANDLE),\n        ('ErrorCode', DWORD),\n    )",
  "class ROpenServiceW(NDRCALL):\n    opnum = 16\n    structure = (\n        ('hSCManager',SC_RPC_HANDLE),\n        ('lpServiceName',WSTR),\n        ('dwDesiredAccess',DWORD),\n    )",
  "class ROpenServiceWResponse(NDRCALL):\n    structure = (\n        ('lpServiceHandle',SC_RPC_HANDLE),\n        ('ErrorCode', DWORD),\n    )",
  "class RQueryServiceConfigW(NDRCALL):\n    opnum = 17\n    structure = (\n        ('hService',SC_RPC_HANDLE),\n        ('cbBufSize',DWORD),\n    )",
  "class RQueryServiceConfigWResponse(NDRCALL):\n    structure = (\n        ('lpServiceConfig',QUERY_SERVICE_CONFIGW),\n        ('pcbBytesNeeded',BOUNDED_DWORD_8K),\n        ('ErrorCode', DWORD),\n    )",
  "class RQueryServiceLockStatusW(NDRCALL):\n    opnum = 18\n    structure = (\n        ('hSCManager',SC_RPC_HANDLE),\n        ('cbBufSize',DWORD),\n    )",
  "class RQueryServiceLockStatusWResponse(NDRCALL):\n    structure = (\n        ('lpLockStatus',QUERY_SERVICE_LOCK_STATUSW),\n        ('pcbBytesNeeded',BOUNDED_DWORD_4K),\n        ('ErrorCode', DWORD),\n    )",
  "class RStartServiceW(NDRCALL):\n    opnum = 19\n    structure = (\n        ('hService',SC_RPC_HANDLE),\n        ('argc',DWORD),\n        ('argv',UNIQUE_STRING_PTRSW),\n    )",
  "class RStartServiceWResponse(NDRCALL):\n    structure = (\n        ('ErrorCode', DWORD),\n    )",
  "class RGetServiceDisplayNameW(NDRCALL):\n    opnum = 20\n    structure = (\n        ('hSCManager',SC_RPC_HANDLE),\n        ('lpServiceName',WSTR),\n        ('lpcchBuffer',DWORD),\n    )",
  "class RGetServiceDisplayNameWResponse(NDRCALL):\n    structure = (\n        ('lpDisplayName',WSTR),\n        ('lpcchBuffer',DWORD),\n        ('ErrorCode', DWORD),\n    )",
  "class RGetServiceKeyNameW(NDRCALL):\n    opnum = 21\n    structure = (\n        ('hSCManager',SC_RPC_HANDLE),\n        ('lpDisplayName',WSTR),\n        ('lpcchBuffer',DWORD),\n    )",
  "class RGetServiceKeyNameWResponse(NDRCALL):\n    structure = (\n        ('lpDisplayName',WSTR),\n        ('lpcchBuffer',DWORD),\n        ('ErrorCode', DWORD),\n    )",
  "class REnumServiceGroupW(NDRCALL):\n    opnum = 35\n    structure = (\n        ('hSCManager',SC_RPC_HANDLE),\n        ('dwServiceType',DWORD),\n        ('dwServiceState',DWORD),\n        ('cbBufSize',DWORD),\n        ('lpResumeIndex',LPBOUNDED_DWORD_256K),\n        ('pszGroupName',LPWSTR),\n    )",
  "class REnumServiceGroupWResponse(NDRCALL):\n    structure = (\n        ('lpBuffer',LPBYTE),\n        ('pcbBytesNeeded',BOUNDED_DWORD_256K),\n        ('lpServicesReturned',BOUNDED_DWORD_256K),\n        ('lpResumeIndex',BOUNDED_DWORD_256K),\n        ('ErrorCode', DWORD),\n    )",
  "class RChangeServiceConfig2W(NDRCALL):\n    opnum = 37\n    structure = (\n       ('hService',SC_RPC_HANDLE),\n       ('Info',SC_RPC_CONFIG_INFOW),\n    )",
  "class RChangeServiceConfig2WResponse(NDRCALL):\n    structure = (\n        ('ErrorCode', DWORD),\n    )",
  "class RQueryServiceConfig2W(NDRCALL):\n    opnum = 39\n    structure = (\n        ('hService',SC_RPC_HANDLE),\n        ('dwInfoLevel',DWORD),\n        ('cbBufSize',DWORD),\n    )",
  "class RQueryServiceConfig2WResponse(NDRCALL):\n    structure = (\n        ('lpBuffer',NDRUniConformantArray),\n        ('pcbBytesNeeded',BOUNDED_DWORD_8K),\n        ('ErrorCode', DWORD),\n    )",
  "class RQueryServiceStatusEx(NDRCALL):\n    opnum = 40\n    structure = (\n        ('hService',SC_RPC_HANDLE),\n        ('InfoLevel',DWORD),\n        ('cbBufSize',DWORD),\n    )",
  "class RQueryServiceStatusExResponse(NDRCALL):\n    structure = (\n        ('lpBuffer',NDRUniConformantArray),\n        ('pcbBytesNeeded',BOUNDED_DWORD_8K),\n        ('ErrorCode', DWORD),\n    )",
  "class REnumServicesStatusExW(NDRCALL):\n    opnum = 42\n    structure = (\n        ('hSCManager',SC_RPC_HANDLE),\n        ('InfoLevel',DWORD),\n        ('dwServiceType',DWORD),\n        ('dwServiceState',DWORD),\n        ('cbBufSize',DWORD),\n        ('lpResumeIndex',LPBOUNDED_DWORD_256K),\n        ('pszGroupName',LPWSTR),\n    )",
  "class REnumServicesStatusExWResponse(NDRCALL):\n    structure = (\n        ('lpBuffer',NDRUniConformantArray),\n        ('pcbBytesNeeded',BOUNDED_DWORD_256K),\n        ('lpServicesReturned',BOUNDED_DWORD_256K),\n        ('lpResumeIndex',BOUNDED_DWORD_256K),\n        ('ErrorCode', DWORD),\n    )",
  "class RCreateServiceWOW64W(NDRCALL):\n    opnum = 45\n    structure = (\n        ('hSCManager',SC_RPC_HANDLE),\n        ('lpServiceName',WSTR),\n        ('lpDisplayName',LPWSTR),\n        ('dwDesiredAccess',DWORD),\n        ('dwServiceType',DWORD),\n        ('dwStartType',DWORD),\n        ('dwErrorControl',DWORD),\n        ('lpBinaryPathName',WSTR),\n        ('lpLoadOrderGroup',LPWSTR),\n        ('lpdwTagId',LPDWORD),\n        ('lpDependencies',LPBYTE),\n        ('dwDependSize',DWORD),\n        ('lpServiceStartName',LPWSTR),\n        ('lpPassword',LPBYTE),\n        ('dwPwSize',DWORD),\n    )",
  "class RCreateServiceWOW64WResponse(NDRCALL):\n    structure = (\n        ('lpdwTagId',LPWSTR),\n        ('lpServiceHandle',SC_RPC_HANDLE),\n        ('ErrorCode', DWORD),\n    )",
  "class RNotifyServiceStatusChange(NDRCALL):\n    opnum = 47\n    structure = (\n        ('hService',SC_RPC_HANDLE),\n        ('NotifyParams',SC_RPC_NOTIFY_PARAMS),\n        ('pClientProcessGuid',GUID),\n    )",
  "class RNotifyServiceStatusChangeResponse(NDRCALL):\n    structure = (\n        ('pSCMProcessGuid',GUID),\n        ('pfCreateRemoteQueue',PBOOL),\n        ('phNotify',SC_NOTIFY_RPC_HANDLE),\n        ('ErrorCode', DWORD),\n    )",
  "class RGetNotifyResults(NDRCALL):\n    opnum = 48\n    structure = (\n        ('hNotify',SC_NOTIFY_RPC_HANDLE),\n    )",
  "class RGetNotifyResultsResponse(NDRCALL):\n    structure = (\n        ('ppNotifyParams',PSC_RPC_NOTIFY_PARAMS_LIST),\n        ('ErrorCode', DWORD),\n    )",
  "class RCloseNotifyHandle(NDRCALL):\n    opnum = 49\n    structure = (\n        ('phNotify',SC_NOTIFY_RPC_HANDLE),\n    )",
  "class RCloseNotifyHandleResponse(NDRCALL):\n    structure = (\n        ('phNotify',SC_NOTIFY_RPC_HANDLE),\n        ('pfApcFired',PBOOL),\n        ('ErrorCode', DWORD),\n    )",
  "class RControlServiceExW(NDRCALL):\n    opnum = 51\n    structure = (\n        ('hService',SC_RPC_HANDLE),\n        ('dwControl',DWORD),\n        ('dwInfoLevel',DWORD),\n        ('pControlInParams',SERVICE_CONTROL_STATUS_REASON_IN_PARAMSW),\n    )",
  "class RControlServiceExWResponse(NDRCALL):\n    structure = (\n        ('pControlOutParams',SERVICE_CONTROL_STATUS_REASON_OUT_PARAMS),\n        ('ErrorCode', DWORD),\n    )",
  "class RQueryServiceConfigEx(NDRCALL):\n    opnum = 56\n    structure = (\n        ('hService',SC_RPC_HANDLE),\n        ('dwInfoLevel',DWORD),\n    )",
  "class RQueryServiceConfigExResponse(NDRCALL):\n    structure = (\n        ('pInfo',SC_RPC_CONFIG_INFOW),\n        ('ErrorCode', DWORD),\n    )",
  "def checkNullString(string):\n    if string == NULL:\n        return string\n\n    if string[-1:] != '\\x00':\n        return string + '\\x00'\n    else:\n        return string",
  "def hRCloseServiceHandle(dce, hSCObject):\n    request = RCloseServiceHandle()\n    request['hSCObject'] = hSCObject\n    return dce.request(request)",
  "def hRControlService(dce, hService, dwControl):\n    request = RControlService()\n    request['hService'] = hService\n    request['dwControl'] = dwControl\n    return dce.request(request)",
  "def hRDeleteService(dce, hService):\n    request = RDeleteService()\n    request ['hService'] = hService\n    return dce.request(request)",
  "def hRLockServiceDatabase(dce, hSCManager):\n    request = RLockServiceDatabase()\n    request['hSCManager'] = hSCManager\n    return dce.request(request)",
  "def hRQueryServiceObjectSecurity(dce, hService, dwSecurityInformation, cbBufSize=0):\n    request = RQueryServiceObjectSecurity()\n    request['hService'] = hService\n    request['dwSecurityInformation'] = dwSecurityInformation\n    request['cbBufSize'] = cbBufSize\n    try:\n        resp = dce.request(request)\n    except DCERPCSessionError as e:\n        if e.get_error_code() == system_errors.ERROR_INSUFFICIENT_BUFFER:\n            resp = e.get_packet()\n            request['cbBufSize'] = resp['pcbBytesNeeded']\n            resp = dce.request(request)\n        else:\n            raise\n    return resp",
  "def hRSetServiceObjectSecurity(dce, hService, dwSecurityInformation, lpSecurityDescriptor, cbBufSize ):\n    request = RSetServiceObjectSecurity()\n    request['hService'] = hService\n    request['dwSecurityInformation'] = dwSecurityInformation\n    request['cbBufSize'] = cbBufSize\n    return dce.request(request)",
  "def hRQueryServiceStatus(dce, hService ):\n    request = RQueryServiceStatus()\n    request['hService'] = hService\n    return dce.request(request)",
  "def hRSetServiceStatus(dce, hServiceStatus, lpServiceStatus ):\n    request = RSetServiceStatus()\n    request['hServiceStatus'] = hServiceStatus\n    request['lpServiceStatus'] = lpServiceStatus\n    return dce.request(request)",
  "def hRUnlockServiceDatabase(dce, Lock ):\n    request = RUnlockServiceDatabase()\n    request['Lock'] = Lock\n    return dce.request(request)",
  "def hRNotifyBootConfigStatus(dce, lpMachineName, BootAcceptable ):\n    request = RNotifyBootConfigStatus()\n    request['lpMachineName'] = lpMachineName\n    request['BootAcceptable'] = BootAcceptable\n    return dce.request(request)",
  "def hRChangeServiceConfigW(dce, hService, dwServiceType=SERVICE_NO_CHANGE, dwStartType=SERVICE_NO_CHANGE, dwErrorControl=SERVICE_NO_CHANGE, lpBinaryPathName=NULL, lpLoadOrderGroup=NULL, lpdwTagId=NULL, lpDependencies=NULL, dwDependSize=0, lpServiceStartName=NULL, lpPassword=NULL, dwPwSize=0, lpDisplayName=NULL):\n    changeServiceConfig = RChangeServiceConfigW()\n    changeServiceConfig['hService'] = hService\n    changeServiceConfig['dwServiceType'] = dwServiceType\n    changeServiceConfig['dwStartType'] = dwStartType\n    changeServiceConfig['dwErrorControl'] = dwErrorControl\n    changeServiceConfig['lpBinaryPathName'] = checkNullString(lpBinaryPathName)\n    changeServiceConfig['lpLoadOrderGroup'] = checkNullString(lpLoadOrderGroup)\n    changeServiceConfig['lpdwTagId'] = lpdwTagId\n    changeServiceConfig['lpDependencies'] = lpDependencies\n    # Strings MUST be NULL terminated for lpDependencies\n    changeServiceConfig['dwDependSize'] = dwDependSize\n    changeServiceConfig['lpServiceStartName'] = checkNullString(lpServiceStartName)\n    changeServiceConfig['lpPassword'] = lpPassword\n    changeServiceConfig['dwPwSize'] = dwPwSize\n    changeServiceConfig['lpDisplayName'] = checkNullString(lpDisplayName)\n    return dce.request(changeServiceConfig)",
  "def hRCreateServiceW(dce, hSCManager, lpServiceName, lpDisplayName, dwDesiredAccess=SERVICE_ALL_ACCESS, dwServiceType=SERVICE_WIN32_OWN_PROCESS, dwStartType=SERVICE_AUTO_START, dwErrorControl=SERVICE_ERROR_IGNORE, lpBinaryPathName=NULL, lpLoadOrderGroup=NULL, lpdwTagId=NULL, lpDependencies=NULL, dwDependSize=0, lpServiceStartName=NULL, lpPassword=NULL, dwPwSize=0):\n    createService = RCreateServiceW()\n    createService['hSCManager'] = hSCManager\n    createService['lpServiceName'] = checkNullString(lpServiceName)\n    createService['lpDisplayName'] = checkNullString(lpDisplayName)\n    createService['dwDesiredAccess'] = dwDesiredAccess\n    createService['dwServiceType'] = dwServiceType\n    createService['dwStartType'] = dwStartType\n    createService['dwErrorControl'] = dwErrorControl\n    createService['lpBinaryPathName'] = checkNullString(lpBinaryPathName)\n    createService['lpLoadOrderGroup'] = checkNullString(lpLoadOrderGroup)\n    createService['lpdwTagId'] = lpdwTagId\n    # Strings MUST be NULL terminated for lpDependencies\n    createService['lpDependencies'] = lpDependencies\n    createService['dwDependSize'] = dwDependSize\n    createService['lpServiceStartName'] = checkNullString(lpServiceStartName)\n    createService['lpPassword'] = lpPassword\n    createService['dwPwSize'] = dwPwSize\n    return dce.request(createService)",
  "def hREnumDependentServicesW(dce, hService, dwServiceState, cbBufSize ):\n    enumDependentServices = REnumDependentServicesW()\n    enumDependentServices['hService'] = hService\n    enumDependentServices['dwServiceState'] = dwServiceState\n    enumDependentServices['cbBufSize'] = cbBufSize\n    return dce.request(enumDependentServices)",
  "def hREnumServicesStatusW(dce, hSCManager, dwServiceType=SERVICE_WIN32_OWN_PROCESS|SERVICE_KERNEL_DRIVER|SERVICE_FILE_SYSTEM_DRIVER|SERVICE_WIN32_SHARE_PROCESS|SERVICE_INTERACTIVE_PROCESS, dwServiceState=SERVICE_STATE_ALL):\n    class ENUM_SERVICE_STATUSW2(NDRSTRUCT):\n        # This is a little trick, since the original structure is slightly different\n        # but instead of parsing the LPBYTE buffer at hand, we just do it with the aid\n        # of the NDR library, although the pointers are swapped from the original specification.\n        # Why is this? Well.. since we're getting an LPBYTE back, it's just a copy of the remote's memory\n        # where the pointers are actually POINTING to the data.\n        # Sadly, the pointers are not aligned based on the services records, so we gotta do this\n        # It should be easier in C of course.\n        class STR(NDRPOINTER):\n            referent = (\n                ('Data', WIDESTR),\n            )\n        structure = (\n            ('lpServiceName',STR),\n            ('lpDisplayName',STR),\n            ('ServiceStatus',SERVICE_STATUS),\n        )\n\n    enumServicesStatus = REnumServicesStatusW()\n    enumServicesStatus['hSCManager'] = hSCManager\n    enumServicesStatus['dwServiceType'] = dwServiceType\n    enumServicesStatus['dwServiceState'] = dwServiceState\n    enumServicesStatus['cbBufSize'] = 0\n    enumServicesStatus['lpResumeIndex'] = NULL\n\n    try:\n        resp = dce.request(enumServicesStatus)\n    except DCERPCSessionError as e:\n        if e.get_error_code() == system_errors.ERROR_MORE_DATA:\n            resp = e.get_packet()\n            enumServicesStatus['cbBufSize'] = resp['pcbBytesNeeded']\n            resp = dce.request(enumServicesStatus)\n        else:\n            raise\n    \n    # Now we're supposed to have all services returned. Now we gotta parse them\n\n    enumArray = NDRUniConformantArray()\n    enumArray.item = ENUM_SERVICE_STATUSW2\n\n    enumArray.setArraySize(resp['lpServicesReturned'])\n\n    data = b''.join(resp['lpBuffer'])\n    enumArray.fromString(data)\n    data = data[4:]\n    # Since the pointers here are pointing to the actual data, we have to reparse\n    # the referents\n    for record in enumArray['Data']:\n        offset =  record.fields['lpDisplayName'].fields['ReferentID']-4\n        name = WIDESTR(data[offset:])\n        record['lpDisplayName'] = name['Data']\n        offset =  record.fields['lpServiceName'].fields['ReferentID']-4\n        name = WIDESTR(data[offset:])\n        record['lpServiceName'] = name['Data']\n\n    return enumArray['Data']",
  "def hROpenSCManagerW(dce, lpMachineName='DUMMY\\x00', lpDatabaseName='ServicesActive\\x00', dwDesiredAccess=SERVICE_START | SERVICE_STOP | SERVICE_CHANGE_CONFIG | SERVICE_QUERY_CONFIG | SERVICE_QUERY_STATUS | SERVICE_ENUMERATE_DEPENDENTS | SC_MANAGER_ENUMERATE_SERVICE):\n    openSCManager = ROpenSCManagerW()\n    openSCManager['lpMachineName'] = checkNullString(lpMachineName)\n    openSCManager['lpDatabaseName'] = checkNullString(lpDatabaseName)\n    openSCManager['dwDesiredAccess'] = dwDesiredAccess\n    return dce.request(openSCManager)",
  "def hROpenServiceW(dce, hSCManager, lpServiceName, dwDesiredAccess= SERVICE_ALL_ACCESS):\n    openService = ROpenServiceW()\n    openService['hSCManager'] = hSCManager\n    openService['lpServiceName'] = checkNullString(lpServiceName)\n    openService['dwDesiredAccess'] = dwDesiredAccess\n    return dce.request(openService)",
  "def hRQueryServiceConfigW(dce, hService):\n    queryService = RQueryServiceConfigW()\n    queryService['hService'] = hService\n    queryService['cbBufSize'] = 0\n    try:\n        resp = dce.request(queryService)\n    except DCERPCSessionError as e:\n        if e.get_error_code() == system_errors.ERROR_INSUFFICIENT_BUFFER:\n            resp = e.get_packet()\n            queryService['cbBufSize'] = resp['pcbBytesNeeded']\n            resp = dce.request(queryService)\n        else:\n            raise\n\n    return resp",
  "def hRQueryServiceLockStatusW(dce, hSCManager, cbBufSize ):\n    queryServiceLock = RQueryServiceLockStatusW()\n    queryServiceLock['hSCManager'] = hSCManager\n    queryServiceLock['cbBufSize'] = cbBufSize\n    return dce.request(queryServiceLock)",
  "def hRStartServiceW(dce, hService, argc=0, argv=NULL ):\n    startService = RStartServiceW()\n    startService['hService'] = hService\n    startService['argc'] = argc\n    if argc == 0:\n        startService['argv'] = NULL\n    else:\n        for item in argv:\n            itemn = LPWSTR()\n            itemn['Data'] = checkNullString(item)\n            startService['argv'].append(itemn)\n    return dce.request(startService)",
  "def hRGetServiceDisplayNameW(dce, hSCManager, lpServiceName, lpcchBuffer ):\n    getServiceDisplay = RGetServiceDisplayNameW()\n    getServiceDisplay['hSCManager'] = hSCManager\n    getServiceDisplay['lpServiceName'] = checkNullString(lpServiceName)\n    getServiceDisplay['lpcchBuffer'] = lpcchBuffer\n    return dce.request(getServiceDisplay)",
  "def hRGetServiceKeyNameW(dce, hSCManager, lpDisplayName, lpcchBuffer ):\n    getServiceKeyName = RGetServiceKeyNameW()\n    getServiceKeyName['hSCManager'] = hSCManager\n    getServiceKeyName['lpDisplayName'] = checkNullString(lpDisplayName)\n    getServiceKeyName['lpcchBuffer'] = lpcchBuffer\n    return dce.request(getServiceKeyName)",
  "def hREnumServiceGroupW(dce, hSCManager, dwServiceType, dwServiceState, cbBufSize, lpResumeIndex = NULL, pszGroupName = NULL ):\n    enumServiceGroup = REnumServiceGroupW()\n    enumServiceGroup['hSCManager'] = hSCManager\n    enumServiceGroup['dwServiceType'] = dwServiceType\n    enumServiceGroup['dwServiceState'] = dwServiceState\n    enumServiceGroup['cbBufSize'] = cbBufSize\n    enumServiceGroup['lpResumeIndex'] = lpResumeIndex\n    enumServiceGroup['pszGroupName'] = pszGroupName\n    return dce.request(enumServiceGroup)",
  "def __init__(self, error_string=None, error_code=None, packet=None):\n        DCERPCException.__init__(self, error_string, error_code, packet)",
  "def __str__( self ):\n        key = self.error_code\n        if key in system_errors.ERROR_MESSAGES:\n            error_msg_short = system_errors.ERROR_MESSAGES[key][0]\n            error_msg_verbose = system_errors.ERROR_MESSAGES[key][1] \n            return 'SCMR SessionError: code: 0x%x - %s - %s' % (self.error_code, error_msg_short, error_msg_verbose)\n        else:\n            return 'SCMR SessionError: unknown error code: 0x%x' % self.error_code",
  "def getAlignment(self):\n        return 1",
  "def getAlignment(self):\n        return 1",
  "def __init__(self, data = None, isNDR64 = False):\n        NDR.__init__(self,None,isNDR64)\n        self.fields['Data'].item = LPWSTR\n        if data is not None:\n            self.fromString(data)",
  "def __init__(self, data = None, isNDR64 = False):\n        NDR.__init__(self,None,isNDR64)\n        self.fields['Data'].item = SC_ACTION\n        if data is not None:\n            self.fromString(data)",
  "def getData(self, soFar = 0):\n        self['cbRequiredPrivileges'] = len(self['pRequiredPrivileges'])\n        return NDR.getData(self, soFar = 0)",
  "def getAlignment(self):\n        return 1",
  "def getData(self, soFar = 0):\n        if self['pData'] != 0:\n            self['cbData'] = len(self['pData'])\n        return NDR.getData(self, soFar)",
  "def getData(self, soFar = 0):\n        if self['pDataItems'] != 0:\n            self['cDataItems'] = len(self['pDataItems'])\n        return NDR.getData(self, soFar)",
  "def getData(self, soFar = 0):\n        if self['pTriggers'] != 0:\n            self['cTriggers'] = len(self['pTriggers'])\n        return NDR.getData(self, soFar)",
  "class ENUM_SERVICE_STATUSW2(NDRSTRUCT):\n        # This is a little trick, since the original structure is slightly different\n        # but instead of parsing the LPBYTE buffer at hand, we just do it with the aid\n        # of the NDR library, although the pointers are swapped from the original specification.\n        # Why is this? Well.. since we're getting an LPBYTE back, it's just a copy of the remote's memory\n        # where the pointers are actually POINTING to the data.\n        # Sadly, the pointers are not aligned based on the services records, so we gotta do this\n        # It should be easier in C of course.\n        class STR(NDRPOINTER):\n            referent = (\n                ('Data', WIDESTR),\n            )\n        structure = (\n            ('lpServiceName',STR),\n            ('lpDisplayName',STR),\n            ('ServiceStatus',SERVICE_STATUS),\n        )",
  "class STR(NDRPOINTER):\n            referent = (\n                ('Data', WIDESTR),\n            )",
  "class DCERPCSessionError(DCERPCException):\n    def __init__(self, error_string=None, error_code=None, packet=None):\n        DCERPCException.__init__(self, error_string, error_code, packet)\n\n    def __str__( self ):\n        if self.error_code in hresult_errors.ERROR_MESSAGES:\n            error_msg_short = hresult_errors.ERROR_MESSAGES[self.error_code][0]\n            error_msg_verbose = hresult_errors.ERROR_MESSAGES[self.error_code][1] \n            return 'SCMP SessionError: code: 0x%x - %s - %s' % (self.error_code, error_msg_short, error_msg_verbose)\n        else:\n            return 'SCMP SessionError: unknown error code: 0x%x' % self.error_code",
  "class VSS_ID(NDRSTRUCT):\n    structure = (\n        ('Data','16s=b\"\"'),\n    )\n\n    def getAlignment(self):\n        return 2",
  "class VSS_OBJECT_TYPE(NDRENUM):\n    class enumItems(Enum):\n        VSS_OBJECT_UNKNOWN      = 0\n        VSS_OBJECT_NONE         = 1\n        VSS_OBJECT_SNAPSHOT_SET = 2\n        VSS_OBJECT_SNAPSHOT     = 3\n        VSS_OBJECT_PROVIDER     = 4\n        VSS_OBJECT_TYPE_COUNT   = 5",
  "class VSS_MGMT_OBJECT_TYPE(NDRENUM):\n    class enumItems(Enum):\n        VSS_MGMT_OBJECT_UNKNOWN     = 0\n        VSS_MGMT_OBJECT_VOLUME      = 1\n        VSS_MGMT_OBJECT_DIFF_VOLUME = 2\n        VSS_MGMT_OBJECT_DIFF_AREA   = 3",
  "class VSS_VOLUME_SNAPSHOT_ATTRIBUTES(NDRENUM):\n    class enumItems(Enum):\n        VSS_VOLSNAP_ATTR_PERSISTENT        = 0x01\n        VSS_VOLSNAP_ATTR_NO_AUTORECOVERY   = 0x02\n        VSS_VOLSNAP_ATTR_CLIENT_ACCESSIBLE = 0x04\n        VSS_VOLSNAP_ATTR_NO_AUTO_RELEASE   = 0x08\n        VSS_VOLSNAP_ATTR_NO_WRITERS        = 0x10",
  "class VSS_SNAPSHOT_STATE(NDRENUM):\n    class enumItems(Enum):\n        VSS_SS_UNKNOWN  = 0x01\n        VSS_SS_CREATED  = 0x0c",
  "class  VSS_PROVIDER_TYPE(NDRENUM):\n    class enumItems(Enum):\n        VSS_PROV_UNKNOWN  = 0",
  "class VSS_VOLUME_PROP(NDRSTRUCT):\n    structure = (\n        ('m_pwszVolumeName', VSS_PWSZ),\n        ('m_pwszVolumeDisplayName', VSS_PWSZ),\n    )",
  "class VSS_MGMT_OBJECT_UNION(NDRUNION):\n    commonHdr = (\n        ('tag', ULONG),\n    )\n    union = {\n        VSS_MGMT_OBJECT_TYPE.VSS_MGMT_OBJECT_VOLUME: ('Vol', VSS_VOLUME_PROP),\n        #VSS_MGMT_OBJECT_DIFF_VOLUME: ('DiffVol', VSS_DIFF_VOLUME_PROP),\n        #VSS_MGMT_OBJECT_DIFF_AREA: ('DiffArea', VSS_DIFF_AREA_PROP),\n    }",
  "class VSS_MGMT_OBJECT_PROP(NDRSTRUCT):\n    structure = (\n        ('Type', VSS_MGMT_OBJECT_TYPE),\n        ('Obj', VSS_MGMT_OBJECT_UNION),\n    )",
  "class IVssEnumMgmtObject_Next(DCOMCALL):\n    opnum = 3\n    structure = (\n       ('celt', ULONG),\n    )",
  "class IVssEnumMgmtObject_NextResponse(DCOMANSWER):\n    structure = (\n       ('rgelt', VSS_MGMT_OBJECT_PROP),\n       ('pceltFetched', ULONG),\n       ('ErrorCode', error_status_t),\n    )",
  "class IVssEnumObject_Next(DCOMCALL):\n    opnum = 3\n    structure = (\n       ('celt', ULONG),\n    )",
  "class IVssEnumObject_NextResponse(DCOMANSWER):\n    structure = (\n       ('rgelt', VSS_MGMT_OBJECT_PROP),\n       ('pceltFetched', ULONG),\n       ('ErrorCode', error_status_t),\n    )",
  "class GetProviderMgmtInterface(DCOMCALL):\n    opnum = 3\n    structure = (\n       ('ProviderId', VSS_ID),\n       ('InterfaceId', VSS_ID),\n    )",
  "class GetProviderMgmtInterfaceResponse(DCOMANSWER):\n    structure = (\n       ('ppItf', PMInterfacePointer),\n       ('ErrorCode', error_status_t),\n    )",
  "class QueryVolumesSupportedForSnapshots(DCOMCALL):\n    opnum = 4\n    structure = (\n       ('ProviderId', VSS_ID),\n       ('IContext', LONG),\n    )",
  "class QueryVolumesSupportedForSnapshotsResponse(DCOMANSWER):\n    structure = (\n       ('ppEnum', PMInterfacePointer),\n       ('ErrorCode', error_status_t),\n    )",
  "class QuerySnapshotsByVolume(DCOMCALL):\n    opnum = 5\n    structure = (\n       ('pwszVolumeName', VSS_PWSZ),\n       ('ProviderId', VSS_ID),\n    )",
  "class QuerySnapshotsByVolumeResponse(DCOMANSWER):\n    structure = (\n       ('ppEnum', PMInterfacePointer),\n       ('ErrorCode', error_status_t),\n    )",
  "class QueryDiffAreasForVolume(DCOMCALL):\n    opnum = 6\n    structure = (\n       ('pwszVolumeName', VSS_PWSZ),\n    )",
  "class QueryDiffAreasForVolumeResponse(DCOMANSWER):\n    structure = (\n       ('ppEnum', PMInterfacePointer),\n       ('ErrorCode', error_status_t),\n    )",
  "class QueryDiffAreasOnVolume(DCOMCALL):\n    opnum = 7\n    structure = (\n       ('pwszVolumeName', VSS_PWSZ),\n    )",
  "class QueryDiffAreasOnVolumeResponse(DCOMANSWER):\n    structure = (\n       ('ppEnum', PMInterfacePointer),\n       ('ErrorCode', error_status_t),\n    )",
  "class IVssEnumMgmtObject(IRemUnknown2):\n    def __init__(self, interface):\n        IRemUnknown2.__init__(self, interface)\n        self._iid = IID_IVssEnumMgmtObject\n\n    def Next(self, celt):\n        request = IVssEnumMgmtObject_Next()\n        request['ORPCthis'] = self.get_cinstance().get_ORPCthis()\n        request['ORPCthis']['flags'] = 0\n        request['celt'] = celt\n        resp = self.request(request, self._iid, uuid = self.get_iPid())\n        return resp",
  "class IVssEnumObject(IRemUnknown2):\n    def __init__(self, interface):\n        IRemUnknown2.__init__(self, interface)\n        self._iid = IID_IVssEnumObject\n\n    def Next(self, celt):\n        request = IVssEnumObject_Next()\n        request['ORPCthis'] = self.get_cinstance().get_ORPCthis()\n        request['ORPCthis']['flags'] = 0\n        request['celt'] = celt\n        dce = self.connect()\n        resp = dce.request(request, self._iid, uuid = self.get_iPid())\n        return resp",
  "class IVssSnapshotMgmt(IRemUnknown2):\n    def __init__(self, interface):\n        IRemUnknown2.__init__(self, interface)\n        self._iid = IID_IVssSnapshotMgmt\n\n    def GetProviderMgmtInterface(self, providerId = IID_ShadowCopyProvider, interfaceId = IID_IVssDifferentialSoftwareSnapshotMgmt):\n        req = GetProviderMgmtInterface()\n        classInstance = self.get_cinstance()\n        req['ORPCthis'] = classInstance.get_ORPCthis()\n        req['ORPCthis']['flags'] = 0\n        req['ProviderId'] = providerId\n        req['InterfaceId'] = interfaceId\n        resp = self.request(req, self._iid, uuid = self.get_iPid())\n        return IVssDifferentialSoftwareSnapshotMgmt(INTERFACE(classInstance, ''.join(resp['ppItf']['abData']), self.get_ipidRemUnknown(), target = self.get_target()))\n\n    def QueryVolumesSupportedForSnapshots(self, providerId, iContext):\n        req = QueryVolumesSupportedForSnapshots()\n        classInstance = self.get_cinstance()\n        req['ORPCthis'] = classInstance.get_ORPCthis()\n        req['ORPCthis']['flags'] = 0\n        req['ProviderId'] = providerId\n        req['IContext'] = iContext\n        resp = self.request(req, self._iid, uuid = self.get_iPid())\n        return IVssEnumMgmtObject(INTERFACE(self.get_cinstance(), ''.join(resp['ppEnum']['abData']), self.get_ipidRemUnknown(),target = self.get_target()))\n\n    def QuerySnapshotsByVolume(self, volumeName, providerId = IID_ShadowCopyProvider):\n        req = QuerySnapshotsByVolume()\n        classInstance = self.get_cinstance()\n        req['ORPCthis'] = classInstance.get_ORPCthis()\n        req['ORPCthis']['flags'] = 0\n        req['pwszVolumeName'] = volumeName\n        req['ProviderId'] = providerId\n        try:\n            resp = self.request(req, self._iid, uuid = self.get_iPid())\n        except DCERPCException as e:\n            print(e)\n            from impacket.winregistry import hexdump\n            data = e.get_packet()\n            hexdump(data)\n            kk = QuerySnapshotsByVolumeResponse(data)\n            kk.dump()\n        #resp.dump()\n        return IVssEnumObject(INTERFACE(self.get_cinstance(), ''.join(resp['ppEnum']['abData']), self.get_ipidRemUnknown(), target = self.get_target()))",
  "class IVssDifferentialSoftwareSnapshotMgmt(IRemUnknown2):\n    def __init__(self, interface):\n        IRemUnknown2.__init__(self, interface)\n        self._iid = IID_IVssDifferentialSoftwareSnapshotMgmt\n\n    def QueryDiffAreasOnVolume(self, pwszVolumeName):\n        req = QueryDiffAreasOnVolume()\n        classInstance = self.get_cinstance()\n        req['ORPCthis'] = classInstance.get_ORPCthis()\n        req['ORPCthis']['flags'] = 0\n        req['pwszVolumeName'] = pwszVolumeName\n        resp = self.request(req, self._iid, uuid = self.get_iPid())\n        return IVssEnumMgmtObject(INTERFACE(self.get_cinstance(), ''.join(resp['ppEnum']['abData']), self.get_ipidRemUnknown(), target = self.get_target()))\n\n    def QueryDiffAreasForVolume(self, pwszVolumeName):\n        req = QueryDiffAreasForVolume()\n        classInstance = self.get_cinstance()\n        req['ORPCthis'] = classInstance.get_ORPCthis()\n        req['ORPCthis']['flags'] = 0\n        req['pwszVolumeName'] = pwszVolumeName\n        resp = self.request(req, self._iid, uuid = self.get_iPid())\n        return IVssEnumMgmtObject(INTERFACE(self.get_cinstance(), ''.join(resp['ppEnum']['abData']), self.get_ipidRemUnknown(), target = self.get_target()))",
  "def __init__(self, error_string=None, error_code=None, packet=None):\n        DCERPCException.__init__(self, error_string, error_code, packet)",
  "def __str__( self ):\n        if self.error_code in hresult_errors.ERROR_MESSAGES:\n            error_msg_short = hresult_errors.ERROR_MESSAGES[self.error_code][0]\n            error_msg_verbose = hresult_errors.ERROR_MESSAGES[self.error_code][1] \n            return 'SCMP SessionError: code: 0x%x - %s - %s' % (self.error_code, error_msg_short, error_msg_verbose)\n        else:\n            return 'SCMP SessionError: unknown error code: 0x%x' % self.error_code",
  "def getAlignment(self):\n        return 2",
  "class enumItems(Enum):\n        VSS_OBJECT_UNKNOWN      = 0\n        VSS_OBJECT_NONE         = 1\n        VSS_OBJECT_SNAPSHOT_SET = 2\n        VSS_OBJECT_SNAPSHOT     = 3\n        VSS_OBJECT_PROVIDER     = 4\n        VSS_OBJECT_TYPE_COUNT   = 5",
  "class enumItems(Enum):\n        VSS_MGMT_OBJECT_UNKNOWN     = 0\n        VSS_MGMT_OBJECT_VOLUME      = 1\n        VSS_MGMT_OBJECT_DIFF_VOLUME = 2\n        VSS_MGMT_OBJECT_DIFF_AREA   = 3",
  "class enumItems(Enum):\n        VSS_VOLSNAP_ATTR_PERSISTENT        = 0x01\n        VSS_VOLSNAP_ATTR_NO_AUTORECOVERY   = 0x02\n        VSS_VOLSNAP_ATTR_CLIENT_ACCESSIBLE = 0x04\n        VSS_VOLSNAP_ATTR_NO_AUTO_RELEASE   = 0x08\n        VSS_VOLSNAP_ATTR_NO_WRITERS        = 0x10",
  "class enumItems(Enum):\n        VSS_SS_UNKNOWN  = 0x01\n        VSS_SS_CREATED  = 0x0c",
  "class enumItems(Enum):\n        VSS_PROV_UNKNOWN  = 0",
  "def __init__(self, interface):\n        IRemUnknown2.__init__(self, interface)\n        self._iid = IID_IVssEnumMgmtObject",
  "def Next(self, celt):\n        request = IVssEnumMgmtObject_Next()\n        request['ORPCthis'] = self.get_cinstance().get_ORPCthis()\n        request['ORPCthis']['flags'] = 0\n        request['celt'] = celt\n        resp = self.request(request, self._iid, uuid = self.get_iPid())\n        return resp",
  "def __init__(self, interface):\n        IRemUnknown2.__init__(self, interface)\n        self._iid = IID_IVssEnumObject",
  "def Next(self, celt):\n        request = IVssEnumObject_Next()\n        request['ORPCthis'] = self.get_cinstance().get_ORPCthis()\n        request['ORPCthis']['flags'] = 0\n        request['celt'] = celt\n        dce = self.connect()\n        resp = dce.request(request, self._iid, uuid = self.get_iPid())\n        return resp",
  "def __init__(self, interface):\n        IRemUnknown2.__init__(self, interface)\n        self._iid = IID_IVssSnapshotMgmt",
  "def GetProviderMgmtInterface(self, providerId = IID_ShadowCopyProvider, interfaceId = IID_IVssDifferentialSoftwareSnapshotMgmt):\n        req = GetProviderMgmtInterface()\n        classInstance = self.get_cinstance()\n        req['ORPCthis'] = classInstance.get_ORPCthis()\n        req['ORPCthis']['flags'] = 0\n        req['ProviderId'] = providerId\n        req['InterfaceId'] = interfaceId\n        resp = self.request(req, self._iid, uuid = self.get_iPid())\n        return IVssDifferentialSoftwareSnapshotMgmt(INTERFACE(classInstance, ''.join(resp['ppItf']['abData']), self.get_ipidRemUnknown(), target = self.get_target()))",
  "def QueryVolumesSupportedForSnapshots(self, providerId, iContext):\n        req = QueryVolumesSupportedForSnapshots()\n        classInstance = self.get_cinstance()\n        req['ORPCthis'] = classInstance.get_ORPCthis()\n        req['ORPCthis']['flags'] = 0\n        req['ProviderId'] = providerId\n        req['IContext'] = iContext\n        resp = self.request(req, self._iid, uuid = self.get_iPid())\n        return IVssEnumMgmtObject(INTERFACE(self.get_cinstance(), ''.join(resp['ppEnum']['abData']), self.get_ipidRemUnknown(),target = self.get_target()))",
  "def QuerySnapshotsByVolume(self, volumeName, providerId = IID_ShadowCopyProvider):\n        req = QuerySnapshotsByVolume()\n        classInstance = self.get_cinstance()\n        req['ORPCthis'] = classInstance.get_ORPCthis()\n        req['ORPCthis']['flags'] = 0\n        req['pwszVolumeName'] = volumeName\n        req['ProviderId'] = providerId\n        try:\n            resp = self.request(req, self._iid, uuid = self.get_iPid())\n        except DCERPCException as e:\n            print(e)\n            from impacket.winregistry import hexdump\n            data = e.get_packet()\n            hexdump(data)\n            kk = QuerySnapshotsByVolumeResponse(data)\n            kk.dump()\n        #resp.dump()\n        return IVssEnumObject(INTERFACE(self.get_cinstance(), ''.join(resp['ppEnum']['abData']), self.get_ipidRemUnknown(), target = self.get_target()))",
  "def __init__(self, interface):\n        IRemUnknown2.__init__(self, interface)\n        self._iid = IID_IVssDifferentialSoftwareSnapshotMgmt",
  "def QueryDiffAreasOnVolume(self, pwszVolumeName):\n        req = QueryDiffAreasOnVolume()\n        classInstance = self.get_cinstance()\n        req['ORPCthis'] = classInstance.get_ORPCthis()\n        req['ORPCthis']['flags'] = 0\n        req['pwszVolumeName'] = pwszVolumeName\n        resp = self.request(req, self._iid, uuid = self.get_iPid())\n        return IVssEnumMgmtObject(INTERFACE(self.get_cinstance(), ''.join(resp['ppEnum']['abData']), self.get_ipidRemUnknown(), target = self.get_target()))",
  "def QueryDiffAreasForVolume(self, pwszVolumeName):\n        req = QueryDiffAreasForVolume()\n        classInstance = self.get_cinstance()\n        req['ORPCthis'] = classInstance.get_ORPCthis()\n        req['ORPCthis']['flags'] = 0\n        req['pwszVolumeName'] = pwszVolumeName\n        resp = self.request(req, self._iid, uuid = self.get_iPid())\n        return IVssEnumMgmtObject(INTERFACE(self.get_cinstance(), ''.join(resp['ppEnum']['abData']), self.get_ipidRemUnknown(), target = self.get_target()))",
  "class DCERPCSessionError(DCERPCException):\n    def __init__(self, error_string=None, error_code=None, packet=None):\n        DCERPCException.__init__(self, error_string, error_code, packet)\n\n    def __str__( self ):\n        if self.error_code in hresult_errors.ERROR_MESSAGES:\n            error_msg_short = hresult_errors.ERROR_MESSAGES[self.error_code][0]\n            error_msg_verbose = hresult_errors.ERROR_MESSAGES[self.error_code][1] \n            return 'OAUT SessionError: code: 0x%x - %s - %s' % (self.error_code, error_msg_short, error_msg_verbose)\n        else:\n            return 'OAUT SessionError: unknown error code: 0x%x' % (self.error_code)",
  "class PDATE(NDRPOINTER):\n    referent = (\n        ('Data', DATE),\n    )",
  "class PVARIANT_BOOL(NDRPOINTER):\n    referent = (\n        ('Data', VARIANT_BOOL),\n    )",
  "class DECIMAL(NDRSTRUCT):\n    structure = (\n        ('wReserved',WORD),\n        ('scale',BYTE),\n        ('sign',BYTE),\n        ('Hi32',ULONG),\n        ('Lo64',ULONGLONG),\n    )",
  "class PDECIMAL(NDRPOINTER):\n    referent = (\n        ('Data', DECIMAL),\n    )",
  "class VARENUM(NDRENUM):\n    class enumItems(Enum):\n        VT_EMPTY       = 0\n        VT_NULL        = 1\n        VT_I2          = 2\n        VT_I4          = 3\n        VT_R4          = 4\n        VT_R8          = 5\n        VT_CY          = 6\n        VT_DATE        = 7\n        VT_BSTR        = 8\n        VT_DISPATCH    = 9\n        VT_ERROR       = 0xa\n        VT_BOOL        = 0xb\n        VT_VARIANT     = 0xc\n        VT_UNKNOWN     = 0xd\n        VT_DECIMAL     = 0xe\n        VT_I1          = 0x10\n        VT_UI1         = 0x11\n        VT_UI2         = 0x12\n        VT_UI4         = 0x13\n        VT_I8          = 0x14\n        VT_UI8         = 0x15\n        VT_INT         = 0x16\n        VT_UINT        = 0x17\n        VT_VOID        = 0x18\n        VT_HRESULT     = 0x19\n        VT_PTR         = 0x1a\n        VT_SAFEARRAY   = 0x1b\n        VT_CARRAY      = 0x1c\n        VT_USERDEFINED = 0x1d\n        VT_LPSTR       = 0x1e\n        VT_LPWSTR      = 0x1f\n        VT_RECORD      = 0x24\n        VT_INT_PTR     = 0x25\n        VT_UINT_PTR    = 0x26\n        VT_ARRAY       = 0x2000\n        VT_BYREF       = 0x4000\n        VT_RECORD_OR_VT_BYREF   = VT_RECORD | VT_BYREF\n        VT_UI1_OR_VT_BYREF      = VT_UI1 | VT_BYREF\n        VT_I2_OR_VT_BYREF       = VT_I2 | VT_BYREF\n        VT_I4_OR_VT_BYREF       = VT_I4 | VT_BYREF\n        VT_I8_OR_VT_BYREF       = VT_I8 | VT_BYREF\n        VT_R4_OR_VT_BYREF       = VT_R4 | VT_BYREF\n        VT_R8_OR_VT_BYREF       = VT_R8 | VT_BYREF\n        VT_BOOL_OR_VT_BYREF     = VT_BOOL | VT_BYREF\n        VT_ERROR_OR_VT_BYREF    = VT_ERROR | VT_BYREF\n        VT_CY_OR_VT_BYREF       = VT_CY | VT_BYREF\n        VT_DATE_OR_VT_BYREF     = VT_DATE | VT_BYREF\n        VT_BSTR_OR_VT_BYREF     = VT_BSTR | VT_BYREF\n        VT_UNKNOWN_OR_VT_BYREF  = VT_UNKNOWN | VT_BYREF\n        VT_DISPATCH_OR_VT_BYREF = VT_DISPATCH | VT_BYREF\n        VT_ARRAY_OR_VT_BYREF    = VT_ARRAY | VT_BYREF\n        VT_VARIANT_OR_VT_BYREF  = VT_VARIANT| VT_BYREF\n        VT_I1_OR_VT_BYREF       = VT_I1 | VT_BYREF\n        VT_UI2_OR_VT_BYREF      = VT_UI2 | VT_BYREF\n        VT_UI4_OR_VT_BYREF      = VT_UI4 | VT_BYREF\n        VT_UI8_OR_VT_BYREF      = VT_UI8 | VT_BYREF\n        VT_INT_OR_VT_BYREF      = VT_INT | VT_BYREF\n        VT_UINT_OR_VT_BYREF     = VT_UINT | VT_BYREF\n        VT_DECIMAL_OR_VT_BYREF  = VT_DECIMAL | VT_BYREF",
  "class SF_TYPE(NDRENUM):\n    # [v1_enum] type\n    structure = (\n        ('Data', '<L'),\n    )\n    class enumItems(Enum):\n        SF_ERROR     = VARENUM.VT_ERROR\n        SF_I1        = VARENUM.VT_I1\n        SF_I2        = VARENUM.VT_I2\n        SF_I4        = VARENUM.VT_I4\n        SF_I8        = VARENUM.VT_I8\n        SF_BSTR      = VARENUM.VT_BSTR\n        SF_UNKNOWN   = VARENUM.VT_UNKNOWN\n        SF_DISPATCH  = VARENUM.VT_DISPATCH\n        SF_VARIANT   = VARENUM.VT_VARIANT\n        SF_RECORD    = VARENUM.VT_RECORD\n        SF_HAVEIID   = VARENUM.VT_UNKNOWN | 0x8000",
  "class CALLCONV(NDRENUM):\n    # [v1_enum] type\n    structure = (\n        ('Data', '<L'),\n    )\n    class enumItems(Enum):\n        CC_CDECL   = 1\n        CC_PASCAL  = 2\n        CC_STDCALL = 4",
  "class FUNCKIND(NDRENUM):\n    # [v1_enum] type\n    structure = (\n        ('Data', '<L'),\n    )\n    class enumItems(Enum):\n        FUNC_PUREVIRTUAL = 1\n        FUNC_STATIC      = 3\n        FUNC_DISPATCH    = 4",
  "class INVOKEKIND(NDRENUM):\n    # [v1_enum] type\n    structure = (\n        ('Data', '<L'),\n    )\n    class enumItems(Enum):\n        INVOKE_FUNC           = 1\n        INVOKE_PROPERTYGET    = 2\n        INVOKE_PROPERTYPUT    = 4\n        INVOKE_PROPERTYPUTREF = 8",
  "class TYPEKIND(NDRENUM):\n    # [v1_enum] type\n    structure = (\n        ('Data', '<L'),\n    )\n    class enumItems(Enum):\n        TKIND_ENUM      = 0\n        TKIND_RECORD    = 1\n        TKIND_MODULE    = 2\n        TKIND_INTERFACE = 3\n        TKIND_DISPATCH  = 4\n        TKIND_COCLASS   = 5\n        TKIND_ALIAS     = 6\n        TKIND_UNION     = 7",
  "class USHORT_ARRAY(NDRUniConformantArray):\n    item = '<H'",
  "class FLAGGED_WORD_BLOB(NDRSTRUCT):\n    structure = (\n        ('cBytes',ULONG),\n        ('clSize',ULONG),\n        ('asData',USHORT_ARRAY),\n    )\n    def __setitem__(self, key, value):\n        if key == 'asData':\n            value = value #+ '\\x00'\n            array = list()\n            for letter in value:\n                encoded = letter.encode('utf-16le')\n                array.append(unpack('<H', encoded)[0])\n            self.fields[key]['Data'] = array\n            self['cBytes'] = len(value)*2\n            self['clSize'] = len(value)\n            self.data = None        # force recompute\n        else:\n            return NDRSTRUCT.__setitem__(self, key, value)\n\n    def __getitem__(self, key):\n        if key == 'asData':\n            value = ''\n            for letter in self.fields['asData']['Data']:\n                value += pack('<H', letter).decode('utf-16le')\n            return value\n        else:\n            return NDRSTRUCT.__getitem__(self,key)\n\n    def dump(self, msg = None, indent = 0):\n        if msg is None: msg = self.__class__.__name__\n        ind = ' '*indent\n        if msg != '':\n            print(\"%s\" % (msg))\n        value = ''\n        print('%sasData: %s' % (ind,self['asData']), end=' ')",
  "class BSTR(NDRPOINTER):\n    referent = (\n        ('Data', FLAGGED_WORD_BLOB),\n    )",
  "class PBSTR(NDRPOINTER):\n    referent = (\n        ('Data', BSTR),\n    )",
  "class CURRENCY(NDRSTRUCT):\n    structure = (\n        ('int64', LONGLONG),\n    )",
  "class PCURRENCY(NDRPOINTER):\n    referent = (\n        ('Data', CURRENCY),\n    )",
  "class _wireBRECORD(NDRSTRUCT):\n    structure = (\n        ('fFlags', LONGLONG),\n        ('clSize', LONGLONG),\n        ('pRecInfo', MInterfacePointer),\n        ('pRecord', BYTE_ARRAY),\n    )",
  "class BRECORD(NDRPOINTER):\n    referent = (\n        ('Data', _wireBRECORD),\n    )",
  "class SAFEARRAYBOUND(NDRSTRUCT):\n    structure = (\n        ('cElements', ULONG),\n        ('lLbound', LONG),\n    )",
  "class PSAFEARRAYBOUND(NDRPOINTER):\n    referent = (\n        ('Data', SAFEARRAYBOUND),\n    )",
  "class BSTR_ARRAY(NDRUniConformantArray):\n    item = BSTR",
  "class PBSTR_ARRAY(NDRPOINTER):\n    referent = (\n        ('Data', BSTR_ARRAY),\n    )",
  "class SAFEARR_BSTR(NDRSTRUCT):\n    structure = (\n        ('Size', ULONG),\n        ('aBstr', PBSTR_ARRAY),\n    )",
  "class SAFEARR_UNKNOWN(NDRSTRUCT):\n    structure = (\n        ('Size', ULONG),\n        ('apUnknown', MInterfacePointer_ARRAY),\n    )",
  "class SAFEARR_DISPATCH(NDRSTRUCT):\n    structure = (\n        ('Size', ULONG),\n        ('apDispatch', MInterfacePointer_ARRAY),\n    )",
  "class BRECORD_ARRAY(NDRUniConformantArray):\n    item = BRECORD",
  "class SAFEARR_BRECORD(NDRSTRUCT):\n    structure = (\n        ('Size', ULONG),\n        ('aRecord', BRECORD_ARRAY),\n    )",
  "class SAFEARR_HAVEIID(NDRSTRUCT):\n    structure = (\n        ('Size', ULONG),\n        ('apUnknown', MInterfacePointer_ARRAY),\n        ('iid', IID),\n    )",
  "class BYTE_SIZEDARR(NDRSTRUCT):\n    structure = (\n        ('clSize', ULONG),\n        ('pData', BYTE_ARRAY),\n    )",
  "class WORD_ARRAY(NDRUniConformantArray):\n    item = '<H'",
  "class WORD_SIZEDARR(NDRSTRUCT):\n    structure = (\n        ('clSize', ULONG),\n        ('pData', WORD_ARRAY),\n    )",
  "class DWORD_ARRAY(NDRUniConformantArray):\n    item = '<L'",
  "class DWORD_SIZEDARR(NDRSTRUCT):\n    structure = (\n        ('clSize', ULONG),\n        ('pData', DWORD_ARRAY),\n    )",
  "class HYPER_ARRAY(NDRUniConformantArray):\n    item = '<Q'",
  "class HYPER_SIZEDARR(NDRSTRUCT):\n    structure = (\n        ('clSize', ULONG),\n        ('pData', HYPER_ARRAY),\n    )",
  "class VARIANT_ARRAY(NDRUniConformantArray):\n    # In order to avoid the lack of forward declarations in Python\n    # I declare the item in the constructor\n    #item = VARIANT\n    def __init__(self, data = None, isNDR64 = False):\n        NDRUniConformantArray.__init__(self, data, isNDR64)\n        self.item = VARIANT",
  "class PVARIANT_ARRAY(NDRPOINTER):\n    referent = (\n        ('Data', VARIANT_ARRAY),\n    )",
  "class PVARIANT(NDRPOINTER):\n    # In order to avoid the lack of forward declarations in Python\n    # I declare the item in the constructor\n    #referent = (\n    #    ('Data', VARIANT),\n    #)\n    def __init__(self, data = None, isNDR64 = False):\n        NDRPOINTER.__init__(self, data, isNDR64)\n        self.referent = ( ('Data', VARIANT),)",
  "class SAFEARR_VARIANT(NDRSTRUCT):\n    structure = (\n        ('Size', ULONG),\n        ('aVariant', VARIANT_ARRAY),\n    )",
  "class SAFEARRAYUNION(NDRUNION):\n    commonHdr = (\n        ('tag', ULONG),\n    )\n    union = {\n        SF_TYPE.SF_BSTR     : ('BstrStr', SAFEARR_BSTR),\n        SF_TYPE.SF_UNKNOWN  : ('UnknownStr', SAFEARR_UNKNOWN),\n        SF_TYPE.SF_DISPATCH : ('DispatchStr', SAFEARR_DISPATCH),\n        SF_TYPE.SF_VARIANT  : ('VariantStr', SAFEARR_VARIANT),\n        SF_TYPE.SF_RECORD   : ('RecordStr', SAFEARR_BRECORD),\n        SF_TYPE.SF_HAVEIID  : ('HaveIidStr', SAFEARR_HAVEIID),\n        SF_TYPE.SF_I1       : ('ByteStr', BYTE_SIZEDARR),\n        SF_TYPE.SF_I2       : ('WordStr', WORD_SIZEDARR),\n        SF_TYPE.SF_I4       : ('LongStr', DWORD_SIZEDARR),\n        SF_TYPE.SF_I8       : ('HyperStr', HYPER_SIZEDARR),\n    }",
  "class SAFEARRAYBOUND_ARRAY(NDRUniConformantArray):\n    item = SAFEARRAYBOUND",
  "class PSAFEARRAYBOUND_ARRAY(NDRPOINTER):\n    referent = (\n        ('Data', SAFEARRAYBOUND_ARRAY),\n    )",
  "class SAFEARRAY(NDRSTRUCT):\n    structure = (\n        ('cDims', USHORT),\n        ('fFeatures', USHORT),\n        ('cbElements', ULONG),\n        ('cLocks', ULONG),\n        ('uArrayStructs', SAFEARRAYUNION),\n        ('rgsabound', SAFEARRAYBOUND_ARRAY),\n    )",
  "class PSAFEARRAY(NDRPOINTER):\n    referent = (\n        ('Data', SAFEARRAY),\n    )",
  "class EMPTY(NDR):\n    align = 0\n    structure = (\n    )",
  "class varUnion(NDRUNION):\n    commonHdr = (\n        ('tag', ULONG),\n    )\n    union = {\n        VARENUM.VT_I8                  : ('llVal', LONGLONG),\n        VARENUM.VT_I4                  : ('lVal', LONG),\n        VARENUM.VT_UI1                 : ('bVal', BYTE),\n        VARENUM.VT_I2                  : ('iVal', SHORT),\n        VARENUM.VT_R4                  : ('fltVal', FLOAT),\n        VARENUM.VT_R8                  : ('dblVal', DOUBLE),\n        VARENUM.VT_BOOL                : ('boolVal', VARIANT_BOOL),\n        VARENUM.VT_ERROR               : ('scode', HRESULT),\n        VARENUM.VT_CY                  : ('cyVal', CURRENCY),\n        VARENUM.VT_DATE                : ('date', DATE),\n        VARENUM.VT_BSTR                : ('bstrVal', BSTR),\n        VARENUM.VT_UNKNOWN             : ('punkVal', PMInterfacePointer),\n        VARENUM.VT_DISPATCH            : ('pdispVal', PMInterfacePointer),\n        VARENUM.VT_ARRAY               : ('parray', SAFEARRAY),\n        VARENUM.VT_RECORD              : ('brecVal', BRECORD),\n        VARENUM.VT_RECORD_OR_VT_BYREF  : ('brecVal', BRECORD),\n        VARENUM.VT_UI1_OR_VT_BYREF     : ('pbVal', BYTE),\n        VARENUM.VT_I2_OR_VT_BYREF      : ('piVal', PSHORT),\n        VARENUM.VT_I4_OR_VT_BYREF      : ('plVal', PLONG),\n        VARENUM.VT_I8_OR_VT_BYREF      : ('pllVal', PLONGLONG),\n        VARENUM.VT_R4_OR_VT_BYREF      : ('pfltVal', PFLOAT),\n        VARENUM.VT_R8_OR_VT_BYREF      : ('pdblVal', PDOUBLE),\n        VARENUM.VT_BOOL_OR_VT_BYREF    : ('pboolVal', PVARIANT_BOOL),\n        VARENUM.VT_ERROR_OR_VT_BYREF   : ('pscode', PHRESULT),\n        VARENUM.VT_CY_OR_VT_BYREF      : ('pcyVal', PCURRENCY),\n        VARENUM.VT_DATE_OR_VT_BYREF    : ('pdate', PDATE),\n        VARENUM.VT_BSTR_OR_VT_BYREF    : ('pbstrVal', PBSTR),\n        VARENUM.VT_UNKNOWN_OR_VT_BYREF : ('ppunkVal', PPMInterfacePointer),\n        VARENUM.VT_DISPATCH_OR_VT_BYREF: ('ppdispVal', PPMInterfacePointer),\n        VARENUM.VT_ARRAY_OR_VT_BYREF   : ('pparray', PSAFEARRAY),\n        VARENUM.VT_VARIANT_OR_VT_BYREF : ('pvarVal', PVARIANT),\n        VARENUM.VT_I1                  : ('cVal', CHAR),\n        VARENUM.VT_UI2                 : ('uiVal', USHORT),\n        VARENUM.VT_UI4                 : ('ulVal', ULONG),\n        VARENUM.VT_UI8                 : ('ullVal', ULONGLONG),\n        VARENUM.VT_INT                 : ('intVal', INT),\n        VARENUM.VT_UINT                : ('uintVal', UINT),\n        VARENUM.VT_DECIMAL             : ('decVal', DECIMAL),\n        VARENUM.VT_I1_OR_VT_BYREF      : ('pcVal', PCHAR),\n        VARENUM.VT_UI2_OR_VT_BYREF     : ('puiVal', PUSHORT),\n        VARENUM.VT_UI4_OR_VT_BYREF     : ('pulVal', PULONG),\n        VARENUM.VT_UI8_OR_VT_BYREF     : ('pullVal', PULONGLONG),\n        VARENUM.VT_INT_OR_VT_BYREF     : ('pintVal', PINT),\n        VARENUM.VT_UINT_OR_VT_BYREF    : ('puintVal', PUINT),\n        VARENUM.VT_DECIMAL_OR_VT_BYREF : ('pdecVal', PDECIMAL),\n        VARENUM.VT_EMPTY               : ('empty', EMPTY),\n        VARENUM.VT_NULL                : ('null', EMPTY),\n    }",
  "class wireVARIANTStr(NDRSTRUCT):\n    structure = (\n        ('clSize',DWORD),\n        ('rpcReserved',DWORD),\n        ('vt',USHORT),\n        ('wReserved1',USHORT),\n        ('wReserved2',USHORT),\n        ('wReserved3',USHORT),\n        ('_varUnion',varUnion),\n    )\n\n    def getAlignment(self):\n        return 8",
  "class VARIANT(NDRPOINTER):\n    referent = (\n        ('Data', wireVARIANTStr),\n    )",
  "class PVARIANT(NDRPOINTER):\n    referent = (\n        ('Data', VARIANT),\n    )",
  "class DISPID_ARRAY(NDRUniConformantArray):\n    item = '<L'",
  "class PDISPID_ARRAY(NDRPOINTER):\n    referent = (\n        ('Data', DISPID_ARRAY),\n    )",
  "class DISPPARAMS(NDRSTRUCT):\n    structure = (\n        ('rgvarg',PVARIANT_ARRAY),\n        ('rgdispidNamedArgs', PDISPID_ARRAY),\n        ('cArgs', UINT),\n        ('cNamedArgs', UINT),\n    )",
  "class EXCEPINFO(NDRSTRUCT):\n    structure = (\n        ('wCode',WORD),\n        ('wReserved', WORD),\n        ('bstrSource', BSTR),\n        ('bstrDescription', BSTR),\n        ('bstrHelpFile', BSTR),\n        ('dwHelpContext', DWORD),\n        ('pvReserved', ULONG),\n        ('pfnDeferredFillIn', ULONG),\n        ('scode', HRESULT),\n    )",
  "class ARRAYDESC(NDRSTRUCT):\n    # In order to avoid the lack of forward declarations in Python\n    # I declare the item in the constructor\n    #structure = (\n    #    ('tdescElem',TYPEDESC),\n    #    ('cDims',USHORT),\n    #    ('rgbounds',SAFEARRAYBOUND_ARRAY),\n    #)\n    def __init__(self, data = None, isNDR64 = False):\n        NDRSTRUCT.__init__(self, data, isNDR64)\n        self.structure = (\n            ('tdescElem',TYPEDESC),\n            ('cDims',USHORT),\n            ('rgbounds',SAFEARRAYBOUND_ARRAY),\n        )",
  "class tdUnion(NDRUNION):\n    notAlign = True\n    commonHdr = (\n        ('tag', USHORT),\n    )\n    # In order to avoid the lack of forward declarations in Python\n    # I declare the item in the constructor\n    #union = {\n    #    VARENUM.VT_PTR: ('lptdesc', tdUnion),\n    #    VARENUM.VT_SAFEARRAY: ('lptdesc', tdUnion),\n    #    VARENUM.VT_CARRAY: ('lpadesc', ARRAYDESC),\n    #    VARENUM.VT_USERDEFINED: ('hreftype', HREFTYPE),\n    #}\n    def __init__(self, data = None, isNDR64=False, topLevel = False):\n        NDRUNION.__init__(self,None, isNDR64=isNDR64, topLevel=topLevel)\n        self.union = {\n            VARENUM.VT_PTR: ('lptdesc', PTYPEDESC),\n            VARENUM.VT_SAFEARRAY: ('lptdesc', PTYPEDESC),\n            VARENUM.VT_CARRAY: ('lpadesc', ARRAYDESC),\n            VARENUM.VT_USERDEFINED: ('hreftype', HREFTYPE),\n            'default': None,\n        }",
  "class TYPEDESC(NDRSTRUCT):\n    structure = (\n        ('vtType',tdUnion),\n        ('vt', VARENUM),\n    )\n\n    def getAlignment(self):\n        return 4",
  "class PTYPEDESC(NDRPOINTER):\n    referent = (\n        ('Data', TYPEDESC),\n    )\n    def __init__(self, data = None, isNDR64=False, topLevel = False):\n        ret = NDRPOINTER.__init__(self,None, isNDR64=isNDR64, topLevel = False)\n        # We're forcing the pointer not to be topLevel\n        if data is None:\n            self.fields['ReferentID'] = random.randint(1,65535)\n        else:\n           self.fromString(data)",
  "class SCODE_ARRAY(NDRUniConformantArray):\n    item = SCODE",
  "class PSCODE_ARRAY(NDRPOINTER):\n    referent = (\n        ('Data', SCODE_ARRAY),\n    )",
  "class PARAMDESCEX(NDRSTRUCT):\n    structure = (\n        ('cBytes',ULONG),\n        ('varDefaultValue',VARIANT),\n    )",
  "class PPARAMDESCEX(NDRPOINTER):\n    referent = (\n        ('Data', PARAMDESCEX),\n    )",
  "class PARAMDESC(NDRSTRUCT):\n    structure = (\n        ('pparamdescex',PPARAMDESCEX),\n        ('wParamFlags',USHORT),\n    )",
  "class ELEMDESC(NDRSTRUCT):\n    structure = (\n        ('tdesc',TYPEDESC),\n        ('paramdesc',PARAMDESC),\n    )",
  "class ELEMDESC_ARRAY(NDRUniConformantArray):\n    item = ELEMDESC",
  "class PELEMDESC_ARRAY(NDRPOINTER):\n    referent = (\n        ('Data', ELEMDESC_ARRAY),\n    )",
  "class FUNCDESC(NDRSTRUCT):\n    structure = (\n        ('memid',MEMBERID),\n        ('lReserved1',PSCODE_ARRAY),\n        ('lprgelemdescParam',PELEMDESC_ARRAY),\n        ('funckind',FUNCKIND),\n        ('invkind',INVOKEKIND),\n        ('callconv',CALLCONV),\n        ('cParams',SHORT),\n        ('cParamsOpt',SHORT),\n        ('oVft',SHORT),\n        ('cReserved2',SHORT),\n        ('elemdescFunc',ELEMDESC),\n        ('wFuncFlags',WORD),\n    )",
  "class LPFUNCDESC(NDRPOINTER):\n    referent = (\n        ('Data', FUNCDESC),\n    )",
  "class TYPEATTR(NDRSTRUCT):\n    structure = (\n        ('guid',GUID),\n        ('lcid',LCID),\n        ('dwReserved1',DWORD),\n        ('dwReserved2',DWORD),\n        ('dwReserved3',DWORD),\n        ('lpstrReserved4',LPOLESTR),\n        ('cbSizeInstance',ULONG),\n        ('typeKind',TYPEKIND),\n        ('cFuncs',WORD),\n        ('cVars',WORD),\n        ('cImplTypes',WORD),\n        ('cbSizeVft',WORD),\n        ('cbAlignment',WORD),\n        ('wTypeFlags',WORD),\n        ('wMajorVerNum',WORD),\n        ('wMinorVerNum',WORD),\n        ('tdescAlias',TYPEDESC),\n        ('dwReserved5',DWORD),\n        ('dwReserved6',WORD),\n    )",
  "class PTYPEATTR(NDRPOINTER):\n    referent = (\n        ('Data', TYPEATTR),\n    )",
  "class BSTR_ARRAY_CV(NDRUniConformantVaryingArray):\n    item = BSTR",
  "class UINT_ARRAY(NDRUniConformantArray):\n    item = '<L'",
  "class OLESTR_ARRAY(NDRUniConformantArray):\n    item = LPOLESTR",
  "class IDispatch_GetTypeInfoCount(DCOMCALL):\n    opnum = 3\n    structure = (\n       ('pwszMachineName', LPWSTR),\n    )",
  "class IDispatch_GetTypeInfoCountResponse(DCOMANSWER):\n    structure = (\n       ('pctinfo', ULONG),\n       ('ErrorCode', error_status_t),\n    )",
  "class IDispatch_GetTypeInfo(DCOMCALL):\n    opnum = 4\n    structure = (\n       ('iTInfo', ULONG),\n       ('lcid', DWORD),\n    )",
  "class IDispatch_GetTypeInfoResponse(DCOMANSWER):\n    structure = (\n       ('ppTInfo', PMInterfacePointer),\n       ('ErrorCode', error_status_t),\n    )",
  "class IDispatch_GetIDsOfNames(DCOMCALL):\n    opnum = 5\n    structure = (\n       ('riid', REFIID),\n       ('rgszNames', OLESTR_ARRAY),\n       ('cNames', UINT),\n       ('lcid', LCID),\n    )",
  "class IDispatch_GetIDsOfNamesResponse(DCOMANSWER):\n    structure = (\n       ('rgDispId', DISPID_ARRAY),\n       ('ErrorCode', error_status_t),\n    )",
  "class IDispatch_Invoke(DCOMCALL):\n    opnum = 6\n    structure = (\n       ('dispIdMember', DISPID),\n       ('riid', REFIID),\n       ('lcid', LCID),\n       ('dwFlags', DWORD),\n       ('pDispParams', DISPPARAMS),\n       ('cVarRef', UINT),\n       ('rgVarRefIdx', UINT_ARRAY),\n       ('rgVarRef', VARIANT_ARRAY),\n    )",
  "class IDispatch_InvokeResponse(DCOMANSWER):\n    structure = (\n       ('pVarResult', VARIANT),\n       ('pExcepInfo', EXCEPINFO),\n       ('pArgErr', UINT),\n       ('ErrorCode', error_status_t),\n    )",
  "class ITypeInfo_GetTypeAttr(DCOMCALL):\n    opnum = 3\n    structure = (\n    )",
  "class ITypeInfo_GetTypeAttrResponse(DCOMANSWER):\n    structure = (\n       ('ppTypeAttr', PTYPEATTR),\n       ('pReserved', DWORD),\n       ('ErrorCode', error_status_t),\n    )",
  "class ITypeInfo_GetTypeComp(DCOMCALL):\n    opnum = 4\n    structure = (\n    )",
  "class ITypeInfo_GetTypeCompResponse(DCOMANSWER):\n    structure = (\n       ('ppTComp', PMInterfacePointer),\n       ('ErrorCode', error_status_t),\n    )",
  "class ITypeInfo_GetFuncDesc(DCOMCALL):\n    opnum = 5\n    structure = (\n       ('index', UINT),\n    )",
  "class ITypeInfo_GetFuncDescResponse(DCOMANSWER):\n    structure = (\n       ('ppFuncDesc', LPFUNCDESC),\n       ('pReserved', DWORD),\n       ('ErrorCode', error_status_t),\n    )",
  "class ITypeInfo_GetNames(DCOMCALL):\n    opnum = 7\n    structure = (\n       ('memid', MEMBERID),\n       ('cMaxNames', UINT),\n    )",
  "class ITypeInfo_GetNamesResponse(DCOMANSWER):\n    structure = (\n       ('rgBstrNames', BSTR_ARRAY_CV),\n       ('pcNames', UINT),\n       ('ErrorCode', error_status_t),\n    )",
  "class ITypeInfo_GetDocumentation(DCOMCALL):\n    opnum = 12\n    structure = (\n       ('memid', MEMBERID),\n       ('refPtrFlags', DWORD),\n    )",
  "class ITypeInfo_GetDocumentationResponse(DCOMANSWER):\n    structure = (\n       ('pBstrName', BSTR),\n       ('pBstrDocString', BSTR),\n       ('pdwHelpContext', DWORD),\n       ('ErrorCode', error_status_t),\n    )",
  "def enumerateMethods(iInterface):\n    methods = dict()\n    typeInfoCount = iInterface.GetTypeInfoCount()\n    if typeInfoCount['pctinfo'] == 0:\n        LOG.error('Automation Server does not support type information for this object')\n        return {}\n    iTypeInfo = iInterface.GetTypeInfo()\n    iTypeAttr = iTypeInfo.GetTypeAttr()\n    for x in range(iTypeAttr['ppTypeAttr']['cFuncs']):\n        funcDesc = iTypeInfo.GetFuncDesc(x)\n        names = iTypeInfo.GetNames(funcDesc['ppFuncDesc']['memid'], 255)\n        print(names['rgBstrNames'][0]['asData'])\n        funcDesc.dump()\n        print('='*80)\n        if names['pcNames'] > 0:\n            name = names['rgBstrNames'][0]['asData']\n            methods[name] = {}\n            for param in range(1, names['pcNames']):\n                methods[name][names['rgBstrNames'][param]['asData']] = ''\n        if funcDesc['ppFuncDesc']['elemdescFunc'] != NULL:\n            methods[name]['ret'] = funcDesc['ppFuncDesc']['elemdescFunc']['tdesc']['vt']\n\n    return methods",
  "def checkNullString(string):\n    if string == NULL:\n        return string\n\n    if string[-1:] != '\\x00':\n        return string + '\\x00'\n    else:\n        return string",
  "class ITypeComp(IRemUnknown2):\n    def __init__(self, interface):\n        IRemUnknown2.__init__(self,interface)\n        self._iid = IID_ITypeComp",
  "class ITypeInfo(IRemUnknown2):\n    def __init__(self, interface):\n        IRemUnknown2.__init__(self,interface)\n        self._iid = IID_ITypeInfo\n\n    def GetTypeAttr(self):\n        request = ITypeInfo_GetTypeAttr()\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        return resp\n\n    def GetTypeComp(self):\n        request = ITypeInfo_GetTypeComp()\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        return ITypeComp(INTERFACE(self.get_cinstance(), b''.join(resp['ppTComp']['abData']), self.get_ipidRemUnknown(), target = self.get_target()))\n\n    def GetFuncDesc(self, index):\n        request = ITypeInfo_GetFuncDesc()\n        request['index'] = index\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        return resp\n\n    def GetNames(self, memid, cMaxNames=10):\n        request = ITypeInfo_GetNames()\n        request['memid'] = memid\n        request['cMaxNames'] = cMaxNames\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        return resp\n\n    def GetDocumentation(self, memid, refPtrFlags=15):\n        request = ITypeInfo_GetDocumentation()\n        request['memid'] = memid\n        request['refPtrFlags'] = refPtrFlags\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        return resp",
  "class IDispatch(IRemUnknown2):\n    def __init__(self, interface):\n        IRemUnknown2.__init__(self,interface)\n        self._iid = IID_IDispatch\n\n    def GetTypeInfoCount(self):\n        request = IDispatch_GetTypeInfoCount()\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        return resp\n\n    def GetTypeInfo(self):\n        request = IDispatch_GetTypeInfo()\n        request['iTInfo'] = 0\n        request['lcid'] = 0\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        return ITypeInfo(INTERFACE(self.get_cinstance(), b''.join(resp['ppTInfo']['abData']), self.get_ipidRemUnknown(), target = self.get_target()))\n\n    def GetIDsOfNames(self, rgszNames, lcid = 0):\n        request = IDispatch_GetIDsOfNames()\n        request['riid'] = IID_NULL\n        for name in rgszNames:\n            tmpName = LPOLESTR()\n            tmpName['Data'] = checkNullString(name)\n            request['rgszNames'].append(tmpName)\n        request['cNames'] = len(rgszNames)\n        request['lcid'] = lcid\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        IDs = list()\n        for id in resp['rgDispId']:\n            IDs.append(id)\n\n        return IDs\n\n    def Invoke(self, dispIdMember, lcid, dwFlags, pDispParams, cVarRef, rgVarRefIdx, rgVarRef):\n        request = IDispatch_Invoke()\n        request['dispIdMember'] = dispIdMember\n        request['riid'] = IID_NULL\n        request['lcid'] = lcid\n        request['dwFlags'] = dwFlags\n        request['pDispParams'] = pDispParams\n        request['cVarRef'] = cVarRef\n        request['rgVarRefIdx'] = rgVarRefIdx\n        request['rgVarRef'] = rgVarRefIdx\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        return resp",
  "def __init__(self, error_string=None, error_code=None, packet=None):\n        DCERPCException.__init__(self, error_string, error_code, packet)",
  "def __str__( self ):\n        if self.error_code in hresult_errors.ERROR_MESSAGES:\n            error_msg_short = hresult_errors.ERROR_MESSAGES[self.error_code][0]\n            error_msg_verbose = hresult_errors.ERROR_MESSAGES[self.error_code][1] \n            return 'OAUT SessionError: code: 0x%x - %s - %s' % (self.error_code, error_msg_short, error_msg_verbose)\n        else:\n            return 'OAUT SessionError: unknown error code: 0x%x' % (self.error_code)",
  "class enumItems(Enum):\n        VT_EMPTY       = 0\n        VT_NULL        = 1\n        VT_I2          = 2\n        VT_I4          = 3\n        VT_R4          = 4\n        VT_R8          = 5\n        VT_CY          = 6\n        VT_DATE        = 7\n        VT_BSTR        = 8\n        VT_DISPATCH    = 9\n        VT_ERROR       = 0xa\n        VT_BOOL        = 0xb\n        VT_VARIANT     = 0xc\n        VT_UNKNOWN     = 0xd\n        VT_DECIMAL     = 0xe\n        VT_I1          = 0x10\n        VT_UI1         = 0x11\n        VT_UI2         = 0x12\n        VT_UI4         = 0x13\n        VT_I8          = 0x14\n        VT_UI8         = 0x15\n        VT_INT         = 0x16\n        VT_UINT        = 0x17\n        VT_VOID        = 0x18\n        VT_HRESULT     = 0x19\n        VT_PTR         = 0x1a\n        VT_SAFEARRAY   = 0x1b\n        VT_CARRAY      = 0x1c\n        VT_USERDEFINED = 0x1d\n        VT_LPSTR       = 0x1e\n        VT_LPWSTR      = 0x1f\n        VT_RECORD      = 0x24\n        VT_INT_PTR     = 0x25\n        VT_UINT_PTR    = 0x26\n        VT_ARRAY       = 0x2000\n        VT_BYREF       = 0x4000\n        VT_RECORD_OR_VT_BYREF   = VT_RECORD | VT_BYREF\n        VT_UI1_OR_VT_BYREF      = VT_UI1 | VT_BYREF\n        VT_I2_OR_VT_BYREF       = VT_I2 | VT_BYREF\n        VT_I4_OR_VT_BYREF       = VT_I4 | VT_BYREF\n        VT_I8_OR_VT_BYREF       = VT_I8 | VT_BYREF\n        VT_R4_OR_VT_BYREF       = VT_R4 | VT_BYREF\n        VT_R8_OR_VT_BYREF       = VT_R8 | VT_BYREF\n        VT_BOOL_OR_VT_BYREF     = VT_BOOL | VT_BYREF\n        VT_ERROR_OR_VT_BYREF    = VT_ERROR | VT_BYREF\n        VT_CY_OR_VT_BYREF       = VT_CY | VT_BYREF\n        VT_DATE_OR_VT_BYREF     = VT_DATE | VT_BYREF\n        VT_BSTR_OR_VT_BYREF     = VT_BSTR | VT_BYREF\n        VT_UNKNOWN_OR_VT_BYREF  = VT_UNKNOWN | VT_BYREF\n        VT_DISPATCH_OR_VT_BYREF = VT_DISPATCH | VT_BYREF\n        VT_ARRAY_OR_VT_BYREF    = VT_ARRAY | VT_BYREF\n        VT_VARIANT_OR_VT_BYREF  = VT_VARIANT| VT_BYREF\n        VT_I1_OR_VT_BYREF       = VT_I1 | VT_BYREF\n        VT_UI2_OR_VT_BYREF      = VT_UI2 | VT_BYREF\n        VT_UI4_OR_VT_BYREF      = VT_UI4 | VT_BYREF\n        VT_UI8_OR_VT_BYREF      = VT_UI8 | VT_BYREF\n        VT_INT_OR_VT_BYREF      = VT_INT | VT_BYREF\n        VT_UINT_OR_VT_BYREF     = VT_UINT | VT_BYREF\n        VT_DECIMAL_OR_VT_BYREF  = VT_DECIMAL | VT_BYREF",
  "class enumItems(Enum):\n        SF_ERROR     = VARENUM.VT_ERROR\n        SF_I1        = VARENUM.VT_I1\n        SF_I2        = VARENUM.VT_I2\n        SF_I4        = VARENUM.VT_I4\n        SF_I8        = VARENUM.VT_I8\n        SF_BSTR      = VARENUM.VT_BSTR\n        SF_UNKNOWN   = VARENUM.VT_UNKNOWN\n        SF_DISPATCH  = VARENUM.VT_DISPATCH\n        SF_VARIANT   = VARENUM.VT_VARIANT\n        SF_RECORD    = VARENUM.VT_RECORD\n        SF_HAVEIID   = VARENUM.VT_UNKNOWN | 0x8000",
  "class enumItems(Enum):\n        CC_CDECL   = 1\n        CC_PASCAL  = 2\n        CC_STDCALL = 4",
  "class enumItems(Enum):\n        FUNC_PUREVIRTUAL = 1\n        FUNC_STATIC      = 3\n        FUNC_DISPATCH    = 4",
  "class enumItems(Enum):\n        INVOKE_FUNC           = 1\n        INVOKE_PROPERTYGET    = 2\n        INVOKE_PROPERTYPUT    = 4\n        INVOKE_PROPERTYPUTREF = 8",
  "class enumItems(Enum):\n        TKIND_ENUM      = 0\n        TKIND_RECORD    = 1\n        TKIND_MODULE    = 2\n        TKIND_INTERFACE = 3\n        TKIND_DISPATCH  = 4\n        TKIND_COCLASS   = 5\n        TKIND_ALIAS     = 6\n        TKIND_UNION     = 7",
  "def __setitem__(self, key, value):\n        if key == 'asData':\n            value = value #+ '\\x00'\n            array = list()\n            for letter in value:\n                encoded = letter.encode('utf-16le')\n                array.append(unpack('<H', encoded)[0])\n            self.fields[key]['Data'] = array\n            self['cBytes'] = len(value)*2\n            self['clSize'] = len(value)\n            self.data = None        # force recompute\n        else:\n            return NDRSTRUCT.__setitem__(self, key, value)",
  "def __getitem__(self, key):\n        if key == 'asData':\n            value = ''\n            for letter in self.fields['asData']['Data']:\n                value += pack('<H', letter).decode('utf-16le')\n            return value\n        else:\n            return NDRSTRUCT.__getitem__(self,key)",
  "def dump(self, msg = None, indent = 0):\n        if msg is None: msg = self.__class__.__name__\n        ind = ' '*indent\n        if msg != '':\n            print(\"%s\" % (msg))\n        value = ''\n        print('%sasData: %s' % (ind,self['asData']), end=' ')",
  "def __init__(self, data = None, isNDR64 = False):\n        NDRUniConformantArray.__init__(self, data, isNDR64)\n        self.item = VARIANT",
  "def __init__(self, data = None, isNDR64 = False):\n        NDRPOINTER.__init__(self, data, isNDR64)\n        self.referent = ( ('Data', VARIANT),)",
  "def getAlignment(self):\n        return 8",
  "def __init__(self, data = None, isNDR64 = False):\n        NDRSTRUCT.__init__(self, data, isNDR64)\n        self.structure = (\n            ('tdescElem',TYPEDESC),\n            ('cDims',USHORT),\n            ('rgbounds',SAFEARRAYBOUND_ARRAY),\n        )",
  "def __init__(self, data = None, isNDR64=False, topLevel = False):\n        NDRUNION.__init__(self,None, isNDR64=isNDR64, topLevel=topLevel)\n        self.union = {\n            VARENUM.VT_PTR: ('lptdesc', PTYPEDESC),\n            VARENUM.VT_SAFEARRAY: ('lptdesc', PTYPEDESC),\n            VARENUM.VT_CARRAY: ('lpadesc', ARRAYDESC),\n            VARENUM.VT_USERDEFINED: ('hreftype', HREFTYPE),\n            'default': None,\n        }",
  "def getAlignment(self):\n        return 4",
  "def __init__(self, data = None, isNDR64=False, topLevel = False):\n        ret = NDRPOINTER.__init__(self,None, isNDR64=isNDR64, topLevel = False)\n        # We're forcing the pointer not to be topLevel\n        if data is None:\n            self.fields['ReferentID'] = random.randint(1,65535)\n        else:\n           self.fromString(data)",
  "def __init__(self, interface):\n        IRemUnknown2.__init__(self,interface)\n        self._iid = IID_ITypeComp",
  "def __init__(self, interface):\n        IRemUnknown2.__init__(self,interface)\n        self._iid = IID_ITypeInfo",
  "def GetTypeAttr(self):\n        request = ITypeInfo_GetTypeAttr()\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        return resp",
  "def GetTypeComp(self):\n        request = ITypeInfo_GetTypeComp()\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        return ITypeComp(INTERFACE(self.get_cinstance(), b''.join(resp['ppTComp']['abData']), self.get_ipidRemUnknown(), target = self.get_target()))",
  "def GetFuncDesc(self, index):\n        request = ITypeInfo_GetFuncDesc()\n        request['index'] = index\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        return resp",
  "def GetNames(self, memid, cMaxNames=10):\n        request = ITypeInfo_GetNames()\n        request['memid'] = memid\n        request['cMaxNames'] = cMaxNames\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        return resp",
  "def GetDocumentation(self, memid, refPtrFlags=15):\n        request = ITypeInfo_GetDocumentation()\n        request['memid'] = memid\n        request['refPtrFlags'] = refPtrFlags\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        return resp",
  "def __init__(self, interface):\n        IRemUnknown2.__init__(self,interface)\n        self._iid = IID_IDispatch",
  "def GetTypeInfoCount(self):\n        request = IDispatch_GetTypeInfoCount()\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        return resp",
  "def GetTypeInfo(self):\n        request = IDispatch_GetTypeInfo()\n        request['iTInfo'] = 0\n        request['lcid'] = 0\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        return ITypeInfo(INTERFACE(self.get_cinstance(), b''.join(resp['ppTInfo']['abData']), self.get_ipidRemUnknown(), target = self.get_target()))",
  "def GetIDsOfNames(self, rgszNames, lcid = 0):\n        request = IDispatch_GetIDsOfNames()\n        request['riid'] = IID_NULL\n        for name in rgszNames:\n            tmpName = LPOLESTR()\n            tmpName['Data'] = checkNullString(name)\n            request['rgszNames'].append(tmpName)\n        request['cNames'] = len(rgszNames)\n        request['lcid'] = lcid\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        IDs = list()\n        for id in resp['rgDispId']:\n            IDs.append(id)\n\n        return IDs",
  "def Invoke(self, dispIdMember, lcid, dwFlags, pDispParams, cVarRef, rgVarRefIdx, rgVarRef):\n        request = IDispatch_Invoke()\n        request['dispIdMember'] = dispIdMember\n        request['riid'] = IID_NULL\n        request['lcid'] = lcid\n        request['dwFlags'] = dwFlags\n        request['pDispParams'] = pDispParams\n        request['cVarRef'] = cVarRef\n        request['rgVarRefIdx'] = rgVarRefIdx\n        request['rgVarRef'] = rgVarRefIdx\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        return resp",
  "def format_structure(d, level=0):\n    x = \"\"\n    if isinstance(d, collections.abc.Mapping):\n        lenk = max([len(str(x)) for x in list(d.keys())])\n        for k, v in list(d.items()):\n            key_text = \"\\n\" + \" \"*level + \" \"*(lenk - len(str(k))) + str(k)\n            x += key_text + \": \" + format_structure(v, level=level+lenk)\n    elif isinstance(d, collections.abc.Iterable) and not isinstance(d, str):\n        for e in d:\n            x += \"\\n\" + \" \"*level + \"- \" + format_structure(e, level=level+4)\n    else:\n        x = str(d)\n    return x",
  "class DCERPCSessionError(DCERPCException):\n    def __init__(self, error_string=None, error_code=None, packet=None):\n        DCERPCException.__init__(self, error_string, error_code, packet)\n\n    def __str__( self ):\n        if self.error_code in hresult_errors.ERROR_MESSAGES:\n            error_msg_short = hresult_errors.ERROR_MESSAGES[self.error_code][0]\n            error_msg_verbose = hresult_errors.ERROR_MESSAGES[self.error_code][1] \n            return 'WMI SessionError: code: 0x%x - %s - %s' % (self.error_code, error_msg_short, error_msg_verbose)\n        else:\n            # Let's see if we have it as WBEMSTATUS\n            try:\n                return 'WMI Session Error: code: 0x%x - %s' % (self.error_code, WBEMSTATUS.enumItems(self.error_code).name)\n            except:\n                return 'WMI SessionError: unknown error code: 0x%x' % self.error_code",
  "class ENCODED_STRING(Structure):\n    commonHdr = (\n        ('Encoded_String_Flag', ENCODED_STRING_FLAG),\n    )\n\n    tascii = (\n        ('Character', 'z'),\n    )\n\n    tunicode = (\n        ('Character', 'u'),\n    )\n\n    def __init__(self, data = None, alignment = 0):\n        Structure.__init__(self, data, alignment)\n        if data is not None:\n            # Let's first check the commonHdr\n            self.fromString(data)\n            self.structure = ()\n            self.isUnicode = False\n            if len(data) > 1:\n                if self['Encoded_String_Flag'] == 0:\n                    self.structure += self.tascii\n                    # Let's search for the end of the string\n                    index = data[1:].find(b'\\x00')\n                    data  = data[:index+1+1]\n                else:\n                    self.structure = self.tunicode\n                    self.isUnicode = True\n\n                self.fromString(data)\n        else:\n            self.structure = self.tascii\n            self.data = None\n\n    def __getitem__(self, key):\n        if key == 'Character' and self.isUnicode:\n            return self.fields['Character'].decode('utf-16le')\n        return Structure.__getitem__(self, key)",
  "class DECORATION(Structure):\n    structure = (\n        ('DecServerName', ':', DEC_SERVER_NAME),\n        ('DecNamespaceName', ':', DEC_NAMESPACE_NAME),\n    )",
  "class CLASS_HEADER(Structure):\n    structure = (\n        ('EncodingLength', ENCODING_LENGTH),\n        ('ReservedOctet', RESERVED_OCTET),\n        ('ClassNameRef', CLASS_NAME_REF),\n        ('NdTableValueTableLength', NDTABLE_VALUE_TABLE_LENGTH),\n    )",
  "class DERIVATION_LIST(Structure):\n    structure = (\n        ('EncodingLength', ENCODING_LENGTH),\n        ('_ClassNameEncoding','_-ClassNameEncoding', 'self[\"EncodingLength\"]-4'),\n        ('ClassNameEncoding', ':'),\n    )",
  "class EnumType(type):\n    def __getattr__(self, attr):\n        return self.enumItems[attr].value",
  "class CIM_TYPE_ENUM(Enum):\n#    __metaclass__ = EnumType\n    CIM_TYPE_SINT8      = 16\n    CIM_TYPE_UINT8      = 17\n    CIM_TYPE_SINT16     = 2\n    CIM_TYPE_UINT16     = 18\n    CIM_TYPE_SINT32     = 3\n    CIM_TYPE_UINT32     = 19\n    CIM_TYPE_SINT64     = 20\n    CIM_TYPE_UINT64     = 21\n    CIM_TYPE_REAL32     = 4\n    CIM_TYPE_REAL64     = 5\n    CIM_TYPE_BOOLEAN    = 11\n    CIM_TYPE_STRING     = 8\n    CIM_TYPE_DATETIME   = 101\n    CIM_TYPE_REFERENCE  = 102\n    CIM_TYPE_CHAR16     = 103\n    CIM_TYPE_OBJECT     = 13\n    CIM_ARRAY_SINT8     = 8208\n    CIM_ARRAY_UINT8     = 8209\n    CIM_ARRAY_SINT16    = 8194\n    CIM_ARRAY_UINT16    = 8210\n    CIM_ARRAY_SINT32    = 8195\n    CIM_ARRAY_UINT32    = 8201\n    CIM_ARRAY_SINT64    = 8202\n    CIM_ARRAY_UINT64    = 8203\n    CIM_ARRAY_REAL32    = 8196\n    CIM_ARRAY_REAL64    = 8197\n    CIM_ARRAY_BOOLEAN   = 8203\n    CIM_ARRAY_STRING    = 8200\n    CIM_ARRAY_DATETIME  = 8293\n    CIM_ARRAY_REFERENCE = 8294\n    CIM_ARRAY_CHAR16    = 8295\n    CIM_ARRAY_OBJECT    = 8205",
  "class ENCODED_VALUE(Structure):\n    structure = (\n        ('QualifierName', QUALIFIER_NAME),\n    )\n\n    @classmethod\n    def getValue(cls, cimType, entry, heap):\n        # Let's get the default Values\n        pType = cimType & (~(CIM_ARRAY_FLAG|Inherited))\n\n        if entry != 0xffffffff:\n            heapData = heap[entry:]\n            if cimType & CIM_ARRAY_FLAG:\n                # We have an array, let's set the right unpackStr and dataSize for the array contents\n                dataSize = calcsize(HEAPREF[:-2])\n                numItems = unpack(HEAPREF[:-2], heapData[:dataSize])[0]\n                heapData = heapData[dataSize:]\n                array = list()\n                unpackStrArray =  CIM_TYPES_REF[pType][:-2]\n                dataSizeArray = calcsize(unpackStrArray)\n                if cimType == CIM_TYPE_ENUM.CIM_ARRAY_STRING.value:\n                    # We have an array of strings\n                    # First items are DWORDs with the string pointers\n                    # inside the heap. We don't need those ones\n                    heapData = heapData[4*numItems:]\n                    # Let's now grab the strings\n                    for _ in range(numItems):\n                        item = ENCODED_STRING(heapData)\n                        array.append(item['Character'])\n                        heapData = heapData[len(item.getData()):]\n                elif cimType == CIM_TYPE_ENUM.CIM_ARRAY_OBJECT.value:\n                    # Discard the pointers\n                    heapData = heapData[dataSize*numItems:]\n                    for item in range(numItems):\n                        msb = METHOD_SIGNATURE_BLOCK(heapData)\n                        unit = ENCODING_UNIT()\n                        unit['ObjectEncodingLength'] = msb['EncodingLength']\n                        unit['ObjectBlock'] = msb['ObjectBlock']\n                        array.append(unit)\n                        heapData = heapData[msb['EncodingLength']+4:]\n                else:\n                    for item in range(numItems):\n                        # ToDo: Learn to unpack the rest of the array of things\n                        array.append(unpack(unpackStrArray, heapData[:dataSizeArray])[0])\n                        heapData = heapData[dataSizeArray:]\n                value = array\n            elif pType == CIM_TYPE_ENUM.CIM_TYPE_BOOLEAN.value:\n                if entry == 0xffff:\n                    value = 'True'\n                else:\n                    value = 'False'\n            elif pType == CIM_TYPE_ENUM.CIM_TYPE_OBJECT.value:\n                # If the value type is CIM-TYPE-OBJECT, the EncodedValue is a HeapRef to the object encoded as an\n                # ObjectEncodingLength (section 2.2.4) followed by an ObjectBlock (section 2.2.5).\n\n                # ToDo: This is a hack.. We should parse this better. We need to have an ENCODING_UNIT.\n                # I'm going through a METHOD_SIGNATURE_BLOCK first just to parse the ObjectBlock\n                msb = METHOD_SIGNATURE_BLOCK(heapData)\n                unit = ENCODING_UNIT()\n                unit['ObjectEncodingLength'] = msb['EncodingLength']\n                unit['ObjectBlock'] = msb['ObjectBlock']\n                value = unit\n            elif pType not in (CIM_TYPE_ENUM.CIM_TYPE_STRING.value, CIM_TYPE_ENUM.CIM_TYPE_DATETIME.value,\n                               CIM_TYPE_ENUM.CIM_TYPE_REFERENCE.value):\n                value = entry\n            else:\n                try:\n                    value = ENCODED_STRING(heapData)['Character']\n                except UnicodeDecodeError:\n                    if logging.getLogger().level == logging.DEBUG:\n                        LOG.debug('Unicode Error: dumping heapData')\n                        hexdump(heapData)\n                    raise\n\n            return value",
  "class QUALIFIER(Structure):\n    commonHdr = (\n        ('QualifierName', QUALIFIER_NAME),\n        ('QualifierFlavor', QUALIFIER_FLAVOR),\n        ('QualifierType', QUALIFIER_TYPE),\n    )\n    def __init__(self, data = None, alignment = 0):\n        Structure.__init__(self, data, alignment)\n        if data is not None:\n            # Let's first check the commonHdr\n            self.fromString(data)\n            self.structure = (('QualifierValue', CIM_TYPES_REF[self[\"QualifierType\"] & (~CIM_ARRAY_FLAG)]),)\n            self.fromString(data)\n        else:\n            self.data = None",
  "class QUALIFIER_SET(Structure):\n    structure = (\n        ('EncodingLength', ENCODING_LENGTH),\n        ('_Qualifier','_-Qualifier', 'self[\"EncodingLength\"]-4'),\n        ('Qualifier', ':'),\n    )\n\n    def getQualifiers(self, heap):\n        data = self['Qualifier']\n        qualifiers = dict()\n        while len(data) > 0:\n            itemn = QUALIFIER(data)\n            if itemn['QualifierName'] == 0xffffffff:\n                qName = b''\n            elif itemn['QualifierName'] & 0x80000000:\n                qName = DICTIONARY_REFERENCE[itemn['QualifierName'] & 0x7fffffff]\n            else:\n                qName = ENCODED_STRING(heap[itemn['QualifierName']:])['Character']\n\n            value = ENCODED_VALUE.getValue(itemn['QualifierType'], itemn['QualifierValue'], heap)\n            qualifiers[qName] = value\n            data = data[len(itemn):]\n\n        return qualifiers",
  "class PropertyLookup(Structure):\n    structure = (\n        ('PropertyNameRef', PROPERTY_NAME_REF),\n        ('PropertyInfoRef', PROPERTY_INFO_REF),\n    )",
  "class PROPERTY_INFO(Structure):\n    structure = (\n        ('PropertyType', PROPERTY_TYPE),\n        ('DeclarationOrder', DECLARATION_ORDER),\n        ('ValueTableOffset', VALUE_TABLE_OFFSET),\n        ('ClassOfOrigin', CLASS_OF_ORIGIN),\n        ('PropertyQualifierSet', ':', PROPERTY_QUALIFIER_SET),\n    )",
  "class PROPERTY_LOOKUP_TABLE(Structure):\n    PropertyLookupSize = len(PropertyLookup())\n    structure = (\n        ('PropertyCount', PROPERTY_COUNT),\n        ('_PropertyLookup','_-PropertyLookup', 'self[\"PropertyCount\"]*self.PropertyLookupSize'),\n        ('PropertyLookup', ':'),\n    )\n\n    def getProperties(self, heap):\n        propTable = self['PropertyLookup']\n        properties = dict()\n        for property in range(self['PropertyCount']):\n            propItemDict = dict()\n            propItem = PropertyLookup(propTable)\n            if propItem['PropertyNameRef'] & 0x80000000:\n                propName = DICTIONARY_REFERENCE[propItem['PropertyNameRef'] & 0x7fffffff]\n            else:\n                propName = ENCODED_STRING(heap[propItem['PropertyNameRef']:])['Character']\n            propInfo = PROPERTY_INFO(heap[propItem['PropertyInfoRef']:])\n            pType = propInfo['PropertyType']\n            pType &= (~CIM_ARRAY_FLAG)\n            pType &= (~Inherited)\n            sType = CIM_TYPE_TO_NAME[pType]\n \n            propItemDict['stype'] = sType\n            propItemDict['name'] = propName\n            propItemDict['type'] = propInfo['PropertyType']\n            propItemDict['order'] = propInfo['DeclarationOrder']\n            propItemDict['inherited'] = propInfo['PropertyType'] & Inherited\n            propItemDict['value'] = None\n\n            qualifiers = dict() \n            qualifiersBuf = propInfo['PropertyQualifierSet']['Qualifier']\n            while len(qualifiersBuf) > 0:\n                record = QUALIFIER(qualifiersBuf)\n                if record['QualifierName'] & 0x80000000:\n                    qualifierName = DICTIONARY_REFERENCE[record['QualifierName'] & 0x7fffffff]\n                else:\n                    qualifierName = ENCODED_STRING(heap[record['QualifierName']:])['Character']\n                qualifierValue = ENCODED_VALUE.getValue(record['QualifierType'], record['QualifierValue'], heap)\n                qualifiersBuf = qualifiersBuf[len(record):]\n                qualifiers[qualifierName] = qualifierValue\n\n            propItemDict['qualifiers'] = qualifiers\n            properties[propName] = propItemDict\n\n            propTable = propTable[self.PropertyLookupSize:]\n\n        return OrderedDict(sorted(list(properties.items()), key=lambda x:x[1]['order']))",
  "class HEAP(Structure):\n    structure = (\n        ('HeapLength', HEAP_LENGTH),\n        # HeapLength is a 32-bit value with the most significant bit always set \n        # (using little-endian binary encoding for the 32-bit value), so that the \n        # length is actually only 31 bits.\n        ('_HeapItem','_-HeapItem', 'self[\"HeapLength\"]&0x7fffffff'),\n        ('HeapItem', ':'),\n    )",
  "class CLASS_PART(Structure):\n    commonHdr = (\n        ('ClassHeader', ':', CLASS_HEADER),\n        ('DerivationList', ':', DERIVATION_LIST),\n        ('ClassQualifierSet', ':', CLASS_QUALIFIER_SET),\n        ('PropertyLookupTable', ':', PROPERTY_LOOKUP_TABLE),\n        ('_NdTable_ValueTable','_-NdTable_ValueTable', 'self[\"ClassHeader\"][\"NdTableValueTableLength\"]'),\n        ('NdTable_ValueTable',':'),\n        ('ClassHeap', ':', CLASS_HEAP),\n        ('_Garbage', '_-Garbage', 'self[\"ClassHeader\"][\"EncodingLength\"]-len(self)'),\n        ('Garbage', ':=b\"\"'),\n    )\n    def getQualifiers(self):\n        return self[\"ClassQualifierSet\"].getQualifiers(self[\"ClassHeap\"][\"HeapItem\"])\n\n    def getProperties(self):\n        heap = self[\"ClassHeap\"][\"HeapItem\"]\n        properties =  self[\"PropertyLookupTable\"].getProperties(self[\"ClassHeap\"][\"HeapItem\"])\n        sorted_props = sorted(list(properties.keys()), key=lambda k: properties[k]['order'])\n        valueTableOff = (len(properties) - 1) // 4 + 1\n        valueTable = self['NdTable_ValueTable'][valueTableOff:]\n        for key in sorted_props:\n            # Let's get the default Values\n            pType = properties[key]['type'] & (~(CIM_ARRAY_FLAG|Inherited))\n            if properties[key]['type'] & CIM_ARRAY_FLAG:\n                unpackStr = HEAPREF[:-2]\n            else:\n                unpackStr = CIM_TYPES_REF[pType][:-2]\n            dataSize = calcsize(unpackStr)\n            try:\n                itemValue = unpack(unpackStr, valueTable[:dataSize])[0]\n            except: \n                LOG.error(\"getProperties: Error unpacking!!\")\n                itemValue = 0xffffffff\n\n            if itemValue != 0xffffffff and itemValue > 0:\n                value = ENCODED_VALUE.getValue(properties[key]['type'], itemValue, heap)\n                properties[key]['value'] = \"%s\" % value\n            valueTable = valueTable[dataSize:]\n        return properties",
  "class METHOD_DESCRIPTION(Structure):\n    structure = (\n        ('MethodName',METHOD_NAME),\n        ('MethodFlags', METHOD_FLAGS),\n        ('MethodPadding', METHOD_PADDING),\n        ('MethodOrigin', METHOD_ORIGIN),\n        ('MethodQualifiers', METHOD_QUALIFIERS),\n        ('InputSignature', INPUT_SIGNATURE),\n        ('OutputSignature', OUTPUT_SIGNATURE),\n    )",
  "class METHODS_PART(Structure):\n    MethodDescriptionSize = len(METHOD_DESCRIPTION())\n    structure = (\n        ('EncodingLength',ENCODING_LENGTH),\n        ('MethodCount', METHOD_COUNT),\n        ('MethodCountPadding', METHOD_COUNT_PADDING),\n        ('_MethodDescription', '_-MethodDescription', 'self[\"MethodCount\"]*self.MethodDescriptionSize'),\n        ('MethodDescription', ':'),\n        ('MethodHeap', ':', METHOD_HEAP),\n    )\n\n    def getMethods(self):\n        methods = OrderedDict()\n        data = self['MethodDescription']\n        heap = self['MethodHeap']['HeapItem']\n\n        for method in range(self['MethodCount']):\n            methodDict = OrderedDict()\n            itemn = METHOD_DESCRIPTION(data)\n            if itemn['MethodFlags'] & WBEM_FLAVOR_ORIGIN_PROPAGATED:\n               # ToDo\n               #print \"WBEM_FLAVOR_ORIGIN_PROPAGATED not yet supported!\"\n               #raise\n               pass\n            methodDict['name'] = ENCODED_STRING(heap[itemn['MethodName']:])['Character']\n            methodDict['origin'] = itemn['MethodOrigin']\n            if itemn['MethodQualifiers'] != 0xffffffff:\n                # There are qualifiers\n                qualifiersSet = QUALIFIER_SET(heap[itemn['MethodQualifiers']:])\n                qualifiers = qualifiersSet.getQualifiers(heap)\n                methodDict['qualifiers'] = qualifiers\n            if itemn['InputSignature'] != 0xffffffff:\n                inputSignature = METHOD_SIGNATURE_BLOCK(heap[itemn['InputSignature']:])\n                if inputSignature['EncodingLength'] > 0:\n                    methodDict['InParams'] = inputSignature['ObjectBlock']['ClassType']['CurrentClass'].getProperties()\n                    methodDict['InParamsRaw'] = inputSignature['ObjectBlock']\n                    #print methodDict['InParams'] \n                else:\n                    methodDict['InParams'] = None\n            if itemn['OutputSignature'] != 0xffffffff:\n                outputSignature = METHOD_SIGNATURE_BLOCK(heap[itemn['OutputSignature']:])\n                if outputSignature['EncodingLength'] > 0:\n                    methodDict['OutParams'] = outputSignature['ObjectBlock']['ClassType']['CurrentClass'].getProperties()\n                    methodDict['OutParamsRaw'] = outputSignature['ObjectBlock']\n                else:\n                    methodDict['OutParams'] = None\n            data = data[len(itemn):]\n            methods[methodDict['name']] = methodDict\n\n        return methods",
  "class CLASS_AND_METHODS_PART(Structure):\n    structure = (\n        ('ClassPart', ':', CLASS_PART),\n        ('MethodsPart', ':', METHODS_PART),\n    )\n\n    def getClassName(self):\n        pClassName = self['ClassPart']['ClassHeader']['ClassNameRef']\n        cHeap = self['ClassPart']['ClassHeap']['HeapItem']\n        if pClassName == 0xffffffff:\n            return 'None'\n        else:\n            className = ENCODED_STRING(cHeap[pClassName:])['Character']\n            derivationList = self['ClassPart']['DerivationList']['ClassNameEncoding']\n            while len(derivationList) > 0:\n                superClass = ENCODED_STRING(derivationList)['Character']\n                className += ' : %s ' % superClass\n                derivationList = derivationList[len(ENCODED_STRING(derivationList))+4:]\n            return className\n\n    def getQualifiers(self):\n        return self[\"ClassPart\"].getQualifiers()\n\n    def getProperties(self):\n        #print format_structure(self[\"ClassPart\"].getProperties())\n        return self[\"ClassPart\"].getProperties()\n\n    def getMethods(self):\n        return self[\"MethodsPart\"].getMethods()",
  "class CURRENT_CLASS_NO_METHODS(CLASS_AND_METHODS_PART):\n    structure = (\n        ('ClassPart', ':', CLASS_PART),\n    )\n    def getMethods(self):\n        return ()",
  "class INSTANCE_PROP_QUALIFIER_SET(Structure):\n    commonHdr = (\n        ('InstPropQualSetFlag', INST_PROP_QUAL_SET_FLAG),\n    )\n    tail = (\n        # ToDo: this is wrong.. this should be an array of QualifierSet, see documentation\n        #('QualifierSet', ':', QualifierSet),\n        ('QualifierSet', ':', QUALIFIER_SET),\n    )\n\n    def __init__(self, data = None, alignment = 0):\n        Structure.__init__(self, data, alignment)\n        self.structure = ()\n        if data is not None:\n            # Let's first check the commonHdr\n            self.fromString(data)\n            if self['InstPropQualSetFlag'] == 2:\n                # We don't support this yet!\n                raise Exception(\"self['InstPropQualSetFlag'] == 2\")\n            self.fromString(data)\n        else:\n            self.data = None",
  "class INSTANCE_QUALIFIER_SET(Structure):\n    structure = (\n        ('QualifierSet', ':', QUALIFIER_SET),\n        ('InstancePropQualifierSet', ':', INSTANCE_PROP_QUALIFIER_SET),\n    )",
  "class INSTANCE_TYPE(Structure):\n    commonHdr = (\n        ('CurrentClass', ':', CURRENT_CLASS_NO_METHODS),\n        ('EncodingLength', ENCODING_LENGTH),\n        ('InstanceFlags', INSTANCE_FLAGS),\n        ('InstanceClassName', INSTANCE_CLASS_NAME),\n        ('_NdTable_ValueTable', '_-NdTable_ValueTable',\n         'self[\"CurrentClass\"][\"ClassPart\"][\"ClassHeader\"][\"NdTableValueTableLength\"]'),\n        ('NdTable_ValueTable',':'),\n        ('InstanceQualifierSet', ':', INSTANCE_QUALIFIER_SET),\n        ('InstanceHeap', ':', INSTANCE_HEAP),\n    )\n\n    def __init__(self, data = None, alignment = 0):\n        Structure.__init__(self, data, alignment)\n        self.structure = ()\n        if data is not None:\n            # Let's first check the commonHdr\n            self.fromString(data)\n            #hexdump(data[len(self.getData()):])\n            self.NdTableSize = (self['CurrentClass']['ClassPart']['PropertyLookupTable']['PropertyCount'] - 1) //4 + 1\n            #self.InstanceDataSize = self['CurrentClass']['ClassPart']['PropertyLookupTable']['PropertyCount'] * len(InstanceData())\n            self.fromString(data)\n        else:\n            self.data = None\n\n    def __processNdTable(self, properties):\n        octetCount = (len(properties) - 1) // 4 + 1  # see [MS-WMIO]: 2.2.26 NdTable\n        packedNdTable = self['NdTable_ValueTable'][:octetCount]\n        unpackedNdTable = [(byte >> shift) & 0b11 for byte in six.iterbytes(packedNdTable) for shift in (0, 2, 4, 6)]\n        for key in properties:\n            ndEntry = unpackedNdTable[properties[key]['order']]\n            properties[key]['null_default'] = bool(ndEntry & 0b01)\n            properties[key]['inherited_default'] = bool(ndEntry & 0b10)\n\n        return octetCount\n\n    @staticmethod\n    def __isNonNullNumber(prop):\n        return prop['type'] & ~Inherited in CIM_NUMBER_TYPES and not prop['null_default']\n\n    def getValues(self, properties):\n        heap = self[\"InstanceHeap\"][\"HeapItem\"]\n        valueTableOff = self.__processNdTable(properties)\n        valueTable = self['NdTable_ValueTable'][valueTableOff:]\n        sorted_props = sorted(list(properties.keys()), key=lambda k: properties[k]['order'])\n        for key in sorted_props:\n            pType = properties[key]['type'] & (~(CIM_ARRAY_FLAG|Inherited))\n            if properties[key]['type'] & CIM_ARRAY_FLAG:\n                unpackStr = HEAPREF[:-2]\n            else:\n                unpackStr = CIM_TYPES_REF[pType][:-2]\n            dataSize = calcsize(unpackStr)\n            try:\n                itemValue = unpack(unpackStr, valueTable[:dataSize])[0]\n            except:\n                LOG.error(\"getValues: Error Unpacking!\")\n                itemValue = 0xffffffff\n\n            # if itemValue == 0, default value remains\n            if itemValue != 0 or self.__isNonNullNumber(properties[key]):\n                value = ENCODED_VALUE.getValue( properties[key]['type'], itemValue, heap)\n                properties[key]['value'] = value\n            # is the value set valid or should we clear it? ( if not inherited )\n            elif properties[key]['inherited'] == 0:\n                properties[key]['value'] = None\n            valueTable = valueTable[dataSize:]\n        return properties",
  "class CLASS_TYPE(Structure):\n    structure = (\n        ('ParentClass', ':', PARENT_CLASS),\n        ('CurrentClass', ':', CURRENT_CLASS),\n    )",
  "class OBJECT_BLOCK(Structure):\n    commonHdr = (\n        ('ObjectFlags', OBJECT_FLAGS),\n    )\n\n    decoration = (\n        ('Decoration', ':', DECORATION),\n    )\n\n    instanceType = (\n        ('InstanceType', ':', INSTANCE_TYPE),\n    )\n\n    classType = (\n        ('ClassType', ':', CLASS_TYPE),\n    )\n    def __init__(self, data = None, alignment = 0):\n        Structure.__init__(self, data, alignment)\n        self.ctParent  = None\n        self.ctCurrent = None\n\n        if data is not None:\n            self.structure = ()\n            if ord(data[0:1]) & 0x4:\n                # WMIO - 2.2.6 - 0x04 If this flag is set, the object has a Decoration block.\n                self.structure += self.decoration\n            if ord(data[0:1]) & 0x01:\n                # The object is a CIM class. \n                self.structure += self.classType\n            else:\n                self.structure += self.instanceType\n\n            self.fromString(data)\n        else:\n            self.data = None\n\n    def isInstance(self):\n        if self['ObjectFlags'] & 0x01:\n            return False\n        return True\n\n    def printClass(self, pClass, cInstance = None):\n        qualifiers = pClass.getQualifiers()\n\n        for qualifier in qualifiers:\n            print(\"[%s]\" % qualifier)\n\n        className = pClass.getClassName()\n\n        print(\"class %s \\n{\" % className)\n\n        properties = pClass.getProperties()\n        if cInstance is not None:\n            properties = cInstance.getValues(properties)\n\n        for pName in properties:\n            #if property['inherited'] == 0:\n                qualifiers = properties[pName]['qualifiers']\n                for qName in qualifiers:\n                    if qName != 'CIMTYPE':\n                        print('\\t[%s(%s)]' % (qName, qualifiers[qName]))\n                print(\"\\t%s %s\" % (properties[pName]['stype'], properties[pName]['name']), end=' ')\n                if properties[pName]['value'] is not None:\n                    if properties[pName]['type'] == CIM_TYPE_ENUM.CIM_TYPE_OBJECT.value:\n                        print('= IWbemClassObject\\n')\n                    elif properties[pName]['type'] == CIM_TYPE_ENUM.CIM_ARRAY_OBJECT.value:\n                        if properties[pName]['value'] == 0:\n                            print('= %s\\n' % properties[pName]['value'])\n                        else:\n                            print('= %s\\n' % list('IWbemClassObject' for _ in range(len(properties[pName]['value']))))\n                    else:\n                        print('= %s\\n' % properties[pName]['value'])\n                else:\n                    print('\\n')\n\n        print() \n        methods = pClass.getMethods()\n        for methodName in methods:\n            for qualifier in methods[methodName]['qualifiers']:\n                print('\\t[%s]' % qualifier)\n\n            if methods[methodName]['InParams'] is None and methods[methodName]['OutParams'] is None: \n                print('\\t%s %s();\\n' % ('void', methodName))\n            if methods[methodName]['InParams'] is None and len(methods[methodName]['OutParams']) == 1:\n                print('\\t%s %s();\\n' % (methods[methodName]['OutParams']['ReturnValue']['stype'], methodName))\n            else:\n                returnValue = b''\n                if methods[methodName]['OutParams'] is not None:\n                    # Search the Return Value\n                    #returnValue = (item for item in method['OutParams'] if item[\"name\"] == \"ReturnValue\").next()\n                    if 'ReturnValue' in methods[methodName]['OutParams']:\n                        returnValue = methods[methodName]['OutParams']['ReturnValue']['stype']\n \n                print('\\t%s %s(\\n' % (returnValue, methodName), end=' ')\n                if methods[methodName]['InParams'] is not None:\n                    for pName  in methods[methodName]['InParams']:\n                        print('\\t\\t[in]    %s %s,' % (methods[methodName]['InParams'][pName]['stype'], pName))\n\n                if methods[methodName]['OutParams'] is not None:\n                    for pName in methods[methodName]['OutParams']:\n                        if pName != 'ReturnValue':\n                            print('\\t\\t[out]    %s %s,' % (methods[methodName]['OutParams'][pName]['stype'], pName))\n\n                print('\\t);\\n')\n\n        print(\"}\")\n\n    def parseClass(self, pClass, cInstance = None):\n        classDict = OrderedDict()\n        classDict['name'] = pClass.getClassName()\n        classDict['qualifiers'] = pClass.getQualifiers()\n        classDict['properties'] = pClass.getProperties()\n        classDict['methods'] = pClass.getMethods()\n        if cInstance is not None:\n            classDict['values'] = cInstance.getValues(classDict['properties'])\n        else:\n            classDict['values'] = None\n\n        return classDict\n\n    def parseObject(self):\n        if (self['ObjectFlags'] & 0x01) == 0:\n            # instance\n            ctCurrent = self['InstanceType']['CurrentClass']\n            currentName = ctCurrent.getClassName()\n            if currentName is not None:\n                self.ctCurrent = self.parseClass(ctCurrent, self['InstanceType'])\n            return\n        else: \n            ctParent = self['ClassType']['ParentClass']\n            ctCurrent = self['ClassType']['CurrentClass']\n\n            parentName = ctParent.getClassName()\n            if parentName is not None:\n                self.ctParent = self.parseClass(ctParent)\n\n            currentName = ctCurrent.getClassName()\n            if currentName is not None:\n                self.ctCurrent = self.parseClass(ctCurrent)\n\n    def printInformation(self):\n        # First off, do we have a class?\n        if (self['ObjectFlags'] & 0x01) == 0:\n            # instance\n            ctCurrent = self['InstanceType']['CurrentClass']\n            currentName = ctCurrent.getClassName()\n            if currentName is not None:\n                self.printClass(ctCurrent, self['InstanceType'])\n            return\n        else: \n            ctParent = self['ClassType']['ParentClass']\n            ctCurrent = self['ClassType']['CurrentClass']\n\n            parentName = ctParent.getClassName()\n            if parentName is not None:\n                self.printClass(ctParent)\n\n            currentName = ctCurrent.getClassName()\n            if currentName is not None:\n                self.printClass(ctCurrent)",
  "class METHOD_SIGNATURE_BLOCK(Structure):\n    commonHdr = (\n        ('EncodingLength', ENCODING_LENGTH),\n    )\n    tail = (\n        ('_ObjectBlock', '_-ObjectBlock', 'self[\"EncodingLength\"]'),\n        ('ObjectBlock', ':', OBJECT_BLOCK),\n    )\n    def __init__(self, data = None, alignment = 0):\n        Structure.__init__(self, data, alignment)\n        if data is not None:\n            self.fromString(data)\n            if self['EncodingLength'] > 0:\n                self.structure = ()\n                self.structure += self.tail\n            self.fromString(data)\n        else:\n            self.data = None",
  "class ENCODING_UNIT(Structure):\n    structure = (\n        ('Signature', SIGNATURE),\n        ('ObjectEncodingLength', OBJECT_ENCODING_LENGTH),\n        ('_ObjectBlock', '_-ObjectBlock', 'self[\"ObjectEncodingLength\"]'),\n        ('ObjectBlock', ':', OBJECT_BLOCK),\n    )",
  "class UCHAR_ARRAY_CV(NDRUniConformantVaryingArray):\n    item = 'c'",
  "class PUCHAR_ARRAY_CV(NDRPOINTER):\n    referent = (\n        ('Data', UCHAR_ARRAY_CV),\n    )",
  "class PMInterfacePointer_ARRAY_CV(NDRUniConformantVaryingArray):\n    item = PMInterfacePointer",
  "class ULONG_ARRAY(NDRUniConformantArray):\n    item = ULONG",
  "class PULONG_ARRAY(NDRPOINTER):\n    referent = (\n        ('Data', ULONG_ARRAY),\n    )",
  "class WBEM_CHANGE_FLAG_TYPE(NDRENUM):\n    # [v1_enum] type\n    structure = (\n        ('Data', '<L'),\n    )\n    class enumItems(Enum):\n        WBEM_FLAG_CREATE_OR_UPDATE  = 0x00\n        WBEM_FLAG_UPDATE_ONLY       = 0x01\n        WBEM_FLAG_CREATE_ONLY       = 0x02\n        WBEM_FLAG_UPDATE_SAFE_MODE  = 0x20\n        WBEM_FLAG_UPDATE_FORCE_MODE = 0x40",
  "class WBEM_GENERIC_FLAG_TYPE(NDRENUM):\n    # [v1_enum] type\n    structure = (\n        ('Data', '<L'),\n    )\n    class enumItems(Enum):\n        WBEM_FLAG_RETURN_WBEM_COMPLETE   = 0x00\n        WBEM_FLAG_RETURN_IMMEDIATELY     = 0x10\n        WBEM_FLAG_FORWARD_ONLY           = 0x20\n        WBEM_FLAG_NO_ERROR_OBJECT        = 0x40\n        WBEM_FLAG_SEND_STATUS            = 0x80\n        WBEM_FLAG_ENSURE_LOCATABLE       = 0x100\n        WBEM_FLAG_DIRECT_READ            = 0x200\n        WBEM_MASK_RESERVED_FLAGS         = 0x1F000\n        WBEM_FLAG_USE_AMENDED_QUALIFIERS = 0x20000\n        WBEM_FLAG_STRONG_VALIDATION      = 0x100000",
  "class WBEM_STATUS_TYPE(NDRENUM):\n    class enumItems(Enum):\n        WBEM_STATUS_COMPLETE     = 0x00\n        WBEM_STATUS_REQUIREMENTS = 0x01\n        WBEM_STATUS_PROGRESS     = 0x02",
  "class WBEM_TIMEOUT_TYPE(NDRENUM):\n    # [v1_enum] type\n    structure = (\n        ('Data', '<L'),\n    )\n    class enumItems(Enum):\n        WBEM_NO_WAIT  = 0x00000000\n        WBEM_INFINITE = 0xFFFFFFFF",
  "class WBEM_QUERY_FLAG_TYPE(NDRENUM):\n    # [v1_enum] type\n    structure = (\n        ('Data', '<L'),\n    )\n    class enumItems(Enum):\n        WBEM_FLAG_DEEP      = 0x00000000\n        WBEM_FLAG_SHALLOW   = 0x00000001\n        WBEM_FLAG_PROTOTYPE = 0x00000002",
  "class WBEM_BACKUP_RESTORE_FLAGS(NDRENUM):\n    # [v1_enum] type\n    structure = (\n        ('Data', '<L'),\n    )\n    class enumItems(Enum):\n        WBEM_FLAG_BACKUP_RESTORE_FORCE_SHUTDOWN = 0x00000001",
  "class WBEMSTATUS(NDRENUM):\n    # [v1_enum] type\n    structure = (\n        ('Data', '<L'),\n    )\n    class enumItems(Enum):\n        WBEM_S_NO_ERROR                      = 0x00000000\n        WBEM_S_FALSE                         = 0x00000001\n        WBEM_S_TIMEDOUT                      = 0x00040004\n        WBEM_S_NEW_STYLE                     = 0x000400FF\n        WBEM_S_PARTIAL_RESULTS               = 0x00040010\n        WBEM_E_FAILED                        = 0x80041001\n        WBEM_E_NOT_FOUND                     = 0x80041002\n        WBEM_E_ACCESS_DENIED                 = 0x80041003\n        WBEM_E_PROVIDER_FAILURE              = 0x80041004\n        WBEM_E_TYPE_MISMATCH                 = 0x80041005\n        WBEM_E_OUT_OF_MEMORY                 = 0x80041006\n        WBEM_E_INVALID_CONTEXT               = 0x80041007\n        WBEM_E_INVALID_PARAMETER             = 0x80041008\n        WBEM_E_NOT_AVAILABLE                 = 0x80041009\n        WBEM_E_CRITICAL_ERROR                = 0x8004100a\n        WBEM_E_NOT_SUPPORTED                 = 0x8004100c\n        WBEM_E_PROVIDER_NOT_FOUND            = 0x80041011\n        WBEM_E_INVALID_PROVIDER_REGISTRATION = 0x80041012\n        WBEM_E_PROVIDER_LOAD_FAILURE         = 0x80041013\n        WBEM_E_INITIALIZATION_FAILURE        = 0x80041014\n        WBEM_E_TRANSPORT_FAILURE             = 0x80041015\n        WBEM_E_INVALID_OPERATION             = 0x80041016\n        WBEM_E_ALREADY_EXISTS                = 0x80041019\n        WBEM_E_UNEXPECTED                    = 0x8004101d\n        WBEM_E_INCOMPLETE_CLASS              = 0x80041020\n        WBEM_E_SHUTTING_DOWN                 = 0x80041033\n        E_NOTIMPL                            = 0x80004001\n        WBEM_E_INVALID_SUPERCLASS            = 0x8004100D\n        WBEM_E_INVALID_NAMESPACE             = 0x8004100E\n        WBEM_E_INVALID_OBJECT                = 0x8004100F\n        WBEM_E_INVALID_CLASS                 = 0x80041010\n        WBEM_E_INVALID_QUERY                 = 0x80041017\n        WBEM_E_INVALID_QUERY_TYPE            = 0x80041018\n        WBEM_E_PROVIDER_NOT_CAPABLE          = 0x80041024\n        WBEM_E_CLASS_HAS_CHILDREN            = 0x80041025\n        WBEM_E_CLASS_HAS_INSTANCES           = 0x80041026\n        WBEM_E_ILLEGAL_NULL                  = 0x80041028\n        WBEM_E_INVALID_CIM_TYPE              = 0x8004102D\n        WBEM_E_INVALID_METHOD                = 0x8004102E\n        WBEM_E_INVALID_METHOD_PARAMETERS     = 0x8004102F\n        WBEM_E_INVALID_PROPERTY              = 0x80041031\n        WBEM_E_CALL_CANCELLED                = 0x80041032\n        WBEM_E_INVALID_OBJECT_PATH           = 0x8004103A\n        WBEM_E_OUT_OF_DISK_SPACE             = 0x8004103B\n        WBEM_E_UNSUPPORTED_PUT_EXTENSION     = 0x8004103D\n        WBEM_E_QUOTA_VIOLATION               = 0x8004106c\n        WBEM_E_SERVER_TOO_BUSY               = 0x80041045\n        WBEM_E_METHOD_NOT_IMPLEMENTED        = 0x80041055\n        WBEM_E_METHOD_DISABLED               = 0x80041056\n        WBEM_E_UNPARSABLE_QUERY              = 0x80041058\n        WBEM_E_NOT_EVENT_CLASS               = 0x80041059\n        WBEM_E_MISSING_GROUP_WITHIN          = 0x8004105A\n        WBEM_E_MISSING_AGGREGATION_LIST      = 0x8004105B\n        WBEM_E_PROPERTY_NOT_AN_OBJECT        = 0x8004105c\n        WBEM_E_AGGREGATING_BY_OBJECT         = 0x8004105d\n        WBEM_E_BACKUP_RESTORE_WINMGMT_RUNNING= 0x80041060\n        WBEM_E_QUEUE_OVERFLOW                = 0x80041061\n        WBEM_E_PRIVILEGE_NOT_HELD            = 0x80041062\n        WBEM_E_INVALID_OPERATOR              = 0x80041063\n        WBEM_E_CANNOT_BE_ABSTRACT            = 0x80041065\n        WBEM_E_AMENDED_OBJECT                = 0x80041066\n        WBEM_E_VETO_PUT                      = 0x8004107A\n        WBEM_E_PROVIDER_SUSPENDED            = 0x80041081\n        WBEM_E_ENCRYPTED_CONNECTION_REQUIRED = 0x80041087\n        WBEM_E_PROVIDER_TIMED_OUT            = 0x80041088\n        WBEM_E_NO_KEY                        = 0x80041089\n        WBEM_E_PROVIDER_DISABLED             = 0x8004108a\n        WBEM_E_REGISTRATION_TOO_BROAD        = 0x80042001\n        WBEM_E_REGISTRATION_TOO_PRECISE      = 0x80042002",
  "class WBEM_CONNECT_OPTIONS(NDRENUM):\n    # [v1_enum] type\n    structure = (\n        ('Data', '<L'),\n    )\n    class enumItems(Enum):\n        WBEM_FLAG_CONNECT_REPOSITORY_ONLY = 0x40\n        WBEM_FLAG_CONNECT_PROVIDERS       = 0x100",
  "class ObjectArray(Structure):\n    structure = (\n        ('dwByteOrdering', '<L=0'),\n        ('abSignature', '8s=\"WBEMDATA\"'),\n        ('dwSizeOfHeader1', '<L=0x1a'),\n        ('dwDataSize1', '<L=0'),\n        ('dwFlags', '<L=0'),\n        ('bVersion', 'B=1'),\n        ('bPacketType', 'B=0'),\n        ('dwSizeOfHeader2', '<L=8'),\n        ('dwDataSize2', '<L', 'len(self[\"wbemObjects\"])+12'),\n        ('dwSizeOfHeader3', '<L=12'),\n        ('dwDataSize3', '<L', 'len(self[\"dwDataSize2\"])-12)'),\n        ('dwNumObjects', '<L=0'),\n        ('_wbemObjects', '_-wbemObjects', 'self[\"dwDataSize3\"]'),\n        ('wbemObjects', ':'),\n    )",
  "class WBEM_DATAPACKET_OBJECT(Structure):\n    structure = (\n        ('dwSizeOfHeader', '<L=9'),\n        ('dwSizeOfData', '<L','len(self[\"Object\"])'),\n        ('bObjectType', 'B=0'),\n        ('_Object', '_-Object', 'self[\"dwSizeOfData\"]'),\n        ('Object', ':'),\n    )",
  "class WBEMOBJECT_CLASS(Structure):\n    structure = (\n        ('dwSizeOfHeader', '<L=8'),\n        ('dwSizeOfData', '<L','len(self[\"ObjectData\"])'),\n        ('_ObjectData', '_-ObjectData', 'self[\"dwSizeOfData\"]'),\n        ('ObjectData', ':'),\n    )",
  "class WBEMOBJECT_INSTANCE(Structure):\n    structure = (\n        ('dwSizeOfHeader', '<L=0x18'),\n        ('dwSizeOfData', '<L','len(self[\"ObjectData\"])'),\n        ('classID', '16s=b\"\\x00\"*16'),\n        ('_ObjectData', '_-ObjectData', 'self[\"dwSizeOfData\"]'),\n        ('ObjectData', ':'),\n    )",
  "class WBEMOBJECT_INSTANCE_NOCLASS(Structure):\n    structure = (\n        ('dwSizeOfHeader', '<L=0x18'),\n        ('dwSizeOfData', '<L','len(self[\"ObjectData\"])'),\n        ('classID', '16s=b\"\\x00\"*16'),\n        ('_ObjectData', '_-ObjectData', 'self[\"dwSizeOfData\"]'),\n        ('ObjectData', ':'),\n    )",
  "class WBEM_REFRESHED_OBJECT(NDRSTRUCT):\n    structure = (\n        ('m_lRequestId', LONG),\n        ('m_lBlobType', LONG),\n        ('m_lBlobLength', LONG),\n        ('m_pBlob', BYTE_ARRAY),\n    )",
  "class WBEM_REFRESHED_OBJECT_ARRAY(NDRUniConformantArray):\n    item = WBEM_REFRESHED_OBJECT",
  "class PWBEM_REFRESHED_OBJECT_ARRAY(NDRPOINTER):\n    referent = (\n        ('Data', WBEM_REFRESHED_OBJECT_ARRAY),\n    )",
  "class WBEM_INSTANCE_BLOB(Structure):\n    structure = (\n        ('Version', '<L=0x1'),\n        ('numObjects', '<L=0'),\n        ('Objects', ':'),\n    )",
  "class WBEM_INSTANCE_BLOB_TYPE(NDRENUM):\n    # [v1_enum] type\n    structure = (\n        ('Data', '<L'),\n    )\n    class enumItems(Enum):\n        WBEM_FLAG_CONNECT_REPOSITORY_ONLY = 0x40\n        WBEM_FLAG_CONNECT_PROVIDERS       = 0x100",
  "class _WBEM_REFRESH_INFO_NON_HIPERF(NDRSTRUCT):\n    structure = (\n        ('m_wszNamespace', LPWSTR),\n        ('m_pTemplate', PMInterfacePointer),\n    )",
  "class _WBEM_REFRESH_INFO_REMOTE(NDRSTRUCT):\n    structure = (\n        ('m_pRefresher', PMInterfacePointer),\n        ('m_pTemplate', PMInterfacePointer),\n        ('m_Guid', GUID),\n    )",
  "class WBEM_REFRESH_TYPE(NDRENUM):\n    class enumItems(Enum):\n        WBEM_REFRESH_TYPE_INVALID       = 0\n        WBEM_REFRESH_TYPE_REMOTE        = 3\n        WBEM_REFRESH_TYPE_NON_HIPERF    = 6",
  "class _WBEM_REFRESH_INFO_UNION(NDRUNION):\n    commonHdr = (\n        ('tag', LONG),\n    )\n    union = {\n        WBEM_REFRESH_TYPE.WBEM_REFRESH_TYPE_REMOTE    : ('m_Remote', _WBEM_REFRESH_INFO_REMOTE),\n        WBEM_REFRESH_TYPE.WBEM_REFRESH_TYPE_NON_HIPERF: ('m_NonHiPerf', _WBEM_REFRESH_INFO_NON_HIPERF),\n        WBEM_REFRESH_TYPE.WBEM_REFRESH_TYPE_INVALID   : ('m_hres', HRESULT),\n    }",
  "class _WBEM_REFRESH_INFO(NDRSTRUCT):\n    structure = (\n        ('m_lType', LONG),\n        ('m_Info', _WBEM_REFRESH_INFO_UNION),\n        ('m_lCancelId', LONG),\n    )",
  "class _WBEM_REFRESHER_ID(NDRSTRUCT):\n    structure = (\n        ('m_szMachineName', LPCSTR),\n        ('m_dwProcessId', DWORD),\n        ('m_guidRefresherId', GUID),\n    )",
  "class _WBEM_RECONNECT_INFO(NDRSTRUCT):\n    structure = (\n        ('m_lType', LPCSTR),\n        ('m_pwcsPath', LPWSTR),\n    )",
  "class _WBEM_RECONNECT_INFO_ARRAY(NDRUniConformantArray):\n    item = _WBEM_RECONNECT_INFO",
  "class _WBEM_RECONNECT_RESULTS(NDRSTRUCT):\n    structure = (\n        ('m_lId', LONG),\n        ('m_hr', HRESULT),\n    )",
  "class _WBEM_RECONNECT_RESULTS_ARRAY(NDRUniConformantArray):\n    item = _WBEM_RECONNECT_INFO",
  "class IWbemLevel1Login_EstablishPosition(DCOMCALL):\n    opnum = 3\n    structure = (\n       ('reserved1', LPWSTR),\n       ('reserved2', DWORD),\n    )",
  "class IWbemLevel1Login_EstablishPositionResponse(DCOMANSWER):\n    structure = (\n       ('LocaleVersion', DWORD),\n       ('ErrorCode', error_status_t),\n    )",
  "class IWbemLevel1Login_RequestChallenge(DCOMCALL):\n    opnum = 4\n    structure = (\n       ('reserved1', LPWSTR),\n       ('reserved2', LPWSTR),\n    )",
  "class IWbemLevel1Login_RequestChallengeResponse(DCOMANSWER):\n    structure = (\n       ('reserved3', UCHAR_ARRAY_CV),\n       ('ErrorCode', error_status_t),\n    )",
  "class IWbemLevel1Login_WBEMLogin(DCOMCALL):\n    opnum = 5\n    structure = (\n       ('reserved1', LPWSTR),\n       ('reserved2', PUCHAR_ARRAY_CV),\n       ('reserved3', LONG),\n       ('reserved4', PMInterfacePointer),\n    )",
  "class IWbemLevel1Login_WBEMLoginResponse(DCOMANSWER):\n    structure = (\n       ('reserved5', UCHAR_ARRAY_CV),\n       ('ErrorCode', error_status_t),\n    )",
  "class IWbemLevel1Login_NTLMLogin(DCOMCALL):\n    opnum = 6\n    structure = (\n       ('wszNetworkResource', LPWSTR),\n       ('wszPreferredLocale', LPWSTR),\n       ('lFlags', LONG),\n       ('pCtx', PMInterfacePointer),\n    )",
  "class IWbemLevel1Login_NTLMLoginResponse(DCOMANSWER):\n    structure = (\n       ('ppNamespace', PMInterfacePointer),\n       ('ErrorCode', error_status_t),\n    )",
  "class IWbemObjectSink_Indicate(DCOMCALL):\n    opnum = 3\n    structure = (\n       ('lObjectCount', LONG),\n       ('apObjArray', PMInterfacePointer_ARRAY),\n    )",
  "class IWbemObjectSink_IndicateResponse(DCOMANSWER):\n    structure = (\n       ('ErrorCode', error_status_t),\n    )",
  "class IWbemObjectSink_SetStatus(DCOMCALL):\n    opnum = 4\n    structure = (\n       ('lFlags', LONG),\n       ('hResult', HRESULT),\n       ('strParam', BSTR),\n       ('pObjParam', PMInterfacePointer),\n    )",
  "class IWbemObjectSink_SetStatusResponse(DCOMANSWER):\n    structure = (\n       ('ErrorCode', error_status_t),\n    )",
  "class IWbemServices_OpenNamespace(DCOMCALL):\n    opnum = 3\n    structure = (\n       ('strNamespace', BSTR),\n       ('lFlags', LONG),\n       ('pCtx', PMInterfacePointer),\n       ('ppWorkingNamespace', PMInterfacePointer),\n       ('ppResult', PMInterfacePointer),\n    )",
  "class IWbemServices_OpenNamespaceResponse(DCOMANSWER):\n    structure = (\n       ('ppWorkingNamespace', PPMInterfacePointer),\n       ('ppResult', PPMInterfacePointer),\n       ('ErrorCode', error_status_t),\n    )",
  "class IWbemServices_CancelAsyncCall(DCOMCALL):\n    opnum = 4\n    structure = (\n       ('IWbemObjectSink', PMInterfacePointer),\n    )",
  "class IWbemServices_CancelAsyncCallResponse(DCOMANSWER):\n    structure = (\n       ('ErrorCode', error_status_t),\n    )",
  "class IWbemServices_QueryObjectSink(DCOMCALL):\n    opnum = 5\n    structure = (\n       ('lFlags', LONG),\n    )",
  "class IWbemServices_QueryObjectSinkResponse(DCOMANSWER):\n    structure = (\n       ('ppResponseHandler', PMInterfacePointer),\n       ('ErrorCode', error_status_t),\n    )",
  "class IWbemServices_GetObject(DCOMCALL):\n    opnum = 6\n    structure = (\n       ('strObjectPath', BSTR),\n       ('lFlags', LONG),\n       ('pCtx', PMInterfacePointer),\n       ('ppObject', PMInterfacePointer),\n       ('ppCallResult', PMInterfacePointer),\n    )",
  "class IWbemServices_GetObjectResponse(DCOMANSWER):\n    structure = (\n       ('ppObject', PPMInterfacePointer),\n       ('ppCallResult', PPMInterfacePointer),\n       ('ErrorCode', error_status_t),\n    )",
  "class IWbemServices_GetObjectAsync(DCOMCALL):\n    opnum = 7\n    structure = (\n       ('strObjectPath', BSTR),\n       ('lFlags', LONG),\n       ('pCtx', PMInterfacePointer),\n       ('pResponseHandler', PMInterfacePointer),\n    )",
  "class IWbemServices_GetObjectAsyncResponse(DCOMANSWER):\n    structure = (\n       ('ErrorCode', error_status_t),\n    )",
  "class IWbemServices_PutClass(DCOMCALL):\n    opnum = 8\n    structure = (\n       ('pObject', PMInterfacePointer),\n       ('lFlags', LONG),\n       ('pCtx', PMInterfacePointer),\n       ('pResponseHandler', PMInterfacePointer),\n       ('ppCallResult', PMInterfacePointer),\n    )",
  "class IWbemServices_PutClassResponse(DCOMANSWER):\n    structure = (\n       ('ppCallResult', PPMInterfacePointer),\n       ('ErrorCode', error_status_t),\n    )",
  "class IWbemServices_PutClassAsync(DCOMCALL):\n    opnum = 9\n    structure = (\n       ('pObject', PMInterfacePointer),\n       ('lFlags', LONG),\n       ('pCtx', PMInterfacePointer),\n       ('pResponseHandler', PMInterfacePointer),\n    )",
  "class IWbemServices_PutClassAsyncResponse(DCOMANSWER):\n    structure = (\n       ('ErrorCode', error_status_t),\n    )",
  "class IWbemServices_DeleteClass(DCOMCALL):\n    opnum = 10\n    structure = (\n       ('strClass', BSTR),\n       ('lFlags', LONG),\n       ('pCtx', PMInterfacePointer),\n       ('ppCallResult', PMInterfacePointer),\n    )",
  "class IWbemServices_DeleteClassResponse(DCOMANSWER):\n    structure = (\n       ('ppCallResult', PPMInterfacePointer),\n       ('ErrorCode', error_status_t),\n    )",
  "class IWbemServices_DeleteClassAsync(DCOMCALL):\n    opnum = 11\n    structure = (\n       ('strClass', BSTR),\n       ('lFlags', LONG),\n       ('pCtx', PMInterfacePointer),\n       ('pResponseHandler', PMInterfacePointer),\n    )",
  "class IWbemServices_DeleteClassAsyncResponse(DCOMANSWER):\n    structure = (\n       ('ErrorCode', error_status_t),\n    )",
  "class IWbemServices_CreateClassEnum(DCOMCALL):\n    opnum = 12\n    structure = (\n       ('strSuperClass', BSTR),\n       ('lFlags', LONG),\n       ('pCtx', PMInterfacePointer),\n    )",
  "class IWbemServices_CreateClassEnumResponse(DCOMANSWER):\n    structure = (\n       ('ppEnum', PMInterfacePointer),\n       ('ErrorCode', error_status_t),\n    )",
  "class IWbemServices_CreateClassEnumAsync(DCOMCALL):\n    opnum = 13\n    structure = (\n       ('strSuperClass', BSTR),\n       ('lFlags', LONG),\n       ('pCtx', PMInterfacePointer),\n       ('pResponseHandler', PMInterfacePointer),\n    )",
  "class IWbemServices_CreateClassEnumAsyncResponse(DCOMANSWER):\n    structure = (\n       ('ErrorCode', error_status_t),\n    )",
  "class IWbemServices_PutInstance(DCOMCALL):\n    opnum = 14\n    structure = (\n       ('pInst', PMInterfacePointer),\n       ('lFlags', LONG),\n       ('pCtx', PMInterfacePointer),\n       ('ppCallResult', PMInterfacePointer),\n    )",
  "class IWbemServices_PutInstanceResponse(DCOMANSWER):\n    structure = (\n       ('ppCallResult', PPMInterfacePointer),\n       ('ErrorCode', error_status_t),\n    )",
  "class IWbemServices_PutInstanceAsync(DCOMCALL):\n    opnum = 15\n    structure = (\n       ('pInst', PMInterfacePointer),\n       ('lFlags', LONG),\n       ('pCtx', PMInterfacePointer),\n       ('pResponseHandler', PMInterfacePointer),\n    )",
  "class IWbemServices_PutInstanceAsyncResponse(DCOMANSWER):\n    structure = (\n       ('ErrorCode', error_status_t),\n    )",
  "class IWbemServices_DeleteInstance(DCOMCALL):\n    opnum = 16\n    structure = (\n       ('strObjectPath', BSTR),\n       ('lFlags', LONG),\n       ('pCtx', PMInterfacePointer),\n       ('ppCallResult', PMInterfacePointer),\n    )",
  "class IWbemServices_DeleteInstanceResponse(DCOMANSWER):\n    structure = (\n       ('ppCallResult', PPMInterfacePointer),\n       ('ErrorCode', error_status_t),\n    )",
  "class IWbemServices_DeleteInstanceAsync(DCOMCALL):\n    opnum = 17\n    structure = (\n       ('strObjectPath', BSTR),\n       ('lFlags', LONG),\n       ('pCtx', PMInterfacePointer),\n       ('pResponseHandler', PMInterfacePointer),\n    )",
  "class IWbemServices_DeleteInstanceAsyncResponse(DCOMANSWER):\n    structure = (\n       ('ErrorCode', error_status_t),\n    )",
  "class IWbemServices_CreateInstanceEnum(DCOMCALL):\n    opnum = 18\n    structure = (\n       ('strSuperClass', BSTR),\n       ('lFlags', LONG),\n       ('pCtx', PMInterfacePointer),\n    )",
  "class IWbemServices_CreateInstanceEnumResponse(DCOMANSWER):\n    structure = (\n       ('ppEnum', PMInterfacePointer),\n       ('ErrorCode', error_status_t),\n    )",
  "class IWbemServices_CreateInstanceEnumAsync(DCOMCALL):\n    opnum = 19\n    structure = (\n       ('strSuperClass', BSTR),\n       ('lFlags', LONG),\n       ('pCtx', PMInterfacePointer),\n       ('pResponseHandler', PMInterfacePointer),\n    )",
  "class IWbemServices_CreateInstanceEnumAsyncResponse(DCOMANSWER):\n    structure = (\n       ('ErrorCode', error_status_t),\n    )",
  "class IWbemServices_ExecQuery(DCOMCALL):\n    opnum = 20\n    structure = (\n       ('strQueryLanguage', BSTR),\n       ('strQuery', BSTR),\n       ('lFlags', LONG),\n       ('pCtx', PMInterfacePointer),\n    )",
  "class IWbemServices_ExecQueryResponse(DCOMANSWER):\n    structure = (\n       ('ppEnum', PMInterfacePointer),\n       ('ErrorCode', error_status_t),\n    )",
  "class IWbemServices_ExecQueryAsync(DCOMCALL):\n    opnum = 21\n    structure = (\n       ('strQueryLanguage', BSTR),\n       ('strQuery', BSTR),\n       ('lFlags', LONG),\n       ('pCtx', PMInterfacePointer),\n       ('pResponseHandler', PMInterfacePointer),\n    )",
  "class IWbemServices_ExecQueryAsyncResponse(DCOMANSWER):\n    structure = (\n       ('ErrorCode', error_status_t),\n    )",
  "class IWbemServices_ExecNotificationQuery(DCOMCALL):\n    opnum = 22\n    structure = (\n       ('strQueryLanguage', BSTR),\n       ('strQuery', BSTR),\n       ('lFlags', LONG),\n       ('pCtx', PMInterfacePointer),\n    )",
  "class IWbemServices_ExecNotificationQueryResponse(DCOMANSWER):\n    structure = (\n       ('ppEnum', PMInterfacePointer),\n       ('ErrorCode', error_status_t),\n    )",
  "class IWbemServices_ExecNotificationQueryAsync(DCOMCALL):\n    opnum = 23\n    structure = (\n       ('strQueryLanguage', BSTR),\n       ('strQuery', BSTR),\n       ('lFlags', LONG),\n       ('pCtx', PMInterfacePointer),\n       ('pResponseHandler', PMInterfacePointer),\n    )",
  "class IWbemServices_ExecNotificationQueryAsyncResponse(DCOMANSWER):\n    structure = (\n       ('ErrorCode', error_status_t),\n    )",
  "class IWbemServices_ExecMethod(DCOMCALL):\n    opnum = 24\n    structure = (\n       ('strObjectPath', BSTR),\n       ('strMethodName', BSTR),\n       ('lFlags', LONG),\n       ('pCtx', PMInterfacePointer),\n       ('pInParams', PMInterfacePointer),\n       ('ppOutParams', PPMInterfacePointer),\n       ('ppCallResult', PPMInterfacePointer),\n    )",
  "class IWbemServices_ExecMethodResponse(DCOMANSWER):\n    structure = (\n       ('ppOutParams', PPMInterfacePointer),\n       ('ppCallResult', PPMInterfacePointer),\n       ('ErrorCode', error_status_t),\n    )",
  "class IWbemServices_ExecMethodAsync(DCOMCALL):\n    opnum = 25\n    structure = (\n       ('strObjectPath', BSTR),\n       ('strMethodName', BSTR),\n       ('lFlags', LONG),\n       ('pCtx', PMInterfacePointer),\n       ('pInParams', PMInterfacePointer),\n       ('pResponseHandler', PMInterfacePointer),\n    )",
  "class IWbemServices_ExecMethodAsyncResponse(DCOMANSWER):\n    structure = (\n       ('ErrorCode', error_status_t),\n    )",
  "class IEnumWbemClassObject_Reset(DCOMCALL):\n    opnum = 3\n    structure = (\n    )",
  "class IEnumWbemClassObject_ResetResponse(DCOMANSWER):\n    structure = (\n       ('ErrorCode', error_status_t),\n    )",
  "class IEnumWbemClassObject_Next(DCOMCALL):\n    opnum = 4\n    structure = (\n       ('lTimeout', ULONG),\n       ('uCount', ULONG),\n    )",
  "class IEnumWbemClassObject_NextResponse(DCOMANSWER):\n    structure = (\n       ('apObjects', PMInterfacePointer_ARRAY_CV),\n       ('puReturned', ULONG),\n       ('ErrorCode', error_status_t),\n    )",
  "class IEnumWbemClassObject_NextAsync(DCOMCALL):\n    opnum = 5\n    structure = (\n       ('lTimeout', LONG),\n       ('pSink', PMInterfacePointer),\n    )",
  "class IEnumWbemClassObject_NextAsyncResponse(DCOMANSWER):\n    structure = (\n       ('ErrorCode', error_status_t),\n    )",
  "class IEnumWbemClassObject_Clone(DCOMCALL):\n    opnum = 6\n    structure = (\n    )",
  "class IEnumWbemClassObject_CloneResponse(DCOMANSWER):\n    structure = (\n       ('ppEnum', PMInterfacePointer),\n       ('ErrorCode', error_status_t),\n    )",
  "class IEnumWbemClassObject_Skip(DCOMCALL):\n    opnum = 7\n    structure = (\n       ('lTimeout', LONG),\n       ('uCount', ULONG),\n    )",
  "class IEnumWbemClassObject_SkipResponse(DCOMANSWER):\n    structure = (\n       ('ErrorCode', error_status_t),\n    )",
  "class IWbemCallResult_GetResultObject(DCOMCALL):\n    opnum = 3\n    structure = (\n       ('lTimeout', LONG),\n    )",
  "class IWbemCallResult_GetResultObjectResponse(DCOMANSWER):\n    structure = (\n       ('ppResultObject', PMInterfacePointer),\n       ('ErrorCode', error_status_t),\n    )",
  "class IWbemCallResult_GetResultString(DCOMCALL):\n    opnum = 4\n    structure = (\n       ('lTimeout', LONG),\n    )",
  "class IWbemCallResult_GetResultStringResponse(DCOMANSWER):\n    structure = (\n       ('pstrResultString', BSTR),\n       ('ErrorCode', error_status_t),\n    )",
  "class IWbemCallResult_GetResultServices(DCOMCALL):\n    opnum = 5\n    structure = (\n       ('lTimeout', LONG),\n    )",
  "class IWbemCallResult_GetResultServicesResponse(DCOMANSWER):\n    structure = (\n       ('ppServices', PMInterfacePointer),\n       ('ErrorCode', error_status_t),\n    )",
  "class IWbemCallResult_GetCallStatus(DCOMCALL):\n    opnum = 6\n    structure = (\n       ('lTimeout', LONG),\n    )",
  "class IWbemCallResult_GetCallStatusResponse(DCOMANSWER):\n    structure = (\n       ('plStatus', LONG),\n       ('ErrorCode', error_status_t),\n    )",
  "class IWbemFetchSmartEnum_GetSmartEnum(DCOMCALL):\n    opnum = 3\n    structure = (\n    )",
  "class IWbemFetchSmartEnum_GetSmartEnumResponse(DCOMANSWER):\n    structure = (\n       ('ppSmartEnum', PMInterfacePointer),\n       ('ErrorCode', error_status_t),\n    )",
  "class IWbemWCOSmartEnum_Next(DCOMCALL):\n    opnum = 3\n    structure = (\n       ('proxyGUID', REFGUID),\n       ('lTimeout', LONG),\n       ('uCount', ULONG),\n    )",
  "class IWbemWCOSmartEnum_NextResponse(DCOMANSWER):\n    structure = (\n       ('puReturned', ULONG),\n       ('pdwBuffSize', ULONG),\n       ('pBuffer', BYTE_ARRAY),\n       ('ErrorCode', error_status_t),\n    )",
  "class IWbemLoginClientID_SetClientInfo(DCOMCALL):\n    opnum = 3\n    structure = (\n       ('wszClientMachine', LPWSTR),\n       ('lClientProcId', LONG),\n       ('lReserved', LONG),\n    )",
  "class IWbemLoginClientID_SetClientInfoResponse(DCOMANSWER):\n    structure = (\n       ('ErrorCode', error_status_t),\n    )",
  "class IWbemLoginHelper_SetEvent(DCOMCALL):\n    opnum = 3\n    structure = (\n       ('sEventToSet', LPCSTR),\n    )",
  "class IWbemLoginHelper_SetEventResponse(DCOMANSWER):\n    structure = (\n       ('ErrorCode', error_status_t),\n    )",
  "class IWbemBackupRestore_Backup(DCOMCALL):\n    opnum = 3\n    structure = (\n       ('strBackupToFile', LPWSTR),\n       ('lFlags', LONG),\n    )",
  "class IWbemBackupRestore_BackupResponse(DCOMANSWER):\n    structure = (\n       ('ErrorCode', error_status_t),\n    )",
  "class IWbemBackupRestore_Restore(DCOMCALL):\n    opnum = 4\n    structure = (\n       ('strRestoreFromFile', LPWSTR),\n       ('lFlags', LONG),\n    )",
  "class IWbemBackupRestore_RestoreResponse(DCOMANSWER):\n    structure = (\n       ('ErrorCode', error_status_t),\n    )",
  "class IWbemBackupRestoreEx_Pause(DCOMCALL):\n    opnum = 5\n    structure = (\n    )",
  "class IWbemBackupRestoreEx_PauseResponse(DCOMANSWER):\n    structure = (\n       ('ErrorCode', error_status_t),\n    )",
  "class IWbemBackupRestoreEx_Resume(DCOMCALL):\n    opnum = 6\n    structure = (\n    )",
  "class IWbemBackupRestoreEx_ResumeResponse(DCOMANSWER):\n    structure = (\n       ('ErrorCode', error_status_t),\n    )",
  "class IWbemRefreshingServices_AddObjectToRefresher(DCOMCALL):\n    opnum = 3\n    structure = (\n       ('pRefresherId', _WBEM_REFRESHER_ID),\n       ('wszPath', LPWSTR),\n       ('lFlags', LONG),\n       ('pContext', PMInterfacePointer),\n       ('dwClientRefrVersion', DWORD),\n    )",
  "class IWbemRefreshingServices_AddObjectToRefresherResponse(DCOMANSWER):\n    structure = (\n       ('pInfo', _WBEM_REFRESH_INFO),\n       ('pdwSvrRefrVersion', DWORD),\n       ('ErrorCode', error_status_t),\n    )",
  "class IWbemRefreshingServices_AddObjectToRefresherByTemplate(DCOMCALL):\n    opnum = 4\n    structure = (\n       ('pRefresherId', _WBEM_REFRESHER_ID),\n       ('pTemplate', PMInterfacePointer),\n       ('lFlags', LONG),\n       ('pContext', PMInterfacePointer),\n       ('dwClientRefrVersion', DWORD),\n    )",
  "class IWbemRefreshingServices_AddObjectToRefresherByTemplateResponse(DCOMANSWER):\n    structure = (\n       ('pInfo', _WBEM_REFRESH_INFO),\n       ('pdwSvrRefrVersion', DWORD),\n       ('ErrorCode', error_status_t),\n    )",
  "class IWbemRefreshingServices_AddEnumToRefresher(DCOMCALL):\n    opnum = 5\n    structure = (\n       ('pRefresherId', _WBEM_REFRESHER_ID),\n       ('wszClass', LPWSTR),\n       ('lFlags', LONG),\n       ('pContext', PMInterfacePointer),\n       ('dwClientRefrVersion', DWORD),\n    )",
  "class IWbemRefreshingServices_AddEnumToRefresherResponse(DCOMANSWER):\n    structure = (\n       ('pInfo', _WBEM_REFRESH_INFO),\n       ('pdwSvrRefrVersion', DWORD),\n       ('ErrorCode', error_status_t),\n    )",
  "class IWbemRefreshingServices_RemoveObjectFromRefresher(DCOMCALL):\n    opnum = 6\n    structure = (\n       ('pRefresherId', _WBEM_REFRESHER_ID),\n       ('lId', LONG),\n       ('lFlags', LONG),\n       ('dwClientRefrVersion', DWORD),\n    )",
  "class IWbemRefreshingServices_RemoveObjectFromRefresherResponse(DCOMANSWER):\n    structure = (\n       ('pdwSvrRefrVersion', DWORD),\n       ('ErrorCode', error_status_t),\n    )",
  "class IWbemRefreshingServices_GetRemoteRefresher(DCOMCALL):\n    opnum = 7\n    structure = (\n       ('pRefresherId', _WBEM_REFRESHER_ID),\n       ('lFlags', LONG),\n       ('dwClientRefrVersion', DWORD),\n    )",
  "class IWbemRefreshingServices_GetRemoteRefresherResponse(DCOMANSWER):\n    structure = (\n       ('ppRemRefresher', PMInterfacePointer),\n       ('pGuid', GUID),\n       ('pdwSvrRefrVersion', DWORD),\n       ('ErrorCode', error_status_t),\n    )",
  "class IWbemRefreshingServices_ReconnectRemoteRefresher(DCOMCALL):\n    opnum = 8\n    structure = (\n       ('pRefresherId', _WBEM_REFRESHER_ID),\n       ('lFlags', LONG),\n       ('lNumObjects', LONG),\n       ('dwClientRefrVersion', DWORD),\n       ('apReconnectInfo', _WBEM_RECONNECT_INFO_ARRAY),\n    )",
  "class IWbemRefreshingServices_ReconnectRemoteRefresherResponse(DCOMANSWER):\n    structure = (\n       ('apReconnectResults', _WBEM_RECONNECT_RESULTS_ARRAY),\n       ('pdwSvrRefrVersion', DWORD),\n       ('ErrorCode', error_status_t),\n    )",
  "class IWbemRemoteRefresher_RemoteRefresh(DCOMCALL):\n    opnum = 3\n    structure = (\n       ('lFlags', LONG),\n    )",
  "class IWbemRemoteRefresher_RemoteRefreshResponse(DCOMANSWER):\n    structure = (\n       ('plNumObjects', _WBEM_RECONNECT_RESULTS_ARRAY),\n       ('paObjects', PWBEM_REFRESHED_OBJECT_ARRAY),\n       ('ErrorCode', error_status_t),\n    )",
  "class IWbemRemoteRefresher_StopRefreshing(DCOMCALL):\n    opnum = 4\n    structure = (\n       ('lNumIds', LONG),\n       ('aplIds', PULONG_ARRAY),\n       ('lFlags', LONG),\n    )",
  "class IWbemRemoteRefresher_StopRefreshingResponse(DCOMANSWER):\n    structure = (\n       ('ErrorCode', error_status_t),\n    )",
  "class IWbemShutdown_Shutdown(DCOMCALL):\n    opnum = 3\n    structure = (\n       ('reserved1', LONG),\n       ('reserved2', ULONG),\n       ('reserved3', PMInterfacePointer),\n    )",
  "class IWbemShutdown_ShutdownResponse(DCOMANSWER):\n    structure = (\n       ('ErrorCode', error_status_t),\n    )",
  "class IUnsecuredApartment_CreateObjectStub(DCOMCALL):\n    opnum = 3\n    structure = (\n       ('reserved1', PMInterfacePointer),\n    )",
  "class IUnsecuredApartment_CreateObjectStubResponse(DCOMANSWER):\n    structure = (\n       ('reserved2', PMInterfacePointer),\n       ('ErrorCode', error_status_t),\n    )",
  "class IWbemUnsecuredApartment_CreateSinkStub(DCOMCALL):\n    opnum = 3\n    structure = (\n       ('reserved1', PMInterfacePointer),\n       ('reserved2', DWORD),\n       ('reserved3', LPWSTR),\n    )",
  "class IWbemUnsecuredApartment_CreateSinkStubResponse(DCOMANSWER):\n    structure = (\n       ('reserved4', PMInterfacePointer),\n       ('ErrorCode', error_status_t),\n    )",
  "def checkNullString(string):\n    if string == NULL:\n        return string\n\n    if string[-1:] != '\\x00':\n        return string + '\\x00'\n    else:\n        return string",
  "class IWbemClassObject(IRemUnknown):\n    def __init__(self, interface, iWbemServices = None):\n        IRemUnknown.__init__(self,interface)\n        self._iid = IID_IWbemClassObject\n        self.__iWbemServices = iWbemServices\n        self.__methods = None\n\n        objRef = self.get_objRef()\n        objRef = OBJREF_CUSTOM(objRef)\n        self.encodingUnit = ENCODING_UNIT(objRef['pObjectData'])\n        self.parseObject()\n        if self.encodingUnit['ObjectBlock'].isInstance() is False:\n            self.createMethods(self.getClassName(), self.getMethods())\n        else:\n            self.createProperties(self.getProperties())\n\n    def __getattr__(self, attr):\n        if attr.startswith('__') is not True:\n            properties = self.getProperties()\n            # Let's see if there's a key property so we can ExecMethod\n            keyProperty = None\n            for pName in properties:\n                if 'key' in properties[pName]['qualifiers']:\n                    keyProperty = pName\n\n            if keyProperty is None:\n                LOG.error(\"I don't have a key property in this set!\")\n            else:\n                if self.__methods is None:\n                    classObject,_ = self.__iWbemServices.GetObject(self.getClassName())\n                    self.__methods = classObject.getMethods()\n\n                if attr in self.__methods:\n                    # Now we gotta build the class name to be called through ExecMethod\n                    if self.getProperties()[keyProperty]['stype'] != 'string':\n                        instanceName = '%s.%s=%s' % (\n                        self.getClassName(), keyProperty, self.getProperties()[keyProperty]['value'])\n                    else:\n                        instanceName = '%s.%s=\"%s\"' % (\n                        self.getClassName(), keyProperty, self.getProperties()[keyProperty]['value'])\n\n                    self.createMethods(instanceName , self.__methods)\n                    #print dir(self)\n                    return getattr(self, attr)\n\n        raise AttributeError(\"%r object has no attribute %r\" %\n                             (self.__class__, attr))\n\n    def parseObject(self):\n        self.encodingUnit['ObjectBlock'].parseObject()\n\n    def getObject(self):\n        return self.encodingUnit['ObjectBlock']\n\n    def getClassName(self):\n        if self.encodingUnit['ObjectBlock'].isInstance() is False:\n            return self.encodingUnit['ObjectBlock']['ClassType']['CurrentClass'].getClassName().split(' ')[0]\n        else:\n            return self.encodingUnit['ObjectBlock']['InstanceType']['CurrentClass'].getClassName().split(' ')[0]\n\n    def printInformation(self):\n        return self.encodingUnit['ObjectBlock'].printInformation()\n\n    def getProperties(self):\n        if self.encodingUnit['ObjectBlock'].ctCurrent is None:\n            return ()\n        return self.encodingUnit['ObjectBlock'].ctCurrent['properties']\n    \n    def getMethods(self):\n        if self.encodingUnit['ObjectBlock'].ctCurrent is None:\n            return ()\n        return self.encodingUnit['ObjectBlock'].ctCurrent['methods']\n\n    @staticmethod\n    def __ndEntry(index, null_default, inherited_default):\n        # https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-wmio/ed436785-40fc-425e-ad3d-f9200eb1a122\n        return (bool(null_default) << 1 | bool(inherited_default)) << (2 * index)\n\n    def marshalMe(self):\n        # So, in theory, we have the OBJCUSTOM built, but \n        # we need to update the values\n        # That's what we'll do\n\n        instanceHeap = b''\n        valueTable = b''\n        ndTable = 0\n        parametersClass = ENCODED_STRING()\n        parametersClass['Character'] = self.getClassName()\n        instanceHeap += parametersClass.getData()\n        curHeapPtr = len(instanceHeap)\n        properties = self.getProperties()\n        for i, propName in enumerate(properties):\n            propRecord = properties[propName]\n            itemValue = getattr(self, propName)\n            propIsInherited = propRecord['inherited']\n            print(\"PropName %r, Value: %r\" % (propName,itemValue))\n\n            pType = propRecord['type'] & (~(CIM_ARRAY_FLAG|Inherited)) \n            if propRecord['type'] & CIM_ARRAY_FLAG:\n                # Not yet ready\n                packStr = HEAPREF[:-2]\n            else:\n                packStr = CIM_TYPES_REF[pType][:-2]\n\n            if propRecord['type'] & CIM_ARRAY_FLAG:\n                if itemValue is None:\n                    ndTable |= self.__ndEntry(i, True, propIsInherited)\n                    valueTable += pack(packStr, 0)\n                else:\n                    valueTable += pack('<L', curHeapPtr)\n                    arraySize = pack(HEAPREF[:-2], len(itemValue))\n                    packStrArray =  CIM_TYPES_REF[pType][:-2]\n                    arrayItems = b''\n                    for j in range(len(itemValue)):\n                        arrayItems += pack(packStrArray, itemValue[j])\n                    instanceHeap += arraySize + arrayItems\n                    curHeapPtr = len(instanceHeap)\n            elif pType in (CIM_TYPE_ENUM.CIM_TYPE_UINT8.value, CIM_TYPE_ENUM.CIM_TYPE_UINT16.value,\n                           CIM_TYPE_ENUM.CIM_TYPE_UINT32.value, CIM_TYPE_ENUM.CIM_TYPE_UINT64.value):\n                if itemValue is None:\n                    ndTable |= self.__ndEntry(i, True, propIsInherited)\n                    valueTable += pack(packStr, 0)\n                else:\n                    valueTable += pack(packStr, int(itemValue))\n            elif pType in (CIM_TYPE_ENUM.CIM_TYPE_BOOLEAN.value,):\n                if itemValue is None:\n                    ndTable |= self.__ndEntry(i, True, propIsInherited)\n                    valueTable += pack(packStr, False)\n                else:\n                    valueTable += pack(packStr, bool(itemValue))\n            elif pType not in (CIM_TYPE_ENUM.CIM_TYPE_STRING.value, CIM_TYPE_ENUM.CIM_TYPE_DATETIME.value,\n                               CIM_TYPE_ENUM.CIM_TYPE_REFERENCE.value, CIM_TYPE_ENUM.CIM_TYPE_OBJECT.value):\n                if itemValue is None:\n                    ndTable |= self.__ndEntry(i, True, propIsInherited)\n                    valueTable += pack(packStr, -1)\n                else:\n                    valueTable += pack(packStr, itemValue)\n            elif pType == CIM_TYPE_ENUM.CIM_TYPE_OBJECT.value:\n                # For now we just pack None and set the inherited_default\n                # flag, just in case a parent class defines this for us\n                valueTable += b'\\x00'*4\n                if itemValue is None:\n                    ndTable |= self.__ndEntry(i, True, True)\n            else:\n                if itemValue == '':\n                    # https://github.com/fortra/impacket/pull/1069#issuecomment-835179409\n                    # Force inherited_default to avoid 'obscure' issue in wmipersist.py\n                    ndTable |= self.__ndEntry(i, True, True)\n                    valueTable += pack('<L', 0)\n                else:\n                    strIn = ENCODED_STRING()\n                    strIn['Character'] = itemValue\n                    valueTable += pack('<L', curHeapPtr)\n                    instanceHeap += strIn.getData()\n                    curHeapPtr = len(instanceHeap)\n\n        ndTableLen = (len(properties) - 1) // 4 + 1\n        packedNdTable = b''\n        for i in range(ndTableLen):\n            packedNdTable += pack('B', ndTable & 0xff)\n            ndTable >>=  8\n\n        # Now let's update the structure\n        objRef = self.get_objRef()\n        objRef = OBJREF_CUSTOM(objRef)\n        encodingUnit = ENCODING_UNIT(objRef['pObjectData'])\n\n        currentClass = encodingUnit['ObjectBlock']['InstanceType']['CurrentClass']\n        encodingUnit['ObjectBlock']['InstanceType']['CurrentClass'] = b''\n\n        encodingUnit['ObjectBlock']['InstanceType']['NdTable_ValueTable'] = packedNdTable + valueTable\n        encodingUnit['ObjectBlock']['InstanceType']['InstanceHeap']['HeapLength'] = len(instanceHeap) | 0x80000000\n        encodingUnit['ObjectBlock']['InstanceType']['InstanceHeap']['HeapItem'] = instanceHeap\n\n        encodingUnit['ObjectBlock']['InstanceType']['EncodingLength'] = len(encodingUnit['ObjectBlock']['InstanceType'])\n        encodingUnit['ObjectBlock']['InstanceType']['CurrentClass'] = currentClass\n\n        encodingUnit['ObjectEncodingLength'] = len(encodingUnit['ObjectBlock'])\n\n        #encodingUnit.dump()\n        #ENCODING_UNIT(str(encodingUnit)).dump()\n\n        objRef['pObjectData'] = encodingUnit\n\n        return objRef\n\n    def SpawnInstance(self):\n        # Doing something similar to:\n        # https://docs.microsoft.com/windows/desktop/api/wbemcli/nf-wbemcli-iwbemclassobject-spawninstance\n        #\n        if self.encodingUnit['ObjectBlock'].isInstance() is False:\n            # We need to convert some things to transform a class into an instance\n            encodingUnit = ENCODING_UNIT()\n\n            instanceData = OBJECT_BLOCK()\n            instanceData.structure += OBJECT_BLOCK.decoration\n            instanceData.structure += OBJECT_BLOCK.instanceType\n            instanceData['ObjectFlags'] = 6\n            instanceData['Decoration'] = self.encodingUnit['ObjectBlock']['Decoration'].getData()\n\n            instanceType = INSTANCE_TYPE()\n            instanceType['CurrentClass'] = b''\n\n            # Let's create the heap for the parameters\n            instanceHeap = b''\n            valueTable = b''\n            parametersClass = ENCODED_STRING()\n            parametersClass['Character'] = self.getClassName()\n            instanceHeap += parametersClass.getData()\n            curHeapPtr = len(instanceHeap)\n\n            ndTable = 0\n            properties = self.getProperties()\n\n            # Let's initialize the values\n            for i, propName in enumerate(properties):\n                propRecord = properties[propName]\n\n                pType = propRecord['type'] & (~(CIM_ARRAY_FLAG|Inherited)) \n                if propRecord['type'] & CIM_ARRAY_FLAG:\n                    # Not yet ready\n                    #print paramDefinition\n                    #raise\n                    packStr = HEAPREF[:-2]\n                else:\n                    packStr = CIM_TYPES_REF[pType][:-2]\n\n                if propRecord['type'] & CIM_ARRAY_FLAG:\n                    valueTable += pack(packStr, 0)\n                elif pType not in (CIM_TYPE_ENUM.CIM_TYPE_STRING.value, CIM_TYPE_ENUM.CIM_TYPE_DATETIME.value,\n                                   CIM_TYPE_ENUM.CIM_TYPE_REFERENCE.value, CIM_TYPE_ENUM.CIM_TYPE_OBJECT.value):\n                    valueTable += pack(packStr, 0)\n                elif pType == CIM_TYPE_ENUM.CIM_TYPE_OBJECT.value:\n                    # For now we just pack None and set the inherited_default\n                    # flag, just in case a parent class defines this for us\n                    valueTable += b'\\x00'*4\n                    ndTable |= self.__ndEntry(i, True, True)\n                else:\n                    strIn = ENCODED_STRING()\n                    strIn['Character'] = ''\n                    valueTable += pack('<L', curHeapPtr)\n                    instanceHeap += strIn.getData()\n                    curHeapPtr = len(instanceHeap)\n\n            ndTableLen = (len(properties) - 1) // 4 + 1\n            packedNdTable = b''\n            for i in range(ndTableLen):\n                packedNdTable += pack('B', ndTable & 0xff)\n                ndTable >>=  8\n\n            instanceType['NdTable_ValueTable'] = packedNdTable + valueTable\n\n            instanceType['InstanceQualifierSet'] = b'\\x04\\x00\\x00\\x00\\x01'\n\n            instanceType['InstanceHeap'] = HEAP()\n            instanceType['InstanceHeap']['HeapItem'] = instanceHeap\n            instanceType['InstanceHeap']['HeapLength'] = len(instanceHeap) | 0x80000000\n            instanceType['EncodingLength'] = len(instanceType)\n\n            instanceType['CurrentClass'] = self.encodingUnit['ObjectBlock']['ClassType']['CurrentClass']['ClassPart']\n            instanceData['InstanceType'] = instanceType.getData()\n\n            encodingUnit['ObjectBlock'] = instanceData\n            encodingUnit['ObjectEncodingLength'] = len(instanceData)\n\n            #ENCODING_UNIT(str(encodingUnit)).dump()\n\n            objRefCustomIn = OBJREF_CUSTOM()\n            objRefCustomIn['iid'] = self._iid\n            objRefCustomIn['clsid'] = CLSID_WbemClassObject\n            objRefCustomIn['cbExtension'] = 0\n            objRefCustomIn['ObjectReferenceSize'] = len(encodingUnit)\n            objRefCustomIn['pObjectData'] = encodingUnit\n\n            # There's gotta be a better way to do this\n            # I will reimplement this stuff once I know it works\n            import copy\n            newObj = copy.deepcopy(self)\n            newObj.set_objRef(objRefCustomIn.getData())\n            newObj.process_interface(objRefCustomIn.getData())\n            newObj.encodingUnit = ENCODING_UNIT(encodingUnit.getData())\n            newObj.parseObject()\n            if newObj.encodingUnit['ObjectBlock'].isInstance() is False:\n                newObj.createMethods(newObj.getClassName(), newObj.getMethods())\n            else:\n                newObj.createProperties(newObj.getProperties())\n\n            return newObj\n        else:\n            return self\n\n    def createProperties(self, properties):\n        for property in properties:\n            # Do we have an object property?\n            if properties[property]['type'] == CIM_TYPE_ENUM.CIM_TYPE_OBJECT.value:\n                # Yes.. let's create an Object for it too\n                objRef = OBJREF_CUSTOM()\n                objRef['iid'] = self._iid\n                objRef['clsid'] = CLSID_WbemClassObject\n                objRef['cbExtension'] = 0\n                objRef['ObjectReferenceSize'] = len(properties[property]['value'].getData())\n                objRef['pObjectData'] = properties[property]['value']\n                value = IWbemClassObject( INTERFACE(self.get_cinstance(), objRef.getData(), self.get_ipidRemUnknown(),\n                      oxid=self.get_oxid(), target=self.get_target()))\n            elif properties[property]['type'] == CIM_TYPE_ENUM.CIM_ARRAY_OBJECT.value:\n                if isinstance(properties[property]['value'], list):\n                    value = list()\n                    for item in properties[property]['value']:\n                        # Yes.. let's create an Object for it too\n                        objRef = OBJREF_CUSTOM()\n                        objRef['iid'] = self._iid\n                        objRef['clsid'] = CLSID_WbemClassObject\n                        objRef['cbExtension'] = 0\n                        objRef['ObjectReferenceSize'] = len(item.getData())\n                        objRef['pObjectData'] = item\n                        wbemClass = IWbemClassObject(\n                            INTERFACE(self.get_cinstance(), objRef.getData(), self.get_ipidRemUnknown(),\n                                      oxid=self.get_oxid(), target=self.get_target()))\n                        value.append(wbemClass)\n                else:\n                    value = properties[property]['value']\n            else:\n                value = properties[property]['value']\n            setattr(self, property, value)\n\n    def createMethods(self, classOrInstance, methods):\n        class FunctionPool:\n            def __init__(self,function):\n                self.function = function\n            def __getitem__(self,item):\n                return partial(self.function,item)\n\n        @FunctionPool\n        def innerMethod(staticArgs, *args):\n            classOrInstance = staticArgs[0] \n            methodDefinition = staticArgs[1] \n            if methodDefinition['InParams'] is not None:\n                if len(args) != len(methodDefinition['InParams']):\n                    LOG.error(\"Function called with %d parameters instead of %d!\" % (len(args), len(methodDefinition['InParams'])))\n                    return None\n                # In Params\n                encodingUnit = ENCODING_UNIT()\n\n                inParams = OBJECT_BLOCK()\n                inParams.structure += OBJECT_BLOCK.instanceType\n                inParams['ObjectFlags'] = 2\n                inParams['Decoration'] = b''\n\n                instanceType = INSTANCE_TYPE()\n                instanceType['CurrentClass'] = b''\n                instanceType['InstanceQualifierSet'] = b'\\x04\\x00\\x00\\x00\\x01'\n\n                # Let's create the heap for the parameters\n                instanceHeap = b''\n                valueTable = b''\n                parametersClass = ENCODED_STRING()\n                parametersClass['Character'] = '__PARAMETERS'\n                instanceHeap += parametersClass.getData()\n                curHeapPtr = len(instanceHeap)\n\n                ndTable = 0\n                for i in range(len(args)):\n                    paramDefinition = list(methodDefinition['InParams'].values())[i]\n                    inArg = args[i]\n\n                    pType = paramDefinition['type'] & (~(CIM_ARRAY_FLAG|Inherited)) \n                    if paramDefinition['type'] & CIM_ARRAY_FLAG:\n                        # Not yet ready\n                        #print paramDefinition\n                        #raise\n                        packStr = HEAPREF[:-2]\n                    else:\n                        packStr = CIM_TYPES_REF[pType][:-2]\n\n                    if paramDefinition['type'] & CIM_ARRAY_FLAG:\n                        if inArg is None:\n                            valueTable += pack(packStr, 0)\n                        elif pType in (CIM_TYPE_ENUM.CIM_TYPE_STRING.value, CIM_TYPE_ENUM.CIM_TYPE_DATETIME.value,\n                                       CIM_TYPE_ENUM.CIM_TYPE_REFERENCE.value, CIM_TYPE_ENUM.CIM_TYPE_OBJECT.value):\n                            arraySize = pack(HEAPREF[:-2], len(inArg))\n                            arrayItems = []\n                            for j in range(len(inArg)):\n                                curVal = inArg[j]\n                                if pType == CIM_TYPE_ENUM.CIM_TYPE_OBJECT.value:\n                                    curObject = b''\n                                    marshaledObject = curVal.marshalMe()\n                                    curObject += pack('<L', marshaledObject['pObjectData']['ObjectEncodingLength'])\n                                    curObject += marshaledObject['pObjectData']['ObjectBlock'].getData()\n                                    arrayItems.append(curObject)\n                                    continue\n                                strIn = ENCODED_STRING()\n                                if type(curVal) is str:\n                                    # The Encoded-String-Flag is set to 0x01 if the sequence of characters that follows\n                                    # consists of UTF-16 characters (as specified in [UNICODE]) followed by a UTF-16 null\n                                    # terminator.\n                                    strIn['Encoded_String_Flag'] = 0x1\n                                    strIn.structure = strIn.tunicode\n                                    strIn['Character'] = curVal.encode('utf-16le')\n                                else:\n                                    strIn['Character'] = curVal\n                                arrayItems.append(strIn.getData())\n\n\n                            curStrHeapPtr = curHeapPtr + 4\n                            arrayHeapPtrValues = b''\n                            arrayValueTable = b''\n                            for j in range(len(arrayItems)):\n                                arrayHeapPtrValues += pack('<L', curStrHeapPtr + 4 * (len(arrayItems) - j) + len(arrayValueTable))\n                                arrayValueTable += arrayItems[j]\n                                curStrHeapPtr += 4\n\n                            valueTable += pack('<L', curHeapPtr)\n                            instanceHeap += arraySize + arrayHeapPtrValues + arrayValueTable\n                            curHeapPtr = len(instanceHeap)\n                        else:\n                            arraySize = pack(HEAPREF[:-2], len(inArg))\n                            valueTable += pack('<L', curHeapPtr)\n                            instanceHeap += arraySize\n                            for curVal in inArg:\n                                instanceHeap += pack(packStr, curVal)\n                            curHeapPtr = len(instanceHeap)\n                    elif pType not in (CIM_TYPE_ENUM.CIM_TYPE_STRING.value, CIM_TYPE_ENUM.CIM_TYPE_DATETIME.value,\n                                       CIM_TYPE_ENUM.CIM_TYPE_REFERENCE.value, CIM_TYPE_ENUM.CIM_TYPE_OBJECT.value):\n                        valueTable += pack(packStr, inArg)\n                    elif pType == CIM_TYPE_ENUM.CIM_TYPE_OBJECT.value:\n                        if inArg is None:\n                            # For now we just pack None and set the inherited_default\n                            # flag, just in case a parent class defines this for us\n                            valueTable += b'\\x00' * 4\n                            ndTable |= self.__ndEntry(i, True, True)\n                        else:\n                            valueTable += pack('<L', curHeapPtr)\n                            marshaledObject = inArg.marshalMe()\n                            instanceHeap += pack('<L', marshaledObject['pObjectData']['ObjectEncodingLength'])\n                            instanceHeap += marshaledObject['pObjectData']['ObjectBlock'].getData()\n                            curHeapPtr = len(instanceHeap)\n                    else:\n                        strIn = ENCODED_STRING()\n                        if type(inArg) is str:\n                            # The Encoded-String-Flag is set to 0x01 if the sequence of characters that follows\n                            # consists of UTF-16 characters (as specified in [UNICODE]) followed by a UTF-16 null\n                            # terminator.\n                            strIn['Encoded_String_Flag'] = 0x1\n                            strIn.structure = strIn.tunicode\n                            strIn['Character'] = inArg.encode('utf-16le')\n                        else:\n                            strIn['Character'] = inArg\n                        valueTable += pack('<L', curHeapPtr)\n                        instanceHeap += strIn.getData()\n                        curHeapPtr = len(instanceHeap)\n\n                ndTableLen = (len(args) - 1) // 4 + 1\n\n                packedNdTable = b''\n                for i in range(ndTableLen):\n                    packedNdTable += pack('B', ndTable & 0xff)\n                    ndTable >>=  8\n\n                instanceType['NdTable_ValueTable'] = packedNdTable + valueTable\n                heapRecord = HEAP()\n                heapRecord['HeapLength'] = len(instanceHeap) | 0x80000000\n                heapRecord['HeapItem'] = instanceHeap\n                \n                instanceType['InstanceHeap'] = heapRecord\n\n                instanceType['EncodingLength'] = len(instanceType)\n                inMethods = methodDefinition['InParamsRaw']['ClassType']['CurrentClass']['ClassPart']\n                inMethods['ClassHeader']['EncodingLength'] = len(\n                    methodDefinition['InParamsRaw']['ClassType']['CurrentClass']['ClassPart'].getData())\n                instanceType['CurrentClass'] = inMethods\n\n                inParams['InstanceType'] = instanceType.getData()\n\n                encodingUnit['ObjectBlock'] = inParams\n                encodingUnit['ObjectEncodingLength'] = len(inParams)\n\n                objRefCustomIn = OBJREF_CUSTOM()\n                objRefCustomIn['iid'] = self._iid\n                objRefCustomIn['clsid'] = CLSID_WbemClassObject\n                objRefCustomIn['cbExtension'] = 0\n                objRefCustomIn['ObjectReferenceSize'] = len(encodingUnit)\n                objRefCustomIn['pObjectData'] = encodingUnit\n            else:\n                objRefCustomIn = NULL\n\n            ### OutParams\n            encodingUnit = ENCODING_UNIT()\n\n            outParams = OBJECT_BLOCK()\n            outParams.structure += OBJECT_BLOCK.instanceType\n            outParams['ObjectFlags'] = 2\n            outParams['Decoration'] = b''\n\n            instanceType = INSTANCE_TYPE()\n            instanceType['CurrentClass'] = b''\n            instanceType['NdTable_ValueTable'] = b''\n            instanceType['InstanceQualifierSet'] = b''\n            instanceType['InstanceHeap'] = b''\n            instanceType['EncodingLength'] = len(instanceType)\n            instanceType['CurrentClass'] = methodDefinition['OutParamsRaw']['ClassType']['CurrentClass']['ClassPart'].getData()\n            outParams['InstanceType'] = instanceType.getData()\n\n\n            encodingUnit['ObjectBlock'] = outParams\n            encodingUnit['ObjectEncodingLength'] = len(outParams)\n\n            objRefCustom = OBJREF_CUSTOM()\n            objRefCustom['iid'] = self._iid\n            objRefCustom['clsid'] = CLSID_WbemClassObject\n            objRefCustom['cbExtension'] = 0\n            objRefCustom['ObjectReferenceSize'] = len(encodingUnit)\n            objRefCustom['pObjectData'] = encodingUnit\n            try:\n                return self.__iWbemServices.ExecMethod(classOrInstance, methodDefinition['name'], pInParams = objRefCustomIn )\n                #return self.__iWbemServices.ExecMethod('Win32_Process.Handle=\"436\"', methodDefinition['name'],\n                #                                       pInParams=objRefCustomIn).getObject().ctCurrent['properties']\n            except Exception as e:\n                if LOG.level == logging.DEBUG:\n                    import traceback\n                    traceback.print_exc()\n                LOG.error(str(e))\n\n        for methodName in methods:\n           innerMethod.__name__ = methodName\n           setattr(self,innerMethod.__name__,innerMethod[classOrInstance,methods[methodName]])",
  "class IWbemLoginClientID(IRemUnknown):\n    def __init__(self, interface):\n        IRemUnknown.__init__(self,interface)\n        self._iid = IID_IWbemLoginClientID\n\n    def SetClientInfo(self, wszClientMachine, lClientProcId = 1234):\n        request = IWbemLoginClientID_SetClientInfo()\n        request['wszClientMachine'] = checkNullString(wszClientMachine)\n        request['lClientProcId'] = lClientProcId\n        request['lReserved'] = 0\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        return resp",
  "class IWbemLoginHelper(IRemUnknown):\n    def __init__(self, interface):\n        IRemUnknown.__init__(self,interface)\n        self._iid = IID_IWbemLoginHelper\n\n    def SetEvent(self, sEventToSet):\n        request = IWbemLoginHelper_SetEvent()\n        request['sEventToSet'] = sEventToSet\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp",
  "class IWbemWCOSmartEnum(IRemUnknown):\n    def __init__(self, interface):\n        IRemUnknown.__init__(self,interface)\n        self._iid = IID_IWbemWCOSmartEnum\n\n    def Next(self, proxyGUID, lTimeout, uCount):\n        request = IWbemWCOSmartEnum_Next()\n        request['proxyGUID'] = proxyGUID\n        request['lTimeout'] = lTimeout\n        request['uCount'] = uCount\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp",
  "class IWbemFetchSmartEnum(IRemUnknown):\n    def __init__(self, interface):\n        IRemUnknown.__init__(self,interface)\n        self._iid = IID_IWbemFetchSmartEnum\n\n    def GetSmartEnum(self, lTimeout):\n        request = IWbemFetchSmartEnum_GetSmartEnum()\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp",
  "class IWbemCallResult(IRemUnknown):\n    def __init__(self, interface):\n        IRemUnknown.__init__(self,interface)\n        self._iid = IID_IWbemCallResult\n\n    def GetResultObject(self, lTimeout):\n        request = IWbemCallResult_GetResultObject()\n        request['lTimeout'] = lTimeout\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp\n\n    def GetResultString(self, lTimeout):\n        request = IWbemCallResult_GetResultString()\n        request['lTimeout'] = lTimeout\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp\n\n    def GetResultServices(self, lTimeout):\n        request = IWbemCallResult_GetResultServices()\n        request['lTimeout'] = lTimeout\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp\n\n    def GetCallStatus(self, lTimeout):\n        request = IWbemCallResult_GetCallStatus()\n        request['lTimeout'] = lTimeout\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        return resp['plStatus']",
  "class IEnumWbemClassObject(IRemUnknown):\n    def __init__(self, interface, iWbemServices = None):\n        IRemUnknown.__init__(self,interface)\n        self._iid = IID_IEnumWbemClassObject\n        self.__iWbemServices = iWbemServices\n\n    def Reset(self):\n        request = IEnumWbemClassObject_Reset()\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp\n\n    def Next(self, lTimeout, uCount):\n        request = IEnumWbemClassObject_Next()\n        request['lTimeout'] = lTimeout\n        request['uCount'] = uCount\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        interfaces = list()\n        for interface in resp['apObjects']:\n            interfaces.append(IWbemClassObject(\n                INTERFACE(self.get_cinstance(), b''.join(interface['abData']), self.get_ipidRemUnknown(),\n                          oxid=self.get_oxid(), target=self.get_target()), self.__iWbemServices))\n\n        return interfaces\n\n    def NextAsync(self, lTimeout, pSink):\n        request = IEnumWbemClassObject_NextAsync()\n        request['lTimeout'] = lTimeout\n        request['pSink'] = pSink\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp\n\n    def Clone(self):\n        request = IEnumWbemClassObject_Clone()\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp\n\n    def Skip(self, lTimeout, uCount):\n        request = IEnumWbemClassObject_Skip()\n        request['lTimeout'] = lTimeout\n        request['uCount'] = uCount\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp",
  "class IWbemServices(IRemUnknown):\n    def __init__(self, interface):\n        IRemUnknown.__init__(self,interface)\n        self._iid = IID_IWbemServices\n\n    def OpenNamespace(self, strNamespace, lFlags=0, pCtx = NULL):\n        request = IWbemServices_OpenNamespace()\n        request['strNamespace']['asData'] = strNamespace\n        request['lFlags'] = lFlags\n        request['pCtx'] = pCtx\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp\n\n    def CancelAsyncCall(self,IWbemObjectSink ):\n        request = IWbemServices_CancelAsyncCall()\n        request['IWbemObjectSink'] = IWbemObjectSink\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        return resp['ErrorCode']\n\n    def QueryObjectSink(self):\n        request = IWbemServices_QueryObjectSink()\n        request['lFlags'] = 0\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        return INTERFACE(self.get_cinstance(), b''.join(resp['ppResponseHandler']['abData']), self.get_ipidRemUnknown(),\n                         target=self.get_target())\n\n    def GetObject(self, strObjectPath, lFlags=0, pCtx=NULL):\n        request = IWbemServices_GetObject()\n        request['strObjectPath']['asData'] = strObjectPath\n        request['lFlags'] = lFlags\n        request['pCtx'] = pCtx\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        ppObject = IWbemClassObject(\n            INTERFACE(self.get_cinstance(), b''.join(resp['ppObject']['abData']), self.get_ipidRemUnknown(),\n                      oxid=self.get_oxid(), target=self.get_target()), self)\n        if resp['ppCallResult'] != NULL:\n            ppcallResult = IWbemCallResult(\n                INTERFACE(self.get_cinstance(), b''.join(resp['ppObject']['abData']), self.get_ipidRemUnknown(),\n                          target=self.get_target()))\n        else:\n            ppcallResult = NULL\n        return ppObject, ppcallResult\n\n    def GetObjectAsync(self, strNamespace, lFlags=0, pCtx = NULL):\n        request = IWbemServices_GetObjectAsync()\n        request['strObjectPath']['asData'] = checkNullString(strNamespace)\n        request['lFlags'] = lFlags\n        request['pCtx'] = pCtx\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp\n\n    def PutClass(self, pObject, lFlags=0, pCtx=NULL):\n        request = IWbemServices_PutClass()\n        request['pObject'] = pObject\n        request['lFlags'] = lFlags\n        request['pCtx'] = pCtx\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp\n\n    def PutClassAsync(self, pObject, lFlags=0, pCtx=NULL):\n        request = IWbemServices_PutClassAsync()\n        request['pObject'] = pObject\n        request['lFlags'] = lFlags\n        request['pCtx'] = pCtx\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp\n\n    def DeleteClass(self, strClass, lFlags=0, pCtx=NULL):\n        request = IWbemServices_DeleteClass()\n        request['strClass']['asData'] = checkNullString(strClass)\n        request['lFlags'] = lFlags\n        request['pCtx'] = pCtx\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp\n\n    def DeleteClassAsync(self, strClass, lFlags=0, pCtx=NULL):\n        request = IWbemServices_DeleteClassAsync()\n        request['strClass']['asData'] = checkNullString(strClass)\n        request['lFlags'] = lFlags\n        request['pCtx'] = pCtx\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp\n\n    def CreateClassEnum(self, strSuperClass, lFlags=0, pCtx=NULL):\n        request = IWbemServices_CreateClassEnum()\n        request['strSuperClass']['asData'] = checkNullString(strSuperClass)\n        request['lFlags'] = lFlags\n        request['pCtx'] = pCtx\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp\n\n    def CreateClassEnumAsync(self, strSuperClass, lFlags=0, pCtx=NULL):\n        request = IWbemServices_CreateClassEnumAsync()\n        request['strSuperClass']['asData'] = checkNullString(strSuperClass)\n        request['lFlags'] = lFlags\n        request['pCtx'] = pCtx\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp\n\n    def PutInstance(self, pInst, lFlags=0, pCtx=NULL):\n        request = IWbemServices_PutInstance()\n\n        if pInst is NULL:\n            request['pInst'] = pInst\n        else:\n            request['pInst']['ulCntData'] = len(pInst)\n            request['pInst']['abData'] = list(pInst.getData())\n        request['lFlags'] = lFlags\n        request['pCtx'] = pCtx\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        return IWbemCallResult(\n            INTERFACE(self.get_cinstance(), b''.join(resp['ppCallResult']['abData']), self.get_ipidRemUnknown(),\n                      target=self.get_target()))\n\n    def PutInstanceAsync(self, pInst, lFlags=0, pCtx=NULL):\n        request = IWbemServices_PutInstanceAsync()\n        request['pInst'] = pInst\n        request['lFlags'] = lFlags\n        request['pCtx'] = pCtx\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp\n\n    def DeleteInstance(self, strObjectPath, lFlags=0, pCtx=NULL):\n        request = IWbemServices_DeleteInstance()\n        request['strObjectPath']['asData'] = checkNullString(strObjectPath)\n        request['lFlags'] = lFlags\n        request['pCtx'] = pCtx\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        return IWbemCallResult(\n            INTERFACE(self.get_cinstance(), b''.join(resp['ppCallResult']['abData']), self.get_ipidRemUnknown(),\n                      target=self.get_target()))\n\n    def DeleteInstanceAsync(self, strObjectPath, lFlags=0, pCtx=NULL):\n        request = IWbemServices_DeleteInstanceAsync()\n        request['strObjectPath']['asData'] = checkNullString(strObjectPath)\n        request['lFlags'] = lFlags\n        request['pCtx'] = pCtx\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp\n\n    def CreateInstanceEnum(self, strSuperClass, lFlags=0, pCtx=NULL):\n        request = IWbemServices_CreateInstanceEnum()\n        request['strSuperClass']['asData'] = strSuperClass\n        request['lFlags'] = lFlags\n        request['pCtx'] = pCtx\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return IEnumWbemClassObject(\n            INTERFACE(self.get_cinstance(), b''.join(resp['ppEnum']['abData']), self.get_ipidRemUnknown(),\n                      target=self.get_target()))\n\n    def CreateInstanceEnumAsync(self, strSuperClass, lFlags=0, pCtx=NULL):\n        request = IWbemServices_CreateInstanceEnumAsync()\n        request['strSuperClass']['asData'] = checkNullString(strSuperClass)\n        request['lFlags'] = lFlags\n        request['pCtx'] = pCtx\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp\n\n    #def ExecQuery(self, strQuery, lFlags=WBEM_QUERY_FLAG_TYPE.WBEM_FLAG_PROTOTYPE, pCtx=NULL):\n    def ExecQuery(self, strQuery, lFlags=0, pCtx=NULL):\n        request = IWbemServices_ExecQuery()\n        request['strQueryLanguage']['asData'] = checkNullString('WQL')\n        request['strQuery']['asData'] = checkNullString(strQuery)\n        request['lFlags'] = lFlags\n        request['pCtx'] = pCtx\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        return IEnumWbemClassObject(\n            INTERFACE(self.get_cinstance(), b''.join(resp['ppEnum']['abData']), self.get_ipidRemUnknown(),\n                      target=self.get_target()), self)\n\n    def ExecQueryAsync(self, strQuery, lFlags=0, pCtx=NULL):\n        request = IWbemServices_ExecQueryAsync()\n        request['strQueryLanguage']['asData'] = checkNullString('WQL')\n        request['strQuery']['asData'] = checkNullString(strQuery)\n        request['lFlags'] = lFlags\n        request['pCtx'] = pCtx\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp\n\n    def ExecNotificationQuery(self, strQuery, lFlags=0, pCtx=NULL):\n        request = IWbemServices_ExecNotificationQuery()\n        request['strQueryLanguage']['asData'] = checkNullString('WQL')\n        request['strQuery']['asData'] = checkNullString(strQuery)\n        request['lFlags'] = lFlags\n        request['pCtx'] = pCtx\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        return IEnumWbemClassObject(\n            INTERFACE(self.get_cinstance(), b''.join(resp['ppEnum']['abData']), self.get_ipidRemUnknown(),\n                      target=self.get_target()), self)\n\n    def ExecNotificationQueryAsync(self, strQuery, lFlags=0, pCtx=NULL):\n        request = IWbemServices_ExecNotificationQueryAsync()\n        request['strQueryLanguage']['asData'] = checkNullString('WQL')\n        request['strQuery']['asData'] = checkNullString(strQuery)\n        request['lFlags'] = lFlags\n        request['pCtx'] = pCtx\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp\n\n    def ExecMethod(self, strObjectPath, strMethodName, lFlags=0, pCtx=NULL, pInParams=NULL, ppOutParams = NULL):\n        request = IWbemServices_ExecMethod()\n        request['strObjectPath']['asData'] = checkNullString(strObjectPath)\n        request['strMethodName']['asData'] = checkNullString(strMethodName)\n        request['lFlags'] = lFlags\n        request['pCtx'] = pCtx\n        if pInParams is NULL:\n            request['pInParams'] = pInParams\n        else:\n            request['pInParams']['ulCntData'] = len(pInParams)\n            request['pInParams']['abData'] = list(pInParams.getData())\n\n        request.fields['ppCallResult'] = NULL\n        if ppOutParams is NULL:\n            request.fields['ppOutParams'].fields['Data'] = NULL\n        else:\n            request['ppOutParams']['ulCntData'] = len(ppOutParams.getData())\n            request['ppOutParams']['abData'] = list(ppOutParams.getData())\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        return IWbemClassObject(\n            INTERFACE(self.get_cinstance(), b''.join(resp['ppOutParams']['abData']), self.get_ipidRemUnknown(),\n                      oxid=self.get_oxid(), target=self.get_target()))\n\n    def ExecMethodAsync(self, strObjectPath, strMethodName, lFlags=0, pCtx=NULL, pInParams=NULL):\n        request = IWbemServices_ExecMethodAsync()\n        request['strObjectPath']['asData'] = checkNullString(strObjectPath)\n        request['strMethodName']['asData'] = checkNullString(strMethodName)\n        request['lFlags'] = lFlags\n        request['pCtx'] = pCtx\n        request['pInParams'] = pInParams\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp",
  "class IWbemLevel1Login(IRemUnknown):\n    def __init__(self, interface):\n        IRemUnknown.__init__(self,interface)\n        self._iid = IID_IWbemLevel1Login\n\n    def EstablishPosition(self):\n        request = IWbemLevel1Login_EstablishPosition()\n        request['reserved1'] = NULL\n        request['reserved2'] = 0\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        return resp['LocaleVersion']\n\n    def RequestChallenge(self):\n        request = IWbemLevel1Login_RequestChallenge()\n        request['reserved1'] = NULL\n        request['reserved2'] = NULL\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        return resp['reserved3']\n\n    def WBEMLogin(self):\n        request = IWbemLevel1Login_WBEMLogin()\n        request['reserved1'] = NULL\n        request['reserved2'] = NULL\n        request['reserved3'] = 0\n        request['reserved4'] = NULL\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        return resp['reserved5']\n\n    def NTLMLogin(self, wszNetworkResource, wszPreferredLocale, pCtx):\n        request = IWbemLevel1Login_NTLMLogin()\n        request['wszNetworkResource'] = checkNullString(wszNetworkResource)\n        request['wszPreferredLocale'] = checkNullString(wszPreferredLocale)\n        request['lFlags'] = 0\n        request['pCtx'] = pCtx\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        return IWbemServices(\n            INTERFACE(self.get_cinstance(), b''.join(resp['ppNamespace']['abData']), self.get_ipidRemUnknown(),\n                      target=self.get_target()))",
  "def __init__(self, error_string=None, error_code=None, packet=None):\n        DCERPCException.__init__(self, error_string, error_code, packet)",
  "def __str__( self ):\n        if self.error_code in hresult_errors.ERROR_MESSAGES:\n            error_msg_short = hresult_errors.ERROR_MESSAGES[self.error_code][0]\n            error_msg_verbose = hresult_errors.ERROR_MESSAGES[self.error_code][1] \n            return 'WMI SessionError: code: 0x%x - %s - %s' % (self.error_code, error_msg_short, error_msg_verbose)\n        else:\n            # Let's see if we have it as WBEMSTATUS\n            try:\n                return 'WMI Session Error: code: 0x%x - %s' % (self.error_code, WBEMSTATUS.enumItems(self.error_code).name)\n            except:\n                return 'WMI SessionError: unknown error code: 0x%x' % self.error_code",
  "def __init__(self, data = None, alignment = 0):\n        Structure.__init__(self, data, alignment)\n        if data is not None:\n            # Let's first check the commonHdr\n            self.fromString(data)\n            self.structure = ()\n            self.isUnicode = False\n            if len(data) > 1:\n                if self['Encoded_String_Flag'] == 0:\n                    self.structure += self.tascii\n                    # Let's search for the end of the string\n                    index = data[1:].find(b'\\x00')\n                    data  = data[:index+1+1]\n                else:\n                    self.structure = self.tunicode\n                    self.isUnicode = True\n\n                self.fromString(data)\n        else:\n            self.structure = self.tascii\n            self.data = None",
  "def __getitem__(self, key):\n        if key == 'Character' and self.isUnicode:\n            return self.fields['Character'].decode('utf-16le')\n        return Structure.__getitem__(self, key)",
  "def __getattr__(self, attr):\n        return self.enumItems[attr].value",
  "def getValue(cls, cimType, entry, heap):\n        # Let's get the default Values\n        pType = cimType & (~(CIM_ARRAY_FLAG|Inherited))\n\n        if entry != 0xffffffff:\n            heapData = heap[entry:]\n            if cimType & CIM_ARRAY_FLAG:\n                # We have an array, let's set the right unpackStr and dataSize for the array contents\n                dataSize = calcsize(HEAPREF[:-2])\n                numItems = unpack(HEAPREF[:-2], heapData[:dataSize])[0]\n                heapData = heapData[dataSize:]\n                array = list()\n                unpackStrArray =  CIM_TYPES_REF[pType][:-2]\n                dataSizeArray = calcsize(unpackStrArray)\n                if cimType == CIM_TYPE_ENUM.CIM_ARRAY_STRING.value:\n                    # We have an array of strings\n                    # First items are DWORDs with the string pointers\n                    # inside the heap. We don't need those ones\n                    heapData = heapData[4*numItems:]\n                    # Let's now grab the strings\n                    for _ in range(numItems):\n                        item = ENCODED_STRING(heapData)\n                        array.append(item['Character'])\n                        heapData = heapData[len(item.getData()):]\n                elif cimType == CIM_TYPE_ENUM.CIM_ARRAY_OBJECT.value:\n                    # Discard the pointers\n                    heapData = heapData[dataSize*numItems:]\n                    for item in range(numItems):\n                        msb = METHOD_SIGNATURE_BLOCK(heapData)\n                        unit = ENCODING_UNIT()\n                        unit['ObjectEncodingLength'] = msb['EncodingLength']\n                        unit['ObjectBlock'] = msb['ObjectBlock']\n                        array.append(unit)\n                        heapData = heapData[msb['EncodingLength']+4:]\n                else:\n                    for item in range(numItems):\n                        # ToDo: Learn to unpack the rest of the array of things\n                        array.append(unpack(unpackStrArray, heapData[:dataSizeArray])[0])\n                        heapData = heapData[dataSizeArray:]\n                value = array\n            elif pType == CIM_TYPE_ENUM.CIM_TYPE_BOOLEAN.value:\n                if entry == 0xffff:\n                    value = 'True'\n                else:\n                    value = 'False'\n            elif pType == CIM_TYPE_ENUM.CIM_TYPE_OBJECT.value:\n                # If the value type is CIM-TYPE-OBJECT, the EncodedValue is a HeapRef to the object encoded as an\n                # ObjectEncodingLength (section 2.2.4) followed by an ObjectBlock (section 2.2.5).\n\n                # ToDo: This is a hack.. We should parse this better. We need to have an ENCODING_UNIT.\n                # I'm going through a METHOD_SIGNATURE_BLOCK first just to parse the ObjectBlock\n                msb = METHOD_SIGNATURE_BLOCK(heapData)\n                unit = ENCODING_UNIT()\n                unit['ObjectEncodingLength'] = msb['EncodingLength']\n                unit['ObjectBlock'] = msb['ObjectBlock']\n                value = unit\n            elif pType not in (CIM_TYPE_ENUM.CIM_TYPE_STRING.value, CIM_TYPE_ENUM.CIM_TYPE_DATETIME.value,\n                               CIM_TYPE_ENUM.CIM_TYPE_REFERENCE.value):\n                value = entry\n            else:\n                try:\n                    value = ENCODED_STRING(heapData)['Character']\n                except UnicodeDecodeError:\n                    if logging.getLogger().level == logging.DEBUG:\n                        LOG.debug('Unicode Error: dumping heapData')\n                        hexdump(heapData)\n                    raise\n\n            return value",
  "def __init__(self, data = None, alignment = 0):\n        Structure.__init__(self, data, alignment)\n        if data is not None:\n            # Let's first check the commonHdr\n            self.fromString(data)\n            self.structure = (('QualifierValue', CIM_TYPES_REF[self[\"QualifierType\"] & (~CIM_ARRAY_FLAG)]),)\n            self.fromString(data)\n        else:\n            self.data = None",
  "def getQualifiers(self, heap):\n        data = self['Qualifier']\n        qualifiers = dict()\n        while len(data) > 0:\n            itemn = QUALIFIER(data)\n            if itemn['QualifierName'] == 0xffffffff:\n                qName = b''\n            elif itemn['QualifierName'] & 0x80000000:\n                qName = DICTIONARY_REFERENCE[itemn['QualifierName'] & 0x7fffffff]\n            else:\n                qName = ENCODED_STRING(heap[itemn['QualifierName']:])['Character']\n\n            value = ENCODED_VALUE.getValue(itemn['QualifierType'], itemn['QualifierValue'], heap)\n            qualifiers[qName] = value\n            data = data[len(itemn):]\n\n        return qualifiers",
  "def getProperties(self, heap):\n        propTable = self['PropertyLookup']\n        properties = dict()\n        for property in range(self['PropertyCount']):\n            propItemDict = dict()\n            propItem = PropertyLookup(propTable)\n            if propItem['PropertyNameRef'] & 0x80000000:\n                propName = DICTIONARY_REFERENCE[propItem['PropertyNameRef'] & 0x7fffffff]\n            else:\n                propName = ENCODED_STRING(heap[propItem['PropertyNameRef']:])['Character']\n            propInfo = PROPERTY_INFO(heap[propItem['PropertyInfoRef']:])\n            pType = propInfo['PropertyType']\n            pType &= (~CIM_ARRAY_FLAG)\n            pType &= (~Inherited)\n            sType = CIM_TYPE_TO_NAME[pType]\n \n            propItemDict['stype'] = sType\n            propItemDict['name'] = propName\n            propItemDict['type'] = propInfo['PropertyType']\n            propItemDict['order'] = propInfo['DeclarationOrder']\n            propItemDict['inherited'] = propInfo['PropertyType'] & Inherited\n            propItemDict['value'] = None\n\n            qualifiers = dict() \n            qualifiersBuf = propInfo['PropertyQualifierSet']['Qualifier']\n            while len(qualifiersBuf) > 0:\n                record = QUALIFIER(qualifiersBuf)\n                if record['QualifierName'] & 0x80000000:\n                    qualifierName = DICTIONARY_REFERENCE[record['QualifierName'] & 0x7fffffff]\n                else:\n                    qualifierName = ENCODED_STRING(heap[record['QualifierName']:])['Character']\n                qualifierValue = ENCODED_VALUE.getValue(record['QualifierType'], record['QualifierValue'], heap)\n                qualifiersBuf = qualifiersBuf[len(record):]\n                qualifiers[qualifierName] = qualifierValue\n\n            propItemDict['qualifiers'] = qualifiers\n            properties[propName] = propItemDict\n\n            propTable = propTable[self.PropertyLookupSize:]\n\n        return OrderedDict(sorted(list(properties.items()), key=lambda x:x[1]['order']))",
  "def getQualifiers(self):\n        return self[\"ClassQualifierSet\"].getQualifiers(self[\"ClassHeap\"][\"HeapItem\"])",
  "def getProperties(self):\n        heap = self[\"ClassHeap\"][\"HeapItem\"]\n        properties =  self[\"PropertyLookupTable\"].getProperties(self[\"ClassHeap\"][\"HeapItem\"])\n        sorted_props = sorted(list(properties.keys()), key=lambda k: properties[k]['order'])\n        valueTableOff = (len(properties) - 1) // 4 + 1\n        valueTable = self['NdTable_ValueTable'][valueTableOff:]\n        for key in sorted_props:\n            # Let's get the default Values\n            pType = properties[key]['type'] & (~(CIM_ARRAY_FLAG|Inherited))\n            if properties[key]['type'] & CIM_ARRAY_FLAG:\n                unpackStr = HEAPREF[:-2]\n            else:\n                unpackStr = CIM_TYPES_REF[pType][:-2]\n            dataSize = calcsize(unpackStr)\n            try:\n                itemValue = unpack(unpackStr, valueTable[:dataSize])[0]\n            except: \n                LOG.error(\"getProperties: Error unpacking!!\")\n                itemValue = 0xffffffff\n\n            if itemValue != 0xffffffff and itemValue > 0:\n                value = ENCODED_VALUE.getValue(properties[key]['type'], itemValue, heap)\n                properties[key]['value'] = \"%s\" % value\n            valueTable = valueTable[dataSize:]\n        return properties",
  "def getMethods(self):\n        methods = OrderedDict()\n        data = self['MethodDescription']\n        heap = self['MethodHeap']['HeapItem']\n\n        for method in range(self['MethodCount']):\n            methodDict = OrderedDict()\n            itemn = METHOD_DESCRIPTION(data)\n            if itemn['MethodFlags'] & WBEM_FLAVOR_ORIGIN_PROPAGATED:\n               # ToDo\n               #print \"WBEM_FLAVOR_ORIGIN_PROPAGATED not yet supported!\"\n               #raise\n               pass\n            methodDict['name'] = ENCODED_STRING(heap[itemn['MethodName']:])['Character']\n            methodDict['origin'] = itemn['MethodOrigin']\n            if itemn['MethodQualifiers'] != 0xffffffff:\n                # There are qualifiers\n                qualifiersSet = QUALIFIER_SET(heap[itemn['MethodQualifiers']:])\n                qualifiers = qualifiersSet.getQualifiers(heap)\n                methodDict['qualifiers'] = qualifiers\n            if itemn['InputSignature'] != 0xffffffff:\n                inputSignature = METHOD_SIGNATURE_BLOCK(heap[itemn['InputSignature']:])\n                if inputSignature['EncodingLength'] > 0:\n                    methodDict['InParams'] = inputSignature['ObjectBlock']['ClassType']['CurrentClass'].getProperties()\n                    methodDict['InParamsRaw'] = inputSignature['ObjectBlock']\n                    #print methodDict['InParams'] \n                else:\n                    methodDict['InParams'] = None\n            if itemn['OutputSignature'] != 0xffffffff:\n                outputSignature = METHOD_SIGNATURE_BLOCK(heap[itemn['OutputSignature']:])\n                if outputSignature['EncodingLength'] > 0:\n                    methodDict['OutParams'] = outputSignature['ObjectBlock']['ClassType']['CurrentClass'].getProperties()\n                    methodDict['OutParamsRaw'] = outputSignature['ObjectBlock']\n                else:\n                    methodDict['OutParams'] = None\n            data = data[len(itemn):]\n            methods[methodDict['name']] = methodDict\n\n        return methods",
  "def getClassName(self):\n        pClassName = self['ClassPart']['ClassHeader']['ClassNameRef']\n        cHeap = self['ClassPart']['ClassHeap']['HeapItem']\n        if pClassName == 0xffffffff:\n            return 'None'\n        else:\n            className = ENCODED_STRING(cHeap[pClassName:])['Character']\n            derivationList = self['ClassPart']['DerivationList']['ClassNameEncoding']\n            while len(derivationList) > 0:\n                superClass = ENCODED_STRING(derivationList)['Character']\n                className += ' : %s ' % superClass\n                derivationList = derivationList[len(ENCODED_STRING(derivationList))+4:]\n            return className",
  "def getQualifiers(self):\n        return self[\"ClassPart\"].getQualifiers()",
  "def getProperties(self):\n        #print format_structure(self[\"ClassPart\"].getProperties())\n        return self[\"ClassPart\"].getProperties()",
  "def getMethods(self):\n        return self[\"MethodsPart\"].getMethods()",
  "def getMethods(self):\n        return ()",
  "def __init__(self, data = None, alignment = 0):\n        Structure.__init__(self, data, alignment)\n        self.structure = ()\n        if data is not None:\n            # Let's first check the commonHdr\n            self.fromString(data)\n            if self['InstPropQualSetFlag'] == 2:\n                # We don't support this yet!\n                raise Exception(\"self['InstPropQualSetFlag'] == 2\")\n            self.fromString(data)\n        else:\n            self.data = None",
  "def __init__(self, data = None, alignment = 0):\n        Structure.__init__(self, data, alignment)\n        self.structure = ()\n        if data is not None:\n            # Let's first check the commonHdr\n            self.fromString(data)\n            #hexdump(data[len(self.getData()):])\n            self.NdTableSize = (self['CurrentClass']['ClassPart']['PropertyLookupTable']['PropertyCount'] - 1) //4 + 1\n            #self.InstanceDataSize = self['CurrentClass']['ClassPart']['PropertyLookupTable']['PropertyCount'] * len(InstanceData())\n            self.fromString(data)\n        else:\n            self.data = None",
  "def __processNdTable(self, properties):\n        octetCount = (len(properties) - 1) // 4 + 1  # see [MS-WMIO]: 2.2.26 NdTable\n        packedNdTable = self['NdTable_ValueTable'][:octetCount]\n        unpackedNdTable = [(byte >> shift) & 0b11 for byte in six.iterbytes(packedNdTable) for shift in (0, 2, 4, 6)]\n        for key in properties:\n            ndEntry = unpackedNdTable[properties[key]['order']]\n            properties[key]['null_default'] = bool(ndEntry & 0b01)\n            properties[key]['inherited_default'] = bool(ndEntry & 0b10)\n\n        return octetCount",
  "def __isNonNullNumber(prop):\n        return prop['type'] & ~Inherited in CIM_NUMBER_TYPES and not prop['null_default']",
  "def getValues(self, properties):\n        heap = self[\"InstanceHeap\"][\"HeapItem\"]\n        valueTableOff = self.__processNdTable(properties)\n        valueTable = self['NdTable_ValueTable'][valueTableOff:]\n        sorted_props = sorted(list(properties.keys()), key=lambda k: properties[k]['order'])\n        for key in sorted_props:\n            pType = properties[key]['type'] & (~(CIM_ARRAY_FLAG|Inherited))\n            if properties[key]['type'] & CIM_ARRAY_FLAG:\n                unpackStr = HEAPREF[:-2]\n            else:\n                unpackStr = CIM_TYPES_REF[pType][:-2]\n            dataSize = calcsize(unpackStr)\n            try:\n                itemValue = unpack(unpackStr, valueTable[:dataSize])[0]\n            except:\n                LOG.error(\"getValues: Error Unpacking!\")\n                itemValue = 0xffffffff\n\n            # if itemValue == 0, default value remains\n            if itemValue != 0 or self.__isNonNullNumber(properties[key]):\n                value = ENCODED_VALUE.getValue( properties[key]['type'], itemValue, heap)\n                properties[key]['value'] = value\n            # is the value set valid or should we clear it? ( if not inherited )\n            elif properties[key]['inherited'] == 0:\n                properties[key]['value'] = None\n            valueTable = valueTable[dataSize:]\n        return properties",
  "def __init__(self, data = None, alignment = 0):\n        Structure.__init__(self, data, alignment)\n        self.ctParent  = None\n        self.ctCurrent = None\n\n        if data is not None:\n            self.structure = ()\n            if ord(data[0:1]) & 0x4:\n                # WMIO - 2.2.6 - 0x04 If this flag is set, the object has a Decoration block.\n                self.structure += self.decoration\n            if ord(data[0:1]) & 0x01:\n                # The object is a CIM class. \n                self.structure += self.classType\n            else:\n                self.structure += self.instanceType\n\n            self.fromString(data)\n        else:\n            self.data = None",
  "def isInstance(self):\n        if self['ObjectFlags'] & 0x01:\n            return False\n        return True",
  "def printClass(self, pClass, cInstance = None):\n        qualifiers = pClass.getQualifiers()\n\n        for qualifier in qualifiers:\n            print(\"[%s]\" % qualifier)\n\n        className = pClass.getClassName()\n\n        print(\"class %s \\n{\" % className)\n\n        properties = pClass.getProperties()\n        if cInstance is not None:\n            properties = cInstance.getValues(properties)\n\n        for pName in properties:\n            #if property['inherited'] == 0:\n                qualifiers = properties[pName]['qualifiers']\n                for qName in qualifiers:\n                    if qName != 'CIMTYPE':\n                        print('\\t[%s(%s)]' % (qName, qualifiers[qName]))\n                print(\"\\t%s %s\" % (properties[pName]['stype'], properties[pName]['name']), end=' ')\n                if properties[pName]['value'] is not None:\n                    if properties[pName]['type'] == CIM_TYPE_ENUM.CIM_TYPE_OBJECT.value:\n                        print('= IWbemClassObject\\n')\n                    elif properties[pName]['type'] == CIM_TYPE_ENUM.CIM_ARRAY_OBJECT.value:\n                        if properties[pName]['value'] == 0:\n                            print('= %s\\n' % properties[pName]['value'])\n                        else:\n                            print('= %s\\n' % list('IWbemClassObject' for _ in range(len(properties[pName]['value']))))\n                    else:\n                        print('= %s\\n' % properties[pName]['value'])\n                else:\n                    print('\\n')\n\n        print() \n        methods = pClass.getMethods()\n        for methodName in methods:\n            for qualifier in methods[methodName]['qualifiers']:\n                print('\\t[%s]' % qualifier)\n\n            if methods[methodName]['InParams'] is None and methods[methodName]['OutParams'] is None: \n                print('\\t%s %s();\\n' % ('void', methodName))\n            if methods[methodName]['InParams'] is None and len(methods[methodName]['OutParams']) == 1:\n                print('\\t%s %s();\\n' % (methods[methodName]['OutParams']['ReturnValue']['stype'], methodName))\n            else:\n                returnValue = b''\n                if methods[methodName]['OutParams'] is not None:\n                    # Search the Return Value\n                    #returnValue = (item for item in method['OutParams'] if item[\"name\"] == \"ReturnValue\").next()\n                    if 'ReturnValue' in methods[methodName]['OutParams']:\n                        returnValue = methods[methodName]['OutParams']['ReturnValue']['stype']\n \n                print('\\t%s %s(\\n' % (returnValue, methodName), end=' ')\n                if methods[methodName]['InParams'] is not None:\n                    for pName  in methods[methodName]['InParams']:\n                        print('\\t\\t[in]    %s %s,' % (methods[methodName]['InParams'][pName]['stype'], pName))\n\n                if methods[methodName]['OutParams'] is not None:\n                    for pName in methods[methodName]['OutParams']:\n                        if pName != 'ReturnValue':\n                            print('\\t\\t[out]    %s %s,' % (methods[methodName]['OutParams'][pName]['stype'], pName))\n\n                print('\\t);\\n')\n\n        print(\"}\")",
  "def parseClass(self, pClass, cInstance = None):\n        classDict = OrderedDict()\n        classDict['name'] = pClass.getClassName()\n        classDict['qualifiers'] = pClass.getQualifiers()\n        classDict['properties'] = pClass.getProperties()\n        classDict['methods'] = pClass.getMethods()\n        if cInstance is not None:\n            classDict['values'] = cInstance.getValues(classDict['properties'])\n        else:\n            classDict['values'] = None\n\n        return classDict",
  "def parseObject(self):\n        if (self['ObjectFlags'] & 0x01) == 0:\n            # instance\n            ctCurrent = self['InstanceType']['CurrentClass']\n            currentName = ctCurrent.getClassName()\n            if currentName is not None:\n                self.ctCurrent = self.parseClass(ctCurrent, self['InstanceType'])\n            return\n        else: \n            ctParent = self['ClassType']['ParentClass']\n            ctCurrent = self['ClassType']['CurrentClass']\n\n            parentName = ctParent.getClassName()\n            if parentName is not None:\n                self.ctParent = self.parseClass(ctParent)\n\n            currentName = ctCurrent.getClassName()\n            if currentName is not None:\n                self.ctCurrent = self.parseClass(ctCurrent)",
  "def printInformation(self):\n        # First off, do we have a class?\n        if (self['ObjectFlags'] & 0x01) == 0:\n            # instance\n            ctCurrent = self['InstanceType']['CurrentClass']\n            currentName = ctCurrent.getClassName()\n            if currentName is not None:\n                self.printClass(ctCurrent, self['InstanceType'])\n            return\n        else: \n            ctParent = self['ClassType']['ParentClass']\n            ctCurrent = self['ClassType']['CurrentClass']\n\n            parentName = ctParent.getClassName()\n            if parentName is not None:\n                self.printClass(ctParent)\n\n            currentName = ctCurrent.getClassName()\n            if currentName is not None:\n                self.printClass(ctCurrent)",
  "def __init__(self, data = None, alignment = 0):\n        Structure.__init__(self, data, alignment)\n        if data is not None:\n            self.fromString(data)\n            if self['EncodingLength'] > 0:\n                self.structure = ()\n                self.structure += self.tail\n            self.fromString(data)\n        else:\n            self.data = None",
  "class enumItems(Enum):\n        WBEM_FLAG_CREATE_OR_UPDATE  = 0x00\n        WBEM_FLAG_UPDATE_ONLY       = 0x01\n        WBEM_FLAG_CREATE_ONLY       = 0x02\n        WBEM_FLAG_UPDATE_SAFE_MODE  = 0x20\n        WBEM_FLAG_UPDATE_FORCE_MODE = 0x40",
  "class enumItems(Enum):\n        WBEM_FLAG_RETURN_WBEM_COMPLETE   = 0x00\n        WBEM_FLAG_RETURN_IMMEDIATELY     = 0x10\n        WBEM_FLAG_FORWARD_ONLY           = 0x20\n        WBEM_FLAG_NO_ERROR_OBJECT        = 0x40\n        WBEM_FLAG_SEND_STATUS            = 0x80\n        WBEM_FLAG_ENSURE_LOCATABLE       = 0x100\n        WBEM_FLAG_DIRECT_READ            = 0x200\n        WBEM_MASK_RESERVED_FLAGS         = 0x1F000\n        WBEM_FLAG_USE_AMENDED_QUALIFIERS = 0x20000\n        WBEM_FLAG_STRONG_VALIDATION      = 0x100000",
  "class enumItems(Enum):\n        WBEM_STATUS_COMPLETE     = 0x00\n        WBEM_STATUS_REQUIREMENTS = 0x01\n        WBEM_STATUS_PROGRESS     = 0x02",
  "class enumItems(Enum):\n        WBEM_NO_WAIT  = 0x00000000\n        WBEM_INFINITE = 0xFFFFFFFF",
  "class enumItems(Enum):\n        WBEM_FLAG_DEEP      = 0x00000000\n        WBEM_FLAG_SHALLOW   = 0x00000001\n        WBEM_FLAG_PROTOTYPE = 0x00000002",
  "class enumItems(Enum):\n        WBEM_FLAG_BACKUP_RESTORE_FORCE_SHUTDOWN = 0x00000001",
  "class enumItems(Enum):\n        WBEM_S_NO_ERROR                      = 0x00000000\n        WBEM_S_FALSE                         = 0x00000001\n        WBEM_S_TIMEDOUT                      = 0x00040004\n        WBEM_S_NEW_STYLE                     = 0x000400FF\n        WBEM_S_PARTIAL_RESULTS               = 0x00040010\n        WBEM_E_FAILED                        = 0x80041001\n        WBEM_E_NOT_FOUND                     = 0x80041002\n        WBEM_E_ACCESS_DENIED                 = 0x80041003\n        WBEM_E_PROVIDER_FAILURE              = 0x80041004\n        WBEM_E_TYPE_MISMATCH                 = 0x80041005\n        WBEM_E_OUT_OF_MEMORY                 = 0x80041006\n        WBEM_E_INVALID_CONTEXT               = 0x80041007\n        WBEM_E_INVALID_PARAMETER             = 0x80041008\n        WBEM_E_NOT_AVAILABLE                 = 0x80041009\n        WBEM_E_CRITICAL_ERROR                = 0x8004100a\n        WBEM_E_NOT_SUPPORTED                 = 0x8004100c\n        WBEM_E_PROVIDER_NOT_FOUND            = 0x80041011\n        WBEM_E_INVALID_PROVIDER_REGISTRATION = 0x80041012\n        WBEM_E_PROVIDER_LOAD_FAILURE         = 0x80041013\n        WBEM_E_INITIALIZATION_FAILURE        = 0x80041014\n        WBEM_E_TRANSPORT_FAILURE             = 0x80041015\n        WBEM_E_INVALID_OPERATION             = 0x80041016\n        WBEM_E_ALREADY_EXISTS                = 0x80041019\n        WBEM_E_UNEXPECTED                    = 0x8004101d\n        WBEM_E_INCOMPLETE_CLASS              = 0x80041020\n        WBEM_E_SHUTTING_DOWN                 = 0x80041033\n        E_NOTIMPL                            = 0x80004001\n        WBEM_E_INVALID_SUPERCLASS            = 0x8004100D\n        WBEM_E_INVALID_NAMESPACE             = 0x8004100E\n        WBEM_E_INVALID_OBJECT                = 0x8004100F\n        WBEM_E_INVALID_CLASS                 = 0x80041010\n        WBEM_E_INVALID_QUERY                 = 0x80041017\n        WBEM_E_INVALID_QUERY_TYPE            = 0x80041018\n        WBEM_E_PROVIDER_NOT_CAPABLE          = 0x80041024\n        WBEM_E_CLASS_HAS_CHILDREN            = 0x80041025\n        WBEM_E_CLASS_HAS_INSTANCES           = 0x80041026\n        WBEM_E_ILLEGAL_NULL                  = 0x80041028\n        WBEM_E_INVALID_CIM_TYPE              = 0x8004102D\n        WBEM_E_INVALID_METHOD                = 0x8004102E\n        WBEM_E_INVALID_METHOD_PARAMETERS     = 0x8004102F\n        WBEM_E_INVALID_PROPERTY              = 0x80041031\n        WBEM_E_CALL_CANCELLED                = 0x80041032\n        WBEM_E_INVALID_OBJECT_PATH           = 0x8004103A\n        WBEM_E_OUT_OF_DISK_SPACE             = 0x8004103B\n        WBEM_E_UNSUPPORTED_PUT_EXTENSION     = 0x8004103D\n        WBEM_E_QUOTA_VIOLATION               = 0x8004106c\n        WBEM_E_SERVER_TOO_BUSY               = 0x80041045\n        WBEM_E_METHOD_NOT_IMPLEMENTED        = 0x80041055\n        WBEM_E_METHOD_DISABLED               = 0x80041056\n        WBEM_E_UNPARSABLE_QUERY              = 0x80041058\n        WBEM_E_NOT_EVENT_CLASS               = 0x80041059\n        WBEM_E_MISSING_GROUP_WITHIN          = 0x8004105A\n        WBEM_E_MISSING_AGGREGATION_LIST      = 0x8004105B\n        WBEM_E_PROPERTY_NOT_AN_OBJECT        = 0x8004105c\n        WBEM_E_AGGREGATING_BY_OBJECT         = 0x8004105d\n        WBEM_E_BACKUP_RESTORE_WINMGMT_RUNNING= 0x80041060\n        WBEM_E_QUEUE_OVERFLOW                = 0x80041061\n        WBEM_E_PRIVILEGE_NOT_HELD            = 0x80041062\n        WBEM_E_INVALID_OPERATOR              = 0x80041063\n        WBEM_E_CANNOT_BE_ABSTRACT            = 0x80041065\n        WBEM_E_AMENDED_OBJECT                = 0x80041066\n        WBEM_E_VETO_PUT                      = 0x8004107A\n        WBEM_E_PROVIDER_SUSPENDED            = 0x80041081\n        WBEM_E_ENCRYPTED_CONNECTION_REQUIRED = 0x80041087\n        WBEM_E_PROVIDER_TIMED_OUT            = 0x80041088\n        WBEM_E_NO_KEY                        = 0x80041089\n        WBEM_E_PROVIDER_DISABLED             = 0x8004108a\n        WBEM_E_REGISTRATION_TOO_BROAD        = 0x80042001\n        WBEM_E_REGISTRATION_TOO_PRECISE      = 0x80042002",
  "class enumItems(Enum):\n        WBEM_FLAG_CONNECT_REPOSITORY_ONLY = 0x40\n        WBEM_FLAG_CONNECT_PROVIDERS       = 0x100",
  "class enumItems(Enum):\n        WBEM_FLAG_CONNECT_REPOSITORY_ONLY = 0x40\n        WBEM_FLAG_CONNECT_PROVIDERS       = 0x100",
  "class enumItems(Enum):\n        WBEM_REFRESH_TYPE_INVALID       = 0\n        WBEM_REFRESH_TYPE_REMOTE        = 3\n        WBEM_REFRESH_TYPE_NON_HIPERF    = 6",
  "def __init__(self, interface, iWbemServices = None):\n        IRemUnknown.__init__(self,interface)\n        self._iid = IID_IWbemClassObject\n        self.__iWbemServices = iWbemServices\n        self.__methods = None\n\n        objRef = self.get_objRef()\n        objRef = OBJREF_CUSTOM(objRef)\n        self.encodingUnit = ENCODING_UNIT(objRef['pObjectData'])\n        self.parseObject()\n        if self.encodingUnit['ObjectBlock'].isInstance() is False:\n            self.createMethods(self.getClassName(), self.getMethods())\n        else:\n            self.createProperties(self.getProperties())",
  "def __getattr__(self, attr):\n        if attr.startswith('__') is not True:\n            properties = self.getProperties()\n            # Let's see if there's a key property so we can ExecMethod\n            keyProperty = None\n            for pName in properties:\n                if 'key' in properties[pName]['qualifiers']:\n                    keyProperty = pName\n\n            if keyProperty is None:\n                LOG.error(\"I don't have a key property in this set!\")\n            else:\n                if self.__methods is None:\n                    classObject,_ = self.__iWbemServices.GetObject(self.getClassName())\n                    self.__methods = classObject.getMethods()\n\n                if attr in self.__methods:\n                    # Now we gotta build the class name to be called through ExecMethod\n                    if self.getProperties()[keyProperty]['stype'] != 'string':\n                        instanceName = '%s.%s=%s' % (\n                        self.getClassName(), keyProperty, self.getProperties()[keyProperty]['value'])\n                    else:\n                        instanceName = '%s.%s=\"%s\"' % (\n                        self.getClassName(), keyProperty, self.getProperties()[keyProperty]['value'])\n\n                    self.createMethods(instanceName , self.__methods)\n                    #print dir(self)\n                    return getattr(self, attr)\n\n        raise AttributeError(\"%r object has no attribute %r\" %\n                             (self.__class__, attr))",
  "def parseObject(self):\n        self.encodingUnit['ObjectBlock'].parseObject()",
  "def getObject(self):\n        return self.encodingUnit['ObjectBlock']",
  "def getClassName(self):\n        if self.encodingUnit['ObjectBlock'].isInstance() is False:\n            return self.encodingUnit['ObjectBlock']['ClassType']['CurrentClass'].getClassName().split(' ')[0]\n        else:\n            return self.encodingUnit['ObjectBlock']['InstanceType']['CurrentClass'].getClassName().split(' ')[0]",
  "def printInformation(self):\n        return self.encodingUnit['ObjectBlock'].printInformation()",
  "def getProperties(self):\n        if self.encodingUnit['ObjectBlock'].ctCurrent is None:\n            return ()\n        return self.encodingUnit['ObjectBlock'].ctCurrent['properties']",
  "def getMethods(self):\n        if self.encodingUnit['ObjectBlock'].ctCurrent is None:\n            return ()\n        return self.encodingUnit['ObjectBlock'].ctCurrent['methods']",
  "def __ndEntry(index, null_default, inherited_default):\n        # https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-wmio/ed436785-40fc-425e-ad3d-f9200eb1a122\n        return (bool(null_default) << 1 | bool(inherited_default)) << (2 * index)",
  "def marshalMe(self):\n        # So, in theory, we have the OBJCUSTOM built, but \n        # we need to update the values\n        # That's what we'll do\n\n        instanceHeap = b''\n        valueTable = b''\n        ndTable = 0\n        parametersClass = ENCODED_STRING()\n        parametersClass['Character'] = self.getClassName()\n        instanceHeap += parametersClass.getData()\n        curHeapPtr = len(instanceHeap)\n        properties = self.getProperties()\n        for i, propName in enumerate(properties):\n            propRecord = properties[propName]\n            itemValue = getattr(self, propName)\n            propIsInherited = propRecord['inherited']\n            print(\"PropName %r, Value: %r\" % (propName,itemValue))\n\n            pType = propRecord['type'] & (~(CIM_ARRAY_FLAG|Inherited)) \n            if propRecord['type'] & CIM_ARRAY_FLAG:\n                # Not yet ready\n                packStr = HEAPREF[:-2]\n            else:\n                packStr = CIM_TYPES_REF[pType][:-2]\n\n            if propRecord['type'] & CIM_ARRAY_FLAG:\n                if itemValue is None:\n                    ndTable |= self.__ndEntry(i, True, propIsInherited)\n                    valueTable += pack(packStr, 0)\n                else:\n                    valueTable += pack('<L', curHeapPtr)\n                    arraySize = pack(HEAPREF[:-2], len(itemValue))\n                    packStrArray =  CIM_TYPES_REF[pType][:-2]\n                    arrayItems = b''\n                    for j in range(len(itemValue)):\n                        arrayItems += pack(packStrArray, itemValue[j])\n                    instanceHeap += arraySize + arrayItems\n                    curHeapPtr = len(instanceHeap)\n            elif pType in (CIM_TYPE_ENUM.CIM_TYPE_UINT8.value, CIM_TYPE_ENUM.CIM_TYPE_UINT16.value,\n                           CIM_TYPE_ENUM.CIM_TYPE_UINT32.value, CIM_TYPE_ENUM.CIM_TYPE_UINT64.value):\n                if itemValue is None:\n                    ndTable |= self.__ndEntry(i, True, propIsInherited)\n                    valueTable += pack(packStr, 0)\n                else:\n                    valueTable += pack(packStr, int(itemValue))\n            elif pType in (CIM_TYPE_ENUM.CIM_TYPE_BOOLEAN.value,):\n                if itemValue is None:\n                    ndTable |= self.__ndEntry(i, True, propIsInherited)\n                    valueTable += pack(packStr, False)\n                else:\n                    valueTable += pack(packStr, bool(itemValue))\n            elif pType not in (CIM_TYPE_ENUM.CIM_TYPE_STRING.value, CIM_TYPE_ENUM.CIM_TYPE_DATETIME.value,\n                               CIM_TYPE_ENUM.CIM_TYPE_REFERENCE.value, CIM_TYPE_ENUM.CIM_TYPE_OBJECT.value):\n                if itemValue is None:\n                    ndTable |= self.__ndEntry(i, True, propIsInherited)\n                    valueTable += pack(packStr, -1)\n                else:\n                    valueTable += pack(packStr, itemValue)\n            elif pType == CIM_TYPE_ENUM.CIM_TYPE_OBJECT.value:\n                # For now we just pack None and set the inherited_default\n                # flag, just in case a parent class defines this for us\n                valueTable += b'\\x00'*4\n                if itemValue is None:\n                    ndTable |= self.__ndEntry(i, True, True)\n            else:\n                if itemValue == '':\n                    # https://github.com/fortra/impacket/pull/1069#issuecomment-835179409\n                    # Force inherited_default to avoid 'obscure' issue in wmipersist.py\n                    ndTable |= self.__ndEntry(i, True, True)\n                    valueTable += pack('<L', 0)\n                else:\n                    strIn = ENCODED_STRING()\n                    strIn['Character'] = itemValue\n                    valueTable += pack('<L', curHeapPtr)\n                    instanceHeap += strIn.getData()\n                    curHeapPtr = len(instanceHeap)\n\n        ndTableLen = (len(properties) - 1) // 4 + 1\n        packedNdTable = b''\n        for i in range(ndTableLen):\n            packedNdTable += pack('B', ndTable & 0xff)\n            ndTable >>=  8\n\n        # Now let's update the structure\n        objRef = self.get_objRef()\n        objRef = OBJREF_CUSTOM(objRef)\n        encodingUnit = ENCODING_UNIT(objRef['pObjectData'])\n\n        currentClass = encodingUnit['ObjectBlock']['InstanceType']['CurrentClass']\n        encodingUnit['ObjectBlock']['InstanceType']['CurrentClass'] = b''\n\n        encodingUnit['ObjectBlock']['InstanceType']['NdTable_ValueTable'] = packedNdTable + valueTable\n        encodingUnit['ObjectBlock']['InstanceType']['InstanceHeap']['HeapLength'] = len(instanceHeap) | 0x80000000\n        encodingUnit['ObjectBlock']['InstanceType']['InstanceHeap']['HeapItem'] = instanceHeap\n\n        encodingUnit['ObjectBlock']['InstanceType']['EncodingLength'] = len(encodingUnit['ObjectBlock']['InstanceType'])\n        encodingUnit['ObjectBlock']['InstanceType']['CurrentClass'] = currentClass\n\n        encodingUnit['ObjectEncodingLength'] = len(encodingUnit['ObjectBlock'])\n\n        #encodingUnit.dump()\n        #ENCODING_UNIT(str(encodingUnit)).dump()\n\n        objRef['pObjectData'] = encodingUnit\n\n        return objRef",
  "def SpawnInstance(self):\n        # Doing something similar to:\n        # https://docs.microsoft.com/windows/desktop/api/wbemcli/nf-wbemcli-iwbemclassobject-spawninstance\n        #\n        if self.encodingUnit['ObjectBlock'].isInstance() is False:\n            # We need to convert some things to transform a class into an instance\n            encodingUnit = ENCODING_UNIT()\n\n            instanceData = OBJECT_BLOCK()\n            instanceData.structure += OBJECT_BLOCK.decoration\n            instanceData.structure += OBJECT_BLOCK.instanceType\n            instanceData['ObjectFlags'] = 6\n            instanceData['Decoration'] = self.encodingUnit['ObjectBlock']['Decoration'].getData()\n\n            instanceType = INSTANCE_TYPE()\n            instanceType['CurrentClass'] = b''\n\n            # Let's create the heap for the parameters\n            instanceHeap = b''\n            valueTable = b''\n            parametersClass = ENCODED_STRING()\n            parametersClass['Character'] = self.getClassName()\n            instanceHeap += parametersClass.getData()\n            curHeapPtr = len(instanceHeap)\n\n            ndTable = 0\n            properties = self.getProperties()\n\n            # Let's initialize the values\n            for i, propName in enumerate(properties):\n                propRecord = properties[propName]\n\n                pType = propRecord['type'] & (~(CIM_ARRAY_FLAG|Inherited)) \n                if propRecord['type'] & CIM_ARRAY_FLAG:\n                    # Not yet ready\n                    #print paramDefinition\n                    #raise\n                    packStr = HEAPREF[:-2]\n                else:\n                    packStr = CIM_TYPES_REF[pType][:-2]\n\n                if propRecord['type'] & CIM_ARRAY_FLAG:\n                    valueTable += pack(packStr, 0)\n                elif pType not in (CIM_TYPE_ENUM.CIM_TYPE_STRING.value, CIM_TYPE_ENUM.CIM_TYPE_DATETIME.value,\n                                   CIM_TYPE_ENUM.CIM_TYPE_REFERENCE.value, CIM_TYPE_ENUM.CIM_TYPE_OBJECT.value):\n                    valueTable += pack(packStr, 0)\n                elif pType == CIM_TYPE_ENUM.CIM_TYPE_OBJECT.value:\n                    # For now we just pack None and set the inherited_default\n                    # flag, just in case a parent class defines this for us\n                    valueTable += b'\\x00'*4\n                    ndTable |= self.__ndEntry(i, True, True)\n                else:\n                    strIn = ENCODED_STRING()\n                    strIn['Character'] = ''\n                    valueTable += pack('<L', curHeapPtr)\n                    instanceHeap += strIn.getData()\n                    curHeapPtr = len(instanceHeap)\n\n            ndTableLen = (len(properties) - 1) // 4 + 1\n            packedNdTable = b''\n            for i in range(ndTableLen):\n                packedNdTable += pack('B', ndTable & 0xff)\n                ndTable >>=  8\n\n            instanceType['NdTable_ValueTable'] = packedNdTable + valueTable\n\n            instanceType['InstanceQualifierSet'] = b'\\x04\\x00\\x00\\x00\\x01'\n\n            instanceType['InstanceHeap'] = HEAP()\n            instanceType['InstanceHeap']['HeapItem'] = instanceHeap\n            instanceType['InstanceHeap']['HeapLength'] = len(instanceHeap) | 0x80000000\n            instanceType['EncodingLength'] = len(instanceType)\n\n            instanceType['CurrentClass'] = self.encodingUnit['ObjectBlock']['ClassType']['CurrentClass']['ClassPart']\n            instanceData['InstanceType'] = instanceType.getData()\n\n            encodingUnit['ObjectBlock'] = instanceData\n            encodingUnit['ObjectEncodingLength'] = len(instanceData)\n\n            #ENCODING_UNIT(str(encodingUnit)).dump()\n\n            objRefCustomIn = OBJREF_CUSTOM()\n            objRefCustomIn['iid'] = self._iid\n            objRefCustomIn['clsid'] = CLSID_WbemClassObject\n            objRefCustomIn['cbExtension'] = 0\n            objRefCustomIn['ObjectReferenceSize'] = len(encodingUnit)\n            objRefCustomIn['pObjectData'] = encodingUnit\n\n            # There's gotta be a better way to do this\n            # I will reimplement this stuff once I know it works\n            import copy\n            newObj = copy.deepcopy(self)\n            newObj.set_objRef(objRefCustomIn.getData())\n            newObj.process_interface(objRefCustomIn.getData())\n            newObj.encodingUnit = ENCODING_UNIT(encodingUnit.getData())\n            newObj.parseObject()\n            if newObj.encodingUnit['ObjectBlock'].isInstance() is False:\n                newObj.createMethods(newObj.getClassName(), newObj.getMethods())\n            else:\n                newObj.createProperties(newObj.getProperties())\n\n            return newObj\n        else:\n            return self",
  "def createProperties(self, properties):\n        for property in properties:\n            # Do we have an object property?\n            if properties[property]['type'] == CIM_TYPE_ENUM.CIM_TYPE_OBJECT.value:\n                # Yes.. let's create an Object for it too\n                objRef = OBJREF_CUSTOM()\n                objRef['iid'] = self._iid\n                objRef['clsid'] = CLSID_WbemClassObject\n                objRef['cbExtension'] = 0\n                objRef['ObjectReferenceSize'] = len(properties[property]['value'].getData())\n                objRef['pObjectData'] = properties[property]['value']\n                value = IWbemClassObject( INTERFACE(self.get_cinstance(), objRef.getData(), self.get_ipidRemUnknown(),\n                      oxid=self.get_oxid(), target=self.get_target()))\n            elif properties[property]['type'] == CIM_TYPE_ENUM.CIM_ARRAY_OBJECT.value:\n                if isinstance(properties[property]['value'], list):\n                    value = list()\n                    for item in properties[property]['value']:\n                        # Yes.. let's create an Object for it too\n                        objRef = OBJREF_CUSTOM()\n                        objRef['iid'] = self._iid\n                        objRef['clsid'] = CLSID_WbemClassObject\n                        objRef['cbExtension'] = 0\n                        objRef['ObjectReferenceSize'] = len(item.getData())\n                        objRef['pObjectData'] = item\n                        wbemClass = IWbemClassObject(\n                            INTERFACE(self.get_cinstance(), objRef.getData(), self.get_ipidRemUnknown(),\n                                      oxid=self.get_oxid(), target=self.get_target()))\n                        value.append(wbemClass)\n                else:\n                    value = properties[property]['value']\n            else:\n                value = properties[property]['value']\n            setattr(self, property, value)",
  "def createMethods(self, classOrInstance, methods):\n        class FunctionPool:\n            def __init__(self,function):\n                self.function = function\n            def __getitem__(self,item):\n                return partial(self.function,item)\n\n        @FunctionPool\n        def innerMethod(staticArgs, *args):\n            classOrInstance = staticArgs[0] \n            methodDefinition = staticArgs[1] \n            if methodDefinition['InParams'] is not None:\n                if len(args) != len(methodDefinition['InParams']):\n                    LOG.error(\"Function called with %d parameters instead of %d!\" % (len(args), len(methodDefinition['InParams'])))\n                    return None\n                # In Params\n                encodingUnit = ENCODING_UNIT()\n\n                inParams = OBJECT_BLOCK()\n                inParams.structure += OBJECT_BLOCK.instanceType\n                inParams['ObjectFlags'] = 2\n                inParams['Decoration'] = b''\n\n                instanceType = INSTANCE_TYPE()\n                instanceType['CurrentClass'] = b''\n                instanceType['InstanceQualifierSet'] = b'\\x04\\x00\\x00\\x00\\x01'\n\n                # Let's create the heap for the parameters\n                instanceHeap = b''\n                valueTable = b''\n                parametersClass = ENCODED_STRING()\n                parametersClass['Character'] = '__PARAMETERS'\n                instanceHeap += parametersClass.getData()\n                curHeapPtr = len(instanceHeap)\n\n                ndTable = 0\n                for i in range(len(args)):\n                    paramDefinition = list(methodDefinition['InParams'].values())[i]\n                    inArg = args[i]\n\n                    pType = paramDefinition['type'] & (~(CIM_ARRAY_FLAG|Inherited)) \n                    if paramDefinition['type'] & CIM_ARRAY_FLAG:\n                        # Not yet ready\n                        #print paramDefinition\n                        #raise\n                        packStr = HEAPREF[:-2]\n                    else:\n                        packStr = CIM_TYPES_REF[pType][:-2]\n\n                    if paramDefinition['type'] & CIM_ARRAY_FLAG:\n                        if inArg is None:\n                            valueTable += pack(packStr, 0)\n                        elif pType in (CIM_TYPE_ENUM.CIM_TYPE_STRING.value, CIM_TYPE_ENUM.CIM_TYPE_DATETIME.value,\n                                       CIM_TYPE_ENUM.CIM_TYPE_REFERENCE.value, CIM_TYPE_ENUM.CIM_TYPE_OBJECT.value):\n                            arraySize = pack(HEAPREF[:-2], len(inArg))\n                            arrayItems = []\n                            for j in range(len(inArg)):\n                                curVal = inArg[j]\n                                if pType == CIM_TYPE_ENUM.CIM_TYPE_OBJECT.value:\n                                    curObject = b''\n                                    marshaledObject = curVal.marshalMe()\n                                    curObject += pack('<L', marshaledObject['pObjectData']['ObjectEncodingLength'])\n                                    curObject += marshaledObject['pObjectData']['ObjectBlock'].getData()\n                                    arrayItems.append(curObject)\n                                    continue\n                                strIn = ENCODED_STRING()\n                                if type(curVal) is str:\n                                    # The Encoded-String-Flag is set to 0x01 if the sequence of characters that follows\n                                    # consists of UTF-16 characters (as specified in [UNICODE]) followed by a UTF-16 null\n                                    # terminator.\n                                    strIn['Encoded_String_Flag'] = 0x1\n                                    strIn.structure = strIn.tunicode\n                                    strIn['Character'] = curVal.encode('utf-16le')\n                                else:\n                                    strIn['Character'] = curVal\n                                arrayItems.append(strIn.getData())\n\n\n                            curStrHeapPtr = curHeapPtr + 4\n                            arrayHeapPtrValues = b''\n                            arrayValueTable = b''\n                            for j in range(len(arrayItems)):\n                                arrayHeapPtrValues += pack('<L', curStrHeapPtr + 4 * (len(arrayItems) - j) + len(arrayValueTable))\n                                arrayValueTable += arrayItems[j]\n                                curStrHeapPtr += 4\n\n                            valueTable += pack('<L', curHeapPtr)\n                            instanceHeap += arraySize + arrayHeapPtrValues + arrayValueTable\n                            curHeapPtr = len(instanceHeap)\n                        else:\n                            arraySize = pack(HEAPREF[:-2], len(inArg))\n                            valueTable += pack('<L', curHeapPtr)\n                            instanceHeap += arraySize\n                            for curVal in inArg:\n                                instanceHeap += pack(packStr, curVal)\n                            curHeapPtr = len(instanceHeap)\n                    elif pType not in (CIM_TYPE_ENUM.CIM_TYPE_STRING.value, CIM_TYPE_ENUM.CIM_TYPE_DATETIME.value,\n                                       CIM_TYPE_ENUM.CIM_TYPE_REFERENCE.value, CIM_TYPE_ENUM.CIM_TYPE_OBJECT.value):\n                        valueTable += pack(packStr, inArg)\n                    elif pType == CIM_TYPE_ENUM.CIM_TYPE_OBJECT.value:\n                        if inArg is None:\n                            # For now we just pack None and set the inherited_default\n                            # flag, just in case a parent class defines this for us\n                            valueTable += b'\\x00' * 4\n                            ndTable |= self.__ndEntry(i, True, True)\n                        else:\n                            valueTable += pack('<L', curHeapPtr)\n                            marshaledObject = inArg.marshalMe()\n                            instanceHeap += pack('<L', marshaledObject['pObjectData']['ObjectEncodingLength'])\n                            instanceHeap += marshaledObject['pObjectData']['ObjectBlock'].getData()\n                            curHeapPtr = len(instanceHeap)\n                    else:\n                        strIn = ENCODED_STRING()\n                        if type(inArg) is str:\n                            # The Encoded-String-Flag is set to 0x01 if the sequence of characters that follows\n                            # consists of UTF-16 characters (as specified in [UNICODE]) followed by a UTF-16 null\n                            # terminator.\n                            strIn['Encoded_String_Flag'] = 0x1\n                            strIn.structure = strIn.tunicode\n                            strIn['Character'] = inArg.encode('utf-16le')\n                        else:\n                            strIn['Character'] = inArg\n                        valueTable += pack('<L', curHeapPtr)\n                        instanceHeap += strIn.getData()\n                        curHeapPtr = len(instanceHeap)\n\n                ndTableLen = (len(args) - 1) // 4 + 1\n\n                packedNdTable = b''\n                for i in range(ndTableLen):\n                    packedNdTable += pack('B', ndTable & 0xff)\n                    ndTable >>=  8\n\n                instanceType['NdTable_ValueTable'] = packedNdTable + valueTable\n                heapRecord = HEAP()\n                heapRecord['HeapLength'] = len(instanceHeap) | 0x80000000\n                heapRecord['HeapItem'] = instanceHeap\n                \n                instanceType['InstanceHeap'] = heapRecord\n\n                instanceType['EncodingLength'] = len(instanceType)\n                inMethods = methodDefinition['InParamsRaw']['ClassType']['CurrentClass']['ClassPart']\n                inMethods['ClassHeader']['EncodingLength'] = len(\n                    methodDefinition['InParamsRaw']['ClassType']['CurrentClass']['ClassPart'].getData())\n                instanceType['CurrentClass'] = inMethods\n\n                inParams['InstanceType'] = instanceType.getData()\n\n                encodingUnit['ObjectBlock'] = inParams\n                encodingUnit['ObjectEncodingLength'] = len(inParams)\n\n                objRefCustomIn = OBJREF_CUSTOM()\n                objRefCustomIn['iid'] = self._iid\n                objRefCustomIn['clsid'] = CLSID_WbemClassObject\n                objRefCustomIn['cbExtension'] = 0\n                objRefCustomIn['ObjectReferenceSize'] = len(encodingUnit)\n                objRefCustomIn['pObjectData'] = encodingUnit\n            else:\n                objRefCustomIn = NULL\n\n            ### OutParams\n            encodingUnit = ENCODING_UNIT()\n\n            outParams = OBJECT_BLOCK()\n            outParams.structure += OBJECT_BLOCK.instanceType\n            outParams['ObjectFlags'] = 2\n            outParams['Decoration'] = b''\n\n            instanceType = INSTANCE_TYPE()\n            instanceType['CurrentClass'] = b''\n            instanceType['NdTable_ValueTable'] = b''\n            instanceType['InstanceQualifierSet'] = b''\n            instanceType['InstanceHeap'] = b''\n            instanceType['EncodingLength'] = len(instanceType)\n            instanceType['CurrentClass'] = methodDefinition['OutParamsRaw']['ClassType']['CurrentClass']['ClassPart'].getData()\n            outParams['InstanceType'] = instanceType.getData()\n\n\n            encodingUnit['ObjectBlock'] = outParams\n            encodingUnit['ObjectEncodingLength'] = len(outParams)\n\n            objRefCustom = OBJREF_CUSTOM()\n            objRefCustom['iid'] = self._iid\n            objRefCustom['clsid'] = CLSID_WbemClassObject\n            objRefCustom['cbExtension'] = 0\n            objRefCustom['ObjectReferenceSize'] = len(encodingUnit)\n            objRefCustom['pObjectData'] = encodingUnit\n            try:\n                return self.__iWbemServices.ExecMethod(classOrInstance, methodDefinition['name'], pInParams = objRefCustomIn )\n                #return self.__iWbemServices.ExecMethod('Win32_Process.Handle=\"436\"', methodDefinition['name'],\n                #                                       pInParams=objRefCustomIn).getObject().ctCurrent['properties']\n            except Exception as e:\n                if LOG.level == logging.DEBUG:\n                    import traceback\n                    traceback.print_exc()\n                LOG.error(str(e))\n\n        for methodName in methods:\n           innerMethod.__name__ = methodName\n           setattr(self,innerMethod.__name__,innerMethod[classOrInstance,methods[methodName]])",
  "def __init__(self, interface):\n        IRemUnknown.__init__(self,interface)\n        self._iid = IID_IWbemLoginClientID",
  "def SetClientInfo(self, wszClientMachine, lClientProcId = 1234):\n        request = IWbemLoginClientID_SetClientInfo()\n        request['wszClientMachine'] = checkNullString(wszClientMachine)\n        request['lClientProcId'] = lClientProcId\n        request['lReserved'] = 0\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        return resp",
  "def __init__(self, interface):\n        IRemUnknown.__init__(self,interface)\n        self._iid = IID_IWbemLoginHelper",
  "def SetEvent(self, sEventToSet):\n        request = IWbemLoginHelper_SetEvent()\n        request['sEventToSet'] = sEventToSet\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp",
  "def __init__(self, interface):\n        IRemUnknown.__init__(self,interface)\n        self._iid = IID_IWbemWCOSmartEnum",
  "def Next(self, proxyGUID, lTimeout, uCount):\n        request = IWbemWCOSmartEnum_Next()\n        request['proxyGUID'] = proxyGUID\n        request['lTimeout'] = lTimeout\n        request['uCount'] = uCount\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp",
  "def __init__(self, interface):\n        IRemUnknown.__init__(self,interface)\n        self._iid = IID_IWbemFetchSmartEnum",
  "def GetSmartEnum(self, lTimeout):\n        request = IWbemFetchSmartEnum_GetSmartEnum()\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp",
  "def __init__(self, interface):\n        IRemUnknown.__init__(self,interface)\n        self._iid = IID_IWbemCallResult",
  "def GetResultObject(self, lTimeout):\n        request = IWbemCallResult_GetResultObject()\n        request['lTimeout'] = lTimeout\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp",
  "def GetResultString(self, lTimeout):\n        request = IWbemCallResult_GetResultString()\n        request['lTimeout'] = lTimeout\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp",
  "def GetResultServices(self, lTimeout):\n        request = IWbemCallResult_GetResultServices()\n        request['lTimeout'] = lTimeout\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp",
  "def GetCallStatus(self, lTimeout):\n        request = IWbemCallResult_GetCallStatus()\n        request['lTimeout'] = lTimeout\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        return resp['plStatus']",
  "def __init__(self, interface, iWbemServices = None):\n        IRemUnknown.__init__(self,interface)\n        self._iid = IID_IEnumWbemClassObject\n        self.__iWbemServices = iWbemServices",
  "def Reset(self):\n        request = IEnumWbemClassObject_Reset()\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp",
  "def Next(self, lTimeout, uCount):\n        request = IEnumWbemClassObject_Next()\n        request['lTimeout'] = lTimeout\n        request['uCount'] = uCount\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        interfaces = list()\n        for interface in resp['apObjects']:\n            interfaces.append(IWbemClassObject(\n                INTERFACE(self.get_cinstance(), b''.join(interface['abData']), self.get_ipidRemUnknown(),\n                          oxid=self.get_oxid(), target=self.get_target()), self.__iWbemServices))\n\n        return interfaces",
  "def NextAsync(self, lTimeout, pSink):\n        request = IEnumWbemClassObject_NextAsync()\n        request['lTimeout'] = lTimeout\n        request['pSink'] = pSink\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp",
  "def Clone(self):\n        request = IEnumWbemClassObject_Clone()\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp",
  "def Skip(self, lTimeout, uCount):\n        request = IEnumWbemClassObject_Skip()\n        request['lTimeout'] = lTimeout\n        request['uCount'] = uCount\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp",
  "def __init__(self, interface):\n        IRemUnknown.__init__(self,interface)\n        self._iid = IID_IWbemServices",
  "def OpenNamespace(self, strNamespace, lFlags=0, pCtx = NULL):\n        request = IWbemServices_OpenNamespace()\n        request['strNamespace']['asData'] = strNamespace\n        request['lFlags'] = lFlags\n        request['pCtx'] = pCtx\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp",
  "def CancelAsyncCall(self,IWbemObjectSink ):\n        request = IWbemServices_CancelAsyncCall()\n        request['IWbemObjectSink'] = IWbemObjectSink\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        return resp['ErrorCode']",
  "def QueryObjectSink(self):\n        request = IWbemServices_QueryObjectSink()\n        request['lFlags'] = 0\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        return INTERFACE(self.get_cinstance(), b''.join(resp['ppResponseHandler']['abData']), self.get_ipidRemUnknown(),\n                         target=self.get_target())",
  "def GetObject(self, strObjectPath, lFlags=0, pCtx=NULL):\n        request = IWbemServices_GetObject()\n        request['strObjectPath']['asData'] = strObjectPath\n        request['lFlags'] = lFlags\n        request['pCtx'] = pCtx\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        ppObject = IWbemClassObject(\n            INTERFACE(self.get_cinstance(), b''.join(resp['ppObject']['abData']), self.get_ipidRemUnknown(),\n                      oxid=self.get_oxid(), target=self.get_target()), self)\n        if resp['ppCallResult'] != NULL:\n            ppcallResult = IWbemCallResult(\n                INTERFACE(self.get_cinstance(), b''.join(resp['ppObject']['abData']), self.get_ipidRemUnknown(),\n                          target=self.get_target()))\n        else:\n            ppcallResult = NULL\n        return ppObject, ppcallResult",
  "def GetObjectAsync(self, strNamespace, lFlags=0, pCtx = NULL):\n        request = IWbemServices_GetObjectAsync()\n        request['strObjectPath']['asData'] = checkNullString(strNamespace)\n        request['lFlags'] = lFlags\n        request['pCtx'] = pCtx\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp",
  "def PutClass(self, pObject, lFlags=0, pCtx=NULL):\n        request = IWbemServices_PutClass()\n        request['pObject'] = pObject\n        request['lFlags'] = lFlags\n        request['pCtx'] = pCtx\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp",
  "def PutClassAsync(self, pObject, lFlags=0, pCtx=NULL):\n        request = IWbemServices_PutClassAsync()\n        request['pObject'] = pObject\n        request['lFlags'] = lFlags\n        request['pCtx'] = pCtx\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp",
  "def DeleteClass(self, strClass, lFlags=0, pCtx=NULL):\n        request = IWbemServices_DeleteClass()\n        request['strClass']['asData'] = checkNullString(strClass)\n        request['lFlags'] = lFlags\n        request['pCtx'] = pCtx\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp",
  "def DeleteClassAsync(self, strClass, lFlags=0, pCtx=NULL):\n        request = IWbemServices_DeleteClassAsync()\n        request['strClass']['asData'] = checkNullString(strClass)\n        request['lFlags'] = lFlags\n        request['pCtx'] = pCtx\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp",
  "def CreateClassEnum(self, strSuperClass, lFlags=0, pCtx=NULL):\n        request = IWbemServices_CreateClassEnum()\n        request['strSuperClass']['asData'] = checkNullString(strSuperClass)\n        request['lFlags'] = lFlags\n        request['pCtx'] = pCtx\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp",
  "def CreateClassEnumAsync(self, strSuperClass, lFlags=0, pCtx=NULL):\n        request = IWbemServices_CreateClassEnumAsync()\n        request['strSuperClass']['asData'] = checkNullString(strSuperClass)\n        request['lFlags'] = lFlags\n        request['pCtx'] = pCtx\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp",
  "def PutInstance(self, pInst, lFlags=0, pCtx=NULL):\n        request = IWbemServices_PutInstance()\n\n        if pInst is NULL:\n            request['pInst'] = pInst\n        else:\n            request['pInst']['ulCntData'] = len(pInst)\n            request['pInst']['abData'] = list(pInst.getData())\n        request['lFlags'] = lFlags\n        request['pCtx'] = pCtx\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        return IWbemCallResult(\n            INTERFACE(self.get_cinstance(), b''.join(resp['ppCallResult']['abData']), self.get_ipidRemUnknown(),\n                      target=self.get_target()))",
  "def PutInstanceAsync(self, pInst, lFlags=0, pCtx=NULL):\n        request = IWbemServices_PutInstanceAsync()\n        request['pInst'] = pInst\n        request['lFlags'] = lFlags\n        request['pCtx'] = pCtx\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp",
  "def DeleteInstance(self, strObjectPath, lFlags=0, pCtx=NULL):\n        request = IWbemServices_DeleteInstance()\n        request['strObjectPath']['asData'] = checkNullString(strObjectPath)\n        request['lFlags'] = lFlags\n        request['pCtx'] = pCtx\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        return IWbemCallResult(\n            INTERFACE(self.get_cinstance(), b''.join(resp['ppCallResult']['abData']), self.get_ipidRemUnknown(),\n                      target=self.get_target()))",
  "def DeleteInstanceAsync(self, strObjectPath, lFlags=0, pCtx=NULL):\n        request = IWbemServices_DeleteInstanceAsync()\n        request['strObjectPath']['asData'] = checkNullString(strObjectPath)\n        request['lFlags'] = lFlags\n        request['pCtx'] = pCtx\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp",
  "def CreateInstanceEnum(self, strSuperClass, lFlags=0, pCtx=NULL):\n        request = IWbemServices_CreateInstanceEnum()\n        request['strSuperClass']['asData'] = strSuperClass\n        request['lFlags'] = lFlags\n        request['pCtx'] = pCtx\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return IEnumWbemClassObject(\n            INTERFACE(self.get_cinstance(), b''.join(resp['ppEnum']['abData']), self.get_ipidRemUnknown(),\n                      target=self.get_target()))",
  "def CreateInstanceEnumAsync(self, strSuperClass, lFlags=0, pCtx=NULL):\n        request = IWbemServices_CreateInstanceEnumAsync()\n        request['strSuperClass']['asData'] = checkNullString(strSuperClass)\n        request['lFlags'] = lFlags\n        request['pCtx'] = pCtx\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp",
  "def ExecQuery(self, strQuery, lFlags=0, pCtx=NULL):\n        request = IWbemServices_ExecQuery()\n        request['strQueryLanguage']['asData'] = checkNullString('WQL')\n        request['strQuery']['asData'] = checkNullString(strQuery)\n        request['lFlags'] = lFlags\n        request['pCtx'] = pCtx\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        return IEnumWbemClassObject(\n            INTERFACE(self.get_cinstance(), b''.join(resp['ppEnum']['abData']), self.get_ipidRemUnknown(),\n                      target=self.get_target()), self)",
  "def ExecQueryAsync(self, strQuery, lFlags=0, pCtx=NULL):\n        request = IWbemServices_ExecQueryAsync()\n        request['strQueryLanguage']['asData'] = checkNullString('WQL')\n        request['strQuery']['asData'] = checkNullString(strQuery)\n        request['lFlags'] = lFlags\n        request['pCtx'] = pCtx\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp",
  "def ExecNotificationQuery(self, strQuery, lFlags=0, pCtx=NULL):\n        request = IWbemServices_ExecNotificationQuery()\n        request['strQueryLanguage']['asData'] = checkNullString('WQL')\n        request['strQuery']['asData'] = checkNullString(strQuery)\n        request['lFlags'] = lFlags\n        request['pCtx'] = pCtx\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        return IEnumWbemClassObject(\n            INTERFACE(self.get_cinstance(), b''.join(resp['ppEnum']['abData']), self.get_ipidRemUnknown(),\n                      target=self.get_target()), self)",
  "def ExecNotificationQueryAsync(self, strQuery, lFlags=0, pCtx=NULL):\n        request = IWbemServices_ExecNotificationQueryAsync()\n        request['strQueryLanguage']['asData'] = checkNullString('WQL')\n        request['strQuery']['asData'] = checkNullString(strQuery)\n        request['lFlags'] = lFlags\n        request['pCtx'] = pCtx\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp",
  "def ExecMethod(self, strObjectPath, strMethodName, lFlags=0, pCtx=NULL, pInParams=NULL, ppOutParams = NULL):\n        request = IWbemServices_ExecMethod()\n        request['strObjectPath']['asData'] = checkNullString(strObjectPath)\n        request['strMethodName']['asData'] = checkNullString(strMethodName)\n        request['lFlags'] = lFlags\n        request['pCtx'] = pCtx\n        if pInParams is NULL:\n            request['pInParams'] = pInParams\n        else:\n            request['pInParams']['ulCntData'] = len(pInParams)\n            request['pInParams']['abData'] = list(pInParams.getData())\n\n        request.fields['ppCallResult'] = NULL\n        if ppOutParams is NULL:\n            request.fields['ppOutParams'].fields['Data'] = NULL\n        else:\n            request['ppOutParams']['ulCntData'] = len(ppOutParams.getData())\n            request['ppOutParams']['abData'] = list(ppOutParams.getData())\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        return IWbemClassObject(\n            INTERFACE(self.get_cinstance(), b''.join(resp['ppOutParams']['abData']), self.get_ipidRemUnknown(),\n                      oxid=self.get_oxid(), target=self.get_target()))",
  "def ExecMethodAsync(self, strObjectPath, strMethodName, lFlags=0, pCtx=NULL, pInParams=NULL):\n        request = IWbemServices_ExecMethodAsync()\n        request['strObjectPath']['asData'] = checkNullString(strObjectPath)\n        request['strMethodName']['asData'] = checkNullString(strMethodName)\n        request['lFlags'] = lFlags\n        request['pCtx'] = pCtx\n        request['pInParams'] = pInParams\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp",
  "def __init__(self, interface):\n        IRemUnknown.__init__(self,interface)\n        self._iid = IID_IWbemLevel1Login",
  "def EstablishPosition(self):\n        request = IWbemLevel1Login_EstablishPosition()\n        request['reserved1'] = NULL\n        request['reserved2'] = 0\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        return resp['LocaleVersion']",
  "def RequestChallenge(self):\n        request = IWbemLevel1Login_RequestChallenge()\n        request['reserved1'] = NULL\n        request['reserved2'] = NULL\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        return resp['reserved3']",
  "def WBEMLogin(self):\n        request = IWbemLevel1Login_WBEMLogin()\n        request['reserved1'] = NULL\n        request['reserved2'] = NULL\n        request['reserved3'] = 0\n        request['reserved4'] = NULL\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        return resp['reserved5']",
  "def NTLMLogin(self, wszNetworkResource, wszPreferredLocale, pCtx):\n        request = IWbemLevel1Login_NTLMLogin()\n        request['wszNetworkResource'] = checkNullString(wszNetworkResource)\n        request['wszPreferredLocale'] = checkNullString(wszPreferredLocale)\n        request['lFlags'] = 0\n        request['pCtx'] = pCtx\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        return IWbemServices(\n            INTERFACE(self.get_cinstance(), b''.join(resp['ppNamespace']['abData']), self.get_ipidRemUnknown(),\n                      target=self.get_target()))",
  "class FunctionPool:\n            def __init__(self,function):\n                self.function = function\n            def __getitem__(self,item):\n                return partial(self.function,item)",
  "def innerMethod(staticArgs, *args):\n            classOrInstance = staticArgs[0] \n            methodDefinition = staticArgs[1] \n            if methodDefinition['InParams'] is not None:\n                if len(args) != len(methodDefinition['InParams']):\n                    LOG.error(\"Function called with %d parameters instead of %d!\" % (len(args), len(methodDefinition['InParams'])))\n                    return None\n                # In Params\n                encodingUnit = ENCODING_UNIT()\n\n                inParams = OBJECT_BLOCK()\n                inParams.structure += OBJECT_BLOCK.instanceType\n                inParams['ObjectFlags'] = 2\n                inParams['Decoration'] = b''\n\n                instanceType = INSTANCE_TYPE()\n                instanceType['CurrentClass'] = b''\n                instanceType['InstanceQualifierSet'] = b'\\x04\\x00\\x00\\x00\\x01'\n\n                # Let's create the heap for the parameters\n                instanceHeap = b''\n                valueTable = b''\n                parametersClass = ENCODED_STRING()\n                parametersClass['Character'] = '__PARAMETERS'\n                instanceHeap += parametersClass.getData()\n                curHeapPtr = len(instanceHeap)\n\n                ndTable = 0\n                for i in range(len(args)):\n                    paramDefinition = list(methodDefinition['InParams'].values())[i]\n                    inArg = args[i]\n\n                    pType = paramDefinition['type'] & (~(CIM_ARRAY_FLAG|Inherited)) \n                    if paramDefinition['type'] & CIM_ARRAY_FLAG:\n                        # Not yet ready\n                        #print paramDefinition\n                        #raise\n                        packStr = HEAPREF[:-2]\n                    else:\n                        packStr = CIM_TYPES_REF[pType][:-2]\n\n                    if paramDefinition['type'] & CIM_ARRAY_FLAG:\n                        if inArg is None:\n                            valueTable += pack(packStr, 0)\n                        elif pType in (CIM_TYPE_ENUM.CIM_TYPE_STRING.value, CIM_TYPE_ENUM.CIM_TYPE_DATETIME.value,\n                                       CIM_TYPE_ENUM.CIM_TYPE_REFERENCE.value, CIM_TYPE_ENUM.CIM_TYPE_OBJECT.value):\n                            arraySize = pack(HEAPREF[:-2], len(inArg))\n                            arrayItems = []\n                            for j in range(len(inArg)):\n                                curVal = inArg[j]\n                                if pType == CIM_TYPE_ENUM.CIM_TYPE_OBJECT.value:\n                                    curObject = b''\n                                    marshaledObject = curVal.marshalMe()\n                                    curObject += pack('<L', marshaledObject['pObjectData']['ObjectEncodingLength'])\n                                    curObject += marshaledObject['pObjectData']['ObjectBlock'].getData()\n                                    arrayItems.append(curObject)\n                                    continue\n                                strIn = ENCODED_STRING()\n                                if type(curVal) is str:\n                                    # The Encoded-String-Flag is set to 0x01 if the sequence of characters that follows\n                                    # consists of UTF-16 characters (as specified in [UNICODE]) followed by a UTF-16 null\n                                    # terminator.\n                                    strIn['Encoded_String_Flag'] = 0x1\n                                    strIn.structure = strIn.tunicode\n                                    strIn['Character'] = curVal.encode('utf-16le')\n                                else:\n                                    strIn['Character'] = curVal\n                                arrayItems.append(strIn.getData())\n\n\n                            curStrHeapPtr = curHeapPtr + 4\n                            arrayHeapPtrValues = b''\n                            arrayValueTable = b''\n                            for j in range(len(arrayItems)):\n                                arrayHeapPtrValues += pack('<L', curStrHeapPtr + 4 * (len(arrayItems) - j) + len(arrayValueTable))\n                                arrayValueTable += arrayItems[j]\n                                curStrHeapPtr += 4\n\n                            valueTable += pack('<L', curHeapPtr)\n                            instanceHeap += arraySize + arrayHeapPtrValues + arrayValueTable\n                            curHeapPtr = len(instanceHeap)\n                        else:\n                            arraySize = pack(HEAPREF[:-2], len(inArg))\n                            valueTable += pack('<L', curHeapPtr)\n                            instanceHeap += arraySize\n                            for curVal in inArg:\n                                instanceHeap += pack(packStr, curVal)\n                            curHeapPtr = len(instanceHeap)\n                    elif pType not in (CIM_TYPE_ENUM.CIM_TYPE_STRING.value, CIM_TYPE_ENUM.CIM_TYPE_DATETIME.value,\n                                       CIM_TYPE_ENUM.CIM_TYPE_REFERENCE.value, CIM_TYPE_ENUM.CIM_TYPE_OBJECT.value):\n                        valueTable += pack(packStr, inArg)\n                    elif pType == CIM_TYPE_ENUM.CIM_TYPE_OBJECT.value:\n                        if inArg is None:\n                            # For now we just pack None and set the inherited_default\n                            # flag, just in case a parent class defines this for us\n                            valueTable += b'\\x00' * 4\n                            ndTable |= self.__ndEntry(i, True, True)\n                        else:\n                            valueTable += pack('<L', curHeapPtr)\n                            marshaledObject = inArg.marshalMe()\n                            instanceHeap += pack('<L', marshaledObject['pObjectData']['ObjectEncodingLength'])\n                            instanceHeap += marshaledObject['pObjectData']['ObjectBlock'].getData()\n                            curHeapPtr = len(instanceHeap)\n                    else:\n                        strIn = ENCODED_STRING()\n                        if type(inArg) is str:\n                            # The Encoded-String-Flag is set to 0x01 if the sequence of characters that follows\n                            # consists of UTF-16 characters (as specified in [UNICODE]) followed by a UTF-16 null\n                            # terminator.\n                            strIn['Encoded_String_Flag'] = 0x1\n                            strIn.structure = strIn.tunicode\n                            strIn['Character'] = inArg.encode('utf-16le')\n                        else:\n                            strIn['Character'] = inArg\n                        valueTable += pack('<L', curHeapPtr)\n                        instanceHeap += strIn.getData()\n                        curHeapPtr = len(instanceHeap)\n\n                ndTableLen = (len(args) - 1) // 4 + 1\n\n                packedNdTable = b''\n                for i in range(ndTableLen):\n                    packedNdTable += pack('B', ndTable & 0xff)\n                    ndTable >>=  8\n\n                instanceType['NdTable_ValueTable'] = packedNdTable + valueTable\n                heapRecord = HEAP()\n                heapRecord['HeapLength'] = len(instanceHeap) | 0x80000000\n                heapRecord['HeapItem'] = instanceHeap\n                \n                instanceType['InstanceHeap'] = heapRecord\n\n                instanceType['EncodingLength'] = len(instanceType)\n                inMethods = methodDefinition['InParamsRaw']['ClassType']['CurrentClass']['ClassPart']\n                inMethods['ClassHeader']['EncodingLength'] = len(\n                    methodDefinition['InParamsRaw']['ClassType']['CurrentClass']['ClassPart'].getData())\n                instanceType['CurrentClass'] = inMethods\n\n                inParams['InstanceType'] = instanceType.getData()\n\n                encodingUnit['ObjectBlock'] = inParams\n                encodingUnit['ObjectEncodingLength'] = len(inParams)\n\n                objRefCustomIn = OBJREF_CUSTOM()\n                objRefCustomIn['iid'] = self._iid\n                objRefCustomIn['clsid'] = CLSID_WbemClassObject\n                objRefCustomIn['cbExtension'] = 0\n                objRefCustomIn['ObjectReferenceSize'] = len(encodingUnit)\n                objRefCustomIn['pObjectData'] = encodingUnit\n            else:\n                objRefCustomIn = NULL\n\n            ### OutParams\n            encodingUnit = ENCODING_UNIT()\n\n            outParams = OBJECT_BLOCK()\n            outParams.structure += OBJECT_BLOCK.instanceType\n            outParams['ObjectFlags'] = 2\n            outParams['Decoration'] = b''\n\n            instanceType = INSTANCE_TYPE()\n            instanceType['CurrentClass'] = b''\n            instanceType['NdTable_ValueTable'] = b''\n            instanceType['InstanceQualifierSet'] = b''\n            instanceType['InstanceHeap'] = b''\n            instanceType['EncodingLength'] = len(instanceType)\n            instanceType['CurrentClass'] = methodDefinition['OutParamsRaw']['ClassType']['CurrentClass']['ClassPart'].getData()\n            outParams['InstanceType'] = instanceType.getData()\n\n\n            encodingUnit['ObjectBlock'] = outParams\n            encodingUnit['ObjectEncodingLength'] = len(outParams)\n\n            objRefCustom = OBJREF_CUSTOM()\n            objRefCustom['iid'] = self._iid\n            objRefCustom['clsid'] = CLSID_WbemClassObject\n            objRefCustom['cbExtension'] = 0\n            objRefCustom['ObjectReferenceSize'] = len(encodingUnit)\n            objRefCustom['pObjectData'] = encodingUnit\n            try:\n                return self.__iWbemServices.ExecMethod(classOrInstance, methodDefinition['name'], pInParams = objRefCustomIn )\n                #return self.__iWbemServices.ExecMethod('Win32_Process.Handle=\"436\"', methodDefinition['name'],\n                #                                       pInParams=objRefCustomIn).getObject().ctCurrent['properties']\n            except Exception as e:\n                if LOG.level == logging.DEBUG:\n                    import traceback\n                    traceback.print_exc()\n                LOG.error(str(e))",
  "def __init__(self,function):\n                self.function = function",
  "def __getitem__(self,item):\n                return partial(self.function,item)",
  "class DCERPCSessionError(DCERPCException):\n    def __init__(self, error_string=None, error_code=None, packet=None):\n        DCERPCException.__init__(self, error_string, error_code, packet)\n\n    def __str__( self ):\n        if self.error_code in hresult_errors.ERROR_MESSAGES:\n            error_msg_short = hresult_errors.ERROR_MESSAGES[self.error_code][0]\n            error_msg_verbose = hresult_errors.ERROR_MESSAGES[self.error_code][1] \n            return 'COMEV SessionError: code: 0x%x - %s - %s' % (self.error_code, error_msg_short, error_msg_verbose)\n        else:\n            return 'COMEV SessionError: unknown error code: 0x%x' % self.error_code",
  "class VARENUM(NDRENUM):\n    class enumItems(Enum):\n        VT_EMPTY       = 0\n        VT_NULL        = 1\n        VT_I2          = 2\n        VT_I4          = 3\n        VT_R4          = 4\n        VT_R8          = 5\n        VT_CY          = 6\n        VT_DATE        = 7\n        VT_BSTR        = 8\n        VT_DISPATCH    = 9\n        VT_ERROR       = 0xa\n        VT_BOOL        = 0xb\n        VT_VARIANT     = 0xc\n        VT_UNKNOWN     = 0xd\n        VT_DECIMAL     = 0xe\n        VT_I1          = 0x10\n        VT_UI1         = 0x11\n        VT_UI2         = 0x12\n        VT_UI4         = 0x13\n        VT_I8          = 0x14\n        VT_UI8         = 0x15\n        VT_INT         = 0x16\n        VT_UINT        = 0x17\n        VT_VOID        = 0x18\n        VT_HRESULT     = 0x19\n        VT_PTR         = 0x1a\n        VT_SAFEARRAY   = 0x1b\n        VT_CARRAY      = 0x1c\n        VT_USERDEFINED = 0x1d\n        VT_LPSTR       = 0x1e\n        VT_LPWSTR      = 0x1f\n        VT_RECORD      = 0x24\n        VT_INT_PTR     = 0x25\n        VT_UINT_PTR    = 0x26\n        VT_ARRAY       = 0x2000\n        VT_BYREF       = 0x4000",
  "class TYPEATTR(NDRSTRUCT):\n    structure = (\n    )",
  "class OBJECT_ARRAY(NDRUniConformantVaryingArray):\n    item = PMInterfacePointer",
  "class IEventSystem_Query(DCOMCALL):\n    opnum = 7\n    structure = (\n       ('progID', BSTR),\n       ('queryCriteria', BSTR),\n    )",
  "class IEventSystem_QueryResponse(DCOMANSWER):\n    structure = (\n       ('errorIndex', INT),\n       ('ppInterface', PMInterfacePointer),\n       ('ErrorCode', error_status_t),\n    )",
  "class IEventSystem_Store(DCOMCALL):\n    opnum = 8\n    structure = (\n       ('progID', BSTR),\n       ('pInterface', PMInterfacePointer),\n    )",
  "class IEventSystem_StoreResponse(DCOMANSWER):\n    structure = (\n       ('ErrorCode', error_status_t),\n    )",
  "class IEventSystem_Remove(DCOMCALL):\n    opnum = 9\n    structure = (\n       ('progID', BSTR),\n       ('queryCriteria', BSTR),\n    )",
  "class IEventSystem_RemoveResponse(DCOMANSWER):\n    structure = (\n       ('errorIndex', INT),\n       ('ErrorCode', error_status_t),\n    )",
  "class IEventSystem_get_EventObjectChangeEventClassID(DCOMCALL):\n    opnum = 10\n    structure = (\n    )",
  "class IEventSystem_get_EventObjectChangeEventClassIDResponse(DCOMANSWER):\n    structure = (\n       ('pbstrEventClassID', BSTR),\n       ('ErrorCode', error_status_t),\n    )",
  "class IEventSystem_QueryS(DCOMCALL):\n    opnum = 11\n    structure = (\n       ('progID', BSTR),\n       ('queryCriteria', BSTR),\n    )",
  "class IEventSystem_QuerySResponse(DCOMANSWER):\n    structure = (\n       ('pInterface', PMInterfacePointer),\n       ('ErrorCode', error_status_t),\n    )",
  "class IEventSystem_RemoveS(DCOMCALL):\n    opnum = 12\n    structure = (\n       ('progID', BSTR),\n       ('queryCriteria', BSTR),\n    )",
  "class IEventSystem_RemoveSResponse(DCOMANSWER):\n    structure = (\n       ('ErrorCode', error_status_t),\n    )",
  "class IEventClass_get_EventClassID(DCOMCALL):\n    opnum = 7\n    structure = (\n    )",
  "class IEventClass_get_EventClassIDResponse(DCOMANSWER):\n    structure = (\n       ('pbstrEventClassID', BSTR),\n       ('ErrorCode', error_status_t),\n    )",
  "class IEventClass_put_EventClassID(DCOMCALL):\n    opnum = 8\n    structure = (\n       ('bstrEventClassID', BSTR),\n    )",
  "class IEventClass_put_EventClassIDResponse(DCOMANSWER):\n    structure = (\n       ('ErrorCode', error_status_t),\n    )",
  "class IEventClass_get_EventClassName(DCOMCALL):\n    opnum = 9\n    structure = (\n    )",
  "class IEventClass_get_EventClassNameResponse(DCOMANSWER):\n    structure = (\n       ('pbstrEventClassName', BSTR),\n       ('ErrorCode', error_status_t),\n    )",
  "class IEventClass_put_EventClassName(DCOMCALL):\n    opnum = 10\n    structure = (\n       ('bstrEventClassName', BSTR),\n    )",
  "class IEventClass_put_EventClassNameResponse(DCOMANSWER):\n    structure = (\n       ('ErrorCode', error_status_t),\n    )",
  "class IEventClass_get_OwnerSID(DCOMCALL):\n    opnum = 11\n    structure = (\n    )",
  "class IEventClass_get_OwnerSIDResponse(DCOMANSWER):\n    structure = (\n       ('pbstrOwnerSID', BSTR),\n       ('ErrorCode', error_status_t),\n    )",
  "class IEventClass_put_OwnerSID(DCOMCALL):\n    opnum = 12\n    structure = (\n       ('bstrOwnerSID', BSTR),\n    )",
  "class IEventClass_put_OwnerSIDResponse(DCOMANSWER):\n    structure = (\n       ('ErrorCode', error_status_t),\n    )",
  "class IEventClass_get_FiringInterfaceID(DCOMCALL):\n    opnum = 13\n    structure = (\n    )",
  "class IEventClass_get_FiringInterfaceIDResponse(DCOMANSWER):\n    structure = (\n       ('pbstrFiringInterfaceID', BSTR),\n       ('ErrorCode', error_status_t),\n    )",
  "class IEventClass_put_FiringInterfaceID(DCOMCALL):\n    opnum = 14\n    structure = (\n       ('bstrFiringInterfaceID', BSTR),\n    )",
  "class IEventClass_put_FiringInterfaceIDResponse(DCOMANSWER):\n    structure = (\n       ('ErrorCode', error_status_t),\n    )",
  "class IEventClass_get_Description(DCOMCALL):\n    opnum = 15\n    structure = (\n    )",
  "class IEventClass_get_DescriptionResponse(DCOMANSWER):\n    structure = (\n       ('pbstrDescription', BSTR),\n       ('ErrorCode', error_status_t),\n    )",
  "class IEventClass_put_Description(DCOMCALL):\n    opnum = 16\n    structure = (\n       ('bstrDescription', BSTR),\n    )",
  "class IEventClass_put_DescriptionResponse(DCOMANSWER):\n    structure = (\n       ('ErrorCode', error_status_t),\n    )",
  "class IEventClass_get_TypeLib(DCOMCALL):\n    opnum = 19\n    structure = (\n    )",
  "class IEventClass_get_TypeLibResponse(DCOMANSWER):\n    structure = (\n       ('pbstrTypeLib', BSTR),\n       ('ErrorCode', error_status_t),\n    )",
  "class IEventClass_put_TypeLib(DCOMCALL):\n    opnum = 20\n    structure = (\n       ('bstrTypeLib', BSTR),\n    )",
  "class IEventClass_put_TypeLibResponse(DCOMANSWER):\n    structure = (\n       ('ErrorCode', error_status_t),\n    )",
  "class IEventClass2_get_PublisherID(DCOMCALL):\n    opnum = 21\n    structure = (\n    )",
  "class IEventClass2_get_PublisherIDResponse(DCOMANSWER):\n    structure = (\n       ('pbstrSubscriptionID', BSTR),\n       ('ErrorCode', error_status_t),\n    )",
  "class IEventClass2_put_PublisherID(DCOMCALL):\n    opnum = 22\n    structure = (\n       ('bstrPublisherID', BSTR),\n    )",
  "class IEventClass2_put_PublisherIDResponse(DCOMANSWER):\n    structure = (\n       ('ErrorCode', error_status_t),\n    )",
  "class IEventClass2_get_MultiInterfacePublisherFilterCLSID(DCOMCALL):\n    opnum = 23\n    structure = (\n    )",
  "class IEventClass2_get_MultiInterfacePublisherFilterCLSIDResponse(DCOMANSWER):\n    structure = (\n       ('pbstrPubFilCLSID', BSTR),\n       ('ErrorCode', error_status_t),\n    )",
  "class IEventClass2_put_MultiInterfacePublisherFilterCLSID(DCOMCALL):\n    opnum = 24\n    structure = (\n       ('bstrPubFilCLSID', BSTR),\n    )",
  "class IEventClass2_put_MultiInterfacePublisherFilterCLSIDResponse(DCOMANSWER):\n    structure = (\n       ('ErrorCode', error_status_t),\n    )",
  "class IEventClass2_get_AllowInprocActivation(DCOMCALL):\n    opnum = 25\n    structure = (\n    )",
  "class IEventClass2_get_AllowInprocActivationResponse(DCOMANSWER):\n    structure = (\n       ('pfAllowInprocActivation', BOOLEAN),\n       ('ErrorCode', error_status_t),\n    )",
  "class IEventClass2_put_AllowInprocActivation(DCOMCALL):\n    opnum = 26\n    structure = (\n       ('fAllowInprocActivation', BOOLEAN),\n    )",
  "class IEventClass2_put_AllowInprocActivationResponse(DCOMANSWER):\n    structure = (\n       ('ErrorCode', error_status_t),\n    )",
  "class IEventClass2_get_FireInParallel(DCOMCALL):\n    opnum = 27\n    structure = (\n    )",
  "class IEventClass2_get_FireInParallelResponse(DCOMANSWER):\n    structure = (\n       ('pfFireInParallel', BOOLEAN),\n       ('ErrorCode', error_status_t),\n    )",
  "class IEventClass2_put_FireInParallel(DCOMCALL):\n    opnum = 28\n    structure = (\n       ('pfFireInParallel', BOOLEAN),\n    )",
  "class IEventClass2_put_FireInParallelResponse(DCOMANSWER):\n    structure = (\n       ('ErrorCode', error_status_t),\n    )",
  "class IEventSubscription_get_SubscriptionID(DCOMCALL):\n    opnum = 7\n    structure = (\n    )",
  "class IEventSubscription_get_SubscriptionIDResponse(DCOMANSWER):\n    structure = (\n       ('pbstrSubscriptionID', BSTR),\n       ('ErrorCode', error_status_t),\n    )",
  "class IEventSubscription_put_SubscriptionID(DCOMCALL):\n    opnum = 8\n    structure = (\n       ('bstrSubscriptionID', BSTR),\n    )",
  "class IEventSubscription_put_SubscriptionIDResponse(DCOMANSWER):\n    structure = (\n       ('ErrorCode', error_status_t),\n    )",
  "class IEventSubscription_get_SubscriptionName(DCOMCALL):\n    opnum = 9\n    structure = (\n    )",
  "class IEventSubscription_get_SubscriptionNameResponse(DCOMANSWER):\n    structure = (\n       ('pbstrSubscriptionName', BSTR),\n       ('ErrorCode', error_status_t),\n    )",
  "class IEventSubscription_put_SubscriptionName(DCOMCALL):\n    opnum = 10\n    structure = (\n       ('strSubscriptionID', BSTR),\n    )",
  "class IEventSubscription_put_SubscriptionNameResponse(DCOMANSWER):\n    structure = (\n       ('ErrorCode', error_status_t),\n    )",
  "class IEventSubscription_get_PublisherID(DCOMCALL):\n    opnum = 11\n    structure = (\n    )",
  "class IEventSubscription_get_PublisherIDResponse(DCOMANSWER):\n    structure = (\n       ('pbstrPublisherID', BSTR),\n       ('ErrorCode', error_status_t),\n    )",
  "class IEventSubscription_put_PublisherID(DCOMCALL):\n    opnum = 12\n    structure = (\n       ('bstrPublisherID', BSTR),\n    )",
  "class IEventSubscription_put_PublisherIDResponse(DCOMANSWER):\n    structure = (\n       ('ErrorCode', error_status_t),\n    )",
  "class IEventSubscription_get_EventClassID(DCOMCALL):\n    opnum = 13\n    structure = (\n    )",
  "class IEventSubscription_get_EventClassIDResponse(DCOMANSWER):\n    structure = (\n       ('pbstrEventClassID', BSTR),\n       ('ErrorCode', error_status_t),\n    )",
  "class IEventSubscription_put_EventClassID(DCOMCALL):\n    opnum = 14\n    structure = (\n       ('bstrEventClassID', BSTR),\n    )",
  "class IEventSubscription_put_EventClassIDResponse(DCOMANSWER):\n    structure = (\n       ('ErrorCode', error_status_t),\n    )",
  "class IEventSubscription_get_MethodName(DCOMCALL):\n    opnum = 15\n    structure = (\n    )",
  "class IEventSubscription_get_MethodNameResponse(DCOMANSWER):\n    structure = (\n       ('pbstrMethodName', BSTR),\n       ('ErrorCode', error_status_t),\n    )",
  "class IEventSubscription_put_MethodName(DCOMCALL):\n    opnum = 16\n    structure = (\n       ('bstrMethodName', BSTR),\n    )",
  "class IEventSubscription_put_MethodNameResponse(DCOMANSWER):\n    structure = (\n       ('ErrorCode', error_status_t),\n    )",
  "class IEventSubscription_get_SubscriberCLSID(DCOMCALL):\n    opnum = 17\n    structure = (\n    )",
  "class IEventSubscription_get_SubscriberCLSIDResponse(DCOMANSWER):\n    structure = (\n       ('pbstrSubscriberCLSID', BSTR),\n       ('ErrorCode', error_status_t),\n    )",
  "class IEventSubscription_put_SubscriberCLSID(DCOMCALL):\n    opnum = 18\n    structure = (\n       ('bstrSubscriberCLSID', BSTR),\n    )",
  "class IEventSubscription_put_SubscriberCLSIDResponse(DCOMANSWER):\n    structure = (\n       ('ErrorCode', error_status_t),\n    )",
  "class IEventSubscription_get_SubscriberInterface(DCOMCALL):\n    opnum = 19\n    structure = (\n    )",
  "class IEventSubscription_get_SubscriberInterfaceResponse(DCOMANSWER):\n    structure = (\n       ('ppSubscriberInterface', PMInterfacePointer),\n       ('ErrorCode', error_status_t),\n    )",
  "class IEventSubscription_put_SubscriberInterface(DCOMCALL):\n    opnum = 20\n    structure = (\n       ('pSubscriberInterface', PMInterfacePointer),\n    )",
  "class IEventSubscription_put_SubscriberInterfaceResponse(DCOMANSWER):\n    structure = (\n       ('ErrorCode', error_status_t),\n    )",
  "class IEventSubscription_get_PerUser(DCOMCALL):\n    opnum = 21\n    structure = (\n    )",
  "class IEventSubscription_get_PerUserResponse(DCOMANSWER):\n    structure = (\n       ('pfPerUser', BOOLEAN),\n       ('ErrorCode', error_status_t),\n    )",
  "class IEventSubscription_put_PerUser(DCOMCALL):\n    opnum = 22\n    structure = (\n       ('fPerUser', BOOLEAN),\n    )",
  "class IEventSubscription_put_PerUserResponse(DCOMANSWER):\n    structure = (\n       ('ErrorCode', error_status_t),\n    )",
  "class IEventSubscription_get_OwnerSID(DCOMCALL):\n    opnum = 23\n    structure = (\n    )",
  "class IEventSubscription_get_OwnerSIDResponse(DCOMANSWER):\n    structure = (\n       ('pbstrOwnerSID', BSTR),\n       ('ErrorCode', error_status_t),\n    )",
  "class IEventSubscription_put_OwnerSID(DCOMCALL):\n    opnum = 24\n    structure = (\n       ('bstrOwnerSID', BSTR),\n    )",
  "class IEventSubscription_put_OwnerSIDResponse(DCOMANSWER):\n    structure = (\n       ('ErrorCode', error_status_t),\n    )",
  "class IEventSubscription_get_Enabled(DCOMCALL):\n    opnum = 25\n    structure = (\n    )",
  "class IEventSubscription_get_EnabledResponse(DCOMANSWER):\n    structure = (\n       ('pfEnabled', BOOLEAN),\n       ('ErrorCode', error_status_t),\n    )",
  "class IEventSubscription_put_Enabled(DCOMCALL):\n    opnum = 26\n    structure = (\n       ('fEnabled', BOOLEAN),\n    )",
  "class IEventSubscription_put_EnabledResponse(DCOMANSWER):\n    structure = (\n       ('ErrorCode', error_status_t),\n    )",
  "class IEventSubscription_get_Description(DCOMCALL):\n    opnum = 27\n    structure = (\n    )",
  "class IEventSubscription_get_DescriptionResponse(DCOMANSWER):\n    structure = (\n       ('pbstrDescription', BSTR),\n       ('ErrorCode', error_status_t),\n    )",
  "class IEventSubscription_put_Description(DCOMCALL):\n    opnum = 28\n    structure = (\n       ('bstrDescription', BSTR),\n    )",
  "class IEventSubscription_put_DescriptionResponse(DCOMANSWER):\n    structure = (\n       ('ErrorCode', error_status_t),\n    )",
  "class IEventSubscription_get_MachineName(DCOMCALL):\n    opnum = 29\n    structure = (\n    )",
  "class IEventSubscription_get_MachineNameResponse(DCOMANSWER):\n    structure = (\n       ('pbstrMachineName', BSTR),\n       ('ErrorCode', error_status_t),\n    )",
  "class IEventSubscription_put_MachineName(DCOMCALL):\n    opnum = 30\n    structure = (\n       ('bstrMachineName', BSTR),\n    )",
  "class IEventSubscription_put_MachineNameResponse(DCOMANSWER):\n    structure = (\n       ('ErrorCode', error_status_t),\n    )",
  "class IEventSubscription_GetPublisherProperty(DCOMCALL):\n    opnum = 31\n    structure = (\n       ('bstrPropertyName', BSTR),\n    )",
  "class IEventSubscription_GetPublisherPropertyResponse(DCOMANSWER):\n    structure = (\n       ('propertyValue', VARIANT),\n       ('ErrorCode', error_status_t),\n    )",
  "class IEventSubscription_PutPublisherProperty(DCOMCALL):\n    opnum = 32\n    structure = (\n       ('bstrPropertyName', BSTR),\n       ('propertyValue', VARIANT),\n    )",
  "class IEventSubscription_PutPublisherPropertyResponse(DCOMANSWER):\n    structure = (\n       ('ErrorCode', error_status_t),\n    )",
  "class IEventSubscription_RemovePublisherProperty(DCOMCALL):\n    opnum = 33\n    structure = (\n       ('bstrPropertyName', BSTR),\n    )",
  "class IEventSubscription_RemovePublisherPropertyResponse(DCOMANSWER):\n    structure = (\n       ('ErrorCode', error_status_t),\n    )",
  "class IEventSubscription_GetPublisherPropertyCollection(DCOMCALL):\n    opnum = 34\n    structure = (\n    )",
  "class IEventSubscription_GetPublisherPropertyCollectionResponse(DCOMANSWER):\n    structure = (\n       ('collection', PMInterfacePointer),\n       ('ErrorCode', error_status_t),\n    )",
  "class IEventSubscription_GetSubscriberProperty(DCOMCALL):\n    opnum = 35\n    structure = (\n       ('bstrPropertyName', BSTR),\n    )",
  "class IEventSubscription_GetSubscriberPropertyResponse(DCOMANSWER):\n    structure = (\n       ('propertyValue', VARIANT),\n       ('ErrorCode', error_status_t),\n    )",
  "class IEventSubscription_PutSubscriberProperty(DCOMCALL):\n    opnum = 36\n    structure = (\n       ('bstrPropertyName', BSTR),\n       ('propertyValue', VARIANT),\n    )",
  "class IEventSubscription_PutSubscriberPropertyResponse(DCOMANSWER):\n    structure = (\n       ('ErrorCode', error_status_t),\n    )",
  "class IEventSubscription_RemoveSubscriberProperty(DCOMCALL):\n    opnum = 37\n    structure = (\n       ('bstrPropertyName', BSTR),\n    )",
  "class IEventSubscription_RemoveSubscriberPropertyResponse(DCOMANSWER):\n    structure = (\n       ('ErrorCode', error_status_t),\n    )",
  "class IEventSubscription_GetSubscriberPropertyCollection(DCOMCALL):\n    opnum = 38\n    structure = (\n    )",
  "class IEventSubscription_GetSubscriberPropertyCollectionResponse(DCOMANSWER):\n    structure = (\n       ('collection', PMInterfacePointer),\n       ('ErrorCode', error_status_t),\n    )",
  "class IEventSubscription_get_InterfaceID(DCOMCALL):\n    opnum = 39\n    structure = (\n    )",
  "class IEventSubscription_get_InterfaceIDResponse(DCOMANSWER):\n    structure = (\n       ('pbstrInterfaceID', BSTR),\n       ('ErrorCode', error_status_t),\n    )",
  "class IEventSubscription_put_InterfaceID(DCOMCALL):\n    opnum = 40\n    structure = (\n       ('bstrInterfaceID', BSTR),\n    )",
  "class IEventSubscription_put_InterfaceIDResponse(DCOMANSWER):\n    structure = (\n       ('ErrorCode', error_status_t),\n    )",
  "class IEnumEventObject_Clone(DCOMCALL):\n    opnum = 3\n    structure = (\n    )",
  "class IEnumEventObject_CloneResponse(DCOMANSWER):\n    structure = (\n       ('ppInterface', PMInterfacePointer),\n       ('ErrorCode', error_status_t),\n    )",
  "class IEnumEventObject_Next(DCOMCALL):\n    opnum = 4\n    structure = (\n       ('cReqElem', ULONG),\n    )",
  "class IEnumEventObject_NextResponse(DCOMANSWER):\n    structure = (\n       ('ppInterface', OBJECT_ARRAY),\n       ('cRetElem', ULONG),\n       ('ErrorCode', error_status_t),\n    )",
  "class IEnumEventObject_Reset(DCOMCALL):\n    opnum = 5\n    structure = (\n    )",
  "class IEnumEventObject_ResetResponse(DCOMANSWER):\n    structure = (\n       ('ErrorCode', error_status_t),\n    )",
  "class IEnumEventObject_Skip(DCOMCALL):\n    opnum = 6\n    structure = (\n       ('cSkipElem', ULONG),\n    )",
  "class IEnumEventObject_SkipResponse(DCOMANSWER):\n    structure = (\n       ('ErrorCode', error_status_t),\n    )",
  "class IEventObjectCollection_get__NewEnum(DCOMCALL):\n    opnum = 7\n    structure = (\n    )",
  "class IEventObjectCollection_get__NewEnumResponse(DCOMANSWER):\n    structure = (\n       ('ppUnkEnum', PMInterfacePointer),\n       ('ErrorCode', error_status_t),\n    )",
  "class IEventObjectCollection_get_Item(DCOMCALL):\n    opnum = 8\n    structure = (\n       ('objectID', BSTR),\n    )",
  "class IEventObjectCollection_get_ItemResponse(DCOMANSWER):\n    structure = (\n       ('pItem', VARIANT),\n       ('ErrorCode', error_status_t),\n    )",
  "class IEventObjectCollection_get_NewEnum(DCOMCALL):\n    opnum = 9\n    structure = (\n    )",
  "class IEventObjectCollection_get_NewEnumResponse(DCOMANSWER):\n    structure = (\n       ('ppEnum', PMInterfacePointer),\n       ('ErrorCode', error_status_t),\n    )",
  "class IEventObjectCollection_get_Count(DCOMCALL):\n    opnum = 10\n    structure = (\n    )",
  "class IEventObjectCollection_get_CountResponse(DCOMANSWER):\n    structure = (\n       ('pCount', LONG),\n       ('ErrorCode', error_status_t),\n    )",
  "class IEventObjectCollection_Add(DCOMCALL):\n    opnum = 11\n    structure = (\n       ('item', VARIANT),\n       ('objectID', BSTR),\n    )",
  "class IEventObjectCollection_AddResponse(DCOMANSWER):\n    structure = (\n       ('ErrorCode', error_status_t),\n    )",
  "class IEventObjectCollection_Remove(DCOMCALL):\n    opnum = 12\n    structure = (\n       ('objectID', BSTR),\n    )",
  "class IEventObjectCollection_RemoveResponse(DCOMANSWER):\n    structure = (\n       ('ErrorCode', error_status_t),\n    )",
  "class IEventClass3_get_EventClassPartitionID(DCOMCALL):\n    opnum = 29\n    structure = (\n    )",
  "class IEventClass3_get_EventClassPartitionIDResponse(DCOMANSWER):\n    structure = (\n       ('pbstrEventClassPartitionID', BSTR),\n       ('ErrorCode', error_status_t),\n    )",
  "class IEventClass3_put_EventClassPartitionID(DCOMCALL):\n    opnum = 30\n    structure = (\n       ('bstrEventClassPartitionID', BSTR),\n    )",
  "class IEventClass3_put_EventClassPartitionIDResponse(DCOMANSWER):\n    structure = (\n       ('ErrorCode', error_status_t),\n    )",
  "class IEventClass3_get_EventClassApplicationID(DCOMCALL):\n    opnum = 31\n    structure = (\n    )",
  "class IEventClass3_get_EventClassApplicationIDResponse(DCOMANSWER):\n    structure = (\n       ('pbstrEventClassApplicationID', BSTR),\n       ('ErrorCode', error_status_t),\n    )",
  "class IEventClass3_put_EventClassApplicationID(DCOMCALL):\n    opnum = 32\n    structure = (\n       ('bstrEventClassApplicationID', BSTR),\n    )",
  "class IEventClass3_put_EventClassApplicationIDResponse(DCOMANSWER):\n    structure = (\n       ('ErrorCode', error_status_t),\n    )",
  "class IEventSubscription2_get_FilterCriteria(DCOMCALL):\n    opnum = 41\n    structure = (\n    )",
  "class IEventSubscription2_get_FilterCriteriaResponse(DCOMANSWER):\n    structure = (\n       ('pbstrFilterCriteria', BSTR),\n       ('ErrorCode', error_status_t),\n    )",
  "class IEventSubscription2_put_FilterCriteria(DCOMCALL):\n    opnum = 42\n    structure = (\n       ('bstrFilterCriteria', BSTR),\n    )",
  "class IEventSubscription2_put_FilterCriteriaResponse(DCOMANSWER):\n    structure = (\n       ('ErrorCode', error_status_t),\n    )",
  "class IEventSubscription2_get_SubscriberMoniker(DCOMCALL):\n    opnum = 43\n    structure = (\n    )",
  "class IEventSubscription2_get_SubscriberMonikerResponse(DCOMANSWER):\n    structure = (\n       ('pbstrMoniker', BSTR),\n       ('ErrorCode', error_status_t),\n    )",
  "class IEventSubscription2_put_SubscriberMoniker(DCOMCALL):\n    opnum = 44\n    structure = (\n       ('bstrMoniker', BSTR),\n    )",
  "class IEventSubscription2_put_SubscriberMonikerResponse(DCOMANSWER):\n    structure = (\n       ('ErrorCode', error_status_t),\n    )",
  "class IEventSubscription3_get_EventClassPartitionID(DCOMCALL):\n    opnum = 45\n    structure = (\n    )",
  "class IEventSubscription3_get_EventClassPartitionIDResponse(DCOMANSWER):\n    structure = (\n       ('pbstrEventClassPartitionID', BSTR),\n       ('ErrorCode', error_status_t),\n    )",
  "class IEventSubscription3_put_EventClassPartitionID(DCOMCALL):\n    opnum = 46\n    structure = (\n       ('bstrEventClassPartitionID', BSTR),\n    )",
  "class IEventSubscription3_put_EventClassPartitionIDResponse(DCOMANSWER):\n    structure = (\n       ('ErrorCode', error_status_t),\n    )",
  "class IEventSubscription3_get_EventClassApplicationID(DCOMCALL):\n    opnum = 47\n    structure = (\n    )",
  "class IEventSubscription3_get_EventClassApplicationIDResponse(DCOMANSWER):\n    structure = (\n       ('pbstrEventClassApplicationID', BSTR),\n       ('ErrorCode', error_status_t),\n    )",
  "class IEventSubscription3_put_EventClassApplicationID(DCOMCALL):\n    opnum = 48\n    structure = (\n       ('bstrEventClassPartitionID', BSTR),\n    )",
  "class IEventSubscription3_put_EventClassApplicationIDResponse(DCOMANSWER):\n    structure = (\n       ('ErrorCode', error_status_t),\n    )",
  "class IEventSubscription3_get_SubscriberPartitionID(DCOMCALL):\n    opnum = 49\n    structure = (\n    )",
  "class IEventSubscription3_get_SubscriberPartitionIDResponse(DCOMANSWER):\n    structure = (\n       ('pbstrSubscriberPartitionID', BSTR),\n       ('ErrorCode', error_status_t),\n    )",
  "class IEventSubscription3_put_SubscriberPartitionID(DCOMCALL):\n    opnum = 50\n    structure = (\n       ('bstrSubscriberPartitionID', BSTR),\n    )",
  "class IEventSubscription3_put_SubscriberPartitionIDResponse(DCOMANSWER):\n    structure = (\n       ('ErrorCode', error_status_t),\n    )",
  "class IEventSubscription3_get_SubscriberApplicationID(DCOMCALL):\n    opnum = 51\n    structure = (\n    )",
  "class IEventSubscription3_get_SubscriberApplicationIDResponse(DCOMANSWER):\n    structure = (\n       ('pbstrSubscriberApplicationID', BSTR),\n       ('ErrorCode', error_status_t),\n    )",
  "class IEventSubscription3_put_SubscriberApplicationID(DCOMCALL):\n    opnum = 52\n    structure = (\n       ('bstrSubscriberApplicationID', BSTR),\n    )",
  "class IEventSubscription3_put_SubscriberApplicationIDResponse(DCOMANSWER):\n    structure = (\n       ('ErrorCode', error_status_t),\n    )",
  "class IEventSystem2_GetVersion(DCOMCALL):\n    opnum = 13\n    structure = (\n    )",
  "class IEventSystem2_GetVersionResponse(DCOMANSWER):\n    structure = (\n       ('pnVersion', INT),\n       ('ErrorCode', error_status_t),\n    )",
  "class IEventSystem2_VerifyTransientSubscribers(DCOMCALL):\n    opnum = 14\n    structure = (\n    )",
  "class IEventSystem2_VerifyTransientSubscribersResponse(DCOMANSWER):\n    structure = (\n       ('ErrorCode', error_status_t),\n    )",
  "class IEventSystemInitialize_SetCOMCatalogBehaviour(DCOMCALL):\n    opnum = 3\n    structure = (\n       ('bRetainSubKeys', BOOLEAN),\n    )",
  "class IEventSystemInitialize_SetCOMCatalogBehaviourResponse(DCOMANSWER):\n    structure = (\n       ('ErrorCode', error_status_t),\n    )",
  "class IEventClass(IDispatch):\n    def __init__(self, interface):\n        IDispatch.__init__(self,interface)\n        self._iid = IID_IEventClass\n\n    def get_EventClassID(self):\n        request = IEventClass_get_EventClassID()\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp\n\n    def put_EventClassID(self,bstrEventClassID):\n        request = IEventClass_put_EventClassID()\n        request['bstrEventClassID'] = bstrEventClassID\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp\n\n    def get_EventClassName(self):\n        request = IEventClass_get_EventClassName()\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp\n\n    def put_EventClassName(self, bstrEventClassName):\n        request = IEventClass_put_EventClassName()\n        request['bstrEventClassName'] = bstrEventClassName\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp\n\n    def get_OwnerSID(self):\n        request = IEventClass_get_OwnerSID()\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp\n\n    def put_OwnerSID(self, bstrOwnerSID):\n        request = IEventClass_put_OwnerSID()\n        request['bstrOwnerSID'] = bstrOwnerSID\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp\n\n    def get_FiringInterfaceID(self):\n        request = IEventClass_get_FiringInterfaceID()\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp\n\n    def put_FiringInterfaceID(self, bstrFiringInterfaceID):\n        request = IEventClass_put_FiringInterfaceID()\n        request['bstrFiringInterfaceID'] = bstrFiringInterfaceID\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp\n\n    def get_Description(self):\n        request = IEventClass_get_Description()\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp\n\n    def put_Description(self, bstrDescription):\n        request = IEventClass_put_Description()\n        request['bstrDescription'] = bstrDescription\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp\n\n    def get_TypeLib(self):\n        request = IEventClass_get_TypeLib()\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp\n\n    def put_TypeLib(self, bstrTypeLib):\n        request = IEventClass_put_TypeLib()\n        request['bstrTypeLib'] = bstrTypeLib\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp",
  "class IEventClass2(IEventClass):\n    def __init__(self, interface):\n        IEventClass.__init__(self,interface)\n        self._iid = IID_IEventClass2\n\n    def get_PublisherID(self):\n        request = IEventClass2_get_PublisherID()\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp\n\n    def put_PublisherID(self, bstrPublisherID):\n        request = IEventClass2_put_PublisherID()\n        request['bstrPublisherID'] = bstrPublisherID\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp\n\n    def get_MultiInterfacePublisherFilterCLSID(self):\n        request = IEventClass2_get_MultiInterfacePublisherFilterCLSID()\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp\n\n    def put_MultiInterfacePublisherFilterCLSID(self, bstrPubFilCLSID):\n        request = IEventClass2_put_MultiInterfacePublisherFilterCLSID()\n        request['bstrPubFilCLSID'] = bstrPubFilCLSID\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp\n\n    def get_AllowInprocActivation(self):\n        request = IEventClass2_get_AllowInprocActivation()\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp\n\n    def put_AllowInprocActivation(self, fAllowInprocActivation):\n        request = IEventClass2_put_AllowInprocActivation()\n        request['fAllowInprocActivation '] = fAllowInprocActivation\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp\n\n    def get_FireInParallel(self):\n        request = IEventClass2_get_FireInParallel()\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp\n\n    def put_FireInParallel(self, fFireInParallel):\n        request = IEventClass2_put_FireInParallel()\n        request['fFireInParallel '] = fFireInParallel\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp",
  "class IEventClass3(IEventClass2):\n    def __init__(self, interface):\n        IEventClass2.__init__(self,interface)\n        self._iid = IID_IEventClass3\n\n    def get_EventClassPartitionID(self):\n        request = IEventClass3_get_EventClassPartitionID()\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp\n\n    def put_EventClassPartitionID(self, bstrEventClassPartitionID):\n        request = IEventClass3_put_EventClassPartitionID()\n        request['bstrEventClassPartitionID '] = bstrEventClassPartitionID\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp\n\n    def get_EventClassApplicationID(self):\n        request = IEventClass3_get_EventClassApplicationID()\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp\n\n    def put_EventClassApplicationID(self, bstrEventClassApplicationID):\n        request = IEventClass3_put_EventClassApplicationID()\n        request['bstrEventClassApplicationID '] = bstrEventClassApplicationID\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp",
  "class IEventSubscription(IDispatch):\n    def __init__(self, interface):\n        IDispatch.__init__(self,interface)\n        self._iid = IID_IEventSubscription\n\n    def get_SubscriptionID(self):\n        request = IEventSubscription_get_SubscriptionID()\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp\n\n    def put_SubscriptionID(self, bstrSubscriptionID):\n        request = IEventSubscription_put_SubscriptionID()\n        request['bstrSubscriptionID'] = bstrSubscriptionID\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp\n\n    def get_SubscriptionName(self):\n        request = IEventSubscription_get_SubscriptionName()\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        return resp\n\n    def put_SubscriptionName(self, bstrSubscriptionName):\n        request = IEventSubscription_put_SubscriptionName()\n        request['bstrSubscriptionName'] = bstrSubscriptionName\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp\n\n    def get_PublisherID(self):\n        request = IEventSubscription_get_PublisherID()\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp\n\n    def put_PublisherID(self, bstrPublisherID):\n        request = IEventSubscription_put_PublisherID()\n        request['bstrPublisherID'] = bstrPublisherID\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp\n\n    def get_EventClassID(self):\n        request = IEventSubscription_get_EventClassID()\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp\n\n    def put_EventClassID(self, pbstrEventClassID):\n        request = IEventSubscription_put_EventClassID()\n        request['pbstrEventClassID'] = pbstrEventClassID\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp\n\n    def get_MethodName(self):\n        request = IEventSubscription_get_MethodName()\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp\n\n    def put_MethodName(self, bstrMethodName):\n        request = IEventSubscription_put_MethodName()\n        request['bstrMethodName'] = bstrMethodName\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp\n\n    def get_SubscriberCLSID(self):\n        request = IEventSubscription_get_SubscriberCLSID()\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp\n\n    def put_SubscriberCLSID(self, bstrSubscriberCLSID):\n        request = IEventSubscription_put_SubscriberCLSID()\n        request['bstrSubscriberCLSID'] = bstrSubscriberCLSID\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp\n\n    def get_SubscriberInterface(self):\n        request = IEventSubscription_get_SubscriberInterface()\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp\n\n    def put_SubscriberInterface(self, pSubscriberInterface):\n        request = IEventSubscription_put_SubscriberInterface()\n        request['pSubscriberInterface'] = pSubscriberInterface\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp\n\n    def get_PerUser(self):\n        request = IEventSubscription_get_PerUser()\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp\n\n    def put_PerUser(self, fPerUser):\n        request = IEventSubscription_put_PerUser()\n        request['fPerUser'] = fPerUser\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp\n\n    def get_OwnerSID(self):\n        request = IEventSubscription_get_OwnerSID()\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp\n\n    def put_OwnerSID(self, bstrOwnerSID):\n        request = IEventSubscription_put_OwnerSID()\n        request['bstrOwnerSID'] = bstrOwnerSID\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp\n\n    def get_Enabled(self):\n        request = IEventSubscription_get_Enabled()\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp\n\n    def put_Enabled(self, fEnabled):\n        request = IEventSubscription_put_Enabled()\n        request['fEnabled'] = fEnabled\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp\n\n    def get_Description(self):\n        request = IEventSubscription_get_Description()\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp\n\n    def put_Description(self, bstrDescription):\n        request = IEventSubscription_put_Description()\n        request['bstrDescription'] = bstrDescription\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp\n\n    def get_MachineName(self):\n        request = IEventSubscription_get_MachineName()\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp\n\n    def put_MachineName(self, bstrMachineName):\n        request = IEventSubscription_put_MachineName()\n        request['bstrMachineName'] = bstrMachineName\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp\n\n    def GetPublisherProperty(self):\n        request = IEventSubscription_GetPublisherProperty()\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp\n\n    def PutPublisherProperty(self, bstrPropertyName, propertyValue):\n        request = IEventSubscription_PutPublisherProperty()\n        request['bstrPropertyName'] = bstrPropertyName\n        request['propertyValue'] = propertyValue\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp\n\n    def RemovePublisherProperty(self, bstrPropertyName):\n        request = IEventSubscription_RemovePublisherProperty()\n        request['bstrPropertyName'] = bstrPropertyName\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp\n\n    def GetPublisherPropertyCollection(self):\n        request = IEventSubscription_GetPublisherPropertyCollection()\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp\n\n    def GetSubscriberProperty(self):\n        request = IEventSubscription_GetSubscriberProperty()\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp\n\n    def PutSubscriberProperty(self, bstrPropertyName, propertyValue):\n        request = IEventSubscription_PutSubscriberProperty()\n        request['bstrPropertyName'] = bstrPropertyName\n        request['propertyValue'] = propertyValue\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp\n\n    def RemoveSubscriberProperty(self, bstrPropertyName):\n        request = IEventSubscription_RemoveSubscriberProperty()\n        request['bstrPropertyName'] = bstrPropertyName\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp\n\n    def GetSubscriberPropertyCollection(self):\n        request = IEventSubscription_GetSubscriberPropertyCollection()\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp\n\n    def get_InterfaceID(self):\n        request = IEventSubscription_get_InterfaceID()\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp\n\n    def put_InterfaceID(self, bstrInterfaceID):\n        request = IEventSubscription_put_InterfaceID()\n        request['bstrInterfaceID'] = bstrInterfaceID\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp",
  "class IEventSubscription2(IEventSubscription):\n    def __init__(self, interface):\n        IEventSubscription.__init__(self,interface)\n        self._iid = IID_IEventSubscription2\n\n    def get_FilterCriteria(self):\n        request = IEventSubscription2_get_FilterCriteria()\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp\n\n    def put_FilterCriteria(self, bstrFilterCriteria):\n        request = IEventSubscription2_put_FilterCriteria()\n        request['bstrFilterCriteria'] = bstrFilterCriteria\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp\n\n    def get_SubscriberMoniker (self):\n        request = IEventSubscription2_get_SubscriberMoniker ()\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp\n\n    def put_SubscriberMoniker(self, bstrMoniker):\n        request = IEventSubscription2_put_SubscriberMoniker()\n        request['bstrMoniker'] = bstrMoniker\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp",
  "class IEventSubscription3(IEventSubscription2):\n    def __init__(self, interface):\n        IEventSubscription2.__init__(self,interface)\n        self._iid = IID_IEventSubscription3\n\n    def get_EventClassPartitionID(self):\n        request = IEventSubscription3_get_EventClassPartitionID()\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp\n\n    def put_EventClassPartitionID(self, bstrEventClassPartitionID):\n        request = IEventSubscription3_put_EventClassPartitionID()\n        request['bstrEventClassPartitionID'] = bstrEventClassPartitionID\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp\n\n    def get_EventClassApplicationID(self):\n        request = IEventSubscription3_get_EventClassApplicationID()\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp\n\n    def put_EventClassApplicationID(self, bstrEventClassApplicationID):\n        request = IEventSubscription3_put_EventClassApplicationID()\n        request['bstrEventClassApplicationID'] = bstrEventClassApplicationID\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp\n\n    def get_SubscriberPartitionID(self):\n        request = IEventSubscription3_get_SubscriberPartitionID()\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp\n\n    def put_SubscriberPartitionID(self, bstrSubscriberPartitionID):\n        request = IEventSubscription3_put_SubscriberPartitionID()\n        request['bstrSubscriberPartitionID'] = bstrSubscriberPartitionID\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp\n\n    def get_SubscriberApplicationID(self):\n        request = IEventSubscription3_get_SubscriberApplicationID()\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp\n\n    def put_SubscriberApplicationID(self, bstrSubscriberApplicationID):\n        request = IEventSubscription3_put_SubscriberApplicationID()\n        request['bstrSubscriberApplicationID'] = bstrSubscriberApplicationID\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp",
  "class IEnumEventObject(IDispatch):\n    def __init__(self, interface):\n        IDispatch.__init__(self,interface)\n        self._iid = IID_IEnumEventObject\n\n    def Clone(self):\n        request = IEnumEventObject_Clone()\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        return IEnumEventObject(INTERFACE(self.get_cinstance(), b''.join(resp['ppInterface']['abData']), self.get_ipidRemUnknown(), target = self.get_target()))\n\n    def Next(self, cReqElem):\n        request = IEnumEventObject_Next()\n        request['cReqElem'] = cReqElem\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        interfaces = list()\n        for interface in resp['ppInterface']:\n            interfaces.append(IEventClass2(INTERFACE(self.get_cinstance(), b''.join(interface['abData']), self.get_ipidRemUnknown(), target = self.get_target())))\n        return interfaces\n\n    def Reset(self):\n        request = IEnumEventObject_Reset()\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        return resp\n\n    def Skip(self, cSkipElem):\n        request = IEnumEventObject_Skip()\n        request['cSkipElem'] = cSkipElem\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        return resp",
  "class IEventObjectCollection(IDispatch):\n    def __init__(self, interface):\n        IDispatch.__init__(self,interface)\n        self._iid = IID_IEventObjectCollection\n\n    def get__NewEnum(self):\n        request = IEventObjectCollection_get__NewEnum()\n        resp = self.request(request, iid = self._iid , uuid = self.get_iPid())\n        return IEnumEventObject(INTERFACE(self.get_cinstance(), b''.join(resp['ppEnum']['abData']), self.get_ipidRemUnknown(), target = self._get_target()))\n\n    def get_Item(self, objectID):\n        request = IEventObjectCollection_get_Item()\n        request['objectID']['asData'] = objectID\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        return resp\n\n    def get_NewEnum(self):\n        request = IEventObjectCollection_get_NewEnum()\n        resp = self.request(request, iid = self._iid , uuid = self.get_iPid())\n        return IEnumEventObject(INTERFACE(self.get_cinstance(), b''.join(resp['ppEnum']['abData']), self.get_ipidRemUnknown(), target = self.get_target()))\n\n    def get_Count(self):\n        request = IEventObjectCollection_get_Count()\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        return resp\n\n    def Add(self, item, objectID):\n        request = IEventObjectCollection_Add()\n        request['item'] = item\n        request['objectID']['asData'] = objectID\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        return resp\n\n    def Remove(self, objectID):\n        request = IEventObjectCollection_Remove()\n        request['objectID']['asData'] = objectID\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        return resp",
  "class IEventSystem(IDispatch):\n    def __init__(self, interface):\n        IDispatch.__init__(self,interface)\n        self._iid = IID_IEventSystem\n\n    def Query(self, progID, queryCriteria):\n        request = IEventSystem_Query()\n        request['progID']['asData']=progID\n        request['queryCriteria']['asData']=queryCriteria\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        iInterface = IDispatch(INTERFACE(self.get_cinstance(), b''.join(resp['ppInterface']['abData']), self.get_ipidRemUnknown(), target = self.get_target()))\n        return IEventObjectCollection(iInterface.RemQueryInterface(1, (IID_IEventObjectCollection,)))\n\n    def Store(self, progID, pInterface):\n        request = IEventSystem_Store()\n        request['progID']['asData']=progID\n        request['pInterface'] = pInterface\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        return resp\n\n    def Remove(self, progID, queryCriteria):\n        request = IEventSystem_Remove()\n        request['progID']['asData']=progID\n        request['queryCriteria'] = queryCriteria\n        resp = self.request(request, uuid = self.get_iPid())\n        return resp\n\n    def get_EventObjectChangeEventClassID(self):\n        request = IEventSystem_get_EventObjectChangeEventClassID()\n        resp = self.request(request, uuid = self.get_iPid())\n        return resp\n\n    def QueryS(self,progID, queryCriteria):\n        request = IEventSystem_QueryS()\n        request['progID']['asData']=progID\n        request['queryCriteria']['asData']=queryCriteria\n        resp = self.request(request, uuid = self.get_iPid())\n        iInterface = IDispatch(INTERFACE(self.get_cinstance(), b''.join(resp['ppInterface']['abData']), self.get_ipidRemUnknown(), target = self.get_target()))\n        return IEventObjectCollection(iInterface.RemQueryInterface(1, (IID_IEventObjectCollection,)))\n\n    def RemoveS(self,progID, queryCriteria):\n        request = IEventSystem_RemoveS()\n        request['progID']['asData']=progID\n        request['queryCriteria']['asData']=queryCriteria\n        resp = self.request(request, uuid = self.get_iPid())\n        return resp",
  "class IEventSystem2(IEventSystem):\n    def __init__(self, interface):\n        IEventSystem.__init__(self,interface)\n        self._iid = IID_IEventSystem2\n\n    def GetVersion(self):\n        request = IEventSystem2_GetVersion()\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        return resp\n\n    def VerifyTransientSubscribers(self):\n        request = IEventSystem2_GetVersion()\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        return resp",
  "class IEventSystemInitialize(IRemUnknown):\n    def __init__(self, interface):\n        IRemUnknown.__init__(self,interface)\n        self._iid = IID_IEventSystemInitialize\n\n    def SetCOMCatalogBehaviour(self, bRetainSubKeys):\n        request = IEventSystem2_GetVersion()\n        request['bRetainSubKeys'] = bRetainSubKeys\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        return resp",
  "def __init__(self, error_string=None, error_code=None, packet=None):\n        DCERPCException.__init__(self, error_string, error_code, packet)",
  "def __str__( self ):\n        if self.error_code in hresult_errors.ERROR_MESSAGES:\n            error_msg_short = hresult_errors.ERROR_MESSAGES[self.error_code][0]\n            error_msg_verbose = hresult_errors.ERROR_MESSAGES[self.error_code][1] \n            return 'COMEV SessionError: code: 0x%x - %s - %s' % (self.error_code, error_msg_short, error_msg_verbose)\n        else:\n            return 'COMEV SessionError: unknown error code: 0x%x' % self.error_code",
  "class enumItems(Enum):\n        VT_EMPTY       = 0\n        VT_NULL        = 1\n        VT_I2          = 2\n        VT_I4          = 3\n        VT_R4          = 4\n        VT_R8          = 5\n        VT_CY          = 6\n        VT_DATE        = 7\n        VT_BSTR        = 8\n        VT_DISPATCH    = 9\n        VT_ERROR       = 0xa\n        VT_BOOL        = 0xb\n        VT_VARIANT     = 0xc\n        VT_UNKNOWN     = 0xd\n        VT_DECIMAL     = 0xe\n        VT_I1          = 0x10\n        VT_UI1         = 0x11\n        VT_UI2         = 0x12\n        VT_UI4         = 0x13\n        VT_I8          = 0x14\n        VT_UI8         = 0x15\n        VT_INT         = 0x16\n        VT_UINT        = 0x17\n        VT_VOID        = 0x18\n        VT_HRESULT     = 0x19\n        VT_PTR         = 0x1a\n        VT_SAFEARRAY   = 0x1b\n        VT_CARRAY      = 0x1c\n        VT_USERDEFINED = 0x1d\n        VT_LPSTR       = 0x1e\n        VT_LPWSTR      = 0x1f\n        VT_RECORD      = 0x24\n        VT_INT_PTR     = 0x25\n        VT_UINT_PTR    = 0x26\n        VT_ARRAY       = 0x2000\n        VT_BYREF       = 0x4000",
  "def __init__(self, interface):\n        IDispatch.__init__(self,interface)\n        self._iid = IID_IEventClass",
  "def get_EventClassID(self):\n        request = IEventClass_get_EventClassID()\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp",
  "def put_EventClassID(self,bstrEventClassID):\n        request = IEventClass_put_EventClassID()\n        request['bstrEventClassID'] = bstrEventClassID\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp",
  "def get_EventClassName(self):\n        request = IEventClass_get_EventClassName()\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp",
  "def put_EventClassName(self, bstrEventClassName):\n        request = IEventClass_put_EventClassName()\n        request['bstrEventClassName'] = bstrEventClassName\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp",
  "def get_OwnerSID(self):\n        request = IEventClass_get_OwnerSID()\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp",
  "def put_OwnerSID(self, bstrOwnerSID):\n        request = IEventClass_put_OwnerSID()\n        request['bstrOwnerSID'] = bstrOwnerSID\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp",
  "def get_FiringInterfaceID(self):\n        request = IEventClass_get_FiringInterfaceID()\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp",
  "def put_FiringInterfaceID(self, bstrFiringInterfaceID):\n        request = IEventClass_put_FiringInterfaceID()\n        request['bstrFiringInterfaceID'] = bstrFiringInterfaceID\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp",
  "def get_Description(self):\n        request = IEventClass_get_Description()\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp",
  "def put_Description(self, bstrDescription):\n        request = IEventClass_put_Description()\n        request['bstrDescription'] = bstrDescription\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp",
  "def get_TypeLib(self):\n        request = IEventClass_get_TypeLib()\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp",
  "def put_TypeLib(self, bstrTypeLib):\n        request = IEventClass_put_TypeLib()\n        request['bstrTypeLib'] = bstrTypeLib\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp",
  "def __init__(self, interface):\n        IEventClass.__init__(self,interface)\n        self._iid = IID_IEventClass2",
  "def get_PublisherID(self):\n        request = IEventClass2_get_PublisherID()\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp",
  "def put_PublisherID(self, bstrPublisherID):\n        request = IEventClass2_put_PublisherID()\n        request['bstrPublisherID'] = bstrPublisherID\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp",
  "def get_MultiInterfacePublisherFilterCLSID(self):\n        request = IEventClass2_get_MultiInterfacePublisherFilterCLSID()\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp",
  "def put_MultiInterfacePublisherFilterCLSID(self, bstrPubFilCLSID):\n        request = IEventClass2_put_MultiInterfacePublisherFilterCLSID()\n        request['bstrPubFilCLSID'] = bstrPubFilCLSID\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp",
  "def get_AllowInprocActivation(self):\n        request = IEventClass2_get_AllowInprocActivation()\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp",
  "def put_AllowInprocActivation(self, fAllowInprocActivation):\n        request = IEventClass2_put_AllowInprocActivation()\n        request['fAllowInprocActivation '] = fAllowInprocActivation\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp",
  "def get_FireInParallel(self):\n        request = IEventClass2_get_FireInParallel()\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp",
  "def put_FireInParallel(self, fFireInParallel):\n        request = IEventClass2_put_FireInParallel()\n        request['fFireInParallel '] = fFireInParallel\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp",
  "def __init__(self, interface):\n        IEventClass2.__init__(self,interface)\n        self._iid = IID_IEventClass3",
  "def get_EventClassPartitionID(self):\n        request = IEventClass3_get_EventClassPartitionID()\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp",
  "def put_EventClassPartitionID(self, bstrEventClassPartitionID):\n        request = IEventClass3_put_EventClassPartitionID()\n        request['bstrEventClassPartitionID '] = bstrEventClassPartitionID\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp",
  "def get_EventClassApplicationID(self):\n        request = IEventClass3_get_EventClassApplicationID()\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp",
  "def put_EventClassApplicationID(self, bstrEventClassApplicationID):\n        request = IEventClass3_put_EventClassApplicationID()\n        request['bstrEventClassApplicationID '] = bstrEventClassApplicationID\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp",
  "def __init__(self, interface):\n        IDispatch.__init__(self,interface)\n        self._iid = IID_IEventSubscription",
  "def get_SubscriptionID(self):\n        request = IEventSubscription_get_SubscriptionID()\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp",
  "def put_SubscriptionID(self, bstrSubscriptionID):\n        request = IEventSubscription_put_SubscriptionID()\n        request['bstrSubscriptionID'] = bstrSubscriptionID\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp",
  "def get_SubscriptionName(self):\n        request = IEventSubscription_get_SubscriptionName()\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        return resp",
  "def put_SubscriptionName(self, bstrSubscriptionName):\n        request = IEventSubscription_put_SubscriptionName()\n        request['bstrSubscriptionName'] = bstrSubscriptionName\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp",
  "def get_PublisherID(self):\n        request = IEventSubscription_get_PublisherID()\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp",
  "def put_PublisherID(self, bstrPublisherID):\n        request = IEventSubscription_put_PublisherID()\n        request['bstrPublisherID'] = bstrPublisherID\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp",
  "def get_EventClassID(self):\n        request = IEventSubscription_get_EventClassID()\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp",
  "def put_EventClassID(self, pbstrEventClassID):\n        request = IEventSubscription_put_EventClassID()\n        request['pbstrEventClassID'] = pbstrEventClassID\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp",
  "def get_MethodName(self):\n        request = IEventSubscription_get_MethodName()\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp",
  "def put_MethodName(self, bstrMethodName):\n        request = IEventSubscription_put_MethodName()\n        request['bstrMethodName'] = bstrMethodName\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp",
  "def get_SubscriberCLSID(self):\n        request = IEventSubscription_get_SubscriberCLSID()\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp",
  "def put_SubscriberCLSID(self, bstrSubscriberCLSID):\n        request = IEventSubscription_put_SubscriberCLSID()\n        request['bstrSubscriberCLSID'] = bstrSubscriberCLSID\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp",
  "def get_SubscriberInterface(self):\n        request = IEventSubscription_get_SubscriberInterface()\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp",
  "def put_SubscriberInterface(self, pSubscriberInterface):\n        request = IEventSubscription_put_SubscriberInterface()\n        request['pSubscriberInterface'] = pSubscriberInterface\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp",
  "def get_PerUser(self):\n        request = IEventSubscription_get_PerUser()\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp",
  "def put_PerUser(self, fPerUser):\n        request = IEventSubscription_put_PerUser()\n        request['fPerUser'] = fPerUser\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp",
  "def get_OwnerSID(self):\n        request = IEventSubscription_get_OwnerSID()\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp",
  "def put_OwnerSID(self, bstrOwnerSID):\n        request = IEventSubscription_put_OwnerSID()\n        request['bstrOwnerSID'] = bstrOwnerSID\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp",
  "def get_Enabled(self):\n        request = IEventSubscription_get_Enabled()\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp",
  "def put_Enabled(self, fEnabled):\n        request = IEventSubscription_put_Enabled()\n        request['fEnabled'] = fEnabled\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp",
  "def get_Description(self):\n        request = IEventSubscription_get_Description()\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp",
  "def put_Description(self, bstrDescription):\n        request = IEventSubscription_put_Description()\n        request['bstrDescription'] = bstrDescription\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp",
  "def get_MachineName(self):\n        request = IEventSubscription_get_MachineName()\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp",
  "def put_MachineName(self, bstrMachineName):\n        request = IEventSubscription_put_MachineName()\n        request['bstrMachineName'] = bstrMachineName\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp",
  "def GetPublisherProperty(self):\n        request = IEventSubscription_GetPublisherProperty()\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp",
  "def PutPublisherProperty(self, bstrPropertyName, propertyValue):\n        request = IEventSubscription_PutPublisherProperty()\n        request['bstrPropertyName'] = bstrPropertyName\n        request['propertyValue'] = propertyValue\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp",
  "def RemovePublisherProperty(self, bstrPropertyName):\n        request = IEventSubscription_RemovePublisherProperty()\n        request['bstrPropertyName'] = bstrPropertyName\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp",
  "def GetPublisherPropertyCollection(self):\n        request = IEventSubscription_GetPublisherPropertyCollection()\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp",
  "def GetSubscriberProperty(self):\n        request = IEventSubscription_GetSubscriberProperty()\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp",
  "def PutSubscriberProperty(self, bstrPropertyName, propertyValue):\n        request = IEventSubscription_PutSubscriberProperty()\n        request['bstrPropertyName'] = bstrPropertyName\n        request['propertyValue'] = propertyValue\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp",
  "def RemoveSubscriberProperty(self, bstrPropertyName):\n        request = IEventSubscription_RemoveSubscriberProperty()\n        request['bstrPropertyName'] = bstrPropertyName\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp",
  "def GetSubscriberPropertyCollection(self):\n        request = IEventSubscription_GetSubscriberPropertyCollection()\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp",
  "def get_InterfaceID(self):\n        request = IEventSubscription_get_InterfaceID()\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp",
  "def put_InterfaceID(self, bstrInterfaceID):\n        request = IEventSubscription_put_InterfaceID()\n        request['bstrInterfaceID'] = bstrInterfaceID\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp",
  "def __init__(self, interface):\n        IEventSubscription.__init__(self,interface)\n        self._iid = IID_IEventSubscription2",
  "def get_FilterCriteria(self):\n        request = IEventSubscription2_get_FilterCriteria()\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp",
  "def put_FilterCriteria(self, bstrFilterCriteria):\n        request = IEventSubscription2_put_FilterCriteria()\n        request['bstrFilterCriteria'] = bstrFilterCriteria\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp",
  "def get_SubscriberMoniker (self):\n        request = IEventSubscription2_get_SubscriberMoniker ()\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp",
  "def put_SubscriberMoniker(self, bstrMoniker):\n        request = IEventSubscription2_put_SubscriberMoniker()\n        request['bstrMoniker'] = bstrMoniker\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp",
  "def __init__(self, interface):\n        IEventSubscription2.__init__(self,interface)\n        self._iid = IID_IEventSubscription3",
  "def get_EventClassPartitionID(self):\n        request = IEventSubscription3_get_EventClassPartitionID()\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp",
  "def put_EventClassPartitionID(self, bstrEventClassPartitionID):\n        request = IEventSubscription3_put_EventClassPartitionID()\n        request['bstrEventClassPartitionID'] = bstrEventClassPartitionID\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp",
  "def get_EventClassApplicationID(self):\n        request = IEventSubscription3_get_EventClassApplicationID()\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp",
  "def put_EventClassApplicationID(self, bstrEventClassApplicationID):\n        request = IEventSubscription3_put_EventClassApplicationID()\n        request['bstrEventClassApplicationID'] = bstrEventClassApplicationID\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp",
  "def get_SubscriberPartitionID(self):\n        request = IEventSubscription3_get_SubscriberPartitionID()\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp",
  "def put_SubscriberPartitionID(self, bstrSubscriberPartitionID):\n        request = IEventSubscription3_put_SubscriberPartitionID()\n        request['bstrSubscriberPartitionID'] = bstrSubscriberPartitionID\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp",
  "def get_SubscriberApplicationID(self):\n        request = IEventSubscription3_get_SubscriberApplicationID()\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp",
  "def put_SubscriberApplicationID(self, bstrSubscriberApplicationID):\n        request = IEventSubscription3_put_SubscriberApplicationID()\n        request['bstrSubscriberApplicationID'] = bstrSubscriberApplicationID\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        resp.dump()\n        return resp",
  "def __init__(self, interface):\n        IDispatch.__init__(self,interface)\n        self._iid = IID_IEnumEventObject",
  "def Clone(self):\n        request = IEnumEventObject_Clone()\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        return IEnumEventObject(INTERFACE(self.get_cinstance(), b''.join(resp['ppInterface']['abData']), self.get_ipidRemUnknown(), target = self.get_target()))",
  "def Next(self, cReqElem):\n        request = IEnumEventObject_Next()\n        request['cReqElem'] = cReqElem\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        interfaces = list()\n        for interface in resp['ppInterface']:\n            interfaces.append(IEventClass2(INTERFACE(self.get_cinstance(), b''.join(interface['abData']), self.get_ipidRemUnknown(), target = self.get_target())))\n        return interfaces",
  "def Reset(self):\n        request = IEnumEventObject_Reset()\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        return resp",
  "def Skip(self, cSkipElem):\n        request = IEnumEventObject_Skip()\n        request['cSkipElem'] = cSkipElem\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        return resp",
  "def __init__(self, interface):\n        IDispatch.__init__(self,interface)\n        self._iid = IID_IEventObjectCollection",
  "def get__NewEnum(self):\n        request = IEventObjectCollection_get__NewEnum()\n        resp = self.request(request, iid = self._iid , uuid = self.get_iPid())\n        return IEnumEventObject(INTERFACE(self.get_cinstance(), b''.join(resp['ppEnum']['abData']), self.get_ipidRemUnknown(), target = self._get_target()))",
  "def get_Item(self, objectID):\n        request = IEventObjectCollection_get_Item()\n        request['objectID']['asData'] = objectID\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        return resp",
  "def get_NewEnum(self):\n        request = IEventObjectCollection_get_NewEnum()\n        resp = self.request(request, iid = self._iid , uuid = self.get_iPid())\n        return IEnumEventObject(INTERFACE(self.get_cinstance(), b''.join(resp['ppEnum']['abData']), self.get_ipidRemUnknown(), target = self.get_target()))",
  "def get_Count(self):\n        request = IEventObjectCollection_get_Count()\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        return resp",
  "def Add(self, item, objectID):\n        request = IEventObjectCollection_Add()\n        request['item'] = item\n        request['objectID']['asData'] = objectID\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        return resp",
  "def Remove(self, objectID):\n        request = IEventObjectCollection_Remove()\n        request['objectID']['asData'] = objectID\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        return resp",
  "def __init__(self, interface):\n        IDispatch.__init__(self,interface)\n        self._iid = IID_IEventSystem",
  "def Query(self, progID, queryCriteria):\n        request = IEventSystem_Query()\n        request['progID']['asData']=progID\n        request['queryCriteria']['asData']=queryCriteria\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        iInterface = IDispatch(INTERFACE(self.get_cinstance(), b''.join(resp['ppInterface']['abData']), self.get_ipidRemUnknown(), target = self.get_target()))\n        return IEventObjectCollection(iInterface.RemQueryInterface(1, (IID_IEventObjectCollection,)))",
  "def Store(self, progID, pInterface):\n        request = IEventSystem_Store()\n        request['progID']['asData']=progID\n        request['pInterface'] = pInterface\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        return resp",
  "def Remove(self, progID, queryCriteria):\n        request = IEventSystem_Remove()\n        request['progID']['asData']=progID\n        request['queryCriteria'] = queryCriteria\n        resp = self.request(request, uuid = self.get_iPid())\n        return resp",
  "def get_EventObjectChangeEventClassID(self):\n        request = IEventSystem_get_EventObjectChangeEventClassID()\n        resp = self.request(request, uuid = self.get_iPid())\n        return resp",
  "def QueryS(self,progID, queryCriteria):\n        request = IEventSystem_QueryS()\n        request['progID']['asData']=progID\n        request['queryCriteria']['asData']=queryCriteria\n        resp = self.request(request, uuid = self.get_iPid())\n        iInterface = IDispatch(INTERFACE(self.get_cinstance(), b''.join(resp['ppInterface']['abData']), self.get_ipidRemUnknown(), target = self.get_target()))\n        return IEventObjectCollection(iInterface.RemQueryInterface(1, (IID_IEventObjectCollection,)))",
  "def RemoveS(self,progID, queryCriteria):\n        request = IEventSystem_RemoveS()\n        request['progID']['asData']=progID\n        request['queryCriteria']['asData']=queryCriteria\n        resp = self.request(request, uuid = self.get_iPid())\n        return resp",
  "def __init__(self, interface):\n        IEventSystem.__init__(self,interface)\n        self._iid = IID_IEventSystem2",
  "def GetVersion(self):\n        request = IEventSystem2_GetVersion()\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        return resp",
  "def VerifyTransientSubscribers(self):\n        request = IEventSystem2_GetVersion()\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        return resp",
  "def __init__(self, interface):\n        IRemUnknown.__init__(self,interface)\n        self._iid = IID_IEventSystemInitialize",
  "def SetCOMCatalogBehaviour(self, bRetainSubKeys):\n        request = IEventSystem2_GetVersion()\n        request['bRetainSubKeys'] = bRetainSubKeys\n        resp = self.request(request, iid = self._iid, uuid = self.get_iPid())\n        return resp",
  "class DCERPCSessionError(DCERPCException):\n    def __init__(self, error_string=None, error_code=None, packet=None):\n        DCERPCException.__init__(self, error_string, error_code, packet)\n\n    def __str__( self ):\n        if self.error_code in hresult_errors.ERROR_MESSAGES:\n            error_msg_short = hresult_errors.ERROR_MESSAGES[self.error_code][0]\n            error_msg_verbose = hresult_errors.ERROR_MESSAGES[self.error_code][1] \n            return 'VDS SessionError: code: 0x%x - %s - %s' % (self.error_code, error_msg_short, error_msg_verbose)\n        else:\n            return 'VDS SessionError: unknown error code: 0x%x' % (self.error_code)",
  "class VDS_SERVICE_PROP(NDRSTRUCT):\n    structure = (\n        ('pwszVersion',LPWSTR),\n        ('ulFlags',ULONG),\n    )",
  "class OBJECT_ARRAY(NDRUniConformantVaryingArray):\n    item = PMInterfacePointer",
  "class VDS_PROVIDER_TYPE(NDRENUM):\n    class enumItems(Enum):\n        VDS_PT_UNKNOWN     = 0\n        VDS_PT_SOFTWARE    = 1\n        VDS_PT_HARDWARE    = 2\n        VDS_PT_VIRTUALDISK = 3\n        VDS_PT_MAX         = 4",
  "class VDS_PROVIDER_PROP(NDRSTRUCT):\n    structure = (\n        ('id',VDS_OBJECT_ID),\n        ('pwszName',LPWSTR),\n        ('guidVersionId',GUID),\n        ('pwszVersion',LPWSTR),\n        ('type',VDS_PROVIDER_TYPE),\n        ('ulFlags',ULONG),\n        ('ulStripeSizeFlags',ULONG),\n        ('sRebuildPriority',SHORT),\n    )",
  "class IVdsServiceInitialization_Initialize(DCOMCALL):\n    opnum = 3\n    structure = (\n       ('pwszMachineName', LPWSTR),\n    )",
  "class IVdsServiceInitialization_InitializeResponse(DCOMANSWER):\n    structure = (\n       ('ErrorCode', error_status_t),\n    )",
  "class IVdsService_IsServiceReady(DCOMCALL):\n    opnum = 3\n    structure = (\n    )",
  "class IVdsService_IsServiceReadyResponse(DCOMANSWER):\n    structure = (\n       ('ErrorCode', error_status_t),\n    )",
  "class IVdsService_WaitForServiceReady(DCOMCALL):\n    opnum = 4\n    structure = (\n    )",
  "class IVdsService_WaitForServiceReadyResponse(DCOMANSWER):\n    structure = (\n       ('ErrorCode', error_status_t),\n    )",
  "class IVdsService_GetProperties(DCOMCALL):\n    opnum = 5\n    structure = (\n    )",
  "class IVdsService_GetPropertiesResponse(DCOMANSWER):\n    structure = (\n       ('pServiceProp', VDS_SERVICE_PROP),\n       ('ErrorCode', error_status_t),\n    )",
  "class IVdsService_QueryProviders(DCOMCALL):\n    opnum = 6\n    structure = (\n        ('masks', DWORD),\n    )",
  "class IVdsService_QueryProvidersResponse(DCOMANSWER):\n    structure = (\n       ('ppEnum', PMInterfacePointer),\n       ('ErrorCode', error_status_t),\n    )",
  "class IEnumVdsObject_Next(DCOMCALL):\n    opnum = 3\n    structure = (\n       ('celt', ULONG),\n    )",
  "class IEnumVdsObject_NextResponse(DCOMANSWER):\n    structure = (\n       ('ppObjectArray', OBJECT_ARRAY),\n       ('pcFetched', ULONG),\n       ('ErrorCode', error_status_t),\n    )",
  "class IVdsProvider_GetProperties(DCOMCALL):\n    opnum = 3\n    structure = (\n    )",
  "class IVdsProvider_GetPropertiesResponse(DCOMANSWER):\n    structure = (\n       ('pProviderProp', VDS_PROVIDER_PROP),\n       ('ErrorCode', error_status_t),\n    )",
  "class IEnumVdsObject(IRemUnknown2):\n    def Next(self, celt=0xffff):\n        request = IEnumVdsObject_Next()\n        request['ORPCthis'] = self.get_cinstance().get_ORPCthis()\n        request['ORPCthis']['flags'] = 0\n        request['celt'] = celt\n        try:\n            resp = self.request(request, uuid = self.get_iPid())\n        except Exception as e:\n            resp = e.get_packet()\n            # If it is S_FALSE(1) means less items were returned\n            if resp['ErrorCode'] != 1:\n                raise\n        interfaces = list()\n        for interface in resp['ppObjectArray']:\n            interfaces.append(IRemUnknown2(INTERFACE(self.get_cinstance(), ''.join(interface['abData']), self.get_ipidRemUnknown(), target = self.get_target())))\n        return interfaces",
  "class IVdsProvider(IRemUnknown2):\n    def GetProperties(self):\n        request = IVdsProvider_GetProperties()\n        request['ORPCthis'] = self.get_cinstance().get_ORPCthis()\n        request['ORPCthis']['flags'] = 0\n        resp = self.request(request, uuid = self.get_iPid())\n        return resp",
  "class IVdsServiceInitialization(IRemUnknown2):\n    def __init__(self, interface):\n        IRemUnknown2.__init__(self, interface)\n\n    def Initialize(self):\n        request = IVdsServiceInitialization_Initialize()\n        request['ORPCthis'] = self.get_cinstance().get_ORPCthis()\n        request['ORPCthis']['flags'] = 0\n        request['pwszMachineName'] = '\\x00'\n        resp = self.request(request, uuid = self.get_iPid())\n        return resp",
  "class IVdsService(IRemUnknown2):\n    def __init__(self, interface):\n        IRemUnknown2.__init__(self, interface)\n\n    def IsServiceReady(self):\n        request = IVdsService_IsServiceReady()\n        request['ORPCthis'] = self.get_cinstance().get_ORPCthis()\n        request['ORPCthis']['flags'] = 0\n        try:\n            resp = self.request(request, uuid = self.get_iPid())\n        except Exception as e:\n            resp = e.get_packet()\n        return resp \n\n    def WaitForServiceReady(self):\n        request = IVdsService_WaitForServiceReady()\n        request['ORPCthis'] = self.get_cinstance().get_ORPCthis()\n        request['ORPCthis']['flags'] = 0\n        resp = self.request(request, uuid = self.get_iPid())\n        return resp \n\n    def GetProperties(self):\n        request = IVdsService_GetProperties()\n        request['ORPCthis'] = self.get_cinstance().get_ORPCthis()\n        request['ORPCthis']['flags'] = 0\n        resp = self.request(request, uuid = self.get_iPid())\n        return resp \n\n    def QueryProviders(self, masks):\n        request = IVdsService_QueryProviders()\n        request['ORPCthis'] = self.get_cinstance().get_ORPCthis()\n        request['ORPCthis']['flags'] = 0\n        request['masks'] = masks\n        resp = self.request(request, uuid = self.get_iPid())\n        return IEnumVdsObject(INTERFACE(self.get_cinstance(), ''.join(resp['ppEnum']['abData']), self.get_ipidRemUnknown(), target = self.get_target()))",
  "def __init__(self, error_string=None, error_code=None, packet=None):\n        DCERPCException.__init__(self, error_string, error_code, packet)",
  "def __str__( self ):\n        if self.error_code in hresult_errors.ERROR_MESSAGES:\n            error_msg_short = hresult_errors.ERROR_MESSAGES[self.error_code][0]\n            error_msg_verbose = hresult_errors.ERROR_MESSAGES[self.error_code][1] \n            return 'VDS SessionError: code: 0x%x - %s - %s' % (self.error_code, error_msg_short, error_msg_verbose)\n        else:\n            return 'VDS SessionError: unknown error code: 0x%x' % (self.error_code)",
  "class enumItems(Enum):\n        VDS_PT_UNKNOWN     = 0\n        VDS_PT_SOFTWARE    = 1\n        VDS_PT_HARDWARE    = 2\n        VDS_PT_VIRTUALDISK = 3\n        VDS_PT_MAX         = 4",
  "def Next(self, celt=0xffff):\n        request = IEnumVdsObject_Next()\n        request['ORPCthis'] = self.get_cinstance().get_ORPCthis()\n        request['ORPCthis']['flags'] = 0\n        request['celt'] = celt\n        try:\n            resp = self.request(request, uuid = self.get_iPid())\n        except Exception as e:\n            resp = e.get_packet()\n            # If it is S_FALSE(1) means less items were returned\n            if resp['ErrorCode'] != 1:\n                raise\n        interfaces = list()\n        for interface in resp['ppObjectArray']:\n            interfaces.append(IRemUnknown2(INTERFACE(self.get_cinstance(), ''.join(interface['abData']), self.get_ipidRemUnknown(), target = self.get_target())))\n        return interfaces",
  "def GetProperties(self):\n        request = IVdsProvider_GetProperties()\n        request['ORPCthis'] = self.get_cinstance().get_ORPCthis()\n        request['ORPCthis']['flags'] = 0\n        resp = self.request(request, uuid = self.get_iPid())\n        return resp",
  "def __init__(self, interface):\n        IRemUnknown2.__init__(self, interface)",
  "def Initialize(self):\n        request = IVdsServiceInitialization_Initialize()\n        request['ORPCthis'] = self.get_cinstance().get_ORPCthis()\n        request['ORPCthis']['flags'] = 0\n        request['pwszMachineName'] = '\\x00'\n        resp = self.request(request, uuid = self.get_iPid())\n        return resp",
  "def __init__(self, interface):\n        IRemUnknown2.__init__(self, interface)",
  "def IsServiceReady(self):\n        request = IVdsService_IsServiceReady()\n        request['ORPCthis'] = self.get_cinstance().get_ORPCthis()\n        request['ORPCthis']['flags'] = 0\n        try:\n            resp = self.request(request, uuid = self.get_iPid())\n        except Exception as e:\n            resp = e.get_packet()\n        return resp",
  "def WaitForServiceReady(self):\n        request = IVdsService_WaitForServiceReady()\n        request['ORPCthis'] = self.get_cinstance().get_ORPCthis()\n        request['ORPCthis']['flags'] = 0\n        resp = self.request(request, uuid = self.get_iPid())\n        return resp",
  "def GetProperties(self):\n        request = IVdsService_GetProperties()\n        request['ORPCthis'] = self.get_cinstance().get_ORPCthis()\n        request['ORPCthis']['flags'] = 0\n        resp = self.request(request, uuid = self.get_iPid())\n        return resp",
  "def QueryProviders(self, masks):\n        request = IVdsService_QueryProviders()\n        request['ORPCthis'] = self.get_cinstance().get_ORPCthis()\n        request['ORPCthis']['flags'] = 0\n        request['masks'] = masks\n        resp = self.request(request, uuid = self.get_iPid())\n        return IEnumVdsObject(INTERFACE(self.get_cinstance(), ''.join(resp['ppEnum']['abData']), self.get_ipidRemUnknown(), target = self.get_target()))",
  "class LDAPConnection:\n    def __init__(self, url, baseDN='', dstIp=None):\n        \"\"\"\n        LDAPConnection class\n\n        :param string url:\n        :param string baseDN:\n        :param string dstIp:\n\n        :return: a LDAP instance, if not raises a LDAPSessionError exception\n        \"\"\"\n        self._SSL = False\n        self._dstPort = 0\n        self._dstHost = 0\n        self._socket = None\n        self._baseDN = baseDN\n        self._dstIp = dstIp\n\n        if url.startswith('ldap://'):\n            self._dstPort = 389\n            self._SSL = False\n            self._dstHost = url[7:]\n        elif url.startswith('ldaps://'):\n            self._dstPort = 636\n            self._SSL = True\n            self._dstHost = url[8:]\n        elif url.startswith('gc://'):\n            self._dstPort = 3268\n            self._SSL = False\n            self._dstHost = url[5:]\n        else:\n            raise LDAPSessionError(errorString=\"Unknown URL prefix: '%s'\" % url)\n\n        # Try to connect\n        if self._dstIp is not None:\n            targetHost = self._dstIp\n        else:\n            targetHost = self._dstHost\n\n        LOG.debug('Connecting to %s, port %d, SSL %s' % (targetHost, self._dstPort, self._SSL))\n        try:\n            af, socktype, proto, _, sa = socket.getaddrinfo(targetHost, self._dstPort, 0, socket.SOCK_STREAM)[0]\n            self._socket = socket.socket(af, socktype, proto)\n        except socket.error as e:\n            raise socket.error('Connection error (%s:%d)' % (targetHost, self._dstPort), e)\n\n        if self._SSL is False:\n            self._socket.connect(sa)\n        else:\n            # Switching to TLS now\n            ctx = SSL.Context(SSL.TLS_METHOD)\n            ctx.set_cipher_list('ALL:@SECLEVEL=0'.encode('utf-8'))\n            SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION = 0x00040000\n            ctx.set_options(SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION)\n            self._socket = SSL.Connection(ctx, self._socket)\n            self._socket.connect(sa)\n            self._socket.do_handshake()\n\n    def kerberosLogin(self, user, password, domain='', lmhash='', nthash='', aesKey='', kdcHost=None, TGT=None,\n                      TGS=None, useCache=True):\n        \"\"\"\n        logins into the target system explicitly using Kerberos. Hashes are used if RC4_HMAC is supported.\n\n        :param string user: username\n        :param string password: password for the user\n        :param string domain: domain where the account is valid for (required)\n        :param string lmhash: LMHASH used to authenticate using hashes (password is not used)\n        :param string nthash: NTHASH used to authenticate using hashes (password is not used)\n        :param string aesKey: aes256-cts-hmac-sha1-96 or aes128-cts-hmac-sha1-96 used for Kerberos authentication\n        :param string kdcHost: hostname or IP Address for the KDC. If None, the domain will be used (it needs to resolve tho)\n        :param struct TGT: If there's a TGT available, send the structure here and it will be used\n        :param struct TGS: same for TGS. See smb3.py for the format\n        :param bool useCache: whether or not we should use the ccache for credentials lookup. If TGT or TGS are specified this is False\n\n        :return: True, raises a LDAPSessionError if error.\n        \"\"\"\n\n        if lmhash != '' or nthash != '':\n            if len(lmhash) % 2:\n                lmhash = '0' + lmhash\n            if len(nthash) % 2:\n                nthash = '0' + nthash\n            try:  # just in case they were converted already\n                lmhash = unhexlify(lmhash)\n                nthash = unhexlify(nthash)\n            except TypeError:\n                pass\n\n        # Importing down here so pyasn1 is not required if kerberos is not used.\n        from impacket.krb5.ccache import CCache\n        from impacket.krb5.asn1 import AP_REQ, Authenticator, TGS_REP, seq_set\n        from impacket.krb5.kerberosv5 import getKerberosTGT, getKerberosTGS\n        from impacket.krb5 import constants\n        from impacket.krb5.types import Principal, KerberosTime, Ticket\n        import datetime\n\n        if TGT is not None or TGS is not None:\n            useCache = False\n\n        targetName = 'ldap/%s' % self._dstHost\n        if useCache:\n            domain, user, TGT, TGS = CCache.parseFile(domain, user, targetName)\n\n        # First of all, we need to get a TGT for the user\n        userName = Principal(user, type=constants.PrincipalNameType.NT_PRINCIPAL.value)\n        if TGT is None:\n            if TGS is None:\n                tgt, cipher, oldSessionKey, sessionKey = getKerberosTGT(userName, password, domain, lmhash, nthash,\n                                                                        aesKey, kdcHost)\n        else:\n            tgt = TGT['KDC_REP']\n            cipher = TGT['cipher']\n            sessionKey = TGT['sessionKey']\n\n        if TGS is None:\n            serverName = Principal(targetName, type=constants.PrincipalNameType.NT_SRV_INST.value)\n            tgs, cipher, oldSessionKey, sessionKey = getKerberosTGS(serverName, domain, kdcHost, tgt, cipher,\n                                                                    sessionKey)\n        else:\n            tgs = TGS['KDC_REP']\n            cipher = TGS['cipher']\n            sessionKey = TGS['sessionKey']\n\n            # Let's build a NegTokenInit with a Kerberos REQ_AP\n\n        blob = SPNEGO_NegTokenInit()\n\n        # Kerberos\n        blob['MechTypes'] = [TypesMech['MS KRB5 - Microsoft Kerberos 5']]\n\n        # Let's extract the ticket from the TGS\n        tgs = decoder.decode(tgs, asn1Spec=TGS_REP())[0]\n        ticket = Ticket()\n        ticket.from_asn1(tgs['ticket'])\n\n        # Now let's build the AP_REQ\n        apReq = AP_REQ()\n        apReq['pvno'] = 5\n        apReq['msg-type'] = int(constants.ApplicationTagNumbers.AP_REQ.value)\n\n        opts = []\n        apReq['ap-options'] = constants.encodeFlags(opts)\n        seq_set(apReq, 'ticket', ticket.to_asn1)\n\n        authenticator = Authenticator()\n        authenticator['authenticator-vno'] = 5\n        authenticator['crealm'] = domain\n        seq_set(authenticator, 'cname', userName.components_to_asn1)\n        now = datetime.datetime.utcnow()\n\n        authenticator['cusec'] = now.microsecond\n        authenticator['ctime'] = KerberosTime.to_asn1(now)\n\n        encodedAuthenticator = encoder.encode(authenticator)\n\n        # Key Usage 11\n        # AP-REQ Authenticator (includes application authenticator\n        # subkey), encrypted with the application session key\n        # (Section 5.5.1)\n        encryptedEncodedAuthenticator = cipher.encrypt(sessionKey, 11, encodedAuthenticator, None)\n\n        apReq['authenticator'] = noValue\n        apReq['authenticator']['etype'] = cipher.enctype\n        apReq['authenticator']['cipher'] = encryptedEncodedAuthenticator\n\n        blob['MechToken'] = encoder.encode(apReq)\n\n        # Done with the Kerberos saga, now let's get into LDAP\n\n        bindRequest = BindRequest()\n        bindRequest['version'] = 3\n        bindRequest['name'] = user\n        bindRequest['authentication']['sasl']['mechanism'] = 'GSS-SPNEGO'\n        bindRequest['authentication']['sasl']['credentials'] = blob.getData()\n\n        response = self.sendReceive(bindRequest)[0]['protocolOp']\n\n        if response['bindResponse']['resultCode'] != ResultCode('success'):\n            raise LDAPSessionError(\n                errorString='Error in bindRequest -> %s: %s' % (response['bindResponse']['resultCode'].prettyPrint(),\n                                                                response['bindResponse']['diagnosticMessage'])\n            )\n\n        return True\n\n    def login(self, user='', password='', domain='', lmhash='', nthash='', authenticationChoice='sicilyNegotiate'):\n        \"\"\"\n        logins into the target system\n\n        :param string user: username\n        :param string password: password for the user\n        :param string domain: domain where the account is valid for\n        :param string lmhash: LMHASH used to authenticate using hashes (password is not used)\n        :param string nthash: NTHASH used to authenticate using hashes (password is not used)\n        :param string authenticationChoice: type of authentication protocol to use (default NTLM)\n\n        :return: True, raises a LDAPSessionError if error.\n        \"\"\"\n        bindRequest = BindRequest()\n        bindRequest['version'] = 3\n\n        if authenticationChoice == 'simple':\n            if '.' in domain:\n                bindRequest['name'] = user + '@' + domain\n            elif domain:\n                bindRequest['name'] = domain + '\\\\' + user\n            else:\n                bindRequest['name'] = user\n            bindRequest['authentication']['simple'] = password\n            response = self.sendReceive(bindRequest)[0]['protocolOp']\n        elif authenticationChoice == 'sicilyPackageDiscovery':\n            bindRequest['name'] = user\n            bindRequest['authentication']['sicilyPackageDiscovery'] = ''\n            response = self.sendReceive(bindRequest)[0]['protocolOp']\n        elif authenticationChoice == 'sicilyNegotiate':\n            # Deal with NTLM Authentication\n            if lmhash != '' or nthash != '':\n                if len(lmhash) % 2:\n                    lmhash = '0' + lmhash\n                if len(nthash) % 2:\n                    nthash = '0' + nthash\n                try:  # just in case they were converted already\n                    lmhash = unhexlify(lmhash)\n                    nthash = unhexlify(nthash)\n                except TypeError:\n                    pass\n\n            bindRequest['name'] = user\n\n            # NTLM Negotiate\n            negotiate = getNTLMSSPType1('', domain)\n            bindRequest['authentication']['sicilyNegotiate'] = negotiate.getData()\n            response = self.sendReceive(bindRequest)[0]['protocolOp']\n            if response['bindResponse']['resultCode'] != ResultCode('success'):\n                raise LDAPSessionError(\n                    errorString='Error in bindRequest during the NTLMAuthNegotiate request -> %s: %s' %\n                                (response['bindResponse']['resultCode'].prettyPrint(),\n                                 response['bindResponse']['diagnosticMessage'])\n                )\n\n            # NTLM Challenge\n            type2 = response['bindResponse']['matchedDN']\n\n            # NTLM Auth\n            type3, exportedSessionKey = getNTLMSSPType3(negotiate, bytes(type2), user, password, domain, lmhash, nthash)\n            bindRequest['authentication']['sicilyResponse'] = type3.getData()\n            response = self.sendReceive(bindRequest)[0]['protocolOp']\n        elif authenticationChoice == 'sasl':\n            if lmhash != '' or nthash != '':\n                if len(lmhash) % 2:\n                    lmhash = '0' + lmhash\n                if len(nthash) % 2:\n                    nthash = '0' + nthash\n                try:\n                    lmhash = unhexlify(lmhash)\n                    nthash = unhexlify(nthash)\n                except TypeError:\n                    pass\n\n            bindRequest['name'] = user\n\n            # NTLM Negotiate\n            negotiate = getNTLMSSPType1('', domain)\n\n            blob = SPNEGO_NegTokenInit()\n            blob['MechTypes'] = [TypesMech['NTLMSSP - Microsoft NTLM Security Support Provider']]\n            blob['MechToken'] = negotiate.getData()\n\n            bindRequest['authentication']['sasl']['mechanism'] = 'GSS-SPNEGO'\n            bindRequest['authentication']['sasl']['credentials'] = blob.getData()\n            response = self.sendReceive(bindRequest)[0]['protocolOp']\n            if response['bindResponse']['resultCode'] != ResultCode('saslBindInProgress'):\n                raise LDAPSessionError(\n                    errorString='Error in bindRequest during the NTLMAuthNegotiate request -> %s: %s' %\n                                (response['bindResponse']['resultCode'].prettyPrint(),\n                                 response['bindResponse']['diagnosticMessage'])\n                )\n\n            # NTLM Challenge\n            serverSaslCreds = response['bindResponse']['serverSaslCreds']\n            spnegoTokenResp = SPNEGO_NegTokenResp(serverSaslCreds.asOctets())\n            type2 = spnegoTokenResp['ResponseToken']\n\n            # NTLM Auth\n            type3, exportedSessionKey = getNTLMSSPType3(negotiate, type2, user, password, domain, lmhash, nthash)\n            blob = SPNEGO_NegTokenResp()\n            blob['ResponseToken'] = type3.getData()\n\n            bindRequest['authentication']['sasl']['mechanism'] = 'GSS-SPNEGO'\n            bindRequest['authentication']['sasl']['credentials'] = blob.getData()\n            response = self.sendReceive(bindRequest)[0]['protocolOp']\n        else:\n            raise LDAPSessionError(errorString=\"Unknown authenticationChoice: '%s'\" % authenticationChoice)\n\n        if response['bindResponse']['resultCode'] != ResultCode('success'):\n            raise LDAPSessionError(\n                errorString='Error in bindRequest -> %s: %s' % (response['bindResponse']['resultCode'].prettyPrint(),\n                                                                response['bindResponse']['diagnosticMessage'])\n            )\n\n        return True\n\n    def search(self, searchBase=None, scope=None, derefAliases=None, sizeLimit=0, timeLimit=0, typesOnly=False,\n               searchFilter='(objectClass=*)', attributes=None, searchControls=None, perRecordCallback=None):\n        if searchBase is None:\n            searchBase = self._baseDN\n        if scope is None:\n            scope = Scope('wholeSubtree')\n        if derefAliases is None:\n            derefAliases = DerefAliases('neverDerefAliases')\n        if attributes is None:\n            attributes = []\n\n        searchRequest = SearchRequest()\n        searchRequest['baseObject'] = searchBase\n        searchRequest['scope'] = scope\n        searchRequest['derefAliases'] = derefAliases\n        searchRequest['sizeLimit'] = sizeLimit\n        searchRequest['timeLimit'] = timeLimit\n        searchRequest['typesOnly'] = typesOnly\n        searchRequest['filter'] = self._parseFilter(searchFilter)\n        searchRequest['attributes'].setComponents(*attributes)\n\n        done = False\n        answers = []\n        # We keep asking records until we get a SearchResultDone packet and all controls are handled\n        while not done:\n            response = self.sendReceive(searchRequest, searchControls)\n            for message in response:\n                searchResult = message['protocolOp'].getComponent()\n                if searchResult.isSameTypeWith(SearchResultDone()):\n                    if searchResult['resultCode'] == ResultCode('success'):\n                        done = self._handleControls(searchControls, message['controls'])\n                    else:\n                        raise LDAPSearchError(\n                            error=int(searchResult['resultCode']),\n                            errorString='Error in searchRequest -> %s: %s' % (searchResult['resultCode'].prettyPrint(),\n                                                                              searchResult['diagnosticMessage']),\n                            answers=answers\n                        )\n                else:\n                    if perRecordCallback is None:\n                        answers.append(searchResult)\n                    else:\n                        perRecordCallback(searchResult)\n\n        return answers\n\n    def _handleControls(self, requestControls, responseControls):\n        done = True\n        if requestControls is not None:\n            for requestControl in requestControls:\n                if responseControls is not None:\n                    for responseControl in responseControls:\n                        if str(requestControl['controlType']) == CONTROL_PAGEDRESULTS:\n                            if str(responseControl['controlType']) == CONTROL_PAGEDRESULTS:\n                                if hasattr(responseControl, 'getCookie') is not True:\n                                    responseControl = decoder.decode(encoder.encode(responseControl),\n                                                                 asn1Spec=KNOWN_CONTROLS[CONTROL_PAGEDRESULTS]())[0]\n                                if responseControl.getCookie():\n                                    done = False\n                                requestControl.setCookie(responseControl.getCookie())\n                                break\n                        else:\n                            # handle different controls here\n                            pass\n        return done\n\n    def close(self):\n        if self._socket is not None:\n            self._socket.close()\n\n    def send(self, request, controls=None):\n        message = LDAPMessage()\n        message['messageID'] = random.randrange(1, 2147483647)\n        message['protocolOp'].setComponentByType(request.getTagSet(), request)\n        if controls is not None:\n            message['controls'].setComponents(*controls)\n\n        data = encoder.encode(message)\n\n        return self._socket.sendall(data)\n\n    def recv(self):\n        REQUEST_SIZE = 8192\n        data = b''\n        done = False\n        while not done:\n            recvData = self._socket.recv(REQUEST_SIZE)\n            if len(recvData) < REQUEST_SIZE:\n                done = True\n            data += recvData\n\n        response = []\n        while len(data) > 0:\n            try:\n                message, remaining = decoder.decode(data, asn1Spec=LDAPMessage())\n            except SubstrateUnderrunError:\n                # We need more data\n                remaining = data + self._socket.recv(REQUEST_SIZE)\n            else:\n                if message['messageID'] == 0:  # unsolicited notification\n                    name = message['protocolOp']['extendedResp']['responseName'] or message['responseName']\n                    notification = KNOWN_NOTIFICATIONS.get(name, \"Unsolicited Notification '%s'\" % name)\n                    if name == NOTIFICATION_DISCONNECT:  # Server has disconnected\n                        self.close()\n                    raise LDAPSessionError(\n                        error=int(message['protocolOp']['extendedResp']['resultCode']),\n                        errorString='%s -> %s: %s' % (notification,\n                                                      message['protocolOp']['extendedResp']['resultCode'].prettyPrint(),\n                                                      message['protocolOp']['extendedResp']['diagnosticMessage'])\n                    )\n                response.append(message)\n            data = remaining\n\n        return response\n\n    def sendReceive(self, request, controls=None):\n        self.send(request, controls)\n        return self.recv()\n\n    def _parseFilter(self, filterStr):\n        try:\n            filterStr = filterStr.decode()\n        except AttributeError:\n            pass\n        filterList = list(reversed(filterStr))\n        searchFilter = self._consumeCompositeFilter(filterList)\n        if filterList:  # we have not consumed the whole filter string\n            raise LDAPFilterSyntaxError(\"unexpected token: '%s'\" % filterList[-1])\n        return searchFilter\n\n    def _consumeCompositeFilter(self, filterList):\n        try:\n            c = filterList.pop()\n        except IndexError:\n            raise LDAPFilterSyntaxError('EOL while parsing search filter')\n        if c != '(':  # filter must start with a '('\n            filterList.append(c)\n            raise LDAPFilterSyntaxError(\"unexpected token: '%s'\" % c)\n\n        try:\n            operator = filterList.pop()\n        except IndexError:\n            raise LDAPFilterSyntaxError('EOL while parsing search filter')\n        if operator not in ['!', '&', '|']:  # must be simple filter in this case\n            filterList.extend([operator, c])\n            return self._consumeSimpleFilter(filterList)\n\n        filters = []\n        while True:\n            try:\n                filters.append(self._consumeCompositeFilter(filterList))\n            except LDAPFilterSyntaxError:\n                break\n\n        try:\n            c = filterList.pop()\n        except IndexError:\n            raise LDAPFilterSyntaxError('EOL while parsing search filter')\n        if c != ')':  # filter must end with a ')'\n            filterList.append(c)\n            raise LDAPFilterSyntaxError(\"unexpected token: '%s'\" % c)\n\n        return self._compileCompositeFilter(operator, filters)\n\n    def _consumeSimpleFilter(self, filterList):\n        try:\n            c = filterList.pop()\n        except IndexError:\n            raise LDAPFilterSyntaxError('EOL while parsing search filter')\n        if c != '(':  # filter must start with a '('\n            filterList.append(c)\n            raise LDAPFilterSyntaxError(\"unexpected token: '%s'\" % c)\n\n        filter = []\n        while True:\n            try:\n                c = filterList.pop()\n            except IndexError:\n                raise LDAPFilterSyntaxError('EOL while parsing search filter')\n            if c == ')':  # we pop till we find a ')'\n                break\n            elif c == '(':  # should be no unencoded parenthesis\n                filterList.append(c)\n                raise LDAPFilterSyntaxError(\"unexpected token: '('\")\n            else:\n                filter.append(c)\n\n        filterStr = ''.join(filter)\n        try:\n            # https://tools.ietf.org/search/rfc4515#section-3\n            attribute, operator, value = RE_OPERATOR.split(filterStr, 1)\n        except ValueError:\n            raise LDAPFilterInvalidException(\"invalid filter: '(%s)'\" % filterStr)\n\n        return self._compileSimpleFilter(attribute, operator, value)\n\n    @staticmethod\n    def _compileCompositeFilter(operator, filters):\n        searchFilter = Filter()\n        if operator == '!':\n            if len(filters) != 1:\n                raise LDAPFilterInvalidException(\"'not' filter must have exactly one element\")\n            searchFilter['not'].setComponents(*filters)\n        elif operator == '&':\n            if len(filters) == 0:\n                raise LDAPFilterInvalidException(\"'and' filter must have at least one element\")\n            searchFilter['and'].setComponents(*filters)\n        elif operator == '|':\n            if len(filters) == 0:\n                raise LDAPFilterInvalidException(\"'or' filter must have at least one element\")\n            searchFilter['or'].setComponents(*filters)\n\n        return searchFilter\n\n    @staticmethod\n    def _compileSimpleFilter(attribute, operator, value):\n        searchFilter = Filter()\n        if operator == ':=':  # extensibleMatch\n            match = RE_EX_ATTRIBUTE_1.match(attribute) or RE_EX_ATTRIBUTE_2.match(attribute)\n            if not match:\n                raise LDAPFilterInvalidException(\"invalid filter attribute: '%s'\" % attribute)\n            attribute, dn, matchingRule = match.groups()\n            if attribute:\n                searchFilter['extensibleMatch']['type'] = attribute\n            if dn:\n                searchFilter['extensibleMatch']['dnAttributes'] = bool(dn)\n            if matchingRule:\n                searchFilter['extensibleMatch']['matchingRule'] = matchingRule\n            searchFilter['extensibleMatch']['matchValue'] = LDAPConnection._processLdapString(value)\n        else:\n            if not RE_ATTRIBUTE.match(attribute):\n                raise LDAPFilterInvalidException(\"invalid filter attribute: '%s'\" % attribute)\n            if value == '*' and operator == '=':  # present\n                searchFilter['present'] = attribute\n            elif '*' in value and operator == '=':  # substring\n                assertions = [LDAPConnection._processLdapString(assertion) for assertion in value.split('*')]\n                choice = searchFilter['substrings']['substrings'].getComponentType()\n                substrings = []\n                if assertions[0]:\n                    substrings.append(choice.clone().setComponentByName('initial', assertions[0]))\n                for assertion in assertions[1:-1]:\n                    substrings.append(choice.clone().setComponentByName('any', assertion))\n                if assertions[-1]:\n                    substrings.append(choice.clone().setComponentByName('final', assertions[-1]))\n                searchFilter['substrings']['type'] = attribute\n                searchFilter['substrings']['substrings'].setComponents(*substrings)\n            elif '*' not in value:  # simple\n                value = LDAPConnection._processLdapString(value)\n                if operator == '=':\n                    searchFilter['equalityMatch'].setComponents(attribute, value)\n                elif operator == '~=':\n                    searchFilter['approxMatch'].setComponents(attribute, value)\n                elif operator == '>=':\n                    searchFilter['greaterOrEqual'].setComponents(attribute, value)\n                elif operator == '<=':\n                    searchFilter['lessOrEqual'].setComponents(attribute, value)\n            else:\n                raise LDAPFilterInvalidException(\"invalid filter '(%s%s%s)'\" % (attribute, operator, value))\n\n        return searchFilter\n\n\n    @classmethod\n    def _processLdapString(cls, ldapstr):\n        def replace_escaped_chars(match):\n            return chr(int(match.group(1), 16))  # group(1) == \"XX\" (valid hex)\n\n        escaped_chars = re.compile(r'\\\\([0-9a-fA-F]{2})')  # Capture any sequence of \"\\XX\" (where XX is a valid hex)\n        return re.sub(escaped_chars, replace_escaped_chars, ldapstr)",
  "class LDAPFilterSyntaxError(SyntaxError):\n    pass",
  "class LDAPFilterInvalidException(Exception):\n    pass",
  "class LDAPSessionError(Exception):\n    \"\"\"\n    This is the exception every client should catch\n    \"\"\"\n\n    def __init__(self, error=0, packet=0, errorString=''):\n        Exception.__init__(self)\n        self.error = error\n        self.packet = packet\n        self.errorString = errorString\n\n    def getErrorCode(self):\n        return self.error\n\n    def getErrorPacket(self):\n        return self.packet\n\n    def getErrorString(self):\n        return self.errorString\n\n    def __str__(self):\n        return self.errorString",
  "class LDAPSearchError(LDAPSessionError):\n    def __init__(self, error=0, packet=0, errorString='', answers=None):\n        LDAPSessionError.__init__(self, error, packet, errorString)\n        if answers is None:\n            answers = []\n        self.answers = answers\n\n    def getAnswers(self):\n        return self.answers",
  "def __init__(self, url, baseDN='', dstIp=None):\n        \"\"\"\n        LDAPConnection class\n\n        :param string url:\n        :param string baseDN:\n        :param string dstIp:\n\n        :return: a LDAP instance, if not raises a LDAPSessionError exception\n        \"\"\"\n        self._SSL = False\n        self._dstPort = 0\n        self._dstHost = 0\n        self._socket = None\n        self._baseDN = baseDN\n        self._dstIp = dstIp\n\n        if url.startswith('ldap://'):\n            self._dstPort = 389\n            self._SSL = False\n            self._dstHost = url[7:]\n        elif url.startswith('ldaps://'):\n            self._dstPort = 636\n            self._SSL = True\n            self._dstHost = url[8:]\n        elif url.startswith('gc://'):\n            self._dstPort = 3268\n            self._SSL = False\n            self._dstHost = url[5:]\n        else:\n            raise LDAPSessionError(errorString=\"Unknown URL prefix: '%s'\" % url)\n\n        # Try to connect\n        if self._dstIp is not None:\n            targetHost = self._dstIp\n        else:\n            targetHost = self._dstHost\n\n        LOG.debug('Connecting to %s, port %d, SSL %s' % (targetHost, self._dstPort, self._SSL))\n        try:\n            af, socktype, proto, _, sa = socket.getaddrinfo(targetHost, self._dstPort, 0, socket.SOCK_STREAM)[0]\n            self._socket = socket.socket(af, socktype, proto)\n        except socket.error as e:\n            raise socket.error('Connection error (%s:%d)' % (targetHost, self._dstPort), e)\n\n        if self._SSL is False:\n            self._socket.connect(sa)\n        else:\n            # Switching to TLS now\n            ctx = SSL.Context(SSL.TLS_METHOD)\n            ctx.set_cipher_list('ALL:@SECLEVEL=0'.encode('utf-8'))\n            SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION = 0x00040000\n            ctx.set_options(SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION)\n            self._socket = SSL.Connection(ctx, self._socket)\n            self._socket.connect(sa)\n            self._socket.do_handshake()",
  "def kerberosLogin(self, user, password, domain='', lmhash='', nthash='', aesKey='', kdcHost=None, TGT=None,\n                      TGS=None, useCache=True):\n        \"\"\"\n        logins into the target system explicitly using Kerberos. Hashes are used if RC4_HMAC is supported.\n\n        :param string user: username\n        :param string password: password for the user\n        :param string domain: domain where the account is valid for (required)\n        :param string lmhash: LMHASH used to authenticate using hashes (password is not used)\n        :param string nthash: NTHASH used to authenticate using hashes (password is not used)\n        :param string aesKey: aes256-cts-hmac-sha1-96 or aes128-cts-hmac-sha1-96 used for Kerberos authentication\n        :param string kdcHost: hostname or IP Address for the KDC. If None, the domain will be used (it needs to resolve tho)\n        :param struct TGT: If there's a TGT available, send the structure here and it will be used\n        :param struct TGS: same for TGS. See smb3.py for the format\n        :param bool useCache: whether or not we should use the ccache for credentials lookup. If TGT or TGS are specified this is False\n\n        :return: True, raises a LDAPSessionError if error.\n        \"\"\"\n\n        if lmhash != '' or nthash != '':\n            if len(lmhash) % 2:\n                lmhash = '0' + lmhash\n            if len(nthash) % 2:\n                nthash = '0' + nthash\n            try:  # just in case they were converted already\n                lmhash = unhexlify(lmhash)\n                nthash = unhexlify(nthash)\n            except TypeError:\n                pass\n\n        # Importing down here so pyasn1 is not required if kerberos is not used.\n        from impacket.krb5.ccache import CCache\n        from impacket.krb5.asn1 import AP_REQ, Authenticator, TGS_REP, seq_set\n        from impacket.krb5.kerberosv5 import getKerberosTGT, getKerberosTGS\n        from impacket.krb5 import constants\n        from impacket.krb5.types import Principal, KerberosTime, Ticket\n        import datetime\n\n        if TGT is not None or TGS is not None:\n            useCache = False\n\n        targetName = 'ldap/%s' % self._dstHost\n        if useCache:\n            domain, user, TGT, TGS = CCache.parseFile(domain, user, targetName)\n\n        # First of all, we need to get a TGT for the user\n        userName = Principal(user, type=constants.PrincipalNameType.NT_PRINCIPAL.value)\n        if TGT is None:\n            if TGS is None:\n                tgt, cipher, oldSessionKey, sessionKey = getKerberosTGT(userName, password, domain, lmhash, nthash,\n                                                                        aesKey, kdcHost)\n        else:\n            tgt = TGT['KDC_REP']\n            cipher = TGT['cipher']\n            sessionKey = TGT['sessionKey']\n\n        if TGS is None:\n            serverName = Principal(targetName, type=constants.PrincipalNameType.NT_SRV_INST.value)\n            tgs, cipher, oldSessionKey, sessionKey = getKerberosTGS(serverName, domain, kdcHost, tgt, cipher,\n                                                                    sessionKey)\n        else:\n            tgs = TGS['KDC_REP']\n            cipher = TGS['cipher']\n            sessionKey = TGS['sessionKey']\n\n            # Let's build a NegTokenInit with a Kerberos REQ_AP\n\n        blob = SPNEGO_NegTokenInit()\n\n        # Kerberos\n        blob['MechTypes'] = [TypesMech['MS KRB5 - Microsoft Kerberos 5']]\n\n        # Let's extract the ticket from the TGS\n        tgs = decoder.decode(tgs, asn1Spec=TGS_REP())[0]\n        ticket = Ticket()\n        ticket.from_asn1(tgs['ticket'])\n\n        # Now let's build the AP_REQ\n        apReq = AP_REQ()\n        apReq['pvno'] = 5\n        apReq['msg-type'] = int(constants.ApplicationTagNumbers.AP_REQ.value)\n\n        opts = []\n        apReq['ap-options'] = constants.encodeFlags(opts)\n        seq_set(apReq, 'ticket', ticket.to_asn1)\n\n        authenticator = Authenticator()\n        authenticator['authenticator-vno'] = 5\n        authenticator['crealm'] = domain\n        seq_set(authenticator, 'cname', userName.components_to_asn1)\n        now = datetime.datetime.utcnow()\n\n        authenticator['cusec'] = now.microsecond\n        authenticator['ctime'] = KerberosTime.to_asn1(now)\n\n        encodedAuthenticator = encoder.encode(authenticator)\n\n        # Key Usage 11\n        # AP-REQ Authenticator (includes application authenticator\n        # subkey), encrypted with the application session key\n        # (Section 5.5.1)\n        encryptedEncodedAuthenticator = cipher.encrypt(sessionKey, 11, encodedAuthenticator, None)\n\n        apReq['authenticator'] = noValue\n        apReq['authenticator']['etype'] = cipher.enctype\n        apReq['authenticator']['cipher'] = encryptedEncodedAuthenticator\n\n        blob['MechToken'] = encoder.encode(apReq)\n\n        # Done with the Kerberos saga, now let's get into LDAP\n\n        bindRequest = BindRequest()\n        bindRequest['version'] = 3\n        bindRequest['name'] = user\n        bindRequest['authentication']['sasl']['mechanism'] = 'GSS-SPNEGO'\n        bindRequest['authentication']['sasl']['credentials'] = blob.getData()\n\n        response = self.sendReceive(bindRequest)[0]['protocolOp']\n\n        if response['bindResponse']['resultCode'] != ResultCode('success'):\n            raise LDAPSessionError(\n                errorString='Error in bindRequest -> %s: %s' % (response['bindResponse']['resultCode'].prettyPrint(),\n                                                                response['bindResponse']['diagnosticMessage'])\n            )\n\n        return True",
  "def login(self, user='', password='', domain='', lmhash='', nthash='', authenticationChoice='sicilyNegotiate'):\n        \"\"\"\n        logins into the target system\n\n        :param string user: username\n        :param string password: password for the user\n        :param string domain: domain where the account is valid for\n        :param string lmhash: LMHASH used to authenticate using hashes (password is not used)\n        :param string nthash: NTHASH used to authenticate using hashes (password is not used)\n        :param string authenticationChoice: type of authentication protocol to use (default NTLM)\n\n        :return: True, raises a LDAPSessionError if error.\n        \"\"\"\n        bindRequest = BindRequest()\n        bindRequest['version'] = 3\n\n        if authenticationChoice == 'simple':\n            if '.' in domain:\n                bindRequest['name'] = user + '@' + domain\n            elif domain:\n                bindRequest['name'] = domain + '\\\\' + user\n            else:\n                bindRequest['name'] = user\n            bindRequest['authentication']['simple'] = password\n            response = self.sendReceive(bindRequest)[0]['protocolOp']\n        elif authenticationChoice == 'sicilyPackageDiscovery':\n            bindRequest['name'] = user\n            bindRequest['authentication']['sicilyPackageDiscovery'] = ''\n            response = self.sendReceive(bindRequest)[0]['protocolOp']\n        elif authenticationChoice == 'sicilyNegotiate':\n            # Deal with NTLM Authentication\n            if lmhash != '' or nthash != '':\n                if len(lmhash) % 2:\n                    lmhash = '0' + lmhash\n                if len(nthash) % 2:\n                    nthash = '0' + nthash\n                try:  # just in case they were converted already\n                    lmhash = unhexlify(lmhash)\n                    nthash = unhexlify(nthash)\n                except TypeError:\n                    pass\n\n            bindRequest['name'] = user\n\n            # NTLM Negotiate\n            negotiate = getNTLMSSPType1('', domain)\n            bindRequest['authentication']['sicilyNegotiate'] = negotiate.getData()\n            response = self.sendReceive(bindRequest)[0]['protocolOp']\n            if response['bindResponse']['resultCode'] != ResultCode('success'):\n                raise LDAPSessionError(\n                    errorString='Error in bindRequest during the NTLMAuthNegotiate request -> %s: %s' %\n                                (response['bindResponse']['resultCode'].prettyPrint(),\n                                 response['bindResponse']['diagnosticMessage'])\n                )\n\n            # NTLM Challenge\n            type2 = response['bindResponse']['matchedDN']\n\n            # NTLM Auth\n            type3, exportedSessionKey = getNTLMSSPType3(negotiate, bytes(type2), user, password, domain, lmhash, nthash)\n            bindRequest['authentication']['sicilyResponse'] = type3.getData()\n            response = self.sendReceive(bindRequest)[0]['protocolOp']\n        elif authenticationChoice == 'sasl':\n            if lmhash != '' or nthash != '':\n                if len(lmhash) % 2:\n                    lmhash = '0' + lmhash\n                if len(nthash) % 2:\n                    nthash = '0' + nthash\n                try:\n                    lmhash = unhexlify(lmhash)\n                    nthash = unhexlify(nthash)\n                except TypeError:\n                    pass\n\n            bindRequest['name'] = user\n\n            # NTLM Negotiate\n            negotiate = getNTLMSSPType1('', domain)\n\n            blob = SPNEGO_NegTokenInit()\n            blob['MechTypes'] = [TypesMech['NTLMSSP - Microsoft NTLM Security Support Provider']]\n            blob['MechToken'] = negotiate.getData()\n\n            bindRequest['authentication']['sasl']['mechanism'] = 'GSS-SPNEGO'\n            bindRequest['authentication']['sasl']['credentials'] = blob.getData()\n            response = self.sendReceive(bindRequest)[0]['protocolOp']\n            if response['bindResponse']['resultCode'] != ResultCode('saslBindInProgress'):\n                raise LDAPSessionError(\n                    errorString='Error in bindRequest during the NTLMAuthNegotiate request -> %s: %s' %\n                                (response['bindResponse']['resultCode'].prettyPrint(),\n                                 response['bindResponse']['diagnosticMessage'])\n                )\n\n            # NTLM Challenge\n            serverSaslCreds = response['bindResponse']['serverSaslCreds']\n            spnegoTokenResp = SPNEGO_NegTokenResp(serverSaslCreds.asOctets())\n            type2 = spnegoTokenResp['ResponseToken']\n\n            # NTLM Auth\n            type3, exportedSessionKey = getNTLMSSPType3(negotiate, type2, user, password, domain, lmhash, nthash)\n            blob = SPNEGO_NegTokenResp()\n            blob['ResponseToken'] = type3.getData()\n\n            bindRequest['authentication']['sasl']['mechanism'] = 'GSS-SPNEGO'\n            bindRequest['authentication']['sasl']['credentials'] = blob.getData()\n            response = self.sendReceive(bindRequest)[0]['protocolOp']\n        else:\n            raise LDAPSessionError(errorString=\"Unknown authenticationChoice: '%s'\" % authenticationChoice)\n\n        if response['bindResponse']['resultCode'] != ResultCode('success'):\n            raise LDAPSessionError(\n                errorString='Error in bindRequest -> %s: %s' % (response['bindResponse']['resultCode'].prettyPrint(),\n                                                                response['bindResponse']['diagnosticMessage'])\n            )\n\n        return True",
  "def search(self, searchBase=None, scope=None, derefAliases=None, sizeLimit=0, timeLimit=0, typesOnly=False,\n               searchFilter='(objectClass=*)', attributes=None, searchControls=None, perRecordCallback=None):\n        if searchBase is None:\n            searchBase = self._baseDN\n        if scope is None:\n            scope = Scope('wholeSubtree')\n        if derefAliases is None:\n            derefAliases = DerefAliases('neverDerefAliases')\n        if attributes is None:\n            attributes = []\n\n        searchRequest = SearchRequest()\n        searchRequest['baseObject'] = searchBase\n        searchRequest['scope'] = scope\n        searchRequest['derefAliases'] = derefAliases\n        searchRequest['sizeLimit'] = sizeLimit\n        searchRequest['timeLimit'] = timeLimit\n        searchRequest['typesOnly'] = typesOnly\n        searchRequest['filter'] = self._parseFilter(searchFilter)\n        searchRequest['attributes'].setComponents(*attributes)\n\n        done = False\n        answers = []\n        # We keep asking records until we get a SearchResultDone packet and all controls are handled\n        while not done:\n            response = self.sendReceive(searchRequest, searchControls)\n            for message in response:\n                searchResult = message['protocolOp'].getComponent()\n                if searchResult.isSameTypeWith(SearchResultDone()):\n                    if searchResult['resultCode'] == ResultCode('success'):\n                        done = self._handleControls(searchControls, message['controls'])\n                    else:\n                        raise LDAPSearchError(\n                            error=int(searchResult['resultCode']),\n                            errorString='Error in searchRequest -> %s: %s' % (searchResult['resultCode'].prettyPrint(),\n                                                                              searchResult['diagnosticMessage']),\n                            answers=answers\n                        )\n                else:\n                    if perRecordCallback is None:\n                        answers.append(searchResult)\n                    else:\n                        perRecordCallback(searchResult)\n\n        return answers",
  "def _handleControls(self, requestControls, responseControls):\n        done = True\n        if requestControls is not None:\n            for requestControl in requestControls:\n                if responseControls is not None:\n                    for responseControl in responseControls:\n                        if str(requestControl['controlType']) == CONTROL_PAGEDRESULTS:\n                            if str(responseControl['controlType']) == CONTROL_PAGEDRESULTS:\n                                if hasattr(responseControl, 'getCookie') is not True:\n                                    responseControl = decoder.decode(encoder.encode(responseControl),\n                                                                 asn1Spec=KNOWN_CONTROLS[CONTROL_PAGEDRESULTS]())[0]\n                                if responseControl.getCookie():\n                                    done = False\n                                requestControl.setCookie(responseControl.getCookie())\n                                break\n                        else:\n                            # handle different controls here\n                            pass\n        return done",
  "def close(self):\n        if self._socket is not None:\n            self._socket.close()",
  "def send(self, request, controls=None):\n        message = LDAPMessage()\n        message['messageID'] = random.randrange(1, 2147483647)\n        message['protocolOp'].setComponentByType(request.getTagSet(), request)\n        if controls is not None:\n            message['controls'].setComponents(*controls)\n\n        data = encoder.encode(message)\n\n        return self._socket.sendall(data)",
  "def recv(self):\n        REQUEST_SIZE = 8192\n        data = b''\n        done = False\n        while not done:\n            recvData = self._socket.recv(REQUEST_SIZE)\n            if len(recvData) < REQUEST_SIZE:\n                done = True\n            data += recvData\n\n        response = []\n        while len(data) > 0:\n            try:\n                message, remaining = decoder.decode(data, asn1Spec=LDAPMessage())\n            except SubstrateUnderrunError:\n                # We need more data\n                remaining = data + self._socket.recv(REQUEST_SIZE)\n            else:\n                if message['messageID'] == 0:  # unsolicited notification\n                    name = message['protocolOp']['extendedResp']['responseName'] or message['responseName']\n                    notification = KNOWN_NOTIFICATIONS.get(name, \"Unsolicited Notification '%s'\" % name)\n                    if name == NOTIFICATION_DISCONNECT:  # Server has disconnected\n                        self.close()\n                    raise LDAPSessionError(\n                        error=int(message['protocolOp']['extendedResp']['resultCode']),\n                        errorString='%s -> %s: %s' % (notification,\n                                                      message['protocolOp']['extendedResp']['resultCode'].prettyPrint(),\n                                                      message['protocolOp']['extendedResp']['diagnosticMessage'])\n                    )\n                response.append(message)\n            data = remaining\n\n        return response",
  "def sendReceive(self, request, controls=None):\n        self.send(request, controls)\n        return self.recv()",
  "def _parseFilter(self, filterStr):\n        try:\n            filterStr = filterStr.decode()\n        except AttributeError:\n            pass\n        filterList = list(reversed(filterStr))\n        searchFilter = self._consumeCompositeFilter(filterList)\n        if filterList:  # we have not consumed the whole filter string\n            raise LDAPFilterSyntaxError(\"unexpected token: '%s'\" % filterList[-1])\n        return searchFilter",
  "def _consumeCompositeFilter(self, filterList):\n        try:\n            c = filterList.pop()\n        except IndexError:\n            raise LDAPFilterSyntaxError('EOL while parsing search filter')\n        if c != '(':  # filter must start with a '('\n            filterList.append(c)\n            raise LDAPFilterSyntaxError(\"unexpected token: '%s'\" % c)\n\n        try:\n            operator = filterList.pop()\n        except IndexError:\n            raise LDAPFilterSyntaxError('EOL while parsing search filter')\n        if operator not in ['!', '&', '|']:  # must be simple filter in this case\n            filterList.extend([operator, c])\n            return self._consumeSimpleFilter(filterList)\n\n        filters = []\n        while True:\n            try:\n                filters.append(self._consumeCompositeFilter(filterList))\n            except LDAPFilterSyntaxError:\n                break\n\n        try:\n            c = filterList.pop()\n        except IndexError:\n            raise LDAPFilterSyntaxError('EOL while parsing search filter')\n        if c != ')':  # filter must end with a ')'\n            filterList.append(c)\n            raise LDAPFilterSyntaxError(\"unexpected token: '%s'\" % c)\n\n        return self._compileCompositeFilter(operator, filters)",
  "def _consumeSimpleFilter(self, filterList):\n        try:\n            c = filterList.pop()\n        except IndexError:\n            raise LDAPFilterSyntaxError('EOL while parsing search filter')\n        if c != '(':  # filter must start with a '('\n            filterList.append(c)\n            raise LDAPFilterSyntaxError(\"unexpected token: '%s'\" % c)\n\n        filter = []\n        while True:\n            try:\n                c = filterList.pop()\n            except IndexError:\n                raise LDAPFilterSyntaxError('EOL while parsing search filter')\n            if c == ')':  # we pop till we find a ')'\n                break\n            elif c == '(':  # should be no unencoded parenthesis\n                filterList.append(c)\n                raise LDAPFilterSyntaxError(\"unexpected token: '('\")\n            else:\n                filter.append(c)\n\n        filterStr = ''.join(filter)\n        try:\n            # https://tools.ietf.org/search/rfc4515#section-3\n            attribute, operator, value = RE_OPERATOR.split(filterStr, 1)\n        except ValueError:\n            raise LDAPFilterInvalidException(\"invalid filter: '(%s)'\" % filterStr)\n\n        return self._compileSimpleFilter(attribute, operator, value)",
  "def _compileCompositeFilter(operator, filters):\n        searchFilter = Filter()\n        if operator == '!':\n            if len(filters) != 1:\n                raise LDAPFilterInvalidException(\"'not' filter must have exactly one element\")\n            searchFilter['not'].setComponents(*filters)\n        elif operator == '&':\n            if len(filters) == 0:\n                raise LDAPFilterInvalidException(\"'and' filter must have at least one element\")\n            searchFilter['and'].setComponents(*filters)\n        elif operator == '|':\n            if len(filters) == 0:\n                raise LDAPFilterInvalidException(\"'or' filter must have at least one element\")\n            searchFilter['or'].setComponents(*filters)\n\n        return searchFilter",
  "def _compileSimpleFilter(attribute, operator, value):\n        searchFilter = Filter()\n        if operator == ':=':  # extensibleMatch\n            match = RE_EX_ATTRIBUTE_1.match(attribute) or RE_EX_ATTRIBUTE_2.match(attribute)\n            if not match:\n                raise LDAPFilterInvalidException(\"invalid filter attribute: '%s'\" % attribute)\n            attribute, dn, matchingRule = match.groups()\n            if attribute:\n                searchFilter['extensibleMatch']['type'] = attribute\n            if dn:\n                searchFilter['extensibleMatch']['dnAttributes'] = bool(dn)\n            if matchingRule:\n                searchFilter['extensibleMatch']['matchingRule'] = matchingRule\n            searchFilter['extensibleMatch']['matchValue'] = LDAPConnection._processLdapString(value)\n        else:\n            if not RE_ATTRIBUTE.match(attribute):\n                raise LDAPFilterInvalidException(\"invalid filter attribute: '%s'\" % attribute)\n            if value == '*' and operator == '=':  # present\n                searchFilter['present'] = attribute\n            elif '*' in value and operator == '=':  # substring\n                assertions = [LDAPConnection._processLdapString(assertion) for assertion in value.split('*')]\n                choice = searchFilter['substrings']['substrings'].getComponentType()\n                substrings = []\n                if assertions[0]:\n                    substrings.append(choice.clone().setComponentByName('initial', assertions[0]))\n                for assertion in assertions[1:-1]:\n                    substrings.append(choice.clone().setComponentByName('any', assertion))\n                if assertions[-1]:\n                    substrings.append(choice.clone().setComponentByName('final', assertions[-1]))\n                searchFilter['substrings']['type'] = attribute\n                searchFilter['substrings']['substrings'].setComponents(*substrings)\n            elif '*' not in value:  # simple\n                value = LDAPConnection._processLdapString(value)\n                if operator == '=':\n                    searchFilter['equalityMatch'].setComponents(attribute, value)\n                elif operator == '~=':\n                    searchFilter['approxMatch'].setComponents(attribute, value)\n                elif operator == '>=':\n                    searchFilter['greaterOrEqual'].setComponents(attribute, value)\n                elif operator == '<=':\n                    searchFilter['lessOrEqual'].setComponents(attribute, value)\n            else:\n                raise LDAPFilterInvalidException(\"invalid filter '(%s%s%s)'\" % (attribute, operator, value))\n\n        return searchFilter",
  "def _processLdapString(cls, ldapstr):\n        def replace_escaped_chars(match):\n            return chr(int(match.group(1), 16))  # group(1) == \"XX\" (valid hex)\n\n        escaped_chars = re.compile(r'\\\\([0-9a-fA-F]{2})')  # Capture any sequence of \"\\XX\" (where XX is a valid hex)\n        return re.sub(escaped_chars, replace_escaped_chars, ldapstr)",
  "def __init__(self, error=0, packet=0, errorString=''):\n        Exception.__init__(self)\n        self.error = error\n        self.packet = packet\n        self.errorString = errorString",
  "def getErrorCode(self):\n        return self.error",
  "def getErrorPacket(self):\n        return self.packet",
  "def getErrorString(self):\n        return self.errorString",
  "def __str__(self):\n        return self.errorString",
  "def __init__(self, error=0, packet=0, errorString='', answers=None):\n        LDAPSessionError.__init__(self, error, packet, errorString)\n        if answers is None:\n            answers = []\n        self.answers = answers",
  "def getAnswers(self):\n        return self.answers",
  "def replace_escaped_chars(match):\n            return chr(int(match.group(1), 16))",
  "class LDAP_SID_IDENTIFIER_AUTHORITY(Structure):\n    structure = (\n        ('Value','6s'),\n    )",
  "class LDAP_SID(Structure):\n    structure = (\n        ('Revision','<B'),\n        ('SubAuthorityCount','<B'),\n        ('IdentifierAuthority',':',LDAP_SID_IDENTIFIER_AUTHORITY),\n        ('SubLen','_-SubAuthority','self[\"SubAuthorityCount\"]*4'),\n        ('SubAuthority',':'),\n    )\n\n    def formatCanonical(self):\n        ans = 'S-%d-%d' % (self['Revision'], ord(self['IdentifierAuthority']['Value'][5:6]))\n        for i in range(self['SubAuthorityCount']):\n            ans += '-%d' % ( unpack('<L',self['SubAuthority'][i*4:i*4+4])[0])\n        return ans\n\n    def fromCanonical(self, canonical):\n        items = canonical.split('-')\n        self['Revision'] = int(items[1])\n        self['IdentifierAuthority'] = LDAP_SID_IDENTIFIER_AUTHORITY()\n        self['IdentifierAuthority']['Value'] = b'\\x00\\x00\\x00\\x00\\x00' + pack('B',int(items[2]))\n        self['SubAuthorityCount'] = len(items) - 3\n        self['SubAuthority'] = b''\n        for i in range(self['SubAuthorityCount']):\n            self['SubAuthority'] += pack('<L', int(items[i+3]))",
  "class SR_SECURITY_DESCRIPTOR(Structure):\n    structure = (\n        ('Revision','c'),\n        ('Sbz1','c'),\n        ('Control','<H'),\n        ('OffsetOwner','<L'),\n        ('OffsetGroup','<L'),\n        ('OffsetSacl','<L'),\n        ('OffsetDacl','<L'),\n        ('Sacl',':'),\n        ('Dacl',':'),\n        ('OwnerSid',':'),\n        ('GroupSid',':'),\n    )\n\n    def fromString(self, data):\n        Structure.fromString(self, data)\n        # All these fields are optional, if the offset is 0 they are empty\n        # there are also flags indicating if they are present\n        # TODO: parse those if it adds value\n        if self['OffsetOwner'] != 0:\n            self['OwnerSid'] = LDAP_SID(data=data[self['OffsetOwner']:])\n        else:\n            self['OwnerSid'] = b''\n\n        if self['OffsetGroup'] != 0:\n            self['GroupSid'] = LDAP_SID(data=data[self['OffsetGroup']:])\n        else:\n            self['GroupSid'] = b''\n\n        if self['OffsetSacl'] != 0:\n            self['Sacl'] = ACL(data=data[self['OffsetSacl']:])\n        else:\n            self['Sacl'] = b''\n\n        if self['OffsetDacl'] != 0:\n            self['Dacl'] = ACL(data=data[self['OffsetDacl']:])\n        else:\n            self['Sacl'] = b''\n\n    def getData(self):\n        headerlen = 20\n        # Reconstruct the security descriptor\n        # flags are currently not set automatically\n        # TODO: do this?\n        datalen = 0\n        if self['Sacl'] != b'':\n            self['OffsetSacl'] = headerlen + datalen\n            datalen += len(self['Sacl'].getData())\n        else:\n            self['OffsetSacl'] = 0\n\n        if self['Dacl'] != b'':\n            self['OffsetDacl'] = headerlen + datalen\n            datalen += len(self['Dacl'].getData())\n        else:\n            self['OffsetDacl'] = 0\n\n        if self['OwnerSid'] != b'':\n            self['OffsetOwner'] = headerlen + datalen\n            datalen += len(self['OwnerSid'].getData())\n        else:\n            self['OffsetOwner'] = 0\n\n        if self['GroupSid'] != b'':\n            self['OffsetGroup'] = headerlen + datalen\n            datalen += len(self['GroupSid'].getData())\n        else:\n            self['OffsetGroup'] = 0\n        return Structure.getData(self)",
  "class ACE(Structure):\n    # Flag constants\n    CONTAINER_INHERIT_ACE       = 0x02\n    FAILED_ACCESS_ACE_FLAG      = 0x80\n    INHERIT_ONLY_ACE            = 0x08\n    INHERITED_ACE               = 0x10\n    NO_PROPAGATE_INHERIT_ACE    = 0x04\n    OBJECT_INHERIT_ACE          = 0x01\n    SUCCESSFUL_ACCESS_ACE_FLAG  = 0x40\n\n    structure = (\n        #\n        # ACE_HEADER as described in 2.4.4.1\n        # https://msdn.microsoft.com/en-us/library/cc230296.aspx\n        #\n        ('AceType','B'),\n        ('AceFlags','B'),\n        ('AceSize','<H'),\n        # Virtual field to calculate data length from AceSize\n        ('AceLen', '_-Ace', 'self[\"AceSize\"]-4'),\n        #\n        # ACE body, is parsed depending on the type\n        #\n        ('Ace',':')\n    )\n\n    def fromString(self, data):\n        # This will parse the header\n        Structure.fromString(self, data)\n        # Now we parse the ACE body according to its type\n        self['TypeName'] = ACE_TYPE_MAP[self['AceType']].__name__\n        self['Ace'] = ACE_TYPE_MAP[self['AceType']](data=self['Ace'])\n\n    def getData(self):\n        if RECALC_ACE_SIZE or 'AceSize' not in self.fields:\n            self['AceSize'] = len(self['Ace'].getData())+4 # Header size (4 bytes) is included\n        if self['AceSize'] % 4 != 0:\n            # Make sure the alignment is correct\n            self['AceSize'] += self['AceSize'] % 4\n        data = Structure.getData(self)\n        # For some reason ACEs are sometimes longer than they need to be\n        # we fill this space up with null bytes to make sure the object\n        # we create is identical to the original object\n        if len(data) < self['AceSize']:\n            data += '\\x00' * (self['AceSize'] - len(data))\n        return data\n\n    def hasFlag(self, flag):\n        return self['AceFlags'] & flag == flag",
  "class ACCESS_MASK(Structure):\n    # Flag constants\n    GENERIC_READ            = 0x80000000\n    GENERIC_WRITE           = 0x40000000\n    GENERIC_EXECUTE         = 0x20000000\n    GENERIC_ALL             = 0x10000000\n    MAXIMUM_ALLOWED         = 0x02000000\n    ACCESS_SYSTEM_SECURITY  = 0x01000000\n    SYNCHRONIZE             = 0x00100000\n    WRITE_OWNER             = 0x00080000\n    WRITE_DACL              = 0x00040000\n    READ_CONTROL            = 0x00020000\n    DELETE                  = 0x00010000\n\n    structure = (\n        ('Mask', '<L'),\n    )\n\n    def hasPriv(self, priv):\n        return self['Mask'] & priv == priv\n\n    def setPriv(self, priv):\n        self['Mask'] |= priv\n\n    def removePriv(self, priv):\n        self['Mask'] ^= priv",
  "class ACCESS_ALLOWED_ACE(Structure):\n    ACE_TYPE = 0x00\n    structure = (\n        ('Mask', ':', ACCESS_MASK),\n        ('Sid', ':', LDAP_SID)\n    )",
  "class ACCESS_ALLOWED_OBJECT_ACE(Structure):\n    ACE_TYPE = 0x05\n\n    # Flag contstants\n    ACE_OBJECT_TYPE_PRESENT             = 0x01\n    ACE_INHERITED_OBJECT_TYPE_PRESENT   = 0x02\n\n    # ACE type specific mask constants\n    # Note that while not documented, these also seem valid\n    # for ACCESS_ALLOWED_ACE types\n    ADS_RIGHT_DS_CONTROL_ACCESS         = 0x00000100\n    ADS_RIGHT_DS_CREATE_CHILD           = 0x00000001\n    ADS_RIGHT_DS_DELETE_CHILD           = 0x00000002\n    ADS_RIGHT_DS_READ_PROP              = 0x00000010\n    ADS_RIGHT_DS_WRITE_PROP             = 0x00000020\n    ADS_RIGHT_DS_SELF                   = 0x00000008\n\n\n    structure = (\n        ('Mask', ':', ACCESS_MASK),\n        ('Flags', '<L'),\n        # Optional field\n        ('ObjectTypeLen','_-ObjectType','self.checkObjectType(self[\"Flags\"])'),\n        ('ObjectType', ':=\"\"'),\n        # Optional field\n        ('InheritedObjectTypeLen','_-InheritedObjectType','self.checkInheritedObjectType(self[\"Flags\"])'),\n        ('InheritedObjectType', ':=\"\"'),\n        ('Sid', ':', LDAP_SID)\n    )\n\n    @staticmethod\n    def checkInheritedObjectType(flags):\n        if flags & ACCESS_ALLOWED_OBJECT_ACE.ACE_INHERITED_OBJECT_TYPE_PRESENT:\n            return 16\n        return 0\n\n    @staticmethod\n    def checkObjectType(flags):\n        if flags & ACCESS_ALLOWED_OBJECT_ACE.ACE_OBJECT_TYPE_PRESENT:\n            return 16\n        return 0\n\n    def getData(self):\n        # Set the correct flags\n        if self['ObjectType'] != b'':\n            self['Flags'] |= self.ACE_OBJECT_TYPE_PRESENT\n        if self['InheritedObjectType'] != b'':\n            self['Flags'] |= self.ACE_INHERITED_OBJECT_TYPE_PRESENT\n        return Structure.getData(self)\n\n    def hasFlag(self, flag):\n        return self['Flags'] & flag == flag",
  "class ACCESS_DENIED_ACE(ACCESS_ALLOWED_ACE):\n    ACE_TYPE = 0x01",
  "class ACCESS_DENIED_OBJECT_ACE(ACCESS_ALLOWED_OBJECT_ACE):\n    ACE_TYPE = 0x06",
  "class ACCESS_ALLOWED_CALLBACK_ACE(Structure):\n    ACE_TYPE = 0x09\n    structure = (\n        ('Mask', ':', ACCESS_MASK),\n        ('Sid', ':', LDAP_SID),\n        ('ApplicationData', ':')\n    )",
  "class ACCESS_DENIED_CALLBACK_ACE(ACCESS_ALLOWED_CALLBACK_ACE):\n    ACE_TYPE = 0x0A",
  "class ACCESS_ALLOWED_CALLBACK_OBJECT_ACE(ACCESS_ALLOWED_OBJECT_ACE):\n    ACE_TYPE = 0x0B\n    structure = (\n        ('Mask', ':', ACCESS_MASK),\n        ('Flags', '<L'),\n        # Optional field\n        ('ObjectTypeLen','_-ObjectType','self.checkObjectType(self[\"Flags\"])'),\n        ('ObjectType', ':=\"\"'),\n        # Optional field\n        ('InheritedObjectTypeLen','_-InheritedObjectType','self.checkInheritedObjectType(self[\"Flags\"])'),\n        ('InheritedObjectType', ':=\"\"'),\n        ('Sid', ':', LDAP_SID),\n        ('ApplicationData', ':')\n    )",
  "class ACCESS_DENIED_CALLBACK_OBJECT_ACE(ACCESS_ALLOWED_CALLBACK_OBJECT_ACE):\n    ACE_TYPE = 0x0C",
  "class SYSTEM_AUDIT_ACE(ACCESS_ALLOWED_ACE):\n    ACE_TYPE = 0x02",
  "class SYSTEM_AUDIT_OBJECT_ACE(ACCESS_ALLOWED_CALLBACK_OBJECT_ACE):\n    ACE_TYPE = 0x07",
  "class SYSTEM_AUDIT_CALLBACK_ACE(ACCESS_ALLOWED_CALLBACK_ACE):\n    ACE_TYPE = 0x0D",
  "class SYSTEM_MANDATORY_LABEL_ACE(Structure):\n    ACE_TYPE = 0x11\n    structure = (\n        ('Mask', ':', ACCESS_MASK),\n        ('Sid', ':', LDAP_SID)\n    )",
  "class SYSTEM_AUDIT_CALLBACK_OBJECT_ACE(ACCESS_ALLOWED_CALLBACK_OBJECT_ACE):\n    ACE_TYPE = 0x0F",
  "class SYSTEM_RESOURCE_ATTRIBUTE_ACE(ACCESS_ALLOWED_CALLBACK_ACE):\n    ACE_TYPE = 0x12",
  "class SYSTEM_SCOPED_POLICY_ID_ACE(ACCESS_ALLOWED_ACE):\n    ACE_TYPE = 0x13",
  "class ACL(Structure):\n    structure = (\n        ('AclRevision', 'B'),\n        ('Sbz1', 'B'),\n        ('AclSize', '<H'),\n        ('AceCount', '<H'),\n        ('Sbz2', '<H'),\n        # Virtual field to calculate data length from AclSize\n        ('DataLen', '_-Data', 'self[\"AclSize\"]-8'),\n        ('Data', ':'),\n    )\n\n    def fromString(self, data):\n        self.aces = []\n        Structure.fromString(self, data)\n        for i in range(self['AceCount']):\n            # If we don't have any data left, return\n            if len(self['Data']) == 0:\n                raise Exception(\"ACL header indicated there are more ACLs to unpack, but there is no more data\")\n            ace = ACE(data=self['Data'])\n            self.aces.append(ace)\n            self['Data'] = self['Data'][ace['AceSize']:]\n        self['Data'] = self.aces\n\n    def getData(self):\n        self['AceCount'] = len(self.aces)\n        # We modify the data field to be able to use the\n        # parent class parsing\n        self['Data'] = b''.join([ace.getData() for ace in self.aces])\n        self['AclSize'] = len(self['Data'])+8 # Header size (8 bytes) is included\n        data = Structure.getData(self)\n        # Put the ACEs back in data\n        self['Data'] = self.aces\n        return data",
  "def formatCanonical(self):\n        ans = 'S-%d-%d' % (self['Revision'], ord(self['IdentifierAuthority']['Value'][5:6]))\n        for i in range(self['SubAuthorityCount']):\n            ans += '-%d' % ( unpack('<L',self['SubAuthority'][i*4:i*4+4])[0])\n        return ans",
  "def fromCanonical(self, canonical):\n        items = canonical.split('-')\n        self['Revision'] = int(items[1])\n        self['IdentifierAuthority'] = LDAP_SID_IDENTIFIER_AUTHORITY()\n        self['IdentifierAuthority']['Value'] = b'\\x00\\x00\\x00\\x00\\x00' + pack('B',int(items[2]))\n        self['SubAuthorityCount'] = len(items) - 3\n        self['SubAuthority'] = b''\n        for i in range(self['SubAuthorityCount']):\n            self['SubAuthority'] += pack('<L', int(items[i+3]))",
  "def fromString(self, data):\n        Structure.fromString(self, data)\n        # All these fields are optional, if the offset is 0 they are empty\n        # there are also flags indicating if they are present\n        # TODO: parse those if it adds value\n        if self['OffsetOwner'] != 0:\n            self['OwnerSid'] = LDAP_SID(data=data[self['OffsetOwner']:])\n        else:\n            self['OwnerSid'] = b''\n\n        if self['OffsetGroup'] != 0:\n            self['GroupSid'] = LDAP_SID(data=data[self['OffsetGroup']:])\n        else:\n            self['GroupSid'] = b''\n\n        if self['OffsetSacl'] != 0:\n            self['Sacl'] = ACL(data=data[self['OffsetSacl']:])\n        else:\n            self['Sacl'] = b''\n\n        if self['OffsetDacl'] != 0:\n            self['Dacl'] = ACL(data=data[self['OffsetDacl']:])\n        else:\n            self['Sacl'] = b''",
  "def getData(self):\n        headerlen = 20\n        # Reconstruct the security descriptor\n        # flags are currently not set automatically\n        # TODO: do this?\n        datalen = 0\n        if self['Sacl'] != b'':\n            self['OffsetSacl'] = headerlen + datalen\n            datalen += len(self['Sacl'].getData())\n        else:\n            self['OffsetSacl'] = 0\n\n        if self['Dacl'] != b'':\n            self['OffsetDacl'] = headerlen + datalen\n            datalen += len(self['Dacl'].getData())\n        else:\n            self['OffsetDacl'] = 0\n\n        if self['OwnerSid'] != b'':\n            self['OffsetOwner'] = headerlen + datalen\n            datalen += len(self['OwnerSid'].getData())\n        else:\n            self['OffsetOwner'] = 0\n\n        if self['GroupSid'] != b'':\n            self['OffsetGroup'] = headerlen + datalen\n            datalen += len(self['GroupSid'].getData())\n        else:\n            self['OffsetGroup'] = 0\n        return Structure.getData(self)",
  "def fromString(self, data):\n        # This will parse the header\n        Structure.fromString(self, data)\n        # Now we parse the ACE body according to its type\n        self['TypeName'] = ACE_TYPE_MAP[self['AceType']].__name__\n        self['Ace'] = ACE_TYPE_MAP[self['AceType']](data=self['Ace'])",
  "def getData(self):\n        if RECALC_ACE_SIZE or 'AceSize' not in self.fields:\n            self['AceSize'] = len(self['Ace'].getData())+4 # Header size (4 bytes) is included\n        if self['AceSize'] % 4 != 0:\n            # Make sure the alignment is correct\n            self['AceSize'] += self['AceSize'] % 4\n        data = Structure.getData(self)\n        # For some reason ACEs are sometimes longer than they need to be\n        # we fill this space up with null bytes to make sure the object\n        # we create is identical to the original object\n        if len(data) < self['AceSize']:\n            data += '\\x00' * (self['AceSize'] - len(data))\n        return data",
  "def hasFlag(self, flag):\n        return self['AceFlags'] & flag == flag",
  "def hasPriv(self, priv):\n        return self['Mask'] & priv == priv",
  "def setPriv(self, priv):\n        self['Mask'] |= priv",
  "def removePriv(self, priv):\n        self['Mask'] ^= priv",
  "def checkInheritedObjectType(flags):\n        if flags & ACCESS_ALLOWED_OBJECT_ACE.ACE_INHERITED_OBJECT_TYPE_PRESENT:\n            return 16\n        return 0",
  "def checkObjectType(flags):\n        if flags & ACCESS_ALLOWED_OBJECT_ACE.ACE_OBJECT_TYPE_PRESENT:\n            return 16\n        return 0",
  "def getData(self):\n        # Set the correct flags\n        if self['ObjectType'] != b'':\n            self['Flags'] |= self.ACE_OBJECT_TYPE_PRESENT\n        if self['InheritedObjectType'] != b'':\n            self['Flags'] |= self.ACE_INHERITED_OBJECT_TYPE_PRESENT\n        return Structure.getData(self)",
  "def hasFlag(self, flag):\n        return self['Flags'] & flag == flag",
  "def fromString(self, data):\n        self.aces = []\n        Structure.fromString(self, data)\n        for i in range(self['AceCount']):\n            # If we don't have any data left, return\n            if len(self['Data']) == 0:\n                raise Exception(\"ACL header indicated there are more ACLs to unpack, but there is no more data\")\n            ace = ACE(data=self['Data'])\n            self.aces.append(ace)\n            self['Data'] = self['Data'][ace['AceSize']:]\n        self['Data'] = self.aces",
  "def getData(self):\n        self['AceCount'] = len(self.aces)\n        # We modify the data field to be able to use the\n        # parent class parsing\n        self['Data'] = b''.join([ace.getData() for ace in self.aces])\n        self['AclSize'] = len(self['Data'])+8 # Header size (8 bytes) is included\n        data = Structure.getData(self)\n        # Put the ACEs back in data\n        self['Data'] = self.aces\n        return data",
  "class DefaultSequenceAndSetBaseMixin:\n    def getComponentByPosition(self, idx, default=univ.noValue, instantiate=True):\n        for cls in self.__class__.__bases__:\n            if cls is not DefaultSequenceAndSetBaseMixin:\n                try:\n                    component = cls.getComponentByPosition(self, idx)#, default, instantiate)\n                except AttributeError:\n                    continue\n                if component is None:\n                    return self.setComponentByPosition(idx).getComponentByPosition(idx)# , default, instantiate)\n                return component",
  "class ResultCode(univ.Enumerated):\n    namedValues = namedval.NamedValues(\n        ('success', 0),\n        ('operationsError', 1),\n        ('protocolError', 2),\n        ('timeLimitExceeded', 3),\n        ('sizeLimitExceeded', 4),\n        ('compareFalse', 5),\n        ('compareTrue', 6),\n        ('authMethodNotSupported', 7),\n        ('strongerAuthRequired', 8),\n        ('referral', 10),\n        ('adminLimitExceeded', 11),\n        ('unavailableCriticalExtension', 12),\n        ('confidentialityRequired', 13),\n        ('saslBindInProgress', 14),\n        ('noSuchAttribute', 16),\n        ('undefinedAttributeType', 17),\n        ('inappropriateMatching', 18),\n        ('constraintViolation', 19),\n        ('attributeOrValueExists', 20),\n        ('invalidAttributeSyntax', 21),\n        ('noSuchObject', 32),\n        ('aliasProblem', 33),\n        ('invalidDNSyntax', 34),\n        ('aliasDereferencingProblem', 36),\n        ('inappropriateAuthentication', 48),\n        ('invalidCredentials', 49),\n        ('insufficientAccessRights', 50),\n        ('busy', 51),\n        ('unavailable', 52),\n        ('unwillingToPerform', 53),\n        ('loopDetect', 54),\n        ('namingViolation', 64),\n        ('objectClassViolation', 65),\n        ('notAllowedOnNonLeaf', 66),\n        ('notAllowedOnRDN', 67),\n        ('entryAlreadyExists', 68),\n        ('objectClassModsProhibited', 69),\n        ('affectsMultipleDSAs', 71),\n        ('other', 80),\n    )",
  "class Scope(univ.Enumerated):\n    namedValues = namedval.NamedValues(\n        ('baseObject', 0),\n        ('singleLevel', 1),\n        ('wholeSubtree', 2),\n    )",
  "class DerefAliases(univ.Enumerated):\n    namedValues = namedval.NamedValues(\n        ('neverDerefAliases', 0),\n        ('derefInSearching', 1),\n        ('derefFindingBaseObj', 2),\n        ('derefAlways', 3),\n    )",
  "class Operation(univ.Enumerated):\n    namedValues = namedval.NamedValues(\n        ('add', 0),\n        ('delete', 1),\n        ('replace', 2),\n    )",
  "class MessageID(univ.Integer):\n    subtypeSpec = constraint.ValueRangeConstraint(0, maxInt)",
  "class LDAPString(univ.OctetString):\n    encoding = 'utf-8'",
  "class LDAPOID(univ.OctetString):\n    pass",
  "class LDAPDN(LDAPString):\n    pass",
  "class RelativeLDAPDN(LDAPString):\n    pass",
  "class AttributeDescription(LDAPString):\n    pass",
  "class AttributeValue(univ.OctetString):\n    pass",
  "class AssertionValue(univ.OctetString):\n    pass",
  "class MatchingRuleID(LDAPString):\n    pass",
  "class URI(LDAPString):\n    pass",
  "class AttributeValueAssertion(univ.Sequence):\n    componentType = namedtype.NamedTypes(\n        namedtype.NamedType('attributeDesc', AttributeDescription()),\n        namedtype.NamedType('assertionValue', AssertionValue())\n    )",
  "class PartialAttribute(univ.Sequence):\n    componentType = namedtype.NamedTypes(\n        namedtype.NamedType('type', AttributeDescription()),\n        namedtype.NamedType('vals', univ.SetOf(componentType=AttributeValue()))\n    )",
  "class PartialAttributeList(univ.SequenceOf):\n    componentType = PartialAttribute()",
  "class Attribute(univ.Sequence):\n    componentType = namedtype.NamedTypes(\n        namedtype.NamedType('type', AttributeDescription()),\n        namedtype.NamedType(\n            'vals',\n            univ.SetOf(componentType=AttributeValue()).subtype(subtypeSpec=constraint.ValueSizeConstraint(1, maxInt))\n        )\n    )",
  "class AttributeList(univ.SequenceOf):\n    componentType = Attribute()",
  "class AttributeSelection(univ.SequenceOf):\n    componentType = LDAPString()",
  "class Referral(univ.SequenceOf):\n    componentType = URI()\n    subtypeSpec = constraint.ValueSizeConstraint(1, maxInt)",
  "class LDAPResult(univ.Sequence):\n    componentType = namedtype.NamedTypes(\n        namedtype.NamedType('resultCode', ResultCode()),\n        namedtype.NamedType('matchedDN', LDAPDN()),\n        namedtype.NamedType('diagnosticMessage', LDAPString()),\n        namedtype.OptionalNamedType(\n            'referral', Referral().subtype(implicitTag=tag.Tag(tag.tagClassContext, tag.tagFormatSimple, 3))\n        )\n    )",
  "class SaslCredentials(univ.Sequence):\n    componentType = namedtype.NamedTypes(\n        namedtype.NamedType('mechanism', LDAPString()),\n        namedtype.OptionalNamedType('credentials', univ.OctetString())\n    )",
  "class AuthenticationChoice(DefaultSequenceAndSetBaseMixin, univ.Choice):\n    componentType = namedtype.NamedTypes(\n        namedtype.NamedType(\n            'simple',\n            univ.OctetString().subtype(implicitTag=tag.Tag(tag.tagClassContext, tag.tagFormatSimple, 0))\n        ),\n        namedtype.NamedType(\n            'sasl',\n            SaslCredentials().subtype(implicitTag=tag.Tag(tag.tagClassContext, tag.tagFormatConstructed, 3))\n        ),\n        namedtype.NamedType(\n            'sicilyPackageDiscovery',\n            univ.OctetString().subtype(implicitTag=tag.Tag(tag.tagClassContext, tag.tagFormatSimple, 9))\n        ),\n        namedtype.NamedType(\n            'sicilyNegotiate',\n            univ.OctetString().subtype(implicitTag=tag.Tag(tag.tagClassContext, tag.tagFormatSimple, 10))\n        ),\n        namedtype.NamedType(\n            'sicilyResponse',\n            univ.OctetString().subtype(implicitTag=tag.Tag(tag.tagClassContext, tag.tagFormatSimple, 11))\n        )\n    )",
  "class BindRequest(DefaultSequenceAndSetBaseMixin, univ.Sequence):\n    tagSet = univ.Sequence.tagSet.tagImplicitly(tag.Tag(tag.tagClassApplication, tag.tagFormatConstructed, 0))\n    componentType = namedtype.NamedTypes(\n        namedtype.NamedType('version', univ.Integer().subtype(subtypeSpec=constraint.ValueRangeConstraint(1, 127))),\n        namedtype.NamedType('name', LDAPDN()),\n        namedtype.NamedType('authentication', AuthenticationChoice())\n    )",
  "class BindResponse(univ.Sequence):\n    tagSet = univ.Sequence.tagSet.tagImplicitly(tag.Tag(tag.tagClassApplication, tag.tagFormatConstructed, 1))\n    componentType = namedtype.NamedTypes(\n        namedtype.NamedType('resultCode', ResultCode()),\n        namedtype.NamedType('matchedDN', LDAPDN()),\n        namedtype.NamedType('diagnosticMessage', LDAPString()),\n        namedtype.OptionalNamedType(\n            'referral',\n            Referral().subtype(implicitTag=tag.Tag(tag.tagClassContext, tag.tagFormatSimple, 3))\n        ),\n        namedtype.OptionalNamedType(\n            'serverSaslCreds',\n            univ.OctetString().subtype(implicitTag=tag.Tag(tag.tagClassContext, tag.tagFormatSimple, 7))\n        )\n    )",
  "class UnbindRequest(univ.Null):\n    tagSet = univ.Null.tagSet.tagImplicitly(tag.Tag(tag.tagClassApplication, tag.tagFormatSimple, 2))",
  "class SubstringFilter(DefaultSequenceAndSetBaseMixin, univ.Sequence):\n    componentType = namedtype.NamedTypes(\n        namedtype.NamedType('type', AttributeDescription()),\n        namedtype.NamedType(\n            'substrings',\n            univ.SequenceOf(componentType=univ.Choice(componentType=namedtype.NamedTypes(\n                namedtype.NamedType(\n                    'initial',\n                    AssertionValue().subtype(implicitTag=tag.Tag(tag.tagClassContext, tag.tagFormatSimple, 0))\n                ),\n                namedtype.NamedType(\n                    'any',\n                    AssertionValue().subtype(implicitTag=tag.Tag(tag.tagClassContext, tag.tagFormatSimple, 1))\n                ),\n                namedtype.NamedType(\n                    'final',\n                    AssertionValue().subtype(implicitTag=tag.Tag(tag.tagClassContext, tag.tagFormatSimple, 2))\n                )\n            )))\n        )\n    )",
  "class MatchingRuleAssertion(univ.Sequence):\n    componentType = namedtype.NamedTypes(\n        namedtype.OptionalNamedType(\n            'matchingRule',\n            MatchingRuleID().subtype(implicitTag=tag.Tag(tag.tagClassContext, tag.tagFormatSimple, 1))\n        ),\n        namedtype.OptionalNamedType(\n            'type',\n            AttributeDescription().subtype(implicitTag=tag.Tag(tag.tagClassContext, tag.tagFormatSimple, 2))\n        ),\n        namedtype.NamedType(\n            'matchValue',\n            AssertionValue().subtype(implicitTag=tag.Tag(tag.tagClassContext, tag.tagFormatSimple, 3))\n        ),\n        namedtype.DefaultedNamedType(\n            'dnAttributes',\n            univ.Boolean().subtype(value=False, implicitTag=tag.Tag(tag.tagClassContext, tag.tagFormatSimple, 4))\n        )\n    )",
  "class Filter(DefaultSequenceAndSetBaseMixin, univ.Choice):\n    pass",
  "class SearchRequest(DefaultSequenceAndSetBaseMixin, univ.Sequence):\n    tagSet = univ.Sequence.tagSet.tagImplicitly(tag.Tag(tag.tagClassApplication, tag.tagFormatConstructed, 3))\n    componentType = namedtype.NamedTypes(\n        namedtype.NamedType('baseObject', LDAPDN()),\n        namedtype.NamedType('scope', Scope()),\n        namedtype.NamedType('derefAliases', DerefAliases()),\n        namedtype.NamedType(\n            'sizeLimit', univ.Integer().subtype(subtypeSpec=constraint.ValueRangeConstraint(0, maxInt))\n        ),\n        namedtype.NamedType(\n            'timeLimit', univ.Integer().subtype(subtypeSpec=constraint.ValueRangeConstraint(0, maxInt))\n        ),\n        namedtype.NamedType('typesOnly', univ.Boolean()),\n        namedtype.NamedType('filter', Filter()),\n        namedtype.NamedType('attributes', AttributeSelection())\n    )",
  "class SearchResultEntry(univ.Sequence):\n    tagSet = univ.Sequence.tagSet.tagImplicitly(tag.Tag(tag.tagClassApplication, tag.tagFormatConstructed, 4))\n    componentType = namedtype.NamedTypes(\n        namedtype.NamedType('objectName', LDAPDN()),\n        namedtype.NamedType('attributes', PartialAttributeList())\n    )",
  "class SearchResultReference(univ.SequenceOf):\n    tagSet = univ.SequenceOf.tagSet.tagImplicitly(tag.Tag(tag.tagClassApplication, tag.tagFormatSimple, 19))\n    componentType = URI()\n    subtypeSpec = constraint.ValueSizeConstraint(1, maxInt)",
  "class SearchResultDone(LDAPResult):\n    tagSet = LDAPResult.tagSet.tagImplicitly(tag.Tag(tag.tagClassApplication, tag.tagFormatConstructed, 5))",
  "class ModifyRequest(DefaultSequenceAndSetBaseMixin, univ.Sequence):\n    tagSet = univ.Sequence.tagSet.tagImplicitly(tag.Tag(tag.tagClassApplication, tag.tagFormatConstructed, 6))\n    componentType = namedtype.NamedTypes(\n        namedtype.NamedType('object', LDAPDN()),\n        namedtype.NamedType(\n            'changes',\n            univ.SequenceOf(componentType=univ.Sequence(componentType=namedtype.NamedTypes(\n                namedtype.NamedType('operation', Operation()),\n                namedtype.NamedType('modification', PartialAttribute())\n            )))\n        )\n    )",
  "class ModifyResponse(LDAPResult):\n    tagSet = LDAPResult.tagSet.tagImplicitly(tag.Tag(tag.tagClassApplication, tag.tagFormatConstructed, 7))",
  "class AddRequest(DefaultSequenceAndSetBaseMixin, univ.Sequence):\n    tagSet = univ.Sequence.tagSet.tagImplicitly(tag.Tag(tag.tagClassApplication, tag.tagFormatConstructed, 8))\n    componentType = namedtype.NamedTypes(\n        namedtype.NamedType('entry', LDAPDN()),\n        namedtype.NamedType('attributes', AttributeList())\n    )",
  "class AddResponse(LDAPResult):\n    tagSet = LDAPResult.tagSet.tagImplicitly(tag.Tag(tag.tagClassApplication, tag.tagFormatConstructed, 9))",
  "class DelRequest(LDAPDN):\n    tagSet = LDAPDN.tagSet.tagImplicitly(tag.Tag(tag.tagClassApplication, tag.tagFormatSimple, 10))",
  "class DelResponse(LDAPResult):\n    tagSet = LDAPResult.tagSet.tagImplicitly(tag.Tag(tag.tagClassApplication, tag.tagFormatConstructed, 11))",
  "class ModifyDNRequest(univ.Sequence):\n    tagSet = univ.Sequence.tagSet.tagImplicitly(tag.Tag(tag.tagClassApplication, tag.tagFormatConstructed, 12))\n    componentType = namedtype.NamedTypes(\n        namedtype.NamedType('entry', LDAPDN()),\n        namedtype.NamedType('newrdn', RelativeLDAPDN()),\n        namedtype.NamedType('deleteoldrdn', univ.Boolean()),\n        namedtype.OptionalNamedType(\n            'newSuperior', LDAPDN().subtype(implicitTag=tag.Tag(tag.tagClassContext, tag.tagFormatSimple, 0))\n        )\n    )",
  "class ModifyDNResponse(LDAPResult):\n    tagSet = LDAPResult.tagSet.tagImplicitly(tag.Tag(tag.tagClassApplication, tag.tagFormatConstructed, 13))",
  "class CompareRequest(DefaultSequenceAndSetBaseMixin, univ.Sequence):\n    tagSet = univ.Sequence.tagSet.tagImplicitly(tag.Tag(tag.tagClassApplication, tag.tagFormatConstructed, 14))\n    componentType = namedtype.NamedTypes(\n        namedtype.NamedType('entry', LDAPDN()),\n        namedtype.NamedType('ava', AttributeValueAssertion())\n    )",
  "class CompareResponse(LDAPResult):\n    tagSet = LDAPResult.tagSet.tagImplicitly(tag.Tag(tag.tagClassApplication, tag.tagFormatConstructed, 15))",
  "class AbandonRequest(MessageID):\n    tagSet = MessageID.tagSet.tagImplicitly(tag.Tag(tag.tagClassApplication, tag.tagFormatSimple, 16))",
  "class ExtendedRequest(univ.Sequence):\n    tagSet = univ.Sequence.tagSet.tagImplicitly(tag.Tag(tag.tagClassApplication, tag.tagFormatConstructed, 23))\n    componentType = namedtype.NamedTypes(\n        namedtype.NamedType(\n            'requestName', LDAPOID().subtype(implicitTag=tag.Tag(tag.tagClassContext, tag.tagFormatSimple, 0))\n        ),\n        namedtype.OptionalNamedType(\n            'requestValue', univ.OctetString().subtype(implicitTag=tag.Tag(tag.tagClassContext, tag.tagFormatSimple, 1))\n        )\n    )",
  "class ExtendedResponse(univ.Sequence):\n    tagSet = univ.Sequence.tagSet.tagImplicitly(tag.Tag(tag.tagClassApplication, tag.tagFormatConstructed, 24))\n    componentType = namedtype.NamedTypes(\n        namedtype.NamedType('resultCode', ResultCode()),\n        namedtype.NamedType('matchedDN', LDAPDN()),\n        namedtype.NamedType('diagnosticMessage', LDAPString()),\n        namedtype.OptionalNamedType(\n            'referral',\n            Referral().subtype(implicitTag=tag.Tag(tag.tagClassContext, tag.tagFormatSimple, 3))\n        ),\n        namedtype.OptionalNamedType(\n            'responseName',\n            LDAPOID().subtype(implicitTag=tag.Tag(tag.tagClassContext, tag.tagFormatSimple, 10))\n        ),\n        namedtype.OptionalNamedType(\n            'responseValue',\n            univ.OctetString().subtype(implicitTag=tag.Tag(tag.tagClassContext, tag.tagFormatSimple, 11))\n        )\n    )",
  "class IntermediateResponse(univ.Sequence):\n    tagSet = univ.Sequence.tagSet.tagImplicitly(tag.Tag(tag.tagClassApplication, tag.tagFormatConstructed, 25))\n    componentType = namedtype.NamedTypes(\n        namedtype.OptionalNamedType(\n            'responseName',\n            LDAPOID().subtype(implicitTag=tag.Tag(tag.tagClassContext, tag.tagFormatSimple, 0))\n        ),\n        namedtype.OptionalNamedType(\n            'responseValue',\n            univ.OctetString().subtype(implicitTag=tag.Tag(tag.tagClassContext, tag.tagFormatSimple, 1))\n        )\n    )",
  "class Control(univ.Sequence):\n    componentType = namedtype.NamedTypes(\n        namedtype.NamedType('controlType', LDAPOID()),\n        namedtype.DefaultedNamedType('criticality', univ.Boolean().subtype(value=False)),\n        namedtype.OptionalNamedType('controlValue', univ.OctetString())\n    )\n\n    def setComponentByPosition(self, idx, value=univ.noValue,\n                               verifyConstraints=True,\n                               matchTags=True,\n                               matchConstraints=True):\n        if idx == 0:  # controlType\n            try:\n                cls = KNOWN_CONTROLS[value]\n                if self.__class__ is not cls:\n                    self.__class__ = cls\n            except KeyError:\n                pass\n        return univ.Sequence.setComponentByPosition(self, idx, value=value,\n                                                    verifyConstraints=verifyConstraints,\n                                                    matchTags=matchTags,\n                                                    matchConstraints=matchConstraints)\n\n    def encodeControlValue(self):\n        pass\n\n    def decodeControlValue(self):\n        return\n\n    def prettyPrint(self, scope=0):\n        r = univ.Sequence.prettyPrint(self, scope)\n        decodedControlValue = self.decodeControlValue()\n        if decodedControlValue is not None:\n            r = r[:r.rindex('=') + 1] + '%s\\n' % decodedControlValue.prettyPrint(scope + 1)\n        return r",
  "class Controls(univ.SequenceOf):\n    componentType = Control()",
  "class SDFlagsControlValue(univ.Sequence):\n    componentType = namedtype.NamedTypes(\n        namedtype.NamedType('flags', univ.Integer().subtype(subtypeSpec=constraint.ValueRangeConstraint(0, maxInt))),\n    )",
  "class SDFlagsControl(Control):\n    def __init__(self, criticality=None, flags=0x00000007, **kwargs):\n        Control.__init__(self, **kwargs)\n        self['controlType'] = CONTROL_SDFLAGS\n        if criticality is not None:\n            self['criticality'] = criticality\n        self.flags = flags\n        self.encodeControlValue()\n\n    def encodeControlValue(self):\n        self['controlValue'] = encoder.encode(\n            SDFlagsControlValue().setComponents(self.flags))\n\n    def decodeControlValue(self):\n        decodedControlValue, _ = decoder.decode(self['controlValue'], asn1Spec=SDFlagsControlValue())\n        self._flags =  decodedControlValue[0]\n        return decodedControlValue\n\n    def getCriticality(self):\n        return self['criticality']\n\n    def setCriticality(self, value):\n        self['criticality'] = value\n\n    def getFlags(self):\n        self.decodeControlValue()\n        return self._flags\n\n    def setFlags(self, value):\n        self._flags = value\n        self.encodeControlValue()",
  "class SimplePagedResultsControlValue(univ.Sequence):\n    componentType = namedtype.NamedTypes(\n        namedtype.NamedType('size', univ.Integer().subtype(subtypeSpec=constraint.ValueRangeConstraint(0, maxInt))),\n        namedtype.NamedType('cookie', univ.OctetString()),\n    )",
  "class SimplePagedResultsControl(Control):\n    def __init__(self, criticality=None, size=1000, cookie='', **kwargs):\n        Control.__init__(self, **kwargs)\n        self['controlType'] = CONTROL_PAGEDRESULTS\n        if criticality is not None:\n            self['criticality'] = criticality\n        self._size = size\n        self._cookie = cookie\n        self.encodeControlValue()\n\n    def encodeControlValue(self):\n        self['controlValue'] = encoder.encode(SimplePagedResultsControlValue().setComponents(self._size, self._cookie))\n\n    def decodeControlValue(self):\n        decodedControlValue, _ = decoder.decode(self['controlValue'], asn1Spec=SimplePagedResultsControlValue())\n        self._size, self._cookie = decodedControlValue[0], decodedControlValue[1]\n        return decodedControlValue\n\n    def getCriticality(self):\n        return self['criticality']\n\n    def setCriticality(self, value):\n        self['criticality'] = value\n\n    def getSize(self):\n        self.decodeControlValue()\n        return self._size\n\n    def setSize(self, value):\n        self._size = value\n        self.encodeControlValue()\n\n    def getCookie(self):\n        self.decodeControlValue()\n        return self._cookie\n\n    def setCookie(self, value):\n        self._cookie = value\n        self.encodeControlValue()",
  "class LDAPMessage(DefaultSequenceAndSetBaseMixin, univ.Sequence):\n    componentType = namedtype.NamedTypes(\n        namedtype.NamedType('messageID', MessageID()),\n        namedtype.NamedType('protocolOp', univ.Choice(componentType=namedtype.NamedTypes(\n            namedtype.NamedType('bindRequest', BindRequest()),\n            namedtype.NamedType('bindResponse', BindResponse()),\n            namedtype.NamedType('unbindRequest', UnbindRequest()),\n            namedtype.NamedType('searchRequest', SearchRequest()),\n            namedtype.NamedType('searchResEntry', SearchResultEntry()),\n            namedtype.NamedType('searchResDone', SearchResultDone()),\n            namedtype.NamedType('searchResRef', SearchResultReference()),\n            namedtype.NamedType('modifyRequest', ModifyRequest()),\n            namedtype.NamedType('modifyResponse', ModifyResponse()),\n            namedtype.NamedType('addRequest', AddRequest()),\n            namedtype.NamedType('addResponse', AddResponse()),\n            namedtype.NamedType('delRequest', DelRequest()),\n            namedtype.NamedType('delResponse', DelResponse()),\n            namedtype.NamedType('modDNRequest', ModifyDNRequest()),\n            namedtype.NamedType('modDNResponse', ModifyDNResponse()),\n            namedtype.NamedType('compareRequest', CompareRequest()),\n            namedtype.NamedType('compareResponse', CompareResponse()),\n            namedtype.NamedType('abandonRequest', AbandonRequest()),\n            namedtype.NamedType('extendedReq', ExtendedRequest()),\n            namedtype.NamedType('extendedResp', ExtendedResponse()),\n            namedtype.NamedType('intermediateResponse', IntermediateResponse())\n        ))),\n        namedtype.OptionalNamedType(\n            'controls',\n            Controls().subtype(implicitTag=tag.Tag(tag.tagClassContext, tag.tagFormatSimple, 0))\n        ),\n        # fix AD nonconforming to RFC4511\n        namedtype.OptionalNamedType(\n            'responseName',\n            LDAPOID().subtype(implicitTag=tag.Tag(tag.tagClassContext, tag.tagFormatSimple, 10))\n        ),\n        namedtype.OptionalNamedType(\n            'responseValue',\n            univ.OctetString().subtype(implicitTag=tag.Tag(tag.tagClassContext, tag.tagFormatSimple, 11))\n        )\n    )",
  "def getComponentByPosition(self, idx, default=univ.noValue, instantiate=True):\n        for cls in self.__class__.__bases__:\n            if cls is not DefaultSequenceAndSetBaseMixin:\n                try:\n                    component = cls.getComponentByPosition(self, idx)#, default, instantiate)\n                except AttributeError:\n                    continue\n                if component is None:\n                    return self.setComponentByPosition(idx).getComponentByPosition(idx)# , default, instantiate)\n                return component",
  "def setComponentByPosition(self, idx, value=univ.noValue,\n                               verifyConstraints=True,\n                               matchTags=True,\n                               matchConstraints=True):\n        if idx == 0:  # controlType\n            try:\n                cls = KNOWN_CONTROLS[value]\n                if self.__class__ is not cls:\n                    self.__class__ = cls\n            except KeyError:\n                pass\n        return univ.Sequence.setComponentByPosition(self, idx, value=value,\n                                                    verifyConstraints=verifyConstraints,\n                                                    matchTags=matchTags,\n                                                    matchConstraints=matchConstraints)",
  "def encodeControlValue(self):\n        pass",
  "def decodeControlValue(self):\n        return",
  "def prettyPrint(self, scope=0):\n        r = univ.Sequence.prettyPrint(self, scope)\n        decodedControlValue = self.decodeControlValue()\n        if decodedControlValue is not None:\n            r = r[:r.rindex('=') + 1] + '%s\\n' % decodedControlValue.prettyPrint(scope + 1)\n        return r",
  "def __init__(self, criticality=None, flags=0x00000007, **kwargs):\n        Control.__init__(self, **kwargs)\n        self['controlType'] = CONTROL_SDFLAGS\n        if criticality is not None:\n            self['criticality'] = criticality\n        self.flags = flags\n        self.encodeControlValue()",
  "def encodeControlValue(self):\n        self['controlValue'] = encoder.encode(\n            SDFlagsControlValue().setComponents(self.flags))",
  "def decodeControlValue(self):\n        decodedControlValue, _ = decoder.decode(self['controlValue'], asn1Spec=SDFlagsControlValue())\n        self._flags =  decodedControlValue[0]\n        return decodedControlValue",
  "def getCriticality(self):\n        return self['criticality']",
  "def setCriticality(self, value):\n        self['criticality'] = value",
  "def getFlags(self):\n        self.decodeControlValue()\n        return self._flags",
  "def setFlags(self, value):\n        self._flags = value\n        self.encodeControlValue()",
  "def __init__(self, criticality=None, size=1000, cookie='', **kwargs):\n        Control.__init__(self, **kwargs)\n        self['controlType'] = CONTROL_PAGEDRESULTS\n        if criticality is not None:\n            self['criticality'] = criticality\n        self._size = size\n        self._cookie = cookie\n        self.encodeControlValue()",
  "def encodeControlValue(self):\n        self['controlValue'] = encoder.encode(SimplePagedResultsControlValue().setComponents(self._size, self._cookie))",
  "def decodeControlValue(self):\n        decodedControlValue, _ = decoder.decode(self['controlValue'], asn1Spec=SimplePagedResultsControlValue())\n        self._size, self._cookie = decodedControlValue[0], decodedControlValue[1]\n        return decodedControlValue",
  "def getCriticality(self):\n        return self['criticality']",
  "def setCriticality(self, value):\n        self['criticality'] = value",
  "def getSize(self):\n        self.decodeControlValue()\n        return self._size",
  "def setSize(self, value):\n        self._size = value\n        self.encodeControlValue()",
  "def getCookie(self):\n        self.decodeControlValue()\n        return self._cookie",
  "def setCookie(self, value):\n        self._cookie = value\n        self.encodeControlValue()"
]