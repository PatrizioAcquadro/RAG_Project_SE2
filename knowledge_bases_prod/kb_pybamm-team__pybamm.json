[
  "def load_version():\n    try:\n        import os\n\n        root = os.path.abspath(os.path.dirname(__file__))\n        with open(os.path.join(root, \"pybamm\", \"version\"), \"r\") as f:\n            version = f.read().strip().split(\",\")\n        return \".\".join([str(int(x)) for x in version])\n    except Exception as e:\n        raise RuntimeError(\"Unable to read version number (\" + str(e) + \").\")",
  "def run_code_tests(executable=False, folder: str = \"unit\"):\n    \"\"\"\n    Runs tests, exits if they don't finish.\n    Parameters\n    ----------\n    executable : bool (default False)\n        If True, tests are run in subprocesses using the executable 'python'.\n        Must be True for travis tests (otherwise tests always 'pass')\n    folder : str\n        Which folder to run the tests from (unit, integration or both ('all'))\n    \"\"\"\n    if folder == \"all\":\n        tests = \"tests/\"\n    else:\n        tests = \"tests/\" + folder\n        if folder == \"unit\":\n            pybamm.settings.debug_mode = True\n    if executable is False:\n        suite = unittest.defaultTestLoader.discover(tests, pattern=\"test*.py\")\n        unittest.TextTestRunner(verbosity=2).run(suite)\n    else:\n        print(\"Running {} tests with executable 'python'\".format(folder))\n        cmd = [\"python\", \"-m\", \"unittest\", \"discover\", \"-v\", tests]\n        p = subprocess.Popen(cmd)\n        try:\n            ret = p.wait()\n        except KeyboardInterrupt:\n            try:\n                p.terminate()\n            except OSError:\n                pass\n            p.wait()\n            print(\"\")\n            sys.exit(1)\n        if ret != 0:\n            sys.exit(ret)",
  "def run_flake8():\n    \"\"\"\n    Runs flake8 in a subprocess, exits if it doesn't finish.\n    \"\"\"\n    print(\"Running flake8 ... \")\n    sys.stdout.flush()\n    p = subprocess.Popen([\"flake8\"], stderr=subprocess.PIPE)\n    try:\n        ret = p.wait()\n    except KeyboardInterrupt:\n        try:\n            p.terminate()\n        except OSError:\n            pass\n        p.wait()\n        print(\"\")\n        sys.exit(1)\n    if ret == 0:\n        print(\"ok\")\n    else:\n        print(\"FAILED\")\n        sys.exit(ret)",
  "def run_doc_tests():\n    \"\"\"\n    Checks if the documentation can be built, runs any doctests (currently not\n    used).\n    \"\"\"\n    print(\"Checking if docs can be built.\")\n    p = subprocess.Popen(\n        [\"sphinx-build\", \"-b\", \"doctest\", \"docs\", \"docs/build/html\", \"-W\"]\n    )\n    try:\n        ret = p.wait()\n    except KeyboardInterrupt:\n        try:\n            p.terminate()\n        except OSError:\n            pass\n        p.wait()\n        print(\"\")\n        sys.exit(1)\n    if ret != 0:\n        print(\"FAILED\")\n        sys.exit(ret)",
  "def run_notebook_and_scripts(skip_slow_books=False, executable=\"python\"):\n    \"\"\"\n    Runs Jupyter notebook tests. Exits if they fail.\n    \"\"\"\n    # Ignore slow books?\n    ignore_list = []\n    if skip_slow_books and os.path.isfile(\".slow-books\"):\n        with open(\".slow-books\", \"r\") as f:\n            for line in f.readlines():\n                line = line.strip()\n                if not line or line[:1] == \"#\":\n                    continue\n                if not line.startswith(\"examples/\"):\n                    line = \"examples/\" + line\n                if not line.endswith(\".ipynb\"):\n                    line = line + \".ipynb\"\n                if not os.path.isfile(line):\n                    raise Exception(\"Slow notebook note found: \" + line)\n                ignore_list.append(line)\n\n    # Scan and run\n    print(\"Testing notebooks and scripts with executable `\" + str(executable) + \"`\")\n    if not scan_for_nb_and_scripts(\"examples\", True, executable, ignore_list):\n        print(\"\\nErrors encountered in notebooks\")\n        sys.exit(1)\n    print(\"\\nOK\")",
  "def scan_for_nb_and_scripts(root, recursive=True, executable=\"python\", ignore_list=[]):\n    \"\"\"\n    Scans for, and tests, all notebooks and scripts in a directory.\n    \"\"\"\n    ok = True\n    debug = False\n\n    # Scan path\n    for filename in os.listdir(root):\n        path = os.path.join(root, filename)\n        if path in ignore_list:\n            print(\"Skipping slow book: \" + path)\n            continue\n\n        # Recurse into subdirectories\n        if recursive and os.path.isdir(path):\n            # Ignore hidden directories\n            if filename[:1] == \".\":\n                continue\n            ok &= scan_for_nb_and_scripts(path, recursive, executable)\n\n        # Test notebooks\n        if os.path.splitext(path)[1] == \".ipynb\":\n            if debug:\n                print(path)\n            else:\n                ok &= test_notebook(path, executable)\n        # Test scripts\n        elif os.path.splitext(path)[1] == \".py\":\n            if debug:\n                print(path)\n            else:\n                ok &= test_script(path, executable)\n\n    # Return True if every notebook is ok\n    return ok",
  "def test_notebook(path, executable=\"python\"):\n    \"\"\"\n    Tests a single notebook, exists if it doesn't finish.\n    \"\"\"\n    import nbconvert\n    import pybamm\n\n    b = pybamm.Timer()\n    print(\"Test \" + path + \" ... \", end=\"\")\n    sys.stdout.flush()\n\n    # Load notebook, convert to python\n    e = nbconvert.exporters.PythonExporter()\n    code, __ = e.from_filename(path)\n\n    # Remove coding statement, if present\n    code = \"\\n\".join([x for x in code.splitlines() if x[:9] != \"# coding\"])\n\n    # Tell matplotlib not to produce any figures\n    env = dict(os.environ)\n    env[\"MPLBACKEND\"] = \"Template\"\n\n    # Run in subprocess\n    cmd = [executable] + [\"-c\", code]\n    try:\n        p = subprocess.Popen(\n            cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, env=env\n        )\n        stdout, stderr = p.communicate()\n        # TODO: Use p.communicate(timeout=3600) if Python3 only\n        if p.returncode != 0:\n            # Show failing code, output and errors before returning\n            print(\"ERROR\")\n            print(\"-- script \" + \"-\" * (79 - 10))\n            for i, line in enumerate(code.splitlines()):\n                j = str(1 + i)\n                print(j + \" \" * (5 - len(j)) + line)\n            print(\"-- stdout \" + \"-\" * (79 - 10))\n            print(str(stdout, \"utf-8\"))\n            print(\"-- stderr \" + \"-\" * (79 - 10))\n            print(str(stderr, \"utf-8\"))\n            print(\"-\" * 79)\n            return False\n    except KeyboardInterrupt:\n        p.terminate()\n        print(\"ABORTED\")\n        sys.exit(1)\n\n    # Sucessfully run\n    print(\"ok (\" + b.format() + \")\")\n    return True",
  "def test_script(path, executable=\"python\"):\n    \"\"\"\n    Tests a single notebook, exists if it doesn't finish.\n    \"\"\"\n    import pybamm\n\n    b = pybamm.Timer()\n    print(\"Test \" + path + \" ... \", end=\"\")\n    sys.stdout.flush()\n\n    # Tell matplotlib not to produce any figures\n    env = dict(os.environ)\n    env[\"MPLBACKEND\"] = \"Template\"\n\n    # Run in subprocess\n    cmd = [executable] + [path]\n    try:\n        p = subprocess.Popen(\n            cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, env=env\n        )\n        stdout, stderr = p.communicate()\n        # TODO: Use p.communicate(timeout=3600) if Python3 only\n        if p.returncode != 0:\n            # Show failing code, output and errors before returning\n            print(\"ERROR\")\n            print(\"-- stdout \" + \"-\" * (79 - 10))\n            print(str(stdout, \"utf-8\"))\n            print(\"-- stderr \" + \"-\" * (79 - 10))\n            print(str(stderr, \"utf-8\"))\n            print(\"-\" * 79)\n            return False\n    except KeyboardInterrupt:\n        p.terminate()\n        print(\"ABORTED\")\n        sys.exit(1)\n\n    # Sucessfully run\n    print(\"ok (\" + b.format() + \")\")\n    return True",
  "def export_notebook(ipath, opath):\n    \"\"\"\n    Exports the notebook at `ipath` to a python file at `opath`.\n    \"\"\"\n    import nbconvert\n    from traitlets.config import Config\n\n    # Create nbconvert configuration to ignore text cells\n    c = Config()\n    c.TemplateExporter.exclude_markdown = True\n\n    # Load notebook, convert to python\n    e = nbconvert.exporters.PythonExporter(config=c)\n    code, __ = e.from_filename(ipath)\n\n    # Remove \"In [1]:\" comments\n    r = re.compile(r\"(\\s*)# In\\[([^]]*)\\]:(\\s)*\")\n    code = r.sub(\"\\n\\n\", code)\n\n    # Store as executable script file\n    with open(opath, \"w\") as f:\n        f.write(\"#!/usr/bin/env python\")\n        f.write(code)\n    os.chmod(opath, 0o775)",
  "def plot_voltages(all_variables, t_eval, linestyles=None, figsize=(6.4, 4.5)):\n    # Plot\n    linestyles = linestyles or [\"k-\", \"g--\", \"r:\", \"b-.\"]\n    n = int(len(all_variables) // np.sqrt(len(all_variables)))\n    m = int(np.ceil(len(all_variables) / n))\n    fig, axes = plt.subplots(n, m, figsize=figsize)\n    labels = [model for model in [x for x in all_variables.values()][0].keys()]\n    y_min = 0.98 * min(\n        np.nanmin(variables[\"Battery voltage [V]\"](t_eval))\n        for models_variables in all_variables.values()\n        for variables in models_variables.values()\n    )\n    y_max = 1.02 * max(\n        np.nanmax(variables[\"Battery voltage [V]\"](t_eval))\n        for models_variables in all_variables.values()\n        for variables in models_variables.values()\n    )\n    # Strict voltage cut-offs\n    y_min = max(y_min, 10.5)\n    y_max = min(y_max, 14.6)\n    for k, (Crate, models_variables) in enumerate(all_variables.items()):\n        if len(all_variables) == 1:\n            ax = axes\n        else:\n            ax = axes.flat[k]\n        t_max = max(\n            np.nanmax(var[\"Time [h]\"](t_eval)) for var in models_variables.values()\n        )\n        ax.set_xlim([0, t_max])\n        ax.set_ylim([y_min, y_max])\n        ax.set_xlabel(\"Time [h]\")\n        if len(all_variables) > 1:\n            ax.set_title(\n                \"\\\\textbf{{({})}} {}C ($\\\\mathcal{{C}}_e={}$)\".format(\n                    chr(97 + k), abs(Crate), abs(Crate) * 0.6\n                )\n            )\n            # # Hide the right and top spines\n            # ax.spines[\"right\"].set_visible(False)\n            # ax.spines[\"top\"].set_visible(False)\n            #\n            # # Only show ticks on the left and bottom spines\n            # ax.yaxis.set_ticks_position(\"left\")\n            # ax.xaxis.set_ticks_position(\"bottom\")\n        ax.xaxis.set_major_locator(plt.MaxNLocator(3))\n        if k % m == 0:\n            ax.set_ylabel(\"Voltage [V]\")\n        # else:\n        #     ax.set_yticklabels([])\n\n        for j, variables in enumerate(models_variables.values()):\n            ax.plot(\n                variables[\"Time [h]\"](t_eval),\n                variables[\"Battery voltage [V]\"](t_eval),\n                linestyles[j],\n            )\n    if len(all_variables) == 1:\n        leg = ax.legend(labels, loc=\"best\")\n        fig.tight_layout()\n    else:\n        leg = fig.legend(labels, loc=\"lower center\", ncol=len(labels))\n        plt.subplots_adjust(bottom=0.25, right=0.95, hspace=1.1, wspace=0.3)\n    leg.get_frame().set_edgecolor(\"k\")\n    return fig, axes",
  "def plot_variable(\n    all_variables,\n    times,\n    variable,\n    limits_exceptions=None,\n    yaxis=\"SOC\",\n    linestyles=None,\n    figsize=(6.4, 5),\n):\n    limits_exceptions = limits_exceptions or {}\n    linestyles = linestyles or [\"k-\", \"g--\", \"r:\", \"b-.\"]\n    n = len(times)\n    m = len(all_variables)\n    Crates = list(all_variables.keys())\n    labels = [model for model in [x for x in all_variables.values()][0].keys()]\n    x = all_variables[Crates[0]][labels[0]][\"x\"](0, np.linspace(0, 1))[:, 0]\n    x_dim = all_variables[Crates[0]][labels[0]][\"x [m]\"](0, np.linspace(0, 1))[:, 0]\n\n    fig, axes = plt.subplots(n, m, figsize=figsize)\n\n    # Default limits\n    y_min = pybamm.ax_min(\n        [\n            np.nanmin(variables[variable](times, x))\n            for Crate, models_variables in all_variables.items()\n            for variables in models_variables.values()\n        ]\n    )\n    y_max = pybamm.ax_max(\n        [\n            np.nanmax(variables[variable](times, x))\n            for Crate, models_variables in all_variables.items()\n            for variables in models_variables.values()\n        ]\n    )\n    # Exceptions\n    if \"min\" in limits_exceptions:\n        y_min = limits_exceptions[\"min\"]\n    if \"max\" in limits_exceptions:\n        y_max = limits_exceptions[\"max\"]\n\n    # Plot\n    for i, (Crate, models_variables) in enumerate(all_variables.items()):\n        for j, time in enumerate(times):\n            if len(times) == 1:\n                ax = axes[i]\n            else:\n                ax = axes[j, i]\n            ax.set_xlim([x_dim[0], x_dim[-1]])\n            ax.set_ylim([y_min, y_max])\n            ax.yaxis.set_major_locator(plt.MaxNLocator(3))\n\n            # Title\n            if j == 0:\n                ax.set_title(\n                    \"\\\\textbf{{({})}} {}C ($\\\\mathcal{{C}}_e={}$)\".format(\n                        chr(97 + i), abs(Crate), abs(Crate) * 0.6\n                    )\n                )\n            # x-axis\n            if j == len(times) - 1:\n                ax.set_xlabel(\"x [m]\")\n            else:\n                ax.set_xticklabels([])\n\n            # y-axis\n            if i == 0:\n                # If we only want to plot one time the y label is the variable\n                if len(times) == 1:\n                    ax.set_ylabel(variable)\n                # Otherwise the y label is the time\n                else:\n                    for variables in models_variables.values():\n                        try:\n                            if yaxis == \"SOC\":\n                                soc = variables[\"State of Charge\"](time)\n                                ax.set_ylabel(\n                                    \"{}\\% SoC\".format(int(soc)), rotation=0, labelpad=30\n                                )\n                            elif yaxis == \"FCI\":\n                                fci = variables[\"Fractional Charge Input\"](time)\n                                ax.set_ylabel(\n                                    \"{}\\% FCI\".format(int(fci)), rotation=0, labelpad=30\n                                )\n                            ax.yaxis.get_label().set_verticalalignment(\"center\")\n                        except ValueError:\n                            pass\n            else:\n                ax.set_yticklabels([])\n\n            # Plot\n            for j, variables in enumerate(models_variables.values()):\n                ax.plot(x_dim, variables[variable](time, x), linestyles[j])\n    leg = fig.legend(labels, loc=\"lower center\", ncol=len(labels), frameon=True)\n    leg.get_frame().set_edgecolor(\"k\")\n    plt.subplots_adjust(\n        bottom=0.17, top=0.95, left=0.18, right=0.97, hspace=0.08, wspace=0.05\n    )\n    return fig, axes",
  "def plot_time_dependent_variables(\n    all_variables, t_eval, output_vars, labels, colors=None, figsize=(6.4, 3.5)\n):\n    models = list(list(all_variables.values())[0].keys())\n    full_model = models[0]\n    fig, axes = plt.subplots(len(models) - 1, len(all_variables), figsize=figsize)\n    y_min = pybamm.ax_min(\n        [\n            np.nanmin(variables[var](t_eval))\n            for models_variables in all_variables.values()\n            for variables in models_variables.values()\n            for var in output_vars\n        ]\n    )\n    y_max = pybamm.ax_max(\n        [\n            np.nanmax(variables[var](t_eval))\n            for models_variables in all_variables.values()\n            for variables in models_variables.values()\n            for var in output_vars\n        ]\n    )\n    linestyles = [\"--\", \":\", \"-.\", \"-\"]\n    colors = colors or [\"k\", \"b\"]\n    for i, (Crate, models_variables) in enumerate(all_variables.items()):\n        for j, model in enumerate(models[1:]):\n            full_variables = models_variables[full_model]\n            variables = models_variables[model]\n            if len(models) == 2:\n                ax = axes[i]\n            else:\n                ax = axes[j, i]\n            t_max = max(\n                np.nanmax(var[\"Time [h]\"](t_eval)) for var in models_variables.values()\n            )\n            ax.set_xlim([0, t_max])\n            ax.set_ylim([y_min, y_max])\n            if i == 0:\n                if len(models) == 2:\n                    ax.set_ylabel(\"Interfacial current densities\")\n                else:\n                    ax.set_ylabel(\"{}\\nvs Full\".format(model), rotation=0, labelpad=30)\n                    ax.yaxis.get_label().set_verticalalignment(\"center\")\n            if j == 0 and len(all_variables) > 1:\n                ax.set_title(\n                    \"\\\\textbf{{({})}} {}C ($\\\\mathcal{{C}}_e={}$)\".format(\n                        chr(97 + i), abs(Crate), abs(Crate) * 0.6\n                    )\n                )\n            if j == len(models) - 2:\n                ax.set_xlabel(\"Time [h]\")\n            plots = {}\n            for k, var in enumerate(output_vars):\n                plots[(full_model, k)], = ax.plot(\n                    full_variables[\"Time [h]\"](t_eval),\n                    full_variables[var](t_eval),\n                    linestyle=linestyles[k],\n                    color=colors[0],\n                )\n            for k, var in enumerate(output_vars):\n                plots[(model, k)], = ax.plot(\n                    variables[\"Time [h]\"](t_eval),\n                    variables[var](t_eval),\n                    linestyle=linestyles[k],\n                    color=colors[j + 1],\n                )\n    if len(models) == 2:\n        leg1 = fig.legend(\n            [plots[(model, len(linestyles) - 1)] for model in models],\n            models,\n            loc=\"lower center\",\n            ncol=len(models),\n            bbox_to_anchor=(0.5, 0),\n        )\n        fig.legend(\n            labels, loc=\"lower center\", ncol=len(labels), bbox_to_anchor=(0.5, 0.1)\n        )\n        fig.add_artist(leg1)\n    else:\n        fig.legend(labels, loc=\"lower center\", ncol=len(labels))",
  "def plot_voltage_components(all_variables, t_eval, model, Crates):\n    n = int(len(Crates) // np.sqrt(len(Crates)))\n    m = int(np.ceil(len(Crates) / n))\n    fig, axes = plt.subplots(n, m, figsize=(6.4, 2.3))\n    labels = [\"V\", \"$V_U$\", \"$V_k$\", \"$V_c$\", \"$V_o$\"]\n    overpotentials = [\n        \"Average battery reaction overpotential [V]\",\n        \"Average battery concentration overpotential [V]\",\n        \"Average battery electrolyte ohmic losses [V]\",\n    ]\n    y_min = 0.95 * min(\n        np.nanmin(models_variables[model][\"Battery voltage [V]\"](t_eval))\n        for models_variables in all_variables.values()\n    )\n    y_max = 1.05 * max(\n        np.nanmax(models_variables[model][\"Battery voltage [V]\"](t_eval))\n        for models_variables in all_variables.values()\n    )\n    for k, Crate in enumerate(Crates):\n        variables = all_variables[Crate][model]\n        ax = axes.flat[k]\n\n        # Set up\n        t_max = np.nanmax(variables[\"Time [h]\"](t_eval))\n        ax.set_xlim([0, t_max])\n        ax.set_ylim([y_min, y_max])\n        ax.set_xlabel(\"Time [h]\")\n        ax.set_title(\n            \"\\\\textbf{{({})}} {}C ($\\\\mathcal{{C}}_e={}$)\".format(\n                chr(97 + k), abs(Crate), abs(Crate) * 0.6\n            )\n        )\n        ax.xaxis.set_major_locator(plt.MaxNLocator(3))\n        if k % m == 0:\n            ax.set_ylabel(\"Voltage [V]\")\n\n        # Plot\n        # Initialise\n        # for lead-acid we multiply everything by 6 to\n        time = variables[\"Time [h]\"](t_eval)\n        initial_ocv = variables[\"Average battery open circuit voltage [V]\"](0)\n        ocv = variables[\"Average battery open circuit voltage [V]\"](t_eval)\n        ax.fill_between(time, ocv, initial_ocv)\n        top = ocv\n        # Plot\n        for overpotential in overpotentials:\n            bottom = top + variables[overpotential](t_eval)\n            ax.fill_between(time, bottom, top)\n            top = bottom\n        ax.plot(time, variables[\"Battery voltage [V]\"](t_eval), \"k--\")\n    leg = axes.flat[-1].legend(\n        labels, bbox_to_anchor=(1.05, 0.5), loc=\"center left\", frameon=True\n    )\n    leg.get_frame().set_edgecolor(\"k\")\n    fig.tight_layout()",
  "def plot_times(models_times_and_voltages, Crate=1, linestyles=None):\n    linestyles = linestyles or [\"k-\", \"g--\", \"r:\", \"b-.\"]\n    all_npts = defaultdict(list)\n    solver_times = defaultdict(list)\n    fig, ax = plt.subplots(1, 1)\n    for i, (model, times_and_voltages) in enumerate(models_times_and_voltages.items()):\n        for npts in times_and_voltages.keys():\n            try:\n                solver_time = times_and_voltages[npts][Crate][\n                    \"solution object\"\n                ].solve_time\n            except KeyError:\n                continue\n            all_npts[model].append(npts * 3)\n            solver_times[model].append(solver_time)\n        ax.loglog(all_npts[model], solver_times[model], linestyles[i], label=model)\n    ax.set_xlabel(\"Number of grid points\")\n    ax.set_ylabel(\"Solver time [s]\")\n    ax.legend(loc=\"best\")\n    fig.tight_layout()",
  "def plot_voltages(all_variables, t_eval):\n    Crates = [0.1, 0.2, 0.5, 1, 2, 5]\n    all_variables = {k: v for k, v in all_variables.items() if k in Crates}\n    shared_plotting.plot_voltages(all_variables, t_eval)\n    file_name = \"discharge_voltage_comparison.eps\"\n    if OUTPUT_DIR is not None:\n        plt.savefig(OUTPUT_DIR + file_name, format=\"eps\", dpi=1000)",
  "def plot_variables(all_variables, t_eval):\n    # Set up\n    Crates = [0.1, 1, 4]\n    times = np.array([0, 0.195, 0.375, 0.545])\n    var_file_names = {\n        \"Electrolyte concentration [Molar]\"\n        + \"\": \"discharge_electrolyte_concentration_comparison.eps\",\n        \"Electrolyte potential [V]\": \"discharge_electrolyte_potential_comparison.eps\",\n        \"Interfacial current density\"\n        + \"\": \"discharge_interfacial_current_density_comparison.eps\",\n    }\n    limits_exceptions = {\"Electrolyte concentration [Molar]\": {\"min\": 0}}\n    all_variables = {k: v for k, v in all_variables.items() if k in Crates}\n    for var, file_name in var_file_names.items():\n        if var in limits_exceptions:\n            exceptions = limits_exceptions[var]\n        else:\n            exceptions = {}\n        shared_plotting.plot_variable(all_variables, times, var, exceptions)\n        if OUTPUT_DIR is not None:\n            plt.savefig(OUTPUT_DIR + file_name, format=\"eps\", dpi=1000)",
  "def plot_voltage_components(all_variables, t_eval):\n    Crates = [0.1, 2, 5]\n    model = \"Composite\"\n    shared_plotting.plot_voltage_components(all_variables, t_eval, model, Crates)\n    file_name = \"discharge_voltage_components.eps\"\n    if OUTPUT_DIR is not None:\n        plt.savefig(OUTPUT_DIR + file_name, format=\"eps\", dpi=1000)",
  "def discharge_states(compute):\n    savefile = \"discharge_asymptotics_data.pickle\"\n    if compute:\n        models = [\n            pybamm.lead_acid.Full(name=\"Full\"),\n            pybamm.lead_acid.LOQS(name=\"LOQS\"),\n            pybamm.lead_acid.FOQS(name=\"FOQS\"),\n            pybamm.lead_acid.Composite(name=\"Composite\"),\n        ]\n        Crates = [0.1, 0.2, 0.5, 1, 2, 4, 5, 10, 20]\n        t_eval = np.linspace(0, 1, 100)\n        extra_parameter_values = {\"Bruggeman coefficient\": 0.001}\n        all_variables, t_eval = model_comparison(\n            models, Crates, t_eval, extra_parameter_values=extra_parameter_values\n        )\n        with open(savefile, \"wb\") as f:\n            data = (all_variables, t_eval)\n            pickle.dump(data, f, pickle.HIGHEST_PROTOCOL)\n    else:\n        try:\n            with open(savefile, \"rb\") as f:\n                (all_variables, t_eval) = pickle.load(f)\n        except FileNotFoundError:\n            raise FileNotFoundError(\n                \"Run script with '--compute' first to generate results\"\n            )\n    plot_voltages(all_variables, t_eval)\n    plot_variables(all_variables, t_eval)\n    plot_voltage_components(all_variables, t_eval)",
  "def plot_errors(models_times_and_voltages):\n    npts = 20\n    linestyles = [\"k-\", \"g--\", \"r:\", \"b-.\"]\n    Crates = defaultdict(list)\n    voltage_errors = defaultdict(list)\n    fig, ax = plt.subplots(1, 1)\n    for i, (model, times_and_voltages) in enumerate(models_times_and_voltages.items()):\n        if model != \"Full\":\n            for Crate, variables in times_and_voltages[npts].items():\n                Crates[model].append(Crate)\n                full_voltage = models_times_and_voltages[\"Full\"][npts][Crate][\n                    \"Battery voltage [V]\"\n                ]\n                reduced_voltage = variables[\"Battery voltage [V]\"]\n                voltage_errors[model].append(pybamm.rmse(full_voltage, reduced_voltage))\n            ax.semilogx(\n                Crates[model], voltage_errors[model], linestyles[i], label=model\n            )\n    ax.set_xlabel(\"C-rate\")\n    ax.set_ylabel(\"RMSE [V]\")\n    ax.legend(loc=\"best\")\n    fig.tight_layout()\n    file_name = \"discharge_asymptotics_rmse.eps\"\n    if OUTPUT_DIR is not None:\n        plt.savefig(OUTPUT_DIR + file_name, format=\"eps\", dpi=1000)",
  "def plot_times(models_times_and_voltages):\n    shared_plotting.plot_times(models_times_and_voltages, Crate=1)\n    file_name = \"discharge_asymptotics_solver_times.eps\"\n    if OUTPUT_DIR is not None:\n        plt.savefig(OUTPUT_DIR + file_name, format=\"eps\", dpi=1000)",
  "def discharge_times_and_errors(compute):\n    savefile = \"discharge_asymptotics_times_and_errors.pickle\"\n    if compute:\n        try:\n            with open(savefile, \"rb\") as f:\n                models_times_and_voltages = pickle.load(f)\n        except FileNotFoundError:\n            models_times_and_voltages = pybamm.get_infinite_nested_dict()\n        models = [\n            pybamm.lead_acid.Full(\n                {\"surface form\": \"algebraic\"}, name=\"Full\"\n            ),\n            pybamm.lead_acid.LOQS(name=\"LOQS\"),\n            # pybamm.lead_acid.FOQS(name=\"FOQS\"),\n            # pybamm.lead_acid.Composite(name=\"Composite\"),\n        ]\n        Crates = np.linspace(0.01, 5, 2)\n        all_npts = [20]\n        t_eval = np.linspace(0, 1, 100)\n        new_models_times_and_voltages = convergence_study(\n            models, Crates, all_npts, t_eval\n        )\n        models_times_and_voltages.update(new_models_times_and_voltages)\n        with open(savefile, \"wb\") as f:\n            pickle.dump(models_times_and_voltages, f, pickle.HIGHEST_PROTOCOL)\n    else:\n        try:\n            with open(savefile, \"rb\") as f:\n                models_times_and_voltages = pickle.load(f)\n        except FileNotFoundError:\n            raise FileNotFoundError(\n                \"Run script with '--compute' first to generate results\"\n            )\n    plot_errors(models_times_and_voltages)\n    plot_times(models_times_and_voltages)",
  "def plot_voltages(all_variables, t_eval, bigger_beta=False):\n    linestyles = [\"k-\", \"b--\"]\n    shared_plotting.plot_voltages(all_variables, t_eval, linestyles, figsize=(6.4, 2.5))\n    if bigger_beta:\n        file_name = \"convection_voltage_comparison_bigger_beta.eps\"\n    else:\n        file_name = \"convection_voltage_comparison.eps\"\n    plt.subplots_adjust(bottom=0.4)\n    if OUTPUT_DIR is not None:\n        plt.savefig(OUTPUT_DIR + file_name, format=\"eps\", dpi=1000)",
  "def plot_variables(all_variables, t_eval, bigger_beta=False):\n    # Set up\n    times = np.array([0.195])\n    linestyles = [\"k-\", \"b--\"]\n    if bigger_beta:\n        var_file_names = {\n            \"Volume-averaged velocity [m.s-1]\"\n            + \"\": \"convection_velocity_comparison_bigger_beta.eps\",\n            \"Electrolyte concentration [Molar]\"\n            + \"\": \"convection_electrolyte_concentration_comparison_bigger_beta.eps\",\n        }\n    else:\n        var_file_names = {\n            \"Volume-averaged velocity [m.s-1]\": \"convection_velocity_comparison.eps\",\n            \"Electrolyte concentration [Molar]\"\n            + \"\": \"convection_electrolyte_concentration_comparison.eps\",\n        }\n    for var, file_name in var_file_names.items():\n        fig, axes = shared_plotting.plot_variable(\n            all_variables, times, var, linestyles=linestyles, figsize=(6.4, 3)\n        )\n        for ax in axes.flat:\n            title = ax.get_title()\n            ax.set_title(title, y=1.08)\n        plt.subplots_adjust(\n            bottom=0.3, top=0.85, left=0.1, right=0.9, hspace=0.08, wspace=0.05\n        )\n        if OUTPUT_DIR is not None:\n            plt.savefig(OUTPUT_DIR + file_name, format=\"eps\", dpi=1000)",
  "def charge_states(compute):\n    savefile = \"effect_of_convection_data.pickle\"\n    if compute:\n        models = [\n            pybamm.lead_acid.Full(\n                {\"convection\": True}, name=\"With convection\"\n            ),\n            pybamm.lead_acid.Full(name=\"Without convection\"),\n        ]\n        Crates = [0.5, 1, 5]\n        t_eval = np.linspace(0, 1, 100)\n        all_variables, t_eval = model_comparison(models, Crates, t_eval)\n        with open(savefile, \"wb\") as f:\n            data = (all_variables, t_eval)\n            pickle.dump(data, f, pickle.HIGHEST_PROTOCOL)\n    else:\n        try:\n            with open(savefile, \"rb\") as f:\n                (all_variables, t_eval) = pickle.load(f)\n        except FileNotFoundError:\n            raise FileNotFoundError(\n                \"Run script with '--compute' first to generate results\"\n            )\n    plot_voltages(all_variables, t_eval)\n    plot_variables(all_variables, t_eval)",
  "def charge_states_bigger_volume_change(compute):\n    savefile = \"effect_of_convection_bigger_beta_data.pickle\"\n    if compute:\n        models = [\n            pybamm.lead_acid.Full(\n                {\"convection\": True}, name=\"With convection\"\n            ),\n            pybamm.lead_acid.Full(name=\"Without convection\"),\n        ]\n        Crates = [0.5, 1, 5]\n        t_eval = np.linspace(0, 1, 100)\n        extra_parameter_values = {\"Volume change factor\": 10}\n        all_variables, t_eval = model_comparison(\n            models, Crates, t_eval, extra_parameter_values=extra_parameter_values\n        )\n        with open(savefile, \"wb\") as f:\n            data = (all_variables, t_eval)\n            pickle.dump(data, f, pickle.HIGHEST_PROTOCOL)\n    else:\n        try:\n            with open(savefile, \"rb\") as f:\n                (all_variables, t_eval) = pickle.load(f)\n        except FileNotFoundError:\n            raise FileNotFoundError(\n                \"Run script with '--compute' first to generate results\"\n            )\n    plot_voltages(all_variables, t_eval, bigger_beta=True)\n    plot_variables(all_variables, t_eval, bigger_beta=True)",
  "def plot_voltages(all_variables, t_eval):\n    linestyles = [\"k-\", \"b--\"]\n    shared_plotting.plot_voltages(all_variables, t_eval, linestyles, figsize=(6.4, 2.5))\n    file_name = \"side_reactions_voltage_comparison.eps\"\n    plt.subplots_adjust(bottom=0.4)\n    if OUTPUT_DIR is not None:\n        plt.savefig(OUTPUT_DIR + file_name, format=\"eps\", dpi=1000)",
  "def plot_interfacial_currents(all_variables, t_eval):\n    file_name = \"side_reactions_interfacial_current_density_comparison.eps\"\n    output_vars = [\n        \"Average positive electrode interfacial current density\",\n        \"Average positive electrode oxygen interfacial current density\",\n        \"Average negative electrode oxygen interfacial current density\",\n        \"Average negative electrode interfacial current density\",\n    ]\n    labels = [\n        \"Pos electrode\\n(main)\",\n        \"Pos electrode\\n(oxygen)\",\n        \"Neg electrode\\n(oxygen)\",\n        \"Neg electrode\\n(main)\",\n    ]\n    shared_plotting.plot_time_dependent_variables(\n        all_variables, t_eval, output_vars, labels\n    )\n    plt.subplots_adjust(bottom=0.4, right=0.95, wspace=0.3)\n    if OUTPUT_DIR is not None:\n        plt.savefig(OUTPUT_DIR + file_name, format=\"eps\", dpi=1000)",
  "def charge_states(compute):\n    savefile1 = \"effect_of_side_reactions_data.pickle\"\n    savefile2 = \"effect_of_side_reactions_loqs_data.pickle\"\n    if compute:\n        models1 = [\n            pybamm.lead_acid.Full(\n                {\"surface form\": \"algebraic\", \"side reactions\": [\"oxygen\"]},\n                name=\"With oxygen\",\n            ),\n            pybamm.lead_acid.Full(\n                {\"surface form\": \"algebraic\"}, name=\"Without oxygen\"\n            ),\n        ]\n        Crates = [-0.1, -1, -5]\n        t_eval = np.linspace(0, 5, 100)\n        extra_parameter_values = {\n            \"Positive electrode\"\n            + \"reference exchange-current density (oxygen) [A.m-2]\": 1e-24,\n            \"Initial State of Charge\": 0.5,\n        }\n        all_variables1, t_eval1 = model_comparison(\n            models1, Crates, t_eval, extra_parameter_values=extra_parameter_values\n        )\n        # Use LOQS without voltage cut-off for interfacial current densities, so that\n        # the current goes all the way\n        models2 = [\n            pybamm.lead_acid.Full(\n                {\"surface form\": \"algebraic\", \"side reactions\": [\"oxygen\"]},\n                name=\"With oxygen\",\n            ),\n            pybamm.lead_acid.LOQS({\"surface form\": \"algebraic\"}, name=\"Without oxygen\"),\n        ]\n        extra_parameter_values[\"Upper voltage cut-off [V]\"] = 100\n        all_variables2, t_eval2 = model_comparison(\n            models2, Crates, t_eval, extra_parameter_values=extra_parameter_values\n        )\n        with open(savefile1, \"wb\") as f:\n            data1 = (all_variables1, t_eval1)\n            pickle.dump(data1, f, pickle.HIGHEST_PROTOCOL)\n        with open(savefile2, \"wb\") as f:\n            data2 = (all_variables2, t_eval2)\n            pickle.dump(data2, f, pickle.HIGHEST_PROTOCOL)\n    else:\n        try:\n            with open(savefile1, \"rb\") as f:\n                (all_variables1, t_eval1) = pickle.load(f)\n            with open(savefile2, \"rb\") as f:\n                (all_variables2, t_eval2) = pickle.load(f)\n        except FileNotFoundError:\n            raise FileNotFoundError(\n                \"Run script with '--compute' first to generate results\"\n            )\n    plot_voltages(all_variables1, t_eval1)\n    plot_interfacial_currents(all_variables2, t_eval2)",
  "def plot_voltages(all_variables, t_eval):\n    shared_plotting.plot_voltages(all_variables, t_eval)\n    file_name = \"sefl_discharge_voltage_comparison.eps\"\n    if OUTPUT_DIR is not None:\n        plt.savefig(OUTPUT_DIR + file_name, format=\"eps\", dpi=1000)",
  "def self_discharge_states(compute):\n    save_file = \"self_discharge_data.pickle\"\n    if compute:\n        models = [\n            pybamm.lead_acid.Full(name=\"Full, without oxygen\"),\n            pybamm.lead_acid.Full(\n                {\"side reactions\": [\"oxygen\"]}, name=\"Full, with oxygen\"\n            ),\n            pybamm.lead_acid.LOQS(\n                {\"surface form\": \"algebraic\", \"side reactions\": [\"oxygen\"]},\n                name=\"LOQS, with oxygen\",\n            ),\n        ]\n        extra_parameter_values = {\n            \"Current function\": pybamm.GetConstantCurrent(current=0)\n        }\n        t_eval = np.linspace(0, 1000, 100)\n        all_variables, t_eval = model_comparison(\n            models, [1], t_eval, extra_parameter_values=extra_parameter_values\n        )\n        with open(save_file, \"wb\") as f:\n            data = (all_variables, t_eval)\n            pickle.dump(data, f, pickle.HIGHEST_PROTOCOL)\n    else:\n        try:\n            with open(save_file, \"rb\") as f:\n                (all_variables, t_eval) = pickle.load(f)\n        except FileNotFoundError:\n            raise FileNotFoundError(\n                \"Run script with '--compute' first to generate results\"\n            )\n    plot_voltages(all_variables, t_eval)",
  "def plot_voltages(all_variables, t_eval):\n    linestyles = [\"k-\", \"b-.\", \"r--\"]\n    _, axes = shared_plotting.plot_voltages(\n        all_variables, t_eval, linestyles=linestyles, figsize=(6.4, 4)\n    )\n\n    # Add inset plot\n    for k, (Crate, models_variables) in enumerate(all_variables.items()):\n        ax = axes.flat[k]\n        y_min = ax.get_ylim()[0]\n        ax.set_ylim([y_min, 13.6])\n        inset = inset_axes(ax, width=\"40%\", height=\"30%\", loc=1, borderpad=0)\n        for j, variables in enumerate(models_variables.values()):\n            time = variables[\"Time [s]\"](t_eval)\n            capacitance_indices = np.where(time < 50)\n            time = time[capacitance_indices]\n            voltage = variables[\"Battery voltage [V]\"](t_eval)[capacitance_indices]\n            inset.plot(time, voltage, linestyles[j])\n            inset.set_xlabel(\"Time [s]\", fontsize=9)\n            inset.set_xlim([0, 3])\n            inset.tick_params(axis=\"both\", which=\"major\", labelsize=9)\n\n    file_name = \"capacitance_voltage_comparison.eps\"\n    if OUTPUT_DIR is not None:\n        plt.savefig(OUTPUT_DIR + file_name, format=\"eps\", dpi=1000)",
  "def plot_errors(all_variables, t_eval, Crates):\n    # Linestyles\n    linestyles = [\"k-\", \"b-.\", \"r--\"]\n    # Only use some Crates\n    all_variables = {k: v for k, v in all_variables.items() if k in Crates}\n    # Plot\n    fig, ax = plt.subplots(1, 1, figsize=(6.4, 4))\n    for k, (Crate, models_variables) in enumerate(all_variables.items()):\n        ax.set_xlabel(\"Time [h]\")\n        ax.set_ylabel(\"Error [V]\")\n\n        for j, (model, variables) in enumerate(models_variables.items()):\n            if model == \"direct form\":\n                base_model_results = models_variables[model]\n                continue\n            error = np.abs(\n                variables[\"Battery voltage [V]\"](t_eval)\n                - base_model_results[\"Battery voltage [V]\"](t_eval)\n            )\n            ax.loglog(variables[\"Time [h]\"](t_eval), error, linestyles[j], label=model)\n        ax.legend(loc=\"upper right\")\n    fig.tight_layout()\n    file_name = \"capacitance_errors_voltages.eps\".format(Crate)\n    if OUTPUT_DIR is not None:\n        plt.savefig(OUTPUT_DIR + file_name, format=\"eps\", dpi=1000)",
  "def discharge_states(compute):\n    savefile = \"effect_of_capacitance_data.pickle\"\n    if compute:\n        models = [\n            pybamm.lead_acid.Full(name=\"direct form\"),\n            pybamm.lead_acid.Full(\n                {\"surface form\": \"differential\"},\n                name=\"capacitance form\\n(differential)\",\n            ),\n            pybamm.lead_acid.Full(\n                {\"surface form\": \"algebraic\"}, name=\"capacitance form\\n(algebraic)\"\n            ),\n        ]\n        Crates = [0.1, 1, 5]\n        t_eval = np.concatenate(\n            [np.logspace(-6, -3, 50), np.linspace(0.001, 1, 100)[1:]]\n        )\n        all_variables, t_eval = model_comparison(models, Crates, t_eval)\n        with open(savefile, \"wb\") as f:\n            data = (all_variables, t_eval)\n            pickle.dump(data, f, pickle.HIGHEST_PROTOCOL)\n    else:\n        try:\n            with open(savefile, \"rb\") as f:\n                (all_variables, t_eval) = pickle.load(f)\n        except FileNotFoundError:\n            raise FileNotFoundError(\n                \"Run script with '--compute' first to generate results\"\n            )\n    plot_voltages(all_variables, t_eval)\n    plot_errors(all_variables, t_eval, [5])",
  "def plot_times(models_times_and_voltages):\n    shared_plotting.plot_times(\n        models_times_and_voltages, Crate=1, linestyles=[\"k-\", \"b-.\", \"r--\"]\n    )\n    file_name = \"capacitance_solver_times.eps\"\n    if OUTPUT_DIR is not None:\n        plt.savefig(OUTPUT_DIR + file_name, format=\"eps\", dpi=1000)",
  "def discharge_times_and_errors(compute):\n    savefile = \"capacitance_times_and_errors.pickle\"\n    if compute:\n        try:\n            with open(savefile, \"rb\") as f:\n                models_times_and_voltages = pickle.load(f)\n        except FileNotFoundError:\n            models_times_and_voltages = pybamm.get_infinite_nested_dict()\n        models = [\n            pybamm.lead_acid.Full(name=\"direct form\"),\n            pybamm.lead_acid.Full(\n                {\"surface form\": \"differential\"},\n                name=\"capacitance form\\n(differential)\",\n            ),\n            pybamm.lead_acid.Full(\n                {\"surface form\": \"algebraic\"}, name=\"capacitance form\\n(algebraic)\"\n            ),\n        ]\n        Crates = [1]\n        all_npts = np.linspace(10, 100, 2)\n        t_eval = np.linspace(0, 1, 100)\n        new_models_times_and_voltages = convergence_study(\n            models, Crates, all_npts, t_eval\n        )\n        models_times_and_voltages.update(new_models_times_and_voltages)\n        with open(savefile, \"wb\") as f:\n            pickle.dump(models_times_and_voltages, f, pickle.HIGHEST_PROTOCOL)\n    else:\n        try:\n            with open(savefile, \"rb\") as f:\n                models_times_and_voltages = pickle.load(f)\n        except FileNotFoundError:\n            raise FileNotFoundError(\n                \"Run script with '--compute' first to generate results\"\n            )\n    plot_errors(models_times_and_voltages)",
  "def plot_voltages(all_variables, t_eval):\n    Crates = [-0.1, -0.2, -0.5, -1, -2, -5]\n    all_variables = {k: v for k, v in all_variables.items() if k in Crates}\n    shared_plotting.plot_voltages(all_variables, t_eval)\n    file_name = \"charge_voltage_comparison.eps\"\n    if OUTPUT_DIR is not None:\n        plt.savefig(OUTPUT_DIR + file_name, format=\"eps\", dpi=1000)",
  "def plot_interfacial_currents(all_variables, t_eval):\n    Crates = [-0.1, -2, -5]\n    all_variables = {Crate: v for Crate, v in all_variables.items() if Crate in Crates}\n    file_name = \"charge_interfacial_current_density_comparison.eps\"\n    output_vars = [\n        \"Average positive electrode interfacial current density\",\n        \"Average positive electrode oxygen interfacial current density\",\n        \"Average negative electrode oxygen interfacial current density\",\n        \"Average negative electrode interfacial current density\",\n    ]\n    labels = [\n        \"Pos electrode\\n(main)\",\n        \"Pos electrode\\n(oxygen)\",\n        \"Neg electrode\\n(oxygen)\",\n        \"Neg electrode\\n(main)\",\n    ]\n    shared_plotting.plot_time_dependent_variables(\n        all_variables,\n        t_eval,\n        output_vars,\n        labels,\n        colors=[\"k\", \"g\", \"r\", \"b\"],\n        figsize=(6.4, 6.4),\n    )\n    plt.subplots_adjust(\n        bottom=0.15, left=0.15, right=0.95, wspace=0.3, hspace=0.4, top=0.95\n    )\n    if OUTPUT_DIR is not None:\n        plt.savefig(OUTPUT_DIR + file_name, format=\"eps\", dpi=1000)",
  "def plot_variables(all_variables, t_eval):\n    # Set up\n    Crates = [-0.1, -2, -5]\n    times = np.linspace(0, 2, 4)\n    var_file_names = {\n        \"Electrolyte concentration [Molar]\"\n        + \"\": \"charge_electrolyte_concentration_comparison.eps\",\n        \"Oxygen concentration [Molar]\": \"charge_oxygen_concentration_comparison.eps\",\n    }\n    limits_exceptions = {\"Electrolyte concentration [Molar]\": {\"min\": 0}}\n    all_variables = {k: v for k, v in all_variables.items() if k in Crates}\n    for var, file_name in var_file_names.items():\n        if var in limits_exceptions:\n            exceptions = limits_exceptions[var]\n        else:\n            exceptions = {}\n        shared_plotting.plot_variable(\n            all_variables, times, var, exceptions, yaxis=\"FCI\"\n        )\n        if OUTPUT_DIR is not None:\n            plt.savefig(OUTPUT_DIR + file_name, format=\"eps\", dpi=1000)",
  "def plot_voltage_components(all_variables, t_eval):\n    Crates = [-0.1, -2, -5]\n    model = \"Composite\"\n    shared_plotting.plot_voltage_components(all_variables, t_eval, model, Crates)\n    file_name = \"charge_voltage_components.eps\"\n    if OUTPUT_DIR is not None:\n        plt.savefig(OUTPUT_DIR + file_name, format=\"eps\", dpi=1000)",
  "def charge_states(compute):\n    if compute:\n        models = [\n            pybamm.lead_acid.Full(\n                {\"side reactions\": [\"oxygen\"]}, name=\"Full\"\n            ),\n            pybamm.lead_acid.LOQS(\n                {\"surface form\": \"algebraic\", \"side reactions\": [\"oxygen\"]}, name=\"LOQS\"\n            ),\n            pybamm.lead_acid.FOQS(\n                {\"surface form\": \"algebraic\", \"side reactions\": [\"oxygen\"]}, name=\"FOQS\"\n            ),\n            # pybamm.lead_acid.Composite(\n            #     {\"surface form\": \"algebraic\", \"side reactions\": [\"oxygen\"]},\n            #     name=\"Composite\",\n            # ),\n            pybamm.lead_acid.CompositeExtended(\n                {\"surface form\": \"algebraic\", \"side reactions\": [\"oxygen\"]},\n                name=\"Composite\",\n            ),\n        ]\n        Crates = [-0.1, -0.2, -0.5, -1, -2, -5]\n        t_eval = np.linspace(0, 3, 100)\n        extra_parameter_values = {\n            \"Positive electrode\"\n            + \"reference exchange-current density (oxygen) [A.m-2]\": 1e-24,\n            \"Initial State of Charge\": 0.5,\n        }\n        all_variables, t_eval = model_comparison(\n            models, Crates, t_eval, extra_parameter_values=extra_parameter_values\n        )\n        with open(\"charge_asymptotics_data.pickle\", \"wb\") as f:\n            data = (all_variables, t_eval)\n            pickle.dump(data, f, pickle.HIGHEST_PROTOCOL)\n    else:\n        try:\n            with open(\"charge_asymptotics_data.pickle\", \"rb\") as f:\n                (all_variables, t_eval) = pickle.load(f)\n        except FileNotFoundError:\n            raise FileNotFoundError(\n                \"Run script with '--compute' first to generate results\"\n            )\n    plot_voltages(all_variables, t_eval)\n    plot_interfacial_currents(all_variables, t_eval)\n    plot_variables(all_variables, t_eval)\n    plot_voltage_components(all_variables, t_eval)",
  "def model_comparison(models, Crates, t_eval, extra_parameter_values=None):\n    \" Solve models at a range of Crates \"\n    # load parameter values and geometry\n    geometry = models[0].default_geometry\n    extra_parameter_values = extra_parameter_values or {}\n    param = models[0].default_parameter_values\n    param.update(extra_parameter_values)\n\n    # Process parameters (same parameters for all models)\n    for model in models:\n        param.process_model(model)\n    param.process_geometry(geometry)\n\n    # set mesh\n    var = pybamm.standard_spatial_vars\n    var_pts = {var.x_n: 20, var.x_s: 20, var.x_p: 20}\n    mesh = pybamm.Mesh(geometry, models[-1].default_submesh_types, var_pts)\n\n    # discretise models\n    discs = {}\n    for model in models:\n        disc = pybamm.Discretisation(mesh, model.default_spatial_methods)\n        disc.process_model(model)\n        # Store discretisation\n        discs[model] = disc\n\n    # solve model for range of Crates\n    all_variables = {}\n    for Crate in Crates:\n        all_variables[Crate] = {}\n        current = Crate * 17\n        pybamm.logger.info(\"Setting typical current to {} A\".format(current))\n        param.update({\"Typical current [A]\": current})\n        for model in models:\n            param.update_model(model, discs[model])\n            solution = model.default_solver.solve(model, t_eval)\n            variables = pybamm.post_process_variables(\n                model.variables, solution.t, solution.y, mesh\n            )\n            variables[\"solution\"] = solution\n            all_variables[Crate][model.name] = variables\n\n    return all_variables, t_eval",
  "def convergence_study(models, Crates, all_npts, t_eval, extra_parameter_values=None):\n    \" Solve models at a range of number of grid points \"\n    # load parameter values and geometry\n    geometry = models[0].default_geometry\n    param = models[0].default_parameter_values\n    # Update parameters\n    extra_parameter_values = extra_parameter_values or {}\n    param.update(extra_parameter_values)\n\n    # Process parameters (same parameters for all models)\n    for model in models:\n        param.process_model(model)\n    param.process_geometry(geometry)\n\n    # set mesh\n    var = pybamm.standard_spatial_vars\n\n    # solve model for range of Crates and npts\n    models_times_and_voltages = {model.name: {} for model in models}\n    for npts in all_npts:\n        pybamm.logger.info(\"Setting number of grid points to {}\".format(npts))\n        var_pts = {var.x_n: npts, var.x_s: npts, var.x_p: npts}\n        mesh = pybamm.Mesh(geometry, models[-1].default_submesh_types, var_pts)\n\n        # discretise models, store discretised model and discretisation\n        models_disc = {}\n        discs = {}\n        for model in models:\n            disc = pybamm.Discretisation(mesh, model.default_spatial_methods)\n            models_times_and_voltages[model.name][npts] = {}\n            models_disc[model.name] = disc.process_model(model, inplace=False)\n            discs[model.name] = disc\n\n        # Solve for a range of C-rates\n        for Crate in Crates:\n            current = Crate * 17\n            pybamm.logger.info(\"Setting typical current to {} A\".format(current))\n            param.update({\"Typical current [A]\": current})\n            for model in models:\n                model_disc = models_disc[model.name]\n                disc = discs[model.name]\n                param.update_model(model_disc, disc)\n                try:\n                    solution = model.default_solver.solve(model_disc, t_eval)\n                except pybamm.SolverError:\n                    pybamm.logger.error(\n                        \"Could not solve {!s} at {} A with {} points\".format(\n                            model.name, current, npts\n                        )\n                    )\n                    continue\n                voltage = pybamm.ProcessedVariable(\n                    model_disc.variables[\"Battery voltage [V]\"], solution.t, solution.y\n                )(t_eval)\n                variables = {\n                    \"Battery voltage [V]\": voltage,\n                    \"solution object\": solution,\n                }\n                models_times_and_voltages[model.name][npts][Crate] = variables\n\n    return models_times_and_voltages",
  "def simulation(models, t_eval, extra_parameter_values=None, disc_only=False):\n\n    # create geometry\n    geometry = models[-1].default_geometry\n\n    # load parameter values and process models and geometry\n    param = models[0].default_parameter_values\n    extra_parameter_values = extra_parameter_values or {}\n    param.update(extra_parameter_values)\n    for model in models:\n        param.process_model(model)\n    param.process_geometry(geometry)\n\n    # set mesh\n    var = pybamm.standard_spatial_vars\n    var_pts = {var.x_n: 25, var.x_s: 41, var.x_p: 34}\n    mesh = pybamm.Mesh(geometry, models[-1].default_submesh_types, var_pts)\n\n    # discretise models\n    for model in models:\n        disc = pybamm.Discretisation(mesh, model.default_spatial_methods)\n        disc.process_model(model)\n\n    if disc_only:\n        return model, mesh\n\n    # solve model\n    solutions = [None] * len(models)\n    for i, model in enumerate(models):\n        solution = model.default_solver.solve(model, t_eval)\n        solutions[i] = solution\n\n    return models, mesh, solutions",
  "def my_fun(t, A, omega):\n    return A * np.sin(2 * np.pi * omega * t)",
  "def car_current(t):\n    \"\"\"\n    Piecewise constant current as a function of time in seconds. This is adapted\n    from the file getCarCurrent.m, which is part of the LIONSIMBA toolbox [1]_.\n\n    References\n    ----------\n    .. [1] M Torchio, L Magni, R Bushan Gopaluni, RD Braatz, and D. Raimondoa.\n           LIONSIMBA: A Matlab framework based on a finite volume model suitable\n           for Li-ion battery design, simulation, and control. Journal of The\n           Electrochemical Society, 163(7):1192-1205, 2016.\n    \"\"\"\n\n    current = (\n        1 * (t >= 0) * (t <= 50)\n        - 0.5 * (t > 50) * (t <= 60)\n        + 0.5 * (t > 60) * (t <= 210)\n        + 1 * (t > 210) * (t <= 410)\n        + 2 * (t > 410) * (t <= 415)\n        + 1.25 * (t > 415) * (t <= 615)\n        - 0.5 * (t > 615)\n    )\n\n    return current",
  "def plot(t):\n    fig, ax = plt.subplots(figsize=(15, 8))\n    plt.tight_layout()\n    plt.subplots_adjust(left=-0.1)\n\n    # find t index\n    ind = (np.abs(solution.t - t)).argmin()\n\n    # negative current collector potential\n    plt.subplot(131)\n    phi_s_cn_plot = plt.pcolormesh(\n        y_plot,\n        z_plot,\n        np.transpose(phi_s_cn(y=y_plot, z=z_plot, t=solution.t[ind])),\n        shading=\"gouraud\",\n    )\n    plt.axis([0, l_y, 0, l_z])\n    plt.xlabel(r\"$y$\")\n    plt.ylabel(r\"$z$\")\n    plt.title(r\"$\\phi_{s,cn}$ [V]\")\n    plt.set_cmap(\"cividis\")\n    plt.colorbar(phi_s_cn_plot)\n\n    # positive current collector potential\n    plt.subplot(132)\n    phi_s_cp_plot = plt.pcolormesh(\n        y_plot,\n        z_plot,\n        np.transpose(phi_s_cp(y=y_plot, z=z_plot, t=solution.t[ind])),\n        shading=\"gouraud\",\n    )\n\n    plt.axis([0, l_y, 0, l_z])\n    plt.xlabel(r\"$y$\")\n    plt.ylabel(r\"$z$\")\n    plt.title(r\"$\\phi_{s,cp}$ [V]\")\n    plt.set_cmap(\"viridis\")\n    plt.colorbar(phi_s_cp_plot)\n\n    # temperature\n    plt.subplot(133)\n    T_plot = plt.pcolormesh(\n        y_plot,\n        z_plot,\n        np.transpose(T(y=y_plot, z=z_plot, t=solution.t[ind])),\n        shading=\"gouraud\",\n    )\n\n    plt.axis([0, l_y, 0, l_z])\n    plt.xlabel(r\"$y$\")\n    plt.ylabel(r\"$z$\")\n    plt.title(r\"$T$ [K]\")\n    plt.set_cmap(\"inferno\")\n    plt.colorbar(T_plot)\n\n    plt.subplots_adjust(\n        top=0.92, bottom=0.15, left=0.10, right=0.9, hspace=0.5, wspace=0.5\n    )\n    plt.show()",
  "def plot(t):\n    fig, ax = plt.subplots(figsize=(15, 8))\n    plt.tight_layout()\n    plt.subplots_adjust(left=-0.1)\n\n    # find t index\n    ind = (np.abs(solution.t - t)).argmin()\n\n    # negative current collector potential\n    plt.subplot(131)\n    phi_s_cn_plot = plt.pcolormesh(\n        y_plot,\n        z_plot,\n        np.transpose(phi_s_cn(y=y_plot, z=z_plot, t=solution.t[ind])),\n        shading=\"gouraud\",\n    )\n    plt.axis([0, l_y, 0, l_z])\n    plt.xlabel(r\"$y$\")\n    plt.ylabel(r\"$z$\")\n    plt.title(r\"$\\phi_{s,cn}$ [V]\")\n    plt.set_cmap(\"cividis\")\n    plt.colorbar(phi_s_cn_plot)\n\n    # positive current collector potential\n    plt.subplot(132)\n    phi_s_cp_plot = plt.pcolormesh(\n        y_plot,\n        z_plot,\n        np.transpose(phi_s_cp(y=y_plot, z=z_plot, t=solution.t[ind])),\n        shading=\"gouraud\",\n    )\n\n    plt.axis([0, l_y, 0, l_z])\n    plt.xlabel(r\"$y$\")\n    plt.ylabel(r\"$z$\")\n    plt.title(r\"$\\phi_{s,cp}$ [V]\")\n    plt.set_cmap(\"viridis\")\n    plt.colorbar(phi_s_cp_plot)\n\n    # temperature\n    plt.subplot(133)\n    T_plot = plt.pcolormesh(\n        y_plot,\n        z_plot,\n        np.transpose(T(y=y_plot, z=z_plot, t=solution.t[ind])),\n        shading=\"gouraud\",\n    )\n\n    plt.axis([0, l_y, 0, l_z])\n    plt.xlabel(r\"$y$\")\n    plt.ylabel(r\"$z$\")\n    plt.title(r\"$T$ [K]\")\n    plt.set_cmap(\"inferno\")\n    plt.colorbar(T_plot)\n\n    plt.subplots_adjust(\n        top=0.92, bottom=0.15, left=0.10, right=0.9, hspace=0.5, wspace=0.5\n    )\n    plt.show()",
  "def plot(t):\n    plt.subplots(figsize=(15, 8))\n    plt.tight_layout()\n    plt.subplots_adjust(left=-0.1)\n\n    # negative current collector potential\n    plt.subplot(221)\n    phi_s_cn_plot = plt.pcolormesh(\n        y_plot,\n        z_plot,\n        np.transpose(phi_s_cn(y=y_plot, z=z_plot, t=t)),\n        shading=\"gouraud\",\n    )\n    plt.axis([0, l_y, 0, l_z])\n    plt.xlabel(r\"$y$\")\n    plt.ylabel(r\"$z$\")\n    plt.title(r\"$\\phi_{s,cn}$\")\n    plt.set_cmap(\"cividis\")\n    plt.colorbar(phi_s_cn_plot)\n    plt.subplot(222)\n    phi_s_cn_spmecc_plot = plt.pcolormesh(\n        y_plot,\n        z_plot,\n        np.transpose(phi_s_cn_spmecc(y=y_plot, z=z_plot, t=t)),\n        shading=\"gouraud\",\n    )\n    plt.axis([0, l_y, 0, l_z])\n    plt.xlabel(r\"$y$\")\n    plt.ylabel(r\"$z$\")\n    plt.title(r\"$\\phi_{s,cn}$ SPMeCC\")\n    plt.set_cmap(\"cividis\")\n    plt.colorbar(phi_s_cn_spmecc_plot)\n\n    # positive current collector potential\n    plt.subplot(223)\n    phi_s_cp_plot = plt.pcolormesh(\n        y_plot,\n        z_plot,\n        np.transpose(phi_s_cp(y=y_plot, z=z_plot, t=t)),\n        shading=\"gouraud\",\n    )\n\n    plt.axis([0, l_y, 0, l_z])\n    plt.xlabel(r\"$y$\")\n    plt.ylabel(r\"$z$\")\n    plt.title(r\"$\\phi_{s,cp}$\")\n    plt.set_cmap(\"viridis\")\n    plt.colorbar(phi_s_cp_plot)\n    plt.subplot(224)\n    phi_s_cp_spmecc_plot = plt.pcolormesh(\n        y_plot,\n        z_plot,\n        np.transpose(phi_s_cp_spmecc(y=y_plot, z=z_plot, t=t)),\n        shading=\"gouraud\",\n    )\n    plt.axis([0, l_y, 0, l_z])\n    plt.xlabel(r\"$y$\")\n    plt.ylabel(r\"$z$\")\n    plt.title(r\"$\\phi_{s,cp}$ SPMeCC\")\n    plt.set_cmap(\"viridis\")\n    plt.colorbar(phi_s_cp_spmecc_plot)\n\n    plt.subplots_adjust(\n        top=0.92, bottom=0.15, left=0.10, right=0.9, hspace=0.5, wspace=0.5\n    )",
  "def plot(t):\n    fig, ax = plt.subplots(figsize=(15, 8))\n    plt.tight_layout()\n    plt.subplots_adjust(left=-0.1)\n\n    # find t index\n    ind = (np.abs(solution.t - t)).argmin()\n\n    # negative current collector potential\n    plt.subplot(131)\n    phi_s_cn_plot = plt.pcolormesh(\n        y_plot,\n        z_plot,\n        np.transpose(phi_s_cn(y=y_plot, z=z_plot, t=solution.t[ind])),\n        shading=\"gouraud\",\n    )\n    plt.axis([0, l_y, 0, l_z])\n    plt.xlabel(r\"$y$\")\n    plt.ylabel(r\"$z$\")\n    plt.title(r\"$\\phi_{s,cn}$ [V]\")\n    plt.set_cmap(\"cividis\")\n    plt.colorbar(phi_s_cn_plot)\n\n    # positive current collector potential\n    plt.subplot(132)\n    phi_s_cp_plot = plt.pcolormesh(\n        y_plot,\n        z_plot,\n        np.transpose(phi_s_cp(y=y_plot, z=z_plot, t=solution.t[ind])),\n        shading=\"gouraud\",\n    )\n\n    plt.axis([0, l_y, 0, l_z])\n    plt.xlabel(r\"$y$\")\n    plt.ylabel(r\"$z$\")\n    plt.title(r\"$\\phi_{s,cp}$ [V]\")\n    plt.set_cmap(\"viridis\")\n    plt.colorbar(phi_s_cp_plot)\n\n    # temperature\n    plt.subplot(133)\n    T_plot = plt.pcolormesh(\n        y_plot,\n        z_plot,\n        np.transpose(T(y=y_plot, z=z_plot, t=solution.t[ind])),\n        shading=\"gouraud\",\n    )\n\n    plt.axis([0, l_y, 0, l_z])\n    plt.xlabel(r\"$y$\")\n    plt.ylabel(r\"$z$\")\n    plt.title(r\"$T$ [K]\")\n    plt.set_cmap(\"inferno\")\n    plt.colorbar(T_plot)\n\n    plt.subplots_adjust(\n        top=0.92, bottom=0.15, left=0.10, right=0.9, hspace=0.5, wspace=0.5\n    )\n    plt.show()",
  "def plot(t):\n    fig, ax = plt.subplots(figsize=(15, 8))\n    plt.tight_layout()\n    plt.subplots_adjust(left=-0.1)\n\n    # find t index\n    ind = (np.abs(solution.t - t)).argmin()\n\n    # negative current collector potential\n    plt.subplot(131)\n    phi_s_cn_plot = plt.pcolormesh(\n        y_plot,\n        z_plot,\n        np.transpose(phi_s_cn(y=y_plot, z=z_plot, t=solution.t[ind])),\n        shading=\"gouraud\",\n    )\n    plt.axis([0, l_y, 0, l_z])\n    plt.xlabel(r\"$y$\")\n    plt.ylabel(r\"$z$\")\n    plt.title(r\"$\\phi_{s,cn}$ [V]\")\n    plt.set_cmap(\"cividis\")\n    plt.colorbar(phi_s_cn_plot)\n\n    # positive current collector potential\n    plt.subplot(132)\n    phi_s_cp_plot = plt.pcolormesh(\n        y_plot,\n        z_plot,\n        np.transpose(phi_s_cp(y=y_plot, z=z_plot, t=solution.t[ind])),\n        shading=\"gouraud\",\n    )\n\n    plt.axis([0, l_y, 0, l_z])\n    plt.xlabel(r\"$y$\")\n    plt.ylabel(r\"$z$\")\n    plt.title(r\"$\\phi_{s,cp}$ [V]\")\n    plt.set_cmap(\"viridis\")\n    plt.colorbar(phi_s_cp_plot)\n\n    # temperature\n    plt.subplot(133)\n    T_plot = plt.pcolormesh(\n        y_plot,\n        z_plot,\n        np.transpose(T(y=y_plot, z=z_plot, t=solution.t[ind])),\n        shading=\"gouraud\",\n    )\n\n    plt.axis([0, l_y, 0, l_z])\n    plt.xlabel(r\"$y$\")\n    plt.ylabel(r\"$z$\")\n    plt.title(r\"$T$ [K]\")\n    plt.set_cmap(\"inferno\")\n    plt.colorbar(T_plot)\n\n    plt.subplots_adjust(\n        top=0.92, bottom=0.15, left=0.10, right=0.9, hspace=0.5, wspace=0.5\n    )\n    plt.show()",
  "def darken_thermodynamic_factor_Chapman1968(c_e):\n    \"\"\"\n    Dimensional Darken thermodynamic factor of sulfuric acid, from data in\n    [1, 2]_, as a function of the electrolyte concentration c_e [mol.m-3].\n\n    References\n    ----------\n    .. [1] TW Chapman and J Newman. Compilation of selected thermodynamic and transport\n           properties of binary electrolytes in aqueous solution. Technical report,\n           California Univ., Berkeley. Lawrence Radiation Lab., 1968.\n    .. [2] KS Pitzer, RN Roy, and LF Silvester. Thermodynamics of electrolytes. 7.\n           sulfuric acid. Journal of the American Chemical Society, 99(15):4930\u20134936,\n           1977.\n\n    \"\"\"\n    return 0.49 + 4.1e-4 * c_e",
  "def viscosity_Chapman1968(c_e):\n    \"\"\"\n    Dimensional viscosity of sulfuric acid [kg.m-1.s-1], from data in [1]_, as a\n    function of the electrolyte concentration c_e [mol.m-3].\n\n    References\n    ----------\n    .. [1] TW Chapman and J Newman. Compilation of selected thermodynamic and transport\n           properties of binary electrolytes in aqueous solution. Technical report,\n           California Univ., Berkeley. Lawrence Radiation Lab., 1968.\n\n    \"\"\"\n    return 0.89e-3 + 1.11e-7 * c_e + 3.29e-11 * c_e ** 2",
  "def diffusivity_Gu1997(c_e):\n    \"\"\"\n    Dimensional Fickian diffusivity of sulfuric acid [m2.s-1], from [1]_ citing [2]_\n    and agreeing with data in [3]_, as a function of the electrolyte concentration\n    c_e [mol.m-3].\n\n    References\n    ----------\n    .. [1] WB Gu, CY Wang, and BY Liaw. Numerical modeling of coupled electrochemical\n           and transport processes in lead-acid batteries. Journal of The\n           Electrochemical Society, 144(6):2053\u20132061, 1997.\n    .. [2] WH Tiedemann and J Newman. Battery design and optimization. Journal of\n           Electrochemical Society, Softbound Proceeding Series, Princeton, New York,\n           79(1):23, 1979.\n    .. [3] TW Chapman and J Newman. Compilation of selected thermodynamic and transport\n           properties of binary electrolytes in aqueous solution. Technical report,\n           California Univ., Berkeley. Lawrence Radiation Lab., 1968.\n\n    \"\"\"\n    return (1.75 + 260e-6 * c_e) * 1e-9",
  "def conductivity_Gu1997(c_e):\n    \"\"\"\n    Dimensional conductivity of sulfuric acid [S.m-1], from [1]_ citing [2]_ and\n    agreeing with data in [3]_, as a function of the electrolyte concentration\n    c_e [mol.m-3].\n\n    References\n    ----------\n    .. [1] WB Gu, CY Wang, and BY Liaw. Numerical modeling of coupled electrochemical\n           and transport processes in lead-acid batteries. Journal of The\n           Electrochemical Society, 144(6):2053\u20132061, 1997.\n    .. [2] WH Tiedemann and J Newman. Battery design and optimization. Journal of\n           Electrochemical Society, Softbound Proceeding Series, Princeton, New York,\n           79(1):23, 1979.\n    .. [3] TW Chapman and J Newman. Compilation of selected thermodynamic and transport\n           properties of binary electrolytes in aqueous solution. Technical report,\n           California Univ., Berkeley. Lawrence Radiation Lab., 1968.\n\n    \"\"\"\n    return c_e * np.exp(6.23 - 1.34e-4 * c_e - 1.61e-8 * c_e ** 2) * 1e-4",
  "def lead_dioxide_ocp_Bode1977(m):\n    \"\"\"\n    Dimensional open-circuit voltage in the positive (lead-dioxide) electrode [V],\n    from [1]_, as a function of the molar mass m [mol.kg-1].\n\n    References\n    ----------\n    .. [1] H Bode. Lead-acid batteries. John Wiley and Sons, Inc., New York, NY, 1977.\n\n    \"\"\"\n    U = (\n        1.628\n        + 0.074 * np.log10(m)\n        + 0.033 * np.log10(m) ** 2\n        + 0.043 * np.log10(m) ** 3\n        + 0.022 * np.log10(m) ** 4\n    )\n    return U",
  "def lead_ocp_Bode1977(m):\n    \"\"\"\n    Dimensional open-circuit voltage in the negative (lead) electrode [V], from [1]_,\n    as a function of the molar mass m [mol.kg-1].\n\n    References\n    ----------\n    .. [1] H Bode. Lead-acid batteries. John Wiley and Sons, Inc., New York, NY, 1977.\n\n    \"\"\"\n    U = (\n        -0.294\n        - 0.074 * np.log10(m)\n        - 0.030 * np.log10(m) ** 2\n        - 0.031 * np.log10(m) ** 3\n        - 0.012 * np.log10(m) ** 4\n    )\n    return U",
  "def electrolyte_conductivity_Capiglia1999(c_e, T, T_inf, E_k_e, R_g):\n    \"\"\"\n    Conductivity of LiPF6 in EC:DMC as a function of ion concentration. The original\n    data is from [1]. The fit is from Dualfoil [2].\n\n    References\n    ----------\n    .. [1] C Capiglia et al. 7Li and 19F diffusion coefficients and thermal\n    properties of non-aqueous electrolyte solutions for rechargeable lithium batteries.\n    Journal of power sources 81 (1999): 859-862.\n    .. [2] http://www.cchem.berkeley.edu/jsngrp/fortran.html\n    Parameters\n    ----------\n    c_e: :class: `numpy.Array`\n        Dimensional electrolyte concentration\n    T: :class: `numpy.Array`\n        Dimensional temperature\n    T_inf: double\n        Reference temperature\n    E_k_e: double\n        Electrolyte conductivity activation energy\n    R_g: double\n        The ideal gas constant\n\n    Returns\n    -------\n    :`numpy.Array`\n        Solid diffusivity\n    \"\"\"\n\n    sigma_e = (\n        0.0911\n        + 1.9101 * (c_e / 1000)\n        - 1.052 * (c_e / 1000) ** 2\n        + 0.1554 * (c_e / 1000) ** 3\n    )\n\n    arrhenius = np.exp(E_k_e / R_g * (1 / T_inf - 1 / T))\n\n    return sigma_e * arrhenius",
  "def electrolyte_diffusivity_Capiglia1999(c_e, T, T_inf, E_D_e, R_g):\n    \"\"\"\n    Diffusivity of LiPF6 in EC:DMC as a function of ion concentration. The original data\n    is from [1]. The fit from Dualfoil [2].\n\n    References\n    ----------\n    .. [1] C Capiglia et al. 7Li and 19F diffusion coefficients and thermal\n    properties of non-aqueous electrolyte solutions for rechargeable lithium batteries.\n    Journal of power sources 81 (1999): 859-862.\n    .. [2] http://www.cchem.berkeley.edu/jsngrp/fortran.html\n\n    Parameters\n    ----------\n    c_e: :class: `numpy.Array`\n        Dimensional electrolyte concentration\n    T: :class: `numpy.Array`\n        Dimensional temperature\n    T_inf: double\n        Reference temperature\n    E_D_e: double\n        Electrolyte diffusion activation energy\n    R_g: double\n        The ideal gas constant\n\n    Returns\n    -------\n    :`numpy.Array`\n        Solid diffusivity\n    \"\"\"\n\n    D_c_e = 5.34e-10 * np.exp(-0.65 * c_e / 1000)\n    arrhenius = np.exp(E_D_e / R_g * (1 / T_inf - 1 / T))\n\n    return D_c_e * arrhenius",
  "def lico2_ocp_Dualfoil1998(sto):\n    \"\"\"\n    Lithium Cobalt Oxide (LiCO2) Open Circuit Potential (OCP) as a a function of the\n    stochiometry. The fit is taken from Dualfoil [1]. Dualfoil states that the data\n    was measured by Oscar Garcia 2001 using Quallion electrodes for 0.5 < sto < 0.99\n    and by Marc Doyle for sto<0.4 (for unstated electrodes). We could not find any\n    other records of the Garcia measurements. Doyles fits can be found in his\n    thesis [2] but we could not find any other record of his measurments.\n\n    References\n    ----------\n    .. [1] http://www.cchem.berkeley.edu/jsngrp/fortran.html\n    .. [2] CM Doyle. Design and simulation of lithium rechargeable batteries,\n           1995.\n\n    Parameters\n    ----------\n    sto: double\n       Stochiometry of material (li-fraction)\n\n    \"\"\"\n\n    stretch = 1.062\n    sto = stretch * sto\n\n    u_eq = (\n        2.16216\n        + 0.07645 * np.tanh(30.834 - 54.4806 * sto)\n        + 2.1581 * np.tanh(52.294 - 50.294 * sto)\n        - 0.14169 * np.tanh(11.0923 - 19.8543 * sto)\n        + 0.2051 * np.tanh(1.4684 - 5.4888 * sto)\n        + 0.2531 * np.tanh((-sto + 0.56478) / 0.1316)\n        - 0.02167 * np.tanh((sto - 0.525) / 0.006)\n    )\n\n    return u_eq",
  "def lico2_diffusivity_Dualfoil1998(sto, T, T_inf, E_D_s, R_g):\n    \"\"\"\n    LiCo2 diffusivity as a function of stochiometry, in this case the\n    diffusivity is taken to be a constant. The value is taken from Dualfoil [1].\n\n    References\n    ----------\n    .. [1] http://www.cchem.berkeley.edu/jsngrp/fortran.html\n\n    Parameters\n    ----------\n    sto: :class: `numpy.Array`\n        Electrode stochiometry\n    T: :class: `numpy.Array`\n        Dimensional temperature\n    T_inf: double\n        Reference temperature\n    E_D_s: double\n        Solid diffusion activation energy\n    R_g: double\n        The ideal gas constant\n\n    Returns\n    -------\n    : double\n        Solid diffusivity\n    \"\"\"\n\n    D_ref = 1 * 10 ** (-13)\n    arrhenius = np.exp(E_D_s / R_g * (1 / T_inf - 1 / T))\n\n    # Removing the fudge factor 0 * sto requires different handling of either\n    # either simplifications or how sto is passed into this function.\n    # See #547\n    return D_ref * arrhenius + 0 * sto",
  "def lico2_electrolyte_reaction_rate_Dualfoil1998(T, T_inf, E_r, R_g):\n    \"\"\"\n    Reaction rate for Butler-Volmer reactions between lico2 and LiPF6 in EC:DMC.\n\n    References\n    ----------\n    .. [2] http://www.cchem.berkeley.edu/jsngrp/fortran.html\n\n    Parameters\n    ----------\n    T: :class: `numpy.Array`\n        Dimensional temperature\n    T_inf: double\n        Reference temperature\n    E_r: double\n        Reaction activation energy\n    R_g: double\n        The ideal gas constant\n\n    Returns\n    -------\n    : double\n        Reaction rate\n    \"\"\"\n    m_ref = 6 * 10 ** (-7)\n    arrhenius = np.exp(E_r / R_g * (1 / T_inf - 1 / T))\n\n    return m_ref * arrhenius",
  "def lico2_entropic_change_Moura2016(sto, c_p_max):\n    \"\"\"\n        Lithium Cobalt Oxide (LiCO2) entropic change in open circuit potential (OCP) at\n        a temperature of 298.15K as a function of the stochiometry. The fit is taken\n        from Scott Moura's FastDFN code [1].\n\n        References\n        ----------\n        .. [1] https://github.com/scott-moura/fastDFN\n\n          Parameters\n          ----------\n          sto: double\n               Stochiometry of material (li-fraction)\n\n    \"\"\"\n\n    # Since the equation for LiCo2 from this ref. has the stretch factor,\n    # should this too? If not, the \"bumps\" in the OCV don't line up.\n    stretch = 1.062\n    sto = stretch * sto\n\n    du_dT = (\n        0.07645 * (-54.4806 / c_p_max) * ((1.0 / np.cosh(30.834 - 54.4806 * sto)) ** 2)\n        + 2.1581 * (-50.294 / c_p_max) * ((np.cosh(52.294 - 50.294 * sto)) ** (-2))\n        + 0.14169 * (19.854 / c_p_max) * ((np.cosh(11.0923 - 19.8543 * sto)) ** (-2))\n        - 0.2051 * (5.4888 / c_p_max) * ((np.cosh(1.4684 - 5.4888 * sto)) ** (-2))\n        - (0.2531 / 0.1316 / c_p_max) * ((np.cosh((-sto + 0.56478) / 0.1316)) ** (-2))\n        - (0.02167 / 0.006 / c_p_max) * ((np.cosh((sto - 0.525) / 0.006)) ** (-2))\n    )\n\n    return du_dT",
  "def graphite_mcmb2528_diffusivity_Dualfoil1998(sto, T, T_inf, E_D_s, R_g):\n    \"\"\"\n    Graphite MCMB 2528 diffusivity as a function of stochiometry, in this case the\n    diffusivity is taken to be a constant. The value is taken from Dualfoil [1].\n\n    References\n    ----------\n    .. [1] http://www.cchem.berkeley.edu/jsngrp/fortran.html\n\n    Parameters\n    ----------\n    sto: :class: `numpy.Array`\n        Electrode stochiometry\n    T: :class: `numpy.Array`\n        Dimensional temperature\n    T_inf: double\n        Reference temperature\n    E_D_s: double\n        Solid diffusion activation energy\n    R_g: double\n        The ideal gas constant\n\n    Returns\n    -------\n    : double\n        Solid diffusivity\n   \"\"\"\n\n    D_ref = 3.9 * 10 ** (-14)\n    arrhenius = np.exp(E_D_s / R_g * (1 / T_inf - 1 / T))\n\n    # Removing the fudge factor 0 * sto requires different handling of either\n    # either simplifications or how sto is passed into this function.\n    # See #547\n    return D_ref * arrhenius + 0 * sto",
  "def graphite_mcmb2528_ocp_Dualfoil1998(sto):\n    \"\"\"\n       Graphite MCMB 2528 Open Circuit Potential (OCP) as a function of the\n       stochiometry. The fit is taken from Dualfoil [1]. Dualfoil states that the data\n       was measured by Chris Bogatu at Telcordia and PolyStor materials, 2000. However,\n       we could not find any other records of this measurment.\n\n       References\n       ----------\n       .. [1] http://www.cchem.berkeley.edu/jsngrp/fortran.html\n       \"\"\"\n\n    u_eq = (\n        0.194\n        + 1.5 * np.exp(-120.0 * sto)\n        + 0.0351 * np.tanh((sto - 0.286) / 0.083)\n        - 0.0045 * np.tanh((sto - 0.849) / 0.119)\n        - 0.035 * np.tanh((sto - 0.9233) / 0.05)\n        - 0.0147 * np.tanh((sto - 0.5) / 0.034)\n        - 0.102 * np.tanh((sto - 0.194) / 0.142)\n        - 0.022 * np.tanh((sto - 0.9) / 0.0164)\n        - 0.011 * np.tanh((sto - 0.124) / 0.0226)\n        + 0.0155 * np.tanh((sto - 0.105) / 0.029)\n    )\n\n    return u_eq",
  "def graphite_entropic_change_Moura2016(sto, c_n_max):\n    \"\"\"\n        Graphite entropic change in open circuit potential (OCP) at a temperature of\n        298.15K as a function of the stochiometry taken from Scott Moura's FastDFN code\n        [1].\n\n        References\n        ----------\n        .. [1] https://github.com/scott-moura/fastDFN\n\n          Parameters\n          ----------\n          sto: double\n               Stochiometry of material (li-fraction)\n\n    \"\"\"\n\n    du_dT = (\n        -1.5 * (120.0 / c_n_max) * np.exp(-120 * sto)\n        + (0.0351 / (0.083 * c_n_max)) * ((np.cosh((sto - 0.286) / 0.083)) ** (-2))\n        - (0.0045 / (0.119 * c_n_max)) * ((np.cosh((sto - 0.849) / 0.119)) ** (-2))\n        - (0.035 / (0.05 * c_n_max)) * ((np.cosh((sto - 0.9233) / 0.05)) ** (-2))\n        - (0.0147 / (0.034 * c_n_max)) * ((np.cosh((sto - 0.5) / 0.034)) ** (-2))\n        - (0.102 / (0.142 * c_n_max)) * ((np.cosh((sto - 0.194) / 0.142)) ** (-2))\n        - (0.022 / (0.0164 * c_n_max)) * ((np.cosh((sto - 0.9) / 0.0164)) ** (-2))\n        - (0.011 / (0.0226 * c_n_max)) * ((np.cosh((sto - 0.124) / 0.0226)) ** (-2))\n        + (0.0155 / (0.029 * c_n_max)) * ((np.cosh((sto - 0.105) / 0.029)) ** (-2))\n    )\n\n    return du_dT",
  "def graphite_electrolyte_reaction_rate_Dualfoil1998(T, T_inf, E_r, R_g):\n    \"\"\"\n    Reaction rate for Butler-Volmer reactions between graphite and LiPF6 in EC:DMC.\n\n    References\n    ----------\n    .. [2] http://www.cchem.berkeley.edu/jsngrp/fortran.html\n\n    Parameters\n    ----------\n    T: :class: `numpy.Array`\n        Dimensional temperature\n    T_inf: double\n        Reference temperature\n    E_r: double\n        Reaction activation energy\n    R_g: double\n        The ideal gas constant\n\n    Returns\n    -------\n    :`numpy.Array`\n        Reaction rate\n    \"\"\"\n    m_ref = 2 * 10 ** (-5)\n    arrhenius = np.exp(E_r / R_g * (1 / T_inf - 1 / T))\n\n    return m_ref * arrhenius",
  "def root_dir():\n    \"\"\" return the root directory of the PyBaMM install directory \"\"\"\n    return str(pathlib.Path(pybamm.__path__[0]).parent)",
  "class Timer(object):\n    \"\"\"\n    Provides accurate timing.\n\n    Example\n    -------\n    timer = pybamm.Timer()\n    print(timer.format(timer.time()))\n\n    \"\"\"\n\n    def __init__(self):\n        self._start = timeit.default_timer()\n\n    def format(self, time=None):\n        \"\"\"\n        Formats a (non-integer) number of seconds, returns a string like\n        \"5 weeks, 3 days, 1 hour, 4 minutes, 9 seconds\", or \"0.0019 seconds\".\n\n        Arguments\n        ---------\n        time : float, optional\n            The time to be formatted.\n\n        Returns\n        -------\n        string\n            The string representation of ``time`` in human-readable form.\n        \"\"\"\n        if time is None:\n            time = self.time()\n        if time < 1e-2:\n            return str(time) + \" seconds\"\n        elif time < 60:\n            return str(round(time, 2)) + \" seconds\"\n        output = []\n        time = int(round(time))\n        units = [(604800, \"week\"), (86400, \"day\"), (3600, \"hour\"), (60, \"minute\")]\n        for k, name in units:\n            f = time // k\n            if f > 0 or output:\n                output.append(str(f) + \" \" + (name if f == 1 else name + \"s\"))\n            time -= f * k\n        output.append(\"1 second\" if time == 1 else str(time) + \" seconds\")\n        return \", \".join(output)\n\n    def reset(self):\n        \"\"\"\n        Resets this timer's start time.\n        \"\"\"\n        self._start = timeit.default_timer()\n\n    def time(self):\n        \"\"\"\n        Returns the time (float, in seconds) since this timer was created,\n        or since meth:`reset()` was last called.\n        \"\"\"\n        return timeit.default_timer() - self._start",
  "def load_function(filename):\n    \"\"\"\n    Load a python function from a file \"function_name.py\" called \"function_name\".\n    The filename might either be an absolute path, in which case that specific file will\n    be used, or the file will be searched for relative to PyBaMM root.\n\n    Arguments\n    ---------\n    filename : str\n        The name of the file containing the function of the same name.\n\n    Returns\n    -------\n    function\n        The python function loaded from the file.\n    \"\"\"\n\n    if not filename.endswith(\".py\"):\n        raise ValueError(\"Expected filename.py, but got {}\".format(filename))\n\n    # If it's an absolute path, find that exact file\n    if os.path.isabs(filename):\n        if not os.path.isfile(filename):\n            raise ValueError(\n                \"{} is an absolute path, but the file is not found\".format(filename)\n            )\n\n        valid_filename = filename\n\n    # Else, search in the whole PyBaMM directory for matches\n    else:\n        search_path = pybamm.root_dir()\n\n        head, tail = os.path.split(filename)\n\n        matching_files = []\n\n        for root, _, files in os.walk(search_path):\n            for file in files:\n                if file == tail:\n                    full_path = os.path.join(root, file)\n                    if full_path.endswith(filename):\n                        matching_files.append(full_path)\n\n        if len(matching_files) == 0:\n            raise ValueError(\n                \"{} cannot be found in the PyBaMM directory\".format(filename)\n            )\n        elif len(matching_files) > 1:\n            raise ValueError(\n                \"{} found multiple times in the PyBaMM directory\".format(filename)\n            )\n\n        valid_filename = matching_files[0]\n\n    # Now: we have some /path/to/valid/filename.py\n    # Add \"/path/to/vaid\" to the python path, and load the module \"filename\".\n    # Then, check \"filename\" module contains \"filename\" function.  If it does, return\n    # that function object, or raise an exception\n\n    valid_path, valid_leaf = os.path.split(valid_filename)\n    sys.path.append(valid_path)\n\n    # Load the module, which must be the leaf of filename, minus the .py extension\n    valid_module = valid_leaf.replace(\".py\", \"\")\n    module_object = importlib.import_module(valid_module)\n\n    # Check that a function of the same name exists in the loaded module\n    if valid_module not in dir(module_object):\n        raise ValueError(\n            \"No function {} found in module {}\".format(valid_module, valid_module)\n        )\n\n    # Remove valid_path from sys_path to avoid clashes down the line\n    sys.path.remove(valid_path)\n\n    return getattr(module_object, valid_module)",
  "def rmse(x, y):\n    \"Calculate the root-mean-square-error between two vectors x and y, ignoring NaNs\"\n    # Check lengths\n    if len(x) != len(y):\n        raise ValueError(\"Vectors must have the same length\")\n    return np.sqrt(np.nanmean((x - y) ** 2))",
  "def get_infinite_nested_dict():\n    \"\"\"\n    Return a dictionary that allows infinite nesting without having to define level by\n    level.\n\n    See:\n    https://stackoverflow.com/questions/651794/whats-the-best-way-to-initialize-a-dict-of-dicts-in-python/652226#652226\n\n    Example\n    -------\n    >>> import pybamm\n    >>> d = pybamm.get_infinite_nested_dict()\n    >>> d[\"a\"] = 1\n    >>> d[\"a\"]\n    1\n    >>> d[\"b\"][\"c\"][\"d\"] = 2\n    >>> d[\"b\"][\"c\"] == {\"d\": 2}\n    True\n    \"\"\"\n    return defaultdict(get_infinite_nested_dict)",
  "def __init__(self):\n        self._start = timeit.default_timer()",
  "def format(self, time=None):\n        \"\"\"\n        Formats a (non-integer) number of seconds, returns a string like\n        \"5 weeks, 3 days, 1 hour, 4 minutes, 9 seconds\", or \"0.0019 seconds\".\n\n        Arguments\n        ---------\n        time : float, optional\n            The time to be formatted.\n\n        Returns\n        -------\n        string\n            The string representation of ``time`` in human-readable form.\n        \"\"\"\n        if time is None:\n            time = self.time()\n        if time < 1e-2:\n            return str(time) + \" seconds\"\n        elif time < 60:\n            return str(round(time, 2)) + \" seconds\"\n        output = []\n        time = int(round(time))\n        units = [(604800, \"week\"), (86400, \"day\"), (3600, \"hour\"), (60, \"minute\")]\n        for k, name in units:\n            f = time // k\n            if f > 0 or output:\n                output.append(str(f) + \" \" + (name if f == 1 else name + \"s\"))\n            time -= f * k\n        output.append(\"1 second\" if time == 1 else str(time) + \" seconds\")\n        return \", \".join(output)",
  "def reset(self):\n        \"\"\"\n        Resets this timer's start time.\n        \"\"\"\n        self._start = timeit.default_timer()",
  "def time(self):\n        \"\"\"\n        Returns the time (float, in seconds) since this timer was created,\n        or since meth:`reset()` was last called.\n        \"\"\"\n        return timeit.default_timer() - self._start",
  "def set_logging_level(level):\n    logger.setLevel(level)",
  "def ax_min(data):\n    \"Calculate appropriate minimum axis value for plotting\"\n    data_min = np.min(data)\n    if data_min <= 0:\n        return 1.04 * data_min\n    else:\n        return 0.96 * data_min",
  "def ax_max(data):\n    \"Calculate appropriate maximum axis value for plotting\"\n    data_max = np.max(data)\n    if data_max <= 0:\n        return 0.96 * data_max\n    else:\n        return 1.04 * data_max",
  "def split_long_string(title, max_words=4):\n    \"Get title in a nice format\"\n    words = title.split()\n    # Don't split if fits on one line, don't split just for units\n    if len(words) <= max_words or words[max_words].startswith(\"[\"):\n        return title\n    else:\n        first_line = (\" \").join(words[:max_words])\n        second_line = (\" \").join(words[max_words:])\n        return first_line + \"\\n\" + second_line",
  "class QuickPlot(object):\n    \"\"\"\n    Generates a quick plot of a subset of key outputs of the model so that the model\n    outputs can be easily assessed. The axis limits can be set using:\n        self.axis[\"Variable name\"] = [x_min, x_max, y_min, y_max]\n    They can be reset to the default values by using self.reset_axis.\n\n    Parameters\n    ----------\n    models: (iter of) :class:`pybamm.BaseModel`\n        The model(s) to plot the outputs of.\n    meshes: (iter of) :class:`pybamm.Mesh`\n        The mesh(es) on which the model(s) were solved.\n    solutions: (iter of) :class:`pybamm.Solver`\n        The numerical solution(s) for the model(s) which contained the solution to the\n        model(s).\n    output_variables : list of str, optional\n        List of variables to plot\n    labels : list of str, optional\n        Labels for the different models. Defaults to model names\n    colors : list of str, optional\n        The colors to loop over when plotting. Defaults to\n        [\"r\", \"b\", \"k\", \"g\", \"m\", \"c\"]\n    linestyles : list of str, optional\n        The linestyles to loop over when plotting. Defaults to [\"-\", \":\", \"--\", \"-.\"]\n    \"\"\"\n\n    def __init__(\n        self,\n        models,\n        meshes,\n        solutions,\n        output_variables=None,\n        labels=None,\n        colors=None,\n        linestyles=None,\n    ):\n        # Pre-process models and solutions\n        if isinstance(models, pybamm.BaseModel):\n            models = [models]\n        elif not isinstance(models, list):\n            raise TypeError(\"'models' must be 'pybamm.BaseModel' or list\")\n        if isinstance(meshes, pybamm.Mesh):\n            # If only one mesh is passed but there are multiple models, try to use\n            # the same mesh for all of them\n            meshes = [meshes] * len(models)\n        elif not isinstance(meshes, list):\n            raise TypeError(\"'meshes' must be 'pybamm.Mesh' or list\")\n        if isinstance(solutions, pybamm.Solution):\n            solutions = [solutions]\n        elif not isinstance(solutions, list):\n            raise TypeError(\"'solutions' must be 'pybamm.Solution' or list\")\n        if len(models) == len(solutions):\n            self.num_models = len(models)\n        else:\n            raise ValueError(\"must provide the same number of models and solutions\")\n\n        # Set labels\n        self.labels = labels or [model.name for model in models]\n\n        # Set colors and linestyles\n        self.colors = colors\n        self.linestyles = linestyles\n\n        # Scales (default to 1 if information not in model)\n        variables = models[0].variables\n        self.spatial_scales = {\"x\": 1, \"y\": 1, \"z\": 1}\n        self.time_scale = 1\n        if \"x [m]\" and \"x\" in variables:\n            self.spatial_scales[\"x\"] = (variables[\"x [m]\"] / variables[\"x\"]).evaluate()[\n                -1\n            ]\n        if \"y [m]\" and \"y\" in variables:\n            self.spatial_scales[\"y\"] = (variables[\"y [m]\"] / variables[\"y\"]).evaluate()[\n                -1\n            ]\n        if \"z [m]\" and \"z\" in variables:\n            self.spatial_scales[\"z\"] = (variables[\"z [m]\"] / variables[\"z\"]).evaluate()[\n                -1\n            ]\n        if \"r_n [m]\" and \"r_n\" in variables:\n            self.spatial_scales[\"r_n\"] = (\n                variables[\"r_n [m]\"] / variables[\"r_n\"]\n            ).evaluate()[-1]\n        if \"r_p [m]\" and \"r_p\" in variables:\n            self.spatial_scales[\"r_p\"] = (\n                variables[\"r_p [m]\"] / variables[\"r_p\"]\n            ).evaluate()[-1]\n        if \"Time [h]\" and \"Time\" in variables:\n            self.time_scale = (variables[\"Time [h]\"] / variables[\"Time\"]).evaluate(t=1)\n\n        # Time parameters\n        self.ts = [solution.t for solution in solutions]\n        self.min_t = np.min([t[0] for t in self.ts]) * self.time_scale\n        self.max_t = np.max([t[-1] for t in self.ts]) * self.time_scale\n\n        # Default output variables for lead-acid and lithium-ion\n        if output_variables is None:\n            if isinstance(models[0], pybamm.lithium_ion.BaseModel):\n                output_variables = [\n                    \"Negative particle surface concentration\",\n                    \"Electrolyte concentration\",\n                    \"Positive particle surface concentration\",\n                    \"Current [A]\",\n                    \"Negative electrode potential [V]\",\n                    \"Electrolyte potential [V]\",\n                    \"Positive electrode potential [V]\",\n                    \"Terminal voltage [V]\",\n                ]\n            elif isinstance(models[0], pybamm.lead_acid.BaseModel):\n                output_variables = [\n                    \"Interfacial current density [A.m-2]\",\n                    \"Electrolyte concentration [mol.m-3]\",\n                    \"Current [A]\",\n                    \"Porosity\",\n                    \"Electrolyte potential [V]\",\n                    \"Terminal voltage [V]\",\n                ]\n            # else plot all variables in first model\n            else:\n                output_variables = models[0].variables\n\n        self.set_output_variables(output_variables, solutions, models, meshes)\n        self.reset_axis()\n\n    def set_output_variables(self, output_variables, solutions, models, meshes):\n        # Set up output variables\n        self.variables = {}\n        self.spatial_variable = {}\n\n        # Calculate subplot positions based on number of variables supplied\n        self.subplot_positions = {}\n        self.n_rows = int(len(output_variables) // np.sqrt(len(output_variables)))\n        self.n_cols = int(np.ceil(len(output_variables) / self.n_rows))\n\n        # Process output variables into a form that can be plotted\n        processed_variables = {}\n        for i, model in enumerate(models):\n            variables_to_process = {}\n            for variable_list in output_variables:\n                # Make sure we always have a list of lists of variables\n                if isinstance(variable_list, str):\n                    variable_list = [variable_list]\n                # Add all variables to the list of variables that should be processed\n                variables_to_process.update(\n                    {var: model.variables[var] for var in variable_list}\n                )\n            processed_variables[model] = pybamm.post_process_variables(\n                variables_to_process, solutions[i].t, solutions[i].y, meshes[i]\n            )\n\n        # Prepare dictionary of variables\n        for k, variable_list in enumerate(output_variables):\n            # Make sure we always have a list of lists of variables\n            if isinstance(variable_list, str):\n                variable_list = [variable_list]\n\n            # Prepare list of variables\n            key = tuple(variable_list)\n            self.variables[key] = [None] * len(models)\n\n            # process each variable in variable_list for each model\n            for i, model in enumerate(models):\n                # self.variables is a dictionary of lists of lists\n                self.variables[key][i] = [\n                    processed_variables[model][var] for var in variable_list\n                ]\n\n            # Make sure variables have the same dimensions and domain\n            domain = self.variables[key][0][0].domain\n            for variable in self.variables[key][0]:\n                if variable.domain != domain:\n                    raise ValueError(\"mismatching variable domains\")\n\n            # Set the x variable for any two-dimensional variables\n            if self.variables[key][0][0].dimensions == 2:\n                variable_key = self.variables[key][0][0].spatial_var_name\n                variable_value = meshes[0].combine_submeshes(*domain)[0].edges\n                self.spatial_variable[key] = (variable_key, variable_value)\n\n            # Don't allow 3D variables\n            elif any(var.dimensions == 3 for var in self.variables[key][0]):\n                raise NotImplementedError(\"cannot plot 3D variables\")\n\n            # Define subplot position\n            self.subplot_positions[key] = (self.n_rows, self.n_cols, k + 1)\n\n    def reset_axis(self):\n        \"\"\"\n        Reset the axis limits to the default values.\n        These are calculated to fit around the minimum and maximum values of all the\n        variables in each subplot\n        \"\"\"\n        self.axis = {}\n        for key, variable_lists in self.variables.items():\n            if variable_lists[0][0].dimensions == 1:\n                spatial_var_name, spatial_var_value = \"x\", None\n                x_min = self.min_t\n                x_max = self.max_t\n            elif variable_lists[0][0].dimensions == 2:\n                spatial_var_name, spatial_var_value = self.spatial_variable[key]\n                if spatial_var_name == \"r\":\n                    if \"negative\" in key[0].lower():\n                        spatial_var_scaled = (\n                            spatial_var_value * self.spatial_scales[\"r_n\"]\n                        )\n                    elif \"positive\" in key[0].lower():\n                        spatial_var_scaled = (\n                            spatial_var_value * self.spatial_scales[\"r_p\"]\n                        )\n                else:\n                    spatial_var_scaled = (\n                        spatial_var_value * self.spatial_scales[spatial_var_name]\n                    )\n                x_min = spatial_var_scaled[0]\n                x_max = spatial_var_scaled[-1]\n\n            # Get min and max y values\n            y_min = np.min(\n                [\n                    ax_min(var(self.ts[i], **{spatial_var_name: spatial_var_value}))\n                    for i, variable_list in enumerate(variable_lists)\n                    for var in variable_list\n                ]\n            )\n            y_max = np.max(\n                [\n                    ax_max(var(self.ts[i], **{spatial_var_name: spatial_var_value}))\n                    for i, variable_list in enumerate(variable_lists)\n                    for var in variable_list\n                ]\n            )\n            if y_min == y_max:\n                y_min -= 1\n                y_max += 1\n            self.axis[key] = [x_min, x_max, y_min, y_max]\n\n    def plot(self, t):\n        \"\"\"Produces a quick plot with the internal states at time t.\n\n        Parameters\n        ----------\n        t : float\n            Dimensional time (in hours) at which to plot.\n        \"\"\"\n\n        import matplotlib.pyplot as plt\n\n        t /= self.time_scale\n        self.fig, self.ax = plt.subplots(self.n_rows, self.n_cols, figsize=(15, 8))\n        plt.tight_layout()\n        plt.subplots_adjust(left=-0.1)\n        self.plots = {}\n        self.time_lines = {}\n\n        colors = self.colors or [\"r\", \"b\", \"k\", \"g\", \"m\", \"c\"]\n        linestyles = self.linestyles or [\"-\", \":\", \"--\", \"-.\"]\n        fontsize = 42 // self.n_cols\n\n        for k, (key, variable_lists) in enumerate(self.variables.items()):\n            if len(self.variables) == 1:\n                ax = self.ax\n            else:\n                ax = self.ax.flat[k]\n            ax.set_xlim(self.axis[key][:2])\n            ax.set_ylim(self.axis[key][2:])\n            ax.xaxis.set_major_locator(plt.MaxNLocator(3))\n            self.plots[key] = defaultdict(dict)\n            # Set labels for the first subplot only (avoid repetition)\n            if variable_lists[0][0].dimensions == 2:\n                # 2D plot: plot as a function of x at time t\n                spatial_var_name, spatial_var_value = self.spatial_variable[key]\n                ax.set_xlabel(spatial_var_name + \" [m]\", fontsize=fontsize)\n                for i, variable_list in enumerate(variable_lists):\n                    for j, variable in enumerate(variable_list):\n                        if spatial_var_name == \"r\":\n                            if \"negative\" in key[0].lower():\n                                spatial_scale = self.spatial_scales[\"r_n\"]\n                            elif \"positive\" in key[0].lower():\n                                spatial_scale = self.spatial_scales[\"r_p\"]\n                        else:\n                            spatial_scale = self.spatial_scales[spatial_var_name]\n                        self.plots[key][i][j], = ax.plot(\n                            spatial_var_value * spatial_scale,\n                            variable(\n                                t, **{spatial_var_name: spatial_var_value}, warn=False\n                            ),\n                            lw=2,\n                            color=colors[i],\n                            linestyle=linestyles[j],\n                        )\n            else:\n                # 1D plot: plot as a function of time, indicating time t with a line\n                ax.set_xlabel(\"Time [h]\", fontsize=fontsize)\n                for i, variable_list in enumerate(variable_lists):\n                    for j, variable in enumerate(variable_list):\n                        full_t = self.ts[i]\n                        self.plots[key][i][j], = ax.plot(\n                            full_t * self.time_scale,\n                            variable(full_t, warn=False),\n                            lw=2,\n                            color=colors[i],\n                            linestyle=linestyles[j],\n                        )\n                y_min, y_max = self.axis[key][2:]\n                self.time_lines[key], = ax.plot(\n                    [t * self.time_scale, t * self.time_scale], [y_min, y_max], \"k--\"\n                )\n            # Set either y label or legend entries\n            if len(key) == 1:\n                title = split_long_string(key[0])\n                ax.set_title(title, fontsize=fontsize)\n            else:\n                ax.legend(\n                    [split_long_string(s, 6) for s in key],\n                    bbox_to_anchor=(0.5, 1),\n                    fontsize=8,\n                    loc=\"lower center\",\n                )\n            if k == len(self.variables) - 1:\n                ax.legend(self.labels, loc=\"upper right\", bbox_to_anchor=(1, -0.2))\n\n    def dynamic_plot(self, testing=False):\n        \"\"\"\n        Generate a dynamic plot with a slider to control the time. We recommend using\n        ipywidgets instead of this function if you are using jupyter notebooks\n        \"\"\"\n\n        import matplotlib.pyplot as plt\n        from matplotlib.widgets import Slider\n\n        # create an initial plot at time 0\n        self.plot(0)\n\n        axcolor = \"lightgoldenrodyellow\"\n        axfreq = plt.axes([0.315, 0.02, 0.37, 0.03], facecolor=axcolor)\n        self.sfreq = Slider(axfreq, \"Time\", 0, self.max_t, valinit=0)\n        self.sfreq.on_changed(self.update)\n\n        # plt.subplots_adjust(\n        #     top=0.92, bottom=0.15, left=0.10, right=0.9, hspace=0.5, wspace=0.5\n        # )\n        self.fig.tight_layout()\n\n        if not testing:  # pragma: no cover\n            plt.show()\n\n    def update(self, val):\n        \"\"\"\n        Update the plot in self.plot() with values at new time\n        \"\"\"\n        t = self.sfreq.val\n        t_dimensionless = t / self.time_scale\n        for key, plot in self.plots.items():\n            if self.variables[key][0][0].dimensions == 2:\n                spatial_var_name, spatial_var_value = self.spatial_variable[key]\n                for i, variable_lists in enumerate(self.variables[key]):\n                    for j, variable in enumerate(variable_lists):\n                        plot[i][j].set_ydata(\n                            variable(\n                                t_dimensionless,\n                                **{spatial_var_name: spatial_var_value},\n                                warn=False\n                            )\n                        )\n            else:\n                self.time_lines[key].set_xdata([t])\n\n        self.fig.canvas.draw_idle()",
  "def __init__(\n        self,\n        models,\n        meshes,\n        solutions,\n        output_variables=None,\n        labels=None,\n        colors=None,\n        linestyles=None,\n    ):\n        # Pre-process models and solutions\n        if isinstance(models, pybamm.BaseModel):\n            models = [models]\n        elif not isinstance(models, list):\n            raise TypeError(\"'models' must be 'pybamm.BaseModel' or list\")\n        if isinstance(meshes, pybamm.Mesh):\n            # If only one mesh is passed but there are multiple models, try to use\n            # the same mesh for all of them\n            meshes = [meshes] * len(models)\n        elif not isinstance(meshes, list):\n            raise TypeError(\"'meshes' must be 'pybamm.Mesh' or list\")\n        if isinstance(solutions, pybamm.Solution):\n            solutions = [solutions]\n        elif not isinstance(solutions, list):\n            raise TypeError(\"'solutions' must be 'pybamm.Solution' or list\")\n        if len(models) == len(solutions):\n            self.num_models = len(models)\n        else:\n            raise ValueError(\"must provide the same number of models and solutions\")\n\n        # Set labels\n        self.labels = labels or [model.name for model in models]\n\n        # Set colors and linestyles\n        self.colors = colors\n        self.linestyles = linestyles\n\n        # Scales (default to 1 if information not in model)\n        variables = models[0].variables\n        self.spatial_scales = {\"x\": 1, \"y\": 1, \"z\": 1}\n        self.time_scale = 1\n        if \"x [m]\" and \"x\" in variables:\n            self.spatial_scales[\"x\"] = (variables[\"x [m]\"] / variables[\"x\"]).evaluate()[\n                -1\n            ]\n        if \"y [m]\" and \"y\" in variables:\n            self.spatial_scales[\"y\"] = (variables[\"y [m]\"] / variables[\"y\"]).evaluate()[\n                -1\n            ]\n        if \"z [m]\" and \"z\" in variables:\n            self.spatial_scales[\"z\"] = (variables[\"z [m]\"] / variables[\"z\"]).evaluate()[\n                -1\n            ]\n        if \"r_n [m]\" and \"r_n\" in variables:\n            self.spatial_scales[\"r_n\"] = (\n                variables[\"r_n [m]\"] / variables[\"r_n\"]\n            ).evaluate()[-1]\n        if \"r_p [m]\" and \"r_p\" in variables:\n            self.spatial_scales[\"r_p\"] = (\n                variables[\"r_p [m]\"] / variables[\"r_p\"]\n            ).evaluate()[-1]\n        if \"Time [h]\" and \"Time\" in variables:\n            self.time_scale = (variables[\"Time [h]\"] / variables[\"Time\"]).evaluate(t=1)\n\n        # Time parameters\n        self.ts = [solution.t for solution in solutions]\n        self.min_t = np.min([t[0] for t in self.ts]) * self.time_scale\n        self.max_t = np.max([t[-1] for t in self.ts]) * self.time_scale\n\n        # Default output variables for lead-acid and lithium-ion\n        if output_variables is None:\n            if isinstance(models[0], pybamm.lithium_ion.BaseModel):\n                output_variables = [\n                    \"Negative particle surface concentration\",\n                    \"Electrolyte concentration\",\n                    \"Positive particle surface concentration\",\n                    \"Current [A]\",\n                    \"Negative electrode potential [V]\",\n                    \"Electrolyte potential [V]\",\n                    \"Positive electrode potential [V]\",\n                    \"Terminal voltage [V]\",\n                ]\n            elif isinstance(models[0], pybamm.lead_acid.BaseModel):\n                output_variables = [\n                    \"Interfacial current density [A.m-2]\",\n                    \"Electrolyte concentration [mol.m-3]\",\n                    \"Current [A]\",\n                    \"Porosity\",\n                    \"Electrolyte potential [V]\",\n                    \"Terminal voltage [V]\",\n                ]\n            # else plot all variables in first model\n            else:\n                output_variables = models[0].variables\n\n        self.set_output_variables(output_variables, solutions, models, meshes)\n        self.reset_axis()",
  "def set_output_variables(self, output_variables, solutions, models, meshes):\n        # Set up output variables\n        self.variables = {}\n        self.spatial_variable = {}\n\n        # Calculate subplot positions based on number of variables supplied\n        self.subplot_positions = {}\n        self.n_rows = int(len(output_variables) // np.sqrt(len(output_variables)))\n        self.n_cols = int(np.ceil(len(output_variables) / self.n_rows))\n\n        # Process output variables into a form that can be plotted\n        processed_variables = {}\n        for i, model in enumerate(models):\n            variables_to_process = {}\n            for variable_list in output_variables:\n                # Make sure we always have a list of lists of variables\n                if isinstance(variable_list, str):\n                    variable_list = [variable_list]\n                # Add all variables to the list of variables that should be processed\n                variables_to_process.update(\n                    {var: model.variables[var] for var in variable_list}\n                )\n            processed_variables[model] = pybamm.post_process_variables(\n                variables_to_process, solutions[i].t, solutions[i].y, meshes[i]\n            )\n\n        # Prepare dictionary of variables\n        for k, variable_list in enumerate(output_variables):\n            # Make sure we always have a list of lists of variables\n            if isinstance(variable_list, str):\n                variable_list = [variable_list]\n\n            # Prepare list of variables\n            key = tuple(variable_list)\n            self.variables[key] = [None] * len(models)\n\n            # process each variable in variable_list for each model\n            for i, model in enumerate(models):\n                # self.variables is a dictionary of lists of lists\n                self.variables[key][i] = [\n                    processed_variables[model][var] for var in variable_list\n                ]\n\n            # Make sure variables have the same dimensions and domain\n            domain = self.variables[key][0][0].domain\n            for variable in self.variables[key][0]:\n                if variable.domain != domain:\n                    raise ValueError(\"mismatching variable domains\")\n\n            # Set the x variable for any two-dimensional variables\n            if self.variables[key][0][0].dimensions == 2:\n                variable_key = self.variables[key][0][0].spatial_var_name\n                variable_value = meshes[0].combine_submeshes(*domain)[0].edges\n                self.spatial_variable[key] = (variable_key, variable_value)\n\n            # Don't allow 3D variables\n            elif any(var.dimensions == 3 for var in self.variables[key][0]):\n                raise NotImplementedError(\"cannot plot 3D variables\")\n\n            # Define subplot position\n            self.subplot_positions[key] = (self.n_rows, self.n_cols, k + 1)",
  "def reset_axis(self):\n        \"\"\"\n        Reset the axis limits to the default values.\n        These are calculated to fit around the minimum and maximum values of all the\n        variables in each subplot\n        \"\"\"\n        self.axis = {}\n        for key, variable_lists in self.variables.items():\n            if variable_lists[0][0].dimensions == 1:\n                spatial_var_name, spatial_var_value = \"x\", None\n                x_min = self.min_t\n                x_max = self.max_t\n            elif variable_lists[0][0].dimensions == 2:\n                spatial_var_name, spatial_var_value = self.spatial_variable[key]\n                if spatial_var_name == \"r\":\n                    if \"negative\" in key[0].lower():\n                        spatial_var_scaled = (\n                            spatial_var_value * self.spatial_scales[\"r_n\"]\n                        )\n                    elif \"positive\" in key[0].lower():\n                        spatial_var_scaled = (\n                            spatial_var_value * self.spatial_scales[\"r_p\"]\n                        )\n                else:\n                    spatial_var_scaled = (\n                        spatial_var_value * self.spatial_scales[spatial_var_name]\n                    )\n                x_min = spatial_var_scaled[0]\n                x_max = spatial_var_scaled[-1]\n\n            # Get min and max y values\n            y_min = np.min(\n                [\n                    ax_min(var(self.ts[i], **{spatial_var_name: spatial_var_value}))\n                    for i, variable_list in enumerate(variable_lists)\n                    for var in variable_list\n                ]\n            )\n            y_max = np.max(\n                [\n                    ax_max(var(self.ts[i], **{spatial_var_name: spatial_var_value}))\n                    for i, variable_list in enumerate(variable_lists)\n                    for var in variable_list\n                ]\n            )\n            if y_min == y_max:\n                y_min -= 1\n                y_max += 1\n            self.axis[key] = [x_min, x_max, y_min, y_max]",
  "def plot(self, t):\n        \"\"\"Produces a quick plot with the internal states at time t.\n\n        Parameters\n        ----------\n        t : float\n            Dimensional time (in hours) at which to plot.\n        \"\"\"\n\n        import matplotlib.pyplot as plt\n\n        t /= self.time_scale\n        self.fig, self.ax = plt.subplots(self.n_rows, self.n_cols, figsize=(15, 8))\n        plt.tight_layout()\n        plt.subplots_adjust(left=-0.1)\n        self.plots = {}\n        self.time_lines = {}\n\n        colors = self.colors or [\"r\", \"b\", \"k\", \"g\", \"m\", \"c\"]\n        linestyles = self.linestyles or [\"-\", \":\", \"--\", \"-.\"]\n        fontsize = 42 // self.n_cols\n\n        for k, (key, variable_lists) in enumerate(self.variables.items()):\n            if len(self.variables) == 1:\n                ax = self.ax\n            else:\n                ax = self.ax.flat[k]\n            ax.set_xlim(self.axis[key][:2])\n            ax.set_ylim(self.axis[key][2:])\n            ax.xaxis.set_major_locator(plt.MaxNLocator(3))\n            self.plots[key] = defaultdict(dict)\n            # Set labels for the first subplot only (avoid repetition)\n            if variable_lists[0][0].dimensions == 2:\n                # 2D plot: plot as a function of x at time t\n                spatial_var_name, spatial_var_value = self.spatial_variable[key]\n                ax.set_xlabel(spatial_var_name + \" [m]\", fontsize=fontsize)\n                for i, variable_list in enumerate(variable_lists):\n                    for j, variable in enumerate(variable_list):\n                        if spatial_var_name == \"r\":\n                            if \"negative\" in key[0].lower():\n                                spatial_scale = self.spatial_scales[\"r_n\"]\n                            elif \"positive\" in key[0].lower():\n                                spatial_scale = self.spatial_scales[\"r_p\"]\n                        else:\n                            spatial_scale = self.spatial_scales[spatial_var_name]\n                        self.plots[key][i][j], = ax.plot(\n                            spatial_var_value * spatial_scale,\n                            variable(\n                                t, **{spatial_var_name: spatial_var_value}, warn=False\n                            ),\n                            lw=2,\n                            color=colors[i],\n                            linestyle=linestyles[j],\n                        )\n            else:\n                # 1D plot: plot as a function of time, indicating time t with a line\n                ax.set_xlabel(\"Time [h]\", fontsize=fontsize)\n                for i, variable_list in enumerate(variable_lists):\n                    for j, variable in enumerate(variable_list):\n                        full_t = self.ts[i]\n                        self.plots[key][i][j], = ax.plot(\n                            full_t * self.time_scale,\n                            variable(full_t, warn=False),\n                            lw=2,\n                            color=colors[i],\n                            linestyle=linestyles[j],\n                        )\n                y_min, y_max = self.axis[key][2:]\n                self.time_lines[key], = ax.plot(\n                    [t * self.time_scale, t * self.time_scale], [y_min, y_max], \"k--\"\n                )\n            # Set either y label or legend entries\n            if len(key) == 1:\n                title = split_long_string(key[0])\n                ax.set_title(title, fontsize=fontsize)\n            else:\n                ax.legend(\n                    [split_long_string(s, 6) for s in key],\n                    bbox_to_anchor=(0.5, 1),\n                    fontsize=8,\n                    loc=\"lower center\",\n                )\n            if k == len(self.variables) - 1:\n                ax.legend(self.labels, loc=\"upper right\", bbox_to_anchor=(1, -0.2))",
  "def dynamic_plot(self, testing=False):\n        \"\"\"\n        Generate a dynamic plot with a slider to control the time. We recommend using\n        ipywidgets instead of this function if you are using jupyter notebooks\n        \"\"\"\n\n        import matplotlib.pyplot as plt\n        from matplotlib.widgets import Slider\n\n        # create an initial plot at time 0\n        self.plot(0)\n\n        axcolor = \"lightgoldenrodyellow\"\n        axfreq = plt.axes([0.315, 0.02, 0.37, 0.03], facecolor=axcolor)\n        self.sfreq = Slider(axfreq, \"Time\", 0, self.max_t, valinit=0)\n        self.sfreq.on_changed(self.update)\n\n        # plt.subplots_adjust(\n        #     top=0.92, bottom=0.15, left=0.10, right=0.9, hspace=0.5, wspace=0.5\n        # )\n        self.fig.tight_layout()\n\n        if not testing:  # pragma: no cover\n            plt.show()",
  "def update(self, val):\n        \"\"\"\n        Update the plot in self.plot() with values at new time\n        \"\"\"\n        t = self.sfreq.val\n        t_dimensionless = t / self.time_scale\n        for key, plot in self.plots.items():\n            if self.variables[key][0][0].dimensions == 2:\n                spatial_var_name, spatial_var_value = self.spatial_variable[key]\n                for i, variable_lists in enumerate(self.variables[key]):\n                    for j, variable in enumerate(variable_lists):\n                        plot[i][j].set_ydata(\n                            variable(\n                                t_dimensionless,\n                                **{spatial_var_name: spatial_var_value},\n                                warn=False\n                            )\n                        )\n            else:\n                self.time_lines[key].set_xdata([t])\n\n        self.fig.canvas.draw_idle()",
  "def post_process_variables(variables, t_sol, u_sol, mesh=None, interp_kind=\"linear\"):\n    \"\"\"\n    Post-process all variables in a model\n\n    Parameters\n    ----------\n    variables : dict\n        Dictionary of variables\n    t_sol : array_like, size (m,)\n        The time vector returned by the solver\n    u_sol : array_like, size (m, k)\n        The solution vector returned by the solver. Can include solution values that\n        other than those that get read by base_variable.evaluate() (i.e. k>=n)\n    mesh : :class:`pybamm.Mesh`\n        The mesh used to solve, used here to calculate the reference x values for\n        interpolation\n    interp_kind : str\n        The method to use for interpolation\n\n    Returns\n    -------\n    dict\n        Dictionary of processed variables\n    \"\"\"\n    processed_variables = {}\n    known_evals = {t: {} for t in t_sol}\n    for var, eqn in variables.items():\n        pybamm.logger.debug(\"Post-processing {}\".format(var))\n        processed_variables[var] = ProcessedVariable(\n            eqn, t_sol, u_sol, mesh, interp_kind, known_evals\n        )\n\n        for t in known_evals:\n            known_evals[t].update(processed_variables[var].known_evals[t])\n    return processed_variables",
  "class ProcessedVariable(object):\n    \"\"\"\n    An object that can be evaluated at arbitrary (scalars or vectors) t and x, and\n    returns the (interpolated) value of the base variable at that t and x.\n\n    Parameters\n    ----------\n    base_variable : :class:`pybamm.Symbol`\n        A base variable with a method `evaluate(t,y)` that returns the value of that\n        variable. Note that this can be any kind of node in the expression tree, not\n        just a :class:`pybamm.Variable`.\n        When evaluated, returns an array of size (m,n)\n    t_sol : array_like, size (m,)\n        The time vector returned by the solver\n    u_sol : array_like, size (m, k)\n        The solution vector returned by the solver. Can include solution values that\n        other than those that get read by base_variable.evaluate() (i.e. k>=n)\n    mesh : :class:`pybamm.Mesh`\n        The mesh used to solve, used here to calculate the reference x values for\n        interpolation\n    interp_kind : str\n        The method to use for interpolation\n    \"\"\"\n\n    def __init__(\n        self,\n        base_variable,\n        t_sol,\n        u_sol,\n        mesh=None,\n        interp_kind=\"linear\",\n        known_evals=None,\n    ):\n        self.base_variable = base_variable\n        self.t_sol = t_sol\n        self.u_sol = u_sol\n        self.mesh = mesh\n        self.interp_kind = interp_kind\n        self.domain = base_variable.domain\n        self.auxiliary_domains = base_variable.auxiliary_domains\n        self.known_evals = known_evals\n\n        if self.known_evals:\n            self.base_eval, self.known_evals[t_sol[0]] = base_variable.evaluate(\n                t_sol[0], u_sol[:, 0], self.known_evals[t_sol[0]]\n            )\n        else:\n            self.base_eval = base_variable.evaluate(t_sol[0], u_sol[:, 0])\n\n        # handle 2D (in space) finite element variables differently\n        if (\n            mesh\n            and \"current collector\" in self.domain\n            and isinstance(self.mesh[self.domain[0]][0], pybamm.ScikitSubMesh2D)\n        ):\n            if len(self.t_sol) == 1:\n                # space only (steady solution)\n                self.initialise_2Dspace_scikit_fem()\n            else:\n                self.initialise_3D_scikit_fem()\n\n        # check variable shape\n        elif (\n            isinstance(self.base_eval, numbers.Number)\n            or len(self.base_eval.shape) == 0\n            or self.base_eval.shape[0] == 1\n        ):\n            self.initialise_1D()\n        else:\n            n = self.mesh.combine_submeshes(*self.domain)[0].npts\n            base_shape = self.base_eval.shape[0]\n            if base_shape in [n, n + 1]:\n                self.initialise_2D()\n            else:\n                self.initialise_3D()\n\n        # Remove base_variable attribute to allow pickling\n        del self.base_variable\n\n    def initialise_1D(self):\n        # initialise empty array of the correct size\n        entries = np.empty(len(self.t_sol))\n        # Evaluate the base_variable index-by-index\n        for idx in range(len(self.t_sol)):\n            t = self.t_sol[idx]\n            if self.known_evals:\n                entries[idx], self.known_evals[t] = self.base_variable.evaluate(\n                    t, self.u_sol[:, idx], self.known_evals[t]\n                )\n            else:\n                entries[idx] = self.base_variable.evaluate(t, self.u_sol[:, idx])\n\n        # No discretisation provided, or variable has no domain (function of t only)\n        self._interpolation_function = interp.interp1d(\n            self.t_sol,\n            entries,\n            kind=self.interp_kind,\n            fill_value=np.nan,\n            bounds_error=False,\n        )\n\n        self.entries = entries\n        self.dimensions = 1\n\n    def initialise_2D(self):\n        len_space = self.base_eval.shape[0]\n        entries = np.empty((len_space, len(self.t_sol)))\n\n        # Evaluate the base_variable index-by-index\n        for idx in range(len(self.t_sol)):\n            t = self.t_sol[idx]\n            u = self.u_sol[:, idx]\n            if self.known_evals:\n                eval_and_known_evals = self.base_variable.evaluate(\n                    t, u, self.known_evals[t]\n                )\n                entries[:, idx] = eval_and_known_evals[0][:, 0]\n                self.known_evals[t] = eval_and_known_evals[1]\n            else:\n                entries[:, idx] = self.base_variable.evaluate(t, u)[:, 0]\n\n        # Process the discretisation to get x values\n        nodes = self.mesh.combine_submeshes(*self.domain)[0].nodes\n        edges = self.mesh.combine_submeshes(*self.domain)[0].edges\n        if entries.shape[0] == len(nodes):\n            space = nodes\n        elif entries.shape[0] == len(edges):\n            space = edges\n\n        # add points outside domain for extrapolation to boundaries\n        extrap_space_left = np.array([2 * space[0] - space[1]])\n        extrap_space_right = np.array([2 * space[-1] - space[-2]])\n        space = np.concatenate([extrap_space_left, space, extrap_space_right])\n        extrap_entries_left = 2 * entries[0] - entries[1]\n        extrap_entries_right = 2 * entries[-1] - entries[-2]\n        entries = np.vstack([extrap_entries_left, entries, extrap_entries_right])\n\n        # assign attributes for reference (either x_sol or r_sol)\n        self.entries = entries\n        self.dimensions = 2\n        if self.domain[0] in [\"negative particle\", \"positive particle\"]:\n            self.spatial_var_name = \"r\"\n            self.r_sol = space\n        elif self.domain[0] in [\n            \"negative electrode\",\n            \"separator\",\n            \"positive electrode\",\n        ]:\n            self.spatial_var_name = \"x\"\n            self.x_sol = space\n        elif self.domain == [\"current collector\"]:\n            self.spatial_var_name = \"z\"\n            self.z_sol = space\n        else:\n            self.spatial_var_name = \"x\"\n            self.x_sol = space\n\n        # set up interpolation\n        # note that the order of 't' and 'space' is the reverse of what you'd expect\n\n        self._interpolation_function = interp.interp2d(\n            self.t_sol, space, entries, kind=self.interp_kind, fill_value=np.nan\n        )\n\n    def initialise_3D(self):\n        \"\"\"\n        Initialise a 3D object that depends on x and r, or x and z.\n        Needs to be generalised to deal with other domains.\n\n        Notes\n        -----\n        There is different behaviour between a variable on an electrode domain\n        broadcast to a particle (such as temperature) and a variable on a particle\n        domain broadcast to an electrode (such as particle concentration). We deal with\n        this by reshaping the former with the Fortran order (\"F\") and the latter with\n        the C order (\"C\"). These are transposes of each other, so this approach simply\n        avoids having to transpose later.\n        \"\"\"\n        # Dealt with weird particle/electrode case\n        if self.domain in [\n            [\"negative electrode\"],\n            [\"positive electrode\"],\n        ] and self.auxiliary_domains[\"secondary\"] in [\n            [\"negative particle\"],\n            [\"positive particle\"],\n        ]:\n            # Switch domain and auxiliary domains and set order to Fortran order (\"F\")\n            dom = self.domain\n            self.domain = self.auxiliary_domains[\"secondary\"]\n            self.auxiliary_domains[\"secondary\"] = dom\n            order = \"F\"\n        else:\n            # Set order to C order (\"C\")\n            order = \"C\"\n\n        # Process x-r or x-z\n        if self.domain == [\"negative particle\"] and self.auxiliary_domains[\n            \"secondary\"\n        ] == [\"negative electrode\"]:\n            x_sol = self.mesh[\"negative electrode\"][0].nodes\n            r_nodes = self.mesh[\"negative particle\"][0].nodes\n            r_edges = self.mesh[\"negative particle\"][0].edges\n            set_up_r = True\n        elif self.domain == [\"positive particle\"] and self.auxiliary_domains[\n            \"secondary\"\n        ] == [\"positive electrode\"]:\n            x_sol = self.mesh[\"positive electrode\"][0].nodes\n            r_nodes = self.mesh[\"positive particle\"][0].nodes\n            r_edges = self.mesh[\"positive particle\"][0].edges\n            set_up_r = True\n        elif self.domain[0] in [\n            \"negative electrode\",\n            \"separator\",\n            \"positive electrode\",\n        ] and self.auxiliary_domains[\"secondary\"] == [\"current collector\"]:\n            x_nodes = self.mesh.combine_submeshes(*self.domain)[0].nodes\n            x_edges = self.mesh.combine_submeshes(*self.domain)[0].edges\n            z_sol = self.mesh[\"current collector\"][0].nodes\n            r_sol = None\n            self.first_dimension = \"x\"\n            self.second_dimension = \"z\"\n\n            if self.base_eval.size // len(z_sol) == len(x_nodes):\n                x_sol = x_nodes\n            elif self.base_eval.size // len(z_sol) == len(x_edges):\n                x_sol = x_edges\n            first_dim_nodes = x_sol\n            second_dim_nodes = z_sol\n            set_up_r = False\n        else:\n            raise pybamm.DomainError(\n                \"\"\" Cannot process 3D object with domain '{}'\n                and auxiliary_domains '{}'\"\"\".format(\n                    self.domain, self.auxiliary_domains\n                )\n            )\n        if set_up_r:\n            z_sol = None\n            self.first_dimension = \"x\"\n            self.second_dimension = \"r\"\n            if self.base_eval.size // len(x_sol) == len(r_nodes):\n                r_sol = r_nodes\n            elif self.base_eval.size // len(x_sol) == len(r_edges):\n                r_sol = r_edges\n            first_dim_nodes = x_sol\n            second_dim_nodes = r_sol\n\n        first_dim_size = len(first_dim_nodes)\n        second_dim_size = len(second_dim_nodes)\n        entries = np.empty((first_dim_size, second_dim_size, len(self.t_sol)))\n\n        # Evaluate the base_variable index-by-index\n        for idx in range(len(self.t_sol)):\n            t = self.t_sol[idx]\n            u = self.u_sol[:, idx]\n            if self.known_evals:\n                eval_and_known_evals = self.base_variable.evaluate(\n                    t, u, self.known_evals[t]\n                )\n                entries[:, :, idx] = np.reshape(\n                    eval_and_known_evals[0],\n                    [first_dim_size, second_dim_size],\n                    order=order,\n                )\n                self.known_evals[t] = eval_and_known_evals[1]\n            else:\n                entries[:, :, idx] = np.reshape(\n                    self.base_variable.evaluate(t, u),\n                    [first_dim_size, second_dim_size],\n                    order=order,\n                )\n\n        # assign attributes for reference\n        self.entries = entries\n        self.dimensions = 3\n        self.x_sol = x_sol\n        self.r_sol = r_sol\n        self.z_sol = z_sol\n\n        # set up interpolation\n        self._interpolation_function = interp.RegularGridInterpolator(\n            (first_dim_nodes, second_dim_nodes, self.t_sol),\n            entries,\n            method=self.interp_kind,\n            fill_value=np.nan,\n        )\n\n    def initialise_2Dspace_scikit_fem(self):\n        y_sol = self.mesh[self.domain[0]][0].edges[\"y\"]\n        len_y = len(y_sol)\n        z_sol = self.mesh[self.domain[0]][0].edges[\"z\"]\n        len_z = len(z_sol)\n\n        # Evaluate the base_variable\n        entries = np.reshape(self.base_variable.evaluate(0, self.u_sol), [len_y, len_z])\n\n        # assign attributes for reference\n        self.entries = entries\n        self.dimensions = 2\n        self.y_sol = y_sol\n        self.z_sol = z_sol\n        self.first_dimension = \"y\"\n        self.second_dimension = \"z\"\n\n        # set up interpolation\n        self._interpolation_function = interp.interp2d(\n            y_sol, z_sol, entries, kind=self.interp_kind, fill_value=np.nan\n        )\n\n    def initialise_3D_scikit_fem(self):\n        y_sol = self.mesh[self.domain[0]][0].edges[\"y\"]\n        len_y = len(y_sol)\n        z_sol = self.mesh[self.domain[0]][0].edges[\"z\"]\n        len_z = len(z_sol)\n        entries = np.empty((len_y, len_z, len(self.t_sol)))\n\n        # Evaluate the base_variable index-by-index\n        for idx in range(len(self.t_sol)):\n            t = self.t_sol[idx]\n            u = self.u_sol[:, idx]\n            if self.known_evals:\n                eval_and_known_evals = self.base_variable.evaluate(\n                    t, u, self.known_evals[t]\n                )\n                entries[:, :, idx] = np.reshape(eval_and_known_evals[0], [len_y, len_z])\n                self.known_evals[t] = eval_and_known_evals[1]\n            else:\n                entries[:, :, idx] = np.reshape(\n                    self.base_variable.evaluate(t, u), [len_y, len_z]\n                )\n\n        # assign attributes for reference\n        self.entries = entries\n        self.dimensions = 3\n        self.y_sol = y_sol\n        self.z_sol = z_sol\n        self.first_dimension = \"y\"\n        self.second_dimension = \"z\"\n\n        # set up interpolation\n        self._interpolation_function = interp.RegularGridInterpolator(\n            (y_sol, z_sol, self.t_sol),\n            entries,\n            method=self.interp_kind,\n            fill_value=np.nan,\n        )\n\n    def __call__(self, t=None, x=None, r=None, y=None, z=None, warn=True):\n        \"\"\"\n        Evaluate the variable at arbitrary t (and x, r, y and/or z), using interpolation\n        \"\"\"\n        if self.dimensions == 1:\n            out = self._interpolation_function(t)\n        elif self.dimensions == 2:\n            if t is None:\n                out = self._interpolation_function(y, z)\n            else:\n                out = self.call_2D(t, x, r, z)\n        elif self.dimensions == 3:\n            out = self.call_3D(t, x, r, y, z)\n        if warn is True and np.isnan(out).any():\n            pybamm.logger.warning(\n                \"Calling variable outside interpolation range (returns 'nan')\"\n            )\n        return out\n\n    def call_2D(self, t, x, r, z):\n        \"Evaluate a 2D variable\"\n        spatial_var = eval_dimension_name(self.spatial_var_name, x, r, None, z)\n        return self._interpolation_function(t, spatial_var)\n\n    def call_3D(self, t, x, r, y, z):\n        \"Evaluate a 3D variable\"\n        first_dim = eval_dimension_name(self.first_dimension, x, r, y, z)\n        second_dim = eval_dimension_name(self.second_dimension, x, r, y, z)\n        if isinstance(first_dim, np.ndarray):\n            if isinstance(second_dim, np.ndarray) and isinstance(t, np.ndarray):\n                first_dim = first_dim[:, np.newaxis, np.newaxis]\n                second_dim = second_dim[:, np.newaxis]\n            elif isinstance(second_dim, np.ndarray) or isinstance(t, np.ndarray):\n                first_dim = first_dim[:, np.newaxis]\n        else:\n            if isinstance(second_dim, np.ndarray) and isinstance(t, np.ndarray):\n                second_dim = second_dim[:, np.newaxis]\n\n        return self._interpolation_function((first_dim, second_dim, t))",
  "def eval_dimension_name(name, x, r, y, z):\n    if name == \"x\":\n        out = x\n    elif name == \"r\":\n        out = r\n    elif name == \"y\":\n        out = y\n    elif name == \"z\":\n        out = z\n\n    if out is None:\n        raise ValueError(\"inputs {} cannot be None\".format(name))\n    else:\n        return out",
  "def __init__(\n        self,\n        base_variable,\n        t_sol,\n        u_sol,\n        mesh=None,\n        interp_kind=\"linear\",\n        known_evals=None,\n    ):\n        self.base_variable = base_variable\n        self.t_sol = t_sol\n        self.u_sol = u_sol\n        self.mesh = mesh\n        self.interp_kind = interp_kind\n        self.domain = base_variable.domain\n        self.auxiliary_domains = base_variable.auxiliary_domains\n        self.known_evals = known_evals\n\n        if self.known_evals:\n            self.base_eval, self.known_evals[t_sol[0]] = base_variable.evaluate(\n                t_sol[0], u_sol[:, 0], self.known_evals[t_sol[0]]\n            )\n        else:\n            self.base_eval = base_variable.evaluate(t_sol[0], u_sol[:, 0])\n\n        # handle 2D (in space) finite element variables differently\n        if (\n            mesh\n            and \"current collector\" in self.domain\n            and isinstance(self.mesh[self.domain[0]][0], pybamm.ScikitSubMesh2D)\n        ):\n            if len(self.t_sol) == 1:\n                # space only (steady solution)\n                self.initialise_2Dspace_scikit_fem()\n            else:\n                self.initialise_3D_scikit_fem()\n\n        # check variable shape\n        elif (\n            isinstance(self.base_eval, numbers.Number)\n            or len(self.base_eval.shape) == 0\n            or self.base_eval.shape[0] == 1\n        ):\n            self.initialise_1D()\n        else:\n            n = self.mesh.combine_submeshes(*self.domain)[0].npts\n            base_shape = self.base_eval.shape[0]\n            if base_shape in [n, n + 1]:\n                self.initialise_2D()\n            else:\n                self.initialise_3D()\n\n        # Remove base_variable attribute to allow pickling\n        del self.base_variable",
  "def initialise_1D(self):\n        # initialise empty array of the correct size\n        entries = np.empty(len(self.t_sol))\n        # Evaluate the base_variable index-by-index\n        for idx in range(len(self.t_sol)):\n            t = self.t_sol[idx]\n            if self.known_evals:\n                entries[idx], self.known_evals[t] = self.base_variable.evaluate(\n                    t, self.u_sol[:, idx], self.known_evals[t]\n                )\n            else:\n                entries[idx] = self.base_variable.evaluate(t, self.u_sol[:, idx])\n\n        # No discretisation provided, or variable has no domain (function of t only)\n        self._interpolation_function = interp.interp1d(\n            self.t_sol,\n            entries,\n            kind=self.interp_kind,\n            fill_value=np.nan,\n            bounds_error=False,\n        )\n\n        self.entries = entries\n        self.dimensions = 1",
  "def initialise_2D(self):\n        len_space = self.base_eval.shape[0]\n        entries = np.empty((len_space, len(self.t_sol)))\n\n        # Evaluate the base_variable index-by-index\n        for idx in range(len(self.t_sol)):\n            t = self.t_sol[idx]\n            u = self.u_sol[:, idx]\n            if self.known_evals:\n                eval_and_known_evals = self.base_variable.evaluate(\n                    t, u, self.known_evals[t]\n                )\n                entries[:, idx] = eval_and_known_evals[0][:, 0]\n                self.known_evals[t] = eval_and_known_evals[1]\n            else:\n                entries[:, idx] = self.base_variable.evaluate(t, u)[:, 0]\n\n        # Process the discretisation to get x values\n        nodes = self.mesh.combine_submeshes(*self.domain)[0].nodes\n        edges = self.mesh.combine_submeshes(*self.domain)[0].edges\n        if entries.shape[0] == len(nodes):\n            space = nodes\n        elif entries.shape[0] == len(edges):\n            space = edges\n\n        # add points outside domain for extrapolation to boundaries\n        extrap_space_left = np.array([2 * space[0] - space[1]])\n        extrap_space_right = np.array([2 * space[-1] - space[-2]])\n        space = np.concatenate([extrap_space_left, space, extrap_space_right])\n        extrap_entries_left = 2 * entries[0] - entries[1]\n        extrap_entries_right = 2 * entries[-1] - entries[-2]\n        entries = np.vstack([extrap_entries_left, entries, extrap_entries_right])\n\n        # assign attributes for reference (either x_sol or r_sol)\n        self.entries = entries\n        self.dimensions = 2\n        if self.domain[0] in [\"negative particle\", \"positive particle\"]:\n            self.spatial_var_name = \"r\"\n            self.r_sol = space\n        elif self.domain[0] in [\n            \"negative electrode\",\n            \"separator\",\n            \"positive electrode\",\n        ]:\n            self.spatial_var_name = \"x\"\n            self.x_sol = space\n        elif self.domain == [\"current collector\"]:\n            self.spatial_var_name = \"z\"\n            self.z_sol = space\n        else:\n            self.spatial_var_name = \"x\"\n            self.x_sol = space\n\n        # set up interpolation\n        # note that the order of 't' and 'space' is the reverse of what you'd expect\n\n        self._interpolation_function = interp.interp2d(\n            self.t_sol, space, entries, kind=self.interp_kind, fill_value=np.nan\n        )",
  "def initialise_3D(self):\n        \"\"\"\n        Initialise a 3D object that depends on x and r, or x and z.\n        Needs to be generalised to deal with other domains.\n\n        Notes\n        -----\n        There is different behaviour between a variable on an electrode domain\n        broadcast to a particle (such as temperature) and a variable on a particle\n        domain broadcast to an electrode (such as particle concentration). We deal with\n        this by reshaping the former with the Fortran order (\"F\") and the latter with\n        the C order (\"C\"). These are transposes of each other, so this approach simply\n        avoids having to transpose later.\n        \"\"\"\n        # Dealt with weird particle/electrode case\n        if self.domain in [\n            [\"negative electrode\"],\n            [\"positive electrode\"],\n        ] and self.auxiliary_domains[\"secondary\"] in [\n            [\"negative particle\"],\n            [\"positive particle\"],\n        ]:\n            # Switch domain and auxiliary domains and set order to Fortran order (\"F\")\n            dom = self.domain\n            self.domain = self.auxiliary_domains[\"secondary\"]\n            self.auxiliary_domains[\"secondary\"] = dom\n            order = \"F\"\n        else:\n            # Set order to C order (\"C\")\n            order = \"C\"\n\n        # Process x-r or x-z\n        if self.domain == [\"negative particle\"] and self.auxiliary_domains[\n            \"secondary\"\n        ] == [\"negative electrode\"]:\n            x_sol = self.mesh[\"negative electrode\"][0].nodes\n            r_nodes = self.mesh[\"negative particle\"][0].nodes\n            r_edges = self.mesh[\"negative particle\"][0].edges\n            set_up_r = True\n        elif self.domain == [\"positive particle\"] and self.auxiliary_domains[\n            \"secondary\"\n        ] == [\"positive electrode\"]:\n            x_sol = self.mesh[\"positive electrode\"][0].nodes\n            r_nodes = self.mesh[\"positive particle\"][0].nodes\n            r_edges = self.mesh[\"positive particle\"][0].edges\n            set_up_r = True\n        elif self.domain[0] in [\n            \"negative electrode\",\n            \"separator\",\n            \"positive electrode\",\n        ] and self.auxiliary_domains[\"secondary\"] == [\"current collector\"]:\n            x_nodes = self.mesh.combine_submeshes(*self.domain)[0].nodes\n            x_edges = self.mesh.combine_submeshes(*self.domain)[0].edges\n            z_sol = self.mesh[\"current collector\"][0].nodes\n            r_sol = None\n            self.first_dimension = \"x\"\n            self.second_dimension = \"z\"\n\n            if self.base_eval.size // len(z_sol) == len(x_nodes):\n                x_sol = x_nodes\n            elif self.base_eval.size // len(z_sol) == len(x_edges):\n                x_sol = x_edges\n            first_dim_nodes = x_sol\n            second_dim_nodes = z_sol\n            set_up_r = False\n        else:\n            raise pybamm.DomainError(\n                \"\"\" Cannot process 3D object with domain '{}'\n                and auxiliary_domains '{}'\"\"\".format(\n                    self.domain, self.auxiliary_domains\n                )\n            )\n        if set_up_r:\n            z_sol = None\n            self.first_dimension = \"x\"\n            self.second_dimension = \"r\"\n            if self.base_eval.size // len(x_sol) == len(r_nodes):\n                r_sol = r_nodes\n            elif self.base_eval.size // len(x_sol) == len(r_edges):\n                r_sol = r_edges\n            first_dim_nodes = x_sol\n            second_dim_nodes = r_sol\n\n        first_dim_size = len(first_dim_nodes)\n        second_dim_size = len(second_dim_nodes)\n        entries = np.empty((first_dim_size, second_dim_size, len(self.t_sol)))\n\n        # Evaluate the base_variable index-by-index\n        for idx in range(len(self.t_sol)):\n            t = self.t_sol[idx]\n            u = self.u_sol[:, idx]\n            if self.known_evals:\n                eval_and_known_evals = self.base_variable.evaluate(\n                    t, u, self.known_evals[t]\n                )\n                entries[:, :, idx] = np.reshape(\n                    eval_and_known_evals[0],\n                    [first_dim_size, second_dim_size],\n                    order=order,\n                )\n                self.known_evals[t] = eval_and_known_evals[1]\n            else:\n                entries[:, :, idx] = np.reshape(\n                    self.base_variable.evaluate(t, u),\n                    [first_dim_size, second_dim_size],\n                    order=order,\n                )\n\n        # assign attributes for reference\n        self.entries = entries\n        self.dimensions = 3\n        self.x_sol = x_sol\n        self.r_sol = r_sol\n        self.z_sol = z_sol\n\n        # set up interpolation\n        self._interpolation_function = interp.RegularGridInterpolator(\n            (first_dim_nodes, second_dim_nodes, self.t_sol),\n            entries,\n            method=self.interp_kind,\n            fill_value=np.nan,\n        )",
  "def initialise_2Dspace_scikit_fem(self):\n        y_sol = self.mesh[self.domain[0]][0].edges[\"y\"]\n        len_y = len(y_sol)\n        z_sol = self.mesh[self.domain[0]][0].edges[\"z\"]\n        len_z = len(z_sol)\n\n        # Evaluate the base_variable\n        entries = np.reshape(self.base_variable.evaluate(0, self.u_sol), [len_y, len_z])\n\n        # assign attributes for reference\n        self.entries = entries\n        self.dimensions = 2\n        self.y_sol = y_sol\n        self.z_sol = z_sol\n        self.first_dimension = \"y\"\n        self.second_dimension = \"z\"\n\n        # set up interpolation\n        self._interpolation_function = interp.interp2d(\n            y_sol, z_sol, entries, kind=self.interp_kind, fill_value=np.nan\n        )",
  "def initialise_3D_scikit_fem(self):\n        y_sol = self.mesh[self.domain[0]][0].edges[\"y\"]\n        len_y = len(y_sol)\n        z_sol = self.mesh[self.domain[0]][0].edges[\"z\"]\n        len_z = len(z_sol)\n        entries = np.empty((len_y, len_z, len(self.t_sol)))\n\n        # Evaluate the base_variable index-by-index\n        for idx in range(len(self.t_sol)):\n            t = self.t_sol[idx]\n            u = self.u_sol[:, idx]\n            if self.known_evals:\n                eval_and_known_evals = self.base_variable.evaluate(\n                    t, u, self.known_evals[t]\n                )\n                entries[:, :, idx] = np.reshape(eval_and_known_evals[0], [len_y, len_z])\n                self.known_evals[t] = eval_and_known_evals[1]\n            else:\n                entries[:, :, idx] = np.reshape(\n                    self.base_variable.evaluate(t, u), [len_y, len_z]\n                )\n\n        # assign attributes for reference\n        self.entries = entries\n        self.dimensions = 3\n        self.y_sol = y_sol\n        self.z_sol = z_sol\n        self.first_dimension = \"y\"\n        self.second_dimension = \"z\"\n\n        # set up interpolation\n        self._interpolation_function = interp.RegularGridInterpolator(\n            (y_sol, z_sol, self.t_sol),\n            entries,\n            method=self.interp_kind,\n            fill_value=np.nan,\n        )",
  "def __call__(self, t=None, x=None, r=None, y=None, z=None, warn=True):\n        \"\"\"\n        Evaluate the variable at arbitrary t (and x, r, y and/or z), using interpolation\n        \"\"\"\n        if self.dimensions == 1:\n            out = self._interpolation_function(t)\n        elif self.dimensions == 2:\n            if t is None:\n                out = self._interpolation_function(y, z)\n            else:\n                out = self.call_2D(t, x, r, z)\n        elif self.dimensions == 3:\n            out = self.call_3D(t, x, r, y, z)\n        if warn is True and np.isnan(out).any():\n            pybamm.logger.warning(\n                \"Calling variable outside interpolation range (returns 'nan')\"\n            )\n        return out",
  "def call_2D(self, t, x, r, z):\n        \"Evaluate a 2D variable\"\n        spatial_var = eval_dimension_name(self.spatial_var_name, x, r, None, z)\n        return self._interpolation_function(t, spatial_var)",
  "def call_3D(self, t, x, r, y, z):\n        \"Evaluate a 3D variable\"\n        first_dim = eval_dimension_name(self.first_dimension, x, r, y, z)\n        second_dim = eval_dimension_name(self.second_dimension, x, r, y, z)\n        if isinstance(first_dim, np.ndarray):\n            if isinstance(second_dim, np.ndarray) and isinstance(t, np.ndarray):\n                first_dim = first_dim[:, np.newaxis, np.newaxis]\n                second_dim = second_dim[:, np.newaxis]\n            elif isinstance(second_dim, np.ndarray) or isinstance(t, np.ndarray):\n                first_dim = first_dim[:, np.newaxis]\n        else:\n            if isinstance(second_dim, np.ndarray) and isinstance(t, np.ndarray):\n                second_dim = second_dim[:, np.newaxis]\n\n        return self._interpolation_function((first_dim, second_dim, t))",
  "class Settings(object):\n    _debug_mode = False\n\n    @property\n    def debug_mode(self):\n        return self._debug_mode\n\n    @debug_mode.setter\n    def debug_mode(self, value):\n        assert isinstance(value, bool)\n        self._debug_mode = value",
  "def debug_mode(self):\n        return self._debug_mode",
  "def debug_mode(self, value):\n        assert isinstance(value, bool)\n        self._debug_mode = value",
  "def _load_version_int():\n    try:\n        root = os.path.abspath(os.path.dirname(__file__))\n        with open(os.path.join(root, \"version\"), \"r\") as f:\n            version = f.read().strip().split(\",\")\n        major, minor, revision = [int(x) for x in version]\n        return major, minor, revision\n    except Exception as e:\n        raise RuntimeError(\"Unable to read version number (\" + str(e) + \").\")",
  "def version(formatted=False):\n    \"\"\"\n    Returns the version number, as a 3-part integer (major, minor, revision).\n    If ``formatted=True``, it returns a string formatted version (for example\n    \"PyBaMM 1.0.0\").\n    \"\"\"\n    if formatted:\n        return \"PyBaMM \" + __version__\n    else:\n        return __version_int__",
  "class AlgebraicSolver(object):\n    \"\"\"Solve a discretised model which contains only (time independent) algebraic\n    equations using a root finding algorithm.\n    Note: this solver could be extended for quasi-static models, or models in\n    which the time derivative is manually discretised and results in a (possibly\n    nonlinear) algebaric system at each time level.\n\n    Parameters\n    ----------\n    method : str, optional\n        The method to use to solve the system (default is \"lm\")\n    tolerance : float, optional\n        The tolerance for the solver (default is 1e-6).\n    \"\"\"\n\n    def __init__(self, method=\"lm\", tol=1e-6):\n        self.method = method\n        self.tol = tol\n\n    @property\n    def method(self):\n        return self._method\n\n    @method.setter\n    def method(self, value):\n        self._method = value\n\n    @property\n    def tol(self):\n        return self._tol\n\n    @tol.setter\n    def tol(self, value):\n        self._tol = value\n\n    def solve(self, model):\n        \"\"\"Calculate the solution of the model.\n\n        Parameters\n        ----------\n        model : :class:`pybamm.BaseModel`\n            The model whose solution to calculate. Must only contain algebraic\n            equations.\n\n        \"\"\"\n        pybamm.logger.info(\"Start solving {}\".format(model.name))\n\n        # Set up\n        timer = pybamm.Timer()\n        start_time = timer.time()\n        concatenated_algebraic, jac = self.set_up(model)\n        set_up_time = timer.time() - start_time\n\n        # Create function to evaluate algebraic\n        def algebraic(y):\n            return concatenated_algebraic.evaluate(0, y, known_evals={})[0][:, 0]\n\n        # Create function to evaluate jacobian\n        if jac is not None:\n\n            def jacobian(y):\n                # Note: we only use this solver for time independent algebraic\n                # systems, so jac is arbitrarily evaluated at t=0. Also, needs\n                # to be converted from sparse to dense, so in very large\n                # algebraic models it may be best to switch use_jacobian to False\n                # by default.\n                return jac.evaluate(0, y, known_evals={})[0].toarray()\n\n        else:\n            jacobian = None\n\n        # Use \"initial conditions\" set in model as initial guess\n        y0_guess = model.concatenated_initial_conditions\n\n        # Solve\n        solve_start_time = timer.time()\n        pybamm.logger.info(\"Calling root finding algorithm\")\n        solution = self.root(algebraic, y0_guess, jacobian=jacobian)\n\n        # Assign times\n        solution.solve_time = timer.time() - solve_start_time\n        solution.total_time = timer.time() - start_time\n        solution.set_up_time = set_up_time\n\n        pybamm.logger.info(\"Finish solving {}\".format(model.name))\n        pybamm.logger.info(\n            \"Set-up time: {}, Solve time: {}, Total time: {}\".format(\n                timer.format(solution.set_up_time),\n                timer.format(solution.solve_time),\n                timer.format(solution.total_time),\n            )\n        )\n        return solution\n\n    def root(self, algebraic, y0_guess, jacobian=None):\n        \"\"\"\n        Calculate the solution of the algebraic equations through root-finding\n\n        Parameters\n        ----------\n        algebraic : method\n            Function that takes in y and returns the value of the algebraic\n            equations\n        y0_guess : array-like\n            Array of the user's guess for the solution, used to initialise\n            the root finding algorithm\n        jacobian : method, optional\n            A function that takes in t and y and returns the Jacobian. If\n            None, the solver will approximate the Jacobian if required.\n        \"\"\"\n\n        def root_fun(y0):\n            \"Evaluates algebraic using y0\"\n            out = algebraic(y0)\n            pybamm.logger.debug(\n                \"Evaluating algebraic equations, L2-norm is {}\".format(\n                    np.linalg.norm(out)\n                )\n            )\n            return out\n\n        if jacobian:\n            sol = optimize.root(\n                root_fun, y0_guess, method=self.method, tol=self.tol, jac=jacobian\n            )\n        else:\n            sol = optimize.root(root_fun, y0_guess, method=self.method, tol=self.tol)\n\n        if sol.success and np.all(sol.fun < self.tol * len(sol.x)):\n            termination = \"success\"\n            # Return solution object (no events, so pass None to t_event, y_event)\n            return pybamm.Solution([0], sol.x[:, np.newaxis], None, None, termination)\n        elif not sol.success:\n            raise pybamm.SolverError(\n                \"Could not find acceptable solution: {}\".format(sol.message)\n            )\n        else:\n            raise pybamm.SolverError(\n                \"\"\"\n                Could not find acceptable solution: solver terminated\n                successfully, but maximum solution error ({}) above tolerance ({})\n                \"\"\".format(\n                    np.max(sol.fun), self.tol * len(sol.x)\n                )\n            )\n\n    def set_up(self, model):\n        \"\"\"Unpack model, perform checks, simplify and calculate jacobian.\n\n        Parameters\n        ----------\n        model : :class:`pybamm.BaseModel`\n            The model whose solution to calculate. Must have attributes rhs and\n            initial_conditions\n\n        Returns\n        -------\n        concatenated_algebraic : :class:`pybamm.Concatenation`\n            Algebraic equations, which should evaluate to zero\n        jac : :class:`pybamm.SparseStack`\n            Jacobian matrix for the differential and algebraic equations\n\n        Raises\n        ------\n        :class:`pybamm.SolverError`\n            If the model contains any time derivatives, i.e. rhs equations (in\n            which case an ODE or DAE solver should be used instead)\n        \"\"\"\n        if len(model.rhs) > 0:\n            raise pybamm.SolverError(\n                \"\"\"Cannot use algebraic solver to solve model with time derivatives\"\"\"\n            )\n\n        # create simplified algebraic expressions\n        concatenated_algebraic = model.concatenated_algebraic\n\n        if model.use_simplify:\n            # set up simplification object, for re-use of dict\n            simp = pybamm.Simplification()\n            pybamm.logger.info(\"Simplifying algebraic\")\n            concatenated_algebraic = simp.simplify(concatenated_algebraic)\n\n        if model.use_jacobian:\n            # Create Jacobian from concatenated algebraic\n            y = pybamm.StateVector(\n                slice(0, np.size(model.concatenated_initial_conditions))\n            )\n            # set up Jacobian object, for re-use of dict\n            jacobian = pybamm.Jacobian()\n            pybamm.logger.info(\"Calculating jacobian\")\n            jac = jacobian.jac(concatenated_algebraic, y)\n            model.jacobian = jac\n            model.jacobian_algebraic = jac\n\n            if model.use_simplify:\n                pybamm.logger.info(\"Simplifying jacobian\")\n                jac = simp.simplify(jac)\n\n            if model.use_to_python:\n                pybamm.logger.info(\"Converting jacobian to python\")\n                jac = pybamm.EvaluatorPython(jac)\n\n        else:\n            jac = None\n\n        if model.use_to_python:\n            pybamm.logger.info(\"Converting algebraic to python\")\n            concatenated_algebraic = pybamm.EvaluatorPython(concatenated_algebraic)\n\n        return concatenated_algebraic, jac",
  "def __init__(self, method=\"lm\", tol=1e-6):\n        self.method = method\n        self.tol = tol",
  "def method(self):\n        return self._method",
  "def method(self, value):\n        self._method = value",
  "def tol(self):\n        return self._tol",
  "def tol(self, value):\n        self._tol = value",
  "def solve(self, model):\n        \"\"\"Calculate the solution of the model.\n\n        Parameters\n        ----------\n        model : :class:`pybamm.BaseModel`\n            The model whose solution to calculate. Must only contain algebraic\n            equations.\n\n        \"\"\"\n        pybamm.logger.info(\"Start solving {}\".format(model.name))\n\n        # Set up\n        timer = pybamm.Timer()\n        start_time = timer.time()\n        concatenated_algebraic, jac = self.set_up(model)\n        set_up_time = timer.time() - start_time\n\n        # Create function to evaluate algebraic\n        def algebraic(y):\n            return concatenated_algebraic.evaluate(0, y, known_evals={})[0][:, 0]\n\n        # Create function to evaluate jacobian\n        if jac is not None:\n\n            def jacobian(y):\n                # Note: we only use this solver for time independent algebraic\n                # systems, so jac is arbitrarily evaluated at t=0. Also, needs\n                # to be converted from sparse to dense, so in very large\n                # algebraic models it may be best to switch use_jacobian to False\n                # by default.\n                return jac.evaluate(0, y, known_evals={})[0].toarray()\n\n        else:\n            jacobian = None\n\n        # Use \"initial conditions\" set in model as initial guess\n        y0_guess = model.concatenated_initial_conditions\n\n        # Solve\n        solve_start_time = timer.time()\n        pybamm.logger.info(\"Calling root finding algorithm\")\n        solution = self.root(algebraic, y0_guess, jacobian=jacobian)\n\n        # Assign times\n        solution.solve_time = timer.time() - solve_start_time\n        solution.total_time = timer.time() - start_time\n        solution.set_up_time = set_up_time\n\n        pybamm.logger.info(\"Finish solving {}\".format(model.name))\n        pybamm.logger.info(\n            \"Set-up time: {}, Solve time: {}, Total time: {}\".format(\n                timer.format(solution.set_up_time),\n                timer.format(solution.solve_time),\n                timer.format(solution.total_time),\n            )\n        )\n        return solution",
  "def root(self, algebraic, y0_guess, jacobian=None):\n        \"\"\"\n        Calculate the solution of the algebraic equations through root-finding\n\n        Parameters\n        ----------\n        algebraic : method\n            Function that takes in y and returns the value of the algebraic\n            equations\n        y0_guess : array-like\n            Array of the user's guess for the solution, used to initialise\n            the root finding algorithm\n        jacobian : method, optional\n            A function that takes in t and y and returns the Jacobian. If\n            None, the solver will approximate the Jacobian if required.\n        \"\"\"\n\n        def root_fun(y0):\n            \"Evaluates algebraic using y0\"\n            out = algebraic(y0)\n            pybamm.logger.debug(\n                \"Evaluating algebraic equations, L2-norm is {}\".format(\n                    np.linalg.norm(out)\n                )\n            )\n            return out\n\n        if jacobian:\n            sol = optimize.root(\n                root_fun, y0_guess, method=self.method, tol=self.tol, jac=jacobian\n            )\n        else:\n            sol = optimize.root(root_fun, y0_guess, method=self.method, tol=self.tol)\n\n        if sol.success and np.all(sol.fun < self.tol * len(sol.x)):\n            termination = \"success\"\n            # Return solution object (no events, so pass None to t_event, y_event)\n            return pybamm.Solution([0], sol.x[:, np.newaxis], None, None, termination)\n        elif not sol.success:\n            raise pybamm.SolverError(\n                \"Could not find acceptable solution: {}\".format(sol.message)\n            )\n        else:\n            raise pybamm.SolverError(\n                \"\"\"\n                Could not find acceptable solution: solver terminated\n                successfully, but maximum solution error ({}) above tolerance ({})\n                \"\"\".format(\n                    np.max(sol.fun), self.tol * len(sol.x)\n                )\n            )",
  "def set_up(self, model):\n        \"\"\"Unpack model, perform checks, simplify and calculate jacobian.\n\n        Parameters\n        ----------\n        model : :class:`pybamm.BaseModel`\n            The model whose solution to calculate. Must have attributes rhs and\n            initial_conditions\n\n        Returns\n        -------\n        concatenated_algebraic : :class:`pybamm.Concatenation`\n            Algebraic equations, which should evaluate to zero\n        jac : :class:`pybamm.SparseStack`\n            Jacobian matrix for the differential and algebraic equations\n\n        Raises\n        ------\n        :class:`pybamm.SolverError`\n            If the model contains any time derivatives, i.e. rhs equations (in\n            which case an ODE or DAE solver should be used instead)\n        \"\"\"\n        if len(model.rhs) > 0:\n            raise pybamm.SolverError(\n                \"\"\"Cannot use algebraic solver to solve model with time derivatives\"\"\"\n            )\n\n        # create simplified algebraic expressions\n        concatenated_algebraic = model.concatenated_algebraic\n\n        if model.use_simplify:\n            # set up simplification object, for re-use of dict\n            simp = pybamm.Simplification()\n            pybamm.logger.info(\"Simplifying algebraic\")\n            concatenated_algebraic = simp.simplify(concatenated_algebraic)\n\n        if model.use_jacobian:\n            # Create Jacobian from concatenated algebraic\n            y = pybamm.StateVector(\n                slice(0, np.size(model.concatenated_initial_conditions))\n            )\n            # set up Jacobian object, for re-use of dict\n            jacobian = pybamm.Jacobian()\n            pybamm.logger.info(\"Calculating jacobian\")\n            jac = jacobian.jac(concatenated_algebraic, y)\n            model.jacobian = jac\n            model.jacobian_algebraic = jac\n\n            if model.use_simplify:\n                pybamm.logger.info(\"Simplifying jacobian\")\n                jac = simp.simplify(jac)\n\n            if model.use_to_python:\n                pybamm.logger.info(\"Converting jacobian to python\")\n                jac = pybamm.EvaluatorPython(jac)\n\n        else:\n            jac = None\n\n        if model.use_to_python:\n            pybamm.logger.info(\"Converting algebraic to python\")\n            concatenated_algebraic = pybamm.EvaluatorPython(concatenated_algebraic)\n\n        return concatenated_algebraic, jac",
  "def algebraic(y):\n            return concatenated_algebraic.evaluate(0, y, known_evals={})[0][:, 0]",
  "def root_fun(y0):\n            \"Evaluates algebraic using y0\"\n            out = algebraic(y0)\n            pybamm.logger.debug(\n                \"Evaluating algebraic equations, L2-norm is {}\".format(\n                    np.linalg.norm(out)\n                )\n            )\n            return out",
  "def jacobian(y):\n                # Note: we only use this solver for time independent algebraic\n                # systems, so jac is arbitrarily evaluated at t=0. Also, needs\n                # to be converted from sparse to dense, so in very large\n                # algebraic models it may be best to switch use_jacobian to False\n                # by default.\n                return jac.evaluate(0, y, known_evals={})[0].toarray()",
  "def have_scikits_odes():\n    return scikits_odes_spec is None",
  "class ScikitsOdeSolver(pybamm.OdeSolver):\n    \"\"\"Solve a discretised model, using scikits.odes.\n\n    Parameters\n    ----------\n    method : str, optional\n        The method to use in solve_ivp (default is \"BDF\")\n    rtol : float, optional\n        The relative tolerance for the solver (default is 1e-6).\n    atol : float, optional\n        The absolute tolerance for the solver (default is 1e-6).\n    linsolver : str, optional\n            Can be 'dense' (= default), 'lapackdense', 'spgmr', 'spbcgs', 'sptfqmr'\n    \"\"\"\n\n    def __init__(self, method=\"cvode\", rtol=1e-6, atol=1e-6, linsolver=\"dense\"):\n        if scikits_odes_spec is None:\n            raise ImportError(\"scikits.odes is not installed\")\n\n        super().__init__(method, rtol, atol)\n        self.linsolver = linsolver\n\n    def integrate(\n        self, derivs, y0, t_eval, events=None, mass_matrix=None, jacobian=None\n    ):\n        \"\"\"\n        Solve a model defined by dydt with initial conditions y0.\n\n        Parameters\n        ----------\n        derivs : method\n            A function that takes in t and y and returns the time-derivative dydt\n        y0 : numeric type\n            The initial conditions\n        t_eval : numeric type\n            The times at which to compute the solution\n        events : method, optional\n            A function that takes in t and y and returns conditions for the solver to\n            stop\n        mass_matrix : array_like, optional\n            The (sparse) mass matrix for the chosen spatial method.\n        jacobian : method, optional\n            A function that takes in t and y and returns the Jacobian. If\n            None, the solver will approximate the Jacobian.\n            (see `SUNDIALS docs. <https://computation.llnl.gov/projects/sundials>`).\n\n        \"\"\"\n\n        def eqsydot(t, y, return_ydot):\n            return_ydot[:] = derivs(t, y)\n\n        def rootfn(t, y, return_root):\n            return_root[:] = [event(t, y) for event in events]\n\n        if jacobian:\n            jac_y0_t0 = jacobian(t_eval[0], y0)\n            if sparse.issparse(jac_y0_t0):\n\n                def jacfn(t, y, fy, J):\n                    J[:][:] = jacobian(t, y).toarray()\n\n                def jac_times_vecfn(v, Jv, t, y, userdata):\n                    Jv[:] = userdata._jac_eval * v\n                    return 0\n\n            else:\n\n                def jacfn(t, y, fy, J):\n                    J[:][:] = jacobian(t, y)\n\n                def jac_times_vecfn(v, Jv, t, y, userdata):\n                    Jv[:] = np.matmul(userdata._jac_eval, v)\n                    return 0\n\n            def jac_times_setupfn(t, y, fy, userdata):\n                userdata._jac_eval = jacobian(t, y)\n                return 0\n\n        extra_options = {\n            \"old_api\": False,\n            \"rtol\": self.rtol,\n            \"atol\": self.atol,\n            \"linsolver\": self.linsolver,\n        }\n\n        if jacobian:\n            if self.linsolver in (\"dense\", \"lapackdense\"):\n                extra_options.update({\"jacfn\": jacfn})\n            elif self.linsolver in (\"spgmr\", \"spbcgs\", \"sptfqmr\"):\n                extra_options.update(\n                    {\n                        \"jac_times_setupfn\": jac_times_setupfn,\n                        \"jac_times_vecfn\": jac_times_vecfn,\n                        \"user_data\": self,\n                    }\n                )\n\n        if events:\n            extra_options.update({\"rootfn\": rootfn, \"nr_rootfns\": len(events)})\n\n        ode_solver = scikits_odes.ode(self.method, eqsydot, **extra_options)\n        sol = ode_solver.solve(t_eval, y0)\n\n        # return solution, we need to tranpose y to match scipy's ivp interface\n        if sol.flag in [0, 2]:\n            # 0 = solved for all t_eval\n            if sol.flag == 0:\n                termination = \"final time\"\n            # 2 = found root(s)\n            elif sol.flag == 2:\n                termination = \"event\"\n            return pybamm.Solution(\n                sol.values.t,\n                np.transpose(sol.values.y),\n                sol.roots.t,\n                np.transpose(sol.roots.y),\n                termination,\n            )\n        else:\n            raise pybamm.SolverError(sol.message)",
  "def __init__(self, method=\"cvode\", rtol=1e-6, atol=1e-6, linsolver=\"dense\"):\n        if scikits_odes_spec is None:\n            raise ImportError(\"scikits.odes is not installed\")\n\n        super().__init__(method, rtol, atol)\n        self.linsolver = linsolver",
  "def integrate(\n        self, derivs, y0, t_eval, events=None, mass_matrix=None, jacobian=None\n    ):\n        \"\"\"\n        Solve a model defined by dydt with initial conditions y0.\n\n        Parameters\n        ----------\n        derivs : method\n            A function that takes in t and y and returns the time-derivative dydt\n        y0 : numeric type\n            The initial conditions\n        t_eval : numeric type\n            The times at which to compute the solution\n        events : method, optional\n            A function that takes in t and y and returns conditions for the solver to\n            stop\n        mass_matrix : array_like, optional\n            The (sparse) mass matrix for the chosen spatial method.\n        jacobian : method, optional\n            A function that takes in t and y and returns the Jacobian. If\n            None, the solver will approximate the Jacobian.\n            (see `SUNDIALS docs. <https://computation.llnl.gov/projects/sundials>`).\n\n        \"\"\"\n\n        def eqsydot(t, y, return_ydot):\n            return_ydot[:] = derivs(t, y)\n\n        def rootfn(t, y, return_root):\n            return_root[:] = [event(t, y) for event in events]\n\n        if jacobian:\n            jac_y0_t0 = jacobian(t_eval[0], y0)\n            if sparse.issparse(jac_y0_t0):\n\n                def jacfn(t, y, fy, J):\n                    J[:][:] = jacobian(t, y).toarray()\n\n                def jac_times_vecfn(v, Jv, t, y, userdata):\n                    Jv[:] = userdata._jac_eval * v\n                    return 0\n\n            else:\n\n                def jacfn(t, y, fy, J):\n                    J[:][:] = jacobian(t, y)\n\n                def jac_times_vecfn(v, Jv, t, y, userdata):\n                    Jv[:] = np.matmul(userdata._jac_eval, v)\n                    return 0\n\n            def jac_times_setupfn(t, y, fy, userdata):\n                userdata._jac_eval = jacobian(t, y)\n                return 0\n\n        extra_options = {\n            \"old_api\": False,\n            \"rtol\": self.rtol,\n            \"atol\": self.atol,\n            \"linsolver\": self.linsolver,\n        }\n\n        if jacobian:\n            if self.linsolver in (\"dense\", \"lapackdense\"):\n                extra_options.update({\"jacfn\": jacfn})\n            elif self.linsolver in (\"spgmr\", \"spbcgs\", \"sptfqmr\"):\n                extra_options.update(\n                    {\n                        \"jac_times_setupfn\": jac_times_setupfn,\n                        \"jac_times_vecfn\": jac_times_vecfn,\n                        \"user_data\": self,\n                    }\n                )\n\n        if events:\n            extra_options.update({\"rootfn\": rootfn, \"nr_rootfns\": len(events)})\n\n        ode_solver = scikits_odes.ode(self.method, eqsydot, **extra_options)\n        sol = ode_solver.solve(t_eval, y0)\n\n        # return solution, we need to tranpose y to match scipy's ivp interface\n        if sol.flag in [0, 2]:\n            # 0 = solved for all t_eval\n            if sol.flag == 0:\n                termination = \"final time\"\n            # 2 = found root(s)\n            elif sol.flag == 2:\n                termination = \"event\"\n            return pybamm.Solution(\n                sol.values.t,\n                np.transpose(sol.values.y),\n                sol.roots.t,\n                np.transpose(sol.roots.y),\n                termination,\n            )\n        else:\n            raise pybamm.SolverError(sol.message)",
  "def eqsydot(t, y, return_ydot):\n            return_ydot[:] = derivs(t, y)",
  "def rootfn(t, y, return_root):\n            return_root[:] = [event(t, y) for event in events]",
  "def jac_times_setupfn(t, y, fy, userdata):\n                userdata._jac_eval = jacobian(t, y)\n                return 0",
  "def jacfn(t, y, fy, J):\n                    J[:][:] = jacobian(t, y).toarray()",
  "def jac_times_vecfn(v, Jv, t, y, userdata):\n                    Jv[:] = userdata._jac_eval * v\n                    return 0",
  "def jacfn(t, y, fy, J):\n                    J[:][:] = jacobian(t, y)",
  "def jac_times_vecfn(v, Jv, t, y, userdata):\n                    Jv[:] = np.matmul(userdata._jac_eval, v)\n                    return 0",
  "def have_idaklu():\n    return idaklu_spec is None",
  "class IDAKLU(pybamm.DaeSolver):\n    \"\"\"Solve a discretised model, using sundials with the KLU sparse linear solver.\n\n     Parameters\n    ----------\n    rtol : float, optional\n        The relative tolerance for the solver (default is 1e-6).\n    atol : float, optional\n        The absolute tolerance for the solver (default is 1e-6).\n    root_method : str, optional\n        The method to use to find initial conditions (default is \"lm\")\n    root_tol : float, optional\n        The tolerance for the initial-condition solver (default is 1e-8).\n    max_steps: int, optional\n        The maximum number of steps the solver will take before terminating\n        (default is 1000).\n    \"\"\"\n\n    def __init__(\n        self, rtol=1e-6, atol=1e-6, root_method=\"lm\", root_tol=1e-6, max_steps=1000\n    ):\n\n        if idaklu_spec is None:\n            raise ImportError(\"KLU is not installed\")\n\n        super().__init__(\"ida\", rtol, atol, root_method, root_tol, max_steps)\n\n    def integrate(self, residuals, y0, t_eval, events, mass_matrix, jacobian):\n        \"\"\"\n        Solve a DAE model defined by residuals with initial conditions y0.\n\n        Parameters\n        ----------\n        residuals : method\n            A function that takes in t, y and ydot and returns the residuals of the\n            equations\n        y0 : numeric type\n            The initial conditions\n        t_eval : numeric type\n            The times at which to compute the solution\n        events : method,\n            A function that takes in t and y and returns conditions for the solver to\n            stop\n        mass_matrix : array_like,\n            The (sparse) mass matrix for the chosen spatial method.\n        jacobian : method,\n            A function that takes in t and y and returns the Jacobian. If\n            None, the solver will approximate the Jacobian.\n            (see `SUNDIALS docs. <https://computation.llnl.gov/projects/sundials>`).\n        \"\"\"\n\n        if jacobian is None:\n            pybamm.SolverError(\"KLU requires the Jacobian to be provided\")\n\n        if events is None:\n            pybamm.SolverError(\"KLU requires events to be provided\")\n\n        rtol = self._rtol\n        atol = self._atol\n\n        if jacobian:\n            jac_y0_t0 = jacobian(t_eval[0], y0)\n            if sparse.issparse(jac_y0_t0):\n\n                def jacfn(t, y, cj):\n                    j = jacobian(t, y) - cj * mass_matrix\n                    return j\n\n            else:\n\n                def jacfn(t, y, cj):\n                    jac_eval = jacobian(t, y) - cj * mass_matrix\n                    return sparse.csr_matrix(jac_eval)\n\n        class SundialsJacobian:\n            def __init__(self):\n                self.J = None\n\n                random = np.random.random(size=y0.size)\n                J = jacfn(10, random, 20)\n                self.nnz = J.nnz  # hoping nnz remains constant...\n\n            def jac_res(self, t, y, cj):\n                # must be of form j_res = (dr/dy) - (cj) (dr/dy')\n                # cj is just the input parameter\n                # see p68 of the ida_guide.pdf for more details\n                self.J = jacfn(t, y, cj)\n\n            def get_jac_data(self):\n                return self.J.data\n\n            def get_jac_row_vals(self):\n                return self.J.indices\n\n            def get_jac_col_ptrs(self):\n                return self.J.indptr\n\n        # solver works with ydot0 set to zero\n        ydot0 = np.zeros_like(y0)\n\n        jac_class = SundialsJacobian()\n\n        num_of_events = len(events)\n        use_jac = 1\n\n        def rootfn(t, y):\n            return_root = np.ones((num_of_events,))\n            return_root[:] = [event(t, y) for event in events]\n\n            return return_root\n\n        # get ids of rhs and algebraic variables\n        rhs_ids = np.ones(self.rhs(0, y0).shape)\n        alg_ids = np.zeros(self.algebraic(0, y0).shape)\n        ids = np.concatenate((rhs_ids, alg_ids))\n\n        # solve\n        sol = idaklu.solve(\n            t_eval,\n            y0,\n            ydot0,\n            self.residuals,\n            jac_class.jac_res,\n            jac_class.get_jac_data,\n            jac_class.get_jac_row_vals,\n            jac_class.get_jac_col_ptrs,\n            jac_class.nnz,\n            rootfn,\n            num_of_events,\n            use_jac,\n            ids,\n            rtol,\n            atol,\n        )\n\n        t = sol.t\n        number_of_timesteps = t.size\n        number_of_states = y0.size\n        y_out = sol.y.reshape((number_of_timesteps, number_of_states))\n\n        # return solution, we need to tranpose y to match scipy's interface\n        if sol.flag in [0, 2]:\n            # 0 = solved for all t_eval\n            if sol.flag == 0:\n                termination = \"final time\"\n            # 2 = found root(s)\n            elif sol.flag == 2:\n                termination = \"event\"\n            return pybamm.Solution(\n                sol.t, np.transpose(y_out), t[-1], np.transpose(y_out[-1]), termination\n            )\n        else:\n            raise pybamm.SolverError(sol.message)",
  "def __init__(\n        self, rtol=1e-6, atol=1e-6, root_method=\"lm\", root_tol=1e-6, max_steps=1000\n    ):\n\n        if idaklu_spec is None:\n            raise ImportError(\"KLU is not installed\")\n\n        super().__init__(\"ida\", rtol, atol, root_method, root_tol, max_steps)",
  "def integrate(self, residuals, y0, t_eval, events, mass_matrix, jacobian):\n        \"\"\"\n        Solve a DAE model defined by residuals with initial conditions y0.\n\n        Parameters\n        ----------\n        residuals : method\n            A function that takes in t, y and ydot and returns the residuals of the\n            equations\n        y0 : numeric type\n            The initial conditions\n        t_eval : numeric type\n            The times at which to compute the solution\n        events : method,\n            A function that takes in t and y and returns conditions for the solver to\n            stop\n        mass_matrix : array_like,\n            The (sparse) mass matrix for the chosen spatial method.\n        jacobian : method,\n            A function that takes in t and y and returns the Jacobian. If\n            None, the solver will approximate the Jacobian.\n            (see `SUNDIALS docs. <https://computation.llnl.gov/projects/sundials>`).\n        \"\"\"\n\n        if jacobian is None:\n            pybamm.SolverError(\"KLU requires the Jacobian to be provided\")\n\n        if events is None:\n            pybamm.SolverError(\"KLU requires events to be provided\")\n\n        rtol = self._rtol\n        atol = self._atol\n\n        if jacobian:\n            jac_y0_t0 = jacobian(t_eval[0], y0)\n            if sparse.issparse(jac_y0_t0):\n\n                def jacfn(t, y, cj):\n                    j = jacobian(t, y) - cj * mass_matrix\n                    return j\n\n            else:\n\n                def jacfn(t, y, cj):\n                    jac_eval = jacobian(t, y) - cj * mass_matrix\n                    return sparse.csr_matrix(jac_eval)\n\n        class SundialsJacobian:\n            def __init__(self):\n                self.J = None\n\n                random = np.random.random(size=y0.size)\n                J = jacfn(10, random, 20)\n                self.nnz = J.nnz  # hoping nnz remains constant...\n\n            def jac_res(self, t, y, cj):\n                # must be of form j_res = (dr/dy) - (cj) (dr/dy')\n                # cj is just the input parameter\n                # see p68 of the ida_guide.pdf for more details\n                self.J = jacfn(t, y, cj)\n\n            def get_jac_data(self):\n                return self.J.data\n\n            def get_jac_row_vals(self):\n                return self.J.indices\n\n            def get_jac_col_ptrs(self):\n                return self.J.indptr\n\n        # solver works with ydot0 set to zero\n        ydot0 = np.zeros_like(y0)\n\n        jac_class = SundialsJacobian()\n\n        num_of_events = len(events)\n        use_jac = 1\n\n        def rootfn(t, y):\n            return_root = np.ones((num_of_events,))\n            return_root[:] = [event(t, y) for event in events]\n\n            return return_root\n\n        # get ids of rhs and algebraic variables\n        rhs_ids = np.ones(self.rhs(0, y0).shape)\n        alg_ids = np.zeros(self.algebraic(0, y0).shape)\n        ids = np.concatenate((rhs_ids, alg_ids))\n\n        # solve\n        sol = idaklu.solve(\n            t_eval,\n            y0,\n            ydot0,\n            self.residuals,\n            jac_class.jac_res,\n            jac_class.get_jac_data,\n            jac_class.get_jac_row_vals,\n            jac_class.get_jac_col_ptrs,\n            jac_class.nnz,\n            rootfn,\n            num_of_events,\n            use_jac,\n            ids,\n            rtol,\n            atol,\n        )\n\n        t = sol.t\n        number_of_timesteps = t.size\n        number_of_states = y0.size\n        y_out = sol.y.reshape((number_of_timesteps, number_of_states))\n\n        # return solution, we need to tranpose y to match scipy's interface\n        if sol.flag in [0, 2]:\n            # 0 = solved for all t_eval\n            if sol.flag == 0:\n                termination = \"final time\"\n            # 2 = found root(s)\n            elif sol.flag == 2:\n                termination = \"event\"\n            return pybamm.Solution(\n                sol.t, np.transpose(y_out), t[-1], np.transpose(y_out[-1]), termination\n            )\n        else:\n            raise pybamm.SolverError(sol.message)",
  "class SundialsJacobian:\n            def __init__(self):\n                self.J = None\n\n                random = np.random.random(size=y0.size)\n                J = jacfn(10, random, 20)\n                self.nnz = J.nnz  # hoping nnz remains constant...\n\n            def jac_res(self, t, y, cj):\n                # must be of form j_res = (dr/dy) - (cj) (dr/dy')\n                # cj is just the input parameter\n                # see p68 of the ida_guide.pdf for more details\n                self.J = jacfn(t, y, cj)\n\n            def get_jac_data(self):\n                return self.J.data\n\n            def get_jac_row_vals(self):\n                return self.J.indices\n\n            def get_jac_col_ptrs(self):\n                return self.J.indptr",
  "def rootfn(t, y):\n            return_root = np.ones((num_of_events,))\n            return_root[:] = [event(t, y) for event in events]\n\n            return return_root",
  "def __init__(self):\n                self.J = None\n\n                random = np.random.random(size=y0.size)\n                J = jacfn(10, random, 20)\n                self.nnz = J.nnz",
  "def jac_res(self, t, y, cj):\n                # must be of form j_res = (dr/dy) - (cj) (dr/dy')\n                # cj is just the input parameter\n                # see p68 of the ida_guide.pdf for more details\n                self.J = jacfn(t, y, cj)",
  "def get_jac_data(self):\n                return self.J.data",
  "def get_jac_row_vals(self):\n                return self.J.indices",
  "def get_jac_col_ptrs(self):\n                return self.J.indptr",
  "def jacfn(t, y, cj):\n                    j = jacobian(t, y) - cj * mass_matrix\n                    return j",
  "def jacfn(t, y, cj):\n                    jac_eval = jacobian(t, y) - cj * mass_matrix\n                    return sparse.csr_matrix(jac_eval)",
  "class Solution(object):\n    \"\"\"\n    Class containing the solution of, and various attributes associated with, a PyBaMM\n    model.\n\n    Parameters\n    ----------\n    t : :class:`numpy.array`, size (n,)\n        A one-dimensional array containing the times at which the solution is evaluated\n    y : :class:`numpy.array`, size (m, n)\n        A two-dimensional array containing the values of the solution. y[i, :] is the\n        vector of solutions at time t[i].\n    t_event : :class:`numpy.array`, size (1,)\n        A zero-dimensional array containing the time at which the event happens.\n    y_event : :class:`numpy.array`, size (m,)\n        A one-dimensional array containing the value of the solution at the time when\n        the event happens.\n    termination : str\n        String to indicate why the solution terminated\n\n    \"\"\"\n\n    def __init__(self, t, y, t_event, y_event, termination):\n        self.t = t\n        self.y = y\n        self.t_event = t_event\n        self.y_event = y_event\n        self.termination = termination\n\n    @property\n    def t(self):\n        \"Times at which the solution is evaluated\"\n        return self._t\n\n    @t.setter\n    def t(self, value):\n        \"Updates the solution times\"\n        self._t = value\n\n    @property\n    def y(self):\n        \"Values of the solution\"\n        return self._y\n\n    @y.setter\n    def y(self, value):\n        \"Updates the solution values\"\n        self._y = value\n\n    @property\n    def t_event(self):\n        \"Time at which the event happens\"\n        return self._t_event\n\n    @t_event.setter\n    def t_event(self, value):\n        \"Updates the event time\"\n        self._t_event = value\n\n    @property\n    def y_event(self):\n        \"Value of the solution at the time of the event\"\n        return self._y_event\n\n    @y_event.setter\n    def y_event(self, value):\n        \"Updates the solution at the time of the event\"\n        self._y_event = value\n\n    @property\n    def termination(self):\n        \"Reason for termination\"\n        return self._termination\n\n    @termination.setter\n    def termination(self, value):\n        \"Updates the reason for termination\"\n        self._termination = value\n\n    def append(self, solution):\n        \"\"\"\n        Appends solution.t and solution.y onto self.t and self.y.\n        Note: this process removes the initial time and state of solution to avoid\n        duplicate times and states being stored (self.t[-1] is equal to solution.t[0],\n        and self.y[:, -1] is equal to solution.y[:, 0]).\n\n        \"\"\"\n        self.t = np.concatenate((self.t, solution.t[1:]))\n        self.y = np.concatenate((self.y, solution.y[:, 1:]), axis=1)",
  "def __init__(self, t, y, t_event, y_event, termination):\n        self.t = t\n        self.y = y\n        self.t_event = t_event\n        self.y_event = y_event\n        self.termination = termination",
  "def t(self):\n        \"Times at which the solution is evaluated\"\n        return self._t",
  "def t(self, value):\n        \"Updates the solution times\"\n        self._t = value",
  "def y(self):\n        \"Values of the solution\"\n        return self._y",
  "def y(self, value):\n        \"Updates the solution values\"\n        self._y = value",
  "def t_event(self):\n        \"Time at which the event happens\"\n        return self._t_event",
  "def t_event(self, value):\n        \"Updates the event time\"\n        self._t_event = value",
  "def y_event(self):\n        \"Value of the solution at the time of the event\"\n        return self._y_event",
  "def y_event(self, value):\n        \"Updates the solution at the time of the event\"\n        self._y_event = value",
  "def termination(self):\n        \"Reason for termination\"\n        return self._termination",
  "def termination(self, value):\n        \"Updates the reason for termination\"\n        self._termination = value",
  "def append(self, solution):\n        \"\"\"\n        Appends solution.t and solution.y onto self.t and self.y.\n        Note: this process removes the initial time and state of solution to avoid\n        duplicate times and states being stored (self.t[-1] is equal to solution.t[0],\n        and self.y[:, -1] is equal to solution.y[:, 0]).\n\n        \"\"\"\n        self.t = np.concatenate((self.t, solution.t[1:]))\n        self.y = np.concatenate((self.y, solution.y[:, 1:]), axis=1)",
  "class BaseSolver(object):\n    \"\"\"Solve a discretised model.\n\n    Parameters\n    ----------\n    rtol : float, optional\n        The relative tolerance for the solver (default is 1e-6).\n    atol : float, optional\n        The absolute tolerance for the solver (default is 1e-6).\n    \"\"\"\n\n    def __init__(self, method=None, rtol=1e-6, atol=1e-6):\n        self._method = method\n        self._rtol = rtol\n        self._atol = atol\n\n    @property\n    def method(self):\n        return self._method\n\n    @method.setter\n    def method(self, value):\n        self._method = value\n\n    @property\n    def rtol(self):\n        return self._rtol\n\n    @rtol.setter\n    def rtol(self, value):\n        self._rtol = value\n\n    @property\n    def atol(self):\n        return self._atol\n\n    @atol.setter\n    def atol(self, value):\n        self._atol = value\n\n    def solve(self, model, t_eval):\n        \"\"\"\n        Execute the solver setup and calculate the solution of the model at\n        specified times.\n\n        Parameters\n        ----------\n        model : :class:`pybamm.BaseModel`\n            The model whose solution to calculate. Must have attributes rhs and\n            initial_conditions\n        t_eval : numeric type\n            The times at which to compute the solution\n\n        Raises\n        ------\n        :class:`pybamm.ModelError`\n            If an empty model is passed (`model.rhs = {}` and `model.algebraic={}`)\n\n        \"\"\"\n        pybamm.logger.info(\"Start solving {}\".format(model.name))\n\n        # Make sure model isn't empty\n        if len(model.rhs) == 0 and len(model.algebraic) == 0:\n            raise pybamm.ModelError(\"Cannot solve empty model\")\n\n        # Set up\n        timer = pybamm.Timer()\n        start_time = timer.time()\n        self.set_up(model)\n        set_up_time = timer.time() - start_time\n\n        # Solve\n        solution, solve_time, termination = self.compute_solution(model, t_eval)\n\n        # Assign times\n        solution.solve_time = solve_time\n        solution.total_time = timer.time() - start_time\n        solution.set_up_time = set_up_time\n\n        pybamm.logger.info(\"Finish solving {} ({})\".format(model.name, termination))\n        pybamm.logger.info(\n            \"Set-up time: {}, Solve time: {}, Total time: {}\".format(\n                timer.format(solution.set_up_time),\n                timer.format(solution.solve_time),\n                timer.format(solution.total_time),\n            )\n        )\n        return solution\n\n    def step(self, model, dt, npts=2):\n        \"\"\"\n        Step the solution of the model forward by a given time increment. The\n        first time this method is called it executes the necessary setup by\n        calling `self.set_up(model)`.\n\n        Parameters\n        ----------\n        model : :class:`pybamm.BaseModel`\n            The model whose solution to calculate. Must have attributes rhs and\n            initial_conditions\n        dt : numeric type\n            The timestep over which to step the solution\n        npts : int, optional\n            The number of points at which the solution will be returned during\n            the step dt. default is 2 (returns the solution at t0 and t0 + dt).\n\n        Raises\n        ------\n        :class:`pybamm.ModelError`\n            If an empty model is passed (`model.rhs = {}` and `model.algebraic={}`)\n\n        \"\"\"\n        # Make sure model isn't empty\n        if len(model.rhs) == 0 and len(model.algebraic) == 0:\n            raise pybamm.ModelError(\"Cannot step empty model\")\n\n        # Set timer\n        timer = pybamm.Timer()\n\n        # Run set up on first step\n        if not hasattr(self, \"y0\"):\n            start_time = timer.time()\n            self.set_up(model)\n            self.t = 0.0\n            set_up_time = timer.time() - start_time\n        else:\n            set_up_time = None\n\n        # Step\n        pybamm.logger.info(\"Start stepping {}\".format(model.name))\n        t_eval = np.linspace(self.t, self.t + dt, npts)\n        solution, solve_time, termination = self.compute_solution(model, t_eval)\n\n        # Assign times\n        solution.solve_time = solve_time\n        if set_up_time:\n            solution.total_time = timer.time() - start_time\n            solution.set_up_time = set_up_time\n\n        # Set self.t and self.y0 to their values at the final step\n        self.t = solution.t[-1]\n        self.y0 = solution.y[:, -1]\n\n        pybamm.logger.info(\"Finish stepping {} ({})\".format(model.name, termination))\n        if set_up_time:\n            pybamm.logger.info(\n                \"Set-up time: {}, Step time: {}, Total time: {}\".format(\n                    timer.format(solution.set_up_time),\n                    timer.format(solution.solve_time),\n                    timer.format(solution.total_time),\n                )\n            )\n        else:\n            pybamm.logger.info(\n                \"Step time: {}\".format(timer.format(solution.solve_time))\n            )\n        return solution\n\n    def compute_solution(self, model, t_eval):\n        \"\"\"Calculate the solution of the model at specified times. Note: this\n        does *not* execute the solver setup.\n\n        Parameters\n        ----------\n        model : :class:`pybamm.BaseModel`\n            The model whose solution to calculate. Must have attributes rhs and\n            initial_conditions\n        t_eval : numeric type\n            The times at which to compute the solution\n\n        \"\"\"\n        raise NotImplementedError\n\n    def set_up(self, model):\n        \"\"\"Unpack model, perform checks, simplify and calculate jacobian.\n\n        Parameters\n        ----------\n        model : :class:`pybamm.BaseModel`\n            The model whose solution to calculate. Must have attributes rhs and\n            initial_conditions\n\n        Raises\n        ------\n        :class:`pybamm.SolverError`\n            If the model contains any algebraic equations (in which case a DAE solver\n            should be used instead)\n\n        \"\"\"\n        raise NotImplementedError\n\n    def get_termination_reason(self, solution, events):\n        \"\"\"\n        Identify the cause for termination. In particular, if the solver terminated\n        due to an event, (try to) pinpoint which event was responsible.\n        Note that the current approach (evaluating all the events and then finding which\n        one is smallest at the final timestep) is pretty crude, but is the easiest one\n        that works for all the different solvers.\n\n        Parameters\n        ----------\n        solution : :class:`pybamm.Solution`\n            The solution object\n        events : dict\n            Dictionary of events\n        \"\"\"\n        if solution.termination == \"final time\":\n            return \"the solver successfully reached the end of the integration interval\"\n        elif solution.termination == \"event\":\n            # Get final event value\n            final_event_values = {}\n            for name, event in events.items():\n                final_event_values[name] = abs(\n                    event.evaluate(solution.t_event, solution.y_event)\n                )\n            termination_event = min(final_event_values, key=final_event_values.get)\n            # Add the event to the solution object\n            solution.termination = \"event: {}\".format(termination_event)\n            return \"the termination event '{}' occurred\".format(termination_event)",
  "def __init__(self, method=None, rtol=1e-6, atol=1e-6):\n        self._method = method\n        self._rtol = rtol\n        self._atol = atol",
  "def method(self):\n        return self._method",
  "def method(self, value):\n        self._method = value",
  "def rtol(self):\n        return self._rtol",
  "def rtol(self, value):\n        self._rtol = value",
  "def atol(self):\n        return self._atol",
  "def atol(self, value):\n        self._atol = value",
  "def solve(self, model, t_eval):\n        \"\"\"\n        Execute the solver setup and calculate the solution of the model at\n        specified times.\n\n        Parameters\n        ----------\n        model : :class:`pybamm.BaseModel`\n            The model whose solution to calculate. Must have attributes rhs and\n            initial_conditions\n        t_eval : numeric type\n            The times at which to compute the solution\n\n        Raises\n        ------\n        :class:`pybamm.ModelError`\n            If an empty model is passed (`model.rhs = {}` and `model.algebraic={}`)\n\n        \"\"\"\n        pybamm.logger.info(\"Start solving {}\".format(model.name))\n\n        # Make sure model isn't empty\n        if len(model.rhs) == 0 and len(model.algebraic) == 0:\n            raise pybamm.ModelError(\"Cannot solve empty model\")\n\n        # Set up\n        timer = pybamm.Timer()\n        start_time = timer.time()\n        self.set_up(model)\n        set_up_time = timer.time() - start_time\n\n        # Solve\n        solution, solve_time, termination = self.compute_solution(model, t_eval)\n\n        # Assign times\n        solution.solve_time = solve_time\n        solution.total_time = timer.time() - start_time\n        solution.set_up_time = set_up_time\n\n        pybamm.logger.info(\"Finish solving {} ({})\".format(model.name, termination))\n        pybamm.logger.info(\n            \"Set-up time: {}, Solve time: {}, Total time: {}\".format(\n                timer.format(solution.set_up_time),\n                timer.format(solution.solve_time),\n                timer.format(solution.total_time),\n            )\n        )\n        return solution",
  "def step(self, model, dt, npts=2):\n        \"\"\"\n        Step the solution of the model forward by a given time increment. The\n        first time this method is called it executes the necessary setup by\n        calling `self.set_up(model)`.\n\n        Parameters\n        ----------\n        model : :class:`pybamm.BaseModel`\n            The model whose solution to calculate. Must have attributes rhs and\n            initial_conditions\n        dt : numeric type\n            The timestep over which to step the solution\n        npts : int, optional\n            The number of points at which the solution will be returned during\n            the step dt. default is 2 (returns the solution at t0 and t0 + dt).\n\n        Raises\n        ------\n        :class:`pybamm.ModelError`\n            If an empty model is passed (`model.rhs = {}` and `model.algebraic={}`)\n\n        \"\"\"\n        # Make sure model isn't empty\n        if len(model.rhs) == 0 and len(model.algebraic) == 0:\n            raise pybamm.ModelError(\"Cannot step empty model\")\n\n        # Set timer\n        timer = pybamm.Timer()\n\n        # Run set up on first step\n        if not hasattr(self, \"y0\"):\n            start_time = timer.time()\n            self.set_up(model)\n            self.t = 0.0\n            set_up_time = timer.time() - start_time\n        else:\n            set_up_time = None\n\n        # Step\n        pybamm.logger.info(\"Start stepping {}\".format(model.name))\n        t_eval = np.linspace(self.t, self.t + dt, npts)\n        solution, solve_time, termination = self.compute_solution(model, t_eval)\n\n        # Assign times\n        solution.solve_time = solve_time\n        if set_up_time:\n            solution.total_time = timer.time() - start_time\n            solution.set_up_time = set_up_time\n\n        # Set self.t and self.y0 to their values at the final step\n        self.t = solution.t[-1]\n        self.y0 = solution.y[:, -1]\n\n        pybamm.logger.info(\"Finish stepping {} ({})\".format(model.name, termination))\n        if set_up_time:\n            pybamm.logger.info(\n                \"Set-up time: {}, Step time: {}, Total time: {}\".format(\n                    timer.format(solution.set_up_time),\n                    timer.format(solution.solve_time),\n                    timer.format(solution.total_time),\n                )\n            )\n        else:\n            pybamm.logger.info(\n                \"Step time: {}\".format(timer.format(solution.solve_time))\n            )\n        return solution",
  "def compute_solution(self, model, t_eval):\n        \"\"\"Calculate the solution of the model at specified times. Note: this\n        does *not* execute the solver setup.\n\n        Parameters\n        ----------\n        model : :class:`pybamm.BaseModel`\n            The model whose solution to calculate. Must have attributes rhs and\n            initial_conditions\n        t_eval : numeric type\n            The times at which to compute the solution\n\n        \"\"\"\n        raise NotImplementedError",
  "def set_up(self, model):\n        \"\"\"Unpack model, perform checks, simplify and calculate jacobian.\n\n        Parameters\n        ----------\n        model : :class:`pybamm.BaseModel`\n            The model whose solution to calculate. Must have attributes rhs and\n            initial_conditions\n\n        Raises\n        ------\n        :class:`pybamm.SolverError`\n            If the model contains any algebraic equations (in which case a DAE solver\n            should be used instead)\n\n        \"\"\"\n        raise NotImplementedError",
  "def get_termination_reason(self, solution, events):\n        \"\"\"\n        Identify the cause for termination. In particular, if the solver terminated\n        due to an event, (try to) pinpoint which event was responsible.\n        Note that the current approach (evaluating all the events and then finding which\n        one is smallest at the final timestep) is pretty crude, but is the easiest one\n        that works for all the different solvers.\n\n        Parameters\n        ----------\n        solution : :class:`pybamm.Solution`\n            The solution object\n        events : dict\n            Dictionary of events\n        \"\"\"\n        if solution.termination == \"final time\":\n            return \"the solver successfully reached the end of the integration interval\"\n        elif solution.termination == \"event\":\n            # Get final event value\n            final_event_values = {}\n            for name, event in events.items():\n                final_event_values[name] = abs(\n                    event.evaluate(solution.t_event, solution.y_event)\n                )\n            termination_event = min(final_event_values, key=final_event_values.get)\n            # Add the event to the solution object\n            solution.termination = \"event: {}\".format(termination_event)\n            return \"the termination event '{}' occurred\".format(termination_event)",
  "class OdeSolver(pybamm.BaseSolver):\n    \"\"\"Solve a discretised model.\n\n    Parameters\n    ----------\n    rtol : float, optional\n        The relative tolerance for the solver (default is 1e-6).\n    atol : float, optional\n        The absolute tolerance for the solver (default is 1e-6).\n    \"\"\"\n\n    def __init__(self, method=None, rtol=1e-6, atol=1e-6):\n        super().__init__(method, rtol, atol)\n\n    def compute_solution(self, model, t_eval):\n        \"\"\"Calculate the solution of the model at specified times.\n\n        Parameters\n        ----------\n        model : :class:`pybamm.BaseModel`\n            The model whose solution to calculate. Must have attributes rhs and\n            initial_conditions\n        t_eval : numeric type\n            The times at which to compute the solution\n\n        \"\"\"\n        timer = pybamm.Timer()\n\n        solve_start_time = timer.time()\n        pybamm.logger.info(\"Calling ODE solver\")\n        solution = self.integrate(\n            self.dydt,\n            self.y0,\n            t_eval,\n            events=self.event_funs,\n            mass_matrix=model.mass_matrix.entries,\n            jacobian=self.jacobian,\n        )\n        solve_time = timer.time() - solve_start_time\n\n        # Identify the event that caused termination\n        termination = self.get_termination_reason(solution, self.events)\n\n        return solution, solve_time, termination\n\n    def set_up(self, model):\n        \"\"\"Unpack model, perform checks, simplify and calculate jacobian.\n\n        Parameters\n        ----------\n        model : :class:`pybamm.BaseModel`\n            The model whose solution to calculate. Must have attributes rhs and\n            initial_conditions\n\n        Raises\n        ------\n        :class:`pybamm.SolverError`\n            If the model contains any algebraic equations (in which case a DAE solver\n            should be used instead)\n\n        \"\"\"\n        # Check for algebraic equations\n        if len(model.algebraic) > 0:\n            raise pybamm.SolverError(\n                \"\"\"Cannot use ODE solver to solve model with DAEs\"\"\"\n            )\n\n        # create simplified rhs and event expressions\n        concatenated_rhs = model.concatenated_rhs\n        events = model.events\n\n        if model.use_simplify:\n            # set up simplification object, for re-use of dict\n            simp = pybamm.Simplification()\n            # create simplified rhs and event expressions\n            pybamm.logger.info(\"Simplifying RHS\")\n            concatenated_rhs = simp.simplify(concatenated_rhs)\n\n            pybamm.logger.info(\"Simplifying events\")\n            events = {name: simp.simplify(event) for name, event in events.items()}\n\n        y0 = model.concatenated_initial_conditions[:, 0]\n\n        if model.use_jacobian:\n            # Create Jacobian from concatenated rhs\n            y = pybamm.StateVector(slice(0, np.size(y0)))\n            # set up Jacobian object, for re-use of dict\n            jacobian = pybamm.Jacobian()\n            pybamm.logger.info(\"Calculating jacobian\")\n            jac_rhs = jacobian.jac(concatenated_rhs, y)\n            model.jacobian = jac_rhs\n            model.jacobian_rhs = jac_rhs\n\n            if model.use_simplify:\n                pybamm.logger.info(\"Simplifying jacobian\")\n                jac_rhs = simp.simplify(jac_rhs)\n\n            if model.use_to_python:\n                pybamm.logger.info(\"Converting jacobian to python\")\n                jac_rhs = pybamm.EvaluatorPython(jac_rhs)\n        else:\n            jac_rhs = None\n\n        if model.use_to_python:\n            pybamm.logger.info(\"Converting RHS to python\")\n            concatenated_rhs = pybamm.EvaluatorPython(concatenated_rhs)\n            pybamm.logger.info(\"Converting events to python\")\n            events = {\n                name: pybamm.EvaluatorPython(event) for name, event in events.items()\n            }\n\n        # Create function to evaluate rhs\n        def dydt(t, y):\n            pybamm.logger.debug(\"Evaluating RHS for {} at t={}\".format(model.name, t))\n            y = y[:, np.newaxis]\n            dy = concatenated_rhs.evaluate(t, y, known_evals={})[0]\n            return dy[:, 0]\n\n        # Create event-dependent function to evaluate events\n        def event_fun(event):\n            def eval_event(t, y):\n                return event.evaluate(t, y)\n\n            return eval_event\n\n        event_funs = [event_fun(event) for event in events.values()]\n\n        # Create function to evaluate jacobian\n        if jac_rhs is not None:\n\n            def jacobian(t, y):\n                return jac_rhs.evaluate(t, y, known_evals={})[0]\n\n        else:\n            jacobian = None\n\n        # Add the solver attributes\n        # Note: these are the (possibly) converted to python version rhs, algebraic\n        # etc. The expression tree versions of these are attributes of the model\n        self.y0 = y0\n        self.dydt = dydt\n        self.events = events\n        self.event_funs = event_funs\n        self.jacobian = jacobian\n\n    def integrate(\n        self, derivs, y0, t_eval, events=None, mass_matrix=None, jacobian=None\n    ):\n        \"\"\"\n        Solve a model defined by dydt with initial conditions y0.\n\n        Parameters\n        ----------\n        derivs : method\n            A function that takes in t and y and returns the time-derivative dydt\n        y0 : numeric type\n            The initial conditions\n        t_eval : numeric type\n            The times at which to compute the solution\n        events : method, optional\n            A function that takes in t and y and returns conditions for the solver to\n            stop\n        mass_matrix : array_like, optional\n            The (sparse) mass matrix for the chosen spatial method.\n        jacobian : method, optional\n            A function that takes in t and y and returns the Jacobian\n        \"\"\"\n        raise NotImplementedError",
  "def __init__(self, method=None, rtol=1e-6, atol=1e-6):\n        super().__init__(method, rtol, atol)",
  "def compute_solution(self, model, t_eval):\n        \"\"\"Calculate the solution of the model at specified times.\n\n        Parameters\n        ----------\n        model : :class:`pybamm.BaseModel`\n            The model whose solution to calculate. Must have attributes rhs and\n            initial_conditions\n        t_eval : numeric type\n            The times at which to compute the solution\n\n        \"\"\"\n        timer = pybamm.Timer()\n\n        solve_start_time = timer.time()\n        pybamm.logger.info(\"Calling ODE solver\")\n        solution = self.integrate(\n            self.dydt,\n            self.y0,\n            t_eval,\n            events=self.event_funs,\n            mass_matrix=model.mass_matrix.entries,\n            jacobian=self.jacobian,\n        )\n        solve_time = timer.time() - solve_start_time\n\n        # Identify the event that caused termination\n        termination = self.get_termination_reason(solution, self.events)\n\n        return solution, solve_time, termination",
  "def set_up(self, model):\n        \"\"\"Unpack model, perform checks, simplify and calculate jacobian.\n\n        Parameters\n        ----------\n        model : :class:`pybamm.BaseModel`\n            The model whose solution to calculate. Must have attributes rhs and\n            initial_conditions\n\n        Raises\n        ------\n        :class:`pybamm.SolverError`\n            If the model contains any algebraic equations (in which case a DAE solver\n            should be used instead)\n\n        \"\"\"\n        # Check for algebraic equations\n        if len(model.algebraic) > 0:\n            raise pybamm.SolverError(\n                \"\"\"Cannot use ODE solver to solve model with DAEs\"\"\"\n            )\n\n        # create simplified rhs and event expressions\n        concatenated_rhs = model.concatenated_rhs\n        events = model.events\n\n        if model.use_simplify:\n            # set up simplification object, for re-use of dict\n            simp = pybamm.Simplification()\n            # create simplified rhs and event expressions\n            pybamm.logger.info(\"Simplifying RHS\")\n            concatenated_rhs = simp.simplify(concatenated_rhs)\n\n            pybamm.logger.info(\"Simplifying events\")\n            events = {name: simp.simplify(event) for name, event in events.items()}\n\n        y0 = model.concatenated_initial_conditions[:, 0]\n\n        if model.use_jacobian:\n            # Create Jacobian from concatenated rhs\n            y = pybamm.StateVector(slice(0, np.size(y0)))\n            # set up Jacobian object, for re-use of dict\n            jacobian = pybamm.Jacobian()\n            pybamm.logger.info(\"Calculating jacobian\")\n            jac_rhs = jacobian.jac(concatenated_rhs, y)\n            model.jacobian = jac_rhs\n            model.jacobian_rhs = jac_rhs\n\n            if model.use_simplify:\n                pybamm.logger.info(\"Simplifying jacobian\")\n                jac_rhs = simp.simplify(jac_rhs)\n\n            if model.use_to_python:\n                pybamm.logger.info(\"Converting jacobian to python\")\n                jac_rhs = pybamm.EvaluatorPython(jac_rhs)\n        else:\n            jac_rhs = None\n\n        if model.use_to_python:\n            pybamm.logger.info(\"Converting RHS to python\")\n            concatenated_rhs = pybamm.EvaluatorPython(concatenated_rhs)\n            pybamm.logger.info(\"Converting events to python\")\n            events = {\n                name: pybamm.EvaluatorPython(event) for name, event in events.items()\n            }\n\n        # Create function to evaluate rhs\n        def dydt(t, y):\n            pybamm.logger.debug(\"Evaluating RHS for {} at t={}\".format(model.name, t))\n            y = y[:, np.newaxis]\n            dy = concatenated_rhs.evaluate(t, y, known_evals={})[0]\n            return dy[:, 0]\n\n        # Create event-dependent function to evaluate events\n        def event_fun(event):\n            def eval_event(t, y):\n                return event.evaluate(t, y)\n\n            return eval_event\n\n        event_funs = [event_fun(event) for event in events.values()]\n\n        # Create function to evaluate jacobian\n        if jac_rhs is not None:\n\n            def jacobian(t, y):\n                return jac_rhs.evaluate(t, y, known_evals={})[0]\n\n        else:\n            jacobian = None\n\n        # Add the solver attributes\n        # Note: these are the (possibly) converted to python version rhs, algebraic\n        # etc. The expression tree versions of these are attributes of the model\n        self.y0 = y0\n        self.dydt = dydt\n        self.events = events\n        self.event_funs = event_funs\n        self.jacobian = jacobian",
  "def integrate(\n        self, derivs, y0, t_eval, events=None, mass_matrix=None, jacobian=None\n    ):\n        \"\"\"\n        Solve a model defined by dydt with initial conditions y0.\n\n        Parameters\n        ----------\n        derivs : method\n            A function that takes in t and y and returns the time-derivative dydt\n        y0 : numeric type\n            The initial conditions\n        t_eval : numeric type\n            The times at which to compute the solution\n        events : method, optional\n            A function that takes in t and y and returns conditions for the solver to\n            stop\n        mass_matrix : array_like, optional\n            The (sparse) mass matrix for the chosen spatial method.\n        jacobian : method, optional\n            A function that takes in t and y and returns the Jacobian\n        \"\"\"\n        raise NotImplementedError",
  "def dydt(t, y):\n            pybamm.logger.debug(\"Evaluating RHS for {} at t={}\".format(model.name, t))\n            y = y[:, np.newaxis]\n            dy = concatenated_rhs.evaluate(t, y, known_evals={})[0]\n            return dy[:, 0]",
  "def event_fun(event):\n            def eval_event(t, y):\n                return event.evaluate(t, y)\n\n            return eval_event",
  "def eval_event(t, y):\n                return event.evaluate(t, y)",
  "def jacobian(t, y):\n                return jac_rhs.evaluate(t, y, known_evals={})[0]",
  "class ScikitsDaeSolver(pybamm.DaeSolver):\n    \"\"\"Solve a discretised model, using scikits.odes.\n\n    Parameters\n    ----------\n    method : str, optional\n        The method to use in solve_ivp (default is \"BDF\")\n    rtol : float, optional\n        The relative tolerance for the solver (default is 1e-6).\n    atol : float, optional\n        The absolute tolerance for the solver (default is 1e-6).\n    root_method : str, optional\n        The method to use to find initial conditions (default is \"lm\")\n    root_tol : float, optional\n        The tolerance for the initial-condition solver (default is 1e-6).\n    max_steps: int, optional\n        The maximum number of steps the solver will take before terminating\n        (default is 1000).\n    \"\"\"\n\n    def __init__(\n        self,\n        method=\"ida\",\n        rtol=1e-6,\n        atol=1e-6,\n        root_method=\"lm\",\n        root_tol=1e-6,\n        max_steps=1000,\n    ):\n        if scikits_odes_spec is None:\n            raise ImportError(\"scikits.odes is not installed\")\n\n        super().__init__(method, rtol, atol, root_method, root_tol, max_steps)\n\n    def integrate(\n        self, residuals, y0, t_eval, events=None, mass_matrix=None, jacobian=None\n    ):\n        \"\"\"\n        Solve a DAE model defined by residuals with initial conditions y0.\n\n        Parameters\n        ----------\n        residuals : method\n            A function that takes in t, y and ydot and returns the residuals of the\n            equations\n        y0 : numeric type\n            The initial conditions\n        t_eval : numeric type\n            The times at which to compute the solution\n        events : method, optional\n            A function that takes in t and y and returns conditions for the solver to\n            stop\n        mass_matrix : array_like, optional\n            The (sparse) mass matrix for the chosen spatial method.\n        jacobian : method, optional\n            A function that takes in t and y and returns the Jacobian. If\n            None, the solver will approximate the Jacobian.\n            (see `SUNDIALS docs. <https://computation.llnl.gov/projects/sundials>`).\n        \"\"\"\n\n        def eqsres(t, y, ydot, return_residuals):\n            return_residuals[:] = residuals(t, y, ydot)\n\n        def rootfn(t, y, ydot, return_root):\n            return_root[:] = [event(t, y) for event in events]\n\n        extra_options = {\n            \"old_api\": False,\n            \"rtol\": self.rtol,\n            \"atol\": self.atol,\n            \"max_steps\": self.max_steps,\n        }\n\n        if jacobian:\n            jac_y0_t0 = jacobian(t_eval[0], y0)\n            if sparse.issparse(jac_y0_t0):\n\n                def jacfn(t, y, ydot, residuals, cj, J):\n                    jac_eval = jacobian(t, y) - cj * mass_matrix\n                    J[:][:] = jac_eval.toarray()\n\n            else:\n\n                def jacfn(t, y, ydot, residuals, cj, J):\n                    jac_eval = jacobian(t, y) - cj * mass_matrix\n                    J[:][:] = jac_eval\n\n            extra_options.update({\"jacfn\": jacfn})\n\n        if events:\n            extra_options.update({\"rootfn\": rootfn, \"nr_rootfns\": len(events)})\n\n        # solver works with ydot0 set to zero\n        ydot0 = np.zeros_like(y0)\n\n        # set up and solve\n        dae_solver = scikits_odes.dae(self.method, eqsres, **extra_options)\n        sol = dae_solver.solve(t_eval, y0, ydot0)\n\n        # return solution, we need to tranpose y to match scipy's interface\n        if sol.flag in [0, 2]:\n            # 0 = solved for all t_eval\n            if sol.flag == 0:\n                termination = \"final time\"\n            # 2 = found root(s)\n            elif sol.flag == 2:\n                termination = \"event\"\n            return pybamm.Solution(\n                sol.values.t,\n                np.transpose(sol.values.y),\n                sol.roots.t,\n                np.transpose(sol.roots.y),\n                termination,\n            )\n        else:\n            raise pybamm.SolverError(sol.message)",
  "def __init__(\n        self,\n        method=\"ida\",\n        rtol=1e-6,\n        atol=1e-6,\n        root_method=\"lm\",\n        root_tol=1e-6,\n        max_steps=1000,\n    ):\n        if scikits_odes_spec is None:\n            raise ImportError(\"scikits.odes is not installed\")\n\n        super().__init__(method, rtol, atol, root_method, root_tol, max_steps)",
  "def integrate(\n        self, residuals, y0, t_eval, events=None, mass_matrix=None, jacobian=None\n    ):\n        \"\"\"\n        Solve a DAE model defined by residuals with initial conditions y0.\n\n        Parameters\n        ----------\n        residuals : method\n            A function that takes in t, y and ydot and returns the residuals of the\n            equations\n        y0 : numeric type\n            The initial conditions\n        t_eval : numeric type\n            The times at which to compute the solution\n        events : method, optional\n            A function that takes in t and y and returns conditions for the solver to\n            stop\n        mass_matrix : array_like, optional\n            The (sparse) mass matrix for the chosen spatial method.\n        jacobian : method, optional\n            A function that takes in t and y and returns the Jacobian. If\n            None, the solver will approximate the Jacobian.\n            (see `SUNDIALS docs. <https://computation.llnl.gov/projects/sundials>`).\n        \"\"\"\n\n        def eqsres(t, y, ydot, return_residuals):\n            return_residuals[:] = residuals(t, y, ydot)\n\n        def rootfn(t, y, ydot, return_root):\n            return_root[:] = [event(t, y) for event in events]\n\n        extra_options = {\n            \"old_api\": False,\n            \"rtol\": self.rtol,\n            \"atol\": self.atol,\n            \"max_steps\": self.max_steps,\n        }\n\n        if jacobian:\n            jac_y0_t0 = jacobian(t_eval[0], y0)\n            if sparse.issparse(jac_y0_t0):\n\n                def jacfn(t, y, ydot, residuals, cj, J):\n                    jac_eval = jacobian(t, y) - cj * mass_matrix\n                    J[:][:] = jac_eval.toarray()\n\n            else:\n\n                def jacfn(t, y, ydot, residuals, cj, J):\n                    jac_eval = jacobian(t, y) - cj * mass_matrix\n                    J[:][:] = jac_eval\n\n            extra_options.update({\"jacfn\": jacfn})\n\n        if events:\n            extra_options.update({\"rootfn\": rootfn, \"nr_rootfns\": len(events)})\n\n        # solver works with ydot0 set to zero\n        ydot0 = np.zeros_like(y0)\n\n        # set up and solve\n        dae_solver = scikits_odes.dae(self.method, eqsres, **extra_options)\n        sol = dae_solver.solve(t_eval, y0, ydot0)\n\n        # return solution, we need to tranpose y to match scipy's interface\n        if sol.flag in [0, 2]:\n            # 0 = solved for all t_eval\n            if sol.flag == 0:\n                termination = \"final time\"\n            # 2 = found root(s)\n            elif sol.flag == 2:\n                termination = \"event\"\n            return pybamm.Solution(\n                sol.values.t,\n                np.transpose(sol.values.y),\n                sol.roots.t,\n                np.transpose(sol.roots.y),\n                termination,\n            )\n        else:\n            raise pybamm.SolverError(sol.message)",
  "def eqsres(t, y, ydot, return_residuals):\n            return_residuals[:] = residuals(t, y, ydot)",
  "def rootfn(t, y, ydot, return_root):\n            return_root[:] = [event(t, y) for event in events]",
  "def jacfn(t, y, ydot, residuals, cj, J):\n                    jac_eval = jacobian(t, y) - cj * mass_matrix\n                    J[:][:] = jac_eval.toarray()",
  "def jacfn(t, y, ydot, residuals, cj, J):\n                    jac_eval = jacobian(t, y) - cj * mass_matrix\n                    J[:][:] = jac_eval",
  "class DaeSolver(pybamm.BaseSolver):\n    \"\"\"Solve a discretised model.\n\n    Parameters\n    ----------\n    rtol : float, optional\n        The relative tolerance for the solver (default is 1e-6).\n    atol : float, optional\n        The absolute tolerance for the solver (default is 1e-6).\n    root_method : str, optional\n        The method to use to find initial conditions (default is \"lm\")\n    root_tol : float, optional\n        The tolerance for the initial-condition solver (default is 1e-6).\n    max_steps: int, optional\n        The maximum number of steps the solver will take before terminating\n        (default is 1000).\n    \"\"\"\n\n    def __init__(\n        self,\n        method=None,\n        rtol=1e-6,\n        atol=1e-6,\n        root_method=\"lm\",\n        root_tol=1e-6,\n        max_steps=1000,\n    ):\n        super().__init__(method, rtol, atol)\n        self.root_method = root_method\n        self.root_tol = root_tol\n        self.max_steps = max_steps\n\n    @property\n    def root_method(self):\n        return self._root_method\n\n    @root_method.setter\n    def root_method(self, method):\n        self._root_method = method\n\n    @property\n    def root_tol(self):\n        return self._root_tol\n\n    @root_tol.setter\n    def root_tol(self, tol):\n        self._root_tol = tol\n\n    @property\n    def max_steps(self):\n        return self._max_steps\n\n    @max_steps.setter\n    def max_steps(self, max_steps):\n        self._max_steps = max_steps\n\n    def compute_solution(self, model, t_eval):\n        \"\"\"Calculate the solution of the model at specified times.\n\n        Parameters\n        ----------\n        model : :class:`pybamm.BaseModel`\n            The model whose solution to calculate. Must have attributes rhs and\n            initial_conditions\n        t_eval : numeric type\n            The times at which to compute the solution\n\n        \"\"\"\n        timer = pybamm.Timer()\n\n        solve_start_time = timer.time()\n        pybamm.logger.info(\"Calling DAE solver\")\n        solution = self.integrate(\n            self.residuals,\n            self.y0,\n            t_eval,\n            events=self.event_funs,\n            mass_matrix=model.mass_matrix.entries,\n            jacobian=self.jacobian,\n        )\n        solve_time = timer.time() - solve_start_time\n\n        # Identify the event that caused termination\n        termination = self.get_termination_reason(solution, self.events)\n\n        return solution, solve_time, termination\n\n    def set_up(self, model):\n        \"\"\"Unpack model, perform checks, simplify and calculate jacobian.\n\n        Parameters\n        ----------\n        model : :class:`pybamm.BaseModel`\n            The model whose solution to calculate. Must have attributes rhs and\n            initial_conditions\n\n        Raises\n        ------\n        :class:`pybamm.SolverError`\n            If the model contains any algebraic equations (in which case a DAE solver\n            should be used instead)\n        \"\"\"\n        # create simplified rhs, algebraic and event expressions\n        concatenated_rhs = model.concatenated_rhs\n        concatenated_algebraic = model.concatenated_algebraic\n        events = model.events\n\n        if model.use_simplify:\n            # set up simplification object, for re-use of dict\n            simp = pybamm.Simplification()\n            pybamm.logger.info(\"Simplifying RHS\")\n            concatenated_rhs = simp.simplify(concatenated_rhs)\n            pybamm.logger.info(\"Simplifying algebraic\")\n            concatenated_algebraic = simp.simplify(concatenated_algebraic)\n            pybamm.logger.info(\"Simplifying events\")\n            events = {name: simp.simplify(event) for name, event in events.items()}\n\n        if model.use_jacobian:\n            # Create Jacobian from concatenated rhs and algebraic\n            y = pybamm.StateVector(\n                slice(0, np.size(model.concatenated_initial_conditions))\n            )\n            # set up Jacobian object, for re-use of dict\n            jacobian = pybamm.Jacobian()\n            pybamm.logger.info(\"Calculating jacobian\")\n            jac_rhs = jacobian.jac(concatenated_rhs, y)\n            jac_algebraic = jacobian.jac(concatenated_algebraic, y)\n            jac = pybamm.SparseStack(jac_rhs, jac_algebraic)\n            model.jacobian = jac\n            model.jacobian_rhs = jac_rhs\n            model.jacobian_algebraic = jac_algebraic\n\n            if model.use_simplify:\n                pybamm.logger.info(\"Simplifying jacobian\")\n                jac_algebraic = simp.simplify(jac_algebraic)\n                jac = simp.simplify(jac)\n\n            if model.use_to_python:\n                pybamm.logger.info(\"Converting jacobian to python\")\n                jac_algebraic = pybamm.EvaluatorPython(jac_algebraic)\n                jac = pybamm.EvaluatorPython(jac)\n\n            def jac_alg_fn(t, y):\n                return jac_algebraic.evaluate(t, y)\n\n        else:\n            jac = None\n            jac_alg_fn = None\n\n        if model.use_to_python:\n            pybamm.logger.info(\"Converting RHS to python\")\n            concatenated_rhs = pybamm.EvaluatorPython(concatenated_rhs)\n            pybamm.logger.info(\"Converting algebraic to python\")\n            concatenated_algebraic = pybamm.EvaluatorPython(concatenated_algebraic)\n            pybamm.logger.info(\"Converting events to python\")\n            events = {\n                name: pybamm.EvaluatorPython(event) for name, event in events.items()\n            }\n\n        # Calculate consistent initial conditions for the algebraic equations\n        def rhs(t, y):\n            return concatenated_rhs.evaluate(t, y, known_evals={})[0][:, 0]\n\n        def algebraic(t, y):\n            return concatenated_algebraic.evaluate(t, y, known_evals={})[0][:, 0]\n\n        if len(model.algebraic) > 0:\n            y0 = self.calculate_consistent_initial_conditions(\n                rhs, algebraic, model.concatenated_initial_conditions[:, 0], jac_alg_fn\n            )\n        else:\n            # can use DAE solver to solve ODE model\n            y0 = model.concatenated_initial_conditions[:, 0]\n\n        # Create functions to evaluate residuals\n        def residuals(t, y, ydot):\n            pybamm.logger.debug(\n                \"Evaluating residuals for {} at t={}\".format(model.name, t)\n            )\n            y = y[:, np.newaxis]\n            rhs_eval, known_evals = concatenated_rhs.evaluate(t, y, known_evals={})\n            # reuse known_evals\n            alg_eval = concatenated_algebraic.evaluate(t, y, known_evals=known_evals)[0]\n            # turn into 1D arrays\n            rhs_eval = rhs_eval[:, 0]\n            alg_eval = alg_eval[:, 0]\n            return (\n                np.concatenate((rhs_eval, alg_eval)) - model.mass_matrix.entries @ ydot\n            )\n\n        # Create event-dependent function to evaluate events\n        def event_fun(event):\n            def eval_event(t, y):\n                return event.evaluate(t, y)\n\n            return eval_event\n\n        event_funs = [event_fun(event) for event in events.values()]\n\n        # Create function to evaluate jacobian\n        if jac is not None:\n\n            def jacobian(t, y):\n                return jac.evaluate(t, y, known_evals={})[0]\n\n        else:\n            jacobian = None\n\n        # Add the solver attributes\n        # Note: these are the (possibly) converted to python version rhs, algebraic\n        # etc. The expression tree versions of these are attributes of the model\n        self.y0 = y0\n        self.rhs = rhs\n        self.algebraic = algebraic\n        self.residuals = residuals\n        self.events = events\n        self.event_funs = event_funs\n        self.jacobian = jacobian\n\n    def calculate_consistent_initial_conditions(\n        self, rhs, algebraic, y0_guess, jac=None\n    ):\n        \"\"\"\n        Calculate consistent initial conditions for the algebraic equations through\n        root-finding\n\n        Parameters\n        ----------\n        rhs : method\n            Function that takes in t and y and returns the value of the differential\n            equations\n        algebraic : method\n            Function that takes in t and y and returns the value of the algebraic\n            equations\n        y0_guess : array-like\n            Array of the user's guess for the initial conditions, used to initialise\n            the root finding algorithm\n        jac : method\n            Function that takes in t and y and returns the value of the jacobian for the\n            algebraic equations\n\n        Returns\n        -------\n        y0_consistent : array-like, same shape as y0_guess\n            Initial conditions that are consistent with the algebraic equations (roots\n            of the algebraic equations)\n        \"\"\"\n        pybamm.logger.info(\"Start calculating consistent initial conditions\")\n\n        # Split y0_guess into differential and algebraic\n        len_rhs = rhs(0, y0_guess).shape[0]\n        y0_diff, y0_alg_guess = np.split(y0_guess, [len_rhs])\n\n        def root_fun(y0_alg):\n            \"Evaluates algebraic using y0_diff (fixed) and y0_alg (changed by algo)\"\n            y0 = np.concatenate([y0_diff, y0_alg])\n            out = algebraic(0, y0)\n            pybamm.logger.debug(\n                \"Evaluating algebraic equations at t=0, L2-norm is {}\".format(\n                    np.linalg.norm(out)\n                )\n            )\n            return out\n\n        if jac:\n            if issparse(jac(0, y0_guess)):\n\n                def jac_fn(y0_alg):\n                    \"\"\"\n                    Evaluates jacobian using y0_diff (fixed) and y0_alg (varying)\n                    \"\"\"\n                    y0 = np.concatenate([y0_diff, y0_alg])\n                    return jac(0, y0)[:, len_rhs:].toarray()\n\n            else:\n\n                def jac_fn(y0_alg):\n                    \"\"\"\n                    Evaluates jacobian using y0_diff (fixed) and y0_alg (varying)\n                    \"\"\"\n                    y0 = np.concatenate([y0_diff, y0_alg])\n                    return jac(0, y0)[:, len_rhs:]\n\n        else:\n            jac_fn = None\n        # Find the values of y0_alg that are roots of the algebraic equations\n        sol = optimize.root(\n            root_fun,\n            y0_alg_guess,\n            jac=jac_fn,\n            method=self.root_method,\n            tol=self.root_tol,\n        )\n        # Return full set of consistent initial conditions (y0_diff unchanged)\n        y0_consistent = np.concatenate([y0_diff, sol.x])\n\n        if sol.success and np.all(sol.fun < self.root_tol * len(sol.x)):\n            pybamm.logger.info(\"Finish calculating consistent initial conditions\")\n            return y0_consistent\n        elif not sol.success:\n            raise pybamm.SolverError(\n                \"Could not find consistent initial conditions: {}\".format(sol.message)\n            )\n        else:\n            raise pybamm.SolverError(\n                \"\"\"\n                Could not find consistent initial conditions: solver terminated\n                successfully, but maximum solution error ({}) above tolerance ({})\n                \"\"\".format(\n                    np.max(sol.fun), self.root_tol * len(sol.x)\n                )\n            )\n\n    def integrate(\n        self, residuals, y0, t_eval, events=None, mass_matrix=None, jacobian=None\n    ):\n        \"\"\"\n        Solve a DAE model defined by residuals with initial conditions y0.\n\n        Parameters\n        ----------\n        residuals : method\n            A function that takes in t, y and ydot and returns the residuals of the\n            equations\n        y0 : numeric type\n            The initial conditions\n        t_eval : numeric type\n            The times at which to compute the solution\n        events : method, optional\n            A function that takes in t and y and returns conditions for the solver to\n            stop\n        mass_matrix : array_like, optional\n            The (sparse) mass matrix for the chosen spatial method.\n        jacobian : method, optional\n            A function that takes in t, y and ydot and returns the Jacobian\n        \"\"\"\n        raise NotImplementedError",
  "def __init__(\n        self,\n        method=None,\n        rtol=1e-6,\n        atol=1e-6,\n        root_method=\"lm\",\n        root_tol=1e-6,\n        max_steps=1000,\n    ):\n        super().__init__(method, rtol, atol)\n        self.root_method = root_method\n        self.root_tol = root_tol\n        self.max_steps = max_steps",
  "def root_method(self):\n        return self._root_method",
  "def root_method(self, method):\n        self._root_method = method",
  "def root_tol(self):\n        return self._root_tol",
  "def root_tol(self, tol):\n        self._root_tol = tol",
  "def max_steps(self):\n        return self._max_steps",
  "def max_steps(self, max_steps):\n        self._max_steps = max_steps",
  "def compute_solution(self, model, t_eval):\n        \"\"\"Calculate the solution of the model at specified times.\n\n        Parameters\n        ----------\n        model : :class:`pybamm.BaseModel`\n            The model whose solution to calculate. Must have attributes rhs and\n            initial_conditions\n        t_eval : numeric type\n            The times at which to compute the solution\n\n        \"\"\"\n        timer = pybamm.Timer()\n\n        solve_start_time = timer.time()\n        pybamm.logger.info(\"Calling DAE solver\")\n        solution = self.integrate(\n            self.residuals,\n            self.y0,\n            t_eval,\n            events=self.event_funs,\n            mass_matrix=model.mass_matrix.entries,\n            jacobian=self.jacobian,\n        )\n        solve_time = timer.time() - solve_start_time\n\n        # Identify the event that caused termination\n        termination = self.get_termination_reason(solution, self.events)\n\n        return solution, solve_time, termination",
  "def set_up(self, model):\n        \"\"\"Unpack model, perform checks, simplify and calculate jacobian.\n\n        Parameters\n        ----------\n        model : :class:`pybamm.BaseModel`\n            The model whose solution to calculate. Must have attributes rhs and\n            initial_conditions\n\n        Raises\n        ------\n        :class:`pybamm.SolverError`\n            If the model contains any algebraic equations (in which case a DAE solver\n            should be used instead)\n        \"\"\"\n        # create simplified rhs, algebraic and event expressions\n        concatenated_rhs = model.concatenated_rhs\n        concatenated_algebraic = model.concatenated_algebraic\n        events = model.events\n\n        if model.use_simplify:\n            # set up simplification object, for re-use of dict\n            simp = pybamm.Simplification()\n            pybamm.logger.info(\"Simplifying RHS\")\n            concatenated_rhs = simp.simplify(concatenated_rhs)\n            pybamm.logger.info(\"Simplifying algebraic\")\n            concatenated_algebraic = simp.simplify(concatenated_algebraic)\n            pybamm.logger.info(\"Simplifying events\")\n            events = {name: simp.simplify(event) for name, event in events.items()}\n\n        if model.use_jacobian:\n            # Create Jacobian from concatenated rhs and algebraic\n            y = pybamm.StateVector(\n                slice(0, np.size(model.concatenated_initial_conditions))\n            )\n            # set up Jacobian object, for re-use of dict\n            jacobian = pybamm.Jacobian()\n            pybamm.logger.info(\"Calculating jacobian\")\n            jac_rhs = jacobian.jac(concatenated_rhs, y)\n            jac_algebraic = jacobian.jac(concatenated_algebraic, y)\n            jac = pybamm.SparseStack(jac_rhs, jac_algebraic)\n            model.jacobian = jac\n            model.jacobian_rhs = jac_rhs\n            model.jacobian_algebraic = jac_algebraic\n\n            if model.use_simplify:\n                pybamm.logger.info(\"Simplifying jacobian\")\n                jac_algebraic = simp.simplify(jac_algebraic)\n                jac = simp.simplify(jac)\n\n            if model.use_to_python:\n                pybamm.logger.info(\"Converting jacobian to python\")\n                jac_algebraic = pybamm.EvaluatorPython(jac_algebraic)\n                jac = pybamm.EvaluatorPython(jac)\n\n            def jac_alg_fn(t, y):\n                return jac_algebraic.evaluate(t, y)\n\n        else:\n            jac = None\n            jac_alg_fn = None\n\n        if model.use_to_python:\n            pybamm.logger.info(\"Converting RHS to python\")\n            concatenated_rhs = pybamm.EvaluatorPython(concatenated_rhs)\n            pybamm.logger.info(\"Converting algebraic to python\")\n            concatenated_algebraic = pybamm.EvaluatorPython(concatenated_algebraic)\n            pybamm.logger.info(\"Converting events to python\")\n            events = {\n                name: pybamm.EvaluatorPython(event) for name, event in events.items()\n            }\n\n        # Calculate consistent initial conditions for the algebraic equations\n        def rhs(t, y):\n            return concatenated_rhs.evaluate(t, y, known_evals={})[0][:, 0]\n\n        def algebraic(t, y):\n            return concatenated_algebraic.evaluate(t, y, known_evals={})[0][:, 0]\n\n        if len(model.algebraic) > 0:\n            y0 = self.calculate_consistent_initial_conditions(\n                rhs, algebraic, model.concatenated_initial_conditions[:, 0], jac_alg_fn\n            )\n        else:\n            # can use DAE solver to solve ODE model\n            y0 = model.concatenated_initial_conditions[:, 0]\n\n        # Create functions to evaluate residuals\n        def residuals(t, y, ydot):\n            pybamm.logger.debug(\n                \"Evaluating residuals for {} at t={}\".format(model.name, t)\n            )\n            y = y[:, np.newaxis]\n            rhs_eval, known_evals = concatenated_rhs.evaluate(t, y, known_evals={})\n            # reuse known_evals\n            alg_eval = concatenated_algebraic.evaluate(t, y, known_evals=known_evals)[0]\n            # turn into 1D arrays\n            rhs_eval = rhs_eval[:, 0]\n            alg_eval = alg_eval[:, 0]\n            return (\n                np.concatenate((rhs_eval, alg_eval)) - model.mass_matrix.entries @ ydot\n            )\n\n        # Create event-dependent function to evaluate events\n        def event_fun(event):\n            def eval_event(t, y):\n                return event.evaluate(t, y)\n\n            return eval_event\n\n        event_funs = [event_fun(event) for event in events.values()]\n\n        # Create function to evaluate jacobian\n        if jac is not None:\n\n            def jacobian(t, y):\n                return jac.evaluate(t, y, known_evals={})[0]\n\n        else:\n            jacobian = None\n\n        # Add the solver attributes\n        # Note: these are the (possibly) converted to python version rhs, algebraic\n        # etc. The expression tree versions of these are attributes of the model\n        self.y0 = y0\n        self.rhs = rhs\n        self.algebraic = algebraic\n        self.residuals = residuals\n        self.events = events\n        self.event_funs = event_funs\n        self.jacobian = jacobian",
  "def calculate_consistent_initial_conditions(\n        self, rhs, algebraic, y0_guess, jac=None\n    ):\n        \"\"\"\n        Calculate consistent initial conditions for the algebraic equations through\n        root-finding\n\n        Parameters\n        ----------\n        rhs : method\n            Function that takes in t and y and returns the value of the differential\n            equations\n        algebraic : method\n            Function that takes in t and y and returns the value of the algebraic\n            equations\n        y0_guess : array-like\n            Array of the user's guess for the initial conditions, used to initialise\n            the root finding algorithm\n        jac : method\n            Function that takes in t and y and returns the value of the jacobian for the\n            algebraic equations\n\n        Returns\n        -------\n        y0_consistent : array-like, same shape as y0_guess\n            Initial conditions that are consistent with the algebraic equations (roots\n            of the algebraic equations)\n        \"\"\"\n        pybamm.logger.info(\"Start calculating consistent initial conditions\")\n\n        # Split y0_guess into differential and algebraic\n        len_rhs = rhs(0, y0_guess).shape[0]\n        y0_diff, y0_alg_guess = np.split(y0_guess, [len_rhs])\n\n        def root_fun(y0_alg):\n            \"Evaluates algebraic using y0_diff (fixed) and y0_alg (changed by algo)\"\n            y0 = np.concatenate([y0_diff, y0_alg])\n            out = algebraic(0, y0)\n            pybamm.logger.debug(\n                \"Evaluating algebraic equations at t=0, L2-norm is {}\".format(\n                    np.linalg.norm(out)\n                )\n            )\n            return out\n\n        if jac:\n            if issparse(jac(0, y0_guess)):\n\n                def jac_fn(y0_alg):\n                    \"\"\"\n                    Evaluates jacobian using y0_diff (fixed) and y0_alg (varying)\n                    \"\"\"\n                    y0 = np.concatenate([y0_diff, y0_alg])\n                    return jac(0, y0)[:, len_rhs:].toarray()\n\n            else:\n\n                def jac_fn(y0_alg):\n                    \"\"\"\n                    Evaluates jacobian using y0_diff (fixed) and y0_alg (varying)\n                    \"\"\"\n                    y0 = np.concatenate([y0_diff, y0_alg])\n                    return jac(0, y0)[:, len_rhs:]\n\n        else:\n            jac_fn = None\n        # Find the values of y0_alg that are roots of the algebraic equations\n        sol = optimize.root(\n            root_fun,\n            y0_alg_guess,\n            jac=jac_fn,\n            method=self.root_method,\n            tol=self.root_tol,\n        )\n        # Return full set of consistent initial conditions (y0_diff unchanged)\n        y0_consistent = np.concatenate([y0_diff, sol.x])\n\n        if sol.success and np.all(sol.fun < self.root_tol * len(sol.x)):\n            pybamm.logger.info(\"Finish calculating consistent initial conditions\")\n            return y0_consistent\n        elif not sol.success:\n            raise pybamm.SolverError(\n                \"Could not find consistent initial conditions: {}\".format(sol.message)\n            )\n        else:\n            raise pybamm.SolverError(\n                \"\"\"\n                Could not find consistent initial conditions: solver terminated\n                successfully, but maximum solution error ({}) above tolerance ({})\n                \"\"\".format(\n                    np.max(sol.fun), self.root_tol * len(sol.x)\n                )\n            )",
  "def integrate(\n        self, residuals, y0, t_eval, events=None, mass_matrix=None, jacobian=None\n    ):\n        \"\"\"\n        Solve a DAE model defined by residuals with initial conditions y0.\n\n        Parameters\n        ----------\n        residuals : method\n            A function that takes in t, y and ydot and returns the residuals of the\n            equations\n        y0 : numeric type\n            The initial conditions\n        t_eval : numeric type\n            The times at which to compute the solution\n        events : method, optional\n            A function that takes in t and y and returns conditions for the solver to\n            stop\n        mass_matrix : array_like, optional\n            The (sparse) mass matrix for the chosen spatial method.\n        jacobian : method, optional\n            A function that takes in t, y and ydot and returns the Jacobian\n        \"\"\"\n        raise NotImplementedError",
  "def rhs(t, y):\n            return concatenated_rhs.evaluate(t, y, known_evals={})[0][:, 0]",
  "def algebraic(t, y):\n            return concatenated_algebraic.evaluate(t, y, known_evals={})[0][:, 0]",
  "def residuals(t, y, ydot):\n            pybamm.logger.debug(\n                \"Evaluating residuals for {} at t={}\".format(model.name, t)\n            )\n            y = y[:, np.newaxis]\n            rhs_eval, known_evals = concatenated_rhs.evaluate(t, y, known_evals={})\n            # reuse known_evals\n            alg_eval = concatenated_algebraic.evaluate(t, y, known_evals=known_evals)[0]\n            # turn into 1D arrays\n            rhs_eval = rhs_eval[:, 0]\n            alg_eval = alg_eval[:, 0]\n            return (\n                np.concatenate((rhs_eval, alg_eval)) - model.mass_matrix.entries @ ydot\n            )",
  "def event_fun(event):\n            def eval_event(t, y):\n                return event.evaluate(t, y)\n\n            return eval_event",
  "def root_fun(y0_alg):\n            \"Evaluates algebraic using y0_diff (fixed) and y0_alg (changed by algo)\"\n            y0 = np.concatenate([y0_diff, y0_alg])\n            out = algebraic(0, y0)\n            pybamm.logger.debug(\n                \"Evaluating algebraic equations at t=0, L2-norm is {}\".format(\n                    np.linalg.norm(out)\n                )\n            )\n            return out",
  "def jac_alg_fn(t, y):\n                return jac_algebraic.evaluate(t, y)",
  "def eval_event(t, y):\n                return event.evaluate(t, y)",
  "def jacobian(t, y):\n                return jac.evaluate(t, y, known_evals={})[0]",
  "def jac_fn(y0_alg):\n                    \"\"\"\n                    Evaluates jacobian using y0_diff (fixed) and y0_alg (varying)\n                    \"\"\"\n                    y0 = np.concatenate([y0_diff, y0_alg])\n                    return jac(0, y0)[:, len_rhs:].toarray()",
  "def jac_fn(y0_alg):\n                    \"\"\"\n                    Evaluates jacobian using y0_diff (fixed) and y0_alg (varying)\n                    \"\"\"\n                    y0 = np.concatenate([y0_diff, y0_alg])\n                    return jac(0, y0)[:, len_rhs:]",
  "class ScipySolver(pybamm.OdeSolver):\n    \"\"\"Solve a discretised model, using scipy.integrate.solve_ivp.\n\n    Parameters\n    ----------\n    method : str, optional\n        The method to use in solve_ivp (default is \"BDF\")\n    rtol : float, optional\n        The relative tolerance for the solver (default is 1e-6).\n    atol : float, optional\n        The absolute tolerance for the solver (default is 1e-6).\n    \"\"\"\n\n    def __init__(self, method=\"BDF\", rtol=1e-6, atol=1e-6):\n        super().__init__(method, rtol, atol)\n\n    def integrate(\n        self, derivs, y0, t_eval, events=None, mass_matrix=None, jacobian=None\n    ):\n        \"\"\"\n        Solve a model defined by dydt with initial conditions y0.\n\n        Parameters\n        ----------\n        derivs : method\n            A function that takes in t (size (1,)), y (size (n,))\n            and returns the time-derivative dydt (size (n,))\n        y0 : :class:`numpy.array`, size (n,)\n            The initial conditions\n        t_eval : :class:`numpy.array`, size (k,)\n            The times at which to compute the solution\n        events : method, optional\n            A function that takes in t and y and returns conditions for the solver to\n            stop\n        mass_matrix : array_like, optional\n            The (sparse) mass matrix for the chosen spatial method.\n        jacobian : method, optional\n            A function that takes in t and y and returns the Jacobian. If\n            None, the solver will approximate the Jacobian.\n        Returns\n        -------\n        object\n            An object containing the times and values of the solution, as well as\n            various diagnostic messages.\n\n        \"\"\"\n        extra_options = {\"rtol\": self.rtol, \"atol\": self.atol}\n\n        # check for user-supplied Jacobian\n        implicit_methods = [\"Radau\", \"BDF\", \"LSODA\"]\n        if np.any([self.method in implicit_methods]):\n            if jacobian:\n                extra_options.update({\"jac\": jacobian})\n\n        # make events terminal so that the solver stops when they are reached\n        if events:\n            for event in events:\n                event.terminal = True\n            extra_options.update({\"events\": events})\n\n        sol = it.solve_ivp(\n            derivs,\n            (t_eval[0], t_eval[-1]),\n            y0,\n            t_eval=t_eval,\n            method=self.method,\n            dense_output=True,\n            **extra_options\n        )\n\n        if sol.success:\n            # Set the reason for termination\n            if sol.message == \"A termination event occurred.\":\n                termination = \"event\"\n                t_event = []\n                for time in sol.t_events:\n                    if time:\n                        t_event = np.append(t_event, np.max(time))\n                t_event = np.array([np.max(t_event)])\n                y_event = sol.sol(t_event)\n            elif sol.message.startswith(\"The solver successfully reached the end\"):\n                termination = \"final time\"\n                t_event = None\n                y_event = np.array(None)\n            return pybamm.Solution(sol.t, sol.y, t_event, y_event, termination)\n        else:\n            raise pybamm.SolverError(sol.message)",
  "def __init__(self, method=\"BDF\", rtol=1e-6, atol=1e-6):\n        super().__init__(method, rtol, atol)",
  "def integrate(\n        self, derivs, y0, t_eval, events=None, mass_matrix=None, jacobian=None\n    ):\n        \"\"\"\n        Solve a model defined by dydt with initial conditions y0.\n\n        Parameters\n        ----------\n        derivs : method\n            A function that takes in t (size (1,)), y (size (n,))\n            and returns the time-derivative dydt (size (n,))\n        y0 : :class:`numpy.array`, size (n,)\n            The initial conditions\n        t_eval : :class:`numpy.array`, size (k,)\n            The times at which to compute the solution\n        events : method, optional\n            A function that takes in t and y and returns conditions for the solver to\n            stop\n        mass_matrix : array_like, optional\n            The (sparse) mass matrix for the chosen spatial method.\n        jacobian : method, optional\n            A function that takes in t and y and returns the Jacobian. If\n            None, the solver will approximate the Jacobian.\n        Returns\n        -------\n        object\n            An object containing the times and values of the solution, as well as\n            various diagnostic messages.\n\n        \"\"\"\n        extra_options = {\"rtol\": self.rtol, \"atol\": self.atol}\n\n        # check for user-supplied Jacobian\n        implicit_methods = [\"Radau\", \"BDF\", \"LSODA\"]\n        if np.any([self.method in implicit_methods]):\n            if jacobian:\n                extra_options.update({\"jac\": jacobian})\n\n        # make events terminal so that the solver stops when they are reached\n        if events:\n            for event in events:\n                event.terminal = True\n            extra_options.update({\"events\": events})\n\n        sol = it.solve_ivp(\n            derivs,\n            (t_eval[0], t_eval[-1]),\n            y0,\n            t_eval=t_eval,\n            method=self.method,\n            dense_output=True,\n            **extra_options\n        )\n\n        if sol.success:\n            # Set the reason for termination\n            if sol.message == \"A termination event occurred.\":\n                termination = \"event\"\n                t_event = []\n                for time in sol.t_events:\n                    if time:\n                        t_event = np.append(t_event, np.max(time))\n                t_event = np.array([np.max(t_event)])\n                y_event = sol.sol(t_event)\n            elif sol.message.startswith(\"The solver successfully reached the end\"):\n                termination = \"final time\"\n                t_event = None\n                y_event = np.array(None)\n            return pybamm.Solution(sol.t, sol.y, t_event, y_event, termination)\n        else:\n            raise pybamm.SolverError(sol.message)",
  "class ParameterValues(dict):\n    \"\"\"\n    The parameter values for a simulation.\n\n    Parameters\n    ----------\n    values : dict or string\n        Explicit set of parameters, or reference to a file of parameters\n        If string, gets passed to read_parameters_csv to read a file.\n    chemistry : dict\n        Dict of strings for default chemistries. Must be of the form:\n        {\"base chemistry\": base_chemistry,\n        \"cell\": cell_properties_authorYear,\n        \"anode\": anode_chemistry_authorYear,\n        \"separator\": separator_chemistry_authorYear,\n        \"cathode\": cathode_chemistry_authorYear,\n        \"electrolyte\": electrolyte_chemistry_authorYear,\n        \"experiment\": experimental_conditions_authorYear}.\n        Then the anode chemistry is loaded from the file\n        inputs/parameters/base_chemistry/anodes/anode_chemistry_authorYear, etc.\n        Parameters in \"cell\" should include geometry and current collector properties.\n        Parameters in \"experiment\" should include parameters relating to experimental\n        conditions, such as initial conditions and currents.\n\n    Examples\n    --------\n    >>> import pybamm\n    >>> values = {\"some parameter\": 1, \"another parameter\": 2}\n    >>> param = pybamm.ParameterValues(values)\n    >>> param[\"some parameter\"]\n    1\n    >>> file = \"/input/parameters/lithium-ion/cells/kokam_Marquis2019/parameters.csv\"\n    >>> param = pybamm.ParameterValues(values=pybamm.root_dir() + file)\n    >>> param[\"Negative current collector thickness [m]\"]\n    2.5e-05\n    >>> param = pybamm.ParameterValues(chemistry=pybamm.parameter_sets.Marquis2019)\n    >>> param[\"Reference temperature [K]\"]\n    298.15\n\n    \"\"\"\n\n    def __init__(self, values=None, chemistry=None):\n        # Must provide either values or chemistry, not both (nor neither)\n        if values is not None and chemistry is not None:\n            raise ValueError(\n                \"\"\"\n                Only one of values and chemistry can be provided. To change parameters\n                slightly from a chemistry, first load parameters with the chemistry\n                (param = pybamm.ParameterValues(chemistry=...)) and then update with\n                param.update({dict of values}).\n                \"\"\"\n            )\n        if values is None and chemistry is None:\n            raise ValueError(\"values and chemistry cannot both be None\")\n        # First load chemistry\n        if chemistry is not None:\n            self.update_from_chemistry(chemistry)\n        # Then update with values dictionary or file\n        if values is not None:\n            if isinstance(values, str):\n                values = self.read_parameters_csv(values)\n            # If base_parameters is a filename, load from that filename\n            self.update(values)\n\n        # Initialise empty _processed_symbols dict (for caching)\n        self._processed_symbols = {}\n\n    def update_from_chemistry(self, chemistry):\n        \"\"\"\n        Load standard set of components from a 'chemistry' dictionary\n        \"\"\"\n        base_chemistry = chemistry[\"chemistry\"]\n        # Create path to file\n        path = os.path.join(pybamm.root_dir(), \"input\", \"parameters\", base_chemistry)\n        # Load each component name\n        for component_group in [\n            \"cell\",\n            \"anode\",\n            \"cathode\",\n            \"separator\",\n            \"electrolyte\",\n            \"experiment\",\n        ]:\n            # Make sure component is provided\n            try:\n                component = chemistry[component_group]\n            except KeyError:\n                raise KeyError(\n                    \"must provide '{}' parameters for {} chemistry\".format(\n                        component_group, base_chemistry\n                    )\n                )\n            # Create path to component and load values\n            component_path = os.path.join(path, component_group + \"s\", component)\n            component_params = self.read_parameters_csv(\n                os.path.join(component_path, \"parameters.csv\")\n            )\n            # Update parameters, making sure to check any conflicts\n            self.update(component_params, check_conflict=True, path=component_path)\n\n    def read_parameters_csv(self, filename):\n        \"\"\"Reads parameters from csv file into dict.\n\n        Parameters\n        ----------\n        filename : str\n            The name of the csv file containing the parameters.\n\n        Returns\n        -------\n        dict\n            {name: value} pairs for the parameters.\n\n        \"\"\"\n        df = pd.read_csv(filename, comment=\"#\", skip_blank_lines=True)\n        # Drop rows that are all NaN (seems to not work with skip_blank_lines)\n        df.dropna(how=\"all\", inplace=True)\n        return {k: v for (k, v) in zip(df[\"Name [units]\"], df[\"Value\"])}\n\n    def update(self, values, check_conflict=False, path=\"\"):\n        # check parameter values\n        values = self.check_and_update_parameter_values(values)\n        # update\n        for name, value in values.items():\n            # check for conflicts\n            if (\n                check_conflict is True\n                and name in self.keys()\n                and not (self[name] == float(value) or self[name] == value)\n            ):\n                raise ValueError(\n                    \"parameter '{}' already defined with value '{}'\".format(\n                        name, self[name]\n                    )\n                )\n            # if no conflicts, update, loading functions and data if they are specified\n            else:\n                # Functions are flagged with the string \"[function]\"\n                if isinstance(value, str):\n                    if value.startswith(\"[function]\"):\n                        self[name] = pybamm.load_function(\n                            os.path.join(path, value[10:] + \".py\")\n                        )\n                    # Inbuilt functions are flagged with the string \"[inbuilt]\"\n                    elif value.startswith(\"[inbuilt class]\"):\n                        # Extra set of brackets at the end makes an instance of the\n                        # class\n                        self[name] = getattr(pybamm, value[15:])()\n                    # Data is flagged with the string \"[data]\"\n                    elif value.startswith(\"[data]\"):\n                        data = np.loadtxt(os.path.join(path, value[6:] + \".csv\"))\n                        # Save name and data\n                        self[name] = (value[6:], data)\n                    # Anything else should be a converted to a float\n                    else:\n                        self[name] = float(value)\n                else:\n                    self[name] = value\n        # reset processed symbols\n        self._processed_symbols = {}\n\n    def check_and_update_parameter_values(self, values):\n        # Make sure \"C-rate\" and current are both non-zero\n        if \"C-rate\" in values and values[\"C-rate\"] == 0:\n            raise ValueError(\n                \"\"\"\n                \"C-rate\" cannot be zero. A possible alternative is to set\n                \"Current function\" to `pybamm.GetConstantCurrent(current=0)` instead.\n                \"\"\"\n            )\n        if \"Typical current [A]\" in values and values[\"Typical current [A]\"] == 0:\n            raise ValueError(\n                \"\"\"\n                \"Typical current [A]\" cannot be zero. A possible alternative is to set\n                \"Current function\" to `pybamm.GetConstantCurrent(current=0)` instead.\n                \"\"\"\n            )\n        # If the capacity of the cell has been provided, make sure \"C-rate\" and current\n        # match with the stated capacity\n        if \"Cell capacity [A.h]\" in values or \"Cell capacity [A.h]\" in self:\n            # Capacity from values takes precedence\n            if \"Cell capacity [A.h]\" in values:\n                capacity = values[\"Cell capacity [A.h]\"]\n            else:\n                capacity = self[\"Cell capacity [A.h]\"]\n            # Make sure they match if both provided\n            if \"C-rate\" in values and \"Typical current [A]\" in values:\n                if values[\"C-rate\"] * capacity != values[\"Typical current [A]\"]:\n                    raise ValueError(\n                        \"\"\"\n                        \"C-rate\" ({}C) and Typical current ({} A) provided do not match\n                        given capacity ({} Ah). These can be updated individually\n                        instead.\n                        \"\"\".format(\n                            values[\"C-rate\"], values[\"Typical current [A]\"], capacity\n                        )\n                    )\n            # Update the other if only one provided\n            elif \"C-rate\" in values:\n                values[\"Typical current [A]\"] = float(values[\"C-rate\"]) * capacity\n            elif \"Typical current [A]\" in values:\n                values[\"C-rate\"] = float(values[\"Typical current [A]\"]) / capacity\n        return values\n\n    def process_model(self, model, processing=\"process\"):\n        \"\"\"Assign parameter values to a model.\n        Currently inplace, could be changed to return a new model.\n\n        Parameters\n        ----------\n        model : :class:`pybamm.BaseModel`\n            Model to assign parameter values for\n        processing : str, optional\n            Flag to indicate how to process model (default 'process')\n\n            * 'process': Calls :meth:`process_symbol()` (walk through the symbol \\\n            and replace any Parameter with a Value)\n            * 'update': Calls :meth:`update_scalars()` for use on already-processed \\\n            model (update the value of any Scalars in the expression tree.)\n\n        Raises\n        ------\n        :class:`pybamm.ModelError`\n            If an empty model is passed (`model.rhs = {}` and `model.algebraic={}`)\n\n        \"\"\"\n        pybamm.logger.info(\"Start setting parameters for {}\".format(model.name))\n\n        if len(model.rhs) == 0 and len(model.algebraic) == 0:\n            raise pybamm.ModelError(\"Cannot process parameters for empty model\")\n\n        if processing == \"process\":\n            processing_function = self.process_symbol\n        elif processing == \"update\":\n            processing_function = self.update_scalars\n\n        for variable, equation in model.rhs.items():\n            pybamm.logger.debug(\n                \"{} parameters for {!r} (rhs)\".format(processing.capitalize(), variable)\n            )\n            model.rhs[variable] = processing_function(equation)\n\n        for variable, equation in model.algebraic.items():\n            pybamm.logger.debug(\n                \"{} parameters for {!r} (algebraic)\".format(\n                    processing.capitalize(), variable\n                )\n            )\n            model.algebraic[variable] = processing_function(equation)\n\n        for variable, equation in model.initial_conditions.items():\n            pybamm.logger.debug(\n                \"{} parameters for {!r} (initial conditions)\".format(\n                    processing.capitalize(), variable\n                )\n            )\n            model.initial_conditions[variable] = processing_function(equation)\n\n        # Boundary conditions are dictionaries {\"left\": left bc, \"right\": right bc}\n        # in general, but may be imposed on the tabs (or *not* on the tab) for a\n        # small number of variables, e.g. {\"negative tab\": neg. tab bc,\n        # \"positive tab\": pos. tab bc \"no tab\": no tab bc}.\n        new_boundary_conditions = {}\n        for variable, bcs in model.boundary_conditions.items():\n            processed_variable = processing_function(variable)\n            new_boundary_conditions[processed_variable] = {}\n            for side in [\"left\", \"right\", \"negative tab\", \"positive tab\", \"no tab\"]:\n                try:\n                    bc, typ = bcs[side]\n                    pybamm.logger.debug(\n                        \"{} parameters for {!r} ({} bc)\".format(\n                            processing.capitalize(), variable, side\n                        )\n                    )\n                    processed_bc = (processing_function(bc), typ)\n                    new_boundary_conditions[processed_variable][side] = processed_bc\n                except KeyError:\n                    pass\n\n        model.boundary_conditions = new_boundary_conditions\n\n        for variable, equation in model.variables.items():\n            pybamm.logger.debug(\n                \"{} parameters for {!r} (variables)\".format(\n                    processing.capitalize(), variable\n                )\n            )\n            model.variables[variable] = processing_function(equation)\n        for event, equation in model.events.items():\n            pybamm.logger.debug(\n                \"{} parameters for event '{}''\".format(processing.capitalize(), event)\n            )\n            model.events[event] = processing_function(equation)\n\n        pybamm.logger.info(\"Finish setting parameters for {}\".format(model.name))\n\n    def update_model(self, model, disc):\n        \"\"\"Process a discretised model.\n        Currently inplace, could be changed to return a new model.\n\n        Parameters\n        ----------\n        model : :class:`pybamm.BaseModel`\n            Model to assign parameter values for\n        disc : :class:`pybamm.Discretisation`\n            The class that was used to discretise\n\n        \"\"\"\n        # process parameter values for the model\n        self.process_model(model, processing=\"update\")\n\n        # update discretised quantities using disc\n        model.concatenated_rhs = disc._concatenate_in_order(model.rhs)\n        model.concatenated_algebraic = disc._concatenate_in_order(model.algebraic)\n        model.concatenated_initial_conditions = disc._concatenate_in_order(\n            model.initial_conditions\n        ).evaluate(0, None)\n\n    def process_geometry(self, geometry):\n        \"\"\"\n        Assign parameter values to a geometry (inplace).\n\n        Parameters\n        ----------\n        geometry : :class:`pybamm.Geometry`\n                Geometry specs to assign parameter values to\n        \"\"\"\n        for domain in geometry:\n            for prim_sec_tabs, variables in geometry[domain].items():\n                # process tab information if using 1 or 2D current collectors\n                if prim_sec_tabs == \"tabs\":\n                    for tab, position_size in variables.items():\n                        for position_size, sym in position_size.items():\n                            geometry[domain][prim_sec_tabs][tab][\n                                position_size\n                            ] = self.process_symbol(sym)\n                else:\n                    for spatial_variable, spatial_limits in variables.items():\n                        for lim, sym in spatial_limits.items():\n                            geometry[domain][prim_sec_tabs][spatial_variable][\n                                lim\n                            ] = self.process_symbol(sym)\n\n    def process_symbol(self, symbol):\n        \"\"\"Walk through the symbol and replace any Parameter with a Value.\n        If a symbol has already been processed, the stored value is returned.\n\n        Parameters\n        ----------\n        symbol : :class:`pybamm.Symbol`\n            Symbol or Expression tree to set parameters for\n\n        Returns\n        -------\n        symbol : :class:`pybamm.Symbol`\n            Symbol with Parameter instances replaced by Value\n\n        \"\"\"\n\n        try:\n            return self._processed_symbols[symbol.id]\n        except KeyError:\n            processed_symbol = self._process_symbol(symbol)\n\n            self._processed_symbols[symbol.id] = processed_symbol\n            return processed_symbol\n\n    def _process_symbol(self, symbol):\n        \"\"\" See :meth:`ParameterValues.process_symbol()`. \"\"\"\n\n        if isinstance(symbol, pybamm.Parameter):\n            value = self[symbol.name]\n            # Scalar inherits name (for updating parameters) and domain (for Broadcast)\n            return pybamm.Scalar(value, name=symbol.name, domain=symbol.domain)\n\n        elif isinstance(symbol, pybamm.FunctionParameter):\n            new_children = [self.process_symbol(child) for child in symbol.children]\n            function_name = self[symbol.name]\n\n            # if current setter, process any parameters that are symbols and\n            # store the evaluated symbol in the parameters_eval dict\n            if isinstance(function_name, pybamm.GetCurrent):\n                for param, sym in function_name.parameters.items():\n                    if isinstance(sym, pybamm.Symbol):\n                        new_sym = self.process_symbol(sym)\n                        function_name.parameters[param] = new_sym\n                        function_name.parameters_eval[param] = new_sym.evaluate()\n                # If loading data, need to update interpolant with\n                # evaluated parameters\n                if isinstance(function_name, pybamm.GetCurrentData):\n                    function_name.interpolate()\n\n            # Create Function or Interpolant objec\n            if isinstance(function_name, tuple):\n                # If function_name is a tuple then it should be (name, data) and we need\n                # to create an Interpolant\n                name, data = function_name\n                function = pybamm.Interpolant(data, *new_children, name=name)\n            else:\n                # otherwise create standard function\n                function = pybamm.Function(function_name, *new_children)\n            # Differentiate if necessary\n            if symbol.diff_variable is None:\n                return function\n            else:\n                # return differentiated function\n                new_diff_variable = self.process_symbol(symbol.diff_variable)\n                return function.diff(new_diff_variable)\n\n        elif isinstance(symbol, pybamm.BinaryOperator):\n            # process children\n            new_left = self.process_symbol(symbol.left)\n            new_right = self.process_symbol(symbol.right)\n            # make new symbol, ensure domain remains the same\n            new_symbol = symbol.__class__(new_left, new_right)\n            new_symbol.domain = symbol.domain\n            return new_symbol\n\n        # Unary operators\n        elif isinstance(symbol, pybamm.UnaryOperator):\n            new_child = self.process_symbol(symbol.child)\n            new_symbol = symbol._unary_new_copy(new_child)\n            # ensure domain remains the same\n            new_symbol.domain = symbol.domain\n            return new_symbol\n\n        # Functions\n        elif isinstance(symbol, pybamm.Function):\n            new_children = [self.process_symbol(child) for child in symbol.children]\n            return symbol._function_new_copy(new_children)\n\n        # Concatenations\n        elif isinstance(symbol, pybamm.Concatenation):\n            new_children = [self.process_symbol(child) for child in symbol.children]\n            return symbol._concatenation_new_copy(new_children)\n\n        else:\n            # Backup option: return new copy of the object\n            try:\n                return symbol.new_copy()\n            except NotImplementedError:\n                raise NotImplementedError(\n                    \"Cannot process parameters for symbol of type '{}'\".format(\n                        type(symbol)\n                    )\n                )\n\n    def update_scalars(self, symbol):\n        \"\"\"Update the value of any Scalars in the expression tree.\n\n        Parameters\n        ----------\n        symbol : :class:`pybamm.Symbol`\n            Symbol or Expression tree to update\n\n        Returns\n        -------\n        symbol : :class:`pybamm.Symbol`\n            Symbol with Scalars updated\n\n        \"\"\"\n        for x in symbol.pre_order():\n            if isinstance(x, pybamm.Scalar):\n                # update any Scalar nodes if their name is in the parameter dict\n                try:\n                    x.value = self[x.name]\n                    # update id\n                    x.set_id()\n                except KeyError:\n                    # KeyError -> name not in parameter dict, don't update\n                    continue\n            elif isinstance(x, pybamm.Function):\n                if isinstance(x.function, pybamm.GetCurrent):\n                    # Need to update parameters dict to be that of the new current\n                    # function and make new parameters_eval dict to be processed\n                    x.function.parameters = self[\"Current function\"].parameters\n                    x.function.parameters_eval = x.function.parameters.copy()\n                    for param, sym in x.function.parameters.items():\n                        # Need to process again as new symbols may be passed\n                        # e.g. may explicitly pass pybamm.Scalar(1) instead of\n                        # pybamm.electrical_parameters.I_typ\n                        if isinstance(sym, pybamm.Symbol):\n                            new_sym = self.process_symbol(sym)\n                            x.function.parameters[param] = new_sym\n                            try:\n                                x.function.parameters_eval[param] = self[new_sym.name]\n                            except KeyError:\n                                # KeyError -> name not in parameter dict, evaluate\n                                # unnamed Scalar\n                                x.function.parameters_eval[param] = new_sym.evaluate()\n                    if isinstance(x.function, pybamm.GetCurrentData):\n                        # update interpolant\n                        x.function.interpolate()\n\n        return symbol\n\n    def evaluate(self, symbol):\n        \"\"\"\n        Process and evaluate a symbol.\n\n        Parameters\n        ----------\n        symbol : :class:`pybamm.Symbol`\n            Symbol or Expression tree to evaluate\n\n        Returns\n        -------\n        number of array\n            The evaluated symbol\n        \"\"\"\n        processed_symbol = self.process_symbol(symbol)\n        if processed_symbol.is_constant() and processed_symbol.evaluates_to_number():\n            return processed_symbol.evaluate()\n        else:\n            raise ValueError(\"symbol must evaluate to a constant scalar\")",
  "def __init__(self, values=None, chemistry=None):\n        # Must provide either values or chemistry, not both (nor neither)\n        if values is not None and chemistry is not None:\n            raise ValueError(\n                \"\"\"\n                Only one of values and chemistry can be provided. To change parameters\n                slightly from a chemistry, first load parameters with the chemistry\n                (param = pybamm.ParameterValues(chemistry=...)) and then update with\n                param.update({dict of values}).\n                \"\"\"\n            )\n        if values is None and chemistry is None:\n            raise ValueError(\"values and chemistry cannot both be None\")\n        # First load chemistry\n        if chemistry is not None:\n            self.update_from_chemistry(chemistry)\n        # Then update with values dictionary or file\n        if values is not None:\n            if isinstance(values, str):\n                values = self.read_parameters_csv(values)\n            # If base_parameters is a filename, load from that filename\n            self.update(values)\n\n        # Initialise empty _processed_symbols dict (for caching)\n        self._processed_symbols = {}",
  "def update_from_chemistry(self, chemistry):\n        \"\"\"\n        Load standard set of components from a 'chemistry' dictionary\n        \"\"\"\n        base_chemistry = chemistry[\"chemistry\"]\n        # Create path to file\n        path = os.path.join(pybamm.root_dir(), \"input\", \"parameters\", base_chemistry)\n        # Load each component name\n        for component_group in [\n            \"cell\",\n            \"anode\",\n            \"cathode\",\n            \"separator\",\n            \"electrolyte\",\n            \"experiment\",\n        ]:\n            # Make sure component is provided\n            try:\n                component = chemistry[component_group]\n            except KeyError:\n                raise KeyError(\n                    \"must provide '{}' parameters for {} chemistry\".format(\n                        component_group, base_chemistry\n                    )\n                )\n            # Create path to component and load values\n            component_path = os.path.join(path, component_group + \"s\", component)\n            component_params = self.read_parameters_csv(\n                os.path.join(component_path, \"parameters.csv\")\n            )\n            # Update parameters, making sure to check any conflicts\n            self.update(component_params, check_conflict=True, path=component_path)",
  "def read_parameters_csv(self, filename):\n        \"\"\"Reads parameters from csv file into dict.\n\n        Parameters\n        ----------\n        filename : str\n            The name of the csv file containing the parameters.\n\n        Returns\n        -------\n        dict\n            {name: value} pairs for the parameters.\n\n        \"\"\"\n        df = pd.read_csv(filename, comment=\"#\", skip_blank_lines=True)\n        # Drop rows that are all NaN (seems to not work with skip_blank_lines)\n        df.dropna(how=\"all\", inplace=True)\n        return {k: v for (k, v) in zip(df[\"Name [units]\"], df[\"Value\"])}",
  "def update(self, values, check_conflict=False, path=\"\"):\n        # check parameter values\n        values = self.check_and_update_parameter_values(values)\n        # update\n        for name, value in values.items():\n            # check for conflicts\n            if (\n                check_conflict is True\n                and name in self.keys()\n                and not (self[name] == float(value) or self[name] == value)\n            ):\n                raise ValueError(\n                    \"parameter '{}' already defined with value '{}'\".format(\n                        name, self[name]\n                    )\n                )\n            # if no conflicts, update, loading functions and data if they are specified\n            else:\n                # Functions are flagged with the string \"[function]\"\n                if isinstance(value, str):\n                    if value.startswith(\"[function]\"):\n                        self[name] = pybamm.load_function(\n                            os.path.join(path, value[10:] + \".py\")\n                        )\n                    # Inbuilt functions are flagged with the string \"[inbuilt]\"\n                    elif value.startswith(\"[inbuilt class]\"):\n                        # Extra set of brackets at the end makes an instance of the\n                        # class\n                        self[name] = getattr(pybamm, value[15:])()\n                    # Data is flagged with the string \"[data]\"\n                    elif value.startswith(\"[data]\"):\n                        data = np.loadtxt(os.path.join(path, value[6:] + \".csv\"))\n                        # Save name and data\n                        self[name] = (value[6:], data)\n                    # Anything else should be a converted to a float\n                    else:\n                        self[name] = float(value)\n                else:\n                    self[name] = value\n        # reset processed symbols\n        self._processed_symbols = {}",
  "def check_and_update_parameter_values(self, values):\n        # Make sure \"C-rate\" and current are both non-zero\n        if \"C-rate\" in values and values[\"C-rate\"] == 0:\n            raise ValueError(\n                \"\"\"\n                \"C-rate\" cannot be zero. A possible alternative is to set\n                \"Current function\" to `pybamm.GetConstantCurrent(current=0)` instead.\n                \"\"\"\n            )\n        if \"Typical current [A]\" in values and values[\"Typical current [A]\"] == 0:\n            raise ValueError(\n                \"\"\"\n                \"Typical current [A]\" cannot be zero. A possible alternative is to set\n                \"Current function\" to `pybamm.GetConstantCurrent(current=0)` instead.\n                \"\"\"\n            )\n        # If the capacity of the cell has been provided, make sure \"C-rate\" and current\n        # match with the stated capacity\n        if \"Cell capacity [A.h]\" in values or \"Cell capacity [A.h]\" in self:\n            # Capacity from values takes precedence\n            if \"Cell capacity [A.h]\" in values:\n                capacity = values[\"Cell capacity [A.h]\"]\n            else:\n                capacity = self[\"Cell capacity [A.h]\"]\n            # Make sure they match if both provided\n            if \"C-rate\" in values and \"Typical current [A]\" in values:\n                if values[\"C-rate\"] * capacity != values[\"Typical current [A]\"]:\n                    raise ValueError(\n                        \"\"\"\n                        \"C-rate\" ({}C) and Typical current ({} A) provided do not match\n                        given capacity ({} Ah). These can be updated individually\n                        instead.\n                        \"\"\".format(\n                            values[\"C-rate\"], values[\"Typical current [A]\"], capacity\n                        )\n                    )\n            # Update the other if only one provided\n            elif \"C-rate\" in values:\n                values[\"Typical current [A]\"] = float(values[\"C-rate\"]) * capacity\n            elif \"Typical current [A]\" in values:\n                values[\"C-rate\"] = float(values[\"Typical current [A]\"]) / capacity\n        return values",
  "def process_model(self, model, processing=\"process\"):\n        \"\"\"Assign parameter values to a model.\n        Currently inplace, could be changed to return a new model.\n\n        Parameters\n        ----------\n        model : :class:`pybamm.BaseModel`\n            Model to assign parameter values for\n        processing : str, optional\n            Flag to indicate how to process model (default 'process')\n\n            * 'process': Calls :meth:`process_symbol()` (walk through the symbol \\\n            and replace any Parameter with a Value)\n            * 'update': Calls :meth:`update_scalars()` for use on already-processed \\\n            model (update the value of any Scalars in the expression tree.)\n\n        Raises\n        ------\n        :class:`pybamm.ModelError`\n            If an empty model is passed (`model.rhs = {}` and `model.algebraic={}`)\n\n        \"\"\"\n        pybamm.logger.info(\"Start setting parameters for {}\".format(model.name))\n\n        if len(model.rhs) == 0 and len(model.algebraic) == 0:\n            raise pybamm.ModelError(\"Cannot process parameters for empty model\")\n\n        if processing == \"process\":\n            processing_function = self.process_symbol\n        elif processing == \"update\":\n            processing_function = self.update_scalars\n\n        for variable, equation in model.rhs.items():\n            pybamm.logger.debug(\n                \"{} parameters for {!r} (rhs)\".format(processing.capitalize(), variable)\n            )\n            model.rhs[variable] = processing_function(equation)\n\n        for variable, equation in model.algebraic.items():\n            pybamm.logger.debug(\n                \"{} parameters for {!r} (algebraic)\".format(\n                    processing.capitalize(), variable\n                )\n            )\n            model.algebraic[variable] = processing_function(equation)\n\n        for variable, equation in model.initial_conditions.items():\n            pybamm.logger.debug(\n                \"{} parameters for {!r} (initial conditions)\".format(\n                    processing.capitalize(), variable\n                )\n            )\n            model.initial_conditions[variable] = processing_function(equation)\n\n        # Boundary conditions are dictionaries {\"left\": left bc, \"right\": right bc}\n        # in general, but may be imposed on the tabs (or *not* on the tab) for a\n        # small number of variables, e.g. {\"negative tab\": neg. tab bc,\n        # \"positive tab\": pos. tab bc \"no tab\": no tab bc}.\n        new_boundary_conditions = {}\n        for variable, bcs in model.boundary_conditions.items():\n            processed_variable = processing_function(variable)\n            new_boundary_conditions[processed_variable] = {}\n            for side in [\"left\", \"right\", \"negative tab\", \"positive tab\", \"no tab\"]:\n                try:\n                    bc, typ = bcs[side]\n                    pybamm.logger.debug(\n                        \"{} parameters for {!r} ({} bc)\".format(\n                            processing.capitalize(), variable, side\n                        )\n                    )\n                    processed_bc = (processing_function(bc), typ)\n                    new_boundary_conditions[processed_variable][side] = processed_bc\n                except KeyError:\n                    pass\n\n        model.boundary_conditions = new_boundary_conditions\n\n        for variable, equation in model.variables.items():\n            pybamm.logger.debug(\n                \"{} parameters for {!r} (variables)\".format(\n                    processing.capitalize(), variable\n                )\n            )\n            model.variables[variable] = processing_function(equation)\n        for event, equation in model.events.items():\n            pybamm.logger.debug(\n                \"{} parameters for event '{}''\".format(processing.capitalize(), event)\n            )\n            model.events[event] = processing_function(equation)\n\n        pybamm.logger.info(\"Finish setting parameters for {}\".format(model.name))",
  "def update_model(self, model, disc):\n        \"\"\"Process a discretised model.\n        Currently inplace, could be changed to return a new model.\n\n        Parameters\n        ----------\n        model : :class:`pybamm.BaseModel`\n            Model to assign parameter values for\n        disc : :class:`pybamm.Discretisation`\n            The class that was used to discretise\n\n        \"\"\"\n        # process parameter values for the model\n        self.process_model(model, processing=\"update\")\n\n        # update discretised quantities using disc\n        model.concatenated_rhs = disc._concatenate_in_order(model.rhs)\n        model.concatenated_algebraic = disc._concatenate_in_order(model.algebraic)\n        model.concatenated_initial_conditions = disc._concatenate_in_order(\n            model.initial_conditions\n        ).evaluate(0, None)",
  "def process_geometry(self, geometry):\n        \"\"\"\n        Assign parameter values to a geometry (inplace).\n\n        Parameters\n        ----------\n        geometry : :class:`pybamm.Geometry`\n                Geometry specs to assign parameter values to\n        \"\"\"\n        for domain in geometry:\n            for prim_sec_tabs, variables in geometry[domain].items():\n                # process tab information if using 1 or 2D current collectors\n                if prim_sec_tabs == \"tabs\":\n                    for tab, position_size in variables.items():\n                        for position_size, sym in position_size.items():\n                            geometry[domain][prim_sec_tabs][tab][\n                                position_size\n                            ] = self.process_symbol(sym)\n                else:\n                    for spatial_variable, spatial_limits in variables.items():\n                        for lim, sym in spatial_limits.items():\n                            geometry[domain][prim_sec_tabs][spatial_variable][\n                                lim\n                            ] = self.process_symbol(sym)",
  "def process_symbol(self, symbol):\n        \"\"\"Walk through the symbol and replace any Parameter with a Value.\n        If a symbol has already been processed, the stored value is returned.\n\n        Parameters\n        ----------\n        symbol : :class:`pybamm.Symbol`\n            Symbol or Expression tree to set parameters for\n\n        Returns\n        -------\n        symbol : :class:`pybamm.Symbol`\n            Symbol with Parameter instances replaced by Value\n\n        \"\"\"\n\n        try:\n            return self._processed_symbols[symbol.id]\n        except KeyError:\n            processed_symbol = self._process_symbol(symbol)\n\n            self._processed_symbols[symbol.id] = processed_symbol\n            return processed_symbol",
  "def _process_symbol(self, symbol):\n        \"\"\" See :meth:`ParameterValues.process_symbol()`. \"\"\"\n\n        if isinstance(symbol, pybamm.Parameter):\n            value = self[symbol.name]\n            # Scalar inherits name (for updating parameters) and domain (for Broadcast)\n            return pybamm.Scalar(value, name=symbol.name, domain=symbol.domain)\n\n        elif isinstance(symbol, pybamm.FunctionParameter):\n            new_children = [self.process_symbol(child) for child in symbol.children]\n            function_name = self[symbol.name]\n\n            # if current setter, process any parameters that are symbols and\n            # store the evaluated symbol in the parameters_eval dict\n            if isinstance(function_name, pybamm.GetCurrent):\n                for param, sym in function_name.parameters.items():\n                    if isinstance(sym, pybamm.Symbol):\n                        new_sym = self.process_symbol(sym)\n                        function_name.parameters[param] = new_sym\n                        function_name.parameters_eval[param] = new_sym.evaluate()\n                # If loading data, need to update interpolant with\n                # evaluated parameters\n                if isinstance(function_name, pybamm.GetCurrentData):\n                    function_name.interpolate()\n\n            # Create Function or Interpolant objec\n            if isinstance(function_name, tuple):\n                # If function_name is a tuple then it should be (name, data) and we need\n                # to create an Interpolant\n                name, data = function_name\n                function = pybamm.Interpolant(data, *new_children, name=name)\n            else:\n                # otherwise create standard function\n                function = pybamm.Function(function_name, *new_children)\n            # Differentiate if necessary\n            if symbol.diff_variable is None:\n                return function\n            else:\n                # return differentiated function\n                new_diff_variable = self.process_symbol(symbol.diff_variable)\n                return function.diff(new_diff_variable)\n\n        elif isinstance(symbol, pybamm.BinaryOperator):\n            # process children\n            new_left = self.process_symbol(symbol.left)\n            new_right = self.process_symbol(symbol.right)\n            # make new symbol, ensure domain remains the same\n            new_symbol = symbol.__class__(new_left, new_right)\n            new_symbol.domain = symbol.domain\n            return new_symbol\n\n        # Unary operators\n        elif isinstance(symbol, pybamm.UnaryOperator):\n            new_child = self.process_symbol(symbol.child)\n            new_symbol = symbol._unary_new_copy(new_child)\n            # ensure domain remains the same\n            new_symbol.domain = symbol.domain\n            return new_symbol\n\n        # Functions\n        elif isinstance(symbol, pybamm.Function):\n            new_children = [self.process_symbol(child) for child in symbol.children]\n            return symbol._function_new_copy(new_children)\n\n        # Concatenations\n        elif isinstance(symbol, pybamm.Concatenation):\n            new_children = [self.process_symbol(child) for child in symbol.children]\n            return symbol._concatenation_new_copy(new_children)\n\n        else:\n            # Backup option: return new copy of the object\n            try:\n                return symbol.new_copy()\n            except NotImplementedError:\n                raise NotImplementedError(\n                    \"Cannot process parameters for symbol of type '{}'\".format(\n                        type(symbol)\n                    )\n                )",
  "def update_scalars(self, symbol):\n        \"\"\"Update the value of any Scalars in the expression tree.\n\n        Parameters\n        ----------\n        symbol : :class:`pybamm.Symbol`\n            Symbol or Expression tree to update\n\n        Returns\n        -------\n        symbol : :class:`pybamm.Symbol`\n            Symbol with Scalars updated\n\n        \"\"\"\n        for x in symbol.pre_order():\n            if isinstance(x, pybamm.Scalar):\n                # update any Scalar nodes if their name is in the parameter dict\n                try:\n                    x.value = self[x.name]\n                    # update id\n                    x.set_id()\n                except KeyError:\n                    # KeyError -> name not in parameter dict, don't update\n                    continue\n            elif isinstance(x, pybamm.Function):\n                if isinstance(x.function, pybamm.GetCurrent):\n                    # Need to update parameters dict to be that of the new current\n                    # function and make new parameters_eval dict to be processed\n                    x.function.parameters = self[\"Current function\"].parameters\n                    x.function.parameters_eval = x.function.parameters.copy()\n                    for param, sym in x.function.parameters.items():\n                        # Need to process again as new symbols may be passed\n                        # e.g. may explicitly pass pybamm.Scalar(1) instead of\n                        # pybamm.electrical_parameters.I_typ\n                        if isinstance(sym, pybamm.Symbol):\n                            new_sym = self.process_symbol(sym)\n                            x.function.parameters[param] = new_sym\n                            try:\n                                x.function.parameters_eval[param] = self[new_sym.name]\n                            except KeyError:\n                                # KeyError -> name not in parameter dict, evaluate\n                                # unnamed Scalar\n                                x.function.parameters_eval[param] = new_sym.evaluate()\n                    if isinstance(x.function, pybamm.GetCurrentData):\n                        # update interpolant\n                        x.function.interpolate()\n\n        return symbol",
  "def evaluate(self, symbol):\n        \"\"\"\n        Process and evaluate a symbol.\n\n        Parameters\n        ----------\n        symbol : :class:`pybamm.Symbol`\n            Symbol or Expression tree to evaluate\n\n        Returns\n        -------\n        number of array\n            The evaluated symbol\n        \"\"\"\n        processed_symbol = self.process_symbol(symbol)\n        if processed_symbol.is_constant() and processed_symbol.evaluates_to_number():\n            return processed_symbol.evaluate()\n        else:\n            raise ValueError(\"symbol must evaluate to a constant scalar\")",
  "def abs_non_zero(x):\n    if x == 0:  # pragma: no cover\n        return 1\n    else:\n        return abs(x)",
  "def D_e_dimensional(c_e, T):\n    \"Dimensional diffusivity in electrolyte\"\n    return pybamm.FunctionParameter(\"Electrolyte diffusivity [m2.s-1]\", c_e)",
  "def kappa_e_dimensional(c_e, T):\n    \"Dimensional electrolyte conductivity\"\n    return pybamm.FunctionParameter(\"Electrolyte conductivity [S.m-1]\", c_e)",
  "def chi_dimensional(c_e):\n    return pybamm.FunctionParameter(\"Darken thermodynamic factor\", c_e)",
  "def c_w_dimensional(c_e, c_ox=0, c_hy=0):\n    \"\"\"\n    Water concentration [mol.m-3], from thermodynamics. c_k in [mol.m-3].\n    \"\"\"\n    return (1 - c_e * V_e - c_ox * V_ox - c_hy * V_hy) / V_w",
  "def c_T(c_e, c_ox=0, c_hy=0):\n    \"\"\"\n    Total liquid molarity [mol.m-3], from thermodynamics. c_k in [mol.m-3].\n    \"\"\"\n    return (1 + (2 * V_w - V_e) * c_e + (V_w - V_ox) * c_ox + (V_w - V_hy) * c_hy) / V_w",
  "def rho_dimensional(c_e, c_ox=0, c_hy=0):\n    \"\"\"\n    Dimensional density of electrolyte [kg.m-3], from thermodynamics. c_k in [mol.m-3].\n    \"\"\"\n    return (\n        M_w / V_w\n        + (M_e - V_e * M_w / V_w) * c_e\n        + (M_ox - V_ox * M_w / V_w) * c_ox\n        + (M_hy - V_hy * M_w / V_w) * c_hy\n    )",
  "def m_dimensional(c_e):\n    \"\"\"\n    Dimensional electrolyte molar mass [mol.kg-1], from thermodynamics.\n    c_e in [mol.m-3].\n    \"\"\"\n    return c_e * V_w / ((1 - c_e * V_e) * M_w)",
  "def mu_dimensional(c_e):\n    \"\"\"\n    Dimensional viscosity of electrolyte [kg.m-1.s-1].\n    \"\"\"\n    return pybamm.FunctionParameter(\"Electrolyte viscosity [kg.m-1.s-1]\", c_e)",
  "def U_n_dimensional(c_e, T):\n    \"Dimensional open-circuit voltage in the negative electrode [V]\"\n    return pybamm.FunctionParameter(\n        \"Negative electrode open-circuit potential [V]\", m_dimensional(c_e)\n    )",
  "def U_p_dimensional(c_e, T):\n    \"Dimensional open-circuit voltage in the positive electrode [V]\"\n    return pybamm.FunctionParameter(\n        \"Positive electrode open-circuit potential [V]\", m_dimensional(c_e)\n    )",
  "def D_e(c_e, T):\n    \"Dimensionless electrolyte diffusivity\"\n    c_e_dimensional = c_e * c_e_typ\n    return D_e_dimensional(c_e_dimensional, T_ref) / D_e_typ",
  "def kappa_e(c_e, T):\n    \"Dimensionless electrolyte conductivity\"\n    c_e_dimensional = c_e * c_e_typ\n    kappa_scale = F ** 2 * D_e_typ * c_e_typ / (R * T_ref)\n    return kappa_e_dimensional(c_e_dimensional, T_ref) / kappa_scale",
  "def chi(c_e, c_ox=0, c_hy=0):\n    return (\n        chi_dimensional(c_e_typ * c_e)\n        * (2 * (1 - t_plus))\n        / (V_w * c_T(c_e_typ * c_e, c_e_typ * c_ox, c_e_typ * c_hy))\n    )",
  "def c_w(c_e):\n    \"Dimensionless water concentration\"\n    return c_w_dimensional(c_e_typ * c_e) / c_w_dimensional(c_e_typ)",
  "def m_n(T):\n    \"Dimensionless negative electrode reaction rate\"\n    return 1",
  "def m_p(T):\n    \"Dimensionless positive electrode reaction rate\"\n    return 1",
  "def U_n(c_e_n, T):\n    \"Dimensionless open-circuit voltage in the negative electrode\"\n    c_e_n_dimensional = c_e_n * c_e_typ\n    return (U_n_dimensional(c_e_n_dimensional, T_ref) - U_n_ref) / potential_scale",
  "def U_p(c_e_p, T):\n    \"Dimensionless open-circuit voltage in the positive electrode\"\n    c_e_p_dimensional = c_e_p * c_e_typ\n    return (U_p_dimensional(c_e_p_dimensional, T_ref) - U_p_ref) / potential_scale",
  "def D_e_dimensional(c_e, T):\n    \"Dimensional diffusivity in electrolyte\"\n    return pybamm.FunctionParameter(\n        \"Electrolyte diffusivity [m2.s-1]\", c_e, T, T_ref, E_D_e, R\n    )",
  "def kappa_e_dimensional(c_e, T):\n    \"Dimensional electrolyte conductivity\"\n    return pybamm.FunctionParameter(\n        \"Electrolyte conductivity [S.m-1]\", c_e, T, T_ref, E_k_e, R\n    )",
  "def D_n_dimensional(c_n, T):\n    \"Dimensional diffusivity in negative particle\"\n    return pybamm.FunctionParameter(\n        \"Negative electrode diffusivity [m2.s-1]\", c_n, T, T_ref, E_D_s_n, R\n    )",
  "def D_p_dimensional(c_p, T):\n    \"Dimensional diffusivity in positive particle\"\n    return pybamm.FunctionParameter(\n        \"Positive electrode diffusivity [m2.s-1]\", c_p, T, T_ref, E_D_s_p, R\n    )",
  "def m_n_dimensional(T):\n    \"Dimensional negative reaction rate\"\n    return pybamm.FunctionParameter(\n        \"Negative electrode reaction rate\", T, T_ref, E_r_n, R\n    )",
  "def m_p_dimensional(T):\n    \"Dimensional negative reaction rate\"\n    return pybamm.FunctionParameter(\n        \"Positive electrode reaction rate\", T, T_ref, E_r_p, R\n    )",
  "def dUdT_n_dimensional(sto):\n    \"\"\"\n    Dimensional entropic change of the negative electrode open-circuit potential [V.K-1]\n    \"\"\"\n    return pybamm.FunctionParameter(\n        \"Negative electrode OCP entropic change [V.K-1]\", sto, c_n_max\n    )",
  "def dUdT_p_dimensional(sto):\n    \"\"\"\n    Dimensional entropic change of the positive electrode open-circuit potential [V.K-1]\n    \"\"\"\n    return pybamm.FunctionParameter(\n        \"Positive electrode OCP entropic change [V.K-1]\", sto, c_p_max\n    )",
  "def U_n_dimensional(sto, T):\n    \"Dimensional open-circuit potential in the negative electrode [V]\"\n    u_ref = pybamm.FunctionParameter(\"Negative electrode OCP [V]\", sto)\n    return u_ref + (T - T_ref) * dUdT_n_dimensional(sto)",
  "def U_p_dimensional(sto, T):\n    \"Dimensional open-circuit potential in the positive electrode [V]\"\n    u_ref = pybamm.FunctionParameter(\"Positive electrode OCP [V]\", sto)\n    return u_ref + (T - T_ref) * dUdT_p_dimensional(sto)",
  "def chi(c_e):\n    return 2 * (1 - t_plus)",
  "def D_e(c_e, T):\n    \"Dimensionless electrolyte diffusivity\"\n    c_e_dimensional = c_e * c_e_typ\n    T_dim = Delta_T * T + T_ref\n    return D_e_dimensional(c_e_dimensional, T_dim) / D_e_dimensional(c_e_typ, T_ref)",
  "def kappa_e(c_e, T):\n    \"Dimensionless electrolyte conductivity\"\n    c_e_dimensional = c_e * c_e_typ\n    kappa_scale = F ** 2 * D_e_dimensional(c_e_typ, T_ref) * c_e_typ / (R * T_ref)\n    T_dim = Delta_T * T + T_ref\n    return kappa_e_dimensional(c_e_dimensional, T_dim) / kappa_scale",
  "def D_n(c_s_n, T):\n    \"Dimensionless negative particle diffusivity\"\n    c_s_n_dimensional = c_s_n * c_n_max\n    T_dim = Delta_T * T + T_ref\n    return D_n_dimensional(c_s_n_dimensional, T_dim) / D_n_dimensional(c_n_max, T_ref)",
  "def D_p(c_s_p, T):\n    \"Dimensionless positive particle diffusivity\"\n    c_s_p_dimensional = c_s_p * c_p_max\n    T_dim = Delta_T * T + T_ref\n    return D_p_dimensional(c_s_p_dimensional, T_dim) / D_p_dimensional(c_p_max, T_ref)",
  "def m_n(T):\n    \"Dimensionless negative reaction rate\"\n    T_dim = Delta_T * T + T_ref\n    return m_n_dimensional(T_dim) / m_n_ref_dimensional",
  "def m_p(T):\n    \"Dimensionless positive reaction rate\"\n    T_dim = Delta_T * T + T_ref\n    return m_p_dimensional(T_dim) / m_p_ref_dimensional",
  "def U_n(c_s_n, T):\n    \"Dimensionless open-circuit potential in the negative electrode\"\n    sto = c_s_n\n    return (U_n_dimensional(sto, T) - U_n_ref) / potential_scale",
  "def U_p(c_s_p, T):\n    \"Dimensionless open-circuit potential in the positive electrode\"\n    sto = c_s_p\n    return (U_p_dimensional(sto, T) - U_p_ref) / potential_scale",
  "def dUdT_n(c_s_n):\n    \"Dimensionless entropic change in negative open-circuit potential\"\n    sto = c_s_n\n    return dUdT_n_dimensional(sto) * Delta_T / potential_scale",
  "def dUdT_p(c_s_p):\n    \"Dimensionless entropic change in positive open-circuit potential\"\n    sto = c_s_p\n    return dUdT_p_dimensional(sto) * Delta_T / potential_scale",
  "def print_parameters(parameters, parameter_values, output_file=None):\n    \"\"\"\n    Return dictionary of evaluated parameters, and optionally print these evaluated\n    parameters to an output file.\n    For dimensionless parameters that depend on the C-rate, the value is given as a\n    function of the C-rate (either x * Crate or x / Crate depending on the dependence)\n\n    Parameters\n    ----------\n    parameters : class or dict containing :class:`pybamm.Parameter` objects\n        Class or dictionary containing all the parameters to be evaluated\n    parameter_values : :class:`pybamm.ParameterValues`\n        The class of parameter values\n    output_file : string, optional\n        The file to print parameters to. If None, the parameters are not printed, and\n        this function simply acts as a test that all the parameters can be evaluated,\n        and returns the dictionary of evaluated parameters.\n\n    Returns\n    -------\n    evaluated_parameters : defaultdict\n        The evaluated parameters, for further processing if needed\n\n    Notes\n    -----\n    A C-rate of 1 C is the current required to fully discharge the battery in 1 hour,\n    2 C is current to discharge the battery in 0.5 hours, etc\n    \"\"\"\n    # If 'parameters' is a class, extract the dict\n    if not isinstance(parameters, dict):\n        parameters = {k: v for k, v in parameters.__dict__.items() if k not in ignore}\n\n    evaluated_parameters = defaultdict(list)\n    # Calculate parameters for each C-rate\n    for Crate in [1, 10]:\n        # Update Crate\n        parameter_values.update({\"C-rate\": Crate})\n        for name, symbol in parameters.items():\n            if not callable(symbol):\n                proc_symbol = parameter_values.process_symbol(symbol)\n                if not (\n                    callable(proc_symbol)\n                    or isinstance(proc_symbol, pybamm.Concatenation)\n                ):\n                    evaluated_parameters[name].append(proc_symbol.evaluate(t=0))\n\n    # Calculate C-dependence of the parameters based on the difference between the\n    # value at 1C and the value at C / 10\n    for name, values in evaluated_parameters.items():\n        if values[1] == 0 or abs(values[0] / values[1] - 1) < 1e-10:\n            C_dependence = \"\"\n        elif abs(values[0] / values[1] - 10) < 1e-10:\n            C_dependence = \" * Crate\"\n        elif abs(values[0] / values[1] - 0.1) < 1e-10:\n            C_dependence = \" / Crate\"\n        evaluated_parameters[name] = (values[0], C_dependence)\n    # Print the evaluated_parameters dict to output_file\n    if output_file:\n        print_evaluated_parameters(evaluated_parameters, output_file)\n\n    return evaluated_parameters",
  "def print_evaluated_parameters(evaluated_parameters, output_file):\n    \"\"\"\n    Print a dictionary of evaluated parameters to an output file\n\n    Parameters\n    ----------\n    evaluated_parameters : defaultdict\n        The evaluated parameters, for further processing if needed\n    output_file : string, optional\n        The file to print parameters to. If None, the parameters are not printed, and\n        this function simply acts as a test that all the parameters can be evaluated\n\n    \"\"\"\n    # Get column width for pretty printing\n    column_width = max(len(name) for name in evaluated_parameters.keys())\n    s = \"{{:>{}}}\".format(column_width)\n    with open(output_file, \"w\") as file:\n        for name, (value, C_dependence) in sorted(evaluated_parameters.items()):\n            if 0.001 < abs(value) < 1000:\n                file.write((s + \" : {:10.4g}{!s}\\n\").format(name, value, C_dependence))\n            else:\n                file.write((s + \" : {:10.3E}{!s}\\n\").format(name, value, C_dependence))",
  "class GetUserCurrent(pybamm.GetCurrent):\n    \"\"\"\n    Sets a user-defined function as the input current for a simulation.\n\n    Parameters\n    ----------\n    function : method\n        The method which returns the current (in Amperes) as a function of time\n        (in seconds). The first argument of function must be time, followed by\n        any keyword arguments, i.e. function(t, **kwargs).\n    **kwargs : Any keyword arguments required by function.\n\n    **Extends:\"\": :class:`pybamm.GetCurrent`\n    \"\"\"\n\n    def __init__(self, function, **kwargs):\n        self.parameters = kwargs\n        self.parameters_eval = kwargs\n        self.function = function\n\n    def __str__(self):\n        return \"User defined current\"\n\n    def __call__(self, t):\n        return self.function(t, **self.parameters_eval)",
  "def __init__(self, function, **kwargs):\n        self.parameters = kwargs\n        self.parameters_eval = kwargs\n        self.function = function",
  "def __str__(self):\n        return \"User defined current\"",
  "def __call__(self, t):\n        return self.function(t, **self.parameters_eval)",
  "class GetConstantCurrent(pybamm.GetCurrent):\n    \"\"\"\n    Sets a constant input current for a simulation.\n\n    Parameters\n    ----------\n    current : :class:`pybamm.Symbol` or float\n        The size of the current in Amperes.\n\n    **Extends:\"\": :class:`pybamm.GetCurrent`\n    \"\"\"\n\n    def __init__(self, current=pybamm.electrical_parameters.I_typ):\n        self.parameters = {\"Current [A]\": current}\n        self.parameters_eval = {\"Current [A]\": current}\n\n    def __str__(self):\n        return \"Constant current\"\n\n    def __call__(self, t):\n        return self.parameters_eval[\"Current [A]\"]",
  "def __init__(self, current=pybamm.electrical_parameters.I_typ):\n        self.parameters = {\"Current [A]\": current}\n        self.parameters_eval = {\"Current [A]\": current}",
  "def __str__(self):\n        return \"Constant current\"",
  "def __call__(self, t):\n        return self.parameters_eval[\"Current [A]\"]",
  "class GetCurrentData(pybamm.GetCurrent):\n    \"\"\"\n    A class which loads a current profile from a csv file and creates an\n    interpolating function which can be called during solve.\n\n    Parameters\n    ----------\n    filename : str\n        The name of the file to load.\n    units : str, optional\n        The units of the current data which is to be loaded. Can be \"[]\" for\n        dimenionless data (default), or \"[A]\" for current in Amperes.\n    current_scale : :class:`pybamm.Symbol` or float, optional\n        The scale the current in Amperes if loading non-dimensional data. Default\n        is to use the typical current I_typ\n\n    **Extends:\"\": :class:`pybamm.GetCurrent`\n    \"\"\"\n\n    def __init__(\n        self, filename, units=\"[]\", current_scale=pybamm.electrical_parameters.I_typ\n    ):\n        self.parameters = {\"Current [A]\": current_scale}\n        self.parameters_eval = {\"Current [A]\": current_scale}\n\n        # Load data from csv\n        if filename:\n            pybamm_path = pybamm.root_dir()\n            data = pd.read_csv(\n                os.path.join(pybamm_path, \"input\", \"drive_cycles\", filename),\n                comment=\"#\",\n                skip_blank_lines=True,\n            ).to_dict(\"list\")\n\n            self.time = np.array(data[\"time [s]\"])\n            self.units = units\n            self.current = np.array(data[\"current \" + units])\n            # If voltage data is present, load it into the class\n            try:\n                self.voltage = np.array(data[\"voltage [V]\"])\n            except KeyError:\n                self.voltage = None\n        else:\n            raise pybamm.ModelError(\"No input file provided for current\")\n\n    def __str__(self):\n        return \"Current from data\"\n\n    def interpolate(self):\n        \" Creates the interpolant from the loaded data \"\n        # If data is dimenionless, multiply by a typical current (e.g. data\n        # could be C-rate and current_scale the 1C discharge current). Otherwise,\n        # just import the current data.\n        if self.units == \"[]\":\n            current = self.parameters_eval[\"Current [A]\"] * self.current\n        elif self.units == \"[A]\":\n            current = self.current\n        else:\n            raise pybamm.ModelError(\n                \"Current data must have units [A] or be dimensionless\"\n            )\n        # Interpolate using Piecewise Cubic Hermite Interpolating Polynomial\n        # (does not overshoot non-smooth data)\n        self.current_interp = interp.PchipInterpolator(self.time, current)\n\n    def __call__(self, t):\n        \"\"\"\n        Calls the interpolating function created using the data from user-supplied\n        data file at time t (seconds).\n        \"\"\"\n\n        if np.min(t) < self.time[0] or np.max(t) > self.time[-1]:\n            warnings.warn(\n                \"Requested time ({}) is outside of the data range [{}, {}]\".format(\n                    t, self.time[0], self.time[-1]\n                ),\n                pybamm.ModelWarning,\n            )\n\n        return self.current_interp(t)",
  "def __init__(\n        self, filename, units=\"[]\", current_scale=pybamm.electrical_parameters.I_typ\n    ):\n        self.parameters = {\"Current [A]\": current_scale}\n        self.parameters_eval = {\"Current [A]\": current_scale}\n\n        # Load data from csv\n        if filename:\n            pybamm_path = pybamm.root_dir()\n            data = pd.read_csv(\n                os.path.join(pybamm_path, \"input\", \"drive_cycles\", filename),\n                comment=\"#\",\n                skip_blank_lines=True,\n            ).to_dict(\"list\")\n\n            self.time = np.array(data[\"time [s]\"])\n            self.units = units\n            self.current = np.array(data[\"current \" + units])\n            # If voltage data is present, load it into the class\n            try:\n                self.voltage = np.array(data[\"voltage [V]\"])\n            except KeyError:\n                self.voltage = None\n        else:\n            raise pybamm.ModelError(\"No input file provided for current\")",
  "def __str__(self):\n        return \"Current from data\"",
  "def interpolate(self):\n        \" Creates the interpolant from the loaded data \"\n        # If data is dimenionless, multiply by a typical current (e.g. data\n        # could be C-rate and current_scale the 1C discharge current). Otherwise,\n        # just import the current data.\n        if self.units == \"[]\":\n            current = self.parameters_eval[\"Current [A]\"] * self.current\n        elif self.units == \"[A]\":\n            current = self.current\n        else:\n            raise pybamm.ModelError(\n                \"Current data must have units [A] or be dimensionless\"\n            )\n        # Interpolate using Piecewise Cubic Hermite Interpolating Polynomial\n        # (does not overshoot non-smooth data)\n        self.current_interp = interp.PchipInterpolator(self.time, current)",
  "def __call__(self, t):\n        \"\"\"\n        Calls the interpolating function created using the data from user-supplied\n        data file at time t (seconds).\n        \"\"\"\n\n        if np.min(t) < self.time[0] or np.max(t) > self.time[-1]:\n            warnings.warn(\n                \"Requested time ({}) is outside of the data range [{}, {}]\".format(\n                    t, self.time[0], self.time[-1]\n                ),\n                pybamm.ModelWarning,\n            )\n\n        return self.current_interp(t)",
  "class GetCurrent(object):\n    \"\"\"\n    The base class for setting the input current for a simulation. The parameters\n    dictionary holds the symbols of any paramters required to evaluate the current.\n    During processing, the evaluated parameters are stored in parameters_eval.\n    \"\"\"\n\n    def __init__(self):\n        self.parameters = {}\n        self.parameters_eval = {}\n\n    def __str__(self):\n        return \"Base current\"\n\n    def __call__(self, t):\n        return 1",
  "def __init__(self):\n        self.parameters = {}\n        self.parameters_eval = {}",
  "def __str__(self):\n        return \"Base current\"",
  "def __call__(self, t):\n        return 1",
  "class SubMesh0D(SubMesh):\n    \"\"\"\n    0D submesh class.\n    Contains the position of the node.\n\n    Parameters\n    ----------\n    position : dict\n        A dictionary that contains the position of the 0D submesh (a signle point)\n        in space\n    npts : dict, optional\n        Number of points to be used. Included for compatibility with other meshes,\n        but ignored by this mesh class\n    tabs : dict\n        A dictionary that contains information about the size and location of\n        the tabs. Included for compatibility with other meshes, but\n        ignored by this mesh class\n\n    **Extends:\"\": :class:`pybamm.SubMesh`\n    \"\"\"\n\n    def __init__(self, position, npts=None, tabs=None):\n        # check that only one variable passed in\n        if len(position) != 1:\n            raise pybamm.GeometryError(\"position should only contain a single variable\")\n\n        spatial_position = list(position.values())[0]\n        self.nodes = np.array([spatial_position])\n        self.edges = np.array([spatial_position])\n        self.coord_sys = None\n        self.npts = 1\n\n    def add_ghost_meshes(self):\n        # No ghost meshes to be added to this class\n        pass",
  "def __init__(self, position, npts=None, tabs=None):\n        # check that only one variable passed in\n        if len(position) != 1:\n            raise pybamm.GeometryError(\"position should only contain a single variable\")\n\n        spatial_position = list(position.values())[0]\n        self.nodes = np.array([spatial_position])\n        self.edges = np.array([spatial_position])\n        self.coord_sys = None\n        self.npts = 1",
  "def add_ghost_meshes(self):\n        # No ghost meshes to be added to this class\n        pass",
  "class SubMesh1D(SubMesh):\n    \"\"\"\n    1D submesh class.\n    Contains the position of the nodes, the number of mesh points, and\n    (optionally) information about the tab locations.\n\n    Parameters\n    ----------\n    edges : array_like\n        An array containing the points corresponding to the edges of the submesh\n    coord_sys : string\n        The coordinate system of the submesh\n    tabs : dict, optional\n        A dictionary that contains information about the size and location of\n        the tabs\n\n    **Extends:\"\": :class:`pybamm.SubMesh`\n    \"\"\"\n\n    def __init__(self, edges, coord_sys, tabs=None):\n        self.edges = edges\n        self.nodes = (self.edges[1:] + self.edges[:-1]) / 2\n        self.d_edges = np.diff(self.edges)\n        self.d_nodes = np.diff(self.nodes)\n        self.npts = self.nodes.size\n        self.coord_sys = coord_sys\n\n        # Add tab locations in terms of \"left\" and \"right\"\n        if tabs:\n            self.tabs = {}\n            l_z = self.edges[-1]\n\n            def near(x, point, tol=3e-16):\n                return abs(x - point) < tol\n\n            for tab in [\"negative\", \"positive\"]:\n                tab_location = tabs[tab][\"z_centre\"]\n                if near(tab_location, 0):\n                    self.tabs[tab + \" tab\"] = \"left\"\n                elif near(tab_location, l_z):\n                    self.tabs[tab + \" tab\"] = \"right\"\n                else:\n                    raise pybamm.GeometryError(\n                        \"\"\"{} tab located at {}, but must be at either 0 or {}\n                        (in dimensionless coordinates).\"\"\".format(\n                            tab, tab_location, l_z\n                        )\n                    )",
  "class Uniform1DSubMesh(SubMesh1D):\n    \"\"\"\n    A class to generate a uniform submesh on a 1D domain\n\n    Parameters\n    ----------\n    lims : dict\n        A dictionary that contains the limits of the spatial variables\n    npts : dict\n        A dictionary that contains the number of points to be used on each\n        spatial variable. Note: the number of nodes (located at the cell centres)\n        is npts, and the number of edges is npts+1.\n    tabs : dict, optional\n        A dictionary that contains information about the size and location of\n        the tabs\n\n    **Extends:\"\": :class:`pybamm.SubMesh1D`\n    \"\"\"\n\n    def __init__(self, lims, npts, tabs=None):\n\n        # check that only one variable passed in\n        if len(lims) != 1:\n            raise pybamm.GeometryError(\"lims should only contain a single variable\")\n\n        spatial_var = list(lims.keys())[0]\n        spatial_lims = lims[spatial_var]\n        npts = npts[spatial_var.id]\n\n        edges = np.linspace(spatial_lims[\"min\"], spatial_lims[\"max\"], npts + 1)\n\n        coord_sys = spatial_var.coord_sys\n\n        super().__init__(edges, coord_sys=coord_sys, tabs=tabs)",
  "class Exponential1DSubMesh(SubMesh1D):\n    \"\"\"\n    A class to generate a submesh on a 1D domain in which the points are clustered\n    close to one or both of boundaries using an exponential formula on the interval\n    [a,b].\n\n    If side is \"left\", the gridpoints are given by\n\n    .. math::\n        x_{k} = (b-a) + \\\\frac{\\\\exp{\\\\alpha k / N} - 1}{\\\\exp{\\\\alpha} - 1}} + a,\n\n    for k = 1, ..., N, where N is the number of nodes.\n\n    Is side is \"right\", the gridpoints are given by\n\n    .. math::\n        x_{k} = (b-a) + \\\\frac{\\\\exp{-\\\\alpha k / N} - 1}{\\\\exp{-\\\\alpha} - 1}} + a,\n\n    for k = 1, ..., N.\n\n    If side is \"symmetric\", the first half of the interval is meshed using the\n    gridpoints\n\n    .. math::\n        x_{k} = (b/2-a) + \\\\frac{\\\\exp{\\\\alpha k / N} - 1}{\\\\exp{\\\\alpha} - 1}} + a,\n\n    for k = 1, ..., N. The grid spacing is then reflected to contruct the grid\n    on the full interval [a,b].\n\n    In the above, alpha is a stretching factor. As the number of gridpoints tends\n    to infinity, the ratio of the largest and smallest grid cells tends to exp(alpha).\n\n    Parameters\n    ----------\n    lims : dict\n        A dictionary that contains the limits of the spatial variables\n    npts : dict\n        A dictionary that contains the number of points to be used on each\n        spatial variable. Note: the number of nodes (located at the cell centres)\n        is npts, and the number of edges is npts+1.\n    tabs : dict\n        A dictionary that contains information about the size and location of\n        the tabs\n    side : str, optional\n        Whether the points are clustered near to the left or right boundary,\n        or both boundaries. Can be \"left\", \"right\" or \"symmetric\". Default is\n        \"symmetric\"\n    stretch : float, optional\n        The factor (alpha) which appears in the exponential. If side is \"symmetric\"\n        then the default stretch is 1.15. If side is \"left\" or \"right\" then the\n        default stretch is 2.3.\n\n    **Extends:\"\": :class:`pybamm.SubMesh1D`\n    \"\"\"\n\n    def __init__(self, lims, npts, tabs, side=\"symmetric\", stretch=None):\n\n        # check that only one variable passed in\n        if len(lims) != 1:\n            raise pybamm.GeometryError(\"lims should only contain a single variable\")\n\n        spatial_var = list(lims.keys())[0]\n        spatial_lims = lims[spatial_var]\n        a = spatial_lims[\"min\"]\n        b = spatial_lims[\"max\"]\n        npts = npts[spatial_var.id]\n        coord_sys = spatial_var.coord_sys\n\n        # Set stretch if not provided\n        if not stretch:\n            if side == \"symmetric\":\n                stretch = 1.15\n            elif side in [\"left\", \"right\"]:\n                stretch = 2.3\n\n        # Create edges accoriding to \"side\"\n        if side == \"left\":\n            ii = np.array(range(0, npts + 1))\n            edges = (b - a) * (np.exp(stretch * ii / npts) - 1) / (\n                np.exp(stretch) - 1\n            ) + a\n\n        elif side == \"right\":\n            ii = np.array(range(0, npts + 1))\n            edges = (b - a) * (np.exp(-stretch * ii / npts) - 1) / (\n                np.exp(-stretch) - 1\n            ) + a\n\n        elif side == \"symmetric\":\n            # Mesh half-interval [a, b/2]\n            if npts % 2 == 0:\n                ii = np.array(range(0, int((npts) / 2)))\n            else:\n                ii = np.array(range(0, int((npts + 1) / 2)))\n            x_exp_left = (b / 2 - a) * (np.exp(stretch * ii / npts) - 1) / (\n                np.exp(stretch) - 1\n            ) + a\n\n            # Refelct mesh\n            x_exp_right = b * np.ones_like(x_exp_left) - (x_exp_left[::-1] - a)\n\n            # Combine left and right halves of the mesh, adding a node at the\n            # centre if npts is even (odd number of edges)\n            if npts % 2 == 0:\n                edges = np.concatenate((x_exp_left, [(a + b) / 2], x_exp_right))\n            else:\n                edges = np.concatenate((x_exp_left, x_exp_right))\n\n        super().__init__(edges, coord_sys=coord_sys, tabs=tabs)",
  "class Chebyshev1DSubMesh(SubMesh1D):\n    \"\"\"\n    A class to generate a submesh on a 1D domain using Chebyshev nodes on the\n    interval (a, b), given by\n\n    .. math::\n        x_{k} = \\\\frac{1}{2}(a+b) + \\\\frac{1}{2}(b-a) \\\\cos(\\\\frac{2k-1}{2N}\\\\pi),\n\n    for k = 1, ..., N, where N is the number of nodes. Note: this mesh then\n    appends the boundary edges, so that the mesh edges are given by\n\n    .. math::\n        a < x_{1} < ... < x_{N} < b.\n\n    Parameters\n    ----------\n    lims : dict\n        A dictionary that contains the limits of the spatial variables\n    npts : dict\n        A dictionary that contains the number of points to be used on each\n        spatial variable. Note: the number of nodes (located at the cell centres)\n        is npts, and the number of edges is npts+1.\n    tabs : dict, optional\n        A dictionary that contains information about the size and location of\n        the tabs\n\n    **Extends:\"\": :class:`pybamm.SubMesh1D`\n    \"\"\"\n\n    def __init__(self, lims, npts, tabs=None):\n\n        # check that only one variable passed in\n        if len(lims) != 1:\n            raise pybamm.GeometryError(\"lims should only contain a single variable\")\n\n        spatial_var = list(lims.keys())[0]\n        spatial_lims = lims[spatial_var]\n        npts = npts[spatial_var.id]\n\n        # Create N Chebyshev nodes in the interval (a,b)\n        N = npts - 1\n        ii = np.array(range(1, N + 1))\n        a = spatial_lims[\"min\"]\n        b = spatial_lims[\"max\"]\n        x_cheb = (a + b) / 2 + (b - a) / 2 * np.cos((2 * ii - 1) * np.pi / 2 / N)\n\n        # Append the boundary nodes. Note: we need to flip the order the Chebyshev\n        # nodes as they are created in descending order.\n        edges = np.concatenate(([a], np.flip(x_cheb), [b]))\n        coord_sys = spatial_var.coord_sys\n\n        super().__init__(edges, coord_sys=coord_sys, tabs=tabs)",
  "class UserSupplied1DSubMesh(SubMesh1D):\n    \"\"\"\n    A class to generate a submesh on a 1D domain from a user supplied array of\n    edges.\n\n    Parameters\n    ----------\n    lims : dict\n        A dictionary that contains the limits of the spatial variables\n    npts : dict\n        A dictionary that contains the number of points to be used on each\n        spatial variable. Note: the number of nodes (located at the cell centres)\n        is npts, and the number of edges is npts+1.\n    tabs : dict\n        A dictionary that contains information about the size and location of\n        the tabs\n    edges : array_like\n        The array of points which correspond to the edges of the mesh.\n\n    **Extends:\"\": :class:`pybamm.SubMesh1D`\n    \"\"\"\n\n    def __init__(self, lims, npts, tabs, edges=None):\n\n        # raise error if no edges passed\n        if edges is None:\n            raise pybamm.GeometryError(\"User mesh requires parameter 'edges'\")\n\n        # check that only one variable passed in\n        if len(lims) != 1:\n            raise pybamm.GeometryError(\"lims should only contain a single variable\")\n\n        spatial_var = list(lims.keys())[0]\n        spatial_lims = lims[spatial_var]\n        npts = npts[spatial_var.id]\n\n        # check that npts + 1 equals number of user-supplied edges\n        if (npts + 1) != len(edges):\n            raise pybamm.GeometryError(\n                \"\"\"User-suppled edges has should have length (npts + 1) but has length {}.\n                 Number of points (npts) for domain {} is {}.\"\"\".format(\n                    len(edges), spatial_var.domain, npts\n                )\n            )\n\n        # check end points of edges agree with spatial_lims\n        if edges[0] != spatial_lims[\"min\"]:\n            raise pybamm.GeometryError(\n                \"\"\"First entry of edges is {}, but should be equal to {}\n                 for domain {}.\"\"\".format(\n                    edges[0], spatial_lims[\"min\"], spatial_var.domain\n                )\n            )\n        if edges[-1] != spatial_lims[\"max\"]:\n            raise pybamm.GeometryError(\n                \"\"\"Last entry of edges is {}, but should be equal to {}\n                for domain {}.\"\"\".format(\n                    edges[-1], spatial_lims[\"max\"], spatial_var.domain\n                )\n            )\n\n        coord_sys = spatial_var.coord_sys\n\n        super().__init__(edges, coord_sys=coord_sys, tabs=tabs)",
  "def __init__(self, edges, coord_sys, tabs=None):\n        self.edges = edges\n        self.nodes = (self.edges[1:] + self.edges[:-1]) / 2\n        self.d_edges = np.diff(self.edges)\n        self.d_nodes = np.diff(self.nodes)\n        self.npts = self.nodes.size\n        self.coord_sys = coord_sys\n\n        # Add tab locations in terms of \"left\" and \"right\"\n        if tabs:\n            self.tabs = {}\n            l_z = self.edges[-1]\n\n            def near(x, point, tol=3e-16):\n                return abs(x - point) < tol\n\n            for tab in [\"negative\", \"positive\"]:\n                tab_location = tabs[tab][\"z_centre\"]\n                if near(tab_location, 0):\n                    self.tabs[tab + \" tab\"] = \"left\"\n                elif near(tab_location, l_z):\n                    self.tabs[tab + \" tab\"] = \"right\"\n                else:\n                    raise pybamm.GeometryError(\n                        \"\"\"{} tab located at {}, but must be at either 0 or {}\n                        (in dimensionless coordinates).\"\"\".format(\n                            tab, tab_location, l_z\n                        )\n                    )",
  "def __init__(self, lims, npts, tabs=None):\n\n        # check that only one variable passed in\n        if len(lims) != 1:\n            raise pybamm.GeometryError(\"lims should only contain a single variable\")\n\n        spatial_var = list(lims.keys())[0]\n        spatial_lims = lims[spatial_var]\n        npts = npts[spatial_var.id]\n\n        edges = np.linspace(spatial_lims[\"min\"], spatial_lims[\"max\"], npts + 1)\n\n        coord_sys = spatial_var.coord_sys\n\n        super().__init__(edges, coord_sys=coord_sys, tabs=tabs)",
  "def __init__(self, lims, npts, tabs, side=\"symmetric\", stretch=None):\n\n        # check that only one variable passed in\n        if len(lims) != 1:\n            raise pybamm.GeometryError(\"lims should only contain a single variable\")\n\n        spatial_var = list(lims.keys())[0]\n        spatial_lims = lims[spatial_var]\n        a = spatial_lims[\"min\"]\n        b = spatial_lims[\"max\"]\n        npts = npts[spatial_var.id]\n        coord_sys = spatial_var.coord_sys\n\n        # Set stretch if not provided\n        if not stretch:\n            if side == \"symmetric\":\n                stretch = 1.15\n            elif side in [\"left\", \"right\"]:\n                stretch = 2.3\n\n        # Create edges accoriding to \"side\"\n        if side == \"left\":\n            ii = np.array(range(0, npts + 1))\n            edges = (b - a) * (np.exp(stretch * ii / npts) - 1) / (\n                np.exp(stretch) - 1\n            ) + a\n\n        elif side == \"right\":\n            ii = np.array(range(0, npts + 1))\n            edges = (b - a) * (np.exp(-stretch * ii / npts) - 1) / (\n                np.exp(-stretch) - 1\n            ) + a\n\n        elif side == \"symmetric\":\n            # Mesh half-interval [a, b/2]\n            if npts % 2 == 0:\n                ii = np.array(range(0, int((npts) / 2)))\n            else:\n                ii = np.array(range(0, int((npts + 1) / 2)))\n            x_exp_left = (b / 2 - a) * (np.exp(stretch * ii / npts) - 1) / (\n                np.exp(stretch) - 1\n            ) + a\n\n            # Refelct mesh\n            x_exp_right = b * np.ones_like(x_exp_left) - (x_exp_left[::-1] - a)\n\n            # Combine left and right halves of the mesh, adding a node at the\n            # centre if npts is even (odd number of edges)\n            if npts % 2 == 0:\n                edges = np.concatenate((x_exp_left, [(a + b) / 2], x_exp_right))\n            else:\n                edges = np.concatenate((x_exp_left, x_exp_right))\n\n        super().__init__(edges, coord_sys=coord_sys, tabs=tabs)",
  "def __init__(self, lims, npts, tabs=None):\n\n        # check that only one variable passed in\n        if len(lims) != 1:\n            raise pybamm.GeometryError(\"lims should only contain a single variable\")\n\n        spatial_var = list(lims.keys())[0]\n        spatial_lims = lims[spatial_var]\n        npts = npts[spatial_var.id]\n\n        # Create N Chebyshev nodes in the interval (a,b)\n        N = npts - 1\n        ii = np.array(range(1, N + 1))\n        a = spatial_lims[\"min\"]\n        b = spatial_lims[\"max\"]\n        x_cheb = (a + b) / 2 + (b - a) / 2 * np.cos((2 * ii - 1) * np.pi / 2 / N)\n\n        # Append the boundary nodes. Note: we need to flip the order the Chebyshev\n        # nodes as they are created in descending order.\n        edges = np.concatenate(([a], np.flip(x_cheb), [b]))\n        coord_sys = spatial_var.coord_sys\n\n        super().__init__(edges, coord_sys=coord_sys, tabs=tabs)",
  "def __init__(self, lims, npts, tabs, edges=None):\n\n        # raise error if no edges passed\n        if edges is None:\n            raise pybamm.GeometryError(\"User mesh requires parameter 'edges'\")\n\n        # check that only one variable passed in\n        if len(lims) != 1:\n            raise pybamm.GeometryError(\"lims should only contain a single variable\")\n\n        spatial_var = list(lims.keys())[0]\n        spatial_lims = lims[spatial_var]\n        npts = npts[spatial_var.id]\n\n        # check that npts + 1 equals number of user-supplied edges\n        if (npts + 1) != len(edges):\n            raise pybamm.GeometryError(\n                \"\"\"User-suppled edges has should have length (npts + 1) but has length {}.\n                 Number of points (npts) for domain {} is {}.\"\"\".format(\n                    len(edges), spatial_var.domain, npts\n                )\n            )\n\n        # check end points of edges agree with spatial_lims\n        if edges[0] != spatial_lims[\"min\"]:\n            raise pybamm.GeometryError(\n                \"\"\"First entry of edges is {}, but should be equal to {}\n                 for domain {}.\"\"\".format(\n                    edges[0], spatial_lims[\"min\"], spatial_var.domain\n                )\n            )\n        if edges[-1] != spatial_lims[\"max\"]:\n            raise pybamm.GeometryError(\n                \"\"\"Last entry of edges is {}, but should be equal to {}\n                for domain {}.\"\"\".format(\n                    edges[-1], spatial_lims[\"max\"], spatial_var.domain\n                )\n            )\n\n        coord_sys = spatial_var.coord_sys\n\n        super().__init__(edges, coord_sys=coord_sys, tabs=tabs)",
  "def near(x, point, tol=3e-16):\n                return abs(x - point) < tol",
  "class Mesh(dict):\n    \"\"\"\n    Mesh contains a list of submeshes on each subdomain.\n\n    **Extends**: dict\n\n    Parameters\n    ----------\n\n    geometry : :class: `Geometry`\n        contains the geometry of the problem.\n    submesh_types: dict\n        contains the types of submeshes to use (e.g. Uniform1DSubMesh)\n    submesh_pts: dict\n        contains the number of points on each subdomain\n\n    \"\"\"\n\n    def __init__(self, geometry, submesh_types, var_pts):\n        super().__init__()\n        # convert var_pts to an id dict\n        var_id_pts = {var.id: pts for var, pts in var_pts.items()}\n\n        # create submesh_pts from var_pts\n        submesh_pts = {}\n        for domain in geometry:\n            # create mesh generator if just class is passed (will throw an error\n            # later if the mesh needed parameters)\n            if not isinstance(\n                submesh_types[domain], pybamm.MeshGenerator\n            ) and issubclass(submesh_types[domain], pybamm.SubMesh):\n                submesh_types[domain] = pybamm.MeshGenerator(submesh_types[domain])\n            # Zero dimensional submesh case (only one point)\n            if issubclass(submesh_types[domain].submesh_type, pybamm.SubMesh0D):\n                submesh_pts[domain] = 1\n            # other cases\n            else:\n                submesh_pts[domain] = {}\n                if len(list(geometry[domain][\"primary\"].keys())) > 2:\n                    raise pybamm.GeometryError\n                for prim_sec in list(geometry[domain].keys()):\n                    # skip over tabs key\n                    if prim_sec != \"tabs\":\n                        for var in list(geometry[domain][prim_sec].keys()):\n                            # Raise error if the number of points for a particular\n                            # variable haven't been provided, unless that variable\n                            # doesn't appear in the geometry\n                            if (\n                                var.id not in var_id_pts.keys()\n                                and var.domain[0] in geometry.keys()\n                            ):\n                                raise KeyError(\n                                    \"\"\"\n                                    Points not given for a variable in domain {}\n                                    \"\"\".format(\n                                        domain\n                                    )\n                                )\n                            # Otherwise add to the dictionary of submesh points\n                            submesh_pts[domain][var.id] = var_id_pts[var.id]\n        self.submesh_pts = submesh_pts\n\n        # Input domain order manually\n        self.domain_order = []\n        # First the macroscale domains, whose order we care about\n        for domain in [\"negative electrode\", \"separator\", \"positive electrode\"]:\n            if domain in geometry:\n                self.domain_order.append(domain)\n        # Then the remaining domains\n        for domain in geometry:\n            if domain not in [\"negative electrode\", \"separator\", \"positive electrode\"]:\n                self.domain_order.append(domain)\n\n        # evaluate any expressions in geometry\n        for domain in geometry:\n            for prim_sec_tabs, variables in geometry[domain].items():\n                # process tab information if using 1 or 2D current collectors\n                if prim_sec_tabs == \"tabs\":\n                    for tab, position_size in variables.items():\n                        for position_size, sym in position_size.items():\n                            if isinstance(sym, pybamm.Symbol):\n                                sym_eval = sym.evaluate()\n                                geometry[domain][prim_sec_tabs][tab][\n                                    position_size\n                                ] = sym_eval\n                else:\n                    for spatial_variable, spatial_limits in variables.items():\n                        for lim, sym in spatial_limits.items():\n                            if isinstance(sym, pybamm.Symbol):\n                                sym_eval = sym.evaluate()\n                                geometry[domain][prim_sec_tabs][spatial_variable][\n                                    lim\n                                ] = sym_eval\n\n        # Create submeshes\n        for domain in geometry:\n            # repeat mesh if domain has secondary dimension\n            if \"secondary\" in geometry[domain].keys():\n                repeats = 1\n                for var in geometry[domain][\"secondary\"].keys():\n                    repeats *= submesh_pts[domain][var.id]  # note (specific to FV)\n            else:\n                repeats = 1\n            # create submesh, passing tab information if provided\n            if \"tabs\" in geometry[domain].keys():\n                self[domain] = [\n                    submesh_types[domain](\n                        geometry[domain][\"primary\"],\n                        submesh_pts[domain],\n                        geometry[domain][\"tabs\"],\n                    )\n                ] * repeats\n            else:\n                self[domain] = [\n                    submesh_types[domain](\n                        geometry[domain][\"primary\"], submesh_pts[domain]\n                    )\n                ] * repeats\n\n        # add ghost meshes\n        self.add_ghost_meshes()\n\n    def combine_submeshes(self, *submeshnames):\n        \"\"\"Combine submeshes into a new submesh, using self.submeshclass\n        Raises pybamm.DomainError if submeshes to be combined do not match up (edges are\n        not aligned).\n\n        Parameters\n        ----------\n        submeshnames: list of str\n            The names of the submeshes to be combined\n\n        Returns\n        -------\n        submesh: :class:`self.submeshclass`\n            A new submesh with the class defined by self.submeshclass\n        \"\"\"\n        # Check that the final edge of each submesh is the same as the first edge of the\n        # next submesh\n        for i in range(len(submeshnames) - 1):\n            for j in range(len(self[submeshnames[i]])):\n                if (\n                    self[submeshnames[i]][j].edges[-1]\n                    != self[submeshnames[i + 1]][j].edges[0]\n                ):\n                    raise pybamm.DomainError(\"submesh edges are not aligned\")\n\n            coord_sys = self[submeshnames[i]][0].coord_sys\n            coord_sys_r = self[submeshnames[i + 1]][0].coord_sys\n            if coord_sys != coord_sys_r:\n                raise pybamm.DomainError(\n                    \"trying to combine two meshes in different coordinate systems\"\n                )\n        submeshes = [None] * len(self[submeshnames[0]])\n        for i in range(len(self[submeshnames[0]])):\n            combined_submesh_edges = np.concatenate(\n                [self[submeshnames[0]][i].edges]\n                + [self[submeshname][i].edges[1:] for submeshname in submeshnames[1:]]\n            )\n            coord_sys = self[submeshnames[0]][i].coord_sys\n            submeshes[i] = pybamm.SubMesh1D(combined_submesh_edges, coord_sys)\n        return submeshes\n\n    def add_ghost_meshes(self):\n        \"\"\"\n        Create meshes for potential ghost nodes on either side of each submesh, using\n        self.submeshclass\n        This will be useful for calculating the gradient with Dirichlet BCs.\n        \"\"\"\n        # Get all submeshes relating to space (i.e. exclude time)\n        submeshes = [\n            (domain, submesh_list)\n            for domain, submesh_list in self.items()\n            if not isinstance(\n                submesh_list[0], (pybamm.SubMesh0D, pybamm.ScikitSubMesh2D)\n            )\n        ]\n        for domain, submesh_list in submeshes:\n\n            self[domain + \"_left ghost cell\"] = [None] * len(submesh_list)\n            self[domain + \"_right ghost cell\"] = [None] * len(submesh_list)\n            for i, submesh in enumerate(submesh_list):\n                edges = submesh.edges\n\n                # left ghost cell: two edges, one node, to the left of existing submesh\n                lgs_edges = np.array([2 * edges[0] - edges[1], edges[0]])\n                self[domain + \"_left ghost cell\"][i] = pybamm.SubMesh1D(\n                    lgs_edges, submesh.coord_sys\n                )\n\n                # right ghost cell: two edges, one node, to the right of\n                # existing submesh\n                rgs_edges = np.array([edges[-1], 2 * edges[-1] - edges[-2]])\n                self[domain + \"_right ghost cell\"][i] = pybamm.SubMesh1D(\n                    rgs_edges, submesh.coord_sys\n                )",
  "class SubMesh:\n    \"\"\"\n    Base submesh class.\n    Contains the position of the nodes, the number of mesh points, and\n    (optionally) information about the tab locations.\n    \"\"\"\n\n    def __init__(self):\n        pass",
  "class MeshGenerator:\n    \"\"\"\n    Base class for mesh generator objects that are used to generate submeshes.\n\n    Parameters\n    ----------\n\n    submesh_type: :class:`pybamm.SubMesh`\n        The type of submesh to use (e.g. Uniform1DSubMesh).\n    submesh_params: dict, optional\n        Contains any parameters required by the submesh.\n    \"\"\"\n\n    def __init__(self, submesh_type, submesh_params=None):\n        self.submesh_type = submesh_type\n        self.submesh_params = submesh_params or {}\n\n    def __call__(self, lims, npts, tabs=None):\n        return self.submesh_type(lims, npts, tabs, **self.submesh_params)\n\n    def __repr__(self):\n        return \"Generator for {}\".format(\n            self.submesh_type.__name__\n        )",
  "def __init__(self, geometry, submesh_types, var_pts):\n        super().__init__()\n        # convert var_pts to an id dict\n        var_id_pts = {var.id: pts for var, pts in var_pts.items()}\n\n        # create submesh_pts from var_pts\n        submesh_pts = {}\n        for domain in geometry:\n            # create mesh generator if just class is passed (will throw an error\n            # later if the mesh needed parameters)\n            if not isinstance(\n                submesh_types[domain], pybamm.MeshGenerator\n            ) and issubclass(submesh_types[domain], pybamm.SubMesh):\n                submesh_types[domain] = pybamm.MeshGenerator(submesh_types[domain])\n            # Zero dimensional submesh case (only one point)\n            if issubclass(submesh_types[domain].submesh_type, pybamm.SubMesh0D):\n                submesh_pts[domain] = 1\n            # other cases\n            else:\n                submesh_pts[domain] = {}\n                if len(list(geometry[domain][\"primary\"].keys())) > 2:\n                    raise pybamm.GeometryError\n                for prim_sec in list(geometry[domain].keys()):\n                    # skip over tabs key\n                    if prim_sec != \"tabs\":\n                        for var in list(geometry[domain][prim_sec].keys()):\n                            # Raise error if the number of points for a particular\n                            # variable haven't been provided, unless that variable\n                            # doesn't appear in the geometry\n                            if (\n                                var.id not in var_id_pts.keys()\n                                and var.domain[0] in geometry.keys()\n                            ):\n                                raise KeyError(\n                                    \"\"\"\n                                    Points not given for a variable in domain {}\n                                    \"\"\".format(\n                                        domain\n                                    )\n                                )\n                            # Otherwise add to the dictionary of submesh points\n                            submesh_pts[domain][var.id] = var_id_pts[var.id]\n        self.submesh_pts = submesh_pts\n\n        # Input domain order manually\n        self.domain_order = []\n        # First the macroscale domains, whose order we care about\n        for domain in [\"negative electrode\", \"separator\", \"positive electrode\"]:\n            if domain in geometry:\n                self.domain_order.append(domain)\n        # Then the remaining domains\n        for domain in geometry:\n            if domain not in [\"negative electrode\", \"separator\", \"positive electrode\"]:\n                self.domain_order.append(domain)\n\n        # evaluate any expressions in geometry\n        for domain in geometry:\n            for prim_sec_tabs, variables in geometry[domain].items():\n                # process tab information if using 1 or 2D current collectors\n                if prim_sec_tabs == \"tabs\":\n                    for tab, position_size in variables.items():\n                        for position_size, sym in position_size.items():\n                            if isinstance(sym, pybamm.Symbol):\n                                sym_eval = sym.evaluate()\n                                geometry[domain][prim_sec_tabs][tab][\n                                    position_size\n                                ] = sym_eval\n                else:\n                    for spatial_variable, spatial_limits in variables.items():\n                        for lim, sym in spatial_limits.items():\n                            if isinstance(sym, pybamm.Symbol):\n                                sym_eval = sym.evaluate()\n                                geometry[domain][prim_sec_tabs][spatial_variable][\n                                    lim\n                                ] = sym_eval\n\n        # Create submeshes\n        for domain in geometry:\n            # repeat mesh if domain has secondary dimension\n            if \"secondary\" in geometry[domain].keys():\n                repeats = 1\n                for var in geometry[domain][\"secondary\"].keys():\n                    repeats *= submesh_pts[domain][var.id]  # note (specific to FV)\n            else:\n                repeats = 1\n            # create submesh, passing tab information if provided\n            if \"tabs\" in geometry[domain].keys():\n                self[domain] = [\n                    submesh_types[domain](\n                        geometry[domain][\"primary\"],\n                        submesh_pts[domain],\n                        geometry[domain][\"tabs\"],\n                    )\n                ] * repeats\n            else:\n                self[domain] = [\n                    submesh_types[domain](\n                        geometry[domain][\"primary\"], submesh_pts[domain]\n                    )\n                ] * repeats\n\n        # add ghost meshes\n        self.add_ghost_meshes()",
  "def combine_submeshes(self, *submeshnames):\n        \"\"\"Combine submeshes into a new submesh, using self.submeshclass\n        Raises pybamm.DomainError if submeshes to be combined do not match up (edges are\n        not aligned).\n\n        Parameters\n        ----------\n        submeshnames: list of str\n            The names of the submeshes to be combined\n\n        Returns\n        -------\n        submesh: :class:`self.submeshclass`\n            A new submesh with the class defined by self.submeshclass\n        \"\"\"\n        # Check that the final edge of each submesh is the same as the first edge of the\n        # next submesh\n        for i in range(len(submeshnames) - 1):\n            for j in range(len(self[submeshnames[i]])):\n                if (\n                    self[submeshnames[i]][j].edges[-1]\n                    != self[submeshnames[i + 1]][j].edges[0]\n                ):\n                    raise pybamm.DomainError(\"submesh edges are not aligned\")\n\n            coord_sys = self[submeshnames[i]][0].coord_sys\n            coord_sys_r = self[submeshnames[i + 1]][0].coord_sys\n            if coord_sys != coord_sys_r:\n                raise pybamm.DomainError(\n                    \"trying to combine two meshes in different coordinate systems\"\n                )\n        submeshes = [None] * len(self[submeshnames[0]])\n        for i in range(len(self[submeshnames[0]])):\n            combined_submesh_edges = np.concatenate(\n                [self[submeshnames[0]][i].edges]\n                + [self[submeshname][i].edges[1:] for submeshname in submeshnames[1:]]\n            )\n            coord_sys = self[submeshnames[0]][i].coord_sys\n            submeshes[i] = pybamm.SubMesh1D(combined_submesh_edges, coord_sys)\n        return submeshes",
  "def add_ghost_meshes(self):\n        \"\"\"\n        Create meshes for potential ghost nodes on either side of each submesh, using\n        self.submeshclass\n        This will be useful for calculating the gradient with Dirichlet BCs.\n        \"\"\"\n        # Get all submeshes relating to space (i.e. exclude time)\n        submeshes = [\n            (domain, submesh_list)\n            for domain, submesh_list in self.items()\n            if not isinstance(\n                submesh_list[0], (pybamm.SubMesh0D, pybamm.ScikitSubMesh2D)\n            )\n        ]\n        for domain, submesh_list in submeshes:\n\n            self[domain + \"_left ghost cell\"] = [None] * len(submesh_list)\n            self[domain + \"_right ghost cell\"] = [None] * len(submesh_list)\n            for i, submesh in enumerate(submesh_list):\n                edges = submesh.edges\n\n                # left ghost cell: two edges, one node, to the left of existing submesh\n                lgs_edges = np.array([2 * edges[0] - edges[1], edges[0]])\n                self[domain + \"_left ghost cell\"][i] = pybamm.SubMesh1D(\n                    lgs_edges, submesh.coord_sys\n                )\n\n                # right ghost cell: two edges, one node, to the right of\n                # existing submesh\n                rgs_edges = np.array([edges[-1], 2 * edges[-1] - edges[-2]])\n                self[domain + \"_right ghost cell\"][i] = pybamm.SubMesh1D(\n                    rgs_edges, submesh.coord_sys\n                )",
  "def __init__(self):\n        pass",
  "def __init__(self, submesh_type, submesh_params=None):\n        self.submesh_type = submesh_type\n        self.submesh_params = submesh_params or {}",
  "def __call__(self, lims, npts, tabs=None):\n        return self.submesh_type(lims, npts, tabs, **self.submesh_params)",
  "def __repr__(self):\n        return \"Generator for {}\".format(\n            self.submesh_type.__name__\n        )",
  "class ScikitSubMesh2D(SubMesh):\n    \"\"\"\n    2D submesh class.\n    Contains information about the 2D finite element mesh.\n    Note: This class only allows for the use of piecewise-linear triangular\n    finite elements.\n\n    Parameters\n    ----------\n    edges : array_like\n        An array containing the points corresponding to the edges of the submesh\n    coord_sys : string\n        The coordinate system of the submesh\n    tabs : dict, optional\n        A dictionary that contains information about the size and location of\n        the tabs\n\n    **Extends:\"\": :class:`pybamm.SubMesh`\n    \"\"\"\n\n    def __init__(self, edges, coord_sys, tabs):\n        self.edges = edges\n        self.nodes = dict.fromkeys([\"y\", \"z\"])\n        for var in self.nodes.keys():\n            self.nodes[var] = (self.edges[var][1:] + self.edges[var][:-1]) / 2\n        self.npts = len(self.edges[\"y\"]) * len(self.edges[\"z\"])\n        self.coord_sys = coord_sys\n\n        # create mesh\n        self.fem_mesh = skfem.MeshTri.init_tensor(self.edges[\"y\"], self.edges[\"z\"])\n\n        # get coordinates (returns a vector size 2*(Ny*Nz))\n        self.coordinates = self.fem_mesh.p\n\n        # create elements and basis\n        self.element = skfem.ElementTriP1()\n        self.basis = skfem.InteriorBasis(self.fem_mesh, self.element)\n        self.facet_basis = skfem.FacetBasis(self.fem_mesh, self.element)\n\n        # get degrees of freedom and facets which correspond to tabs, and\n        # create facet basis for sub regions\n        self.negative_tab_dofs = self.basis.get_dofs(\n            lambda x: self.on_boundary(x[0], x[1], tabs[\"negative\"])\n        ).all()\n        self.positive_tab_dofs = self.basis.get_dofs(\n            lambda x: self.on_boundary(x[0], x[1], tabs[\"positive\"])\n        ).all()\n        self.negative_tab_facets = self.fem_mesh.facets_satisfying(\n            lambda x: self.on_boundary(x[0], x[1], tabs[\"negative\"])\n        )\n        self.positive_tab_facets = self.fem_mesh.facets_satisfying(\n            lambda x: self.on_boundary(x[0], x[1], tabs[\"positive\"])\n        )\n        self.negative_tab_basis = skfem.FacetBasis(\n            self.fem_mesh, self.element, facets=self.negative_tab_facets\n        )\n        self.positive_tab_basis = skfem.FacetBasis(\n            self.fem_mesh, self.element, facets=self.positive_tab_facets\n        )\n\n    def on_boundary(self, y, z, tab):\n        \"\"\"\n        A method to get the degrees of freedom corresponding to the subdomains\n        for the tabs.\n        \"\"\"\n\n        l_y = self.edges[\"y\"][-1]\n        l_z = self.edges[\"z\"][-1]\n\n        def near(x, point, tol=3e-16):\n            return abs(x - point) < tol\n\n        def between(x, interval, tol=3e-16):\n            return x > interval[0] - tol and x < interval[1] + tol\n\n        # Tab on top\n        if near(tab[\"z_centre\"], l_z):\n            tab_left = tab[\"y_centre\"] - tab[\"width\"] / 2\n            tab_right = tab[\"y_centre\"] + tab[\"width\"] / 2\n            return [\n                near(Z, l_z) and between(Y, [tab_left, tab_right]) for Y, Z in zip(y, z)\n            ]\n        # Tab on bottom\n        elif near(tab[\"z_centre\"], 0):\n            tab_left = tab[\"y_centre\"] - tab[\"width\"] / 2\n            tab_right = tab[\"y_centre\"] + tab[\"width\"] / 2\n            return [\n                near(Z, 0) and between(Y, [tab_left, tab_right]) for Y, Z in zip(y, z)\n            ]\n        # Tab on left\n        elif near(tab[\"y_centre\"], 0):\n            tab_bottom = tab[\"z_centre\"] - tab[\"width\"] / 2\n            tab_top = tab[\"z_centre\"] + tab[\"width\"] / 2\n            return [\n                near(Y, 0) and between(Z, [tab_bottom, tab_top]) for Y, Z in zip(y, z)\n            ]\n        # Tab on right\n        elif near(tab[\"y_centre\"], l_y):\n            tab_bottom = tab[\"z_centre\"] - tab[\"width\"] / 2\n            tab_top = tab[\"z_centre\"] + tab[\"width\"] / 2\n            return [\n                near(Y, l_y) and between(Z, [tab_bottom, tab_top]) for Y, Z in zip(y, z)\n            ]\n        else:\n            raise pybamm.GeometryError(\"tab location not valid\")",
  "class ScikitUniform2DSubMesh(ScikitSubMesh2D):\n    \"\"\"\n    Contains information about the 2D finite element mesh with uniform grid\n    spacing (can be different spacing in y and z).\n    Note: This class only allows for the use of piecewise-linear triangular\n    finite elements.\n\n    Parameters\n    ----------\n    lims : dict\n        A dictionary that contains the limits of each\n        spatial variable\n    npts : dict\n        A dictionary that contains the number of points to be used on each\n        spatial variable\n    tabs : dict\n        A dictionary that contains information about the size and location of\n        the tabs\n\n    **Extends:\"\": :class:`pybamm.ScikitSubMesh2D`\n    \"\"\"\n\n    def __init__(self, lims, npts, tabs):\n\n        # check that two variables have been passed in\n        if len(lims) != 2:\n            raise pybamm.GeometryError(\n                \"lims should contain exactly two variables, not {}\".format(len(lims))\n            )\n\n        # get spatial variables\n        spatial_vars = list(lims.keys())\n\n        # check coordinate system agrees\n        if spatial_vars[0].coord_sys == spatial_vars[1].coord_sys:\n            coord_sys = spatial_vars[0].coord_sys\n        else:\n            raise pybamm.DomainError(\n                \"\"\"spatial variables should have the same coordinate system,\n                but have coordinate systems {} and {}\"\"\".format(\n                    spatial_vars[0].coord_sys, spatial_vars[1].coord_sys\n                )\n            )\n\n        # compute edges\n        edges = {}\n        for var in spatial_vars:\n            if var.name not in [\"y\", \"z\"]:\n                raise pybamm.DomainError(\n                    \"spatial variable must be y or z not {}\".format(var.name)\n                )\n            else:\n                edges[var.name] = np.linspace(\n                    lims[var][\"min\"], lims[var][\"max\"], npts[var.id]\n                )\n\n        super().__init__(edges, coord_sys, tabs)",
  "class ScikitExponential2DSubMesh(ScikitSubMesh2D):\n    \"\"\"\n    Contains information about the 2D finite element mesh generated by taking the\n    tensor product of a uniformly spaced grid in the y direction, and a unequally\n    spaced grid in the z direction in which the points are clustered\n    close to the top boundary using an exponential formula on the interval [a,b].\n    The gridpoints in the z direction are given by\n\n    .. math::\n        z_{k} = (b-a) + \\\\frac{\\\\exp{-\\\\alpha k / N} - 1}{\\\\exp{-\\\\alpha} - 1}} + a,\n\n    for k = 1, ..., N, where N is the number of nodes. Here alpha is\n    a stretching factor. As the number of gridpoints tends to infinity, the ratio\n    of the largest and smallest grid cells tends to exp(alpha).\n\n    Note: in the future this will be extended to allow points to be clustered near\n    any of the boundaries.\n\n    Parameters\n    ----------\n    lims : dict\n        A dictionary that contains the limits of each\n        spatial variable\n    npts : dict\n        A dictionary that contains the number of points to be used on each\n        spatial variable\n    tabs : dict\n        A dictionary that contains information about the size and location of\n        the tabs\n    side : str, optional\n        Whether the points are clustered near to a particular boundary. At present,\n        can only be \"top\". Default is \"top\".\n    stretch : float, optional\n        The factor (alpha) which appears in the exponential. Default is 2.3.\n\n    **Extends:\"\": :class:`pybamm.ScikitSubMesh2D`\n    \"\"\"\n\n    def __init__(self, lims, npts, tabs, side=\"top\", stretch=2.3):\n\n        # check side is top\n        if side != \"top\":\n            raise pybamm.GeometryError(\n                \"At present, side can only be 'top', but is set to {}\".format(side)\n            )\n\n        # check that two variables have been passed in\n        if len(lims) != 2:\n            raise pybamm.GeometryError(\n                \"lims should contain exactly two variables, not {}\".format(len(lims))\n            )\n\n        # get spatial variables\n        spatial_vars = list(lims.keys())\n\n        # check coordinate system agrees\n        if spatial_vars[0].coord_sys == spatial_vars[1].coord_sys:\n            coord_sys = spatial_vars[0].coord_sys\n        else:\n            raise pybamm.DomainError(\n                \"\"\"spatial variables should have the same coordinate system,\n                but have coordinate systems {} and {}\"\"\".format(\n                    spatial_vars[0].coord_sys, spatial_vars[1].coord_sys\n                )\n            )\n\n        # compute edges\n        edges = {}\n        for var in spatial_vars:\n            if var.name not in [\"y\", \"z\"]:\n                raise pybamm.DomainError(\n                    \"spatial variable must be y or z not {}\".format(var.name)\n                )\n            elif var.name == \"y\":\n                edges[var.name] = np.linspace(\n                    lims[var][\"min\"], lims[var][\"max\"], npts[var.id]\n                )\n            elif var.name == \"z\":\n                ii = np.array(range(0, npts[var.id]))\n                a = lims[var][\"min\"]\n                b = lims[var][\"max\"]\n                edges[var.name] = (b - a) * (\n                    np.exp(-stretch * ii / (npts[var.id] - 1)) - 1\n                ) / (np.exp(-stretch) - 1) + a\n\n        super().__init__(edges, coord_sys, tabs)",
  "class ScikitChebyshev2DSubMesh(ScikitSubMesh2D):\n    \"\"\"\n    Contains information about the 2D finite element mesh generated by taking the\n    tensor product of two 1D meshes which use Chebyshev nodes on the\n    interval (a, b), given by\n\n    .. math::\n        x_{k} = \\\\frac{1}{2}(a+b) + \\\\frac{1}{2}(b-a) \\\\cos(\\\\frac{2k-1}{2N}\\\\pi),\n\n    for k = 1, ..., N, where N is the number of nodes. Note: this mesh then\n    appends the boundary edgess, so that the 1D mesh edges are given by\n\n    .. math ::\n        a < x_{1} < ... < x_{N} < b.\n\n    Note: This class only allows for the use of piecewise-linear triangular\n    finite elements.\n\n    Parameters\n    ----------\n    lims : dict\n        A dictionary that contains the limits of each\n        spatial variable\n    npts : dict\n        A dictionary that contains the number of points to be used on each\n        spatial variable\n    tabs : dict\n        A dictionary that contains information about the size and location of\n        the tabs\n\n    **Extends:\"\": :class:`pybamm.ScikitSubMesh2D`\n    \"\"\"\n\n    def __init__(self, lims, npts, tabs):\n\n        # check that two variables have been passed in\n        if len(lims) != 2:\n            raise pybamm.GeometryError(\n                \"lims should contain exactly two variables, not {}\".format(len(lims))\n            )\n\n        # get spatial variables\n        spatial_vars = list(lims.keys())\n\n        # check coordinate system agrees\n        if spatial_vars[0].coord_sys == spatial_vars[1].coord_sys:\n            coord_sys = spatial_vars[0].coord_sys\n        else:\n            raise pybamm.DomainError(\n                \"\"\"spatial variables should have the same coordinate system,\n                but have coordinate systems {} and {}\"\"\".format(\n                    spatial_vars[0].coord_sys, spatial_vars[1].coord_sys\n                )\n            )\n\n        # compute edges\n        edges = {}\n        for var in spatial_vars:\n            if var.name not in [\"y\", \"z\"]:\n                raise pybamm.DomainError(\n                    \"spatial variable must be y or z not {}\".format(var.name)\n                )\n            else:\n                # Create N Chebyshev nodes in the interval (a,b)\n                N = npts[var.id] - 2\n                ii = np.array(range(1, N + 1))\n                a = lims[var][\"min\"]\n                b = lims[var][\"max\"]\n                x_cheb = (a + b) / 2 + (b - a) / 2 * np.cos(\n                    (2 * ii - 1) * np.pi / 2 / N\n                )\n\n                # Append the boundary nodes. Note: we need to flip the order the\n                # Chebyshev nodes as they are created in descending order.\n                edges[var.name] = np.concatenate(([a], np.flip(x_cheb), [b]))\n\n        super().__init__(edges, coord_sys, tabs)",
  "class UserSupplied2DSubMesh(ScikitSubMesh2D):\n    \"\"\"\n    A class to generate a tensor product submesh on a 2D domain by using two user\n    supplied vectors of edges: one for the y-direction and one for the z-direction.\n    Note: this mesh should be created using :class:`UserSupplied2DSubMeshGenerator`.\n\n    Parameters\n    ----------\n    lims : dict\n        A dictionary that contains the limits of the spatial variables\n    npts : dict\n        A dictionary that contains the number of points to be used on each\n        spatial variable. Note: the number of nodes (located at the cell centres)\n        is npts, and the number of edges is npts+1.\n    tabs : dict\n        A dictionary that contains information about the size and location of\n        the tabs\n    y_edges : array_like\n        The array of points which correspond to the edges in the y direction\n        of the mesh.\n    z_edges : array_like\n        The array of points which correspond to the edges in the z direction\n        of the mesh.\n\n    **Extends:\"\": :class:`pybamm.ScikitSubMesh2D`\n    \"\"\"\n\n    def __init__(self, lims, npts, tabs, y_edges=None, z_edges=None):\n\n        # raise error if no edges passed\n        if y_edges is None:\n            raise pybamm.GeometryError(\"User mesh requires parameter 'y_edges'\")\n        if z_edges is None:\n            raise pybamm.GeometryError(\"User mesh requires parameter 'z_edges'\")\n\n        # check that two variables have been passed in\n        if len(lims) != 2:\n            raise pybamm.GeometryError(\n                \"lims should contain exactly two variables, not {}\".format(len(lims))\n            )\n\n        # get spatial variables\n        spatial_vars = list(lims.keys())\n\n        # check coordinate system agrees\n        if spatial_vars[0].coord_sys == spatial_vars[1].coord_sys:\n            coord_sys = spatial_vars[0].coord_sys\n        else:\n            raise pybamm.DomainError(\n                \"\"\"spatial variables should have the same coordinate system,\n                but have coordinate systems {} and {}\"\"\".format(\n                    spatial_vars[0].coord_sys, spatial_vars[1].coord_sys\n                )\n            )\n\n        # check and store edges\n        edges = {\"y\": y_edges, \"z\": z_edges}\n        for var in spatial_vars:\n\n            # check that npts equals number of user-supplied edges\n            if npts[var.id] != len(edges[var.name]):\n                raise pybamm.GeometryError(\n                    \"\"\"User-suppled edges has should have length npts but has length {}.\n                     Number of points (npts) for variable {} in\n                     domain {} is {}.\"\"\".format(\n                        len(edges[var.name]), var.name, var.domain, npts[var.id]\n                    )\n                )\n\n            # check end points of edges agree with spatial_lims\n            if edges[var.name][0] != lims[var][\"min\"]:\n                raise pybamm.GeometryError(\n                    \"\"\"First entry of edges is {}, but should be equal to {}\n                     for variable {} in domain {}.\"\"\".format(\n                        edges[var.name][0], lims[var][\"min\"], var.name, var.domain\n                    )\n                )\n            if edges[var.name][-1] != lims[var][\"max\"]:\n                raise pybamm.GeometryError(\n                    \"\"\"Last entry of edges is {}, but should be equal to {}\n                    for variable {} in domain {}.\"\"\".format(\n                        edges[var.name][-1], lims[var][\"max\"], var.name, var.domain\n                    )\n                )\n\n        super().__init__(edges, coord_sys=coord_sys, tabs=tabs)",
  "def __init__(self, edges, coord_sys, tabs):\n        self.edges = edges\n        self.nodes = dict.fromkeys([\"y\", \"z\"])\n        for var in self.nodes.keys():\n            self.nodes[var] = (self.edges[var][1:] + self.edges[var][:-1]) / 2\n        self.npts = len(self.edges[\"y\"]) * len(self.edges[\"z\"])\n        self.coord_sys = coord_sys\n\n        # create mesh\n        self.fem_mesh = skfem.MeshTri.init_tensor(self.edges[\"y\"], self.edges[\"z\"])\n\n        # get coordinates (returns a vector size 2*(Ny*Nz))\n        self.coordinates = self.fem_mesh.p\n\n        # create elements and basis\n        self.element = skfem.ElementTriP1()\n        self.basis = skfem.InteriorBasis(self.fem_mesh, self.element)\n        self.facet_basis = skfem.FacetBasis(self.fem_mesh, self.element)\n\n        # get degrees of freedom and facets which correspond to tabs, and\n        # create facet basis for sub regions\n        self.negative_tab_dofs = self.basis.get_dofs(\n            lambda x: self.on_boundary(x[0], x[1], tabs[\"negative\"])\n        ).all()\n        self.positive_tab_dofs = self.basis.get_dofs(\n            lambda x: self.on_boundary(x[0], x[1], tabs[\"positive\"])\n        ).all()\n        self.negative_tab_facets = self.fem_mesh.facets_satisfying(\n            lambda x: self.on_boundary(x[0], x[1], tabs[\"negative\"])\n        )\n        self.positive_tab_facets = self.fem_mesh.facets_satisfying(\n            lambda x: self.on_boundary(x[0], x[1], tabs[\"positive\"])\n        )\n        self.negative_tab_basis = skfem.FacetBasis(\n            self.fem_mesh, self.element, facets=self.negative_tab_facets\n        )\n        self.positive_tab_basis = skfem.FacetBasis(\n            self.fem_mesh, self.element, facets=self.positive_tab_facets\n        )",
  "def on_boundary(self, y, z, tab):\n        \"\"\"\n        A method to get the degrees of freedom corresponding to the subdomains\n        for the tabs.\n        \"\"\"\n\n        l_y = self.edges[\"y\"][-1]\n        l_z = self.edges[\"z\"][-1]\n\n        def near(x, point, tol=3e-16):\n            return abs(x - point) < tol\n\n        def between(x, interval, tol=3e-16):\n            return x > interval[0] - tol and x < interval[1] + tol\n\n        # Tab on top\n        if near(tab[\"z_centre\"], l_z):\n            tab_left = tab[\"y_centre\"] - tab[\"width\"] / 2\n            tab_right = tab[\"y_centre\"] + tab[\"width\"] / 2\n            return [\n                near(Z, l_z) and between(Y, [tab_left, tab_right]) for Y, Z in zip(y, z)\n            ]\n        # Tab on bottom\n        elif near(tab[\"z_centre\"], 0):\n            tab_left = tab[\"y_centre\"] - tab[\"width\"] / 2\n            tab_right = tab[\"y_centre\"] + tab[\"width\"] / 2\n            return [\n                near(Z, 0) and between(Y, [tab_left, tab_right]) for Y, Z in zip(y, z)\n            ]\n        # Tab on left\n        elif near(tab[\"y_centre\"], 0):\n            tab_bottom = tab[\"z_centre\"] - tab[\"width\"] / 2\n            tab_top = tab[\"z_centre\"] + tab[\"width\"] / 2\n            return [\n                near(Y, 0) and between(Z, [tab_bottom, tab_top]) for Y, Z in zip(y, z)\n            ]\n        # Tab on right\n        elif near(tab[\"y_centre\"], l_y):\n            tab_bottom = tab[\"z_centre\"] - tab[\"width\"] / 2\n            tab_top = tab[\"z_centre\"] + tab[\"width\"] / 2\n            return [\n                near(Y, l_y) and between(Z, [tab_bottom, tab_top]) for Y, Z in zip(y, z)\n            ]\n        else:\n            raise pybamm.GeometryError(\"tab location not valid\")",
  "def __init__(self, lims, npts, tabs):\n\n        # check that two variables have been passed in\n        if len(lims) != 2:\n            raise pybamm.GeometryError(\n                \"lims should contain exactly two variables, not {}\".format(len(lims))\n            )\n\n        # get spatial variables\n        spatial_vars = list(lims.keys())\n\n        # check coordinate system agrees\n        if spatial_vars[0].coord_sys == spatial_vars[1].coord_sys:\n            coord_sys = spatial_vars[0].coord_sys\n        else:\n            raise pybamm.DomainError(\n                \"\"\"spatial variables should have the same coordinate system,\n                but have coordinate systems {} and {}\"\"\".format(\n                    spatial_vars[0].coord_sys, spatial_vars[1].coord_sys\n                )\n            )\n\n        # compute edges\n        edges = {}\n        for var in spatial_vars:\n            if var.name not in [\"y\", \"z\"]:\n                raise pybamm.DomainError(\n                    \"spatial variable must be y or z not {}\".format(var.name)\n                )\n            else:\n                edges[var.name] = np.linspace(\n                    lims[var][\"min\"], lims[var][\"max\"], npts[var.id]\n                )\n\n        super().__init__(edges, coord_sys, tabs)",
  "def __init__(self, lims, npts, tabs, side=\"top\", stretch=2.3):\n\n        # check side is top\n        if side != \"top\":\n            raise pybamm.GeometryError(\n                \"At present, side can only be 'top', but is set to {}\".format(side)\n            )\n\n        # check that two variables have been passed in\n        if len(lims) != 2:\n            raise pybamm.GeometryError(\n                \"lims should contain exactly two variables, not {}\".format(len(lims))\n            )\n\n        # get spatial variables\n        spatial_vars = list(lims.keys())\n\n        # check coordinate system agrees\n        if spatial_vars[0].coord_sys == spatial_vars[1].coord_sys:\n            coord_sys = spatial_vars[0].coord_sys\n        else:\n            raise pybamm.DomainError(\n                \"\"\"spatial variables should have the same coordinate system,\n                but have coordinate systems {} and {}\"\"\".format(\n                    spatial_vars[0].coord_sys, spatial_vars[1].coord_sys\n                )\n            )\n\n        # compute edges\n        edges = {}\n        for var in spatial_vars:\n            if var.name not in [\"y\", \"z\"]:\n                raise pybamm.DomainError(\n                    \"spatial variable must be y or z not {}\".format(var.name)\n                )\n            elif var.name == \"y\":\n                edges[var.name] = np.linspace(\n                    lims[var][\"min\"], lims[var][\"max\"], npts[var.id]\n                )\n            elif var.name == \"z\":\n                ii = np.array(range(0, npts[var.id]))\n                a = lims[var][\"min\"]\n                b = lims[var][\"max\"]\n                edges[var.name] = (b - a) * (\n                    np.exp(-stretch * ii / (npts[var.id] - 1)) - 1\n                ) / (np.exp(-stretch) - 1) + a\n\n        super().__init__(edges, coord_sys, tabs)",
  "def __init__(self, lims, npts, tabs):\n\n        # check that two variables have been passed in\n        if len(lims) != 2:\n            raise pybamm.GeometryError(\n                \"lims should contain exactly two variables, not {}\".format(len(lims))\n            )\n\n        # get spatial variables\n        spatial_vars = list(lims.keys())\n\n        # check coordinate system agrees\n        if spatial_vars[0].coord_sys == spatial_vars[1].coord_sys:\n            coord_sys = spatial_vars[0].coord_sys\n        else:\n            raise pybamm.DomainError(\n                \"\"\"spatial variables should have the same coordinate system,\n                but have coordinate systems {} and {}\"\"\".format(\n                    spatial_vars[0].coord_sys, spatial_vars[1].coord_sys\n                )\n            )\n\n        # compute edges\n        edges = {}\n        for var in spatial_vars:\n            if var.name not in [\"y\", \"z\"]:\n                raise pybamm.DomainError(\n                    \"spatial variable must be y or z not {}\".format(var.name)\n                )\n            else:\n                # Create N Chebyshev nodes in the interval (a,b)\n                N = npts[var.id] - 2\n                ii = np.array(range(1, N + 1))\n                a = lims[var][\"min\"]\n                b = lims[var][\"max\"]\n                x_cheb = (a + b) / 2 + (b - a) / 2 * np.cos(\n                    (2 * ii - 1) * np.pi / 2 / N\n                )\n\n                # Append the boundary nodes. Note: we need to flip the order the\n                # Chebyshev nodes as they are created in descending order.\n                edges[var.name] = np.concatenate(([a], np.flip(x_cheb), [b]))\n\n        super().__init__(edges, coord_sys, tabs)",
  "def __init__(self, lims, npts, tabs, y_edges=None, z_edges=None):\n\n        # raise error if no edges passed\n        if y_edges is None:\n            raise pybamm.GeometryError(\"User mesh requires parameter 'y_edges'\")\n        if z_edges is None:\n            raise pybamm.GeometryError(\"User mesh requires parameter 'z_edges'\")\n\n        # check that two variables have been passed in\n        if len(lims) != 2:\n            raise pybamm.GeometryError(\n                \"lims should contain exactly two variables, not {}\".format(len(lims))\n            )\n\n        # get spatial variables\n        spatial_vars = list(lims.keys())\n\n        # check coordinate system agrees\n        if spatial_vars[0].coord_sys == spatial_vars[1].coord_sys:\n            coord_sys = spatial_vars[0].coord_sys\n        else:\n            raise pybamm.DomainError(\n                \"\"\"spatial variables should have the same coordinate system,\n                but have coordinate systems {} and {}\"\"\".format(\n                    spatial_vars[0].coord_sys, spatial_vars[1].coord_sys\n                )\n            )\n\n        # check and store edges\n        edges = {\"y\": y_edges, \"z\": z_edges}\n        for var in spatial_vars:\n\n            # check that npts equals number of user-supplied edges\n            if npts[var.id] != len(edges[var.name]):\n                raise pybamm.GeometryError(\n                    \"\"\"User-suppled edges has should have length npts but has length {}.\n                     Number of points (npts) for variable {} in\n                     domain {} is {}.\"\"\".format(\n                        len(edges[var.name]), var.name, var.domain, npts[var.id]\n                    )\n                )\n\n            # check end points of edges agree with spatial_lims\n            if edges[var.name][0] != lims[var][\"min\"]:\n                raise pybamm.GeometryError(\n                    \"\"\"First entry of edges is {}, but should be equal to {}\n                     for variable {} in domain {}.\"\"\".format(\n                        edges[var.name][0], lims[var][\"min\"], var.name, var.domain\n                    )\n                )\n            if edges[var.name][-1] != lims[var][\"max\"]:\n                raise pybamm.GeometryError(\n                    \"\"\"Last entry of edges is {}, but should be equal to {}\n                    for variable {} in domain {}.\"\"\".format(\n                        edges[var.name][-1], lims[var][\"max\"], var.name, var.domain\n                    )\n                )\n\n        super().__init__(edges, coord_sys=coord_sys, tabs=tabs)",
  "def near(x, point, tol=3e-16):\n            return abs(x - point) < tol",
  "def between(x, interval, tol=3e-16):\n            return x > interval[0] - tol and x < interval[1] + tol",
  "class ScikitFiniteElement(pybamm.SpatialMethod):\n    \"\"\"\n    A class which implements the steps specific to the finite element method during\n    discretisation. The class uses scikit-fem to discretise the problem to obtain\n    the mass and stifnness matrices. At present, this class is only used for\n    solving the Poisson problem -grad^2 u = f in the y-z plane (i.e. not the\n    through-cell direction).\n\n    For broadcast we follow the default behaviour from SpatialMethod.\n\n    Parameters\n    ----------\n    mesh : :class:`pybamm.Mesh`\n        Contains all the submeshes for discretisation\n\n    **Extends:\"\": :class:`pybamm.SpatialMethod`\n    \"\"\"\n\n    def __init__(self, mesh):\n        super().__init__(mesh)\n        # add npts_for_broadcast to mesh domains for this particular discretisation\n        for dom in mesh.keys():\n            for i in range(len(mesh[dom])):\n                mesh[dom][i].npts_for_broadcast = mesh[dom][i].npts\n\n    def spatial_variable(self, symbol):\n        \"\"\"\n        Creates a discretised spatial variable compatible with\n        the FiniteElement method.\n\n        Parameters\n        -----------\n        symbol : :class:`pybamm.SpatialVariable`\n            The spatial variable to be discretised.\n\n        Returns\n        -------\n        :class:`pybamm.Vector`\n            Contains the discretised spatial variable\n        \"\"\"\n        symbol_mesh = self.mesh\n        if symbol.name == \"y\":\n            vector = pybamm.Vector(\n                symbol_mesh[\"current collector\"][0].edges[\"y\"], domain=symbol.domain\n            )\n        elif symbol.name == \"z\":\n            vector = pybamm.Vector(\n                symbol_mesh[\"current collector\"][0].edges[\"z\"], domain=symbol.domain\n            )\n        else:\n            raise pybamm.GeometryError(\n                \"Spatial variable must be 'y' or 'z' not {}\".format(symbol.name)\n            )\n        return vector\n\n    def gradient(self, symbol, discretised_symbol, boundary_conditions):\n        \"\"\"Matrix-vector multiplication to implement the gradient operator.\n        See :meth:`pybamm.SpatialMethod.gradient`\n        \"\"\"\n        raise NotImplementedError\n\n    def divergence(self, symbol, discretised_symbol, boundary_conditions):\n        \"\"\"Matrix-vector multiplication to implement the divergence operator.\n        See :meth:`pybamm.SpatialMethod.divergence`\n        \"\"\"\n        raise NotImplementedError\n\n    def laplacian(self, symbol, discretised_symbol, boundary_conditions):\n        \"\"\"Matrix-vector multiplication to implement the laplacian operator.\n\n        Parameters\n        ----------\n        symbol: :class:`pybamm.Symbol`\n            The symbol that we will take the laplacian of.\n        discretised_symbol: :class:`pybamm.Symbol`\n            The discretised symbol of the correct size\n        boundary_conditions : dict\n            The boundary conditions of the model\n            ({symbol.id: {\"negative tab\": neg. tab bc, \"positive tab\": pos. tab bc}})\n\n        Returns\n        -------\n        :class: `pybamm.Array`\n            Contains the result of acting the discretised gradient on\n            the child discretised_symbol\n        \"\"\"\n        domain = symbol.domain[0]\n        mesh = self.mesh[domain][0]\n\n        stiffness_matrix = self.stiffness_matrix(symbol, boundary_conditions)\n\n        # get boundary conditions and type\n        neg_bc_value, neg_bc_type = boundary_conditions[symbol.id][\"negative tab\"]\n        pos_bc_value, pos_bc_type = boundary_conditions[symbol.id][\"positive tab\"]\n        # boundary load vector is adjusted to account for boundary conditions below\n        boundary_load = pybamm.Vector(np.zeros(mesh.npts))\n\n        # assemble boundary load if Neumann boundary conditions\n        if \"Neumann\" in [neg_bc_type, pos_bc_type]:\n            # make form for unit load over the boundary\n            @skfem.linear_form\n            def unit_bc_load_form(v, dv, w):\n                return v\n\n        if neg_bc_type == \"Neumann\":\n            # assemble unit load over tab\n            neg_bc_load = skfem.asm(unit_bc_load_form, mesh.negative_tab_basis)\n            # value multiplied by weights\n            boundary_load = boundary_load + neg_bc_value * pybamm.Vector(neg_bc_load)\n        elif neg_bc_type == \"Dirichlet\":\n            # set Dirichlet value at facets corresponding to tab\n            neg_bc_load = np.zeros(mesh.npts)\n            neg_bc_load[mesh.negative_tab_dofs] = 1\n            boundary_load = boundary_load - neg_bc_value * pybamm.Vector(neg_bc_load)\n        else:\n            raise ValueError(\n                \"boundary condition must be Dirichlet or Neumann, not '{}'\".format(\n                    neg_bc_type\n                )\n            )\n\n        if pos_bc_type == \"Neumann\":\n            # assemble unit load over tab\n            pos_bc_load = skfem.asm(unit_bc_load_form, mesh.positive_tab_basis)\n            # value multiplied by weights\n            boundary_load = boundary_load + pos_bc_value * pybamm.Vector(pos_bc_load)\n        elif pos_bc_type == \"Dirichlet\":\n            # set Dirichlet value at facets corresponding to tab\n            pos_bc_load = np.zeros(mesh.npts)\n            pos_bc_load[mesh.positive_tab_dofs] = 1\n            boundary_load = boundary_load - pos_bc_value * pybamm.Vector(pos_bc_load)\n        else:\n            raise ValueError(\n                \"boundary condition must be Dirichlet or Neumann, not '{}'\".format(\n                    pos_bc_type\n                )\n            )\n\n        return -stiffness_matrix @ discretised_symbol + boundary_load\n\n    def gradient_squared(self, symbol, discretised_symbol, boundary_conditions):\n        \"\"\"Matrix-vector multiplication to implement the inner product of the\n        gradient operator with itself.\n        See :meth:`pybamm.SpatialMethod.gradient_squared`\n        \"\"\"\n        stiffness_matrix = self.stiffness_matrix(symbol, boundary_conditions)\n\n        return stiffness_matrix @ (discretised_symbol ** 2)\n\n    def stiffness_matrix(self, symbol, boundary_conditions):\n        \"\"\"\n        Laplacian (stiffness) matrix for finite elements in the appropriate domain.\n\n        Parameters\n        ----------\n        symbol: :class:`pybamm.Symbol`\n            The symbol for which we want to calculate the laplacian matrix\n        boundary_conditions : dict\n            The boundary conditions of the model\n            ({symbol.id: {\"negative tab\": neg. tab bc, \"positive tab\": pos. tab bc}})\n\n        Returns\n        -------\n        :class:`pybamm.Matrix`\n            The (sparse) finite element stiffness matrix for the domain\n        \"\"\"\n        # get primary domain mesh\n        domain = symbol.domain[0]\n        mesh = self.mesh[domain][0]\n\n        # make form for the stiffness\n        @skfem.bilinear_form\n        def stiffness_form(u, du, v, dv, w):\n            return sum(du * dv)\n\n        # assemble the stifnness matrix\n        stiffness = skfem.asm(stiffness_form, mesh.basis)\n\n        # get boundary conditions and type\n        try:\n            _, neg_bc_type = boundary_conditions[symbol.id][\"negative tab\"]\n            _, pos_bc_type = boundary_conditions[symbol.id][\"positive tab\"]\n        except KeyError:\n            raise pybamm.ModelError(\n                \"No boundary conditions provided for symbol `{}``\".format(symbol)\n            )\n\n        # adjust matrix for Dirichlet boundary conditions\n        if neg_bc_type == \"Dirichlet\":\n            self.bc_apply(stiffness, mesh.negative_tab_dofs)\n        if pos_bc_type == \"Dirichlet\":\n            self.bc_apply(stiffness, mesh.positive_tab_dofs)\n\n        return pybamm.Matrix(stiffness)\n\n    def integral(self, child, discretised_child):\n        \"\"\"Vector-vector dot product to implement the integral operator.\n        See :meth:`pybamm.SpatialMethod.integral`\n        \"\"\"\n        # Calculate integration vector\n        integration_vector = self.definite_integral_matrix(child.domain[0])\n\n        out = integration_vector @ discretised_child\n\n        return out\n\n    def definite_integral_matrix(self, domain, vector_type=\"row\"):\n        \"\"\"\n        Matrix for finite-element implementation of the definite integral over\n        the entire domain\n\n        .. math::\n            I = \\\\int_{\\Omega}\\\\!f(s)\\\\,dx\n\n        for where :math:`\\Omega` is the domain.\n\n        Parameters\n        ----------\n        domain : list\n            The domain(s) of integration\n        vector_type : str, optional\n            Whether to return a row or column vector (default is row)\n\n        Returns\n        -------\n        :class:`pybamm.Matrix`\n            The finite element integral vector for the domain\n        \"\"\"\n        # get primary domain mesh\n        if isinstance(domain, list):\n            domain = domain[0]\n        mesh = self.mesh[domain][0]\n\n        # make form for the integral\n        @skfem.linear_form\n        def integral_form(v, dv, w):\n            return v\n\n        # assemble\n        vector = skfem.asm(integral_form, mesh.basis)\n\n        if vector_type == \"row\":\n            return pybamm.Matrix(vector[np.newaxis, :])\n        elif vector_type == \"column\":\n            return pybamm.Matrix(vector[:, np.newaxis])\n\n    def indefinite_integral(self, child, discretised_child):\n        \"\"\"Implementation of the indefinite integral operator. The\n        input discretised child must be defined on the internal mesh edges.\n        See :meth:`pybamm.SpatialMethod.indefinite_integral`\n        \"\"\"\n        raise NotImplementedError\n\n    def boundary_integral(self, child, discretised_child, region):\n        \"\"\"Implementation of the boundary integral operator.\n        See :meth:`pybamm.SpatialMethod.boundary_integral`\n        \"\"\"\n        # Calculate integration vector\n        integration_vector = self.boundary_integral_vector(\n            child.domain[0], region=region\n        )\n\n        out = integration_vector @ discretised_child\n        out.domain = []\n        return out\n\n    def boundary_integral_vector(self, domain, region):\n        \"\"\"A node in the expression tree representing an integral operator over the\n        boundary of a domain\n\n        .. math::\n            I = \\\\int_{\\\\partial a}\\\\!f(u)\\\\,du,\n\n        where :math:`\\\\partial a` is the boundary of the domain, and\n        :math:`u\\\\in\\\\text{domain boundary}`.\n\n        Parameters\n        ----------\n        domain : list\n            The domain(s) of the variable in the integrand\n        region : str\n            The region of the boundary over which to integrate. If region is\n            `entire` the integration is carried out over the entire boundary. If\n            region is `negative tab` or `positive tab` then the integration is only\n            carried out over the appropriate part of the boundary corresponding to\n            the tab.\n\n        Returns\n        -------\n        :class:`pybamm.Matrix`\n            The finite element integral vector for the domain\n        \"\"\"\n        # get primary domain mesh\n        if isinstance(domain, list):\n            domain = domain[0]\n        mesh = self.mesh[domain][0]\n\n        # make form for the boundary integral\n        @skfem.linear_form\n        def integral_form(v, dv, w):\n            return v\n\n        if region == \"entire\":\n            # assemble over all facets\n            integration_vector = skfem.asm(integral_form, mesh.facet_basis)\n        elif region == \"negative tab\":\n            # assemble over negative tab facets\n            integration_vector = skfem.asm(integral_form, mesh.negative_tab_basis)\n        elif region == \"positive tab\":\n            # assemble over positive tab facets\n            integration_vector = skfem.asm(integral_form, mesh.positive_tab_basis)\n\n        return pybamm.Matrix(integration_vector[np.newaxis, :])\n\n    def boundary_value_or_flux(self, symbol, discretised_child):\n        \"\"\"\n        Returns the average value of the symbol over the negative tab (\"negative tab\")\n        or the positive tab (\"positive tab\") in the Finite Element Method.\n\n        Overwrites the default :meth:`pybamm.SpatialMethod.boundary_value`\n        \"\"\"\n\n        # Return average value on the negative tab for \"negative tab\" and positive tab\n        # for \"positive tab\"\n        if isinstance(symbol, pybamm.BoundaryValue):\n            # get integration_vector\n            if symbol.side == \"negative tab\":\n                region = \"negative tab\"\n            elif symbol.side == \"positive tab\":\n                region = \"positive tab\"\n            domain = symbol.children[0].domain[0]\n            integration_vector = self.boundary_integral_vector(domain, region=region)\n\n            # divide integration weights by (numerical) tab width to give average value\n            boundary_val_vector = integration_vector / (\n                integration_vector @ pybamm.Vector(np.ones(integration_vector.shape[1]))\n            )\n\n        elif isinstance(symbol, pybamm.BoundaryGradient):\n            raise NotImplementedError\n\n        # Return boundary value with domain given by symbol\n        boundary_value = boundary_val_vector @ discretised_child\n\n        boundary_value.domain = symbol.domain\n\n        return boundary_value\n\n    def mass_matrix(self, symbol, boundary_conditions):\n        \"\"\"\n        Calculates the mass matrix for the finite element method.\n\n        Parameters\n        ----------\n        symbol: :class:`pybamm.Variable`\n            The variable corresponding to the equation for which we are\n            calculating the mass matrix.\n        boundary_conditions : dict\n            The boundary conditions of the model\n            ({symbol.id: {\"negative tab\": neg. tab bc, \"positive tab\": pos. tab bc}})\n\n        Returns\n        -------\n        :class:`pybamm.Matrix`\n            The (sparse) mass matrix for the spatial method.\n        \"\"\"\n        return self.assemble_mass_form(symbol, boundary_conditions)\n\n    def boundary_mass_matrix(self, symbol, boundary_conditions):\n        \"\"\"\n        Calculates the mass matrix for the finite element method assembled\n        over the boundary.\n\n        Parameters\n        ----------\n        symbol: :class:`pybamm.Variable`\n            The variable corresponding to the equation for which we are\n            calculating the mass matrix.\n        boundary_conditions : dict\n            The boundary conditions of the model\n            ({symbol.id: {\"negative tab\": neg. tab bc, \"positive tab\": pos. tab bc}})\n\n        Returns\n        -------\n        :class:`pybamm.Matrix`\n            The (sparse) mass matrix for the spatial method.\n        \"\"\"\n        return self.assemble_mass_form(symbol, boundary_conditions, region=\"boundary\")\n\n    def assemble_mass_form(self, symbol, boundary_conditions, region=\"interior\"):\n        \"\"\"\n        Assembles the form of the finite element mass matrix over the domain\n        interior or boundary.\n\n        Parameters\n        ----------\n        symbol: :class:`pybamm.Variable`\n            The variable corresponding to the equation for which we are\n            calculating the mass matrix.\n        boundary_conditions : dict\n            The boundary conditions of the model\n            ({symbol.id: {\"negative tab\": neg. tab bc, \"positive tab\": pos. tab bc}})\n        region: str, optional\n            The domain over which to assemble the mass matrix form. Can be \"interior\"\n            (default) or \"boundary\".\n\n        Returns\n        -------\n        :class:`pybamm.Matrix`\n            The (sparse) mass matrix for the spatial method.\n        \"\"\"\n        # get primary domain mesh\n        domain = symbol.domain[0]\n        mesh = self.mesh[domain][0]\n\n        # create form for mass\n        @skfem.bilinear_form\n        def mass_form(u, du, v, dv, w):\n            return u * v\n\n        # assemble mass matrix\n        if region == \"interior\":\n            mass = skfem.asm(mass_form, mesh.basis)\n        if region == \"boundary\":\n            mass = skfem.asm(mass_form, mesh.facet_basis)\n\n        # get boundary conditions and type\n        if symbol.id in boundary_conditions:\n            _, neg_bc_type = boundary_conditions[symbol.id][\"negative tab\"]\n            _, pos_bc_type = boundary_conditions[symbol.id][\"positive tab\"]\n\n            if neg_bc_type == \"Dirichlet\":\n                # set source terms to zero on boundary by zeroing out mass matrix\n                self.bc_apply(mass, mesh.negative_tab_dofs, zero=True)\n            if pos_bc_type == \"Dirichlet\":\n                # set source terms to zero on boundary by zeroing out mass matrix\n                self.bc_apply(mass, mesh.positive_tab_dofs, zero=True)\n\n        return pybamm.Matrix(mass)\n\n    def bc_apply(self, M, boundary, zero=False):\n        \"\"\"\n        Adjusts the assemled finite element matrices to account for boundary conditons.\n\n        Parameters\n        ----------\n        M: :class:`scipy.sparse.coo_matrix`\n            The assemled finite element matrix to adjust.\n        boundary: :class:`numpy.array`\n            Array of the indicies which correspond to the boundary.\n        zero: bool, optional\n            If True, the rows of M given by the indicies in boundary are set to zero.\n            If False, the diagonal element is set to one. default is False.\n        \"\"\"\n        row = np.arange(0, np.size(boundary))\n        if zero:\n            data = np.zeros_like(boundary)\n        else:\n            data = np.ones_like(boundary)\n        bc_matrix = csr_matrix(\n            (data, (row, boundary)), shape=(np.size(boundary), np.shape(M)[1])\n        )\n        M[boundary] = bc_matrix",
  "def __init__(self, mesh):\n        super().__init__(mesh)\n        # add npts_for_broadcast to mesh domains for this particular discretisation\n        for dom in mesh.keys():\n            for i in range(len(mesh[dom])):\n                mesh[dom][i].npts_for_broadcast = mesh[dom][i].npts",
  "def spatial_variable(self, symbol):\n        \"\"\"\n        Creates a discretised spatial variable compatible with\n        the FiniteElement method.\n\n        Parameters\n        -----------\n        symbol : :class:`pybamm.SpatialVariable`\n            The spatial variable to be discretised.\n\n        Returns\n        -------\n        :class:`pybamm.Vector`\n            Contains the discretised spatial variable\n        \"\"\"\n        symbol_mesh = self.mesh\n        if symbol.name == \"y\":\n            vector = pybamm.Vector(\n                symbol_mesh[\"current collector\"][0].edges[\"y\"], domain=symbol.domain\n            )\n        elif symbol.name == \"z\":\n            vector = pybamm.Vector(\n                symbol_mesh[\"current collector\"][0].edges[\"z\"], domain=symbol.domain\n            )\n        else:\n            raise pybamm.GeometryError(\n                \"Spatial variable must be 'y' or 'z' not {}\".format(symbol.name)\n            )\n        return vector",
  "def gradient(self, symbol, discretised_symbol, boundary_conditions):\n        \"\"\"Matrix-vector multiplication to implement the gradient operator.\n        See :meth:`pybamm.SpatialMethod.gradient`\n        \"\"\"\n        raise NotImplementedError",
  "def divergence(self, symbol, discretised_symbol, boundary_conditions):\n        \"\"\"Matrix-vector multiplication to implement the divergence operator.\n        See :meth:`pybamm.SpatialMethod.divergence`\n        \"\"\"\n        raise NotImplementedError",
  "def laplacian(self, symbol, discretised_symbol, boundary_conditions):\n        \"\"\"Matrix-vector multiplication to implement the laplacian operator.\n\n        Parameters\n        ----------\n        symbol: :class:`pybamm.Symbol`\n            The symbol that we will take the laplacian of.\n        discretised_symbol: :class:`pybamm.Symbol`\n            The discretised symbol of the correct size\n        boundary_conditions : dict\n            The boundary conditions of the model\n            ({symbol.id: {\"negative tab\": neg. tab bc, \"positive tab\": pos. tab bc}})\n\n        Returns\n        -------\n        :class: `pybamm.Array`\n            Contains the result of acting the discretised gradient on\n            the child discretised_symbol\n        \"\"\"\n        domain = symbol.domain[0]\n        mesh = self.mesh[domain][0]\n\n        stiffness_matrix = self.stiffness_matrix(symbol, boundary_conditions)\n\n        # get boundary conditions and type\n        neg_bc_value, neg_bc_type = boundary_conditions[symbol.id][\"negative tab\"]\n        pos_bc_value, pos_bc_type = boundary_conditions[symbol.id][\"positive tab\"]\n        # boundary load vector is adjusted to account for boundary conditions below\n        boundary_load = pybamm.Vector(np.zeros(mesh.npts))\n\n        # assemble boundary load if Neumann boundary conditions\n        if \"Neumann\" in [neg_bc_type, pos_bc_type]:\n            # make form for unit load over the boundary\n            @skfem.linear_form\n            def unit_bc_load_form(v, dv, w):\n                return v\n\n        if neg_bc_type == \"Neumann\":\n            # assemble unit load over tab\n            neg_bc_load = skfem.asm(unit_bc_load_form, mesh.negative_tab_basis)\n            # value multiplied by weights\n            boundary_load = boundary_load + neg_bc_value * pybamm.Vector(neg_bc_load)\n        elif neg_bc_type == \"Dirichlet\":\n            # set Dirichlet value at facets corresponding to tab\n            neg_bc_load = np.zeros(mesh.npts)\n            neg_bc_load[mesh.negative_tab_dofs] = 1\n            boundary_load = boundary_load - neg_bc_value * pybamm.Vector(neg_bc_load)\n        else:\n            raise ValueError(\n                \"boundary condition must be Dirichlet or Neumann, not '{}'\".format(\n                    neg_bc_type\n                )\n            )\n\n        if pos_bc_type == \"Neumann\":\n            # assemble unit load over tab\n            pos_bc_load = skfem.asm(unit_bc_load_form, mesh.positive_tab_basis)\n            # value multiplied by weights\n            boundary_load = boundary_load + pos_bc_value * pybamm.Vector(pos_bc_load)\n        elif pos_bc_type == \"Dirichlet\":\n            # set Dirichlet value at facets corresponding to tab\n            pos_bc_load = np.zeros(mesh.npts)\n            pos_bc_load[mesh.positive_tab_dofs] = 1\n            boundary_load = boundary_load - pos_bc_value * pybamm.Vector(pos_bc_load)\n        else:\n            raise ValueError(\n                \"boundary condition must be Dirichlet or Neumann, not '{}'\".format(\n                    pos_bc_type\n                )\n            )\n\n        return -stiffness_matrix @ discretised_symbol + boundary_load",
  "def gradient_squared(self, symbol, discretised_symbol, boundary_conditions):\n        \"\"\"Matrix-vector multiplication to implement the inner product of the\n        gradient operator with itself.\n        See :meth:`pybamm.SpatialMethod.gradient_squared`\n        \"\"\"\n        stiffness_matrix = self.stiffness_matrix(symbol, boundary_conditions)\n\n        return stiffness_matrix @ (discretised_symbol ** 2)",
  "def stiffness_matrix(self, symbol, boundary_conditions):\n        \"\"\"\n        Laplacian (stiffness) matrix for finite elements in the appropriate domain.\n\n        Parameters\n        ----------\n        symbol: :class:`pybamm.Symbol`\n            The symbol for which we want to calculate the laplacian matrix\n        boundary_conditions : dict\n            The boundary conditions of the model\n            ({symbol.id: {\"negative tab\": neg. tab bc, \"positive tab\": pos. tab bc}})\n\n        Returns\n        -------\n        :class:`pybamm.Matrix`\n            The (sparse) finite element stiffness matrix for the domain\n        \"\"\"\n        # get primary domain mesh\n        domain = symbol.domain[0]\n        mesh = self.mesh[domain][0]\n\n        # make form for the stiffness\n        @skfem.bilinear_form\n        def stiffness_form(u, du, v, dv, w):\n            return sum(du * dv)\n\n        # assemble the stifnness matrix\n        stiffness = skfem.asm(stiffness_form, mesh.basis)\n\n        # get boundary conditions and type\n        try:\n            _, neg_bc_type = boundary_conditions[symbol.id][\"negative tab\"]\n            _, pos_bc_type = boundary_conditions[symbol.id][\"positive tab\"]\n        except KeyError:\n            raise pybamm.ModelError(\n                \"No boundary conditions provided for symbol `{}``\".format(symbol)\n            )\n\n        # adjust matrix for Dirichlet boundary conditions\n        if neg_bc_type == \"Dirichlet\":\n            self.bc_apply(stiffness, mesh.negative_tab_dofs)\n        if pos_bc_type == \"Dirichlet\":\n            self.bc_apply(stiffness, mesh.positive_tab_dofs)\n\n        return pybamm.Matrix(stiffness)",
  "def integral(self, child, discretised_child):\n        \"\"\"Vector-vector dot product to implement the integral operator.\n        See :meth:`pybamm.SpatialMethod.integral`\n        \"\"\"\n        # Calculate integration vector\n        integration_vector = self.definite_integral_matrix(child.domain[0])\n\n        out = integration_vector @ discretised_child\n\n        return out",
  "def definite_integral_matrix(self, domain, vector_type=\"row\"):\n        \"\"\"\n        Matrix for finite-element implementation of the definite integral over\n        the entire domain\n\n        .. math::\n            I = \\\\int_{\\Omega}\\\\!f(s)\\\\,dx\n\n        for where :math:`\\Omega` is the domain.\n\n        Parameters\n        ----------\n        domain : list\n            The domain(s) of integration\n        vector_type : str, optional\n            Whether to return a row or column vector (default is row)\n\n        Returns\n        -------\n        :class:`pybamm.Matrix`\n            The finite element integral vector for the domain\n        \"\"\"\n        # get primary domain mesh\n        if isinstance(domain, list):\n            domain = domain[0]\n        mesh = self.mesh[domain][0]\n\n        # make form for the integral\n        @skfem.linear_form\n        def integral_form(v, dv, w):\n            return v\n\n        # assemble\n        vector = skfem.asm(integral_form, mesh.basis)\n\n        if vector_type == \"row\":\n            return pybamm.Matrix(vector[np.newaxis, :])\n        elif vector_type == \"column\":\n            return pybamm.Matrix(vector[:, np.newaxis])",
  "def indefinite_integral(self, child, discretised_child):\n        \"\"\"Implementation of the indefinite integral operator. The\n        input discretised child must be defined on the internal mesh edges.\n        See :meth:`pybamm.SpatialMethod.indefinite_integral`\n        \"\"\"\n        raise NotImplementedError",
  "def boundary_integral(self, child, discretised_child, region):\n        \"\"\"Implementation of the boundary integral operator.\n        See :meth:`pybamm.SpatialMethod.boundary_integral`\n        \"\"\"\n        # Calculate integration vector\n        integration_vector = self.boundary_integral_vector(\n            child.domain[0], region=region\n        )\n\n        out = integration_vector @ discretised_child\n        out.domain = []\n        return out",
  "def boundary_integral_vector(self, domain, region):\n        \"\"\"A node in the expression tree representing an integral operator over the\n        boundary of a domain\n\n        .. math::\n            I = \\\\int_{\\\\partial a}\\\\!f(u)\\\\,du,\n\n        where :math:`\\\\partial a` is the boundary of the domain, and\n        :math:`u\\\\in\\\\text{domain boundary}`.\n\n        Parameters\n        ----------\n        domain : list\n            The domain(s) of the variable in the integrand\n        region : str\n            The region of the boundary over which to integrate. If region is\n            `entire` the integration is carried out over the entire boundary. If\n            region is `negative tab` or `positive tab` then the integration is only\n            carried out over the appropriate part of the boundary corresponding to\n            the tab.\n\n        Returns\n        -------\n        :class:`pybamm.Matrix`\n            The finite element integral vector for the domain\n        \"\"\"\n        # get primary domain mesh\n        if isinstance(domain, list):\n            domain = domain[0]\n        mesh = self.mesh[domain][0]\n\n        # make form for the boundary integral\n        @skfem.linear_form\n        def integral_form(v, dv, w):\n            return v\n\n        if region == \"entire\":\n            # assemble over all facets\n            integration_vector = skfem.asm(integral_form, mesh.facet_basis)\n        elif region == \"negative tab\":\n            # assemble over negative tab facets\n            integration_vector = skfem.asm(integral_form, mesh.negative_tab_basis)\n        elif region == \"positive tab\":\n            # assemble over positive tab facets\n            integration_vector = skfem.asm(integral_form, mesh.positive_tab_basis)\n\n        return pybamm.Matrix(integration_vector[np.newaxis, :])",
  "def boundary_value_or_flux(self, symbol, discretised_child):\n        \"\"\"\n        Returns the average value of the symbol over the negative tab (\"negative tab\")\n        or the positive tab (\"positive tab\") in the Finite Element Method.\n\n        Overwrites the default :meth:`pybamm.SpatialMethod.boundary_value`\n        \"\"\"\n\n        # Return average value on the negative tab for \"negative tab\" and positive tab\n        # for \"positive tab\"\n        if isinstance(symbol, pybamm.BoundaryValue):\n            # get integration_vector\n            if symbol.side == \"negative tab\":\n                region = \"negative tab\"\n            elif symbol.side == \"positive tab\":\n                region = \"positive tab\"\n            domain = symbol.children[0].domain[0]\n            integration_vector = self.boundary_integral_vector(domain, region=region)\n\n            # divide integration weights by (numerical) tab width to give average value\n            boundary_val_vector = integration_vector / (\n                integration_vector @ pybamm.Vector(np.ones(integration_vector.shape[1]))\n            )\n\n        elif isinstance(symbol, pybamm.BoundaryGradient):\n            raise NotImplementedError\n\n        # Return boundary value with domain given by symbol\n        boundary_value = boundary_val_vector @ discretised_child\n\n        boundary_value.domain = symbol.domain\n\n        return boundary_value",
  "def mass_matrix(self, symbol, boundary_conditions):\n        \"\"\"\n        Calculates the mass matrix for the finite element method.\n\n        Parameters\n        ----------\n        symbol: :class:`pybamm.Variable`\n            The variable corresponding to the equation for which we are\n            calculating the mass matrix.\n        boundary_conditions : dict\n            The boundary conditions of the model\n            ({symbol.id: {\"negative tab\": neg. tab bc, \"positive tab\": pos. tab bc}})\n\n        Returns\n        -------\n        :class:`pybamm.Matrix`\n            The (sparse) mass matrix for the spatial method.\n        \"\"\"\n        return self.assemble_mass_form(symbol, boundary_conditions)",
  "def boundary_mass_matrix(self, symbol, boundary_conditions):\n        \"\"\"\n        Calculates the mass matrix for the finite element method assembled\n        over the boundary.\n\n        Parameters\n        ----------\n        symbol: :class:`pybamm.Variable`\n            The variable corresponding to the equation for which we are\n            calculating the mass matrix.\n        boundary_conditions : dict\n            The boundary conditions of the model\n            ({symbol.id: {\"negative tab\": neg. tab bc, \"positive tab\": pos. tab bc}})\n\n        Returns\n        -------\n        :class:`pybamm.Matrix`\n            The (sparse) mass matrix for the spatial method.\n        \"\"\"\n        return self.assemble_mass_form(symbol, boundary_conditions, region=\"boundary\")",
  "def assemble_mass_form(self, symbol, boundary_conditions, region=\"interior\"):\n        \"\"\"\n        Assembles the form of the finite element mass matrix over the domain\n        interior or boundary.\n\n        Parameters\n        ----------\n        symbol: :class:`pybamm.Variable`\n            The variable corresponding to the equation for which we are\n            calculating the mass matrix.\n        boundary_conditions : dict\n            The boundary conditions of the model\n            ({symbol.id: {\"negative tab\": neg. tab bc, \"positive tab\": pos. tab bc}})\n        region: str, optional\n            The domain over which to assemble the mass matrix form. Can be \"interior\"\n            (default) or \"boundary\".\n\n        Returns\n        -------\n        :class:`pybamm.Matrix`\n            The (sparse) mass matrix for the spatial method.\n        \"\"\"\n        # get primary domain mesh\n        domain = symbol.domain[0]\n        mesh = self.mesh[domain][0]\n\n        # create form for mass\n        @skfem.bilinear_form\n        def mass_form(u, du, v, dv, w):\n            return u * v\n\n        # assemble mass matrix\n        if region == \"interior\":\n            mass = skfem.asm(mass_form, mesh.basis)\n        if region == \"boundary\":\n            mass = skfem.asm(mass_form, mesh.facet_basis)\n\n        # get boundary conditions and type\n        if symbol.id in boundary_conditions:\n            _, neg_bc_type = boundary_conditions[symbol.id][\"negative tab\"]\n            _, pos_bc_type = boundary_conditions[symbol.id][\"positive tab\"]\n\n            if neg_bc_type == \"Dirichlet\":\n                # set source terms to zero on boundary by zeroing out mass matrix\n                self.bc_apply(mass, mesh.negative_tab_dofs, zero=True)\n            if pos_bc_type == \"Dirichlet\":\n                # set source terms to zero on boundary by zeroing out mass matrix\n                self.bc_apply(mass, mesh.positive_tab_dofs, zero=True)\n\n        return pybamm.Matrix(mass)",
  "def bc_apply(self, M, boundary, zero=False):\n        \"\"\"\n        Adjusts the assemled finite element matrices to account for boundary conditons.\n\n        Parameters\n        ----------\n        M: :class:`scipy.sparse.coo_matrix`\n            The assemled finite element matrix to adjust.\n        boundary: :class:`numpy.array`\n            Array of the indicies which correspond to the boundary.\n        zero: bool, optional\n            If True, the rows of M given by the indicies in boundary are set to zero.\n            If False, the diagonal element is set to one. default is False.\n        \"\"\"\n        row = np.arange(0, np.size(boundary))\n        if zero:\n            data = np.zeros_like(boundary)\n        else:\n            data = np.ones_like(boundary)\n        bc_matrix = csr_matrix(\n            (data, (row, boundary)), shape=(np.size(boundary), np.shape(M)[1])\n        )\n        M[boundary] = bc_matrix",
  "def stiffness_form(u, du, v, dv, w):\n            return sum(du * dv)",
  "def integral_form(v, dv, w):\n            return v",
  "def integral_form(v, dv, w):\n            return v",
  "def mass_form(u, du, v, dv, w):\n            return u * v",
  "def unit_bc_load_form(v, dv, w):\n                return v",
  "class ZeroDimensionalMethod(pybamm.SpatialMethod):\n    \"\"\"\n    A discretisation class for the zero dimensional mesh\n\n    Parameters\n    ----------\n    mesh : :class: `pybamm.Mesh`\n        Contains all the submeshes for discretisation\n\n    **Extends** : :class:`pybamm.SpatialMethod`\n    \"\"\"\n\n    def __init__(self, mesh=None):\n        self._mesh = mesh\n\n    def mass_matrix(self, symbol, boundary_conditions):\n        \"\"\"\n        Calculates the mass matrix for a spatial method. Since the spatial method is\n        zero dimensional, this is simply the number 1.\n        \"\"\"\n        return pybamm.Matrix(np.ones((1, 1)))",
  "def __init__(self, mesh=None):\n        self._mesh = mesh",
  "def mass_matrix(self, symbol, boundary_conditions):\n        \"\"\"\n        Calculates the mass matrix for a spatial method. Since the spatial method is\n        zero dimensional, this is simply the number 1.\n        \"\"\"\n        return pybamm.Matrix(np.ones((1, 1)))",
  "class FiniteVolume(pybamm.SpatialMethod):\n    \"\"\"\n    A class which implements the steps specific to the finite volume method during\n    discretisation.\n\n    For broadcast and mass_matrix, we follow the default behaviour from SpatialMethod.\n\n    Parameters\n    ----------\n    mesh : :class:`pybamm.Mesh`\n        Contains all the submeshes for discretisation\n\n    **Extends:\"\": :class:`pybamm.SpatialMethod`\n    \"\"\"\n\n    def __init__(self, mesh):\n        super().__init__(mesh)\n        # add npts_for_broadcast to mesh domains for this particular discretisation\n        for dom in mesh.keys():\n            for i in range(len(mesh[dom])):\n                mesh[dom][i].npts_for_broadcast = mesh[dom][i].npts\n\n    def spatial_variable(self, symbol):\n        \"\"\"\n        Creates a discretised spatial variable compatible with\n        the FiniteVolume method.\n\n        Parameters\n        -----------\n        symbol : :class:`pybamm.SpatialVariable`\n            The spatial variable to be discretised.\n\n        Returns\n        -------\n        :class:`pybamm.Vector`\n            Contains the discretised spatial variable\n        \"\"\"\n        # for finite volume we use the cell centres\n        symbol_mesh = self.mesh.combine_submeshes(*symbol.domain)\n        return pybamm.Vector(symbol_mesh[0].nodes, domain=symbol.domain)\n\n    def gradient(self, symbol, discretised_symbol, boundary_conditions):\n        \"\"\"Matrix-vector multiplication to implement the gradient operator.\n        See :meth:`pybamm.SpatialMethod.gradient`\n        \"\"\"\n        # Discretise symbol\n        domain = symbol.domain\n\n        # Add boundary conditions, if defined\n        if symbol.id in boundary_conditions:\n            bcs = boundary_conditions[symbol.id]\n            # add ghost nodes\n            discretised_symbol = self.add_ghost_nodes(symbol, discretised_symbol, bcs)\n            # edit domain\n            domain = (\n                [domain[0] + \"_left ghost cell\"]\n                + domain\n                + [domain[-1] + \"_right ghost cell\"]\n            )\n\n        # note in 1D spherical grad and normal grad are the same\n        gradient_matrix = self.gradient_matrix(domain)\n\n        out = gradient_matrix @ discretised_symbol\n        return out\n\n    def gradient_matrix(self, domain):\n        \"\"\"\n        Gradient matrix for finite volumes in the appropriate domain.\n        Equivalent to grad(y) = (y[1:] - y[:-1])/dx\n\n        Parameters\n        ----------\n        domain : list\n            The domain(s) in which to compute the gradient matrix\n\n        Returns\n        -------\n        :class:`pybamm.Matrix`\n            The (sparse) finite volume gradient matrix for the domain\n        \"\"\"\n        # Create appropriate submesh by combining submeshes in domain\n        submesh_list = self.mesh.combine_submeshes(*domain)\n\n        # can just use 1st entry of list to obtain the point etc\n        submesh = submesh_list[0]\n\n        # Create 1D matrix using submesh\n        n = submesh.npts\n        e = 1 / submesh.d_nodes\n        sub_matrix = diags([-e, e], [0, 1], shape=(n - 1, n))\n\n        # second dim length\n        second_dim_len = len(submesh_list)\n\n        # generate full matrix from the submatrix\n        # Convert to csr_matrix so that we can take the index (row-slicing), which is\n        # not supported by the default kron format\n        # Note that this makes column-slicing inefficient, but this should not be an\n        # issue\n        matrix = csr_matrix(kron(eye(second_dim_len), sub_matrix))\n\n        return pybamm.Matrix(matrix)\n\n    def divergence(self, symbol, discretised_symbol, boundary_conditions):\n        \"\"\"Matrix-vector multiplication to implement the divergence operator.\n        See :meth:`pybamm.SpatialMethod.divergence`\n        \"\"\"\n        domain = symbol.domain\n        submesh_list = self.mesh.combine_submeshes(*domain)\n\n        divergence_matrix = self.divergence_matrix(domain)\n\n        # check for particle domain\n        if submesh_list[0].coord_sys == \"spherical polar\":\n            second_dim = len(submesh_list)\n            edges = submesh_list[0].edges\n\n            # create np.array of repeated submesh[0].nodes\n            r_numpy = np.kron(np.ones(second_dim), submesh_list[0].nodes)\n            r_edges_numpy = np.kron(np.ones(second_dim), edges)\n\n            r = pybamm.Vector(r_numpy)\n            r_edges = pybamm.Vector(r_edges_numpy)\n\n            out = (1 / (r ** 2)) * (\n                divergence_matrix @ ((r_edges ** 2) * discretised_symbol)\n            )\n        else:\n            out = divergence_matrix @ discretised_symbol\n\n        return out\n\n    def divergence_matrix(self, domain):\n        \"\"\"\n        Divergence matrix for finite volumes in the appropriate domain.\n        Equivalent to div(N) = (N[1:] - N[:-1])/dx\n\n        Parameters\n        ----------\n        domain : list\n            The domain(s) in which to compute the divergence matrix\n\n        Returns\n        -------\n        :class:`pybamm.Matrix`\n            The (sparse) finite volume divergence matrix for the domain\n        \"\"\"\n        # Create appropriate submesh by combining submeshes in domain\n        submesh_list = self.mesh.combine_submeshes(*domain)\n\n        # can just use 1st entry of list to obtain the point etc\n        submesh = submesh_list[0]\n        e = 1 / submesh.d_edges\n\n        # Create matrix using submesh\n        n = submesh.npts + 1\n        sub_matrix = diags([-e, e], [0, 1], shape=(n - 1, n))\n\n        # repeat matrix for each node in secondary dimensions\n        second_dim_len = len(submesh_list)\n        # generate full matrix from the submatrix\n        # Convert to csr_matrix so that we can take the index (row-slicing), which is\n        # not supported by the default kron format\n        # Note that this makes column-slicing inefficient, but this should not be an\n        # issue\n        matrix = csr_matrix(kron(eye(second_dim_len), sub_matrix))\n        return pybamm.Matrix(matrix)\n\n    def laplacian(self, symbol, discretised_symbol, boundary_conditions):\n        \"\"\"\n        Laplacian operator, implemented as div(grad(.))\n        See :meth:`pybamm.SpatialMethod.laplacian`\n        \"\"\"\n        grad = self.gradient(symbol, discretised_symbol, boundary_conditions)\n        return self.divergence(grad, grad, boundary_conditions)\n\n    def integral(self, child, discretised_child):\n        \"\"\"Vector-vector dot product to implement the integral operator. \"\"\"\n        # Calculate integration vector\n        integration_vector = self.definite_integral_matrix(child.domain)\n\n        # Check for spherical domains\n        submesh_list = self.mesh.combine_submeshes(*child.domain)\n        if submesh_list[0].coord_sys == \"spherical polar\":\n            second_dim = len(submesh_list)\n            r_numpy = np.kron(np.ones(second_dim), submesh_list[0].nodes)\n            r = pybamm.Vector(r_numpy)\n            out = 4 * np.pi ** 2 * integration_vector @ (discretised_child * r)\n        else:\n            out = integration_vector @ discretised_child\n\n        return out\n\n    def definite_integral_matrix(self, domain, vector_type=\"row\"):\n        \"\"\"\n        Matrix for finite-volume implementation of the definite integral in the\n        primary dimension\n\n        .. math::\n            I = \\\\int_{a}^{b}\\\\!f(s)\\\\,ds\n\n        for where :math:`a` and :math:`b` are the left-hand and right-hand boundaries of\n        the domain respectively\n\n        Parameters\n        ----------\n        domain : list\n            The domain(s) of integration\n\n        Returns\n        -------\n        :class:`pybamm.Matrix`\n            The finite volume integral matrix for the domain\n        vector_type : str, optional\n            Whether to return a row or column vector in the primary dimension\n            (default is row)\n        \"\"\"\n        # Create appropriate submesh by combining submeshes in domain\n        submesh_list = self.mesh.combine_submeshes(*domain)\n\n        # Create vector of ones for primary domain submesh\n        submesh = submesh_list[0]\n        vector = submesh.d_edges * np.ones_like(submesh.nodes)\n\n        if vector_type == \"row\":\n            vector = vector[np.newaxis, :]\n        elif vector_type == \"column\":\n            vector = vector[:, np.newaxis]\n\n        # repeat matrix for each node in secondary dimensions\n        second_dim_len = len(submesh_list)\n        # generate full matrix from the submatrix\n        # Convert to csr_matrix so that we can take the index (row-slicing), which is\n        # not supported by the default kron format\n        # Note that this makes column-slicing inefficient, but this should not be an\n        # issue\n        matrix = csr_matrix(kron(eye(second_dim_len), vector))\n        return pybamm.Matrix(matrix)\n\n    def indefinite_integral(self, child, discretised_child):\n        \"\"\"Implementation of the indefinite integral operator. \"\"\"\n\n        # Different integral matrix depending on whether the integrand evaluates on\n        # edges or nodes\n        if child.evaluates_on_edges():\n            integration_matrix = self.indefinite_integral_matrix_edges(child.domain)\n        else:\n            integration_matrix = self.indefinite_integral_matrix_nodes(child.domain)\n\n        # Don't need to check for spherical domains as spherical polars\n        # only change the diveregence (childs here have grad and no div)\n        out = integration_matrix @ discretised_child\n\n        out.domain = child.domain\n        out.auxiliary_domains = child.auxiliary_domains\n\n        return out\n\n    def indefinite_integral_matrix_edges(self, domain):\n        \"\"\"\n        Matrix for finite-volume implementation of the indefinite integral where the\n        integrand is evaluated on mesh edges\n\n        .. math::\n            F(x) = \\\\int_0^x\\\\!f(u)\\\\,du\n\n        The indefinite integral must satisfy the following conditions:\n\n        - :math:`F(0) = 0`\n        - :math:`f(x) = \\\\frac{dF}{dx}`\n\n        or, in discrete form,\n\n        - `BoundaryValue(F, \"left\") = 0`, i.e. :math:`3*F_0 - F_1 = 0`\n        - :math:`f_{i+1/2} = (F_{i+1} - F_i) / dx_{i+1/2}`\n\n        Hence we must have\n\n        - :math:`F_0 = du_{1/2} * f_{1/2} / 2`\n        - :math:`F_{i+1} = F_i + du * f_{i+1/2}`\n\n        Note that :math:`f_{-1/2}` and :math:`f_{n+1/2}` are included in the discrete\n        integrand vector `f`, so we add a column of zeros at each end of the\n        indefinite integral matrix to ignore these.\n\n        Parameters\n        ----------\n        domain : list\n            The domain(s) of integration\n\n        Returns\n        -------\n        :class:`pybamm.Matrix`\n            The finite volume integral matrix for the domain\n        \"\"\"\n\n        # Create appropriate submesh by combining submeshes in domain\n        submesh_list = self.mesh.combine_submeshes(*domain)\n        submesh = submesh_list[0]\n        n = submesh.npts\n        sec_pts = len(submesh_list)\n\n        du_n = submesh.d_nodes\n        du_entries = [du_n] * (n - 1)\n        offset = -np.arange(1, n, 1)\n        main_integral_matrix = diags(du_entries, offset, shape=(n, n - 1))\n        bc_offset_matrix = lil_matrix((n, n - 1))\n        bc_offset_matrix[:, 0] = du_n[0] / 2\n        sub_matrix = main_integral_matrix + bc_offset_matrix\n        # add a column of zeros at each end\n        zero_col = csr_matrix((n, 1))\n        sub_matrix = hstack([zero_col, sub_matrix, zero_col])\n        # Convert to csr_matrix so that we can take the index (row-slicing), which is\n        # not supported by the default kron format\n        # Note that this makes column-slicing inefficient, but this should not be an\n        # issue\n        matrix = csr_matrix(kron(eye(sec_pts), sub_matrix))\n\n        return pybamm.Matrix(matrix)\n\n    def delta_function(self, symbol, discretised_symbol):\n        \"\"\"\n        Delta function. Implemented as a vector whose only non-zero element is the\n        first (if symbol.side = \"left\") or last (if symbol.side = \"right\"), with\n        appropriate value so that the integral of the delta function across the whole\n        domain is the same as the integral of the discretised symbol across the whole\n        domain.\n\n        See :meth:`pybamm.SpatialMethod.delta_function`\n        \"\"\"\n        # Find the number of submeshes\n        submesh_list = self.mesh.combine_submeshes(*symbol.domain)\n\n        prim_pts = submesh_list[0].npts\n        sec_pts = len(submesh_list)\n\n        # Create submatrix to compute delta function as a flux\n        if symbol.side == \"left\":\n            dx = submesh_list[0].d_nodes[0]\n            sub_matrix = csr_matrix(([1], ([0], [0])), shape=(prim_pts, 1))\n        elif symbol.side == \"right\":\n            dx = submesh_list[0].d_nodes[-1]\n            sub_matrix = csr_matrix(([1], ([prim_pts - 1], [0])), shape=(prim_pts, 1))\n\n        # Calculate domain width, to make sure that the integral of the delta function\n        # is the same as the integral of the child\n        domain_width = submesh_list[0].edges[-1] - submesh_list[0].edges[0]\n        # Generate full matrix from the submatrix\n        # Convert to csr_matrix so that we can take the index (row-slicing), which is\n        # not supported by the default kron format\n        # Note that this makes column-slicing inefficient, but this should not be an\n        # issue\n        matrix = kron(eye(sec_pts), sub_matrix).toarray()\n\n        # Return delta function, keep domains\n        delta_fn = pybamm.Matrix(domain_width / dx * matrix) * discretised_symbol\n        delta_fn.domain = symbol.domain\n        delta_fn.auxiliary_domains = symbol.auxiliary_domains\n\n        return delta_fn\n\n    def internal_neumann_condition(\n        self, left_symbol_disc, right_symbol_disc, left_mesh, right_mesh\n    ):\n        \"\"\"\n        A method to find the internal neumann conditions between two symbols\n        on adjacent subdomains.\n\n        Parameters\n        ----------\n        left_symbol_disc : :class:`pybamm.Symbol`\n            The discretised symbol on the left subdomain\n        right_symbol_disc : :class:`pybamm.Symbol`\n            The discretised symbol on the right subdomain\n        left_mesh : list\n            The mesh on the left subdomain\n        right_mesh : list\n            The mesh on the right subdomain\n        \"\"\"\n\n        left_npts = left_mesh[0].npts\n        right_npts = right_mesh[0].npts\n\n        sec_pts = len(left_mesh)\n\n        if sec_pts != len(right_mesh):\n            raise pybamm.DomainError(\n                \"\"\"Number of secondary points in subdomains do not match\"\"\"\n            )\n\n        left_sub_matrix = np.zeros((1, left_npts))\n        left_sub_matrix[0][left_npts - 1] = 1\n        left_matrix = pybamm.Matrix(csr_matrix(kron(eye(sec_pts), left_sub_matrix)))\n\n        right_sub_matrix = np.zeros((1, right_npts))\n        right_sub_matrix[0][0] = 1\n        right_matrix = pybamm.Matrix(csr_matrix(kron(eye(sec_pts), right_sub_matrix)))\n\n        # Remove domains to avoid clash\n        left_domain = left_symbol_disc.domain\n        right_domain = right_symbol_disc.domain\n        left_symbol_disc.domain = []\n        right_symbol_disc.domain = []\n\n        # Finite volume derivative\n        dy = right_matrix @ right_symbol_disc - left_matrix @ left_symbol_disc\n        dx = right_mesh[0].nodes[0] - left_mesh[0].nodes[-1]\n\n        # Change domains back\n        left_symbol_disc.domain = left_domain\n        right_symbol_disc.domain = right_domain\n\n        return dy / dx\n\n    def indefinite_integral_matrix_nodes(self, domain):\n        \"\"\"\n        Matrix for finite-volume implementation of the indefinite integral where the\n        integrand is evaluated on mesh nodes.\n        This is just a straightforward cumulative sum of the integrand\n\n        Parameters\n        ----------\n        domain : list\n            The domain(s) of integration\n\n        Returns\n        -------\n        :class:`pybamm.Matrix`\n            The finite volume integral matrix for the domain\n        \"\"\"\n\n        # Create appropriate submesh by combining submeshes in domain\n        submesh_list = self.mesh.combine_submeshes(*domain)\n        submesh = submesh_list[0]\n        n = submesh.npts\n        sec_pts = len(submesh_list)\n\n        du_n = submesh.d_edges\n        du_entries = [du_n] * (n)\n        offset = -np.arange(1, n + 1, 1)\n        sub_matrix = diags(du_entries, offset, shape=(n + 1, n))\n        # Convert to csr_matrix so that we can take the index (row-slicing), which is\n        # not supported by the default kron format\n        # Note that this makes column-slicing inefficient, but this should not be an\n        # issue\n        matrix = csr_matrix(kron(eye(sec_pts), sub_matrix))\n\n        return pybamm.Matrix(matrix)\n\n    def add_ghost_nodes(self, symbol, discretised_symbol, bcs):\n        \"\"\"\n        Add ghost nodes to a symbol.\n\n        For Dirichlet bcs, for a boundary condition \"y = a at the left-hand boundary\",\n        we concatenate a ghost node to the start of the vector y with value \"2*a - y1\"\n        where y1 is the value of the first node.\n        Similarly for the right-hand boundary condition.\n\n        For Dirichlet bcs, for a boundary condition \"y = a at the left-hand boundary\",\n        we concatenate a ghost node to the start of the vector y with value \"2*a - y1\"\n        where y1 is the value of the first node.\n        Similarly for the right-hand boundary condition.\n\n        For Neumann bcs, for a boundary condition \"dy/dx = b at the left-hand boundary\",\n        we concatenate a ghost node to the start of the vector y with value \"b*h + y1\"\n        where y1 is the value of the first node and h is the mesh size.\n        Similarly for the right-hand boundary condition.\n\n        Parameters\n        ----------\n        domain : list of strings\n            The domain of the symbol for which to add ghost nodes\n        bcs : dict of tuples (:class:`pybamm.Scalar`, str)\n            Dictionary (with keys \"left\" and \"right\") of boundary conditions. Each\n            boundary condition consists of a value and a flag indicating its type\n            (e.g. \"Dirichlet\")\n\n        Returns\n        -------\n        :class:`pybamm.Symbol` (shape (n+2, n))\n            `Matrix @ discretised_symbol + bcs_vector`. When evaluated, this gives the\n            discretised_symbol, with appropriate ghost nodes concatenated at each end.\n\n        \"\"\"\n        # get relevant grid points\n        submesh_list = self.mesh.combine_submeshes(*symbol.domain)\n\n        # Prepare sizes and empty bcs_vector\n        n = submesh_list[0].npts\n        sec_pts = len(submesh_list)\n\n        bcs_vector = pybamm.Vector(np.array([]))  # starts empty\n\n        lbc_value, lbc_type = bcs[\"left\"]\n        rbc_value, rbc_type = bcs[\"right\"]\n\n        for i in range(sec_pts):\n            if lbc_value.evaluates_to_number():\n                lbc_i = lbc_value\n            else:\n                lbc_i = lbc_value[i]\n            if rbc_value.evaluates_to_number():\n                rbc_i = rbc_value\n            else:\n                rbc_i = rbc_value[i]\n            if lbc_type == \"Dirichlet\":\n                left_ghost_constant = 2 * lbc_i\n            elif lbc_type == \"Neumann\":\n                dx = 2 * (submesh_list[0].nodes[0] - submesh_list[0].edges[0])\n                left_ghost_constant = -dx * lbc_i\n            else:\n                raise ValueError(\n                    \"boundary condition must be Dirichlet or Neumann, not '{}'\".format(\n                        lbc_type\n                    )\n                )\n            if rbc_type == \"Dirichlet\":\n                right_ghost_constant = 2 * rbc_i\n            elif rbc_type == \"Neumann\":\n                dx = 2 * (submesh_list[0].edges[-1] - submesh_list[0].nodes[-1])\n                right_ghost_constant = dx * rbc_i\n            else:\n                raise ValueError(\n                    \"boundary condition must be Dirichlet or Neumann, not '{}'\".format(\n                        rbc_type\n                    )\n                )\n            # concatenate\n            bcs_vector = pybamm.NumpyConcatenation(\n                bcs_vector,\n                left_ghost_constant,\n                pybamm.Vector(np.zeros(n)),\n                right_ghost_constant,\n            )\n\n        # Make matrix to calculate ghost nodes\n        bc_factors = {\"Dirichlet\": -1, \"Neumann\": 1}\n        left_factor = bc_factors[lbc_type]\n        right_factor = bc_factors[rbc_type]\n        # coo_matrix takes inputs (data, (row, col)) and puts data[i] at the point\n        # (row[i], col[i]) for each index of data.\n        left_ghost_vector = coo_matrix(([left_factor], ([0], [0])), shape=(1, n))\n        right_ghost_vector = coo_matrix(([right_factor], ([0], [n - 1])), shape=(1, n))\n        sub_matrix = vstack([left_ghost_vector, eye(n), right_ghost_vector])\n\n        # repeat matrix for secondary dimensions\n        # Convert to csr_matrix so that we can take the index (row-slicing), which is\n        # not supported by the default kron format\n        # Note that this makes column-slicing inefficient, but this should not be an\n        # issue\n        matrix = csr_matrix(kron(eye(sec_pts), sub_matrix))\n\n        return pybamm.Matrix(matrix) @ discretised_symbol + bcs_vector\n\n    def boundary_value_or_flux(self, symbol, discretised_child):\n        \"\"\"\n        Uses linear extrapolation to get the boundary value or flux of a variable in the\n        Finite Volume Method.\n\n        See :meth:`pybamm.SpatialMethod.boundary_value`\n        \"\"\"\n\n        # Find the number of submeshes\n        submesh_list = self.mesh.combine_submeshes(*discretised_child.domain)\n\n        prim_pts = submesh_list[0].npts\n        sec_pts = len(submesh_list)\n\n        # Create submatrix to compute boundary values or fluxes\n        if isinstance(symbol, pybamm.BoundaryValue):\n            if symbol.side == \"left\":\n                sub_matrix = csr_matrix(\n                    ([1.5, -0.5], ([0, 0], [0, 1])), shape=(1, prim_pts)\n                )\n            elif symbol.side == \"right\":\n                sub_matrix = csr_matrix(\n                    ([-0.5, 1.5], ([0, 0], [prim_pts - 2, prim_pts - 1])),\n                    shape=(1, prim_pts),\n                )\n        elif isinstance(symbol, pybamm.BoundaryGradient):\n            if symbol.side == \"left\":\n                dx = submesh_list[0].d_nodes[0]\n                sub_matrix = (1 / dx) * csr_matrix(\n                    ([-1, 1], ([0, 0], [0, 1])), shape=(1, prim_pts)\n                )\n            elif symbol.side == \"right\":\n                dx = submesh_list[0].d_nodes[-1]\n                sub_matrix = (1 / dx) * csr_matrix(\n                    ([-1, 1], ([0, 0], [prim_pts - 2, prim_pts - 1])),\n                    shape=(1, prim_pts),\n                )\n\n        # Generate full matrix from the submatrix\n        # Convert to csr_matrix so that we can take the index (row-slicing), which is\n        # not supported by the default kron format\n        # Note that this makes column-slicing inefficient, but this should not be an\n        # issue\n        matrix = csr_matrix(kron(eye(sec_pts), sub_matrix))\n\n        # Return boundary value with domain given by symbol\n        boundary_value = pybamm.Matrix(matrix) @ discretised_child\n        boundary_value.domain = symbol.domain\n        boundary_value.auxiliary_domains = symbol.auxiliary_domains\n\n        return boundary_value\n\n    def process_binary_operators(self, bin_op, left, right, disc_left, disc_right):\n        \"\"\"Discretise binary operators in model equations.  Performs appropriate\n        averaging of diffusivities if one of the children is a gradient operator, so\n        that discretised sizes match up.\n\n        Parameters\n        ----------\n        bin_op : :class:`pybamm.BinaryOperator`\n            Binary operator to discretise\n        left : :class:`pybamm.Symbol`\n            The left child of `bin_op`\n        right : :class:`pybamm.Symbol`\n            The right child of `bin_op`\n        disc_left : :class:`pybamm.Symbol`\n            The discretised left child of `bin_op`\n        disc_right : :class:`pybamm.Symbol`\n            The discretised right child of `bin_op`\n        Returns\n        -------\n        :class:`pybamm.BinaryOperator`\n            Discretised binary operator\n\n        \"\"\"\n        # Post-processing to make sure discretised dimensions match\n        left_evaluates_on_edges = left.evaluates_on_edges()\n        right_evaluates_on_edges = right.evaluates_on_edges()\n\n        # inner product takes fluxes from edges to nodes\n        if isinstance(bin_op, pybamm.Inner):\n            if left_evaluates_on_edges:\n                disc_left = self.edge_to_node(disc_left)\n            if right_evaluates_on_edges:\n                disc_right = self.edge_to_node(disc_right)\n\n        # If neither child evaluates on edges, or both children have gradients,\n        # no need to do any averaging\n        elif left_evaluates_on_edges == right_evaluates_on_edges:\n            pass\n        # If only left child evaluates on edges, map right child onto edges\n        elif left_evaluates_on_edges and not right_evaluates_on_edges:\n            disc_right = self.node_to_edge(disc_right)\n        # If only right child evaluates on edges, map left child onto edges\n        elif right_evaluates_on_edges and not left_evaluates_on_edges:\n            disc_left = self.node_to_edge(disc_left)\n        # Return new binary operator with appropriate class\n        out = bin_op.__class__(disc_left, disc_right)\n        return out\n\n    def concatenation(self, disc_children):\n        \"\"\"Discrete concatenation, taking `edge_to_node` for children that evaluate on\n        edges.\n        See :meth:`pybamm.SpatialMethod.concatenation`\n        \"\"\"\n        for idx, child in enumerate(disc_children):\n            n_nodes = sum(\n                len(mesh.nodes) for mesh in self.mesh.combine_submeshes(*child.domain)\n            )\n            n_edges = sum(\n                len(mesh.edges) for mesh in self.mesh.combine_submeshes(*child.domain)\n            )\n            child_size = child.size\n            if child_size != n_nodes:\n                # Average any children that evaluate on the edges (size n_edges) to\n                # evaluate on nodes instead, so that concatenation works properly\n                if child_size == n_edges:\n                    disc_children[idx] = self.edge_to_node(child)\n                else:\n                    raise pybamm.ShapeError(\n                        \"\"\"\n                        child must have size n_nodes (number of nodes in the mesh)\n                        or n_edges (number of edges in the mesh)\n                        \"\"\"\n                    )\n        return pybamm.DomainConcatenation(disc_children, self.mesh)\n\n    def edge_to_node(self, discretised_symbol):\n        \"\"\"\n        Convert a discretised symbol evaluated on the cell edges to a discretised symbol\n        evaluated on the cell nodes.\n        See :meth:`pybamm.FiniteVolume.shift`\n        \"\"\"\n        return self.shift(discretised_symbol, \"edge to node\")\n\n    def node_to_edge(self, discretised_symbol):\n        \"\"\"\n        Convert a discretised symbol evaluated on the cell nodes to a discretised symbol\n        evaluated on the cell edges.\n        See :meth:`pybamm.FiniteVolume.shift`\n        \"\"\"\n        return self.shift(discretised_symbol, \"node to edge\")\n\n    def shift(self, discretised_symbol, shift_key):\n        \"\"\"\n        Convert a discretised symbol evaluated at edges/nodes, to a discretised symbol\n        evaluated at nodes/edges.\n        For now we just take the arithemtic mean, though it may be better to take the\n        harmonic mean based on [1].\n\n        [1] Recktenwald, Gerald. \"The control-volume finite-difference approximation to\n        the diffusion equation.\" (2012).\n\n        Parameters\n        ----------\n        discretised_symbol : :class:`pybamm.Symbol`\n            Symbol to be averaged. When evaluated, this symbol returns either a scalar\n            or an array of shape (n,) or (n+1,), where n is the number of points in the\n            mesh for the symbol's domain (n = self.mesh[symbol.domain].npts)\n        shift_key : str\n            Whether to shift from nodes to edges (\"node to edge\"), or from edges to\n            nodes (\"edge to node\")\n\n        Returns\n        -------\n        :class:`pybamm.Symbol`\n            Averaged symbol. When evaluated, this returns either a scalar or an array of\n            shape (n+1,) (if `shift_key = \"node to edge\"`) or (n,) (if\n            `shift_key = \"edge to node\"`)\n        \"\"\"\n\n        def arithmetic_mean(array):\n            \"\"\"Calculate the arithmetic mean of an array using matrix multiplication\"\"\"\n            # Create appropriate submesh by combining submeshes in domain\n            submesh_list = self.mesh.combine_submeshes(*array.domain)\n\n            # Can just use 1st entry of list to obtain the point etc\n            submesh = submesh_list[0]\n\n            # Create 1D matrix using submesh\n            n = submesh.npts\n\n            if shift_key == \"node to edge\":\n                sub_matrix_left = csr_matrix(\n                    ([1.5, -0.5], ([0, 0], [0, 1])), shape=(1, n)\n                )\n                sub_matrix_center = diags([0.5, 0.5], [0, 1], shape=(n - 1, n))\n                sub_matrix_right = csr_matrix(\n                    ([-0.5, 1.5], ([0, 0], [n - 2, n - 1])), shape=(1, n)\n                )\n                sub_matrix = vstack(\n                    [sub_matrix_left, sub_matrix_center, sub_matrix_right]\n                )\n            elif shift_key == \"edge to node\":\n                sub_matrix = diags([0.5, 0.5], [0, 1], shape=(n, n + 1))\n            else:\n                raise ValueError(\"shift key '{}' not recognised\".format(shift_key))\n            # Second dimension length\n            second_dim_len = len(submesh_list)\n\n            # Generate full matrix from the submatrix\n            # Convert to csr_matrix so that we can take the index (row-slicing), which\n            # is not supported by the default kron format\n            # Note that this makes column-slicing inefficient, but this should not be an\n            # issue\n            matrix = csr_matrix(kron(eye(second_dim_len), sub_matrix))\n\n            return pybamm.Matrix(matrix) @ array\n\n        # If discretised_symbol evaluates to number there is no need to average\n        if discretised_symbol.evaluates_to_number():\n            out = discretised_symbol\n        else:\n            out = arithmetic_mean(discretised_symbol)\n\n        return out",
  "def __init__(self, mesh):\n        super().__init__(mesh)\n        # add npts_for_broadcast to mesh domains for this particular discretisation\n        for dom in mesh.keys():\n            for i in range(len(mesh[dom])):\n                mesh[dom][i].npts_for_broadcast = mesh[dom][i].npts",
  "def spatial_variable(self, symbol):\n        \"\"\"\n        Creates a discretised spatial variable compatible with\n        the FiniteVolume method.\n\n        Parameters\n        -----------\n        symbol : :class:`pybamm.SpatialVariable`\n            The spatial variable to be discretised.\n\n        Returns\n        -------\n        :class:`pybamm.Vector`\n            Contains the discretised spatial variable\n        \"\"\"\n        # for finite volume we use the cell centres\n        symbol_mesh = self.mesh.combine_submeshes(*symbol.domain)\n        return pybamm.Vector(symbol_mesh[0].nodes, domain=symbol.domain)",
  "def gradient(self, symbol, discretised_symbol, boundary_conditions):\n        \"\"\"Matrix-vector multiplication to implement the gradient operator.\n        See :meth:`pybamm.SpatialMethod.gradient`\n        \"\"\"\n        # Discretise symbol\n        domain = symbol.domain\n\n        # Add boundary conditions, if defined\n        if symbol.id in boundary_conditions:\n            bcs = boundary_conditions[symbol.id]\n            # add ghost nodes\n            discretised_symbol = self.add_ghost_nodes(symbol, discretised_symbol, bcs)\n            # edit domain\n            domain = (\n                [domain[0] + \"_left ghost cell\"]\n                + domain\n                + [domain[-1] + \"_right ghost cell\"]\n            )\n\n        # note in 1D spherical grad and normal grad are the same\n        gradient_matrix = self.gradient_matrix(domain)\n\n        out = gradient_matrix @ discretised_symbol\n        return out",
  "def gradient_matrix(self, domain):\n        \"\"\"\n        Gradient matrix for finite volumes in the appropriate domain.\n        Equivalent to grad(y) = (y[1:] - y[:-1])/dx\n\n        Parameters\n        ----------\n        domain : list\n            The domain(s) in which to compute the gradient matrix\n\n        Returns\n        -------\n        :class:`pybamm.Matrix`\n            The (sparse) finite volume gradient matrix for the domain\n        \"\"\"\n        # Create appropriate submesh by combining submeshes in domain\n        submesh_list = self.mesh.combine_submeshes(*domain)\n\n        # can just use 1st entry of list to obtain the point etc\n        submesh = submesh_list[0]\n\n        # Create 1D matrix using submesh\n        n = submesh.npts\n        e = 1 / submesh.d_nodes\n        sub_matrix = diags([-e, e], [0, 1], shape=(n - 1, n))\n\n        # second dim length\n        second_dim_len = len(submesh_list)\n\n        # generate full matrix from the submatrix\n        # Convert to csr_matrix so that we can take the index (row-slicing), which is\n        # not supported by the default kron format\n        # Note that this makes column-slicing inefficient, but this should not be an\n        # issue\n        matrix = csr_matrix(kron(eye(second_dim_len), sub_matrix))\n\n        return pybamm.Matrix(matrix)",
  "def divergence(self, symbol, discretised_symbol, boundary_conditions):\n        \"\"\"Matrix-vector multiplication to implement the divergence operator.\n        See :meth:`pybamm.SpatialMethod.divergence`\n        \"\"\"\n        domain = symbol.domain\n        submesh_list = self.mesh.combine_submeshes(*domain)\n\n        divergence_matrix = self.divergence_matrix(domain)\n\n        # check for particle domain\n        if submesh_list[0].coord_sys == \"spherical polar\":\n            second_dim = len(submesh_list)\n            edges = submesh_list[0].edges\n\n            # create np.array of repeated submesh[0].nodes\n            r_numpy = np.kron(np.ones(second_dim), submesh_list[0].nodes)\n            r_edges_numpy = np.kron(np.ones(second_dim), edges)\n\n            r = pybamm.Vector(r_numpy)\n            r_edges = pybamm.Vector(r_edges_numpy)\n\n            out = (1 / (r ** 2)) * (\n                divergence_matrix @ ((r_edges ** 2) * discretised_symbol)\n            )\n        else:\n            out = divergence_matrix @ discretised_symbol\n\n        return out",
  "def divergence_matrix(self, domain):\n        \"\"\"\n        Divergence matrix for finite volumes in the appropriate domain.\n        Equivalent to div(N) = (N[1:] - N[:-1])/dx\n\n        Parameters\n        ----------\n        domain : list\n            The domain(s) in which to compute the divergence matrix\n\n        Returns\n        -------\n        :class:`pybamm.Matrix`\n            The (sparse) finite volume divergence matrix for the domain\n        \"\"\"\n        # Create appropriate submesh by combining submeshes in domain\n        submesh_list = self.mesh.combine_submeshes(*domain)\n\n        # can just use 1st entry of list to obtain the point etc\n        submesh = submesh_list[0]\n        e = 1 / submesh.d_edges\n\n        # Create matrix using submesh\n        n = submesh.npts + 1\n        sub_matrix = diags([-e, e], [0, 1], shape=(n - 1, n))\n\n        # repeat matrix for each node in secondary dimensions\n        second_dim_len = len(submesh_list)\n        # generate full matrix from the submatrix\n        # Convert to csr_matrix so that we can take the index (row-slicing), which is\n        # not supported by the default kron format\n        # Note that this makes column-slicing inefficient, but this should not be an\n        # issue\n        matrix = csr_matrix(kron(eye(second_dim_len), sub_matrix))\n        return pybamm.Matrix(matrix)",
  "def laplacian(self, symbol, discretised_symbol, boundary_conditions):\n        \"\"\"\n        Laplacian operator, implemented as div(grad(.))\n        See :meth:`pybamm.SpatialMethod.laplacian`\n        \"\"\"\n        grad = self.gradient(symbol, discretised_symbol, boundary_conditions)\n        return self.divergence(grad, grad, boundary_conditions)",
  "def integral(self, child, discretised_child):\n        \"\"\"Vector-vector dot product to implement the integral operator. \"\"\"\n        # Calculate integration vector\n        integration_vector = self.definite_integral_matrix(child.domain)\n\n        # Check for spherical domains\n        submesh_list = self.mesh.combine_submeshes(*child.domain)\n        if submesh_list[0].coord_sys == \"spherical polar\":\n            second_dim = len(submesh_list)\n            r_numpy = np.kron(np.ones(second_dim), submesh_list[0].nodes)\n            r = pybamm.Vector(r_numpy)\n            out = 4 * np.pi ** 2 * integration_vector @ (discretised_child * r)\n        else:\n            out = integration_vector @ discretised_child\n\n        return out",
  "def definite_integral_matrix(self, domain, vector_type=\"row\"):\n        \"\"\"\n        Matrix for finite-volume implementation of the definite integral in the\n        primary dimension\n\n        .. math::\n            I = \\\\int_{a}^{b}\\\\!f(s)\\\\,ds\n\n        for where :math:`a` and :math:`b` are the left-hand and right-hand boundaries of\n        the domain respectively\n\n        Parameters\n        ----------\n        domain : list\n            The domain(s) of integration\n\n        Returns\n        -------\n        :class:`pybamm.Matrix`\n            The finite volume integral matrix for the domain\n        vector_type : str, optional\n            Whether to return a row or column vector in the primary dimension\n            (default is row)\n        \"\"\"\n        # Create appropriate submesh by combining submeshes in domain\n        submesh_list = self.mesh.combine_submeshes(*domain)\n\n        # Create vector of ones for primary domain submesh\n        submesh = submesh_list[0]\n        vector = submesh.d_edges * np.ones_like(submesh.nodes)\n\n        if vector_type == \"row\":\n            vector = vector[np.newaxis, :]\n        elif vector_type == \"column\":\n            vector = vector[:, np.newaxis]\n\n        # repeat matrix for each node in secondary dimensions\n        second_dim_len = len(submesh_list)\n        # generate full matrix from the submatrix\n        # Convert to csr_matrix so that we can take the index (row-slicing), which is\n        # not supported by the default kron format\n        # Note that this makes column-slicing inefficient, but this should not be an\n        # issue\n        matrix = csr_matrix(kron(eye(second_dim_len), vector))\n        return pybamm.Matrix(matrix)",
  "def indefinite_integral(self, child, discretised_child):\n        \"\"\"Implementation of the indefinite integral operator. \"\"\"\n\n        # Different integral matrix depending on whether the integrand evaluates on\n        # edges or nodes\n        if child.evaluates_on_edges():\n            integration_matrix = self.indefinite_integral_matrix_edges(child.domain)\n        else:\n            integration_matrix = self.indefinite_integral_matrix_nodes(child.domain)\n\n        # Don't need to check for spherical domains as spherical polars\n        # only change the diveregence (childs here have grad and no div)\n        out = integration_matrix @ discretised_child\n\n        out.domain = child.domain\n        out.auxiliary_domains = child.auxiliary_domains\n\n        return out",
  "def indefinite_integral_matrix_edges(self, domain):\n        \"\"\"\n        Matrix for finite-volume implementation of the indefinite integral where the\n        integrand is evaluated on mesh edges\n\n        .. math::\n            F(x) = \\\\int_0^x\\\\!f(u)\\\\,du\n\n        The indefinite integral must satisfy the following conditions:\n\n        - :math:`F(0) = 0`\n        - :math:`f(x) = \\\\frac{dF}{dx}`\n\n        or, in discrete form,\n\n        - `BoundaryValue(F, \"left\") = 0`, i.e. :math:`3*F_0 - F_1 = 0`\n        - :math:`f_{i+1/2} = (F_{i+1} - F_i) / dx_{i+1/2}`\n\n        Hence we must have\n\n        - :math:`F_0 = du_{1/2} * f_{1/2} / 2`\n        - :math:`F_{i+1} = F_i + du * f_{i+1/2}`\n\n        Note that :math:`f_{-1/2}` and :math:`f_{n+1/2}` are included in the discrete\n        integrand vector `f`, so we add a column of zeros at each end of the\n        indefinite integral matrix to ignore these.\n\n        Parameters\n        ----------\n        domain : list\n            The domain(s) of integration\n\n        Returns\n        -------\n        :class:`pybamm.Matrix`\n            The finite volume integral matrix for the domain\n        \"\"\"\n\n        # Create appropriate submesh by combining submeshes in domain\n        submesh_list = self.mesh.combine_submeshes(*domain)\n        submesh = submesh_list[0]\n        n = submesh.npts\n        sec_pts = len(submesh_list)\n\n        du_n = submesh.d_nodes\n        du_entries = [du_n] * (n - 1)\n        offset = -np.arange(1, n, 1)\n        main_integral_matrix = diags(du_entries, offset, shape=(n, n - 1))\n        bc_offset_matrix = lil_matrix((n, n - 1))\n        bc_offset_matrix[:, 0] = du_n[0] / 2\n        sub_matrix = main_integral_matrix + bc_offset_matrix\n        # add a column of zeros at each end\n        zero_col = csr_matrix((n, 1))\n        sub_matrix = hstack([zero_col, sub_matrix, zero_col])\n        # Convert to csr_matrix so that we can take the index (row-slicing), which is\n        # not supported by the default kron format\n        # Note that this makes column-slicing inefficient, but this should not be an\n        # issue\n        matrix = csr_matrix(kron(eye(sec_pts), sub_matrix))\n\n        return pybamm.Matrix(matrix)",
  "def delta_function(self, symbol, discretised_symbol):\n        \"\"\"\n        Delta function. Implemented as a vector whose only non-zero element is the\n        first (if symbol.side = \"left\") or last (if symbol.side = \"right\"), with\n        appropriate value so that the integral of the delta function across the whole\n        domain is the same as the integral of the discretised symbol across the whole\n        domain.\n\n        See :meth:`pybamm.SpatialMethod.delta_function`\n        \"\"\"\n        # Find the number of submeshes\n        submesh_list = self.mesh.combine_submeshes(*symbol.domain)\n\n        prim_pts = submesh_list[0].npts\n        sec_pts = len(submesh_list)\n\n        # Create submatrix to compute delta function as a flux\n        if symbol.side == \"left\":\n            dx = submesh_list[0].d_nodes[0]\n            sub_matrix = csr_matrix(([1], ([0], [0])), shape=(prim_pts, 1))\n        elif symbol.side == \"right\":\n            dx = submesh_list[0].d_nodes[-1]\n            sub_matrix = csr_matrix(([1], ([prim_pts - 1], [0])), shape=(prim_pts, 1))\n\n        # Calculate domain width, to make sure that the integral of the delta function\n        # is the same as the integral of the child\n        domain_width = submesh_list[0].edges[-1] - submesh_list[0].edges[0]\n        # Generate full matrix from the submatrix\n        # Convert to csr_matrix so that we can take the index (row-slicing), which is\n        # not supported by the default kron format\n        # Note that this makes column-slicing inefficient, but this should not be an\n        # issue\n        matrix = kron(eye(sec_pts), sub_matrix).toarray()\n\n        # Return delta function, keep domains\n        delta_fn = pybamm.Matrix(domain_width / dx * matrix) * discretised_symbol\n        delta_fn.domain = symbol.domain\n        delta_fn.auxiliary_domains = symbol.auxiliary_domains\n\n        return delta_fn",
  "def internal_neumann_condition(\n        self, left_symbol_disc, right_symbol_disc, left_mesh, right_mesh\n    ):\n        \"\"\"\n        A method to find the internal neumann conditions between two symbols\n        on adjacent subdomains.\n\n        Parameters\n        ----------\n        left_symbol_disc : :class:`pybamm.Symbol`\n            The discretised symbol on the left subdomain\n        right_symbol_disc : :class:`pybamm.Symbol`\n            The discretised symbol on the right subdomain\n        left_mesh : list\n            The mesh on the left subdomain\n        right_mesh : list\n            The mesh on the right subdomain\n        \"\"\"\n\n        left_npts = left_mesh[0].npts\n        right_npts = right_mesh[0].npts\n\n        sec_pts = len(left_mesh)\n\n        if sec_pts != len(right_mesh):\n            raise pybamm.DomainError(\n                \"\"\"Number of secondary points in subdomains do not match\"\"\"\n            )\n\n        left_sub_matrix = np.zeros((1, left_npts))\n        left_sub_matrix[0][left_npts - 1] = 1\n        left_matrix = pybamm.Matrix(csr_matrix(kron(eye(sec_pts), left_sub_matrix)))\n\n        right_sub_matrix = np.zeros((1, right_npts))\n        right_sub_matrix[0][0] = 1\n        right_matrix = pybamm.Matrix(csr_matrix(kron(eye(sec_pts), right_sub_matrix)))\n\n        # Remove domains to avoid clash\n        left_domain = left_symbol_disc.domain\n        right_domain = right_symbol_disc.domain\n        left_symbol_disc.domain = []\n        right_symbol_disc.domain = []\n\n        # Finite volume derivative\n        dy = right_matrix @ right_symbol_disc - left_matrix @ left_symbol_disc\n        dx = right_mesh[0].nodes[0] - left_mesh[0].nodes[-1]\n\n        # Change domains back\n        left_symbol_disc.domain = left_domain\n        right_symbol_disc.domain = right_domain\n\n        return dy / dx",
  "def indefinite_integral_matrix_nodes(self, domain):\n        \"\"\"\n        Matrix for finite-volume implementation of the indefinite integral where the\n        integrand is evaluated on mesh nodes.\n        This is just a straightforward cumulative sum of the integrand\n\n        Parameters\n        ----------\n        domain : list\n            The domain(s) of integration\n\n        Returns\n        -------\n        :class:`pybamm.Matrix`\n            The finite volume integral matrix for the domain\n        \"\"\"\n\n        # Create appropriate submesh by combining submeshes in domain\n        submesh_list = self.mesh.combine_submeshes(*domain)\n        submesh = submesh_list[0]\n        n = submesh.npts\n        sec_pts = len(submesh_list)\n\n        du_n = submesh.d_edges\n        du_entries = [du_n] * (n)\n        offset = -np.arange(1, n + 1, 1)\n        sub_matrix = diags(du_entries, offset, shape=(n + 1, n))\n        # Convert to csr_matrix so that we can take the index (row-slicing), which is\n        # not supported by the default kron format\n        # Note that this makes column-slicing inefficient, but this should not be an\n        # issue\n        matrix = csr_matrix(kron(eye(sec_pts), sub_matrix))\n\n        return pybamm.Matrix(matrix)",
  "def add_ghost_nodes(self, symbol, discretised_symbol, bcs):\n        \"\"\"\n        Add ghost nodes to a symbol.\n\n        For Dirichlet bcs, for a boundary condition \"y = a at the left-hand boundary\",\n        we concatenate a ghost node to the start of the vector y with value \"2*a - y1\"\n        where y1 is the value of the first node.\n        Similarly for the right-hand boundary condition.\n\n        For Dirichlet bcs, for a boundary condition \"y = a at the left-hand boundary\",\n        we concatenate a ghost node to the start of the vector y with value \"2*a - y1\"\n        where y1 is the value of the first node.\n        Similarly for the right-hand boundary condition.\n\n        For Neumann bcs, for a boundary condition \"dy/dx = b at the left-hand boundary\",\n        we concatenate a ghost node to the start of the vector y with value \"b*h + y1\"\n        where y1 is the value of the first node and h is the mesh size.\n        Similarly for the right-hand boundary condition.\n\n        Parameters\n        ----------\n        domain : list of strings\n            The domain of the symbol for which to add ghost nodes\n        bcs : dict of tuples (:class:`pybamm.Scalar`, str)\n            Dictionary (with keys \"left\" and \"right\") of boundary conditions. Each\n            boundary condition consists of a value and a flag indicating its type\n            (e.g. \"Dirichlet\")\n\n        Returns\n        -------\n        :class:`pybamm.Symbol` (shape (n+2, n))\n            `Matrix @ discretised_symbol + bcs_vector`. When evaluated, this gives the\n            discretised_symbol, with appropriate ghost nodes concatenated at each end.\n\n        \"\"\"\n        # get relevant grid points\n        submesh_list = self.mesh.combine_submeshes(*symbol.domain)\n\n        # Prepare sizes and empty bcs_vector\n        n = submesh_list[0].npts\n        sec_pts = len(submesh_list)\n\n        bcs_vector = pybamm.Vector(np.array([]))  # starts empty\n\n        lbc_value, lbc_type = bcs[\"left\"]\n        rbc_value, rbc_type = bcs[\"right\"]\n\n        for i in range(sec_pts):\n            if lbc_value.evaluates_to_number():\n                lbc_i = lbc_value\n            else:\n                lbc_i = lbc_value[i]\n            if rbc_value.evaluates_to_number():\n                rbc_i = rbc_value\n            else:\n                rbc_i = rbc_value[i]\n            if lbc_type == \"Dirichlet\":\n                left_ghost_constant = 2 * lbc_i\n            elif lbc_type == \"Neumann\":\n                dx = 2 * (submesh_list[0].nodes[0] - submesh_list[0].edges[0])\n                left_ghost_constant = -dx * lbc_i\n            else:\n                raise ValueError(\n                    \"boundary condition must be Dirichlet or Neumann, not '{}'\".format(\n                        lbc_type\n                    )\n                )\n            if rbc_type == \"Dirichlet\":\n                right_ghost_constant = 2 * rbc_i\n            elif rbc_type == \"Neumann\":\n                dx = 2 * (submesh_list[0].edges[-1] - submesh_list[0].nodes[-1])\n                right_ghost_constant = dx * rbc_i\n            else:\n                raise ValueError(\n                    \"boundary condition must be Dirichlet or Neumann, not '{}'\".format(\n                        rbc_type\n                    )\n                )\n            # concatenate\n            bcs_vector = pybamm.NumpyConcatenation(\n                bcs_vector,\n                left_ghost_constant,\n                pybamm.Vector(np.zeros(n)),\n                right_ghost_constant,\n            )\n\n        # Make matrix to calculate ghost nodes\n        bc_factors = {\"Dirichlet\": -1, \"Neumann\": 1}\n        left_factor = bc_factors[lbc_type]\n        right_factor = bc_factors[rbc_type]\n        # coo_matrix takes inputs (data, (row, col)) and puts data[i] at the point\n        # (row[i], col[i]) for each index of data.\n        left_ghost_vector = coo_matrix(([left_factor], ([0], [0])), shape=(1, n))\n        right_ghost_vector = coo_matrix(([right_factor], ([0], [n - 1])), shape=(1, n))\n        sub_matrix = vstack([left_ghost_vector, eye(n), right_ghost_vector])\n\n        # repeat matrix for secondary dimensions\n        # Convert to csr_matrix so that we can take the index (row-slicing), which is\n        # not supported by the default kron format\n        # Note that this makes column-slicing inefficient, but this should not be an\n        # issue\n        matrix = csr_matrix(kron(eye(sec_pts), sub_matrix))\n\n        return pybamm.Matrix(matrix) @ discretised_symbol + bcs_vector",
  "def boundary_value_or_flux(self, symbol, discretised_child):\n        \"\"\"\n        Uses linear extrapolation to get the boundary value or flux of a variable in the\n        Finite Volume Method.\n\n        See :meth:`pybamm.SpatialMethod.boundary_value`\n        \"\"\"\n\n        # Find the number of submeshes\n        submesh_list = self.mesh.combine_submeshes(*discretised_child.domain)\n\n        prim_pts = submesh_list[0].npts\n        sec_pts = len(submesh_list)\n\n        # Create submatrix to compute boundary values or fluxes\n        if isinstance(symbol, pybamm.BoundaryValue):\n            if symbol.side == \"left\":\n                sub_matrix = csr_matrix(\n                    ([1.5, -0.5], ([0, 0], [0, 1])), shape=(1, prim_pts)\n                )\n            elif symbol.side == \"right\":\n                sub_matrix = csr_matrix(\n                    ([-0.5, 1.5], ([0, 0], [prim_pts - 2, prim_pts - 1])),\n                    shape=(1, prim_pts),\n                )\n        elif isinstance(symbol, pybamm.BoundaryGradient):\n            if symbol.side == \"left\":\n                dx = submesh_list[0].d_nodes[0]\n                sub_matrix = (1 / dx) * csr_matrix(\n                    ([-1, 1], ([0, 0], [0, 1])), shape=(1, prim_pts)\n                )\n            elif symbol.side == \"right\":\n                dx = submesh_list[0].d_nodes[-1]\n                sub_matrix = (1 / dx) * csr_matrix(\n                    ([-1, 1], ([0, 0], [prim_pts - 2, prim_pts - 1])),\n                    shape=(1, prim_pts),\n                )\n\n        # Generate full matrix from the submatrix\n        # Convert to csr_matrix so that we can take the index (row-slicing), which is\n        # not supported by the default kron format\n        # Note that this makes column-slicing inefficient, but this should not be an\n        # issue\n        matrix = csr_matrix(kron(eye(sec_pts), sub_matrix))\n\n        # Return boundary value with domain given by symbol\n        boundary_value = pybamm.Matrix(matrix) @ discretised_child\n        boundary_value.domain = symbol.domain\n        boundary_value.auxiliary_domains = symbol.auxiliary_domains\n\n        return boundary_value",
  "def process_binary_operators(self, bin_op, left, right, disc_left, disc_right):\n        \"\"\"Discretise binary operators in model equations.  Performs appropriate\n        averaging of diffusivities if one of the children is a gradient operator, so\n        that discretised sizes match up.\n\n        Parameters\n        ----------\n        bin_op : :class:`pybamm.BinaryOperator`\n            Binary operator to discretise\n        left : :class:`pybamm.Symbol`\n            The left child of `bin_op`\n        right : :class:`pybamm.Symbol`\n            The right child of `bin_op`\n        disc_left : :class:`pybamm.Symbol`\n            The discretised left child of `bin_op`\n        disc_right : :class:`pybamm.Symbol`\n            The discretised right child of `bin_op`\n        Returns\n        -------\n        :class:`pybamm.BinaryOperator`\n            Discretised binary operator\n\n        \"\"\"\n        # Post-processing to make sure discretised dimensions match\n        left_evaluates_on_edges = left.evaluates_on_edges()\n        right_evaluates_on_edges = right.evaluates_on_edges()\n\n        # inner product takes fluxes from edges to nodes\n        if isinstance(bin_op, pybamm.Inner):\n            if left_evaluates_on_edges:\n                disc_left = self.edge_to_node(disc_left)\n            if right_evaluates_on_edges:\n                disc_right = self.edge_to_node(disc_right)\n\n        # If neither child evaluates on edges, or both children have gradients,\n        # no need to do any averaging\n        elif left_evaluates_on_edges == right_evaluates_on_edges:\n            pass\n        # If only left child evaluates on edges, map right child onto edges\n        elif left_evaluates_on_edges and not right_evaluates_on_edges:\n            disc_right = self.node_to_edge(disc_right)\n        # If only right child evaluates on edges, map left child onto edges\n        elif right_evaluates_on_edges and not left_evaluates_on_edges:\n            disc_left = self.node_to_edge(disc_left)\n        # Return new binary operator with appropriate class\n        out = bin_op.__class__(disc_left, disc_right)\n        return out",
  "def concatenation(self, disc_children):\n        \"\"\"Discrete concatenation, taking `edge_to_node` for children that evaluate on\n        edges.\n        See :meth:`pybamm.SpatialMethod.concatenation`\n        \"\"\"\n        for idx, child in enumerate(disc_children):\n            n_nodes = sum(\n                len(mesh.nodes) for mesh in self.mesh.combine_submeshes(*child.domain)\n            )\n            n_edges = sum(\n                len(mesh.edges) for mesh in self.mesh.combine_submeshes(*child.domain)\n            )\n            child_size = child.size\n            if child_size != n_nodes:\n                # Average any children that evaluate on the edges (size n_edges) to\n                # evaluate on nodes instead, so that concatenation works properly\n                if child_size == n_edges:\n                    disc_children[idx] = self.edge_to_node(child)\n                else:\n                    raise pybamm.ShapeError(\n                        \"\"\"\n                        child must have size n_nodes (number of nodes in the mesh)\n                        or n_edges (number of edges in the mesh)\n                        \"\"\"\n                    )\n        return pybamm.DomainConcatenation(disc_children, self.mesh)",
  "def edge_to_node(self, discretised_symbol):\n        \"\"\"\n        Convert a discretised symbol evaluated on the cell edges to a discretised symbol\n        evaluated on the cell nodes.\n        See :meth:`pybamm.FiniteVolume.shift`\n        \"\"\"\n        return self.shift(discretised_symbol, \"edge to node\")",
  "def node_to_edge(self, discretised_symbol):\n        \"\"\"\n        Convert a discretised symbol evaluated on the cell nodes to a discretised symbol\n        evaluated on the cell edges.\n        See :meth:`pybamm.FiniteVolume.shift`\n        \"\"\"\n        return self.shift(discretised_symbol, \"node to edge\")",
  "def shift(self, discretised_symbol, shift_key):\n        \"\"\"\n        Convert a discretised symbol evaluated at edges/nodes, to a discretised symbol\n        evaluated at nodes/edges.\n        For now we just take the arithemtic mean, though it may be better to take the\n        harmonic mean based on [1].\n\n        [1] Recktenwald, Gerald. \"The control-volume finite-difference approximation to\n        the diffusion equation.\" (2012).\n\n        Parameters\n        ----------\n        discretised_symbol : :class:`pybamm.Symbol`\n            Symbol to be averaged. When evaluated, this symbol returns either a scalar\n            or an array of shape (n,) or (n+1,), where n is the number of points in the\n            mesh for the symbol's domain (n = self.mesh[symbol.domain].npts)\n        shift_key : str\n            Whether to shift from nodes to edges (\"node to edge\"), or from edges to\n            nodes (\"edge to node\")\n\n        Returns\n        -------\n        :class:`pybamm.Symbol`\n            Averaged symbol. When evaluated, this returns either a scalar or an array of\n            shape (n+1,) (if `shift_key = \"node to edge\"`) or (n,) (if\n            `shift_key = \"edge to node\"`)\n        \"\"\"\n\n        def arithmetic_mean(array):\n            \"\"\"Calculate the arithmetic mean of an array using matrix multiplication\"\"\"\n            # Create appropriate submesh by combining submeshes in domain\n            submesh_list = self.mesh.combine_submeshes(*array.domain)\n\n            # Can just use 1st entry of list to obtain the point etc\n            submesh = submesh_list[0]\n\n            # Create 1D matrix using submesh\n            n = submesh.npts\n\n            if shift_key == \"node to edge\":\n                sub_matrix_left = csr_matrix(\n                    ([1.5, -0.5], ([0, 0], [0, 1])), shape=(1, n)\n                )\n                sub_matrix_center = diags([0.5, 0.5], [0, 1], shape=(n - 1, n))\n                sub_matrix_right = csr_matrix(\n                    ([-0.5, 1.5], ([0, 0], [n - 2, n - 1])), shape=(1, n)\n                )\n                sub_matrix = vstack(\n                    [sub_matrix_left, sub_matrix_center, sub_matrix_right]\n                )\n            elif shift_key == \"edge to node\":\n                sub_matrix = diags([0.5, 0.5], [0, 1], shape=(n, n + 1))\n            else:\n                raise ValueError(\"shift key '{}' not recognised\".format(shift_key))\n            # Second dimension length\n            second_dim_len = len(submesh_list)\n\n            # Generate full matrix from the submatrix\n            # Convert to csr_matrix so that we can take the index (row-slicing), which\n            # is not supported by the default kron format\n            # Note that this makes column-slicing inefficient, but this should not be an\n            # issue\n            matrix = csr_matrix(kron(eye(second_dim_len), sub_matrix))\n\n            return pybamm.Matrix(matrix) @ array\n\n        # If discretised_symbol evaluates to number there is no need to average\n        if discretised_symbol.evaluates_to_number():\n            out = discretised_symbol\n        else:\n            out = arithmetic_mean(discretised_symbol)\n\n        return out",
  "def arithmetic_mean(array):\n            \"\"\"Calculate the arithmetic mean of an array using matrix multiplication\"\"\"\n            # Create appropriate submesh by combining submeshes in domain\n            submesh_list = self.mesh.combine_submeshes(*array.domain)\n\n            # Can just use 1st entry of list to obtain the point etc\n            submesh = submesh_list[0]\n\n            # Create 1D matrix using submesh\n            n = submesh.npts\n\n            if shift_key == \"node to edge\":\n                sub_matrix_left = csr_matrix(\n                    ([1.5, -0.5], ([0, 0], [0, 1])), shape=(1, n)\n                )\n                sub_matrix_center = diags([0.5, 0.5], [0, 1], shape=(n - 1, n))\n                sub_matrix_right = csr_matrix(\n                    ([-0.5, 1.5], ([0, 0], [n - 2, n - 1])), shape=(1, n)\n                )\n                sub_matrix = vstack(\n                    [sub_matrix_left, sub_matrix_center, sub_matrix_right]\n                )\n            elif shift_key == \"edge to node\":\n                sub_matrix = diags([0.5, 0.5], [0, 1], shape=(n, n + 1))\n            else:\n                raise ValueError(\"shift key '{}' not recognised\".format(shift_key))\n            # Second dimension length\n            second_dim_len = len(submesh_list)\n\n            # Generate full matrix from the submatrix\n            # Convert to csr_matrix so that we can take the index (row-slicing), which\n            # is not supported by the default kron format\n            # Note that this makes column-slicing inefficient, but this should not be an\n            # issue\n            matrix = csr_matrix(kron(eye(second_dim_len), sub_matrix))\n\n            return pybamm.Matrix(matrix) @ array",
  "class SpatialMethod:\n    \"\"\"\n    A general spatial methods class, with default (trivial) behaviour for some spatial\n    operations.\n    All spatial methods will follow the general form of SpatialMethod in\n    that they contain a method for broadcasting variables onto a mesh,\n    a gradient operator, and a diverence operator.\n\n    Parameters\n    ----------\n    mesh : :class: `pybamm.Mesh`\n        Contains all the submeshes for discretisation\n    \"\"\"\n\n    def __init__(self, mesh):\n        # add npts_for_broadcast to mesh domains for this particular discretisation\n        for dom in mesh.keys():\n            for i in range(len(mesh[dom])):\n                mesh[dom][i].npts_for_broadcast = mesh[dom][i].npts\n        self._mesh = mesh\n\n    @property\n    def mesh(self):\n        return self._mesh\n\n    def spatial_variable(self, symbol):\n        \"\"\"\n        Convert a :class:`pybamm.SpatialVariable` node to a linear algebra object that\n        can be evaluated (here, a :class:`pybamm.Vector` on either the nodes or the\n        edges).\n\n        Parameters\n        -----------\n        symbol : :class:`pybamm.SpatialVariable`\n            The spatial variable to be discretised.\n\n        Returns\n        -------\n        :class:`pybamm.Vector`\n            Contains the discretised spatial variable\n        \"\"\"\n        symbol_mesh = self.mesh.combine_submeshes(*symbol.domain)\n        if symbol.name.endswith(\"_edge\"):\n            return pybamm.Vector(symbol_mesh[0].edges, domain=symbol.domain)\n        else:\n            return pybamm.Vector(symbol_mesh[0].nodes, domain=symbol.domain)\n\n    def broadcast(self, symbol, domain, auxiliary_domains, broadcast_type):\n        \"\"\"\n        Broadcast symbol to a specified domain.\n\n        Parameters\n        ----------\n        symbol : :class:`pybamm.Symbol`\n            The symbol to be broadcasted\n        domain : iterable of strings\n            The domain to broadcast to\n        broadcast_type : str\n            The type of broadcast, either: 'primary' or 'full'\n\n        Returns\n        -------\n        broadcasted_symbol: class: `pybamm.Symbol`\n            The discretised symbol of the correct size for the spatial method\n        \"\"\"\n\n        primary_pts_for_broadcast = sum(\n            self.mesh[dom][0].npts_for_broadcast for dom in domain\n        )\n\n        full_pts_for_broadcast = sum(\n            subdom.npts_for_broadcast for dom in domain for subdom in self.mesh[dom]\n        )\n\n        if broadcast_type == \"primary\":\n            out = pybamm.Outer(\n                symbol, pybamm.Vector(np.ones(primary_pts_for_broadcast), domain=domain)\n            )\n\n        elif broadcast_type == \"full\":\n            out = symbol * pybamm.Vector(np.ones(full_pts_for_broadcast), domain=domain)\n\n        out.auxiliary_domains = auxiliary_domains\n        return out\n\n    def gradient(self, symbol, discretised_symbol, boundary_conditions):\n        \"\"\"\n        Implements the gradient for a spatial method.\n\n        Parameters\n        ----------\n        symbol: :class:`pybamm.Symbol`\n            The symbol that we will take the gradient of.\n        discretised_symbol: :class:`pybamm.Symbol`\n            The discretised symbol of the correct size\n\n        boundary_conditions : dict\n            The boundary conditions of the model\n            ({symbol.id: {\"left\": left bc, \"right\": right bc}})\n\n        Returns\n        -------\n        :class: `pybamm.Array`\n            Contains the result of acting the discretised gradient on\n            the child discretised_symbol\n        \"\"\"\n        raise NotImplementedError\n\n    def divergence(self, symbol, discretised_symbol, boundary_conditions):\n        \"\"\"\n        Implements the divergence for a spatial method.\n\n        Parameters\n        ----------\n        symbol: :class:`pybamm.Symbol`\n            The symbol that we will take the gradient of.\n        discretised_symbol: :class:`pybamm.Symbol`\n            The discretised symbol of the correct size\n        boundary_conditions : dict\n            The boundary conditions of the model\n            ({symbol.id: {\"left\": left bc, \"right\": right bc}})\n\n        Returns\n        -------\n        :class: `pybamm.Array`\n            Contains the result of acting the discretised divergence on\n            the child discretised_symbol\n        \"\"\"\n        raise NotImplementedError\n\n    def laplacian(self, symbol, discretised_symbol, boundary_conditions):\n        \"\"\"\n        Implements the laplacian for a spatial method.\n\n        Parameters\n        ----------\n        symbol: :class:`pybamm.Symbol`\n            The symbol that we will take the gradient of.\n        discretised_symbol: :class:`pybamm.Symbol`\n            The discretised symbol of the correct size\n        boundary_conditions : dict\n            The boundary conditions of the model\n            ({symbol.id: {\"left\": left bc, \"right\": right bc}})\n\n        Returns\n        -------\n        :class: `pybamm.Array`\n            Contains the result of acting the discretised laplacian on\n            the child discretised_symbol\n        \"\"\"\n        raise NotImplementedError\n\n    def gradient_squared(self, symbol, discretised_symbol, boundary_conditions):\n        \"\"\"\n        Implements the inner product of the gradient with itself for a spatial method.\n\n        Parameters\n        ----------\n        symbol: :class:`pybamm.Symbol`\n            The symbol that we will take the gradient of.\n        discretised_symbol: :class:`pybamm.Symbol`\n            The discretised symbol of the correct size\n\n        boundary_conditions : dict\n            The boundary conditions of the model\n            ({symbol.id: {\"left\": left bc, \"right\": right bc}})\n\n        Returns\n        -------\n        :class: `pybamm.Array`\n            Contains the result of taking the inner product of the result of acting\n            the discretised gradient on the child discretised_symbol with itself\n        \"\"\"\n        raise NotImplementedError\n\n    def integral(self, child, discretised_child):\n        \"\"\"\n        Implements the integral for a spatial method.\n\n        Parameters\n        ----------\n        child: :class:`pybamm.Symbol`\n            The symbol to which is being integrated\n        discretised_child: :class:`pybamm.Symbol`\n            The discretised symbol of the correct size\n\n        Returns\n        -------\n        :class: `pybamm.Array`\n            Contains the result of acting the discretised integral on\n            the child discretised_symbol\n        \"\"\"\n        raise NotImplementedError\n\n    def indefinite_integral(self, child, discretised_child):\n        \"\"\"\n        Implements the indefinite integral for a spatial method.\n\n        Parameters\n        ----------\n        child: :class:`pybamm.Symbol`\n            The symbol to which is being integrated\n        discretised_child: :class:`pybamm.Symbol`\n            The discretised symbol of the correct size\n\n        Returns\n        -------\n        :class: `pybamm.Array`\n            Contains the result of acting the discretised indefinite integral on\n            the child discretised_symbol\n        \"\"\"\n        raise NotImplementedError\n\n    def boundary_integral(self, child, discretised_child, region):\n        \"\"\"\n        Implements the boundary integral for a spatial method.\n\n        Parameters\n        ----------\n        child: :class:`pybamm.Symbol`\n            The symbol to which is being integrated\n        discretised_child: :class:`pybamm.Symbol`\n            The discretised symbol of the correct size\n        region: str\n            The region of the boundary over which to integrate. If region is None\n            (default) the integration is carried out over the entire boundary. If\n            region is `negative tab` or `positive tab` then the integration is only\n            carried out over the appropriate part of the boundary corresponding to\n            the tab.\n\n        Returns\n        -------\n        :class: `pybamm.Array`\n            Contains the result of acting the discretised boundary integral on\n            the child discretised_symbol\n        \"\"\"\n        raise NotImplementedError\n\n    def delta_function(self, symbol, discretised_symbol):\n        \"\"\"\n        Implements the delta function on the approriate side for a spatial method.\n\n        Parameters\n        ----------\n        symbol: :class:`pybamm.Symbol`\n            The symbol to which is being integrated\n        discretised_symbol: :class:`pybamm.Symbol`\n            The discretised symbol of the correct size\n        \"\"\"\n        raise NotImplementedError\n\n    def internal_neumann_condition(\n        self, left_symbol_disc, right_symbol_disc, left_mesh, right_mesh\n    ):\n        \"\"\"\n        A method to find the internal neumann conditions between two symbols\n        on adjacent subdomains.\n\n        Parameters\n        ----------\n        left_symbol_disc : :class:`pybamm.Symbol`\n            The discretised symbol on the left subdomain\n        right_symbol_disc : :class:`pybamm.Symbol`\n            The discretised symbol on the right subdomain\n        left_mesh : list\n            The mesh on the left subdomain\n        right_mesh : list\n            The mesh on the right subdomain\n        \"\"\"\n\n        raise NotImplementedError\n\n    def boundary_value_or_flux(self, symbol, discretised_child):\n        \"\"\"\n        Returns the boundary value or flux using the approriate expression for the\n        spatial method. To do this, we create a sparse vector 'bv_vector' that extracts\n        either the first (for side=\"left\") or last (for side=\"right\") point from\n        'discretised_child'.\n\n        Parameters\n        -----------\n        symbol: :class:`pybamm.Symbol`\n            The boundary value or flux symbol\n        discretised_child : :class:`pybamm.StateVector`\n            The discretised variable from which to calculate the boundary value\n\n        Returns\n        -------\n        :class:`pybamm.MatrixMultiplication`\n            The variable representing the surface value.\n        \"\"\"\n        if any(len(self.mesh[dom]) > 1 for dom in discretised_child.domain):\n            raise NotImplementedError(\"Cannot process 2D symbol in base spatial method\")\n        if isinstance(symbol, pybamm.BoundaryGradient):\n            raise TypeError(\"Cannot process BoundaryGradient in base spatial method\")\n        n = sum(self.mesh[dom][0].npts for dom in discretised_child.domain)\n        if symbol.side == \"left\":\n            # coo_matrix takes inputs (data, (row, col)) and puts data[i] at the point\n            # (row[i], col[i]) for each index of data. Here we just want a single point\n            # with value 1 at (0,0).\n            # Convert to a csr_matrix to allow indexing and other functionality\n            left_vector = csr_matrix(coo_matrix(([1], ([0], [0])), shape=(1, n)))\n            bv_vector = pybamm.Matrix(left_vector)\n        elif symbol.side == \"right\":\n            # as above, but now we want a single point with value 1 at (0, n-1)\n            right_vector = csr_matrix(coo_matrix(([1], ([0], [n - 1])), shape=(1, n)))\n            bv_vector = pybamm.Matrix(right_vector)\n\n        out = bv_vector @ discretised_child\n        # boundary value removes domain\n        out.domain = []\n        return out\n\n    def mass_matrix(self, symbol, boundary_conditions):\n        \"\"\"\n        Calculates the mass matrix for a spatial method.\n\n        Parameters\n        ----------\n        symbol: :class:`pybamm.Variable`\n            The variable corresponding to the equation for which we are\n            calculating the mass matrix.\n        boundary_conditions : dict\n            The boundary conditions of the model\n            ({symbol.id: {\"left\": left bc, \"right\": right bc}})\n\n        Returns\n        -------\n        :class:`pybamm.Matrix`\n            The (sparse) mass matrix for the spatial method.\n        \"\"\"\n        # NOTE: for different spatial methods the matrix may need to be adjusted\n        # to account for Dirichlet boundary conditions. Here, we just have the default\n        # behaviour that the mass matrix is the identity.\n\n        # Create appropriate submesh by combining submeshes in domain\n        submesh = self.mesh.combine_submeshes(*symbol.domain)\n\n        # Get number of points in primary dimension\n        n = submesh[0].npts\n\n        # Create mass matrix for primary dimension\n        prim_mass = eye(n)\n\n        # Get number of points in secondary dimension\n        sec_pts = len(submesh)\n\n        # Convert to csr_matrix as required by some solvers\n        mass = csr_matrix(kron(eye(sec_pts), prim_mass))\n        return pybamm.Matrix(mass)\n\n    def process_binary_operators(self, bin_op, left, right, disc_left, disc_right):\n        \"\"\"Discretise binary operators in model equations. Default behaviour is to\n        return a new binary operator with the discretised children.\n\n        Parameters\n        ----------\n        bin_op : :class:`pybamm.BinaryOperator`\n            Binary operator to discretise\n        left : :class:`pybamm.Symbol`\n            The left child of `bin_op`\n        right : :class:`pybamm.Symbol`\n            The right child of `bin_op`\n        disc_left : :class:`pybamm.Symbol`\n            The discretised left child of `bin_op`\n        disc_right : :class:`pybamm.Symbol`\n            The discretised right child of `bin_op`\n\n        Returns\n        -------\n        :class:`pybamm.BinaryOperator`\n            Discretised binary operator\n\n        \"\"\"\n        return bin_op.__class__(disc_left, disc_right)\n\n    def concatenation(self, disc_children):\n        \"\"\"Discrete concatenation object.\n\n        Parameters\n        ----------\n        disc_children : list\n            List of discretised children\n\n        Returns\n        -------\n        :class:`pybamm.DomainConcatenation`\n            Concatenation of the discretised children\n        \"\"\"\n        return pybamm.DomainConcatenation(disc_children, self.mesh)",
  "def __init__(self, mesh):\n        # add npts_for_broadcast to mesh domains for this particular discretisation\n        for dom in mesh.keys():\n            for i in range(len(mesh[dom])):\n                mesh[dom][i].npts_for_broadcast = mesh[dom][i].npts\n        self._mesh = mesh",
  "def mesh(self):\n        return self._mesh",
  "def spatial_variable(self, symbol):\n        \"\"\"\n        Convert a :class:`pybamm.SpatialVariable` node to a linear algebra object that\n        can be evaluated (here, a :class:`pybamm.Vector` on either the nodes or the\n        edges).\n\n        Parameters\n        -----------\n        symbol : :class:`pybamm.SpatialVariable`\n            The spatial variable to be discretised.\n\n        Returns\n        -------\n        :class:`pybamm.Vector`\n            Contains the discretised spatial variable\n        \"\"\"\n        symbol_mesh = self.mesh.combine_submeshes(*symbol.domain)\n        if symbol.name.endswith(\"_edge\"):\n            return pybamm.Vector(symbol_mesh[0].edges, domain=symbol.domain)\n        else:\n            return pybamm.Vector(symbol_mesh[0].nodes, domain=symbol.domain)",
  "def broadcast(self, symbol, domain, auxiliary_domains, broadcast_type):\n        \"\"\"\n        Broadcast symbol to a specified domain.\n\n        Parameters\n        ----------\n        symbol : :class:`pybamm.Symbol`\n            The symbol to be broadcasted\n        domain : iterable of strings\n            The domain to broadcast to\n        broadcast_type : str\n            The type of broadcast, either: 'primary' or 'full'\n\n        Returns\n        -------\n        broadcasted_symbol: class: `pybamm.Symbol`\n            The discretised symbol of the correct size for the spatial method\n        \"\"\"\n\n        primary_pts_for_broadcast = sum(\n            self.mesh[dom][0].npts_for_broadcast for dom in domain\n        )\n\n        full_pts_for_broadcast = sum(\n            subdom.npts_for_broadcast for dom in domain for subdom in self.mesh[dom]\n        )\n\n        if broadcast_type == \"primary\":\n            out = pybamm.Outer(\n                symbol, pybamm.Vector(np.ones(primary_pts_for_broadcast), domain=domain)\n            )\n\n        elif broadcast_type == \"full\":\n            out = symbol * pybamm.Vector(np.ones(full_pts_for_broadcast), domain=domain)\n\n        out.auxiliary_domains = auxiliary_domains\n        return out",
  "def gradient(self, symbol, discretised_symbol, boundary_conditions):\n        \"\"\"\n        Implements the gradient for a spatial method.\n\n        Parameters\n        ----------\n        symbol: :class:`pybamm.Symbol`\n            The symbol that we will take the gradient of.\n        discretised_symbol: :class:`pybamm.Symbol`\n            The discretised symbol of the correct size\n\n        boundary_conditions : dict\n            The boundary conditions of the model\n            ({symbol.id: {\"left\": left bc, \"right\": right bc}})\n\n        Returns\n        -------\n        :class: `pybamm.Array`\n            Contains the result of acting the discretised gradient on\n            the child discretised_symbol\n        \"\"\"\n        raise NotImplementedError",
  "def divergence(self, symbol, discretised_symbol, boundary_conditions):\n        \"\"\"\n        Implements the divergence for a spatial method.\n\n        Parameters\n        ----------\n        symbol: :class:`pybamm.Symbol`\n            The symbol that we will take the gradient of.\n        discretised_symbol: :class:`pybamm.Symbol`\n            The discretised symbol of the correct size\n        boundary_conditions : dict\n            The boundary conditions of the model\n            ({symbol.id: {\"left\": left bc, \"right\": right bc}})\n\n        Returns\n        -------\n        :class: `pybamm.Array`\n            Contains the result of acting the discretised divergence on\n            the child discretised_symbol\n        \"\"\"\n        raise NotImplementedError",
  "def laplacian(self, symbol, discretised_symbol, boundary_conditions):\n        \"\"\"\n        Implements the laplacian for a spatial method.\n\n        Parameters\n        ----------\n        symbol: :class:`pybamm.Symbol`\n            The symbol that we will take the gradient of.\n        discretised_symbol: :class:`pybamm.Symbol`\n            The discretised symbol of the correct size\n        boundary_conditions : dict\n            The boundary conditions of the model\n            ({symbol.id: {\"left\": left bc, \"right\": right bc}})\n\n        Returns\n        -------\n        :class: `pybamm.Array`\n            Contains the result of acting the discretised laplacian on\n            the child discretised_symbol\n        \"\"\"\n        raise NotImplementedError",
  "def gradient_squared(self, symbol, discretised_symbol, boundary_conditions):\n        \"\"\"\n        Implements the inner product of the gradient with itself for a spatial method.\n\n        Parameters\n        ----------\n        symbol: :class:`pybamm.Symbol`\n            The symbol that we will take the gradient of.\n        discretised_symbol: :class:`pybamm.Symbol`\n            The discretised symbol of the correct size\n\n        boundary_conditions : dict\n            The boundary conditions of the model\n            ({symbol.id: {\"left\": left bc, \"right\": right bc}})\n\n        Returns\n        -------\n        :class: `pybamm.Array`\n            Contains the result of taking the inner product of the result of acting\n            the discretised gradient on the child discretised_symbol with itself\n        \"\"\"\n        raise NotImplementedError",
  "def integral(self, child, discretised_child):\n        \"\"\"\n        Implements the integral for a spatial method.\n\n        Parameters\n        ----------\n        child: :class:`pybamm.Symbol`\n            The symbol to which is being integrated\n        discretised_child: :class:`pybamm.Symbol`\n            The discretised symbol of the correct size\n\n        Returns\n        -------\n        :class: `pybamm.Array`\n            Contains the result of acting the discretised integral on\n            the child discretised_symbol\n        \"\"\"\n        raise NotImplementedError",
  "def indefinite_integral(self, child, discretised_child):\n        \"\"\"\n        Implements the indefinite integral for a spatial method.\n\n        Parameters\n        ----------\n        child: :class:`pybamm.Symbol`\n            The symbol to which is being integrated\n        discretised_child: :class:`pybamm.Symbol`\n            The discretised symbol of the correct size\n\n        Returns\n        -------\n        :class: `pybamm.Array`\n            Contains the result of acting the discretised indefinite integral on\n            the child discretised_symbol\n        \"\"\"\n        raise NotImplementedError",
  "def boundary_integral(self, child, discretised_child, region):\n        \"\"\"\n        Implements the boundary integral for a spatial method.\n\n        Parameters\n        ----------\n        child: :class:`pybamm.Symbol`\n            The symbol to which is being integrated\n        discretised_child: :class:`pybamm.Symbol`\n            The discretised symbol of the correct size\n        region: str\n            The region of the boundary over which to integrate. If region is None\n            (default) the integration is carried out over the entire boundary. If\n            region is `negative tab` or `positive tab` then the integration is only\n            carried out over the appropriate part of the boundary corresponding to\n            the tab.\n\n        Returns\n        -------\n        :class: `pybamm.Array`\n            Contains the result of acting the discretised boundary integral on\n            the child discretised_symbol\n        \"\"\"\n        raise NotImplementedError",
  "def delta_function(self, symbol, discretised_symbol):\n        \"\"\"\n        Implements the delta function on the approriate side for a spatial method.\n\n        Parameters\n        ----------\n        symbol: :class:`pybamm.Symbol`\n            The symbol to which is being integrated\n        discretised_symbol: :class:`pybamm.Symbol`\n            The discretised symbol of the correct size\n        \"\"\"\n        raise NotImplementedError",
  "def internal_neumann_condition(\n        self, left_symbol_disc, right_symbol_disc, left_mesh, right_mesh\n    ):\n        \"\"\"\n        A method to find the internal neumann conditions between two symbols\n        on adjacent subdomains.\n\n        Parameters\n        ----------\n        left_symbol_disc : :class:`pybamm.Symbol`\n            The discretised symbol on the left subdomain\n        right_symbol_disc : :class:`pybamm.Symbol`\n            The discretised symbol on the right subdomain\n        left_mesh : list\n            The mesh on the left subdomain\n        right_mesh : list\n            The mesh on the right subdomain\n        \"\"\"\n\n        raise NotImplementedError",
  "def boundary_value_or_flux(self, symbol, discretised_child):\n        \"\"\"\n        Returns the boundary value or flux using the approriate expression for the\n        spatial method. To do this, we create a sparse vector 'bv_vector' that extracts\n        either the first (for side=\"left\") or last (for side=\"right\") point from\n        'discretised_child'.\n\n        Parameters\n        -----------\n        symbol: :class:`pybamm.Symbol`\n            The boundary value or flux symbol\n        discretised_child : :class:`pybamm.StateVector`\n            The discretised variable from which to calculate the boundary value\n\n        Returns\n        -------\n        :class:`pybamm.MatrixMultiplication`\n            The variable representing the surface value.\n        \"\"\"\n        if any(len(self.mesh[dom]) > 1 for dom in discretised_child.domain):\n            raise NotImplementedError(\"Cannot process 2D symbol in base spatial method\")\n        if isinstance(symbol, pybamm.BoundaryGradient):\n            raise TypeError(\"Cannot process BoundaryGradient in base spatial method\")\n        n = sum(self.mesh[dom][0].npts for dom in discretised_child.domain)\n        if symbol.side == \"left\":\n            # coo_matrix takes inputs (data, (row, col)) and puts data[i] at the point\n            # (row[i], col[i]) for each index of data. Here we just want a single point\n            # with value 1 at (0,0).\n            # Convert to a csr_matrix to allow indexing and other functionality\n            left_vector = csr_matrix(coo_matrix(([1], ([0], [0])), shape=(1, n)))\n            bv_vector = pybamm.Matrix(left_vector)\n        elif symbol.side == \"right\":\n            # as above, but now we want a single point with value 1 at (0, n-1)\n            right_vector = csr_matrix(coo_matrix(([1], ([0], [n - 1])), shape=(1, n)))\n            bv_vector = pybamm.Matrix(right_vector)\n\n        out = bv_vector @ discretised_child\n        # boundary value removes domain\n        out.domain = []\n        return out",
  "def mass_matrix(self, symbol, boundary_conditions):\n        \"\"\"\n        Calculates the mass matrix for a spatial method.\n\n        Parameters\n        ----------\n        symbol: :class:`pybamm.Variable`\n            The variable corresponding to the equation for which we are\n            calculating the mass matrix.\n        boundary_conditions : dict\n            The boundary conditions of the model\n            ({symbol.id: {\"left\": left bc, \"right\": right bc}})\n\n        Returns\n        -------\n        :class:`pybamm.Matrix`\n            The (sparse) mass matrix for the spatial method.\n        \"\"\"\n        # NOTE: for different spatial methods the matrix may need to be adjusted\n        # to account for Dirichlet boundary conditions. Here, we just have the default\n        # behaviour that the mass matrix is the identity.\n\n        # Create appropriate submesh by combining submeshes in domain\n        submesh = self.mesh.combine_submeshes(*symbol.domain)\n\n        # Get number of points in primary dimension\n        n = submesh[0].npts\n\n        # Create mass matrix for primary dimension\n        prim_mass = eye(n)\n\n        # Get number of points in secondary dimension\n        sec_pts = len(submesh)\n\n        # Convert to csr_matrix as required by some solvers\n        mass = csr_matrix(kron(eye(sec_pts), prim_mass))\n        return pybamm.Matrix(mass)",
  "def process_binary_operators(self, bin_op, left, right, disc_left, disc_right):\n        \"\"\"Discretise binary operators in model equations. Default behaviour is to\n        return a new binary operator with the discretised children.\n\n        Parameters\n        ----------\n        bin_op : :class:`pybamm.BinaryOperator`\n            Binary operator to discretise\n        left : :class:`pybamm.Symbol`\n            The left child of `bin_op`\n        right : :class:`pybamm.Symbol`\n            The right child of `bin_op`\n        disc_left : :class:`pybamm.Symbol`\n            The discretised left child of `bin_op`\n        disc_right : :class:`pybamm.Symbol`\n            The discretised right child of `bin_op`\n\n        Returns\n        -------\n        :class:`pybamm.BinaryOperator`\n            Discretised binary operator\n\n        \"\"\"\n        return bin_op.__class__(disc_left, disc_right)",
  "def concatenation(self, disc_children):\n        \"\"\"Discrete concatenation object.\n\n        Parameters\n        ----------\n        disc_children : list\n            List of discretised children\n\n        Returns\n        -------\n        :class:`pybamm.DomainConcatenation`\n            Concatenation of the discretised children\n        \"\"\"\n        return pybamm.DomainConcatenation(disc_children, self.mesh)",
  "class Discretisation(object):\n    \"\"\"The discretisation class, with methods to process a model and replace\n    Spatial Operators with Matrices and Variables with StateVectors\n\n    Parameters\n    ----------\n    mesh : pybamm.Mesh\n            contains all submeshes to be used on each domain\n    spatial_methods : dict\n            a dictionary of the spatial method to be used on each\n            domain. The keys correspond to the keys in a pybamm.Model\n    \"\"\"\n\n    def __init__(self, mesh=None, spatial_methods=None):\n        self._mesh = mesh\n        if mesh is None:\n            self._spatial_methods = {}\n        else:\n            # Unpack macroscale to the constituent subdomains\n            if \"macroscale\" in spatial_methods.keys():\n                method = spatial_methods[\"macroscale\"]\n                spatial_methods[\"negative electrode\"] = method\n                spatial_methods[\"separator\"] = method\n                spatial_methods[\"positive electrode\"] = method\n            self._spatial_methods = {\n                dom: method(mesh) for dom, method in spatial_methods.items()\n            }\n        self.bcs = {}\n        self.y_slices = {}\n        self._discretised_symbols = {}\n\n    @property\n    def mesh(self):\n        return self._mesh\n\n    @property\n    def y_slices(self):\n        return self._y_slices\n\n    @y_slices.setter\n    def y_slices(self, value):\n        if not isinstance(value, dict):\n            raise TypeError(\"\"\"y_slices should be dict, not {}\"\"\".format(type(value)))\n\n        self._y_slices = value\n\n    @property\n    def spatial_methods(self):\n        return self._spatial_methods\n\n    @property\n    def bcs(self):\n        return self._bcs\n\n    @bcs.setter\n    def bcs(self, value):\n        self._bcs = value\n        # reset discretised_symbols\n        self._discretised_symbols = {}\n\n    def process_model(self, model, inplace=True):\n        \"\"\"Discretise a model.\n        Currently inplace, could be changed to return a new model.\n\n        Parameters\n        ----------\n        model : :class:`pybamm.BaseModel`\n            Model to dicretise. Must have attributes rhs, initial_conditions and\n            boundary_conditions (all dicts of {variable: equation})\n        inplace: bool, optional\n            If True, discretise the model in place. Otherwise, return a new\n            discretised model. Default is True.\n\n        Returns\n        -------\n        model_disc : :class:`pybamm.BaseModel`\n            The discretised model. Note that if ``inplace`` is True, model will\n            have also been discretised in place so model == model_disc. If\n            ``inplace`` is False, model != model_disc\n\n        Raises\n        ------\n        :class:`pybamm.ModelError`\n            If an empty model is passed (`model.rhs = {}` and `model.algebraic={}`)\n\n        \"\"\"\n\n        pybamm.logger.info(\"Start discretising {}\".format(model.name))\n\n        # Make sure model isn't empty\n        if len(model.rhs) == 0 and len(model.algebraic) == 0:\n            raise pybamm.ModelError(\"Cannot discretise empty model\")\n        # Check well-posedness to avoid obscure errors\n        model.check_well_posedness()\n\n        # Prepare discretisation\n        # set variables (we require the full variable not just id)\n        variables = list(model.rhs.keys()) + list(model.algebraic.keys())\n\n        # Set the y split for variables\n        pybamm.logger.info(\"Set variable slices for {}\".format(model.name))\n        self.set_variable_slices(variables)\n\n        # set boundary conditions (only need key ids for boundary_conditions)\n        pybamm.logger.info(\"Discretise boundary conditions for {}\".format(model.name))\n        self.bcs = self.process_boundary_conditions(model)\n        pybamm.logger.info(\"Set internal boundary conditions for {}\".format(model.name))\n        self.set_internal_boundary_conditions(model)\n\n        # set up inplace vs not inplace\n        if inplace:\n            # any changes to model_disc attributes will change model attributes\n            # since they point to the same object\n            model_disc = model\n        else:\n            # create a blank model so that original model is unchanged\n            model_disc = pybamm.BaseModel()\n            model_disc.name = model.name\n            model_disc.options = model.options\n            model_disc.use_jacobian = model.use_jacobian\n            model_disc.use_simplify = model.use_simplify\n            model_disc.use_to_python = model.use_to_python\n\n        model_disc.bcs = self.bcs\n\n        # Process initial condtions\n        pybamm.logger.info(\"Discretise initial conditions for {}\".format(model.name))\n        ics, concat_ics = self.process_initial_conditions(model)\n        model_disc.initial_conditions = ics\n        model_disc.concatenated_initial_conditions = concat_ics\n\n        # Discretise variables (applying boundary conditions)\n        # Note that we **do not** discretise the keys of model.rhs,\n        # model.initial_conditions and model.boundary_conditions\n        pybamm.logger.info(\"Discretise variables for {}\".format(model.name))\n        model_disc.variables = self.process_dict(model.variables)\n\n        # Process parabolic and elliptic equations\n        pybamm.logger.info(\"Discretise model equations for {}\".format(model.name))\n        rhs, concat_rhs, alg, concat_alg = self.process_rhs_and_algebraic(model)\n        model_disc.rhs, model_disc.concatenated_rhs = rhs, concat_rhs\n        model_disc.algebraic, model_disc.concatenated_algebraic = alg, concat_alg\n\n        # Process events\n        processed_events = {}\n        pybamm.logger.info(\"Discretise events for {}\".format(model.name))\n        for event, equation in model.events.items():\n            pybamm.logger.debug(\"Discretise event '{}'\".format(event))\n            processed_events[event] = self.process_symbol(equation)\n        model_disc.events = processed_events\n\n        # Create mass matrix\n        pybamm.logger.info(\"Create mass matrix for {}\".format(model.name))\n        model_disc.mass_matrix = self.create_mass_matrix(model_disc)\n\n        # Check that resulting model makes sense\n        self.check_model(model_disc)\n\n        pybamm.logger.info(\"Finish discretising {}\".format(model.name))\n\n        return model_disc\n\n    def set_variable_slices(self, variables):\n        \"\"\"\n        Sets the slicing for variables.\n\n        Parameters\n        ----------\n        variables : iterable of :class:`pybamm.Variables`\n            The variables for which to set slices\n        \"\"\"\n        # Set up y_slices\n        y_slices = defaultdict(list)\n        start = 0\n        end = 0\n        # Iterate through unpacked variables, adding appropriate slices to y_slices\n        for variable in variables:\n            # If domain is empty then variable has size 1\n            if variable.domain == []:\n                end += 1\n                y_slices[variable.id].append(slice(start, end))\n                start = end\n            # Otherwise, add up the size of all the domains in variable.domain\n            elif isinstance(variable, pybamm.Concatenation):\n                children = variable.children\n                meshes = OrderedDict()\n                for child in children:\n                    meshes[child] = [\n                        self.spatial_methods[dom].mesh[dom] for dom in child.domain\n                    ]\n                sec_points = len(list(meshes.values())[0][0])\n                for i in range(sec_points):\n                    for child, mesh in meshes.items():\n                        for domain_mesh in mesh:\n                            submesh = domain_mesh[i]\n                            end += submesh.npts_for_broadcast\n                        y_slices[child.id].append(slice(start, end))\n                        start = end\n            else:\n                for dom in variable.domain:\n                    for submesh in self.spatial_methods[dom].mesh[dom]:\n                        end += submesh.npts_for_broadcast\n                y_slices[variable.id].append(slice(start, end))\n                start = end\n\n        self.y_slices = y_slices\n\n        # reset discretised_symbols\n        self._discretised_symbols = {}\n\n    def set_internal_boundary_conditions(self, model):\n        \"\"\"\n        A method to set the internal boundary conditions for the submodel.\n        These are required to properly calculate the gradient.\n        Note: this method modifies the state of self.boundary_conditions.\n        \"\"\"\n\n        def boundary_gradient(left_symbol, right_symbol):\n\n            pybamm.logger.debug(\n                \"Calculate boundary gradient ({} and {})\".format(\n                    left_symbol, right_symbol\n                )\n            )\n            left_domain = left_symbol.domain[0]\n            right_domain = right_symbol.domain[0]\n\n            left_mesh = self.spatial_methods[left_domain].mesh[left_domain]\n            right_mesh = self.spatial_methods[right_domain].mesh[right_domain]\n\n            left_symbol_disc = self.process_symbol(left_symbol)\n            right_symbol_disc = self.process_symbol(right_symbol)\n\n            return self.spatial_methods[left_domain].internal_neumann_condition(\n                left_symbol_disc, right_symbol_disc, left_mesh, right_mesh\n            )\n\n        # bc_key_ids = [key.id for key in list(model.boundary_conditions.keys())]\n        bc_key_ids = list(self.bcs.keys())\n\n        internal_bcs = {}\n        for var in model.boundary_conditions.keys():\n            if isinstance(var, pybamm.Concatenation):\n                children = var.children\n\n                first_child = children[0]\n                first_orphan = first_child.new_copy()\n                next_child = children[1]\n                next_orphan = next_child.new_copy()\n\n                lbc = self.bcs[var.id][\"left\"]\n                rbc = (boundary_gradient(first_orphan, next_orphan), \"Neumann\")\n\n                if first_child.id not in bc_key_ids:\n                    internal_bcs.update({first_child.id: {\"left\": lbc, \"right\": rbc}})\n\n                for i, _ in enumerate(children[1:-1]):\n                    current_child = next_child\n                    current_orphan = next_orphan\n                    next_child = children[i + 2]\n                    next_orphan = next_child.new_copy()\n\n                    lbc = rbc\n                    rbc = (boundary_gradient(current_orphan, next_orphan), \"Neumann\")\n                    if current_child.id not in bc_key_ids:\n                        internal_bcs.update(\n                            {current_child.id: {\"left\": lbc, \"right\": rbc}}\n                        )\n\n                lbc = rbc\n                rbc = self.bcs[var.id][\"right\"]\n                if children[-1].id not in bc_key_ids:\n                    internal_bcs.update({children[-1].id: {\"left\": lbc, \"right\": rbc}})\n\n        self.bcs.update(internal_bcs)\n\n    def process_initial_conditions(self, model):\n        \"\"\"Discretise model initial_conditions.\n\n        Parameters\n        ----------\n        model : :class:`pybamm.BaseModel`\n            Model to dicretise. Must have attributes rhs, initial_conditions and\n            boundary_conditions (all dicts of {variable: equation})\n\n        Returns\n        -------\n        tuple\n            Tuple of processed_initial_conditions (dict of initial conditions) and\n            concatenated_initial_conditions (numpy array of concatenated initial\n            conditions)\n\n        \"\"\"\n        # Discretise initial conditions\n        processed_initial_conditions = self.process_dict(model.initial_conditions)\n\n        # Concatenate initial conditions into a single vector\n        # check that all initial conditions are set\n        processed_concatenated_initial_conditions = self._concatenate_in_order(\n            processed_initial_conditions, check_complete=True\n        ).evaluate(0, None)\n\n        return processed_initial_conditions, processed_concatenated_initial_conditions\n\n    def process_boundary_conditions(self, model):\n        \"\"\"Discretise model boundary_conditions, also converting keys to ids\n\n        Parameters\n        ----------\n        model : :class:`pybamm.BaseModel`\n            Model to dicretise. Must have attributes rhs, initial_conditions and\n            boundary_conditions (all dicts of {variable: equation})\n\n        Returns\n        -------\n        dict\n            Dictionary of processed boundary conditions\n\n        \"\"\"\n\n        processed_bcs = {}\n\n        # process and set pybamm.variables first incase required\n        # in discrisation of other boundary conditions\n        for key, bcs in model.boundary_conditions.items():\n            processed_bcs[key.id] = {}\n\n            # Handle any boundary conditions applied on the tabs\n            if any(\"tab\" in side for side in list(bcs.keys())):\n                bcs = self.check_tab_conditions(key, bcs)\n\n            # Process boundary conditions\n            for side, bc in bcs.items():\n                eqn, typ = bc\n                pybamm.logger.debug(\"Discretise {} ({} bc)\".format(key, side))\n                processed_eqn = self.process_symbol(eqn)\n                processed_bcs[key.id][side] = (processed_eqn, typ)\n\n        return processed_bcs\n\n    def check_tab_conditions(self, symbol, bcs):\n        \"\"\"\n        Check any boundary conditions applied on \"negative tab\", \"positive tab\"\n        and \"no tab\". For 1D current collector meshes, these conditions are\n        converted into boundary conditions on \"left\" (tab at z=0) or \"right\"\n        (tab at z=l_z) depending on the tab location stored in the mesh. For 2D\n        current collector meshes, the boundary conditions can be applied on the\n        tabs directly.\n\n        Parameters\n        ----------\n        symbol : :class:`pybamm.expression_tree.symbol.Symbol`\n            The symbol on which the boundary conditions are applied.\n        bcs : dict\n            The dictionary of boundary conditions (a dict of {side: equation}).\n\n        Returns\n        -------\n        dict\n            The dictionary of boundary conditions, with the keys changed to\n            \"left\" and \"right\" where necessary.\n\n        \"\"\"\n        # Check symbol domain\n        domain = symbol.domain[0]\n        mesh = self.mesh[domain][0]\n\n        if domain != \"current collector\":\n            raise pybamm.ModelError(\n                \"\"\"Boundary conditions can only be applied on the tabs in the domain\n            'current collector', but {} has domain {}\"\"\".format(\n                    symbol, domain\n                )\n            )\n\n        # Replace keys with \"left\" and \"right\" as appropriate for 1D meshes\n        if isinstance(mesh, pybamm.SubMesh1D):\n            # replace negative and/or positive tab\n            for tab in [\"negative tab\", \"positive tab\"]:\n                if any(tab in side for side in list(bcs.keys())):\n                    bcs[mesh.tabs[tab]] = bcs.pop(tab)\n            # replace no tab\n            if any(\"no tab\" in side for side in list(bcs.keys())):\n                if \"left\" in list(bcs.keys()):\n                    bcs[\"right\"] = bcs.pop(\"no tab\")  # tab at bottom\n                else:\n                    bcs[\"left\"] = bcs.pop(\"no tab\")  # tab at top\n\n        return bcs\n\n    def process_rhs_and_algebraic(self, model):\n        \"\"\"Discretise model equations - differential ('rhs') and algebraic.\n\n        Parameters\n        ----------\n        model : :class:`pybamm.BaseModel`\n            Model to dicretise. Must have attributes rhs, initial_conditions and\n            boundary_conditions (all dicts of {variable: equation})\n\n        Returns\n        -------\n        tuple\n            Tuple of processed_rhs (dict of processed differential equations),\n            processed_concatenated_rhs, processed_algebraic (dict of processed algebraic\n            equations) and processed_concatenated_algebraic\n\n        \"\"\"\n        # Discretise right-hand sides, passing domain from variable\n        processed_rhs = self.process_dict(model.rhs)\n\n        # Concatenate rhs into a single state vector\n        # Need to concatenate in order as the ordering of equations could be different\n        # in processed_rhs and model.rhs\n        processed_concatenated_rhs = self._concatenate_in_order(processed_rhs)\n\n        # Discretise and concatenate algebraic equations\n        processed_algebraic = self.process_dict(model.algebraic)\n\n        # Concatenate algebraic into a single state vector\n        # Need to concatenate in order as the ordering of equations could be different\n        # in processed_algebraic and model.algebraic\n        processed_concatenated_algebraic = self._concatenate_in_order(\n            processed_algebraic\n        )\n\n        return (\n            processed_rhs,\n            processed_concatenated_rhs,\n            processed_algebraic,\n            processed_concatenated_algebraic,\n        )\n\n    def create_mass_matrix(self, model):\n        \"\"\"Creates mass matrix of the discretised model.\n        Note that the model is assumed to be of the form M*y_dot = f(t,y), where\n        M is the (possibly singular) mass matrix.\n\n        Parameters\n        ----------\n        model : :class:`pybamm.BaseModel`\n            Discretised model. Must have attributes rhs, initial_conditions and\n            boundary_conditions (all dicts of {variable: equation})\n\n        Returns\n        -------\n        :class:`pybamm.Matrix`\n            The mass matrix\n        \"\"\"\n        # Create list of mass matrices for each equation to be put into block\n        # diagonal mass matrix for the model\n        mass_list = []\n\n        # get a list of model rhs variables that are sorted according to\n        # where they are in the state vector\n        model_variables = model.rhs.keys()\n        model_slices = []\n        for v in model_variables:\n            if isinstance(v, pybamm.Concatenation):\n                model_slices.append(\n                    slice(\n                        self.y_slices[v.children[0].id][0].start,\n                        self.y_slices[v.children[-1].id][0].stop,\n                    )\n                )\n            else:\n                model_slices.append(self.y_slices[v.id][0])\n        sorted_model_variables = [\n            v for _, v in sorted(zip(model_slices, model_variables))\n        ]\n\n        # Process mass matrices for the differential equations\n        for var in sorted_model_variables:\n            if var.domain == []:\n                # If variable domain empty then mass matrix is just 1\n                mass_list.append(1.0)\n            else:\n                mass_list.append(\n                    self.spatial_methods[var.domain[0]]\n                    .mass_matrix(var, self.bcs)\n                    .entries\n                )\n\n        # Create lumped mass matrix (of zeros) of the correct shape for the\n        # discretised algebraic equations\n        if model.algebraic.keys():\n            mass_algebraic_size = model.concatenated_algebraic.shape[0]\n            mass_algebraic = csr_matrix((mass_algebraic_size, mass_algebraic_size))\n            mass_list.append(mass_algebraic)\n\n        # Create block diagonal (sparse) mass matrix\n        mass_matrix = block_diag(mass_list, format=\"csr\")\n\n        return pybamm.Matrix(mass_matrix)\n\n    def create_jacobian(self, model):\n        \"\"\"Creates Jacobian of the discretised model.\n        Note that the model is assumed to be of the form M*y_dot = f(t,y), where\n        M is the (possibly singular) mass matrix. The Jacobian is df/dy.\n\n        Note: At present, calculation of the Jacobian is deferred until after\n        simplification, since it is much faster to compute the Jacobian of the\n        simplified model. However, in some use cases (e.g. running the same\n        model multiple times but with different parameters) it may be more\n        efficient to compute the Jacobian once, before simplification, so that\n        parameters in the Jacobian can be updated (see PR #670).\n\n        Parameters\n        ----------\n        model : :class:`pybamm.BaseModel`\n            Discretised model. Must have attributes rhs, initial_conditions and\n            boundary_conditions (all dicts of {variable: equation})\n\n        Returns\n        -------\n        :class:`pybamm.Concatenation`\n            The expression trees corresponding to the Jacobian of the model\n        \"\"\"\n        # create state vector to differentiate with respect to\n        y = pybamm.StateVector(slice(0, np.size(model.concatenated_initial_conditions)))\n        # set up Jacobian object, for re-use of dict\n        jacobian = pybamm.Jacobian()\n\n        # calculate Jacobian of rhs by equation\n        jac_rhs_eqn_dict = {}\n        for eqn_key, eqn in model.rhs.items():\n            pybamm.logger.debug(\n                \"Calculating block of Jacobian for {!r}\".format(eqn_key.name)\n            )\n            jac_rhs_eqn_dict[eqn_key] = jacobian.jac(eqn, y)\n        jac_rhs = self._concatenate_in_order(jac_rhs_eqn_dict, sparse=True)\n\n        # calculate Jacobian of algebraic by equation\n        jac_algebraic_eqn_dict = {}\n        for eqn_key, eqn in model.algebraic.items():\n            pybamm.logger.debug(\n                \"Calculating block of Jacobian for {!r}\".format(eqn_key.name)\n            )\n            jac_algebraic_eqn_dict[eqn_key] = jacobian.jac(eqn, y)\n        jac_algebraic = self._concatenate_in_order(jac_algebraic_eqn_dict, sparse=True)\n\n        # full Jacobian\n        if model.rhs.keys() and model.algebraic.keys():\n            jac = pybamm.SparseStack(jac_rhs, jac_algebraic)\n        elif not model.algebraic.keys():\n            jac = jac_rhs\n        else:\n            jac = jac_algebraic\n\n        return jac, jac_rhs, jac_algebraic\n\n    def process_dict(self, var_eqn_dict):\n        \"\"\"Discretise a dictionary of {variable: equation}, broadcasting if necessary\n        (can be model.rhs, model.algebraic, model.initial_conditions or\n        model.variables).\n\n        Parameters\n        ----------\n        var_eqn_dict : dict\n            Equations ({variable: equation} dict) to dicretise\n            (can be model.rhs, model.algebraic, model.initial_conditions or\n            model.variables)\n\n        Returns\n        -------\n        new_var_eqn_dict : dict\n            Discretised equations\n\n        \"\"\"\n        new_var_eqn_dict = {}\n        for eqn_key, eqn in var_eqn_dict.items():\n            # Broadcast if the equation evaluates to a number(e.g. Scalar)\n            if eqn.evaluates_to_number() and not isinstance(eqn_key, str):\n                eqn = pybamm.Broadcast(eqn, eqn_key.domain)\n\n            # note we are sending in the key.id here so we don't have to\n            # keep calling .id\n            pybamm.logger.debug(\"Discretise {!r}\".format(eqn_key))\n\n            new_var_eqn_dict[eqn_key] = self.process_symbol(eqn)\n\n        return new_var_eqn_dict\n\n    def process_symbol(self, symbol):\n        \"\"\"Discretise operators in model equations.\n        If a symbol has already been discretised, the stored value is returned.\n\n        Parameters\n        ----------\n        symbol : :class:`pybamm.expression_tree.symbol.Symbol`\n            Symbol to discretise\n\n        Returns\n        -------\n        :class:`pybamm.expression_tree.symbol.Symbol`\n            Discretised symbol\n\n        \"\"\"\n        try:\n            return self._discretised_symbols[symbol.id]\n        except KeyError:\n            discretised_symbol = self._process_symbol(symbol)\n            self._discretised_symbols[symbol.id] = discretised_symbol\n            discretised_symbol.test_shape()\n            return discretised_symbol\n\n    def _process_symbol(self, symbol):\n        \"\"\" See :meth:`Discretisation.process_symbol()`. \"\"\"\n\n        if symbol.domain != []:\n            spatial_method = self.spatial_methods[symbol.domain[0]]\n            # If boundary conditions are provided, need to check for BCs on tabs\n            if self.bcs:\n                key_id = list(self.bcs.keys())[0]\n                if any(\"tab\" in side for side in list(self.bcs[key_id].keys())):\n                    self.bcs[key_id] = self.check_tab_conditions(\n                        symbol, self.bcs[key_id]\n                    )\n\n        if isinstance(symbol, pybamm.BinaryOperator):\n            # Pre-process children\n            left, right = symbol.children\n            disc_left = self.process_symbol(left)\n            disc_right = self.process_symbol(right)\n            if symbol.domain == []:\n                return symbol.__class__(disc_left, disc_right)\n            else:\n                return spatial_method.process_binary_operators(\n                    symbol, left, right, disc_left, disc_right\n                )\n\n        elif isinstance(symbol, pybamm.UnaryOperator):\n            child = symbol.child\n            disc_child = self.process_symbol(child)\n            if child.domain != []:\n                child_spatial_method = self.spatial_methods[child.domain[0]]\n\n            if isinstance(symbol, pybamm.Gradient):\n                return child_spatial_method.gradient(child, disc_child, self.bcs)\n\n            elif isinstance(symbol, pybamm.Divergence):\n                return child_spatial_method.divergence(child, disc_child, self.bcs)\n\n            elif isinstance(symbol, pybamm.Laplacian):\n                return child_spatial_method.laplacian(child, disc_child, self.bcs)\n\n            elif isinstance(symbol, pybamm.Gradient_Squared):\n                return child_spatial_method.gradient_squared(\n                    child, disc_child, self.bcs\n                )\n\n            elif isinstance(symbol, pybamm.Mass):\n                return child_spatial_method.mass_matrix(child, self.bcs)\n\n            elif isinstance(symbol, pybamm.BoundaryMass):\n                return child_spatial_method.boundary_mass_matrix(child, self.bcs)\n\n            elif isinstance(symbol, pybamm.IndefiniteIntegral):\n                return child_spatial_method.indefinite_integral(child, disc_child)\n\n            elif isinstance(symbol, pybamm.Integral):\n                out = child_spatial_method.integral(child, disc_child)\n                out.domain = symbol.domain\n                out.auxiliary_domains = symbol.auxiliary_domains\n                return out\n\n            elif isinstance(symbol, pybamm.DefiniteIntegralVector):\n                return child_spatial_method.definite_integral_matrix(\n                    child.domain, vector_type=symbol.vector_type\n                )\n\n            elif isinstance(symbol, pybamm.BoundaryIntegral):\n                return child_spatial_method.boundary_integral(\n                    child, disc_child, symbol.region\n                )\n\n            elif isinstance(symbol, pybamm.Broadcast):\n                # Broadcast new_child to the domain specified by symbol.domain\n                # Different discretisations may broadcast differently\n                if symbol.domain == []:\n                    symbol = disc_child * pybamm.Vector(np.array([1]))\n                else:\n                    symbol = spatial_method.broadcast(\n                        disc_child,\n                        symbol.domain,\n                        symbol.auxiliary_domains,\n                        symbol.broadcast_type,\n                    )\n                return symbol\n\n            elif isinstance(symbol, pybamm.DeltaFunction):\n                return spatial_method.delta_function(symbol, disc_child)\n\n            elif isinstance(symbol, pybamm.BoundaryOperator):\n                # if boundary operator applied on \"negative tab\" or\n                # \"positive tab\" *and* the mesh is 1D then change side to\n                # \"left\" or \"right\" as appropriate\n                if symbol.side in [\"negative tab\", \"positive tab\"]:\n                    mesh = self.mesh[symbol.children[0].domain[0]][0]\n                    if isinstance(mesh, pybamm.SubMesh1D):\n                        symbol.side = mesh.tabs[symbol.side]\n                return child_spatial_method.boundary_value_or_flux(symbol, disc_child)\n\n            else:\n                return symbol._unary_new_copy(disc_child)\n\n        elif isinstance(symbol, pybamm.Function):\n            disc_children = [self.process_symbol(child) for child in symbol.children]\n            return symbol._function_new_copy(disc_children)\n\n        elif isinstance(symbol, pybamm.Variable):\n            return pybamm.StateVector(\n                *self.y_slices[symbol.id],\n                domain=symbol.domain,\n                auxiliary_domains=symbol.auxiliary_domains\n            )\n\n        elif isinstance(symbol, pybamm.SpatialVariable):\n            return spatial_method.spatial_variable(symbol)\n\n        elif isinstance(symbol, pybamm.Concatenation):\n            new_children = [self.process_symbol(child) for child in symbol.children]\n            new_symbol = spatial_method.concatenation(new_children)\n\n            return new_symbol\n\n        else:\n            # Backup option: return new copy of the object\n            try:\n                return symbol.new_copy()\n            except NotImplementedError:\n                raise NotImplementedError(\n                    \"Cannot discretise symbol of type '{}'\".format(type(symbol))\n                )\n\n    def concatenate(self, *symbols, sparse=False):\n        if sparse:\n            return pybamm.SparseStack(*symbols)\n        else:\n            return pybamm.NumpyConcatenation(*symbols)\n\n    def _concatenate_in_order(self, var_eqn_dict, check_complete=False, sparse=False):\n        \"\"\"\n        Concatenate a dictionary of {variable: equation} using self.y_slices\n\n        The keys/variables in `var_eqn_dict` must be the same as the ids in\n        `self.y_slices`.\n        The resultant concatenation is ordered according to the ordering of the slice\n        values in `self.y_slices`\n\n        Parameters\n        ----------\n        var_eqn_dict : dict\n            Equations ({variable: equation} dict) to dicretise\n        check_complete : bool, optional\n            Whether to check keys in var_eqn_dict against self.y_slices. Default\n            is False\n        sparse : bool, optional\n            If True the concatenation will be a :class:`pybamm.SparseStack`. If\n            False the concatenation will be a :class:`pybamm.NumpyConcatenation`.\n            Default is False\n\n        Returns\n        -------\n        var_eqn_dict : dict\n            Discretised right-hand side equations\n\n        \"\"\"\n        # Unpack symbols in variables that are concatenations of variables\n        unpacked_variables = []\n        slices = []\n        for symbol in var_eqn_dict.keys():\n            if isinstance(symbol, pybamm.Concatenation):\n                unpacked_variables.extend([var for var in symbol.children])\n                # must append the slice for the whole concatenation, so that equations\n                # get sorted correctly\n                slices.append(\n                    slice(\n                        self.y_slices[symbol.children[0].id][0].start,\n                        self.y_slices[symbol.children[-1].id][0].stop,\n                    )\n                )\n            else:\n                unpacked_variables.append(symbol)\n                slices.append(self.y_slices[symbol.id][0])\n\n        if check_complete:\n            # Check keys from the given var_eqn_dict against self.y_slices\n            ids = {v.id for v in unpacked_variables}\n            if ids != self.y_slices.keys():\n                given_variable_names = [v.name for v in var_eqn_dict.keys()]\n                raise pybamm.ModelError(\n                    \"Initial conditions are insufficient. Only \"\n                    \"provided for {} \".format(given_variable_names)\n                )\n\n        equations = list(var_eqn_dict.values())\n\n        # sort equations according to slices\n        sorted_equations = [eq for _, eq in sorted(zip(slices, equations))]\n\n        return self.concatenate(*sorted_equations, sparse=sparse)\n\n    def check_model(self, model):\n        \"\"\" Perform some basic checks to make sure the discretised model makes sense.\"\"\"\n        self.check_initial_conditions(model)\n        self.check_initial_conditions_rhs(model)\n        self.check_variables(model)\n\n    def check_initial_conditions(self, model):\n        \"\"\"Check initial conditions are a numpy array\"\"\"\n        # Individual\n        for var, eqn in model.initial_conditions.items():\n            assert type(eqn.evaluate(0, None)) is np.ndarray, pybamm.ModelError(\n                \"\"\"\n                initial_conditions must be numpy array after discretisation but they are\n                {} for variable '{}'.\n                \"\"\".format(\n                    type(eqn.evaluate(0, None)), var\n                )\n            )\n        # Concatenated\n        assert (\n            type(model.concatenated_initial_conditions) is np.ndarray\n        ), pybamm.ModelError(\n            \"\"\"\n            Concatenated initial_conditions must be numpy array after discretisation but\n            they are {}.\n            \"\"\".format(\n                type(model.concatenated_initial_conditions)\n            )\n        )\n\n    def check_initial_conditions_rhs(self, model):\n        \"\"\"Check initial conditions and rhs have the same shape\"\"\"\n        y0 = model.concatenated_initial_conditions\n        # Individual\n        for var in model.rhs.keys():\n            assert (\n                model.rhs[var].shape == model.initial_conditions[var].shape\n            ), pybamm.ModelError(\n                \"\"\"\n                rhs and initial_conditions must have the same shape after discretisation\n                but rhs.shape = {} and initial_conditions.shape = {} for variable '{}'.\n                \"\"\".format(\n                    model.rhs[var].shape, model.initial_conditions[var].shape, var\n                )\n            )\n        # Concatenated\n        assert (\n            model.concatenated_rhs.shape[0] + model.concatenated_algebraic.shape[0]\n            == y0.shape[0]\n        ), pybamm.ModelError(\n            \"\"\"\n            Concatenation of (rhs, algebraic) and initial_conditions must have the\n            same shape after discretisation but rhs.shape = {}, algebraic.shape = {},\n            and initial_conditions.shape = {}.\n            \"\"\".format(\n                model.concatenated_rhs.shape,\n                model.concatenated_algebraic.shape,\n                y0.shape,\n            )\n        )\n\n    def check_variables(self, model):\n        \"\"\"\n        Check variables in variable list against rhs\n        Be lenient with size check if the variable in model.variables is broadcasted, or\n        a concatenation, or an outer product\n        (if broadcasted, variable is a multiplication with a vector of ones)\n        \"\"\"\n        for rhs_var in model.rhs.keys():\n            if rhs_var.name in model.variables.keys():\n                var = model.variables[rhs_var.name]\n\n                different_shapes = not np.array_equal(\n                    model.rhs[rhs_var].shape, var.shape\n                )\n\n                not_concatenation = not isinstance(var, pybamm.Concatenation)\n                not_outer = not isinstance(var, pybamm.Outer)\n\n                not_mult_by_one_vec = not (\n                    isinstance(var, pybamm.Multiplication)\n                    and isinstance(var.right, pybamm.Vector)\n                    and np.all(var.right.entries == 1)\n                )\n\n                if (\n                    different_shapes\n                    and not_concatenation\n                    and not_outer\n                    and not_mult_by_one_vec\n                ):\n                    raise pybamm.ModelError(\n                        \"\"\"\n                    variable and its eqn must have the same shape after discretisation\n                    but variable.shape = {} and rhs.shape = {} for variable '{}'.\n                    \"\"\".format(\n                            var.shape, model.rhs[rhs_var].shape, var\n                        )\n                    )",
  "def __init__(self, mesh=None, spatial_methods=None):\n        self._mesh = mesh\n        if mesh is None:\n            self._spatial_methods = {}\n        else:\n            # Unpack macroscale to the constituent subdomains\n            if \"macroscale\" in spatial_methods.keys():\n                method = spatial_methods[\"macroscale\"]\n                spatial_methods[\"negative electrode\"] = method\n                spatial_methods[\"separator\"] = method\n                spatial_methods[\"positive electrode\"] = method\n            self._spatial_methods = {\n                dom: method(mesh) for dom, method in spatial_methods.items()\n            }\n        self.bcs = {}\n        self.y_slices = {}\n        self._discretised_symbols = {}",
  "def mesh(self):\n        return self._mesh",
  "def y_slices(self):\n        return self._y_slices",
  "def y_slices(self, value):\n        if not isinstance(value, dict):\n            raise TypeError(\"\"\"y_slices should be dict, not {}\"\"\".format(type(value)))\n\n        self._y_slices = value",
  "def spatial_methods(self):\n        return self._spatial_methods",
  "def bcs(self):\n        return self._bcs",
  "def bcs(self, value):\n        self._bcs = value\n        # reset discretised_symbols\n        self._discretised_symbols = {}",
  "def process_model(self, model, inplace=True):\n        \"\"\"Discretise a model.\n        Currently inplace, could be changed to return a new model.\n\n        Parameters\n        ----------\n        model : :class:`pybamm.BaseModel`\n            Model to dicretise. Must have attributes rhs, initial_conditions and\n            boundary_conditions (all dicts of {variable: equation})\n        inplace: bool, optional\n            If True, discretise the model in place. Otherwise, return a new\n            discretised model. Default is True.\n\n        Returns\n        -------\n        model_disc : :class:`pybamm.BaseModel`\n            The discretised model. Note that if ``inplace`` is True, model will\n            have also been discretised in place so model == model_disc. If\n            ``inplace`` is False, model != model_disc\n\n        Raises\n        ------\n        :class:`pybamm.ModelError`\n            If an empty model is passed (`model.rhs = {}` and `model.algebraic={}`)\n\n        \"\"\"\n\n        pybamm.logger.info(\"Start discretising {}\".format(model.name))\n\n        # Make sure model isn't empty\n        if len(model.rhs) == 0 and len(model.algebraic) == 0:\n            raise pybamm.ModelError(\"Cannot discretise empty model\")\n        # Check well-posedness to avoid obscure errors\n        model.check_well_posedness()\n\n        # Prepare discretisation\n        # set variables (we require the full variable not just id)\n        variables = list(model.rhs.keys()) + list(model.algebraic.keys())\n\n        # Set the y split for variables\n        pybamm.logger.info(\"Set variable slices for {}\".format(model.name))\n        self.set_variable_slices(variables)\n\n        # set boundary conditions (only need key ids for boundary_conditions)\n        pybamm.logger.info(\"Discretise boundary conditions for {}\".format(model.name))\n        self.bcs = self.process_boundary_conditions(model)\n        pybamm.logger.info(\"Set internal boundary conditions for {}\".format(model.name))\n        self.set_internal_boundary_conditions(model)\n\n        # set up inplace vs not inplace\n        if inplace:\n            # any changes to model_disc attributes will change model attributes\n            # since they point to the same object\n            model_disc = model\n        else:\n            # create a blank model so that original model is unchanged\n            model_disc = pybamm.BaseModel()\n            model_disc.name = model.name\n            model_disc.options = model.options\n            model_disc.use_jacobian = model.use_jacobian\n            model_disc.use_simplify = model.use_simplify\n            model_disc.use_to_python = model.use_to_python\n\n        model_disc.bcs = self.bcs\n\n        # Process initial condtions\n        pybamm.logger.info(\"Discretise initial conditions for {}\".format(model.name))\n        ics, concat_ics = self.process_initial_conditions(model)\n        model_disc.initial_conditions = ics\n        model_disc.concatenated_initial_conditions = concat_ics\n\n        # Discretise variables (applying boundary conditions)\n        # Note that we **do not** discretise the keys of model.rhs,\n        # model.initial_conditions and model.boundary_conditions\n        pybamm.logger.info(\"Discretise variables for {}\".format(model.name))\n        model_disc.variables = self.process_dict(model.variables)\n\n        # Process parabolic and elliptic equations\n        pybamm.logger.info(\"Discretise model equations for {}\".format(model.name))\n        rhs, concat_rhs, alg, concat_alg = self.process_rhs_and_algebraic(model)\n        model_disc.rhs, model_disc.concatenated_rhs = rhs, concat_rhs\n        model_disc.algebraic, model_disc.concatenated_algebraic = alg, concat_alg\n\n        # Process events\n        processed_events = {}\n        pybamm.logger.info(\"Discretise events for {}\".format(model.name))\n        for event, equation in model.events.items():\n            pybamm.logger.debug(\"Discretise event '{}'\".format(event))\n            processed_events[event] = self.process_symbol(equation)\n        model_disc.events = processed_events\n\n        # Create mass matrix\n        pybamm.logger.info(\"Create mass matrix for {}\".format(model.name))\n        model_disc.mass_matrix = self.create_mass_matrix(model_disc)\n\n        # Check that resulting model makes sense\n        self.check_model(model_disc)\n\n        pybamm.logger.info(\"Finish discretising {}\".format(model.name))\n\n        return model_disc",
  "def set_variable_slices(self, variables):\n        \"\"\"\n        Sets the slicing for variables.\n\n        Parameters\n        ----------\n        variables : iterable of :class:`pybamm.Variables`\n            The variables for which to set slices\n        \"\"\"\n        # Set up y_slices\n        y_slices = defaultdict(list)\n        start = 0\n        end = 0\n        # Iterate through unpacked variables, adding appropriate slices to y_slices\n        for variable in variables:\n            # If domain is empty then variable has size 1\n            if variable.domain == []:\n                end += 1\n                y_slices[variable.id].append(slice(start, end))\n                start = end\n            # Otherwise, add up the size of all the domains in variable.domain\n            elif isinstance(variable, pybamm.Concatenation):\n                children = variable.children\n                meshes = OrderedDict()\n                for child in children:\n                    meshes[child] = [\n                        self.spatial_methods[dom].mesh[dom] for dom in child.domain\n                    ]\n                sec_points = len(list(meshes.values())[0][0])\n                for i in range(sec_points):\n                    for child, mesh in meshes.items():\n                        for domain_mesh in mesh:\n                            submesh = domain_mesh[i]\n                            end += submesh.npts_for_broadcast\n                        y_slices[child.id].append(slice(start, end))\n                        start = end\n            else:\n                for dom in variable.domain:\n                    for submesh in self.spatial_methods[dom].mesh[dom]:\n                        end += submesh.npts_for_broadcast\n                y_slices[variable.id].append(slice(start, end))\n                start = end\n\n        self.y_slices = y_slices\n\n        # reset discretised_symbols\n        self._discretised_symbols = {}",
  "def set_internal_boundary_conditions(self, model):\n        \"\"\"\n        A method to set the internal boundary conditions for the submodel.\n        These are required to properly calculate the gradient.\n        Note: this method modifies the state of self.boundary_conditions.\n        \"\"\"\n\n        def boundary_gradient(left_symbol, right_symbol):\n\n            pybamm.logger.debug(\n                \"Calculate boundary gradient ({} and {})\".format(\n                    left_symbol, right_symbol\n                )\n            )\n            left_domain = left_symbol.domain[0]\n            right_domain = right_symbol.domain[0]\n\n            left_mesh = self.spatial_methods[left_domain].mesh[left_domain]\n            right_mesh = self.spatial_methods[right_domain].mesh[right_domain]\n\n            left_symbol_disc = self.process_symbol(left_symbol)\n            right_symbol_disc = self.process_symbol(right_symbol)\n\n            return self.spatial_methods[left_domain].internal_neumann_condition(\n                left_symbol_disc, right_symbol_disc, left_mesh, right_mesh\n            )\n\n        # bc_key_ids = [key.id for key in list(model.boundary_conditions.keys())]\n        bc_key_ids = list(self.bcs.keys())\n\n        internal_bcs = {}\n        for var in model.boundary_conditions.keys():\n            if isinstance(var, pybamm.Concatenation):\n                children = var.children\n\n                first_child = children[0]\n                first_orphan = first_child.new_copy()\n                next_child = children[1]\n                next_orphan = next_child.new_copy()\n\n                lbc = self.bcs[var.id][\"left\"]\n                rbc = (boundary_gradient(first_orphan, next_orphan), \"Neumann\")\n\n                if first_child.id not in bc_key_ids:\n                    internal_bcs.update({first_child.id: {\"left\": lbc, \"right\": rbc}})\n\n                for i, _ in enumerate(children[1:-1]):\n                    current_child = next_child\n                    current_orphan = next_orphan\n                    next_child = children[i + 2]\n                    next_orphan = next_child.new_copy()\n\n                    lbc = rbc\n                    rbc = (boundary_gradient(current_orphan, next_orphan), \"Neumann\")\n                    if current_child.id not in bc_key_ids:\n                        internal_bcs.update(\n                            {current_child.id: {\"left\": lbc, \"right\": rbc}}\n                        )\n\n                lbc = rbc\n                rbc = self.bcs[var.id][\"right\"]\n                if children[-1].id not in bc_key_ids:\n                    internal_bcs.update({children[-1].id: {\"left\": lbc, \"right\": rbc}})\n\n        self.bcs.update(internal_bcs)",
  "def process_initial_conditions(self, model):\n        \"\"\"Discretise model initial_conditions.\n\n        Parameters\n        ----------\n        model : :class:`pybamm.BaseModel`\n            Model to dicretise. Must have attributes rhs, initial_conditions and\n            boundary_conditions (all dicts of {variable: equation})\n\n        Returns\n        -------\n        tuple\n            Tuple of processed_initial_conditions (dict of initial conditions) and\n            concatenated_initial_conditions (numpy array of concatenated initial\n            conditions)\n\n        \"\"\"\n        # Discretise initial conditions\n        processed_initial_conditions = self.process_dict(model.initial_conditions)\n\n        # Concatenate initial conditions into a single vector\n        # check that all initial conditions are set\n        processed_concatenated_initial_conditions = self._concatenate_in_order(\n            processed_initial_conditions, check_complete=True\n        ).evaluate(0, None)\n\n        return processed_initial_conditions, processed_concatenated_initial_conditions",
  "def process_boundary_conditions(self, model):\n        \"\"\"Discretise model boundary_conditions, also converting keys to ids\n\n        Parameters\n        ----------\n        model : :class:`pybamm.BaseModel`\n            Model to dicretise. Must have attributes rhs, initial_conditions and\n            boundary_conditions (all dicts of {variable: equation})\n\n        Returns\n        -------\n        dict\n            Dictionary of processed boundary conditions\n\n        \"\"\"\n\n        processed_bcs = {}\n\n        # process and set pybamm.variables first incase required\n        # in discrisation of other boundary conditions\n        for key, bcs in model.boundary_conditions.items():\n            processed_bcs[key.id] = {}\n\n            # Handle any boundary conditions applied on the tabs\n            if any(\"tab\" in side for side in list(bcs.keys())):\n                bcs = self.check_tab_conditions(key, bcs)\n\n            # Process boundary conditions\n            for side, bc in bcs.items():\n                eqn, typ = bc\n                pybamm.logger.debug(\"Discretise {} ({} bc)\".format(key, side))\n                processed_eqn = self.process_symbol(eqn)\n                processed_bcs[key.id][side] = (processed_eqn, typ)\n\n        return processed_bcs",
  "def check_tab_conditions(self, symbol, bcs):\n        \"\"\"\n        Check any boundary conditions applied on \"negative tab\", \"positive tab\"\n        and \"no tab\". For 1D current collector meshes, these conditions are\n        converted into boundary conditions on \"left\" (tab at z=0) or \"right\"\n        (tab at z=l_z) depending on the tab location stored in the mesh. For 2D\n        current collector meshes, the boundary conditions can be applied on the\n        tabs directly.\n\n        Parameters\n        ----------\n        symbol : :class:`pybamm.expression_tree.symbol.Symbol`\n            The symbol on which the boundary conditions are applied.\n        bcs : dict\n            The dictionary of boundary conditions (a dict of {side: equation}).\n\n        Returns\n        -------\n        dict\n            The dictionary of boundary conditions, with the keys changed to\n            \"left\" and \"right\" where necessary.\n\n        \"\"\"\n        # Check symbol domain\n        domain = symbol.domain[0]\n        mesh = self.mesh[domain][0]\n\n        if domain != \"current collector\":\n            raise pybamm.ModelError(\n                \"\"\"Boundary conditions can only be applied on the tabs in the domain\n            'current collector', but {} has domain {}\"\"\".format(\n                    symbol, domain\n                )\n            )\n\n        # Replace keys with \"left\" and \"right\" as appropriate for 1D meshes\n        if isinstance(mesh, pybamm.SubMesh1D):\n            # replace negative and/or positive tab\n            for tab in [\"negative tab\", \"positive tab\"]:\n                if any(tab in side for side in list(bcs.keys())):\n                    bcs[mesh.tabs[tab]] = bcs.pop(tab)\n            # replace no tab\n            if any(\"no tab\" in side for side in list(bcs.keys())):\n                if \"left\" in list(bcs.keys()):\n                    bcs[\"right\"] = bcs.pop(\"no tab\")  # tab at bottom\n                else:\n                    bcs[\"left\"] = bcs.pop(\"no tab\")  # tab at top\n\n        return bcs",
  "def process_rhs_and_algebraic(self, model):\n        \"\"\"Discretise model equations - differential ('rhs') and algebraic.\n\n        Parameters\n        ----------\n        model : :class:`pybamm.BaseModel`\n            Model to dicretise. Must have attributes rhs, initial_conditions and\n            boundary_conditions (all dicts of {variable: equation})\n\n        Returns\n        -------\n        tuple\n            Tuple of processed_rhs (dict of processed differential equations),\n            processed_concatenated_rhs, processed_algebraic (dict of processed algebraic\n            equations) and processed_concatenated_algebraic\n\n        \"\"\"\n        # Discretise right-hand sides, passing domain from variable\n        processed_rhs = self.process_dict(model.rhs)\n\n        # Concatenate rhs into a single state vector\n        # Need to concatenate in order as the ordering of equations could be different\n        # in processed_rhs and model.rhs\n        processed_concatenated_rhs = self._concatenate_in_order(processed_rhs)\n\n        # Discretise and concatenate algebraic equations\n        processed_algebraic = self.process_dict(model.algebraic)\n\n        # Concatenate algebraic into a single state vector\n        # Need to concatenate in order as the ordering of equations could be different\n        # in processed_algebraic and model.algebraic\n        processed_concatenated_algebraic = self._concatenate_in_order(\n            processed_algebraic\n        )\n\n        return (\n            processed_rhs,\n            processed_concatenated_rhs,\n            processed_algebraic,\n            processed_concatenated_algebraic,\n        )",
  "def create_mass_matrix(self, model):\n        \"\"\"Creates mass matrix of the discretised model.\n        Note that the model is assumed to be of the form M*y_dot = f(t,y), where\n        M is the (possibly singular) mass matrix.\n\n        Parameters\n        ----------\n        model : :class:`pybamm.BaseModel`\n            Discretised model. Must have attributes rhs, initial_conditions and\n            boundary_conditions (all dicts of {variable: equation})\n\n        Returns\n        -------\n        :class:`pybamm.Matrix`\n            The mass matrix\n        \"\"\"\n        # Create list of mass matrices for each equation to be put into block\n        # diagonal mass matrix for the model\n        mass_list = []\n\n        # get a list of model rhs variables that are sorted according to\n        # where they are in the state vector\n        model_variables = model.rhs.keys()\n        model_slices = []\n        for v in model_variables:\n            if isinstance(v, pybamm.Concatenation):\n                model_slices.append(\n                    slice(\n                        self.y_slices[v.children[0].id][0].start,\n                        self.y_slices[v.children[-1].id][0].stop,\n                    )\n                )\n            else:\n                model_slices.append(self.y_slices[v.id][0])\n        sorted_model_variables = [\n            v for _, v in sorted(zip(model_slices, model_variables))\n        ]\n\n        # Process mass matrices for the differential equations\n        for var in sorted_model_variables:\n            if var.domain == []:\n                # If variable domain empty then mass matrix is just 1\n                mass_list.append(1.0)\n            else:\n                mass_list.append(\n                    self.spatial_methods[var.domain[0]]\n                    .mass_matrix(var, self.bcs)\n                    .entries\n                )\n\n        # Create lumped mass matrix (of zeros) of the correct shape for the\n        # discretised algebraic equations\n        if model.algebraic.keys():\n            mass_algebraic_size = model.concatenated_algebraic.shape[0]\n            mass_algebraic = csr_matrix((mass_algebraic_size, mass_algebraic_size))\n            mass_list.append(mass_algebraic)\n\n        # Create block diagonal (sparse) mass matrix\n        mass_matrix = block_diag(mass_list, format=\"csr\")\n\n        return pybamm.Matrix(mass_matrix)",
  "def create_jacobian(self, model):\n        \"\"\"Creates Jacobian of the discretised model.\n        Note that the model is assumed to be of the form M*y_dot = f(t,y), where\n        M is the (possibly singular) mass matrix. The Jacobian is df/dy.\n\n        Note: At present, calculation of the Jacobian is deferred until after\n        simplification, since it is much faster to compute the Jacobian of the\n        simplified model. However, in some use cases (e.g. running the same\n        model multiple times but with different parameters) it may be more\n        efficient to compute the Jacobian once, before simplification, so that\n        parameters in the Jacobian can be updated (see PR #670).\n\n        Parameters\n        ----------\n        model : :class:`pybamm.BaseModel`\n            Discretised model. Must have attributes rhs, initial_conditions and\n            boundary_conditions (all dicts of {variable: equation})\n\n        Returns\n        -------\n        :class:`pybamm.Concatenation`\n            The expression trees corresponding to the Jacobian of the model\n        \"\"\"\n        # create state vector to differentiate with respect to\n        y = pybamm.StateVector(slice(0, np.size(model.concatenated_initial_conditions)))\n        # set up Jacobian object, for re-use of dict\n        jacobian = pybamm.Jacobian()\n\n        # calculate Jacobian of rhs by equation\n        jac_rhs_eqn_dict = {}\n        for eqn_key, eqn in model.rhs.items():\n            pybamm.logger.debug(\n                \"Calculating block of Jacobian for {!r}\".format(eqn_key.name)\n            )\n            jac_rhs_eqn_dict[eqn_key] = jacobian.jac(eqn, y)\n        jac_rhs = self._concatenate_in_order(jac_rhs_eqn_dict, sparse=True)\n\n        # calculate Jacobian of algebraic by equation\n        jac_algebraic_eqn_dict = {}\n        for eqn_key, eqn in model.algebraic.items():\n            pybamm.logger.debug(\n                \"Calculating block of Jacobian for {!r}\".format(eqn_key.name)\n            )\n            jac_algebraic_eqn_dict[eqn_key] = jacobian.jac(eqn, y)\n        jac_algebraic = self._concatenate_in_order(jac_algebraic_eqn_dict, sparse=True)\n\n        # full Jacobian\n        if model.rhs.keys() and model.algebraic.keys():\n            jac = pybamm.SparseStack(jac_rhs, jac_algebraic)\n        elif not model.algebraic.keys():\n            jac = jac_rhs\n        else:\n            jac = jac_algebraic\n\n        return jac, jac_rhs, jac_algebraic",
  "def process_dict(self, var_eqn_dict):\n        \"\"\"Discretise a dictionary of {variable: equation}, broadcasting if necessary\n        (can be model.rhs, model.algebraic, model.initial_conditions or\n        model.variables).\n\n        Parameters\n        ----------\n        var_eqn_dict : dict\n            Equations ({variable: equation} dict) to dicretise\n            (can be model.rhs, model.algebraic, model.initial_conditions or\n            model.variables)\n\n        Returns\n        -------\n        new_var_eqn_dict : dict\n            Discretised equations\n\n        \"\"\"\n        new_var_eqn_dict = {}\n        for eqn_key, eqn in var_eqn_dict.items():\n            # Broadcast if the equation evaluates to a number(e.g. Scalar)\n            if eqn.evaluates_to_number() and not isinstance(eqn_key, str):\n                eqn = pybamm.Broadcast(eqn, eqn_key.domain)\n\n            # note we are sending in the key.id here so we don't have to\n            # keep calling .id\n            pybamm.logger.debug(\"Discretise {!r}\".format(eqn_key))\n\n            new_var_eqn_dict[eqn_key] = self.process_symbol(eqn)\n\n        return new_var_eqn_dict",
  "def process_symbol(self, symbol):\n        \"\"\"Discretise operators in model equations.\n        If a symbol has already been discretised, the stored value is returned.\n\n        Parameters\n        ----------\n        symbol : :class:`pybamm.expression_tree.symbol.Symbol`\n            Symbol to discretise\n\n        Returns\n        -------\n        :class:`pybamm.expression_tree.symbol.Symbol`\n            Discretised symbol\n\n        \"\"\"\n        try:\n            return self._discretised_symbols[symbol.id]\n        except KeyError:\n            discretised_symbol = self._process_symbol(symbol)\n            self._discretised_symbols[symbol.id] = discretised_symbol\n            discretised_symbol.test_shape()\n            return discretised_symbol",
  "def _process_symbol(self, symbol):\n        \"\"\" See :meth:`Discretisation.process_symbol()`. \"\"\"\n\n        if symbol.domain != []:\n            spatial_method = self.spatial_methods[symbol.domain[0]]\n            # If boundary conditions are provided, need to check for BCs on tabs\n            if self.bcs:\n                key_id = list(self.bcs.keys())[0]\n                if any(\"tab\" in side for side in list(self.bcs[key_id].keys())):\n                    self.bcs[key_id] = self.check_tab_conditions(\n                        symbol, self.bcs[key_id]\n                    )\n\n        if isinstance(symbol, pybamm.BinaryOperator):\n            # Pre-process children\n            left, right = symbol.children\n            disc_left = self.process_symbol(left)\n            disc_right = self.process_symbol(right)\n            if symbol.domain == []:\n                return symbol.__class__(disc_left, disc_right)\n            else:\n                return spatial_method.process_binary_operators(\n                    symbol, left, right, disc_left, disc_right\n                )\n\n        elif isinstance(symbol, pybamm.UnaryOperator):\n            child = symbol.child\n            disc_child = self.process_symbol(child)\n            if child.domain != []:\n                child_spatial_method = self.spatial_methods[child.domain[0]]\n\n            if isinstance(symbol, pybamm.Gradient):\n                return child_spatial_method.gradient(child, disc_child, self.bcs)\n\n            elif isinstance(symbol, pybamm.Divergence):\n                return child_spatial_method.divergence(child, disc_child, self.bcs)\n\n            elif isinstance(symbol, pybamm.Laplacian):\n                return child_spatial_method.laplacian(child, disc_child, self.bcs)\n\n            elif isinstance(symbol, pybamm.Gradient_Squared):\n                return child_spatial_method.gradient_squared(\n                    child, disc_child, self.bcs\n                )\n\n            elif isinstance(symbol, pybamm.Mass):\n                return child_spatial_method.mass_matrix(child, self.bcs)\n\n            elif isinstance(symbol, pybamm.BoundaryMass):\n                return child_spatial_method.boundary_mass_matrix(child, self.bcs)\n\n            elif isinstance(symbol, pybamm.IndefiniteIntegral):\n                return child_spatial_method.indefinite_integral(child, disc_child)\n\n            elif isinstance(symbol, pybamm.Integral):\n                out = child_spatial_method.integral(child, disc_child)\n                out.domain = symbol.domain\n                out.auxiliary_domains = symbol.auxiliary_domains\n                return out\n\n            elif isinstance(symbol, pybamm.DefiniteIntegralVector):\n                return child_spatial_method.definite_integral_matrix(\n                    child.domain, vector_type=symbol.vector_type\n                )\n\n            elif isinstance(symbol, pybamm.BoundaryIntegral):\n                return child_spatial_method.boundary_integral(\n                    child, disc_child, symbol.region\n                )\n\n            elif isinstance(symbol, pybamm.Broadcast):\n                # Broadcast new_child to the domain specified by symbol.domain\n                # Different discretisations may broadcast differently\n                if symbol.domain == []:\n                    symbol = disc_child * pybamm.Vector(np.array([1]))\n                else:\n                    symbol = spatial_method.broadcast(\n                        disc_child,\n                        symbol.domain,\n                        symbol.auxiliary_domains,\n                        symbol.broadcast_type,\n                    )\n                return symbol\n\n            elif isinstance(symbol, pybamm.DeltaFunction):\n                return spatial_method.delta_function(symbol, disc_child)\n\n            elif isinstance(symbol, pybamm.BoundaryOperator):\n                # if boundary operator applied on \"negative tab\" or\n                # \"positive tab\" *and* the mesh is 1D then change side to\n                # \"left\" or \"right\" as appropriate\n                if symbol.side in [\"negative tab\", \"positive tab\"]:\n                    mesh = self.mesh[symbol.children[0].domain[0]][0]\n                    if isinstance(mesh, pybamm.SubMesh1D):\n                        symbol.side = mesh.tabs[symbol.side]\n                return child_spatial_method.boundary_value_or_flux(symbol, disc_child)\n\n            else:\n                return symbol._unary_new_copy(disc_child)\n\n        elif isinstance(symbol, pybamm.Function):\n            disc_children = [self.process_symbol(child) for child in symbol.children]\n            return symbol._function_new_copy(disc_children)\n\n        elif isinstance(symbol, pybamm.Variable):\n            return pybamm.StateVector(\n                *self.y_slices[symbol.id],\n                domain=symbol.domain,\n                auxiliary_domains=symbol.auxiliary_domains\n            )\n\n        elif isinstance(symbol, pybamm.SpatialVariable):\n            return spatial_method.spatial_variable(symbol)\n\n        elif isinstance(symbol, pybamm.Concatenation):\n            new_children = [self.process_symbol(child) for child in symbol.children]\n            new_symbol = spatial_method.concatenation(new_children)\n\n            return new_symbol\n\n        else:\n            # Backup option: return new copy of the object\n            try:\n                return symbol.new_copy()\n            except NotImplementedError:\n                raise NotImplementedError(\n                    \"Cannot discretise symbol of type '{}'\".format(type(symbol))\n                )",
  "def concatenate(self, *symbols, sparse=False):\n        if sparse:\n            return pybamm.SparseStack(*symbols)\n        else:\n            return pybamm.NumpyConcatenation(*symbols)",
  "def _concatenate_in_order(self, var_eqn_dict, check_complete=False, sparse=False):\n        \"\"\"\n        Concatenate a dictionary of {variable: equation} using self.y_slices\n\n        The keys/variables in `var_eqn_dict` must be the same as the ids in\n        `self.y_slices`.\n        The resultant concatenation is ordered according to the ordering of the slice\n        values in `self.y_slices`\n\n        Parameters\n        ----------\n        var_eqn_dict : dict\n            Equations ({variable: equation} dict) to dicretise\n        check_complete : bool, optional\n            Whether to check keys in var_eqn_dict against self.y_slices. Default\n            is False\n        sparse : bool, optional\n            If True the concatenation will be a :class:`pybamm.SparseStack`. If\n            False the concatenation will be a :class:`pybamm.NumpyConcatenation`.\n            Default is False\n\n        Returns\n        -------\n        var_eqn_dict : dict\n            Discretised right-hand side equations\n\n        \"\"\"\n        # Unpack symbols in variables that are concatenations of variables\n        unpacked_variables = []\n        slices = []\n        for symbol in var_eqn_dict.keys():\n            if isinstance(symbol, pybamm.Concatenation):\n                unpacked_variables.extend([var for var in symbol.children])\n                # must append the slice for the whole concatenation, so that equations\n                # get sorted correctly\n                slices.append(\n                    slice(\n                        self.y_slices[symbol.children[0].id][0].start,\n                        self.y_slices[symbol.children[-1].id][0].stop,\n                    )\n                )\n            else:\n                unpacked_variables.append(symbol)\n                slices.append(self.y_slices[symbol.id][0])\n\n        if check_complete:\n            # Check keys from the given var_eqn_dict against self.y_slices\n            ids = {v.id for v in unpacked_variables}\n            if ids != self.y_slices.keys():\n                given_variable_names = [v.name for v in var_eqn_dict.keys()]\n                raise pybamm.ModelError(\n                    \"Initial conditions are insufficient. Only \"\n                    \"provided for {} \".format(given_variable_names)\n                )\n\n        equations = list(var_eqn_dict.values())\n\n        # sort equations according to slices\n        sorted_equations = [eq for _, eq in sorted(zip(slices, equations))]\n\n        return self.concatenate(*sorted_equations, sparse=sparse)",
  "def check_model(self, model):\n        \"\"\" Perform some basic checks to make sure the discretised model makes sense.\"\"\"\n        self.check_initial_conditions(model)\n        self.check_initial_conditions_rhs(model)\n        self.check_variables(model)",
  "def check_initial_conditions(self, model):\n        \"\"\"Check initial conditions are a numpy array\"\"\"\n        # Individual\n        for var, eqn in model.initial_conditions.items():\n            assert type(eqn.evaluate(0, None)) is np.ndarray, pybamm.ModelError(\n                \"\"\"\n                initial_conditions must be numpy array after discretisation but they are\n                {} for variable '{}'.\n                \"\"\".format(\n                    type(eqn.evaluate(0, None)), var\n                )\n            )\n        # Concatenated\n        assert (\n            type(model.concatenated_initial_conditions) is np.ndarray\n        ), pybamm.ModelError(\n            \"\"\"\n            Concatenated initial_conditions must be numpy array after discretisation but\n            they are {}.\n            \"\"\".format(\n                type(model.concatenated_initial_conditions)\n            )\n        )",
  "def check_initial_conditions_rhs(self, model):\n        \"\"\"Check initial conditions and rhs have the same shape\"\"\"\n        y0 = model.concatenated_initial_conditions\n        # Individual\n        for var in model.rhs.keys():\n            assert (\n                model.rhs[var].shape == model.initial_conditions[var].shape\n            ), pybamm.ModelError(\n                \"\"\"\n                rhs and initial_conditions must have the same shape after discretisation\n                but rhs.shape = {} and initial_conditions.shape = {} for variable '{}'.\n                \"\"\".format(\n                    model.rhs[var].shape, model.initial_conditions[var].shape, var\n                )\n            )\n        # Concatenated\n        assert (\n            model.concatenated_rhs.shape[0] + model.concatenated_algebraic.shape[0]\n            == y0.shape[0]\n        ), pybamm.ModelError(\n            \"\"\"\n            Concatenation of (rhs, algebraic) and initial_conditions must have the\n            same shape after discretisation but rhs.shape = {}, algebraic.shape = {},\n            and initial_conditions.shape = {}.\n            \"\"\".format(\n                model.concatenated_rhs.shape,\n                model.concatenated_algebraic.shape,\n                y0.shape,\n            )\n        )",
  "def check_variables(self, model):\n        \"\"\"\n        Check variables in variable list against rhs\n        Be lenient with size check if the variable in model.variables is broadcasted, or\n        a concatenation, or an outer product\n        (if broadcasted, variable is a multiplication with a vector of ones)\n        \"\"\"\n        for rhs_var in model.rhs.keys():\n            if rhs_var.name in model.variables.keys():\n                var = model.variables[rhs_var.name]\n\n                different_shapes = not np.array_equal(\n                    model.rhs[rhs_var].shape, var.shape\n                )\n\n                not_concatenation = not isinstance(var, pybamm.Concatenation)\n                not_outer = not isinstance(var, pybamm.Outer)\n\n                not_mult_by_one_vec = not (\n                    isinstance(var, pybamm.Multiplication)\n                    and isinstance(var.right, pybamm.Vector)\n                    and np.all(var.right.entries == 1)\n                )\n\n                if (\n                    different_shapes\n                    and not_concatenation\n                    and not_outer\n                    and not_mult_by_one_vec\n                ):\n                    raise pybamm.ModelError(\n                        \"\"\"\n                    variable and its eqn must have the same shape after discretisation\n                    but variable.shape = {} and rhs.shape = {} for variable '{}'.\n                    \"\"\".format(\n                            var.shape, model.rhs[rhs_var].shape, var\n                        )\n                    )",
  "def boundary_gradient(left_symbol, right_symbol):\n\n            pybamm.logger.debug(\n                \"Calculate boundary gradient ({} and {})\".format(\n                    left_symbol, right_symbol\n                )\n            )\n            left_domain = left_symbol.domain[0]\n            right_domain = right_symbol.domain[0]\n\n            left_mesh = self.spatial_methods[left_domain].mesh[left_domain]\n            right_mesh = self.spatial_methods[right_domain].mesh[right_domain]\n\n            left_symbol_disc = self.process_symbol(left_symbol)\n            right_symbol_disc = self.process_symbol(right_symbol)\n\n            return self.spatial_methods[left_domain].internal_neumann_condition(\n                left_symbol_disc, right_symbol_disc, left_mesh, right_mesh\n            )",
  "class BaseModel(object):\n    \"\"\"Base model class for other models to extend.\n\n    Attributes\n    ----------\n\n    name: str\n        A string giving the name of the model\n    options: dict\n        A dictionary of options to be passed to the model\n    rhs: dict\n        A dictionary that maps expressions (variables) to expressions that represent\n        the rhs\n    algebraic: dict\n        A dictionary that maps expressions (variables) to expressions that represent\n        the algebraic equations. The algebraic expressions are assumed to equate\n        to zero. Note that all the variables in the model must exist in the keys of\n        `rhs` or `algebraic`.\n    initial_conditions: dict\n        A dictionary that maps expressions (variables) to expressions that represent\n        the initial conditions for the state variables y. The initial conditions for\n        algebraic variables are provided as initial guesses to a root finding algorithm\n        that calculates consistent initial conditions.\n    boundary_conditions: dict\n        A dictionary that maps expressions (variables) to expressions that represent\n        the boundary conditions\n    variables: dict\n        A dictionary that maps strings to expressions that represent\n        the useful variables\n    events: list\n        A list of events that should cause the solver to terminate (e.g. concentration\n        goes negative)\n    concatenated_rhs : :class:`pybamm.Concatenation`\n        After discretisation, contains the expressions representing the rhs equations\n        concatenated into a single expression\n    concatenated_algebraic : :class:`pybamm.Concatenation`\n        After discretisation, contains the expressions representing the algebraic\n        equations concatenated into a single expression\n    concatenated_initial_conditions : :class:`numpy.array`\n        After discretisation, contains the vector of initial conditions\n    mass_matrix : :class:`pybamm.Matrix`\n        After discretisation, contains the mass matrix for the model. This is computed\n        automatically\n    jacobian : :class:`pybamm.Concatenation`\n        Contains the Jacobian for the model. If model.use_jacobian is True, the\n        Jacobian is computed automatically during solver set up\n    jacobian_rhs : :class:`pybamm.Concatenation`\n        Contains the Jacobian for the part of the model which contains time derivatives.\n        If model.use_jacobian is True, the Jacobian is computed automatically during\n        solver set up\n    jacobian_algebraic : :class:`pybamm.Concatenation`\n        Contains the Jacobian for the algebraic part of the model. This may be used\n        by the solver when calculating consistent initial conditions. If\n        model.use_jacobian is True, the Jacobian is computed automatically during\n        solver set up\n    use_jacobian : bool\n        Whether to use the Jacobian when solving the model (default is True)\n    use_simplify : bool\n        Whether to simplify the expression tress representing the rhs and\n        algebraic equations, Jacobain (if using) and events, before solving the\n        model (default is True)\n    use_to_python : bool\n        Whether to convert the expression tress representing the rhs and\n        algebraic equations, Jacobain (if using) and events into pure python code\n        that will calculate the result of calling `evaluate(t, y)` on the given\n        expression tree (default is True)\n    \"\"\"\n\n    def __init__(self, name=\"Unnamed model\"):\n        self.name = name\n        self.options = {}\n\n        # Initialise empty model\n        self._rhs = {}\n        self._algebraic = {}\n        self._initial_conditions = {}\n        self._boundary_conditions = {}\n        self._variables = {}\n        self._events = {}\n        self._concatenated_rhs = None\n        self._concatenated_algebraic = None\n        self._concatenated_initial_conditions = None\n        self._mass_matrix = None\n        self._jacobian = None\n        self._jacobian_algebraic = None\n\n        # Default behaviour is to use the jacobian and simplify\n        self.use_jacobian = True\n        self.use_simplify = True\n        self.use_to_python = True\n\n    def _set_dictionary(self, dict, name):\n        \"\"\"\n        Convert any scalar equations in dict to 'pybamm.Scalar'\n        and check that domains are consistent\n        \"\"\"\n        # Convert any numbers to a pybamm.Scalar\n        for var, eqn in dict.items():\n            if isinstance(eqn, numbers.Number):\n                dict[var] = pybamm.Scalar(eqn)\n\n        if not all(\n            [\n                variable.domain == equation.domain\n                or variable.domain == []\n                or equation.domain == []\n                for variable, equation in dict.items()\n            ]\n        ):\n            raise pybamm.DomainError(\n                \"variable and equation in '{}' must have the same domain\".format(name)\n            )\n\n        return dict\n\n    @property\n    def name(self):\n        return self._name\n\n    @name.setter\n    def name(self, value):\n        self._name = value\n\n    @property\n    def rhs(self):\n        return self._rhs\n\n    @rhs.setter\n    def rhs(self, rhs):\n        self._rhs = self._set_dictionary(rhs, \"rhs\")\n\n    @property\n    def algebraic(self):\n        return self._algebraic\n\n    @algebraic.setter\n    def algebraic(self, algebraic):\n        self._algebraic = self._set_dictionary(algebraic, \"algebraic\")\n\n    @property\n    def initial_conditions(self):\n        return self._initial_conditions\n\n    @initial_conditions.setter\n    def initial_conditions(self, initial_conditions):\n        self._initial_conditions = self._set_dictionary(\n            initial_conditions, \"initial_conditions\"\n        )\n\n    @property\n    def boundary_conditions(self):\n        return self._boundary_conditions\n\n    @boundary_conditions.setter\n    def boundary_conditions(self, boundary_conditions):\n        # Convert any numbers to a pybamm.Scalar\n        for var, bcs in boundary_conditions.items():\n            for side, bc in bcs.items():\n                if isinstance(bc[0], numbers.Number):\n                    # typ is the type of the bc, e.g. \"Dirichlet\" or \"Neumann\"\n                    eqn, typ = boundary_conditions[var][side]\n                    boundary_conditions[var][side] = (pybamm.Scalar(eqn), typ)\n                # Check types\n                if bc[1] not in [\"Dirichlet\", \"Neumann\"]:\n                    raise pybamm.ModelError(\n                        \"\"\"\n                        boundary condition types must be Dirichlet or Neumann, not '{}'\n                        \"\"\".format(\n                            bc[1]\n                        )\n                    )\n        self._boundary_conditions = boundary_conditions\n\n    @property\n    def variables(self):\n        return self._variables\n\n    @variables.setter\n    def variables(self, variables):\n        self._variables = variables\n\n    @property\n    def events(self):\n        return self._events\n\n    @events.setter\n    def events(self, events):\n        self._events = events\n\n    @property\n    def concatenated_rhs(self):\n        return self._concatenated_rhs\n\n    @concatenated_rhs.setter\n    def concatenated_rhs(self, concatenated_rhs):\n        self._concatenated_rhs = concatenated_rhs\n\n    @property\n    def concatenated_algebraic(self):\n        return self._concatenated_algebraic\n\n    @concatenated_algebraic.setter\n    def concatenated_algebraic(self, concatenated_algebraic):\n        self._concatenated_algebraic = concatenated_algebraic\n\n    @property\n    def concatenated_initial_conditions(self):\n        return self._concatenated_initial_conditions\n\n    @concatenated_initial_conditions.setter\n    def concatenated_initial_conditions(self, concatenated_initial_conditions):\n        self._concatenated_initial_conditions = concatenated_initial_conditions\n\n    @property\n    def mass_matrix(self):\n        return self._mass_matrix\n\n    @mass_matrix.setter\n    def mass_matrix(self, mass_matrix):\n        self._mass_matrix = mass_matrix\n\n    @property\n    def jacobian(self):\n        return self._jacobian\n\n    @jacobian.setter\n    def jacobian(self, jacobian):\n        self._jacobian = jacobian\n\n    @property\n    def jacobian_rhs(self):\n        return self._jacobian_rhs\n\n    @jacobian_rhs.setter\n    def jacobian_rhs(self, jacobian_rhs):\n        self._jacobian_rhs = jacobian_rhs\n\n    @property\n    def jacobian_algebraic(self):\n        return self._jacobian_algebraic\n\n    @jacobian_algebraic.setter\n    def jacobian_algebraic(self, jacobian_algebraic):\n        self._jacobian_algebraic = jacobian_algebraic\n\n    @property\n    def set_of_parameters(self):\n        return self._set_of_parameters\n\n    @property\n    def options(self):\n        return self._options\n\n    @options.setter\n    def options(self, options):\n        self._options = options\n\n    def __getitem__(self, key):\n        return self.rhs[key]\n\n    def update(self, *submodels):\n        \"\"\"\n        Update model to add new physics from submodels\n\n        Parameters\n        ----------\n        submodel : iterable of :class:`pybamm.BaseModel`\n            The submodels from which to create new model\n        \"\"\"\n        for submodel in submodels:\n\n            # check and then update dicts\n            self.check_and_combine_dict(self._rhs, submodel.rhs)\n            self.check_and_combine_dict(self._algebraic, submodel.algebraic)\n            self.check_and_combine_dict(\n                self._initial_conditions, submodel.initial_conditions\n            )\n            self.check_and_combine_dict(\n                self._boundary_conditions, submodel.boundary_conditions\n            )\n            self.variables.update(submodel.variables)  # keys are strings so no check\n            self._events.update(submodel.events)\n\n    def check_and_combine_dict(self, dict1, dict2):\n        # check that the key ids are distinct\n        ids1 = set(x.id for x in dict1.keys())\n        ids2 = set(x.id for x in dict2.keys())\n        if len(ids1.intersection(ids2)) != 0:\n            raise pybamm.ModelError(\"Submodel incompatible: duplicate variables\")\n        dict1.update(dict2)\n\n    def check_well_posedness(self, post_discretisation=False):\n        \"\"\"\n        Check that the model is well-posed by executing the following tests:\n        - Model is not over- or underdetermined, by comparing keys and equations in rhs\n        and algebraic. Overdetermined if more equations than variables, underdetermined\n        if more variables than equations.\n        - There is an initial condition in self.initial_conditions for each\n        variable/equation pair in self.rhs\n        - There are appropriate boundary conditions in self.boundary_conditions for each\n        variable/equation pair in self.rhs and self.algebraic\n\n        Parameters\n        ----------\n        post_discretisation : boolean\n            A flag indicating tests to be skipped after discretisation\n        \"\"\"\n        self.check_well_determined(post_discretisation)\n        self.check_algebraic_equations(post_discretisation)\n        self.check_ics_bcs()\n        self.check_default_variables_dictionaries()\n        # Can't check variables after discretising, since Variable objects get replaced\n        # by StateVector objects\n        # Checking variables is slow, so only do it in debug mode\n        if pybamm.settings.debug_mode is True and post_discretisation is False:\n            self.check_variables()\n\n    def check_well_determined(self, post_discretisation):\n        \"\"\" Check that the model is not under- or over-determined. \"\"\"\n        # Equations (differential and algebraic)\n        # Get all the variables from differential and algebraic equations\n        vars_in_rhs_keys = set()\n        vars_in_algebraic_keys = set()\n        vars_in_eqns = set()\n        # Get all variables ids from rhs and algebraic keys and equations\n        # For equations we look through the whole expression tree.\n        # \"Variables\" can be Concatenations so we also have to look in the whole\n        # expression tree\n        for var, eqn in self.rhs.items():\n            vars_in_rhs_keys.update(\n                [x.id for x in var.pre_order() if isinstance(x, pybamm.Variable)]\n            )\n            vars_in_eqns.update(\n                [x.id for x in eqn.pre_order() if isinstance(x, pybamm.Variable)]\n            )\n        for var, eqn in self.algebraic.items():\n            vars_in_algebraic_keys.update(\n                [x.id for x in var.pre_order() if isinstance(x, pybamm.Variable)]\n            )\n            vars_in_eqns.update(\n                [x.id for x in eqn.pre_order() if isinstance(x, pybamm.Variable)]\n            )\n        # If any keys are repeated between rhs and algebraic then the model is\n        # overdetermined\n        if not set(vars_in_rhs_keys).isdisjoint(vars_in_algebraic_keys):\n            raise pybamm.ModelError(\"model is overdetermined (repeated keys)\")\n        # If any algebraic keys don't appear in the eqns then the model is\n        # overdetermined (but rhs keys can be absent from the eqns, e.g. dcdt = -1 is\n        # fine)\n        # Skip this step after discretisation, as any variables in the equations will\n        # have been discretised to slices but keys will still be variables\n        extra_algebraic_keys = vars_in_algebraic_keys.difference(vars_in_eqns)\n        if extra_algebraic_keys and not post_discretisation:\n            raise pybamm.ModelError(\"model is overdetermined (extra algebraic keys)\")\n        # If any variables in the equations don't appear in the keys then the model is\n        # underdetermined\n        vars_in_keys = vars_in_rhs_keys.union(vars_in_algebraic_keys)\n        extra_variables = vars_in_eqns.difference(vars_in_keys)\n        if extra_variables:\n            raise pybamm.ModelError(\"model is underdetermined (too many variables)\")\n\n    def check_algebraic_equations(self, post_discretisation):\n        \"\"\"\n        Check that the algebraic equations are well-posed.\n        Before discretisation, each algebraic equation key must appear in the equation\n        After discretisation, there must be at least one StateVector in each algebraic\n        equation\n        \"\"\"\n        if not post_discretisation:\n            # After the model has been defined, each algebraic equation key should\n            # appear in that algebraic equation\n            # this has been relaxed for concatenations for now\n            for var, eqn in self.algebraic.items():\n                if not any(x.id == var.id for x in eqn.pre_order()) and not isinstance(\n                    var, pybamm.Concatenation\n                ):\n                    raise pybamm.ModelError(\n                        \"each variable in the algebraic eqn keys must appear in the eqn\"\n                    )\n        else:\n            # variables in keys don't get discretised so they will no longer match\n            # with the state vectors in the algebraic equations. Instead, we check\n            # that each algebraic equation contains some StateVector\n            for eqn in self.algebraic.values():\n                if not any(isinstance(x, pybamm.StateVector) for x in eqn.pre_order()):\n                    raise pybamm.ModelError(\n                        \"each algebraic equation must contain at least one StateVector\"\n                    )\n\n    def check_ics_bcs(self):\n        \"\"\" Check that the initial and boundary conditions are well-posed. \"\"\"\n        # Initial conditions\n        for var in self.rhs.keys():\n            if var not in self.initial_conditions.keys():\n                raise pybamm.ModelError(\n                    \"\"\"no initial condition given for variable '{}'\"\"\".format(var)\n                )\n\n        # Boundary conditions\n        for var, eqn in {**self.rhs, **self.algebraic}.items():\n            if eqn.has_symbol_of_classes(\n                (pybamm.Gradient, pybamm.Divergence)\n            ) and not eqn.has_symbol_of_classes(pybamm.Integral):\n                # I have relaxed this check for now so that the lumped temperature\n                # equation doesn't raise errors (this has and average in it)\n\n                # Variable must be in the boundary conditions\n                if not any(\n                    var.id == x.id\n                    for symbol in self.boundary_conditions.keys()\n                    for x in symbol.pre_order()\n                ):\n                    raise pybamm.ModelError(\n                        \"\"\"\n                        no boundary condition given for\n                        variable '{}' with equation '{}'.\n                        \"\"\".format(\n                            var, eqn\n                        )\n                    )\n\n    def check_default_variables_dictionaries(self):\n        \"\"\" Chec that the right variables are provided. \"\"\"\n        missing_vars = []\n        for output, expression in self._variables.items():\n            if expression is None:\n                missing_vars.append(output)\n        if len(missing_vars) > 0:\n            warnings.warn(\n                \"the standard output variable(s) '{}' have not been supplied. \"\n                \"These may be required for testing or comparison with other \"\n                \"models.\".format(missing_vars),\n                pybamm.ModelWarning,\n                stacklevel=2,\n            )\n            # Remove missing entries\n            for output in missing_vars:\n                del self._variables[output]\n\n    def check_variables(self):\n        # Create list of all Variable nodes that appear in the model's list of variables\n        all_vars = {}\n        for eqn in self.variables.values():\n            # Add all variables in the equation to the list of variables\n            all_vars.update(\n                {x.id: x for x in eqn.pre_order() if isinstance(x, pybamm.Variable)}\n            )\n        var_ids_in_keys = set()\n        for var in {**self.rhs, **self.algebraic}.keys():\n            if isinstance(var, pybamm.Variable):\n                var_ids_in_keys.add(var.id)\n            # Key can be a concatenation\n            elif isinstance(var, pybamm.Concatenation):\n                var_ids_in_keys.update([child.id for child in var.children])\n        for var_id, var in all_vars.items():\n            if var_id not in var_ids_in_keys:\n                raise pybamm.ModelError(\n                    \"\"\"\n                    No key set for variable '{}'. Make sure it is included in either\n                    model.rhs or model.algebraic in an unmodified form (e.g. not\n                    Broadcasted)\n                    \"\"\".format(\n                        var\n                    )\n                )",
  "def __init__(self, name=\"Unnamed model\"):\n        self.name = name\n        self.options = {}\n\n        # Initialise empty model\n        self._rhs = {}\n        self._algebraic = {}\n        self._initial_conditions = {}\n        self._boundary_conditions = {}\n        self._variables = {}\n        self._events = {}\n        self._concatenated_rhs = None\n        self._concatenated_algebraic = None\n        self._concatenated_initial_conditions = None\n        self._mass_matrix = None\n        self._jacobian = None\n        self._jacobian_algebraic = None\n\n        # Default behaviour is to use the jacobian and simplify\n        self.use_jacobian = True\n        self.use_simplify = True\n        self.use_to_python = True",
  "def _set_dictionary(self, dict, name):\n        \"\"\"\n        Convert any scalar equations in dict to 'pybamm.Scalar'\n        and check that domains are consistent\n        \"\"\"\n        # Convert any numbers to a pybamm.Scalar\n        for var, eqn in dict.items():\n            if isinstance(eqn, numbers.Number):\n                dict[var] = pybamm.Scalar(eqn)\n\n        if not all(\n            [\n                variable.domain == equation.domain\n                or variable.domain == []\n                or equation.domain == []\n                for variable, equation in dict.items()\n            ]\n        ):\n            raise pybamm.DomainError(\n                \"variable and equation in '{}' must have the same domain\".format(name)\n            )\n\n        return dict",
  "def name(self):\n        return self._name",
  "def name(self, value):\n        self._name = value",
  "def rhs(self):\n        return self._rhs",
  "def rhs(self, rhs):\n        self._rhs = self._set_dictionary(rhs, \"rhs\")",
  "def algebraic(self):\n        return self._algebraic",
  "def algebraic(self, algebraic):\n        self._algebraic = self._set_dictionary(algebraic, \"algebraic\")",
  "def initial_conditions(self):\n        return self._initial_conditions",
  "def initial_conditions(self, initial_conditions):\n        self._initial_conditions = self._set_dictionary(\n            initial_conditions, \"initial_conditions\"\n        )",
  "def boundary_conditions(self):\n        return self._boundary_conditions",
  "def boundary_conditions(self, boundary_conditions):\n        # Convert any numbers to a pybamm.Scalar\n        for var, bcs in boundary_conditions.items():\n            for side, bc in bcs.items():\n                if isinstance(bc[0], numbers.Number):\n                    # typ is the type of the bc, e.g. \"Dirichlet\" or \"Neumann\"\n                    eqn, typ = boundary_conditions[var][side]\n                    boundary_conditions[var][side] = (pybamm.Scalar(eqn), typ)\n                # Check types\n                if bc[1] not in [\"Dirichlet\", \"Neumann\"]:\n                    raise pybamm.ModelError(\n                        \"\"\"\n                        boundary condition types must be Dirichlet or Neumann, not '{}'\n                        \"\"\".format(\n                            bc[1]\n                        )\n                    )\n        self._boundary_conditions = boundary_conditions",
  "def variables(self):\n        return self._variables",
  "def variables(self, variables):\n        self._variables = variables",
  "def events(self):\n        return self._events",
  "def events(self, events):\n        self._events = events",
  "def concatenated_rhs(self):\n        return self._concatenated_rhs",
  "def concatenated_rhs(self, concatenated_rhs):\n        self._concatenated_rhs = concatenated_rhs",
  "def concatenated_algebraic(self):\n        return self._concatenated_algebraic",
  "def concatenated_algebraic(self, concatenated_algebraic):\n        self._concatenated_algebraic = concatenated_algebraic",
  "def concatenated_initial_conditions(self):\n        return self._concatenated_initial_conditions",
  "def concatenated_initial_conditions(self, concatenated_initial_conditions):\n        self._concatenated_initial_conditions = concatenated_initial_conditions",
  "def mass_matrix(self):\n        return self._mass_matrix",
  "def mass_matrix(self, mass_matrix):\n        self._mass_matrix = mass_matrix",
  "def jacobian(self):\n        return self._jacobian",
  "def jacobian(self, jacobian):\n        self._jacobian = jacobian",
  "def jacobian_rhs(self):\n        return self._jacobian_rhs",
  "def jacobian_rhs(self, jacobian_rhs):\n        self._jacobian_rhs = jacobian_rhs",
  "def jacobian_algebraic(self):\n        return self._jacobian_algebraic",
  "def jacobian_algebraic(self, jacobian_algebraic):\n        self._jacobian_algebraic = jacobian_algebraic",
  "def set_of_parameters(self):\n        return self._set_of_parameters",
  "def options(self):\n        return self._options",
  "def options(self, options):\n        self._options = options",
  "def __getitem__(self, key):\n        return self.rhs[key]",
  "def update(self, *submodels):\n        \"\"\"\n        Update model to add new physics from submodels\n\n        Parameters\n        ----------\n        submodel : iterable of :class:`pybamm.BaseModel`\n            The submodels from which to create new model\n        \"\"\"\n        for submodel in submodels:\n\n            # check and then update dicts\n            self.check_and_combine_dict(self._rhs, submodel.rhs)\n            self.check_and_combine_dict(self._algebraic, submodel.algebraic)\n            self.check_and_combine_dict(\n                self._initial_conditions, submodel.initial_conditions\n            )\n            self.check_and_combine_dict(\n                self._boundary_conditions, submodel.boundary_conditions\n            )\n            self.variables.update(submodel.variables)  # keys are strings so no check\n            self._events.update(submodel.events)",
  "def check_and_combine_dict(self, dict1, dict2):\n        # check that the key ids are distinct\n        ids1 = set(x.id for x in dict1.keys())\n        ids2 = set(x.id for x in dict2.keys())\n        if len(ids1.intersection(ids2)) != 0:\n            raise pybamm.ModelError(\"Submodel incompatible: duplicate variables\")\n        dict1.update(dict2)",
  "def check_well_posedness(self, post_discretisation=False):\n        \"\"\"\n        Check that the model is well-posed by executing the following tests:\n        - Model is not over- or underdetermined, by comparing keys and equations in rhs\n        and algebraic. Overdetermined if more equations than variables, underdetermined\n        if more variables than equations.\n        - There is an initial condition in self.initial_conditions for each\n        variable/equation pair in self.rhs\n        - There are appropriate boundary conditions in self.boundary_conditions for each\n        variable/equation pair in self.rhs and self.algebraic\n\n        Parameters\n        ----------\n        post_discretisation : boolean\n            A flag indicating tests to be skipped after discretisation\n        \"\"\"\n        self.check_well_determined(post_discretisation)\n        self.check_algebraic_equations(post_discretisation)\n        self.check_ics_bcs()\n        self.check_default_variables_dictionaries()\n        # Can't check variables after discretising, since Variable objects get replaced\n        # by StateVector objects\n        # Checking variables is slow, so only do it in debug mode\n        if pybamm.settings.debug_mode is True and post_discretisation is False:\n            self.check_variables()",
  "def check_well_determined(self, post_discretisation):\n        \"\"\" Check that the model is not under- or over-determined. \"\"\"\n        # Equations (differential and algebraic)\n        # Get all the variables from differential and algebraic equations\n        vars_in_rhs_keys = set()\n        vars_in_algebraic_keys = set()\n        vars_in_eqns = set()\n        # Get all variables ids from rhs and algebraic keys and equations\n        # For equations we look through the whole expression tree.\n        # \"Variables\" can be Concatenations so we also have to look in the whole\n        # expression tree\n        for var, eqn in self.rhs.items():\n            vars_in_rhs_keys.update(\n                [x.id for x in var.pre_order() if isinstance(x, pybamm.Variable)]\n            )\n            vars_in_eqns.update(\n                [x.id for x in eqn.pre_order() if isinstance(x, pybamm.Variable)]\n            )\n        for var, eqn in self.algebraic.items():\n            vars_in_algebraic_keys.update(\n                [x.id for x in var.pre_order() if isinstance(x, pybamm.Variable)]\n            )\n            vars_in_eqns.update(\n                [x.id for x in eqn.pre_order() if isinstance(x, pybamm.Variable)]\n            )\n        # If any keys are repeated between rhs and algebraic then the model is\n        # overdetermined\n        if not set(vars_in_rhs_keys).isdisjoint(vars_in_algebraic_keys):\n            raise pybamm.ModelError(\"model is overdetermined (repeated keys)\")\n        # If any algebraic keys don't appear in the eqns then the model is\n        # overdetermined (but rhs keys can be absent from the eqns, e.g. dcdt = -1 is\n        # fine)\n        # Skip this step after discretisation, as any variables in the equations will\n        # have been discretised to slices but keys will still be variables\n        extra_algebraic_keys = vars_in_algebraic_keys.difference(vars_in_eqns)\n        if extra_algebraic_keys and not post_discretisation:\n            raise pybamm.ModelError(\"model is overdetermined (extra algebraic keys)\")\n        # If any variables in the equations don't appear in the keys then the model is\n        # underdetermined\n        vars_in_keys = vars_in_rhs_keys.union(vars_in_algebraic_keys)\n        extra_variables = vars_in_eqns.difference(vars_in_keys)\n        if extra_variables:\n            raise pybamm.ModelError(\"model is underdetermined (too many variables)\")",
  "def check_algebraic_equations(self, post_discretisation):\n        \"\"\"\n        Check that the algebraic equations are well-posed.\n        Before discretisation, each algebraic equation key must appear in the equation\n        After discretisation, there must be at least one StateVector in each algebraic\n        equation\n        \"\"\"\n        if not post_discretisation:\n            # After the model has been defined, each algebraic equation key should\n            # appear in that algebraic equation\n            # this has been relaxed for concatenations for now\n            for var, eqn in self.algebraic.items():\n                if not any(x.id == var.id for x in eqn.pre_order()) and not isinstance(\n                    var, pybamm.Concatenation\n                ):\n                    raise pybamm.ModelError(\n                        \"each variable in the algebraic eqn keys must appear in the eqn\"\n                    )\n        else:\n            # variables in keys don't get discretised so they will no longer match\n            # with the state vectors in the algebraic equations. Instead, we check\n            # that each algebraic equation contains some StateVector\n            for eqn in self.algebraic.values():\n                if not any(isinstance(x, pybamm.StateVector) for x in eqn.pre_order()):\n                    raise pybamm.ModelError(\n                        \"each algebraic equation must contain at least one StateVector\"\n                    )",
  "def check_ics_bcs(self):\n        \"\"\" Check that the initial and boundary conditions are well-posed. \"\"\"\n        # Initial conditions\n        for var in self.rhs.keys():\n            if var not in self.initial_conditions.keys():\n                raise pybamm.ModelError(\n                    \"\"\"no initial condition given for variable '{}'\"\"\".format(var)\n                )\n\n        # Boundary conditions\n        for var, eqn in {**self.rhs, **self.algebraic}.items():\n            if eqn.has_symbol_of_classes(\n                (pybamm.Gradient, pybamm.Divergence)\n            ) and not eqn.has_symbol_of_classes(pybamm.Integral):\n                # I have relaxed this check for now so that the lumped temperature\n                # equation doesn't raise errors (this has and average in it)\n\n                # Variable must be in the boundary conditions\n                if not any(\n                    var.id == x.id\n                    for symbol in self.boundary_conditions.keys()\n                    for x in symbol.pre_order()\n                ):\n                    raise pybamm.ModelError(\n                        \"\"\"\n                        no boundary condition given for\n                        variable '{}' with equation '{}'.\n                        \"\"\".format(\n                            var, eqn\n                        )\n                    )",
  "def check_default_variables_dictionaries(self):\n        \"\"\" Chec that the right variables are provided. \"\"\"\n        missing_vars = []\n        for output, expression in self._variables.items():\n            if expression is None:\n                missing_vars.append(output)\n        if len(missing_vars) > 0:\n            warnings.warn(\n                \"the standard output variable(s) '{}' have not been supplied. \"\n                \"These may be required for testing or comparison with other \"\n                \"models.\".format(missing_vars),\n                pybamm.ModelWarning,\n                stacklevel=2,\n            )\n            # Remove missing entries\n            for output in missing_vars:\n                del self._variables[output]",
  "def check_variables(self):\n        # Create list of all Variable nodes that appear in the model's list of variables\n        all_vars = {}\n        for eqn in self.variables.values():\n            # Add all variables in the equation to the list of variables\n            all_vars.update(\n                {x.id: x for x in eqn.pre_order() if isinstance(x, pybamm.Variable)}\n            )\n        var_ids_in_keys = set()\n        for var in {**self.rhs, **self.algebraic}.keys():\n            if isinstance(var, pybamm.Variable):\n                var_ids_in_keys.add(var.id)\n            # Key can be a concatenation\n            elif isinstance(var, pybamm.Concatenation):\n                var_ids_in_keys.update([child.id for child in var.children])\n        for var_id, var in all_vars.items():\n            if var_id not in var_ids_in_keys:\n                raise pybamm.ModelError(\n                    \"\"\"\n                    No key set for variable '{}'. Make sure it is included in either\n                    model.rhs or model.algebraic in an unmodified form (e.g. not\n                    Broadcasted)\n                    \"\"\".format(\n                        var\n                    )\n                )",
  "class BaseSubModel:\n    \"\"\"\n    The base class for all submodels. All submodels inherit from this class and must\n    only provide public methods which overwrite those in this base class. Any methods\n    added to a submodel that do not overwrite those in this bass class are made\n    private with the prefix '_', providing a consistent public interface for all\n    submodels.\n\n    Parameters\n    ----------\n    param: parameter class\n        The model parameter symbols\n\n    Attributes\n    ----------\n    param: parameter class\n        The model parameter symbols\n    rhs: dict\n        A dictionary that maps expressions (variables) to expressions that represent\n        the rhs\n    algebraic: dict\n        A dictionary that maps expressions (variables) to expressions that represent\n        the algebraic equations. The algebraic expressions are assumed to equate\n        to zero. Note that all the variables in the model must exist in the keys of\n        `rhs` or `algebraic`.\n    initial_conditions: dict\n        A dictionary that maps expressions (variables) to expressions that represent\n        the initial conditions for the state variables y. The initial conditions for\n        algebraic variables are provided as initial guesses to a root finding algorithm\n        that calculates consistent initial conditions.\n    boundary_conditions: dict\n        A dictionary that maps expressions (variables) to expressions that represent\n        the boundary conditions\n    variables: dict\n        A dictionary that maps strings to expressions that represent\n        the useful variables\n    events: dict\n        A dictionary of events that should cause the solver to terminate (e.g.\n        concentration goes negative). The keys are strings and the values are\n        symbols.\n    \"\"\"\n\n    def __init__(self, param, domain=None, reactions=None):\n        super().__init__()\n        self.param = param\n        # Initialise empty variables (to avoid overwriting with 'None')\n\n        self.rhs = {}\n        self.algebraic = {}\n        self.boundary_conditions = {}\n        self.initial_conditions = {}\n        self.variables = {}\n        self.events = {}\n\n        self.domain = domain\n        self.set_domain_for_broadcast()\n        self.reactions = reactions\n\n    @property\n    def domain(self):\n        return self._domain\n\n    @domain.setter\n    def domain(self, domain):\n        if domain in [\"Negative\", \"Separator\", \"Positive\"]:\n            self._domain = domain\n        elif domain is None:\n            pass\n        else:\n            raise pybamm.DomainError(\n                \"Domain must be either 'Negative' or 'Positive' not {}\".format(domain)\n            )\n\n    def set_domain_for_broadcast(self):\n        if hasattr(self, \"_domain\"):\n            if self.domain in [\"Negative\", \"Positive\"]:\n                self.domain_for_broadcast = self.domain.lower() + \" electrode\"\n            elif self.domain == \"Separator\":\n                self.domain_for_broadcast = \"separator\"\n\n    def get_fundamental_variables(self):\n        \"\"\"\n        A public method that creates and returns the variables in a submodel which can\n        be created independent of other submodels. For example, the electrolyte\n        concentration variables can be created independent of whether any other\n        variables have been defined in the model. As a rule, if a variable can be\n        created without variables from other submodels, then it should be placed in\n        this method.\n\n        Returns\n        -------\n        dict :\n            The variables created by the submodel which are independent of variables in\n            other submodels.\n        \"\"\"\n        return {}\n\n    def get_coupled_variables(self, variables):\n        \"\"\"\n        A public method that creates and returns the variables in a submodel which\n        require variables in other submodels to be set first. For example, the\n        exchange current density requires the concentration in the electrolyte to\n        be created before it can be created. If a variable can be created independent\n        of other submodels then it should be created in 'get_fundamental_variables'\n        instead of this method.\n\n        Parameters\n        ----------\n        variables: dict\n            The variables in the whole model.\n\n        Returns\n        -------\n        dict :\n            The variables created in this submodel which depend on variables in\n            other submodels.\n        \"\"\"\n        return {}\n\n    def set_rhs(self, variables):\n        \"\"\"\n        A method to set the right hand side of the differential equations which contain\n        a time derivative. Note: this method modifies the state of self.rhs. Unless\n        overwritten by a submodel, the default behaviour of 'pass' is used as\n        implemented in :class:`pybamm.BaseSubModel`.\n\n        Parameters\n        ----------\n        variables: dict\n            The variables in the whole model.\n        \"\"\"\n        pass\n\n    def set_algebraic(self, variables):\n        \"\"\"\n        A method to set the differential equations which do not contain a time\n        derivative. Note: this method modifies the state of self.algebraic. Unless\n        overwritten by a submodel, the default behaviour of 'pass' is used as\n        implemented in :class:`pybamm.BaseSubModel`.\n\n        Parameters\n        ----------\n        variables: dict\n            The variables in the whole model.\n        \"\"\"\n        pass\n\n    def set_boundary_conditions(self, variables):\n        \"\"\"\n        A method to set the boundary conditions for the submodel. Note: this method\n        modifies the state of self.boundary_conditions. Unless overwritten by a\n        submodel, the default behaviour of 'pass' is used a implemented in\n        :class:`pybamm.BaseSubModel`.\n\n        Parameters\n        ----------\n        variables: dict\n            The variables in the whole model.\n        \"\"\"\n        pass\n\n    def set_initial_conditions(self, variables):\n        \"\"\"\n        A method to set the initial conditions for the submodel. Note: this method\n        modifies the state of self.initial_conditions. Unless overwritten by a\n        submodel, the default behaviour of 'pass' is used a implemented in\n        :class:`pybamm.BaseSubModel`.\n\n\n        Parameters\n        ----------\n        variables: dict\n            The variables in the whole model.\n        \"\"\"\n        pass\n\n    def set_events(self, variables):\n        \"\"\"\n        A method to set events related to the state of submodel variable. Note: this\n        method modifies the state of self.events. Unless overwritten by a submodel, the\n        default behaviour of 'pass' is used a implemented in\n        :class:`pybamm.BaseSubModel`.\n\n        Parameters\n        ----------\n        variables: dict\n            The variables in the whole model.\n        \"\"\"\n        pass",
  "def __init__(self, param, domain=None, reactions=None):\n        super().__init__()\n        self.param = param\n        # Initialise empty variables (to avoid overwriting with 'None')\n\n        self.rhs = {}\n        self.algebraic = {}\n        self.boundary_conditions = {}\n        self.initial_conditions = {}\n        self.variables = {}\n        self.events = {}\n\n        self.domain = domain\n        self.set_domain_for_broadcast()\n        self.reactions = reactions",
  "def domain(self):\n        return self._domain",
  "def domain(self, domain):\n        if domain in [\"Negative\", \"Separator\", \"Positive\"]:\n            self._domain = domain\n        elif domain is None:\n            pass\n        else:\n            raise pybamm.DomainError(\n                \"Domain must be either 'Negative' or 'Positive' not {}\".format(domain)\n            )",
  "def set_domain_for_broadcast(self):\n        if hasattr(self, \"_domain\"):\n            if self.domain in [\"Negative\", \"Positive\"]:\n                self.domain_for_broadcast = self.domain.lower() + \" electrode\"\n            elif self.domain == \"Separator\":\n                self.domain_for_broadcast = \"separator\"",
  "def get_fundamental_variables(self):\n        \"\"\"\n        A public method that creates and returns the variables in a submodel which can\n        be created independent of other submodels. For example, the electrolyte\n        concentration variables can be created independent of whether any other\n        variables have been defined in the model. As a rule, if a variable can be\n        created without variables from other submodels, then it should be placed in\n        this method.\n\n        Returns\n        -------\n        dict :\n            The variables created by the submodel which are independent of variables in\n            other submodels.\n        \"\"\"\n        return {}",
  "def get_coupled_variables(self, variables):\n        \"\"\"\n        A public method that creates and returns the variables in a submodel which\n        require variables in other submodels to be set first. For example, the\n        exchange current density requires the concentration in the electrolyte to\n        be created before it can be created. If a variable can be created independent\n        of other submodels then it should be created in 'get_fundamental_variables'\n        instead of this method.\n\n        Parameters\n        ----------\n        variables: dict\n            The variables in the whole model.\n\n        Returns\n        -------\n        dict :\n            The variables created in this submodel which depend on variables in\n            other submodels.\n        \"\"\"\n        return {}",
  "def set_rhs(self, variables):\n        \"\"\"\n        A method to set the right hand side of the differential equations which contain\n        a time derivative. Note: this method modifies the state of self.rhs. Unless\n        overwritten by a submodel, the default behaviour of 'pass' is used as\n        implemented in :class:`pybamm.BaseSubModel`.\n\n        Parameters\n        ----------\n        variables: dict\n            The variables in the whole model.\n        \"\"\"\n        pass",
  "def set_algebraic(self, variables):\n        \"\"\"\n        A method to set the differential equations which do not contain a time\n        derivative. Note: this method modifies the state of self.algebraic. Unless\n        overwritten by a submodel, the default behaviour of 'pass' is used as\n        implemented in :class:`pybamm.BaseSubModel`.\n\n        Parameters\n        ----------\n        variables: dict\n            The variables in the whole model.\n        \"\"\"\n        pass",
  "def set_boundary_conditions(self, variables):\n        \"\"\"\n        A method to set the boundary conditions for the submodel. Note: this method\n        modifies the state of self.boundary_conditions. Unless overwritten by a\n        submodel, the default behaviour of 'pass' is used a implemented in\n        :class:`pybamm.BaseSubModel`.\n\n        Parameters\n        ----------\n        variables: dict\n            The variables in the whole model.\n        \"\"\"\n        pass",
  "def set_initial_conditions(self, variables):\n        \"\"\"\n        A method to set the initial conditions for the submodel. Note: this method\n        modifies the state of self.initial_conditions. Unless overwritten by a\n        submodel, the default behaviour of 'pass' is used a implemented in\n        :class:`pybamm.BaseSubModel`.\n\n\n        Parameters\n        ----------\n        variables: dict\n            The variables in the whole model.\n        \"\"\"\n        pass",
  "def set_events(self, variables):\n        \"\"\"\n        A method to set events related to the state of submodel variable. Note: this\n        method modifies the state of self.events. Unless overwritten by a submodel, the\n        default behaviour of 'pass' is used a implemented in\n        :class:`pybamm.BaseSubModel`.\n\n        Parameters\n        ----------\n        variables: dict\n            The variables in the whole model.\n        \"\"\"\n        pass",
  "class FirstOrder(BaseModel):\n    \"\"\"Class for conservation of mass of oxygen. (First-order refers to first-order\n    expansion in asymptotic methods)\n    In this model, extremely fast oxygen kinetics in the negative electrode imposes\n    zero oxygen concentration there, and so the oxygen variable only lives in the\n    separator and positive electrode. The boundary condition at the negative electrode/\n    separator interface is homogeneous Dirichlet.\n\n    Parameters\n    ----------\n    param : parameter class\n        The parameters to use for this submodel\n    reactions : dict\n        Dictionary of reaction terms\n\n    **Extends:** :class:`pybamm.oxygen_diffusion.BaseModel`\n    \"\"\"\n\n    def __init__(self, param, reactions):\n        super().__init__(param, reactions)\n\n    def get_coupled_variables(self, variables):\n\n        param = self.param\n        l_n = param.l_n\n        l_s = param.l_s\n        l_p = param.l_p\n        x_s = pybamm.standard_spatial_vars.x_s\n        x_p = pybamm.standard_spatial_vars.x_p\n\n        # Unpack\n        eps_s_0_av = variables[\"Leading-order x-averaged separator porosity\"]\n        eps_p_0_av = variables[\"Leading-order x-averaged positive electrode porosity\"]\n\n        # Diffusivities\n        D_ox_s = (eps_s_0_av ** param.b_s) * param.curlyD_ox\n        D_ox_p = (eps_p_0_av ** param.b_p) * param.curlyD_ox\n\n        # Reactions\n        sj_ox_p = sum(\n            reaction[\"Positive\"][\"s_ox\"]\n            * variables[\n                \"Leading-order x-averaged \" + reaction[\"Positive\"][\"aj\"].lower()\n            ]\n            for reaction in self.reactions.values()\n        )\n\n        # Fluxes\n        N_ox_n_1 = pybamm.FullBroadcast(0, \"negative electrode\", \"current collector\")\n        N_ox_s_1 = -pybamm.PrimaryBroadcast(sj_ox_p * l_p, \"separator\")\n        N_ox_p_1 = pybamm.outer(sj_ox_p, x_p - 1)\n\n        # Concentrations\n        c_ox_n_1 = pybamm.FullBroadcast(0, \"negative electrode\", \"current collector\")\n        c_ox_s_1 = pybamm.outer(sj_ox_p * l_p / D_ox_s, x_s - l_n)\n        c_ox_p_1 = pybamm.outer(\n            -sj_ox_p / (2 * D_ox_p), (x_p - 1) ** 2 - l_p ** 2\n        ) + pybamm.PrimaryBroadcast(sj_ox_p * l_p * l_s / D_ox_s, \"positive electrode\")\n\n        # Update variables\n        c_ox = pybamm.Concatenation(\n            param.C_e * c_ox_n_1, param.C_e * c_ox_s_1, param.C_e * c_ox_p_1\n        )\n        variables.update(self._get_standard_concentration_variables(c_ox))\n\n        N_ox = pybamm.Concatenation(\n            param.C_e * N_ox_n_1, param.C_e * N_ox_s_1, param.C_e * N_ox_p_1\n        )\n        variables.update(self._get_standard_flux_variables(N_ox))\n\n        return variables",
  "def __init__(self, param, reactions):\n        super().__init__(param, reactions)",
  "def get_coupled_variables(self, variables):\n\n        param = self.param\n        l_n = param.l_n\n        l_s = param.l_s\n        l_p = param.l_p\n        x_s = pybamm.standard_spatial_vars.x_s\n        x_p = pybamm.standard_spatial_vars.x_p\n\n        # Unpack\n        eps_s_0_av = variables[\"Leading-order x-averaged separator porosity\"]\n        eps_p_0_av = variables[\"Leading-order x-averaged positive electrode porosity\"]\n\n        # Diffusivities\n        D_ox_s = (eps_s_0_av ** param.b_s) * param.curlyD_ox\n        D_ox_p = (eps_p_0_av ** param.b_p) * param.curlyD_ox\n\n        # Reactions\n        sj_ox_p = sum(\n            reaction[\"Positive\"][\"s_ox\"]\n            * variables[\n                \"Leading-order x-averaged \" + reaction[\"Positive\"][\"aj\"].lower()\n            ]\n            for reaction in self.reactions.values()\n        )\n\n        # Fluxes\n        N_ox_n_1 = pybamm.FullBroadcast(0, \"negative electrode\", \"current collector\")\n        N_ox_s_1 = -pybamm.PrimaryBroadcast(sj_ox_p * l_p, \"separator\")\n        N_ox_p_1 = pybamm.outer(sj_ox_p, x_p - 1)\n\n        # Concentrations\n        c_ox_n_1 = pybamm.FullBroadcast(0, \"negative electrode\", \"current collector\")\n        c_ox_s_1 = pybamm.outer(sj_ox_p * l_p / D_ox_s, x_s - l_n)\n        c_ox_p_1 = pybamm.outer(\n            -sj_ox_p / (2 * D_ox_p), (x_p - 1) ** 2 - l_p ** 2\n        ) + pybamm.PrimaryBroadcast(sj_ox_p * l_p * l_s / D_ox_s, \"positive electrode\")\n\n        # Update variables\n        c_ox = pybamm.Concatenation(\n            param.C_e * c_ox_n_1, param.C_e * c_ox_s_1, param.C_e * c_ox_p_1\n        )\n        variables.update(self._get_standard_concentration_variables(c_ox))\n\n        N_ox = pybamm.Concatenation(\n            param.C_e * N_ox_n_1, param.C_e * N_ox_s_1, param.C_e * N_ox_p_1\n        )\n        variables.update(self._get_standard_flux_variables(N_ox))\n\n        return variables",
  "class Composite(Full):\n    \"\"\"Class for conservation of mass of oxygen. (Composite refers to composite\n    expansion in asymptotic methods)\n    In this model, extremely fast oxygen kinetics in the negative electrode imposes\n    zero oxygen concentration there, and so the oxygen variable only lives in the\n    separator and positive electrode. The boundary condition at the negative electrode/\n    separator interface is homogeneous Dirichlet.\n\n    Parameters\n    ----------\n    param : parameter class\n        The parameters to use for this submodel\n    reactions : dict\n        Dictionary of reaction terms\n    extended : bool\n        Whether to include feedback from the first-order terms\n\n    **Extends:** :class:`pybamm.oxygen_diffusion.Full`\n    \"\"\"\n\n    def __init__(self, param, reactions, extended=False):\n        super().__init__(param, reactions)\n        self.extended = extended\n\n    def get_coupled_variables(self, variables):\n\n        eps_0 = separator_and_positive_only(variables[\"Leading-order porosity\"])\n        c_ox = variables[\"Separator and positive electrode oxygen concentration\"]\n        # TODO: allow charge and convection?\n        # v_box = pybamm.Scalar(0)\n\n        param = self.param\n\n        b = pybamm.Concatenation(\n            pybamm.FullBroadcast(param.b_s, [\"separator\"], \"current collector\"),\n            pybamm.FullBroadcast(\n                param.b_p, [\"positive electrode\"], \"current collector\"\n            ),\n        )\n\n        N_ox_diffusion = -(eps_0 ** b) * param.curlyD_ox * pybamm.grad(c_ox)\n\n        N_ox = N_ox_diffusion  # + c_ox * v_box\n        # Flux in the negative electrode is zero\n        N_ox = pybamm.Concatenation(\n            pybamm.FullBroadcast(0, \"negative electrode\", \"current collector\"), N_ox\n        )\n\n        variables.update(self._get_standard_flux_variables(N_ox))\n\n        return variables\n\n    def set_rhs(self, variables):\n        \"Composite reaction-diffusion with source terms from leading order\"\n\n        param = self.param\n\n        eps_0 = separator_and_positive_only(variables[\"Leading-order porosity\"])\n        deps_0_dt = separator_and_positive_only(\n            variables[\"Leading-order porosity change\"]\n        )\n        c_ox = variables[\"Separator and positive electrode oxygen concentration\"]\n        N_ox = variables[\"Oxygen flux\"].orphans[1]\n\n        if self.extended is False:\n            pos_reactions = sum(\n                reaction[\"Positive\"][\"s_ox\"]\n                * variables[\"Leading-order \" + reaction[\"Positive\"][\"aj\"].lower()]\n                for reaction in self.reactions.values()\n            )\n        else:\n            pos_reactions = sum(\n                reaction[\"Positive\"][\"s_ox\"] * variables[reaction[\"Positive\"][\"aj\"]]\n                for reaction in self.reactions.values()\n            )\n        sep_reactions = pybamm.FullBroadcast(0, \"separator\", \"current collector\")\n        source_terms_0 = (\n            pybamm.Concatenation(sep_reactions, pos_reactions) / param.gamma_e\n        )\n\n        self.rhs = {\n            c_ox: (1 / eps_0)\n            * (-pybamm.div(N_ox) / param.C_e + source_terms_0 - c_ox * deps_0_dt)\n        }",
  "def __init__(self, param, reactions, extended=False):\n        super().__init__(param, reactions)\n        self.extended = extended",
  "def get_coupled_variables(self, variables):\n\n        eps_0 = separator_and_positive_only(variables[\"Leading-order porosity\"])\n        c_ox = variables[\"Separator and positive electrode oxygen concentration\"]\n        # TODO: allow charge and convection?\n        # v_box = pybamm.Scalar(0)\n\n        param = self.param\n\n        b = pybamm.Concatenation(\n            pybamm.FullBroadcast(param.b_s, [\"separator\"], \"current collector\"),\n            pybamm.FullBroadcast(\n                param.b_p, [\"positive electrode\"], \"current collector\"\n            ),\n        )\n\n        N_ox_diffusion = -(eps_0 ** b) * param.curlyD_ox * pybamm.grad(c_ox)\n\n        N_ox = N_ox_diffusion  # + c_ox * v_box\n        # Flux in the negative electrode is zero\n        N_ox = pybamm.Concatenation(\n            pybamm.FullBroadcast(0, \"negative electrode\", \"current collector\"), N_ox\n        )\n\n        variables.update(self._get_standard_flux_variables(N_ox))\n\n        return variables",
  "def set_rhs(self, variables):\n        \"Composite reaction-diffusion with source terms from leading order\"\n\n        param = self.param\n\n        eps_0 = separator_and_positive_only(variables[\"Leading-order porosity\"])\n        deps_0_dt = separator_and_positive_only(\n            variables[\"Leading-order porosity change\"]\n        )\n        c_ox = variables[\"Separator and positive electrode oxygen concentration\"]\n        N_ox = variables[\"Oxygen flux\"].orphans[1]\n\n        if self.extended is False:\n            pos_reactions = sum(\n                reaction[\"Positive\"][\"s_ox\"]\n                * variables[\"Leading-order \" + reaction[\"Positive\"][\"aj\"].lower()]\n                for reaction in self.reactions.values()\n            )\n        else:\n            pos_reactions = sum(\n                reaction[\"Positive\"][\"s_ox\"] * variables[reaction[\"Positive\"][\"aj\"]]\n                for reaction in self.reactions.values()\n            )\n        sep_reactions = pybamm.FullBroadcast(0, \"separator\", \"current collector\")\n        source_terms_0 = (\n            pybamm.Concatenation(sep_reactions, pos_reactions) / param.gamma_e\n        )\n\n        self.rhs = {\n            c_ox: (1 / eps_0)\n            * (-pybamm.div(N_ox) / param.C_e + source_terms_0 - c_ox * deps_0_dt)\n        }",
  "class BaseModel(pybamm.BaseSubModel):\n    \"\"\"Base class for conservation of mass of oxygen.\n\n    Parameters\n    ----------\n    param : parameter class\n        The parameters to use for this submodel\n    reactions : dict, optional\n        Dictionary of reaction terms\n\n    **Extends:** :class:`pybamm.BaseSubModel`\n    \"\"\"\n\n    def __init__(self, param, reactions=None):\n        super().__init__(param, reactions=reactions)\n\n    def _get_standard_concentration_variables(self, c_ox):\n        \"\"\"\n        A private function to obtain the standard variables which\n        can be derived from the concentration of oxygen.\n\n        Parameters\n        ----------\n        c_ox : :class:`pybamm.Symbol`\n            The concentration of oxygen.\n        c_ox_av : :class:`pybamm.Symbol`\n            The cell-averaged concentration of oxygen.\n\n        Returns\n        -------\n        variables : dict\n            The variables which can be derived from the concentration in the\n            oxygen.\n        \"\"\"\n\n        c_ox_av = pybamm.x_average(c_ox)\n        c_ox_typ = self.param.c_ox_typ\n        c_ox_n, c_ox_s, c_ox_p = c_ox.orphans\n\n        variables = {\n            \"Oxygen concentration\": c_ox,\n            \"Oxygen concentration [mol.m-3]\": c_ox_typ * c_ox,\n            \"Oxygen concentration [Molar]\": c_ox_typ * c_ox / 1000,\n            \"X-averaged oxygen concentration\": c_ox_av,\n            \"X-averaged oxygen concentration [mol.m-3]\": c_ox_typ * c_ox_av,\n            \"X-averaged oxygen concentration [Molar]\": c_ox_typ * c_ox_av / 1000,\n            \"Negative oxygen concentration\": c_ox_n,\n            \"Negative oxygen concentration [mol.m-3]\": c_ox_typ * c_ox_n,\n            \"Negative oxygen concentration [Molar]\": c_ox_typ * c_ox_n / 1000,\n            \"Separator oxygen concentration\": c_ox_s,\n            \"Separator oxygen concentration [mol.m-3]\": c_ox_typ * c_ox_s,\n            \"Separator oxygen concentration [Molar]\": c_ox_typ * c_ox_s / 1000,\n            \"Positive oxygen concentration\": c_ox_p,\n            \"Positive oxygen concentration [mol.m-3]\": c_ox_typ * c_ox_p,\n            \"Positive oxygen concentration [Molar]\": c_ox_typ * c_ox_p / 1000,\n        }\n\n        return variables\n\n    def _get_standard_flux_variables(self, N_ox):\n        \"\"\"\n        A private function to obtain the standard variables which\n        can be derived from the mass flux of oxygen.\n\n        Parameters\n        ----------\n        N_ox : :class:`pybamm.Symbol`\n            The flux of oxygen.\n\n        Returns\n        -------\n        variables : dict\n            The variables which can be derived from the flux of oxygen.\n        \"\"\"\n\n        param = self.param\n        flux_scale = param.curlyD_ox * param.c_ox_typ / param.L_x\n\n        variables = {\n            \"Oxygen flux\": N_ox,\n            \"Oxygen flux [mol.m-2.s-1]\": N_ox * flux_scale,\n        }\n\n        return variables",
  "def __init__(self, param, reactions=None):\n        super().__init__(param, reactions=reactions)",
  "def _get_standard_concentration_variables(self, c_ox):\n        \"\"\"\n        A private function to obtain the standard variables which\n        can be derived from the concentration of oxygen.\n\n        Parameters\n        ----------\n        c_ox : :class:`pybamm.Symbol`\n            The concentration of oxygen.\n        c_ox_av : :class:`pybamm.Symbol`\n            The cell-averaged concentration of oxygen.\n\n        Returns\n        -------\n        variables : dict\n            The variables which can be derived from the concentration in the\n            oxygen.\n        \"\"\"\n\n        c_ox_av = pybamm.x_average(c_ox)\n        c_ox_typ = self.param.c_ox_typ\n        c_ox_n, c_ox_s, c_ox_p = c_ox.orphans\n\n        variables = {\n            \"Oxygen concentration\": c_ox,\n            \"Oxygen concentration [mol.m-3]\": c_ox_typ * c_ox,\n            \"Oxygen concentration [Molar]\": c_ox_typ * c_ox / 1000,\n            \"X-averaged oxygen concentration\": c_ox_av,\n            \"X-averaged oxygen concentration [mol.m-3]\": c_ox_typ * c_ox_av,\n            \"X-averaged oxygen concentration [Molar]\": c_ox_typ * c_ox_av / 1000,\n            \"Negative oxygen concentration\": c_ox_n,\n            \"Negative oxygen concentration [mol.m-3]\": c_ox_typ * c_ox_n,\n            \"Negative oxygen concentration [Molar]\": c_ox_typ * c_ox_n / 1000,\n            \"Separator oxygen concentration\": c_ox_s,\n            \"Separator oxygen concentration [mol.m-3]\": c_ox_typ * c_ox_s,\n            \"Separator oxygen concentration [Molar]\": c_ox_typ * c_ox_s / 1000,\n            \"Positive oxygen concentration\": c_ox_p,\n            \"Positive oxygen concentration [mol.m-3]\": c_ox_typ * c_ox_p,\n            \"Positive oxygen concentration [Molar]\": c_ox_typ * c_ox_p / 1000,\n        }\n\n        return variables",
  "def _get_standard_flux_variables(self, N_ox):\n        \"\"\"\n        A private function to obtain the standard variables which\n        can be derived from the mass flux of oxygen.\n\n        Parameters\n        ----------\n        N_ox : :class:`pybamm.Symbol`\n            The flux of oxygen.\n\n        Returns\n        -------\n        variables : dict\n            The variables which can be derived from the flux of oxygen.\n        \"\"\"\n\n        param = self.param\n        flux_scale = param.curlyD_ox * param.c_ox_typ / param.L_x\n\n        variables = {\n            \"Oxygen flux\": N_ox,\n            \"Oxygen flux [mol.m-2.s-1]\": N_ox * flux_scale,\n        }\n\n        return variables",
  "class NoOxygen(BaseModel):\n    \"\"\"Class for when there is no oxygen\n\n    Parameters\n    ----------\n    param : parameter class\n        The parameters to use for this submodel\n\n\n    **Extends:** :class:`pybamm.oxygen_diffusion.BaseModel`\n    \"\"\"\n\n    def __init__(self, param):\n        super().__init__(param)\n\n    def get_fundamental_variables(self):\n        c_ox_n = pybamm.FullBroadcast(0, [\"negative electrode\"], \"current collector\")\n        c_ox_s = pybamm.FullBroadcast(0, [\"separator\"], \"current collector\")\n        c_ox_p = pybamm.FullBroadcast(0, [\"positive electrode\"], \"current collector\")\n        c_ox = pybamm.Concatenation(c_ox_n, c_ox_s, c_ox_p)\n\n        variables = self._get_standard_concentration_variables(c_ox)\n\n        N_e = pybamm.FullBroadcast(\n            0,\n            [\"negative electrode\", \"separator\", \"positive electrode\"],\n            \"current collector\",\n        )\n\n        variables.update(self._get_standard_flux_variables(N_e))\n\n        return variables",
  "def __init__(self, param):\n        super().__init__(param)",
  "def get_fundamental_variables(self):\n        c_ox_n = pybamm.FullBroadcast(0, [\"negative electrode\"], \"current collector\")\n        c_ox_s = pybamm.FullBroadcast(0, [\"separator\"], \"current collector\")\n        c_ox_p = pybamm.FullBroadcast(0, [\"positive electrode\"], \"current collector\")\n        c_ox = pybamm.Concatenation(c_ox_n, c_ox_s, c_ox_p)\n\n        variables = self._get_standard_concentration_variables(c_ox)\n\n        N_e = pybamm.FullBroadcast(\n            0,\n            [\"negative electrode\", \"separator\", \"positive electrode\"],\n            \"current collector\",\n        )\n\n        variables.update(self._get_standard_flux_variables(N_e))\n\n        return variables",
  "def separator_and_positive_only(variable):\n    \"\"\"Return only the separator and positive electrode children\n\n    Parameters\n    ----------\n    variable : :class:`pybamm.Concatenation`\n        Concatenation of variables in negative, separator, positive\n\n    Returns\n    -------\n    :class:`pybamm.Concatenation`\n        Concatenation of variables in separator and positive only\n    \"\"\"\n    _, var_s, var_p = variable.orphans\n    return pybamm.Concatenation(var_s, var_p)",
  "class Full(BaseModel):\n    \"\"\"Class for conservation of mass of oxygen. (Full refers to unreduced by\n    asymptotic methods)\n    In this model, extremely fast oxygen kinetics in the negative electrode imposes\n    zero oxygen concentration there, and so the oxygen variable only lives in the\n    separator and positive electrode. The boundary condition at the negative electrode/\n    separator interface is homogeneous Dirichlet.\n\n    Parameters\n    ----------\n    param : parameter class\n        The parameters to use for this submodel\n    reactions : dict\n        Dictionary of reaction terms\n\n    **Extends:** :class:`pybamm.oxygen_diffusion.BaseModel`\n    \"\"\"\n\n    def __init__(self, param, reactions):\n        super().__init__(param, reactions)\n\n    def get_fundamental_variables(self):\n        # Oxygen concentration (oxygen concentration is zero in the negative electrode)\n        c_ox_n = pybamm.FullBroadcast(0, \"negative electrode\", \"current collector\")\n        c_ox_s = pybamm.Variable(\n            \"Separator oxygen concentration\",\n            domain=\"separator\",\n            auxiliary_domains={\"secondary\": \"current collector\"},\n        )\n        c_ox_p = pybamm.Variable(\n            \"Positive oxygen concentration\",\n            domain=\"positive electrode\",\n            auxiliary_domains={\"secondary\": \"current collector\"},\n        )\n        c_ox_s_p = pybamm.Concatenation(c_ox_s, c_ox_p)\n        variables = {\"Separator and positive electrode oxygen concentration\": c_ox_s_p}\n\n        c_ox = pybamm.Concatenation(c_ox_n, c_ox_s, c_ox_p)\n        variables.update(self._get_standard_concentration_variables(c_ox))\n\n        return variables\n\n    def get_coupled_variables(self, variables):\n\n        eps = separator_and_positive_only(variables[\"Porosity\"])\n        c_ox = variables[\"Separator and positive electrode oxygen concentration\"]\n        # TODO: allow charge and convection?\n        v_box = pybamm.Scalar(0)\n\n        param = self.param\n\n        b = pybamm.Concatenation(\n            pybamm.FullBroadcast(param.b_s, [\"separator\"], \"current collector\"),\n            pybamm.FullBroadcast(\n                param.b_p, [\"positive electrode\"], \"current collector\"\n            ),\n        )\n\n        N_ox_diffusion = -(eps ** b) * param.curlyD_ox * pybamm.grad(c_ox)\n\n        N_ox = N_ox_diffusion + c_ox * v_box\n        # Flux in the negative electrode is zero\n        N_ox = pybamm.Concatenation(\n            pybamm.FullBroadcast(0, \"negative electrode\", \"current collector\"), N_ox\n        )\n\n        variables.update(self._get_standard_flux_variables(N_ox))\n\n        return variables\n\n    def set_rhs(self, variables):\n\n        param = self.param\n\n        eps = separator_and_positive_only(variables[\"Porosity\"])\n        deps_dt = separator_and_positive_only(variables[\"Porosity change\"])\n        c_ox = variables[\"Separator and positive electrode oxygen concentration\"]\n        N_ox = variables[\"Oxygen flux\"].orphans[1]\n\n        source_terms = sum(\n            pybamm.Concatenation(\n                pybamm.FullBroadcast(0, \"separator\", \"current collector\"),\n                reaction[\"Positive\"][\"s_ox\"] * variables[reaction[\"Positive\"][\"aj\"]],\n            )\n            for reaction in self.reactions.values()\n        )\n\n        self.rhs = {\n            c_ox: (1 / eps)\n            * (-pybamm.div(N_ox) / param.C_e + source_terms - c_ox * deps_dt)\n        }\n\n    def set_boundary_conditions(self, variables):\n\n        c_ox = variables[\"Separator and positive electrode oxygen concentration\"]\n\n        self.boundary_conditions = {\n            c_ox: {\n                \"left\": (pybamm.Scalar(0), \"Dirichlet\"),\n                \"right\": (pybamm.Scalar(0), \"Neumann\"),\n            }\n        }\n\n    def set_initial_conditions(self, variables):\n\n        c_ox = variables[\"Separator and positive electrode oxygen concentration\"]\n\n        self.initial_conditions = {c_ox: self.param.c_ox_init}",
  "def __init__(self, param, reactions):\n        super().__init__(param, reactions)",
  "def get_fundamental_variables(self):\n        # Oxygen concentration (oxygen concentration is zero in the negative electrode)\n        c_ox_n = pybamm.FullBroadcast(0, \"negative electrode\", \"current collector\")\n        c_ox_s = pybamm.Variable(\n            \"Separator oxygen concentration\",\n            domain=\"separator\",\n            auxiliary_domains={\"secondary\": \"current collector\"},\n        )\n        c_ox_p = pybamm.Variable(\n            \"Positive oxygen concentration\",\n            domain=\"positive electrode\",\n            auxiliary_domains={\"secondary\": \"current collector\"},\n        )\n        c_ox_s_p = pybamm.Concatenation(c_ox_s, c_ox_p)\n        variables = {\"Separator and positive electrode oxygen concentration\": c_ox_s_p}\n\n        c_ox = pybamm.Concatenation(c_ox_n, c_ox_s, c_ox_p)\n        variables.update(self._get_standard_concentration_variables(c_ox))\n\n        return variables",
  "def get_coupled_variables(self, variables):\n\n        eps = separator_and_positive_only(variables[\"Porosity\"])\n        c_ox = variables[\"Separator and positive electrode oxygen concentration\"]\n        # TODO: allow charge and convection?\n        v_box = pybamm.Scalar(0)\n\n        param = self.param\n\n        b = pybamm.Concatenation(\n            pybamm.FullBroadcast(param.b_s, [\"separator\"], \"current collector\"),\n            pybamm.FullBroadcast(\n                param.b_p, [\"positive electrode\"], \"current collector\"\n            ),\n        )\n\n        N_ox_diffusion = -(eps ** b) * param.curlyD_ox * pybamm.grad(c_ox)\n\n        N_ox = N_ox_diffusion + c_ox * v_box\n        # Flux in the negative electrode is zero\n        N_ox = pybamm.Concatenation(\n            pybamm.FullBroadcast(0, \"negative electrode\", \"current collector\"), N_ox\n        )\n\n        variables.update(self._get_standard_flux_variables(N_ox))\n\n        return variables",
  "def set_rhs(self, variables):\n\n        param = self.param\n\n        eps = separator_and_positive_only(variables[\"Porosity\"])\n        deps_dt = separator_and_positive_only(variables[\"Porosity change\"])\n        c_ox = variables[\"Separator and positive electrode oxygen concentration\"]\n        N_ox = variables[\"Oxygen flux\"].orphans[1]\n\n        source_terms = sum(\n            pybamm.Concatenation(\n                pybamm.FullBroadcast(0, \"separator\", \"current collector\"),\n                reaction[\"Positive\"][\"s_ox\"] * variables[reaction[\"Positive\"][\"aj\"]],\n            )\n            for reaction in self.reactions.values()\n        )\n\n        self.rhs = {\n            c_ox: (1 / eps)\n            * (-pybamm.div(N_ox) / param.C_e + source_terms - c_ox * deps_dt)\n        }",
  "def set_boundary_conditions(self, variables):\n\n        c_ox = variables[\"Separator and positive electrode oxygen concentration\"]\n\n        self.boundary_conditions = {\n            c_ox: {\n                \"left\": (pybamm.Scalar(0), \"Dirichlet\"),\n                \"right\": (pybamm.Scalar(0), \"Neumann\"),\n            }\n        }",
  "def set_initial_conditions(self, variables):\n\n        c_ox = variables[\"Separator and positive electrode oxygen concentration\"]\n\n        self.initial_conditions = {c_ox: self.param.c_ox_init}",
  "class LeadingOrder(BaseModel):\n    \"\"\"Class for conservation of mass of oxygen. (Leading refers to leading order\n    of asymptotic reduction)\n\n    Parameters\n    ----------\n    param : parameter class\n        The parameters to use for this submodel\n    reactions : dict\n        Dictionary of reaction terms\n\n    **Extends:** :class:`pybamm.oxgen_diffusion.BaseModel`\n    \"\"\"\n\n    def __init__(self, param, reactions):\n        super().__init__(param, reactions)\n\n    def get_fundamental_variables(self):\n        c_ox_av = pybamm.Variable(\"X-averaged oxygen concentration\")\n        c_ox_n = pybamm.FullBroadcast(\n            c_ox_av, [\"negative electrode\"], \"current collector\"\n        )\n        c_ox_s = pybamm.FullBroadcast(c_ox_av, [\"separator\"], \"current collector\")\n        c_ox_p = pybamm.FullBroadcast(\n            c_ox_av, [\"positive electrode\"], \"current collector\"\n        )\n        c_ox = pybamm.Concatenation(c_ox_n, c_ox_s, c_ox_p)\n\n        return self._get_standard_concentration_variables(c_ox)\n\n    def get_coupled_variables(self, variables):\n\n        N_ox = pybamm.FullBroadcast(\n            0,\n            [\"negative electrode\", \"separator\", \"positive electrode\"],\n            \"current collector\",\n        )\n\n        variables.update(self._get_standard_flux_variables(N_ox))\n\n        return variables\n\n    def set_rhs(self, variables):\n\n        param = self.param\n\n        c_ox_av = variables[\"X-averaged oxygen concentration\"]\n\n        eps_n_av = variables[\"X-averaged negative electrode porosity\"]\n        eps_s_av = variables[\"X-averaged separator porosity\"]\n        eps_p_av = variables[\"X-averaged positive electrode porosity\"]\n\n        deps_n_dt_av = variables[\"X-averaged negative electrode porosity change\"]\n        deps_p_dt_av = variables[\"X-averaged positive electrode porosity change\"]\n\n        source_terms = sum(\n            param.l_n\n            * rxn[\"Negative\"][\"s_ox\"]\n            * variables[\"X-averaged \" + rxn[\"Negative\"][\"aj\"].lower()]\n            + param.l_p\n            * rxn[\"Positive\"][\"s_ox\"]\n            * variables[\"X-averaged \" + rxn[\"Positive\"][\"aj\"].lower()]\n            for rxn in self.reactions.values()\n        )\n\n        self.rhs = {\n            c_ox_av: 1\n            / (param.l_n * eps_n_av + param.l_s * eps_s_av + param.l_p * eps_p_av)\n            * (\n                source_terms\n                - c_ox_av * (param.l_n * deps_n_dt_av + param.l_p * deps_p_dt_av)\n            )\n        }\n\n    def set_initial_conditions(self, variables):\n        c_ox = variables[\"X-averaged oxygen concentration\"]\n        self.initial_conditions = {c_ox: self.param.c_ox_init}",
  "def __init__(self, param, reactions):\n        super().__init__(param, reactions)",
  "def get_fundamental_variables(self):\n        c_ox_av = pybamm.Variable(\"X-averaged oxygen concentration\")\n        c_ox_n = pybamm.FullBroadcast(\n            c_ox_av, [\"negative electrode\"], \"current collector\"\n        )\n        c_ox_s = pybamm.FullBroadcast(c_ox_av, [\"separator\"], \"current collector\")\n        c_ox_p = pybamm.FullBroadcast(\n            c_ox_av, [\"positive electrode\"], \"current collector\"\n        )\n        c_ox = pybamm.Concatenation(c_ox_n, c_ox_s, c_ox_p)\n\n        return self._get_standard_concentration_variables(c_ox)",
  "def get_coupled_variables(self, variables):\n\n        N_ox = pybamm.FullBroadcast(\n            0,\n            [\"negative electrode\", \"separator\", \"positive electrode\"],\n            \"current collector\",\n        )\n\n        variables.update(self._get_standard_flux_variables(N_ox))\n\n        return variables",
  "def set_rhs(self, variables):\n\n        param = self.param\n\n        c_ox_av = variables[\"X-averaged oxygen concentration\"]\n\n        eps_n_av = variables[\"X-averaged negative electrode porosity\"]\n        eps_s_av = variables[\"X-averaged separator porosity\"]\n        eps_p_av = variables[\"X-averaged positive electrode porosity\"]\n\n        deps_n_dt_av = variables[\"X-averaged negative electrode porosity change\"]\n        deps_p_dt_av = variables[\"X-averaged positive electrode porosity change\"]\n\n        source_terms = sum(\n            param.l_n\n            * rxn[\"Negative\"][\"s_ox\"]\n            * variables[\"X-averaged \" + rxn[\"Negative\"][\"aj\"].lower()]\n            + param.l_p\n            * rxn[\"Positive\"][\"s_ox\"]\n            * variables[\"X-averaged \" + rxn[\"Positive\"][\"aj\"].lower()]\n            for rxn in self.reactions.values()\n        )\n\n        self.rhs = {\n            c_ox_av: 1\n            / (param.l_n * eps_n_av + param.l_s * eps_s_av + param.l_p * eps_p_av)\n            * (\n                source_terms\n                - c_ox_av * (param.l_n * deps_n_dt_av + param.l_p * deps_p_dt_av)\n            )\n        }",
  "def set_initial_conditions(self, variables):\n        c_ox = variables[\"X-averaged oxygen concentration\"]\n        self.initial_conditions = {c_ox: self.param.c_ox_init}",
  "class BaseElectrode(pybamm.BaseSubModel):\n    \"\"\"Base class for electrode submodels.\n\n    Parameters\n    ----------\n    param : parameter class\n        The parameters to use for this submodel\n    domain : str\n        Either 'Negative' or 'Positive'\n\n    **Extends:** :class:`pybamm.BaseSubModel`\n    \"\"\"\n\n    def __init__(self, param, domain, reactions=None):\n        super().__init__(param, domain, reactions)\n\n    def _get_standard_potential_variables(self, phi_s):\n        \"\"\"\n        A private function to obtain the standard variables which\n        can be derived from the potential in the electrode.\n\n        Parameters\n        ----------\n        phi_s : :class:`pybamm.Symbol`\n            The potential in the electrode.\n\n        Returns\n        -------\n        variables : dict\n            The variables which can be derived from the potential in the\n            electrode.\n        \"\"\"\n        param = self.param\n        phi_s_av = pybamm.x_average(phi_s)\n\n        if self.domain == \"Negative\":\n            phi_s_dim = param.potential_scale * phi_s\n            phi_s_av_dim = param.potential_scale * phi_s_av\n            delta_phi_s = phi_s\n\n        elif self.domain == \"Positive\":\n            phi_s_dim = param.U_p_ref - param.U_n_ref + param.potential_scale * phi_s\n            phi_s_av_dim = (\n                param.U_p_ref - param.U_n_ref + param.potential_scale * phi_s_av\n            )\n\n            v = pybamm.boundary_value(phi_s, \"right\")\n            delta_phi_s = phi_s - pybamm.PrimaryBroadcast(v, [\"positive electrode\"])\n        delta_phi_s_av = pybamm.x_average(delta_phi_s)\n        delta_phi_s_dim = delta_phi_s * param.potential_scale\n        delta_phi_s_av_dim = delta_phi_s_av * param.potential_scale\n\n        variables = {\n            self.domain + \" electrode potential\": phi_s,\n            self.domain + \" electrode potential [V]\": phi_s_dim,\n            \"X-averaged \" + self.domain.lower() + \" electrode potential\": phi_s_av,\n            \"X-averaged \"\n            + self.domain.lower()\n            + \" electrode potential [V]\": phi_s_av_dim,\n            self.domain + \" electrode ohmic losses\": delta_phi_s,\n            self.domain + \" electrode ohmic losses [V]\": delta_phi_s_dim,\n            \"X-averaged \"\n            + self.domain.lower()\n            + \" electrode ohmic losses\": delta_phi_s_av,\n            \"X-averaged \"\n            + self.domain.lower()\n            + \" electrode ohmic losses [V]\": delta_phi_s_av_dim,\n            \"Gradient of \"\n            + self.domain.lower()\n            + \" electrode potential\": pybamm.grad(phi_s),\n        }\n\n        return variables\n\n    def _get_standard_current_variables(self, i_s):\n        \"\"\"\n        A private function to obtain the standard variables which\n        can be derived from the current in the electrode.\n\n        Parameters\n        ----------\n        i_s : :class:`pybamm.Symbol`\n            The current in the electrode.\n\n        Returns\n        -------\n        variables : dict\n            The variables which can be derived from the current in the\n            electrode.\n        \"\"\"\n        param = self.param\n\n        i_s_dim = param.i_typ * i_s\n\n        variables = {\n            self.domain + \" electrode current density\": i_s,\n            self.domain + \" electrode current density [A.m-2]\": i_s_dim,\n        }\n\n        return variables\n\n    def _get_standard_whole_cell_variables(self, variables):\n        \"\"\"\n        A private function to obtain the whole-cell versions of the\n        current variables.\n\n        Parameters\n        ----------\n        variables : dict\n            The variables in the whole model.\n\n        Returns\n        -------\n        variables : dict\n            The variables in the whole model with the whole-cell\n            current variables added.\n        \"\"\"\n        pot_scale = self.param.potential_scale\n        U_ref = self.param.U_p_ref - self.param.U_n_ref\n\n        i_s_n = variables[\"Negative electrode current density\"]\n        i_s_s = pybamm.FullBroadcast(0, [\"separator\"], \"current collector\")\n        i_s_p = variables[\"Positive electrode current density\"]\n        phi_s_p = variables[\"Positive electrode potential\"]\n\n        phi_s_cn = variables[\"Negative current collector potential\"]\n        phi_s_cp = pybamm.boundary_value(phi_s_p, \"right\")\n        v_boundary_cc = phi_s_cp - phi_s_cn\n\n        i_s = pybamm.Concatenation(i_s_n, i_s_s, i_s_p)\n\n        variables = {\n            \"Electrode current density\": i_s,\n            \"Positive current collector potential\": phi_s_cp,\n            \"Local current collector potential difference\": v_boundary_cc,\n            \"Local current collector potential difference [V]\": U_ref\n            + v_boundary_cc * pot_scale,\n        }\n\n        return variables\n\n    @property\n    def default_solver(self):\n        \"\"\"\n        Create and return the default solver for this model\n        \"\"\"\n        return pybamm.ScikitsDaeSolver()",
  "def __init__(self, param, domain, reactions=None):\n        super().__init__(param, domain, reactions)",
  "def _get_standard_potential_variables(self, phi_s):\n        \"\"\"\n        A private function to obtain the standard variables which\n        can be derived from the potential in the electrode.\n\n        Parameters\n        ----------\n        phi_s : :class:`pybamm.Symbol`\n            The potential in the electrode.\n\n        Returns\n        -------\n        variables : dict\n            The variables which can be derived from the potential in the\n            electrode.\n        \"\"\"\n        param = self.param\n        phi_s_av = pybamm.x_average(phi_s)\n\n        if self.domain == \"Negative\":\n            phi_s_dim = param.potential_scale * phi_s\n            phi_s_av_dim = param.potential_scale * phi_s_av\n            delta_phi_s = phi_s\n\n        elif self.domain == \"Positive\":\n            phi_s_dim = param.U_p_ref - param.U_n_ref + param.potential_scale * phi_s\n            phi_s_av_dim = (\n                param.U_p_ref - param.U_n_ref + param.potential_scale * phi_s_av\n            )\n\n            v = pybamm.boundary_value(phi_s, \"right\")\n            delta_phi_s = phi_s - pybamm.PrimaryBroadcast(v, [\"positive electrode\"])\n        delta_phi_s_av = pybamm.x_average(delta_phi_s)\n        delta_phi_s_dim = delta_phi_s * param.potential_scale\n        delta_phi_s_av_dim = delta_phi_s_av * param.potential_scale\n\n        variables = {\n            self.domain + \" electrode potential\": phi_s,\n            self.domain + \" electrode potential [V]\": phi_s_dim,\n            \"X-averaged \" + self.domain.lower() + \" electrode potential\": phi_s_av,\n            \"X-averaged \"\n            + self.domain.lower()\n            + \" electrode potential [V]\": phi_s_av_dim,\n            self.domain + \" electrode ohmic losses\": delta_phi_s,\n            self.domain + \" electrode ohmic losses [V]\": delta_phi_s_dim,\n            \"X-averaged \"\n            + self.domain.lower()\n            + \" electrode ohmic losses\": delta_phi_s_av,\n            \"X-averaged \"\n            + self.domain.lower()\n            + \" electrode ohmic losses [V]\": delta_phi_s_av_dim,\n            \"Gradient of \"\n            + self.domain.lower()\n            + \" electrode potential\": pybamm.grad(phi_s),\n        }\n\n        return variables",
  "def _get_standard_current_variables(self, i_s):\n        \"\"\"\n        A private function to obtain the standard variables which\n        can be derived from the current in the electrode.\n\n        Parameters\n        ----------\n        i_s : :class:`pybamm.Symbol`\n            The current in the electrode.\n\n        Returns\n        -------\n        variables : dict\n            The variables which can be derived from the current in the\n            electrode.\n        \"\"\"\n        param = self.param\n\n        i_s_dim = param.i_typ * i_s\n\n        variables = {\n            self.domain + \" electrode current density\": i_s,\n            self.domain + \" electrode current density [A.m-2]\": i_s_dim,\n        }\n\n        return variables",
  "def _get_standard_whole_cell_variables(self, variables):\n        \"\"\"\n        A private function to obtain the whole-cell versions of the\n        current variables.\n\n        Parameters\n        ----------\n        variables : dict\n            The variables in the whole model.\n\n        Returns\n        -------\n        variables : dict\n            The variables in the whole model with the whole-cell\n            current variables added.\n        \"\"\"\n        pot_scale = self.param.potential_scale\n        U_ref = self.param.U_p_ref - self.param.U_n_ref\n\n        i_s_n = variables[\"Negative electrode current density\"]\n        i_s_s = pybamm.FullBroadcast(0, [\"separator\"], \"current collector\")\n        i_s_p = variables[\"Positive electrode current density\"]\n        phi_s_p = variables[\"Positive electrode potential\"]\n\n        phi_s_cn = variables[\"Negative current collector potential\"]\n        phi_s_cp = pybamm.boundary_value(phi_s_p, \"right\")\n        v_boundary_cc = phi_s_cp - phi_s_cn\n\n        i_s = pybamm.Concatenation(i_s_n, i_s_s, i_s_p)\n\n        variables = {\n            \"Electrode current density\": i_s,\n            \"Positive current collector potential\": phi_s_cp,\n            \"Local current collector potential difference\": v_boundary_cc,\n            \"Local current collector potential difference [V]\": U_ref\n            + v_boundary_cc * pot_scale,\n        }\n\n        return variables",
  "def default_solver(self):\n        \"\"\"\n        Create and return the default solver for this model\n        \"\"\"\n        return pybamm.ScikitsDaeSolver()",
  "class Full(BaseModel):\n    \"\"\"Full model of electrode employing Ohm's law.\n\n    Parameters\n    ----------\n    param : parameter class\n        The parameters to use for this submodel\n    domain : str\n        Either 'Negative' or 'Positive'\n\n\n    **Extends:** :class:`pybamm.electrode.ohm.BaseModel`\n    \"\"\"\n\n    def __init__(self, param, domain, reactions):\n        super().__init__(param, domain, reactions)\n\n    def get_fundamental_variables(self):\n\n        if self.domain == \"Negative\":\n            phi_s = pybamm.standard_variables.phi_s_n\n        elif self.domain == \"Positive\":\n            phi_s = pybamm.standard_variables.phi_s_p\n\n        variables = self._get_standard_potential_variables(phi_s)\n\n        return variables\n\n    def get_coupled_variables(self, variables):\n\n        phi_s = variables[self.domain + \" electrode potential\"]\n        eps = variables[self.domain + \" electrode porosity\"]\n\n        if self.domain == \"Negative\":\n            sigma = self.param.sigma_n\n            b = self.param.b_n\n        elif self.domain == \"Positive\":\n            sigma = self.param.sigma_p\n            b = self.param.b_p\n\n        sigma_eff = sigma * (1 - eps) ** b\n        i_s = -sigma_eff * pybamm.grad(phi_s)\n\n        variables.update({self.domain + \" electrode effective conductivity\": sigma_eff})\n\n        variables.update(self._get_standard_current_variables(i_s))\n\n        if self.domain == \"Positive\":\n            variables.update(self._get_standard_whole_cell_variables(variables))\n\n        return variables\n\n    def set_algebraic(self, variables):\n\n        phi_s = variables[self.domain + \" electrode potential\"]\n        i_s = variables[self.domain + \" electrode current density\"]\n        sum_j = sum(\n            variables[reaction[self.domain][\"aj\"]]\n            for reaction in self.reactions.values()\n        )\n\n        self.algebraic[phi_s] = pybamm.div(i_s) + sum_j\n\n    def set_boundary_conditions(self, variables):\n\n        phi_s = variables[self.domain + \" electrode potential\"]\n        phi_s_cn = variables[\"Negative current collector potential\"]\n        eps = variables[self.domain + \" electrode porosity\"]\n        i_boundary_cc = variables[\"Current collector current density\"]\n\n        if self.domain == \"Negative\":\n            lbc = (phi_s_cn, \"Dirichlet\")\n            rbc = (pybamm.Scalar(0), \"Neumann\")\n\n        elif self.domain == \"Positive\":\n            lbc = (pybamm.Scalar(0), \"Neumann\")\n            sigma_eff = self.param.sigma_p * (1 - eps) ** self.param.b_p\n            rbc = (\n                i_boundary_cc / pybamm.boundary_value(-sigma_eff, \"right\"),\n                \"Neumann\",\n            )\n\n        self.boundary_conditions[phi_s] = {\"left\": lbc, \"right\": rbc}\n\n    def set_initial_conditions(self, variables):\n\n        phi_s = variables[self.domain + \" electrode potential\"]\n        T_ref = self.param.T_ref\n\n        if self.domain == \"Negative\":\n            phi_s_init = pybamm.Scalar(0)\n        elif self.domain == \"Positive\":\n            phi_s_init = self.param.U_p(self.param.c_p_init, T_ref) - self.param.U_n(\n                self.param.c_n_init, T_ref\n            )\n\n        self.initial_conditions[phi_s] = phi_s_init\n\n    @property\n    def default_solver(self):\n        \"\"\"\n        Create and return the default solver for this model\n        \"\"\"\n        return pybamm.ScikitsDaeSolver()",
  "def __init__(self, param, domain, reactions):\n        super().__init__(param, domain, reactions)",
  "def get_fundamental_variables(self):\n\n        if self.domain == \"Negative\":\n            phi_s = pybamm.standard_variables.phi_s_n\n        elif self.domain == \"Positive\":\n            phi_s = pybamm.standard_variables.phi_s_p\n\n        variables = self._get_standard_potential_variables(phi_s)\n\n        return variables",
  "def get_coupled_variables(self, variables):\n\n        phi_s = variables[self.domain + \" electrode potential\"]\n        eps = variables[self.domain + \" electrode porosity\"]\n\n        if self.domain == \"Negative\":\n            sigma = self.param.sigma_n\n            b = self.param.b_n\n        elif self.domain == \"Positive\":\n            sigma = self.param.sigma_p\n            b = self.param.b_p\n\n        sigma_eff = sigma * (1 - eps) ** b\n        i_s = -sigma_eff * pybamm.grad(phi_s)\n\n        variables.update({self.domain + \" electrode effective conductivity\": sigma_eff})\n\n        variables.update(self._get_standard_current_variables(i_s))\n\n        if self.domain == \"Positive\":\n            variables.update(self._get_standard_whole_cell_variables(variables))\n\n        return variables",
  "def set_algebraic(self, variables):\n\n        phi_s = variables[self.domain + \" electrode potential\"]\n        i_s = variables[self.domain + \" electrode current density\"]\n        sum_j = sum(\n            variables[reaction[self.domain][\"aj\"]]\n            for reaction in self.reactions.values()\n        )\n\n        self.algebraic[phi_s] = pybamm.div(i_s) + sum_j",
  "def set_boundary_conditions(self, variables):\n\n        phi_s = variables[self.domain + \" electrode potential\"]\n        phi_s_cn = variables[\"Negative current collector potential\"]\n        eps = variables[self.domain + \" electrode porosity\"]\n        i_boundary_cc = variables[\"Current collector current density\"]\n\n        if self.domain == \"Negative\":\n            lbc = (phi_s_cn, \"Dirichlet\")\n            rbc = (pybamm.Scalar(0), \"Neumann\")\n\n        elif self.domain == \"Positive\":\n            lbc = (pybamm.Scalar(0), \"Neumann\")\n            sigma_eff = self.param.sigma_p * (1 - eps) ** self.param.b_p\n            rbc = (\n                i_boundary_cc / pybamm.boundary_value(-sigma_eff, \"right\"),\n                \"Neumann\",\n            )\n\n        self.boundary_conditions[phi_s] = {\"left\": lbc, \"right\": rbc}",
  "def set_initial_conditions(self, variables):\n\n        phi_s = variables[self.domain + \" electrode potential\"]\n        T_ref = self.param.T_ref\n\n        if self.domain == \"Negative\":\n            phi_s_init = pybamm.Scalar(0)\n        elif self.domain == \"Positive\":\n            phi_s_init = self.param.U_p(self.param.c_p_init, T_ref) - self.param.U_n(\n                self.param.c_n_init, T_ref\n            )\n\n        self.initial_conditions[phi_s] = phi_s_init",
  "def default_solver(self):\n        \"\"\"\n        Create and return the default solver for this model\n        \"\"\"\n        return pybamm.ScikitsDaeSolver()",
  "class SurfaceForm(BaseModel):\n    \"\"\"A submodel for the electrode with Ohm's law in the surface potential\n    formulation.\n\n    Parameters\n    ----------\n    param : parameter class\n        The parameters to use for this submodel\n    domain : str\n        Either 'Negative' or 'Positive'\n\n\n    **Extends:** :class:`pybamm.electrode.ohm.BaseModel`\n    \"\"\"\n\n    def __init__(self, param, domain):\n        super().__init__(param, domain)\n\n    def get_coupled_variables(self, variables):\n\n        param = self.param\n        x_n = pybamm.standard_spatial_vars.x_n\n        x_p = pybamm.standard_spatial_vars.x_p\n        i_boundary_cc = variables[\"Current collector current density\"]\n        i_e = variables[self.domain + \" electrolyte current density\"]\n        eps = variables[self.domain + \" electrode porosity\"]\n        phi_s_cn = variables[\"Negative current collector potential\"]\n\n        i_s = pybamm.PrimaryBroadcast(i_boundary_cc, self.domain_for_broadcast) - i_e\n\n        if self.domain == \"Negative\":\n            conductivity = param.sigma_n * (1 - eps) ** param.b_n\n            phi_s = pybamm.PrimaryBroadcast(\n                phi_s_cn, \"negative electrode\"\n            ) - pybamm.IndefiniteIntegral(i_s / conductivity, x_n)\n\n        elif self.domain == \"Positive\":\n\n            phi_e_s = variables[\"Separator electrolyte potential\"]\n            delta_phi_p = variables[\"Positive electrode surface potential difference\"]\n\n            conductivity = param.sigma_p * (1 - eps) ** param.b_p\n            phi_s = -pybamm.IndefiniteIntegral(\n                i_s / conductivity, x_p\n            ) + pybamm.PrimaryBroadcast(\n                pybamm.boundary_value(phi_e_s, \"right\")\n                + pybamm.boundary_value(delta_phi_p, \"left\"),\n                \"positive electrode\",\n            )\n\n        variables.update(self._get_standard_potential_variables(phi_s))\n        variables.update(self._get_standard_current_variables(i_s))\n\n        if (\n            \"Negative electrode current density\" in variables\n            and \"Positive electrode current density\" in variables\n        ):\n            variables.update(self._get_standard_whole_cell_variables(variables))\n\n        return variables\n\n    @property\n    def default_solver(self):\n        \"\"\"\n        Create and return the default solver for this model\n        \"\"\"\n        return pybamm.ScikitsDaeSolver()",
  "def __init__(self, param, domain):\n        super().__init__(param, domain)",
  "def get_coupled_variables(self, variables):\n\n        param = self.param\n        x_n = pybamm.standard_spatial_vars.x_n\n        x_p = pybamm.standard_spatial_vars.x_p\n        i_boundary_cc = variables[\"Current collector current density\"]\n        i_e = variables[self.domain + \" electrolyte current density\"]\n        eps = variables[self.domain + \" electrode porosity\"]\n        phi_s_cn = variables[\"Negative current collector potential\"]\n\n        i_s = pybamm.PrimaryBroadcast(i_boundary_cc, self.domain_for_broadcast) - i_e\n\n        if self.domain == \"Negative\":\n            conductivity = param.sigma_n * (1 - eps) ** param.b_n\n            phi_s = pybamm.PrimaryBroadcast(\n                phi_s_cn, \"negative electrode\"\n            ) - pybamm.IndefiniteIntegral(i_s / conductivity, x_n)\n\n        elif self.domain == \"Positive\":\n\n            phi_e_s = variables[\"Separator electrolyte potential\"]\n            delta_phi_p = variables[\"Positive electrode surface potential difference\"]\n\n            conductivity = param.sigma_p * (1 - eps) ** param.b_p\n            phi_s = -pybamm.IndefiniteIntegral(\n                i_s / conductivity, x_p\n            ) + pybamm.PrimaryBroadcast(\n                pybamm.boundary_value(phi_e_s, \"right\")\n                + pybamm.boundary_value(delta_phi_p, \"left\"),\n                \"positive electrode\",\n            )\n\n        variables.update(self._get_standard_potential_variables(phi_s))\n        variables.update(self._get_standard_current_variables(i_s))\n\n        if (\n            \"Negative electrode current density\" in variables\n            and \"Positive electrode current density\" in variables\n        ):\n            variables.update(self._get_standard_whole_cell_variables(variables))\n\n        return variables",
  "def default_solver(self):\n        \"\"\"\n        Create and return the default solver for this model\n        \"\"\"\n        return pybamm.ScikitsDaeSolver()",
  "class LeadingOrder(BaseModel):\n    \"\"\"An electrode submodel that employs Ohm's law the leading-order approximation to\n    governing equations.\n\n    Parameters\n    ----------\n    param : parameter class\n        The parameters to use for this submodel\n    domain : str\n        Either 'Negative' or 'Positive'\n\n\n    **Extends:** :class:`pybamm.electrode.ohm.BaseModel`\n    \"\"\"\n\n    def __init__(self, param, domain):\n        super().__init__(param, domain)\n\n    def get_coupled_variables(self, variables):\n        \"\"\"\n        Returns variables which are derived from the fundamental variables in the model.\n        \"\"\"\n        i_boundary_cc = variables[\"Current collector current density\"]\n        phi_s_cn = variables[\"Negative current collector potential\"]\n\n        # import parameters and spatial variables\n        l_n = self.param.l_n\n        l_p = self.param.l_p\n        x_n = pybamm.standard_spatial_vars.x_n\n        x_p = pybamm.standard_spatial_vars.x_p\n\n        if self.domain == \"Negative\":\n            phi_s = pybamm.PrimaryBroadcast(phi_s_cn, \"negative electrode\")\n            i_s = pybamm.outer(i_boundary_cc, 1 - x_n / l_n)\n\n        elif self.domain == \"Positive\":\n            # recall delta_phi = phi_s - phi_e\n            delta_phi_p_av = variables[\n                \"X-averaged positive electrode surface potential difference\"\n            ]\n            phi_e_p_av = variables[\"X-averaged positive electrolyte potential\"]\n\n            v = delta_phi_p_av + phi_e_p_av\n\n            phi_s = pybamm.PrimaryBroadcast(v, [\"positive electrode\"])\n            i_s = pybamm.outer(i_boundary_cc, 1 - (1 - x_p) / l_p)\n\n        variables.update(self._get_standard_potential_variables(phi_s))\n        variables.update(self._get_standard_current_variables(i_s))\n\n        if self.domain == \"Positive\":\n            variables.update(self._get_standard_whole_cell_variables(variables))\n\n        return variables\n\n    def set_boundary_conditions(self, variables):\n\n        phi_s = variables[self.domain + \" electrode potential\"]\n\n        lbc = (pybamm.Scalar(0), \"Neumann\")\n        rbc = (pybamm.Scalar(0), \"Neumann\")\n\n        self.boundary_conditions[phi_s] = {\"left\": lbc, \"right\": rbc}\n\n    @property\n    def default_solver(self):\n        \"\"\"\n        Create and return the default solver for this model\n        \"\"\"\n        return pybamm.ScikitsOdeSolver()",
  "def __init__(self, param, domain):\n        super().__init__(param, domain)",
  "def get_coupled_variables(self, variables):\n        \"\"\"\n        Returns variables which are derived from the fundamental variables in the model.\n        \"\"\"\n        i_boundary_cc = variables[\"Current collector current density\"]\n        phi_s_cn = variables[\"Negative current collector potential\"]\n\n        # import parameters and spatial variables\n        l_n = self.param.l_n\n        l_p = self.param.l_p\n        x_n = pybamm.standard_spatial_vars.x_n\n        x_p = pybamm.standard_spatial_vars.x_p\n\n        if self.domain == \"Negative\":\n            phi_s = pybamm.PrimaryBroadcast(phi_s_cn, \"negative electrode\")\n            i_s = pybamm.outer(i_boundary_cc, 1 - x_n / l_n)\n\n        elif self.domain == \"Positive\":\n            # recall delta_phi = phi_s - phi_e\n            delta_phi_p_av = variables[\n                \"X-averaged positive electrode surface potential difference\"\n            ]\n            phi_e_p_av = variables[\"X-averaged positive electrolyte potential\"]\n\n            v = delta_phi_p_av + phi_e_p_av\n\n            phi_s = pybamm.PrimaryBroadcast(v, [\"positive electrode\"])\n            i_s = pybamm.outer(i_boundary_cc, 1 - (1 - x_p) / l_p)\n\n        variables.update(self._get_standard_potential_variables(phi_s))\n        variables.update(self._get_standard_current_variables(i_s))\n\n        if self.domain == \"Positive\":\n            variables.update(self._get_standard_whole_cell_variables(variables))\n\n        return variables",
  "def set_boundary_conditions(self, variables):\n\n        phi_s = variables[self.domain + \" electrode potential\"]\n\n        lbc = (pybamm.Scalar(0), \"Neumann\")\n        rbc = (pybamm.Scalar(0), \"Neumann\")\n\n        self.boundary_conditions[phi_s] = {\"left\": lbc, \"right\": rbc}",
  "def default_solver(self):\n        \"\"\"\n        Create and return the default solver for this model\n        \"\"\"\n        return pybamm.ScikitsOdeSolver()",
  "class Composite(BaseModel):\n    \"\"\"An explicit composite leading and first order solution to solid phase\n    current conservation with ohm's law. Note that the returned current density is\n    only the leading order approximation.\n\n    Parameters\n    ----------\n    param : parameter class\n        The parameters to use for this submodel\n    domain : str\n        Either 'Negative electrode' or 'Positive electrode'\n\n\n    **Extends:** :class:`pybamm.BaseOhm`\n    \"\"\"\n\n    def __init__(self, param, domain):\n        super().__init__(param, domain)\n\n    def get_coupled_variables(self, variables):\n\n        i_boundary_cc_0 = variables[\"Leading-order current collector current density\"]\n\n        # import parameters and spatial variables\n        l_n = self.param.l_n\n        l_p = self.param.l_p\n        x_n = pybamm.standard_spatial_vars.x_n\n        x_p = pybamm.standard_spatial_vars.x_p\n\n        eps_0 = variables[\n            \"Leading-order x-averaged \" + self.domain.lower() + \" electrode porosity\"\n        ]\n        phi_s_cn = variables[\"Negative current collector potential\"]\n\n        if self._domain == \"Negative\":\n            sigma_eff_0 = self.param.sigma_n * (1 - eps_0) ** self.param.b_n\n            phi_s = pybamm.PrimaryBroadcast(\n                phi_s_cn, \"negative electrode\"\n            ) + pybamm.outer(\n                i_boundary_cc_0 / sigma_eff_0, x_n * (x_n - 2 * l_n) / (2 * l_n)\n            )\n            i_s = pybamm.outer(i_boundary_cc_0, 1 - x_n / l_n)\n\n        elif self.domain == \"Positive\":\n            delta_phi_p_av = variables[\n                \"X-averaged positive electrode surface potential difference\"\n            ]\n            phi_e_p_av = variables[\"X-averaged positive electrolyte potential\"]\n\n            sigma_eff_0 = self.param.sigma_p * (1 - eps_0) ** self.param.b_p\n\n            const = (\n                delta_phi_p_av\n                + phi_e_p_av\n                + (i_boundary_cc_0 / sigma_eff_0) * (1 - l_p / 3)\n            )\n\n            phi_s = pybamm.PrimaryBroadcast(\n                const, [\"positive electrode\"]\n            ) - pybamm.outer(\n                i_boundary_cc_0 / sigma_eff_0, x_p + (x_p - 1) ** 2 / (2 * l_p)\n            )\n            i_s = pybamm.outer(i_boundary_cc_0, 1 - (1 - x_p) / l_p)\n\n        variables.update(self._get_standard_potential_variables(phi_s))\n        variables.update(self._get_standard_current_variables(i_s))\n\n        if self.domain == \"Positive\":\n            variables.update(self._get_standard_whole_cell_variables(variables))\n\n        return variables\n\n    def set_boundary_conditions(self, variables):\n\n        phi_s = variables[self.domain + \" electrode potential\"]\n        eps_0 = variables[\n            \"Leading-order x-averaged \" + self.domain.lower() + \" electrode porosity\"\n        ]\n        i_boundary_cc_0 = variables[\"Leading-order current collector current density\"]\n\n        if self.domain == \"Negative\":\n            lbc = (pybamm.Scalar(0), \"Dirichlet\")\n            rbc = (pybamm.Scalar(0), \"Neumann\")\n\n        elif self.domain == \"Positive\":\n            lbc = (pybamm.Scalar(0), \"Neumann\")\n            sigma_eff_0 = self.param.sigma_p * (1 - eps_0) ** self.param.b_p\n            rbc = (-i_boundary_cc_0 / sigma_eff_0, \"Neumann\")\n\n        self.boundary_conditions[phi_s] = {\"left\": lbc, \"right\": rbc}",
  "def __init__(self, param, domain):\n        super().__init__(param, domain)",
  "def get_coupled_variables(self, variables):\n\n        i_boundary_cc_0 = variables[\"Leading-order current collector current density\"]\n\n        # import parameters and spatial variables\n        l_n = self.param.l_n\n        l_p = self.param.l_p\n        x_n = pybamm.standard_spatial_vars.x_n\n        x_p = pybamm.standard_spatial_vars.x_p\n\n        eps_0 = variables[\n            \"Leading-order x-averaged \" + self.domain.lower() + \" electrode porosity\"\n        ]\n        phi_s_cn = variables[\"Negative current collector potential\"]\n\n        if self._domain == \"Negative\":\n            sigma_eff_0 = self.param.sigma_n * (1 - eps_0) ** self.param.b_n\n            phi_s = pybamm.PrimaryBroadcast(\n                phi_s_cn, \"negative electrode\"\n            ) + pybamm.outer(\n                i_boundary_cc_0 / sigma_eff_0, x_n * (x_n - 2 * l_n) / (2 * l_n)\n            )\n            i_s = pybamm.outer(i_boundary_cc_0, 1 - x_n / l_n)\n\n        elif self.domain == \"Positive\":\n            delta_phi_p_av = variables[\n                \"X-averaged positive electrode surface potential difference\"\n            ]\n            phi_e_p_av = variables[\"X-averaged positive electrolyte potential\"]\n\n            sigma_eff_0 = self.param.sigma_p * (1 - eps_0) ** self.param.b_p\n\n            const = (\n                delta_phi_p_av\n                + phi_e_p_av\n                + (i_boundary_cc_0 / sigma_eff_0) * (1 - l_p / 3)\n            )\n\n            phi_s = pybamm.PrimaryBroadcast(\n                const, [\"positive electrode\"]\n            ) - pybamm.outer(\n                i_boundary_cc_0 / sigma_eff_0, x_p + (x_p - 1) ** 2 / (2 * l_p)\n            )\n            i_s = pybamm.outer(i_boundary_cc_0, 1 - (1 - x_p) / l_p)\n\n        variables.update(self._get_standard_potential_variables(phi_s))\n        variables.update(self._get_standard_current_variables(i_s))\n\n        if self.domain == \"Positive\":\n            variables.update(self._get_standard_whole_cell_variables(variables))\n\n        return variables",
  "def set_boundary_conditions(self, variables):\n\n        phi_s = variables[self.domain + \" electrode potential\"]\n        eps_0 = variables[\n            \"Leading-order x-averaged \" + self.domain.lower() + \" electrode porosity\"\n        ]\n        i_boundary_cc_0 = variables[\"Leading-order current collector current density\"]\n\n        if self.domain == \"Negative\":\n            lbc = (pybamm.Scalar(0), \"Dirichlet\")\n            rbc = (pybamm.Scalar(0), \"Neumann\")\n\n        elif self.domain == \"Positive\":\n            lbc = (pybamm.Scalar(0), \"Neumann\")\n            sigma_eff_0 = self.param.sigma_p * (1 - eps_0) ** self.param.b_p\n            rbc = (-i_boundary_cc_0 / sigma_eff_0, \"Neumann\")\n\n        self.boundary_conditions[phi_s] = {\"left\": lbc, \"right\": rbc}",
  "class BaseModel(BaseElectrode):\n    \"\"\"A base class for electrode submodels that employ\n    Ohm's law.\n\n    Parameters\n    ----------\n    param : parameter class\n        The parameters to use for this submodel\n    domain : str\n        Either 'Negative' or 'Positive'\n\n\n    **Extends:** :class:`pybamm.electrode.BaseElectrode`\n    \"\"\"\n\n    def __init__(self, param, domain, reactions=None):\n        super().__init__(param, domain, reactions)\n\n    def set_boundary_conditions(self, variables):\n\n        phi_s = variables[self.domain + \" electrode potential\"]\n        eps = variables[self.domain + \" electrode porosity\"]\n        i_boundary_cc = variables[\"Current collector current density\"]\n        phi_s_cn = variables[\"Negative current collector potential\"]\n\n        if self.domain == \"Negative\":\n            lbc = (phi_s_cn, \"Dirichlet\")\n            rbc = (pybamm.Scalar(0), \"Neumann\")\n\n        elif self.domain == \"Positive\":\n            lbc = (pybamm.Scalar(0), \"Neumann\")\n            sigma_eff = self.param.sigma_p * (1 - eps) ** self.param.b_p\n            rbc = (\n                i_boundary_cc / pybamm.boundary_value(-sigma_eff, \"right\"),\n                \"Neumann\",\n            )\n\n        self.boundary_conditions[phi_s] = {\"left\": lbc, \"right\": rbc}\n\n    @property\n    def default_solver(self):\n        \"\"\"\n        Create and return the default solver for this model\n        \"\"\"\n        return pybamm.ScikitsDaeSolver()",
  "def __init__(self, param, domain, reactions=None):\n        super().__init__(param, domain, reactions)",
  "def set_boundary_conditions(self, variables):\n\n        phi_s = variables[self.domain + \" electrode potential\"]\n        eps = variables[self.domain + \" electrode porosity\"]\n        i_boundary_cc = variables[\"Current collector current density\"]\n        phi_s_cn = variables[\"Negative current collector potential\"]\n\n        if self.domain == \"Negative\":\n            lbc = (phi_s_cn, \"Dirichlet\")\n            rbc = (pybamm.Scalar(0), \"Neumann\")\n\n        elif self.domain == \"Positive\":\n            lbc = (pybamm.Scalar(0), \"Neumann\")\n            sigma_eff = self.param.sigma_p * (1 - eps) ** self.param.b_p\n            rbc = (\n                i_boundary_cc / pybamm.boundary_value(-sigma_eff, \"right\"),\n                \"Neumann\",\n            )\n\n        self.boundary_conditions[phi_s] = {\"left\": lbc, \"right\": rbc}",
  "def default_solver(self):\n        \"\"\"\n        Create and return the default solver for this model\n        \"\"\"\n        return pybamm.ScikitsDaeSolver()",
  "class BaseInterface(pybamm.BaseSubModel):\n    \"\"\"\n    Base class for interfacial currents\n\n    Parameters\n    ----------\n    param : parameter class\n        The parameters to use for this submodel\n\n\n    **Extends:** :class:`pybamm.BaseSubModel`\n    \"\"\"\n\n    def __init__(self, param, domain):\n        super().__init__(param, domain)\n\n    def _get_delta_phi(self, variables):\n        \"Calculate delta_phi, and derived variables, using phi_s and phi_e\"\n        phi_s = variables[self.domain + \" electrode potential\"]\n        phi_e = variables[self.domain + \" electrolyte potential\"]\n        delta_phi = phi_s - phi_e\n        variables.update(\n            self._get_standard_surface_potential_difference_variables(delta_phi)\n        )\n        return variables\n\n    def _get_average_total_interfacial_current_density(self, variables):\n        \"\"\"\n        Method to obtain the average total interfacial current density.\n        \"\"\"\n\n        i_boundary_cc = variables[\"Current collector current density\"]\n\n        if self.domain == \"Negative\":\n            j_total_average = i_boundary_cc / pybamm.geometric_parameters.l_n\n\n        elif self.domain == \"Positive\":\n            j_total_average = -i_boundary_cc / pybamm.geometric_parameters.l_p\n\n        return j_total_average\n\n    def _get_standard_interfacial_current_variables(self, j):\n\n        i_typ = self.param.i_typ\n        L_x = self.param.L_x\n        if self.domain == \"Negative\":\n            j_scale = i_typ / (self.param.a_n_dim * L_x)\n        elif self.domain == \"Positive\":\n            j_scale = i_typ / (self.param.a_p_dim * L_x)\n\n        # Average, and broadcast if necessary\n        j_av = pybamm.x_average(j)\n        if j.domain == []:\n            j = pybamm.FullBroadcast(j, self.domain_for_broadcast, \"current collector\")\n        elif j.domain == [\"current collector\"]:\n            j = pybamm.PrimaryBroadcast(j, self.domain_for_broadcast)\n\n        variables = {\n            self.domain\n            + \" electrode\"\n            + self.reaction_name\n            + \" interfacial current density\": j,\n            \"X-averaged \"\n            + self.domain.lower()\n            + \" electrode\"\n            + self.reaction_name\n            + \" interfacial current density\": j_av,\n            self.domain\n            + \" electrode\"\n            + self.reaction_name\n            + \" interfacial current density [A.m-2]\": j_scale * j,\n            \"X-averaged \"\n            + self.domain.lower()\n            + \" electrode\"\n            + self.reaction_name\n            + \" interfacial current density [A.m-2]\": j_scale * j_av,\n            self.domain\n            + \" electrode\"\n            + self.reaction_name\n            + \" interfacial current density per volume [A.m-3]\": i_typ / L_x * j,\n            \"X-averaged \"\n            + self.domain.lower()\n            + \" electrode\"\n            + self.reaction_name\n            + \" interfacial current density per volume [A.m-3]\": i_typ / L_x * j_av,\n        }\n\n        return variables\n\n    def _get_standard_total_interfacial_current_variables(self, j_tot_av):\n\n        i_typ = self.param.i_typ\n        L_x = self.param.L_x\n        if self.domain == \"Negative\":\n            j_scale = i_typ / (self.param.a_n_dim * L_x)\n        elif self.domain == \"Positive\":\n            j_scale = i_typ / (self.param.a_p_dim * L_x)\n\n        variables = {\n            \"X-averaged \"\n            + self.domain.lower()\n            + \" electrode total interfacial current density\": j_tot_av,\n            \"X-averaged \"\n            + self.domain.lower()\n            + \" electrode total interfacial current density [A.m-2]\": j_scale\n            * j_tot_av,\n            \"X-averaged \"\n            + self.domain.lower()\n            + \" electrode total interfacial current density per volume [A.m-3]\": i_typ\n            / L_x\n            * j_tot_av,\n        }\n\n        return variables\n\n    def _get_standard_whole_cell_interfacial_current_variables(self, variables):\n\n        i_typ = self.param.i_typ\n        L_x = self.param.L_x\n        j_n_scale = i_typ / (self.param.a_n_dim * L_x)\n        j_p_scale = i_typ / (self.param.a_p_dim * L_x)\n\n        j_n = variables[\n            \"Negative electrode\" + self.reaction_name + \" interfacial current density\"\n        ]\n        j_s = pybamm.FullBroadcast(0, \"separator\", \"current collector\")\n        j_p = variables[\n            \"Positive electrode\" + self.reaction_name + \" interfacial current density\"\n        ]\n        j = pybamm.Concatenation(j_n, j_s, j_p)\n        j_dim = pybamm.Concatenation(j_n_scale * j_n, j_s, j_p_scale * j_p)\n\n        if self.reaction_name == \"\":\n            variables = {\n                \"Interfacial current density\": j,\n                \"Interfacial current density [A.m-2]\": j_dim,\n                \"Interfacial current density per volume [A.m-3]\": i_typ / L_x * j,\n            }\n        else:\n            reaction_name = self.reaction_name[1:].capitalize()\n            variables = {\n                reaction_name + \" interfacial current density\": j,\n                reaction_name + \" interfacial current density [A.m-2]\": j_dim,\n                reaction_name\n                + \" interfacial current density per volume [A.m-3]\": i_typ / L_x * j,\n            }\n\n        return variables\n\n    def _get_standard_exchange_current_variables(self, j0):\n\n        i_typ = self.param.i_typ\n        L_x = self.param.L_x\n        if self.domain == \"Negative\":\n            j_scale = i_typ / (self.param.a_n_dim * L_x)\n        elif self.domain == \"Positive\":\n            j_scale = i_typ / (self.param.a_p_dim * L_x)\n\n        # Average, and broadcast if necessary\n        j0_av = pybamm.x_average(j0)\n        if j0.domain == []:\n            j0 = pybamm.FullBroadcast(\n                j0, self.domain_for_broadcast, \"current collector\"\n            )\n        elif j0.domain == [\"current collector\"]:\n            j0 = pybamm.PrimaryBroadcast(j0, self.domain_for_broadcast)\n\n        variables = {\n            self.domain\n            + \" electrode\"\n            + self.reaction_name\n            + \" exchange current density\": j0,\n            \"X-averaged \"\n            + self.domain.lower()\n            + \" electrode\"\n            + self.reaction_name\n            + \" exchange current density\": j0_av,\n            self.domain\n            + \" electrode\"\n            + self.reaction_name\n            + \" exchange current density [A.m-2]\": j_scale * j0,\n            \"X-averaged \"\n            + self.domain.lower()\n            + \" electrode\"\n            + self.reaction_name\n            + \" exchange current density [A.m-2]\": j_scale * j0_av,\n            self.domain\n            + \" electrode\"\n            + self.reaction_name\n            + \" exchange current density per volume [A.m-3]\": i_typ / L_x * j0,\n            \"X-averaged \"\n            + self.domain.lower()\n            + \" electrode\"\n            + self.reaction_name\n            + \" exchange current density per volume [A.m-3]\": i_typ / L_x * j0_av,\n        }\n\n        return variables\n\n    def _get_standard_whole_cell_exchange_current_variables(self, variables):\n\n        i_typ = self.param.i_typ\n        L_x = self.param.L_x\n        j_n_scale = i_typ / (self.param.a_n_dim * L_x)\n        j_p_scale = i_typ / (self.param.a_p_dim * L_x)\n\n        j0_n = variables[\n            \"Negative electrode\" + self.reaction_name + \" exchange current density\"\n        ]\n        j0_s = pybamm.FullBroadcast(0, \"separator\", \"current collector\")\n        j0_p = variables[\n            \"Positive electrode\" + self.reaction_name + \" exchange current density\"\n        ]\n        j0 = pybamm.Concatenation(j0_n, j0_s, j0_p)\n        j0_dim = pybamm.Concatenation(j_n_scale * j0_n, j0_s, j_p_scale * j0_p)\n\n        if self.reaction_name == \"\":\n            variables = {\n                \"Exchange current density\": j0,\n                \"Exchange current density [A.m-2]\": j0_dim,\n                \"Exchange current density per volume [A.m-3]\": i_typ / L_x * j0,\n            }\n        else:\n            reaction_name = self.reaction_name[1:].capitalize()\n            variables = {\n                reaction_name + \" exchange current density\": j0,\n                reaction_name + \" exchange current density [A.m-2]\": j0_dim,\n                reaction_name\n                + \" exchange current density per volume [A.m-3]\": i_typ / L_x * j0,\n            }\n\n        return variables\n\n    def _get_standard_overpotential_variables(self, eta_r):\n\n        pot_scale = self.param.potential_scale\n        # Average, and broadcast if necessary\n        eta_r_av = pybamm.x_average(eta_r)\n        if eta_r.domain == []:\n            eta_r = pybamm.FullBroadcast(\n                eta_r, self.domain_for_broadcast, \"current collector\"\n            )\n        elif eta_r.domain == [\"current collector\"]:\n            eta_r = pybamm.PrimaryBroadcast(eta_r, self.domain_for_broadcast)\n\n        variables = {\n            self.domain\n            + \" electrode\"\n            + self.reaction_name\n            + \" reaction overpotential\": eta_r,\n            \"X-averaged \"\n            + self.domain.lower()\n            + \" electrode\"\n            + self.reaction_name\n            + \" reaction overpotential\": eta_r_av,\n            self.domain\n            + \" electrode\"\n            + self.reaction_name\n            + \" reaction overpotential [V]\": eta_r * pot_scale,\n            \"X-averaged \"\n            + self.domain.lower()\n            + \" electrode\"\n            + self.reaction_name\n            + \" reaction overpotential [V]\": eta_r_av * pot_scale,\n        }\n\n        return variables\n\n    def _get_standard_surface_potential_difference_variables(self, delta_phi):\n\n        if self.domain == \"Negative\":\n            ocp_ref = self.param.U_n_ref\n        elif self.domain == \"Positive\":\n            ocp_ref = self.param.U_p_ref\n        pot_scale = self.param.potential_scale\n\n        # Average, and broadcast if necessary\n        delta_phi_av = pybamm.x_average(delta_phi)\n        if delta_phi.domain == []:\n            delta_phi = pybamm.FullBroadcast(\n                delta_phi, self.domain_for_broadcast, \"current collector\"\n            )\n        elif delta_phi.domain == [\"current collector\"]:\n            delta_phi = pybamm.PrimaryBroadcast(delta_phi, self.domain_for_broadcast)\n\n        variables = {\n            self.domain + \" electrode surface potential difference\": delta_phi,\n            \"X-averaged \"\n            + self.domain.lower()\n            + \" electrode surface potential difference\": delta_phi_av,\n            self.domain\n            + \" electrode surface potential difference [V]\": ocp_ref\n            + delta_phi * pot_scale,\n            \"X-averaged \"\n            + self.domain.lower()\n            + \" electrode surface potential difference [V]\": ocp_ref\n            + delta_phi_av * pot_scale,\n        }\n\n        return variables\n\n    def _get_standard_ocp_variables(self, ocp, dUdT):\n        \"\"\"\n        A private function to obtain the open circuit potential and\n        related standard variables.\n\n        Parameters\n        ----------\n        ocp : :class:`pybamm.Symbol`\n            The open-circuit potential\n        dUdT : :class:`pybamm.Symbol`\n            The entropic change in ocp\n\n        Returns\n        -------\n        variables : dict\n            The variables dictionary including the open circuit potentials\n            and related standard variables.\n        \"\"\"\n\n        # Average, and broadcast if necessary\n        ocp_av = pybamm.x_average(ocp)\n        if ocp.domain == []:\n            ocp = pybamm.FullBroadcast(\n                ocp, self.domain_for_broadcast, \"current collector\"\n            )\n        elif ocp.domain == [\"current collector\"]:\n            ocp = pybamm.PrimaryBroadcast(ocp, self.domain_for_broadcast)\n        dUdT_av = pybamm.x_average(dUdT)\n\n        if self.domain == \"Negative\":\n            ocp_dim = self.param.U_n_ref + self.param.potential_scale * ocp\n            ocp_av_dim = self.param.U_n_ref + self.param.potential_scale * ocp_av\n        elif self.domain == \"Positive\":\n            ocp_dim = self.param.U_p_ref + self.param.potential_scale * ocp\n            ocp_av_dim = self.param.U_p_ref + self.param.potential_scale * ocp_av\n\n        variables = {\n            self.domain\n            + \" electrode\"\n            + self.reaction_name\n            + \" open circuit potential\": ocp,\n            self.domain\n            + \" electrode\"\n            + self.reaction_name\n            + \" open circuit potential [V]\": ocp_dim,\n            \"X-averaged \"\n            + self.domain.lower()\n            + \" electrode\"\n            + self.reaction_name\n            + \" open circuit potential\": ocp_av,\n            \"X-averaged \"\n            + self.domain.lower()\n            + \" electrode\"\n            + self.reaction_name\n            + \" open circuit potential [V]\": ocp_av_dim,\n            self.domain + \" electrode entropic change\": dUdT,\n            \"X-averaged \" + self.domain.lower() + \" electrode entropic change\": dUdT_av,\n        }\n\n        return variables",
  "def __init__(self, param, domain):\n        super().__init__(param, domain)",
  "def _get_delta_phi(self, variables):\n        \"Calculate delta_phi, and derived variables, using phi_s and phi_e\"\n        phi_s = variables[self.domain + \" electrode potential\"]\n        phi_e = variables[self.domain + \" electrolyte potential\"]\n        delta_phi = phi_s - phi_e\n        variables.update(\n            self._get_standard_surface_potential_difference_variables(delta_phi)\n        )\n        return variables",
  "def _get_average_total_interfacial_current_density(self, variables):\n        \"\"\"\n        Method to obtain the average total interfacial current density.\n        \"\"\"\n\n        i_boundary_cc = variables[\"Current collector current density\"]\n\n        if self.domain == \"Negative\":\n            j_total_average = i_boundary_cc / pybamm.geometric_parameters.l_n\n\n        elif self.domain == \"Positive\":\n            j_total_average = -i_boundary_cc / pybamm.geometric_parameters.l_p\n\n        return j_total_average",
  "def _get_standard_interfacial_current_variables(self, j):\n\n        i_typ = self.param.i_typ\n        L_x = self.param.L_x\n        if self.domain == \"Negative\":\n            j_scale = i_typ / (self.param.a_n_dim * L_x)\n        elif self.domain == \"Positive\":\n            j_scale = i_typ / (self.param.a_p_dim * L_x)\n\n        # Average, and broadcast if necessary\n        j_av = pybamm.x_average(j)\n        if j.domain == []:\n            j = pybamm.FullBroadcast(j, self.domain_for_broadcast, \"current collector\")\n        elif j.domain == [\"current collector\"]:\n            j = pybamm.PrimaryBroadcast(j, self.domain_for_broadcast)\n\n        variables = {\n            self.domain\n            + \" electrode\"\n            + self.reaction_name\n            + \" interfacial current density\": j,\n            \"X-averaged \"\n            + self.domain.lower()\n            + \" electrode\"\n            + self.reaction_name\n            + \" interfacial current density\": j_av,\n            self.domain\n            + \" electrode\"\n            + self.reaction_name\n            + \" interfacial current density [A.m-2]\": j_scale * j,\n            \"X-averaged \"\n            + self.domain.lower()\n            + \" electrode\"\n            + self.reaction_name\n            + \" interfacial current density [A.m-2]\": j_scale * j_av,\n            self.domain\n            + \" electrode\"\n            + self.reaction_name\n            + \" interfacial current density per volume [A.m-3]\": i_typ / L_x * j,\n            \"X-averaged \"\n            + self.domain.lower()\n            + \" electrode\"\n            + self.reaction_name\n            + \" interfacial current density per volume [A.m-3]\": i_typ / L_x * j_av,\n        }\n\n        return variables",
  "def _get_standard_total_interfacial_current_variables(self, j_tot_av):\n\n        i_typ = self.param.i_typ\n        L_x = self.param.L_x\n        if self.domain == \"Negative\":\n            j_scale = i_typ / (self.param.a_n_dim * L_x)\n        elif self.domain == \"Positive\":\n            j_scale = i_typ / (self.param.a_p_dim * L_x)\n\n        variables = {\n            \"X-averaged \"\n            + self.domain.lower()\n            + \" electrode total interfacial current density\": j_tot_av,\n            \"X-averaged \"\n            + self.domain.lower()\n            + \" electrode total interfacial current density [A.m-2]\": j_scale\n            * j_tot_av,\n            \"X-averaged \"\n            + self.domain.lower()\n            + \" electrode total interfacial current density per volume [A.m-3]\": i_typ\n            / L_x\n            * j_tot_av,\n        }\n\n        return variables",
  "def _get_standard_whole_cell_interfacial_current_variables(self, variables):\n\n        i_typ = self.param.i_typ\n        L_x = self.param.L_x\n        j_n_scale = i_typ / (self.param.a_n_dim * L_x)\n        j_p_scale = i_typ / (self.param.a_p_dim * L_x)\n\n        j_n = variables[\n            \"Negative electrode\" + self.reaction_name + \" interfacial current density\"\n        ]\n        j_s = pybamm.FullBroadcast(0, \"separator\", \"current collector\")\n        j_p = variables[\n            \"Positive electrode\" + self.reaction_name + \" interfacial current density\"\n        ]\n        j = pybamm.Concatenation(j_n, j_s, j_p)\n        j_dim = pybamm.Concatenation(j_n_scale * j_n, j_s, j_p_scale * j_p)\n\n        if self.reaction_name == \"\":\n            variables = {\n                \"Interfacial current density\": j,\n                \"Interfacial current density [A.m-2]\": j_dim,\n                \"Interfacial current density per volume [A.m-3]\": i_typ / L_x * j,\n            }\n        else:\n            reaction_name = self.reaction_name[1:].capitalize()\n            variables = {\n                reaction_name + \" interfacial current density\": j,\n                reaction_name + \" interfacial current density [A.m-2]\": j_dim,\n                reaction_name\n                + \" interfacial current density per volume [A.m-3]\": i_typ / L_x * j,\n            }\n\n        return variables",
  "def _get_standard_exchange_current_variables(self, j0):\n\n        i_typ = self.param.i_typ\n        L_x = self.param.L_x\n        if self.domain == \"Negative\":\n            j_scale = i_typ / (self.param.a_n_dim * L_x)\n        elif self.domain == \"Positive\":\n            j_scale = i_typ / (self.param.a_p_dim * L_x)\n\n        # Average, and broadcast if necessary\n        j0_av = pybamm.x_average(j0)\n        if j0.domain == []:\n            j0 = pybamm.FullBroadcast(\n                j0, self.domain_for_broadcast, \"current collector\"\n            )\n        elif j0.domain == [\"current collector\"]:\n            j0 = pybamm.PrimaryBroadcast(j0, self.domain_for_broadcast)\n\n        variables = {\n            self.domain\n            + \" electrode\"\n            + self.reaction_name\n            + \" exchange current density\": j0,\n            \"X-averaged \"\n            + self.domain.lower()\n            + \" electrode\"\n            + self.reaction_name\n            + \" exchange current density\": j0_av,\n            self.domain\n            + \" electrode\"\n            + self.reaction_name\n            + \" exchange current density [A.m-2]\": j_scale * j0,\n            \"X-averaged \"\n            + self.domain.lower()\n            + \" electrode\"\n            + self.reaction_name\n            + \" exchange current density [A.m-2]\": j_scale * j0_av,\n            self.domain\n            + \" electrode\"\n            + self.reaction_name\n            + \" exchange current density per volume [A.m-3]\": i_typ / L_x * j0,\n            \"X-averaged \"\n            + self.domain.lower()\n            + \" electrode\"\n            + self.reaction_name\n            + \" exchange current density per volume [A.m-3]\": i_typ / L_x * j0_av,\n        }\n\n        return variables",
  "def _get_standard_whole_cell_exchange_current_variables(self, variables):\n\n        i_typ = self.param.i_typ\n        L_x = self.param.L_x\n        j_n_scale = i_typ / (self.param.a_n_dim * L_x)\n        j_p_scale = i_typ / (self.param.a_p_dim * L_x)\n\n        j0_n = variables[\n            \"Negative electrode\" + self.reaction_name + \" exchange current density\"\n        ]\n        j0_s = pybamm.FullBroadcast(0, \"separator\", \"current collector\")\n        j0_p = variables[\n            \"Positive electrode\" + self.reaction_name + \" exchange current density\"\n        ]\n        j0 = pybamm.Concatenation(j0_n, j0_s, j0_p)\n        j0_dim = pybamm.Concatenation(j_n_scale * j0_n, j0_s, j_p_scale * j0_p)\n\n        if self.reaction_name == \"\":\n            variables = {\n                \"Exchange current density\": j0,\n                \"Exchange current density [A.m-2]\": j0_dim,\n                \"Exchange current density per volume [A.m-3]\": i_typ / L_x * j0,\n            }\n        else:\n            reaction_name = self.reaction_name[1:].capitalize()\n            variables = {\n                reaction_name + \" exchange current density\": j0,\n                reaction_name + \" exchange current density [A.m-2]\": j0_dim,\n                reaction_name\n                + \" exchange current density per volume [A.m-3]\": i_typ / L_x * j0,\n            }\n\n        return variables",
  "def _get_standard_overpotential_variables(self, eta_r):\n\n        pot_scale = self.param.potential_scale\n        # Average, and broadcast if necessary\n        eta_r_av = pybamm.x_average(eta_r)\n        if eta_r.domain == []:\n            eta_r = pybamm.FullBroadcast(\n                eta_r, self.domain_for_broadcast, \"current collector\"\n            )\n        elif eta_r.domain == [\"current collector\"]:\n            eta_r = pybamm.PrimaryBroadcast(eta_r, self.domain_for_broadcast)\n\n        variables = {\n            self.domain\n            + \" electrode\"\n            + self.reaction_name\n            + \" reaction overpotential\": eta_r,\n            \"X-averaged \"\n            + self.domain.lower()\n            + \" electrode\"\n            + self.reaction_name\n            + \" reaction overpotential\": eta_r_av,\n            self.domain\n            + \" electrode\"\n            + self.reaction_name\n            + \" reaction overpotential [V]\": eta_r * pot_scale,\n            \"X-averaged \"\n            + self.domain.lower()\n            + \" electrode\"\n            + self.reaction_name\n            + \" reaction overpotential [V]\": eta_r_av * pot_scale,\n        }\n\n        return variables",
  "def _get_standard_surface_potential_difference_variables(self, delta_phi):\n\n        if self.domain == \"Negative\":\n            ocp_ref = self.param.U_n_ref\n        elif self.domain == \"Positive\":\n            ocp_ref = self.param.U_p_ref\n        pot_scale = self.param.potential_scale\n\n        # Average, and broadcast if necessary\n        delta_phi_av = pybamm.x_average(delta_phi)\n        if delta_phi.domain == []:\n            delta_phi = pybamm.FullBroadcast(\n                delta_phi, self.domain_for_broadcast, \"current collector\"\n            )\n        elif delta_phi.domain == [\"current collector\"]:\n            delta_phi = pybamm.PrimaryBroadcast(delta_phi, self.domain_for_broadcast)\n\n        variables = {\n            self.domain + \" electrode surface potential difference\": delta_phi,\n            \"X-averaged \"\n            + self.domain.lower()\n            + \" electrode surface potential difference\": delta_phi_av,\n            self.domain\n            + \" electrode surface potential difference [V]\": ocp_ref\n            + delta_phi * pot_scale,\n            \"X-averaged \"\n            + self.domain.lower()\n            + \" electrode surface potential difference [V]\": ocp_ref\n            + delta_phi_av * pot_scale,\n        }\n\n        return variables",
  "def _get_standard_ocp_variables(self, ocp, dUdT):\n        \"\"\"\n        A private function to obtain the open circuit potential and\n        related standard variables.\n\n        Parameters\n        ----------\n        ocp : :class:`pybamm.Symbol`\n            The open-circuit potential\n        dUdT : :class:`pybamm.Symbol`\n            The entropic change in ocp\n\n        Returns\n        -------\n        variables : dict\n            The variables dictionary including the open circuit potentials\n            and related standard variables.\n        \"\"\"\n\n        # Average, and broadcast if necessary\n        ocp_av = pybamm.x_average(ocp)\n        if ocp.domain == []:\n            ocp = pybamm.FullBroadcast(\n                ocp, self.domain_for_broadcast, \"current collector\"\n            )\n        elif ocp.domain == [\"current collector\"]:\n            ocp = pybamm.PrimaryBroadcast(ocp, self.domain_for_broadcast)\n        dUdT_av = pybamm.x_average(dUdT)\n\n        if self.domain == \"Negative\":\n            ocp_dim = self.param.U_n_ref + self.param.potential_scale * ocp\n            ocp_av_dim = self.param.U_n_ref + self.param.potential_scale * ocp_av\n        elif self.domain == \"Positive\":\n            ocp_dim = self.param.U_p_ref + self.param.potential_scale * ocp\n            ocp_av_dim = self.param.U_p_ref + self.param.potential_scale * ocp_av\n\n        variables = {\n            self.domain\n            + \" electrode\"\n            + self.reaction_name\n            + \" open circuit potential\": ocp,\n            self.domain\n            + \" electrode\"\n            + self.reaction_name\n            + \" open circuit potential [V]\": ocp_dim,\n            \"X-averaged \"\n            + self.domain.lower()\n            + \" electrode\"\n            + self.reaction_name\n            + \" open circuit potential\": ocp_av,\n            \"X-averaged \"\n            + self.domain.lower()\n            + \" electrode\"\n            + self.reaction_name\n            + \" open circuit potential [V]\": ocp_av_dim,\n            self.domain + \" electrode entropic change\": dUdT,\n            \"X-averaged \" + self.domain.lower() + \" electrode entropic change\": dUdT_av,\n        }\n\n        return variables",
  "class BaseInterfaceLithiumIon(BaseInterface):\n    \"\"\"\n    Base lthium-ion interface class\n\n    Parameters\n    ----------\n    param :\n        model parameters\n    domain : str\n        The domain to implement the model, either: 'Negative' or 'Positive'.\n\n\n    **Extends:** :class:`pybamm.interface.BaseInterface`\n    \"\"\"\n\n    def __init__(self, param, domain):\n        super().__init__(param, domain)\n        self.reaction_name = \"\"  # empty reaction name, assumed to be the main reaction\n\n    def _get_exchange_current_density(self, variables):\n        \"\"\"\n        A private function to obtain the exchange current density for a lithium-ion\n        deposition reaction.\n\n        Parameters\n        ----------\n        variables: dict\n        `   The variables in the full model.\n\n        Returns\n        -------\n        j0 : :class: `pybamm.Symbol`\n            The exchange current density.\n        \"\"\"\n        c_s_surf = variables[self.domain + \" particle surface concentration\"]\n        c_e = variables[self.domain + \" electrolyte concentration\"]\n        T = variables[self.domain + \" electrode temperature\"]\n\n        if self.domain == \"Negative\":\n            prefactor = self.param.m_n(T) / self.param.C_r_n\n\n        elif self.domain == \"Positive\":\n            prefactor = self.param.gamma_p * self.param.m_p(T) / self.param.C_r_p\n\n        j0 = prefactor * (\n            c_e ** (1 / 2) * c_s_surf ** (1 / 2) * (1 - c_s_surf) ** (1 / 2)\n        )\n\n        return j0\n\n    def _get_open_circuit_potential(self, variables):\n        \"\"\"\n        A private function to obtain the open circuit potential and entropic change\n\n        Parameters\n        ----------\n        variables: dict\n            The variables in the full model.\n\n        Returns\n        -------\n        ocp : :class:`pybamm.Symbol`\n            The open-circuit potential\n        dUdT : :class:`pybamm.Symbol`\n            The entropic change in open-circuit potential due to temperature\n\n        \"\"\"\n        c_s_surf = variables[self.domain + \" particle surface concentration\"]\n        T = variables[self.domain + \" electrode temperature\"]\n\n        if self.domain == \"Negative\":\n            ocp = self.param.U_n(c_s_surf, T)\n            dUdT = self.param.dUdT_n(c_s_surf)\n\n        elif self.domain == \"Positive\":\n            ocp = self.param.U_p(c_s_surf, T)\n            dUdT = self.param.dUdT_p(c_s_surf)\n\n        return ocp, dUdT\n\n    def _get_number_of_electrons_in_reaction(self):\n        if self.domain == \"Negative\":\n            ne = self.param.ne_n\n        elif self.domain == \"Positive\":\n            ne = self.param.ne_p\n        return ne",
  "class ButlerVolmer(BaseInterfaceLithiumIon, kinetics.ButlerVolmer):\n    \"\"\"\n    Extends :class:`BaseInterfaceLithiumIon` (for exchange-current density, etc) and\n    :class:`kinetics.ButlerVolmer` (for kinetics)\n    \"\"\"\n\n    def __init__(self, param, domain):\n        super().__init__(param, domain)",
  "class InverseButlerVolmer(\n    BaseInterfaceLithiumIon, inverse_kinetics.InverseButlerVolmer\n):\n    \"\"\"\n    Extends :class:`BaseInterfaceLithiumIon` (for exchange-current density, etc) and\n    :class:`inverse_kinetics.InverseButlerVolmer` (for kinetics)\n    \"\"\"\n\n    def __init__(self, param, domain):\n        super().__init__(param, domain)",
  "def __init__(self, param, domain):\n        super().__init__(param, domain)\n        self.reaction_name = \"\"",
  "def _get_exchange_current_density(self, variables):\n        \"\"\"\n        A private function to obtain the exchange current density for a lithium-ion\n        deposition reaction.\n\n        Parameters\n        ----------\n        variables: dict\n        `   The variables in the full model.\n\n        Returns\n        -------\n        j0 : :class: `pybamm.Symbol`\n            The exchange current density.\n        \"\"\"\n        c_s_surf = variables[self.domain + \" particle surface concentration\"]\n        c_e = variables[self.domain + \" electrolyte concentration\"]\n        T = variables[self.domain + \" electrode temperature\"]\n\n        if self.domain == \"Negative\":\n            prefactor = self.param.m_n(T) / self.param.C_r_n\n\n        elif self.domain == \"Positive\":\n            prefactor = self.param.gamma_p * self.param.m_p(T) / self.param.C_r_p\n\n        j0 = prefactor * (\n            c_e ** (1 / 2) * c_s_surf ** (1 / 2) * (1 - c_s_surf) ** (1 / 2)\n        )\n\n        return j0",
  "def _get_open_circuit_potential(self, variables):\n        \"\"\"\n        A private function to obtain the open circuit potential and entropic change\n\n        Parameters\n        ----------\n        variables: dict\n            The variables in the full model.\n\n        Returns\n        -------\n        ocp : :class:`pybamm.Symbol`\n            The open-circuit potential\n        dUdT : :class:`pybamm.Symbol`\n            The entropic change in open-circuit potential due to temperature\n\n        \"\"\"\n        c_s_surf = variables[self.domain + \" particle surface concentration\"]\n        T = variables[self.domain + \" electrode temperature\"]\n\n        if self.domain == \"Negative\":\n            ocp = self.param.U_n(c_s_surf, T)\n            dUdT = self.param.dUdT_n(c_s_surf)\n\n        elif self.domain == \"Positive\":\n            ocp = self.param.U_p(c_s_surf, T)\n            dUdT = self.param.dUdT_p(c_s_surf)\n\n        return ocp, dUdT",
  "def _get_number_of_electrons_in_reaction(self):\n        if self.domain == \"Negative\":\n            ne = self.param.ne_n\n        elif self.domain == \"Positive\":\n            ne = self.param.ne_p\n        return ne",
  "def __init__(self, param, domain):\n        super().__init__(param, domain)",
  "def __init__(self, param, domain):\n        super().__init__(param, domain)",
  "class BaseInterfaceOxygenLeadAcid(BaseInterface):\n    \"\"\"\n    Base lead-acid interface class\n\n    Parameters\n    ----------\n    param :\n        model parameters\n    domain : str\n        The domain to implement the model, either: 'Negative' or 'Positive'.\n\n\n    **Extends:** :class:`pybamm.interface.BaseInterface`\n    \"\"\"\n\n    def __init__(self, param, domain):\n        super().__init__(param, domain)\n        self.reaction_name = \" oxygen\"\n\n    def _get_exchange_current_density(self, variables):\n        \"\"\"\n        A private function to obtain the exchange current density for a lead acid\n        deposition reaction.\n\n        Parameters\n        ----------\n        variables: dict\n            The variables in the full model.\n\n        Returns\n        -------\n        j0 : :class: `pybamm.Symbol`\n            The exchange current density.\n        \"\"\"\n        c_e = variables[self.domain + \" electrolyte concentration\"]\n        # If c_e was broadcast, take only the orphan\n        if isinstance(c_e, pybamm.Broadcast):\n            c_e = c_e.orphans[0]\n\n        if self.domain == \"Negative\":\n            j0 = pybamm.Scalar(0)\n        elif self.domain == \"Positive\":\n            j0 = self.param.j0_p_Ox_ref * c_e  # ** self.param.exponent_e_Ox\n\n        return j0\n\n    def _get_open_circuit_potential(self, variables):\n        \"\"\"\n        A private function to obtain the open circuit potential and entropic change\n\n        Parameters\n        ----------\n        variables: dict\n            The variables in the full model.\n\n        Returns\n        -------\n        ocp : :class:`pybamm.Symbol`\n            The open-circuit potential\n        dUdT : :class:`pybamm.Symbol`\n            The entropic change in open-circuit potential due to temperature\n\n        \"\"\"\n        if self.domain == \"Negative\":\n            ocp = self.param.U_n_Ox\n        elif self.domain == \"Positive\":\n            ocp = self.param.U_p_Ox\n\n        dUdT = pybamm.Scalar(0)\n\n        return ocp, dUdT\n\n    def _get_number_of_electrons_in_reaction(self):\n        return self.param.ne_Ox",
  "class ForwardTafel(BaseInterfaceOxygenLeadAcid, kinetics.ForwardTafel):\n    \"\"\"\n    Extends :class:`BaseInterfaceOxygenLeadAcid` (for exchange-current density, etc) and\n    :class:`kinetics.ForwardTafel` (for kinetics)\n    \"\"\"\n\n    def __init__(self, param, domain):\n        super().__init__(param, domain)",
  "class FirstOrderForwardTafel(\n    BaseInterfaceOxygenLeadAcid, kinetics.FirstOrderForwardTafel\n):\n    \"\"\"\n    Extends :class:`BaseInterfaceOxygenLeadAcid` (for exchange-current density, etc) and\n    :class:`kinetics.ForwardTafel` (for kinetics)\n    \"\"\"\n\n    def __init__(self, param, domain):\n        super().__init__(param, domain)",
  "class LeadingOrderDiffusionLimited(\n    BaseInterfaceOxygenLeadAcid, diffusion_limited.LeadingOrderDiffusionLimited\n):\n    \"\"\"\n    Extends :class:`BaseInterfaceOxygenLeadAcid` (for exchange-current density, etc) and\n    :class:`kinetics.LeadingOrderDiffusionLimited` (for kinetics)\n    \"\"\"\n\n    def __init__(self, param, domain):\n        super().__init__(param, domain)",
  "class FullDiffusionLimited(\n    BaseInterfaceOxygenLeadAcid, diffusion_limited.FullDiffusionLimited\n):\n    \"\"\"\n    Extends :class:`BaseInterfaceOxygenLeadAcid` (for exchange-current density, etc) and\n    :class:`kinetics.FullDiffusionLimited` (for kinetics)\n    \"\"\"\n\n    def __init__(self, param, domain):\n        super().__init__(param, domain)",
  "class NoReaction(BaseInterfaceOxygenLeadAcid, kinetics.NoReaction):\n    \"\"\"\n    Extends :class:`BaseInterfaceOxygenLeadAcid` (for exchange-current density, etc) and\n    :class:`kinetics.NoReaction` (for kinetics)\n    \"\"\"\n\n    def __init__(self, param, domain):\n        super().__init__(param, domain)",
  "def __init__(self, param, domain):\n        super().__init__(param, domain)\n        self.reaction_name = \" oxygen\"",
  "def _get_exchange_current_density(self, variables):\n        \"\"\"\n        A private function to obtain the exchange current density for a lead acid\n        deposition reaction.\n\n        Parameters\n        ----------\n        variables: dict\n            The variables in the full model.\n\n        Returns\n        -------\n        j0 : :class: `pybamm.Symbol`\n            The exchange current density.\n        \"\"\"\n        c_e = variables[self.domain + \" electrolyte concentration\"]\n        # If c_e was broadcast, take only the orphan\n        if isinstance(c_e, pybamm.Broadcast):\n            c_e = c_e.orphans[0]\n\n        if self.domain == \"Negative\":\n            j0 = pybamm.Scalar(0)\n        elif self.domain == \"Positive\":\n            j0 = self.param.j0_p_Ox_ref * c_e  # ** self.param.exponent_e_Ox\n\n        return j0",
  "def _get_open_circuit_potential(self, variables):\n        \"\"\"\n        A private function to obtain the open circuit potential and entropic change\n\n        Parameters\n        ----------\n        variables: dict\n            The variables in the full model.\n\n        Returns\n        -------\n        ocp : :class:`pybamm.Symbol`\n            The open-circuit potential\n        dUdT : :class:`pybamm.Symbol`\n            The entropic change in open-circuit potential due to temperature\n\n        \"\"\"\n        if self.domain == \"Negative\":\n            ocp = self.param.U_n_Ox\n        elif self.domain == \"Positive\":\n            ocp = self.param.U_p_Ox\n\n        dUdT = pybamm.Scalar(0)\n\n        return ocp, dUdT",
  "def _get_number_of_electrons_in_reaction(self):\n        return self.param.ne_Ox",
  "def __init__(self, param, domain):\n        super().__init__(param, domain)",
  "def __init__(self, param, domain):\n        super().__init__(param, domain)",
  "def __init__(self, param, domain):\n        super().__init__(param, domain)",
  "def __init__(self, param, domain):\n        super().__init__(param, domain)",
  "def __init__(self, param, domain):\n        super().__init__(param, domain)",
  "class BaseInterfaceLeadAcid(BaseInterface):\n    \"\"\"\n    Base lead-acid interface class\n\n    Parameters\n    ----------\n    param :\n        model parameters\n    domain : str\n        The domain to implement the model, either: 'Negative' or 'Positive'.\n\n\n    **Extends:** :class:`pybamm.interface.BaseInterface`\n    \"\"\"\n\n    def __init__(self, param, domain):\n        super().__init__(param, domain)\n        self.reaction_name = \"\"  # empty reaction name, assumed to be the main reaction\n\n    def _get_exchange_current_density(self, variables):\n        \"\"\"\n        A private function to obtain the exchange current density for a lead acid\n        deposition reaction.\n\n        Parameters\n        ----------\n        variables: dict\n        `   The variables in the full model.\n\n        Returns\n        -------\n        j0 : :class: `pybamm.Symbol`\n            The exchange current density.\n        \"\"\"\n        c_e = variables[self.domain + \" electrolyte concentration\"]\n        # If c_e was broadcast, take only the orphan\n        if isinstance(c_e, pybamm.Broadcast):\n            c_e = c_e.orphans[0]\n\n        if self.domain == \"Negative\":\n            j0 = self.param.j0_n_S_ref * c_e\n\n        elif self.domain == \"Positive\":\n            c_w = self.param.c_w(c_e)\n            j0 = self.param.j0_p_S_ref * c_e ** 2 * c_w\n\n        return j0\n\n    def _get_open_circuit_potential(self, variables):\n        \"\"\"\n        A private function to obtain the open circuit potential and entropic change\n\n        Parameters\n        ----------\n        variables: dict\n            The variables in the full model.\n\n        Returns\n        -------\n        ocp : :class:`pybamm.Symbol`\n            The open-circuit potential\n        dUdT : :class:`pybamm.Symbol`\n            The entropic change in open-circuit potential due to temperature\n\n        \"\"\"\n\n        c_e = variables[self.domain + \" electrolyte concentration\"]\n        # If c_e was broadcast, take only the orphan\n        if isinstance(c_e, pybamm.Broadcast):\n            c_e = c_e.orphans[0]\n\n        if self.domain == \"Negative\":\n            ocp = self.param.U_n(c_e, self.param.T_ref)\n        elif self.domain == \"Positive\":\n            ocp = self.param.U_p(c_e, self.param.T_ref)\n\n        dUdT = pybamm.Scalar(0)\n\n        return ocp, dUdT\n\n    def _get_number_of_electrons_in_reaction(self):\n        if self.domain == \"Negative\":\n            ne = self.param.ne_n\n        elif self.domain == \"Positive\":\n            ne = self.param.ne_p\n        return ne",
  "class ButlerVolmer(BaseInterfaceLeadAcid, kinetics.ButlerVolmer):\n    \"\"\"\n    Extends :class:`BaseInterfaceLeadAcid` (for exchange-current density, etc) and\n    :class:`kinetics.ButlerVolmer` (for kinetics)\n    \"\"\"\n\n    def __init__(self, param, domain):\n        super().__init__(param, domain)",
  "class FirstOrderButlerVolmer(BaseInterfaceLeadAcid, kinetics.FirstOrderButlerVolmer):\n    \"\"\"\n    Extends :class:`BaseInterfaceLeadAcid` (for exchange-current density, etc) and\n    :class:`kinetics.FirstOrderButlerVolmer` (for kinetics)\n    \"\"\"\n\n    def __init__(self, param, domain):\n        super().__init__(param, domain)",
  "class InverseFirstOrderKinetics(\n    BaseInterfaceLeadAcid, inverse_kinetics.BaseInverseFirstOrderKinetics\n):\n    \"\"\"\n    Extends :class:`BaseInterfaceLeadAcid` (for exchange-current density, etc) and\n    :class:`kinetics.BaseInverseFirstOrderKinetics` (for kinetics)\n    \"\"\"\n\n    def __init__(self, param, domain):\n        super().__init__(param, domain)",
  "class InverseButlerVolmer(BaseInterfaceLeadAcid, inverse_kinetics.InverseButlerVolmer):\n    \"\"\"\n    Extends :class:`BaseInterfaceLeadAcid` (for exchange-current density, etc) and\n    :class:`inverse_kinetics.InverseButlerVolmer` (for kinetics)\n    \"\"\"\n\n    def __init__(self, param, domain):\n        super().__init__(param, domain)",
  "def __init__(self, param, domain):\n        super().__init__(param, domain)\n        self.reaction_name = \"\"",
  "def _get_exchange_current_density(self, variables):\n        \"\"\"\n        A private function to obtain the exchange current density for a lead acid\n        deposition reaction.\n\n        Parameters\n        ----------\n        variables: dict\n        `   The variables in the full model.\n\n        Returns\n        -------\n        j0 : :class: `pybamm.Symbol`\n            The exchange current density.\n        \"\"\"\n        c_e = variables[self.domain + \" electrolyte concentration\"]\n        # If c_e was broadcast, take only the orphan\n        if isinstance(c_e, pybamm.Broadcast):\n            c_e = c_e.orphans[0]\n\n        if self.domain == \"Negative\":\n            j0 = self.param.j0_n_S_ref * c_e\n\n        elif self.domain == \"Positive\":\n            c_w = self.param.c_w(c_e)\n            j0 = self.param.j0_p_S_ref * c_e ** 2 * c_w\n\n        return j0",
  "def _get_open_circuit_potential(self, variables):\n        \"\"\"\n        A private function to obtain the open circuit potential and entropic change\n\n        Parameters\n        ----------\n        variables: dict\n            The variables in the full model.\n\n        Returns\n        -------\n        ocp : :class:`pybamm.Symbol`\n            The open-circuit potential\n        dUdT : :class:`pybamm.Symbol`\n            The entropic change in open-circuit potential due to temperature\n\n        \"\"\"\n\n        c_e = variables[self.domain + \" electrolyte concentration\"]\n        # If c_e was broadcast, take only the orphan\n        if isinstance(c_e, pybamm.Broadcast):\n            c_e = c_e.orphans[0]\n\n        if self.domain == \"Negative\":\n            ocp = self.param.U_n(c_e, self.param.T_ref)\n        elif self.domain == \"Positive\":\n            ocp = self.param.U_p(c_e, self.param.T_ref)\n\n        dUdT = pybamm.Scalar(0)\n\n        return ocp, dUdT",
  "def _get_number_of_electrons_in_reaction(self):\n        if self.domain == \"Negative\":\n            ne = self.param.ne_n\n        elif self.domain == \"Positive\":\n            ne = self.param.ne_p\n        return ne",
  "def __init__(self, param, domain):\n        super().__init__(param, domain)",
  "def __init__(self, param, domain):\n        super().__init__(param, domain)",
  "def __init__(self, param, domain):\n        super().__init__(param, domain)",
  "def __init__(self, param, domain):\n        super().__init__(param, domain)",
  "class NoReaction(BaseModel):\n    \"\"\"\n    Base submodel for when no reaction occurs\n\n    Parameters\n    ----------\n    param :\n        model parameters\n    domain : str\n        The domain to implement the model, either: 'Negative' or 'Positive'.\n\n\n    **Extends:** :class:`pybamm.interface.kinetics.BaseModel`\n    \"\"\"\n\n    def __init__(self, param, domain):\n        super().__init__(param, domain)\n\n    def _get_kinetics(self, j0, ne, eta_r):\n        return pybamm.Scalar(0)",
  "def __init__(self, param, domain):\n        super().__init__(param, domain)",
  "def _get_kinetics(self, j0, ne, eta_r):\n        return pybamm.Scalar(0)",
  "class ForwardTafel(BaseModel):\n    \"\"\"\n    Base submodel which implements the forward Tafel equation:\n\n    .. math::\n        j = j_0(c) * \\\\exp(\\\\eta_r(c))\n\n    Parameters\n    ----------\n    param :\n        model parameters\n    domain : str\n        The domain to implement the model, either: 'Negative' or 'Positive'.\n\n\n    **Extends:** :class:`pybamm.interface.kinetics.BaseModel`\n    \"\"\"\n\n    def __init__(self, param, domain):\n        super().__init__(param, domain)\n\n    def _get_kinetics(self, j0, ne, eta_r):\n        return j0 * pybamm.exp((ne / 2) * eta_r)\n\n    def _get_dj_dc(self, variables):\n        \"See :meth:`pybamm.interface.kinetics.BaseKinetics._get_dj_dc`\"\n        c_e, delta_phi, j0, ne, ocp = self._get_interface_variables_for_first_order(\n            variables\n        )\n        eta_r = delta_phi - ocp\n        return 2 * j0.diff(c_e) * pybamm.exp((ne / 2) * eta_r)\n\n    def _get_dj_ddeltaphi(self, variables):\n        \"See :meth:`pybamm.interface.kinetics.BaseKinetics._get_dj_ddeltaphi`\"\n        _, delta_phi, j0, ne, ocp = self._get_interface_variables_for_first_order(\n            variables\n        )\n        eta_r = delta_phi - ocp\n        return 2 * j0 * (ne / 2) * pybamm.exp((ne / 2) * eta_r)",
  "class FirstOrderForwardTafel(ForwardTafel, BaseFirstOrderKinetics):\n    def __init__(self, param, domain):\n        super().__init__(param, domain)",
  "class BackwardTafel(BaseModel):\n    \"\"\"\n    Base submodel which implements the backward Tafel equation:\n\n    .. math::\n        j = -j_0(c) * \\\\exp(-\\\\eta_r(c))\n\n    Parameters\n    ----------\n    param :\n        model parameters\n    domain : str\n        The domain to implement the model, either: 'Negative' or 'Positive'.\n\n\n    **Extends:** :class:`pybamm.interface.kinetics.BaseModel`\n    \"\"\"\n\n    def __init__(self, param, domain):\n        super().__init__(param, domain)\n\n    def _get_kinetics(self, j0, ne, eta_r):\n        return -j0 * pybamm.exp(-(ne / 2) * eta_r)",
  "def __init__(self, param, domain):\n        super().__init__(param, domain)",
  "def _get_kinetics(self, j0, ne, eta_r):\n        return j0 * pybamm.exp((ne / 2) * eta_r)",
  "def _get_dj_dc(self, variables):\n        \"See :meth:`pybamm.interface.kinetics.BaseKinetics._get_dj_dc`\"\n        c_e, delta_phi, j0, ne, ocp = self._get_interface_variables_for_first_order(\n            variables\n        )\n        eta_r = delta_phi - ocp\n        return 2 * j0.diff(c_e) * pybamm.exp((ne / 2) * eta_r)",
  "def _get_dj_ddeltaphi(self, variables):\n        \"See :meth:`pybamm.interface.kinetics.BaseKinetics._get_dj_ddeltaphi`\"\n        _, delta_phi, j0, ne, ocp = self._get_interface_variables_for_first_order(\n            variables\n        )\n        eta_r = delta_phi - ocp\n        return 2 * j0 * (ne / 2) * pybamm.exp((ne / 2) * eta_r)",
  "def __init__(self, param, domain):\n        super().__init__(param, domain)",
  "def __init__(self, param, domain):\n        super().__init__(param, domain)",
  "def _get_kinetics(self, j0, ne, eta_r):\n        return -j0 * pybamm.exp(-(ne / 2) * eta_r)",
  "class BaseModel(BaseInterface):\n    \"\"\"\n    Base submodel for kinetics\n\n    Parameters\n    ----------\n    param :\n        model parameters\n    domain : str\n        The domain to implement the model, either: 'Negative' or 'Positive'.\n\n\n    **Extends:** :class:`pybamm.interface.BaseInterface`\n    \"\"\"\n\n    def __init__(self, param, domain):\n        super().__init__(param, domain)\n\n    def get_coupled_variables(self, variables):\n        # Calculate delta_phi from phi_s and phi_e if it isn't already known\n        if self.domain + \" electrode surface potential difference\" not in variables:\n            variables = self._get_delta_phi(variables)\n        delta_phi = variables[self.domain + \" electrode surface potential difference\"]\n        # If delta_phi was broadcast, take only the orphan\n        if isinstance(delta_phi, pybamm.Broadcast):\n            delta_phi = delta_phi.orphans[0]\n\n        # Get exchange-current density\n        j0 = self._get_exchange_current_density(variables)\n        # Get open-circuit potential variables and reaction overpotential\n        ocp, dUdT = self._get_open_circuit_potential(variables)\n        eta_r = delta_phi - ocp\n        # Get number of electrons in reaction\n        ne = self._get_number_of_electrons_in_reaction()\n\n        j = self._get_kinetics(j0, ne, eta_r)\n        j_tot_av = self._get_average_total_interfacial_current_density(variables)\n        # j = j_tot_av + (j - pybamm.x_average(j))  # enforce true average\n\n        variables.update(self._get_standard_interfacial_current_variables(j))\n        variables.update(\n            self._get_standard_total_interfacial_current_variables(j_tot_av)\n        )\n        variables.update(self._get_standard_exchange_current_variables(j0))\n        variables.update(self._get_standard_overpotential_variables(eta_r))\n        variables.update(self._get_standard_ocp_variables(ocp, dUdT))\n\n        if (\n            \"Negative electrode\" + self.reaction_name + \" interfacial current density\"\n            in variables\n            and \"Positive electrode\"\n            + self.reaction_name\n            + \" interfacial current density\"\n            in variables\n        ):\n            variables.update(\n                self._get_standard_whole_cell_interfacial_current_variables(variables)\n            )\n            variables.update(\n                self._get_standard_whole_cell_exchange_current_variables(variables)\n            )\n\n        return variables\n\n    def _get_exchange_current_density(self, variables):\n        raise NotImplementedError\n\n    def _get_kinetics(self, j0, ne, eta_r):\n        raise NotImplementedError\n\n    def _get_open_circuit_potential(self, variables):\n        raise NotImplementedError\n\n    def _get_dj_dc(self, variables):\n        \"\"\"\n        Default to calculate derivative of interfacial current density with respect to\n        concentration. Can be overwritten by specific kinetic functions.\n        \"\"\"\n        c_e, delta_phi, j0, ne, ocp = self._get_interface_variables_for_first_order(\n            variables\n        )\n        j = self._get_kinetics(j0, ne, delta_phi - ocp)\n        return j.diff(c_e)\n\n    def _get_dj_ddeltaphi(self, variables):\n        \"\"\"\n        Default to calculate derivative of interfacial current density with respect to\n        surface potential difference. Can be overwritten by specific kinetic functions.\n        \"\"\"\n        _, delta_phi, j0, ne, ocp = self._get_interface_variables_for_first_order(\n            variables\n        )\n        j = self._get_kinetics(j0, ne, delta_phi - ocp)\n        return j.diff(delta_phi)\n\n    def _get_interface_variables_for_first_order(self, variables):\n        # This is a bit of a hack, but we need to multiply electrolyte concentration by\n        # one to differentiate it from the electrolyte concentration inside the\n        # surface potential difference when taking j.diff(c_e) later on\n        c_e_0 = variables[\"Leading-order x-averaged electrolyte concentration\"] * 1\n        hacked_variables = {\n            **variables,\n            self.domain + \" electrolyte concentration\": c_e_0,\n        }\n        delta_phi = variables[\n            \"Leading-order x-averaged \"\n            + self.domain.lower()\n            + \" electrode surface potential difference\"\n        ]\n        j0 = self._get_exchange_current_density(hacked_variables)\n        ne = self._get_number_of_electrons_in_reaction()\n        ocp = self._get_open_circuit_potential(hacked_variables)[0]\n        return c_e_0, delta_phi, j0, ne, ocp\n\n    def _get_j_diffusion_limited_first_order(self, variables):\n        \"\"\"\n        First-order correction to the interfacial current density due to\n        diffusion-limited effects. For a general model the correction term is zero,\n        since the reaction is not diffusion-limited\n        \"\"\"\n        return pybamm.Scalar(0)",
  "def __init__(self, param, domain):\n        super().__init__(param, domain)",
  "def get_coupled_variables(self, variables):\n        # Calculate delta_phi from phi_s and phi_e if it isn't already known\n        if self.domain + \" electrode surface potential difference\" not in variables:\n            variables = self._get_delta_phi(variables)\n        delta_phi = variables[self.domain + \" electrode surface potential difference\"]\n        # If delta_phi was broadcast, take only the orphan\n        if isinstance(delta_phi, pybamm.Broadcast):\n            delta_phi = delta_phi.orphans[0]\n\n        # Get exchange-current density\n        j0 = self._get_exchange_current_density(variables)\n        # Get open-circuit potential variables and reaction overpotential\n        ocp, dUdT = self._get_open_circuit_potential(variables)\n        eta_r = delta_phi - ocp\n        # Get number of electrons in reaction\n        ne = self._get_number_of_electrons_in_reaction()\n\n        j = self._get_kinetics(j0, ne, eta_r)\n        j_tot_av = self._get_average_total_interfacial_current_density(variables)\n        # j = j_tot_av + (j - pybamm.x_average(j))  # enforce true average\n\n        variables.update(self._get_standard_interfacial_current_variables(j))\n        variables.update(\n            self._get_standard_total_interfacial_current_variables(j_tot_av)\n        )\n        variables.update(self._get_standard_exchange_current_variables(j0))\n        variables.update(self._get_standard_overpotential_variables(eta_r))\n        variables.update(self._get_standard_ocp_variables(ocp, dUdT))\n\n        if (\n            \"Negative electrode\" + self.reaction_name + \" interfacial current density\"\n            in variables\n            and \"Positive electrode\"\n            + self.reaction_name\n            + \" interfacial current density\"\n            in variables\n        ):\n            variables.update(\n                self._get_standard_whole_cell_interfacial_current_variables(variables)\n            )\n            variables.update(\n                self._get_standard_whole_cell_exchange_current_variables(variables)\n            )\n\n        return variables",
  "def _get_exchange_current_density(self, variables):\n        raise NotImplementedError",
  "def _get_kinetics(self, j0, ne, eta_r):\n        raise NotImplementedError",
  "def _get_open_circuit_potential(self, variables):\n        raise NotImplementedError",
  "def _get_dj_dc(self, variables):\n        \"\"\"\n        Default to calculate derivative of interfacial current density with respect to\n        concentration. Can be overwritten by specific kinetic functions.\n        \"\"\"\n        c_e, delta_phi, j0, ne, ocp = self._get_interface_variables_for_first_order(\n            variables\n        )\n        j = self._get_kinetics(j0, ne, delta_phi - ocp)\n        return j.diff(c_e)",
  "def _get_dj_ddeltaphi(self, variables):\n        \"\"\"\n        Default to calculate derivative of interfacial current density with respect to\n        surface potential difference. Can be overwritten by specific kinetic functions.\n        \"\"\"\n        _, delta_phi, j0, ne, ocp = self._get_interface_variables_for_first_order(\n            variables\n        )\n        j = self._get_kinetics(j0, ne, delta_phi - ocp)\n        return j.diff(delta_phi)",
  "def _get_interface_variables_for_first_order(self, variables):\n        # This is a bit of a hack, but we need to multiply electrolyte concentration by\n        # one to differentiate it from the electrolyte concentration inside the\n        # surface potential difference when taking j.diff(c_e) later on\n        c_e_0 = variables[\"Leading-order x-averaged electrolyte concentration\"] * 1\n        hacked_variables = {\n            **variables,\n            self.domain + \" electrolyte concentration\": c_e_0,\n        }\n        delta_phi = variables[\n            \"Leading-order x-averaged \"\n            + self.domain.lower()\n            + \" electrode surface potential difference\"\n        ]\n        j0 = self._get_exchange_current_density(hacked_variables)\n        ne = self._get_number_of_electrons_in_reaction()\n        ocp = self._get_open_circuit_potential(hacked_variables)[0]\n        return c_e_0, delta_phi, j0, ne, ocp",
  "def _get_j_diffusion_limited_first_order(self, variables):\n        \"\"\"\n        First-order correction to the interfacial current density due to\n        diffusion-limited effects. For a general model the correction term is zero,\n        since the reaction is not diffusion-limited\n        \"\"\"\n        return pybamm.Scalar(0)",
  "class BaseFirstOrderKinetics(BaseModel):\n    \"\"\"\n    Base first-order kinetics\n\n    Parameters\n    ----------\n    param :\n        model parameters\n    domain : str\n        The domain to implement the model, either: 'Negative' or 'Positive'.\n\n\n    **Extends:** :class:`pybamm.interface.BaseInterface`\n    \"\"\"\n\n    def __init__(self, param, domain):\n        super().__init__(param, domain)\n\n    def get_coupled_variables(self, variables):\n        # Unpack\n        c_e_0 = variables[\n            \"Leading-order \" + self.domain.lower() + \" electrolyte concentration\"\n        ]\n        c_e = variables[self.domain + \" electrolyte concentration\"]\n        c_e_1 = (c_e - c_e_0) / self.param.C_e\n\n        dj_dc_0 = self._get_dj_dc(variables)\n        dj_ddeltaphi_0 = self._get_dj_ddeltaphi(variables)\n\n        # Update delta_phi with new phi_e and phi_s\n        variables = self._get_delta_phi(variables)\n\n        delta_phi_0 = variables[\n            \"Leading-order \"\n            + self.domain.lower()\n            + \" electrode surface potential difference\"\n        ]\n        delta_phi = variables[self.domain + \" electrode surface potential difference\"]\n        delta_phi_1 = (delta_phi - delta_phi_0) / self.param.C_e\n\n        j_0 = variables[\n            \"Leading-order \"\n            + self.domain.lower()\n            + \" electrode\"\n            + self.reaction_name\n            + \" interfacial current density\"\n        ]\n        j_1 = (\n            pybamm.PrimaryBroadcast(dj_dc_0, self.domain_for_broadcast) * c_e_1\n            + pybamm.PrimaryBroadcast(dj_ddeltaphi_0, self.domain_for_broadcast)\n            * delta_phi_1\n        )\n        j = j_0 + self.param.C_e * j_1\n        # Get exchange-current density\n        j0 = self._get_exchange_current_density(variables)\n        # Get open-circuit potential variables and reaction overpotential\n        ocp, dUdT = self._get_open_circuit_potential(variables)\n        eta_r = delta_phi - ocp\n\n        variables.update(self._get_standard_interfacial_current_variables(j))\n        variables.update(self._get_standard_exchange_current_variables(j0))\n        variables.update(self._get_standard_overpotential_variables(eta_r))\n        variables.update(self._get_standard_ocp_variables(ocp, dUdT))\n\n        if (\n            \"Negative electrode\" + self.reaction_name + \" interfacial current density\"\n            in variables\n            and \"Positive electrode\"\n            + self.reaction_name\n            + \" interfacial current density\"\n            in variables\n        ):\n            variables.update(\n                self._get_standard_whole_cell_interfacial_current_variables(variables)\n            )\n            variables.update(\n                self._get_standard_whole_cell_exchange_current_variables(variables)\n            )\n\n        return variables",
  "def __init__(self, param, domain):\n        super().__init__(param, domain)",
  "def get_coupled_variables(self, variables):\n        # Unpack\n        c_e_0 = variables[\n            \"Leading-order \" + self.domain.lower() + \" electrolyte concentration\"\n        ]\n        c_e = variables[self.domain + \" electrolyte concentration\"]\n        c_e_1 = (c_e - c_e_0) / self.param.C_e\n\n        dj_dc_0 = self._get_dj_dc(variables)\n        dj_ddeltaphi_0 = self._get_dj_ddeltaphi(variables)\n\n        # Update delta_phi with new phi_e and phi_s\n        variables = self._get_delta_phi(variables)\n\n        delta_phi_0 = variables[\n            \"Leading-order \"\n            + self.domain.lower()\n            + \" electrode surface potential difference\"\n        ]\n        delta_phi = variables[self.domain + \" electrode surface potential difference\"]\n        delta_phi_1 = (delta_phi - delta_phi_0) / self.param.C_e\n\n        j_0 = variables[\n            \"Leading-order \"\n            + self.domain.lower()\n            + \" electrode\"\n            + self.reaction_name\n            + \" interfacial current density\"\n        ]\n        j_1 = (\n            pybamm.PrimaryBroadcast(dj_dc_0, self.domain_for_broadcast) * c_e_1\n            + pybamm.PrimaryBroadcast(dj_ddeltaphi_0, self.domain_for_broadcast)\n            * delta_phi_1\n        )\n        j = j_0 + self.param.C_e * j_1\n        # Get exchange-current density\n        j0 = self._get_exchange_current_density(variables)\n        # Get open-circuit potential variables and reaction overpotential\n        ocp, dUdT = self._get_open_circuit_potential(variables)\n        eta_r = delta_phi - ocp\n\n        variables.update(self._get_standard_interfacial_current_variables(j))\n        variables.update(self._get_standard_exchange_current_variables(j0))\n        variables.update(self._get_standard_overpotential_variables(eta_r))\n        variables.update(self._get_standard_ocp_variables(ocp, dUdT))\n\n        if (\n            \"Negative electrode\" + self.reaction_name + \" interfacial current density\"\n            in variables\n            and \"Positive electrode\"\n            + self.reaction_name\n            + \" interfacial current density\"\n            in variables\n        ):\n            variables.update(\n                self._get_standard_whole_cell_interfacial_current_variables(variables)\n            )\n            variables.update(\n                self._get_standard_whole_cell_exchange_current_variables(variables)\n            )\n\n        return variables",
  "class ButlerVolmer(BaseModel):\n    \"\"\"\n    Base submodel which implements the forward Butler-Volmer equation:\n\n    .. math::\n        j = j_0(c) * \\\\sinh(\\\\eta_r(c))\n\n    Parameters\n    ----------\n    param :\n        model parameters\n    domain : str\n        The domain to implement the model, either: 'Negative' or 'Positive'.\n\n\n    **Extends:** :class:`pybamm.interface.kinetics.BaseModel`\n    \"\"\"\n\n    def __init__(self, param, domain):\n        super().__init__(param, domain)\n\n    def _get_kinetics(self, j0, ne, eta_r):\n        return 2 * j0 * pybamm.sinh((ne / 2) * eta_r)\n\n    def _get_dj_dc(self, variables):\n        \"See :meth:`pybamm.interface.kinetics.BaseModel._get_dj_dc`\"\n        c_e, delta_phi, j0, ne, ocp = self._get_interface_variables_for_first_order(\n            variables\n        )\n        eta_r = delta_phi - ocp\n        return (2 * j0.diff(c_e) * pybamm.sinh((ne / 2) * eta_r)) - (\n            2 * j0 * (ne / 2) * ocp.diff(c_e) * pybamm.cosh((ne / 2) * eta_r)\n        )\n\n    def _get_dj_ddeltaphi(self, variables):\n        \"See :meth:`pybamm.interface.kinetics.BaseModel._get_dj_ddeltaphi`\"\n        _, delta_phi, j0, ne, ocp = self._get_interface_variables_for_first_order(\n            variables\n        )\n        eta_r = delta_phi - ocp\n        return 2 * j0 * (ne / 2) * pybamm.cosh((ne / 2) * eta_r)",
  "class FirstOrderButlerVolmer(ButlerVolmer, BaseFirstOrderKinetics):\n    def __init__(self, param, domain):\n        super().__init__(param, domain)",
  "def __init__(self, param, domain):\n        super().__init__(param, domain)",
  "def _get_kinetics(self, j0, ne, eta_r):\n        return 2 * j0 * pybamm.sinh((ne / 2) * eta_r)",
  "def _get_dj_dc(self, variables):\n        \"See :meth:`pybamm.interface.kinetics.BaseModel._get_dj_dc`\"\n        c_e, delta_phi, j0, ne, ocp = self._get_interface_variables_for_first_order(\n            variables\n        )\n        eta_r = delta_phi - ocp\n        return (2 * j0.diff(c_e) * pybamm.sinh((ne / 2) * eta_r)) - (\n            2 * j0 * (ne / 2) * ocp.diff(c_e) * pybamm.cosh((ne / 2) * eta_r)\n        )",
  "def _get_dj_ddeltaphi(self, variables):\n        \"See :meth:`pybamm.interface.kinetics.BaseModel._get_dj_ddeltaphi`\"\n        _, delta_phi, j0, ne, ocp = self._get_interface_variables_for_first_order(\n            variables\n        )\n        eta_r = delta_phi - ocp\n        return 2 * j0 * (ne / 2) * pybamm.cosh((ne / 2) * eta_r)",
  "def __init__(self, param, domain):\n        super().__init__(param, domain)",
  "class BaseInverseFirstOrderKinetics(BaseFirstOrderKinetics):\n    \"\"\"\n    Base inverse first-order kinetics\n\n    Parameters\n    ----------\n    param :\n        model parameters\n    domain : str\n        The domain to implement the model, either: 'Negative' or 'Positive'.\n\n\n    **Extends:** :class:`pybamm.interface.kinetics.BaseFirstOrderKinetics`\n    \"\"\"\n\n    def __init__(self, param, domain):\n        super().__init__(param, domain)\n\n    def _get_die1dx(self, variables):\n        i_boundary_cc = variables[\"Current collector current density\"]\n        i_boundary_cc_0 = variables[\"Leading-order current collector current density\"]\n        i_boundary_cc_1 = (i_boundary_cc - i_boundary_cc_0) / self.param.C_e\n\n        if self.domain == \"Negative\":\n            return i_boundary_cc_1 / self.param.l_n\n        elif self.domain == \"Positive\":\n            return -i_boundary_cc_1 / self.param.l_p\n\n    def get_coupled_variables(self, variables):\n        # Unpack\n        delta_phi_0 = variables[\n            \"Leading-order x-averaged \"\n            + self.domain.lower()\n            + \" electrode surface potential difference\"\n        ]\n        c_e_0 = variables[\"Leading-order x-averaged electrolyte concentration\"]\n        c_e_av = variables[\n            \"X-averaged \" + self.domain.lower() + \" electrolyte concentration\"\n        ]\n        c_e_1_av = (c_e_av - c_e_0) / self.param.C_e\n\n        # Get first-order current (this is zero in 1D)\n        die1_dx = self._get_die1dx(variables)\n\n        # Get derivatives of leading-order terms\n        sum_dj_dc_0 = sum(\n            reaction_submodel._get_dj_dc(variables)\n            for reaction_submodel in self.reaction_submodels\n        )\n        sum_dj_ddeltaphi_0 = sum(\n            reaction_submodel._get_dj_ddeltaphi(variables)\n            for reaction_submodel in self.reaction_submodels\n        )\n        sum_j_diffusion_limited_first_order = sum(\n            reaction_submodel._get_j_diffusion_limited_first_order(variables)\n            for reaction_submodel in self.reaction_submodels\n        )\n\n        delta_phi_1_av = (\n            die1_dx - (sum_dj_dc_0 * c_e_1_av + sum_j_diffusion_limited_first_order)\n        ) / sum_dj_ddeltaphi_0\n        delta_phi = delta_phi_0 + self.param.C_e * delta_phi_1_av\n\n        # Update variables dictionary\n        variables.update(\n            self._get_standard_surface_potential_difference_variables(delta_phi)\n        )\n\n        return variables",
  "def __init__(self, param, domain):\n        super().__init__(param, domain)",
  "def _get_die1dx(self, variables):\n        i_boundary_cc = variables[\"Current collector current density\"]\n        i_boundary_cc_0 = variables[\"Leading-order current collector current density\"]\n        i_boundary_cc_1 = (i_boundary_cc - i_boundary_cc_0) / self.param.C_e\n\n        if self.domain == \"Negative\":\n            return i_boundary_cc_1 / self.param.l_n\n        elif self.domain == \"Positive\":\n            return -i_boundary_cc_1 / self.param.l_p",
  "def get_coupled_variables(self, variables):\n        # Unpack\n        delta_phi_0 = variables[\n            \"Leading-order x-averaged \"\n            + self.domain.lower()\n            + \" electrode surface potential difference\"\n        ]\n        c_e_0 = variables[\"Leading-order x-averaged electrolyte concentration\"]\n        c_e_av = variables[\n            \"X-averaged \" + self.domain.lower() + \" electrolyte concentration\"\n        ]\n        c_e_1_av = (c_e_av - c_e_0) / self.param.C_e\n\n        # Get first-order current (this is zero in 1D)\n        die1_dx = self._get_die1dx(variables)\n\n        # Get derivatives of leading-order terms\n        sum_dj_dc_0 = sum(\n            reaction_submodel._get_dj_dc(variables)\n            for reaction_submodel in self.reaction_submodels\n        )\n        sum_dj_ddeltaphi_0 = sum(\n            reaction_submodel._get_dj_ddeltaphi(variables)\n            for reaction_submodel in self.reaction_submodels\n        )\n        sum_j_diffusion_limited_first_order = sum(\n            reaction_submodel._get_j_diffusion_limited_first_order(variables)\n            for reaction_submodel in self.reaction_submodels\n        )\n\n        delta_phi_1_av = (\n            die1_dx - (sum_dj_dc_0 * c_e_1_av + sum_j_diffusion_limited_first_order)\n        ) / sum_dj_ddeltaphi_0\n        delta_phi = delta_phi_0 + self.param.C_e * delta_phi_1_av\n\n        # Update variables dictionary\n        variables.update(\n            self._get_standard_surface_potential_difference_variables(delta_phi)\n        )\n\n        return variables",
  "class BaseInverseKinetics(BaseInterface):\n    \"\"\"\n    A base submodel that implements the inverted form of the Butler-Volmer relation to\n    solve for the reaction overpotential.\n\n    Parameters\n    ----------\n    param\n        Model parameters\n    domain : iter of str, optional\n        The domain(s) in which to compute the interfacial current. Default is None,\n        in which case j.domain is used.\n\n    **Extends:** :class:`pybamm.interface.kinetics.ButlerVolmer`\n\n    \"\"\"\n\n    def __init__(self, param, domain):\n        super().__init__(param, domain)\n\n    def get_coupled_variables(self, variables):\n        ocp, dUdT = self._get_open_circuit_potential(variables)\n\n        j0 = self._get_exchange_current_density(variables)\n        j_tot_av = self._get_average_total_interfacial_current_density(variables)\n        # Broadcast to match j0's domain\n        if j0.domain in [[], [\"current collector\"]]:\n            j = j_tot_av\n        else:\n            j = pybamm.PrimaryBroadcast(j_tot_av, [self.domain.lower() + \" electrode\"])\n\n        if self.domain == \"Negative\":\n            ne = self.param.ne_n\n        elif self.domain == \"Positive\":\n            ne = self.param.ne_p\n\n        eta_r = self._get_overpotential(j, j0, ne)\n        delta_phi = eta_r + ocp\n\n        variables.update(self._get_standard_interfacial_current_variables(j))\n        variables.update(\n            self._get_standard_total_interfacial_current_variables(j_tot_av)\n        )\n        variables.update(self._get_standard_exchange_current_variables(j0))\n        variables.update(self._get_standard_overpotential_variables(eta_r))\n        variables.update(\n            self._get_standard_surface_potential_difference_variables(delta_phi)\n        )\n        variables.update(self._get_standard_ocp_variables(ocp, dUdT))\n\n        if (\n            \"Negative electrode\" + self.reaction_name + \" interfacial current density\"\n            in variables\n            and \"Positive electrode\"\n            + self.reaction_name\n            + \" interfacial current density\"\n            in variables\n        ):\n            variables.update(\n                self._get_standard_whole_cell_interfacial_current_variables(variables)\n            )\n            variables.update(\n                self._get_standard_whole_cell_exchange_current_variables(variables)\n            )\n\n        return variables\n\n    def _get_overpotential(self, j, j0, ne):\n        raise NotImplementedError",
  "def __init__(self, param, domain):\n        super().__init__(param, domain)",
  "def get_coupled_variables(self, variables):\n        ocp, dUdT = self._get_open_circuit_potential(variables)\n\n        j0 = self._get_exchange_current_density(variables)\n        j_tot_av = self._get_average_total_interfacial_current_density(variables)\n        # Broadcast to match j0's domain\n        if j0.domain in [[], [\"current collector\"]]:\n            j = j_tot_av\n        else:\n            j = pybamm.PrimaryBroadcast(j_tot_av, [self.domain.lower() + \" electrode\"])\n\n        if self.domain == \"Negative\":\n            ne = self.param.ne_n\n        elif self.domain == \"Positive\":\n            ne = self.param.ne_p\n\n        eta_r = self._get_overpotential(j, j0, ne)\n        delta_phi = eta_r + ocp\n\n        variables.update(self._get_standard_interfacial_current_variables(j))\n        variables.update(\n            self._get_standard_total_interfacial_current_variables(j_tot_av)\n        )\n        variables.update(self._get_standard_exchange_current_variables(j0))\n        variables.update(self._get_standard_overpotential_variables(eta_r))\n        variables.update(\n            self._get_standard_surface_potential_difference_variables(delta_phi)\n        )\n        variables.update(self._get_standard_ocp_variables(ocp, dUdT))\n\n        if (\n            \"Negative electrode\" + self.reaction_name + \" interfacial current density\"\n            in variables\n            and \"Positive electrode\"\n            + self.reaction_name\n            + \" interfacial current density\"\n            in variables\n        ):\n            variables.update(\n                self._get_standard_whole_cell_interfacial_current_variables(variables)\n            )\n            variables.update(\n                self._get_standard_whole_cell_exchange_current_variables(variables)\n            )\n\n        return variables",
  "def _get_overpotential(self, j, j0, ne):\n        raise NotImplementedError",
  "class InverseButlerVolmer(BaseInverseKinetics, ButlerVolmer):\n    \"\"\"\n    A base submodel that implements the inverted form of the Butler-Volmer relation to\n    solve for the reaction overpotential.\n\n    Parameters\n    ----------\n    param\n        Model parameters\n    domain : iter of str, optional\n        The domain(s) in which to compute the interfacial current. Default is None,\n        in which case j.domain is used.\n\n    **Extends:** :class:`pybamm.interface.kinetics.ButlerVolmer`\n\n    \"\"\"\n\n    def __init__(self, param, domain):\n        super().__init__(param, domain)\n\n    def _get_overpotential(self, j, j0, ne):\n        return (2 / ne) * pybamm.Function(np.arcsinh, j / (2 * j0))",
  "def __init__(self, param, domain):\n        super().__init__(param, domain)",
  "def _get_overpotential(self, j, j0, ne):\n        return (2 / ne) * pybamm.Function(np.arcsinh, j / (2 * j0))",
  "class BaseModel(BaseInterface):\n    \"\"\"\n    Leading-order submodel for diffusion-limited kinetics\n\n    Parameters\n    ----------\n    param :\n        model parameters\n    domain : str\n        The domain to implement the model, either: 'Negative' or 'Positive'.\n\n\n    **Extends:** :class:`pybamm.interface.BaseInterface`\n    \"\"\"\n\n    def __init__(self, param, domain):\n        super().__init__(param, domain)\n\n    def get_coupled_variables(self, variables):\n        # Calculate delta_phi_s from phi_s and phi_e if it isn't already known\n        if self.domain + \" electrode surface potential difference\" not in variables:\n            variables = self._get_delta_phi(variables)\n        delta_phi_s = variables[self.domain + \" electrode surface potential difference\"]\n        # If delta_phi_s was broadcast, take only the orphan\n        if isinstance(delta_phi_s, pybamm.Broadcast):\n            delta_phi_s = delta_phi_s.orphans[0]\n\n        # Get exchange-current density\n        j0 = self._get_exchange_current_density(variables)\n        # Get open-circuit potential variables and reaction overpotential\n        ocp, dUdT = self._get_open_circuit_potential(variables)\n        eta_r = delta_phi_s - ocp\n\n        # Get interfacial current densities\n        j = self._get_diffusion_limited_current_density(variables)\n        j_tot_av = self._get_average_total_interfacial_current_density(variables)\n\n        variables.update(self._get_standard_interfacial_current_variables(j))\n        variables.update(\n            self._get_standard_total_interfacial_current_variables(j_tot_av)\n        )\n        variables.update(self._get_standard_exchange_current_variables(j0))\n        variables.update(self._get_standard_overpotential_variables(eta_r))\n        variables.update(self._get_standard_ocp_variables(ocp, dUdT))\n\n        if (\n            \"Negative electrode\" + self.reaction_name + \" interfacial current density\"\n            in variables\n            and \"Positive electrode\"\n            + self.reaction_name\n            + \" interfacial current density\"\n            in variables\n        ):\n            variables.update(\n                self._get_standard_whole_cell_interfacial_current_variables(variables)\n            )\n            variables.update(\n                self._get_standard_whole_cell_exchange_current_variables(variables)\n            )\n\n        return variables\n\n    def _get_exchange_current_density(self, variables):\n        raise NotImplementedError\n\n    def _get_open_circuit_potential(self, variables):\n        raise NotImplementedError\n\n    def _get_diffusion_limited_current_density(self, variables):\n        raise NotImplementedError\n\n    def _get_dj_dc(self, variables):\n        return pybamm.Scalar(0)\n\n    def _get_dj_ddeltaphi(self, variables):\n        return pybamm.Scalar(0)",
  "def __init__(self, param, domain):\n        super().__init__(param, domain)",
  "def get_coupled_variables(self, variables):\n        # Calculate delta_phi_s from phi_s and phi_e if it isn't already known\n        if self.domain + \" electrode surface potential difference\" not in variables:\n            variables = self._get_delta_phi(variables)\n        delta_phi_s = variables[self.domain + \" electrode surface potential difference\"]\n        # If delta_phi_s was broadcast, take only the orphan\n        if isinstance(delta_phi_s, pybamm.Broadcast):\n            delta_phi_s = delta_phi_s.orphans[0]\n\n        # Get exchange-current density\n        j0 = self._get_exchange_current_density(variables)\n        # Get open-circuit potential variables and reaction overpotential\n        ocp, dUdT = self._get_open_circuit_potential(variables)\n        eta_r = delta_phi_s - ocp\n\n        # Get interfacial current densities\n        j = self._get_diffusion_limited_current_density(variables)\n        j_tot_av = self._get_average_total_interfacial_current_density(variables)\n\n        variables.update(self._get_standard_interfacial_current_variables(j))\n        variables.update(\n            self._get_standard_total_interfacial_current_variables(j_tot_av)\n        )\n        variables.update(self._get_standard_exchange_current_variables(j0))\n        variables.update(self._get_standard_overpotential_variables(eta_r))\n        variables.update(self._get_standard_ocp_variables(ocp, dUdT))\n\n        if (\n            \"Negative electrode\" + self.reaction_name + \" interfacial current density\"\n            in variables\n            and \"Positive electrode\"\n            + self.reaction_name\n            + \" interfacial current density\"\n            in variables\n        ):\n            variables.update(\n                self._get_standard_whole_cell_interfacial_current_variables(variables)\n            )\n            variables.update(\n                self._get_standard_whole_cell_exchange_current_variables(variables)\n            )\n\n        return variables",
  "def _get_exchange_current_density(self, variables):\n        raise NotImplementedError",
  "def _get_open_circuit_potential(self, variables):\n        raise NotImplementedError",
  "def _get_diffusion_limited_current_density(self, variables):\n        raise NotImplementedError",
  "def _get_dj_dc(self, variables):\n        return pybamm.Scalar(0)",
  "def _get_dj_ddeltaphi(self, variables):\n        return pybamm.Scalar(0)",
  "class LeadingOrderDiffusionLimited(BaseModel):\n    \"\"\"\n    Leading-order submodel for diffusion-limited kinetics\n\n    Parameters\n    ----------\n    param :\n        model parameters\n    domain : str\n        The domain to implement the model, either: 'Negative' or 'Positive'.\n\n\n    **Extends:** :class:`pybamm.interface.diffusion_limited.BaseModel`\n    \"\"\"\n\n    def __init__(self, param, domain):\n        super().__init__(param, domain)\n\n    def _get_diffusion_limited_current_density(self, variables):\n        if self.domain == \"Negative\":\n            j_p = variables[\n                \"X-averaged positive electrode\"\n                + self.reaction_name\n                + \" interfacial current density\"\n            ]\n            j = -self.param.l_p * j_p / self.param.l_n\n\n        return j\n\n    def _get_j_diffusion_limited_first_order(self, variables):\n        \"\"\"\n        First-order correction to the interfacial current density due to\n        diffusion-limited effects. For a general model the correction term is zero,\n        since the reaction is not diffusion-limited\n        \"\"\"\n        j_leading_order = variables[\n            \"Leading-order x-averaged \"\n            + self.domain.lower()\n            + \" electrode\"\n            + self.reaction_name\n            + \" interfacial current density\"\n        ]\n        param = self.param\n        if self.domain == \"Negative\":\n            N_ox_s_p = variables[\"Oxygen flux\"].orphans[1]\n            N_ox_neg_sep_interface = N_ox_s_p[0]\n\n            j = -N_ox_neg_sep_interface / param.C_e / param.s_ox_Ox / param.l_n\n\n        return (j - j_leading_order) / param.C_e",
  "def __init__(self, param, domain):\n        super().__init__(param, domain)",
  "def _get_diffusion_limited_current_density(self, variables):\n        if self.domain == \"Negative\":\n            j_p = variables[\n                \"X-averaged positive electrode\"\n                + self.reaction_name\n                + \" interfacial current density\"\n            ]\n            j = -self.param.l_p * j_p / self.param.l_n\n\n        return j",
  "def _get_j_diffusion_limited_first_order(self, variables):\n        \"\"\"\n        First-order correction to the interfacial current density due to\n        diffusion-limited effects. For a general model the correction term is zero,\n        since the reaction is not diffusion-limited\n        \"\"\"\n        j_leading_order = variables[\n            \"Leading-order x-averaged \"\n            + self.domain.lower()\n            + \" electrode\"\n            + self.reaction_name\n            + \" interfacial current density\"\n        ]\n        param = self.param\n        if self.domain == \"Negative\":\n            N_ox_s_p = variables[\"Oxygen flux\"].orphans[1]\n            N_ox_neg_sep_interface = N_ox_s_p[0]\n\n            j = -N_ox_neg_sep_interface / param.C_e / param.s_ox_Ox / param.l_n\n\n        return (j - j_leading_order) / param.C_e",
  "class FullDiffusionLimited(BaseModel):\n    \"\"\"\n    Full submodel for diffusion-limited kinetics\n\n    Parameters\n    ----------\n    param :\n        model parameters\n    domain : str\n        The domain to implement the model, either: 'Negative' or 'Positive'.\n\n\n    **Extends:** :class:`pybamm.interface.diffusion_limited.BaseModel`\n    \"\"\"\n\n    def __init__(self, param, domain):\n        super().__init__(param, domain)\n\n    def _get_diffusion_limited_current_density(self, variables):\n        param = self.param\n        if self.domain == \"Negative\":\n            eps_s = variables[\"Separator porosity\"]\n            c_ox_s = variables[\"Separator oxygen concentration\"]\n            N_ox_neg_sep_interface = (\n                -pybamm.boundary_value(eps_s ** param.b_s, \"left\")\n                * param.curlyD_ox\n                * pybamm.BoundaryGradient(c_ox_s, \"left\")\n            )\n            N_ox_neg_sep_interface.domain = [\"current collector\"]\n\n            j = -N_ox_neg_sep_interface / param.C_e / param.s_ox_Ox / param.l_n\n\n        return j",
  "def __init__(self, param, domain):\n        super().__init__(param, domain)",
  "def _get_diffusion_limited_current_density(self, variables):\n        param = self.param\n        if self.domain == \"Negative\":\n            eps_s = variables[\"Separator porosity\"]\n            c_ox_s = variables[\"Separator oxygen concentration\"]\n            N_ox_neg_sep_interface = (\n                -pybamm.boundary_value(eps_s ** param.b_s, \"left\")\n                * param.curlyD_ox\n                * pybamm.BoundaryGradient(c_ox_s, \"left\")\n            )\n            N_ox_neg_sep_interface.domain = [\"current collector\"]\n\n            j = -N_ox_neg_sep_interface / param.C_e / param.s_ox_Ox / param.l_n\n\n        return j",
  "class BaseParticle(pybamm.BaseSubModel):\n    \"\"\"Base class for molar conservation in particles.\n\n    Parameters\n    ----------\n    param : parameter class\n        The parameters to use for this submodel\n    domain : str\n        The domain of the model either 'Negative' or 'Positive'\n\n\n    **Extends:** :class:`pybamm.BaseSubModel`\n    \"\"\"\n\n    def __init__(self, param, domain):\n        super().__init__(param, domain)\n\n    def _get_standard_concentration_variables(self, c_s, c_s_xav):\n\n        c_s_surf = pybamm.surf(c_s, set_domain=True)\n\n        c_s_surf_av = pybamm.x_average(c_s_surf)\n        geo_param = pybamm.geometric_parameters\n\n        if self.domain == \"Negative\":\n            c_scale = self.param.c_n_max\n            active_volume = geo_param.a_n_dim * geo_param.R_n / 3\n        elif self.domain == \"Positive\":\n            c_scale = self.param.c_p_max\n            active_volume = geo_param.a_p_dim * geo_param.R_p / 3\n        c_s_r_av = pybamm.r_average(c_s_xav)\n        c_s_r_av_vol = active_volume * c_s_r_av\n        variables = {\n            self.domain + \" particle concentration\": c_s,\n            self.domain + \" particle concentration [mol.m-3]\": c_s * c_scale,\n            \"X-averaged \" + self.domain.lower() + \" particle concentration\": c_s_xav,\n            \"X-averaged \"\n            + self.domain.lower()\n            + \" particle concentration [mol.m-3]\": c_s_xav * c_scale,\n            self.domain + \" particle surface concentration\": c_s_surf,\n            self.domain\n            + \" particle surface concentration [mol.m-3]\": c_scale * c_s_surf,\n            \"X-averaged \"\n            + self.domain.lower()\n            + \" particle surface concentration\": c_s_surf_av,\n            \"X-averaged \"\n            + self.domain.lower()\n            + \" particle surface concentration [mol.m-3]\": c_scale * c_s_surf_av,\n            self.domain + \" electrode active volume fraction\": active_volume,\n            self.domain\n            + \" electrode volume-averaged concentration\": c_s_r_av_vol,\n            self.domain + \" electrode \"\n            + \"volume-averaged concentration [mol.m-3]\": c_s_r_av_vol * c_scale,\n            self.domain + \" electrode average extent of lithiation\": c_s_r_av\n        }\n\n        return variables\n\n    def _get_standard_flux_variables(self, N_s, N_s_xav):\n        variables = {\n            self.domain + \" particle flux\": N_s,\n            \"X-averaged \" + self.domain.lower() + \" particle flux\": N_s_xav,\n        }\n\n        return variables\n\n    def _flux_law(self, c, T):\n        raise NotImplementedError\n\n    def _unpack(self, variables):\n        raise NotImplementedError\n\n    def set_initial_conditions(self, variables):\n        c, _, _ = self._unpack(variables)\n\n        if self.domain == \"Negative\":\n            c_init = self.param.c_n_init\n\n        elif self.domain == \"Positive\":\n            c_init = self.param.c_p_init\n\n        self.initial_conditions = {c: c_init}\n\n    def set_events(self, variables):\n        c_s_surf = variables[self.domain + \" particle surface concentration\"]\n        tol = 0.01\n\n        self.events[\n            \"Minumum \" + self.domain.lower() + \" particle surface concentration\"\n        ] = (pybamm.min(c_s_surf) - tol)\n\n        self.events[\n            \"Maximum \" + self.domain.lower() + \" particle surface concentration\"\n        ] = (1 - tol) - pybamm.max(c_s_surf)",
  "def __init__(self, param, domain):\n        super().__init__(param, domain)",
  "def _get_standard_concentration_variables(self, c_s, c_s_xav):\n\n        c_s_surf = pybamm.surf(c_s, set_domain=True)\n\n        c_s_surf_av = pybamm.x_average(c_s_surf)\n        geo_param = pybamm.geometric_parameters\n\n        if self.domain == \"Negative\":\n            c_scale = self.param.c_n_max\n            active_volume = geo_param.a_n_dim * geo_param.R_n / 3\n        elif self.domain == \"Positive\":\n            c_scale = self.param.c_p_max\n            active_volume = geo_param.a_p_dim * geo_param.R_p / 3\n        c_s_r_av = pybamm.r_average(c_s_xav)\n        c_s_r_av_vol = active_volume * c_s_r_av\n        variables = {\n            self.domain + \" particle concentration\": c_s,\n            self.domain + \" particle concentration [mol.m-3]\": c_s * c_scale,\n            \"X-averaged \" + self.domain.lower() + \" particle concentration\": c_s_xav,\n            \"X-averaged \"\n            + self.domain.lower()\n            + \" particle concentration [mol.m-3]\": c_s_xav * c_scale,\n            self.domain + \" particle surface concentration\": c_s_surf,\n            self.domain\n            + \" particle surface concentration [mol.m-3]\": c_scale * c_s_surf,\n            \"X-averaged \"\n            + self.domain.lower()\n            + \" particle surface concentration\": c_s_surf_av,\n            \"X-averaged \"\n            + self.domain.lower()\n            + \" particle surface concentration [mol.m-3]\": c_scale * c_s_surf_av,\n            self.domain + \" electrode active volume fraction\": active_volume,\n            self.domain\n            + \" electrode volume-averaged concentration\": c_s_r_av_vol,\n            self.domain + \" electrode \"\n            + \"volume-averaged concentration [mol.m-3]\": c_s_r_av_vol * c_scale,\n            self.domain + \" electrode average extent of lithiation\": c_s_r_av\n        }\n\n        return variables",
  "def _get_standard_flux_variables(self, N_s, N_s_xav):\n        variables = {\n            self.domain + \" particle flux\": N_s,\n            \"X-averaged \" + self.domain.lower() + \" particle flux\": N_s_xav,\n        }\n\n        return variables",
  "def _flux_law(self, c, T):\n        raise NotImplementedError",
  "def _unpack(self, variables):\n        raise NotImplementedError",
  "def set_initial_conditions(self, variables):\n        c, _, _ = self._unpack(variables)\n\n        if self.domain == \"Negative\":\n            c_init = self.param.c_n_init\n\n        elif self.domain == \"Positive\":\n            c_init = self.param.c_p_init\n\n        self.initial_conditions = {c: c_init}",
  "def set_events(self, variables):\n        c_s_surf = variables[self.domain + \" particle surface concentration\"]\n        tol = 0.01\n\n        self.events[\n            \"Minumum \" + self.domain.lower() + \" particle surface concentration\"\n        ] = (pybamm.min(c_s_surf) - tol)\n\n        self.events[\n            \"Maximum \" + self.domain.lower() + \" particle surface concentration\"\n        ] = (1 - tol) - pybamm.max(c_s_surf)",
  "class BaseModel(BaseParticle):\n    \"\"\"Base class for molar conservation in particles which employ Fick's law.\n\n    Parameters\n    ----------\n    param : parameter class\n        The parameters to use for this submodel\n    domain : str\n        The domain of the model either 'Negative' or 'Positive'\n\n\n    **Extends:** :class:`pybamm.particle.BaseParticle`\n    \"\"\"\n\n    def __init__(self, param, domain):\n        super().__init__(param, domain)\n\n    def _flux_law(self, c, T):\n\n        if self.domain == \"Negative\":\n            D = self.param.D_n(c, T)\n        elif self.domain == \"Positive\":\n            D = self.param.D_p(c, T)\n\n        return -D * pybamm.grad(c)\n\n    def _unpack(self, variables):\n        raise NotImplementedError\n\n    def set_rhs(self, variables):\n\n        c, N, _ = self._unpack(variables)\n\n        if self.domain == \"Negative\":\n            self.rhs = {c: -(1 / self.param.C_n) * pybamm.div(N)}\n\n        elif self.domain == \"Positive\":\n            self.rhs = {c: -(1 / self.param.C_p) * pybamm.div(N)}\n\n    def set_boundary_conditions(self, variables):\n\n        c, _, j = self._unpack(variables)\n\n        if self.domain == \"Negative\":\n            rbc = -self.param.C_n * j / self.param.a_n\n\n        elif self.domain == \"Positive\":\n            rbc = -self.param.C_p * j / self.param.a_p / self.param.gamma_p\n\n        self.boundary_conditions = {\n            c: {\"left\": (pybamm.Scalar(0), \"Neumann\"), \"right\": (rbc, \"Neumann\")}\n        }",
  "def __init__(self, param, domain):\n        super().__init__(param, domain)",
  "def _flux_law(self, c, T):\n\n        if self.domain == \"Negative\":\n            D = self.param.D_n(c, T)\n        elif self.domain == \"Positive\":\n            D = self.param.D_p(c, T)\n\n        return -D * pybamm.grad(c)",
  "def _unpack(self, variables):\n        raise NotImplementedError",
  "def set_rhs(self, variables):\n\n        c, N, _ = self._unpack(variables)\n\n        if self.domain == \"Negative\":\n            self.rhs = {c: -(1 / self.param.C_n) * pybamm.div(N)}\n\n        elif self.domain == \"Positive\":\n            self.rhs = {c: -(1 / self.param.C_p) * pybamm.div(N)}",
  "def set_boundary_conditions(self, variables):\n\n        c, _, j = self._unpack(variables)\n\n        if self.domain == \"Negative\":\n            rbc = -self.param.C_n * j / self.param.a_n\n\n        elif self.domain == \"Positive\":\n            rbc = -self.param.C_p * j / self.param.a_p / self.param.gamma_p\n\n        self.boundary_conditions = {\n            c: {\"left\": (pybamm.Scalar(0), \"Neumann\"), \"right\": (rbc, \"Neumann\")}\n        }",
  "class ManyParticles(BaseModel):\n    \"\"\"Base class for molar conservation in many particles which employs\n    Fick's law.\n\n    Parameters\n    ----------\n    param : parameter class\n        The parameters to use for this submodel\n    domain : str\n        The domain of the model either 'Negative' or 'Positive'\n\n\n    **Extends:** :class:`pybamm.particle.fickian.BaseModel`\n    \"\"\"\n\n    def __init__(self, param, domain):\n        super().__init__(param, domain)\n\n    def get_fundamental_variables(self):\n        if self.domain == \"Negative\":\n            c_s = pybamm.standard_variables.c_s_n\n\n        elif self.domain == \"Positive\":\n            c_s = pybamm.standard_variables.c_s_p\n\n        # TODO: implement c_s_xav for Fickian many particles (tricky because this\n        # requires averaging a secondary domain)\n        variables = self._get_standard_concentration_variables(c_s, c_s)\n\n        return variables\n\n    def get_coupled_variables(self, variables):\n        c_s = variables[self.domain + \" particle concentration\"]\n        T_k = pybamm.PrimaryBroadcast(\n            variables[self.domain + \" electrode temperature\"],\n            [self.domain.lower() + \" particle\"],\n        )\n\n        N_s = self._flux_law(c_s, T_k)\n\n        variables.update(self._get_standard_flux_variables(N_s, N_s))\n        return variables\n\n    def _unpack(self, variables):\n        c_s = variables[self.domain + \" particle concentration\"]\n        N_s = variables[self.domain + \" particle flux\"]\n        j = variables[self.domain + \" electrode interfacial current density\"]\n\n        return c_s, N_s, j",
  "def __init__(self, param, domain):\n        super().__init__(param, domain)",
  "def get_fundamental_variables(self):\n        if self.domain == \"Negative\":\n            c_s = pybamm.standard_variables.c_s_n\n\n        elif self.domain == \"Positive\":\n            c_s = pybamm.standard_variables.c_s_p\n\n        # TODO: implement c_s_xav for Fickian many particles (tricky because this\n        # requires averaging a secondary domain)\n        variables = self._get_standard_concentration_variables(c_s, c_s)\n\n        return variables",
  "def get_coupled_variables(self, variables):\n        c_s = variables[self.domain + \" particle concentration\"]\n        T_k = pybamm.PrimaryBroadcast(\n            variables[self.domain + \" electrode temperature\"],\n            [self.domain.lower() + \" particle\"],\n        )\n\n        N_s = self._flux_law(c_s, T_k)\n\n        variables.update(self._get_standard_flux_variables(N_s, N_s))\n        return variables",
  "def _unpack(self, variables):\n        c_s = variables[self.domain + \" particle concentration\"]\n        N_s = variables[self.domain + \" particle flux\"]\n        j = variables[self.domain + \" electrode interfacial current density\"]\n\n        return c_s, N_s, j",
  "class SingleParticle(BaseModel):\n    \"\"\"Base class for molar conservation in a single x-averaged particle which employs\n    Fick's law.\n\n    Parameters\n    ----------\n    param : parameter class\n        The parameters to use for this submodel\n    domain : str\n        The domain of the model either 'Negative' or 'Positive'\n\n\n    **Extends:** :class:`pybamm.particle.fickian.BaseModel`\n    \"\"\"\n\n    def __init__(self, param, domain):\n        super().__init__(param, domain)\n\n    def get_fundamental_variables(self):\n        if self.domain == \"Negative\":\n            c_s_xav = pybamm.standard_variables.c_s_n_xav\n            c_s = pybamm.PrimaryBroadcast(c_s_xav, [\"negative electrode\"])\n\n        elif self.domain == \"Positive\":\n            c_s_xav = pybamm.standard_variables.c_s_p_xav\n            c_s = pybamm.PrimaryBroadcast(c_s_xav, [\"positive electrode\"])\n\n        variables = self._get_standard_concentration_variables(c_s, c_s_xav)\n\n        return variables\n\n    def get_coupled_variables(self, variables):\n        c_s_xav = variables[\n            \"X-averaged \" + self.domain.lower() + \" particle concentration\"\n        ]\n        T_k_xav = pybamm.PrimaryBroadcast(\n            variables[\"X-averaged \" + self.domain.lower() + \" electrode temperature\"],\n            [self.domain.lower() + \" particle\"],\n        )\n\n        N_s_xav = self._flux_law(c_s_xav, T_k_xav)\n        N_s = pybamm.PrimaryBroadcast(N_s_xav, [self._domain.lower() + \" electrode\"])\n\n        variables.update(self._get_standard_flux_variables(N_s, N_s_xav))\n\n        return variables\n\n    def _unpack(self, variables):\n        c_s_xav = variables[\n            \"X-averaged \" + self.domain.lower() + \" particle concentration\"\n        ]\n        N_s_xav = variables[\"X-averaged \" + self.domain.lower() + \" particle flux\"]\n        j_av = variables[\n            \"X-averaged \"\n            + self.domain.lower()\n            + \" electrode interfacial current density\"\n        ]\n\n        return c_s_xav, N_s_xav, j_av",
  "def __init__(self, param, domain):\n        super().__init__(param, domain)",
  "def get_fundamental_variables(self):\n        if self.domain == \"Negative\":\n            c_s_xav = pybamm.standard_variables.c_s_n_xav\n            c_s = pybamm.PrimaryBroadcast(c_s_xav, [\"negative electrode\"])\n\n        elif self.domain == \"Positive\":\n            c_s_xav = pybamm.standard_variables.c_s_p_xav\n            c_s = pybamm.PrimaryBroadcast(c_s_xav, [\"positive electrode\"])\n\n        variables = self._get_standard_concentration_variables(c_s, c_s_xav)\n\n        return variables",
  "def get_coupled_variables(self, variables):\n        c_s_xav = variables[\n            \"X-averaged \" + self.domain.lower() + \" particle concentration\"\n        ]\n        T_k_xav = pybamm.PrimaryBroadcast(\n            variables[\"X-averaged \" + self.domain.lower() + \" electrode temperature\"],\n            [self.domain.lower() + \" particle\"],\n        )\n\n        N_s_xav = self._flux_law(c_s_xav, T_k_xav)\n        N_s = pybamm.PrimaryBroadcast(N_s_xav, [self._domain.lower() + \" electrode\"])\n\n        variables.update(self._get_standard_flux_variables(N_s, N_s_xav))\n\n        return variables",
  "def _unpack(self, variables):\n        c_s_xav = variables[\n            \"X-averaged \" + self.domain.lower() + \" particle concentration\"\n        ]\n        N_s_xav = variables[\"X-averaged \" + self.domain.lower() + \" particle flux\"]\n        j_av = variables[\n            \"X-averaged \"\n            + self.domain.lower()\n            + \" electrode interfacial current density\"\n        ]\n\n        return c_s_xav, N_s_xav, j_av",
  "class ManyParticles(BaseModel):\n    \"\"\"Base class for molar conservation in many particles with\n    uniform concentration in r (i.e. infinitely fast diffusion within particles).\n\n    Parameters\n    ----------\n    param : parameter class\n        The parameters to use for this submodel\n    domain : str\n        The domain of the model either 'Negative' or 'Positive'\n\n\n    **Extends:** :class:`pybamm.particle.fast.BaseModel`\n    \"\"\"\n\n    def __init__(self, param, domain):\n        super().__init__(param, domain)\n\n    def get_fundamental_variables(self):\n        # The particle concentration is uniform throughout the particle, so we\n        # can just use the surface value.\n        if self.domain == \"Negative\":\n            c_s_surf = pybamm.standard_variables.c_s_n_surf\n            c_s = pybamm.PrimaryBroadcast(c_s_surf, [\"negative particle\"])\n            c_s_xav = pybamm.x_average(c_s)\n\n            N_s = pybamm.FullBroadcast(\n                0,\n                [\"negative particle\"],\n                auxiliary_domains={\n                    \"secondary\": \"negative electrode\",\n                    \"tertiary\": \"current collector\",\n                },\n            )\n            N_s_xav = pybamm.x_average(N_s)\n\n        elif self.domain == \"Positive\":\n            c_s_surf = pybamm.standard_variables.c_s_p_surf\n            c_s = pybamm.PrimaryBroadcast(c_s_surf, [\"positive particle\"])\n            c_s_xav = pybamm.x_average(c_s)\n\n            N_s = pybamm.FullBroadcast(\n                0,\n                [\"positive particle\"],\n                auxiliary_domains={\n                    \"secondary\": \"positive electrode\",\n                    \"tertiary\": \"current collector\",\n                },\n            )\n            N_s_xav = pybamm.x_average(N_s)\n\n        variables = self._get_standard_concentration_variables(c_s, c_s_xav)\n        variables.update(self._get_standard_flux_variables(N_s, N_s_xav))\n\n        return variables\n\n    def _unpack(self, variables):\n        c_s_surf = variables[self.domain + \" particle surface concentration\"]\n        N_s = variables[self.domain + \" particle flux\"]\n        j = variables[self.domain + \" electrode interfacial current density\"]\n\n        return c_s_surf, N_s, j",
  "def __init__(self, param, domain):\n        super().__init__(param, domain)",
  "def get_fundamental_variables(self):\n        # The particle concentration is uniform throughout the particle, so we\n        # can just use the surface value.\n        if self.domain == \"Negative\":\n            c_s_surf = pybamm.standard_variables.c_s_n_surf\n            c_s = pybamm.PrimaryBroadcast(c_s_surf, [\"negative particle\"])\n            c_s_xav = pybamm.x_average(c_s)\n\n            N_s = pybamm.FullBroadcast(\n                0,\n                [\"negative particle\"],\n                auxiliary_domains={\n                    \"secondary\": \"negative electrode\",\n                    \"tertiary\": \"current collector\",\n                },\n            )\n            N_s_xav = pybamm.x_average(N_s)\n\n        elif self.domain == \"Positive\":\n            c_s_surf = pybamm.standard_variables.c_s_p_surf\n            c_s = pybamm.PrimaryBroadcast(c_s_surf, [\"positive particle\"])\n            c_s_xav = pybamm.x_average(c_s)\n\n            N_s = pybamm.FullBroadcast(\n                0,\n                [\"positive particle\"],\n                auxiliary_domains={\n                    \"secondary\": \"positive electrode\",\n                    \"tertiary\": \"current collector\",\n                },\n            )\n            N_s_xav = pybamm.x_average(N_s)\n\n        variables = self._get_standard_concentration_variables(c_s, c_s_xav)\n        variables.update(self._get_standard_flux_variables(N_s, N_s_xav))\n\n        return variables",
  "def _unpack(self, variables):\n        c_s_surf = variables[self.domain + \" particle surface concentration\"]\n        N_s = variables[self.domain + \" particle flux\"]\n        j = variables[self.domain + \" electrode interfacial current density\"]\n\n        return c_s_surf, N_s, j",
  "class SingleParticle(BaseModel):\n    \"\"\"Base class for molar conservation in a single x-averaged particle with\n    uniform concentration in r (i.e. infinitely fast diffusion within particles).\n\n    Parameters\n    ----------\n    param : parameter class\n        The parameters to use for this submodel\n    domain : str\n        The domain of the model either 'Negative' or 'Positive'\n\n\n    **Extends:** :class:`pybamm.particle.fast.BaseModel`\n    \"\"\"\n\n    def __init__(self, param, domain):\n        super().__init__(param, domain)\n\n    def get_fundamental_variables(self):\n        # The particle concentration is uniform throughout the particle, so we\n        # can just use the surface value. This avoids dealing with both\n        # x *and* r averaged quantities, which may be confusing.\n\n        if self.domain == \"Negative\":\n            c_s_surf_xav = pybamm.standard_variables.c_s_n_surf_xav\n            c_s_xav = pybamm.PrimaryBroadcast(c_s_surf_xav, [\"negative particle\"])\n            c_s = pybamm.PrimaryBroadcast(c_s_xav, [\"negative electrode\"])\n\n            N_s = pybamm.FullBroadcast(\n                0,\n                [\"negative particle\"],\n                auxiliary_domains={\n                    \"secondary\": \"negative electrode\",\n                    \"tertiary\": \"current collector\",\n                },\n            )\n            N_s_xav = pybamm.x_average(N_s)\n\n        elif self.domain == \"Positive\":\n            c_s_surf_xav = pybamm.standard_variables.c_s_p_surf_xav\n            c_s_xav = pybamm.PrimaryBroadcast(c_s_surf_xav, [\"positive particle\"])\n            c_s = pybamm.PrimaryBroadcast(c_s_xav, [\"positive electrode\"])\n\n            N_s = pybamm.FullBroadcast(\n                0,\n                [\"positive particle\"],\n                auxiliary_domains={\n                    \"secondary\": \"positive electrode\",\n                    \"tertiary\": \"current collector\",\n                },\n            )\n            N_s_xav = pybamm.x_average(N_s)\n\n        variables = self._get_standard_concentration_variables(c_s, c_s_xav)\n        variables.update(self._get_standard_flux_variables(N_s, N_s_xav))\n\n        return variables\n\n    def _unpack(self, variables):\n        c_s_surf_xav = variables[\n            \"X-averaged \" + self.domain.lower() + \" particle surface concentration\"\n        ]\n        N_s_xav = variables[\"X-averaged \" + self.domain.lower() + \" particle flux\"]\n        j_av = variables[\n            \"X-averaged \"\n            + self.domain.lower()\n            + \" electrode interfacial current density\"\n        ]\n\n        return c_s_surf_xav, N_s_xav, j_av",
  "def __init__(self, param, domain):\n        super().__init__(param, domain)",
  "def get_fundamental_variables(self):\n        # The particle concentration is uniform throughout the particle, so we\n        # can just use the surface value. This avoids dealing with both\n        # x *and* r averaged quantities, which may be confusing.\n\n        if self.domain == \"Negative\":\n            c_s_surf_xav = pybamm.standard_variables.c_s_n_surf_xav\n            c_s_xav = pybamm.PrimaryBroadcast(c_s_surf_xav, [\"negative particle\"])\n            c_s = pybamm.PrimaryBroadcast(c_s_xav, [\"negative electrode\"])\n\n            N_s = pybamm.FullBroadcast(\n                0,\n                [\"negative particle\"],\n                auxiliary_domains={\n                    \"secondary\": \"negative electrode\",\n                    \"tertiary\": \"current collector\",\n                },\n            )\n            N_s_xav = pybamm.x_average(N_s)\n\n        elif self.domain == \"Positive\":\n            c_s_surf_xav = pybamm.standard_variables.c_s_p_surf_xav\n            c_s_xav = pybamm.PrimaryBroadcast(c_s_surf_xav, [\"positive particle\"])\n            c_s = pybamm.PrimaryBroadcast(c_s_xav, [\"positive electrode\"])\n\n            N_s = pybamm.FullBroadcast(\n                0,\n                [\"positive particle\"],\n                auxiliary_domains={\n                    \"secondary\": \"positive electrode\",\n                    \"tertiary\": \"current collector\",\n                },\n            )\n            N_s_xav = pybamm.x_average(N_s)\n\n        variables = self._get_standard_concentration_variables(c_s, c_s_xav)\n        variables.update(self._get_standard_flux_variables(N_s, N_s_xav))\n\n        return variables",
  "def _unpack(self, variables):\n        c_s_surf_xav = variables[\n            \"X-averaged \" + self.domain.lower() + \" particle surface concentration\"\n        ]\n        N_s_xav = variables[\"X-averaged \" + self.domain.lower() + \" particle flux\"]\n        j_av = variables[\n            \"X-averaged \"\n            + self.domain.lower()\n            + \" electrode interfacial current density\"\n        ]\n\n        return c_s_surf_xav, N_s_xav, j_av",
  "class BaseModel(BaseParticle):\n    \"\"\"Base class for molar conservation in particles with uniform concentration\n    in r (i.e. infinitely fast diffusion within particles).\n\n    Parameters\n    ----------\n    param : parameter class\n        The parameters to use for this submodel\n    domain : str\n        The domain of the model either 'Negative' or 'Positive'\n\n\n    **Extends:** :class:`pybamm.particle.BaseParticle`\n    \"\"\"\n\n    def __init__(self, param, domain):\n        super().__init__(param, domain)\n\n    def _unpack(self, variables):\n        raise NotImplementedError\n\n    def set_rhs(self, variables):\n\n        c, _, j = self._unpack(variables)\n\n        if self.domain == \"Negative\":\n            self.rhs = {c: -3 * j / self.param.a_n}\n\n        elif self.domain == \"Positive\":\n            self.rhs = {c: -3 * j / self.param.a_p / self.param.gamma_p}",
  "def __init__(self, param, domain):\n        super().__init__(param, domain)",
  "def _unpack(self, variables):\n        raise NotImplementedError",
  "def set_rhs(self, variables):\n\n        c, _, j = self._unpack(variables)\n\n        if self.domain == \"Negative\":\n            self.rhs = {c: -3 * j / self.param.a_n}\n\n        elif self.domain == \"Positive\":\n            self.rhs = {c: -3 * j / self.param.a_p / self.param.gamma_p}",
  "class BaseThermal(pybamm.BaseSubModel):\n    \"\"\"Base class for thermal effects\n\n    Parameters\n    ----------\n    param : parameter class\n        The parameters to use for this submodel\n\n\n    **Extends:** :class:`pybamm.BaseSubModel`\n    \"\"\"\n\n    def __init__(self, param):\n        super().__init__(param)\n\n    def _get_standard_fundamental_variables(self, T, T_cn, T_cp):\n        param = self.param\n        T_n, T_s, T_p = T.orphans\n\n        # Compute the X-average over the current collectors by default.\n        # Note: the method 'self._x_average' is overwritten by models which do\n        # not include current collector effects, so that the average is just taken\n        # over the negative electrode, separator and positive electrode.\n        T_x_av = self._x_average(T, T_cn, T_cp)\n        T_vol_av = self._yz_average(T_x_av)\n\n        q = self._flux_law(T)\n\n        variables = {\n            \"Negative current collector temperature\": T_cn,\n            \"Negative current collector temperature [K]\": param.Delta_T * T_cn,\n            \"X-averaged negative electrode temperature\": pybamm.x_average(T_n),\n            \"X-averaged negative electrode temperature [K]\": param.Delta_T\n            * pybamm.x_average(T_n)\n            + param.T_ref,\n            \"Negative electrode temperature\": T_n,\n            \"Negative electrode temperature [K]\": param.Delta_T * T_n + param.T_ref,\n            \"X-averaged separator temperature\": pybamm.x_average(T_s),\n            \"X-averaged separator temperature [K]\": param.Delta_T\n            * pybamm.x_average(T_s)\n            + param.T_ref,\n            \"Separator temperature\": T_s,\n            \"Separator temperature [K]\": param.Delta_T * T_s + param.T_ref,\n            \"X-averaged positive electrode temperature\": pybamm.x_average(T_p),\n            \"X-averaged positive electrode temperature [K]\": param.Delta_T\n            * pybamm.x_average(T_p)\n            + param.T_ref,\n            \"Positive electrode temperature\": T_p,\n            \"Positive electrode temperature [K]\": param.Delta_T * T_p + param.T_ref,\n            \"Positive current collector temperature\": T_cp,\n            \"Positive current collector temperature [K]\": param.Delta_T * T_cp,\n            \"Cell temperature\": T,\n            \"Cell temperature [K]\": param.Delta_T * T + param.T_ref,\n            \"X-averaged cell temperature\": T_x_av,\n            \"X-averaged cell temperature [K]\": param.Delta_T * T_x_av + param.T_ref,\n            \"Volume-averaged cell temperature\": T_vol_av,\n            \"Volume-averaged cell temperature [K]\": param.Delta_T * T_vol_av\n            + param.T_ref,\n            \"Heat flux\": q,\n            \"Heat flux [W.m-2]\": q,\n        }\n\n        return variables\n\n    def _get_standard_coupled_variables(self, variables):\n\n        param = self.param\n\n        T = variables[\"Cell temperature\"]\n        T_n, _, T_p = T.orphans\n\n        j_n = variables[\"Negative electrode interfacial current density\"]\n        j_p = variables[\"Positive electrode interfacial current density\"]\n\n        eta_r_n = variables[\"Negative electrode reaction overpotential\"]\n        eta_r_p = variables[\"Positive electrode reaction overpotential\"]\n\n        dUdT_n = variables[\"Negative electrode entropic change\"]\n        dUdT_p = variables[\"Positive electrode entropic change\"]\n\n        i_e = variables[\"Electrolyte current density\"]\n        phi_e = variables[\"Electrolyte potential\"]\n\n        i_s_n = variables[\"Negative electrode current density\"]\n        i_s_p = variables[\"Positive electrode current density\"]\n        phi_s_n = variables[\"Negative electrode potential\"]\n        phi_s_p = variables[\"Positive electrode potential\"]\n\n        Q_ohm_s_cn, Q_ohm_s_cp = self._current_collector_heating(variables)\n        Q_ohm_s_n = -pybamm.inner(i_s_n, pybamm.grad(phi_s_n))\n        Q_ohm_s_s = pybamm.FullBroadcast(0, [\"separator\"], \"current collector\")\n        Q_ohm_s_p = -pybamm.inner(i_s_p, pybamm.grad(phi_s_p))\n        Q_ohm_s = pybamm.Concatenation(Q_ohm_s_n, Q_ohm_s_s, Q_ohm_s_p)\n\n        Q_ohm_e = -pybamm.inner(i_e, pybamm.grad(phi_e))\n\n        Q_ohm = Q_ohm_s + Q_ohm_e\n\n        Q_rxn_n = j_n * eta_r_n\n        Q_rxn_p = j_p * eta_r_p\n        Q_rxn = pybamm.Concatenation(\n            *[\n                Q_rxn_n,\n                pybamm.FullBroadcast(0, [\"separator\"], \"current collector\"),\n                Q_rxn_p,\n            ]\n        )\n\n        Q_rev_n = j_n * (param.Theta ** (-1) + T_n) * dUdT_n\n        Q_rev_p = j_p * (param.Theta ** (-1) + T_p) * dUdT_p\n        Q_rev = pybamm.Concatenation(\n            *[\n                Q_rev_n,\n                pybamm.FullBroadcast(0, [\"separator\"], \"current collector\"),\n                Q_rev_p,\n            ]\n        )\n\n        Q = Q_ohm + Q_rxn + Q_rev\n\n        # Compute the X-average over the current collectors by default.\n        # Note: the method 'self._x_average' is overwritten by models which do\n        # not include current collector effects, so that the average is just taken\n        # over the negative electrode, separator and positive electrode.\n        Q_ohm_av = self._x_average(Q_ohm, Q_ohm_s_cn, Q_ohm_s_cp)\n        Q_rxn_av = self._x_average(Q_rxn, 0, 0)\n        Q_rev_av = self._x_average(Q_rev, 0, 0)\n        Q_av = self._x_average(Q, Q_ohm_s_cn, Q_ohm_s_cp)\n\n        Q_ohm_vol_av = self._yz_average(Q_ohm_av)\n        Q_rxn_vol_av = self._yz_average(Q_rxn_av)\n        Q_rev_vol_av = self._yz_average(Q_rev_av)\n        Q_vol_av = self._yz_average(Q_av)\n\n        variables.update(\n            {\n                \"Ohmic heating\": Q_ohm,\n                \"Ohmic heating [A.V.m-3]\": param.i_typ\n                * param.potential_scale\n                * Q_ohm\n                / param.L_x,\n                \"X-averaged Ohmic heating\": Q_ohm_av,\n                \"X-averaged Ohmic heating [A.V.m-3]\": param.i_typ\n                * param.potential_scale\n                * Q_ohm_av\n                / param.L_x,\n                \"Volume-averaged Ohmic heating\": Q_ohm_vol_av,\n                \"Volume-averaged Ohmic heating [A.V.m-3]\": param.i_typ\n                * param.potential_scale\n                * Q_ohm_vol_av\n                / param.L_x,\n                \"Irreversible electrochemical heating\": Q_rxn,\n                \"Irreversible electrochemical heating [A.V.m-3]\": param.i_typ\n                * param.potential_scale\n                * Q_rxn\n                / param.L_x,\n                \"X-averaged electrochemical heating\": Q_rxn_av,\n                \"X-averaged electrochemical heating [A.V.m-3]\": param.i_typ\n                * param.potential_scale\n                * Q_rxn_av\n                / param.L_x,\n                \"Volume-averaged electrochemical heating\": Q_rxn_vol_av,\n                \"Volume-averaged electrochemical heating [A.V.m-3]\": param.i_typ\n                * param.potential_scale\n                * Q_rxn_vol_av\n                / param.L_x,\n                \"Reversible heating\": Q_rev,\n                \"Reversible heating [A.V.m-3]\": param.i_typ\n                * param.potential_scale\n                * Q_rev\n                / param.L_x,\n                \"X-averaged reversible heating\": Q_rev_av,\n                \"X-averaged reversible heating [A.V.m-3]\": param.i_typ\n                * param.potential_scale\n                * Q_rev_av\n                / param.L_x,\n                \"Volume-averaged reversible heating\": Q_rev_vol_av,\n                \"Volume-averaged reversible heating [A.V.m-3]\": param.i_typ\n                * param.potential_scale\n                * Q_rev_vol_av\n                / param.L_x,\n                \"Total heating\": Q,\n                \"Total heating [A.V.m-3]\": param.i_typ\n                * param.potential_scale\n                * Q\n                / param.L_x,\n                \"X-averaged total heating\": Q_av,\n                \"X-averaged total heating [A.V.m-3]\": param.i_typ\n                * param.potential_scale\n                * Q_av\n                / param.L_x,\n                \"Volume-averaged total heating\": Q_vol_av,\n                \"Volume-averaged total heating [A.V.m-3]\": param.i_typ\n                * param.potential_scale\n                * Q_vol_av\n                / param.L_x,\n            }\n        )\n        return variables\n\n    def _flux_law(self, T):\n        raise NotImplementedError\n\n    def _unpack(self, variables):\n        raise NotImplementedError\n\n    def _current_collector_heating(self, variables):\n        raise NotImplementedError\n\n    def _yz_average(self, var):\n        raise NotImplementedError\n\n    def _x_average(self, var, var_cn, var_cp):\n        \"\"\"\n        Computes the X-average over the whole cell (including current collectors)\n        from the variable in the cell (negative electrode, separator,\n        positive electrode), negative current collector, and positive current\n        collector. This method is overwritten by models which do not include\n        current collector effects, so that the average is just taken over the\n        negative electrode, separator and positive electrode.\n        Note: we do this as we cannot create a single variable which is\n        the concatenation [var_cn, var, var_cp] since var_cn and var_cp share the\n        same domian. (In the N+1D formulation the current collector variables are\n        assumed independent of x, so we do not make the distinction between negative\n        and positive current collectors in the geometry).\n        \"\"\"\n        # When averging the temperature for x-lumped or xyz-lumped models, var\n        # is a concatenation of broadcasts of the X- or Volume- averaged temperature.\n        # In this instance we return the (unmodified) variable corresponding to\n        # the correct average to avoid a ModelError (the unmodified variables must\n        # be the key in model.rhs)\n        if isinstance(var, pybamm.Concatenation) and all(\n            isinstance(child, pybamm.Broadcast) for child in var.children\n        ):\n            # Create list of var.ids\n            var_ids = [child.children[0].id for child in var.children]\n            var_ids.extend([var_cn.id, var_cp.id])\n            # If all var.ids the same, then the variable is uniform in x so can\n            # just return one the values (arbitrarily var_cn here)\n            if len(set(var_ids)) == 1:\n                out = var_cn\n        else:\n            out = (\n                self.param.l_cn * var_cn\n                + pybamm.x_average(var)\n                + self.param.l_cp * var_cp\n            ) / self.param.l\n        return out",
  "def __init__(self, param):\n        super().__init__(param)",
  "def _get_standard_fundamental_variables(self, T, T_cn, T_cp):\n        param = self.param\n        T_n, T_s, T_p = T.orphans\n\n        # Compute the X-average over the current collectors by default.\n        # Note: the method 'self._x_average' is overwritten by models which do\n        # not include current collector effects, so that the average is just taken\n        # over the negative electrode, separator and positive electrode.\n        T_x_av = self._x_average(T, T_cn, T_cp)\n        T_vol_av = self._yz_average(T_x_av)\n\n        q = self._flux_law(T)\n\n        variables = {\n            \"Negative current collector temperature\": T_cn,\n            \"Negative current collector temperature [K]\": param.Delta_T * T_cn,\n            \"X-averaged negative electrode temperature\": pybamm.x_average(T_n),\n            \"X-averaged negative electrode temperature [K]\": param.Delta_T\n            * pybamm.x_average(T_n)\n            + param.T_ref,\n            \"Negative electrode temperature\": T_n,\n            \"Negative electrode temperature [K]\": param.Delta_T * T_n + param.T_ref,\n            \"X-averaged separator temperature\": pybamm.x_average(T_s),\n            \"X-averaged separator temperature [K]\": param.Delta_T\n            * pybamm.x_average(T_s)\n            + param.T_ref,\n            \"Separator temperature\": T_s,\n            \"Separator temperature [K]\": param.Delta_T * T_s + param.T_ref,\n            \"X-averaged positive electrode temperature\": pybamm.x_average(T_p),\n            \"X-averaged positive electrode temperature [K]\": param.Delta_T\n            * pybamm.x_average(T_p)\n            + param.T_ref,\n            \"Positive electrode temperature\": T_p,\n            \"Positive electrode temperature [K]\": param.Delta_T * T_p + param.T_ref,\n            \"Positive current collector temperature\": T_cp,\n            \"Positive current collector temperature [K]\": param.Delta_T * T_cp,\n            \"Cell temperature\": T,\n            \"Cell temperature [K]\": param.Delta_T * T + param.T_ref,\n            \"X-averaged cell temperature\": T_x_av,\n            \"X-averaged cell temperature [K]\": param.Delta_T * T_x_av + param.T_ref,\n            \"Volume-averaged cell temperature\": T_vol_av,\n            \"Volume-averaged cell temperature [K]\": param.Delta_T * T_vol_av\n            + param.T_ref,\n            \"Heat flux\": q,\n            \"Heat flux [W.m-2]\": q,\n        }\n\n        return variables",
  "def _get_standard_coupled_variables(self, variables):\n\n        param = self.param\n\n        T = variables[\"Cell temperature\"]\n        T_n, _, T_p = T.orphans\n\n        j_n = variables[\"Negative electrode interfacial current density\"]\n        j_p = variables[\"Positive electrode interfacial current density\"]\n\n        eta_r_n = variables[\"Negative electrode reaction overpotential\"]\n        eta_r_p = variables[\"Positive electrode reaction overpotential\"]\n\n        dUdT_n = variables[\"Negative electrode entropic change\"]\n        dUdT_p = variables[\"Positive electrode entropic change\"]\n\n        i_e = variables[\"Electrolyte current density\"]\n        phi_e = variables[\"Electrolyte potential\"]\n\n        i_s_n = variables[\"Negative electrode current density\"]\n        i_s_p = variables[\"Positive electrode current density\"]\n        phi_s_n = variables[\"Negative electrode potential\"]\n        phi_s_p = variables[\"Positive electrode potential\"]\n\n        Q_ohm_s_cn, Q_ohm_s_cp = self._current_collector_heating(variables)\n        Q_ohm_s_n = -pybamm.inner(i_s_n, pybamm.grad(phi_s_n))\n        Q_ohm_s_s = pybamm.FullBroadcast(0, [\"separator\"], \"current collector\")\n        Q_ohm_s_p = -pybamm.inner(i_s_p, pybamm.grad(phi_s_p))\n        Q_ohm_s = pybamm.Concatenation(Q_ohm_s_n, Q_ohm_s_s, Q_ohm_s_p)\n\n        Q_ohm_e = -pybamm.inner(i_e, pybamm.grad(phi_e))\n\n        Q_ohm = Q_ohm_s + Q_ohm_e\n\n        Q_rxn_n = j_n * eta_r_n\n        Q_rxn_p = j_p * eta_r_p\n        Q_rxn = pybamm.Concatenation(\n            *[\n                Q_rxn_n,\n                pybamm.FullBroadcast(0, [\"separator\"], \"current collector\"),\n                Q_rxn_p,\n            ]\n        )\n\n        Q_rev_n = j_n * (param.Theta ** (-1) + T_n) * dUdT_n\n        Q_rev_p = j_p * (param.Theta ** (-1) + T_p) * dUdT_p\n        Q_rev = pybamm.Concatenation(\n            *[\n                Q_rev_n,\n                pybamm.FullBroadcast(0, [\"separator\"], \"current collector\"),\n                Q_rev_p,\n            ]\n        )\n\n        Q = Q_ohm + Q_rxn + Q_rev\n\n        # Compute the X-average over the current collectors by default.\n        # Note: the method 'self._x_average' is overwritten by models which do\n        # not include current collector effects, so that the average is just taken\n        # over the negative electrode, separator and positive electrode.\n        Q_ohm_av = self._x_average(Q_ohm, Q_ohm_s_cn, Q_ohm_s_cp)\n        Q_rxn_av = self._x_average(Q_rxn, 0, 0)\n        Q_rev_av = self._x_average(Q_rev, 0, 0)\n        Q_av = self._x_average(Q, Q_ohm_s_cn, Q_ohm_s_cp)\n\n        Q_ohm_vol_av = self._yz_average(Q_ohm_av)\n        Q_rxn_vol_av = self._yz_average(Q_rxn_av)\n        Q_rev_vol_av = self._yz_average(Q_rev_av)\n        Q_vol_av = self._yz_average(Q_av)\n\n        variables.update(\n            {\n                \"Ohmic heating\": Q_ohm,\n                \"Ohmic heating [A.V.m-3]\": param.i_typ\n                * param.potential_scale\n                * Q_ohm\n                / param.L_x,\n                \"X-averaged Ohmic heating\": Q_ohm_av,\n                \"X-averaged Ohmic heating [A.V.m-3]\": param.i_typ\n                * param.potential_scale\n                * Q_ohm_av\n                / param.L_x,\n                \"Volume-averaged Ohmic heating\": Q_ohm_vol_av,\n                \"Volume-averaged Ohmic heating [A.V.m-3]\": param.i_typ\n                * param.potential_scale\n                * Q_ohm_vol_av\n                / param.L_x,\n                \"Irreversible electrochemical heating\": Q_rxn,\n                \"Irreversible electrochemical heating [A.V.m-3]\": param.i_typ\n                * param.potential_scale\n                * Q_rxn\n                / param.L_x,\n                \"X-averaged electrochemical heating\": Q_rxn_av,\n                \"X-averaged electrochemical heating [A.V.m-3]\": param.i_typ\n                * param.potential_scale\n                * Q_rxn_av\n                / param.L_x,\n                \"Volume-averaged electrochemical heating\": Q_rxn_vol_av,\n                \"Volume-averaged electrochemical heating [A.V.m-3]\": param.i_typ\n                * param.potential_scale\n                * Q_rxn_vol_av\n                / param.L_x,\n                \"Reversible heating\": Q_rev,\n                \"Reversible heating [A.V.m-3]\": param.i_typ\n                * param.potential_scale\n                * Q_rev\n                / param.L_x,\n                \"X-averaged reversible heating\": Q_rev_av,\n                \"X-averaged reversible heating [A.V.m-3]\": param.i_typ\n                * param.potential_scale\n                * Q_rev_av\n                / param.L_x,\n                \"Volume-averaged reversible heating\": Q_rev_vol_av,\n                \"Volume-averaged reversible heating [A.V.m-3]\": param.i_typ\n                * param.potential_scale\n                * Q_rev_vol_av\n                / param.L_x,\n                \"Total heating\": Q,\n                \"Total heating [A.V.m-3]\": param.i_typ\n                * param.potential_scale\n                * Q\n                / param.L_x,\n                \"X-averaged total heating\": Q_av,\n                \"X-averaged total heating [A.V.m-3]\": param.i_typ\n                * param.potential_scale\n                * Q_av\n                / param.L_x,\n                \"Volume-averaged total heating\": Q_vol_av,\n                \"Volume-averaged total heating [A.V.m-3]\": param.i_typ\n                * param.potential_scale\n                * Q_vol_av\n                / param.L_x,\n            }\n        )\n        return variables",
  "def _flux_law(self, T):\n        raise NotImplementedError",
  "def _unpack(self, variables):\n        raise NotImplementedError",
  "def _current_collector_heating(self, variables):\n        raise NotImplementedError",
  "def _yz_average(self, var):\n        raise NotImplementedError",
  "def _x_average(self, var, var_cn, var_cp):\n        \"\"\"\n        Computes the X-average over the whole cell (including current collectors)\n        from the variable in the cell (negative electrode, separator,\n        positive electrode), negative current collector, and positive current\n        collector. This method is overwritten by models which do not include\n        current collector effects, so that the average is just taken over the\n        negative electrode, separator and positive electrode.\n        Note: we do this as we cannot create a single variable which is\n        the concatenation [var_cn, var, var_cp] since var_cn and var_cp share the\n        same domian. (In the N+1D formulation the current collector variables are\n        assumed independent of x, so we do not make the distinction between negative\n        and positive current collectors in the geometry).\n        \"\"\"\n        # When averging the temperature for x-lumped or xyz-lumped models, var\n        # is a concatenation of broadcasts of the X- or Volume- averaged temperature.\n        # In this instance we return the (unmodified) variable corresponding to\n        # the correct average to avoid a ModelError (the unmodified variables must\n        # be the key in model.rhs)\n        if isinstance(var, pybamm.Concatenation) and all(\n            isinstance(child, pybamm.Broadcast) for child in var.children\n        ):\n            # Create list of var.ids\n            var_ids = [child.children[0].id for child in var.children]\n            var_ids.extend([var_cn.id, var_cp.id])\n            # If all var.ids the same, then the variable is uniform in x so can\n            # just return one the values (arbitrarily var_cn here)\n            if len(set(var_ids)) == 1:\n                out = var_cn\n        else:\n            out = (\n                self.param.l_cn * var_cn\n                + pybamm.x_average(var)\n                + self.param.l_cp * var_cp\n            ) / self.param.l\n        return out",
  "class BaseModel(BaseThermal):\n    \"\"\"Base class for xyz-lumped thermal submodel\n\n    Parameters\n    ----------\n    param : parameter class\n        The parameters to use for this submodel\n\n\n    **Extends:** :class:`pybamm.thermal.BaseModel`\n    \"\"\"\n\n    def __init__(self, param):\n        super().__init__(param)\n\n    def get_fundamental_variables(self):\n\n        T_vol_av = pybamm.standard_variables.T_vol_av\n        T_x_av = pybamm.PrimaryBroadcast(T_vol_av, [\"current collector\"])\n\n        T_n = pybamm.PrimaryBroadcast(T_x_av, \"negative electrode\")\n        T_s = pybamm.PrimaryBroadcast(T_x_av, \"separator\")\n        T_p = pybamm.PrimaryBroadcast(T_x_av, \"positive electrode\")\n        T = pybamm.Concatenation(T_n, T_s, T_p)\n\n        T_cn = T_x_av\n        T_cp = T_x_av\n\n        variables = self._get_standard_fundamental_variables(T, T_cn, T_cp)\n\n        return variables\n\n    def get_coupled_variables(self, variables):\n        variables.update(self._get_standard_coupled_variables(variables))\n        return variables\n\n    def set_rhs(self, variables):\n        T_vol_av = variables[\"Volume-averaged cell temperature\"]\n        Q_vol_av = variables[\"Volume-averaged total heating\"]\n\n        cooling_coeff = self._surface_cooling_coefficient()\n\n        self.rhs = {\n            T_vol_av: (self.param.B * Q_vol_av + cooling_coeff * T_vol_av)\n            / self.param.C_th\n        }\n\n    def _flux_law(self, T):\n        \"\"\"Fast heat diffusion (temperature has no spatial dependence)\"\"\"\n        q = pybamm.FullBroadcast(\n            pybamm.Scalar(0),\n            [\"negative electrode\", \"separator\", \"positive electrode\"],\n            \"current collector\",\n        )\n        return q\n\n    def set_initial_conditions(self, variables):\n        T_vol_av = variables[\"Volume-averaged cell temperature\"]\n        self.initial_conditions = {T_vol_av: self.param.T_init}",
  "def __init__(self, param):\n        super().__init__(param)",
  "def get_fundamental_variables(self):\n\n        T_vol_av = pybamm.standard_variables.T_vol_av\n        T_x_av = pybamm.PrimaryBroadcast(T_vol_av, [\"current collector\"])\n\n        T_n = pybamm.PrimaryBroadcast(T_x_av, \"negative electrode\")\n        T_s = pybamm.PrimaryBroadcast(T_x_av, \"separator\")\n        T_p = pybamm.PrimaryBroadcast(T_x_av, \"positive electrode\")\n        T = pybamm.Concatenation(T_n, T_s, T_p)\n\n        T_cn = T_x_av\n        T_cp = T_x_av\n\n        variables = self._get_standard_fundamental_variables(T, T_cn, T_cp)\n\n        return variables",
  "def get_coupled_variables(self, variables):\n        variables.update(self._get_standard_coupled_variables(variables))\n        return variables",
  "def set_rhs(self, variables):\n        T_vol_av = variables[\"Volume-averaged cell temperature\"]\n        Q_vol_av = variables[\"Volume-averaged total heating\"]\n\n        cooling_coeff = self._surface_cooling_coefficient()\n\n        self.rhs = {\n            T_vol_av: (self.param.B * Q_vol_av + cooling_coeff * T_vol_av)\n            / self.param.C_th\n        }",
  "def _flux_law(self, T):\n        \"\"\"Fast heat diffusion (temperature has no spatial dependence)\"\"\"\n        q = pybamm.FullBroadcast(\n            pybamm.Scalar(0),\n            [\"negative electrode\", \"separator\", \"positive electrode\"],\n            \"current collector\",\n        )\n        return q",
  "def set_initial_conditions(self, variables):\n        T_vol_av = variables[\"Volume-averaged cell temperature\"]\n        self.initial_conditions = {T_vol_av: self.param.T_init}",
  "class CurrentCollector2D(BaseModel):\n    \"\"\"Class for xyz-lumped thermal submodel with 2D current collectors\n\n    Parameters\n    ----------\n    param : parameter class\n        The parameters to use for this submodel\n\n\n    **Extends:** :class:`pybamm.thermal.BaseModel`\n    \"\"\"\n\n    def __init__(self, param):\n        super().__init__(param)\n\n    def _current_collector_heating(self, variables):\n        \"\"\"Returns the heat source terms in the 2D current collector\"\"\"\n        phi_s_cn = variables[\"Negative current collector potential\"]\n        phi_s_cp = variables[\"Positive current collector potential\"]\n        # Note: grad not implemented in 2D weak form, but can compute grad squared\n        # directly\n        Q_s_cn = self.param.sigma_cn_prime * pybamm.grad_squared(phi_s_cn)\n        Q_s_cp = self.param.sigma_cp_prime * pybamm.grad_squared(phi_s_cp)\n        return Q_s_cn, Q_s_cp\n\n    def _surface_cooling_coefficient(self):\n        \"\"\"Returns the surface cooling coefficient in 2+1D\"\"\"\n        return (\n            -2 * self.param.h / (self.param.delta ** 2) / self.param.l\n            - 2 * (self.param.l_y + self.param.l_z) * self.param.h / self.param.delta\n        )\n\n    def _yz_average(self, var):\n        \"\"\"Computes the y-z average by integration over y and z\"\"\"\n        return pybamm.yz_average(var)",
  "def __init__(self, param):\n        super().__init__(param)",
  "def _current_collector_heating(self, variables):\n        \"\"\"Returns the heat source terms in the 2D current collector\"\"\"\n        phi_s_cn = variables[\"Negative current collector potential\"]\n        phi_s_cp = variables[\"Positive current collector potential\"]\n        # Note: grad not implemented in 2D weak form, but can compute grad squared\n        # directly\n        Q_s_cn = self.param.sigma_cn_prime * pybamm.grad_squared(phi_s_cn)\n        Q_s_cp = self.param.sigma_cp_prime * pybamm.grad_squared(phi_s_cp)\n        return Q_s_cn, Q_s_cp",
  "def _surface_cooling_coefficient(self):\n        \"\"\"Returns the surface cooling coefficient in 2+1D\"\"\"\n        return (\n            -2 * self.param.h / (self.param.delta ** 2) / self.param.l\n            - 2 * (self.param.l_y + self.param.l_z) * self.param.h / self.param.delta\n        )",
  "def _yz_average(self, var):\n        \"\"\"Computes the y-z average by integration over y and z\"\"\"\n        return pybamm.yz_average(var)",
  "class CurrentCollector1D(BaseModel):\n    \"\"\"Class for xyz-lumped thermal submodel with 1D current collectors\n\n    Parameters\n    ----------\n    param : parameter class\n        The parameters to use for this submodel\n\n\n    **Extends:** :class:`pybamm.thermal.BaseModel`\n    \"\"\"\n\n    def _current_collector_heating(self, variables):\n        \"\"\"Returns the heat source terms in the 1D current collector\"\"\"\n        phi_s_cn = variables[\"Negative current collector potential\"]\n        phi_s_cp = variables[\"Positive current collector potential\"]\n        Q_s_cn = self.param.sigma_cn_prime * pybamm.inner(\n            pybamm.grad(phi_s_cn), pybamm.grad(phi_s_cn)\n        )\n        Q_s_cp = self.param.sigma_cp_prime * pybamm.inner(\n            pybamm.grad(phi_s_cp), pybamm.grad(phi_s_cp)\n        )\n        return Q_s_cn, Q_s_cp\n\n    def _surface_cooling_coefficient(self):\n        \"\"\"Returns the surface cooling coefficient in 1+1D\"\"\"\n        return (\n            -2 * self.param.h / (self.param.delta ** 2) / self.param.l\n            - self.param.l_z * self.param.h / self.param.delta\n        )\n\n    def _yz_average(self, var):\n        \"\"\"Computes the y-z average by integration over z (no y-direction)\"\"\"\n        return pybamm.z_average(var)",
  "def _current_collector_heating(self, variables):\n        \"\"\"Returns the heat source terms in the 1D current collector\"\"\"\n        phi_s_cn = variables[\"Negative current collector potential\"]\n        phi_s_cp = variables[\"Positive current collector potential\"]\n        Q_s_cn = self.param.sigma_cn_prime * pybamm.inner(\n            pybamm.grad(phi_s_cn), pybamm.grad(phi_s_cn)\n        )\n        Q_s_cp = self.param.sigma_cp_prime * pybamm.inner(\n            pybamm.grad(phi_s_cp), pybamm.grad(phi_s_cp)\n        )\n        return Q_s_cn, Q_s_cp",
  "def _surface_cooling_coefficient(self):\n        \"\"\"Returns the surface cooling coefficient in 1+1D\"\"\"\n        return (\n            -2 * self.param.h / (self.param.delta ** 2) / self.param.l\n            - self.param.l_z * self.param.h / self.param.delta\n        )",
  "def _yz_average(self, var):\n        \"\"\"Computes the y-z average by integration over z (no y-direction)\"\"\"\n        return pybamm.z_average(var)",
  "class BaseModel(BaseThermal):\n    \"\"\"Base class for full x-direction thermal submodels.\n\n    Parameters\n    ----------\n    param : parameter class\n        The parameters to use for this submodel\n\n\n    **Extends:** :class:`pybamm.thermal.BaseModel`\n    \"\"\"\n\n    def __init__(self, param):\n        super().__init__(param)\n\n    def get_fundamental_variables(self):\n        T = pybamm.standard_variables.T\n        T_cn = pybamm.BoundaryValue(T, \"left\")\n        T_cp = pybamm.BoundaryValue(T, \"right\")\n        variables = self._get_standard_fundamental_variables(T, T_cn, T_cp)\n        return variables\n\n    def get_coupled_variables(self, variables):\n        variables.update(self._get_standard_coupled_variables(variables))\n        return variables\n\n    def _flux_law(self, T):\n        \"\"\"Fourier's law for heat transfer\"\"\"\n        q = -self.param.lambda_k * pybamm.grad(T)\n        return q\n\n    def set_initial_conditions(self, variables):\n        T = variables[\"Cell temperature\"]\n        self.initial_conditions = {T: self.param.T_init}",
  "def __init__(self, param):\n        super().__init__(param)",
  "def get_fundamental_variables(self):\n        T = pybamm.standard_variables.T\n        T_cn = pybamm.BoundaryValue(T, \"left\")\n        T_cp = pybamm.BoundaryValue(T, \"right\")\n        variables = self._get_standard_fundamental_variables(T, T_cn, T_cp)\n        return variables",
  "def get_coupled_variables(self, variables):\n        variables.update(self._get_standard_coupled_variables(variables))\n        return variables",
  "def _flux_law(self, T):\n        \"\"\"Fourier's law for heat transfer\"\"\"\n        q = -self.param.lambda_k * pybamm.grad(T)\n        return q",
  "def set_initial_conditions(self, variables):\n        T = variables[\"Cell temperature\"]\n        self.initial_conditions = {T: self.param.T_init}",
  "class NoCurrentCollector(BaseModel):\n    \"\"\"Class for full x-direction thermal submodel without current collectors\n\n    Parameters\n    ----------\n    param : parameter class\n        The parameters to use for this submodel\n\n\n    **Extends:** :class:`pybamm.thermal.x_full.BaseModel`\n    \"\"\"\n\n    def __init__(self, param):\n        super().__init__(param)\n\n    def set_rhs(self, variables):\n        T = variables[\"Cell temperature\"]\n        q = variables[\"Heat flux\"]\n        Q = variables[\"Total heating\"]\n\n        self.rhs = {\n            T: (-pybamm.div(q) / self.param.delta ** 2 + self.param.B * Q)\n            / (self.param.C_th * self.param.rho_k)\n        }\n\n    def set_boundary_conditions(self, variables):\n        T = variables[\"Cell temperature\"]\n        T_n_left = pybamm.boundary_value(T, \"left\")\n        T_p_right = pybamm.boundary_value(T, \"right\")\n\n        self.boundary_conditions = {\n            T: {\n                \"left\": (self.param.h * T_n_left / self.param.lambda_n, \"Neumann\"),\n                \"right\": (-self.param.h * T_p_right / self.param.lambda_p, \"Neumann\"),\n            }\n        }\n\n    def _current_collector_heating(self, variables):\n        \"\"\"Returns zeros for current collector heat source terms\"\"\"\n        Q_s_cn = pybamm.Scalar(0)\n        Q_s_cp = pybamm.Scalar(0)\n        return Q_s_cn, Q_s_cp\n\n    def _yz_average(self, var):\n        \"\"\"Computes the y-z average by integration over y and z\n            In this case this is just equal to the input variable\"\"\"\n        return var\n\n    def _x_average(self, var, var_cn, var_cp):\n        \"\"\"\n        Computes the X-average over the whole cell *not* including current\n        collectors. This overwrites the default behaviour of 'base_thermal'.\n        \"\"\"\n        return pybamm.x_average(var)",
  "def __init__(self, param):\n        super().__init__(param)",
  "def set_rhs(self, variables):\n        T = variables[\"Cell temperature\"]\n        q = variables[\"Heat flux\"]\n        Q = variables[\"Total heating\"]\n\n        self.rhs = {\n            T: (-pybamm.div(q) / self.param.delta ** 2 + self.param.B * Q)\n            / (self.param.C_th * self.param.rho_k)\n        }",
  "def set_boundary_conditions(self, variables):\n        T = variables[\"Cell temperature\"]\n        T_n_left = pybamm.boundary_value(T, \"left\")\n        T_p_right = pybamm.boundary_value(T, \"right\")\n\n        self.boundary_conditions = {\n            T: {\n                \"left\": (self.param.h * T_n_left / self.param.lambda_n, \"Neumann\"),\n                \"right\": (-self.param.h * T_p_right / self.param.lambda_p, \"Neumann\"),\n            }\n        }",
  "def _current_collector_heating(self, variables):\n        \"\"\"Returns zeros for current collector heat source terms\"\"\"\n        Q_s_cn = pybamm.Scalar(0)\n        Q_s_cp = pybamm.Scalar(0)\n        return Q_s_cn, Q_s_cp",
  "def _yz_average(self, var):\n        \"\"\"Computes the y-z average by integration over y and z\n            In this case this is just equal to the input variable\"\"\"\n        return var",
  "def _x_average(self, var, var_cn, var_cp):\n        \"\"\"\n        Computes the X-average over the whole cell *not* including current\n        collectors. This overwrites the default behaviour of 'base_thermal'.\n        \"\"\"\n        return pybamm.x_average(var)",
  "class CurrentCollector0D(BaseModel):\n    \"\"\"Class for x-lumped thermal model with 0D current collectors\"\"\"\n\n    def __init__(self, param):\n        super().__init__(param)\n\n    def set_rhs(self, variables):\n        T_av = variables[\"X-averaged cell temperature\"]\n        Q_av = variables[\"X-averaged total heating\"]\n\n        self.rhs = {\n            T_av: (\n                self.param.B * Q_av\n                - (2 * self.param.h / (self.param.delta ** 2) / self.param.l) * T_av\n            )\n            / self.param.C_th\n        }\n\n    def _current_collector_heating(self, variables):\n        \"\"\"Returns the heat source terms in the 0D current collector\"\"\"\n        i_boundary_cc = variables[\"Current collector current density\"]\n        Q_s_cn = i_boundary_cc ** 2 / self.param.sigma_cn\n        Q_s_cp = i_boundary_cc ** 2 / self.param.sigma_cp\n        return Q_s_cn, Q_s_cp\n\n    def _yz_average(self, var):\n        \"\"\"In 1D volume-averaged quantities are unchanged\"\"\"\n        return var",
  "def __init__(self, param):\n        super().__init__(param)",
  "def set_rhs(self, variables):\n        T_av = variables[\"X-averaged cell temperature\"]\n        Q_av = variables[\"X-averaged total heating\"]\n\n        self.rhs = {\n            T_av: (\n                self.param.B * Q_av\n                - (2 * self.param.h / (self.param.delta ** 2) / self.param.l) * T_av\n            )\n            / self.param.C_th\n        }",
  "def _current_collector_heating(self, variables):\n        \"\"\"Returns the heat source terms in the 0D current collector\"\"\"\n        i_boundary_cc = variables[\"Current collector current density\"]\n        Q_s_cn = i_boundary_cc ** 2 / self.param.sigma_cn\n        Q_s_cp = i_boundary_cc ** 2 / self.param.sigma_cp\n        return Q_s_cn, Q_s_cp",
  "def _yz_average(self, var):\n        \"\"\"In 1D volume-averaged quantities are unchanged\"\"\"\n        return var",
  "class NoCurrentCollector(BaseModel):\n    \"\"\"\n    Class for x-lumped thermal submodel without current collectors. Note: since\n    there are no current collectors in this model, the electrochemical model\n    must be 1D (x-direction only).\n\n    Parameters\n    ----------\n    param : parameter class\n        The parameters to use for this submodel\n\n\n    **Extends:** :class:`pybamm.thermal.BaseModel`\n    \"\"\"\n\n    def __init__(self, param):\n        super().__init__(param)\n\n    def set_rhs(self, variables):\n        T_av = variables[\"X-averaged cell temperature\"]\n        Q_av = variables[\"X-averaged total heating\"]\n\n        self.rhs = {\n            T_av: (\n                self.param.B * Q_av\n                - (2 * self.param.h / (self.param.delta ** 2) / self.param.l) * T_av\n            )\n            / self.param.C_th\n        }\n\n    def _current_collector_heating(self, variables):\n        \"\"\"Returns zeros for current collector heat source terms\"\"\"\n        Q_s_cn = pybamm.Scalar(0)\n        Q_s_cp = pybamm.Scalar(0)\n        return Q_s_cn, Q_s_cp\n\n    def _yz_average(self, var):\n        \"\"\"In 1D volume-averaged quantities are unchanged\"\"\"\n        return var\n\n    def _x_average(self, var, var_cn, var_cp):\n        \"\"\"\n        Computes the X-average over the whole cell *not* including current\n        collectors. This overwrites the default behaviour of 'base_thermal'.\n        \"\"\"\n        return pybamm.x_average(var)",
  "def __init__(self, param):\n        super().__init__(param)",
  "def set_rhs(self, variables):\n        T_av = variables[\"X-averaged cell temperature\"]\n        Q_av = variables[\"X-averaged total heating\"]\n\n        self.rhs = {\n            T_av: (\n                self.param.B * Q_av\n                - (2 * self.param.h / (self.param.delta ** 2) / self.param.l) * T_av\n            )\n            / self.param.C_th\n        }",
  "def _current_collector_heating(self, variables):\n        \"\"\"Returns zeros for current collector heat source terms\"\"\"\n        Q_s_cn = pybamm.Scalar(0)\n        Q_s_cp = pybamm.Scalar(0)\n        return Q_s_cn, Q_s_cp",
  "def _yz_average(self, var):\n        \"\"\"In 1D volume-averaged quantities are unchanged\"\"\"\n        return var",
  "def _x_average(self, var, var_cn, var_cp):\n        \"\"\"\n        Computes the X-average over the whole cell *not* including current\n        collectors. This overwrites the default behaviour of 'base_thermal'.\n        \"\"\"\n        return pybamm.x_average(var)",
  "class CurrentCollector2D(BaseModel):\n    \"\"\"Class for x-lumped thermal submodel with 2D current collectors\"\"\"\n\n    def __init__(self, param):\n        super().__init__(param)\n\n    def set_rhs(self, variables):\n        T_av = variables[\"X-averaged cell temperature\"]\n        Q_av = variables[\"X-averaged total heating\"]\n\n        # Add boundary source term which accounts for surface cooling around\n        # the edge of the domain in the weak formulation.\n        # TODO: update to allow different cooling conditions at the tabs\n        self.rhs = {\n            T_av: (\n                pybamm.laplacian(T_av)\n                + self.param.B * pybamm.source(Q_av, T_av)\n                - (2 * self.param.h / (self.param.delta ** 2) / self.param.l)\n                * pybamm.source(T_av, T_av)\n                - (self.param.h / self.param.delta)\n                * pybamm.source(T_av, T_av, boundary=True)\n            )\n            / self.param.C_th\n        }\n\n    def set_boundary_conditions(self, variables):\n        T_av = variables[\"X-averaged cell temperature\"]\n        # Dummy no flux boundary conditions since cooling at the the tabs is\n        # accounted for in the boundary source term in the weak form of the\n        # governing equation\n        # TODO: update to allow different cooling conditions at the tabs\n        self.boundary_conditions = {\n            T_av: {\n                \"negative tab\": (pybamm.Scalar(0), \"Neumann\"),\n                \"positive tab\": (pybamm.Scalar(0), \"Neumann\"),\n            }\n        }\n\n    def _current_collector_heating(self, variables):\n        \"\"\"Returns the heat source terms in the 2D current collector\"\"\"\n        phi_s_cn = variables[\"Negative current collector potential\"]\n        phi_s_cp = variables[\"Positive current collector potential\"]\n        # Note: grad not implemented in 2D weak form, but can compute grad squared\n        # directly\n        Q_s_cn = self.param.sigma_cn_prime * pybamm.grad_squared(phi_s_cn)\n        Q_s_cp = self.param.sigma_cp_prime * pybamm.grad_squared(phi_s_cp)\n        return Q_s_cn, Q_s_cp\n\n    def _yz_average(self, var):\n        \"\"\"Computes the y-z average by integration over y and z\"\"\"\n        return pybamm.yz_average(var)",
  "def __init__(self, param):\n        super().__init__(param)",
  "def set_rhs(self, variables):\n        T_av = variables[\"X-averaged cell temperature\"]\n        Q_av = variables[\"X-averaged total heating\"]\n\n        # Add boundary source term which accounts for surface cooling around\n        # the edge of the domain in the weak formulation.\n        # TODO: update to allow different cooling conditions at the tabs\n        self.rhs = {\n            T_av: (\n                pybamm.laplacian(T_av)\n                + self.param.B * pybamm.source(Q_av, T_av)\n                - (2 * self.param.h / (self.param.delta ** 2) / self.param.l)\n                * pybamm.source(T_av, T_av)\n                - (self.param.h / self.param.delta)\n                * pybamm.source(T_av, T_av, boundary=True)\n            )\n            / self.param.C_th\n        }",
  "def set_boundary_conditions(self, variables):\n        T_av = variables[\"X-averaged cell temperature\"]\n        # Dummy no flux boundary conditions since cooling at the the tabs is\n        # accounted for in the boundary source term in the weak form of the\n        # governing equation\n        # TODO: update to allow different cooling conditions at the tabs\n        self.boundary_conditions = {\n            T_av: {\n                \"negative tab\": (pybamm.Scalar(0), \"Neumann\"),\n                \"positive tab\": (pybamm.Scalar(0), \"Neumann\"),\n            }\n        }",
  "def _current_collector_heating(self, variables):\n        \"\"\"Returns the heat source terms in the 2D current collector\"\"\"\n        phi_s_cn = variables[\"Negative current collector potential\"]\n        phi_s_cp = variables[\"Positive current collector potential\"]\n        # Note: grad not implemented in 2D weak form, but can compute grad squared\n        # directly\n        Q_s_cn = self.param.sigma_cn_prime * pybamm.grad_squared(phi_s_cn)\n        Q_s_cp = self.param.sigma_cp_prime * pybamm.grad_squared(phi_s_cp)\n        return Q_s_cn, Q_s_cp",
  "def _yz_average(self, var):\n        \"\"\"Computes the y-z average by integration over y and z\"\"\"\n        return pybamm.yz_average(var)",
  "class CurrentCollector1D(BaseModel):\n    \"\"\"Class for x-lumped thermal model with 1D current collectors\"\"\"\n\n    def __init__(self, param):\n        super().__init__(param)\n\n    def set_rhs(self, variables):\n        T_av = variables[\"X-averaged cell temperature\"]\n        Q_av = variables[\"X-averaged total heating\"]\n        self.rhs = {\n            T_av: (\n                pybamm.laplacian(T_av)\n                + self.param.B * Q_av\n                - (2 * self.param.h / (self.param.delta ** 2) / self.param.l) * T_av\n            )\n            / self.param.C_th\n        }\n\n    def set_boundary_conditions(self, variables):\n        T_av = variables[\"X-averaged cell temperature\"]\n        T_av_left = pybamm.boundary_value(T_av, \"negative tab\")\n        T_av_right = pybamm.boundary_value(T_av, \"positive tab\")\n\n        # Three boundary conditions here to handle the cases of both tabs at\n        # the same side (top or bottom), or one either side. For both tabs on the\n        # same side, T_av_left and T_av_right are equal, and the boundary condition\n        # \"no tab\" is used on the other side.\n        self.boundary_conditions = {\n            T_av: {\n                \"negative tab\": (\n                    self.param.h * T_av_left / self.param.delta,\n                    \"Neumann\",\n                ),\n                \"positive tab\": (\n                    -self.param.h * T_av_right / self.param.delta,\n                    \"Neumann\",\n                ),\n                \"no tab\": (pybamm.Scalar(0), \"Neumann\"),\n            }\n        }\n\n    def _current_collector_heating(self, variables):\n        \"\"\"Returns the heat source terms in the 1D current collector\"\"\"\n        phi_s_cn = variables[\"Negative current collector potential\"]\n        phi_s_cp = variables[\"Positive current collector potential\"]\n        Q_s_cn = self.param.sigma_cn_prime * pybamm.inner(\n            pybamm.grad(phi_s_cn), pybamm.grad(phi_s_cn)\n        )\n        Q_s_cp = self.param.sigma_cp_prime * pybamm.inner(\n            pybamm.grad(phi_s_cp), pybamm.grad(phi_s_cp)\n        )\n        return Q_s_cn, Q_s_cp\n\n    def _yz_average(self, var):\n        \"\"\"Computes the y-z average by integration over z (no y-direction)\"\"\"\n        return pybamm.z_average(var)",
  "def __init__(self, param):\n        super().__init__(param)",
  "def set_rhs(self, variables):\n        T_av = variables[\"X-averaged cell temperature\"]\n        Q_av = variables[\"X-averaged total heating\"]\n        self.rhs = {\n            T_av: (\n                pybamm.laplacian(T_av)\n                + self.param.B * Q_av\n                - (2 * self.param.h / (self.param.delta ** 2) / self.param.l) * T_av\n            )\n            / self.param.C_th\n        }",
  "def set_boundary_conditions(self, variables):\n        T_av = variables[\"X-averaged cell temperature\"]\n        T_av_left = pybamm.boundary_value(T_av, \"negative tab\")\n        T_av_right = pybamm.boundary_value(T_av, \"positive tab\")\n\n        # Three boundary conditions here to handle the cases of both tabs at\n        # the same side (top or bottom), or one either side. For both tabs on the\n        # same side, T_av_left and T_av_right are equal, and the boundary condition\n        # \"no tab\" is used on the other side.\n        self.boundary_conditions = {\n            T_av: {\n                \"negative tab\": (\n                    self.param.h * T_av_left / self.param.delta,\n                    \"Neumann\",\n                ),\n                \"positive tab\": (\n                    -self.param.h * T_av_right / self.param.delta,\n                    \"Neumann\",\n                ),\n                \"no tab\": (pybamm.Scalar(0), \"Neumann\"),\n            }\n        }",
  "def _current_collector_heating(self, variables):\n        \"\"\"Returns the heat source terms in the 1D current collector\"\"\"\n        phi_s_cn = variables[\"Negative current collector potential\"]\n        phi_s_cp = variables[\"Positive current collector potential\"]\n        Q_s_cn = self.param.sigma_cn_prime * pybamm.inner(\n            pybamm.grad(phi_s_cn), pybamm.grad(phi_s_cn)\n        )\n        Q_s_cp = self.param.sigma_cp_prime * pybamm.inner(\n            pybamm.grad(phi_s_cp), pybamm.grad(phi_s_cp)\n        )\n        return Q_s_cn, Q_s_cp",
  "def _yz_average(self, var):\n        \"\"\"Computes the y-z average by integration over z (no y-direction)\"\"\"\n        return pybamm.z_average(var)",
  "class BaseModel(BaseThermal):\n    \"\"\"Base class for x-lumped thermal submodel\n\n    Parameters\n    ----------\n    param : parameter class\n        The parameters to use for this submodel\n\n\n    **Extends:** :class:`pybamm.thermal.BaseModel`\n    \"\"\"\n\n    def __init__(self, param):\n        super().__init__(param)\n\n    def get_fundamental_variables(self):\n\n        T_x_av = pybamm.standard_variables.T_av\n        T_n = pybamm.PrimaryBroadcast(T_x_av, \"negative electrode\")\n        T_s = pybamm.PrimaryBroadcast(T_x_av, \"separator\")\n        T_p = pybamm.PrimaryBroadcast(T_x_av, \"positive electrode\")\n        T = pybamm.Concatenation(T_n, T_s, T_p)\n\n        T_cn = T_x_av\n        T_cp = T_x_av\n\n        variables = self._get_standard_fundamental_variables(T, T_cn, T_cp)\n        return variables\n\n    def get_coupled_variables(self, variables):\n        variables.update(self._get_standard_coupled_variables(variables))\n        return variables\n\n    def _flux_law(self, T):\n        \"\"\"Fast heat diffusion (temperature has no spatial dependence)\"\"\"\n        q = pybamm.FullBroadcast(\n            pybamm.Scalar(0),\n            [\"negative electrode\", \"separator\", \"positive electrode\"],\n            \"current collector\",\n        )\n        return q\n\n    def set_initial_conditions(self, variables):\n        T = variables[\"X-averaged cell temperature\"]\n        self.initial_conditions = {T: self.param.T_init}",
  "def __init__(self, param):\n        super().__init__(param)",
  "def get_fundamental_variables(self):\n\n        T_x_av = pybamm.standard_variables.T_av\n        T_n = pybamm.PrimaryBroadcast(T_x_av, \"negative electrode\")\n        T_s = pybamm.PrimaryBroadcast(T_x_av, \"separator\")\n        T_p = pybamm.PrimaryBroadcast(T_x_av, \"positive electrode\")\n        T = pybamm.Concatenation(T_n, T_s, T_p)\n\n        T_cn = T_x_av\n        T_cp = T_x_av\n\n        variables = self._get_standard_fundamental_variables(T, T_cn, T_cp)\n        return variables",
  "def get_coupled_variables(self, variables):\n        variables.update(self._get_standard_coupled_variables(variables))\n        return variables",
  "def _flux_law(self, T):\n        \"\"\"Fast heat diffusion (temperature has no spatial dependence)\"\"\"\n        q = pybamm.FullBroadcast(\n            pybamm.Scalar(0),\n            [\"negative electrode\", \"separator\", \"positive electrode\"],\n            \"current collector\",\n        )\n        return q",
  "def set_initial_conditions(self, variables):\n        T = variables[\"X-averaged cell temperature\"]\n        self.initial_conditions = {T: self.param.T_init}",
  "class Isothermal(BaseThermal):\n    \"\"\"Class for isothermal submodel.\n\n    Parameters\n    ----------\n    param : parameter class\n        The parameters to use for this submodel\n\n\n    **Extends:** :class:`pybamm.thermal.BaseThermal`\n    \"\"\"\n\n    def __init__(self, param):\n        super().__init__(param)\n\n    def get_fundamental_variables(self):\n\n        T_x_av = pybamm.PrimaryBroadcast(0, \"current collector\")\n        T_n = pybamm.PrimaryBroadcast(T_x_av, \"negative electrode\")\n        T_s = pybamm.PrimaryBroadcast(T_x_av, \"separator\")\n        T_p = pybamm.PrimaryBroadcast(T_x_av, \"positive electrode\")\n        T = pybamm.Concatenation(T_n, T_s, T_p)\n\n        T_cn = T_x_av\n        T_cp = T_x_av\n\n        variables = self._get_standard_fundamental_variables(T, T_cn, T_cp)\n        return variables\n\n    def get_coupled_variables(self, variables):\n        variables.update(\n            {\n                \"Ohmic heating\": pybamm.Scalar(0),\n                \"Ohmic heating [A.V.m-3]\": pybamm.Scalar(0),\n                \"Irreversible electrochemical heating\": pybamm.Scalar(0),\n                \"Irreversible electrochemical heating [A.V.m-3]\": pybamm.Scalar(0),\n                \"Reversible heating\": pybamm.Scalar(0),\n                \"Reversible heating [A.V.m-3]\": pybamm.Scalar(0),\n                \"Total heating\": pybamm.Scalar(0),\n                \"Total heating [A.V.m-3]\": pybamm.Scalar(0),\n                \"X-averaged total heating\": pybamm.Scalar(0),\n                \"X-averaged total heating [A.V.m-3]\": pybamm.Scalar(0),\n                \"Volume-averaged total heating\": pybamm.Scalar(0),\n                \"Volume-averaged total heating [A.V.m-3]\": pybamm.Scalar(0),\n            }\n        )\n        return variables\n\n    def _flux_law(self, T):\n        \"\"\"Zero heat flux since temperature is constant\"\"\"\n        q = pybamm.FullBroadcast(\n            pybamm.Scalar(0),\n            [\"negative electrode\", \"separator\", \"positive electrode\"],\n            \"current collector\",\n        )\n        return q\n\n    def _yz_average(self, var):\n        \"\"\"\n        Temperature is uniform and heat source terms are zero, so the average\n        returns the input variable.\n        \"\"\"\n        return var\n\n    def _x_average(self, var, var_cn, var_cp):\n        \"\"\"\n        Temperature is uniform and heat source terms are zero, so the average\n        returns the input variable.\n        \"\"\"\n        return var",
  "def __init__(self, param):\n        super().__init__(param)",
  "def get_fundamental_variables(self):\n\n        T_x_av = pybamm.PrimaryBroadcast(0, \"current collector\")\n        T_n = pybamm.PrimaryBroadcast(T_x_av, \"negative electrode\")\n        T_s = pybamm.PrimaryBroadcast(T_x_av, \"separator\")\n        T_p = pybamm.PrimaryBroadcast(T_x_av, \"positive electrode\")\n        T = pybamm.Concatenation(T_n, T_s, T_p)\n\n        T_cn = T_x_av\n        T_cp = T_x_av\n\n        variables = self._get_standard_fundamental_variables(T, T_cn, T_cp)\n        return variables",
  "def get_coupled_variables(self, variables):\n        variables.update(\n            {\n                \"Ohmic heating\": pybamm.Scalar(0),\n                \"Ohmic heating [A.V.m-3]\": pybamm.Scalar(0),\n                \"Irreversible electrochemical heating\": pybamm.Scalar(0),\n                \"Irreversible electrochemical heating [A.V.m-3]\": pybamm.Scalar(0),\n                \"Reversible heating\": pybamm.Scalar(0),\n                \"Reversible heating [A.V.m-3]\": pybamm.Scalar(0),\n                \"Total heating\": pybamm.Scalar(0),\n                \"Total heating [A.V.m-3]\": pybamm.Scalar(0),\n                \"X-averaged total heating\": pybamm.Scalar(0),\n                \"X-averaged total heating [A.V.m-3]\": pybamm.Scalar(0),\n                \"Volume-averaged total heating\": pybamm.Scalar(0),\n                \"Volume-averaged total heating [A.V.m-3]\": pybamm.Scalar(0),\n            }\n        )\n        return variables",
  "def _flux_law(self, T):\n        \"\"\"Zero heat flux since temperature is constant\"\"\"\n        q = pybamm.FullBroadcast(\n            pybamm.Scalar(0),\n            [\"negative electrode\", \"separator\", \"positive electrode\"],\n            \"current collector\",\n        )\n        return q",
  "def _yz_average(self, var):\n        \"\"\"\n        Temperature is uniform and heat source terms are zero, so the average\n        returns the input variable.\n        \"\"\"\n        return var",
  "def _x_average(self, var, var_cn, var_cp):\n        \"\"\"\n        Temperature is uniform and heat source terms are zero, so the average\n        returns the input variable.\n        \"\"\"\n        return var",
  "class Full(BaseModel):\n    \"\"\"Submodel for the full model of pressure-driven convection\n\n    Parameters\n    ----------\n    param : parameter class\n        The parameters to use for this submodel\n\n\n    **Extends:** :class:`pybamm.convection.BaseModel`\n    \"\"\"\n\n    def __init__(self, param):\n        super().__init__(param)\n\n    def get_fundamental_variables(self):\n\n        p = pybamm.standard_variables.pressure\n\n        v_mass = -pybamm.grad(p)\n        v_box = v_mass\n\n        variables = self._get_standard_pressure_variables(p)\n        variables.update(self._get_standard_velocity_variables(v_box))\n\n        return variables\n\n    def get_coupled_variables(self, variables):\n\n        _, dVbox_dz = self._separator_velocity(variables)\n\n        variables.update(self._get_standard_vertical_velocity_variables(dVbox_dz))\n\n        return variables\n\n    def set_algebraic(self, variables):\n        p = variables[\"Electrolyte pressure\"]\n        j = variables[\"Interfacial current density\"]\n        v_box = variables[\"Volume-averaged velocity\"]\n        dVbox_dz = variables[\"Vertical volume-averaged acceleration\"]\n\n        self.algebraic = {p: pybamm.div(v_box) + dVbox_dz - self.param.beta * j}\n\n    def set_boundary_conditions(self, variables):\n        p = variables[\"Electrolyte pressure\"]\n        self.boundary_conditions = {\n            p: {\n                \"left\": (pybamm.Scalar(0), \"Dirichlet\"),\n                \"right\": (pybamm.Scalar(0), \"Neumann\"),\n            }\n        }\n\n    def set_initial_conditions(self, variables):\n        p = variables[\"Electrolyte pressure\"]\n        self.initial_conditions = {p: pybamm.Scalar(0)}",
  "def __init__(self, param):\n        super().__init__(param)",
  "def get_fundamental_variables(self):\n\n        p = pybamm.standard_variables.pressure\n\n        v_mass = -pybamm.grad(p)\n        v_box = v_mass\n\n        variables = self._get_standard_pressure_variables(p)\n        variables.update(self._get_standard_velocity_variables(v_box))\n\n        return variables",
  "def get_coupled_variables(self, variables):\n\n        _, dVbox_dz = self._separator_velocity(variables)\n\n        variables.update(self._get_standard_vertical_velocity_variables(dVbox_dz))\n\n        return variables",
  "def set_algebraic(self, variables):\n        p = variables[\"Electrolyte pressure\"]\n        j = variables[\"Interfacial current density\"]\n        v_box = variables[\"Volume-averaged velocity\"]\n        dVbox_dz = variables[\"Vertical volume-averaged acceleration\"]\n\n        self.algebraic = {p: pybamm.div(v_box) + dVbox_dz - self.param.beta * j}",
  "def set_boundary_conditions(self, variables):\n        p = variables[\"Electrolyte pressure\"]\n        self.boundary_conditions = {\n            p: {\n                \"left\": (pybamm.Scalar(0), \"Dirichlet\"),\n                \"right\": (pybamm.Scalar(0), \"Neumann\"),\n            }\n        }",
  "def set_initial_conditions(self, variables):\n        p = variables[\"Electrolyte pressure\"]\n        self.initial_conditions = {p: pybamm.Scalar(0)}",
  "class NoConvection(BaseModel):\n    \"\"\"A submodel for case where there is no convection.\n\n    Parameters\n    ----------\n    param : parameter class\n        The parameters to use for this submodel\n\n\n    **Extends:** :class:`pybamm.convection.BaseModel`\n    \"\"\"\n\n    def __init__(self, param):\n        super().__init__(param)\n\n    def get_fundamental_variables(self):\n\n        v_box = pybamm.FullBroadcast(\n            pybamm.Scalar(0),\n            [\"negative electrode\", \"separator\", \"positive electrode\"],\n            \"current collector\",\n        )\n        variables = self._get_standard_velocity_variables(v_box)\n\n        p = pybamm.FullBroadcast(\n            pybamm.Scalar(0),\n            [\"negative electrode\", \"separator\", \"positive electrode\"],\n            \"current collector\",\n        )\n        variables.update(self._get_standard_pressure_variables(p))\n\n        return variables",
  "def __init__(self, param):\n        super().__init__(param)",
  "def get_fundamental_variables(self):\n\n        v_box = pybamm.FullBroadcast(\n            pybamm.Scalar(0),\n            [\"negative electrode\", \"separator\", \"positive electrode\"],\n            \"current collector\",\n        )\n        variables = self._get_standard_velocity_variables(v_box)\n\n        p = pybamm.FullBroadcast(\n            pybamm.Scalar(0),\n            [\"negative electrode\", \"separator\", \"positive electrode\"],\n            \"current collector\",\n        )\n        variables.update(self._get_standard_pressure_variables(p))\n\n        return variables",
  "class LeadingOrder(BaseModel):\n    \"\"\"A submodel for the leading-order approximation of pressure-driven convection\n\n    Parameters\n    ----------\n    param : parameter class\n        The parameters to use for this submodel\n\n\n    **Extends:** :class:`pybamm.convection.BaseModel`\n    \"\"\"\n\n    def __init__(self, param):\n        super().__init__(param)\n\n    def get_coupled_variables(self, variables):\n\n        param = self.param\n        x_n = pybamm.standard_spatial_vars.x_n\n        x_p = pybamm.standard_spatial_vars.x_p\n\n        j_n_av = variables[\"X-averaged negative electrode interfacial current density\"]\n        j_p_av = variables[\"X-averaged positive electrode interfacial current density\"]\n\n        # Volume-averaged velocity\n        v_box_n = param.beta_n * pybamm.outer(j_n_av, x_n)\n        v_box_p = param.beta_p * pybamm.outer(j_p_av, x_p - 1)\n\n        v_box_s, dVbox_dz = self._separator_velocity(variables)\n        v_box = pybamm.Concatenation(v_box_n, v_box_s, v_box_p)\n\n        variables.update(self._get_standard_velocity_variables(v_box))\n        variables.update(self._get_standard_vertical_velocity_variables(dVbox_dz))\n\n        return variables",
  "def __init__(self, param):\n        super().__init__(param)",
  "def get_coupled_variables(self, variables):\n\n        param = self.param\n        x_n = pybamm.standard_spatial_vars.x_n\n        x_p = pybamm.standard_spatial_vars.x_p\n\n        j_n_av = variables[\"X-averaged negative electrode interfacial current density\"]\n        j_p_av = variables[\"X-averaged positive electrode interfacial current density\"]\n\n        # Volume-averaged velocity\n        v_box_n = param.beta_n * pybamm.outer(j_n_av, x_n)\n        v_box_p = param.beta_p * pybamm.outer(j_p_av, x_p - 1)\n\n        v_box_s, dVbox_dz = self._separator_velocity(variables)\n        v_box = pybamm.Concatenation(v_box_n, v_box_s, v_box_p)\n\n        variables.update(self._get_standard_velocity_variables(v_box))\n        variables.update(self._get_standard_vertical_velocity_variables(dVbox_dz))\n\n        return variables",
  "class Composite(BaseModel):\n    \"\"\"Class for composite pressure-driven convection\n\n    Parameters\n    ----------\n    param : parameter class\n        The parameters to use for this submodel\n\n    *Extends:* :class:`BaseModel`\n    \"\"\"\n\n    def __init__(self, param):\n        super().__init__(param)\n\n    def get_coupled_variables(self, variables):\n        param = self.param\n        x_n = pybamm.standard_spatial_vars.x_n\n        x_p = pybamm.standard_spatial_vars.x_p\n        # j_n = variables[\"Negative electrode interfacial current density\"]\n        # j_p = variables[\"Positive electrode interfacial current density\"]\n\n        # Volume-averaged velocity\n        # v_box_n = param.beta_n * pybamm.IndefiniteIntegral(j_n, x_n)\n        # # Shift v_box_p to be equal to 0 at x_p = 1\n        # v_box_p = param.beta_p * (\n        #     pybamm.IndefiniteIntegral(j_p, x_p) - pybamm.Integral(j_p, x_p)\n        # )\n        j_n_av = variables[\"X-averaged negative electrode interfacial current density\"]\n        j_p_av = variables[\"X-averaged positive electrode interfacial current density\"]\n\n        # Volume-averaged velocity\n        v_box_n = param.beta_n * pybamm.outer(j_n_av, x_n)\n        v_box_p = param.beta_p * pybamm.outer(j_p_av, x_p - 1)\n\n        v_box_s, dVbox_dz = self._separator_velocity(variables)\n        v_box = pybamm.Concatenation(v_box_n, v_box_s, v_box_p)\n\n        variables.update(self._get_standard_velocity_variables(v_box))\n        variables.update(self._get_standard_vertical_velocity_variables(dVbox_dz))\n\n        return variables",
  "def __init__(self, param):\n        super().__init__(param)",
  "def get_coupled_variables(self, variables):\n        param = self.param\n        x_n = pybamm.standard_spatial_vars.x_n\n        x_p = pybamm.standard_spatial_vars.x_p\n        # j_n = variables[\"Negative electrode interfacial current density\"]\n        # j_p = variables[\"Positive electrode interfacial current density\"]\n\n        # Volume-averaged velocity\n        # v_box_n = param.beta_n * pybamm.IndefiniteIntegral(j_n, x_n)\n        # # Shift v_box_p to be equal to 0 at x_p = 1\n        # v_box_p = param.beta_p * (\n        #     pybamm.IndefiniteIntegral(j_p, x_p) - pybamm.Integral(j_p, x_p)\n        # )\n        j_n_av = variables[\"X-averaged negative electrode interfacial current density\"]\n        j_p_av = variables[\"X-averaged positive electrode interfacial current density\"]\n\n        # Volume-averaged velocity\n        v_box_n = param.beta_n * pybamm.outer(j_n_av, x_n)\n        v_box_p = param.beta_p * pybamm.outer(j_p_av, x_p - 1)\n\n        v_box_s, dVbox_dz = self._separator_velocity(variables)\n        v_box = pybamm.Concatenation(v_box_n, v_box_s, v_box_p)\n\n        variables.update(self._get_standard_velocity_variables(v_box))\n        variables.update(self._get_standard_vertical_velocity_variables(dVbox_dz))\n\n        return variables",
  "class BaseModel(pybamm.BaseSubModel):\n    \"\"\"Base class for convection submodels.\n\n    Parameters\n    ----------\n    param : parameter class\n        The parameters to use for this submodel\n\n\n    **Extends:** :class:`pybamm.BaseSubModel`\n    \"\"\"\n\n    def __init__(self, param):\n        super().__init__(param)\n\n    def _get_standard_velocity_variables(self, v_box):\n        \"\"\"\n        A private function to obtain the standard variables which\n        can be derived from the fluid velocity.\n\n        Parameters\n        ----------\n        v_box : :class:`pybamm.Symbol`\n            The volume-averaged fluid velocity\n\n        Returns\n        -------\n        variables : dict\n            The variables which can be derived from the volume-averaged\n            velocity.\n        \"\"\"\n\n        vel_scale = self.param.velocity_scale\n\n        # add more to this (x-averages etc)\n        variables = {\n            \"Volume-averaged velocity\": v_box,\n            \"Volume-averaged velocity [m.s-1]\": vel_scale * v_box,\n        }\n\n        return variables\n\n    def _get_standard_pressure_variables(self, p):\n        \"\"\"\n        A private function to obtain the standard variables which\n        can be derived from the pressure in the fluid.\n\n        Parameters\n        ----------\n        p : :class:`pybamm.Symbol`\n            The fluid pressure\n\n        Returns\n        -------\n        variables : dict\n            The variables which can be derived from the pressure.\n        \"\"\"\n\n        # add more to this (x-averages etc)\n        variables = {\"Electrolyte pressure\": p}\n\n        return variables\n\n    def _get_standard_vertical_velocity_variables(self, dVbox_dz):\n        \"\"\"\n        A private function to obtain the standard variables which\n        can be derived from the vertical velocity of the fluid.\n\n        Parameters\n        ----------\n        dV_box_dz : :class:`pybamm.Symbol`\n            The vertical velocity of the fluid\n\n        Returns\n        -------\n        variables : dict\n            The variables which can be derived from the vertical velocity.\n        \"\"\"\n        vel_scale = self.param.velocity_scale\n        L_z = self.param.L_z\n\n        variables = {\n            \"Vertical volume-averaged acceleration\": dVbox_dz,\n            \"Vertical volume-averaged acceleration [m.s-2]\": vel_scale / L_z * dVbox_dz,\n        }\n\n        return variables\n\n    def _separator_velocity(self, variables):\n        \"\"\"\n        A private method to calculate x- and z-components of velocity in the separator\n\n        Parameters\n        ----------\n        variables : dict\n            Dictionary of variables in the whole model.\n\n        Returns\n        -------\n        v_box_s : :class:`pybamm.Symbol`\n            The x-component of velocity in the separator\n        dVbox_dz : :class:`pybamm.Symbol`\n            The z-component of velocity in the separator\n        \"\"\"\n        # Set up\n        param = self.param\n        l_n = pybamm.geometric_parameters.l_n\n        l_s = pybamm.geometric_parameters.l_s\n        x_s = pybamm.standard_spatial_vars.x_s\n\n        # Difference in negative and positive electrode velocities determines the\n        # velocity in the separator\n        i_boundary_cc = variables[\"Current collector current density\"]\n        v_box_n_right = param.beta_n * i_boundary_cc\n        v_box_p_left = param.beta_p * i_boundary_cc\n        d_vbox_s__dx = (v_box_p_left - v_box_n_right) / l_s\n\n        # Simple formula for velocity in the separator\n        dVbox_dz = pybamm.Concatenation(\n            pybamm.FullBroadcast(\n                0,\n                \"negative electrode\",\n                auxiliary_domains={\"secondary\": \"current collector\"},\n            ),\n            pybamm.PrimaryBroadcast(-d_vbox_s__dx, \"separator\"),\n            pybamm.FullBroadcast(\n                0,\n                \"positive electrode\",\n                auxiliary_domains={\"secondary\": \"current collector\"},\n            ),\n        )\n        v_box_s = pybamm.outer(d_vbox_s__dx, (x_s - l_n)) + pybamm.PrimaryBroadcast(\n            v_box_n_right, \"separator\"\n        )\n\n        return v_box_s, dVbox_dz",
  "def __init__(self, param):\n        super().__init__(param)",
  "def _get_standard_velocity_variables(self, v_box):\n        \"\"\"\n        A private function to obtain the standard variables which\n        can be derived from the fluid velocity.\n\n        Parameters\n        ----------\n        v_box : :class:`pybamm.Symbol`\n            The volume-averaged fluid velocity\n\n        Returns\n        -------\n        variables : dict\n            The variables which can be derived from the volume-averaged\n            velocity.\n        \"\"\"\n\n        vel_scale = self.param.velocity_scale\n\n        # add more to this (x-averages etc)\n        variables = {\n            \"Volume-averaged velocity\": v_box,\n            \"Volume-averaged velocity [m.s-1]\": vel_scale * v_box,\n        }\n\n        return variables",
  "def _get_standard_pressure_variables(self, p):\n        \"\"\"\n        A private function to obtain the standard variables which\n        can be derived from the pressure in the fluid.\n\n        Parameters\n        ----------\n        p : :class:`pybamm.Symbol`\n            The fluid pressure\n\n        Returns\n        -------\n        variables : dict\n            The variables which can be derived from the pressure.\n        \"\"\"\n\n        # add more to this (x-averages etc)\n        variables = {\"Electrolyte pressure\": p}\n\n        return variables",
  "def _get_standard_vertical_velocity_variables(self, dVbox_dz):\n        \"\"\"\n        A private function to obtain the standard variables which\n        can be derived from the vertical velocity of the fluid.\n\n        Parameters\n        ----------\n        dV_box_dz : :class:`pybamm.Symbol`\n            The vertical velocity of the fluid\n\n        Returns\n        -------\n        variables : dict\n            The variables which can be derived from the vertical velocity.\n        \"\"\"\n        vel_scale = self.param.velocity_scale\n        L_z = self.param.L_z\n\n        variables = {\n            \"Vertical volume-averaged acceleration\": dVbox_dz,\n            \"Vertical volume-averaged acceleration [m.s-2]\": vel_scale / L_z * dVbox_dz,\n        }\n\n        return variables",
  "def _separator_velocity(self, variables):\n        \"\"\"\n        A private method to calculate x- and z-components of velocity in the separator\n\n        Parameters\n        ----------\n        variables : dict\n            Dictionary of variables in the whole model.\n\n        Returns\n        -------\n        v_box_s : :class:`pybamm.Symbol`\n            The x-component of velocity in the separator\n        dVbox_dz : :class:`pybamm.Symbol`\n            The z-component of velocity in the separator\n        \"\"\"\n        # Set up\n        param = self.param\n        l_n = pybamm.geometric_parameters.l_n\n        l_s = pybamm.geometric_parameters.l_s\n        x_s = pybamm.standard_spatial_vars.x_s\n\n        # Difference in negative and positive electrode velocities determines the\n        # velocity in the separator\n        i_boundary_cc = variables[\"Current collector current density\"]\n        v_box_n_right = param.beta_n * i_boundary_cc\n        v_box_p_left = param.beta_p * i_boundary_cc\n        d_vbox_s__dx = (v_box_p_left - v_box_n_right) / l_s\n\n        # Simple formula for velocity in the separator\n        dVbox_dz = pybamm.Concatenation(\n            pybamm.FullBroadcast(\n                0,\n                \"negative electrode\",\n                auxiliary_domains={\"secondary\": \"current collector\"},\n            ),\n            pybamm.PrimaryBroadcast(-d_vbox_s__dx, \"separator\"),\n            pybamm.FullBroadcast(\n                0,\n                \"positive electrode\",\n                auxiliary_domains={\"secondary\": \"current collector\"},\n            ),\n        )\n        v_box_s = pybamm.outer(d_vbox_s__dx, (x_s - l_n)) + pybamm.PrimaryBroadcast(\n            v_box_n_right, \"separator\"\n        )\n\n        return v_box_s, dVbox_dz",
  "class BasePotentialPair(BaseModel):\n    \"\"\"A submodel for Ohm's law plus conservation of current in the current collectors.\n\n    Parameters\n    ----------\n    param : parameter class\n        The parameters to use for this submodel\n\n\n    **Extends:** :class:`pybamm.current_collector.BaseModel`\n    \"\"\"\n\n    def __init__(self, param):\n        super().__init__(param)\n\n    def get_fundamental_variables(self):\n\n        phi_s_cn = pybamm.standard_variables.phi_s_cn\n\n        variables = self._get_standard_negative_potential_variables(phi_s_cn)\n\n        # TODO: grad not implemented for 2D yet\n        i_cc = pybamm.Scalar(0)\n        i_boundary_cc = pybamm.standard_variables.i_boundary_cc\n\n        variables.update(self._get_standard_current_variables(i_cc, i_boundary_cc))\n        # Hack to get the leading-order current collector current density\n        # Note that this should be different from the actual (composite) current\n        # collector current density for 2+1D models, but not sure how to implement this\n        # using current structure of lithium-ion models\n        variables[\"Leading-order current collector current density\"] = variables[\n            \"Current collector current density\"\n        ]\n\n        return variables\n\n    def set_algebraic(self, variables):\n\n        param = self.param\n\n        phi_s_cn = variables[\"Negative current collector potential\"]\n        phi_s_cp = variables[\"Positive current collector potential\"]\n        i_boundary_cc = variables[\"Current collector current density\"]\n\n        self.algebraic = {\n            phi_s_cn: (param.sigma_cn * param.delta ** 2 * param.l_cn)\n            * pybamm.laplacian(phi_s_cn)\n            - pybamm.source(i_boundary_cc, phi_s_cn),\n            i_boundary_cc: (param.sigma_cp * param.delta ** 2 * param.l_cp)\n            * pybamm.laplacian(phi_s_cp)\n            + pybamm.source(i_boundary_cc, phi_s_cp),\n        }\n\n    def set_initial_conditions(self, variables):\n\n        param = self.param\n        applied_current = param.current_with_time\n        cc_area = self._get_effective_current_collector_area()\n        phi_s_cn = variables[\"Negative current collector potential\"]\n        i_boundary_cc = variables[\"Current collector current density\"]\n\n        self.initial_conditions = {\n            phi_s_cn: pybamm.Scalar(0),\n            i_boundary_cc: applied_current / cc_area,\n        }",
  "class PotentialPair1plus1D(BasePotentialPair):\n    \"Base class for a 1+1D potential pair model\"\n\n    def __init__(self, param):\n        super().__init__(param)\n\n    def set_boundary_conditions(self, variables):\n\n        phi_s_cn = variables[\"Negative current collector potential\"]\n        phi_s_cp = variables[\"Positive current collector potential\"]\n\n        param = self.param\n        applied_current = param.current_with_time\n        cc_area = self._get_effective_current_collector_area()\n\n        # cc_area appears here due to choice of non-dimensionalisation\n        pos_tab_bc = (\n            -applied_current\n            * cc_area\n            / (param.sigma_cp * param.delta ** 2 * param.l_cp)\n        )\n\n        # Boundary condition needs to be on the variables that go into the Laplacian,\n        # even though phi_s_cp isn't a pybamm.Variable object\n        self.boundary_conditions = {\n            phi_s_cn: {\n                \"negative tab\": (pybamm.Scalar(0), \"Dirichlet\"),\n                \"no tab\": (pybamm.Scalar(0), \"Neumann\"),\n            },\n            phi_s_cp: {\n                \"no tab\": (pybamm.Scalar(0), \"Neumann\"),\n                \"positive tab\": (pos_tab_bc, \"Neumann\"),\n            },\n        }\n\n    def _get_effective_current_collector_area(self):\n        \"In the 1+1D models the current collector effectively has surface area l_z\"\n        return self.param.l_z",
  "class PotentialPair2plus1D(BasePotentialPair):\n    \"Base class for a 2+1D potential pair model\"\n\n    def __init__(self, param):\n        super().__init__(param)\n\n    def set_boundary_conditions(self, variables):\n\n        phi_s_cn = variables[\"Negative current collector potential\"]\n        phi_s_cp = variables[\"Positive current collector potential\"]\n\n        param = self.param\n        applied_current = param.current_with_time\n        cc_area = self._get_effective_current_collector_area()\n\n        # Note: we divide by the *numerical* tab area so that the correct total\n        # current is applied. That is, numerically integrating the current density\n        # around the boundary gives the applied current exactly.\n\n        positive_tab_area = pybamm.BoundaryIntegral(\n            pybamm.PrimaryBroadcast(param.l_cp, \"current collector\"),\n            region=\"positive tab\",\n        )\n\n        # cc_area appears here due to choice of non-dimensionalisation\n        pos_tab_bc = (\n            -applied_current\n            * cc_area\n            / (param.sigma_cp * param.delta ** 2 * positive_tab_area)\n        )\n\n        # Boundary condition needs to be on the variables that go into the Laplacian,\n        # even though phi_s_cp isn't a pybamm.Variable object\n        # In the 2+1D model, the equations for the current collector potentials\n        # are solved on a 2D domain and the regions \"negative tab\" and \"positive tab\"\n        # are the projections of the tabs onto this 2D domain.\n        # In the 2D formulation it is assumed that no flux boundary conditions\n        # are applied everywhere apart from the tabs.\n        # The reference potential is taken to be zero on the negative tab,\n        # giving the zero Dirichlet condition on phi_s_cn. Elsewhere, the boundary\n        # is insulated, giving no flux conditions on phi_s_cn. This is automatically\n        # applied everywhere, apart from the region corresponding to the projection\n        # of the positive tab, so we need to explititly apply a zero-flux boundary\n        # condition on the region \"positive tab\" for phi_s_cn.\n        # A current is drawn from the positive tab, giving the non-zero Neumann\n        # boundary condition on phi_s_cp at \"positive tab\". Elsewhere, the boundary is\n        # insulated, so, as with phi_s_cn, we need to explicitly give the zero-flux\n        # condition on the region \"negative tab\" for phi_s_cp.\n        self.boundary_conditions = {\n            phi_s_cn: {\n                \"negative tab\": (pybamm.Scalar(0), \"Dirichlet\"),\n                \"positive tab\": (pybamm.Scalar(0), \"Neumann\"),\n            },\n            phi_s_cp: {\n                \"negative tab\": (pybamm.Scalar(0), \"Neumann\"),\n                \"positive tab\": (pos_tab_bc, \"Neumann\"),\n            },\n        }\n\n    def _get_effective_current_collector_area(self):\n        \"Return the area of the current collector\"\n        return self.param.l_y * self.param.l_z",
  "def __init__(self, param):\n        super().__init__(param)",
  "def get_fundamental_variables(self):\n\n        phi_s_cn = pybamm.standard_variables.phi_s_cn\n\n        variables = self._get_standard_negative_potential_variables(phi_s_cn)\n\n        # TODO: grad not implemented for 2D yet\n        i_cc = pybamm.Scalar(0)\n        i_boundary_cc = pybamm.standard_variables.i_boundary_cc\n\n        variables.update(self._get_standard_current_variables(i_cc, i_boundary_cc))\n        # Hack to get the leading-order current collector current density\n        # Note that this should be different from the actual (composite) current\n        # collector current density for 2+1D models, but not sure how to implement this\n        # using current structure of lithium-ion models\n        variables[\"Leading-order current collector current density\"] = variables[\n            \"Current collector current density\"\n        ]\n\n        return variables",
  "def set_algebraic(self, variables):\n\n        param = self.param\n\n        phi_s_cn = variables[\"Negative current collector potential\"]\n        phi_s_cp = variables[\"Positive current collector potential\"]\n        i_boundary_cc = variables[\"Current collector current density\"]\n\n        self.algebraic = {\n            phi_s_cn: (param.sigma_cn * param.delta ** 2 * param.l_cn)\n            * pybamm.laplacian(phi_s_cn)\n            - pybamm.source(i_boundary_cc, phi_s_cn),\n            i_boundary_cc: (param.sigma_cp * param.delta ** 2 * param.l_cp)\n            * pybamm.laplacian(phi_s_cp)\n            + pybamm.source(i_boundary_cc, phi_s_cp),\n        }",
  "def set_initial_conditions(self, variables):\n\n        param = self.param\n        applied_current = param.current_with_time\n        cc_area = self._get_effective_current_collector_area()\n        phi_s_cn = variables[\"Negative current collector potential\"]\n        i_boundary_cc = variables[\"Current collector current density\"]\n\n        self.initial_conditions = {\n            phi_s_cn: pybamm.Scalar(0),\n            i_boundary_cc: applied_current / cc_area,\n        }",
  "def __init__(self, param):\n        super().__init__(param)",
  "def set_boundary_conditions(self, variables):\n\n        phi_s_cn = variables[\"Negative current collector potential\"]\n        phi_s_cp = variables[\"Positive current collector potential\"]\n\n        param = self.param\n        applied_current = param.current_with_time\n        cc_area = self._get_effective_current_collector_area()\n\n        # cc_area appears here due to choice of non-dimensionalisation\n        pos_tab_bc = (\n            -applied_current\n            * cc_area\n            / (param.sigma_cp * param.delta ** 2 * param.l_cp)\n        )\n\n        # Boundary condition needs to be on the variables that go into the Laplacian,\n        # even though phi_s_cp isn't a pybamm.Variable object\n        self.boundary_conditions = {\n            phi_s_cn: {\n                \"negative tab\": (pybamm.Scalar(0), \"Dirichlet\"),\n                \"no tab\": (pybamm.Scalar(0), \"Neumann\"),\n            },\n            phi_s_cp: {\n                \"no tab\": (pybamm.Scalar(0), \"Neumann\"),\n                \"positive tab\": (pos_tab_bc, \"Neumann\"),\n            },\n        }",
  "def _get_effective_current_collector_area(self):\n        \"In the 1+1D models the current collector effectively has surface area l_z\"\n        return self.param.l_z",
  "def __init__(self, param):\n        super().__init__(param)",
  "def set_boundary_conditions(self, variables):\n\n        phi_s_cn = variables[\"Negative current collector potential\"]\n        phi_s_cp = variables[\"Positive current collector potential\"]\n\n        param = self.param\n        applied_current = param.current_with_time\n        cc_area = self._get_effective_current_collector_area()\n\n        # Note: we divide by the *numerical* tab area so that the correct total\n        # current is applied. That is, numerically integrating the current density\n        # around the boundary gives the applied current exactly.\n\n        positive_tab_area = pybamm.BoundaryIntegral(\n            pybamm.PrimaryBroadcast(param.l_cp, \"current collector\"),\n            region=\"positive tab\",\n        )\n\n        # cc_area appears here due to choice of non-dimensionalisation\n        pos_tab_bc = (\n            -applied_current\n            * cc_area\n            / (param.sigma_cp * param.delta ** 2 * positive_tab_area)\n        )\n\n        # Boundary condition needs to be on the variables that go into the Laplacian,\n        # even though phi_s_cp isn't a pybamm.Variable object\n        # In the 2+1D model, the equations for the current collector potentials\n        # are solved on a 2D domain and the regions \"negative tab\" and \"positive tab\"\n        # are the projections of the tabs onto this 2D domain.\n        # In the 2D formulation it is assumed that no flux boundary conditions\n        # are applied everywhere apart from the tabs.\n        # The reference potential is taken to be zero on the negative tab,\n        # giving the zero Dirichlet condition on phi_s_cn. Elsewhere, the boundary\n        # is insulated, giving no flux conditions on phi_s_cn. This is automatically\n        # applied everywhere, apart from the region corresponding to the projection\n        # of the positive tab, so we need to explititly apply a zero-flux boundary\n        # condition on the region \"positive tab\" for phi_s_cn.\n        # A current is drawn from the positive tab, giving the non-zero Neumann\n        # boundary condition on phi_s_cp at \"positive tab\". Elsewhere, the boundary is\n        # insulated, so, as with phi_s_cn, we need to explicitly give the zero-flux\n        # condition on the region \"negative tab\" for phi_s_cp.\n        self.boundary_conditions = {\n            phi_s_cn: {\n                \"negative tab\": (pybamm.Scalar(0), \"Dirichlet\"),\n                \"positive tab\": (pybamm.Scalar(0), \"Neumann\"),\n            },\n            phi_s_cp: {\n                \"negative tab\": (pybamm.Scalar(0), \"Neumann\"),\n                \"positive tab\": (pos_tab_bc, \"Neumann\"),\n            },\n        }",
  "def _get_effective_current_collector_area(self):\n        \"Return the area of the current collector\"\n        return self.param.l_y * self.param.l_z",
  "class EffectiveResistance2D(pybamm.BaseModel):\n    \"\"\"A model which calculates the effective Ohmic resistance of the current\n    collectors in the limit of large electrical conductivity.\n    Note:  This submodel should be solved before a one-dimensional model to calculate\n    and return the effective current collector resistance.\n\n    **Extends:** :class:`pybamm.BaseModel`\n    \"\"\"\n\n    def __init__(self):\n        super().__init__()\n        self.name = \"Effective resistance in current collector model\"\n        self.param = pybamm.standard_parameters_lithium_ion\n\n        # Get useful parameters\n        param = self.param\n        l_cn = param.l_cn\n        l_cp = param.l_cp\n        l_y = param.l_y\n        sigma_cn_dbl_prime = param.sigma_cn_dbl_prime\n        sigma_cp_dbl_prime = param.sigma_cp_dbl_prime\n        alpha_prime = param.alpha_prime\n\n        # Set model variables\n        var = pybamm.standard_spatial_vars\n\n        psi = pybamm.Variable(\n            \"Current collector potential weighted sum\", [\"current collector\"]\n        )\n        W = pybamm.Variable(\n            \"Perturbation to current collector potential difference\",\n            [\"current collector\"],\n        )\n        c_psi = pybamm.Variable(\"Lagrange multiplier for variable `psi`\")\n        c_W = pybamm.Variable(\"Lagrange multiplier for variable `W`\")\n\n        self.variables = {\n            \"Current collector potential weighted sum\": psi,\n            \"Perturbation to current collector potential difference\": W,\n            \"Lagrange multiplier for variable `psi`\": c_psi,\n            \"Lagrange multiplier for variable `W`\": c_W,\n        }\n\n        # Algebraic equations (enforce zero mean constraint through Lagrange multiplier)\n        # 0*LagrangeMultiplier hack otherwise gives KeyError\n        self.algebraic = {\n            psi: pybamm.laplacian(psi)\n            + c_psi * pybamm.DefiniteIntegralVector(psi, vector_type=\"column\"),\n            W: pybamm.laplacian(W)\n            - pybamm.source(1, W)\n            + c_W * pybamm.DefiniteIntegralVector(W, vector_type=\"column\"),\n            c_psi: pybamm.Integral(psi, [var.y, var.z]) + 0 * c_psi,\n            c_W: pybamm.Integral(W, [var.y, var.z]) + 0 * c_W,\n        }\n\n        # Boundary conditons\n        psi_neg_tab_bc = l_cn\n        psi_pos_tab_bc = -l_cp\n        W_neg_tab_bc = l_y / (alpha_prime * sigma_cn_dbl_prime)\n        W_pos_tab_bc = l_y / (alpha_prime * sigma_cp_dbl_prime)\n\n        self.boundary_conditions = {\n            psi: {\n                \"negative tab\": (psi_neg_tab_bc, \"Neumann\"),\n                \"positive tab\": (psi_pos_tab_bc, \"Neumann\"),\n            },\n            W: {\n                \"negative tab\": (W_neg_tab_bc, \"Neumann\"),\n                \"positive tab\": (W_pos_tab_bc, \"Neumann\"),\n            },\n        }\n\n        # \"Initial conditions\" provides initial guess for solver\n        # TODO: better guess than zero?\n        self.initial_conditions = {\n            psi: pybamm.Scalar(0),\n            W: pybamm.Scalar(0),\n            c_psi: pybamm.Scalar(0),\n            c_W: pybamm.Scalar(0),\n        }\n\n        # Define effective current collector resistance\n        psi_neg_tab = pybamm.BoundaryValue(psi, \"negative tab\")\n        psi_pos_tab = pybamm.BoundaryValue(psi, \"positive tab\")\n        W_neg_tab = pybamm.BoundaryValue(W, \"negative tab\")\n        W_pos_tab = pybamm.BoundaryValue(W, \"positive tab\")\n\n        R_cc = (\n            (alpha_prime / l_y)\n            * (\n                sigma_cn_dbl_prime * l_cn * W_pos_tab\n                + sigma_cp_dbl_prime * l_cp * W_neg_tab\n            )\n            - (psi_pos_tab - psi_neg_tab)\n        ) / (sigma_cn_dbl_prime * l_cn + sigma_cp_dbl_prime * l_cp)\n\n        R_cc_dim = R_cc * param.potential_scale / param.I_typ\n\n        self.variables.update(\n            {\n                \"Current collector potential weighted sum (negative tab)\": psi_neg_tab,\n                \"Current collector potential weighted sum (positive tab)\": psi_pos_tab,\n                \"Perturbation to c.c. potential difference (negative tab)\": W_neg_tab,\n                \"Perturbation to c.c. potential difference (positive tab)\": W_pos_tab,\n                \"Effective current collector resistance\": R_cc,\n                \"Effective current collector resistance [Ohm]\": R_cc_dim,\n            }\n        )\n\n    def get_processed_potentials(self, solution, mesh, param_values, V_av, I_av):\n        \"\"\"\n        Calculates the potentials in the current collector given\n        the average voltage and current.\n        Note: This takes in the *processed* V_av and I_av from a 1D simulation\n        representing the average cell behaviour and returns a dictionary of\n        processed potentials.\n        \"\"\"\n        # Get required processed parameters\n        param = self.param\n        l_cn = param_values.evaluate(param.l_cn)\n        l_cp = param_values.evaluate(param.l_cp)\n        l_y = param_values.evaluate(param.l_y)\n        l_z = param_values.evaluate(param.l_z)\n        sigma_cn_prime = param_values.evaluate(param.sigma_cn_prime)\n        sigma_cp_prime = param_values.evaluate(param.sigma_cp_prime)\n        alpha = param_values.evaluate(param.alpha)\n        pot_scale = param_values.evaluate(param.potential_scale)\n        U_ref = param_values.evaluate(param.U_p_ref - param.U_n_ref)\n\n        # Process psi and W, and their (average) values at the negative tab\n        psi = pybamm.ProcessedVariable(\n            self.variables[\"Current collector potential weighted sum\"],\n            solution.t,\n            solution.y,\n            mesh,\n        )\n        W = pybamm.ProcessedVariable(\n            self.variables[\"Perturbation to current collector potential difference\"],\n            solution.t,\n            solution.y,\n            mesh,\n        )\n        psi_neg_tab = self.variables[\n            \"Current collector potential weighted sum (negative tab)\"\n        ].evaluate(y=solution.y[:, 0])[0][0]\n        W_neg_tab = self.variables[\n            \"Perturbation to c.c. potential difference (negative tab)\"\n        ].evaluate(y=solution.y[:, 0])[0][0]\n\n        # Create callable combination of ProcessedVariable objects for potentials\n        def V_cc(t, y, z):\n            return V_av(t) - alpha * I_av(t) * W(y=y, z=z)\n\n        def V_cc_dim(t, y, z):\n            return U_ref + V_cc(t, y, z) * pot_scale\n\n        denominator = sigma_cn_prime * l_cn + sigma_cn_prime * l_cp\n\n        # The method only defines psi up to an arbitrary function of time. This\n        # is fixed by ensuring phi_s_cn = 0 on the negative tab when reconstructing\n        # the potentials\n        def phi_s_cn_tab(t):\n            phi_s_cn_tab = (\n                I_av(t) * l_y * l_z * psi_neg_tab\n                - sigma_cp_prime * l_cp * (V_av(t) - alpha * I_av(t) * W_neg_tab)\n            ) / denominator\n            return phi_s_cn_tab\n\n        def phi_s_cn(t, y, z):\n            phi_s_cn = (\n                I_av(t) * l_y * l_z * psi(y=y, z=z)\n                - sigma_cp_prime * l_cp * V_cc(t, y, z)\n            ) / denominator\n            return phi_s_cn - phi_s_cn_tab(t)\n\n        def phi_s_cn_dim(t, y, z):\n            return phi_s_cn(t, y, z) * pot_scale\n\n        def phi_s_cp(t, y, z):\n            phi_s_cp = (\n                I_av(t) * l_y * l_z * psi(y=y, z=z)\n                + sigma_cn_prime * l_cn * V_cc(t, y, z)\n            ) / denominator\n            return phi_s_cp - phi_s_cn_tab(t)\n\n        def phi_s_cp_dim(t, y, z):\n            return U_ref + phi_s_cp(t, y, z) * pot_scale\n\n        potentials = {\n            \"Negative current collector potential\": phi_s_cn,\n            \"Negative current collector potential [V]\": phi_s_cn_dim,\n            \"Positive current collector potential\": phi_s_cp,\n            \"Positive current collector potential [V]\": phi_s_cp_dim,\n            \"Local current collector potential difference\": V_cc,\n            \"Local current collector potential difference [V]\": V_cc_dim,\n        }\n        return potentials\n\n    @property\n    def default_parameter_values(self):\n        return pybamm.ParameterValues(chemistry=pybamm.parameter_sets.Marquis2019)\n\n    @property\n    def default_geometry(self):\n        return pybamm.Geometry(\"2D current collector\")\n\n    @property\n    def default_var_pts(self):\n        var = pybamm.standard_spatial_vars\n        return {var.y: 32, var.z: 32}\n\n    @property\n    def default_submesh_types(self):\n        return {\n            \"current collector\": pybamm.MeshGenerator(pybamm.ScikitUniform2DSubMesh)\n        }\n\n    @property\n    def default_spatial_methods(self):\n        return {\"current collector\": pybamm.ScikitFiniteElement}\n\n    @property\n    def default_solver(self):\n        return pybamm.AlgebraicSolver()",
  "def __init__(self):\n        super().__init__()\n        self.name = \"Effective resistance in current collector model\"\n        self.param = pybamm.standard_parameters_lithium_ion\n\n        # Get useful parameters\n        param = self.param\n        l_cn = param.l_cn\n        l_cp = param.l_cp\n        l_y = param.l_y\n        sigma_cn_dbl_prime = param.sigma_cn_dbl_prime\n        sigma_cp_dbl_prime = param.sigma_cp_dbl_prime\n        alpha_prime = param.alpha_prime\n\n        # Set model variables\n        var = pybamm.standard_spatial_vars\n\n        psi = pybamm.Variable(\n            \"Current collector potential weighted sum\", [\"current collector\"]\n        )\n        W = pybamm.Variable(\n            \"Perturbation to current collector potential difference\",\n            [\"current collector\"],\n        )\n        c_psi = pybamm.Variable(\"Lagrange multiplier for variable `psi`\")\n        c_W = pybamm.Variable(\"Lagrange multiplier for variable `W`\")\n\n        self.variables = {\n            \"Current collector potential weighted sum\": psi,\n            \"Perturbation to current collector potential difference\": W,\n            \"Lagrange multiplier for variable `psi`\": c_psi,\n            \"Lagrange multiplier for variable `W`\": c_W,\n        }\n\n        # Algebraic equations (enforce zero mean constraint through Lagrange multiplier)\n        # 0*LagrangeMultiplier hack otherwise gives KeyError\n        self.algebraic = {\n            psi: pybamm.laplacian(psi)\n            + c_psi * pybamm.DefiniteIntegralVector(psi, vector_type=\"column\"),\n            W: pybamm.laplacian(W)\n            - pybamm.source(1, W)\n            + c_W * pybamm.DefiniteIntegralVector(W, vector_type=\"column\"),\n            c_psi: pybamm.Integral(psi, [var.y, var.z]) + 0 * c_psi,\n            c_W: pybamm.Integral(W, [var.y, var.z]) + 0 * c_W,\n        }\n\n        # Boundary conditons\n        psi_neg_tab_bc = l_cn\n        psi_pos_tab_bc = -l_cp\n        W_neg_tab_bc = l_y / (alpha_prime * sigma_cn_dbl_prime)\n        W_pos_tab_bc = l_y / (alpha_prime * sigma_cp_dbl_prime)\n\n        self.boundary_conditions = {\n            psi: {\n                \"negative tab\": (psi_neg_tab_bc, \"Neumann\"),\n                \"positive tab\": (psi_pos_tab_bc, \"Neumann\"),\n            },\n            W: {\n                \"negative tab\": (W_neg_tab_bc, \"Neumann\"),\n                \"positive tab\": (W_pos_tab_bc, \"Neumann\"),\n            },\n        }\n\n        # \"Initial conditions\" provides initial guess for solver\n        # TODO: better guess than zero?\n        self.initial_conditions = {\n            psi: pybamm.Scalar(0),\n            W: pybamm.Scalar(0),\n            c_psi: pybamm.Scalar(0),\n            c_W: pybamm.Scalar(0),\n        }\n\n        # Define effective current collector resistance\n        psi_neg_tab = pybamm.BoundaryValue(psi, \"negative tab\")\n        psi_pos_tab = pybamm.BoundaryValue(psi, \"positive tab\")\n        W_neg_tab = pybamm.BoundaryValue(W, \"negative tab\")\n        W_pos_tab = pybamm.BoundaryValue(W, \"positive tab\")\n\n        R_cc = (\n            (alpha_prime / l_y)\n            * (\n                sigma_cn_dbl_prime * l_cn * W_pos_tab\n                + sigma_cp_dbl_prime * l_cp * W_neg_tab\n            )\n            - (psi_pos_tab - psi_neg_tab)\n        ) / (sigma_cn_dbl_prime * l_cn + sigma_cp_dbl_prime * l_cp)\n\n        R_cc_dim = R_cc * param.potential_scale / param.I_typ\n\n        self.variables.update(\n            {\n                \"Current collector potential weighted sum (negative tab)\": psi_neg_tab,\n                \"Current collector potential weighted sum (positive tab)\": psi_pos_tab,\n                \"Perturbation to c.c. potential difference (negative tab)\": W_neg_tab,\n                \"Perturbation to c.c. potential difference (positive tab)\": W_pos_tab,\n                \"Effective current collector resistance\": R_cc,\n                \"Effective current collector resistance [Ohm]\": R_cc_dim,\n            }\n        )",
  "def get_processed_potentials(self, solution, mesh, param_values, V_av, I_av):\n        \"\"\"\n        Calculates the potentials in the current collector given\n        the average voltage and current.\n        Note: This takes in the *processed* V_av and I_av from a 1D simulation\n        representing the average cell behaviour and returns a dictionary of\n        processed potentials.\n        \"\"\"\n        # Get required processed parameters\n        param = self.param\n        l_cn = param_values.evaluate(param.l_cn)\n        l_cp = param_values.evaluate(param.l_cp)\n        l_y = param_values.evaluate(param.l_y)\n        l_z = param_values.evaluate(param.l_z)\n        sigma_cn_prime = param_values.evaluate(param.sigma_cn_prime)\n        sigma_cp_prime = param_values.evaluate(param.sigma_cp_prime)\n        alpha = param_values.evaluate(param.alpha)\n        pot_scale = param_values.evaluate(param.potential_scale)\n        U_ref = param_values.evaluate(param.U_p_ref - param.U_n_ref)\n\n        # Process psi and W, and their (average) values at the negative tab\n        psi = pybamm.ProcessedVariable(\n            self.variables[\"Current collector potential weighted sum\"],\n            solution.t,\n            solution.y,\n            mesh,\n        )\n        W = pybamm.ProcessedVariable(\n            self.variables[\"Perturbation to current collector potential difference\"],\n            solution.t,\n            solution.y,\n            mesh,\n        )\n        psi_neg_tab = self.variables[\n            \"Current collector potential weighted sum (negative tab)\"\n        ].evaluate(y=solution.y[:, 0])[0][0]\n        W_neg_tab = self.variables[\n            \"Perturbation to c.c. potential difference (negative tab)\"\n        ].evaluate(y=solution.y[:, 0])[0][0]\n\n        # Create callable combination of ProcessedVariable objects for potentials\n        def V_cc(t, y, z):\n            return V_av(t) - alpha * I_av(t) * W(y=y, z=z)\n\n        def V_cc_dim(t, y, z):\n            return U_ref + V_cc(t, y, z) * pot_scale\n\n        denominator = sigma_cn_prime * l_cn + sigma_cn_prime * l_cp\n\n        # The method only defines psi up to an arbitrary function of time. This\n        # is fixed by ensuring phi_s_cn = 0 on the negative tab when reconstructing\n        # the potentials\n        def phi_s_cn_tab(t):\n            phi_s_cn_tab = (\n                I_av(t) * l_y * l_z * psi_neg_tab\n                - sigma_cp_prime * l_cp * (V_av(t) - alpha * I_av(t) * W_neg_tab)\n            ) / denominator\n            return phi_s_cn_tab\n\n        def phi_s_cn(t, y, z):\n            phi_s_cn = (\n                I_av(t) * l_y * l_z * psi(y=y, z=z)\n                - sigma_cp_prime * l_cp * V_cc(t, y, z)\n            ) / denominator\n            return phi_s_cn - phi_s_cn_tab(t)\n\n        def phi_s_cn_dim(t, y, z):\n            return phi_s_cn(t, y, z) * pot_scale\n\n        def phi_s_cp(t, y, z):\n            phi_s_cp = (\n                I_av(t) * l_y * l_z * psi(y=y, z=z)\n                + sigma_cn_prime * l_cn * V_cc(t, y, z)\n            ) / denominator\n            return phi_s_cp - phi_s_cn_tab(t)\n\n        def phi_s_cp_dim(t, y, z):\n            return U_ref + phi_s_cp(t, y, z) * pot_scale\n\n        potentials = {\n            \"Negative current collector potential\": phi_s_cn,\n            \"Negative current collector potential [V]\": phi_s_cn_dim,\n            \"Positive current collector potential\": phi_s_cp,\n            \"Positive current collector potential [V]\": phi_s_cp_dim,\n            \"Local current collector potential difference\": V_cc,\n            \"Local current collector potential difference [V]\": V_cc_dim,\n        }\n        return potentials",
  "def default_parameter_values(self):\n        return pybamm.ParameterValues(chemistry=pybamm.parameter_sets.Marquis2019)",
  "def default_geometry(self):\n        return pybamm.Geometry(\"2D current collector\")",
  "def default_var_pts(self):\n        var = pybamm.standard_spatial_vars\n        return {var.y: 32, var.z: 32}",
  "def default_submesh_types(self):\n        return {\n            \"current collector\": pybamm.MeshGenerator(pybamm.ScikitUniform2DSubMesh)\n        }",
  "def default_spatial_methods(self):\n        return {\"current collector\": pybamm.ScikitFiniteElement}",
  "def default_solver(self):\n        return pybamm.AlgebraicSolver()",
  "def V_cc(t, y, z):\n            return V_av(t) - alpha * I_av(t) * W(y=y, z=z)",
  "def V_cc_dim(t, y, z):\n            return U_ref + V_cc(t, y, z) * pot_scale",
  "def phi_s_cn_tab(t):\n            phi_s_cn_tab = (\n                I_av(t) * l_y * l_z * psi_neg_tab\n                - sigma_cp_prime * l_cp * (V_av(t) - alpha * I_av(t) * W_neg_tab)\n            ) / denominator\n            return phi_s_cn_tab",
  "def phi_s_cn(t, y, z):\n            phi_s_cn = (\n                I_av(t) * l_y * l_z * psi(y=y, z=z)\n                - sigma_cp_prime * l_cp * V_cc(t, y, z)\n            ) / denominator\n            return phi_s_cn - phi_s_cn_tab(t)",
  "def phi_s_cn_dim(t, y, z):\n            return phi_s_cn(t, y, z) * pot_scale",
  "def phi_s_cp(t, y, z):\n            phi_s_cp = (\n                I_av(t) * l_y * l_z * psi(y=y, z=z)\n                + sigma_cn_prime * l_cn * V_cc(t, y, z)\n            ) / denominator\n            return phi_s_cp - phi_s_cn_tab(t)",
  "def phi_s_cp_dim(t, y, z):\n            return U_ref + phi_s_cp(t, y, z) * pot_scale",
  "class Uniform(BaseModel):\n    \"\"\"A submodel for uniform potential in the current collectors which\n    is valid in the limit of fast conductivity in the current collectors.\n\n    Parameters\n    ----------\n    param : parameter class\n        The parameters to use for this submodel\n\n\n    **Extends:** :class:`pybamm.current_collector.BaseModel`\n    \"\"\"\n\n    def __init__(self, param):\n        super().__init__(param)\n\n    def get_fundamental_variables(self):\n\n        # TODO: grad not implemented for 2D yet\n        i_cc = pybamm.Scalar(0)\n        i_boundary_cc = pybamm.PrimaryBroadcast(\n            self.param.current_with_time, \"current collector\"\n        )\n        phi_s_cn = pybamm.PrimaryBroadcast(0, \"current collector\")\n\n        variables = self._get_standard_negative_potential_variables(phi_s_cn)\n        variables.update(self._get_standard_current_variables(i_cc, i_boundary_cc))\n\n        # Hack to get the leading-order current collector current density\n        # Note that this should be different from the actual (composite) current\n        # collector current density for 2+1D models, but not sure how to implement this\n        # using current structure of lithium-ion models\n        variables[\"Leading-order current collector current density\"] = variables[\n            \"Current collector current density\"\n        ]\n        return variables",
  "def __init__(self, param):\n        super().__init__(param)",
  "def get_fundamental_variables(self):\n\n        # TODO: grad not implemented for 2D yet\n        i_cc = pybamm.Scalar(0)\n        i_boundary_cc = pybamm.PrimaryBroadcast(\n            self.param.current_with_time, \"current collector\"\n        )\n        phi_s_cn = pybamm.PrimaryBroadcast(0, \"current collector\")\n\n        variables = self._get_standard_negative_potential_variables(phi_s_cn)\n        variables.update(self._get_standard_current_variables(i_cc, i_boundary_cc))\n\n        # Hack to get the leading-order current collector current density\n        # Note that this should be different from the actual (composite) current\n        # collector current density for 2+1D models, but not sure how to implement this\n        # using current structure of lithium-ion models\n        variables[\"Leading-order current collector current density\"] = variables[\n            \"Current collector current density\"\n        ]\n        return variables",
  "class SingleParticlePotentialPair(PotentialPair2plus1D):\n    \"\"\"A submodel for Ohm's law plus conservation of current in the current collectors,\n    which uses the voltage-current relationship from the SPM(e).\n\n    Parameters\n    ----------\n    param : parameter class\n        The parameters to use for this submodel\n\n\n    **Extends:** :class:`pybamm.current_collector.PotentialPair2plus1D`\n    \"\"\"\n\n    def __init__(self, param):\n        super().__init__(param)\n\n    def get_coupled_variables(self, variables):\n        ocp_p_av = variables[\"X-averaged positive electrode open circuit potential\"]\n        ocp_n_av = variables[\"X-averaged negative electrode open circuit potential\"]\n        eta_r_n_av = variables[\"X-averaged negative electrode reaction overpotential\"]\n        eta_r_p_av = variables[\"X-averaged positive electrode reaction overpotential\"]\n        eta_e_av = variables[\"X-averaged electrolyte overpotential\"]\n        delta_phi_s_n_av = variables[\"X-averaged negative electrode ohmic losses\"]\n        delta_phi_s_p_av = variables[\"X-averaged positive electrode ohmic losses\"]\n\n        phi_s_cn = variables[\"Negative current collector potential\"]\n\n        local_voltage_expression = (\n            ocp_p_av\n            - ocp_n_av\n            + eta_r_p_av\n            - eta_r_n_av\n            + eta_e_av\n            + delta_phi_s_p_av\n            - delta_phi_s_n_av\n        )\n        phi_s_cp = phi_s_cn + local_voltage_expression\n        variables = self._get_standard_potential_variables(phi_s_cn, phi_s_cp)\n        return variables",
  "def __init__(self, param):\n        super().__init__(param)",
  "def get_coupled_variables(self, variables):\n        ocp_p_av = variables[\"X-averaged positive electrode open circuit potential\"]\n        ocp_n_av = variables[\"X-averaged negative electrode open circuit potential\"]\n        eta_r_n_av = variables[\"X-averaged negative electrode reaction overpotential\"]\n        eta_r_p_av = variables[\"X-averaged positive electrode reaction overpotential\"]\n        eta_e_av = variables[\"X-averaged electrolyte overpotential\"]\n        delta_phi_s_n_av = variables[\"X-averaged negative electrode ohmic losses\"]\n        delta_phi_s_p_av = variables[\"X-averaged positive electrode ohmic losses\"]\n\n        phi_s_cn = variables[\"Negative current collector potential\"]\n\n        local_voltage_expression = (\n            ocp_p_av\n            - ocp_n_av\n            + eta_r_p_av\n            - eta_r_n_av\n            + eta_e_av\n            + delta_phi_s_p_av\n            - delta_phi_s_n_av\n        )\n        phi_s_cp = phi_s_cn + local_voltage_expression\n        variables = self._get_standard_potential_variables(phi_s_cn, phi_s_cp)\n        return variables",
  "class BaseQuiteConductivePotentialPair(BasePotentialPair):\n    \"\"\"A submodel for Ohm's law plus conservation of current in the current collectors,\n    in the limit of quite conductive electrodes.\n\n    Parameters\n    ----------\n    param : parameter class\n        The parameters to use for this submodel\n\n\n    **Extends:** :class:`pybamm.current_collector.BaseModel`\n    \"\"\"\n\n    def __init__(self, param):\n        super().__init__(param)\n\n    def get_fundamental_variables(self):\n\n        phi_s_cn = pybamm.standard_variables.phi_s_cn\n\n        variables = self._get_standard_negative_potential_variables(phi_s_cn)\n\n        # TODO: grad not implemented for 2D yet\n        i_cc = pybamm.Scalar(0)\n        i_boundary_cc = pybamm.standard_variables.i_boundary_cc\n\n        variables.update(self._get_standard_current_variables(i_cc, i_boundary_cc))\n\n        # Lagrange multiplier for the composite current (enforce average)\n        c = pybamm.Variable(\"Lagrange multiplier\")\n        variables.update({\"Lagrange multiplier\": c})\n\n        return variables\n\n    def set_algebraic(self, variables):\n\n        param = self.param\n        applied_current = param.current_with_time\n        cc_area = self._get_effective_current_collector_area()\n        z = pybamm.standard_spatial_vars.z\n\n        phi_s_cn = variables[\"Negative current collector potential\"]\n        phi_s_cp = variables[\"Positive current collector potential\"]\n        i_boundary_cc = variables[\"Current collector current density\"]\n        i_boundary_cc_0 = variables[\"Leading-order current collector current density\"]\n        c = variables[\"Lagrange multiplier\"]\n\n        # Note that the second argument of 'source' must be the same as the argument\n        # in the laplacian (the variable to which the boundary conditions are applied)\n        self.algebraic = {\n            phi_s_cn: (param.sigma_cn * param.delta ** 2 * param.l_cn)\n            * pybamm.laplacian(phi_s_cn)\n            - pybamm.source(i_boundary_cc_0, phi_s_cn),\n            i_boundary_cc: (param.sigma_cp * param.delta ** 2 * param.l_cp)\n            * pybamm.laplacian(phi_s_cp)\n            + pybamm.source(i_boundary_cc_0, phi_s_cp)\n            + c * pybamm.PrimaryBroadcast(cc_area, \"current collector\"),\n            c: pybamm.Integral(i_boundary_cc, z) - applied_current / cc_area + 0 * c,\n        }\n\n    def set_initial_conditions(self, variables):\n\n        param = self.param\n        applied_current = param.current_with_time\n        cc_area = self._get_effective_current_collector_area()\n        phi_s_cn = variables[\"Negative current collector potential\"]\n        i_boundary_cc = variables[\"Current collector current density\"]\n        c = variables[\"Lagrange multiplier\"]\n\n        self.initial_conditions = {\n            phi_s_cn: pybamm.Scalar(0),\n            i_boundary_cc: applied_current / cc_area,\n            c: pybamm.Scalar(0),\n        }",
  "class QuiteConductivePotentialPair1plus1D(\n    BaseQuiteConductivePotentialPair, PotentialPair1plus1D\n):\n    def __init__(self, param):\n        super().__init__(param)",
  "class QuiteConductivePotentialPair2plus1D(\n    BaseQuiteConductivePotentialPair, PotentialPair2plus1D\n):\n    def __init__(self, param):\n        super().__init__(param)",
  "def __init__(self, param):\n        super().__init__(param)",
  "def get_fundamental_variables(self):\n\n        phi_s_cn = pybamm.standard_variables.phi_s_cn\n\n        variables = self._get_standard_negative_potential_variables(phi_s_cn)\n\n        # TODO: grad not implemented for 2D yet\n        i_cc = pybamm.Scalar(0)\n        i_boundary_cc = pybamm.standard_variables.i_boundary_cc\n\n        variables.update(self._get_standard_current_variables(i_cc, i_boundary_cc))\n\n        # Lagrange multiplier for the composite current (enforce average)\n        c = pybamm.Variable(\"Lagrange multiplier\")\n        variables.update({\"Lagrange multiplier\": c})\n\n        return variables",
  "def set_algebraic(self, variables):\n\n        param = self.param\n        applied_current = param.current_with_time\n        cc_area = self._get_effective_current_collector_area()\n        z = pybamm.standard_spatial_vars.z\n\n        phi_s_cn = variables[\"Negative current collector potential\"]\n        phi_s_cp = variables[\"Positive current collector potential\"]\n        i_boundary_cc = variables[\"Current collector current density\"]\n        i_boundary_cc_0 = variables[\"Leading-order current collector current density\"]\n        c = variables[\"Lagrange multiplier\"]\n\n        # Note that the second argument of 'source' must be the same as the argument\n        # in the laplacian (the variable to which the boundary conditions are applied)\n        self.algebraic = {\n            phi_s_cn: (param.sigma_cn * param.delta ** 2 * param.l_cn)\n            * pybamm.laplacian(phi_s_cn)\n            - pybamm.source(i_boundary_cc_0, phi_s_cn),\n            i_boundary_cc: (param.sigma_cp * param.delta ** 2 * param.l_cp)\n            * pybamm.laplacian(phi_s_cp)\n            + pybamm.source(i_boundary_cc_0, phi_s_cp)\n            + c * pybamm.PrimaryBroadcast(cc_area, \"current collector\"),\n            c: pybamm.Integral(i_boundary_cc, z) - applied_current / cc_area + 0 * c,\n        }",
  "def set_initial_conditions(self, variables):\n\n        param = self.param\n        applied_current = param.current_with_time\n        cc_area = self._get_effective_current_collector_area()\n        phi_s_cn = variables[\"Negative current collector potential\"]\n        i_boundary_cc = variables[\"Current collector current density\"]\n        c = variables[\"Lagrange multiplier\"]\n\n        self.initial_conditions = {\n            phi_s_cn: pybamm.Scalar(0),\n            i_boundary_cc: applied_current / cc_area,\n            c: pybamm.Scalar(0),\n        }",
  "def __init__(self, param):\n        super().__init__(param)",
  "def __init__(self, param):\n        super().__init__(param)",
  "class BaseModel(pybamm.BaseSubModel):\n    \"\"\"Base class for current collector submodels\n\n    Parameters\n    ----------\n    param : parameter class\n        The parameters to use for this submodel\n\n\n    **Extends:** :class:`pybamm.BaseSubModel`\n    \"\"\"\n\n    def __init__(self, param):\n        super().__init__(param)\n\n    def get_coupled_variables(self, variables):\n\n        # 1D models determine phi_s_cp\n        phi_s_cn = variables[\"Negative current collector potential\"]\n        phi_s_cp = variables[\"Positive current collector potential\"]\n\n        variables = self._get_standard_potential_variables(phi_s_cn, phi_s_cp)\n        return variables\n\n    def _get_standard_negative_potential_variables(self, phi_s_cn):\n        \"\"\"\n        A private function to obtain the standard variables which\n        can be derived from the negative potential in the current collector.\n\n        Parameters\n        ----------\n        phi_cc : :class:`pybamm.Symbol`\n            The potential in the current collector.\n\n        Returns\n        -------\n        variables : dict\n            The variables which can be derived from the potential in the\n            current collector.\n        \"\"\"\n\n        pot_scale = self.param.potential_scale\n\n        variables = {\n            \"Negative current collector potential\": phi_s_cn,\n            \"Negative current collector potential [V]\": phi_s_cn * pot_scale,\n        }\n\n        return variables\n\n    def _get_standard_potential_variables(self, phi_s_cn, phi_s_cp):\n        \"\"\"\n        A private function to obtain the standard variables which\n        can be derived from the potentials in the current collector.\n\n        Parameters\n        ----------\n        phi_cc : :class:`pybamm.Symbol`\n            The potential in the current collector.\n\n        Returns\n        -------\n        variables : dict\n            The variables which can be derived from the potential in the\n            current collector.\n        \"\"\"\n\n        pot_scale = self.param.potential_scale\n        U_ref = self.param.U_p_ref - self.param.U_n_ref\n\n        # add more to this\n        variables = {\n            \"Positive current collector potential\": phi_s_cp,\n            \"Positive current collector potential [V]\": U_ref + phi_s_cp * pot_scale,\n            \"Local potential difference\": phi_s_cp - phi_s_cn,\n            \"Local potential difference [V]\": U_ref + (phi_s_cp - phi_s_cn) * pot_scale,\n        }\n        variables.update(self._get_standard_negative_potential_variables(phi_s_cn))\n\n        return variables\n\n    def _get_standard_current_variables(self, i_cc, i_boundary_cc):\n        \"\"\"\n        A private function to obtain the standard variables which\n        can be derived from the current in the current collector.\n\n        Parameters\n        ----------\n        i_cc : :class:`pybamm.Symbol`\n            The current in the current collector.\n        i_boundary_cc : :class:`pybamm.Symbol`\n            The current leaving the current collector and going into the cell\n\n        Returns\n        -------\n        variables : dict\n            The variables which can be derived from the current in the current\n            collector.\n        \"\"\"\n        i_typ = self.param.i_typ\n\n        # TO DO: implement grad in 2D to get i_cc\n        # just need this to get 1D models working for now\n        variables = {\n            \"Current collector current density\": i_boundary_cc,\n            \"Current collector current density [A.m-2]\": i_typ * i_boundary_cc,\n        }\n\n        return variables",
  "def __init__(self, param):\n        super().__init__(param)",
  "def get_coupled_variables(self, variables):\n\n        # 1D models determine phi_s_cp\n        phi_s_cn = variables[\"Negative current collector potential\"]\n        phi_s_cp = variables[\"Positive current collector potential\"]\n\n        variables = self._get_standard_potential_variables(phi_s_cn, phi_s_cp)\n        return variables",
  "def _get_standard_negative_potential_variables(self, phi_s_cn):\n        \"\"\"\n        A private function to obtain the standard variables which\n        can be derived from the negative potential in the current collector.\n\n        Parameters\n        ----------\n        phi_cc : :class:`pybamm.Symbol`\n            The potential in the current collector.\n\n        Returns\n        -------\n        variables : dict\n            The variables which can be derived from the potential in the\n            current collector.\n        \"\"\"\n\n        pot_scale = self.param.potential_scale\n\n        variables = {\n            \"Negative current collector potential\": phi_s_cn,\n            \"Negative current collector potential [V]\": phi_s_cn * pot_scale,\n        }\n\n        return variables",
  "def _get_standard_potential_variables(self, phi_s_cn, phi_s_cp):\n        \"\"\"\n        A private function to obtain the standard variables which\n        can be derived from the potentials in the current collector.\n\n        Parameters\n        ----------\n        phi_cc : :class:`pybamm.Symbol`\n            The potential in the current collector.\n\n        Returns\n        -------\n        variables : dict\n            The variables which can be derived from the potential in the\n            current collector.\n        \"\"\"\n\n        pot_scale = self.param.potential_scale\n        U_ref = self.param.U_p_ref - self.param.U_n_ref\n\n        # add more to this\n        variables = {\n            \"Positive current collector potential\": phi_s_cp,\n            \"Positive current collector potential [V]\": U_ref + phi_s_cp * pot_scale,\n            \"Local potential difference\": phi_s_cp - phi_s_cn,\n            \"Local potential difference [V]\": U_ref + (phi_s_cp - phi_s_cn) * pot_scale,\n        }\n        variables.update(self._get_standard_negative_potential_variables(phi_s_cn))\n\n        return variables",
  "def _get_standard_current_variables(self, i_cc, i_boundary_cc):\n        \"\"\"\n        A private function to obtain the standard variables which\n        can be derived from the current in the current collector.\n\n        Parameters\n        ----------\n        i_cc : :class:`pybamm.Symbol`\n            The current in the current collector.\n        i_boundary_cc : :class:`pybamm.Symbol`\n            The current leaving the current collector and going into the cell\n\n        Returns\n        -------\n        variables : dict\n            The variables which can be derived from the current in the current\n            collector.\n        \"\"\"\n        i_typ = self.param.i_typ\n\n        # TO DO: implement grad in 2D to get i_cc\n        # just need this to get 1D models working for now\n        variables = {\n            \"Current collector current density\": i_boundary_cc,\n            \"Current collector current density [A.m-2]\": i_typ * i_boundary_cc,\n        }\n\n        return variables",
  "class BaseCompositePotentialPair(BasePotentialPair):\n    \"\"\"\n    Composite potential pair model for the current collectors.\n    This is identical to the BasePotentialPair model, except the name of the fundamental\n    variables are changed to avoid clashes with leading order.\n\n    Parameters\n    ----------\n    param : parameter class\n        The parameters to use for this submodel\n\n\n    **Extends:** :class:`pybamm.current_collector.BasePotentialPair`\n    \"\"\"\n\n    def __init__(self, param):\n        super().__init__(param)\n\n    def get_fundamental_variables(self):\n\n        phi_s_cn = pybamm.standard_variables.phi_s_cn_composite\n\n        variables = self._get_standard_negative_potential_variables(phi_s_cn)\n\n        # TODO: grad not implemented for 2D yet\n        i_cc = pybamm.Scalar(0)\n        i_boundary_cc = pybamm.standard_variables.i_boundary_cc_composite\n\n        variables.update(self._get_standard_current_variables(i_cc, i_boundary_cc))\n\n        return variables",
  "class CompositePotentialPair1plus1D(BaseCompositePotentialPair, PotentialPair1plus1D):\n    def __init__(self, param):\n        super().__init__(param)",
  "class CompositePotentialPair2plus1D(BaseCompositePotentialPair, PotentialPair2plus1D):\n    def __init__(self, param):\n        super().__init__(param)",
  "def __init__(self, param):\n        super().__init__(param)",
  "def get_fundamental_variables(self):\n\n        phi_s_cn = pybamm.standard_variables.phi_s_cn_composite\n\n        variables = self._get_standard_negative_potential_variables(phi_s_cn)\n\n        # TODO: grad not implemented for 2D yet\n        i_cc = pybamm.Scalar(0)\n        i_boundary_cc = pybamm.standard_variables.i_boundary_cc_composite\n\n        variables.update(self._get_standard_current_variables(i_cc, i_boundary_cc))\n\n        return variables",
  "def __init__(self, param):\n        super().__init__(param)",
  "def __init__(self, param):\n        super().__init__(param)",
  "class BaseModel(pybamm.BaseSubModel):\n    \"\"\"Base class for porosity\n\n    Parameters\n    ----------\n    param : parameter class\n        The parameters to use for this submodel\n\n\n    **Extends:** :class:`pybamm.BaseSubModel`\n    \"\"\"\n\n    def __init__(self, param):\n        super().__init__(param)\n\n    def _get_standard_porosity_variables(self, eps, set_leading_order=False):\n\n        eps_n, eps_s, eps_p = eps.orphans\n\n        variables = {\n            \"Porosity\": eps,\n            \"Negative electrode porosity\": eps_n,\n            \"Separator porosity\": eps_s,\n            \"Positive electrode porosity\": eps_p,\n            \"X-averaged negative electrode porosity\": pybamm.x_average(eps_n),\n            \"X-averaged separator porosity\": pybamm.x_average(eps_s),\n            \"X-averaged positive electrode porosity\": pybamm.x_average(eps_p),\n        }\n\n        if set_leading_order is True:\n            variables.update(\n                {\n                    \"Leading-order negative electrode porosity\": eps_n,\n                    \"Leading-order separator porosity\": eps_s,\n                    \"Leading-order positive electrode porosity\": eps_p,\n                    \"Leading-order x-averaged \"\n                    + \"negative electrode porosity\": pybamm.x_average(eps_n),\n                    \"Leading-order x-averaged separator porosity\": pybamm.x_average(\n                        eps_s\n                    ),\n                    \"Leading-order x-averaged \"\n                    + \"positive electrode porosity\": pybamm.x_average(eps_p),\n                }\n            )\n\n        return variables\n\n    def _get_standard_porosity_change_variables(self, deps_dt, set_leading_order=False):\n\n        deps_n_dt, deps_s_dt, deps_p_dt = deps_dt.orphans\n\n        variables = {\n            \"Porosity change\": deps_dt,\n            \"Negative electrode porosity change\": deps_n_dt,\n            \"Separator porosity change\": deps_s_dt,\n            \"Positive electrode porosity change\": deps_p_dt,\n            \"X-averaged porosity change\": pybamm.x_average(deps_dt),\n            \"X-averaged negative electrode porosity change\": pybamm.x_average(\n                deps_n_dt\n            ),\n            \"X-averaged separator porosity change\": pybamm.x_average(deps_s_dt),\n            \"X-averaged positive electrode porosity change\": pybamm.x_average(\n                deps_p_dt\n            ),\n        }\n\n        if set_leading_order is True:\n            variables.update(\n                {\n                    \"Leading-order x-averaged \"\n                    + \"negative electrode porosity change\": pybamm.x_average(deps_n_dt),\n                    \"Leading-order x-averaged \"\n                    + \"separator porosity change\": pybamm.x_average(deps_s_dt),\n                    \"Leading-order x-averaged \"\n                    + \"positive electrode porosity change\": pybamm.x_average(deps_p_dt),\n                }\n            )\n\n        return variables",
  "def __init__(self, param):\n        super().__init__(param)",
  "def _get_standard_porosity_variables(self, eps, set_leading_order=False):\n\n        eps_n, eps_s, eps_p = eps.orphans\n\n        variables = {\n            \"Porosity\": eps,\n            \"Negative electrode porosity\": eps_n,\n            \"Separator porosity\": eps_s,\n            \"Positive electrode porosity\": eps_p,\n            \"X-averaged negative electrode porosity\": pybamm.x_average(eps_n),\n            \"X-averaged separator porosity\": pybamm.x_average(eps_s),\n            \"X-averaged positive electrode porosity\": pybamm.x_average(eps_p),\n        }\n\n        if set_leading_order is True:\n            variables.update(\n                {\n                    \"Leading-order negative electrode porosity\": eps_n,\n                    \"Leading-order separator porosity\": eps_s,\n                    \"Leading-order positive electrode porosity\": eps_p,\n                    \"Leading-order x-averaged \"\n                    + \"negative electrode porosity\": pybamm.x_average(eps_n),\n                    \"Leading-order x-averaged separator porosity\": pybamm.x_average(\n                        eps_s\n                    ),\n                    \"Leading-order x-averaged \"\n                    + \"positive electrode porosity\": pybamm.x_average(eps_p),\n                }\n            )\n\n        return variables",
  "def _get_standard_porosity_change_variables(self, deps_dt, set_leading_order=False):\n\n        deps_n_dt, deps_s_dt, deps_p_dt = deps_dt.orphans\n\n        variables = {\n            \"Porosity change\": deps_dt,\n            \"Negative electrode porosity change\": deps_n_dt,\n            \"Separator porosity change\": deps_s_dt,\n            \"Positive electrode porosity change\": deps_p_dt,\n            \"X-averaged porosity change\": pybamm.x_average(deps_dt),\n            \"X-averaged negative electrode porosity change\": pybamm.x_average(\n                deps_n_dt\n            ),\n            \"X-averaged separator porosity change\": pybamm.x_average(deps_s_dt),\n            \"X-averaged positive electrode porosity change\": pybamm.x_average(\n                deps_p_dt\n            ),\n        }\n\n        if set_leading_order is True:\n            variables.update(\n                {\n                    \"Leading-order x-averaged \"\n                    + \"negative electrode porosity change\": pybamm.x_average(deps_n_dt),\n                    \"Leading-order x-averaged \"\n                    + \"separator porosity change\": pybamm.x_average(deps_s_dt),\n                    \"Leading-order x-averaged \"\n                    + \"positive electrode porosity change\": pybamm.x_average(deps_p_dt),\n                }\n            )\n\n        return variables",
  "class Full(BaseModel):\n    \"\"\"Full model for reaction-driven porosity changes\n\n    Parameters\n    ----------\n    param : parameter class\n        The parameters to use for this submodel\n\n\n    **Extends:** :class:`pybamm.porosity.BaseModel`\n    \"\"\"\n\n    def __init__(self, param):\n        super().__init__(param)\n\n    def get_fundamental_variables(self):\n\n        eps = pybamm.standard_variables.eps\n        variables = self._get_standard_porosity_variables(eps)\n        return variables\n\n    def get_coupled_variables(self, variables):\n\n        j_n = variables[\"Negative electrode interfacial current density\"]\n        j_p = variables[\"Positive electrode interfacial current density\"]\n\n        deps_dt_n = -self.param.beta_surf_n * j_n\n        deps_dt_s = pybamm.FullBroadcast(\n            0, \"separator\", auxiliary_domains={\"secondary\": \"current collector\"}\n        )\n        deps_dt_p = -self.param.beta_surf_p * j_p\n\n        deps_dt = pybamm.Concatenation(deps_dt_n, deps_dt_s, deps_dt_p)\n\n        variables.update(self._get_standard_porosity_change_variables(deps_dt))\n\n        return variables\n\n    def set_rhs(self, variables):\n\n        eps = variables[\"Porosity\"]\n        deps_dt = variables[\"Porosity change\"]\n\n        self.rhs = {eps: deps_dt}\n\n    def set_initial_conditions(self, variables):\n        eps = variables[\"Porosity\"]\n        self.initial_conditions = {eps: self.param.eps_init}",
  "def __init__(self, param):\n        super().__init__(param)",
  "def get_fundamental_variables(self):\n\n        eps = pybamm.standard_variables.eps\n        variables = self._get_standard_porosity_variables(eps)\n        return variables",
  "def get_coupled_variables(self, variables):\n\n        j_n = variables[\"Negative electrode interfacial current density\"]\n        j_p = variables[\"Positive electrode interfacial current density\"]\n\n        deps_dt_n = -self.param.beta_surf_n * j_n\n        deps_dt_s = pybamm.FullBroadcast(\n            0, \"separator\", auxiliary_domains={\"secondary\": \"current collector\"}\n        )\n        deps_dt_p = -self.param.beta_surf_p * j_p\n\n        deps_dt = pybamm.Concatenation(deps_dt_n, deps_dt_s, deps_dt_p)\n\n        variables.update(self._get_standard_porosity_change_variables(deps_dt))\n\n        return variables",
  "def set_rhs(self, variables):\n\n        eps = variables[\"Porosity\"]\n        deps_dt = variables[\"Porosity change\"]\n\n        self.rhs = {eps: deps_dt}",
  "def set_initial_conditions(self, variables):\n        eps = variables[\"Porosity\"]\n        self.initial_conditions = {eps: self.param.eps_init}",
  "class Constant(BaseModel):\n    \"\"\"Submodel for constant porosity\n\n    Parameters\n    ----------\n    param : parameter class\n        The parameters to use for this submodel\n\n\n    **Extends:** :class:`pybamm.porosity.BaseModel`\n    \"\"\"\n\n    def get_fundamental_variables(self):\n\n        eps_n_av = self.param.epsilon_n\n        eps_s_av = self.param.epsilon_s\n        eps_p_av = self.param.epsilon_p\n\n        eps_n = pybamm.FullBroadcast(\n            eps_n_av, \"negative electrode\", \"current collector\"\n        )\n        eps_s = pybamm.FullBroadcast(eps_s_av, \"separator\", \"current collector\")\n        eps_p = pybamm.FullBroadcast(\n            eps_p_av, \"positive electrode\", \"current collector\"\n        )\n        eps = pybamm.Concatenation(eps_n, eps_s, eps_p)\n\n        deps_n_dt = pybamm.FullBroadcast(0, \"negative electrode\", \"current collector\")\n        deps_s_dt = pybamm.FullBroadcast(0, \"separator\", \"current collector\")\n        deps_p_dt = pybamm.FullBroadcast(0, \"positive electrode\", \"current collector\")\n        deps_dt = pybamm.Concatenation(deps_n_dt, deps_s_dt, deps_p_dt)\n\n        variables = self._get_standard_porosity_variables(eps, set_leading_order=True)\n        variables.update(\n            self._get_standard_porosity_change_variables(\n                deps_dt, set_leading_order=True\n            )\n        )\n\n        return variables",
  "def get_fundamental_variables(self):\n\n        eps_n_av = self.param.epsilon_n\n        eps_s_av = self.param.epsilon_s\n        eps_p_av = self.param.epsilon_p\n\n        eps_n = pybamm.FullBroadcast(\n            eps_n_av, \"negative electrode\", \"current collector\"\n        )\n        eps_s = pybamm.FullBroadcast(eps_s_av, \"separator\", \"current collector\")\n        eps_p = pybamm.FullBroadcast(\n            eps_p_av, \"positive electrode\", \"current collector\"\n        )\n        eps = pybamm.Concatenation(eps_n, eps_s, eps_p)\n\n        deps_n_dt = pybamm.FullBroadcast(0, \"negative electrode\", \"current collector\")\n        deps_s_dt = pybamm.FullBroadcast(0, \"separator\", \"current collector\")\n        deps_p_dt = pybamm.FullBroadcast(0, \"positive electrode\", \"current collector\")\n        deps_dt = pybamm.Concatenation(deps_n_dt, deps_s_dt, deps_p_dt)\n\n        variables = self._get_standard_porosity_variables(eps, set_leading_order=True)\n        variables.update(\n            self._get_standard_porosity_change_variables(\n                deps_dt, set_leading_order=True\n            )\n        )\n\n        return variables",
  "class LeadingOrder(BaseModel):\n    \"\"\"Leading-order model for reaction-driven porosity changes\n\n    Parameters\n    ----------\n    param : parameter class\n        The parameters to use for this submodel\n\n\n    **Extends:** :class:`pybamm.porosity.BaseModel`\n    \"\"\"\n\n    def __init__(self, param):\n        super().__init__(param)\n\n    def get_fundamental_variables(self):\n\n        eps = pybamm.standard_variables.eps_piecewise_constant\n        variables = self._get_standard_porosity_variables(eps)\n        return variables\n\n    def get_coupled_variables(self, variables):\n\n        j_n = variables[\"X-averaged negative electrode interfacial current density\"]\n        j_p = variables[\"X-averaged positive electrode interfacial current density\"]\n\n        deps_dt_n = pybamm.PrimaryBroadcast(\n            -self.param.beta_surf_n * j_n, [\"negative electrode\"]\n        )\n        deps_dt_s = pybamm.FullBroadcast(\n            0, \"separator\", auxiliary_domains={\"secondary\": \"current collector\"}\n        )\n        deps_dt_p = pybamm.PrimaryBroadcast(\n            -self.param.beta_surf_p * j_p, [\"positive electrode\"]\n        )\n\n        deps_dt = pybamm.Concatenation(deps_dt_n, deps_dt_s, deps_dt_p)\n\n        variables.update(self._get_standard_porosity_change_variables(deps_dt))\n\n        return variables\n\n    def set_rhs(self, variables):\n        self.rhs = {}\n        for domain in [\"negative electrode\", \"separator\", \"positive electrode\"]:\n            eps_av = variables[\"X-averaged \" + domain + \" porosity\"]\n            deps_dt_av = variables[\"X-averaged \" + domain + \" porosity change\"]\n            self.rhs.update({eps_av: deps_dt_av})\n\n    def set_initial_conditions(self, variables):\n\n        eps_n_av = variables[\"X-averaged negative electrode porosity\"]\n        eps_s_av = variables[\"X-averaged separator porosity\"]\n        eps_p_av = variables[\"X-averaged positive electrode porosity\"]\n\n        self.initial_conditions = {eps_n_av: self.param.eps_n_init}\n        self.initial_conditions.update({eps_s_av: self.param.eps_s_init})\n        self.initial_conditions.update({eps_p_av: self.param.eps_p_init})",
  "def __init__(self, param):\n        super().__init__(param)",
  "def get_fundamental_variables(self):\n\n        eps = pybamm.standard_variables.eps_piecewise_constant\n        variables = self._get_standard_porosity_variables(eps)\n        return variables",
  "def get_coupled_variables(self, variables):\n\n        j_n = variables[\"X-averaged negative electrode interfacial current density\"]\n        j_p = variables[\"X-averaged positive electrode interfacial current density\"]\n\n        deps_dt_n = pybamm.PrimaryBroadcast(\n            -self.param.beta_surf_n * j_n, [\"negative electrode\"]\n        )\n        deps_dt_s = pybamm.FullBroadcast(\n            0, \"separator\", auxiliary_domains={\"secondary\": \"current collector\"}\n        )\n        deps_dt_p = pybamm.PrimaryBroadcast(\n            -self.param.beta_surf_p * j_p, [\"positive electrode\"]\n        )\n\n        deps_dt = pybamm.Concatenation(deps_dt_n, deps_dt_s, deps_dt_p)\n\n        variables.update(self._get_standard_porosity_change_variables(deps_dt))\n\n        return variables",
  "def set_rhs(self, variables):\n        self.rhs = {}\n        for domain in [\"negative electrode\", \"separator\", \"positive electrode\"]:\n            eps_av = variables[\"X-averaged \" + domain + \" porosity\"]\n            deps_dt_av = variables[\"X-averaged \" + domain + \" porosity change\"]\n            self.rhs.update({eps_av: deps_dt_av})",
  "def set_initial_conditions(self, variables):\n\n        eps_n_av = variables[\"X-averaged negative electrode porosity\"]\n        eps_s_av = variables[\"X-averaged separator porosity\"]\n        eps_p_av = variables[\"X-averaged positive electrode porosity\"]\n\n        self.initial_conditions = {eps_n_av: self.param.eps_n_init}\n        self.initial_conditions.update({eps_s_av: self.param.eps_s_init})\n        self.initial_conditions.update({eps_p_av: self.param.eps_p_init})",
  "class BaseElectrolyteDiffusion(pybamm.BaseSubModel):\n    \"\"\"Base class for conservation of mass in the electrolyte.\n\n    Parameters\n    ----------\n    param : parameter class\n        The parameters to use for this submodel\n    reactions : dict, optional\n        Dictionary of reaction terms\n\n    **Extends:** :class:`pybamm.BaseSubModel`\n    \"\"\"\n\n    def __init__(self, param, reactions=None):\n        super().__init__(param, reactions=reactions)\n\n    def _get_standard_concentration_variables(self, c_e):\n        \"\"\"\n        A private function to obtain the standard variables which\n        can be derived from the concentration in the electrolyte.\n\n        Parameters\n        ----------\n        c_e : :class:`pybamm.Symbol`\n            The concentration in the electrolyte.\n        c_e_av : :class:`pybamm.Symbol`\n            The cell-averaged concentration in the electrolyte.\n\n        Returns\n        -------\n        variables : dict\n            The variables which can be derived from the concentration in the\n            electrolyte.\n        \"\"\"\n\n        c_e_typ = self.param.c_e_typ\n        c_e_n, c_e_s, c_e_p = c_e.orphans\n        c_e_av = pybamm.x_average(c_e)\n        c_e_n_av = pybamm.x_average(c_e_n)\n        c_e_s_av = pybamm.x_average(c_e_s)\n        c_e_p_av = pybamm.x_average(c_e_p)\n\n        variables = {\n            \"Electrolyte concentration\": c_e,\n            \"Electrolyte concentration [mol.m-3]\": c_e_typ * c_e,\n            \"Electrolyte concentration [Molar]\": c_e_typ * c_e / 1000,\n            \"X-averaged electrolyte concentration\": c_e_av,\n            \"X-averaged electrolyte concentration [mol.m-3]\": c_e_typ * c_e_av,\n            \"X-averaged electrolyte concentration [Molar]\": c_e_typ * c_e_av / 1000,\n            \"Negative electrolyte concentration\": c_e_n,\n            \"Negative electrolyte concentration [mol.m-3]\": c_e_typ * c_e_n,\n            \"Negative electrolyte concentration [Molar]\": c_e_typ * c_e_n / 1000,\n            \"Separator electrolyte concentration\": c_e_s,\n            \"Separator electrolyte concentration [mol.m-3]\": c_e_typ * c_e_s,\n            \"Separator electrolyte concentration [Molar]\": c_e_typ * c_e_s / 1000,\n            \"Positive electrolyte concentration\": c_e_p,\n            \"Positive electrolyte concentration [mol.m-3]\": c_e_typ * c_e_p,\n            \"Positive electrolyte concentration [Molar]\": c_e_typ * c_e_p / 1000,\n            \"X-averaged negative electrolyte concentration\": c_e_n_av,\n            \"X-averaged negative electrolyte concentration [mol.m-3]\": c_e_typ\n            * c_e_n_av,\n            \"X-averaged separator electrolyte concentration\": c_e_s_av,\n            \"X-averaged separator electrolyte concentration [mol.m-3]\": c_e_typ\n            * c_e_s_av,\n            \"X-averaged positive electrolyte concentration\": c_e_p_av,\n            \"X-averaged positive electrolyte concentration [mol.m-3]\": c_e_typ\n            * c_e_p_av,\n        }\n\n        return variables\n\n    def _get_standard_flux_variables(self, N_e):\n        \"\"\"\n        A private function to obtain the standard variables which\n        can be derived from the mass flux in the electrolyte.\n\n        Parameters\n        ----------\n        N_e : :class:`pybamm.Symbol`\n            The flux in the electrolyte.\n\n        Returns\n        -------\n        variables : dict\n            The variables which can be derived from the flux in the\n            electrolyte.\n        \"\"\"\n\n        param = self.param\n        D_e_typ = param.D_e(param.c_e_typ, param.T_ref)\n        flux_scale = D_e_typ * param.c_e_typ / param.L_x\n\n        variables = {\n            \"Electrolyte flux\": N_e,\n            \"Electrolyte flux [mol.m-2.s-1]\": N_e * flux_scale,\n        }\n\n        return variables\n\n    def set_events(self, variables):\n        c_e = variables[\"Electrolyte concentration\"]\n        self.events[\"Zero electrolyte concentration cut-off\"] = pybamm.min(c_e) - 0.002",
  "def __init__(self, param, reactions=None):\n        super().__init__(param, reactions=reactions)",
  "def _get_standard_concentration_variables(self, c_e):\n        \"\"\"\n        A private function to obtain the standard variables which\n        can be derived from the concentration in the electrolyte.\n\n        Parameters\n        ----------\n        c_e : :class:`pybamm.Symbol`\n            The concentration in the electrolyte.\n        c_e_av : :class:`pybamm.Symbol`\n            The cell-averaged concentration in the electrolyte.\n\n        Returns\n        -------\n        variables : dict\n            The variables which can be derived from the concentration in the\n            electrolyte.\n        \"\"\"\n\n        c_e_typ = self.param.c_e_typ\n        c_e_n, c_e_s, c_e_p = c_e.orphans\n        c_e_av = pybamm.x_average(c_e)\n        c_e_n_av = pybamm.x_average(c_e_n)\n        c_e_s_av = pybamm.x_average(c_e_s)\n        c_e_p_av = pybamm.x_average(c_e_p)\n\n        variables = {\n            \"Electrolyte concentration\": c_e,\n            \"Electrolyte concentration [mol.m-3]\": c_e_typ * c_e,\n            \"Electrolyte concentration [Molar]\": c_e_typ * c_e / 1000,\n            \"X-averaged electrolyte concentration\": c_e_av,\n            \"X-averaged electrolyte concentration [mol.m-3]\": c_e_typ * c_e_av,\n            \"X-averaged electrolyte concentration [Molar]\": c_e_typ * c_e_av / 1000,\n            \"Negative electrolyte concentration\": c_e_n,\n            \"Negative electrolyte concentration [mol.m-3]\": c_e_typ * c_e_n,\n            \"Negative electrolyte concentration [Molar]\": c_e_typ * c_e_n / 1000,\n            \"Separator electrolyte concentration\": c_e_s,\n            \"Separator electrolyte concentration [mol.m-3]\": c_e_typ * c_e_s,\n            \"Separator electrolyte concentration [Molar]\": c_e_typ * c_e_s / 1000,\n            \"Positive electrolyte concentration\": c_e_p,\n            \"Positive electrolyte concentration [mol.m-3]\": c_e_typ * c_e_p,\n            \"Positive electrolyte concentration [Molar]\": c_e_typ * c_e_p / 1000,\n            \"X-averaged negative electrolyte concentration\": c_e_n_av,\n            \"X-averaged negative electrolyte concentration [mol.m-3]\": c_e_typ\n            * c_e_n_av,\n            \"X-averaged separator electrolyte concentration\": c_e_s_av,\n            \"X-averaged separator electrolyte concentration [mol.m-3]\": c_e_typ\n            * c_e_s_av,\n            \"X-averaged positive electrolyte concentration\": c_e_p_av,\n            \"X-averaged positive electrolyte concentration [mol.m-3]\": c_e_typ\n            * c_e_p_av,\n        }\n\n        return variables",
  "def _get_standard_flux_variables(self, N_e):\n        \"\"\"\n        A private function to obtain the standard variables which\n        can be derived from the mass flux in the electrolyte.\n\n        Parameters\n        ----------\n        N_e : :class:`pybamm.Symbol`\n            The flux in the electrolyte.\n\n        Returns\n        -------\n        variables : dict\n            The variables which can be derived from the flux in the\n            electrolyte.\n        \"\"\"\n\n        param = self.param\n        D_e_typ = param.D_e(param.c_e_typ, param.T_ref)\n        flux_scale = D_e_typ * param.c_e_typ / param.L_x\n\n        variables = {\n            \"Electrolyte flux\": N_e,\n            \"Electrolyte flux [mol.m-2.s-1]\": N_e * flux_scale,\n        }\n\n        return variables",
  "def set_events(self, variables):\n        c_e = variables[\"Electrolyte concentration\"]\n        self.events[\"Zero electrolyte concentration cut-off\"] = pybamm.min(c_e) - 0.002",
  "class BaseElectrolyteConductivity(pybamm.BaseSubModel):\n    \"\"\"Base class for conservation of charge in the electrolyte.\n\n    Parameters\n    ----------\n    param : parameter class\n        The parameters to use for this submodel\n    domain : str, optional\n        The domain in which the model holds\n    reactions : dict, optional\n        Dictionary of reaction terms\n\n    **Extends:** :class:`pybamm.BaseSubModel`\n    \"\"\"\n\n    def __init__(self, param, domain=None, reactions=None):\n        super().__init__(param, domain)\n        self.reactions = reactions\n\n    def _get_standard_potential_variables(self, phi_e, phi_e_av):\n        \"\"\"\n        A private function to obtain the standard variables which\n        can be derived from the potential in the electrolyte.\n\n        Parameters\n        ----------\n        phi_e : :class:`pybamm.Symbol`\n            The potential in the electrolyte.\n        phi_e_av : :class:`pybamm.Symbol`\n            The cell-averaged potential in the electrolyte.\n\n        Returns\n        -------\n        variables : dict\n            The variables which can be derived from the potential in the\n            electrolyte.\n        \"\"\"\n\n        param = self.param\n        pot_scale = param.potential_scale\n        phi_e_n, phi_e_s, phi_e_p = phi_e.orphans\n\n        phi_e_n_av = pybamm.x_average(phi_e_n)\n        phi_e_s_av = pybamm.x_average(phi_e_s)\n        phi_e_p_av = pybamm.x_average(phi_e_p)\n        eta_e_av = phi_e_p_av - phi_e_n_av\n        phi_e_av = pybamm.x_average(phi_e)\n\n        variables = {\n            \"Negative electrolyte potential\": phi_e_n,\n            \"Negative electrolyte potential [V]\": -param.U_n_ref + pot_scale * phi_e_n,\n            \"Separator electrolyte potential\": phi_e_s,\n            \"Separator electrolyte potential [V]\": -param.U_n_ref + pot_scale * phi_e_s,\n            \"Positive electrolyte potential\": phi_e_p,\n            \"Positive electrolyte potential [V]\": -param.U_n_ref + pot_scale * phi_e_p,\n            \"Electrolyte potential\": phi_e,\n            \"Electrolyte potential [V]\": -param.U_n_ref + pot_scale * phi_e,\n            \"X-averaged electrolyte potential\": phi_e_av,\n            \"X-averaged electrolyte potential [V]\": -param.U_n_ref\n            + pot_scale * phi_e_av,\n            \"X-averaged negative electrolyte potential\": phi_e_n_av,\n            \"X-averaged negative electrolyte potential [V]\": -param.U_n_ref\n            + pot_scale * phi_e_n_av,\n            \"X-averaged separator electrolyte potential\": phi_e_s_av,\n            \"X-averaged separator electrolyte potential [V]\": -param.U_n_ref\n            + pot_scale * phi_e_s_av,\n            \"X-averaged positive electrolyte potential\": phi_e_p_av,\n            \"X-averaged positive electrolyte potential [V]\": -param.U_n_ref\n            + pot_scale * phi_e_p_av,\n            \"X-averaged electrolyte overpotential\": eta_e_av,\n            \"X-averaged electrolyte overpotential [V]\": pot_scale * eta_e_av,\n            \"Gradient of negative electrolyte potential\": pybamm.grad(phi_e_n),\n            \"Gradient of separator electrolyte potential\": pybamm.grad(phi_e_s),\n            \"Gradient of positive electrolyte potential\": pybamm.grad(phi_e_p),\n            \"Gradient of electrolyte potential\": pybamm.grad(phi_e),\n        }\n\n        return variables\n\n    def _get_standard_current_variables(self, i_e):\n        \"\"\"\n        A private function to obtain the standard variables which\n        can be derived from the current in the electrolyte.\n\n        Parameters\n        ----------\n        i_e : :class:`pybamm.Symbol`\n            The current in the electrolyte.\n\n        Returns\n        -------\n        variables : dict\n            The variables which can be derived from the current in the\n            electrolyte.\n        \"\"\"\n\n        i_typ = self.param.i_typ\n        variables = {\n            \"Electrolyte current density\": i_e,\n            \"Electrolyte current density [A.m-2]\": i_typ * i_e,\n        }\n\n        if isinstance(i_e, pybamm.Concatenation):\n            i_e_n, _, i_e_p = i_e.orphans\n            variables.update(self._get_domain_current_variables(i_e_n, \"Negative\"))\n            variables.update(self._get_domain_current_variables(i_e_p, \"Positive\"))\n\n        return variables\n\n    def _get_split_overpotential(self, eta_c_av, delta_phi_e_av):\n        \"\"\"\n        A private function to obtain the standard variables which\n        can be derived from the electrode-averaged concentration\n        overpotential and Ohmic losses in the electrolyte.\n\n        Parameters\n        ----------\n        eta_c_av : :class:`pybamm.Symbol`\n            The electrode-averaged concentration overpotential\n        delta_phi_e_av: :class:`pybamm.Symbol`\n            The electrode-averaged electrolyte Ohmic losses\n\n        Returns\n        -------\n        variables : dict\n            The variables which can be derived from the electrode-averaged\n            concentration overpotential and Ohmic losses in the electrolyte\n            electrolyte.\n        \"\"\"\n\n        param = self.param\n        pot_scale = param.potential_scale\n\n        variables = {\n            \"X-averaged concentration overpotential\": eta_c_av,\n            \"X-averaged electrolyte ohmic losses\": delta_phi_e_av,\n            \"X-averaged concentration overpotential [V]\": pot_scale * eta_c_av,\n            \"X-averaged electrolyte ohmic losses [V]\": pot_scale * delta_phi_e_av,\n        }\n\n        return variables\n\n    def _get_standard_surface_potential_difference_variables(self, delta_phi):\n        \"\"\"\n        A private function to obtain the standard variables which\n        can be derived from the surface potential difference.\n\n        Parameters\n        ----------\n        delta_phi : :class:`pybamm.Symbol`\n            The surface potential difference.\n\n        Returns\n        -------\n        variables : dict\n            The variables which can be derived from the surface potential difference.\n        \"\"\"\n\n        if self.domain == \"Negative\":\n            ocp_ref = self.param.U_n_ref\n        elif self.domain == \"Positive\":\n            ocp_ref = self.param.U_p_ref\n        pot_scale = self.param.potential_scale\n\n        # Average, and broadcast if necessary\n        delta_phi_av = pybamm.x_average(delta_phi)\n        if delta_phi.domain == []:\n            delta_phi = pybamm.FullBroadcast(\n                delta_phi, self.domain_for_broadcast, \"current collector\"\n            )\n        elif delta_phi.domain == [\"current collector\"]:\n            delta_phi = pybamm.PrimaryBroadcast(delta_phi, self.domain_for_broadcast)\n\n        variables = {\n            self.domain + \" electrode surface potential difference\": delta_phi,\n            \"X-averaged \"\n            + self.domain.lower()\n            + \" electrode surface potential difference\": delta_phi_av,\n            self.domain\n            + \" electrode surface potential difference [V]\": ocp_ref\n            + delta_phi * pot_scale,\n            \"X-averaged \"\n            + self.domain.lower()\n            + \" electrode surface potential difference [V]\": ocp_ref\n            + delta_phi_av * pot_scale,\n        }\n\n        return variables\n\n    def _get_domain_potential_variables(self, phi_e, domain=None):\n        \"\"\"\n        A private function to obtain the standard variables which\n        can be derived from the potential in the electrolyte split\n        by domain: 'negative electrode', 'separator' and 'positive electrode'.\n\n        Parameters\n        ----------\n        phi_e : :class:`pybamm.Symbol`\n            The potential in the electrolyte within the domain 'domain'.\n\n        Returns\n        -------\n        variables : dict\n            The variables which can be derived from the potential in the\n            electrolyte in domain 'domain'.\n        \"\"\"\n        domain = domain or self.domain\n\n        pot_scale = self.param.potential_scale\n        phi_e_av = pybamm.x_average(phi_e)\n\n        variables = {\n            domain + \" electrolyte potential\": phi_e,\n            domain + \" electrolyte potential [V]\": phi_e * pot_scale,\n            \"X-averaged \" + domain.lower() + \" electrolyte potential\": phi_e_av,\n            \"X-averaged \"\n            + domain.lower()\n            + \" electrolyte potential [V]\": phi_e_av * pot_scale,\n        }\n\n        return variables\n\n    def _get_domain_current_variables(self, i_e, domain=None):\n        \"\"\"\n        A private function to obtain the standard variables which\n        can be derived from the current in the electrolyte split\n        by domain: 'negative electrode', 'separator' and 'positive electrode'.\n\n        Parameters\n        ----------\n        i_e : :class:`pybamm.Symbol`\n            The current in the electrolyte within the domain 'domain'.\n\n        Returns\n        -------\n        variables : dict\n            The variables which can be derived from the current in the\n            electrolyte in domain 'domain'.\n        \"\"\"\n        domain = domain or self.domain\n\n        i_typ = self.param.i_typ\n\n        variables = {\n            domain + \" electrolyte current density\": i_e,\n            domain + \" electrolyte current density [V]\": i_e * i_typ,\n        }\n\n        return variables\n\n    def _get_whole_cell_variables(self, variables):\n        \"\"\"\n        A private function to obtain the potential and current concatenated\n        across the whole cell. Note required 'variables' to contain the potential\n        and current in the subdomains: 'negative electrode', 'separator', and\n        'positive electrode'.\n\n        Parameters\n        ----------\n        variables : dict\n            The variables that have been set in the rest of the model.\n\n        Returns\n        -------\n        variables : dict\n            The variables including the whole-cell electrolyte potentials\n            and currents.\n        \"\"\"\n\n        phi_e_n = variables[\"Negative electrolyte potential\"]\n        phi_e_s = variables[\"Separator electrolyte potential\"]\n        phi_e_p = variables[\"Positive electrolyte potential\"]\n        phi_e = pybamm.Concatenation(phi_e_n, phi_e_s, phi_e_p)\n        phi_e_av = pybamm.x_average(phi_e)\n\n        i_e_n = variables[\"Negative electrolyte current density\"]\n        i_e_s = variables[\"Separator electrolyte current density\"]\n        i_e_p = variables[\"Positive electrolyte current density\"]\n        i_e = pybamm.Concatenation(i_e_n, i_e_s, i_e_p)\n\n        variables.update(self._get_standard_potential_variables(phi_e, phi_e_av))\n        variables.update(self._get_standard_current_variables(i_e))\n\n        return variables",
  "def __init__(self, param, domain=None, reactions=None):\n        super().__init__(param, domain)\n        self.reactions = reactions",
  "def _get_standard_potential_variables(self, phi_e, phi_e_av):\n        \"\"\"\n        A private function to obtain the standard variables which\n        can be derived from the potential in the electrolyte.\n\n        Parameters\n        ----------\n        phi_e : :class:`pybamm.Symbol`\n            The potential in the electrolyte.\n        phi_e_av : :class:`pybamm.Symbol`\n            The cell-averaged potential in the electrolyte.\n\n        Returns\n        -------\n        variables : dict\n            The variables which can be derived from the potential in the\n            electrolyte.\n        \"\"\"\n\n        param = self.param\n        pot_scale = param.potential_scale\n        phi_e_n, phi_e_s, phi_e_p = phi_e.orphans\n\n        phi_e_n_av = pybamm.x_average(phi_e_n)\n        phi_e_s_av = pybamm.x_average(phi_e_s)\n        phi_e_p_av = pybamm.x_average(phi_e_p)\n        eta_e_av = phi_e_p_av - phi_e_n_av\n        phi_e_av = pybamm.x_average(phi_e)\n\n        variables = {\n            \"Negative electrolyte potential\": phi_e_n,\n            \"Negative electrolyte potential [V]\": -param.U_n_ref + pot_scale * phi_e_n,\n            \"Separator electrolyte potential\": phi_e_s,\n            \"Separator electrolyte potential [V]\": -param.U_n_ref + pot_scale * phi_e_s,\n            \"Positive electrolyte potential\": phi_e_p,\n            \"Positive electrolyte potential [V]\": -param.U_n_ref + pot_scale * phi_e_p,\n            \"Electrolyte potential\": phi_e,\n            \"Electrolyte potential [V]\": -param.U_n_ref + pot_scale * phi_e,\n            \"X-averaged electrolyte potential\": phi_e_av,\n            \"X-averaged electrolyte potential [V]\": -param.U_n_ref\n            + pot_scale * phi_e_av,\n            \"X-averaged negative electrolyte potential\": phi_e_n_av,\n            \"X-averaged negative electrolyte potential [V]\": -param.U_n_ref\n            + pot_scale * phi_e_n_av,\n            \"X-averaged separator electrolyte potential\": phi_e_s_av,\n            \"X-averaged separator electrolyte potential [V]\": -param.U_n_ref\n            + pot_scale * phi_e_s_av,\n            \"X-averaged positive electrolyte potential\": phi_e_p_av,\n            \"X-averaged positive electrolyte potential [V]\": -param.U_n_ref\n            + pot_scale * phi_e_p_av,\n            \"X-averaged electrolyte overpotential\": eta_e_av,\n            \"X-averaged electrolyte overpotential [V]\": pot_scale * eta_e_av,\n            \"Gradient of negative electrolyte potential\": pybamm.grad(phi_e_n),\n            \"Gradient of separator electrolyte potential\": pybamm.grad(phi_e_s),\n            \"Gradient of positive electrolyte potential\": pybamm.grad(phi_e_p),\n            \"Gradient of electrolyte potential\": pybamm.grad(phi_e),\n        }\n\n        return variables",
  "def _get_standard_current_variables(self, i_e):\n        \"\"\"\n        A private function to obtain the standard variables which\n        can be derived from the current in the electrolyte.\n\n        Parameters\n        ----------\n        i_e : :class:`pybamm.Symbol`\n            The current in the electrolyte.\n\n        Returns\n        -------\n        variables : dict\n            The variables which can be derived from the current in the\n            electrolyte.\n        \"\"\"\n\n        i_typ = self.param.i_typ\n        variables = {\n            \"Electrolyte current density\": i_e,\n            \"Electrolyte current density [A.m-2]\": i_typ * i_e,\n        }\n\n        if isinstance(i_e, pybamm.Concatenation):\n            i_e_n, _, i_e_p = i_e.orphans\n            variables.update(self._get_domain_current_variables(i_e_n, \"Negative\"))\n            variables.update(self._get_domain_current_variables(i_e_p, \"Positive\"))\n\n        return variables",
  "def _get_split_overpotential(self, eta_c_av, delta_phi_e_av):\n        \"\"\"\n        A private function to obtain the standard variables which\n        can be derived from the electrode-averaged concentration\n        overpotential and Ohmic losses in the electrolyte.\n\n        Parameters\n        ----------\n        eta_c_av : :class:`pybamm.Symbol`\n            The electrode-averaged concentration overpotential\n        delta_phi_e_av: :class:`pybamm.Symbol`\n            The electrode-averaged electrolyte Ohmic losses\n\n        Returns\n        -------\n        variables : dict\n            The variables which can be derived from the electrode-averaged\n            concentration overpotential and Ohmic losses in the electrolyte\n            electrolyte.\n        \"\"\"\n\n        param = self.param\n        pot_scale = param.potential_scale\n\n        variables = {\n            \"X-averaged concentration overpotential\": eta_c_av,\n            \"X-averaged electrolyte ohmic losses\": delta_phi_e_av,\n            \"X-averaged concentration overpotential [V]\": pot_scale * eta_c_av,\n            \"X-averaged electrolyte ohmic losses [V]\": pot_scale * delta_phi_e_av,\n        }\n\n        return variables",
  "def _get_standard_surface_potential_difference_variables(self, delta_phi):\n        \"\"\"\n        A private function to obtain the standard variables which\n        can be derived from the surface potential difference.\n\n        Parameters\n        ----------\n        delta_phi : :class:`pybamm.Symbol`\n            The surface potential difference.\n\n        Returns\n        -------\n        variables : dict\n            The variables which can be derived from the surface potential difference.\n        \"\"\"\n\n        if self.domain == \"Negative\":\n            ocp_ref = self.param.U_n_ref\n        elif self.domain == \"Positive\":\n            ocp_ref = self.param.U_p_ref\n        pot_scale = self.param.potential_scale\n\n        # Average, and broadcast if necessary\n        delta_phi_av = pybamm.x_average(delta_phi)\n        if delta_phi.domain == []:\n            delta_phi = pybamm.FullBroadcast(\n                delta_phi, self.domain_for_broadcast, \"current collector\"\n            )\n        elif delta_phi.domain == [\"current collector\"]:\n            delta_phi = pybamm.PrimaryBroadcast(delta_phi, self.domain_for_broadcast)\n\n        variables = {\n            self.domain + \" electrode surface potential difference\": delta_phi,\n            \"X-averaged \"\n            + self.domain.lower()\n            + \" electrode surface potential difference\": delta_phi_av,\n            self.domain\n            + \" electrode surface potential difference [V]\": ocp_ref\n            + delta_phi * pot_scale,\n            \"X-averaged \"\n            + self.domain.lower()\n            + \" electrode surface potential difference [V]\": ocp_ref\n            + delta_phi_av * pot_scale,\n        }\n\n        return variables",
  "def _get_domain_potential_variables(self, phi_e, domain=None):\n        \"\"\"\n        A private function to obtain the standard variables which\n        can be derived from the potential in the electrolyte split\n        by domain: 'negative electrode', 'separator' and 'positive electrode'.\n\n        Parameters\n        ----------\n        phi_e : :class:`pybamm.Symbol`\n            The potential in the electrolyte within the domain 'domain'.\n\n        Returns\n        -------\n        variables : dict\n            The variables which can be derived from the potential in the\n            electrolyte in domain 'domain'.\n        \"\"\"\n        domain = domain or self.domain\n\n        pot_scale = self.param.potential_scale\n        phi_e_av = pybamm.x_average(phi_e)\n\n        variables = {\n            domain + \" electrolyte potential\": phi_e,\n            domain + \" electrolyte potential [V]\": phi_e * pot_scale,\n            \"X-averaged \" + domain.lower() + \" electrolyte potential\": phi_e_av,\n            \"X-averaged \"\n            + domain.lower()\n            + \" electrolyte potential [V]\": phi_e_av * pot_scale,\n        }\n\n        return variables",
  "def _get_domain_current_variables(self, i_e, domain=None):\n        \"\"\"\n        A private function to obtain the standard variables which\n        can be derived from the current in the electrolyte split\n        by domain: 'negative electrode', 'separator' and 'positive electrode'.\n\n        Parameters\n        ----------\n        i_e : :class:`pybamm.Symbol`\n            The current in the electrolyte within the domain 'domain'.\n\n        Returns\n        -------\n        variables : dict\n            The variables which can be derived from the current in the\n            electrolyte in domain 'domain'.\n        \"\"\"\n        domain = domain or self.domain\n\n        i_typ = self.param.i_typ\n\n        variables = {\n            domain + \" electrolyte current density\": i_e,\n            domain + \" electrolyte current density [V]\": i_e * i_typ,\n        }\n\n        return variables",
  "def _get_whole_cell_variables(self, variables):\n        \"\"\"\n        A private function to obtain the potential and current concatenated\n        across the whole cell. Note required 'variables' to contain the potential\n        and current in the subdomains: 'negative electrode', 'separator', and\n        'positive electrode'.\n\n        Parameters\n        ----------\n        variables : dict\n            The variables that have been set in the rest of the model.\n\n        Returns\n        -------\n        variables : dict\n            The variables including the whole-cell electrolyte potentials\n            and currents.\n        \"\"\"\n\n        phi_e_n = variables[\"Negative electrolyte potential\"]\n        phi_e_s = variables[\"Separator electrolyte potential\"]\n        phi_e_p = variables[\"Positive electrolyte potential\"]\n        phi_e = pybamm.Concatenation(phi_e_n, phi_e_s, phi_e_p)\n        phi_e_av = pybamm.x_average(phi_e)\n\n        i_e_n = variables[\"Negative electrolyte current density\"]\n        i_e_s = variables[\"Separator electrolyte current density\"]\n        i_e_p = variables[\"Positive electrolyte current density\"]\n        i_e = pybamm.Concatenation(i_e_n, i_e_s, i_e_p)\n\n        variables.update(self._get_standard_potential_variables(phi_e, phi_e_av))\n        variables.update(self._get_standard_current_variables(i_e))\n\n        return variables",
  "class BaseModel(BaseElectrolyteDiffusion):\n    \"\"\"Base class for conservation of mass in the electrolyte employing the\n    Stefan-Maxwell constitutive equations.\n\n    Parameters\n    ----------\n    param : parameter class\n        The parameters to use for this submodel\n    reactions : dict, optional\n        Dictionary of reaction terms\n\n    **Extends:** :class:`pybamm.electrolyte.BaseElectrolyteDiffusion`\n    \"\"\"\n\n    def __init__(self, param, reactions=None):\n        super().__init__(param, reactions)\n\n    def set_boundary_conditions(self, variables):\n\n        c_e = variables[\"Electrolyte concentration\"]\n\n        self.boundary_conditions = {\n            c_e: {\n                \"left\": (pybamm.Scalar(0), \"Neumann\"),\n                \"right\": (pybamm.Scalar(0), \"Neumann\"),\n            }\n        }",
  "def __init__(self, param, reactions=None):\n        super().__init__(param, reactions)",
  "def set_boundary_conditions(self, variables):\n\n        c_e = variables[\"Electrolyte concentration\"]\n\n        self.boundary_conditions = {\n            c_e: {\n                \"left\": (pybamm.Scalar(0), \"Neumann\"),\n                \"right\": (pybamm.Scalar(0), \"Neumann\"),\n            }\n        }",
  "class FirstOrder(BaseModel):\n    \"\"\"Class for conservation of mass in the electrolyte employing the\n    Stefan-Maxwell constitutive equations. (First-order refers to first-order term in\n    asymptotic expansion)\n\n    Parameters\n    ----------\n    param : parameter class\n        The parameters to use for this submodel\n    reactions : dict\n        Dictionary of reaction terms\n\n    **Extends:** :class:`pybamm.electrolyte.stefan_maxwell.diffusion.BaseModel`\n    \"\"\"\n\n    def __init__(self, param, reactions):\n        super().__init__(param, reactions)\n\n    def get_coupled_variables(self, variables):\n        param = self.param\n        l_n = param.l_n\n        l_s = param.l_s\n        l_p = param.l_p\n        x_n = pybamm.standard_spatial_vars.x_n\n        x_s = pybamm.standard_spatial_vars.x_s\n        x_p = pybamm.standard_spatial_vars.x_p\n\n        # Unpack\n        T_0 = variables[\"Leading-order cell temperature\"]\n        c_e_0 = variables[\"Leading-order x-averaged electrolyte concentration\"]\n        # v_box_0 = variables[\"Leading-order volume-averaged velocity\"]\n        dc_e_0_dt = variables[\"Leading-order electrolyte concentration change\"]\n        eps_n_0 = variables[\"Leading-order x-averaged negative electrode porosity\"]\n        eps_s_0 = variables[\"Leading-order x-averaged separator porosity\"]\n        eps_p_0 = variables[\"Leading-order x-averaged positive electrode porosity\"]\n        deps_n_0_dt = variables[\n            \"Leading-order x-averaged negative electrode porosity change\"\n        ]\n        deps_p_0_dt = variables[\n            \"Leading-order x-averaged positive electrode porosity change\"\n        ]\n\n        # Combined time derivatives\n        d_epsc_n_0_dt = c_e_0 * deps_n_0_dt + eps_n_0 * dc_e_0_dt\n        d_epsc_s_0_dt = eps_s_0 * dc_e_0_dt\n        d_epsc_p_0_dt = c_e_0 * deps_p_0_dt + eps_p_0 * dc_e_0_dt\n\n        # Right-hand sides\n        rhs_n = d_epsc_n_0_dt - sum(\n            reaction[\"Negative\"][\"s\"]\n            * variables[\n                \"Leading-order x-averaged \" + reaction[\"Negative\"][\"aj\"].lower()\n            ]\n            for reaction in self.reactions.values()\n        )\n        rhs_s = d_epsc_s_0_dt\n        rhs_p = d_epsc_p_0_dt - sum(\n            reaction[\"Positive\"][\"s\"]\n            * variables[\n                \"Leading-order x-averaged \" + reaction[\"Positive\"][\"aj\"].lower()\n            ]\n            for reaction in self.reactions.values()\n        )\n\n        # Diffusivities\n        D_e_n = (eps_n_0 ** param.b_n) * param.D_e(c_e_0, T_0)\n        D_e_s = (eps_s_0 ** param.b_s) * param.D_e(c_e_0, T_0)\n        D_e_p = (eps_p_0 ** param.b_p) * param.D_e(c_e_0, T_0)\n\n        # Fluxes\n        N_e_n_1 = -pybamm.outer(rhs_n, x_n)\n        N_e_s_1 = -(\n            pybamm.outer(rhs_s, (x_s - l_n))\n            + pybamm.PrimaryBroadcast(rhs_n * l_n, \"separator\")\n        )\n        N_e_p_1 = -pybamm.outer(rhs_p, (x_p - 1))\n\n        # Concentrations\n        c_e_n_1 = pybamm.outer(rhs_n / (2 * D_e_n), x_n ** 2 - l_n ** 2)\n        c_e_s_1 = pybamm.outer(rhs_s / 2, (x_s - l_n) ** 2) + pybamm.outer(\n            rhs_n * l_n / D_e_s, x_s - l_n\n        )\n        c_e_p_1 = pybamm.outer(\n            rhs_p / (2 * D_e_p), (x_p - 1) ** 2 - l_p ** 2\n        ) + pybamm.PrimaryBroadcast(\n            (rhs_s * l_s ** 2 / (2 * D_e_s)) + (rhs_n * l_n * l_s / D_e_s),\n            \"positive electrode\",\n        )\n\n        # Correct for integral\n        c_e_n_1_av = -rhs_n * l_n ** 3 / (3 * D_e_n)\n        c_e_s_1_av = (rhs_s * l_s ** 3 / 6 + rhs_n * l_n * l_s ** 2 / 2) / D_e_s\n        c_e_p_1_av = (\n            -rhs_p * l_p ** 3 / (3 * D_e_p)\n            + (rhs_s * l_s ** 2 * l_p / (2 * D_e_s))\n            + (rhs_n * l_n * l_s * l_p / D_e_s)\n        )\n        A_e = -(eps_n_0 * c_e_n_1_av + eps_s_0 * c_e_s_1_av + eps_p_0 * c_e_p_1_av) / (\n            l_n * eps_n_0 + l_s * eps_s_0 + l_p * eps_p_0\n        )\n        c_e_n_1 += pybamm.PrimaryBroadcast(A_e, \"negative electrode\")\n        c_e_s_1 += pybamm.PrimaryBroadcast(A_e, \"separator\")\n        c_e_p_1 += pybamm.PrimaryBroadcast(A_e, \"positive electrode\")\n        c_e_n_1_av += A_e\n        c_e_s_1_av += A_e\n        c_e_p_1_av += A_e\n\n        # Update variables\n        c_e = pybamm.Concatenation(\n            pybamm.PrimaryBroadcast(c_e_0, \"negative electrode\") + param.C_e * c_e_n_1,\n            pybamm.PrimaryBroadcast(c_e_0, \"separator\") + param.C_e * c_e_s_1,\n            pybamm.PrimaryBroadcast(c_e_0, \"positive electrode\") + param.C_e * c_e_p_1,\n        )\n        variables.update(self._get_standard_concentration_variables(c_e))\n        # Update with analytical expressions for first-order x-averages\n        variables.update(\n            {\n                \"X-averaged first-order negative electrolyte concentration\": c_e_n_1_av,\n                \"X-averaged first-order separator concentration\": c_e_s_1_av,\n                \"X-averaged first-order positive electrolyte concentration\": c_e_p_1_av,\n            }\n        )\n\n        N_e = pybamm.Concatenation(\n            param.C_e * N_e_n_1, param.C_e * N_e_s_1, param.C_e * N_e_p_1\n        )\n        variables.update(self._get_standard_flux_variables(N_e))\n\n        return variables",
  "def __init__(self, param, reactions):\n        super().__init__(param, reactions)",
  "def get_coupled_variables(self, variables):\n        param = self.param\n        l_n = param.l_n\n        l_s = param.l_s\n        l_p = param.l_p\n        x_n = pybamm.standard_spatial_vars.x_n\n        x_s = pybamm.standard_spatial_vars.x_s\n        x_p = pybamm.standard_spatial_vars.x_p\n\n        # Unpack\n        T_0 = variables[\"Leading-order cell temperature\"]\n        c_e_0 = variables[\"Leading-order x-averaged electrolyte concentration\"]\n        # v_box_0 = variables[\"Leading-order volume-averaged velocity\"]\n        dc_e_0_dt = variables[\"Leading-order electrolyte concentration change\"]\n        eps_n_0 = variables[\"Leading-order x-averaged negative electrode porosity\"]\n        eps_s_0 = variables[\"Leading-order x-averaged separator porosity\"]\n        eps_p_0 = variables[\"Leading-order x-averaged positive electrode porosity\"]\n        deps_n_0_dt = variables[\n            \"Leading-order x-averaged negative electrode porosity change\"\n        ]\n        deps_p_0_dt = variables[\n            \"Leading-order x-averaged positive electrode porosity change\"\n        ]\n\n        # Combined time derivatives\n        d_epsc_n_0_dt = c_e_0 * deps_n_0_dt + eps_n_0 * dc_e_0_dt\n        d_epsc_s_0_dt = eps_s_0 * dc_e_0_dt\n        d_epsc_p_0_dt = c_e_0 * deps_p_0_dt + eps_p_0 * dc_e_0_dt\n\n        # Right-hand sides\n        rhs_n = d_epsc_n_0_dt - sum(\n            reaction[\"Negative\"][\"s\"]\n            * variables[\n                \"Leading-order x-averaged \" + reaction[\"Negative\"][\"aj\"].lower()\n            ]\n            for reaction in self.reactions.values()\n        )\n        rhs_s = d_epsc_s_0_dt\n        rhs_p = d_epsc_p_0_dt - sum(\n            reaction[\"Positive\"][\"s\"]\n            * variables[\n                \"Leading-order x-averaged \" + reaction[\"Positive\"][\"aj\"].lower()\n            ]\n            for reaction in self.reactions.values()\n        )\n\n        # Diffusivities\n        D_e_n = (eps_n_0 ** param.b_n) * param.D_e(c_e_0, T_0)\n        D_e_s = (eps_s_0 ** param.b_s) * param.D_e(c_e_0, T_0)\n        D_e_p = (eps_p_0 ** param.b_p) * param.D_e(c_e_0, T_0)\n\n        # Fluxes\n        N_e_n_1 = -pybamm.outer(rhs_n, x_n)\n        N_e_s_1 = -(\n            pybamm.outer(rhs_s, (x_s - l_n))\n            + pybamm.PrimaryBroadcast(rhs_n * l_n, \"separator\")\n        )\n        N_e_p_1 = -pybamm.outer(rhs_p, (x_p - 1))\n\n        # Concentrations\n        c_e_n_1 = pybamm.outer(rhs_n / (2 * D_e_n), x_n ** 2 - l_n ** 2)\n        c_e_s_1 = pybamm.outer(rhs_s / 2, (x_s - l_n) ** 2) + pybamm.outer(\n            rhs_n * l_n / D_e_s, x_s - l_n\n        )\n        c_e_p_1 = pybamm.outer(\n            rhs_p / (2 * D_e_p), (x_p - 1) ** 2 - l_p ** 2\n        ) + pybamm.PrimaryBroadcast(\n            (rhs_s * l_s ** 2 / (2 * D_e_s)) + (rhs_n * l_n * l_s / D_e_s),\n            \"positive electrode\",\n        )\n\n        # Correct for integral\n        c_e_n_1_av = -rhs_n * l_n ** 3 / (3 * D_e_n)\n        c_e_s_1_av = (rhs_s * l_s ** 3 / 6 + rhs_n * l_n * l_s ** 2 / 2) / D_e_s\n        c_e_p_1_av = (\n            -rhs_p * l_p ** 3 / (3 * D_e_p)\n            + (rhs_s * l_s ** 2 * l_p / (2 * D_e_s))\n            + (rhs_n * l_n * l_s * l_p / D_e_s)\n        )\n        A_e = -(eps_n_0 * c_e_n_1_av + eps_s_0 * c_e_s_1_av + eps_p_0 * c_e_p_1_av) / (\n            l_n * eps_n_0 + l_s * eps_s_0 + l_p * eps_p_0\n        )\n        c_e_n_1 += pybamm.PrimaryBroadcast(A_e, \"negative electrode\")\n        c_e_s_1 += pybamm.PrimaryBroadcast(A_e, \"separator\")\n        c_e_p_1 += pybamm.PrimaryBroadcast(A_e, \"positive electrode\")\n        c_e_n_1_av += A_e\n        c_e_s_1_av += A_e\n        c_e_p_1_av += A_e\n\n        # Update variables\n        c_e = pybamm.Concatenation(\n            pybamm.PrimaryBroadcast(c_e_0, \"negative electrode\") + param.C_e * c_e_n_1,\n            pybamm.PrimaryBroadcast(c_e_0, \"separator\") + param.C_e * c_e_s_1,\n            pybamm.PrimaryBroadcast(c_e_0, \"positive electrode\") + param.C_e * c_e_p_1,\n        )\n        variables.update(self._get_standard_concentration_variables(c_e))\n        # Update with analytical expressions for first-order x-averages\n        variables.update(\n            {\n                \"X-averaged first-order negative electrolyte concentration\": c_e_n_1_av,\n                \"X-averaged first-order separator concentration\": c_e_s_1_av,\n                \"X-averaged first-order positive electrolyte concentration\": c_e_p_1_av,\n            }\n        )\n\n        N_e = pybamm.Concatenation(\n            param.C_e * N_e_n_1, param.C_e * N_e_s_1, param.C_e * N_e_p_1\n        )\n        variables.update(self._get_standard_flux_variables(N_e))\n\n        return variables",
  "class Full(BaseModel):\n    \"\"\"Class for conservation of mass in the electrolyte employing the\n    Stefan-Maxwell constitutive equations. (Full refers to unreduced by\n    asymptotic methods)\n\n    Parameters\n    ----------\n    param : parameter class\n        The parameters to use for this submodel\n    reactions : dict\n        Dictionary of reaction terms\n\n    **Extends:** :class:`pybamm.electrolyte.stefan_maxwell.diffusion.BaseModel`\n    \"\"\"\n\n    def __init__(self, param, reactions):\n        super().__init__(param, reactions)\n\n    def get_fundamental_variables(self):\n        c_e = pybamm.standard_variables.c_e\n\n        return self._get_standard_concentration_variables(c_e)\n\n    def get_coupled_variables(self, variables):\n\n        eps = variables[\"Porosity\"]\n        c_e = variables[\"Electrolyte concentration\"]\n        # i_e = variables[\"Electrolyte current density\"]\n        v_box = variables[\"Volume-averaged velocity\"]\n        T = variables[\"Cell temperature\"]\n\n        param = self.param\n\n        N_e_diffusion = -(eps ** param.b) * param.D_e(c_e, T) * pybamm.grad(c_e)\n        # N_e_migration = (param.C_e * param.t_plus) / param.gamma_e * i_e\n        # N_e_convection = c_e * v_box\n\n        # N_e = N_e_diffusion + N_e_migration + N_e_convection\n\n        N_e = N_e_diffusion + c_e * v_box\n\n        variables.update(self._get_standard_flux_variables(N_e))\n\n        return variables\n\n    def set_rhs(self, variables):\n\n        param = self.param\n\n        eps = variables[\"Porosity\"]\n        deps_dt = variables[\"Porosity change\"]\n        c_e = variables[\"Electrolyte concentration\"]\n        N_e = variables[\"Electrolyte flux\"]\n        # i_e = variables[\"Electrolyte current density\"]\n\n        # source_term = ((param.s - param.t_plus) / param.gamma_e) * pybamm.div(i_e)\n        # source_term = pybamm.div(i_e) / param.gamma_e  # lithium-ion\n        source_terms = sum(\n            pybamm.Concatenation(\n                reaction[\"Negative\"][\"s\"] * variables[reaction[\"Negative\"][\"aj\"]],\n                pybamm.FullBroadcast(0, \"separator\", \"current collector\"),\n                reaction[\"Positive\"][\"s\"] * variables[reaction[\"Positive\"][\"aj\"]],\n            )\n            / param.gamma_e\n            for reaction in self.reactions.values()\n        )\n\n        self.rhs = {\n            c_e: (1 / eps)\n            * (-pybamm.div(N_e) / param.C_e + source_terms - c_e * deps_dt)\n        }\n\n    def set_initial_conditions(self, variables):\n\n        c_e = variables[\"Electrolyte concentration\"]\n\n        self.initial_conditions = {c_e: self.param.c_e_init}",
  "def __init__(self, param, reactions):\n        super().__init__(param, reactions)",
  "def get_fundamental_variables(self):\n        c_e = pybamm.standard_variables.c_e\n\n        return self._get_standard_concentration_variables(c_e)",
  "def get_coupled_variables(self, variables):\n\n        eps = variables[\"Porosity\"]\n        c_e = variables[\"Electrolyte concentration\"]\n        # i_e = variables[\"Electrolyte current density\"]\n        v_box = variables[\"Volume-averaged velocity\"]\n        T = variables[\"Cell temperature\"]\n\n        param = self.param\n\n        N_e_diffusion = -(eps ** param.b) * param.D_e(c_e, T) * pybamm.grad(c_e)\n        # N_e_migration = (param.C_e * param.t_plus) / param.gamma_e * i_e\n        # N_e_convection = c_e * v_box\n\n        # N_e = N_e_diffusion + N_e_migration + N_e_convection\n\n        N_e = N_e_diffusion + c_e * v_box\n\n        variables.update(self._get_standard_flux_variables(N_e))\n\n        return variables",
  "def set_rhs(self, variables):\n\n        param = self.param\n\n        eps = variables[\"Porosity\"]\n        deps_dt = variables[\"Porosity change\"]\n        c_e = variables[\"Electrolyte concentration\"]\n        N_e = variables[\"Electrolyte flux\"]\n        # i_e = variables[\"Electrolyte current density\"]\n\n        # source_term = ((param.s - param.t_plus) / param.gamma_e) * pybamm.div(i_e)\n        # source_term = pybamm.div(i_e) / param.gamma_e  # lithium-ion\n        source_terms = sum(\n            pybamm.Concatenation(\n                reaction[\"Negative\"][\"s\"] * variables[reaction[\"Negative\"][\"aj\"]],\n                pybamm.FullBroadcast(0, \"separator\", \"current collector\"),\n                reaction[\"Positive\"][\"s\"] * variables[reaction[\"Positive\"][\"aj\"]],\n            )\n            / param.gamma_e\n            for reaction in self.reactions.values()\n        )\n\n        self.rhs = {\n            c_e: (1 / eps)\n            * (-pybamm.div(N_e) / param.C_e + source_terms - c_e * deps_dt)\n        }",
  "def set_initial_conditions(self, variables):\n\n        c_e = variables[\"Electrolyte concentration\"]\n\n        self.initial_conditions = {c_e: self.param.c_e_init}",
  "class LeadingOrder(BaseModel):\n    \"\"\"Class for conservation of mass in the electrolyte employing the\n    Stefan-Maxwell constitutive equations. (Leading refers to leading order\n    of asymptotic reduction)\n\n    Parameters\n    ----------\n    param : parameter class\n        The parameters to use for this submodel\n    reactions : dict\n        Dictionary of reaction terms\n\n    **Extends:** :class:`pybamm.electrolyte.stefan_maxwell.diffusion.BaseModel`\n    \"\"\"\n\n    def __init__(self, param, reactions):\n        super().__init__(param, reactions)\n\n    def get_fundamental_variables(self):\n        c_e_av = pybamm.standard_variables.c_e_av\n        c_e_n = pybamm.PrimaryBroadcast(c_e_av, [\"negative electrode\"])\n        c_e_s = pybamm.PrimaryBroadcast(c_e_av, [\"separator\"])\n        c_e_p = pybamm.PrimaryBroadcast(c_e_av, [\"positive electrode\"])\n        c_e = pybamm.Concatenation(c_e_n, c_e_s, c_e_p)\n\n        return self._get_standard_concentration_variables(c_e)\n\n    def get_coupled_variables(self, variables):\n\n        N_e = pybamm.FullBroadcast(\n            0,\n            [\"negative electrode\", \"separator\", \"positive electrode\"],\n            \"current collector\",\n        )\n\n        variables.update(self._get_standard_flux_variables(N_e))\n\n        return variables\n\n    def set_rhs(self, variables):\n\n        param = self.param\n\n        c_e_av = variables[\"X-averaged electrolyte concentration\"]\n\n        eps_n_av = variables[\"X-averaged negative electrode porosity\"]\n        eps_s_av = variables[\"X-averaged separator porosity\"]\n        eps_p_av = variables[\"X-averaged positive electrode porosity\"]\n\n        deps_n_dt_av = variables[\"X-averaged negative electrode porosity change\"]\n        deps_p_dt_av = variables[\"X-averaged positive electrode porosity change\"]\n\n        source_terms = sum(\n            param.l_n\n            * rxn[\"Negative\"][\"s\"]\n            * variables[\"X-averaged \" + rxn[\"Negative\"][\"aj\"].lower()]\n            + param.l_p\n            * rxn[\"Positive\"][\"s\"]\n            * variables[\"X-averaged \" + rxn[\"Positive\"][\"aj\"].lower()]\n            for rxn in self.reactions.values()\n        )\n\n        self.rhs = {\n            c_e_av: 1\n            / (param.l_n * eps_n_av + param.l_s * eps_s_av + param.l_p * eps_p_av)\n            * (\n                source_terms\n                - c_e_av * (param.l_n * deps_n_dt_av + param.l_p * deps_p_dt_av)\n            )\n        }\n\n    def set_initial_conditions(self, variables):\n        c_e = variables[\"X-averaged electrolyte concentration\"]\n        self.initial_conditions = {c_e: self.param.c_e_init}",
  "def __init__(self, param, reactions):\n        super().__init__(param, reactions)",
  "def get_fundamental_variables(self):\n        c_e_av = pybamm.standard_variables.c_e_av\n        c_e_n = pybamm.PrimaryBroadcast(c_e_av, [\"negative electrode\"])\n        c_e_s = pybamm.PrimaryBroadcast(c_e_av, [\"separator\"])\n        c_e_p = pybamm.PrimaryBroadcast(c_e_av, [\"positive electrode\"])\n        c_e = pybamm.Concatenation(c_e_n, c_e_s, c_e_p)\n\n        return self._get_standard_concentration_variables(c_e)",
  "def get_coupled_variables(self, variables):\n\n        N_e = pybamm.FullBroadcast(\n            0,\n            [\"negative electrode\", \"separator\", \"positive electrode\"],\n            \"current collector\",\n        )\n\n        variables.update(self._get_standard_flux_variables(N_e))\n\n        return variables",
  "def set_rhs(self, variables):\n\n        param = self.param\n\n        c_e_av = variables[\"X-averaged electrolyte concentration\"]\n\n        eps_n_av = variables[\"X-averaged negative electrode porosity\"]\n        eps_s_av = variables[\"X-averaged separator porosity\"]\n        eps_p_av = variables[\"X-averaged positive electrode porosity\"]\n\n        deps_n_dt_av = variables[\"X-averaged negative electrode porosity change\"]\n        deps_p_dt_av = variables[\"X-averaged positive electrode porosity change\"]\n\n        source_terms = sum(\n            param.l_n\n            * rxn[\"Negative\"][\"s\"]\n            * variables[\"X-averaged \" + rxn[\"Negative\"][\"aj\"].lower()]\n            + param.l_p\n            * rxn[\"Positive\"][\"s\"]\n            * variables[\"X-averaged \" + rxn[\"Positive\"][\"aj\"].lower()]\n            for rxn in self.reactions.values()\n        )\n\n        self.rhs = {\n            c_e_av: 1\n            / (param.l_n * eps_n_av + param.l_s * eps_s_av + param.l_p * eps_p_av)\n            * (\n                source_terms\n                - c_e_av * (param.l_n * deps_n_dt_av + param.l_p * deps_p_dt_av)\n            )\n        }",
  "def set_initial_conditions(self, variables):\n        c_e = variables[\"X-averaged electrolyte concentration\"]\n        self.initial_conditions = {c_e: self.param.c_e_init}",
  "class ConstantConcentration(BaseModel):\n    \"\"\"Class for constant concentration of electrolyte\n\n    Parameters\n    ----------\n    param : parameter class\n        The parameters to use for this submodel\n\n\n    **Extends:** :class:`pybamm.electrolyte.stefan_maxwell.diffusion.BaseModel`\n    \"\"\"\n\n    def __init__(self, param):\n        super().__init__(param)\n\n    def get_fundamental_variables(self):\n        c_e_n = pybamm.FullBroadcast(1, \"negative electrode\", \"current collector\")\n        c_e_s = pybamm.FullBroadcast(1, \"separator\", \"current collector\")\n        c_e_p = pybamm.FullBroadcast(1, \"positive electrode\", \"current collector\")\n        c_e = pybamm.Concatenation(c_e_n, c_e_s, c_e_p)\n\n        variables = self._get_standard_concentration_variables(c_e)\n\n        N_e = pybamm.FullBroadcast(\n            0,\n            [\"negative electrode\", \"separator\", \"positive electrode\"],\n            \"current collector\",\n        )\n\n        variables.update(self._get_standard_flux_variables(N_e))\n\n        return variables\n\n    def set_boundary_conditions(self, variables):\n        return None",
  "def __init__(self, param):\n        super().__init__(param)",
  "def get_fundamental_variables(self):\n        c_e_n = pybamm.FullBroadcast(1, \"negative electrode\", \"current collector\")\n        c_e_s = pybamm.FullBroadcast(1, \"separator\", \"current collector\")\n        c_e_p = pybamm.FullBroadcast(1, \"positive electrode\", \"current collector\")\n        c_e = pybamm.Concatenation(c_e_n, c_e_s, c_e_p)\n\n        variables = self._get_standard_concentration_variables(c_e)\n\n        N_e = pybamm.FullBroadcast(\n            0,\n            [\"negative electrode\", \"separator\", \"positive electrode\"],\n            \"current collector\",\n        )\n\n        variables.update(self._get_standard_flux_variables(N_e))\n\n        return variables",
  "def set_boundary_conditions(self, variables):\n        return None",
  "class Composite(Full):\n    \"\"\"Class for conservation of mass in the electrolyte employing the\n    Stefan-Maxwell constitutive equations. (Composite refers to composite model by\n    asymptotic methods)\n\n    Parameters\n    ----------\n    param : parameter class\n        The parameters to use for this submodel\n    reactions : dict\n        Dictionary of reaction terms\n    extended : bool\n        Whether to include feedback from the first-order terms\n\n    **Extends:** :class:`pybamm.electrolyte.stefan_maxwell.diffusion.Full`\n    \"\"\"\n\n    def __init__(self, param, reactions, extended=False):\n        super().__init__(param, reactions)\n        self.extended = extended\n\n    def get_coupled_variables(self, variables):\n\n        eps_0 = variables[\"Leading-order porosity\"]\n        c_e_0_av = variables[\"Leading-order x-averaged electrolyte concentration\"]\n        c_e = variables[\"Electrolyte concentration\"]\n        # i_e = variables[\"Electrolyte current density\"]\n        v_box_0 = variables[\"Leading-order volume-averaged velocity\"]\n        T_0 = variables[\"Leading-order cell temperature\"]\n\n        param = self.param\n\n        whole_cell = [\"negative electrode\", \"separator\", \"positive electrode\"]\n        N_e_diffusion = (\n            -(eps_0 ** param.b)\n            * pybamm.PrimaryBroadcast(param.D_e(c_e_0_av, T_0), whole_cell)\n            * pybamm.grad(c_e)\n        )\n        # N_e_migration = (param.C_e * param.t_plus) / param.gamma_e * i_e\n        # N_e_convection = c_e * v_box_0\n\n        # N_e = N_e_diffusion + N_e_migration + N_e_convection\n\n        if v_box_0.id == pybamm.Scalar(0).id:\n            N_e = N_e_diffusion\n        else:\n            N_e = N_e_diffusion + pybamm.outer(v_box_0, c_e)\n\n        variables.update(self._get_standard_flux_variables(N_e))\n\n        return variables\n\n    def set_rhs(self, variables):\n        \"Composite reaction-diffusion with source terms from leading order\"\n\n        param = self.param\n\n        eps_0 = variables[\"Leading-order porosity\"]\n        deps_0_dt = variables[\"Leading-order porosity change\"]\n        c_e = variables[\"Electrolyte concentration\"]\n        N_e = variables[\"Electrolyte flux\"]\n        if self.extended is False:\n            source_terms_0 = self._get_source_terms_leading_order(variables)\n        else:\n            source_terms_0 = self._get_source_terms_first_order(variables)\n\n        self.rhs = {\n            c_e: (1 / eps_0)\n            * (-pybamm.div(N_e) / param.C_e + source_terms_0 - c_e * deps_0_dt)\n        }\n\n    def _get_source_terms_leading_order(self, variables):\n        return sum(\n            pybamm.Concatenation(\n                reaction[\"Negative\"][\"s\"]\n                * variables[\"Leading-order \" + reaction[\"Negative\"][\"aj\"].lower()],\n                pybamm.FullBroadcast(0, \"separator\", \"current collector\"),\n                reaction[\"Positive\"][\"s\"]\n                * variables[\"Leading-order \" + reaction[\"Positive\"][\"aj\"].lower()],\n            )\n            / self.param.gamma_e\n            for reaction in self.reactions.values()\n        )\n\n    def _get_source_terms_first_order(self, variables):\n        return sum(\n            pybamm.Concatenation(\n                reaction[\"Negative\"][\"s\"] * variables[reaction[\"Negative\"][\"aj\"]],\n                pybamm.FullBroadcast(0, \"separator\", \"current collector\"),\n                reaction[\"Positive\"][\"s\"] * variables[reaction[\"Positive\"][\"aj\"]],\n            )\n            / self.param.gamma_e\n            for reaction in self.reactions.values()\n        )",
  "def __init__(self, param, reactions, extended=False):\n        super().__init__(param, reactions)\n        self.extended = extended",
  "def get_coupled_variables(self, variables):\n\n        eps_0 = variables[\"Leading-order porosity\"]\n        c_e_0_av = variables[\"Leading-order x-averaged electrolyte concentration\"]\n        c_e = variables[\"Electrolyte concentration\"]\n        # i_e = variables[\"Electrolyte current density\"]\n        v_box_0 = variables[\"Leading-order volume-averaged velocity\"]\n        T_0 = variables[\"Leading-order cell temperature\"]\n\n        param = self.param\n\n        whole_cell = [\"negative electrode\", \"separator\", \"positive electrode\"]\n        N_e_diffusion = (\n            -(eps_0 ** param.b)\n            * pybamm.PrimaryBroadcast(param.D_e(c_e_0_av, T_0), whole_cell)\n            * pybamm.grad(c_e)\n        )\n        # N_e_migration = (param.C_e * param.t_plus) / param.gamma_e * i_e\n        # N_e_convection = c_e * v_box_0\n\n        # N_e = N_e_diffusion + N_e_migration + N_e_convection\n\n        if v_box_0.id == pybamm.Scalar(0).id:\n            N_e = N_e_diffusion\n        else:\n            N_e = N_e_diffusion + pybamm.outer(v_box_0, c_e)\n\n        variables.update(self._get_standard_flux_variables(N_e))\n\n        return variables",
  "def set_rhs(self, variables):\n        \"Composite reaction-diffusion with source terms from leading order\"\n\n        param = self.param\n\n        eps_0 = variables[\"Leading-order porosity\"]\n        deps_0_dt = variables[\"Leading-order porosity change\"]\n        c_e = variables[\"Electrolyte concentration\"]\n        N_e = variables[\"Electrolyte flux\"]\n        if self.extended is False:\n            source_terms_0 = self._get_source_terms_leading_order(variables)\n        else:\n            source_terms_0 = self._get_source_terms_first_order(variables)\n\n        self.rhs = {\n            c_e: (1 / eps_0)\n            * (-pybamm.div(N_e) / param.C_e + source_terms_0 - c_e * deps_0_dt)\n        }",
  "def _get_source_terms_leading_order(self, variables):\n        return sum(\n            pybamm.Concatenation(\n                reaction[\"Negative\"][\"s\"]\n                * variables[\"Leading-order \" + reaction[\"Negative\"][\"aj\"].lower()],\n                pybamm.FullBroadcast(0, \"separator\", \"current collector\"),\n                reaction[\"Positive\"][\"s\"]\n                * variables[\"Leading-order \" + reaction[\"Positive\"][\"aj\"].lower()],\n            )\n            / self.param.gamma_e\n            for reaction in self.reactions.values()\n        )",
  "def _get_source_terms_first_order(self, variables):\n        return sum(\n            pybamm.Concatenation(\n                reaction[\"Negative\"][\"s\"] * variables[reaction[\"Negative\"][\"aj\"]],\n                pybamm.FullBroadcast(0, \"separator\", \"current collector\"),\n                reaction[\"Positive\"][\"s\"] * variables[reaction[\"Positive\"][\"aj\"]],\n            )\n            / self.param.gamma_e\n            for reaction in self.reactions.values()\n        )",
  "class LeadingOrder(BaseModel):\n    \"\"\"Leading-order model for conservation of charge in the electrolyte\n    employing the Stefan-Maxwell constitutive equations. (Leading refers\n    to leading-order in the asymptotic reduction)\n\n    Parameters\n    ----------\n    param : parameter class\n        The parameters to use for this submodel\n    domain : str, optional\n        The domain in which the model holds\n    reactions : dict, optional\n        Dictionary of reaction terms\n\n    **Extends:** :class:`pybamm.BaseStefanMaxwellConductivity`\n    \"\"\"\n\n    def __init__(self, param, domain=None, reactions=None):\n        super().__init__(param, domain, reactions)\n\n    def get_coupled_variables(self, variables):\n        ocp_n_av = variables[\"X-averaged negative electrode open circuit potential\"]\n        eta_r_n_av = variables[\"X-averaged negative electrode reaction overpotential\"]\n        phi_s_n_av = variables[\"X-averaged negative electrode potential\"]\n        phi_e_av = phi_s_n_av - eta_r_n_av - ocp_n_av\n        return self._get_coupled_variables_from_potential(variables, phi_e_av)\n\n    def _get_coupled_variables_from_potential(self, variables, phi_e_av):\n        i_boundary_cc = variables[\"Current collector current density\"]\n\n        param = self.param\n        l_n = param.l_n\n        l_p = param.l_p\n        x_n = pybamm.standard_spatial_vars.x_n\n        x_p = pybamm.standard_spatial_vars.x_p\n\n        phi_e_n = pybamm.PrimaryBroadcast(phi_e_av, [\"negative electrode\"])\n        phi_e_s = pybamm.PrimaryBroadcast(phi_e_av, [\"separator\"])\n        phi_e_p = pybamm.PrimaryBroadcast(phi_e_av, [\"positive electrode\"])\n        phi_e = pybamm.Concatenation(phi_e_n, phi_e_s, phi_e_p)\n\n        i_e_n = pybamm.outer(i_boundary_cc, x_n / l_n)\n        i_e_s = pybamm.PrimaryBroadcast(i_boundary_cc, [\"separator\"])\n        i_e_p = pybamm.outer(i_boundary_cc, (1 - x_p) / l_p)\n        i_e = pybamm.Concatenation(i_e_n, i_e_s, i_e_p)\n\n        variables.update(self._get_standard_potential_variables(phi_e, phi_e_av))\n        variables.update(self._get_standard_current_variables(i_e))\n\n        eta_c_av = pybamm.Scalar(0)  # concentration overpotential\n        delta_phi_e_av = pybamm.Scalar(0)  # ohmic losses\n        variables.update(self._get_split_overpotential(eta_c_av, delta_phi_e_av))\n\n        return variables",
  "def __init__(self, param, domain=None, reactions=None):\n        super().__init__(param, domain, reactions)",
  "def get_coupled_variables(self, variables):\n        ocp_n_av = variables[\"X-averaged negative electrode open circuit potential\"]\n        eta_r_n_av = variables[\"X-averaged negative electrode reaction overpotential\"]\n        phi_s_n_av = variables[\"X-averaged negative electrode potential\"]\n        phi_e_av = phi_s_n_av - eta_r_n_av - ocp_n_av\n        return self._get_coupled_variables_from_potential(variables, phi_e_av)",
  "def _get_coupled_variables_from_potential(self, variables, phi_e_av):\n        i_boundary_cc = variables[\"Current collector current density\"]\n\n        param = self.param\n        l_n = param.l_n\n        l_p = param.l_p\n        x_n = pybamm.standard_spatial_vars.x_n\n        x_p = pybamm.standard_spatial_vars.x_p\n\n        phi_e_n = pybamm.PrimaryBroadcast(phi_e_av, [\"negative electrode\"])\n        phi_e_s = pybamm.PrimaryBroadcast(phi_e_av, [\"separator\"])\n        phi_e_p = pybamm.PrimaryBroadcast(phi_e_av, [\"positive electrode\"])\n        phi_e = pybamm.Concatenation(phi_e_n, phi_e_s, phi_e_p)\n\n        i_e_n = pybamm.outer(i_boundary_cc, x_n / l_n)\n        i_e_s = pybamm.PrimaryBroadcast(i_boundary_cc, [\"separator\"])\n        i_e_p = pybamm.outer(i_boundary_cc, (1 - x_p) / l_p)\n        i_e = pybamm.Concatenation(i_e_n, i_e_s, i_e_p)\n\n        variables.update(self._get_standard_potential_variables(phi_e, phi_e_av))\n        variables.update(self._get_standard_current_variables(i_e))\n\n        eta_c_av = pybamm.Scalar(0)  # concentration overpotential\n        delta_phi_e_av = pybamm.Scalar(0)  # ohmic losses\n        variables.update(self._get_split_overpotential(eta_c_av, delta_phi_e_av))\n\n        return variables",
  "class BaseModel(BaseElectrolyteConductivity):\n    \"\"\"Base class for conservation of charge in the electrolyte employing the\n    Stefan-Maxwell constitutive equations.\n\n    Parameters\n    ----------\n    param : parameter class\n        The parameters to use for this submodel\n    domain : str, optional\n        The domain in which the model holds\n    reactions : dict, optional\n        Dictionary of reaction terms\n\n    **Extends:** :class:`pybamm.electrolyte.BaseElectrolyteConductivity`\n    \"\"\"\n\n    def __init__(self, param, domain=None, reactions=None):\n        super().__init__(param, domain, reactions)\n\n    def set_boundary_conditions(self, variables):\n        phi_e = variables[\"Electrolyte potential\"]\n        self.boundary_conditions = {\n            phi_e: {\n                \"left\": (pybamm.Scalar(0), \"Neumann\"),\n                \"right\": (pybamm.Scalar(0), \"Neumann\"),\n            }\n        }",
  "def __init__(self, param, domain=None, reactions=None):\n        super().__init__(param, domain, reactions)",
  "def set_boundary_conditions(self, variables):\n        phi_e = variables[\"Electrolyte potential\"]\n        self.boundary_conditions = {\n            phi_e: {\n                \"left\": (pybamm.Scalar(0), \"Neumann\"),\n                \"right\": (pybamm.Scalar(0), \"Neumann\"),\n            }\n        }",
  "class Composite(BaseHigherOrder):\n    \"\"\"Class for conservation of charge in the electrolyte employing the\n    Stefan-Maxwell constitutive equations. (Composite refers to a composite\n    leading and first-order expression from the asymptotic reduction)\n\n    Parameters\n    ----------\n    param : parameter class\n        The parameters to use for this submodel\n    domain : str, optional\n        The domain in which the model holds\n\n    **Extends:** :class:`pybamm.electrolyte.stefan_maxwell.conductivity.BaseHigerOrder`\n    \"\"\"\n\n    def __init__(self, param, domain=None):\n        super().__init__(param, domain)\n\n    def _higher_order_macinnes_function(self, x):\n        \"Use log for composite higher order terms\"\n        return pybamm.log(x)\n\n    def unpack(self, variables):\n        \"Unpack variables and return average values\"\n        c_e_av = variables[\"X-averaged electrolyte concentration\"]\n        return c_e_av",
  "def __init__(self, param, domain=None):\n        super().__init__(param, domain)",
  "def _higher_order_macinnes_function(self, x):\n        \"Use log for composite higher order terms\"\n        return pybamm.log(x)",
  "def unpack(self, variables):\n        \"Unpack variables and return average values\"\n        c_e_av = variables[\"X-averaged electrolyte concentration\"]\n        return c_e_av",
  "class FirstOrder(BaseHigherOrder):\n    \"\"\"Class for conservation of charge in the electrolyte employing the\n    Stefan-Maxwell constitutive equations. (First order refers to a first-order\n    expression from the asymptotic reduction)\n\n    Parameters\n    ----------\n    param : parameter class\n        The parameters to use for this submodel\n    domain : str, optional\n        The domain in which the model holds\n\n    **Extends:** :class:`pybamm.electrolyte.stefan_maxwell.conductivity.BaseHigerOrder`\n    \"\"\"\n\n    def __init__(self, param, domain=None):\n        super().__init__(param, domain)\n\n    def _higher_order_macinnes_function(self, x):\n        \"Linear higher order terms\"\n        return x\n\n    def unpack(self, variables):\n        \"Unpack variables and return leading-order x-averaged values\"\n        c_e_av = variables[\"Leading-order x-averaged electrolyte concentration\"]\n        return c_e_av",
  "def __init__(self, param, domain=None):\n        super().__init__(param, domain)",
  "def _higher_order_macinnes_function(self, x):\n        \"Linear higher order terms\"\n        return x",
  "def unpack(self, variables):\n        \"Unpack variables and return leading-order x-averaged values\"\n        c_e_av = variables[\"Leading-order x-averaged electrolyte concentration\"]\n        return c_e_av",
  "class Full(BaseModel):\n    \"\"\"Full model for conservation of charge in the electrolyte employing the\n    Stefan-Maxwell constitutive equations. (Full refers to unreduced by\n    asymptotic methods)\n\n    Parameters\n    ----------\n    param : parameter class\n        The parameters to use for this submodel\n    reactions : dict\n        Dictionary of reaction terms\n\n    **Extends:** :class:`pybamm.BaseStefanMaxwellConductivity`\n    \"\"\"\n\n    def __init__(self, param, reactions):\n        super().__init__(param, reactions=reactions)\n\n    def get_fundamental_variables(self):\n        phi_e = pybamm.standard_variables.phi_e\n        phi_e_av = pybamm.x_average(phi_e)\n\n        variables = self._get_standard_potential_variables(phi_e, phi_e_av)\n        return variables\n\n    def get_coupled_variables(self, variables):\n        param = self.param\n        T = variables[\"Cell temperature\"]\n        eps = variables[\"Porosity\"]\n        c_e = variables[\"Electrolyte concentration\"]\n        phi_e = variables[\"Electrolyte potential\"]\n\n        i_e = (param.kappa_e(c_e, T) * (eps ** param.b) * param.gamma_e / param.C_e) * (\n            param.chi(c_e) * pybamm.grad(c_e) / c_e - pybamm.grad(phi_e)\n        )\n\n        variables.update(self._get_standard_current_variables(i_e))\n\n        return variables\n\n    def set_algebraic(self, variables):\n        phi_e = variables[\"Electrolyte potential\"]\n        i_e = variables[\"Electrolyte current density\"]\n        sum_j = sum(\n            pybamm.Concatenation(\n                variables[reaction[\"Negative\"][\"aj\"]],\n                pybamm.FullBroadcast(0, \"separator\", \"current collector\"),\n                variables[reaction[\"Positive\"][\"aj\"]],\n            )\n            for reaction in self.reactions.values()\n        )\n\n        self.algebraic = {phi_e: pybamm.div(i_e) - sum_j}\n\n    def set_initial_conditions(self, variables):\n        phi_e = variables[\"Electrolyte potential\"]\n        T_ref = self.param.T_ref\n        self.initial_conditions = {phi_e: -self.param.U_n(self.param.c_n_init, T_ref)}\n\n    @property\n    def default_solver(self):\n        \"\"\"\n        Create and return the default solver for this model\n        \"\"\"\n        return pybamm.ScikitsDaeSolver()",
  "def __init__(self, param, reactions):\n        super().__init__(param, reactions=reactions)",
  "def get_fundamental_variables(self):\n        phi_e = pybamm.standard_variables.phi_e\n        phi_e_av = pybamm.x_average(phi_e)\n\n        variables = self._get_standard_potential_variables(phi_e, phi_e_av)\n        return variables",
  "def get_coupled_variables(self, variables):\n        param = self.param\n        T = variables[\"Cell temperature\"]\n        eps = variables[\"Porosity\"]\n        c_e = variables[\"Electrolyte concentration\"]\n        phi_e = variables[\"Electrolyte potential\"]\n\n        i_e = (param.kappa_e(c_e, T) * (eps ** param.b) * param.gamma_e / param.C_e) * (\n            param.chi(c_e) * pybamm.grad(c_e) / c_e - pybamm.grad(phi_e)\n        )\n\n        variables.update(self._get_standard_current_variables(i_e))\n\n        return variables",
  "def set_algebraic(self, variables):\n        phi_e = variables[\"Electrolyte potential\"]\n        i_e = variables[\"Electrolyte current density\"]\n        sum_j = sum(\n            pybamm.Concatenation(\n                variables[reaction[\"Negative\"][\"aj\"]],\n                pybamm.FullBroadcast(0, \"separator\", \"current collector\"),\n                variables[reaction[\"Positive\"][\"aj\"]],\n            )\n            for reaction in self.reactions.values()\n        )\n\n        self.algebraic = {phi_e: pybamm.div(i_e) - sum_j}",
  "def set_initial_conditions(self, variables):\n        phi_e = variables[\"Electrolyte potential\"]\n        T_ref = self.param.T_ref\n        self.initial_conditions = {phi_e: -self.param.U_n(self.param.c_n_init, T_ref)}",
  "def default_solver(self):\n        \"\"\"\n        Create and return the default solver for this model\n        \"\"\"\n        return pybamm.ScikitsDaeSolver()",
  "class BaseHigherOrder(BaseModel):\n    \"\"\"Base class for conservation of charge in the electrolyte employing the\n    Stefan-Maxwell constitutive equations.\n\n    Parameters\n    ----------\n    param : parameter class\n        The parameters to use for this submodel\n    domain : str, optional\n        The domain in which the model holds\n\n    **Extends:** :class:`pybamm.electrolyte.stefan_maxwell.conductivity.BaseModel`\n    \"\"\"\n\n    def __init__(self, param, domain=None):\n        super().__init__(param, domain)\n\n    def _higher_order_macinnes_function(self, x):\n        \"Function to differentiate between composite and first-order models\"\n        raise NotImplementedError\n\n    def unpack(self, variables):\n        raise NotImplementedError\n\n    def get_coupled_variables(self, variables):\n        # NOTE: the heavy use of Broadcast and outer in this method is mainly so\n        # that products are handled correctly when using 1 or 2D current collector\n        # models. In standard 1D battery models outer behaves as a normal multiply.\n        # In the future, multiply will automatically handle switching between\n        # normal multiply and outer products as appropriate.\n\n        c_e_av = self.unpack(variables)\n\n        i_boundary_cc_0 = variables[\"Leading-order current collector current density\"]\n        c_e = variables[\"Electrolyte concentration\"]\n        delta_phi_n_av = variables[\n            \"X-averaged negative electrode surface potential difference\"\n        ]\n        phi_s_n_av = variables[\"X-averaged negative electrode potential\"]\n        eps_n_av = variables[\"Leading-order x-averaged negative electrode porosity\"]\n        eps_s_av = variables[\"Leading-order x-averaged separator porosity\"]\n        eps_p_av = variables[\"Leading-order x-averaged positive electrode porosity\"]\n\n        # Note: here we want the average of the temperature over the negative\n        # electrode, separator and positive electrode (not including the current\n        # collectors)\n        T = variables[\"Cell temperature\"]\n        T_av = pybamm.x_average(T)\n\n        c_e_n, c_e_s, c_e_p = c_e.orphans\n\n        param = self.param\n        l_n = param.l_n\n        l_p = param.l_p\n        x_n = pybamm.standard_spatial_vars.x_n\n        x_s = pybamm.standard_spatial_vars.x_s\n        x_p = pybamm.standard_spatial_vars.x_p\n\n        # bulk conductivities\n        kappa_n_av = param.kappa_e(c_e_av, T_av) * eps_n_av ** param.b_n\n        kappa_s_av = param.kappa_e(c_e_av, T_av) * eps_s_av ** param.b_s\n        kappa_p_av = param.kappa_e(c_e_av, T_av) * eps_p_av ** param.b_p\n\n        chi_av = param.chi(c_e_av)\n        if chi_av.domain == [\"current collector\"]:\n            chi_av_n = pybamm.PrimaryBroadcast(chi_av, \"negative electrode\")\n            chi_av_s = pybamm.PrimaryBroadcast(chi_av, \"separator\")\n            chi_av_p = pybamm.PrimaryBroadcast(chi_av, \"positive electrode\")\n        else:\n            chi_av_n = chi_av\n            chi_av_s = chi_av\n            chi_av_p = chi_av\n\n        # electrolyte current\n        i_e_n = pybamm.outer(i_boundary_cc_0, x_n / l_n)\n        i_e_s = pybamm.PrimaryBroadcast(i_boundary_cc_0, \"separator\")\n        i_e_p = pybamm.outer(i_boundary_cc_0, (1 - x_p) / l_p)\n        i_e = pybamm.Concatenation(i_e_n, i_e_s, i_e_p)\n\n        # electrolyte potential\n        phi_e_const = (\n            -delta_phi_n_av\n            + phi_s_n_av\n            - (\n                chi_av\n                * pybamm.x_average(\n                    self._higher_order_macinnes_function(\n                        c_e_n / pybamm.PrimaryBroadcast(c_e_av, \"negative electrode\")\n                    )\n                )\n            )\n            - (\n                (i_boundary_cc_0 * param.C_e * l_n / param.gamma_e)\n                * (1 / (3 * kappa_n_av) - 1 / kappa_s_av)\n            )\n        )\n\n        phi_e_n = (\n            pybamm.PrimaryBroadcast(phi_e_const, \"negative electrode\")\n            + (\n                chi_av_n\n                * self._higher_order_macinnes_function(\n                    c_e_n / pybamm.PrimaryBroadcast(c_e_av, \"negative electrode\")\n                )\n            )\n            - pybamm.outer(\n                i_boundary_cc_0 * (param.C_e / param.gamma_e) / kappa_n_av,\n                (x_n ** 2 - l_n ** 2) / (2 * l_n),\n            )\n            - pybamm.PrimaryBroadcast(\n                i_boundary_cc_0 * l_n * (param.C_e / param.gamma_e) / kappa_s_av,\n                \"negative electrode\",\n            )\n        )\n\n        phi_e_s = (\n            pybamm.PrimaryBroadcast(phi_e_const, \"separator\")\n            + (\n                chi_av_s\n                * self._higher_order_macinnes_function(\n                    c_e_s / pybamm.PrimaryBroadcast(c_e_av, \"separator\")\n                )\n            )\n            - pybamm.outer(\n                i_boundary_cc_0 * param.C_e / param.gamma_e / kappa_s_av, x_s\n            )\n        )\n\n        phi_e_p = (\n            pybamm.PrimaryBroadcast(phi_e_const, \"positive electrode\")\n            + (\n                chi_av_p\n                * self._higher_order_macinnes_function(\n                    c_e_p / pybamm.PrimaryBroadcast(c_e_av, \"positive electrode\")\n                )\n            )\n            - pybamm.outer(\n                i_boundary_cc_0 * (param.C_e / param.gamma_e) / kappa_p_av,\n                (x_p * (2 - x_p) + l_p ** 2 - 1) / (2 * l_p),\n            )\n            - pybamm.PrimaryBroadcast(\n                i_boundary_cc_0 * (1 - l_p) * (param.C_e / param.gamma_e) / kappa_s_av,\n                \"positive electrode\",\n            )\n        )\n\n        phi_e = pybamm.Concatenation(phi_e_n, phi_e_s, phi_e_p)\n        phi_e_av = pybamm.x_average(phi_e)\n\n        # concentration overpotential\n        eta_c_av = chi_av * (\n            pybamm.x_average(\n                self._higher_order_macinnes_function(\n                    c_e_p / pybamm.PrimaryBroadcast(c_e_av, \"positive electrode\")\n                )\n            )\n            - pybamm.x_average(\n                self._higher_order_macinnes_function(\n                    c_e_n / pybamm.PrimaryBroadcast(c_e_av, \"negative electrode\")\n                )\n            )\n        )\n\n        # average electrolyte ohmic losses\n        delta_phi_e_av = -(param.C_e * i_boundary_cc_0 / param.gamma_e) * (\n            param.l_n / (3 * kappa_n_av)\n            + param.l_s / (kappa_s_av)\n            + param.l_p / (3 * kappa_p_av)\n        )\n\n        variables.update(self._get_standard_potential_variables(phi_e, phi_e_av))\n        variables.update(self._get_standard_current_variables(i_e))\n        variables.update(self._get_split_overpotential(eta_c_av, delta_phi_e_av))\n\n        return variables",
  "def __init__(self, param, domain=None):\n        super().__init__(param, domain)",
  "def _higher_order_macinnes_function(self, x):\n        \"Function to differentiate between composite and first-order models\"\n        raise NotImplementedError",
  "def unpack(self, variables):\n        raise NotImplementedError",
  "def get_coupled_variables(self, variables):\n        # NOTE: the heavy use of Broadcast and outer in this method is mainly so\n        # that products are handled correctly when using 1 or 2D current collector\n        # models. In standard 1D battery models outer behaves as a normal multiply.\n        # In the future, multiply will automatically handle switching between\n        # normal multiply and outer products as appropriate.\n\n        c_e_av = self.unpack(variables)\n\n        i_boundary_cc_0 = variables[\"Leading-order current collector current density\"]\n        c_e = variables[\"Electrolyte concentration\"]\n        delta_phi_n_av = variables[\n            \"X-averaged negative electrode surface potential difference\"\n        ]\n        phi_s_n_av = variables[\"X-averaged negative electrode potential\"]\n        eps_n_av = variables[\"Leading-order x-averaged negative electrode porosity\"]\n        eps_s_av = variables[\"Leading-order x-averaged separator porosity\"]\n        eps_p_av = variables[\"Leading-order x-averaged positive electrode porosity\"]\n\n        # Note: here we want the average of the temperature over the negative\n        # electrode, separator and positive electrode (not including the current\n        # collectors)\n        T = variables[\"Cell temperature\"]\n        T_av = pybamm.x_average(T)\n\n        c_e_n, c_e_s, c_e_p = c_e.orphans\n\n        param = self.param\n        l_n = param.l_n\n        l_p = param.l_p\n        x_n = pybamm.standard_spatial_vars.x_n\n        x_s = pybamm.standard_spatial_vars.x_s\n        x_p = pybamm.standard_spatial_vars.x_p\n\n        # bulk conductivities\n        kappa_n_av = param.kappa_e(c_e_av, T_av) * eps_n_av ** param.b_n\n        kappa_s_av = param.kappa_e(c_e_av, T_av) * eps_s_av ** param.b_s\n        kappa_p_av = param.kappa_e(c_e_av, T_av) * eps_p_av ** param.b_p\n\n        chi_av = param.chi(c_e_av)\n        if chi_av.domain == [\"current collector\"]:\n            chi_av_n = pybamm.PrimaryBroadcast(chi_av, \"negative electrode\")\n            chi_av_s = pybamm.PrimaryBroadcast(chi_av, \"separator\")\n            chi_av_p = pybamm.PrimaryBroadcast(chi_av, \"positive electrode\")\n        else:\n            chi_av_n = chi_av\n            chi_av_s = chi_av\n            chi_av_p = chi_av\n\n        # electrolyte current\n        i_e_n = pybamm.outer(i_boundary_cc_0, x_n / l_n)\n        i_e_s = pybamm.PrimaryBroadcast(i_boundary_cc_0, \"separator\")\n        i_e_p = pybamm.outer(i_boundary_cc_0, (1 - x_p) / l_p)\n        i_e = pybamm.Concatenation(i_e_n, i_e_s, i_e_p)\n\n        # electrolyte potential\n        phi_e_const = (\n            -delta_phi_n_av\n            + phi_s_n_av\n            - (\n                chi_av\n                * pybamm.x_average(\n                    self._higher_order_macinnes_function(\n                        c_e_n / pybamm.PrimaryBroadcast(c_e_av, \"negative electrode\")\n                    )\n                )\n            )\n            - (\n                (i_boundary_cc_0 * param.C_e * l_n / param.gamma_e)\n                * (1 / (3 * kappa_n_av) - 1 / kappa_s_av)\n            )\n        )\n\n        phi_e_n = (\n            pybamm.PrimaryBroadcast(phi_e_const, \"negative electrode\")\n            + (\n                chi_av_n\n                * self._higher_order_macinnes_function(\n                    c_e_n / pybamm.PrimaryBroadcast(c_e_av, \"negative electrode\")\n                )\n            )\n            - pybamm.outer(\n                i_boundary_cc_0 * (param.C_e / param.gamma_e) / kappa_n_av,\n                (x_n ** 2 - l_n ** 2) / (2 * l_n),\n            )\n            - pybamm.PrimaryBroadcast(\n                i_boundary_cc_0 * l_n * (param.C_e / param.gamma_e) / kappa_s_av,\n                \"negative electrode\",\n            )\n        )\n\n        phi_e_s = (\n            pybamm.PrimaryBroadcast(phi_e_const, \"separator\")\n            + (\n                chi_av_s\n                * self._higher_order_macinnes_function(\n                    c_e_s / pybamm.PrimaryBroadcast(c_e_av, \"separator\")\n                )\n            )\n            - pybamm.outer(\n                i_boundary_cc_0 * param.C_e / param.gamma_e / kappa_s_av, x_s\n            )\n        )\n\n        phi_e_p = (\n            pybamm.PrimaryBroadcast(phi_e_const, \"positive electrode\")\n            + (\n                chi_av_p\n                * self._higher_order_macinnes_function(\n                    c_e_p / pybamm.PrimaryBroadcast(c_e_av, \"positive electrode\")\n                )\n            )\n            - pybamm.outer(\n                i_boundary_cc_0 * (param.C_e / param.gamma_e) / kappa_p_av,\n                (x_p * (2 - x_p) + l_p ** 2 - 1) / (2 * l_p),\n            )\n            - pybamm.PrimaryBroadcast(\n                i_boundary_cc_0 * (1 - l_p) * (param.C_e / param.gamma_e) / kappa_s_av,\n                \"positive electrode\",\n            )\n        )\n\n        phi_e = pybamm.Concatenation(phi_e_n, phi_e_s, phi_e_p)\n        phi_e_av = pybamm.x_average(phi_e)\n\n        # concentration overpotential\n        eta_c_av = chi_av * (\n            pybamm.x_average(\n                self._higher_order_macinnes_function(\n                    c_e_p / pybamm.PrimaryBroadcast(c_e_av, \"positive electrode\")\n                )\n            )\n            - pybamm.x_average(\n                self._higher_order_macinnes_function(\n                    c_e_n / pybamm.PrimaryBroadcast(c_e_av, \"negative electrode\")\n                )\n            )\n        )\n\n        # average electrolyte ohmic losses\n        delta_phi_e_av = -(param.C_e * i_boundary_cc_0 / param.gamma_e) * (\n            param.l_n / (3 * kappa_n_av)\n            + param.l_s / (kappa_s_av)\n            + param.l_p / (3 * kappa_p_av)\n        )\n\n        variables.update(self._get_standard_potential_variables(phi_e, phi_e_av))\n        variables.update(self._get_standard_current_variables(i_e))\n        variables.update(self._get_split_overpotential(eta_c_av, delta_phi_e_av))\n\n        return variables",
  "class BaseModel(BaseStefanMaxwellConductivity):\n    \"\"\"Base class for conservation of charge in the electrolyte employing the\n    Stefan-Maxwell constitutive equations employing the surface potential difference\n    formulation.\n\n    Parameters\n    ----------\n    param : parameter class\n        The parameters to use for this submodel\n    domain : str\n        The domain in which the model holds\n    reactions : dict\n        Dictionary of reaction terms\n\n    **Extends:** :class:`pybamm.electrolyte.stefan_maxwell.conductivity.BaseModel`\n    \"\"\"\n\n    def __init__(self, param, domain, reactions):\n        super().__init__(param, domain, reactions)\n\n    def get_fundamental_variables(self):\n        if self.domain == \"Negative\":\n            delta_phi = pybamm.standard_variables.delta_phi_n\n        elif self.domain == \"Separator\":\n            return {}\n        elif self.domain == \"Positive\":\n            delta_phi = pybamm.standard_variables.delta_phi_p\n\n        variables = self._get_standard_surface_potential_difference_variables(delta_phi)\n\n        return variables\n\n    def set_initial_conditions(self, variables):\n        if self.domain == \"Separator\":\n            return\n\n        delta_phi_e = variables[self.domain + \" electrode surface potential difference\"]\n        if self.domain == \"Negative\":\n            delta_phi_e_init = self.param.U_n(self.param.c_n_init, self.param.T_ref)\n        elif self.domain == \"Positive\":\n            delta_phi_e_init = self.param.U_p(self.param.c_p_init, self.param.T_ref)\n\n        self.initial_conditions = {delta_phi_e: delta_phi_e_init}\n\n    def get_coupled_variables(self, variables):\n\n        if self.domain == \"Negative\":\n            variables.update(self._get_neg_pos_coupled_variables(variables))\n        elif self.domain == \"Separator\":\n            variables.update(self._get_sep_coupled_variables(variables))\n        elif self.domain == \"Positive\":\n            variables.update(self._get_neg_pos_coupled_variables(variables))\n            variables.update(self._get_whole_cell_variables(variables))\n\n        return variables\n\n    def set_boundary_conditions(self, variables):\n        if self.domain == \"Separator\":\n            return None\n\n        param = self.param\n\n        conductivity, sigma_eff = self._get_conductivities(variables)\n        i_boundary_cc = variables[\"Current collector current density\"]\n        c_e = variables[self.domain + \" electrolyte concentration\"]\n        delta_phi = variables[self.domain + \" electrode surface potential difference\"]\n\n        if self.domain == \"Negative\":\n            c_e_flux = pybamm.BoundaryGradient(c_e, \"right\")\n            flux_left = -i_boundary_cc * pybamm.BoundaryValue(1 / sigma_eff, \"left\")\n            flux_right = (\n                (i_boundary_cc / pybamm.BoundaryValue(conductivity, \"right\"))\n                - pybamm.BoundaryValue(param.chi(c_e) / c_e, \"right\") * c_e_flux\n                - i_boundary_cc * pybamm.BoundaryValue(1 / sigma_eff, \"right\")\n            )\n\n            lbc = (flux_left, \"Neumann\")\n            rbc = (flux_right, \"Neumann\")\n            lbc_c_e = (pybamm.Scalar(0), \"Neumann\")\n            rbc_c_e = (c_e_flux, \"Neumann\")\n\n        elif self.domain == \"Positive\":\n            c_e_flux = pybamm.BoundaryGradient(c_e, \"left\")\n            flux_left = (\n                (i_boundary_cc / pybamm.BoundaryValue(conductivity, \"left\"))\n                - pybamm.BoundaryValue(param.chi(c_e) / c_e, \"left\") * c_e_flux\n                - i_boundary_cc * pybamm.BoundaryValue(1 / sigma_eff, \"left\")\n            )\n            flux_right = -i_boundary_cc * pybamm.BoundaryValue(1 / sigma_eff, \"right\")\n\n            lbc = (flux_left, \"Neumann\")\n            rbc = (flux_right, \"Neumann\")\n            lbc_c_e = (c_e_flux, \"Neumann\")\n            rbc_c_e = (pybamm.Scalar(0), \"Neumann\")\n\n        # TODO: check if we still need the boundary conditions for c_e, once we have\n        # internal boundary conditions\n        self.boundary_conditions = {\n            delta_phi: {\"left\": lbc, \"right\": rbc},\n            c_e: {\"left\": lbc_c_e, \"right\": rbc_c_e},\n        }\n\n        if self.domain == \"Negative\":\n            phi_e = variables[\"Electrolyte potential\"]\n            self.boundary_conditions.update(\n                {\n                    phi_e: {\n                        \"left\": (pybamm.Scalar(0), \"Neumann\"),\n                        \"right\": (pybamm.Scalar(0), \"Neumann\"),\n                    }\n                }\n            )\n\n    def _get_conductivities(self, variables):\n        param = self.param\n        eps = variables[self.domain + \" electrode porosity\"]\n        c_e = variables[self.domain + \" electrolyte concentration\"]\n        T = variables[self.domain + \" electrode temperature\"]\n        if self.domain == \"Negative\":\n            sigma = param.sigma_n\n            b = param.b_n\n        elif self.domain == \"Positive\":\n            sigma = param.sigma_p\n            b = param.b_p\n        sigma_eff = sigma * (1 - eps) ** b\n        conductivity = (\n            param.kappa_e(c_e, T)\n            * (eps ** b)\n            / (param.C_e / param.gamma_e + param.kappa_e(c_e, T) / sigma_eff)\n        )\n\n        return conductivity, sigma_eff\n\n    def _get_neg_pos_coupled_variables(self, variables):\n        \"\"\"\n        A private function to get the coupled variables when the domain is 'Negative'\n        or 'Positive'.\n        \"\"\"\n\n        param = self.param\n\n        conductivity, sigma_eff = self._get_conductivities(variables)\n        i_boundary_cc = variables[\"Current collector current density\"]\n        c_e = variables[self.domain + \" electrolyte concentration\"]\n        delta_phi = variables[self.domain + \" electrode surface potential difference\"]\n\n        i_e = conductivity * (\n            (param.chi(c_e) / c_e) * pybamm.grad(c_e)\n            + pybamm.grad(delta_phi)\n            + pybamm.PrimaryBroadcast(i_boundary_cc, self.domain_for_broadcast)\n            / sigma_eff\n        )\n        variables.update(self._get_domain_current_variables(i_e))\n\n        # TODO: Expression can be written in a form which does not require phi_s and\n        # so avoid this hack.\n        phi_s = self.nasty_hack_to_get_phi_s(variables)\n        phi_e = phi_s - delta_phi\n\n        variables.update(self._get_domain_potential_variables(phi_e))\n\n        return variables\n\n    def _get_sep_coupled_variables(self, variables):\n        \"\"\"\n        A private function to get the coupled variables when the domain is 'Separator'.\n        \"\"\"\n\n        param = self.param\n        x_s = pybamm.standard_spatial_vars.x_s\n\n        i_boundary_cc = variables[\"Current collector current density\"]\n        c_e_s = variables[\"Separator electrolyte concentration\"]\n        phi_e_n = variables[\"Negative electrolyte potential\"]\n        eps_s = variables[\"Separator porosity\"]\n        T = variables[\"Separator temperature\"]\n\n        chi_e_s = param.chi(c_e_s)\n        kappa_s_eff = param.kappa_e(c_e_s, T) * (eps_s ** param.b_s)\n\n        phi_e_s = pybamm.PrimaryBroadcast(\n            pybamm.boundary_value(phi_e_n, \"right\"), \"separator\"\n        ) + pybamm.IndefiniteIntegral(\n            chi_e_s / c_e_s * pybamm.grad(c_e_s)\n            - param.C_e\n            * pybamm.PrimaryBroadcast(i_boundary_cc, self.domain_for_broadcast)\n            / kappa_s_eff,\n            x_s,\n        )\n\n        i_e_s = pybamm.PrimaryBroadcast(i_boundary_cc, \"separator\")\n\n        variables.update(self._get_domain_potential_variables(phi_e_s))\n        variables.update(self._get_domain_current_variables(i_e_s))\n\n        # Update boundary conditions (for indefinite integral)\n        self.boundary_conditions[c_e_s] = {\n            \"left\": (pybamm.BoundaryGradient(c_e_s, \"left\"), \"Neumann\"),\n            \"right\": (pybamm.BoundaryGradient(c_e_s, \"right\"), \"Neumann\"),\n        }\n\n        return variables\n\n    def nasty_hack_to_get_phi_s(self, variables):\n        \"This restates what is already in the electrode submodel which we should not do\"\n\n        param = self.param\n\n        x_n = pybamm.standard_spatial_vars.x_n\n        x_p = pybamm.standard_spatial_vars.x_p\n        eps = variables[self.domain + \" electrode porosity\"]\n        i_boundary_cc = variables[\"Current collector current density\"]\n        i_e = variables[self.domain + \" electrolyte current density\"]\n\n        i_s = pybamm.PrimaryBroadcast(i_boundary_cc, self.domain_for_broadcast) - i_e\n\n        if self.domain == \"Negative\":\n            conductivity = param.sigma_n * (1 - eps) ** param.b_n\n            phi_s = -pybamm.IndefiniteIntegral(i_s / conductivity, x_n)\n\n        elif self.domain == \"Positive\":\n\n            phi_e_s = variables[\"Separator electrolyte potential\"]\n            delta_phi_p = variables[\"Positive electrode surface potential difference\"]\n\n            conductivity = param.sigma_p * (1 - eps) ** param.b_p\n\n            phi_s = -pybamm.IndefiniteIntegral(\n                i_s / conductivity, x_p\n            ) + pybamm.PrimaryBroadcast(\n                pybamm.boundary_value(phi_e_s, \"right\")\n                + pybamm.boundary_value(delta_phi_p, \"left\"),\n                \"positive electrode\",\n            )\n\n        return phi_s",
  "class FullAlgebraic(BaseModel):\n    \"\"\"Full model for conservation of charge in the electrolyte employing the\n    Stefan-Maxwell constitutive equations. (Full refers to unreduced by\n    asymptotic methods)\n\n    Parameters\n    ----------\n    param : parameter class\n        The parameters to use for this submodel\n\n\n     **Extends:** :class:`pybamm.electrolyte.stefan_maxwell.conductivity.surface_potential_form.BaseFull`\n    \"\"\"  # noqa: E501\n\n    def __init__(self, param, domain, reactions):\n        super().__init__(param, domain, reactions)\n\n    def set_algebraic(self, variables):\n        if self.domain == \"Separator\":\n            return\n\n        delta_phi = variables[self.domain + \" electrode surface potential difference\"]\n        i_e = variables[self.domain + \" electrolyte current density\"]\n        sum_j = sum(\n            variables[reaction[self.domain][\"aj\"]]\n            for reaction in self.reactions.values()\n        )\n        self.algebraic[delta_phi] = pybamm.div(i_e) - sum_j",
  "class FullDifferential(BaseModel):\n    \"\"\"Full model for conservation of charge in the electrolyte employing the\n    Stefan-Maxwell constitutive equations and where capacitance is present.\n    (Full refers to unreduced by asymptotic methods)\n\n    Parameters\n    ----------\n    param : parameter class\n        The parameters to use for this submodel\n\n\n    **Extends:** :class:`pybamm.electrolyte.stefan_maxwell.conductivity.surface_potential_form.BaseFull`\n\n    \"\"\"  # noqa: E501\n\n    def __init__(self, param, domain, reactions):\n        super().__init__(param, domain, reactions)\n\n    def set_rhs(self, variables):\n        if self.domain == \"Separator\":\n            return\n\n        if self.domain == \"Negative\":\n            C_dl = self.param.C_dl_n\n        elif self.domain == \"Positive\":\n            C_dl = self.param.C_dl_p\n\n        delta_phi = variables[self.domain + \" electrode surface potential difference\"]\n        i_e = variables[self.domain + \" electrolyte current density\"]\n        sum_j = sum(\n            variables[reaction[self.domain][\"aj\"]]\n            for reaction in self.reactions.values()\n        )\n\n        self.rhs[delta_phi] = 1 / C_dl * (pybamm.div(i_e) - sum_j)",
  "def __init__(self, param, domain, reactions):\n        super().__init__(param, domain, reactions)",
  "def get_fundamental_variables(self):\n        if self.domain == \"Negative\":\n            delta_phi = pybamm.standard_variables.delta_phi_n\n        elif self.domain == \"Separator\":\n            return {}\n        elif self.domain == \"Positive\":\n            delta_phi = pybamm.standard_variables.delta_phi_p\n\n        variables = self._get_standard_surface_potential_difference_variables(delta_phi)\n\n        return variables",
  "def set_initial_conditions(self, variables):\n        if self.domain == \"Separator\":\n            return\n\n        delta_phi_e = variables[self.domain + \" electrode surface potential difference\"]\n        if self.domain == \"Negative\":\n            delta_phi_e_init = self.param.U_n(self.param.c_n_init, self.param.T_ref)\n        elif self.domain == \"Positive\":\n            delta_phi_e_init = self.param.U_p(self.param.c_p_init, self.param.T_ref)\n\n        self.initial_conditions = {delta_phi_e: delta_phi_e_init}",
  "def get_coupled_variables(self, variables):\n\n        if self.domain == \"Negative\":\n            variables.update(self._get_neg_pos_coupled_variables(variables))\n        elif self.domain == \"Separator\":\n            variables.update(self._get_sep_coupled_variables(variables))\n        elif self.domain == \"Positive\":\n            variables.update(self._get_neg_pos_coupled_variables(variables))\n            variables.update(self._get_whole_cell_variables(variables))\n\n        return variables",
  "def set_boundary_conditions(self, variables):\n        if self.domain == \"Separator\":\n            return None\n\n        param = self.param\n\n        conductivity, sigma_eff = self._get_conductivities(variables)\n        i_boundary_cc = variables[\"Current collector current density\"]\n        c_e = variables[self.domain + \" electrolyte concentration\"]\n        delta_phi = variables[self.domain + \" electrode surface potential difference\"]\n\n        if self.domain == \"Negative\":\n            c_e_flux = pybamm.BoundaryGradient(c_e, \"right\")\n            flux_left = -i_boundary_cc * pybamm.BoundaryValue(1 / sigma_eff, \"left\")\n            flux_right = (\n                (i_boundary_cc / pybamm.BoundaryValue(conductivity, \"right\"))\n                - pybamm.BoundaryValue(param.chi(c_e) / c_e, \"right\") * c_e_flux\n                - i_boundary_cc * pybamm.BoundaryValue(1 / sigma_eff, \"right\")\n            )\n\n            lbc = (flux_left, \"Neumann\")\n            rbc = (flux_right, \"Neumann\")\n            lbc_c_e = (pybamm.Scalar(0), \"Neumann\")\n            rbc_c_e = (c_e_flux, \"Neumann\")\n\n        elif self.domain == \"Positive\":\n            c_e_flux = pybamm.BoundaryGradient(c_e, \"left\")\n            flux_left = (\n                (i_boundary_cc / pybamm.BoundaryValue(conductivity, \"left\"))\n                - pybamm.BoundaryValue(param.chi(c_e) / c_e, \"left\") * c_e_flux\n                - i_boundary_cc * pybamm.BoundaryValue(1 / sigma_eff, \"left\")\n            )\n            flux_right = -i_boundary_cc * pybamm.BoundaryValue(1 / sigma_eff, \"right\")\n\n            lbc = (flux_left, \"Neumann\")\n            rbc = (flux_right, \"Neumann\")\n            lbc_c_e = (c_e_flux, \"Neumann\")\n            rbc_c_e = (pybamm.Scalar(0), \"Neumann\")\n\n        # TODO: check if we still need the boundary conditions for c_e, once we have\n        # internal boundary conditions\n        self.boundary_conditions = {\n            delta_phi: {\"left\": lbc, \"right\": rbc},\n            c_e: {\"left\": lbc_c_e, \"right\": rbc_c_e},\n        }\n\n        if self.domain == \"Negative\":\n            phi_e = variables[\"Electrolyte potential\"]\n            self.boundary_conditions.update(\n                {\n                    phi_e: {\n                        \"left\": (pybamm.Scalar(0), \"Neumann\"),\n                        \"right\": (pybamm.Scalar(0), \"Neumann\"),\n                    }\n                }\n            )",
  "def _get_conductivities(self, variables):\n        param = self.param\n        eps = variables[self.domain + \" electrode porosity\"]\n        c_e = variables[self.domain + \" electrolyte concentration\"]\n        T = variables[self.domain + \" electrode temperature\"]\n        if self.domain == \"Negative\":\n            sigma = param.sigma_n\n            b = param.b_n\n        elif self.domain == \"Positive\":\n            sigma = param.sigma_p\n            b = param.b_p\n        sigma_eff = sigma * (1 - eps) ** b\n        conductivity = (\n            param.kappa_e(c_e, T)\n            * (eps ** b)\n            / (param.C_e / param.gamma_e + param.kappa_e(c_e, T) / sigma_eff)\n        )\n\n        return conductivity, sigma_eff",
  "def _get_neg_pos_coupled_variables(self, variables):\n        \"\"\"\n        A private function to get the coupled variables when the domain is 'Negative'\n        or 'Positive'.\n        \"\"\"\n\n        param = self.param\n\n        conductivity, sigma_eff = self._get_conductivities(variables)\n        i_boundary_cc = variables[\"Current collector current density\"]\n        c_e = variables[self.domain + \" electrolyte concentration\"]\n        delta_phi = variables[self.domain + \" electrode surface potential difference\"]\n\n        i_e = conductivity * (\n            (param.chi(c_e) / c_e) * pybamm.grad(c_e)\n            + pybamm.grad(delta_phi)\n            + pybamm.PrimaryBroadcast(i_boundary_cc, self.domain_for_broadcast)\n            / sigma_eff\n        )\n        variables.update(self._get_domain_current_variables(i_e))\n\n        # TODO: Expression can be written in a form which does not require phi_s and\n        # so avoid this hack.\n        phi_s = self.nasty_hack_to_get_phi_s(variables)\n        phi_e = phi_s - delta_phi\n\n        variables.update(self._get_domain_potential_variables(phi_e))\n\n        return variables",
  "def _get_sep_coupled_variables(self, variables):\n        \"\"\"\n        A private function to get the coupled variables when the domain is 'Separator'.\n        \"\"\"\n\n        param = self.param\n        x_s = pybamm.standard_spatial_vars.x_s\n\n        i_boundary_cc = variables[\"Current collector current density\"]\n        c_e_s = variables[\"Separator electrolyte concentration\"]\n        phi_e_n = variables[\"Negative electrolyte potential\"]\n        eps_s = variables[\"Separator porosity\"]\n        T = variables[\"Separator temperature\"]\n\n        chi_e_s = param.chi(c_e_s)\n        kappa_s_eff = param.kappa_e(c_e_s, T) * (eps_s ** param.b_s)\n\n        phi_e_s = pybamm.PrimaryBroadcast(\n            pybamm.boundary_value(phi_e_n, \"right\"), \"separator\"\n        ) + pybamm.IndefiniteIntegral(\n            chi_e_s / c_e_s * pybamm.grad(c_e_s)\n            - param.C_e\n            * pybamm.PrimaryBroadcast(i_boundary_cc, self.domain_for_broadcast)\n            / kappa_s_eff,\n            x_s,\n        )\n\n        i_e_s = pybamm.PrimaryBroadcast(i_boundary_cc, \"separator\")\n\n        variables.update(self._get_domain_potential_variables(phi_e_s))\n        variables.update(self._get_domain_current_variables(i_e_s))\n\n        # Update boundary conditions (for indefinite integral)\n        self.boundary_conditions[c_e_s] = {\n            \"left\": (pybamm.BoundaryGradient(c_e_s, \"left\"), \"Neumann\"),\n            \"right\": (pybamm.BoundaryGradient(c_e_s, \"right\"), \"Neumann\"),\n        }\n\n        return variables",
  "def nasty_hack_to_get_phi_s(self, variables):\n        \"This restates what is already in the electrode submodel which we should not do\"\n\n        param = self.param\n\n        x_n = pybamm.standard_spatial_vars.x_n\n        x_p = pybamm.standard_spatial_vars.x_p\n        eps = variables[self.domain + \" electrode porosity\"]\n        i_boundary_cc = variables[\"Current collector current density\"]\n        i_e = variables[self.domain + \" electrolyte current density\"]\n\n        i_s = pybamm.PrimaryBroadcast(i_boundary_cc, self.domain_for_broadcast) - i_e\n\n        if self.domain == \"Negative\":\n            conductivity = param.sigma_n * (1 - eps) ** param.b_n\n            phi_s = -pybamm.IndefiniteIntegral(i_s / conductivity, x_n)\n\n        elif self.domain == \"Positive\":\n\n            phi_e_s = variables[\"Separator electrolyte potential\"]\n            delta_phi_p = variables[\"Positive electrode surface potential difference\"]\n\n            conductivity = param.sigma_p * (1 - eps) ** param.b_p\n\n            phi_s = -pybamm.IndefiniteIntegral(\n                i_s / conductivity, x_p\n            ) + pybamm.PrimaryBroadcast(\n                pybamm.boundary_value(phi_e_s, \"right\")\n                + pybamm.boundary_value(delta_phi_p, \"left\"),\n                \"positive electrode\",\n            )\n\n        return phi_s",
  "def __init__(self, param, domain, reactions):\n        super().__init__(param, domain, reactions)",
  "def set_algebraic(self, variables):\n        if self.domain == \"Separator\":\n            return\n\n        delta_phi = variables[self.domain + \" electrode surface potential difference\"]\n        i_e = variables[self.domain + \" electrolyte current density\"]\n        sum_j = sum(\n            variables[reaction[self.domain][\"aj\"]]\n            for reaction in self.reactions.values()\n        )\n        self.algebraic[delta_phi] = pybamm.div(i_e) - sum_j",
  "def __init__(self, param, domain, reactions):\n        super().__init__(param, domain, reactions)",
  "def set_rhs(self, variables):\n        if self.domain == \"Separator\":\n            return\n\n        if self.domain == \"Negative\":\n            C_dl = self.param.C_dl_n\n        elif self.domain == \"Positive\":\n            C_dl = self.param.C_dl_p\n\n        delta_phi = variables[self.domain + \" electrode surface potential difference\"]\n        i_e = variables[self.domain + \" electrolyte current density\"]\n        sum_j = sum(\n            variables[reaction[self.domain][\"aj\"]]\n            for reaction in self.reactions.values()\n        )\n\n        self.rhs[delta_phi] = 1 / C_dl * (pybamm.div(i_e) - sum_j)",
  "class BaseLeadingOrderSurfaceForm(LeadingOrder):\n    \"\"\"Base class for leading-order conservation of charge in the electrolyte employing\n    the Stefan-Maxwell constitutive equations employing the surface potential difference\n    formulation. (Leading refers to leading order in asymptotics)\n\n    Parameters\n    ----------\n    param : parameter class\n        The parameters to use for this submodel\n    domain : str\n        The domain in which the model holds\n    reactions : dict\n        Dictionary of reaction terms\n\n    **Extends:** :class:`pybamm.electrolyte.stefan_maxwell.conductivity.surface_potential_form.BaseModel`\n    \"\"\"  # noqa: E501\n\n    def __init__(self, param, domain, reactions):\n        super().__init__(param, domain, reactions)\n\n    def get_fundamental_variables(self):\n\n        if self.domain == \"Negative\":\n            delta_phi = pybamm.standard_variables.delta_phi_n_av\n        elif self.domain == \"Separator\":\n            return {}\n        elif self.domain == \"Positive\":\n            delta_phi = pybamm.standard_variables.delta_phi_p_av\n\n        variables = self._get_standard_surface_potential_difference_variables(delta_phi)\n        return variables\n\n    def set_initial_conditions(self, variables):\n\n        if self.domain == \"Separator\":\n            return\n\n        delta_phi = variables[\n            \"X-averaged \"\n            + self.domain.lower()\n            + \" electrode surface potential difference\"\n        ]\n        if self.domain == \"Negative\":\n            delta_phi_init = self.param.U_n(self.param.c_n_init, self.param.T_ref)\n        elif self.domain == \"Positive\":\n            delta_phi_init = self.param.U_p(self.param.c_p_init, self.param.T_ref)\n\n        self.initial_conditions = {delta_phi: delta_phi_init}\n\n    def get_coupled_variables(self, variables):\n        # Use the potential difference in the negative electrode to calculate the\n        # potential difference and current\n        if self.domain == \"Negative\":\n            delta_phi_n_av = variables[\n                \"X-averaged negative electrode surface potential difference\"\n            ]\n            phi_e_av = -delta_phi_n_av\n            return self._get_coupled_variables_from_potential(variables, phi_e_av)\n\n        else:\n            return variables\n\n    def set_boundary_conditions(self, variables):\n        if self.domain == \"Negative\":\n            phi_e = variables[\"Electrolyte potential\"]\n            self.boundary_conditions = {\n                phi_e: {\n                    \"left\": (pybamm.Scalar(0), \"Neumann\"),\n                    \"right\": (pybamm.Scalar(0), \"Neumann\"),\n                }\n            }",
  "class LeadingOrderDifferential(BaseLeadingOrderSurfaceForm):\n    \"\"\"Leading-order model for conservation of charge in the electrolyte employing the\n    Stefan-Maxwell constitutive equations employing the surface potential difference\n    formulation and where capacitance is present.\n\n    Parameters\n    ----------\n    param : parameter class\n        The parameters to use for this submodel\n\n\n    **Extends:** :class:`BaseLeadingOrderSurfaceForm`\n\n    \"\"\"\n\n    def __init__(self, param, domain, reactions):\n        super().__init__(param, domain, reactions)\n\n    def set_rhs(self, variables):\n        if self.domain == \"Separator\":\n            return\n\n        param = self.param\n\n        sum_j = sum(\n            variables[\"X-averaged \" + reaction[self.domain][\"aj\"].lower()]\n            for reaction in self.reactions.values()\n        )\n\n        sum_j_av = variables[\n            \"X-averaged \"\n            + self.domain.lower()\n            + \" electrode total interfacial current density\"\n        ]\n        delta_phi = variables[\n            \"X-averaged \"\n            + self.domain.lower()\n            + \" electrode surface potential difference\"\n        ]\n\n        if self.domain == \"Negative\":\n            C_dl = param.C_dl_n\n        elif self.domain == \"Positive\":\n            C_dl = param.C_dl_p\n\n        self.rhs[delta_phi] = 1 / C_dl * (sum_j_av - sum_j)",
  "class LeadingOrderAlgebraic(BaseLeadingOrderSurfaceForm):\n    \"\"\"Leading-order model for conservation of charge in the electrolyte employing the\n    Stefan-Maxwell constitutive equations employing the surface potential difference\n    formulation.\n\n    Parameters\n    ----------\n    param : parameter class\n        The parameters to use for this submodel\n\n\n    **Extends:** :class:`BaseLeadingOrderSurfaceForm`\n    \"\"\"\n\n    def __init__(self, param, domain, reactions):\n        super().__init__(param, domain, reactions)\n\n    def set_algebraic(self, variables):\n        if self.domain == \"Separator\":\n            return\n\n        sum_j = sum(\n            variables[\"X-averaged \" + reaction[self.domain][\"aj\"].lower()]\n            for reaction in self.reactions.values()\n        )\n\n        sum_j_av = variables[\n            \"X-averaged \"\n            + self.domain.lower()\n            + \" electrode total interfacial current density\"\n        ]\n        delta_phi = variables[\n            \"X-averaged \"\n            + self.domain.lower()\n            + \" electrode surface potential difference\"\n        ]\n\n        self.algebraic[delta_phi] = sum_j_av - sum_j",
  "def __init__(self, param, domain, reactions):\n        super().__init__(param, domain, reactions)",
  "def get_fundamental_variables(self):\n\n        if self.domain == \"Negative\":\n            delta_phi = pybamm.standard_variables.delta_phi_n_av\n        elif self.domain == \"Separator\":\n            return {}\n        elif self.domain == \"Positive\":\n            delta_phi = pybamm.standard_variables.delta_phi_p_av\n\n        variables = self._get_standard_surface_potential_difference_variables(delta_phi)\n        return variables",
  "def set_initial_conditions(self, variables):\n\n        if self.domain == \"Separator\":\n            return\n\n        delta_phi = variables[\n            \"X-averaged \"\n            + self.domain.lower()\n            + \" electrode surface potential difference\"\n        ]\n        if self.domain == \"Negative\":\n            delta_phi_init = self.param.U_n(self.param.c_n_init, self.param.T_ref)\n        elif self.domain == \"Positive\":\n            delta_phi_init = self.param.U_p(self.param.c_p_init, self.param.T_ref)\n\n        self.initial_conditions = {delta_phi: delta_phi_init}",
  "def get_coupled_variables(self, variables):\n        # Use the potential difference in the negative electrode to calculate the\n        # potential difference and current\n        if self.domain == \"Negative\":\n            delta_phi_n_av = variables[\n                \"X-averaged negative electrode surface potential difference\"\n            ]\n            phi_e_av = -delta_phi_n_av\n            return self._get_coupled_variables_from_potential(variables, phi_e_av)\n\n        else:\n            return variables",
  "def set_boundary_conditions(self, variables):\n        if self.domain == \"Negative\":\n            phi_e = variables[\"Electrolyte potential\"]\n            self.boundary_conditions = {\n                phi_e: {\n                    \"left\": (pybamm.Scalar(0), \"Neumann\"),\n                    \"right\": (pybamm.Scalar(0), \"Neumann\"),\n                }\n            }",
  "def __init__(self, param, domain, reactions):\n        super().__init__(param, domain, reactions)",
  "def set_rhs(self, variables):\n        if self.domain == \"Separator\":\n            return\n\n        param = self.param\n\n        sum_j = sum(\n            variables[\"X-averaged \" + reaction[self.domain][\"aj\"].lower()]\n            for reaction in self.reactions.values()\n        )\n\n        sum_j_av = variables[\n            \"X-averaged \"\n            + self.domain.lower()\n            + \" electrode total interfacial current density\"\n        ]\n        delta_phi = variables[\n            \"X-averaged \"\n            + self.domain.lower()\n            + \" electrode surface potential difference\"\n        ]\n\n        if self.domain == \"Negative\":\n            C_dl = param.C_dl_n\n        elif self.domain == \"Positive\":\n            C_dl = param.C_dl_p\n\n        self.rhs[delta_phi] = 1 / C_dl * (sum_j_av - sum_j)",
  "def __init__(self, param, domain, reactions):\n        super().__init__(param, domain, reactions)",
  "def set_algebraic(self, variables):\n        if self.domain == \"Separator\":\n            return\n\n        sum_j = sum(\n            variables[\"X-averaged \" + reaction[self.domain][\"aj\"].lower()]\n            for reaction in self.reactions.values()\n        )\n\n        sum_j_av = variables[\n            \"X-averaged \"\n            + self.domain.lower()\n            + \" electrode total interfacial current density\"\n        ]\n        delta_phi = variables[\n            \"X-averaged \"\n            + self.domain.lower()\n            + \" electrode surface potential difference\"\n        ]\n\n        self.algebraic[delta_phi] = sum_j_av - sum_j",
  "class BaseBatteryModel(pybamm.BaseModel):\n    \"\"\"\n    Base model class with some default settings and required variables\n\n    Attributes\n    ----------\n\n    options: dict\n        A dictionary of options to be passed to the model. The options that can\n        be set are listed below. Note that not all of the options are compatible with\n        each other and with all of the models implemented in PyBaMM.\n\n            * \"dimensionality\" : int, optional\n                Sets the dimension of the current collector problem. Can be 0\n                (default), 1 or 2.\n            * \"surface form\" : bool or str, optional\n                Whether to use the surface formulation of the problem. Can be False\n                (default), \"differential\" or \"algebraic\". Must be 'False' for\n                lithium-ion models.\n            * \"convection\" : bool or str, optional\n                Whether to include the effects of convection in the model. Can be\n                False (default), \"differential\" or \"algebraic\". Must be 'False' for\n                lithium-ion models.\n            * \"side reactions\" : list, optional\n                Contains a list of any side reactions to include. Default is []. If this\n                list is not empty (i.e. side reactions are included in the model), then\n                \"surface form\" cannot be 'False'.\n            * \"interfacial surface area\" : str, optional\n                Sets the model for the interfacial surface area. Can be \"constant\"\n                (default) or \"varying\". Not currently implemented in any of the models.\n            * \"current collector\" : str, optional\n                Sets the current collector model to use. Can be \"uniform\" (default),\n                \"potential pair\", \"potential pair quite conductive\" or \"single particle\n                potential pair\".\n            * \"particle\" : str, optional\n                Sets the submodel to use to describe behaviour within the particle.\n                Can be \"Fickian diffusion\" (default) or \"fast diffusion\".\n            * \"thermal\" : str, optional\n                Sets the thermal model to use. Can be \"isothermal\" (default),\n                \"x-full\", \"x-lumped\", \"xyz-lumped\" or \"lumped\". Must be \"isothermal\" for\n                lead-acid models.\n            * \"thermal current collector\" : bool, optional\n                Whether to include thermal effects in the current collector in\n                one-dimensional models (default is False). Note that this option\n                only takes effect if \"dimensionality\" is 0. If \"dimensionality\"\n                is 1 or 2 current collector effects are always included. Must be 'False'\n                for lead-acid models.\n\n\n    **Extends:** :class:`pybamm.BaseModel`\n    \"\"\"\n\n    def __init__(self, options=None, name=\"Unnamed battery model\"):\n        super().__init__(name)\n        self.options = options\n        self.set_standard_output_variables()\n        self.submodels = {}\n        self._built = False\n\n    @property\n    def default_parameter_values(self):\n        # Default parameter values\n        # Lion parameters left as default parameter set for tests\n        return pybamm.ParameterValues(chemistry=pybamm.parameter_sets.Marquis2019)\n\n    @property\n    def default_geometry(self):\n        if self.options[\"dimensionality\"] == 0:\n            return pybamm.Geometry(\"1D macro\", \"1+1D micro\")\n        elif self.options[\"dimensionality\"] == 1:\n            return pybamm.Geometry(\"1+1D macro\", \"1+1D micro\")\n        elif self.options[\"dimensionality\"] == 2:\n            return pybamm.Geometry(\"2+1D macro\", \"1+1D micro\")\n\n    @property\n    def default_var_pts(self):\n        var = pybamm.standard_spatial_vars\n        return {\n            var.x_n: 20,\n            var.x_s: 20,\n            var.x_p: 20,\n            var.r_n: 10,\n            var.r_p: 10,\n            var.y: 10,\n            var.z: 10,\n        }\n\n    @property\n    def default_submesh_types(self):\n        base_submeshes = {\n            \"negative electrode\": pybamm.MeshGenerator(pybamm.Uniform1DSubMesh),\n            \"separator\": pybamm.MeshGenerator(pybamm.Uniform1DSubMesh),\n            \"positive electrode\": pybamm.MeshGenerator(pybamm.Uniform1DSubMesh),\n            \"negative particle\": pybamm.MeshGenerator(pybamm.Uniform1DSubMesh),\n            \"positive particle\": pybamm.MeshGenerator(pybamm.Uniform1DSubMesh),\n        }\n        if self.options[\"dimensionality\"] == 0:\n            base_submeshes[\"current collector\"] = pybamm.MeshGenerator(pybamm.SubMesh0D)\n        elif self.options[\"dimensionality\"] == 1:\n            base_submeshes[\"current collector\"] = pybamm.MeshGenerator(\n                pybamm.Uniform1DSubMesh\n            )\n        elif self.options[\"dimensionality\"] == 2:\n            base_submeshes[\"current collector\"] = pybamm.MeshGenerator(\n                pybamm.ScikitUniform2DSubMesh\n            )\n        return base_submeshes\n\n    @property\n    def default_spatial_methods(self):\n        base_spatial_methods = {\n            \"macroscale\": pybamm.FiniteVolume,\n            \"negative particle\": pybamm.FiniteVolume,\n            \"positive particle\": pybamm.FiniteVolume,\n        }\n        if self.options[\"dimensionality\"] == 0:\n            # 0D submesh - use base spatial method\n            base_spatial_methods[\"current collector\"] = pybamm.ZeroDimensionalMethod\n        elif self.options[\"dimensionality\"] == 1:\n            base_spatial_methods[\"current collector\"] = pybamm.FiniteVolume\n        elif self.options[\"dimensionality\"] == 2:\n            base_spatial_methods[\"current collector\"] = pybamm.ScikitFiniteElement\n        return base_spatial_methods\n\n    @property\n    def default_solver(self):\n        \"\"\"\n        Create and return the default solver for this model\n        \"\"\"\n        return pybamm.ScipySolver()\n\n    @property\n    def options(self):\n        return self._options\n\n    @options.setter\n    def options(self, extra_options):\n        default_options = {\n            \"dimensionality\": 0,\n            \"surface form\": False,\n            \"convection\": False,\n            \"side reactions\": [],\n            \"interfacial surface area\": \"constant\",\n            \"current collector\": \"uniform\",\n            \"particle\": \"Fickian diffusion\",\n            \"thermal\": \"isothermal\",\n            \"thermal current collector\": False,\n        }\n        options = default_options\n        # any extra options overwrite the default options\n        if extra_options is not None:\n            for name, opt in extra_options.items():\n                if name in default_options:\n                    options[name] = opt\n                else:\n                    raise pybamm.OptionError(\"option {} not recognised\".format(name))\n\n        # Some standard checks to make sure options are compatible\n        if (\n            isinstance(self, (pybamm.lead_acid.LOQS, pybamm.lead_acid.Composite))\n            and options[\"surface form\"] is False\n        ):\n            if len(options[\"side reactions\"]) > 0:\n                raise pybamm.OptionError(\n                    \"\"\"\n                    must use surface formulation to solve {!s} with side reactions\n                    \"\"\".format(\n                        self\n                    )\n                )\n        if options[\"surface form\"] not in [False, \"differential\", \"algebraic\"]:\n            raise pybamm.OptionError(\n                \"surface form '{}' not recognised\".format(options[\"surface form\"])\n            )\n        if options[\"current collector\"] not in [\n            \"uniform\",\n            \"potential pair\",\n            \"potential pair quite conductive\",\n            \"single particle potential pair\",\n        ]:\n            raise pybamm.OptionError(\n                \"current collector model '{}' not recognised\".format(\n                    options[\"current collector\"]\n                )\n            )\n        if options[\"dimensionality\"] not in [0, 1, 2]:\n            raise pybamm.OptionError(\n                \"Dimension of current collectors must be 0, 1, or 2, not {}\".format(\n                    options[\"dimensionality\"]\n                )\n            )\n        if options[\"thermal\"] not in [\n            \"isothermal\",\n            \"x-full\",\n            \"x-lumped\",\n            \"xyz-lumped\",\n            \"lumped\",\n        ]:\n            raise pybamm.OptionError(\n                \"Unknown thermal model '{}'\".format(options[\"thermal\"])\n            )\n        if options[\"particle\"] not in [\"Fickian diffusion\", \"fast diffusion\"]:\n            raise pybamm.OptionError(\n                \"particle model '{}' not recognised\".format(options[\"particle\"])\n            )\n\n        # Options that are incompatible with models\n        if isinstance(self, pybamm.lithium_ion.BaseModel):\n            if options[\"surface form\"] is not False:\n                raise pybamm.OptionError(\n                    \"surface form not implemented for lithium-ion models\"\n                )\n            if options[\"convection\"] is True:\n                raise pybamm.OptionError(\n                    \"convection not implemented for lithium-ion models\"\n                )\n        if isinstance(self, pybamm.lead_acid.BaseModel):\n            if options[\"thermal\"] != \"isothermal\":\n                raise pybamm.OptionError(\n                    \"thermal effects not implemented for lead-acid models\"\n                )\n            if options[\"thermal current collector\"] is True:\n                raise pybamm.OptionError(\n                    \"thermal effects not implemented for lead-acid models\"\n                )\n        self._options = options\n\n    def set_standard_output_variables(self):\n        # Standard output variables\n\n        # Interfacial current\n        self.variables.update(\n            {\n                \"Negative electrode current density\": None,\n                \"Positive electrode current density\": None,\n                \"Electrolyte current density\": None,\n                \"Interfacial current density\": None,\n                \"Exchange current density\": None,\n            }\n        )\n        self.variables.update(\n            {\n                \"Negative electrode current density [A.m-2]\": None,\n                \"Positive electrode current density [A.m-2]\": None,\n                \"Electrolyte current density [A.m-2]\": None,\n                \"Interfacial current density [A.m-2]\": None,\n                \"Exchange current density [A.m-2]\": None,\n            }\n        )\n\n        # Voltage\n        self.variables.update(\n            {\n                \"Negative electrode open circuit potential\": None,\n                \"Positive electrode open circuit potential\": None,\n                \"X-averaged negative electrode open circuit potential\": None,\n                \"X-averaged positive electrode open circuit potential\": None,\n                \"X-averaged open circuit voltage\": None,\n                \"Measured open circuit voltage\": None,\n                \"Terminal voltage\": None,\n            }\n        )\n        self.variables.update(\n            {\n                \"Negative electrode open circuit potential [V]\": None,\n                \"Positive electrode open circuit potential [V]\": None,\n                \"X-averaged negative electrode open circuit potential [V]\": None,\n                \"X-averaged positive electrode open circuit potential [V]\": None,\n                \"X-averaged open circuit voltage [V]\": None,\n                \"Measured open circuit voltage [V]\": None,\n                \"Terminal voltage [V]\": None,\n            }\n        )\n\n        # Overpotentials\n        self.variables.update(\n            {\n                \"Negative reaction overpotential\": None,\n                \"Positive reaction overpotential\": None,\n                \"X-averaged negative reaction overpotential\": None,\n                \"X-averaged positive reaction overpotential\": None,\n                \"X-averaged reaction overpotential\": None,\n                \"X-averaged electrolyte overpotential\": None,\n                \"X-averaged solid phase ohmic losses\": None,\n            }\n        )\n        self.variables.update(\n            {\n                \"Negative reaction overpotential [V]\": None,\n                \"Positive reaction overpotential [V]\": None,\n                \"X-averaged negative reaction overpotential [V]\": None,\n                \"X-averaged positive reaction overpotential [V]\": None,\n                \"X-averaged reaction overpotential [V]\": None,\n                \"X-averaged electrolyte overpotential [V]\": None,\n                \"X-averaged solid phase ohmic losses [V]\": None,\n            }\n        )\n\n        # Concentration\n        self.variables.update(\n            {\n                \"Electrolyte concentration\": None,\n                \"Electrolyte concentration [mol.m-3]\": None,\n            }\n        )\n\n        # Potential\n        self.variables.update(\n            {\n                \"Negative electrode potential\": None,\n                \"Positive electrode potential\": None,\n                \"Electrolyte potential\": None,\n            }\n        )\n\n        self.variables = {}\n\n        # Current\n        i_cell = pybamm.electrical_parameters.current_with_time\n        i_cell_dim = pybamm.electrical_parameters.dimensional_current_density_with_time\n        I = pybamm.electrical_parameters.dimensional_current_with_time\n        self.variables.update(\n            {\n                \"Total current density\": i_cell,\n                \"Total current density [A.m-2]\": i_cell_dim,\n                \"Current [A]\": I,\n            }\n        )\n\n        # Time\n        time_scale = pybamm.electrical_parameters.timescale\n        self.variables.update(\n            {\n                \"Time\": pybamm.t,\n                \"Time [s]\": pybamm.t * time_scale,\n                \"Time [min]\": pybamm.t * time_scale / 60,\n                \"Time [h]\": pybamm.t * time_scale / 3600,\n                \"Discharge capacity [A.h]\": I * pybamm.t * time_scale / 3600,\n            }\n        )\n\n        # Spatial\n        var = pybamm.standard_spatial_vars\n        L_x = pybamm.geometric_parameters.L_x\n        L_y = pybamm.geometric_parameters.L_y\n        L_z = pybamm.geometric_parameters.L_z\n        self.variables.update(\n            {\n                \"x\": var.x,\n                \"x [m]\": var.x * L_x,\n                \"x_n\": var.x_n,\n                \"x_n [m]\": var.x_n * L_x,\n                \"x_s\": var.x_s,\n                \"x_s [m]\": var.x_s * L_x,\n                \"x_p\": var.x_p,\n                \"x_p [m]\": var.x_p * L_x,\n            }\n        )\n        if self.options[\"dimensionality\"] == 1:\n            self.variables.update({\"y\": var.y, \"y [m]\": var.y * L_y})\n        elif self.options[\"dimensionality\"] == 2:\n            self.variables.update(\n                {\"y\": var.y, \"y [m]\": var.y * L_y, \"z\": var.z, \"z [m]\": var.z * L_z}\n            )\n\n    def build_model(self):\n\n        # Check if already built\n        if self._built:\n            raise pybamm.ModelError(\n                \"\"\"Model already built. If you are adding a new submodel, try using\n                `model.update` instead.\"\"\"\n            )\n\n        pybamm.logger.info(\"Building {}\".format(self.name))\n\n        # Get the fundamental variables\n        for submodel_name, submodel in self.submodels.items():\n            pybamm.logger.debug(\n                \"Getting fundamental variables for {} submodel ({})\".format(\n                    submodel_name, self.name\n                )\n            )\n            self.variables.update(submodel.get_fundamental_variables())\n\n        # Get coupled variables\n        # Note: pybamm will try to get the coupled variables for the submodels in the\n        # order they are set by the user. If this fails for a particular submodel,\n        # return to it later and try again. If setting coupled variables fails and\n        # there are no more submodels to try, raise an error.\n        submodels = list(self.submodels.keys())\n        while len(submodels) > 0:\n            for submodel_name, submodel in self.submodels.items():\n                if submodel_name in submodels:\n                    pybamm.logger.debug(\n                        \"Getting coupled variables for {} submodel ({})\".format(\n                            submodel_name, self.name\n                        )\n                    )\n                    try:\n                        self.variables.update(\n                            submodel.get_coupled_variables(self.variables)\n                        )\n                        submodels.remove(submodel_name)\n                    except KeyError as key:\n                        if len(submodels) == 1:\n                            # no more submodels to try\n                            raise pybamm.ModelError(\n                                \"\"\"Submodel \"{}\" requires the variable {}, but it cannot be found.\n                                Check the selected submodels provide all of the required\n                                variables.\"\"\".format(\n                                    submodel_name, key\n                                )\n                            )\n                        else:\n                            # try setting coupled variables on next loop through\n                            pass\n\n        # Set model equations\n        for submodel_name, submodel in self.submodels.items():\n            pybamm.logger.debug(\n                \"Setting rhs for {} submodel ({})\".format(submodel_name, self.name)\n            )\n            submodel.set_rhs(self.variables)\n            pybamm.logger.debug(\n                \"Setting algebraic for {} submodel ({})\".format(\n                    submodel_name, self.name\n                )\n            )\n            submodel.set_algebraic(self.variables)\n            pybamm.logger.debug(\n                \"Setting boundary conditions for {} submodel ({})\".format(\n                    submodel_name, self.name\n                )\n            )\n            submodel.set_boundary_conditions(self.variables)\n            pybamm.logger.debug(\n                \"Setting initial conditions for {} submodel ({})\".format(\n                    submodel_name, self.name\n                )\n            )\n            submodel.set_initial_conditions(self.variables)\n            submodel.set_events(self.variables)\n            pybamm.logger.debug(\n                \"Updating {} submodel ({})\".format(submodel_name, self.name)\n            )\n            self.update(submodel)\n\n        pybamm.logger.debug(\"Setting voltage variables\")\n        self.set_voltage_variables()\n\n        pybamm.logger.debug(\"Setting SoC variables\")\n        self.set_soc_variables()\n\n        # Massive hack for consistent delta_phi = phi_s - phi_e with SPMe\n        # This needs to be corrected\n        if isinstance(self, pybamm.lithium_ion.SPMe):\n            for domain in [\"Negative\", \"Positive\"]:\n                phi_s = self.variables[domain + \" electrode potential\"]\n                phi_e = self.variables[domain + \" electrolyte potential\"]\n                delta_phi = phi_s - phi_e\n                s = self.submodels[domain.lower() + \" interface\"]\n                var = s._get_standard_surface_potential_difference_variables(delta_phi)\n                self.variables.update(var)\n\n        self._built = True\n\n    def set_thermal_submodel(self):\n\n        if self.options[\"thermal\"] == \"isothermal\":\n            thermal_submodel = pybamm.thermal.isothermal.Isothermal(self.param)\n\n        elif self.options[\"thermal\"] == \"x-lumped\":\n            if self.options[\"dimensionality\"] == 0:\n                if self.options[\"thermal current collector\"] is False:\n                    thermal_submodel = pybamm.thermal.x_lumped.NoCurrentCollector(\n                        self.param\n                    )\n                elif self.options[\"thermal current collector\"] is True:\n                    thermal_submodel = pybamm.thermal.x_lumped.CurrentCollector0D(\n                        self.param\n                    )\n            elif self.options[\"dimensionality\"] == 1:\n                thermal_submodel = pybamm.thermal.x_lumped.CurrentCollector1D(\n                    self.param\n                )\n            elif self.options[\"dimensionality\"] == 2:\n                thermal_submodel = pybamm.thermal.x_lumped.CurrentCollector2D(\n                    self.param\n                )\n\n        elif self.options[\"thermal\"] == \"x-full\":\n            if self.options[\"dimensionality\"] == 0:\n                if self.options[\"thermal current collector\"] is False:\n                    thermal_submodel = pybamm.thermal.x_full.NoCurrentCollector(\n                        self.param\n                    )\n                elif self.options[\"thermal current collector\"] is True:\n                    raise NotImplementedError(\n                        \"\"\"X-full thermal submodels do\n                    not yet account for current collector\"\"\"\n                    )\n            elif self.options[\"dimensionality\"] == 1:\n                raise NotImplementedError(\n                    \"\"\"X-full thermal submodels do not\n                yet support 1D current collectors\"\"\"\n                )\n            elif self.options[\"dimensionality\"] == 2:\n                raise NotImplementedError(\n                    \"\"\"X-full thermal submodels do\n                    not yet support 2D current collectors\"\"\"\n                )\n\n        elif self.options[\"thermal\"] == \"xyz-lumped\":\n            if self.options[\"dimensionality\"] == 0:\n                # note here we will just call the x_lumped model\n                # because it is equivalent\n                if self.options[\"thermal current collector\"] is False:\n                    thermal_submodel = pybamm.thermal.x_lumped.NoCurrentCollector(\n                        self.param\n                    )\n                elif self.options[\"thermal current collector\"] is True:\n                    thermal_submodel = pybamm.thermal.x_lumped.CurrentCollector0D(\n                        self.param\n                    )\n            elif self.options[\"dimensionality\"] == 1:\n                thermal_submodel = pybamm.thermal.xyz_lumped.CurrentCollector1D(\n                    self.param\n                )\n            elif self.options[\"dimensionality\"] == 2:\n                thermal_submodel = pybamm.thermal.xyz_lumped.CurrentCollector2D(\n                    self.param\n                )\n\n        elif self.options[\"thermal\"] == \"lumped\":\n            # Easy option for returning a single Temperature regardless of choice of\n            # current collector model. Note: Always includes current collector effects\n            if self.options[\"dimensionality\"] == 0:\n                thermal_submodel = pybamm.thermal.x_lumped.CurrentCollector0D(\n                    self.param\n                )\n            elif self.options[\"dimensionality\"] == 1:\n                thermal_submodel = pybamm.thermal.xyz_lumped.CurrentCollector1D(\n                    self.param\n                )\n            elif self.options[\"dimensionality\"] == 2:\n                thermal_submodel = pybamm.thermal.xyz_lumped.CurrentCollector2D(\n                    self.param\n                )\n\n        self.submodels[\"thermal\"] = thermal_submodel\n\n    def set_current_collector_submodel(self):\n\n        if self.options[\"current collector\"] == \"uniform\":\n            submodel = pybamm.current_collector.Uniform(self.param)\n        elif self.options[\"current collector\"] == \"potential pair\":\n            if self.options[\"dimensionality\"] == 1:\n                submodel = pybamm.current_collector.PotentialPair1plus1D(self.param)\n            elif self.options[\"dimensionality\"] == 2:\n                submodel = pybamm.current_collector.PotentialPair2plus1D(self.param)\n        elif self.options[\"current collector\"] == \"single particle potential pair\":\n            submodel = pybamm.current_collector.SingleParticlePotentialPair(self.param)\n\n        self.submodels[\"current collector\"] = submodel\n\n    def set_voltage_variables(self):\n\n        ocp_n = self.variables[\"Negative electrode open circuit potential\"]\n        ocp_p = self.variables[\"Positive electrode open circuit potential\"]\n        ocp_n_av = self.variables[\n            \"X-averaged negative electrode open circuit potential\"\n        ]\n        ocp_p_av = self.variables[\n            \"X-averaged positive electrode open circuit potential\"\n        ]\n\n        ocp_n_dim = self.variables[\"Negative electrode open circuit potential [V]\"]\n        ocp_p_dim = self.variables[\"Positive electrode open circuit potential [V]\"]\n        ocp_n_av_dim = self.variables[\n            \"X-averaged negative electrode open circuit potential [V]\"\n        ]\n        ocp_p_av_dim = self.variables[\n            \"X-averaged positive electrode open circuit potential [V]\"\n        ]\n\n        ocp_n_left = pybamm.boundary_value(ocp_n, \"left\")\n        ocp_n_left_dim = pybamm.boundary_value(ocp_n_dim, \"left\")\n        ocp_p_right = pybamm.boundary_value(ocp_p, \"right\")\n        ocp_p_right_dim = pybamm.boundary_value(ocp_p_dim, \"right\")\n\n        ocv_av = ocp_p_av - ocp_n_av\n        ocv_av_dim = ocp_p_av_dim - ocp_n_av_dim\n        ocv = ocp_p_right - ocp_n_left\n        ocv_dim = ocp_p_right_dim - ocp_n_left_dim\n\n        # overpotentials\n        eta_r_n_av = self.variables[\n            \"X-averaged negative electrode reaction overpotential\"\n        ]\n        eta_r_n_av_dim = self.variables[\n            \"X-averaged negative electrode reaction overpotential [V]\"\n        ]\n        eta_r_p_av = self.variables[\n            \"X-averaged positive electrode reaction overpotential\"\n        ]\n        eta_r_p_av_dim = self.variables[\n            \"X-averaged positive electrode reaction overpotential [V]\"\n        ]\n\n        delta_phi_s_n_av = self.variables[\"X-averaged negative electrode ohmic losses\"]\n        delta_phi_s_n_av_dim = self.variables[\n            \"X-averaged negative electrode ohmic losses [V]\"\n        ]\n        delta_phi_s_p_av = self.variables[\"X-averaged positive electrode ohmic losses\"]\n        delta_phi_s_p_av_dim = self.variables[\n            \"X-averaged positive electrode ohmic losses [V]\"\n        ]\n\n        delta_phi_s_av = delta_phi_s_p_av - delta_phi_s_n_av\n        delta_phi_s_av_dim = delta_phi_s_p_av_dim - delta_phi_s_n_av_dim\n\n        eta_r_av = eta_r_p_av - eta_r_n_av\n        eta_r_av_dim = eta_r_p_av_dim - eta_r_n_av_dim\n\n        # terminal voltage (Note: phi_s_cn is zero at the negative tab)\n        phi_s_cp = self.variables[\"Positive current collector potential\"]\n        phi_s_cp_dim = self.variables[\"Positive current collector potential [V]\"]\n        if self.options[\"dimensionality\"] == 0:\n            V = phi_s_cp\n            V_dim = phi_s_cp_dim\n        elif self.options[\"dimensionality\"] in [1, 2]:\n            V = pybamm.BoundaryValue(phi_s_cp, \"positive tab\")\n            V_dim = pybamm.BoundaryValue(phi_s_cp_dim, \"positive tab\")\n\n        # TODO: add current collector losses to the voltage in 3D\n\n        self.variables.update(\n            {\n                \"X-averaged open circuit voltage\": ocv_av,\n                \"Measured open circuit voltage\": ocv,\n                \"X-averaged open circuit voltage [V]\": ocv_av_dim,\n                \"Measured open circuit voltage [V]\": ocv_dim,\n                \"X-averaged reaction overpotential\": eta_r_av,\n                \"X-averaged reaction overpotential [V]\": eta_r_av_dim,\n                \"X-averaged solid phase ohmic losses\": delta_phi_s_av,\n                \"X-averaged solid phase ohmic losses [V]\": delta_phi_s_av_dim,\n                \"Terminal voltage\": V,\n                \"Terminal voltage [V]\": V_dim,\n            }\n        )\n\n        # Battery-wide variables\n        eta_e_av_dim = self.variables.get(\"X-averaged electrolyte ohmic losses [V]\", 0)\n        eta_c_av_dim = self.variables.get(\n            \"X-averaged concentration overpotential [V]\", 0\n        )\n        num_cells = pybamm.Parameter(\n            \"Number of cells connected in series to make a battery\"\n        )\n\n        self.variables.update(\n            {\n                \"X-averaged battery open circuit voltage [V]\": ocv_av_dim * num_cells,\n                \"Measured battery open circuit voltage [V]\": ocv_dim * num_cells,\n                \"X-averaged battery reaction overpotential [V]\": eta_r_av_dim\n                * num_cells,\n                \"X-averaged battery solid phase ohmic losses [V]\": delta_phi_s_av_dim\n                * num_cells,\n                \"X-averaged battery electrolyte ohmic losses [V]\": eta_e_av_dim\n                * num_cells,\n                \"X-averaged battery concentration overpotential [V]\": eta_c_av_dim\n                * num_cells,\n                \"Battery voltage [V]\": V_dim * num_cells,\n            }\n        )\n\n        # Cut-off voltage\n        voltage = self.variables[\"Terminal voltage\"]\n        self.events[\"Minimum voltage\"] = voltage - self.param.voltage_low_cut\n        self.events[\"Maximum voltage\"] = voltage - self.param.voltage_high_cut\n\n    def set_soc_variables(self):\n        \"\"\"\n        Set variables relating to the state of charge.\n        This function is overriden by the base battery models\n        \"\"\"\n        pass\n\n    def process_parameters_and_discretise(self, symbol, parameter_values, disc):\n        \"\"\"\n        Process parameters and discretise a symbol using supplied parameter values\n        and discretisation. Note: care should be taken if using spatial operators\n        on dimensional symbols. Operators in pybamm are written in non-dimensional\n        form, so may need to be scaled by the appropriate length scale. It is\n        recommended to use this method on non-dimensional symbols.\n\n        Parameters\n        ----------\n        symbol : :class:`pybamm.Symbol`\n            Symbol to be processed\n        parameter_values : :class:`pybamm.ParameterValues`\n            The parameter values to use during processing\n        disc : :class:`pybamm.Discretisation`\n            The discrisation to use\n\n        Returns\n        -------\n        :class:`pybamm.Symbol`\n            Processed symbol\n        \"\"\"\n        # Set y slices\n        if disc.y_slices == {}:\n            variables = list(self.rhs.keys()) + list(self.algebraic.keys())\n            disc.set_variable_slices(variables)\n\n        # Set boundary condtions\n        if disc.bcs == {}:\n            disc.bcs = disc.process_boundary_conditions(self)\n\n        # Process\n        param_symbol = parameter_values.process_symbol(symbol)\n        disc_symbol = disc.process_symbol(param_symbol)\n\n        return disc_symbol",
  "def __init__(self, options=None, name=\"Unnamed battery model\"):\n        super().__init__(name)\n        self.options = options\n        self.set_standard_output_variables()\n        self.submodels = {}\n        self._built = False",
  "def default_parameter_values(self):\n        # Default parameter values\n        # Lion parameters left as default parameter set for tests\n        return pybamm.ParameterValues(chemistry=pybamm.parameter_sets.Marquis2019)",
  "def default_geometry(self):\n        if self.options[\"dimensionality\"] == 0:\n            return pybamm.Geometry(\"1D macro\", \"1+1D micro\")\n        elif self.options[\"dimensionality\"] == 1:\n            return pybamm.Geometry(\"1+1D macro\", \"1+1D micro\")\n        elif self.options[\"dimensionality\"] == 2:\n            return pybamm.Geometry(\"2+1D macro\", \"1+1D micro\")",
  "def default_var_pts(self):\n        var = pybamm.standard_spatial_vars\n        return {\n            var.x_n: 20,\n            var.x_s: 20,\n            var.x_p: 20,\n            var.r_n: 10,\n            var.r_p: 10,\n            var.y: 10,\n            var.z: 10,\n        }",
  "def default_submesh_types(self):\n        base_submeshes = {\n            \"negative electrode\": pybamm.MeshGenerator(pybamm.Uniform1DSubMesh),\n            \"separator\": pybamm.MeshGenerator(pybamm.Uniform1DSubMesh),\n            \"positive electrode\": pybamm.MeshGenerator(pybamm.Uniform1DSubMesh),\n            \"negative particle\": pybamm.MeshGenerator(pybamm.Uniform1DSubMesh),\n            \"positive particle\": pybamm.MeshGenerator(pybamm.Uniform1DSubMesh),\n        }\n        if self.options[\"dimensionality\"] == 0:\n            base_submeshes[\"current collector\"] = pybamm.MeshGenerator(pybamm.SubMesh0D)\n        elif self.options[\"dimensionality\"] == 1:\n            base_submeshes[\"current collector\"] = pybamm.MeshGenerator(\n                pybamm.Uniform1DSubMesh\n            )\n        elif self.options[\"dimensionality\"] == 2:\n            base_submeshes[\"current collector\"] = pybamm.MeshGenerator(\n                pybamm.ScikitUniform2DSubMesh\n            )\n        return base_submeshes",
  "def default_spatial_methods(self):\n        base_spatial_methods = {\n            \"macroscale\": pybamm.FiniteVolume,\n            \"negative particle\": pybamm.FiniteVolume,\n            \"positive particle\": pybamm.FiniteVolume,\n        }\n        if self.options[\"dimensionality\"] == 0:\n            # 0D submesh - use base spatial method\n            base_spatial_methods[\"current collector\"] = pybamm.ZeroDimensionalMethod\n        elif self.options[\"dimensionality\"] == 1:\n            base_spatial_methods[\"current collector\"] = pybamm.FiniteVolume\n        elif self.options[\"dimensionality\"] == 2:\n            base_spatial_methods[\"current collector\"] = pybamm.ScikitFiniteElement\n        return base_spatial_methods",
  "def default_solver(self):\n        \"\"\"\n        Create and return the default solver for this model\n        \"\"\"\n        return pybamm.ScipySolver()",
  "def options(self):\n        return self._options",
  "def options(self, extra_options):\n        default_options = {\n            \"dimensionality\": 0,\n            \"surface form\": False,\n            \"convection\": False,\n            \"side reactions\": [],\n            \"interfacial surface area\": \"constant\",\n            \"current collector\": \"uniform\",\n            \"particle\": \"Fickian diffusion\",\n            \"thermal\": \"isothermal\",\n            \"thermal current collector\": False,\n        }\n        options = default_options\n        # any extra options overwrite the default options\n        if extra_options is not None:\n            for name, opt in extra_options.items():\n                if name in default_options:\n                    options[name] = opt\n                else:\n                    raise pybamm.OptionError(\"option {} not recognised\".format(name))\n\n        # Some standard checks to make sure options are compatible\n        if (\n            isinstance(self, (pybamm.lead_acid.LOQS, pybamm.lead_acid.Composite))\n            and options[\"surface form\"] is False\n        ):\n            if len(options[\"side reactions\"]) > 0:\n                raise pybamm.OptionError(\n                    \"\"\"\n                    must use surface formulation to solve {!s} with side reactions\n                    \"\"\".format(\n                        self\n                    )\n                )\n        if options[\"surface form\"] not in [False, \"differential\", \"algebraic\"]:\n            raise pybamm.OptionError(\n                \"surface form '{}' not recognised\".format(options[\"surface form\"])\n            )\n        if options[\"current collector\"] not in [\n            \"uniform\",\n            \"potential pair\",\n            \"potential pair quite conductive\",\n            \"single particle potential pair\",\n        ]:\n            raise pybamm.OptionError(\n                \"current collector model '{}' not recognised\".format(\n                    options[\"current collector\"]\n                )\n            )\n        if options[\"dimensionality\"] not in [0, 1, 2]:\n            raise pybamm.OptionError(\n                \"Dimension of current collectors must be 0, 1, or 2, not {}\".format(\n                    options[\"dimensionality\"]\n                )\n            )\n        if options[\"thermal\"] not in [\n            \"isothermal\",\n            \"x-full\",\n            \"x-lumped\",\n            \"xyz-lumped\",\n            \"lumped\",\n        ]:\n            raise pybamm.OptionError(\n                \"Unknown thermal model '{}'\".format(options[\"thermal\"])\n            )\n        if options[\"particle\"] not in [\"Fickian diffusion\", \"fast diffusion\"]:\n            raise pybamm.OptionError(\n                \"particle model '{}' not recognised\".format(options[\"particle\"])\n            )\n\n        # Options that are incompatible with models\n        if isinstance(self, pybamm.lithium_ion.BaseModel):\n            if options[\"surface form\"] is not False:\n                raise pybamm.OptionError(\n                    \"surface form not implemented for lithium-ion models\"\n                )\n            if options[\"convection\"] is True:\n                raise pybamm.OptionError(\n                    \"convection not implemented for lithium-ion models\"\n                )\n        if isinstance(self, pybamm.lead_acid.BaseModel):\n            if options[\"thermal\"] != \"isothermal\":\n                raise pybamm.OptionError(\n                    \"thermal effects not implemented for lead-acid models\"\n                )\n            if options[\"thermal current collector\"] is True:\n                raise pybamm.OptionError(\n                    \"thermal effects not implemented for lead-acid models\"\n                )\n        self._options = options",
  "def set_standard_output_variables(self):\n        # Standard output variables\n\n        # Interfacial current\n        self.variables.update(\n            {\n                \"Negative electrode current density\": None,\n                \"Positive electrode current density\": None,\n                \"Electrolyte current density\": None,\n                \"Interfacial current density\": None,\n                \"Exchange current density\": None,\n            }\n        )\n        self.variables.update(\n            {\n                \"Negative electrode current density [A.m-2]\": None,\n                \"Positive electrode current density [A.m-2]\": None,\n                \"Electrolyte current density [A.m-2]\": None,\n                \"Interfacial current density [A.m-2]\": None,\n                \"Exchange current density [A.m-2]\": None,\n            }\n        )\n\n        # Voltage\n        self.variables.update(\n            {\n                \"Negative electrode open circuit potential\": None,\n                \"Positive electrode open circuit potential\": None,\n                \"X-averaged negative electrode open circuit potential\": None,\n                \"X-averaged positive electrode open circuit potential\": None,\n                \"X-averaged open circuit voltage\": None,\n                \"Measured open circuit voltage\": None,\n                \"Terminal voltage\": None,\n            }\n        )\n        self.variables.update(\n            {\n                \"Negative electrode open circuit potential [V]\": None,\n                \"Positive electrode open circuit potential [V]\": None,\n                \"X-averaged negative electrode open circuit potential [V]\": None,\n                \"X-averaged positive electrode open circuit potential [V]\": None,\n                \"X-averaged open circuit voltage [V]\": None,\n                \"Measured open circuit voltage [V]\": None,\n                \"Terminal voltage [V]\": None,\n            }\n        )\n\n        # Overpotentials\n        self.variables.update(\n            {\n                \"Negative reaction overpotential\": None,\n                \"Positive reaction overpotential\": None,\n                \"X-averaged negative reaction overpotential\": None,\n                \"X-averaged positive reaction overpotential\": None,\n                \"X-averaged reaction overpotential\": None,\n                \"X-averaged electrolyte overpotential\": None,\n                \"X-averaged solid phase ohmic losses\": None,\n            }\n        )\n        self.variables.update(\n            {\n                \"Negative reaction overpotential [V]\": None,\n                \"Positive reaction overpotential [V]\": None,\n                \"X-averaged negative reaction overpotential [V]\": None,\n                \"X-averaged positive reaction overpotential [V]\": None,\n                \"X-averaged reaction overpotential [V]\": None,\n                \"X-averaged electrolyte overpotential [V]\": None,\n                \"X-averaged solid phase ohmic losses [V]\": None,\n            }\n        )\n\n        # Concentration\n        self.variables.update(\n            {\n                \"Electrolyte concentration\": None,\n                \"Electrolyte concentration [mol.m-3]\": None,\n            }\n        )\n\n        # Potential\n        self.variables.update(\n            {\n                \"Negative electrode potential\": None,\n                \"Positive electrode potential\": None,\n                \"Electrolyte potential\": None,\n            }\n        )\n\n        self.variables = {}\n\n        # Current\n        i_cell = pybamm.electrical_parameters.current_with_time\n        i_cell_dim = pybamm.electrical_parameters.dimensional_current_density_with_time\n        I = pybamm.electrical_parameters.dimensional_current_with_time\n        self.variables.update(\n            {\n                \"Total current density\": i_cell,\n                \"Total current density [A.m-2]\": i_cell_dim,\n                \"Current [A]\": I,\n            }\n        )\n\n        # Time\n        time_scale = pybamm.electrical_parameters.timescale\n        self.variables.update(\n            {\n                \"Time\": pybamm.t,\n                \"Time [s]\": pybamm.t * time_scale,\n                \"Time [min]\": pybamm.t * time_scale / 60,\n                \"Time [h]\": pybamm.t * time_scale / 3600,\n                \"Discharge capacity [A.h]\": I * pybamm.t * time_scale / 3600,\n            }\n        )\n\n        # Spatial\n        var = pybamm.standard_spatial_vars\n        L_x = pybamm.geometric_parameters.L_x\n        L_y = pybamm.geometric_parameters.L_y\n        L_z = pybamm.geometric_parameters.L_z\n        self.variables.update(\n            {\n                \"x\": var.x,\n                \"x [m]\": var.x * L_x,\n                \"x_n\": var.x_n,\n                \"x_n [m]\": var.x_n * L_x,\n                \"x_s\": var.x_s,\n                \"x_s [m]\": var.x_s * L_x,\n                \"x_p\": var.x_p,\n                \"x_p [m]\": var.x_p * L_x,\n            }\n        )\n        if self.options[\"dimensionality\"] == 1:\n            self.variables.update({\"y\": var.y, \"y [m]\": var.y * L_y})\n        elif self.options[\"dimensionality\"] == 2:\n            self.variables.update(\n                {\"y\": var.y, \"y [m]\": var.y * L_y, \"z\": var.z, \"z [m]\": var.z * L_z}\n            )",
  "def build_model(self):\n\n        # Check if already built\n        if self._built:\n            raise pybamm.ModelError(\n                \"\"\"Model already built. If you are adding a new submodel, try using\n                `model.update` instead.\"\"\"\n            )\n\n        pybamm.logger.info(\"Building {}\".format(self.name))\n\n        # Get the fundamental variables\n        for submodel_name, submodel in self.submodels.items():\n            pybamm.logger.debug(\n                \"Getting fundamental variables for {} submodel ({})\".format(\n                    submodel_name, self.name\n                )\n            )\n            self.variables.update(submodel.get_fundamental_variables())\n\n        # Get coupled variables\n        # Note: pybamm will try to get the coupled variables for the submodels in the\n        # order they are set by the user. If this fails for a particular submodel,\n        # return to it later and try again. If setting coupled variables fails and\n        # there are no more submodels to try, raise an error.\n        submodels = list(self.submodels.keys())\n        while len(submodels) > 0:\n            for submodel_name, submodel in self.submodels.items():\n                if submodel_name in submodels:\n                    pybamm.logger.debug(\n                        \"Getting coupled variables for {} submodel ({})\".format(\n                            submodel_name, self.name\n                        )\n                    )\n                    try:\n                        self.variables.update(\n                            submodel.get_coupled_variables(self.variables)\n                        )\n                        submodels.remove(submodel_name)\n                    except KeyError as key:\n                        if len(submodels) == 1:\n                            # no more submodels to try\n                            raise pybamm.ModelError(\n                                \"\"\"Submodel \"{}\" requires the variable {}, but it cannot be found.\n                                Check the selected submodels provide all of the required\n                                variables.\"\"\".format(\n                                    submodel_name, key\n                                )\n                            )\n                        else:\n                            # try setting coupled variables on next loop through\n                            pass\n\n        # Set model equations\n        for submodel_name, submodel in self.submodels.items():\n            pybamm.logger.debug(\n                \"Setting rhs for {} submodel ({})\".format(submodel_name, self.name)\n            )\n            submodel.set_rhs(self.variables)\n            pybamm.logger.debug(\n                \"Setting algebraic for {} submodel ({})\".format(\n                    submodel_name, self.name\n                )\n            )\n            submodel.set_algebraic(self.variables)\n            pybamm.logger.debug(\n                \"Setting boundary conditions for {} submodel ({})\".format(\n                    submodel_name, self.name\n                )\n            )\n            submodel.set_boundary_conditions(self.variables)\n            pybamm.logger.debug(\n                \"Setting initial conditions for {} submodel ({})\".format(\n                    submodel_name, self.name\n                )\n            )\n            submodel.set_initial_conditions(self.variables)\n            submodel.set_events(self.variables)\n            pybamm.logger.debug(\n                \"Updating {} submodel ({})\".format(submodel_name, self.name)\n            )\n            self.update(submodel)\n\n        pybamm.logger.debug(\"Setting voltage variables\")\n        self.set_voltage_variables()\n\n        pybamm.logger.debug(\"Setting SoC variables\")\n        self.set_soc_variables()\n\n        # Massive hack for consistent delta_phi = phi_s - phi_e with SPMe\n        # This needs to be corrected\n        if isinstance(self, pybamm.lithium_ion.SPMe):\n            for domain in [\"Negative\", \"Positive\"]:\n                phi_s = self.variables[domain + \" electrode potential\"]\n                phi_e = self.variables[domain + \" electrolyte potential\"]\n                delta_phi = phi_s - phi_e\n                s = self.submodels[domain.lower() + \" interface\"]\n                var = s._get_standard_surface_potential_difference_variables(delta_phi)\n                self.variables.update(var)\n\n        self._built = True",
  "def set_thermal_submodel(self):\n\n        if self.options[\"thermal\"] == \"isothermal\":\n            thermal_submodel = pybamm.thermal.isothermal.Isothermal(self.param)\n\n        elif self.options[\"thermal\"] == \"x-lumped\":\n            if self.options[\"dimensionality\"] == 0:\n                if self.options[\"thermal current collector\"] is False:\n                    thermal_submodel = pybamm.thermal.x_lumped.NoCurrentCollector(\n                        self.param\n                    )\n                elif self.options[\"thermal current collector\"] is True:\n                    thermal_submodel = pybamm.thermal.x_lumped.CurrentCollector0D(\n                        self.param\n                    )\n            elif self.options[\"dimensionality\"] == 1:\n                thermal_submodel = pybamm.thermal.x_lumped.CurrentCollector1D(\n                    self.param\n                )\n            elif self.options[\"dimensionality\"] == 2:\n                thermal_submodel = pybamm.thermal.x_lumped.CurrentCollector2D(\n                    self.param\n                )\n\n        elif self.options[\"thermal\"] == \"x-full\":\n            if self.options[\"dimensionality\"] == 0:\n                if self.options[\"thermal current collector\"] is False:\n                    thermal_submodel = pybamm.thermal.x_full.NoCurrentCollector(\n                        self.param\n                    )\n                elif self.options[\"thermal current collector\"] is True:\n                    raise NotImplementedError(\n                        \"\"\"X-full thermal submodels do\n                    not yet account for current collector\"\"\"\n                    )\n            elif self.options[\"dimensionality\"] == 1:\n                raise NotImplementedError(\n                    \"\"\"X-full thermal submodels do not\n                yet support 1D current collectors\"\"\"\n                )\n            elif self.options[\"dimensionality\"] == 2:\n                raise NotImplementedError(\n                    \"\"\"X-full thermal submodels do\n                    not yet support 2D current collectors\"\"\"\n                )\n\n        elif self.options[\"thermal\"] == \"xyz-lumped\":\n            if self.options[\"dimensionality\"] == 0:\n                # note here we will just call the x_lumped model\n                # because it is equivalent\n                if self.options[\"thermal current collector\"] is False:\n                    thermal_submodel = pybamm.thermal.x_lumped.NoCurrentCollector(\n                        self.param\n                    )\n                elif self.options[\"thermal current collector\"] is True:\n                    thermal_submodel = pybamm.thermal.x_lumped.CurrentCollector0D(\n                        self.param\n                    )\n            elif self.options[\"dimensionality\"] == 1:\n                thermal_submodel = pybamm.thermal.xyz_lumped.CurrentCollector1D(\n                    self.param\n                )\n            elif self.options[\"dimensionality\"] == 2:\n                thermal_submodel = pybamm.thermal.xyz_lumped.CurrentCollector2D(\n                    self.param\n                )\n\n        elif self.options[\"thermal\"] == \"lumped\":\n            # Easy option for returning a single Temperature regardless of choice of\n            # current collector model. Note: Always includes current collector effects\n            if self.options[\"dimensionality\"] == 0:\n                thermal_submodel = pybamm.thermal.x_lumped.CurrentCollector0D(\n                    self.param\n                )\n            elif self.options[\"dimensionality\"] == 1:\n                thermal_submodel = pybamm.thermal.xyz_lumped.CurrentCollector1D(\n                    self.param\n                )\n            elif self.options[\"dimensionality\"] == 2:\n                thermal_submodel = pybamm.thermal.xyz_lumped.CurrentCollector2D(\n                    self.param\n                )\n\n        self.submodels[\"thermal\"] = thermal_submodel",
  "def set_current_collector_submodel(self):\n\n        if self.options[\"current collector\"] == \"uniform\":\n            submodel = pybamm.current_collector.Uniform(self.param)\n        elif self.options[\"current collector\"] == \"potential pair\":\n            if self.options[\"dimensionality\"] == 1:\n                submodel = pybamm.current_collector.PotentialPair1plus1D(self.param)\n            elif self.options[\"dimensionality\"] == 2:\n                submodel = pybamm.current_collector.PotentialPair2plus1D(self.param)\n        elif self.options[\"current collector\"] == \"single particle potential pair\":\n            submodel = pybamm.current_collector.SingleParticlePotentialPair(self.param)\n\n        self.submodels[\"current collector\"] = submodel",
  "def set_voltage_variables(self):\n\n        ocp_n = self.variables[\"Negative electrode open circuit potential\"]\n        ocp_p = self.variables[\"Positive electrode open circuit potential\"]\n        ocp_n_av = self.variables[\n            \"X-averaged negative electrode open circuit potential\"\n        ]\n        ocp_p_av = self.variables[\n            \"X-averaged positive electrode open circuit potential\"\n        ]\n\n        ocp_n_dim = self.variables[\"Negative electrode open circuit potential [V]\"]\n        ocp_p_dim = self.variables[\"Positive electrode open circuit potential [V]\"]\n        ocp_n_av_dim = self.variables[\n            \"X-averaged negative electrode open circuit potential [V]\"\n        ]\n        ocp_p_av_dim = self.variables[\n            \"X-averaged positive electrode open circuit potential [V]\"\n        ]\n\n        ocp_n_left = pybamm.boundary_value(ocp_n, \"left\")\n        ocp_n_left_dim = pybamm.boundary_value(ocp_n_dim, \"left\")\n        ocp_p_right = pybamm.boundary_value(ocp_p, \"right\")\n        ocp_p_right_dim = pybamm.boundary_value(ocp_p_dim, \"right\")\n\n        ocv_av = ocp_p_av - ocp_n_av\n        ocv_av_dim = ocp_p_av_dim - ocp_n_av_dim\n        ocv = ocp_p_right - ocp_n_left\n        ocv_dim = ocp_p_right_dim - ocp_n_left_dim\n\n        # overpotentials\n        eta_r_n_av = self.variables[\n            \"X-averaged negative electrode reaction overpotential\"\n        ]\n        eta_r_n_av_dim = self.variables[\n            \"X-averaged negative electrode reaction overpotential [V]\"\n        ]\n        eta_r_p_av = self.variables[\n            \"X-averaged positive electrode reaction overpotential\"\n        ]\n        eta_r_p_av_dim = self.variables[\n            \"X-averaged positive electrode reaction overpotential [V]\"\n        ]\n\n        delta_phi_s_n_av = self.variables[\"X-averaged negative electrode ohmic losses\"]\n        delta_phi_s_n_av_dim = self.variables[\n            \"X-averaged negative electrode ohmic losses [V]\"\n        ]\n        delta_phi_s_p_av = self.variables[\"X-averaged positive electrode ohmic losses\"]\n        delta_phi_s_p_av_dim = self.variables[\n            \"X-averaged positive electrode ohmic losses [V]\"\n        ]\n\n        delta_phi_s_av = delta_phi_s_p_av - delta_phi_s_n_av\n        delta_phi_s_av_dim = delta_phi_s_p_av_dim - delta_phi_s_n_av_dim\n\n        eta_r_av = eta_r_p_av - eta_r_n_av\n        eta_r_av_dim = eta_r_p_av_dim - eta_r_n_av_dim\n\n        # terminal voltage (Note: phi_s_cn is zero at the negative tab)\n        phi_s_cp = self.variables[\"Positive current collector potential\"]\n        phi_s_cp_dim = self.variables[\"Positive current collector potential [V]\"]\n        if self.options[\"dimensionality\"] == 0:\n            V = phi_s_cp\n            V_dim = phi_s_cp_dim\n        elif self.options[\"dimensionality\"] in [1, 2]:\n            V = pybamm.BoundaryValue(phi_s_cp, \"positive tab\")\n            V_dim = pybamm.BoundaryValue(phi_s_cp_dim, \"positive tab\")\n\n        # TODO: add current collector losses to the voltage in 3D\n\n        self.variables.update(\n            {\n                \"X-averaged open circuit voltage\": ocv_av,\n                \"Measured open circuit voltage\": ocv,\n                \"X-averaged open circuit voltage [V]\": ocv_av_dim,\n                \"Measured open circuit voltage [V]\": ocv_dim,\n                \"X-averaged reaction overpotential\": eta_r_av,\n                \"X-averaged reaction overpotential [V]\": eta_r_av_dim,\n                \"X-averaged solid phase ohmic losses\": delta_phi_s_av,\n                \"X-averaged solid phase ohmic losses [V]\": delta_phi_s_av_dim,\n                \"Terminal voltage\": V,\n                \"Terminal voltage [V]\": V_dim,\n            }\n        )\n\n        # Battery-wide variables\n        eta_e_av_dim = self.variables.get(\"X-averaged electrolyte ohmic losses [V]\", 0)\n        eta_c_av_dim = self.variables.get(\n            \"X-averaged concentration overpotential [V]\", 0\n        )\n        num_cells = pybamm.Parameter(\n            \"Number of cells connected in series to make a battery\"\n        )\n\n        self.variables.update(\n            {\n                \"X-averaged battery open circuit voltage [V]\": ocv_av_dim * num_cells,\n                \"Measured battery open circuit voltage [V]\": ocv_dim * num_cells,\n                \"X-averaged battery reaction overpotential [V]\": eta_r_av_dim\n                * num_cells,\n                \"X-averaged battery solid phase ohmic losses [V]\": delta_phi_s_av_dim\n                * num_cells,\n                \"X-averaged battery electrolyte ohmic losses [V]\": eta_e_av_dim\n                * num_cells,\n                \"X-averaged battery concentration overpotential [V]\": eta_c_av_dim\n                * num_cells,\n                \"Battery voltage [V]\": V_dim * num_cells,\n            }\n        )\n\n        # Cut-off voltage\n        voltage = self.variables[\"Terminal voltage\"]\n        self.events[\"Minimum voltage\"] = voltage - self.param.voltage_low_cut\n        self.events[\"Maximum voltage\"] = voltage - self.param.voltage_high_cut",
  "def set_soc_variables(self):\n        \"\"\"\n        Set variables relating to the state of charge.\n        This function is overriden by the base battery models\n        \"\"\"\n        pass",
  "def process_parameters_and_discretise(self, symbol, parameter_values, disc):\n        \"\"\"\n        Process parameters and discretise a symbol using supplied parameter values\n        and discretisation. Note: care should be taken if using spatial operators\n        on dimensional symbols. Operators in pybamm are written in non-dimensional\n        form, so may need to be scaled by the appropriate length scale. It is\n        recommended to use this method on non-dimensional symbols.\n\n        Parameters\n        ----------\n        symbol : :class:`pybamm.Symbol`\n            Symbol to be processed\n        parameter_values : :class:`pybamm.ParameterValues`\n            The parameter values to use during processing\n        disc : :class:`pybamm.Discretisation`\n            The discrisation to use\n\n        Returns\n        -------\n        :class:`pybamm.Symbol`\n            Processed symbol\n        \"\"\"\n        # Set y slices\n        if disc.y_slices == {}:\n            variables = list(self.rhs.keys()) + list(self.algebraic.keys())\n            disc.set_variable_slices(variables)\n\n        # Set boundary condtions\n        if disc.bcs == {}:\n            disc.bcs = disc.process_boundary_conditions(self)\n\n        # Process\n        param_symbol = parameter_values.process_symbol(symbol)\n        disc_symbol = disc.process_symbol(param_symbol)\n\n        return disc_symbol",
  "class BaseHigherOrderModel(BaseModel):\n    \"\"\"Base model for higher-order models for lead-acid, from [1]_.\n    Uses leading-order model from :class:`pybamm.lead_acid.LOQS`\n\n    Parameters\n    ----------\n    options : dict, optional\n        A dictionary of options to be passed to the model.\n    name : str, optional\n        The name of the model.\n    build :  bool, optional\n        Whether to build the model on instantiation. Default is True. Setting this\n        option to False allows users to change any number of the submodels before\n        building the complete model (submodels cannot be changed after the model is\n        built).\n\n    References\n    ----------\n    .. [1] V Sulzer, SJ Chapman, CP Please, DA Howey, and CW Monroe. Faster lead-acid\n           battery simulations from porous-electrode theory: Part II. Asymptotic\n           analysis. Journal of The Electrochemical Society 166.12 (2019), A2372\u2013A2382.\n\n\n    **Extends:** :class:`pybamm.lead_acid.BaseModel`\n    \"\"\"\n\n    def __init__(self, options=None, name=\"Composite model\", build=True):\n        super().__init__(options, name)\n\n        self.set_leading_order_model()\n        self.set_reactions()\n        # Electrolyte submodel to get first-order concentrations\n        self.set_electrolyte_diffusion_submodel()\n        self.set_other_species_diffusion_submodels()\n        # Average interface submodel to get average first-order potential differences\n        self.set_average_interfacial_submodel()\n        # Electrolyte and solid submodels to get full first-order potentials\n        self.set_negative_electrode_submodel()\n        self.set_electrolyte_conductivity_submodel()\n        self.set_positive_electrode_submodel()\n        # Update interface, porosity and convection with full potentials\n        self.set_full_interface_submodel()\n        self.set_full_convection_submodel()\n        self.set_full_porosity_submodel()\n        self.set_thermal_submodel()\n        self.set_current_collector_submodel()\n\n        if build:\n            self.build_model()\n\n    def set_current_collector_submodel(self):\n        cc = pybamm.current_collector\n\n        if self.options[\"current collector\"] == \"uniform\":\n            submodel = cc.Uniform(self.param)\n        elif self.options[\"current collector\"] == \"potential pair quite conductive\":\n            if self.options[\"dimensionality\"] == 1:\n                submodel = cc.QuiteConductivePotentialPair1plus1D(self.param)\n            elif self.options[\"dimensionality\"] == 2:\n                submodel = cc.QuiteConductivePotentialPair2plus1D(self.param)\n        elif self.options[\"current collector\"] == \"potential pair\":\n            if self.options[\"dimensionality\"] == 1:\n                submodel = cc.CompositePotentialPair1plus1D(self.param)\n            elif self.options[\"dimensionality\"] == 2:\n                submodel = cc.CompositePotentialPair2plus1D(self.param)\n        self.submodels[\"current collector\"] = submodel\n\n    def set_leading_order_model(self):\n        leading_order_model = pybamm.lead_acid.LOQS(\n            self.options, name=\"LOQS model (for composite model)\"\n        )\n        self.update(leading_order_model)\n        self.reaction_submodels = leading_order_model.reaction_submodels\n\n        # Leading-order variables\n        leading_order_variables = {}\n        for variable in self.variables.keys():\n            leading_order_variables[\n                \"Leading-order \" + variable.lower()\n            ] = leading_order_model.variables[variable]\n        self.variables.update(leading_order_variables)\n        self.variables[\n            \"Leading-order electrolyte concentration change\"\n        ] = leading_order_model.rhs[\n            leading_order_model.variables[\"X-averaged electrolyte concentration\"]\n        ]\n\n    def set_average_interfacial_submodel(self):\n        self.submodels[\n            \"x-averaged negative interface\"\n        ] = pybamm.interface.lead_acid.InverseFirstOrderKinetics(self.param, \"Negative\")\n        self.submodels[\n            \"x-averaged negative interface\"\n        ].reaction_submodels = self.reaction_submodels[\"Negative\"]\n        self.submodels[\n            \"x-averaged positive interface\"\n        ] = pybamm.interface.lead_acid.InverseFirstOrderKinetics(self.param, \"Positive\")\n        self.submodels[\n            \"x-averaged positive interface\"\n        ].reaction_submodels = self.reaction_submodels[\"Positive\"]\n\n    def set_electrolyte_conductivity_submodel(self):\n        self.submodels[\n            \"electrolyte conductivity\"\n        ] = pybamm.electrolyte.stefan_maxwell.conductivity.FirstOrder(self.param)\n\n    def set_negative_electrode_submodel(self):\n        self.submodels[\"negative electrode\"] = pybamm.electrode.ohm.Composite(\n            self.param, \"Negative\"\n        )\n\n    def set_positive_electrode_submodel(self):\n        self.submodels[\"positive electrode\"] = pybamm.electrode.ohm.Composite(\n            self.param, \"Positive\"\n        )\n\n    def set_full_interface_submodel(self):\n        \"\"\"\n        Set full interface submodel, to get spatially heterogeneous interfacial current\n        densities\n        \"\"\"\n        # Main reaction\n        self.submodels[\n            \"negative interface\"\n        ] = pybamm.interface.lead_acid.FirstOrderButlerVolmer(self.param, \"Negative\")\n        self.submodels[\n            \"positive interface\"\n        ] = pybamm.interface.lead_acid.FirstOrderButlerVolmer(self.param, \"Positive\")\n\n        # Oxygen\n        if \"oxygen\" in self.options[\"side reactions\"]:\n            self.submodels[\n                \"positive oxygen interface\"\n            ] = pybamm.interface.lead_acid_oxygen.FirstOrderForwardTafel(\n                self.param, \"Positive\"\n            )\n            self.submodels[\n                \"negative oxygen interface\"\n            ] = pybamm.interface.lead_acid_oxygen.FullDiffusionLimited(\n                self.param, \"Negative\"\n            )\n\n    def set_full_convection_submodel(self):\n        \"\"\"\n        Update convection submodel, now that we have the spatially heterogeneous\n        interfacial current densities\n        \"\"\"\n        if self.options[\"convection\"] is False:\n            self.submodels[\"full convection\"] = pybamm.convection.NoConvection(\n                self.param\n            )\n        if self.options[\"convection\"] is True:\n            self.submodels[\"full convection\"] = pybamm.convection.Composite(self.param)\n\n    def set_full_porosity_submodel(self):\n        \"\"\"\n        Update porosity submodel, now that we have the spatially heterogeneous\n        interfacial current densities\n        \"\"\"\n        self.submodels[\"full porosity\"] = pybamm.porosity.Full(self.param)\n\n    @property\n    def default_solver(self):\n        \"\"\"\n        Create and return the default solver for this model\n        \"\"\"\n        # Different solver depending on whether we solve ODEs or DAEs\n        if (\n            self.options[\"current collector\"] != \"uniform\"\n            or self.options[\"surface form\"] == \"algebraic\"\n        ):\n            return pybamm.ScikitsDaeSolver()\n        else:\n            return pybamm.ScipySolver()",
  "class FOQS(BaseHigherOrderModel):\n    \"\"\"First-order quasi-static model for lead-acid, from [1]_.\n    Uses leading-order model from :class:`pybamm.lead_acid.LOQS`\n\n    Parameters\n    ----------\n    options : dict, optional\n        A dictionary of options to be passed to the model.\n    name : str, optional\n        The name of the model.\n    build :  bool, optional\n        Whether to build the model on instantiation. Default is True. Setting this\n        option to False allows users to change any number of the submodels before\n        building the complete model (submodels cannot be changed after the model is\n        built).\n\n    **Extends:** :class:`pybamm.lead_acid.BaseHigherOrderModel`\n    \"\"\"\n\n    def __init__(self, options=None, name=\"FOQS model\", build=True):\n        super().__init__(options, name, build=build)\n\n    def set_electrolyte_diffusion_submodel(self):\n        self.submodels[\n            \"electrolyte diffusion\"\n        ] = pybamm.electrolyte.stefan_maxwell.diffusion.FirstOrder(\n            self.param, self.reactions\n        )\n\n    def set_other_species_diffusion_submodels(self):\n        if \"oxygen\" in self.options[\"side reactions\"]:\n            self.submodels[\"oxygen diffusion\"] = pybamm.oxygen_diffusion.FirstOrder(\n                self.param, self.reactions\n            )\n\n    def set_full_porosity_submodel(self):\n        \"\"\"\n        Update porosity submodel, now that we have the spatially heterogeneous\n        interfacial current densities\n        \"\"\"\n        # TODO: fix shape for jacobian\n        pass",
  "class Composite(BaseHigherOrderModel):\n    \"\"\"Composite model for lead-acid, from [1]_.\n    Uses leading-order model from :class:`pybamm.lead_acid.LOQS`\n\n    **Extends:** :class:`pybamm.lead_acid.BaseHigherOrderModel`\n    \"\"\"\n\n    def __init__(self, options=None, name=\"Composite model\", build=True):\n        super().__init__(options, name, build=build)\n\n    def set_electrolyte_diffusion_submodel(self):\n        self.submodels[\n            \"electrolyte diffusion\"\n        ] = pybamm.electrolyte.stefan_maxwell.diffusion.Composite(\n            self.param, self.reactions\n        )\n\n    def set_other_species_diffusion_submodels(self):\n        if \"oxygen\" in self.options[\"side reactions\"]:\n            self.submodels[\"oxygen diffusion\"] = pybamm.oxygen_diffusion.Composite(\n                self.param, self.reactions\n            )\n\n    def set_full_porosity_submodel(self):\n        \"\"\"\n        Update porosity submodel, now that we have the spatially heterogeneous\n        interfacial current densities\n        \"\"\"\n        self.submodels[\"full porosity\"] = pybamm.porosity.Full(self.param)",
  "class CompositeExtended(BaseHigherOrderModel):\n    \"\"\"Extended composite model for lead-acid, from [2]_.\n    Uses leading-order model from :class:`pybamm.lead_acid.LOQS`\n\n    Parameters\n    ----------\n    options : dict, optional\n        A dictionary of options to be passed to the model.\n    name : str, optional\n        The name of the model.\n    build :  bool, optional\n        Whether to build the model on instantiation. Default is True. Setting this\n        option to False allows users to change any number of the submodels before\n        building the complete model (submodels cannot be changed after the model is\n        built).\n\n    References\n    ----------\n    .. [2] V Sulzer. Mathematical modelling of lead-acid batteries. PhD thesis,\n           University of Oxford, 2019.\n\n\n    **Extends:** :class:`pybamm.lead_acid.BaseHigherOrderModel`\n    \"\"\"\n\n    def __init__(self, options=None, name=\"Extended composite model\", build=True):\n        super().__init__(options, name, build=build)\n\n    def set_electrolyte_diffusion_submodel(self):\n        self.submodels[\n            \"electrolyte diffusion\"\n        ] = pybamm.electrolyte.stefan_maxwell.diffusion.Composite(\n            self.param, self.reactions, extended=True\n        )\n\n    def set_other_species_diffusion_submodels(self):\n        if \"oxygen\" in self.options[\"side reactions\"]:\n            self.submodels[\"oxygen diffusion\"] = pybamm.oxygen_diffusion.Composite(\n                self.param, self.reactions, extended=True\n            )\n\n    def set_full_porosity_submodel(self):\n        \"\"\"\n        Update porosity submodel, now that we have the spatially heterogeneous\n        interfacial current densities\n        \"\"\"\n        self.submodels[\"full porosity\"] = pybamm.porosity.Full(self.param)",
  "def __init__(self, options=None, name=\"Composite model\", build=True):\n        super().__init__(options, name)\n\n        self.set_leading_order_model()\n        self.set_reactions()\n        # Electrolyte submodel to get first-order concentrations\n        self.set_electrolyte_diffusion_submodel()\n        self.set_other_species_diffusion_submodels()\n        # Average interface submodel to get average first-order potential differences\n        self.set_average_interfacial_submodel()\n        # Electrolyte and solid submodels to get full first-order potentials\n        self.set_negative_electrode_submodel()\n        self.set_electrolyte_conductivity_submodel()\n        self.set_positive_electrode_submodel()\n        # Update interface, porosity and convection with full potentials\n        self.set_full_interface_submodel()\n        self.set_full_convection_submodel()\n        self.set_full_porosity_submodel()\n        self.set_thermal_submodel()\n        self.set_current_collector_submodel()\n\n        if build:\n            self.build_model()",
  "def set_current_collector_submodel(self):\n        cc = pybamm.current_collector\n\n        if self.options[\"current collector\"] == \"uniform\":\n            submodel = cc.Uniform(self.param)\n        elif self.options[\"current collector\"] == \"potential pair quite conductive\":\n            if self.options[\"dimensionality\"] == 1:\n                submodel = cc.QuiteConductivePotentialPair1plus1D(self.param)\n            elif self.options[\"dimensionality\"] == 2:\n                submodel = cc.QuiteConductivePotentialPair2plus1D(self.param)\n        elif self.options[\"current collector\"] == \"potential pair\":\n            if self.options[\"dimensionality\"] == 1:\n                submodel = cc.CompositePotentialPair1plus1D(self.param)\n            elif self.options[\"dimensionality\"] == 2:\n                submodel = cc.CompositePotentialPair2plus1D(self.param)\n        self.submodels[\"current collector\"] = submodel",
  "def set_leading_order_model(self):\n        leading_order_model = pybamm.lead_acid.LOQS(\n            self.options, name=\"LOQS model (for composite model)\"\n        )\n        self.update(leading_order_model)\n        self.reaction_submodels = leading_order_model.reaction_submodels\n\n        # Leading-order variables\n        leading_order_variables = {}\n        for variable in self.variables.keys():\n            leading_order_variables[\n                \"Leading-order \" + variable.lower()\n            ] = leading_order_model.variables[variable]\n        self.variables.update(leading_order_variables)\n        self.variables[\n            \"Leading-order electrolyte concentration change\"\n        ] = leading_order_model.rhs[\n            leading_order_model.variables[\"X-averaged electrolyte concentration\"]\n        ]",
  "def set_average_interfacial_submodel(self):\n        self.submodels[\n            \"x-averaged negative interface\"\n        ] = pybamm.interface.lead_acid.InverseFirstOrderKinetics(self.param, \"Negative\")\n        self.submodels[\n            \"x-averaged negative interface\"\n        ].reaction_submodels = self.reaction_submodels[\"Negative\"]\n        self.submodels[\n            \"x-averaged positive interface\"\n        ] = pybamm.interface.lead_acid.InverseFirstOrderKinetics(self.param, \"Positive\")\n        self.submodels[\n            \"x-averaged positive interface\"\n        ].reaction_submodels = self.reaction_submodels[\"Positive\"]",
  "def set_electrolyte_conductivity_submodel(self):\n        self.submodels[\n            \"electrolyte conductivity\"\n        ] = pybamm.electrolyte.stefan_maxwell.conductivity.FirstOrder(self.param)",
  "def set_negative_electrode_submodel(self):\n        self.submodels[\"negative electrode\"] = pybamm.electrode.ohm.Composite(\n            self.param, \"Negative\"\n        )",
  "def set_positive_electrode_submodel(self):\n        self.submodels[\"positive electrode\"] = pybamm.electrode.ohm.Composite(\n            self.param, \"Positive\"\n        )",
  "def set_full_interface_submodel(self):\n        \"\"\"\n        Set full interface submodel, to get spatially heterogeneous interfacial current\n        densities\n        \"\"\"\n        # Main reaction\n        self.submodels[\n            \"negative interface\"\n        ] = pybamm.interface.lead_acid.FirstOrderButlerVolmer(self.param, \"Negative\")\n        self.submodels[\n            \"positive interface\"\n        ] = pybamm.interface.lead_acid.FirstOrderButlerVolmer(self.param, \"Positive\")\n\n        # Oxygen\n        if \"oxygen\" in self.options[\"side reactions\"]:\n            self.submodels[\n                \"positive oxygen interface\"\n            ] = pybamm.interface.lead_acid_oxygen.FirstOrderForwardTafel(\n                self.param, \"Positive\"\n            )\n            self.submodels[\n                \"negative oxygen interface\"\n            ] = pybamm.interface.lead_acid_oxygen.FullDiffusionLimited(\n                self.param, \"Negative\"\n            )",
  "def set_full_convection_submodel(self):\n        \"\"\"\n        Update convection submodel, now that we have the spatially heterogeneous\n        interfacial current densities\n        \"\"\"\n        if self.options[\"convection\"] is False:\n            self.submodels[\"full convection\"] = pybamm.convection.NoConvection(\n                self.param\n            )\n        if self.options[\"convection\"] is True:\n            self.submodels[\"full convection\"] = pybamm.convection.Composite(self.param)",
  "def set_full_porosity_submodel(self):\n        \"\"\"\n        Update porosity submodel, now that we have the spatially heterogeneous\n        interfacial current densities\n        \"\"\"\n        self.submodels[\"full porosity\"] = pybamm.porosity.Full(self.param)",
  "def default_solver(self):\n        \"\"\"\n        Create and return the default solver for this model\n        \"\"\"\n        # Different solver depending on whether we solve ODEs or DAEs\n        if (\n            self.options[\"current collector\"] != \"uniform\"\n            or self.options[\"surface form\"] == \"algebraic\"\n        ):\n            return pybamm.ScikitsDaeSolver()\n        else:\n            return pybamm.ScipySolver()",
  "def __init__(self, options=None, name=\"FOQS model\", build=True):\n        super().__init__(options, name, build=build)",
  "def set_electrolyte_diffusion_submodel(self):\n        self.submodels[\n            \"electrolyte diffusion\"\n        ] = pybamm.electrolyte.stefan_maxwell.diffusion.FirstOrder(\n            self.param, self.reactions\n        )",
  "def set_other_species_diffusion_submodels(self):\n        if \"oxygen\" in self.options[\"side reactions\"]:\n            self.submodels[\"oxygen diffusion\"] = pybamm.oxygen_diffusion.FirstOrder(\n                self.param, self.reactions\n            )",
  "def set_full_porosity_submodel(self):\n        \"\"\"\n        Update porosity submodel, now that we have the spatially heterogeneous\n        interfacial current densities\n        \"\"\"\n        # TODO: fix shape for jacobian\n        pass",
  "def __init__(self, options=None, name=\"Composite model\", build=True):\n        super().__init__(options, name, build=build)",
  "def set_electrolyte_diffusion_submodel(self):\n        self.submodels[\n            \"electrolyte diffusion\"\n        ] = pybamm.electrolyte.stefan_maxwell.diffusion.Composite(\n            self.param, self.reactions\n        )",
  "def set_other_species_diffusion_submodels(self):\n        if \"oxygen\" in self.options[\"side reactions\"]:\n            self.submodels[\"oxygen diffusion\"] = pybamm.oxygen_diffusion.Composite(\n                self.param, self.reactions\n            )",
  "def set_full_porosity_submodel(self):\n        \"\"\"\n        Update porosity submodel, now that we have the spatially heterogeneous\n        interfacial current densities\n        \"\"\"\n        self.submodels[\"full porosity\"] = pybamm.porosity.Full(self.param)",
  "def __init__(self, options=None, name=\"Extended composite model\", build=True):\n        super().__init__(options, name, build=build)",
  "def set_electrolyte_diffusion_submodel(self):\n        self.submodels[\n            \"electrolyte diffusion\"\n        ] = pybamm.electrolyte.stefan_maxwell.diffusion.Composite(\n            self.param, self.reactions, extended=True\n        )",
  "def set_other_species_diffusion_submodels(self):\n        if \"oxygen\" in self.options[\"side reactions\"]:\n            self.submodels[\"oxygen diffusion\"] = pybamm.oxygen_diffusion.Composite(\n                self.param, self.reactions, extended=True\n            )",
  "def set_full_porosity_submodel(self):\n        \"\"\"\n        Update porosity submodel, now that we have the spatially heterogeneous\n        interfacial current densities\n        \"\"\"\n        self.submodels[\"full porosity\"] = pybamm.porosity.Full(self.param)",
  "class BaseModel(pybamm.BaseBatteryModel):\n    \"\"\"\n    Overwrites default parameters from Base Model with default parameters for\n    lead-acid models\n\n\n    **Extends:** :class:`pybamm.BaseBatteryModel`\n\n    \"\"\"\n\n    def __init__(self, options=None, name=\"Unnamed lead-acid model\"):\n        super().__init__(options, name)\n        self.param = pybamm.standard_parameters_lead_acid\n\n    @property\n    def default_parameter_values(self):\n        return pybamm.ParameterValues(chemistry=pybamm.parameter_sets.Sulzer2019)\n\n    @property\n    def default_geometry(self):\n        if self.options[\"dimensionality\"] == 0:\n            return pybamm.Geometry(\"1D macro\")\n        elif self.options[\"dimensionality\"] == 1:\n            return pybamm.Geometry(\"1+1D macro\")\n        elif self.options[\"dimensionality\"] == 2:\n            return pybamm.Geometry(\"2+1D macro\")\n\n    @property\n    def default_var_pts(self):\n        var = pybamm.standard_spatial_vars\n        return {var.x_n: 30, var.x_s: 30, var.x_p: 30, var.y: 10, var.z: 10}\n\n    def set_standard_output_variables(self):\n        super().set_standard_output_variables()\n        # Current\n        i_cell = pybamm.standard_parameters_lead_acid.current_with_time\n        i_cell_dim = (\n            pybamm.standard_parameters_lead_acid.dimensional_current_density_with_time\n        )\n        I = pybamm.standard_parameters_lead_acid.dimensional_current_with_time\n        self.variables.update(\n            {\n                \"Total current density\": i_cell,\n                \"Total current density [A.m-2]\": i_cell_dim,\n                \"Current [A]\": I,\n            }\n        )\n\n        # Time\n        time_scale = pybamm.standard_parameters_lead_acid.tau_discharge\n        self.variables.update(\n            {\n                \"Time [s]\": pybamm.t * time_scale,\n                \"Time [min]\": pybamm.t * time_scale / 60,\n                \"Time [h]\": pybamm.t * time_scale / 3600,\n                \"Discharge capacity [A.h]\": I * pybamm.t * time_scale / 3600,\n            }\n        )\n\n    def set_reactions(self):\n\n        # Should probably refactor as this is a bit clunky at the moment\n        # Maybe each reaction as a Reaction class so we can just list names of classes\n        param = self.param\n        icd = \" interfacial current density\"\n        self.reactions = {\n            \"main\": {\n                \"Negative\": {\"s\": param.s_n, \"aj\": \"Negative electrode\" + icd},\n                \"Positive\": {\"s\": param.s_p, \"aj\": \"Positive electrode\" + icd},\n            }\n        }\n        if \"oxygen\" in self.options[\"side reactions\"]:\n            self.reactions[\"oxygen\"] = {\n                \"Negative\": {\n                    \"s\": -(param.s_plus_Ox + param.t_plus),\n                    \"s_ox\": -param.s_ox_Ox,\n                    \"aj\": \"Negative electrode oxygen\" + icd,\n                },\n                \"Positive\": {\n                    \"s\": -(param.s_plus_Ox + param.t_plus),\n                    \"s_ox\": -param.s_ox_Ox,\n                    \"aj\": \"Positive electrode oxygen\" + icd,\n                },\n            }\n            self.reactions[\"main\"][\"Negative\"][\"s_ox\"] = 0\n            self.reactions[\"main\"][\"Positive\"][\"s_ox\"] = 0\n\n    def set_soc_variables(self):\n        \"Set variables relating to the state of charge.\"\n        # State of Charge defined as function of dimensionless electrolyte concentration\n        soc = self.variables[\"X-averaged electrolyte concentration\"] * 100\n        self.variables.update({\"State of Charge\": soc, \"Depth of Discharge\": 100 - soc})\n\n        # Fractional charge input\n        if \"Fractional Charge Input\" not in self.variables:\n            fci = pybamm.Variable(\"Fractional Charge Input\", domain=\"current collector\")\n            self.variables[\"Fractional Charge Input\"] = fci\n            self.rhs[fci] = -self.param.current_with_time * 100\n            self.initial_conditions[fci] = self.param.q_init * 100",
  "def __init__(self, options=None, name=\"Unnamed lead-acid model\"):\n        super().__init__(options, name)\n        self.param = pybamm.standard_parameters_lead_acid",
  "def default_parameter_values(self):\n        return pybamm.ParameterValues(chemistry=pybamm.parameter_sets.Sulzer2019)",
  "def default_geometry(self):\n        if self.options[\"dimensionality\"] == 0:\n            return pybamm.Geometry(\"1D macro\")\n        elif self.options[\"dimensionality\"] == 1:\n            return pybamm.Geometry(\"1+1D macro\")\n        elif self.options[\"dimensionality\"] == 2:\n            return pybamm.Geometry(\"2+1D macro\")",
  "def default_var_pts(self):\n        var = pybamm.standard_spatial_vars\n        return {var.x_n: 30, var.x_s: 30, var.x_p: 30, var.y: 10, var.z: 10}",
  "def set_standard_output_variables(self):\n        super().set_standard_output_variables()\n        # Current\n        i_cell = pybamm.standard_parameters_lead_acid.current_with_time\n        i_cell_dim = (\n            pybamm.standard_parameters_lead_acid.dimensional_current_density_with_time\n        )\n        I = pybamm.standard_parameters_lead_acid.dimensional_current_with_time\n        self.variables.update(\n            {\n                \"Total current density\": i_cell,\n                \"Total current density [A.m-2]\": i_cell_dim,\n                \"Current [A]\": I,\n            }\n        )\n\n        # Time\n        time_scale = pybamm.standard_parameters_lead_acid.tau_discharge\n        self.variables.update(\n            {\n                \"Time [s]\": pybamm.t * time_scale,\n                \"Time [min]\": pybamm.t * time_scale / 60,\n                \"Time [h]\": pybamm.t * time_scale / 3600,\n                \"Discharge capacity [A.h]\": I * pybamm.t * time_scale / 3600,\n            }\n        )",
  "def set_reactions(self):\n\n        # Should probably refactor as this is a bit clunky at the moment\n        # Maybe each reaction as a Reaction class so we can just list names of classes\n        param = self.param\n        icd = \" interfacial current density\"\n        self.reactions = {\n            \"main\": {\n                \"Negative\": {\"s\": param.s_n, \"aj\": \"Negative electrode\" + icd},\n                \"Positive\": {\"s\": param.s_p, \"aj\": \"Positive electrode\" + icd},\n            }\n        }\n        if \"oxygen\" in self.options[\"side reactions\"]:\n            self.reactions[\"oxygen\"] = {\n                \"Negative\": {\n                    \"s\": -(param.s_plus_Ox + param.t_plus),\n                    \"s_ox\": -param.s_ox_Ox,\n                    \"aj\": \"Negative electrode oxygen\" + icd,\n                },\n                \"Positive\": {\n                    \"s\": -(param.s_plus_Ox + param.t_plus),\n                    \"s_ox\": -param.s_ox_Ox,\n                    \"aj\": \"Positive electrode oxygen\" + icd,\n                },\n            }\n            self.reactions[\"main\"][\"Negative\"][\"s_ox\"] = 0\n            self.reactions[\"main\"][\"Positive\"][\"s_ox\"] = 0",
  "def set_soc_variables(self):\n        \"Set variables relating to the state of charge.\"\n        # State of Charge defined as function of dimensionless electrolyte concentration\n        soc = self.variables[\"X-averaged electrolyte concentration\"] * 100\n        self.variables.update({\"State of Charge\": soc, \"Depth of Discharge\": 100 - soc})\n\n        # Fractional charge input\n        if \"Fractional Charge Input\" not in self.variables:\n            fci = pybamm.Variable(\"Fractional Charge Input\", domain=\"current collector\")\n            self.variables[\"Fractional Charge Input\"] = fci\n            self.rhs[fci] = -self.param.current_with_time * 100\n            self.initial_conditions[fci] = self.param.q_init * 100",
  "class Full(BaseModel):\n    \"\"\"Porous electrode model for lead-acid, from [1]_, based on the Full\n    model.\n\n    Parameters\n    ----------\n    options : dict, optional\n        A dictionary of options to be passed to the model.\n    name : str, optional\n        The name of the model.\n    build :  bool, optional\n        Whether to build the model on instantiation. Default is True. Setting this\n        option to False allows users to change any number of the submodels before\n        building the complete model (submodels cannot be changed after the model is\n        built).\n\n    References\n    ----------\n    .. [1] V Sulzer, SJ Chapman, CP Please, DA Howey, and CW Monroe. Faster lead-acid\n           battery simulations from porous-electrode theory: Part II. Asymptotic\n           analysis. Journal of The Electrochemical Society 166.12 (2019), A2372\u2013A2382.\n\n\n    **Extends:** :class:`pybamm.lead_acid.BaseModel`\n    \"\"\"\n\n    def __init__(self, options=None, name=\"Full model\", build=True):\n        super().__init__(options, name)\n\n        self.set_reactions()\n        self.set_interfacial_submodel()\n        self.set_porosity_submodel()\n        self.set_convection_submodel()\n        self.set_electrolyte_submodel()\n        self.set_solid_submodel()\n        self.set_thermal_submodel()\n        self.set_side_reaction_submodels()\n        self.set_current_collector_submodel()\n\n        if build:\n            self.build_model()\n\n    def set_porosity_submodel(self):\n        self.submodels[\"porosity\"] = pybamm.porosity.Full(self.param)\n\n    def set_convection_submodel(self):\n        if self.options[\"convection\"] is False:\n            self.submodels[\"convection\"] = pybamm.convection.NoConvection(self.param)\n        if self.options[\"convection\"] is True:\n            self.submodels[\"convection\"] = pybamm.convection.Full(self.param)\n\n    def set_interfacial_submodel(self):\n        self.submodels[\"negative interface\"] = pybamm.interface.lead_acid.ButlerVolmer(\n            self.param, \"Negative\"\n        )\n        self.submodels[\"positive interface\"] = pybamm.interface.lead_acid.ButlerVolmer(\n            self.param, \"Positive\"\n        )\n\n    def set_solid_submodel(self):\n        if self.options[\"surface form\"] is False:\n            submod_n = pybamm.electrode.ohm.Full(self.param, \"Negative\", self.reactions)\n            submod_p = pybamm.electrode.ohm.Full(self.param, \"Positive\", self.reactions)\n        else:\n            submod_n = pybamm.electrode.ohm.SurfaceForm(self.param, \"Negative\")\n            submod_p = pybamm.electrode.ohm.SurfaceForm(self.param, \"Positive\")\n\n        self.submodels[\"negative electrode\"] = submod_n\n        self.submodels[\"positive electrode\"] = submod_p\n\n    def set_electrolyte_submodel(self):\n\n        electrolyte = pybamm.electrolyte.stefan_maxwell\n        surf_form = electrolyte.conductivity.surface_potential_form\n\n        self.submodels[\"electrolyte diffusion\"] = electrolyte.diffusion.Full(\n            self.param, self.reactions\n        )\n\n        if self.options[\"surface form\"] is False:\n            self.submodels[\"electrolyte conductivity\"] = electrolyte.conductivity.Full(\n                self.param, self.reactions\n            )\n        elif self.options[\"surface form\"] == \"differential\":\n            for domain in [\"Negative\", \"Separator\", \"Positive\"]:\n                self.submodels[\n                    domain.lower() + \" electrolyte conductivity\"\n                ] = surf_form.FullDifferential(self.param, domain, self.reactions)\n        elif self.options[\"surface form\"] == \"algebraic\":\n            for domain in [\"Negative\", \"Separator\", \"Positive\"]:\n                self.submodels[\n                    domain.lower() + \" electrolyte conductivity\"\n                ] = surf_form.FullAlgebraic(self.param, domain, self.reactions)\n\n    def set_side_reaction_submodels(self):\n        if \"oxygen\" in self.options[\"side reactions\"]:\n            self.submodels[\"oxygen diffusion\"] = pybamm.oxygen_diffusion.Full(\n                self.param, self.reactions\n            )\n            self.submodels[\n                \"positive oxygen interface\"\n            ] = pybamm.interface.lead_acid_oxygen.ForwardTafel(self.param, \"Positive\")\n            self.submodels[\n                \"negative oxygen interface\"\n            ] = pybamm.interface.lead_acid_oxygen.FullDiffusionLimited(\n                self.param, \"Negative\"\n            )\n        else:\n            self.submodels[\"oxygen diffusion\"] = pybamm.oxygen_diffusion.NoOxygen(\n                self.param\n            )\n            self.submodels[\n                \"positive oxygen interface\"\n            ] = pybamm.interface.lead_acid_oxygen.NoReaction(self.param, \"Positive\")\n            self.submodels[\n                \"negative oxygen interface\"\n            ] = pybamm.interface.lead_acid_oxygen.NoReaction(self.param, \"Negative\")\n\n    @property\n    def default_solver(self):\n        \"\"\"\n        Create and return the default solver for this model\n        \"\"\"\n        # Different solver depending on whether we solve ODEs or DAEs\n        if (\n            self.options[\"surface form\"] == \"differential\"\n            and self.options[\"current collector\"] == \"uniform\"\n        ):\n            return pybamm.ScipySolver()\n        else:\n            return pybamm.ScikitsDaeSolver()",
  "def __init__(self, options=None, name=\"Full model\", build=True):\n        super().__init__(options, name)\n\n        self.set_reactions()\n        self.set_interfacial_submodel()\n        self.set_porosity_submodel()\n        self.set_convection_submodel()\n        self.set_electrolyte_submodel()\n        self.set_solid_submodel()\n        self.set_thermal_submodel()\n        self.set_side_reaction_submodels()\n        self.set_current_collector_submodel()\n\n        if build:\n            self.build_model()",
  "def set_porosity_submodel(self):\n        self.submodels[\"porosity\"] = pybamm.porosity.Full(self.param)",
  "def set_convection_submodel(self):\n        if self.options[\"convection\"] is False:\n            self.submodels[\"convection\"] = pybamm.convection.NoConvection(self.param)\n        if self.options[\"convection\"] is True:\n            self.submodels[\"convection\"] = pybamm.convection.Full(self.param)",
  "def set_interfacial_submodel(self):\n        self.submodels[\"negative interface\"] = pybamm.interface.lead_acid.ButlerVolmer(\n            self.param, \"Negative\"\n        )\n        self.submodels[\"positive interface\"] = pybamm.interface.lead_acid.ButlerVolmer(\n            self.param, \"Positive\"\n        )",
  "def set_solid_submodel(self):\n        if self.options[\"surface form\"] is False:\n            submod_n = pybamm.electrode.ohm.Full(self.param, \"Negative\", self.reactions)\n            submod_p = pybamm.electrode.ohm.Full(self.param, \"Positive\", self.reactions)\n        else:\n            submod_n = pybamm.electrode.ohm.SurfaceForm(self.param, \"Negative\")\n            submod_p = pybamm.electrode.ohm.SurfaceForm(self.param, \"Positive\")\n\n        self.submodels[\"negative electrode\"] = submod_n\n        self.submodels[\"positive electrode\"] = submod_p",
  "def set_electrolyte_submodel(self):\n\n        electrolyte = pybamm.electrolyte.stefan_maxwell\n        surf_form = electrolyte.conductivity.surface_potential_form\n\n        self.submodels[\"electrolyte diffusion\"] = electrolyte.diffusion.Full(\n            self.param, self.reactions\n        )\n\n        if self.options[\"surface form\"] is False:\n            self.submodels[\"electrolyte conductivity\"] = electrolyte.conductivity.Full(\n                self.param, self.reactions\n            )\n        elif self.options[\"surface form\"] == \"differential\":\n            for domain in [\"Negative\", \"Separator\", \"Positive\"]:\n                self.submodels[\n                    domain.lower() + \" electrolyte conductivity\"\n                ] = surf_form.FullDifferential(self.param, domain, self.reactions)\n        elif self.options[\"surface form\"] == \"algebraic\":\n            for domain in [\"Negative\", \"Separator\", \"Positive\"]:\n                self.submodels[\n                    domain.lower() + \" electrolyte conductivity\"\n                ] = surf_form.FullAlgebraic(self.param, domain, self.reactions)",
  "def set_side_reaction_submodels(self):\n        if \"oxygen\" in self.options[\"side reactions\"]:\n            self.submodels[\"oxygen diffusion\"] = pybamm.oxygen_diffusion.Full(\n                self.param, self.reactions\n            )\n            self.submodels[\n                \"positive oxygen interface\"\n            ] = pybamm.interface.lead_acid_oxygen.ForwardTafel(self.param, \"Positive\")\n            self.submodels[\n                \"negative oxygen interface\"\n            ] = pybamm.interface.lead_acid_oxygen.FullDiffusionLimited(\n                self.param, \"Negative\"\n            )\n        else:\n            self.submodels[\"oxygen diffusion\"] = pybamm.oxygen_diffusion.NoOxygen(\n                self.param\n            )\n            self.submodels[\n                \"positive oxygen interface\"\n            ] = pybamm.interface.lead_acid_oxygen.NoReaction(self.param, \"Positive\")\n            self.submodels[\n                \"negative oxygen interface\"\n            ] = pybamm.interface.lead_acid_oxygen.NoReaction(self.param, \"Negative\")",
  "def default_solver(self):\n        \"\"\"\n        Create and return the default solver for this model\n        \"\"\"\n        # Different solver depending on whether we solve ODEs or DAEs\n        if (\n            self.options[\"surface form\"] == \"differential\"\n            and self.options[\"current collector\"] == \"uniform\"\n        ):\n            return pybamm.ScipySolver()\n        else:\n            return pybamm.ScikitsDaeSolver()",
  "class LOQS(BaseModel):\n    \"\"\"Leading-Order Quasi-Static model for lead-acid, from [1]_.\n\n    Parameters\n    ----------\n    options : dict, optional\n        A dictionary of options to be passed to the model.\n    name : str, optional\n        The name of the model.\n    build :  bool, optional\n        Whether to build the model on instantiation. Default is True. Setting this\n        option to False allows users to change any number of the submodels before\n        building the complete model (submodels cannot be changed after the model is\n        built).\n\n    References\n    ----------\n    .. [1] V Sulzer, SJ Chapman, CP Please, DA Howey, and CW Monroe. Faster lead-acid\n           battery simulations from porous-electrode theory: Part II. Asymptotic\n           analysis. Journal of The Electrochemical Society 166.12 (2019), A2372\u2013A2382.\n\n\n    **Extends:** :class:`pybamm.lead_acid.BaseModel`\n    \"\"\"\n\n    def __init__(self, options=None, name=\"LOQS model\", build=True):\n        super().__init__(options, name)\n\n        self.set_reactions()\n        self.set_interfacial_submodel()\n        self.set_convection_submodel()\n        self.set_porosity_submodel()\n        self.set_negative_electrode_submodel()\n        self.set_electrolyte_submodel()\n        self.set_positive_electrode_submodel()\n        self.set_thermal_submodel()\n        self.set_side_reaction_submodels()\n        self.set_current_collector_submodel()\n\n        if build:\n            self.build_model()\n\n        if self.options[\"dimensionality\"] == 0:\n            self.use_jacobian = False\n\n    def set_current_collector_submodel(self):\n\n        if self.options[\"current collector\"] in [\n            \"uniform\",\n            \"potential pair quite conductive\",\n        ]:\n            submodel = pybamm.current_collector.Uniform(self.param)\n        elif self.options[\"current collector\"] == \"potential pair\":\n            if self.options[\"dimensionality\"] == 1:\n                submodel = pybamm.current_collector.PotentialPair1plus1D(self.param)\n            elif self.options[\"dimensionality\"] == 2:\n                submodel = pybamm.current_collector.PotentialPair2plus1D(self.param)\n        self.submodels[\"leading-order current collector\"] = submodel\n\n    def set_porosity_submodel(self):\n\n        self.submodels[\"leading-order porosity\"] = pybamm.porosity.LeadingOrder(\n            self.param\n        )\n\n    def set_convection_submodel(self):\n\n        if self.options[\"convection\"] is False:\n            self.submodels[\"leading-order convection\"] = pybamm.convection.NoConvection(\n                self.param\n            )\n        if self.options[\"convection\"] is True:\n            self.submodels[\"leading-order convection\"] = pybamm.convection.LeadingOrder(\n                self.param\n            )\n\n    def set_interfacial_submodel(self):\n\n        if self.options[\"surface form\"] is False:\n            self.submodels[\n                \"leading-order negative interface\"\n            ] = pybamm.interface.lead_acid.InverseButlerVolmer(self.param, \"Negative\")\n            self.submodels[\n                \"leading-order positive interface\"\n            ] = pybamm.interface.lead_acid.InverseButlerVolmer(self.param, \"Positive\")\n        else:\n            self.submodels[\n                \"leading-order negative interface\"\n            ] = pybamm.interface.lead_acid.ButlerVolmer(self.param, \"Negative\")\n\n            self.submodels[\n                \"leading-order positive interface\"\n            ] = pybamm.interface.lead_acid.ButlerVolmer(self.param, \"Positive\")\n        self.reaction_submodels = {\n            \"Negative\": [self.submodels[\"leading-order negative interface\"]],\n            \"Positive\": [self.submodels[\"leading-order positive interface\"]],\n        }\n\n    def set_negative_electrode_submodel(self):\n\n        self.submodels[\n            \"leading-order negative electrode\"\n        ] = pybamm.electrode.ohm.LeadingOrder(self.param, \"Negative\")\n\n    def set_positive_electrode_submodel(self):\n\n        self.submodels[\n            \"leading-order positive electrode\"\n        ] = pybamm.electrode.ohm.LeadingOrder(self.param, \"Positive\")\n\n    def set_electrolyte_submodel(self):\n\n        electrolyte = pybamm.electrolyte.stefan_maxwell\n        surf_form = electrolyte.conductivity.surface_potential_form\n\n        if self.options[\"surface form\"] is False:\n            self.submodels[\n                \"leading-order electrolyte conductivity\"\n            ] = electrolyte.conductivity.LeadingOrder(self.param)\n\n        elif self.options[\"surface form\"] == \"differential\":\n            for domain in [\"Negative\", \"Separator\", \"Positive\"]:\n                self.submodels[\n                    \"leading-order \" + domain.lower() + \" electrolyte conductivity\"\n                ] = surf_form.LeadingOrderDifferential(\n                    self.param, domain, self.reactions\n                )\n\n        elif self.options[\"surface form\"] == \"algebraic\":\n            for domain in [\"Negative\", \"Separator\", \"Positive\"]:\n                self.submodels[\n                    \"leading-order \" + domain.lower() + \" electrolyte conductivity\"\n                ] = surf_form.LeadingOrderAlgebraic(self.param, domain, self.reactions)\n\n        self.submodels[\"electrolyte diffusion\"] = electrolyte.diffusion.LeadingOrder(\n            self.param, self.reactions\n        )\n\n    def set_side_reaction_submodels(self):\n        if \"oxygen\" in self.options[\"side reactions\"]:\n            self.submodels[\n                \"leading-order oxygen diffusion\"\n            ] = pybamm.oxygen_diffusion.LeadingOrder(self.param, self.reactions)\n            self.submodels[\n                \"leading-order positive oxygen interface\"\n            ] = pybamm.interface.lead_acid_oxygen.ForwardTafel(self.param, \"Positive\")\n            self.submodels[\n                \"leading-order negative oxygen interface\"\n            ] = pybamm.interface.lead_acid_oxygen.LeadingOrderDiffusionLimited(\n                self.param, \"Negative\"\n            )\n        else:\n            self.submodels[\n                \"leading-order oxygen diffusion\"\n            ] = pybamm.oxygen_diffusion.NoOxygen(self.param)\n            self.submodels[\n                \"leading-order positive oxygen interface\"\n            ] = pybamm.interface.lead_acid_oxygen.NoReaction(self.param, \"Positive\")\n            self.submodels[\n                \"leading-order negative oxygen interface\"\n            ] = pybamm.interface.lead_acid_oxygen.NoReaction(self.param, \"Negative\")\n        self.reaction_submodels[\"Negative\"].append(\n            self.submodels[\"leading-order negative oxygen interface\"]\n        )\n        self.reaction_submodels[\"Positive\"].append(\n            self.submodels[\"leading-order positive oxygen interface\"]\n        )\n\n    @property\n    def default_solver(self):\n        \"\"\"\n        Create and return the default solver for this model\n        \"\"\"\n\n        if (\n            self.options[\"current collector\"] != \"uniform\"\n            or self.options[\"surface form\"] == \"algebraic\"\n        ):\n            return pybamm.ScikitsDaeSolver()\n        else:\n            return pybamm.ScipySolver()",
  "def __init__(self, options=None, name=\"LOQS model\", build=True):\n        super().__init__(options, name)\n\n        self.set_reactions()\n        self.set_interfacial_submodel()\n        self.set_convection_submodel()\n        self.set_porosity_submodel()\n        self.set_negative_electrode_submodel()\n        self.set_electrolyte_submodel()\n        self.set_positive_electrode_submodel()\n        self.set_thermal_submodel()\n        self.set_side_reaction_submodels()\n        self.set_current_collector_submodel()\n\n        if build:\n            self.build_model()\n\n        if self.options[\"dimensionality\"] == 0:\n            self.use_jacobian = False",
  "def set_current_collector_submodel(self):\n\n        if self.options[\"current collector\"] in [\n            \"uniform\",\n            \"potential pair quite conductive\",\n        ]:\n            submodel = pybamm.current_collector.Uniform(self.param)\n        elif self.options[\"current collector\"] == \"potential pair\":\n            if self.options[\"dimensionality\"] == 1:\n                submodel = pybamm.current_collector.PotentialPair1plus1D(self.param)\n            elif self.options[\"dimensionality\"] == 2:\n                submodel = pybamm.current_collector.PotentialPair2plus1D(self.param)\n        self.submodels[\"leading-order current collector\"] = submodel",
  "def set_porosity_submodel(self):\n\n        self.submodels[\"leading-order porosity\"] = pybamm.porosity.LeadingOrder(\n            self.param\n        )",
  "def set_convection_submodel(self):\n\n        if self.options[\"convection\"] is False:\n            self.submodels[\"leading-order convection\"] = pybamm.convection.NoConvection(\n                self.param\n            )\n        if self.options[\"convection\"] is True:\n            self.submodels[\"leading-order convection\"] = pybamm.convection.LeadingOrder(\n                self.param\n            )",
  "def set_interfacial_submodel(self):\n\n        if self.options[\"surface form\"] is False:\n            self.submodels[\n                \"leading-order negative interface\"\n            ] = pybamm.interface.lead_acid.InverseButlerVolmer(self.param, \"Negative\")\n            self.submodels[\n                \"leading-order positive interface\"\n            ] = pybamm.interface.lead_acid.InverseButlerVolmer(self.param, \"Positive\")\n        else:\n            self.submodels[\n                \"leading-order negative interface\"\n            ] = pybamm.interface.lead_acid.ButlerVolmer(self.param, \"Negative\")\n\n            self.submodels[\n                \"leading-order positive interface\"\n            ] = pybamm.interface.lead_acid.ButlerVolmer(self.param, \"Positive\")\n        self.reaction_submodels = {\n            \"Negative\": [self.submodels[\"leading-order negative interface\"]],\n            \"Positive\": [self.submodels[\"leading-order positive interface\"]],\n        }",
  "def set_negative_electrode_submodel(self):\n\n        self.submodels[\n            \"leading-order negative electrode\"\n        ] = pybamm.electrode.ohm.LeadingOrder(self.param, \"Negative\")",
  "def set_positive_electrode_submodel(self):\n\n        self.submodels[\n            \"leading-order positive electrode\"\n        ] = pybamm.electrode.ohm.LeadingOrder(self.param, \"Positive\")",
  "def set_electrolyte_submodel(self):\n\n        electrolyte = pybamm.electrolyte.stefan_maxwell\n        surf_form = electrolyte.conductivity.surface_potential_form\n\n        if self.options[\"surface form\"] is False:\n            self.submodels[\n                \"leading-order electrolyte conductivity\"\n            ] = electrolyte.conductivity.LeadingOrder(self.param)\n\n        elif self.options[\"surface form\"] == \"differential\":\n            for domain in [\"Negative\", \"Separator\", \"Positive\"]:\n                self.submodels[\n                    \"leading-order \" + domain.lower() + \" electrolyte conductivity\"\n                ] = surf_form.LeadingOrderDifferential(\n                    self.param, domain, self.reactions\n                )\n\n        elif self.options[\"surface form\"] == \"algebraic\":\n            for domain in [\"Negative\", \"Separator\", \"Positive\"]:\n                self.submodels[\n                    \"leading-order \" + domain.lower() + \" electrolyte conductivity\"\n                ] = surf_form.LeadingOrderAlgebraic(self.param, domain, self.reactions)\n\n        self.submodels[\"electrolyte diffusion\"] = electrolyte.diffusion.LeadingOrder(\n            self.param, self.reactions\n        )",
  "def set_side_reaction_submodels(self):\n        if \"oxygen\" in self.options[\"side reactions\"]:\n            self.submodels[\n                \"leading-order oxygen diffusion\"\n            ] = pybamm.oxygen_diffusion.LeadingOrder(self.param, self.reactions)\n            self.submodels[\n                \"leading-order positive oxygen interface\"\n            ] = pybamm.interface.lead_acid_oxygen.ForwardTafel(self.param, \"Positive\")\n            self.submodels[\n                \"leading-order negative oxygen interface\"\n            ] = pybamm.interface.lead_acid_oxygen.LeadingOrderDiffusionLimited(\n                self.param, \"Negative\"\n            )\n        else:\n            self.submodels[\n                \"leading-order oxygen diffusion\"\n            ] = pybamm.oxygen_diffusion.NoOxygen(self.param)\n            self.submodels[\n                \"leading-order positive oxygen interface\"\n            ] = pybamm.interface.lead_acid_oxygen.NoReaction(self.param, \"Positive\")\n            self.submodels[\n                \"leading-order negative oxygen interface\"\n            ] = pybamm.interface.lead_acid_oxygen.NoReaction(self.param, \"Negative\")\n        self.reaction_submodels[\"Negative\"].append(\n            self.submodels[\"leading-order negative oxygen interface\"]\n        )\n        self.reaction_submodels[\"Positive\"].append(\n            self.submodels[\"leading-order positive oxygen interface\"]\n        )",
  "def default_solver(self):\n        \"\"\"\n        Create and return the default solver for this model\n        \"\"\"\n\n        if (\n            self.options[\"current collector\"] != \"uniform\"\n            or self.options[\"surface form\"] == \"algebraic\"\n        ):\n            return pybamm.ScikitsDaeSolver()\n        else:\n            return pybamm.ScipySolver()",
  "class BaseModel(pybamm.BaseBatteryModel):\n    \"\"\"\n    Overwrites default parameters from Base Model with default parameters for\n    lithium-ion models\n\n    **Extends:** :class:`pybamm.BaseBatteryModel`\n\n    \"\"\"\n\n    def __init__(self, options=None, name=\"Unnamed lithium-ion model\"):\n        super().__init__(options, name)\n        self.param = pybamm.standard_parameters_lithium_ion\n\n    def set_standard_output_variables(self):\n        super().set_standard_output_variables()\n        # Current\n        i_cell = pybamm.standard_parameters_lithium_ion.current_with_time\n        i_cell_dim = (\n            pybamm.standard_parameters_lithium_ion.dimensional_current_density_with_time\n        )\n        I = pybamm.standard_parameters_lithium_ion.dimensional_current_with_time\n        self.variables.update(\n            {\n                \"Total current density\": i_cell,\n                \"Total current density [A.m-2]\": i_cell_dim,\n                \"Current [A]\": I,\n            }\n        )\n\n        # Time\n        time_scale = pybamm.standard_parameters_lithium_ion.tau_discharge\n        self.variables.update(\n            {\n                \"Time [s]\": pybamm.t * time_scale,\n                \"Time [min]\": pybamm.t * time_scale / 60,\n                \"Time [h]\": pybamm.t * time_scale / 3600,\n                \"Discharge capacity [A.h]\": I * pybamm.t * time_scale / 3600,\n            }\n        )\n\n        # Particle concentration and position\n        self.variables.update(\n            {\n                \"Negative particle concentration\": None,\n                \"Positive particle concentration\": None,\n                \"Negative particle surface concentration\": None,\n                \"Positive particle surface concentration\": None,\n                \"Negative particle concentration [mol.m-3]\": None,\n                \"Positive particle concentration [mol.m-3]\": None,\n                \"Negative particle surface concentration [mol.m-3]\": None,\n                \"Positive particle surface concentration [mol.m-3]\": None,\n            }\n        )\n        var = pybamm.standard_spatial_vars\n        param = pybamm.geometric_parameters\n        self.variables.update(\n            {\n                \"r_n\": var.r_n,\n                \"r_n [m]\": var.r_n * param.R_n,\n                \"r_p\": var.r_p,\n                \"r_p [m]\": var.r_p * param.R_p,\n            }\n        )\n\n    def set_reactions(self):\n\n        # Should probably refactor as this is a bit clunky at the moment\n        # Maybe each reaction as a Reaction class so we can just list names of classes\n        icd = \" interfacial current density\"\n        self.reactions = {\n            \"main\": {\n                \"Negative\": {\n                    \"s\": 1 - self.param.t_plus,\n                    \"aj\": \"Negative electrode\" + icd,\n                },\n                \"Positive\": {\n                    \"s\": 1 - self.param.t_plus,\n                    \"aj\": \"Positive electrode\" + icd,\n                },\n            }\n        }",
  "def __init__(self, options=None, name=\"Unnamed lithium-ion model\"):\n        super().__init__(options, name)\n        self.param = pybamm.standard_parameters_lithium_ion",
  "def set_standard_output_variables(self):\n        super().set_standard_output_variables()\n        # Current\n        i_cell = pybamm.standard_parameters_lithium_ion.current_with_time\n        i_cell_dim = (\n            pybamm.standard_parameters_lithium_ion.dimensional_current_density_with_time\n        )\n        I = pybamm.standard_parameters_lithium_ion.dimensional_current_with_time\n        self.variables.update(\n            {\n                \"Total current density\": i_cell,\n                \"Total current density [A.m-2]\": i_cell_dim,\n                \"Current [A]\": I,\n            }\n        )\n\n        # Time\n        time_scale = pybamm.standard_parameters_lithium_ion.tau_discharge\n        self.variables.update(\n            {\n                \"Time [s]\": pybamm.t * time_scale,\n                \"Time [min]\": pybamm.t * time_scale / 60,\n                \"Time [h]\": pybamm.t * time_scale / 3600,\n                \"Discharge capacity [A.h]\": I * pybamm.t * time_scale / 3600,\n            }\n        )\n\n        # Particle concentration and position\n        self.variables.update(\n            {\n                \"Negative particle concentration\": None,\n                \"Positive particle concentration\": None,\n                \"Negative particle surface concentration\": None,\n                \"Positive particle surface concentration\": None,\n                \"Negative particle concentration [mol.m-3]\": None,\n                \"Positive particle concentration [mol.m-3]\": None,\n                \"Negative particle surface concentration [mol.m-3]\": None,\n                \"Positive particle surface concentration [mol.m-3]\": None,\n            }\n        )\n        var = pybamm.standard_spatial_vars\n        param = pybamm.geometric_parameters\n        self.variables.update(\n            {\n                \"r_n\": var.r_n,\n                \"r_n [m]\": var.r_n * param.R_n,\n                \"r_p\": var.r_p,\n                \"r_p [m]\": var.r_p * param.R_p,\n            }\n        )",
  "def set_reactions(self):\n\n        # Should probably refactor as this is a bit clunky at the moment\n        # Maybe each reaction as a Reaction class so we can just list names of classes\n        icd = \" interfacial current density\"\n        self.reactions = {\n            \"main\": {\n                \"Negative\": {\n                    \"s\": 1 - self.param.t_plus,\n                    \"aj\": \"Negative electrode\" + icd,\n                },\n                \"Positive\": {\n                    \"s\": 1 - self.param.t_plus,\n                    \"aj\": \"Positive electrode\" + icd,\n                },\n            }\n        }",
  "class DFN(BaseModel):\n    \"\"\"Doyle-Fuller-Newman (DFN) model of a lithium-ion battery, from [1]_.\n\n    Parameters\n    ----------\n    options : dict, optional\n        A dictionary of options to be passed to the model.\n    name : str, optional\n        The name of the model.\n    build :  bool, optional\n        Whether to build the model on instantiation. Default is True. Setting this\n        option to False allows users to change any number of the submodels before\n        building the complete model (submodels cannot be changed after the model is\n        built).\n\n    References\n    ----------\n    .. [1] SG Marquis, V Sulzer, R Timms, CP Please and SJ Chapman. \u201cAn asymptotic\n           derivation of a single particle model with electrolyte\u201d. In: arXiv preprint\n           arXiv:1905.12553 (2019).\n\n\n    **Extends:** :class:`pybamm.lithium_ion.BaseModel`\n    \"\"\"\n\n    def __init__(self, options=None, name=\"Doyle-Fuller-Newman model\", build=True):\n        super().__init__(options, name)\n\n        self.set_reactions()\n        self.set_porosity_submodel()\n        self.set_convection_submodel()\n        self.set_interfacial_submodel()\n        self.set_particle_submodel()\n        self.set_solid_submodel()\n        self.set_electrolyte_submodel()\n        self.set_thermal_submodel()\n        self.set_current_collector_submodel()\n\n        if build:\n            self.build_model()\n\n    def set_porosity_submodel(self):\n\n        self.submodels[\"porosity\"] = pybamm.porosity.Constant(self.param)\n\n    def set_convection_submodel(self):\n\n        self.submodels[\"convection\"] = pybamm.convection.NoConvection(self.param)\n\n    def set_interfacial_submodel(self):\n\n        self.submodels[\n            \"negative interface\"\n        ] = pybamm.interface.lithium_ion.ButlerVolmer(self.param, \"Negative\")\n        self.submodels[\n            \"positive interface\"\n        ] = pybamm.interface.lithium_ion.ButlerVolmer(self.param, \"Positive\")\n\n    def set_particle_submodel(self):\n\n        if self.options[\"particle\"] == \"Fickian diffusion\":\n            self.submodels[\"negative particle\"] = pybamm.particle.fickian.ManyParticles(\n                self.param, \"Negative\"\n            )\n            self.submodels[\"positive particle\"] = pybamm.particle.fickian.ManyParticles(\n                self.param, \"Positive\"\n            )\n        elif self.options[\"particle\"] == \"fast diffusion\":\n            self.submodels[\"negative particle\"] = pybamm.particle.fast.ManyParticles(\n                self.param, \"Negative\"\n            )\n            self.submodels[\"positive particle\"] = pybamm.particle.fast.ManyParticles(\n                self.param, \"Positive\"\n            )\n\n    def set_solid_submodel(self):\n\n        self.submodels[\"negative electrode\"] = pybamm.electrode.ohm.Full(\n            self.param, \"Negative\", self.reactions\n        )\n        self.submodels[\"positive electrode\"] = pybamm.electrode.ohm.Full(\n            self.param, \"Positive\", self.reactions\n        )\n\n    def set_electrolyte_submodel(self):\n\n        electrolyte = pybamm.electrolyte.stefan_maxwell\n\n        self.submodels[\"electrolyte conductivity\"] = electrolyte.conductivity.Full(\n            self.param, self.reactions\n        )\n        self.submodels[\"electrolyte diffusion\"] = electrolyte.diffusion.Full(\n            self.param, self.reactions\n        )\n\n    @property\n    def default_geometry(self):\n        dimensionality = self.options[\"dimensionality\"]\n        if dimensionality == 0:\n            return pybamm.Geometry(\"1D macro\", \"1+1D micro\")\n        elif dimensionality == 1:\n            return pybamm.Geometry(\"1+1D macro\", \"(1+1)+1D micro\")\n        elif dimensionality == 2:\n            return pybamm.Geometry(\"2+1D macro\", \"(2+1)+1D micro\")\n\n    @property\n    def default_solver(self):\n        \"\"\"\n        Create and return the default solver for this model\n        \"\"\"\n\n        # Default solver to DAE\n        return pybamm.ScikitsDaeSolver()",
  "def __init__(self, options=None, name=\"Doyle-Fuller-Newman model\", build=True):\n        super().__init__(options, name)\n\n        self.set_reactions()\n        self.set_porosity_submodel()\n        self.set_convection_submodel()\n        self.set_interfacial_submodel()\n        self.set_particle_submodel()\n        self.set_solid_submodel()\n        self.set_electrolyte_submodel()\n        self.set_thermal_submodel()\n        self.set_current_collector_submodel()\n\n        if build:\n            self.build_model()",
  "def set_porosity_submodel(self):\n\n        self.submodels[\"porosity\"] = pybamm.porosity.Constant(self.param)",
  "def set_convection_submodel(self):\n\n        self.submodels[\"convection\"] = pybamm.convection.NoConvection(self.param)",
  "def set_interfacial_submodel(self):\n\n        self.submodels[\n            \"negative interface\"\n        ] = pybamm.interface.lithium_ion.ButlerVolmer(self.param, \"Negative\")\n        self.submodels[\n            \"positive interface\"\n        ] = pybamm.interface.lithium_ion.ButlerVolmer(self.param, \"Positive\")",
  "def set_particle_submodel(self):\n\n        if self.options[\"particle\"] == \"Fickian diffusion\":\n            self.submodels[\"negative particle\"] = pybamm.particle.fickian.ManyParticles(\n                self.param, \"Negative\"\n            )\n            self.submodels[\"positive particle\"] = pybamm.particle.fickian.ManyParticles(\n                self.param, \"Positive\"\n            )\n        elif self.options[\"particle\"] == \"fast diffusion\":\n            self.submodels[\"negative particle\"] = pybamm.particle.fast.ManyParticles(\n                self.param, \"Negative\"\n            )\n            self.submodels[\"positive particle\"] = pybamm.particle.fast.ManyParticles(\n                self.param, \"Positive\"\n            )",
  "def set_solid_submodel(self):\n\n        self.submodels[\"negative electrode\"] = pybamm.electrode.ohm.Full(\n            self.param, \"Negative\", self.reactions\n        )\n        self.submodels[\"positive electrode\"] = pybamm.electrode.ohm.Full(\n            self.param, \"Positive\", self.reactions\n        )",
  "def set_electrolyte_submodel(self):\n\n        electrolyte = pybamm.electrolyte.stefan_maxwell\n\n        self.submodels[\"electrolyte conductivity\"] = electrolyte.conductivity.Full(\n            self.param, self.reactions\n        )\n        self.submodels[\"electrolyte diffusion\"] = electrolyte.diffusion.Full(\n            self.param, self.reactions\n        )",
  "def default_geometry(self):\n        dimensionality = self.options[\"dimensionality\"]\n        if dimensionality == 0:\n            return pybamm.Geometry(\"1D macro\", \"1+1D micro\")\n        elif dimensionality == 1:\n            return pybamm.Geometry(\"1+1D macro\", \"(1+1)+1D micro\")\n        elif dimensionality == 2:\n            return pybamm.Geometry(\"2+1D macro\", \"(2+1)+1D micro\")",
  "def default_solver(self):\n        \"\"\"\n        Create and return the default solver for this model\n        \"\"\"\n\n        # Default solver to DAE\n        return pybamm.ScikitsDaeSolver()",
  "class SPM(BaseModel):\n    \"\"\"Single Particle Model (SPM) of a lithium-ion battery, from [1]_.\n\n    Parameters\n    ----------\n    options : dict, optional\n        A dictionary of options to be passed to the model.\n    name : str, optional\n        The name of the model.\n    build :  bool, optional\n        Whether to build the model on instantiation. Default is True. Setting this\n        option to False allows users to change any number of the submodels before\n        building the complete model (submodels cannot be changed after the model is\n        built).\n\n    References\n    ----------\n    .. [1] SG Marquis, V Sulzer, R Timms, CP Please and SJ Chapman. \u201cAn asymptotic\n           derivation of a single particle model with electrolyte\u201d. In: arXiv preprint\n           arXiv:1905.12553 (2019).\n\n    **Extends:** :class:`pybamm.lithium_ion.BaseModel`\n    \"\"\"\n\n    def __init__(self, options=None, name=\"Single Particle Model\", build=True):\n        super().__init__(options, name)\n\n        self.set_porosity_submodel()\n        self.set_convection_submodel()\n        self.set_interfacial_submodel()\n        self.set_particle_submodel()\n        self.set_negative_electrode_submodel()\n        self.set_electrolyte_submodel()\n        self.set_positive_electrode_submodel()\n        self.set_thermal_submodel()\n        self.set_current_collector_submodel()\n\n        if build:\n            self.build_model()\n\n    def set_porosity_submodel(self):\n\n        self.submodels[\"porosity\"] = pybamm.porosity.Constant(self.param)\n\n    def set_convection_submodel(self):\n\n        self.submodels[\"convection\"] = pybamm.convection.NoConvection(self.param)\n\n    def set_interfacial_submodel(self):\n\n        self.submodels[\n            \"negative interface\"\n        ] = pybamm.interface.lithium_ion.InverseButlerVolmer(self.param, \"Negative\")\n        self.submodels[\n            \"positive interface\"\n        ] = pybamm.interface.lithium_ion.InverseButlerVolmer(self.param, \"Positive\")\n\n    def set_particle_submodel(self):\n\n        if self.options[\"particle\"] == \"Fickian diffusion\":\n            self.submodels[\n                \"negative particle\"\n            ] = pybamm.particle.fickian.SingleParticle(self.param, \"Negative\")\n            self.submodels[\n                \"positive particle\"\n            ] = pybamm.particle.fickian.SingleParticle(self.param, \"Positive\")\n        elif self.options[\"particle\"] == \"fast diffusion\":\n            self.submodels[\"negative particle\"] = pybamm.particle.fast.SingleParticle(\n                self.param, \"Negative\"\n            )\n            self.submodels[\"positive particle\"] = pybamm.particle.fast.SingleParticle(\n                self.param, \"Positive\"\n            )\n\n    def set_negative_electrode_submodel(self):\n\n        self.submodels[\"negative electrode\"] = pybamm.electrode.ohm.LeadingOrder(\n            self.param, \"Negative\"\n        )\n\n    def set_positive_electrode_submodel(self):\n\n        self.submodels[\"positive electrode\"] = pybamm.electrode.ohm.LeadingOrder(\n            self.param, \"Positive\"\n        )\n\n    def set_electrolyte_submodel(self):\n\n        electrolyte = pybamm.electrolyte.stefan_maxwell\n\n        self.submodels[\n            \"electrolyte conductivity\"\n        ] = electrolyte.conductivity.LeadingOrder(self.param)\n        self.submodels[\n            \"electrolyte diffusion\"\n        ] = electrolyte.diffusion.ConstantConcentration(self.param)\n\n    @property\n    def default_geometry(self):\n        dimensionality = self.options[\"dimensionality\"]\n        if dimensionality == 0:\n            return pybamm.Geometry(\"1D macro\", \"1D micro\")\n        elif dimensionality == 1:\n            return pybamm.Geometry(\"1+1D macro\", \"(1+0)+1D micro\")\n        elif dimensionality == 2:\n            return pybamm.Geometry(\"2+1D macro\", \"(2+0)+1D micro\")\n\n    @property\n    def default_solver(self):\n        \"\"\"\n        Create and return the default solver for this model\n        \"\"\"\n        # Different solver depending on whether we solve ODEs or DAEs\n        dimensionality = self.options[\"dimensionality\"]\n        if dimensionality == 0:\n            return pybamm.ScipySolver()\n        else:\n            return pybamm.ScikitsDaeSolver()",
  "def __init__(self, options=None, name=\"Single Particle Model\", build=True):\n        super().__init__(options, name)\n\n        self.set_porosity_submodel()\n        self.set_convection_submodel()\n        self.set_interfacial_submodel()\n        self.set_particle_submodel()\n        self.set_negative_electrode_submodel()\n        self.set_electrolyte_submodel()\n        self.set_positive_electrode_submodel()\n        self.set_thermal_submodel()\n        self.set_current_collector_submodel()\n\n        if build:\n            self.build_model()",
  "def set_porosity_submodel(self):\n\n        self.submodels[\"porosity\"] = pybamm.porosity.Constant(self.param)",
  "def set_convection_submodel(self):\n\n        self.submodels[\"convection\"] = pybamm.convection.NoConvection(self.param)",
  "def set_interfacial_submodel(self):\n\n        self.submodels[\n            \"negative interface\"\n        ] = pybamm.interface.lithium_ion.InverseButlerVolmer(self.param, \"Negative\")\n        self.submodels[\n            \"positive interface\"\n        ] = pybamm.interface.lithium_ion.InverseButlerVolmer(self.param, \"Positive\")",
  "def set_particle_submodel(self):\n\n        if self.options[\"particle\"] == \"Fickian diffusion\":\n            self.submodels[\n                \"negative particle\"\n            ] = pybamm.particle.fickian.SingleParticle(self.param, \"Negative\")\n            self.submodels[\n                \"positive particle\"\n            ] = pybamm.particle.fickian.SingleParticle(self.param, \"Positive\")\n        elif self.options[\"particle\"] == \"fast diffusion\":\n            self.submodels[\"negative particle\"] = pybamm.particle.fast.SingleParticle(\n                self.param, \"Negative\"\n            )\n            self.submodels[\"positive particle\"] = pybamm.particle.fast.SingleParticle(\n                self.param, \"Positive\"\n            )",
  "def set_negative_electrode_submodel(self):\n\n        self.submodels[\"negative electrode\"] = pybamm.electrode.ohm.LeadingOrder(\n            self.param, \"Negative\"\n        )",
  "def set_positive_electrode_submodel(self):\n\n        self.submodels[\"positive electrode\"] = pybamm.electrode.ohm.LeadingOrder(\n            self.param, \"Positive\"\n        )",
  "def set_electrolyte_submodel(self):\n\n        electrolyte = pybamm.electrolyte.stefan_maxwell\n\n        self.submodels[\n            \"electrolyte conductivity\"\n        ] = electrolyte.conductivity.LeadingOrder(self.param)\n        self.submodels[\n            \"electrolyte diffusion\"\n        ] = electrolyte.diffusion.ConstantConcentration(self.param)",
  "def default_geometry(self):\n        dimensionality = self.options[\"dimensionality\"]\n        if dimensionality == 0:\n            return pybamm.Geometry(\"1D macro\", \"1D micro\")\n        elif dimensionality == 1:\n            return pybamm.Geometry(\"1+1D macro\", \"(1+0)+1D micro\")\n        elif dimensionality == 2:\n            return pybamm.Geometry(\"2+1D macro\", \"(2+0)+1D micro\")",
  "def default_solver(self):\n        \"\"\"\n        Create and return the default solver for this model\n        \"\"\"\n        # Different solver depending on whether we solve ODEs or DAEs\n        dimensionality = self.options[\"dimensionality\"]\n        if dimensionality == 0:\n            return pybamm.ScipySolver()\n        else:\n            return pybamm.ScikitsDaeSolver()",
  "class SPMe(BaseModel):\n    \"\"\"Single Particle Model with Electrolyte (SPMe) of a lithium-ion battery, from\n    [1]_.\n\n    Parameters\n    ----------\n    options : dict, optional\n        A dictionary of options to be passed to the model.\n    name : str, optional\n        The name of the model.\n    build :  bool, optional\n        Whether to build the model on instantiation. Default is True. Setting this\n        option to False allows users to change any number of the submodels before\n        building the complete model (submodels cannot be changed after the model is\n        built).\n\n    References\n    ----------\n    .. [1] SG Marquis, V Sulzer, R Timms, CP Please and SJ Chapman. \u201cAn asymptotic\n           derivation of a single particle model with electrolyte\u201d. In: arXiv preprint\n           arXiv:1905.12553 (2019).\n\n    **Extends:** :class:`pybamm.lithium_ion.BaseModel`\n    \"\"\"\n\n    def __init__(\n        self, options=None, name=\"Single Particle Model with electrolyte\", build=True\n    ):\n        super().__init__(options, name)\n\n        self.set_reactions()\n        self.set_porosity_submodel()\n        self.set_convection_submodel()\n        self.set_interfacial_submodel()\n        self.set_particle_submodel()\n        self.set_negative_electrode_submodel()\n        self.set_electrolyte_submodel()\n        self.set_positive_electrode_submodel()\n        self.set_thermal_submodel()\n        self.set_current_collector_submodel()\n\n        if build:\n            self.build_model()\n\n    def set_porosity_submodel(self):\n\n        self.submodels[\"porosity\"] = pybamm.porosity.Constant(self.param)\n\n    def set_convection_submodel(self):\n\n        self.submodels[\"convection\"] = pybamm.convection.NoConvection(self.param)\n\n    def set_interfacial_submodel(self):\n\n        self.submodels[\n            \"negative interface\"\n        ] = pybamm.interface.lithium_ion.InverseButlerVolmer(self.param, \"Negative\")\n        self.submodels[\n            \"positive interface\"\n        ] = pybamm.interface.lithium_ion.InverseButlerVolmer(self.param, \"Positive\")\n\n    def set_particle_submodel(self):\n\n        if self.options[\"particle\"] == \"Fickian diffusion\":\n            self.submodels[\n                \"negative particle\"\n            ] = pybamm.particle.fickian.SingleParticle(self.param, \"Negative\")\n            self.submodels[\n                \"positive particle\"\n            ] = pybamm.particle.fickian.SingleParticle(self.param, \"Positive\")\n        elif self.options[\"particle\"] == \"fast diffusion\":\n            self.submodels[\"negative particle\"] = pybamm.particle.fast.SingleParticle(\n                self.param, \"Negative\"\n            )\n            self.submodels[\"positive particle\"] = pybamm.particle.fast.SingleParticle(\n                self.param, \"Positive\"\n            )\n\n    def set_negative_electrode_submodel(self):\n\n        self.submodels[\"negative electrode\"] = pybamm.electrode.ohm.Composite(\n            self.param, \"Negative\"\n        )\n\n    def set_positive_electrode_submodel(self):\n\n        self.submodels[\"positive electrode\"] = pybamm.electrode.ohm.Composite(\n            self.param, \"Positive\"\n        )\n\n    def set_electrolyte_submodel(self):\n\n        electrolyte = pybamm.electrolyte.stefan_maxwell\n\n        self.submodels[\"electrolyte conductivity\"] = electrolyte.conductivity.Composite(\n            self.param\n        )\n        self.submodels[\"electrolyte diffusion\"] = electrolyte.diffusion.Full(\n            self.param, self.reactions\n        )\n\n    @property\n    def default_geometry(self):\n        dimensionality = self.options[\"dimensionality\"]\n        if dimensionality == 0:\n            return pybamm.Geometry(\"1D macro\", \"1D micro\")\n        elif dimensionality == 1:\n            return pybamm.Geometry(\"1+1D macro\", \"(1+0)+1D micro\")\n        elif dimensionality == 2:\n            return pybamm.Geometry(\"2+1D macro\", \"(2+0)+1D micro\")\n\n    @property\n    def default_solver(self):\n        \"\"\"\n        Create and return the default solver for this model\n        \"\"\"\n        # Different solver depending on whether we solve ODEs or DAEs\n        dimensionality = self.options[\"dimensionality\"]\n        if dimensionality == 0:\n            return pybamm.ScipySolver()\n        else:\n            return pybamm.ScikitsDaeSolver()",
  "def __init__(\n        self, options=None, name=\"Single Particle Model with electrolyte\", build=True\n    ):\n        super().__init__(options, name)\n\n        self.set_reactions()\n        self.set_porosity_submodel()\n        self.set_convection_submodel()\n        self.set_interfacial_submodel()\n        self.set_particle_submodel()\n        self.set_negative_electrode_submodel()\n        self.set_electrolyte_submodel()\n        self.set_positive_electrode_submodel()\n        self.set_thermal_submodel()\n        self.set_current_collector_submodel()\n\n        if build:\n            self.build_model()",
  "def set_porosity_submodel(self):\n\n        self.submodels[\"porosity\"] = pybamm.porosity.Constant(self.param)",
  "def set_convection_submodel(self):\n\n        self.submodels[\"convection\"] = pybamm.convection.NoConvection(self.param)",
  "def set_interfacial_submodel(self):\n\n        self.submodels[\n            \"negative interface\"\n        ] = pybamm.interface.lithium_ion.InverseButlerVolmer(self.param, \"Negative\")\n        self.submodels[\n            \"positive interface\"\n        ] = pybamm.interface.lithium_ion.InverseButlerVolmer(self.param, \"Positive\")",
  "def set_particle_submodel(self):\n\n        if self.options[\"particle\"] == \"Fickian diffusion\":\n            self.submodels[\n                \"negative particle\"\n            ] = pybamm.particle.fickian.SingleParticle(self.param, \"Negative\")\n            self.submodels[\n                \"positive particle\"\n            ] = pybamm.particle.fickian.SingleParticle(self.param, \"Positive\")\n        elif self.options[\"particle\"] == \"fast diffusion\":\n            self.submodels[\"negative particle\"] = pybamm.particle.fast.SingleParticle(\n                self.param, \"Negative\"\n            )\n            self.submodels[\"positive particle\"] = pybamm.particle.fast.SingleParticle(\n                self.param, \"Positive\"\n            )",
  "def set_negative_electrode_submodel(self):\n\n        self.submodels[\"negative electrode\"] = pybamm.electrode.ohm.Composite(\n            self.param, \"Negative\"\n        )",
  "def set_positive_electrode_submodel(self):\n\n        self.submodels[\"positive electrode\"] = pybamm.electrode.ohm.Composite(\n            self.param, \"Positive\"\n        )",
  "def set_electrolyte_submodel(self):\n\n        electrolyte = pybamm.electrolyte.stefan_maxwell\n\n        self.submodels[\"electrolyte conductivity\"] = electrolyte.conductivity.Composite(\n            self.param\n        )\n        self.submodels[\"electrolyte diffusion\"] = electrolyte.diffusion.Full(\n            self.param, self.reactions\n        )",
  "def default_geometry(self):\n        dimensionality = self.options[\"dimensionality\"]\n        if dimensionality == 0:\n            return pybamm.Geometry(\"1D macro\", \"1D micro\")\n        elif dimensionality == 1:\n            return pybamm.Geometry(\"1+1D macro\", \"(1+0)+1D micro\")\n        elif dimensionality == 2:\n            return pybamm.Geometry(\"2+1D macro\", \"(2+0)+1D micro\")",
  "def default_solver(self):\n        \"\"\"\n        Create and return the default solver for this model\n        \"\"\"\n        # Different solver depending on whether we solve ODEs or DAEs\n        dimensionality = self.options[\"dimensionality\"]\n        if dimensionality == 0:\n            return pybamm.ScipySolver()\n        else:\n            return pybamm.ScikitsDaeSolver()",
  "class Array(pybamm.Symbol):\n    \"\"\"node in the expression tree that holds an tensor type variable\n    (e.g. :class:`numpy.array`)\n\n    Parameters\n    ----------\n\n    entries : numpy.array\n        the array associated with the node\n    name : str, optional\n        the name of the node\n    domain : iterable of str, optional\n        list of domains the parameter is valid over, defaults to empty list\n    auxiliary_domainds : dict, optional\n        dictionary of auxiliary domains, defaults to empty dict\n    entries_string : str\n        String representing the entries (slow to recalculate when copying)\n\n    *Extends:* :class:`Symbol`\n    \"\"\"\n\n    def __init__(\n        self,\n        entries,\n        name=None,\n        domain=None,\n        auxiliary_domains=None,\n        entries_string=None,\n    ):\n        if entries.ndim == 1:\n            entries = entries[:, np.newaxis]\n        if name is None:\n            name = \"Array of shape {!s}\".format(entries.shape)\n        self._entries = entries\n        # Use known entries string to avoid re-hashing, where possible\n        self.entries_string = entries_string\n        super().__init__(name, domain=domain, auxiliary_domains=auxiliary_domains)\n\n    @property\n    def entries(self):\n        return self._entries\n\n    @property\n    def ndim(self):\n        \"\"\" returns the number of dimensions of the tensor\"\"\"\n        return self._entries.ndim\n\n    @property\n    def shape(self):\n        \"\"\" returns the number of entries along each dimension\"\"\"\n        return self._entries.shape\n\n    @property\n    def entries_string(self):\n        return self._entries_string\n\n    @entries_string.setter\n    def entries_string(self, value):\n        # We must include the entries in the hash, since different arrays can be\n        # indistinguishable by class, name and domain alone\n        # Slightly different syntax for sparse and non-sparse matrices\n        if value is not None:\n            self._entries_string = value\n        else:\n            entries = self._entries\n            if issparse(entries):\n                self._entries_string = str(entries.__dict__)\n            else:\n                self._entries_string = entries.tostring()\n\n    def set_id(self):\n        \"\"\" See :meth:`pybamm.Symbol.set_id()`. \"\"\"\n        self._id = hash(\n            (self.__class__, self.name, self.entries_string) + tuple(self.domain)\n        )\n\n    def _jac(self, variable):\n        \"\"\" See :meth:`pybamm.Symbol._jac()`. \"\"\"\n        # Return zeros of correct size\n        jac = csr_matrix((self.size, variable.evaluation_array.count(True)))\n        return pybamm.Matrix(jac)\n\n    def new_copy(self):\n        \"\"\" See :meth:`pybamm.Symbol.new_copy()`. \"\"\"\n        return self.__class__(\n            self.entries,\n            self.name,\n            self.domain,\n            self.auxiliary_domains,\n            self.entries_string,\n        )\n\n    def _base_evaluate(self, t=None, y=None):\n        \"\"\" See :meth:`pybamm.Symbol._base_evaluate()`. \"\"\"\n        return self._entries",
  "def __init__(\n        self,\n        entries,\n        name=None,\n        domain=None,\n        auxiliary_domains=None,\n        entries_string=None,\n    ):\n        if entries.ndim == 1:\n            entries = entries[:, np.newaxis]\n        if name is None:\n            name = \"Array of shape {!s}\".format(entries.shape)\n        self._entries = entries\n        # Use known entries string to avoid re-hashing, where possible\n        self.entries_string = entries_string\n        super().__init__(name, domain=domain, auxiliary_domains=auxiliary_domains)",
  "def entries(self):\n        return self._entries",
  "def ndim(self):\n        \"\"\" returns the number of dimensions of the tensor\"\"\"\n        return self._entries.ndim",
  "def shape(self):\n        \"\"\" returns the number of entries along each dimension\"\"\"\n        return self._entries.shape",
  "def entries_string(self):\n        return self._entries_string",
  "def entries_string(self, value):\n        # We must include the entries in the hash, since different arrays can be\n        # indistinguishable by class, name and domain alone\n        # Slightly different syntax for sparse and non-sparse matrices\n        if value is not None:\n            self._entries_string = value\n        else:\n            entries = self._entries\n            if issparse(entries):\n                self._entries_string = str(entries.__dict__)\n            else:\n                self._entries_string = entries.tostring()",
  "def set_id(self):\n        \"\"\" See :meth:`pybamm.Symbol.set_id()`. \"\"\"\n        self._id = hash(\n            (self.__class__, self.name, self.entries_string) + tuple(self.domain)\n        )",
  "def _jac(self, variable):\n        \"\"\" See :meth:`pybamm.Symbol._jac()`. \"\"\"\n        # Return zeros of correct size\n        jac = csr_matrix((self.size, variable.evaluation_array.count(True)))\n        return pybamm.Matrix(jac)",
  "def new_copy(self):\n        \"\"\" See :meth:`pybamm.Symbol.new_copy()`. \"\"\"\n        return self.__class__(\n            self.entries,\n            self.name,\n            self.domain,\n            self.auxiliary_domains,\n            self.entries_string,\n        )",
  "def _base_evaluate(self, t=None, y=None):\n        \"\"\" See :meth:`pybamm.Symbol._base_evaluate()`. \"\"\"\n        return self._entries",
  "class Concatenation(pybamm.Symbol):\n    \"\"\"A node in the expression tree representing a concatenation of symbols\n\n    **Extends**: :class:`pybamm.Symbol`\n\n    Parameters\n    ----------\n    children : iterable of :class:`pybamm.Symbol`\n        The symbols to concatenate\n\n    \"\"\"\n\n    def __init__(self, *children, name=None, check_domain=True, concat_fun=None):\n        if name is None:\n            name = \"concatenation\"\n        if check_domain:\n            domain = self.get_children_domains(children)\n            auxiliary_domains = self.get_children_auxiliary_domains(children)\n        else:\n            domain = []\n            auxiliary_domains = {}\n        self.concatenation_function = concat_fun\n        super().__init__(\n            name, children, domain=domain, auxiliary_domains=auxiliary_domains\n        )\n\n    def get_children_domains(self, children):\n        # combine domains from children\n        domain = []\n        for child in children:\n            child_domain = child.domain\n            if set(domain).isdisjoint(child_domain):\n                domain += child_domain\n            else:\n                raise pybamm.DomainError(\"\"\"domain of children must be disjoint\"\"\")\n        return domain\n\n    def _concatenation_evaluate(self, children_eval):\n        \"\"\" See :meth:`Concatenation._concatenation_evaluate()`. \"\"\"\n        if len(children_eval) == 0:\n            return np.array([])\n        else:\n            return self.concatenation_function(children_eval)\n\n    def evaluate(self, t=None, y=None, known_evals=None):\n        \"\"\" See :meth:`pybamm.Symbol.evaluate()`. \"\"\"\n        children = self.cached_children\n        if known_evals is not None:\n            if self.id not in known_evals:\n                children_eval = [None] * len(children)\n                for idx, child in enumerate(children):\n                    children_eval[idx], known_evals = child.evaluate(t, y, known_evals)\n                known_evals[self.id] = self._concatenation_evaluate(children_eval)\n            return known_evals[self.id], known_evals\n        else:\n            children_eval = [None] * len(children)\n            for idx, child in enumerate(children):\n                children_eval[idx] = child.evaluate(t, y)\n            return self._concatenation_evaluate(children_eval)\n\n    def new_copy(self):\n        \"\"\" See :meth:`pybamm.Symbol.new_copy()`. \"\"\"\n        new_children = [child.new_copy() for child in self.children]\n        return self._concatenation_new_copy(new_children)\n\n    def _concatenation_new_copy(self, children):\n        \"\"\" See :meth:`pybamm.Symbol.new_copy()`. \"\"\"\n        new_symbol = self.__class__(*children)\n        return new_symbol\n\n    def _concatenation_jac(self, children_jacs):\n        \"\"\" Calculate the jacobian of a concatenation \"\"\"\n        return NotImplementedError\n\n    def _concatenation_simplify(self, children):\n        \"\"\" See :meth:`pybamm.Symbol.simplify()`. \"\"\"\n        new_symbol = self.__class__(*children)\n        new_symbol.domain = []\n        return new_symbol\n\n    def evaluate_for_shape(self):\n        \"\"\" See :meth:`pybamm.Symbol.evaluate_for_shape` \"\"\"\n        if len(self.children) == 0:\n            return np.array([])\n        else:\n            # Default: use np.concatenate\n            concatenation_function = self.concatenation_function or np.concatenate\n            return concatenation_function(\n                [child.evaluate_for_shape() for child in self.children]\n            )",
  "class NumpyConcatenation(Concatenation):\n    \"\"\"A node in the expression tree representing a concatenation of equations, when we\n    *don't* care about domains. The class :class:`pybamm.DomainConcatenation`, which\n    *is* careful about domains and uses broadcasting where appropriate, should be used\n    whenever possible instead.\n\n    Upon evaluation, equations are concatenated using numpy concatenation.\n\n    **Extends**: :class:`Concatenation`\n\n    Parameters\n    ----------\n    children : iterable of :class:`pybamm.Symbol`\n        The equations to concatenate\n\n    \"\"\"\n\n    def __init__(self, *children):\n        children = list(children)\n        # Turn objects that evaluate to scalars to objects that evaluate to vectors,\n        # so that we can concatenate them\n        for i, child in enumerate(children):\n            if child.evaluates_to_number():\n                children[i] = child * pybamm.Vector(np.array([1]))\n        super().__init__(\n            *children,\n            name=\"numpy concatenation\",\n            check_domain=False,\n            concat_fun=np.concatenate\n        )\n\n    def _concatenation_jac(self, children_jacs):\n        \"\"\" See :meth:`pybamm.Concatenation.concatenation_jac()`. \"\"\"\n        children = self.cached_children\n        if len(children) == 0:\n            return pybamm.Scalar(0)\n        else:\n            return SparseStack(*children_jacs)\n\n    def _concatenation_simplify(self, children):\n        \"\"\" See :meth:`pybamm.Symbol.simplify()`. \"\"\"\n        # Turn a concatenation of concatenations into a single concatenation\n        new_children = []\n        for child in children:\n            # extract any children from numpy concatenation\n            if isinstance(child, NumpyConcatenation):\n                new_children.extend(child.orphans)\n            else:\n                new_children.append(child)\n        new_symbol = NumpyConcatenation(*new_children)\n        new_symbol.domain = []\n        return new_symbol",
  "class DomainConcatenation(Concatenation):\n    \"\"\"A node in the expression tree representing a concatenation of symbols, being\n    careful about domains.\n\n    It is assumed that each child has a domain, and the final concatenated vector will\n    respect the sizes and ordering of domains established in mesh keys\n\n    **Extends**: :class:`pybamm.Concatenation`\n\n    Parameters\n    ----------\n\n    children : iterable of :class:`pybamm.Symbol`\n        The symbols to concatenate\n\n    mesh : :class:`pybamm.BaseMesh`\n        The underlying mesh for discretisation, used to obtain the number of mesh points\n        in each domain.\n\n    copy_this : :class:`pybamm.DomainConcatenation` (optional)\n        if provided, this class is initialised by copying everything except the children\n        from `copy_this`. `mesh` is not used in this case\n\n    \"\"\"\n\n    def __init__(self, children, mesh, copy_this=None):\n        # Convert any constant symbols in children to a Vector of the right size for\n        # concatenation\n        children = list(children)\n\n        # Allow the base class to sort the domains into the correct order\n        super().__init__(*children, name=\"domain concatenation\")\n\n        # ensure domain is sorted according to mesh keys\n        domain_dict = {d: mesh.domain_order.index(d) for d in self.domain}\n        self.domain = sorted(domain_dict, key=domain_dict.__getitem__)\n\n        if copy_this is None:\n            # store mesh\n            self._mesh = mesh\n\n            # Check that there is a domain, otherwise the functionality won't work\n            # and we should raise a DomainError\n            if self.domain == []:\n                raise pybamm.DomainError(\n                    \"\"\"\n                    domain cannot be empty for a DomainConcatenation.\n                    Perhaps the children should have been Broadcasted first?\n                    \"\"\"\n                )\n\n            # create dict of domain => slice of final vector\n            self.secondary_dimensions_npts = len(self.mesh[self.domain[0]])\n            self._slices = self.create_slices(self)\n\n            # store size of final vector\n            self._size = self._slices[self.domain[-1]][-1].stop\n\n            # create disc of domain => slice for each child\n            self._children_slices = [\n                self.create_slices(child) for child in self.cached_children\n            ]\n        else:\n            self._mesh = copy.copy(copy_this._mesh)\n            self._slices = copy.copy(copy_this._slices)\n            self._size = copy.copy(copy_this._size)\n            self._children_slices = copy.copy(copy_this._children_slices)\n            self.secondary_dimensions_npts = copy_this.secondary_dimensions_npts\n\n    @property\n    def mesh(self):\n        return self._mesh\n\n    def create_slices(self, node):\n        slices = defaultdict(list)\n        start = 0\n        end = 0\n        second_pts = len(self.mesh[node.domain[0]])\n        if second_pts != self.secondary_dimensions_npts:\n            raise ValueError(\n                \"\"\"Concatenation and children must have the same number of\n                points in secondary dimensions\"\"\"\n            )\n        for i in range(second_pts):\n            for dom in node.domain:\n                end += self.mesh[dom][i].npts\n                slices[dom].append(slice(start, end))\n                start = end\n        return slices\n\n    def _concatenation_evaluate(self, children_eval):\n        \"\"\" See :meth:`Concatenation._concatenation_evaluate()`. \"\"\"\n        # preallocate vector\n        vector = np.empty((self._size, 1))\n\n        # loop through domains of children writing subvectors to final vector\n        for child_vector, slices in zip(children_eval, self._children_slices):\n            for child_dom, child_slice in slices.items():\n                for i, _slice in enumerate(child_slice):\n                    vector[self._slices[child_dom][i]] = child_vector[_slice]\n\n        return vector\n\n    def _concatenation_jac(self, children_jacs):\n        \"\"\" See :meth:`pybamm.Concatenation.concatenation_jac()`. \"\"\"\n        # note that this assumes that the children are in the right order and only have\n        # one domain each\n        jacs = []\n        for i in range(self.secondary_dimensions_npts):\n            for child_jac, slices in zip(children_jacs, self._children_slices):\n                if len(slices) > 1:\n                    raise NotImplementedError(\n                        \"\"\"jacobian only implemented for when each child has\n                        a single domain\"\"\"\n                    )\n                child_slice = next(iter(slices.values()))\n                jacs.append(child_jac[child_slice[i]])\n        return SparseStack(*jacs)\n\n    def _concatenation_new_copy(self, children):\n        \"\"\" See :meth:`pybamm.Symbol.new_copy()`. \"\"\"\n        new_symbol = self.__class__(children, self.mesh, self)\n        return new_symbol\n\n    def _concatenation_simplify(self, children):\n        \"\"\" See :meth:`pybamm.Symbol.simplify()`. \"\"\"\n        # Simplify Concatenation of StateVectors to a single StateVector\n        # The sum of the evalation arrays of the StateVectors must be exactly 1\n        if all([isinstance(child, pybamm.StateVector) for child in children]):\n            longest_eval_array = len(children[-1]._evaluation_array)\n            eval_arrays = {}\n            for child in children:\n                eval_arrays[child] = np.concatenate(\n                    [\n                        child.evaluation_array,\n                        np.zeros(longest_eval_array - len(child.evaluation_array)),\n                    ]\n                )\n            if all(sum(array for array in eval_arrays.values()) == 1):\n                return pybamm.StateVector(\n                    slice(children[0].y_slices[0].start, children[-1].y_slices[-1].stop)\n                )\n\n        new_symbol = self.__class__(children, self.mesh, self)\n\n        # TODO: this should not be needed, but somehow we are still getting domains in\n        # the simplified children\n        new_symbol.domain = []\n\n        return new_symbol",
  "class SparseStack(Concatenation):\n    \"\"\"A node in the expression tree representing a concatenation of sparse\n    matrices. As with NumpyConcatenation, we *don't* care about domains.\n    The class :class:`pybamm.DomainConcatenation`, which *is* careful about\n    domains and uses broadcasting where appropriate, should be used whenever\n    possible instead.\n\n    **Extends**: :class:`Concatenation`\n\n    Parameters\n    ----------\n    children : iterable of :class:`Concatenation`\n        The equations to concatenate\n\n    \"\"\"\n\n    def __init__(self, *children):\n        children = list(children)\n        super().__init__(\n            *children, name=\"sparse stack\", check_domain=False, concat_fun=vstack\n        )",
  "def __init__(self, *children, name=None, check_domain=True, concat_fun=None):\n        if name is None:\n            name = \"concatenation\"\n        if check_domain:\n            domain = self.get_children_domains(children)\n            auxiliary_domains = self.get_children_auxiliary_domains(children)\n        else:\n            domain = []\n            auxiliary_domains = {}\n        self.concatenation_function = concat_fun\n        super().__init__(\n            name, children, domain=domain, auxiliary_domains=auxiliary_domains\n        )",
  "def get_children_domains(self, children):\n        # combine domains from children\n        domain = []\n        for child in children:\n            child_domain = child.domain\n            if set(domain).isdisjoint(child_domain):\n                domain += child_domain\n            else:\n                raise pybamm.DomainError(\"\"\"domain of children must be disjoint\"\"\")\n        return domain",
  "def _concatenation_evaluate(self, children_eval):\n        \"\"\" See :meth:`Concatenation._concatenation_evaluate()`. \"\"\"\n        if len(children_eval) == 0:\n            return np.array([])\n        else:\n            return self.concatenation_function(children_eval)",
  "def evaluate(self, t=None, y=None, known_evals=None):\n        \"\"\" See :meth:`pybamm.Symbol.evaluate()`. \"\"\"\n        children = self.cached_children\n        if known_evals is not None:\n            if self.id not in known_evals:\n                children_eval = [None] * len(children)\n                for idx, child in enumerate(children):\n                    children_eval[idx], known_evals = child.evaluate(t, y, known_evals)\n                known_evals[self.id] = self._concatenation_evaluate(children_eval)\n            return known_evals[self.id], known_evals\n        else:\n            children_eval = [None] * len(children)\n            for idx, child in enumerate(children):\n                children_eval[idx] = child.evaluate(t, y)\n            return self._concatenation_evaluate(children_eval)",
  "def new_copy(self):\n        \"\"\" See :meth:`pybamm.Symbol.new_copy()`. \"\"\"\n        new_children = [child.new_copy() for child in self.children]\n        return self._concatenation_new_copy(new_children)",
  "def _concatenation_new_copy(self, children):\n        \"\"\" See :meth:`pybamm.Symbol.new_copy()`. \"\"\"\n        new_symbol = self.__class__(*children)\n        return new_symbol",
  "def _concatenation_jac(self, children_jacs):\n        \"\"\" Calculate the jacobian of a concatenation \"\"\"\n        return NotImplementedError",
  "def _concatenation_simplify(self, children):\n        \"\"\" See :meth:`pybamm.Symbol.simplify()`. \"\"\"\n        new_symbol = self.__class__(*children)\n        new_symbol.domain = []\n        return new_symbol",
  "def evaluate_for_shape(self):\n        \"\"\" See :meth:`pybamm.Symbol.evaluate_for_shape` \"\"\"\n        if len(self.children) == 0:\n            return np.array([])\n        else:\n            # Default: use np.concatenate\n            concatenation_function = self.concatenation_function or np.concatenate\n            return concatenation_function(\n                [child.evaluate_for_shape() for child in self.children]\n            )",
  "def __init__(self, *children):\n        children = list(children)\n        # Turn objects that evaluate to scalars to objects that evaluate to vectors,\n        # so that we can concatenate them\n        for i, child in enumerate(children):\n            if child.evaluates_to_number():\n                children[i] = child * pybamm.Vector(np.array([1]))\n        super().__init__(\n            *children,\n            name=\"numpy concatenation\",\n            check_domain=False,\n            concat_fun=np.concatenate\n        )",
  "def _concatenation_jac(self, children_jacs):\n        \"\"\" See :meth:`pybamm.Concatenation.concatenation_jac()`. \"\"\"\n        children = self.cached_children\n        if len(children) == 0:\n            return pybamm.Scalar(0)\n        else:\n            return SparseStack(*children_jacs)",
  "def _concatenation_simplify(self, children):\n        \"\"\" See :meth:`pybamm.Symbol.simplify()`. \"\"\"\n        # Turn a concatenation of concatenations into a single concatenation\n        new_children = []\n        for child in children:\n            # extract any children from numpy concatenation\n            if isinstance(child, NumpyConcatenation):\n                new_children.extend(child.orphans)\n            else:\n                new_children.append(child)\n        new_symbol = NumpyConcatenation(*new_children)\n        new_symbol.domain = []\n        return new_symbol",
  "def __init__(self, children, mesh, copy_this=None):\n        # Convert any constant symbols in children to a Vector of the right size for\n        # concatenation\n        children = list(children)\n\n        # Allow the base class to sort the domains into the correct order\n        super().__init__(*children, name=\"domain concatenation\")\n\n        # ensure domain is sorted according to mesh keys\n        domain_dict = {d: mesh.domain_order.index(d) for d in self.domain}\n        self.domain = sorted(domain_dict, key=domain_dict.__getitem__)\n\n        if copy_this is None:\n            # store mesh\n            self._mesh = mesh\n\n            # Check that there is a domain, otherwise the functionality won't work\n            # and we should raise a DomainError\n            if self.domain == []:\n                raise pybamm.DomainError(\n                    \"\"\"\n                    domain cannot be empty for a DomainConcatenation.\n                    Perhaps the children should have been Broadcasted first?\n                    \"\"\"\n                )\n\n            # create dict of domain => slice of final vector\n            self.secondary_dimensions_npts = len(self.mesh[self.domain[0]])\n            self._slices = self.create_slices(self)\n\n            # store size of final vector\n            self._size = self._slices[self.domain[-1]][-1].stop\n\n            # create disc of domain => slice for each child\n            self._children_slices = [\n                self.create_slices(child) for child in self.cached_children\n            ]\n        else:\n            self._mesh = copy.copy(copy_this._mesh)\n            self._slices = copy.copy(copy_this._slices)\n            self._size = copy.copy(copy_this._size)\n            self._children_slices = copy.copy(copy_this._children_slices)\n            self.secondary_dimensions_npts = copy_this.secondary_dimensions_npts",
  "def mesh(self):\n        return self._mesh",
  "def create_slices(self, node):\n        slices = defaultdict(list)\n        start = 0\n        end = 0\n        second_pts = len(self.mesh[node.domain[0]])\n        if second_pts != self.secondary_dimensions_npts:\n            raise ValueError(\n                \"\"\"Concatenation and children must have the same number of\n                points in secondary dimensions\"\"\"\n            )\n        for i in range(second_pts):\n            for dom in node.domain:\n                end += self.mesh[dom][i].npts\n                slices[dom].append(slice(start, end))\n                start = end\n        return slices",
  "def _concatenation_evaluate(self, children_eval):\n        \"\"\" See :meth:`Concatenation._concatenation_evaluate()`. \"\"\"\n        # preallocate vector\n        vector = np.empty((self._size, 1))\n\n        # loop through domains of children writing subvectors to final vector\n        for child_vector, slices in zip(children_eval, self._children_slices):\n            for child_dom, child_slice in slices.items():\n                for i, _slice in enumerate(child_slice):\n                    vector[self._slices[child_dom][i]] = child_vector[_slice]\n\n        return vector",
  "def _concatenation_jac(self, children_jacs):\n        \"\"\" See :meth:`pybamm.Concatenation.concatenation_jac()`. \"\"\"\n        # note that this assumes that the children are in the right order and only have\n        # one domain each\n        jacs = []\n        for i in range(self.secondary_dimensions_npts):\n            for child_jac, slices in zip(children_jacs, self._children_slices):\n                if len(slices) > 1:\n                    raise NotImplementedError(\n                        \"\"\"jacobian only implemented for when each child has\n                        a single domain\"\"\"\n                    )\n                child_slice = next(iter(slices.values()))\n                jacs.append(child_jac[child_slice[i]])\n        return SparseStack(*jacs)",
  "def _concatenation_new_copy(self, children):\n        \"\"\" See :meth:`pybamm.Symbol.new_copy()`. \"\"\"\n        new_symbol = self.__class__(children, self.mesh, self)\n        return new_symbol",
  "def _concatenation_simplify(self, children):\n        \"\"\" See :meth:`pybamm.Symbol.simplify()`. \"\"\"\n        # Simplify Concatenation of StateVectors to a single StateVector\n        # The sum of the evalation arrays of the StateVectors must be exactly 1\n        if all([isinstance(child, pybamm.StateVector) for child in children]):\n            longest_eval_array = len(children[-1]._evaluation_array)\n            eval_arrays = {}\n            for child in children:\n                eval_arrays[child] = np.concatenate(\n                    [\n                        child.evaluation_array,\n                        np.zeros(longest_eval_array - len(child.evaluation_array)),\n                    ]\n                )\n            if all(sum(array for array in eval_arrays.values()) == 1):\n                return pybamm.StateVector(\n                    slice(children[0].y_slices[0].start, children[-1].y_slices[-1].stop)\n                )\n\n        new_symbol = self.__class__(children, self.mesh, self)\n\n        # TODO: this should not be needed, but somehow we are still getting domains in\n        # the simplified children\n        new_symbol.domain = []\n\n        return new_symbol",
  "def __init__(self, *children):\n        children = list(children)\n        super().__init__(\n            *children, name=\"sparse stack\", check_domain=False, concat_fun=vstack\n        )",
  "class Variable(pybamm.Symbol):\n    \"\"\"A node in the expression tree represending a dependent variable\n\n    This node will be discretised by :class:`.Discretisation` and converted\n    to a :class:`.Vector` node.\n\n    Parameters\n    ----------\n\n    name : str\n        name of the node\n    domain : iterable of str\n        list of domains that this variable is valid over\n    auxiliary_domains : dict\n        dictionary of auxiliary domains ({'secondary': ..., 'tertiary': ...}). For\n        example, for the single particle model, the particle concentration would be a\n        Variable with domain 'negative particle' and secondary auxiliary domain 'current\n        collector'. For the DFN, the particle concentration would be a Variable with\n        domain 'negative particle', secondary domain 'negative electrode' and tertiary\n        domain 'current collector'\n\n    *Extends:* :class:`Symbol`\n    \"\"\"\n\n    def __init__(self, name, domain=None, auxiliary_domains=None):\n        if domain is None:\n            domain = []\n        if auxiliary_domains is None:\n            auxiliary_domains = {}\n        super().__init__(name, domain=domain, auxiliary_domains=auxiliary_domains)\n\n    def new_copy(self):\n        \"\"\" See :meth:`pybamm.Symbol.new_copy()`. \"\"\"\n        return Variable(self.name, self.domain, self.auxiliary_domains)\n\n    def evaluate_for_shape(self):\n        \"\"\" See :meth:`pybamm.Symbol.evaluate_for_shape_using_domain()` \"\"\"\n        return pybamm.evaluate_for_shape_using_domain(\n            self.domain, self.auxiliary_domains\n        )",
  "def __init__(self, name, domain=None, auxiliary_domains=None):\n        if domain is None:\n            domain = []\n        if auxiliary_domains is None:\n            auxiliary_domains = {}\n        super().__init__(name, domain=domain, auxiliary_domains=auxiliary_domains)",
  "def new_copy(self):\n        \"\"\" See :meth:`pybamm.Symbol.new_copy()`. \"\"\"\n        return Variable(self.name, self.domain, self.auxiliary_domains)",
  "def evaluate_for_shape(self):\n        \"\"\" See :meth:`pybamm.Symbol.evaluate_for_shape_using_domain()` \"\"\"\n        return pybamm.evaluate_for_shape_using_domain(\n            self.domain, self.auxiliary_domains\n        )",
  "class DomainError(Exception):\n    \"\"\"Domain error: an operation was attempted on nodes with un-matched domains\"\"\"\n\n    pass",
  "class OptionError(Exception):\n    \"\"\"Option error: an unknown option was given\"\"\"\n\n    pass",
  "class GeometryError(Exception):\n    \"\"\"\n        Geometry error: Raised if the an unimplemented geometry is used.\n     \"\"\"\n\n    pass",
  "class ModelError(Exception):\n    \"\"\"Model error: the model is not well-posed (can be before or after processing)\"\"\"\n\n    pass",
  "class SolverError(Exception):\n    \"\"\"\n    Solver error: a solution to the model could not be found with the chosen settings\n    \"\"\"\n\n    pass",
  "class ShapeError(Exception):\n    \"\"\"\n    Shape error: cannot evaluate an object to find its shape\n    \"\"\"\n\n    pass",
  "class ModelWarning(UserWarning):\n    \"\"\"\n    Model warning: the model does not contain all of the standard output variables\n    \"\"\"\n\n    pass",
  "class UndefinedOperationError(Exception):\n    \"\"\"\n    Undefined operation: Raised when a mathematical operation is not well-defined\n    \"\"\"\n\n    pass",
  "class Broadcast(pybamm.SpatialOperator):\n    \"\"\"A node in the expression tree representing a broadcasting operator.\n    Broadcasts a child to a specified domain. After discretisation, this will evaluate\n    to an array of the right shape for the specified domain.\n\n    Parameters\n    ----------\n    child : :class:`Symbol`\n        child node\n    broadcast_domain : iterable of str\n        Primary domain for broadcast. This will become the domain of the symbol\n    auxiliary_domain : iterable of str\n        Secondary domain for broadcast. Currently, this is only used for testing that\n        symbols have the right shape.\n    broadcast_type : str, optional\n        Whether to broadcast to the full domain (primary and secondary) or only in the\n        primary direction. Default is \"full\".\n    name : str\n        name of the node\n\n    **Extends:** :class:`SpatialOperator`\n    \"\"\"\n\n    def __init__(\n        self,\n        child,\n        broadcast_domain,\n        auxiliary_domains=None,\n        broadcast_type=\"full\",\n        name=None,\n    ):\n        # Convert child to scalar if it is a number\n        if isinstance(child, numbers.Number):\n            child = pybamm.Scalar(child)\n\n        if name is None:\n            name = \"broadcast\"\n\n        # perform some basic checks and set attributes\n        domain = self.check_and_set_domain_and_broadcast_type(\n            child, broadcast_domain, broadcast_type\n        )\n        self.broadcast_type = broadcast_type\n        self.broadcast_domain = broadcast_domain\n        if auxiliary_domains is None:\n            if child.domain != []:\n                auxiliary_domains = {\"secondary\": child.domain}\n            else:\n                auxiliary_domains = {}\n        super().__init__(name, child, domain, auxiliary_domains)\n\n    def check_and_set_domain_and_broadcast_type(\n        self, child, broadcast_domain, broadcast_type\n    ):\n        \"\"\"\n        Set broadcast domain and broadcast type, performing basic checks to make sure\n        it is compatible with the child\n        \"\"\"\n        # Acceptable broadcast types\n        if broadcast_type not in [\"primary\", \"secondary\", \"full\"]:\n            raise KeyError(\n                \"\"\"Broadcast type must be either: 'primary', 'secondary', or 'full' and\n                not {}\"\"\".format(\n                    broadcast_type\n                )\n            )\n\n        domain = broadcast_domain\n\n        # Variables on the current collector can only be broadcast to 'primary'\n        if broadcast_type == \"full\":\n            if child.domain == [\"current collector\"]:\n                raise ValueError(\n                    \"\"\"\n                    Variables on the current collector must be broadcast to 'primary'\n                    only\n                    \"\"\"\n                )\n        return domain\n\n    def _unary_simplify(self, child):\n        \"\"\" See :meth:`pybamm.UnaryOperator.simplify()`. \"\"\"\n\n        return Broadcast(\n            child, self.broadcast_domain, self.auxiliary_domains, self.broadcast_type\n        )\n\n    def _unary_new_copy(self, child):\n        \"\"\" See :meth:`pybamm.UnaryOperator.simplify()`. \"\"\"\n\n        return Broadcast(\n            child, self.broadcast_domain, self.auxiliary_domains, self.broadcast_type\n        )\n\n    def evaluate_for_shape(self):\n        \"\"\"\n        Returns a vector of NaNs to represent the shape of a Broadcast.\n        See :meth:`pybamm.Symbol.evaluate_for_shape_using_domain()`\n        \"\"\"\n        child_eval = self.children[0].evaluate_for_shape()\n        vec = pybamm.evaluate_for_shape_using_domain(self.domain)\n\n        if self.broadcast_type == \"primary\":\n            return np.outer(child_eval, vec).reshape(-1, 1)\n        elif self.broadcast_type == \"full\":\n            return child_eval * vec",
  "class PrimaryBroadcast(Broadcast):\n    \"\"\"A node in the expression tree representing a primary broadcasting operator.\n    Broadcasts in a `primary` dimension only. That is, makes explicit copies\n\n    Parameters\n    ----------\n    child : :class:`Symbol`\n        child node\n    broadcast_domain : iterable of str\n        Primary domain for broadcast. This will become the domain of the symbol\n    name : str\n        name of the node\n\n    **Extends:** :class:`SpatialOperator`\n    \"\"\"\n\n    def __init__(self, child, broadcast_domain, name=None):\n        super().__init__(child, broadcast_domain, broadcast_type=\"primary\", name=name)\n\n    def _unary_simplify(self, child):\n        \"\"\" See :meth:`pybamm.UnaryOperator.simplify()`. \"\"\"\n        return PrimaryBroadcast(child, self.broadcast_domain)\n\n    def _unary_new_copy(self, child):\n        \"\"\" See :meth:`pybamm.UnaryOperator.simplify()`. \"\"\"\n        return PrimaryBroadcast(child, self.broadcast_domain)\n\n    def evaluate_for_shape(self):\n        \"\"\"\n        Returns a vector of NaNs to represent the shape of a Broadcast.\n        See :meth:`pybamm.Symbol.evaluate_for_shape_using_domain()`\n        \"\"\"\n        child_eval = self.children[0].evaluate_for_shape()\n        vec = pybamm.evaluate_for_shape_using_domain(self.domain)\n        return np.outer(child_eval, vec).reshape(-1, 1)",
  "class FullBroadcast(Broadcast):\n    \"A class for full broadcasts\"\n\n    def __init__(self, child, broadcast_domain, auxiliary_domains, name=None):\n        if auxiliary_domains == \"current collector\":\n            auxiliary_domains = {\"secondary\": \"current collector\"}\n        super().__init__(\n            child,\n            broadcast_domain,\n            auxiliary_domains=auxiliary_domains,\n            broadcast_type=\"full\",\n            name=name,\n        )\n\n    def _unary_simplify(self, child):\n        \"\"\" See :meth:`pybamm.UnaryOperator.simplify()`. \"\"\"\n        return FullBroadcast(child, self.broadcast_domain, self.auxiliary_domains)\n\n    def _unary_new_copy(self, child):\n        \"\"\" See :meth:`pybamm.UnaryOperator.simplify()`. \"\"\"\n        return FullBroadcast(child, self.broadcast_domain, self.auxiliary_domains)\n\n    def evaluate_for_shape(self):\n        \"\"\"\n        Returns a vector of NaNs to represent the shape of a Broadcast.\n        See :meth:`pybamm.Symbol.evaluate_for_shape_using_domain()`\n        \"\"\"\n        child_eval = self.children[0].evaluate_for_shape()\n        vec = pybamm.evaluate_for_shape_using_domain(\n            self.domain, self.auxiliary_domains\n        )\n\n        return child_eval * vec",
  "def __init__(\n        self,\n        child,\n        broadcast_domain,\n        auxiliary_domains=None,\n        broadcast_type=\"full\",\n        name=None,\n    ):\n        # Convert child to scalar if it is a number\n        if isinstance(child, numbers.Number):\n            child = pybamm.Scalar(child)\n\n        if name is None:\n            name = \"broadcast\"\n\n        # perform some basic checks and set attributes\n        domain = self.check_and_set_domain_and_broadcast_type(\n            child, broadcast_domain, broadcast_type\n        )\n        self.broadcast_type = broadcast_type\n        self.broadcast_domain = broadcast_domain\n        if auxiliary_domains is None:\n            if child.domain != []:\n                auxiliary_domains = {\"secondary\": child.domain}\n            else:\n                auxiliary_domains = {}\n        super().__init__(name, child, domain, auxiliary_domains)",
  "def check_and_set_domain_and_broadcast_type(\n        self, child, broadcast_domain, broadcast_type\n    ):\n        \"\"\"\n        Set broadcast domain and broadcast type, performing basic checks to make sure\n        it is compatible with the child\n        \"\"\"\n        # Acceptable broadcast types\n        if broadcast_type not in [\"primary\", \"secondary\", \"full\"]:\n            raise KeyError(\n                \"\"\"Broadcast type must be either: 'primary', 'secondary', or 'full' and\n                not {}\"\"\".format(\n                    broadcast_type\n                )\n            )\n\n        domain = broadcast_domain\n\n        # Variables on the current collector can only be broadcast to 'primary'\n        if broadcast_type == \"full\":\n            if child.domain == [\"current collector\"]:\n                raise ValueError(\n                    \"\"\"\n                    Variables on the current collector must be broadcast to 'primary'\n                    only\n                    \"\"\"\n                )\n        return domain",
  "def _unary_simplify(self, child):\n        \"\"\" See :meth:`pybamm.UnaryOperator.simplify()`. \"\"\"\n\n        return Broadcast(\n            child, self.broadcast_domain, self.auxiliary_domains, self.broadcast_type\n        )",
  "def _unary_new_copy(self, child):\n        \"\"\" See :meth:`pybamm.UnaryOperator.simplify()`. \"\"\"\n\n        return Broadcast(\n            child, self.broadcast_domain, self.auxiliary_domains, self.broadcast_type\n        )",
  "def evaluate_for_shape(self):\n        \"\"\"\n        Returns a vector of NaNs to represent the shape of a Broadcast.\n        See :meth:`pybamm.Symbol.evaluate_for_shape_using_domain()`\n        \"\"\"\n        child_eval = self.children[0].evaluate_for_shape()\n        vec = pybamm.evaluate_for_shape_using_domain(self.domain)\n\n        if self.broadcast_type == \"primary\":\n            return np.outer(child_eval, vec).reshape(-1, 1)\n        elif self.broadcast_type == \"full\":\n            return child_eval * vec",
  "def __init__(self, child, broadcast_domain, name=None):\n        super().__init__(child, broadcast_domain, broadcast_type=\"primary\", name=name)",
  "def _unary_simplify(self, child):\n        \"\"\" See :meth:`pybamm.UnaryOperator.simplify()`. \"\"\"\n        return PrimaryBroadcast(child, self.broadcast_domain)",
  "def _unary_new_copy(self, child):\n        \"\"\" See :meth:`pybamm.UnaryOperator.simplify()`. \"\"\"\n        return PrimaryBroadcast(child, self.broadcast_domain)",
  "def evaluate_for_shape(self):\n        \"\"\"\n        Returns a vector of NaNs to represent the shape of a Broadcast.\n        See :meth:`pybamm.Symbol.evaluate_for_shape_using_domain()`\n        \"\"\"\n        child_eval = self.children[0].evaluate_for_shape()\n        vec = pybamm.evaluate_for_shape_using_domain(self.domain)\n        return np.outer(child_eval, vec).reshape(-1, 1)",
  "def __init__(self, child, broadcast_domain, auxiliary_domains, name=None):\n        if auxiliary_domains == \"current collector\":\n            auxiliary_domains = {\"secondary\": \"current collector\"}\n        super().__init__(\n            child,\n            broadcast_domain,\n            auxiliary_domains=auxiliary_domains,\n            broadcast_type=\"full\",\n            name=name,\n        )",
  "def _unary_simplify(self, child):\n        \"\"\" See :meth:`pybamm.UnaryOperator.simplify()`. \"\"\"\n        return FullBroadcast(child, self.broadcast_domain, self.auxiliary_domains)",
  "def _unary_new_copy(self, child):\n        \"\"\" See :meth:`pybamm.UnaryOperator.simplify()`. \"\"\"\n        return FullBroadcast(child, self.broadcast_domain, self.auxiliary_domains)",
  "def evaluate_for_shape(self):\n        \"\"\"\n        Returns a vector of NaNs to represent the shape of a Broadcast.\n        See :meth:`pybamm.Symbol.evaluate_for_shape_using_domain()`\n        \"\"\"\n        child_eval = self.children[0].evaluate_for_shape()\n        vec = pybamm.evaluate_for_shape_using_domain(\n            self.domain, self.auxiliary_domains\n        )\n\n        return child_eval * vec",
  "class Parameter(pybamm.Symbol):\n    \"\"\"A node in the expression tree representing a parameter\n\n    This node will be replaced by a :class:`.Scalar` node by :class`.Parameter`\n\n    Parameters\n    ----------\n\n    name : str\n        name of the node\n    domain : iterable of str, optional\n        list of domains the parameter is valid over, defaults to empty list\n\n    \"\"\"\n\n    def __init__(self, name, domain=[]):\n        super().__init__(name, domain=domain)\n\n    def new_copy(self):\n        \"\"\" See :meth:`pybamm.Symbol.new_copy()`. \"\"\"\n        return Parameter(self.name, self.domain)\n\n    def evaluate_for_shape(self):\n        \"\"\"\n        Returns the scalar 'NaN' to represent the shape of a parameter.\n        See :meth:`pybamm.Symbol.evaluate_for_shape()`\n        \"\"\"\n        return np.nan",
  "class FunctionParameter(pybamm.Symbol):\n    \"\"\"A node in the expression tree representing a function parameter\n\n    This node will be replaced by a :class:`pybamm.Function` node if a callable function\n    is passed to the parameter values, and otherwise (in some rarer cases, such as\n    constant current) a :class:`pybamm.Scalar` node.\n\n    Parameters\n    ----------\n\n    name : str\n        name of the node\n    child : :class:`Symbol`\n        child node\n    diff_variable : :class:`pybamm.Symbol`, optional\n        if diff_variable is specified, the FunctionParameter node will be replaced by a\n        :class:`pybamm.Function` and then differentiated with respect to diff_variable.\n        Default is None.\n\n    \"\"\"\n\n    def __init__(self, name, *children, diff_variable=None):\n        # assign diff variable\n        self.diff_variable = diff_variable\n        children_list = list(children)\n        domain = self.get_children_domains(children_list)\n        auxiliary_domains = self.get_children_auxiliary_domains(children)\n        super().__init__(\n            name, children=children, domain=domain, auxiliary_domains=auxiliary_domains\n        )\n\n    def set_id(self):\n        \"\"\"See :meth:`pybamm.Symbol.set_id` \"\"\"\n        self._id = hash(\n            (self.__class__, self.name, self.diff_variable)\n            + tuple([child.id for child in self.children])\n            + tuple(self.domain)\n        )\n\n    def get_children_domains(self, children_list):\n        \"\"\"Obtains the unique domain of the children. If the\n        children have different domains then raise an error\"\"\"\n        domains = [child.domain for child in children_list if child.domain != []]\n\n        # check that there is one common domain amongst children\n        distinct_domains = set(tuple(dom) for dom in domains)\n\n        if len(distinct_domains) > 1:\n            raise pybamm.DomainError(\n                \"Functions can only be applied to variables on the same domain\"\n            )\n        elif len(distinct_domains) == 0:\n            domain = []\n        else:\n            domain = domains[0]\n\n        return domain\n\n    def diff(self, variable):\n        \"\"\" See :meth:`pybamm.Symbol.diff()`. \"\"\"\n        # return a new FunctionParameter, that knows it will need to be differentiated\n        # when the parameters are set\n        return FunctionParameter(self.name, *self.orphans, diff_variable=variable)\n\n    def new_copy(self):\n        \"\"\" See :meth:`pybamm.Symbol.new_copy()`. \"\"\"\n        return self._function_parameter_new_copy(self.orphans)\n\n    def _function_parameter_new_copy(self, children):\n        \"\"\"Returns a new copy of the function parameter.\n\n        Inputs\n        ------\n        children : : list\n            A list of the children of the function\n\n        Returns\n        -------\n            : :pybamm.FunctionParameter\n            A new copy of the function parameter\n        \"\"\"\n        return FunctionParameter(self.name, *children, diff_variable=self.diff_variable)\n\n    def evaluate_for_shape(self):\n        \"\"\"\n        Returns the sum of the evaluated children\n        See :meth:`pybamm.Symbol.evaluate_for_shape()`\n        \"\"\"\n        return sum(child.evaluate_for_shape() for child in self.children)",
  "def __init__(self, name, domain=[]):\n        super().__init__(name, domain=domain)",
  "def new_copy(self):\n        \"\"\" See :meth:`pybamm.Symbol.new_copy()`. \"\"\"\n        return Parameter(self.name, self.domain)",
  "def evaluate_for_shape(self):\n        \"\"\"\n        Returns the scalar 'NaN' to represent the shape of a parameter.\n        See :meth:`pybamm.Symbol.evaluate_for_shape()`\n        \"\"\"\n        return np.nan",
  "def __init__(self, name, *children, diff_variable=None):\n        # assign diff variable\n        self.diff_variable = diff_variable\n        children_list = list(children)\n        domain = self.get_children_domains(children_list)\n        auxiliary_domains = self.get_children_auxiliary_domains(children)\n        super().__init__(\n            name, children=children, domain=domain, auxiliary_domains=auxiliary_domains\n        )",
  "def set_id(self):\n        \"\"\"See :meth:`pybamm.Symbol.set_id` \"\"\"\n        self._id = hash(\n            (self.__class__, self.name, self.diff_variable)\n            + tuple([child.id for child in self.children])\n            + tuple(self.domain)\n        )",
  "def get_children_domains(self, children_list):\n        \"\"\"Obtains the unique domain of the children. If the\n        children have different domains then raise an error\"\"\"\n        domains = [child.domain for child in children_list if child.domain != []]\n\n        # check that there is one common domain amongst children\n        distinct_domains = set(tuple(dom) for dom in domains)\n\n        if len(distinct_domains) > 1:\n            raise pybamm.DomainError(\n                \"Functions can only be applied to variables on the same domain\"\n            )\n        elif len(distinct_domains) == 0:\n            domain = []\n        else:\n            domain = domains[0]\n\n        return domain",
  "def diff(self, variable):\n        \"\"\" See :meth:`pybamm.Symbol.diff()`. \"\"\"\n        # return a new FunctionParameter, that knows it will need to be differentiated\n        # when the parameters are set\n        return FunctionParameter(self.name, *self.orphans, diff_variable=variable)",
  "def new_copy(self):\n        \"\"\" See :meth:`pybamm.Symbol.new_copy()`. \"\"\"\n        return self._function_parameter_new_copy(self.orphans)",
  "def _function_parameter_new_copy(self, children):\n        \"\"\"Returns a new copy of the function parameter.\n\n        Inputs\n        ------\n        children : : list\n            A list of the children of the function\n\n        Returns\n        -------\n            : :pybamm.FunctionParameter\n            A new copy of the function parameter\n        \"\"\"\n        return FunctionParameter(self.name, *children, diff_variable=self.diff_variable)",
  "def evaluate_for_shape(self):\n        \"\"\"\n        Returns the sum of the evaluated children\n        See :meth:`pybamm.Symbol.evaluate_for_shape()`\n        \"\"\"\n        return sum(child.evaluate_for_shape() for child in self.children)",
  "class Vector(pybamm.Array):\n    \"\"\"node in the expression tree that holds a vector type (e.g. :class:`numpy.array`)\n\n    **Extends:** :class:`Array`\n\n    \"\"\"\n\n    def __init__(\n        self,\n        entries,\n        name=None,\n        domain=None,\n        auxiliary_domains=None,\n        entries_string=None,\n    ):\n        # make sure that entries are a vector (can be a column vector)\n        if entries.ndim == 1:\n            entries = entries[:, np.newaxis]\n        if entries.shape[1] != 1:\n            raise ValueError(\n                \"\"\"\n                Entries must have 1 dimension or be column vector, not have shape {}\n                \"\"\".format(\n                    entries.shape\n                )\n            )\n        if name is None:\n            name = \"Column vector of length {!s}\".format(entries.shape[0])\n\n        super().__init__(entries, name, domain, auxiliary_domains, entries_string)",
  "def __init__(\n        self,\n        entries,\n        name=None,\n        domain=None,\n        auxiliary_domains=None,\n        entries_string=None,\n    ):\n        # make sure that entries are a vector (can be a column vector)\n        if entries.ndim == 1:\n            entries = entries[:, np.newaxis]\n        if entries.shape[1] != 1:\n            raise ValueError(\n                \"\"\"\n                Entries must have 1 dimension or be column vector, not have shape {}\n                \"\"\".format(\n                    entries.shape\n                )\n            )\n        if name is None:\n            name = \"Column vector of length {!s}\".format(entries.shape[0])\n\n        super().__init__(entries, name, domain, auxiliary_domains, entries_string)",
  "class Jacobian(object):\n    def __init__(self, known_jacs=None):\n        self._known_jacs = known_jacs or {}\n\n    def jac(self, symbol, variable):\n        \"\"\"\n        This function recurses down the tree, computing the Jacobian using\n        the Jacobians defined in classes derived from pybamm.Symbol. E.g. the\n        Jacobian of a 'pybamm.Multiplication' is computed via the product rule.\n        If the Jacobian of a symbol has already been calculated, the stored value\n        is returned.\n        Note: The Jacobian is the derivative of a symbol with respect to a (slice of)\n        a State Vector.\n\n        Parameters\n        ----------\n        symbol : :class:`pybamm.Symbol`\n            The symbol to calculate the Jacobian of\n        variable : :class:`pybamm.Symbol`\n            The variable with respect to which to differentiate\n\n        Returns\n        -------\n        :class:`pybamm.Symbol`\n            Symbol representing the Jacobian\n        \"\"\"\n\n        try:\n            return self._known_jacs[symbol.id]\n        except KeyError:\n            jac = self._jac(symbol, variable)\n            self._known_jacs[symbol.id] = jac\n            return jac\n\n    def _jac(self, symbol, variable):\n        \"\"\" See :meth:`Jacobian.jac()`. \"\"\"\n\n        if isinstance(symbol, pybamm.BinaryOperator):\n            left, right = symbol.children\n            # process children\n            left_jac = self.jac(left, variable)\n            right_jac = self.jac(right, variable)\n            # Need to treat outer differently. If the left child of an Outer\n            # evaluates to number then we need to return a matrix of zeros\n            # of the correct size, which requires variable.evaluation_array\n            if isinstance(symbol, pybamm.Outer):\n                # _outer_jac defined in pybamm.Outer\n                jac = symbol._outer_jac(left_jac, right_jac, variable)\n            else:\n                # _binary_jac defined in derived classes for specific rules\n                jac = symbol._binary_jac(left_jac, right_jac)\n\n        elif isinstance(symbol, pybamm.UnaryOperator):\n            child_jac = self.jac(symbol.child, variable)\n            # _unary_jac defined in derived classes for specific rules\n            jac = symbol._unary_jac(child_jac)\n\n        elif isinstance(symbol, pybamm.Function):\n            children_jacs = [None] * len(symbol.children)\n            for i, child in enumerate(symbol.children):\n                children_jacs[i] = self.jac(child, variable)\n            # _function_jac defined in function class\n            jac = symbol._function_jac(children_jacs)\n\n        elif isinstance(symbol, pybamm.Concatenation):\n            children_jacs = [child.jac(variable) for child in symbol.cached_children]\n            jac = symbol._concatenation_jac(children_jacs)\n\n        else:\n            try:\n                jac = symbol._jac(variable)\n            except NotImplementedError:\n                raise NotImplementedError(\n                    \"Cannot calculate Jacobian of symbol of type '{}'\".format(\n                        type(symbol)\n                    )\n                )\n\n        # jacobian removes the domain(s)\n        jac.domain = []\n        jac.auxiliary_domains = {}\n        return jac",
  "def __init__(self, known_jacs=None):\n        self._known_jacs = known_jacs or {}",
  "def jac(self, symbol, variable):\n        \"\"\"\n        This function recurses down the tree, computing the Jacobian using\n        the Jacobians defined in classes derived from pybamm.Symbol. E.g. the\n        Jacobian of a 'pybamm.Multiplication' is computed via the product rule.\n        If the Jacobian of a symbol has already been calculated, the stored value\n        is returned.\n        Note: The Jacobian is the derivative of a symbol with respect to a (slice of)\n        a State Vector.\n\n        Parameters\n        ----------\n        symbol : :class:`pybamm.Symbol`\n            The symbol to calculate the Jacobian of\n        variable : :class:`pybamm.Symbol`\n            The variable with respect to which to differentiate\n\n        Returns\n        -------\n        :class:`pybamm.Symbol`\n            Symbol representing the Jacobian\n        \"\"\"\n\n        try:\n            return self._known_jacs[symbol.id]\n        except KeyError:\n            jac = self._jac(symbol, variable)\n            self._known_jacs[symbol.id] = jac\n            return jac",
  "def _jac(self, symbol, variable):\n        \"\"\" See :meth:`Jacobian.jac()`. \"\"\"\n\n        if isinstance(symbol, pybamm.BinaryOperator):\n            left, right = symbol.children\n            # process children\n            left_jac = self.jac(left, variable)\n            right_jac = self.jac(right, variable)\n            # Need to treat outer differently. If the left child of an Outer\n            # evaluates to number then we need to return a matrix of zeros\n            # of the correct size, which requires variable.evaluation_array\n            if isinstance(symbol, pybamm.Outer):\n                # _outer_jac defined in pybamm.Outer\n                jac = symbol._outer_jac(left_jac, right_jac, variable)\n            else:\n                # _binary_jac defined in derived classes for specific rules\n                jac = symbol._binary_jac(left_jac, right_jac)\n\n        elif isinstance(symbol, pybamm.UnaryOperator):\n            child_jac = self.jac(symbol.child, variable)\n            # _unary_jac defined in derived classes for specific rules\n            jac = symbol._unary_jac(child_jac)\n\n        elif isinstance(symbol, pybamm.Function):\n            children_jacs = [None] * len(symbol.children)\n            for i, child in enumerate(symbol.children):\n                children_jacs[i] = self.jac(child, variable)\n            # _function_jac defined in function class\n            jac = symbol._function_jac(children_jacs)\n\n        elif isinstance(symbol, pybamm.Concatenation):\n            children_jacs = [child.jac(variable) for child in symbol.cached_children]\n            jac = symbol._concatenation_jac(children_jacs)\n\n        else:\n            try:\n                jac = symbol._jac(variable)\n            except NotImplementedError:\n                raise NotImplementedError(\n                    \"Cannot calculate Jacobian of symbol of type '{}'\".format(\n                        type(symbol)\n                    )\n                )\n\n        # jacobian removes the domain(s)\n        jac.domain = []\n        jac.auxiliary_domains = {}\n        return jac",
  "def is_scalar_zero(expr):\n    \"\"\"\n    Utility function to test if an expression evaluates to a constant scalar zero\n    \"\"\"\n    if expr.is_constant():\n        result = expr.evaluate_ignoring_errors()\n        return isinstance(result, numbers.Number) and result == 0\n    else:\n        return False",
  "def is_matrix_zero(expr):\n    \"\"\"\n    Utility function to test if an expression evaluates to a constant matrix zero\n    \"\"\"\n    if expr.is_constant():\n        result = expr.evaluate_ignoring_errors()\n        return (issparse(result) and result.count_nonzero() == 0) or (\n            isinstance(result, np.ndarray) and np.all(result == 0)\n        )\n    else:\n        return False",
  "def is_one(expr):\n    \"\"\"\n    Utility function to test if an expression evaluates to a constant scalar one\n    \"\"\"\n    if expr.is_constant():\n        result = expr.evaluate_ignoring_errors()\n        return isinstance(result, numbers.Number) and result == 1\n    else:\n        return False",
  "def zeros_of_shape(shape):\n    \"\"\"\n    Utility function to create a scalar zero, or a vector or matrix of zeros of\n    the correct shape\n    \"\"\"\n    if shape == ():\n        return pybamm.Scalar(0)\n    else:\n        if len(shape) == 1 or shape[1] == 1:\n            return pybamm.Vector(np.zeros(shape))\n        else:\n            return pybamm.Matrix(csr_matrix(shape))",
  "class BinaryOperator(pybamm.Symbol):\n    \"\"\"A node in the expression tree representing a binary operator (e.g. `+`, `*`)\n\n    Derived classes will specify the particular operator\n\n    **Extends**: :class:`Symbol`\n\n    Parameters\n    ----------\n\n    name : str\n        name of the node\n    left : :class:`Symbol` or :class:`Number`\n        lhs child node (converted to :class:`Scalar` if Number)\n    right : :class:`Symbol` or :class:`Number`\n        rhs child node (converted to :class:`Scalar` if Number)\n\n    \"\"\"\n\n    def __init__(self, name, left, right):\n        assert isinstance(left, (pybamm.Symbol, numbers.Number)) and isinstance(\n            right, (pybamm.Symbol, numbers.Number)\n        ), TypeError(\n            \"\"\"left and right must both be Symbols or Numbers\n                but they are {} and {}\"\"\".format(\n                type(left), type(right)\n            )\n        )\n        # Turn numbers into scalars\n        if isinstance(left, numbers.Number):\n            left = pybamm.Scalar(left)\n        if isinstance(right, numbers.Number):\n            right = pybamm.Scalar(right)\n\n        # Check and process domains, except for Outer symbol which takes the outer\n        # product of two smbols in different domains, and gives it the domain of the\n        # right child.\n        if isinstance(self, (pybamm.Outer, pybamm.Kron)):\n            domain = right.domain\n            auxiliary_domains = {\"secondary\": left.domain}\n        else:\n            domain = self.get_children_domains(left.domain, right.domain)\n            auxiliary_domains = self.get_children_auxiliary_domains([left, right])\n        super().__init__(\n            name,\n            children=[left, right],\n            domain=domain,\n            auxiliary_domains=auxiliary_domains,\n        )\n        self.left = self.children[0]\n        self.right = self.children[1]\n\n    def __str__(self):\n        \"\"\" See :meth:`pybamm.Symbol.__str__()`. \"\"\"\n        return \"{!s} {} {!s}\".format(self.left, self.name, self.right)\n\n    def get_children_domains(self, ldomain, rdomain):\n        \"Combine domains from children in appropriate way\"\n        if ldomain == rdomain:\n            return ldomain\n        elif ldomain == []:\n            return rdomain\n        elif rdomain == []:\n            return ldomain\n        else:\n            raise pybamm.DomainError(\n                \"\"\"\n                children must have same (or empty) domains, but left.domain is '{}'\n                and right.domain is '{}'\n                \"\"\".format(\n                    ldomain, rdomain\n                )\n            )\n\n    def new_copy(self):\n        \"\"\" See :meth:`pybamm.Symbol.new_copy()`. \"\"\"\n\n        # process children\n        new_left = self.left.new_copy()\n        new_right = self.right.new_copy()\n\n        # make new symbol, ensure domain(s) remain the same\n        out = self.__class__(new_left, new_right)\n        out.domain = self.domain\n        out.auxiliary_domains = self.auxiliary_domains\n\n        return out\n\n    def evaluate(self, t=None, y=None, known_evals=None):\n        \"\"\" See :meth:`pybamm.Symbol.evaluate()`. \"\"\"\n        if known_evals is not None:\n            id = self.id\n            try:\n                return known_evals[id], known_evals\n            except KeyError:\n                left, known_evals = self.left.evaluate(t, y, known_evals)\n                right, known_evals = self.right.evaluate(t, y, known_evals)\n                value = self._binary_evaluate(left, right)\n                known_evals[id] = value\n                return value, known_evals\n        else:\n            left = self.left.evaluate(t, y)\n            right = self.right.evaluate(t, y)\n            return self._binary_evaluate(left, right)\n\n    def evaluate_for_shape(self):\n        \"\"\" See :meth:`pybamm.Symbol.evaluate_for_shape()`. \"\"\"\n        left = self.children[0].evaluate_for_shape()\n        right = self.children[1].evaluate_for_shape()\n        return self._binary_evaluate(left, right)\n\n    def _binary_jac(self, left_jac, right_jac):\n        \"\"\" Calculate the jacobian of a binary operator. \"\"\"\n        raise NotImplementedError\n\n    def _binary_simplify(self, left, right):\n        \"\"\" Simplify a binary operator. \"\"\"\n        raise NotImplementedError\n\n    def _binary_evaluate(self, left, right):\n        \"\"\" Perform binary operation on nodes 'left' and 'right'. \"\"\"\n        raise NotImplementedError\n\n    def evaluates_on_edges(self):\n        \"\"\" See :meth:`pybamm.Symbol.evaluates_on_edges()`. \"\"\"\n        return self.left.evaluates_on_edges() or self.right.evaluates_on_edges()",
  "class Power(BinaryOperator):\n    \"\"\"A node in the expression tree representing a `**` power operator\n\n    **Extends:** :class:`BinaryOperator`\n    \"\"\"\n\n    def __init__(self, left, right):\n        \"\"\" See :meth:`pybamm.BinaryOperator.__init__()`. \"\"\"\n        super().__init__(\"**\", left, right)\n\n    def _diff(self, variable):\n        \"\"\" See :meth:`pybamm.Symbol._diff()`. \"\"\"\n        # apply chain rule and power rule\n        base, exponent = self.orphans\n        return base ** (exponent - 1) * (\n            exponent * base.diff(variable)\n            + base * pybamm.log(base) * exponent.diff(variable)\n        )\n\n    def _binary_jac(self, left_jac, right_jac):\n        \"\"\" See :meth:`pybamm.BinaryOperator._binary_jac()`. \"\"\"\n        # apply chain rule and power rule\n        left, right = self.orphans\n        if left.evaluates_to_number() and right.evaluates_to_number():\n            return pybamm.Scalar(0)\n        elif right.evaluates_to_number():\n            return (right * left ** (right - 1)) * left_jac\n        elif left.evaluates_to_number():\n            return (left ** right * pybamm.log(left)) * right_jac\n        else:\n            return (left ** (right - 1)) * (\n                right * left_jac + left * pybamm.log(left) * right_jac\n            )\n\n    def _binary_evaluate(self, left, right):\n        \"\"\" See :meth:`pybamm.BinaryOperator._binary_evaluate()`. \"\"\"\n        return left ** right\n\n    def _binary_simplify(self, left, right):\n        \"\"\" See :meth:`pybamm.BinaryOperator._binary_simplify()`. \"\"\"\n\n        # anything to the power of zero is one\n        if is_scalar_zero(right):\n            return pybamm.Scalar(1)\n\n        # anything to the power of one is itself\n        if is_scalar_zero(left):\n            return left\n\n        return self.__class__(left, right)",
  "class Addition(BinaryOperator):\n    \"\"\"A node in the expression tree representing an addition operator\n\n    **Extends:** :class:`BinaryOperator`\n    \"\"\"\n\n    def __init__(self, left, right):\n        \"\"\" See :meth:`pybamm.BinaryOperator.__init__()`. \"\"\"\n        super().__init__(\"+\", left, right)\n\n    def _diff(self, variable):\n        \"\"\" See :meth:`pybamm.Symbol._diff()`. \"\"\"\n        return self.left.diff(variable) + self.right.diff(variable)\n\n    def _binary_jac(self, left_jac, right_jac):\n        \"\"\" See :meth:`pybamm.BinaryOperator._binary_jac()`. \"\"\"\n        return left_jac + right_jac\n\n    def _binary_evaluate(self, left, right):\n        \"\"\" See :meth:`pybamm.BinaryOperator._binary_evaluate()`. \"\"\"\n        return left + right\n\n    def _binary_simplify(self, left, right):\n        \"\"\"\n        See :meth:`pybamm.BinaryOperator._binary_simplify()`.\n\n        Note\n        ----\n        We check for scalars first, then matrices. This is because\n        (Zero Matrix) + (Zero Scalar)\n        should return (Zero Matrix), not (Zero Scalar).\n        \"\"\"\n\n        # anything added by a scalar zero returns the other child\n        if is_scalar_zero(left):\n            return right\n        if is_scalar_zero(right):\n            return left\n        # Check matrices after checking scalars\n        if is_matrix_zero(left):\n            return right\n        if is_matrix_zero(right):\n            return left\n\n        return pybamm.simplify_addition_subtraction(self.__class__, left, right)",
  "class Subtraction(BinaryOperator):\n    \"\"\"A node in the expression tree representing a subtraction operator\n\n    **Extends:** :class:`BinaryOperator`\n    \"\"\"\n\n    def __init__(self, left, right):\n        \"\"\" See :meth:`pybamm.BinaryOperator.__init__()`. \"\"\"\n\n        super().__init__(\"-\", left, right)\n\n    def _diff(self, variable):\n        \"\"\" See :meth:`pybamm.Symbol._diff()`. \"\"\"\n        return self.left.diff(variable) - self.right.diff(variable)\n\n    def _binary_jac(self, left_jac, right_jac):\n        \"\"\" See :meth:`pybamm.BinaryOperator._binary_jac()`. \"\"\"\n        return left_jac - right_jac\n\n    def _binary_evaluate(self, left, right):\n        \"\"\" See :meth:`pybamm.BinaryOperator._binary_evaluate()`. \"\"\"\n        return left - right\n\n    def _binary_simplify(self, left, right):\n        \"\"\"\n        See :meth:`pybamm.BinaryOperator._binary_simplify()`.\n\n        Note\n        ----\n        We check for scalars first, then matrices. This is because\n        (Zero Matrix) - (Zero Scalar)\n        should return (Zero Matrix), not -(Zero Scalar).\n        \"\"\"\n\n        # anything added by a scalar zero returns the other child\n        if is_scalar_zero(left):\n            return -right\n        if is_scalar_zero(right):\n            return left\n        # Check matrices after checking scalars\n        if is_matrix_zero(left):\n            return -right\n        if is_matrix_zero(right):\n            return left\n\n        return pybamm.simplify_addition_subtraction(self.__class__, left, right)",
  "class Multiplication(BinaryOperator):\n    \"\"\"\n    A node in the expression tree representing a multiplication operator\n    (Hadamard product). Overloads cases where the \"*\" operator would usually return a\n    matrix multiplication (e.g. scipy.sparse.coo.coo_matrix)\n\n    **Extends:** :class:`BinaryOperator`\n    \"\"\"\n\n    def __init__(self, left, right):\n        \"\"\" See :meth:`pybamm.BinaryOperator.__init__()`. \"\"\"\n\n        super().__init__(\"*\", left, right)\n\n    def _diff(self, variable):\n        \"\"\" See :meth:`pybamm.Symbol._diff()`. \"\"\"\n        # apply product rule\n        left, right = self.orphans\n        return left.diff(variable) * right + left * right.diff(variable)\n\n    def _binary_jac(self, left_jac, right_jac):\n        \"\"\" See :meth:`pybamm.BinaryOperator._binary_jac()`. \"\"\"\n        # apply product rule\n        left, right = self.orphans\n        if left.evaluates_to_number() and right.evaluates_to_number():\n            return pybamm.Scalar(0)\n        elif left.evaluates_to_number():\n            return left * right_jac\n        elif right.evaluates_to_number():\n            return right * left_jac\n        else:\n            return right * left_jac + left * right_jac\n\n    def _binary_evaluate(self, left, right):\n        \"\"\" See :meth:`pybamm.BinaryOperator._binary_evaluate()`. \"\"\"\n\n        if issparse(left):\n            return csr_matrix(left.multiply(right))\n        elif issparse(right):\n            # Hadamard product is commutative, so we can switch right and left\n            return csr_matrix(right.multiply(left))\n        else:\n            return left * right\n\n    def _binary_simplify(self, left, right):\n        \"\"\" See :meth:`pybamm.BinaryOperator._binary_simplify()`. \"\"\"\n\n        # simplify multiply by scalar zero, being careful about shape\n        if is_scalar_zero(left):\n            return zeros_of_shape(right.shape_for_testing)\n        if is_scalar_zero(right):\n            return zeros_of_shape(left.shape_for_testing)\n\n        # if one of the children is a zero matrix, we have to be careful about shapes\n        if is_matrix_zero(left) or is_matrix_zero(right):\n            shape = (left * right).shape\n            return zeros_of_shape(shape)\n\n        # anything multiplied by a scalar one returns itself\n        if is_one(left):\n            return right\n        if is_one(right):\n            return left\n\n        return pybamm.simplify_multiplication_division(self.__class__, left, right)",
  "class MatrixMultiplication(BinaryOperator):\n    \"\"\"A node in the expression tree representing a matrix multiplication operator\n\n    **Extends:** :class:`BinaryOperator`\n    \"\"\"\n\n    def __init__(self, left, right):\n        \"\"\" See :meth:`pybamm.BinaryOperator.__init__()`. \"\"\"\n\n        super().__init__(\"@\", left, right)\n\n    def diff(self, variable):\n        \"\"\" See :meth:`pybamm.Symbol.diff()`. \"\"\"\n        # We shouldn't need this\n        raise NotImplementedError(\n            \"diff not implemented for symbol of type 'MatrixMultiplication'\"\n        )\n\n    def _binary_jac(self, left_jac, right_jac):\n        \"\"\" See :meth:`pybamm.BinaryOperator._binary_jac()`. \"\"\"\n        # We only need the case where left is an array and right\n        # is a (slice of a) state vector, e.g. for discretised spatial\n        # operators of the form D @ u (also catch cases of (-D) @ u)\n        left, right = self.orphans\n        if isinstance(left, pybamm.Array) or (\n            isinstance(left, pybamm.Negate) and isinstance(left.child, pybamm.Array)\n        ):\n            left = pybamm.Matrix(csr_matrix(left.evaluate()))\n            return left @ right_jac\n        else:\n            raise NotImplementedError(\n                \"\"\"jac of 'MatrixMultiplication' is only\n             implemented for left of type 'pybamm.Array',\n             not {}\"\"\".format(\n                    left.__class__\n                )\n            )\n\n    def _binary_evaluate(self, left, right):\n        \"\"\" See :meth:`pybamm.BinaryOperator._binary_evaluate()`. \"\"\"\n        return left @ right\n\n    def _binary_simplify(self, left, right):\n        \"\"\" See :meth:`pybamm.BinaryOperator._binary_simplify()`. \"\"\"\n        if is_matrix_zero(left) or is_matrix_zero(right):\n            shape = (left @ right).shape\n            return zeros_of_shape(shape)\n\n        return pybamm.simplify_multiplication_division(self.__class__, left, right)",
  "class Division(BinaryOperator):\n    \"\"\"A node in the expression tree representing a division operator\n\n    **Extends:** :class:`BinaryOperator`\n    \"\"\"\n\n    def __init__(self, left, right):\n        \"\"\" See :meth:`pybamm.BinaryOperator.__init__()`. \"\"\"\n        super().__init__(\"/\", left, right)\n\n    def _diff(self, variable):\n        \"\"\" See :meth:`pybamm.Symbol._diff()`. \"\"\"\n        # apply quotient rule\n        top, bottom = self.orphans\n        return (top.diff(variable) * bottom - top * bottom.diff(variable)) / bottom ** 2\n\n    def _binary_jac(self, left_jac, right_jac):\n        \"\"\" See :meth:`pybamm.BinaryOperator._binary_jac()`. \"\"\"\n        # apply quotient rule\n        left, right = self.orphans\n        if left.evaluates_to_number() and right.evaluates_to_number():\n            return pybamm.Scalar(0)\n        elif left.evaluates_to_number():\n            return -left / right ** 2 * right_jac\n        elif right.evaluates_to_number():\n            return left_jac / right\n        else:\n            return (right * left_jac - left * right_jac) / right ** 2\n\n    def _binary_evaluate(self, left, right):\n        \"\"\" See :meth:`pybamm.BinaryOperator._binary_evaluate()`. \"\"\"\n\n        if issparse(left):\n            return csr_matrix(left.multiply(1 / right))\n        else:\n            if isinstance(right, numbers.Number) and right == 0:\n                return left * np.inf\n            else:\n                return left / right\n\n    def _binary_simplify(self, left, right):\n        \"\"\" See :meth:`pybamm.BinaryOperator._binary_simplify()`. \"\"\"\n\n        # zero divided by zero returns nan scalar\n        if is_scalar_zero(left) and is_scalar_zero(right):\n            return pybamm.Scalar(np.nan)\n\n        # zero divided by anything returns zero (being careful about shape)\n        if is_scalar_zero(left):\n            return zeros_of_shape(right.shape_for_testing)\n\n        # matrix zero divided by anything returns matrix zero (i.e. itself)\n        if is_matrix_zero(left):\n            return left\n\n        # anything divided by zero returns inf\n        if is_scalar_zero(right):\n            if left.shape_for_testing == ():\n                return pybamm.Scalar(np.inf)\n            else:\n                return pybamm.Array(np.inf * np.ones(left.shape_for_testing))\n\n        # anything divided by one is itself\n        if is_one(right):\n            return left\n\n        return pybamm.simplify_multiplication_division(self.__class__, left, right)",
  "class Inner(BinaryOperator):\n    \"\"\"\n    A node in the expression tree which represents the inner (or dot) product. This\n    operator should be used to take the inner product of two mathematical vectors\n    (as opposed to the computational vectors arrived at post-discretisation) of the\n    form v = v_x e_x + v_y e_y + v_z e_z where v_x, v_y, v_z are scalars\n    and e_x, e_y, e_z are x-y-z-directional unit vectors. For v and w mathematical\n    vectors, inner product returns v_x * w_x + v_y * w_y + v_z * w_z. In addition,\n    for some spatial discretisations mathematical vector quantities (such as\n    i = grad(phi) ) are evaluated on a different part of the grid to mathematical\n    scalars (e.g. for finite volume mathematical scalars are evaluated on the nodes but\n    mathematical vectors are evaluated on cell edges). Therefore, inner also transfers\n    the inner product of the vector onto the scalar part of the grid if required\n    by a particular discretisation.\n\n    **Extends:** :class:`BinaryOperator`\n    \"\"\"\n\n    def __init__(self, left, right):\n        \"\"\" See :meth:`pybamm.BinaryOperator.__init__()`. \"\"\"\n        super().__init__(\"inner product\", left, right)\n\n    def _diff(self, variable):\n        \"\"\" See :meth:`pybamm.Symbol._diff()`. \"\"\"\n        # apply product rule\n        left, right = self.orphans\n        return left.diff(variable) * right + left * right.diff(variable)\n\n    def _binary_jac(self, left_jac, right_jac):\n        \"\"\" See :meth:`pybamm.BinaryOperator._binary_jac()`. \"\"\"\n        # apply product rule\n        left, right = self.orphans\n        if left.evaluates_to_number() and right.evaluates_to_number():\n            return pybamm.Scalar(0)\n        elif left.evaluates_to_number():\n            return left * right_jac\n        elif right.evaluates_to_number():\n            return right * left_jac\n        else:\n            return right * left_jac + left * right_jac\n\n    def _binary_evaluate(self, left, right):\n        \"\"\" See :meth:`pybamm.BinaryOperator._binary_evaluate()`. \"\"\"\n\n        if issparse(left):\n            return left.multiply(right)\n        elif issparse(right):\n            # Hadamard product is commutative, so we can switch right and left\n            return right.multiply(left)\n        else:\n            return left * right\n\n    def _binary_simplify(self, left, right):\n        \"\"\" See :meth:`pybamm.BinaryOperator._binary_simplify()`. \"\"\"\n\n        # simplify multiply by scalar zero, being careful about shape\n        if is_scalar_zero(left):\n            return zeros_of_shape(right.shape_for_testing)\n        if is_scalar_zero(right):\n            return zeros_of_shape(left.shape_for_testing)\n\n        # if one of the children is a zero matrix, we have to be careful about shapes\n        if is_matrix_zero(left) or is_matrix_zero(right):\n            shape = (left * right).shape\n            return zeros_of_shape(shape)\n\n        # anything multiplied by a scalar one returns itself\n        if is_one(left):\n            return right\n        if is_one(right):\n            return left\n\n        return pybamm.simplify_multiplication_division(self.__class__, left, right)\n\n    def evaluates_on_edges(self):\n        \"\"\" See :meth:`pybamm.Symbol.evaluates_on_edges()`. \"\"\"\n        return False",
  "def inner(left, right):\n    \"\"\"\n    Return inner product of two symbols.\n    \"\"\"\n    return pybamm.Inner(left, right)",
  "class Outer(BinaryOperator):\n    \"\"\"A node in the expression tree representing an outer product.\n    This takes a 1D vector in the current collector domain of size (n,1) and a 1D\n    variable of size (m,1), takes their outer product, and reshapes this into a vector\n    of size (nm,1). It can also take in a vector in a single particle and a vector\n    of the electrolyte domain to repeat that particle.\n    Note: this class might be a bit dangerous, so at the moment it is very restrictive\n    in what symbols can be passed to it\n\n    **Extends:** :class:`BinaryOperator`\n    \"\"\"\n\n    def __init__(self, left, right):\n        \"\"\" See :meth:`pybamm.BinaryOperator.__init__()`. \"\"\"\n        # cannot have Variable, StateVector or Matrix in the right symbol, as these\n        # can already be 2D objects (so we can't take an outer product with them)\n        if right.has_symbol_of_classes(\n            (pybamm.Variable, pybamm.StateVector, pybamm.Matrix)\n        ):\n            raise TypeError(\n                \"right child must only contain SpatialVariable and scalars\" \"\"\n            )\n\n        super().__init__(\"outer product\", left, right)\n\n    def __str__(self):\n        \"\"\" See :meth:`pybamm.Symbol.__str__()`. \"\"\"\n        return \"outer({!s}, {!s})\".format(self.left, self.right)\n\n    def diff(self, variable):\n        \"\"\" See :meth:`pybamm.Symbol.diff()`. \"\"\"\n        raise NotImplementedError(\"diff not implemented for symbol of type 'Outer'\")\n\n    def _outer_jac(self, left_jac, right_jac, variable):\n        \"\"\"\n        Calculate jacobian of outer product.\n        See :meth:`pybamm.Jacobian._jac()`.\n        \"\"\"\n        # right cannot be a StateVector, so no need for product rule\n        left, right = self.orphans\n        if left.evaluates_to_number():\n            # Return zeros of correct size\n            return pybamm.Matrix(\n                csr_matrix((self.size, variable.evaluation_array.count(True)))\n            )\n        else:\n            return pybamm.Kron(left_jac, right)\n\n    def _binary_evaluate(self, left, right):\n        \"\"\" See :meth:`pybamm.BinaryOperator._binary_evaluate()`. \"\"\"\n\n        return np.outer(left, right).reshape(-1, 1)\n\n    def _binary_simplify(self, left, right):\n        \"\"\" See :meth:`pybamm.BinaryOperator._binary_simplify()`. \"\"\"\n        return pybamm.Outer(left, right)",
  "class Kron(BinaryOperator):\n    \"\"\"A node in the expression tree representing a (sparse) kronecker product operator\n\n    **Extends:** :class:`BinaryOperator`\n    \"\"\"\n\n    def __init__(self, left, right):\n        \"\"\" See :meth:`pybamm.BinaryOperator.__init__()`. \"\"\"\n\n        super().__init__(\"kronecker product\", left, right)\n\n    def __str__(self):\n        \"\"\" See :meth:`pybamm.Symbol.__str__()`. \"\"\"\n        return \"kron({!s}, {!s})\".format(self.left, self.right)\n\n    def diff(self, variable):\n        \"\"\" See :meth:`pybamm.Symbol.diff()`. \"\"\"\n        raise NotImplementedError(\"diff not implemented for symbol of type 'Kron'\")\n\n    def _binary_jac(self, left_jac, right_jac):\n        \"\"\" See :meth:`pybamm.BinaryOperator._binary_jac()`. \"\"\"\n        raise NotImplementedError(\"jac not implemented for symbol of type 'Kron'\")\n\n    def _binary_evaluate(self, left, right):\n        \"\"\" See :meth:`pybamm.BinaryOperator._binary_evaluate()`. \"\"\"\n        return csr_matrix(kron(left, right))\n\n    def _binary_simplify(self, left, right):\n        \"\"\" See :meth:`pybamm.BinaryOperator._binary_simplify()`. \"\"\"\n        return pybamm.Kron(left, right)",
  "def outer(left, right):\n    \"\"\"\n    Return outer product of two symbols. If the symbols have the same domain, the outer\n    product is just a multiplication. If they have different domains, make a copy of the\n    left child with same domain as right child, and then take outer product.\n    \"\"\"\n    try:\n        return left * right\n    except pybamm.DomainError:\n        return pybamm.Outer(left, right)",
  "def source(left, right, boundary=False):\n    \"\"\"A convinience function for creating (part of) an expression tree representing\n    a source term. This is necessary for spatial methods where the mass matrix\n    is not the identity (e.g. finite element formulation with piecwise linear\n    basis functions). The left child is the symbol representing the source term\n    and the right child is the symbol of the equation variable (currently, the\n    finite element formulation in PyBaMM assumes all functions are constructed\n    using the same basis, and the matrix here is constructed accoutning for the\n    boundary conditions of the right child). The method returns the matrix-vector\n    product of the mass matrix (adjusted to account for any Dirichlet boundary\n    conditions imposed the the right symbol) and the discretised left symbol.\n\n    Parameters\n    ----------\n\n    left : :class:`Symbol`\n        The left child node, which represents the expression for the source term.\n    right : :class:`Symbol`\n        The right child node. This is the symbol whose boundary conditions are\n        accounted for in the construction of the mass matrix.\n    boundary : bool, optional\n        If True, then the mass matrix should is assembled over the boundary,\n        corresponding to a source term which only acts on the boundary of the\n        domain. If False (default), the matrix is assembled over the entire domain,\n        corresponding to a source term in the bulk.\n\n    \"\"\"\n    # Broadcast if left is number\n    if isinstance(left, numbers.Number):\n        left = pybamm.Broadcast(left, \"current collector\")\n\n    if left.domain != [\"current collector\"] or right.domain != [\"current collector\"]:\n        raise pybamm.DomainError(\n            \"\"\"'source' only implemented in the 'current collector' domain,\n            but symbols have domains {} and {}\"\"\".format(\n                left.domain, right.domain\n            )\n        )\n    if boundary:\n        return pybamm.BoundaryMass(right) @ left\n    else:\n        return pybamm.Mass(right) @ left",
  "def __init__(self, name, left, right):\n        assert isinstance(left, (pybamm.Symbol, numbers.Number)) and isinstance(\n            right, (pybamm.Symbol, numbers.Number)\n        ), TypeError(\n            \"\"\"left and right must both be Symbols or Numbers\n                but they are {} and {}\"\"\".format(\n                type(left), type(right)\n            )\n        )\n        # Turn numbers into scalars\n        if isinstance(left, numbers.Number):\n            left = pybamm.Scalar(left)\n        if isinstance(right, numbers.Number):\n            right = pybamm.Scalar(right)\n\n        # Check and process domains, except for Outer symbol which takes the outer\n        # product of two smbols in different domains, and gives it the domain of the\n        # right child.\n        if isinstance(self, (pybamm.Outer, pybamm.Kron)):\n            domain = right.domain\n            auxiliary_domains = {\"secondary\": left.domain}\n        else:\n            domain = self.get_children_domains(left.domain, right.domain)\n            auxiliary_domains = self.get_children_auxiliary_domains([left, right])\n        super().__init__(\n            name,\n            children=[left, right],\n            domain=domain,\n            auxiliary_domains=auxiliary_domains,\n        )\n        self.left = self.children[0]\n        self.right = self.children[1]",
  "def __str__(self):\n        \"\"\" See :meth:`pybamm.Symbol.__str__()`. \"\"\"\n        return \"{!s} {} {!s}\".format(self.left, self.name, self.right)",
  "def get_children_domains(self, ldomain, rdomain):\n        \"Combine domains from children in appropriate way\"\n        if ldomain == rdomain:\n            return ldomain\n        elif ldomain == []:\n            return rdomain\n        elif rdomain == []:\n            return ldomain\n        else:\n            raise pybamm.DomainError(\n                \"\"\"\n                children must have same (or empty) domains, but left.domain is '{}'\n                and right.domain is '{}'\n                \"\"\".format(\n                    ldomain, rdomain\n                )\n            )",
  "def new_copy(self):\n        \"\"\" See :meth:`pybamm.Symbol.new_copy()`. \"\"\"\n\n        # process children\n        new_left = self.left.new_copy()\n        new_right = self.right.new_copy()\n\n        # make new symbol, ensure domain(s) remain the same\n        out = self.__class__(new_left, new_right)\n        out.domain = self.domain\n        out.auxiliary_domains = self.auxiliary_domains\n\n        return out",
  "def evaluate(self, t=None, y=None, known_evals=None):\n        \"\"\" See :meth:`pybamm.Symbol.evaluate()`. \"\"\"\n        if known_evals is not None:\n            id = self.id\n            try:\n                return known_evals[id], known_evals\n            except KeyError:\n                left, known_evals = self.left.evaluate(t, y, known_evals)\n                right, known_evals = self.right.evaluate(t, y, known_evals)\n                value = self._binary_evaluate(left, right)\n                known_evals[id] = value\n                return value, known_evals\n        else:\n            left = self.left.evaluate(t, y)\n            right = self.right.evaluate(t, y)\n            return self._binary_evaluate(left, right)",
  "def evaluate_for_shape(self):\n        \"\"\" See :meth:`pybamm.Symbol.evaluate_for_shape()`. \"\"\"\n        left = self.children[0].evaluate_for_shape()\n        right = self.children[1].evaluate_for_shape()\n        return self._binary_evaluate(left, right)",
  "def _binary_jac(self, left_jac, right_jac):\n        \"\"\" Calculate the jacobian of a binary operator. \"\"\"\n        raise NotImplementedError",
  "def _binary_simplify(self, left, right):\n        \"\"\" Simplify a binary operator. \"\"\"\n        raise NotImplementedError",
  "def _binary_evaluate(self, left, right):\n        \"\"\" Perform binary operation on nodes 'left' and 'right'. \"\"\"\n        raise NotImplementedError",
  "def evaluates_on_edges(self):\n        \"\"\" See :meth:`pybamm.Symbol.evaluates_on_edges()`. \"\"\"\n        return self.left.evaluates_on_edges() or self.right.evaluates_on_edges()",
  "def __init__(self, left, right):\n        \"\"\" See :meth:`pybamm.BinaryOperator.__init__()`. \"\"\"\n        super().__init__(\"**\", left, right)",
  "def _diff(self, variable):\n        \"\"\" See :meth:`pybamm.Symbol._diff()`. \"\"\"\n        # apply chain rule and power rule\n        base, exponent = self.orphans\n        return base ** (exponent - 1) * (\n            exponent * base.diff(variable)\n            + base * pybamm.log(base) * exponent.diff(variable)\n        )",
  "def _binary_jac(self, left_jac, right_jac):\n        \"\"\" See :meth:`pybamm.BinaryOperator._binary_jac()`. \"\"\"\n        # apply chain rule and power rule\n        left, right = self.orphans\n        if left.evaluates_to_number() and right.evaluates_to_number():\n            return pybamm.Scalar(0)\n        elif right.evaluates_to_number():\n            return (right * left ** (right - 1)) * left_jac\n        elif left.evaluates_to_number():\n            return (left ** right * pybamm.log(left)) * right_jac\n        else:\n            return (left ** (right - 1)) * (\n                right * left_jac + left * pybamm.log(left) * right_jac\n            )",
  "def _binary_evaluate(self, left, right):\n        \"\"\" See :meth:`pybamm.BinaryOperator._binary_evaluate()`. \"\"\"\n        return left ** right",
  "def _binary_simplify(self, left, right):\n        \"\"\" See :meth:`pybamm.BinaryOperator._binary_simplify()`. \"\"\"\n\n        # anything to the power of zero is one\n        if is_scalar_zero(right):\n            return pybamm.Scalar(1)\n\n        # anything to the power of one is itself\n        if is_scalar_zero(left):\n            return left\n\n        return self.__class__(left, right)",
  "def __init__(self, left, right):\n        \"\"\" See :meth:`pybamm.BinaryOperator.__init__()`. \"\"\"\n        super().__init__(\"+\", left, right)",
  "def _diff(self, variable):\n        \"\"\" See :meth:`pybamm.Symbol._diff()`. \"\"\"\n        return self.left.diff(variable) + self.right.diff(variable)",
  "def _binary_jac(self, left_jac, right_jac):\n        \"\"\" See :meth:`pybamm.BinaryOperator._binary_jac()`. \"\"\"\n        return left_jac + right_jac",
  "def _binary_evaluate(self, left, right):\n        \"\"\" See :meth:`pybamm.BinaryOperator._binary_evaluate()`. \"\"\"\n        return left + right",
  "def _binary_simplify(self, left, right):\n        \"\"\"\n        See :meth:`pybamm.BinaryOperator._binary_simplify()`.\n\n        Note\n        ----\n        We check for scalars first, then matrices. This is because\n        (Zero Matrix) + (Zero Scalar)\n        should return (Zero Matrix), not (Zero Scalar).\n        \"\"\"\n\n        # anything added by a scalar zero returns the other child\n        if is_scalar_zero(left):\n            return right\n        if is_scalar_zero(right):\n            return left\n        # Check matrices after checking scalars\n        if is_matrix_zero(left):\n            return right\n        if is_matrix_zero(right):\n            return left\n\n        return pybamm.simplify_addition_subtraction(self.__class__, left, right)",
  "def __init__(self, left, right):\n        \"\"\" See :meth:`pybamm.BinaryOperator.__init__()`. \"\"\"\n\n        super().__init__(\"-\", left, right)",
  "def _diff(self, variable):\n        \"\"\" See :meth:`pybamm.Symbol._diff()`. \"\"\"\n        return self.left.diff(variable) - self.right.diff(variable)",
  "def _binary_jac(self, left_jac, right_jac):\n        \"\"\" See :meth:`pybamm.BinaryOperator._binary_jac()`. \"\"\"\n        return left_jac - right_jac",
  "def _binary_evaluate(self, left, right):\n        \"\"\" See :meth:`pybamm.BinaryOperator._binary_evaluate()`. \"\"\"\n        return left - right",
  "def _binary_simplify(self, left, right):\n        \"\"\"\n        See :meth:`pybamm.BinaryOperator._binary_simplify()`.\n\n        Note\n        ----\n        We check for scalars first, then matrices. This is because\n        (Zero Matrix) - (Zero Scalar)\n        should return (Zero Matrix), not -(Zero Scalar).\n        \"\"\"\n\n        # anything added by a scalar zero returns the other child\n        if is_scalar_zero(left):\n            return -right\n        if is_scalar_zero(right):\n            return left\n        # Check matrices after checking scalars\n        if is_matrix_zero(left):\n            return -right\n        if is_matrix_zero(right):\n            return left\n\n        return pybamm.simplify_addition_subtraction(self.__class__, left, right)",
  "def __init__(self, left, right):\n        \"\"\" See :meth:`pybamm.BinaryOperator.__init__()`. \"\"\"\n\n        super().__init__(\"*\", left, right)",
  "def _diff(self, variable):\n        \"\"\" See :meth:`pybamm.Symbol._diff()`. \"\"\"\n        # apply product rule\n        left, right = self.orphans\n        return left.diff(variable) * right + left * right.diff(variable)",
  "def _binary_jac(self, left_jac, right_jac):\n        \"\"\" See :meth:`pybamm.BinaryOperator._binary_jac()`. \"\"\"\n        # apply product rule\n        left, right = self.orphans\n        if left.evaluates_to_number() and right.evaluates_to_number():\n            return pybamm.Scalar(0)\n        elif left.evaluates_to_number():\n            return left * right_jac\n        elif right.evaluates_to_number():\n            return right * left_jac\n        else:\n            return right * left_jac + left * right_jac",
  "def _binary_evaluate(self, left, right):\n        \"\"\" See :meth:`pybamm.BinaryOperator._binary_evaluate()`. \"\"\"\n\n        if issparse(left):\n            return csr_matrix(left.multiply(right))\n        elif issparse(right):\n            # Hadamard product is commutative, so we can switch right and left\n            return csr_matrix(right.multiply(left))\n        else:\n            return left * right",
  "def _binary_simplify(self, left, right):\n        \"\"\" See :meth:`pybamm.BinaryOperator._binary_simplify()`. \"\"\"\n\n        # simplify multiply by scalar zero, being careful about shape\n        if is_scalar_zero(left):\n            return zeros_of_shape(right.shape_for_testing)\n        if is_scalar_zero(right):\n            return zeros_of_shape(left.shape_for_testing)\n\n        # if one of the children is a zero matrix, we have to be careful about shapes\n        if is_matrix_zero(left) or is_matrix_zero(right):\n            shape = (left * right).shape\n            return zeros_of_shape(shape)\n\n        # anything multiplied by a scalar one returns itself\n        if is_one(left):\n            return right\n        if is_one(right):\n            return left\n\n        return pybamm.simplify_multiplication_division(self.__class__, left, right)",
  "def __init__(self, left, right):\n        \"\"\" See :meth:`pybamm.BinaryOperator.__init__()`. \"\"\"\n\n        super().__init__(\"@\", left, right)",
  "def diff(self, variable):\n        \"\"\" See :meth:`pybamm.Symbol.diff()`. \"\"\"\n        # We shouldn't need this\n        raise NotImplementedError(\n            \"diff not implemented for symbol of type 'MatrixMultiplication'\"\n        )",
  "def _binary_jac(self, left_jac, right_jac):\n        \"\"\" See :meth:`pybamm.BinaryOperator._binary_jac()`. \"\"\"\n        # We only need the case where left is an array and right\n        # is a (slice of a) state vector, e.g. for discretised spatial\n        # operators of the form D @ u (also catch cases of (-D) @ u)\n        left, right = self.orphans\n        if isinstance(left, pybamm.Array) or (\n            isinstance(left, pybamm.Negate) and isinstance(left.child, pybamm.Array)\n        ):\n            left = pybamm.Matrix(csr_matrix(left.evaluate()))\n            return left @ right_jac\n        else:\n            raise NotImplementedError(\n                \"\"\"jac of 'MatrixMultiplication' is only\n             implemented for left of type 'pybamm.Array',\n             not {}\"\"\".format(\n                    left.__class__\n                )\n            )",
  "def _binary_evaluate(self, left, right):\n        \"\"\" See :meth:`pybamm.BinaryOperator._binary_evaluate()`. \"\"\"\n        return left @ right",
  "def _binary_simplify(self, left, right):\n        \"\"\" See :meth:`pybamm.BinaryOperator._binary_simplify()`. \"\"\"\n        if is_matrix_zero(left) or is_matrix_zero(right):\n            shape = (left @ right).shape\n            return zeros_of_shape(shape)\n\n        return pybamm.simplify_multiplication_division(self.__class__, left, right)",
  "def __init__(self, left, right):\n        \"\"\" See :meth:`pybamm.BinaryOperator.__init__()`. \"\"\"\n        super().__init__(\"/\", left, right)",
  "def _diff(self, variable):\n        \"\"\" See :meth:`pybamm.Symbol._diff()`. \"\"\"\n        # apply quotient rule\n        top, bottom = self.orphans\n        return (top.diff(variable) * bottom - top * bottom.diff(variable)) / bottom ** 2",
  "def _binary_jac(self, left_jac, right_jac):\n        \"\"\" See :meth:`pybamm.BinaryOperator._binary_jac()`. \"\"\"\n        # apply quotient rule\n        left, right = self.orphans\n        if left.evaluates_to_number() and right.evaluates_to_number():\n            return pybamm.Scalar(0)\n        elif left.evaluates_to_number():\n            return -left / right ** 2 * right_jac\n        elif right.evaluates_to_number():\n            return left_jac / right\n        else:\n            return (right * left_jac - left * right_jac) / right ** 2",
  "def _binary_evaluate(self, left, right):\n        \"\"\" See :meth:`pybamm.BinaryOperator._binary_evaluate()`. \"\"\"\n\n        if issparse(left):\n            return csr_matrix(left.multiply(1 / right))\n        else:\n            if isinstance(right, numbers.Number) and right == 0:\n                return left * np.inf\n            else:\n                return left / right",
  "def _binary_simplify(self, left, right):\n        \"\"\" See :meth:`pybamm.BinaryOperator._binary_simplify()`. \"\"\"\n\n        # zero divided by zero returns nan scalar\n        if is_scalar_zero(left) and is_scalar_zero(right):\n            return pybamm.Scalar(np.nan)\n\n        # zero divided by anything returns zero (being careful about shape)\n        if is_scalar_zero(left):\n            return zeros_of_shape(right.shape_for_testing)\n\n        # matrix zero divided by anything returns matrix zero (i.e. itself)\n        if is_matrix_zero(left):\n            return left\n\n        # anything divided by zero returns inf\n        if is_scalar_zero(right):\n            if left.shape_for_testing == ():\n                return pybamm.Scalar(np.inf)\n            else:\n                return pybamm.Array(np.inf * np.ones(left.shape_for_testing))\n\n        # anything divided by one is itself\n        if is_one(right):\n            return left\n\n        return pybamm.simplify_multiplication_division(self.__class__, left, right)",
  "def __init__(self, left, right):\n        \"\"\" See :meth:`pybamm.BinaryOperator.__init__()`. \"\"\"\n        super().__init__(\"inner product\", left, right)",
  "def _diff(self, variable):\n        \"\"\" See :meth:`pybamm.Symbol._diff()`. \"\"\"\n        # apply product rule\n        left, right = self.orphans\n        return left.diff(variable) * right + left * right.diff(variable)",
  "def _binary_jac(self, left_jac, right_jac):\n        \"\"\" See :meth:`pybamm.BinaryOperator._binary_jac()`. \"\"\"\n        # apply product rule\n        left, right = self.orphans\n        if left.evaluates_to_number() and right.evaluates_to_number():\n            return pybamm.Scalar(0)\n        elif left.evaluates_to_number():\n            return left * right_jac\n        elif right.evaluates_to_number():\n            return right * left_jac\n        else:\n            return right * left_jac + left * right_jac",
  "def _binary_evaluate(self, left, right):\n        \"\"\" See :meth:`pybamm.BinaryOperator._binary_evaluate()`. \"\"\"\n\n        if issparse(left):\n            return left.multiply(right)\n        elif issparse(right):\n            # Hadamard product is commutative, so we can switch right and left\n            return right.multiply(left)\n        else:\n            return left * right",
  "def _binary_simplify(self, left, right):\n        \"\"\" See :meth:`pybamm.BinaryOperator._binary_simplify()`. \"\"\"\n\n        # simplify multiply by scalar zero, being careful about shape\n        if is_scalar_zero(left):\n            return zeros_of_shape(right.shape_for_testing)\n        if is_scalar_zero(right):\n            return zeros_of_shape(left.shape_for_testing)\n\n        # if one of the children is a zero matrix, we have to be careful about shapes\n        if is_matrix_zero(left) or is_matrix_zero(right):\n            shape = (left * right).shape\n            return zeros_of_shape(shape)\n\n        # anything multiplied by a scalar one returns itself\n        if is_one(left):\n            return right\n        if is_one(right):\n            return left\n\n        return pybamm.simplify_multiplication_division(self.__class__, left, right)",
  "def evaluates_on_edges(self):\n        \"\"\" See :meth:`pybamm.Symbol.evaluates_on_edges()`. \"\"\"\n        return False",
  "def __init__(self, left, right):\n        \"\"\" See :meth:`pybamm.BinaryOperator.__init__()`. \"\"\"\n        # cannot have Variable, StateVector or Matrix in the right symbol, as these\n        # can already be 2D objects (so we can't take an outer product with them)\n        if right.has_symbol_of_classes(\n            (pybamm.Variable, pybamm.StateVector, pybamm.Matrix)\n        ):\n            raise TypeError(\n                \"right child must only contain SpatialVariable and scalars\" \"\"\n            )\n\n        super().__init__(\"outer product\", left, right)",
  "def __str__(self):\n        \"\"\" See :meth:`pybamm.Symbol.__str__()`. \"\"\"\n        return \"outer({!s}, {!s})\".format(self.left, self.right)",
  "def diff(self, variable):\n        \"\"\" See :meth:`pybamm.Symbol.diff()`. \"\"\"\n        raise NotImplementedError(\"diff not implemented for symbol of type 'Outer'\")",
  "def _outer_jac(self, left_jac, right_jac, variable):\n        \"\"\"\n        Calculate jacobian of outer product.\n        See :meth:`pybamm.Jacobian._jac()`.\n        \"\"\"\n        # right cannot be a StateVector, so no need for product rule\n        left, right = self.orphans\n        if left.evaluates_to_number():\n            # Return zeros of correct size\n            return pybamm.Matrix(\n                csr_matrix((self.size, variable.evaluation_array.count(True)))\n            )\n        else:\n            return pybamm.Kron(left_jac, right)",
  "def _binary_evaluate(self, left, right):\n        \"\"\" See :meth:`pybamm.BinaryOperator._binary_evaluate()`. \"\"\"\n\n        return np.outer(left, right).reshape(-1, 1)",
  "def _binary_simplify(self, left, right):\n        \"\"\" See :meth:`pybamm.BinaryOperator._binary_simplify()`. \"\"\"\n        return pybamm.Outer(left, right)",
  "def __init__(self, left, right):\n        \"\"\" See :meth:`pybamm.BinaryOperator.__init__()`. \"\"\"\n\n        super().__init__(\"kronecker product\", left, right)",
  "def __str__(self):\n        \"\"\" See :meth:`pybamm.Symbol.__str__()`. \"\"\"\n        return \"kron({!s}, {!s})\".format(self.left, self.right)",
  "def diff(self, variable):\n        \"\"\" See :meth:`pybamm.Symbol.diff()`. \"\"\"\n        raise NotImplementedError(\"diff not implemented for symbol of type 'Kron'\")",
  "def _binary_jac(self, left_jac, right_jac):\n        \"\"\" See :meth:`pybamm.BinaryOperator._binary_jac()`. \"\"\"\n        raise NotImplementedError(\"jac not implemented for symbol of type 'Kron'\")",
  "def _binary_evaluate(self, left, right):\n        \"\"\" See :meth:`pybamm.BinaryOperator._binary_evaluate()`. \"\"\"\n        return csr_matrix(kron(left, right))",
  "def _binary_simplify(self, left, right):\n        \"\"\" See :meth:`pybamm.BinaryOperator._binary_simplify()`. \"\"\"\n        return pybamm.Kron(left, right)",
  "class Scalar(pybamm.Symbol):\n    \"\"\"A node in the expression tree representing a scalar value\n\n    **Extends:** :class:`Symbol`\n\n    Parameters\n    ----------\n\n    value : numeric\n        the value returned by the node when evaluated\n    name : str, optional\n        the name of the node. Defaulted to ``str(value)``\n        if not provided\n    domain : iterable of str, optional\n        list of domains the parameter is valid over, defaults to empty list\n\n    \"\"\"\n\n    def __init__(self, value, name=None, domain=[]):\n        \"\"\"\n\n        \"\"\"\n        # set default name if not provided\n        self.value = value\n        if name is None:\n            name = str(self.value)\n\n        super().__init__(name, domain=domain)\n\n    @property\n    def value(self):\n        \"\"\"the value returned by the node when evaluated\"\"\"\n        return self._value\n\n    @value.setter\n    def value(self, value):\n        self._value = float(value)\n\n    def set_id(self):\n        \"\"\" See :meth:`pybamm.Symbol.set_id()`. \"\"\"\n        # We must include the value in the hash, since different scalars can be\n        # indistinguishable by class, name and domain alone\n        self._id = hash(\n            (self.__class__, self.name) + tuple(self.domain) + tuple(str(self._value))\n        )\n\n    def _base_evaluate(self, t=None, y=None):\n        \"\"\" See :meth:`pybamm.Symbol._base_evaluate()`. \"\"\"\n        return self._value\n\n    def _jac(self, variable):\n        \"\"\" See :meth:`pybamm.Symbol._jac()`. \"\"\"\n        return pybamm.Scalar(0)\n\n    def new_copy(self):\n        \"\"\" See :meth:`pybamm.Symbol.new_copy()`. \"\"\"\n        return Scalar(self.value, self.name, self.domain)",
  "def __init__(self, value, name=None, domain=[]):\n        \"\"\"\n\n        \"\"\"\n        # set default name if not provided\n        self.value = value\n        if name is None:\n            name = str(self.value)\n\n        super().__init__(name, domain=domain)",
  "def value(self):\n        \"\"\"the value returned by the node when evaluated\"\"\"\n        return self._value",
  "def value(self, value):\n        self._value = float(value)",
  "def set_id(self):\n        \"\"\" See :meth:`pybamm.Symbol.set_id()`. \"\"\"\n        # We must include the value in the hash, since different scalars can be\n        # indistinguishable by class, name and domain alone\n        self._id = hash(\n            (self.__class__, self.name) + tuple(self.domain) + tuple(str(self._value))\n        )",
  "def _base_evaluate(self, t=None, y=None):\n        \"\"\" See :meth:`pybamm.Symbol._base_evaluate()`. \"\"\"\n        return self._value",
  "def _jac(self, variable):\n        \"\"\" See :meth:`pybamm.Symbol._jac()`. \"\"\"\n        return pybamm.Scalar(0)",
  "def new_copy(self):\n        \"\"\" See :meth:`pybamm.Symbol.new_copy()`. \"\"\"\n        return Scalar(self.value, self.name, self.domain)",
  "def id_to_python_variable(symbol_id, constant=False):\n    \"\"\"\n    This function defines the format for the python variable names used in find_symbols\n    and to_python. Variable names are based on a nodes' id to make them unique\n    \"\"\"\n\n    if constant:\n        var_format = \"self.const_{:05d}\"\n    else:\n        var_format = \"self.var_{:05d}\"\n\n    # Need to replace \"-\" character to make them valid python variable names\n    return var_format.format(symbol_id).replace(\"-\", \"m\")",
  "def find_symbols(symbol, constant_symbols, variable_symbols):\n    \"\"\"\n    This function converts an expression tree to a dictionary of node id's and strings\n    specifying valid python code to calculate that nodes value, given y and t.\n\n    The function distinguishes between nodes that represent constant nodes in the tree\n    (e.g. a pybamm.Matrix), and those that are variable (e.g. subtrees that contain\n    pybamm.StateVector). The former are put in `constant_symbols`, the latter in\n    `variable_symbols`\n\n    Note that it is important that the arguments `constant_symbols` and\n    `variable_symbols` be and *ordered* dict, since the final ordering of the code lines\n    are important for the calculations. A dict is specified rather than a list so that\n    identical subtrees (which give identical id's) are not recalculated in the code\n\n    Parameters\n    ----------\n    symbol : :class:`pybamm.Symbol`\n        The symbol or expression tree to convert\n\n    constant_symbol: collections.OrderedDict\n        The output dictionary of constant symbol ids to lines of code\n\n    variable_symbol: collections.OrderedDict\n        The output dictionary of variable (with y or t) symbol ids to lines of code\n\n    \"\"\"\n    if symbol.is_constant():\n        constant_symbols[symbol.id] = symbol.evaluate()\n        return\n\n    # process children recursively\n    for child in symbol.children:\n        find_symbols(child, constant_symbols, variable_symbols)\n\n    # calculate the variable names that will hold the result of calculating the\n    # children variables\n    children_vars = [\n        id_to_python_variable(child.id, child.is_constant())\n        for child in symbol.children\n    ]\n\n    if isinstance(symbol, pybamm.BinaryOperator):\n        # Multiplication and Division need special handling for scipy sparse matrices\n        # TODO: we can pass through a dummy y and t to get the type and then hardcode\n        # the right line, avoiding these checks\n        if isinstance(symbol, pybamm.Multiplication):\n            symbol_str = (\n                \"scipy.sparse.csr_matrix({0}.multiply({1})) \"\n                \"if scipy.sparse.issparse({0}) else \"\n                \"scipy.sparse.csr_matrix({1}.multiply({0})) \"\n                \"if scipy.sparse.issparse({1}) else \"\n                \"{0} * {1}\".format(children_vars[0], children_vars[1])\n            )\n        elif isinstance(symbol, pybamm.Division):\n            symbol_str = (\n                \"scipy.sparse.csr_matrix({0}.multiply(1/{1})) \"\n                \"if scipy.sparse.issparse({0}) else \"\n                \"{0} / {1}\".format(children_vars[0], children_vars[1])\n            )\n        elif isinstance(symbol, pybamm.Inner):\n            symbol_str = (\n                \"{0}.multiply({1}) \"\n                \"if scipy.sparse.issparse({0}) else \"\n                \"{1}.multiply({0}) \"\n                \"if scipy.sparse.issparse({1}) else \"\n                \"{0} * {1}\".format(children_vars[0], children_vars[1])\n            )\n        elif isinstance(symbol, pybamm.Outer):\n            symbol_str = \"np.outer({}, {}).reshape(-1, 1)\".format(\n                children_vars[0], children_vars[1]\n            )\n        elif isinstance(symbol, pybamm.Kron):\n            symbol_str = \"scipy.sparse.csr_matrix(scipy.sparse.kron({}, {}))\".format(\n                children_vars[0], children_vars[1]\n            )\n        else:\n            symbol_str = children_vars[0] + \" \" + symbol.name + \" \" + children_vars[1]\n\n    elif isinstance(symbol, pybamm.UnaryOperator):\n        # Index has a different syntax than other univariate operations\n        if isinstance(symbol, pybamm.Index):\n            symbol_str = \"{}[{}:{}]\".format(\n                children_vars[0], symbol.slice.start, symbol.slice.stop\n            )\n        else:\n            symbol_str = symbol.name + children_vars[0]\n\n    # For a Function we create two lines of code, one in constant_symbols that\n    # contains the function handle, the other in variable_symbols that calls that\n    # function on the children variables\n    elif isinstance(symbol, pybamm.Function):\n        constant_symbols[symbol.id] = symbol.function\n        funct_var = id_to_python_variable(symbol.id, True)\n        children_str = \"\"\n        for child_var in children_vars:\n            if children_str == \"\":\n                children_str = child_var\n            else:\n                children_str += \", \" + child_var\n        symbol_str = \"{}({})\".format(funct_var, children_str)\n\n    elif isinstance(symbol, pybamm.Concatenation):\n\n        # don't bother to concatenate if there is only a single child\n        if isinstance(symbol, pybamm.NumpyConcatenation):\n            if len(children_vars) > 1:\n                symbol_str = \"np.concatenate(({}))\".format(\",\".join(children_vars))\n            else:\n                symbol_str = \"{}\".format(\",\".join(children_vars))\n\n        elif isinstance(symbol, pybamm.SparseStack):\n            if len(children_vars) > 1:\n                symbol_str = \"scipy.sparse.vstack(({}))\".format(\",\".join(children_vars))\n            else:\n                symbol_str = \"{}\".format(\",\".join(children_vars))\n\n        # DomainConcatenation specifies a particular ordering for the concatenation,\n        # which we must follow\n        elif isinstance(symbol, pybamm.DomainConcatenation):\n            slice_starts = []\n            all_child_vectors = []\n            for i in range(symbol.secondary_dimensions_npts):\n                child_vectors = []\n                for child_var, slices in zip(children_vars, symbol._children_slices):\n                    for child_dom, child_slice in slices.items():\n                        slice_starts.append(symbol._slices[child_dom][i].start)\n                        child_vectors.append(\n                            \"{}[{}:{}]\".format(\n                                child_var, child_slice[i].start, child_slice[i].stop\n                            )\n                        )\n                all_child_vectors.extend(\n                    [v for _, v in sorted(zip(slice_starts, child_vectors))]\n                )\n            if len(children_vars) > 1 or symbol.secondary_dimensions_npts > 1:\n                symbol_str = \"np.concatenate(({}))\".format(\",\".join(all_child_vectors))\n            else:\n                symbol_str = \"{}\".format(\",\".join(children_vars))\n        else:\n            raise NotImplementedError\n\n    # Note: we assume that y is being passed as a column vector\n    elif isinstance(symbol, pybamm.StateVector):\n        symbol_str = \"y[:{}][{}]\".format(\n            len(symbol.evaluation_array), symbol.evaluation_array\n        )\n\n    elif isinstance(symbol, pybamm.Time):\n        symbol_str = \"t\"\n\n    else:\n        raise NotImplementedError(\n            \"Not implemented for a symbol of type '{}'\".format(type(symbol))\n        )\n\n    variable_symbols[symbol.id] = symbol_str",
  "def to_python(symbol, debug=False):\n    \"\"\"\n    This function converts an expression tree into a dict of constant input values, and\n    valid python code that acts like the tree's :func:`pybamm.Symbol.evaluate` function\n\n    Parameters\n    ----------\n    symbol : :class:`pybamm.Symbol`\n        The symbol to convert to python code\n\n    debug : bool\n        If set to True, the function also emits debug code\n\n    Returns\n    -------\n    collections.OrderedDict:\n        dict mapping node id to a constant value. Represents all the constant nodes in\n        the expression tree\n    str:\n        valid python code that will evaluate all the variable nodes in the tree.\n\n    \"\"\"\n\n    constant_values = OrderedDict()\n    variable_symbols = OrderedDict()\n    find_symbols(symbol, constant_values, variable_symbols)\n\n    line_format = \"{} = {}\"\n\n    if debug:\n        variable_lines = [\n            \"print('{}'); \".format(\n                line_format.format(id_to_python_variable(symbol_id, False), symbol_line)\n            )\n            + line_format.format(id_to_python_variable(symbol_id, False), symbol_line)\n            + \"; print(type({0}),{0}.shape)\".format(\n                id_to_python_variable(symbol_id, False)\n            )\n            for symbol_id, symbol_line in variable_symbols.items()\n        ]\n    else:\n        variable_lines = [\n            line_format.format(id_to_python_variable(symbol_id, False), symbol_line)\n            for symbol_id, symbol_line in variable_symbols.items()\n        ]\n\n    return constant_values, \"\\n\".join(variable_lines)",
  "class EvaluatorPython:\n    \"\"\"\n    Converts a pybamm expression tree into pure python code that will calculate the\n    result of calling `evaluate(t, y)` on the given expression tree.\n\n    Parameters\n    ----------\n\n    symbol : :class:`pybamm.Symbol`\n        The symbol to convert to python code\n\n\n    \"\"\"\n\n    def __init__(self, symbol):\n        constants, self._variable_function = pybamm.to_python(symbol, debug=False)\n\n        # store all the constant symbols in the tree as internal variables of this\n        # object\n        for symbol_id, value in constants.items():\n            setattr(\n                self, id_to_python_variable(symbol_id, True).replace(\"self.\", \"\"), value\n            )\n\n        # calculate the final variable that will output the result of calling `evaluate`\n        # on `symbol`\n        self._result_var = id_to_python_variable(symbol.id, symbol.is_constant())\n\n        # compile the generated python code\n        self._variable_compiled = compile(\n            self._variable_function, self._result_var, \"exec\"\n        )\n\n        # compile the line that will return the output of `evaluate`\n        self._return_compiled = compile(\n            self._result_var, \"return\" + self._result_var, \"eval\"\n        )\n\n    def evaluate(self, t=None, y=None, known_evals=None):\n        \"\"\"\n        Acts as a drop-in replacement for :func:`pybamm.Symbol.evaluate`\n        \"\"\"\n        # generated code assumes y is a column vector\n        if y is not None and y.ndim == 1:\n            y = y.reshape(-1, 1)\n\n        # execute code\n        exec(self._variable_compiled)\n\n        # don't need known_evals, but need to reproduce Symbol.evaluate signature\n        if known_evals is not None:\n            return eval(self._return_compiled), known_evals\n        else:\n            return eval(self._return_compiled)",
  "def __init__(self, symbol):\n        constants, self._variable_function = pybamm.to_python(symbol, debug=False)\n\n        # store all the constant symbols in the tree as internal variables of this\n        # object\n        for symbol_id, value in constants.items():\n            setattr(\n                self, id_to_python_variable(symbol_id, True).replace(\"self.\", \"\"), value\n            )\n\n        # calculate the final variable that will output the result of calling `evaluate`\n        # on `symbol`\n        self._result_var = id_to_python_variable(symbol.id, symbol.is_constant())\n\n        # compile the generated python code\n        self._variable_compiled = compile(\n            self._variable_function, self._result_var, \"exec\"\n        )\n\n        # compile the line that will return the output of `evaluate`\n        self._return_compiled = compile(\n            self._result_var, \"return\" + self._result_var, \"eval\"\n        )",
  "def evaluate(self, t=None, y=None, known_evals=None):\n        \"\"\"\n        Acts as a drop-in replacement for :func:`pybamm.Symbol.evaluate`\n        \"\"\"\n        # generated code assumes y is a column vector\n        if y is not None and y.ndim == 1:\n            y = y.reshape(-1, 1)\n\n        # execute code\n        exec(self._variable_compiled)\n\n        # don't need known_evals, but need to reproduce Symbol.evaluate signature\n        if known_evals is not None:\n            return eval(self._return_compiled), known_evals\n        else:\n            return eval(self._return_compiled)",
  "class IndependentVariable(pybamm.Symbol):\n    \"\"\"A node in the expression tree representing an independent variable\n\n    Used for expressing functions depending on a spatial variable or time\n\n    Parameters\n    ----------\n    name : str\n        name of the node\n    domain : iterable of str\n        list of domains that this variable is valid over\n\n    *Extends:* :class:`Symbol`\n    \"\"\"\n\n    def __init__(self, name, domain=[]):\n        super().__init__(name, domain=domain)\n\n    def evaluate_for_shape(self):\n        \"\"\" See :meth:`pybamm.Symbol.evaluate_for_shape_using_domain()` \"\"\"\n        return pybamm.evaluate_for_shape_using_domain(self.domain)\n\n    def _jac(self, variable):\n        \"\"\" See :meth:`pybamm.Symbol._jac()`. \"\"\"\n        return pybamm.Scalar(0)",
  "class Time(IndependentVariable):\n    \"\"\"A node in the expression tree representing time\n\n    *Extends:* :class:`Symbol`\n    \"\"\"\n\n    def __init__(self):\n        super().__init__(\"time\")\n\n    def new_copy(self):\n        \"\"\" See :meth:`pybamm.Symbol.new_copy()`. \"\"\"\n        return Time()\n\n    def _base_evaluate(self, t, y=None):\n        \"\"\" See :meth:`pybamm.Symbol._base_evaluate()`. \"\"\"\n        if t is None:\n            raise ValueError(\"t must be provided\")\n        return t\n\n    def evaluate_for_shape(self):\n        \"\"\"\n        Return the scalar '0' to represent the shape of the independent variable `Time`.\n        See :meth:`pybamm.Symbol.evaluate_for_shape()`\n        \"\"\"\n        return 0",
  "class SpatialVariable(IndependentVariable):\n    \"\"\"A node in the expression tree representing a spatial variable\n\n    Parameters\n    ----------\n    name : str\n        name of the node (e.g. \"x\", \"y\", \"z\", \"r\", \"x_n\", \"x_s\", \"x_p\", \"r_n\", \"r_p\")\n    domain : iterable of str\n        list of domains that this variable is valid over (e.g. \"cartesian\", \"spherical\n        polar\")\n\n    *Extends:* :class:`Symbol`\n    \"\"\"\n\n    def __init__(self, name, domain=None, coord_sys=None):\n        self.coord_sys = coord_sys\n        super().__init__(name, domain=domain)\n        domain = self.domain\n\n        if name not in KNOWN_SPATIAL_VARS:\n            raise ValueError(\n                \"name must be KNOWN_SPATIAL_VARS  but is '{}'\".format(name)\n            )\n        if domain == []:\n            raise ValueError(\"domain must be provided\")\n\n        # Check symbol name vs domain name\n        if name == \"r\" and not (len(domain) == 1 and \"particle\" in domain[0]):\n            raise pybamm.DomainError(\"domain must be particle if name is 'r'\")\n        elif name == \"r_n\" and domain != [\"negative particle\"]:\n            raise pybamm.DomainError(\n                \"domain must be negative particle if name is 'r_n'\"\n            )\n        elif name == \"r_p\" and domain != [\"positive particle\"]:\n            raise pybamm.DomainError(\n                \"domain must be positive particle if name is 'r_p'\"\n            )\n        elif name in [\"x\", \"y\", \"z\", \"x_n\", \"x_s\", \"x_p\"] and any(\n            [\"particle\" in dom for dom in domain]\n        ):\n            raise pybamm.DomainError(\n                \"domain cannot be particle if name is '{}'\".format(name)\n            )\n\n    def new_copy(self):\n        \"\"\" See :meth:`pybamm.Symbol.new_copy()`. \"\"\"\n        return SpatialVariable(self.name, self.domain, self.coord_sys)",
  "def __init__(self, name, domain=[]):\n        super().__init__(name, domain=domain)",
  "def evaluate_for_shape(self):\n        \"\"\" See :meth:`pybamm.Symbol.evaluate_for_shape_using_domain()` \"\"\"\n        return pybamm.evaluate_for_shape_using_domain(self.domain)",
  "def _jac(self, variable):\n        \"\"\" See :meth:`pybamm.Symbol._jac()`. \"\"\"\n        return pybamm.Scalar(0)",
  "def __init__(self):\n        super().__init__(\"time\")",
  "def new_copy(self):\n        \"\"\" See :meth:`pybamm.Symbol.new_copy()`. \"\"\"\n        return Time()",
  "def _base_evaluate(self, t, y=None):\n        \"\"\" See :meth:`pybamm.Symbol._base_evaluate()`. \"\"\"\n        if t is None:\n            raise ValueError(\"t must be provided\")\n        return t",
  "def evaluate_for_shape(self):\n        \"\"\"\n        Return the scalar '0' to represent the shape of the independent variable `Time`.\n        See :meth:`pybamm.Symbol.evaluate_for_shape()`\n        \"\"\"\n        return 0",
  "def __init__(self, name, domain=None, coord_sys=None):\n        self.coord_sys = coord_sys\n        super().__init__(name, domain=domain)\n        domain = self.domain\n\n        if name not in KNOWN_SPATIAL_VARS:\n            raise ValueError(\n                \"name must be KNOWN_SPATIAL_VARS  but is '{}'\".format(name)\n            )\n        if domain == []:\n            raise ValueError(\"domain must be provided\")\n\n        # Check symbol name vs domain name\n        if name == \"r\" and not (len(domain) == 1 and \"particle\" in domain[0]):\n            raise pybamm.DomainError(\"domain must be particle if name is 'r'\")\n        elif name == \"r_n\" and domain != [\"negative particle\"]:\n            raise pybamm.DomainError(\n                \"domain must be negative particle if name is 'r_n'\"\n            )\n        elif name == \"r_p\" and domain != [\"positive particle\"]:\n            raise pybamm.DomainError(\n                \"domain must be positive particle if name is 'r_p'\"\n            )\n        elif name in [\"x\", \"y\", \"z\", \"x_n\", \"x_s\", \"x_p\"] and any(\n            [\"particle\" in dom for dom in domain]\n        ):\n            raise pybamm.DomainError(\n                \"domain cannot be particle if name is '{}'\".format(name)\n            )",
  "def new_copy(self):\n        \"\"\" See :meth:`pybamm.Symbol.new_copy()`. \"\"\"\n        return SpatialVariable(self.name, self.domain, self.coord_sys)",
  "def simplify_if_constant(symbol):\n    \"\"\"\n    Utility function to simplify an expression tree if it evalutes to a constant\n    scalar, vector or matrix\n    \"\"\"\n    if symbol.is_constant():\n        result = symbol.evaluate_ignoring_errors()\n        if result is not None:\n            if isinstance(result, numbers.Number) or (\n                isinstance(result, np.ndarray) and result.ndim == 0\n            ):\n                return pybamm.Scalar(result)\n            elif isinstance(result, np.ndarray) or issparse(result):\n                if result.ndim == 1 or result.shape[1] == 1:\n                    return pybamm.Vector(result)\n                else:\n                    return pybamm.Matrix(result)\n\n    return symbol",
  "def simplify_addition_subtraction(myclass, left, right):\n    \"\"\"\n    if children are associative (addition, subtraction, etc) then try to find groups of\n    constant children (that produce a value) and simplify them to a single term\n\n    The purpose of this function is to simplify expressions like (1 + (1 + p)), which\n    should be simplified to (2 + p). The former expression consists of an Addition, with\n    a left child of Scalar type, and a right child of another Addition containing a\n    Scalar and a Parameter. For this case, this function will first flatten the\n    expression to a list of the bottom level children (i.e. [Scalar(1), Scalar(2),\n    Parameter(p)]), and their operators (i.e. [None, Addition, Addition]), and then\n    combine all the constant children (i.e. Scalar(1) and Scalar(1)) to a single child\n    (i.e. Scalar(2))\n\n    Note that this function will flatten the expression tree until a symbol is found\n    that is not either an Addition or a Subtraction, so this function would simplify\n    (3 - (2 + a*b*c)) to (1 + a*b*c)\n\n    This function is useful if different children expressions contain non-constant terms\n    that prevent them from being simplified, so for example (1 + a) + (b - 2) - (6 + c)\n    will be simplified to (-7 + a + b - c)\n\n    Parameters\n    ----------\n\n    myclass: class\n        the binary operator class (pybamm.Addition or pybamm.Subtraction) operating on\n        children left and right\n    left: derived from pybamm.Symbol\n        the left child of the binary operator\n    right: derived from pybamm.Symbol\n        the right child of the binary operator\n\n    \"\"\"\n    numerator = []\n    numerator_types = []\n\n    def flatten(this_class, left_child, right_child, in_subtraction):\n        \"\"\"\n        recursive function to flatten a term involving only additions or subtractions\n\n        outputs to lists `numerator` and `numerator_types`\n\n        Note that domains are all set to [] as we do not wish to consider domains once\n        simplifications are applied\n\n        e.g.\n\n        (1 + 2) + 3       -> [1, 2, 3]    and [None, Addition, Addition]\n        1 + (2 - 3)       -> [1, 2, 3]    and [None, Addition, Subtraction]\n        1 - (2 + 3)       -> [1, 2, 3]    and [None, Subtraction, Subtraction]\n        (1 + 2) - (2 + 3) -> [1, 2, 2, 3] and [None, Addition, Subtraction, Subtraction]\n        \"\"\"\n\n        left_child.domain = []\n        right_child.domain = []\n        for side, child in [(\"left\", left_child), (\"right\", right_child)]:\n            if isinstance(child, (pybamm.Addition, pybamm.Subtraction)):\n                left, right = child.orphans\n                flatten(child.__class__, left, right, in_subtraction)\n\n            else:\n                numerator.append(child)\n                if in_subtraction is None:\n                    numerator_types.append(None)\n                elif in_subtraction:\n                    numerator_types.append(pybamm.Subtraction)\n                else:\n                    numerator_types.append(pybamm.Addition)\n\n            if side == \"left\":\n                if in_subtraction is None:\n                    in_subtraction = this_class == pybamm.Subtraction\n                elif this_class == pybamm.Subtraction:\n                    in_subtraction = not in_subtraction\n\n    flatten(myclass, left, right, None)\n\n    def partition_by_constant(source, types):\n        \"\"\"\n        function to partition a source list of symbols into those that return a constant\n        value, and those that do not\n        \"\"\"\n        constant = []\n        nonconstant = []\n        constant_types = []\n        nonconstant_types = []\n\n        for child, op_type in zip(source, types):\n            if child.is_constant() and child.evaluate_ignoring_errors() is not None:\n                constant.append(child)\n                constant_types.append(op_type)\n            else:\n                nonconstant.append(child)\n                nonconstant_types.append(op_type)\n        return constant, nonconstant, constant_types, nonconstant_types\n\n    def fold_add_subtract(array, types):\n        \"\"\"\n        performs a fold operation on the children nodes in `array`, using the operator\n        types given in `types`\n\n        e.g. if the input was:\n        array = [1, 2, 3, 4]\n        types = [None, +, -, +]\n\n        the result would be 1 + 2 - 3 + 4\n        \"\"\"\n        ret = None\n        if len(array) > 0:\n            if types[0] in [None, pybamm.Addition]:\n                ret = array[0]\n            elif types[0] == pybamm.Subtraction:\n                ret = -array[0]\n            for child, typ in zip(array[1:], types[1:]):\n                if typ == pybamm.Addition:\n                    ret += child\n                else:\n                    ret -= child\n        return ret\n\n    # simplify identical terms\n    i = 0\n    while i < len(numerator) - 1:\n        if isinstance(numerator[i], pybamm.Multiplication) and isinstance(\n            numerator[i].children[0], pybamm.Scalar\n        ):\n            term_i = numerator[i].orphans[1]\n            term_i_count = numerator[i].children[0].evaluate()\n        else:\n            term_i = numerator[i]\n            term_i_count = 1\n\n        # loop through rest of numerator counting up and deleting identical terms\n        for j, (term_j, typ_j) in enumerate(\n            zip(numerator[i + 1 :], numerator_types[i + 1 :])\n        ):\n            if isinstance(term_j, pybamm.Multiplication) and isinstance(\n                term_j.left, pybamm.Scalar\n            ):\n                factor = term_j.left.evaluate()\n                term_j = term_j.right\n            else:\n                factor = 1\n            if term_i.id == term_j.id:\n                if typ_j == pybamm.Addition:\n                    term_i_count += factor\n                elif typ_j == pybamm.Subtraction:\n                    term_i_count -= factor\n                del numerator[j + i + 1]\n                del numerator_types[j + i + 1]\n\n        # replace this term by count * term if count > 1\n        if term_i_count != 1:\n            # simplify the result just in case\n            # (e.g. count == 0, or can fold constant into the term)\n            numerator[i] = (term_i_count * term_i).simplify()\n\n        i += 1\n\n    # can reorder the numerator\n    (constant, nonconstant, constant_types, nonconstant_types) = partition_by_constant(\n        numerator, numerator_types\n    )\n\n    constant_expr = fold_add_subtract(constant, constant_types)\n    nonconstant_expr = fold_add_subtract(nonconstant, nonconstant_types)\n\n    if constant_expr is not None and nonconstant_expr is None:\n        # might be no nonconstants\n        new_expression = pybamm.simplify_if_constant(constant_expr)\n    elif constant_expr is None and nonconstant_expr is not None:\n        # might be no constants\n        new_expression = nonconstant_expr\n    else:\n        # or mix of both\n        constant_expr = pybamm.simplify_if_constant(constant_expr)\n        new_expression = constant_expr + nonconstant_expr\n\n    return new_expression",
  "def simplify_multiplication_division(myclass, left, right):\n    \"\"\"\n    if children are associative (multiply, division, etc) then try to find\n    groups of constant children (that produce a value) and simplify them\n\n    The purpose of this function is to simplify expressions of the type (1 * c / 2),\n    which should simplify to (0.5 * c). The former expression consists of a Division,\n    with a left child of a Multiplication containing a Scalar and a Parameter, and a\n    right child consisting of a Scalar. For this case, this function will first flatten\n    the expression to a list of the bottom level children on the numerator (i.e.\n    [Scalar(1), Parameter(c)]) and their operators (i.e. [None, Multiplication]), as\n    well as those children on the denominator (i.e. [Scalar(2)]. After this, all the\n    constant children on the numerator and denominator (i.e. Scalar(1) and Scalar(2))\n    will be combined appropriately, in this case to Scalar(0.5), and combined with the\n    nonconstant children (i.e. Parameter(c))\n\n    Note that this function will flatten the expression tree until a symbol is found\n    that is not either an Multiplication, Division or MatrixMultiplication, so this\n    function would simplify (3*(1 + d)*2) to (6 * (1 + d))\n\n    As well as Multiplication and Division, this function can handle\n    MatrixMultiplication. If any MatrixMultiplications are found on the\n    numerator/denominator, no reordering of children is done to find groups of constant\n    children. In this case only neighbouring constant children on the numerator are\n    simplified\n\n    Parameters\n    ----------\n\n    myclass: class\n        the binary operator class (pybamm.Addition or pybamm.Subtraction) operating on\n        children left and right\n    left: derived from pybamm.Symbol\n        the left child of the binary operator\n    right: derived from pybamm.Symbol\n        the right child of the binary operator\n\n    \"\"\"\n    numerator = []\n    denominator = []\n    numerator_types = []\n    denominator_types = []\n\n    # recursive function to flatten a term involving only multiplications or divisions\n    def flatten(\n        previous_class,\n        this_class,\n        left_child,\n        right_child,\n        in_numerator,\n        in_matrix_multiplication,\n    ):\n        \"\"\"\n        recursive function to flatten a term involving only Multiplication, Division or\n        MatrixMultiplication. keeps track of wether a term is on the numerator or\n        denominator. For those terms on the numerator, their operator type\n        (Multiplication or MatrixMultiplication) is stored\n\n        Note that multiplication *within* matrix multiplications, e.g. a@(b*c), are not\n        flattened into a@b*c, as this would be incorrect (see #253)\n\n        Note that the domains are all set to [] as we do not wish to consider domains\n        once simplifications are applied\n\n        outputs to lists `numerator`, `denominator` and `numerator_types`\n\n        e.g.\n        expression     numerator  denominator  numerator_types\n        (1 * 2) / 3 ->  [1, 2]       [3]       [None, Multiplication]\n        (1 @ 2) / 3 ->  [1, 2]       [3]       [None, MatrixMultiplication]\n        1 / (c / 2) ->  [1, 2]       [c]       [None, Multiplication]\n        \"\"\"\n\n        left_child.domain = []\n        right_child.domain = []\n        for side, child in [(\"left\", left_child), (\"right\", right_child)]:\n\n            if side == \"left\":\n                other_child = right_child\n            else:\n                other_child = left_child\n\n            # flatten if all matrix multiplications\n            # flatten if one child is a matrix mult if the other term is a scalar or\n            # vector\n            if isinstance(child, pybamm.MatrixMultiplication) and (\n                in_matrix_multiplication\n                or isinstance(other_child, (pybamm.Scalar, pybamm.Vector))\n            ):\n                left, right = child.orphans\n                if (\n                    side == \"left\"\n                    and this_class == pybamm.Multiplication\n                    and isinstance(other_child, pybamm.Vector)\n                ):\n                    # change (m @ v1) * v2 -> v2 * m @ v so can simplify correctly\n                    # (#341)\n                    numerator.append(other_child)\n                    numerator_types.append(previous_class)\n                    flatten(\n                        this_class, child.__class__, left, right, in_numerator, True\n                    )\n                    break\n                if side == \"left\":\n                    flatten(\n                        previous_class, child.__class__, left, right, in_numerator, True\n                    )\n                else:\n                    flatten(\n                        this_class, child.__class__, left, right, in_numerator, True\n                    )\n            # flatten if all multiplies and divides\n            elif (\n                isinstance(child, (pybamm.Multiplication, pybamm.Division))\n                and not in_matrix_multiplication\n            ):\n                left, right = child.orphans\n                if side == \"left\":\n                    flatten(\n                        previous_class,\n                        child.__class__,\n                        left,\n                        right,\n                        in_numerator,\n                        False,\n                    )\n                else:\n                    flatten(\n                        this_class, child.__class__, left, right, in_numerator, False\n                    )\n            # everything else don't flatten\n            else:\n                if in_numerator:\n                    numerator.append(child)\n                    if side == \"left\":\n                        numerator_types.append(previous_class)\n                    else:\n                        numerator_types.append(this_class)\n                else:\n                    denominator.append(child)\n                    if side == \"left\":\n                        denominator_types.append(previous_class)\n                    else:\n                        denominator_types.append(this_class)\n\n            if side == \"left\" and this_class == pybamm.Division:\n                in_numerator = not in_numerator\n\n    flatten(None, myclass, left, right, True, myclass == pybamm.MatrixMultiplication)\n\n    # check if there is a matrix multiply in the numerator (if so we can't reorder it)\n    numerator_has_mat_mul = any(\n        [typ == pybamm.MatrixMultiplication for typ in numerator_types + [myclass]]\n    )\n\n    denominator_has_mat_mul = any(\n        [typ == pybamm.MatrixMultiplication for typ in denominator_types]\n    )\n\n    def partition_by_constant(source, types=None):\n        \"\"\"\n        function to partition a source list of symbols into those that return a constant\n        value, and those that do not\n        \"\"\"\n        constant = []\n        nonconstant = []\n\n        for child in source:\n            if child.is_constant() and child.evaluate_ignoring_errors() is not None:\n                constant.append(child)\n            else:\n                nonconstant.append(child)\n        return constant, nonconstant\n\n    def fold_multiply(array, types=None):\n        \"\"\"\n        performs a fold operation on the children nodes in `array`, using the operator\n        types given in `types`\n\n        e.g. if the input was:\n        array = [1, 2, 3, 4]\n        types = [None, *, @, *]\n\n        the result would be 1 * 2 @ 3 * 4\n        \"\"\"\n        ret = None\n        if len(array) > 0:\n            if types is None:\n                ret = array[0]\n                for child in array[1:]:\n                    ret *= child\n            else:\n                # work backwards through 'array' and 'types' so that multiplications\n                # and matrix multiplications are performed in the most efficient order\n                ret = array[-1]\n                for child, typ in zip(reversed(array[:-1]), reversed(types[1:])):\n                    if typ == pybamm.MatrixMultiplication:\n                        ret = child @ ret\n                    else:\n                        ret = child * ret\n        return ret\n\n    def simplify_with_mat_mul(nodes, types):\n        new_nodes = [nodes[0]]\n        new_types = [types[0]]\n        for child, typ in zip(nodes[1:], types[1:]):\n            if (\n                new_nodes[-1].is_constant()\n                and child.is_constant()\n                and new_nodes[-1].evaluate_ignoring_errors() is not None\n                and child.evaluate_ignoring_errors() is not None\n            ):\n                if typ == pybamm.MatrixMultiplication:\n                    new_nodes[-1] = new_nodes[-1] @ child\n                else:\n                    new_nodes[-1] *= child\n                new_nodes[-1] = pybamm.simplify_if_constant(new_nodes[-1])\n            else:\n                new_nodes.append(child)\n                new_types.append(typ)\n        new_nodes = fold_multiply(new_nodes, new_types)\n        return new_nodes\n\n    if numerator_has_mat_mul and denominator_has_mat_mul:\n        new_numerator = simplify_with_mat_mul(numerator, numerator_types)\n        new_denominator = simplify_with_mat_mul(denominator, denominator_types)\n        if new_denominator is None:\n            result = new_numerator\n        else:\n            result = new_numerator / new_denominator\n\n    elif numerator_has_mat_mul and not denominator_has_mat_mul:\n        # can reorder the denominator since no matrix multiplies\n        denominator_constant, denominator_nonconst = partition_by_constant(denominator)\n\n        constant_denominator_expr = fold_multiply(denominator_constant)\n        nonconst_denominator_expr = fold_multiply(denominator_nonconst)\n\n        # fold constant denominator expr into numerator if possible\n        if constant_denominator_expr is not None:\n            for i, child in enumerate(numerator):\n                if child.is_constant() and child.evaluate_ignoring_errors() is not None:\n                    numerator[i] = child / constant_denominator_expr\n                    numerator[i] = pybamm.simplify_if_constant(numerator[i])\n                    constant_denominator_expr = None\n\n        new_numerator = simplify_with_mat_mul(numerator, numerator_types)\n\n        # result = constant_numerator_expr * new_numerator / nonconst_denominator_expr\n        # need to take into accound that terms can be None\n        if constant_denominator_expr is None:\n            if nonconst_denominator_expr is None:\n                result = new_numerator\n            else:\n                result = new_numerator / nonconst_denominator_expr\n        else:\n            # invert constant denominator terms for speed\n            constant_numerator_expr = pybamm.simplify_if_constant(\n                1 / constant_denominator_expr\n            )\n\n            if nonconst_denominator_expr is None:\n                result = constant_numerator_expr * new_numerator\n            else:\n                result = (\n                    constant_numerator_expr * new_numerator / nonconst_denominator_expr\n                )\n\n    elif not numerator_has_mat_mul and denominator_has_mat_mul:\n        new_denominator = simplify_with_mat_mul(denominator, denominator_types)\n\n        # can reorder the numerator since no matrix multiplies\n        numerator_constant, numerator_nonconst = partition_by_constant(numerator)\n\n        constant_numerator_expr = fold_multiply(numerator_constant)\n        nonconst_numerator_expr = fold_multiply(numerator_nonconst)\n\n        # result = constant_numerator_expr * nonconst_numerator_expr / new_denominator\n        # need to take into account that terms can be None\n        if constant_numerator_expr is None:\n            result = nonconst_numerator_expr / new_denominator\n        else:\n            constant_numerator_expr = pybamm.simplify_if_constant(\n                constant_numerator_expr\n            )\n            if nonconst_numerator_expr is None:\n                result = constant_numerator_expr / new_denominator\n            else:\n                result = (\n                    constant_numerator_expr * nonconst_numerator_expr / new_denominator\n                )\n\n    else:\n        # can reorder the numerator since no matrix multiplies\n        numerator_constant, numerator_nonconstant = partition_by_constant(numerator)\n\n        constant_numerator_expr = fold_multiply(numerator_constant)\n        nonconst_numerator_expr = fold_multiply(numerator_nonconstant)\n\n        # can reorder the denominator since no matrix multiplies\n        denominator_constant, denominator_nonconst = partition_by_constant(denominator)\n\n        constant_denominator_expr = fold_multiply(denominator_constant)\n        nonconst_denominator_expr = fold_multiply(denominator_nonconst)\n\n        if constant_numerator_expr is not None:\n            if constant_denominator_expr is not None:\n                constant_numerator_expr = pybamm.simplify_if_constant(\n                    constant_numerator_expr / constant_denominator_expr\n                )\n            else:\n                constant_numerator_expr = pybamm.simplify_if_constant(\n                    constant_numerator_expr\n                )\n        else:\n            if constant_denominator_expr is not None:\n                constant_numerator_expr = pybamm.simplify_if_constant(\n                    1 / constant_denominator_expr\n                )\n\n        # result = constant_numerator_expr * nonconst_numerator_expr\n        #    / nonconst_denominator_expr\n        # need to take into account that terms can be None\n        if constant_numerator_expr is None:\n            result = nonconst_numerator_expr\n        else:\n            if nonconst_numerator_expr is None:\n                result = constant_numerator_expr\n            else:\n                result = constant_numerator_expr * nonconst_numerator_expr\n\n        if nonconst_denominator_expr is not None:\n            result = result / nonconst_denominator_expr\n\n    return result",
  "class Simplification(object):\n    def __init__(self, simplified_symbols=None):\n        self._simplified_symbols = simplified_symbols or {}\n\n    def simplify(self, symbol):\n        \"\"\"\n        This function recurses down the tree, applying any simplifications defined in\n        classes derived from pybamm.Symbol. E.g. any expression multiplied by a\n        pybamm.Scalar(0) will be simplified to a pybamm.Scalar(0).\n        If a symbol has already been simplified, the stored value is returned.\n\n        Parameters\n        ----------\n        symbol : :class:`pybamm.Symbol`\n        The symbol to simplify\n\n        Returns\n        -------\n        :class:`pybamm.Symbol`\n        Simplified symbol\n        \"\"\"\n\n        try:\n            return self._simplified_symbols[symbol.id]\n        except KeyError:\n            simplified_symbol = self._simplify(symbol)\n            self._simplified_symbols[symbol.id] = simplified_symbol\n\n            return simplified_symbol\n\n    def _simplify(self, symbol):\n        \"\"\" See :meth:`Simplification.simplify()`. \"\"\"\n        symbol.domain = []\n        symbol.auxiliary_domains = {}\n\n        if isinstance(symbol, pybamm.BinaryOperator):\n            left, right = symbol.children\n            # process children\n            new_left = self.simplify(left)\n            new_right = self.simplify(right)\n            # _binary_simplify defined in derived classes for specific rules\n            new_symbol = symbol._binary_simplify(new_left, new_right)\n\n        elif isinstance(symbol, pybamm.UnaryOperator):\n            new_child = self.simplify(symbol.child)\n            # _unary_simplify defined in derived classes for specific rules\n            new_symbol = symbol._unary_simplify(new_child)\n\n        elif isinstance(symbol, pybamm.Function):\n            simplified_children = [None] * len(symbol.children)\n            for i, child in enumerate(symbol.children):\n                simplified_children[i] = self.simplify(child)\n            # _function_simplify defined in function class\n            new_symbol = symbol._function_simplify(simplified_children)\n\n        elif isinstance(symbol, pybamm.Concatenation):\n            new_children = [self.simplify(child) for child in symbol.children]\n            new_symbol = symbol._concatenation_simplify(new_children)\n\n        else:\n            # Backup option: return new copy of the object\n            try:\n                new_symbol = symbol.new_copy()\n                return new_symbol\n            except NotImplementedError:\n                raise NotImplementedError(\n                    \"Cannot simplify symbol of type '{}'\".format(type(symbol))\n                )\n\n        return simplify_if_constant(new_symbol)",
  "def flatten(this_class, left_child, right_child, in_subtraction):\n        \"\"\"\n        recursive function to flatten a term involving only additions or subtractions\n\n        outputs to lists `numerator` and `numerator_types`\n\n        Note that domains are all set to [] as we do not wish to consider domains once\n        simplifications are applied\n\n        e.g.\n\n        (1 + 2) + 3       -> [1, 2, 3]    and [None, Addition, Addition]\n        1 + (2 - 3)       -> [1, 2, 3]    and [None, Addition, Subtraction]\n        1 - (2 + 3)       -> [1, 2, 3]    and [None, Subtraction, Subtraction]\n        (1 + 2) - (2 + 3) -> [1, 2, 2, 3] and [None, Addition, Subtraction, Subtraction]\n        \"\"\"\n\n        left_child.domain = []\n        right_child.domain = []\n        for side, child in [(\"left\", left_child), (\"right\", right_child)]:\n            if isinstance(child, (pybamm.Addition, pybamm.Subtraction)):\n                left, right = child.orphans\n                flatten(child.__class__, left, right, in_subtraction)\n\n            else:\n                numerator.append(child)\n                if in_subtraction is None:\n                    numerator_types.append(None)\n                elif in_subtraction:\n                    numerator_types.append(pybamm.Subtraction)\n                else:\n                    numerator_types.append(pybamm.Addition)\n\n            if side == \"left\":\n                if in_subtraction is None:\n                    in_subtraction = this_class == pybamm.Subtraction\n                elif this_class == pybamm.Subtraction:\n                    in_subtraction = not in_subtraction",
  "def partition_by_constant(source, types):\n        \"\"\"\n        function to partition a source list of symbols into those that return a constant\n        value, and those that do not\n        \"\"\"\n        constant = []\n        nonconstant = []\n        constant_types = []\n        nonconstant_types = []\n\n        for child, op_type in zip(source, types):\n            if child.is_constant() and child.evaluate_ignoring_errors() is not None:\n                constant.append(child)\n                constant_types.append(op_type)\n            else:\n                nonconstant.append(child)\n                nonconstant_types.append(op_type)\n        return constant, nonconstant, constant_types, nonconstant_types",
  "def fold_add_subtract(array, types):\n        \"\"\"\n        performs a fold operation on the children nodes in `array`, using the operator\n        types given in `types`\n\n        e.g. if the input was:\n        array = [1, 2, 3, 4]\n        types = [None, +, -, +]\n\n        the result would be 1 + 2 - 3 + 4\n        \"\"\"\n        ret = None\n        if len(array) > 0:\n            if types[0] in [None, pybamm.Addition]:\n                ret = array[0]\n            elif types[0] == pybamm.Subtraction:\n                ret = -array[0]\n            for child, typ in zip(array[1:], types[1:]):\n                if typ == pybamm.Addition:\n                    ret += child\n                else:\n                    ret -= child\n        return ret",
  "def flatten(\n        previous_class,\n        this_class,\n        left_child,\n        right_child,\n        in_numerator,\n        in_matrix_multiplication,\n    ):\n        \"\"\"\n        recursive function to flatten a term involving only Multiplication, Division or\n        MatrixMultiplication. keeps track of wether a term is on the numerator or\n        denominator. For those terms on the numerator, their operator type\n        (Multiplication or MatrixMultiplication) is stored\n\n        Note that multiplication *within* matrix multiplications, e.g. a@(b*c), are not\n        flattened into a@b*c, as this would be incorrect (see #253)\n\n        Note that the domains are all set to [] as we do not wish to consider domains\n        once simplifications are applied\n\n        outputs to lists `numerator`, `denominator` and `numerator_types`\n\n        e.g.\n        expression     numerator  denominator  numerator_types\n        (1 * 2) / 3 ->  [1, 2]       [3]       [None, Multiplication]\n        (1 @ 2) / 3 ->  [1, 2]       [3]       [None, MatrixMultiplication]\n        1 / (c / 2) ->  [1, 2]       [c]       [None, Multiplication]\n        \"\"\"\n\n        left_child.domain = []\n        right_child.domain = []\n        for side, child in [(\"left\", left_child), (\"right\", right_child)]:\n\n            if side == \"left\":\n                other_child = right_child\n            else:\n                other_child = left_child\n\n            # flatten if all matrix multiplications\n            # flatten if one child is a matrix mult if the other term is a scalar or\n            # vector\n            if isinstance(child, pybamm.MatrixMultiplication) and (\n                in_matrix_multiplication\n                or isinstance(other_child, (pybamm.Scalar, pybamm.Vector))\n            ):\n                left, right = child.orphans\n                if (\n                    side == \"left\"\n                    and this_class == pybamm.Multiplication\n                    and isinstance(other_child, pybamm.Vector)\n                ):\n                    # change (m @ v1) * v2 -> v2 * m @ v so can simplify correctly\n                    # (#341)\n                    numerator.append(other_child)\n                    numerator_types.append(previous_class)\n                    flatten(\n                        this_class, child.__class__, left, right, in_numerator, True\n                    )\n                    break\n                if side == \"left\":\n                    flatten(\n                        previous_class, child.__class__, left, right, in_numerator, True\n                    )\n                else:\n                    flatten(\n                        this_class, child.__class__, left, right, in_numerator, True\n                    )\n            # flatten if all multiplies and divides\n            elif (\n                isinstance(child, (pybamm.Multiplication, pybamm.Division))\n                and not in_matrix_multiplication\n            ):\n                left, right = child.orphans\n                if side == \"left\":\n                    flatten(\n                        previous_class,\n                        child.__class__,\n                        left,\n                        right,\n                        in_numerator,\n                        False,\n                    )\n                else:\n                    flatten(\n                        this_class, child.__class__, left, right, in_numerator, False\n                    )\n            # everything else don't flatten\n            else:\n                if in_numerator:\n                    numerator.append(child)\n                    if side == \"left\":\n                        numerator_types.append(previous_class)\n                    else:\n                        numerator_types.append(this_class)\n                else:\n                    denominator.append(child)\n                    if side == \"left\":\n                        denominator_types.append(previous_class)\n                    else:\n                        denominator_types.append(this_class)\n\n            if side == \"left\" and this_class == pybamm.Division:\n                in_numerator = not in_numerator",
  "def partition_by_constant(source, types=None):\n        \"\"\"\n        function to partition a source list of symbols into those that return a constant\n        value, and those that do not\n        \"\"\"\n        constant = []\n        nonconstant = []\n\n        for child in source:\n            if child.is_constant() and child.evaluate_ignoring_errors() is not None:\n                constant.append(child)\n            else:\n                nonconstant.append(child)\n        return constant, nonconstant",
  "def fold_multiply(array, types=None):\n        \"\"\"\n        performs a fold operation on the children nodes in `array`, using the operator\n        types given in `types`\n\n        e.g. if the input was:\n        array = [1, 2, 3, 4]\n        types = [None, *, @, *]\n\n        the result would be 1 * 2 @ 3 * 4\n        \"\"\"\n        ret = None\n        if len(array) > 0:\n            if types is None:\n                ret = array[0]\n                for child in array[1:]:\n                    ret *= child\n            else:\n                # work backwards through 'array' and 'types' so that multiplications\n                # and matrix multiplications are performed in the most efficient order\n                ret = array[-1]\n                for child, typ in zip(reversed(array[:-1]), reversed(types[1:])):\n                    if typ == pybamm.MatrixMultiplication:\n                        ret = child @ ret\n                    else:\n                        ret = child * ret\n        return ret",
  "def simplify_with_mat_mul(nodes, types):\n        new_nodes = [nodes[0]]\n        new_types = [types[0]]\n        for child, typ in zip(nodes[1:], types[1:]):\n            if (\n                new_nodes[-1].is_constant()\n                and child.is_constant()\n                and new_nodes[-1].evaluate_ignoring_errors() is not None\n                and child.evaluate_ignoring_errors() is not None\n            ):\n                if typ == pybamm.MatrixMultiplication:\n                    new_nodes[-1] = new_nodes[-1] @ child\n                else:\n                    new_nodes[-1] *= child\n                new_nodes[-1] = pybamm.simplify_if_constant(new_nodes[-1])\n            else:\n                new_nodes.append(child)\n                new_types.append(typ)\n        new_nodes = fold_multiply(new_nodes, new_types)\n        return new_nodes",
  "def __init__(self, simplified_symbols=None):\n        self._simplified_symbols = simplified_symbols or {}",
  "def simplify(self, symbol):\n        \"\"\"\n        This function recurses down the tree, applying any simplifications defined in\n        classes derived from pybamm.Symbol. E.g. any expression multiplied by a\n        pybamm.Scalar(0) will be simplified to a pybamm.Scalar(0).\n        If a symbol has already been simplified, the stored value is returned.\n\n        Parameters\n        ----------\n        symbol : :class:`pybamm.Symbol`\n        The symbol to simplify\n\n        Returns\n        -------\n        :class:`pybamm.Symbol`\n        Simplified symbol\n        \"\"\"\n\n        try:\n            return self._simplified_symbols[symbol.id]\n        except KeyError:\n            simplified_symbol = self._simplify(symbol)\n            self._simplified_symbols[symbol.id] = simplified_symbol\n\n            return simplified_symbol",
  "def _simplify(self, symbol):\n        \"\"\" See :meth:`Simplification.simplify()`. \"\"\"\n        symbol.domain = []\n        symbol.auxiliary_domains = {}\n\n        if isinstance(symbol, pybamm.BinaryOperator):\n            left, right = symbol.children\n            # process children\n            new_left = self.simplify(left)\n            new_right = self.simplify(right)\n            # _binary_simplify defined in derived classes for specific rules\n            new_symbol = symbol._binary_simplify(new_left, new_right)\n\n        elif isinstance(symbol, pybamm.UnaryOperator):\n            new_child = self.simplify(symbol.child)\n            # _unary_simplify defined in derived classes for specific rules\n            new_symbol = symbol._unary_simplify(new_child)\n\n        elif isinstance(symbol, pybamm.Function):\n            simplified_children = [None] * len(symbol.children)\n            for i, child in enumerate(symbol.children):\n                simplified_children[i] = self.simplify(child)\n            # _function_simplify defined in function class\n            new_symbol = symbol._function_simplify(simplified_children)\n\n        elif isinstance(symbol, pybamm.Concatenation):\n            new_children = [self.simplify(child) for child in symbol.children]\n            new_symbol = symbol._concatenation_simplify(new_children)\n\n        else:\n            # Backup option: return new copy of the object\n            try:\n                new_symbol = symbol.new_copy()\n                return new_symbol\n            except NotImplementedError:\n                raise NotImplementedError(\n                    \"Cannot simplify symbol of type '{}'\".format(type(symbol))\n                )\n\n        return simplify_if_constant(new_symbol)",
  "class Function(pybamm.Symbol):\n    \"\"\"A node in the expression tree representing an arbitrary function\n\n    Parameters\n    ----------\n    function : method\n        A function can have 0 or many inputs. If no inputs are given, self.evaluate()\n        simply returns func(). Otherwise, self.evaluate(t, y) returns\n        func(child0.evaluate(t, y), child1.evaluate(t, y), etc).\n    children : :class:`pybamm.Symbol`\n        The children nodes to apply the function to\n    derivative : str, optional\n        Which derivative to use when differentiating (\"autograd\" or \"derivative\").\n        Default is \"autograd\".\n    **Extends:** :class:`pybamm.Symbol`\n    \"\"\"\n\n    def __init__(self, function, *children, name=None, derivative=\"autograd\"):\n\n        if name is not None:\n            self.name = name\n        else:\n            try:\n                name = \"function ({})\".format(function.__name__)\n            except AttributeError:\n                name = \"function ({})\".format(function.__class__)\n        children_list = list(children)\n        domain = self.get_children_domains(children_list)\n        auxiliary_domains = self.get_children_auxiliary_domains(children)\n\n        self.function = function\n        self.derivative = derivative\n\n        # hack to work out whether function takes any params\n        # (signature doesn't work for numpy)\n        if isinstance(function, np.ufunc):\n            self.takes_no_params = False\n        else:\n            self.takes_no_params = len(signature(function).parameters) == 0\n\n        super().__init__(\n            name,\n            children=children_list,\n            domain=domain,\n            auxiliary_domains=auxiliary_domains,\n        )\n\n    def get_children_domains(self, children_list):\n        \"\"\"Obtains the unique domain of the children. If the\n        children have different domains then raise an error\"\"\"\n\n        domains = [child.domain for child in children_list if child.domain != []]\n\n        # check that there is one common domain amongst children\n        distinct_domains = set(tuple(dom) for dom in domains)\n\n        if len(distinct_domains) > 1:\n            raise pybamm.DomainError(\n                \"Functions can only be applied to variables on the same domain\"\n            )\n        elif len(distinct_domains) == 0:\n            domain = []\n        else:\n            domain = domains[0]\n\n        return domain\n\n    def diff(self, variable):\n        \"\"\" See :meth:`pybamm.Symbol.diff()`. \"\"\"\n        if variable.id == self.id:\n            return pybamm.Scalar(1)\n        else:\n            children = self.orphans\n            partial_derivatives = [None] * len(children)\n            for i, child in enumerate(self.children):\n                # if variable appears in the function,use autograd to differentiate\n                # function, and apply chain rule\n                if variable.id in [symbol.id for symbol in child.pre_order()]:\n                    partial_derivatives[i] = self._diff(children) * child.diff(variable)\n\n            # remove None entries\n            partial_derivatives = list(filter(None, partial_derivatives))\n\n            derivative = sum(partial_derivatives)\n            if derivative == 0:\n                derivative = pybamm.Scalar(0)\n\n            return derivative\n\n    def _diff(self, children):\n        \"\"\" See :meth:`pybamm.Symbol._diff()`. \"\"\"\n        if self.derivative == \"autograd\":\n            return Function(autograd.elementwise_grad(self.function), *children)\n        elif self.derivative == \"derivative\":\n            # keep using \"derivative\" as derivative\n            return pybamm.Function(\n                self.function.derivative(), *children, derivative=\"derivative\"\n            )\n\n    def _function_jac(self, children_jacs):\n        \"\"\" Calculate the jacobian of a function. \"\"\"\n\n        if all(child.evaluates_to_number() for child in self.children):\n            jacobian = pybamm.Scalar(0)\n        else:\n            # if at least one child contains variable dependence, then\n            # calculate the required partial jacobians and add them\n            jacobian = None\n            children = self.orphans\n            for i, child in enumerate(children):\n                if not child.evaluates_to_number():\n                    jac_fun = self._diff(children) * children_jacs[i]\n                    jac_fun.domain = []\n                    if jacobian is None:\n                        jacobian = jac_fun\n                    else:\n                        jacobian += jac_fun\n\n        return jacobian\n\n    def evaluate(self, t=None, y=None, known_evals=None):\n        \"\"\" See :meth:`pybamm.Symbol.evaluate()`. \"\"\"\n        if known_evals is not None:\n            if self.id not in known_evals:\n                evaluated_children = [None] * len(self.children)\n                for i, child in enumerate(self.children):\n                    evaluated_children[i], known_evals = child.evaluate(\n                        t, y, known_evals\n                    )\n                known_evals[self.id] = self._function_evaluate(evaluated_children)\n            return known_evals[self.id], known_evals\n        else:\n            evaluated_children = [child.evaluate(t, y) for child in self.children]\n            return self._function_evaluate(evaluated_children)\n\n    def evaluate_for_shape(self):\n        \"\"\"\n        Default behaviour: has same shape as all child\n        See :meth:`pybamm.Symbol.evaluate_for_shape()`\n        \"\"\"\n        evaluated_children = [child.evaluate_for_shape() for child in self.children]\n        return self._function_evaluate(evaluated_children)\n\n    def _function_evaluate(self, evaluated_children):\n        if self.takes_no_params is True:\n            return self.function()\n        else:\n            return self.function(*evaluated_children)\n\n    def new_copy(self):\n        \"\"\" See :meth:`pybamm.Symbol.new_copy()`. \"\"\"\n        children_copy = [child.new_copy() for child in self.children]\n        return self._function_new_copy(children_copy)\n\n    def _function_new_copy(self, children):\n        \"\"\"Returns a new copy of the function.\n\n        Inputs\n        ------\n        children : : list\n            A list of the children of the function\n\n        Returns\n        -------\n            : :pybamm.Function\n            A new copy of the function\n        \"\"\"\n        return pybamm.Function(\n            self.function, *children, name=self.name, derivative=self.derivative\n        )\n\n    def _function_simplify(self, simplified_children):\n        \"\"\"\n        Simplifies the function.\n\n        Inputs\n        ------\n        simplified_children: : list\n            A list of simplified children of the function\n\n        Returns\n        -------\n         :: pybamm.Scalar() if no children\n         :: pybamm.Function if there are children\n        \"\"\"\n        if self.takes_no_params is True:\n            # If self.function() takes no parameters then we can always simplify it\n            return pybamm.Scalar(self.function())\n        elif isinstance(self.function, pybamm.GetConstantCurrent):\n            # If self.function() is a constant current then simplify to scalar\n            return pybamm.Scalar(self.function.parameters_eval[\"Current [A]\"])\n        else:\n            return pybamm.Function(\n                self.function,\n                *simplified_children,\n                name=self.name,\n                derivative=self.derivative\n            )",
  "class SpecificFunction(Function):\n    \"\"\"\n    Parent class for the specific functions, which implement their own `diff`\n    operators directly.\n\n    Parameters\n    ----------\n    function : method\n        Function to be applied to child\n    child : :class:`pybamm.Symbol`\n        The child to apply the function to\n\n    \"\"\"\n\n    def __init__(self, function, child):\n        super().__init__(function, child)\n\n    def _function_new_copy(self, children):\n        \"\"\" See :meth:`pybamm.Function._function_new_copy()` \"\"\"\n        return self.__class__(*children)\n\n    def _function_simplify(self, simplified_children):\n        \"\"\" See :meth:`pybamm.Function._function_simplify()` \"\"\"\n        return self.__class__(*simplified_children)",
  "class Cos(SpecificFunction):\n    \"\"\" Cosine function \"\"\"\n\n    def __init__(self, child):\n        super().__init__(np.cos, child)\n\n    def _diff(self, children):\n        \"\"\" See :meth:`pybamm.Symbol._diff()`. \"\"\"\n        return -Sin(children[0])",
  "def cos(child):\n    \" Returns cosine function of child. \"\n    return Cos(child)",
  "class Cosh(SpecificFunction):\n    \"\"\" Hyberbolic cosine function \"\"\"\n\n    def __init__(self, child):\n        super().__init__(np.cosh, child)\n\n    def _diff(self, children):\n        \"\"\" See :meth:`pybamm.Function._diff()`. \"\"\"\n        return Sinh(children[0])",
  "def cosh(child):\n    \" Returns hyperbolic cosine function of child. \"\n    return Cosh(child)",
  "class Exponential(SpecificFunction):\n    \"\"\" Exponential function \"\"\"\n\n    def __init__(self, child):\n        super().__init__(np.exp, child)\n\n    def _diff(self, children):\n        \"\"\" See :meth:`pybamm.Function._diff()`. \"\"\"\n        return Exponential(children[0])",
  "def exp(child):\n    \" Returns exponential function of child. \"\n    return Exponential(child)",
  "class Log(SpecificFunction):\n    \"\"\" Logarithmic function \"\"\"\n\n    def __init__(self, child):\n        super().__init__(np.log, child)\n\n    def _diff(self, children):\n        \"\"\" See :meth:`pybamm.Function._diff()`. \"\"\"\n        return 1 / children[0]",
  "def log(child):\n    \" Returns logarithmic function of child. \"\n    return Log(child)",
  "def max(child):\n    \" Returns max function of child. \"\n    return Function(np.max, child)",
  "def min(child):\n    \" Returns min function of child. \"\n    return Function(np.min, child)",
  "class Sin(SpecificFunction):\n    \"\"\" Sine function \"\"\"\n\n    def __init__(self, child):\n        super().__init__(np.sin, child)\n\n    def _diff(self, children):\n        \"\"\" See :meth:`pybamm.Function._diff()`. \"\"\"\n        return Cos(children[0])",
  "def sin(child):\n    \" Returns sine function of child. \"\n    return Sin(child)",
  "class Sinh(SpecificFunction):\n    \"\"\" Hyperbolic sine function \"\"\"\n\n    def __init__(self, child):\n        super().__init__(np.sinh, child)\n\n    def _diff(self, children):\n        \"\"\" See :meth:`pybamm.Function._diff()`. \"\"\"\n        return Cosh(children[0])",
  "def sinh(child):\n    \" Returns hyperbolic sine function of child. \"\n    return Sinh(child)",
  "def __init__(self, function, *children, name=None, derivative=\"autograd\"):\n\n        if name is not None:\n            self.name = name\n        else:\n            try:\n                name = \"function ({})\".format(function.__name__)\n            except AttributeError:\n                name = \"function ({})\".format(function.__class__)\n        children_list = list(children)\n        domain = self.get_children_domains(children_list)\n        auxiliary_domains = self.get_children_auxiliary_domains(children)\n\n        self.function = function\n        self.derivative = derivative\n\n        # hack to work out whether function takes any params\n        # (signature doesn't work for numpy)\n        if isinstance(function, np.ufunc):\n            self.takes_no_params = False\n        else:\n            self.takes_no_params = len(signature(function).parameters) == 0\n\n        super().__init__(\n            name,\n            children=children_list,\n            domain=domain,\n            auxiliary_domains=auxiliary_domains,\n        )",
  "def get_children_domains(self, children_list):\n        \"\"\"Obtains the unique domain of the children. If the\n        children have different domains then raise an error\"\"\"\n\n        domains = [child.domain for child in children_list if child.domain != []]\n\n        # check that there is one common domain amongst children\n        distinct_domains = set(tuple(dom) for dom in domains)\n\n        if len(distinct_domains) > 1:\n            raise pybamm.DomainError(\n                \"Functions can only be applied to variables on the same domain\"\n            )\n        elif len(distinct_domains) == 0:\n            domain = []\n        else:\n            domain = domains[0]\n\n        return domain",
  "def diff(self, variable):\n        \"\"\" See :meth:`pybamm.Symbol.diff()`. \"\"\"\n        if variable.id == self.id:\n            return pybamm.Scalar(1)\n        else:\n            children = self.orphans\n            partial_derivatives = [None] * len(children)\n            for i, child in enumerate(self.children):\n                # if variable appears in the function,use autograd to differentiate\n                # function, and apply chain rule\n                if variable.id in [symbol.id for symbol in child.pre_order()]:\n                    partial_derivatives[i] = self._diff(children) * child.diff(variable)\n\n            # remove None entries\n            partial_derivatives = list(filter(None, partial_derivatives))\n\n            derivative = sum(partial_derivatives)\n            if derivative == 0:\n                derivative = pybamm.Scalar(0)\n\n            return derivative",
  "def _diff(self, children):\n        \"\"\" See :meth:`pybamm.Symbol._diff()`. \"\"\"\n        if self.derivative == \"autograd\":\n            return Function(autograd.elementwise_grad(self.function), *children)\n        elif self.derivative == \"derivative\":\n            # keep using \"derivative\" as derivative\n            return pybamm.Function(\n                self.function.derivative(), *children, derivative=\"derivative\"\n            )",
  "def _function_jac(self, children_jacs):\n        \"\"\" Calculate the jacobian of a function. \"\"\"\n\n        if all(child.evaluates_to_number() for child in self.children):\n            jacobian = pybamm.Scalar(0)\n        else:\n            # if at least one child contains variable dependence, then\n            # calculate the required partial jacobians and add them\n            jacobian = None\n            children = self.orphans\n            for i, child in enumerate(children):\n                if not child.evaluates_to_number():\n                    jac_fun = self._diff(children) * children_jacs[i]\n                    jac_fun.domain = []\n                    if jacobian is None:\n                        jacobian = jac_fun\n                    else:\n                        jacobian += jac_fun\n\n        return jacobian",
  "def evaluate(self, t=None, y=None, known_evals=None):\n        \"\"\" See :meth:`pybamm.Symbol.evaluate()`. \"\"\"\n        if known_evals is not None:\n            if self.id not in known_evals:\n                evaluated_children = [None] * len(self.children)\n                for i, child in enumerate(self.children):\n                    evaluated_children[i], known_evals = child.evaluate(\n                        t, y, known_evals\n                    )\n                known_evals[self.id] = self._function_evaluate(evaluated_children)\n            return known_evals[self.id], known_evals\n        else:\n            evaluated_children = [child.evaluate(t, y) for child in self.children]\n            return self._function_evaluate(evaluated_children)",
  "def evaluate_for_shape(self):\n        \"\"\"\n        Default behaviour: has same shape as all child\n        See :meth:`pybamm.Symbol.evaluate_for_shape()`\n        \"\"\"\n        evaluated_children = [child.evaluate_for_shape() for child in self.children]\n        return self._function_evaluate(evaluated_children)",
  "def _function_evaluate(self, evaluated_children):\n        if self.takes_no_params is True:\n            return self.function()\n        else:\n            return self.function(*evaluated_children)",
  "def new_copy(self):\n        \"\"\" See :meth:`pybamm.Symbol.new_copy()`. \"\"\"\n        children_copy = [child.new_copy() for child in self.children]\n        return self._function_new_copy(children_copy)",
  "def _function_new_copy(self, children):\n        \"\"\"Returns a new copy of the function.\n\n        Inputs\n        ------\n        children : : list\n            A list of the children of the function\n\n        Returns\n        -------\n            : :pybamm.Function\n            A new copy of the function\n        \"\"\"\n        return pybamm.Function(\n            self.function, *children, name=self.name, derivative=self.derivative\n        )",
  "def _function_simplify(self, simplified_children):\n        \"\"\"\n        Simplifies the function.\n\n        Inputs\n        ------\n        simplified_children: : list\n            A list of simplified children of the function\n\n        Returns\n        -------\n         :: pybamm.Scalar() if no children\n         :: pybamm.Function if there are children\n        \"\"\"\n        if self.takes_no_params is True:\n            # If self.function() takes no parameters then we can always simplify it\n            return pybamm.Scalar(self.function())\n        elif isinstance(self.function, pybamm.GetConstantCurrent):\n            # If self.function() is a constant current then simplify to scalar\n            return pybamm.Scalar(self.function.parameters_eval[\"Current [A]\"])\n        else:\n            return pybamm.Function(\n                self.function,\n                *simplified_children,\n                name=self.name,\n                derivative=self.derivative\n            )",
  "def __init__(self, function, child):\n        super().__init__(function, child)",
  "def _function_new_copy(self, children):\n        \"\"\" See :meth:`pybamm.Function._function_new_copy()` \"\"\"\n        return self.__class__(*children)",
  "def _function_simplify(self, simplified_children):\n        \"\"\" See :meth:`pybamm.Function._function_simplify()` \"\"\"\n        return self.__class__(*simplified_children)",
  "def __init__(self, child):\n        super().__init__(np.cos, child)",
  "def _diff(self, children):\n        \"\"\" See :meth:`pybamm.Symbol._diff()`. \"\"\"\n        return -Sin(children[0])",
  "def __init__(self, child):\n        super().__init__(np.cosh, child)",
  "def _diff(self, children):\n        \"\"\" See :meth:`pybamm.Function._diff()`. \"\"\"\n        return Sinh(children[0])",
  "def __init__(self, child):\n        super().__init__(np.exp, child)",
  "def _diff(self, children):\n        \"\"\" See :meth:`pybamm.Function._diff()`. \"\"\"\n        return Exponential(children[0])",
  "def __init__(self, child):\n        super().__init__(np.log, child)",
  "def _diff(self, children):\n        \"\"\" See :meth:`pybamm.Function._diff()`. \"\"\"\n        return 1 / children[0]",
  "def __init__(self, child):\n        super().__init__(np.sin, child)",
  "def _diff(self, children):\n        \"\"\" See :meth:`pybamm.Function._diff()`. \"\"\"\n        return Cos(children[0])",
  "def __init__(self, child):\n        super().__init__(np.sinh, child)",
  "def _diff(self, children):\n        \"\"\" See :meth:`pybamm.Function._diff()`. \"\"\"\n        return Cosh(children[0])",
  "def domain_size(domain):\n    \"\"\"\n    Get the domain size.\n\n    Empty domain has size 1.\n    If the domain falls within the list of standard battery domains, the size is read\n    from a dictionary of standard domain sizes. Otherwise, the hash of the domain string\n    is used to generate a `random` domain size.\n    \"\"\"\n    fixed_domain_sizes = {\n        \"current collector\": 3,\n        \"negative particle\": 5,\n        \"positive particle\": 7,\n        \"negative electrode\": 11,\n        \"separator\": 13,\n        \"positive electrode\": 17,\n    }\n    if isinstance(domain, str):\n        domain = [domain]\n    if domain in [[], None]:\n        size = 1\n    elif all(dom in fixed_domain_sizes for dom in domain):\n        size = sum(fixed_domain_sizes[dom] for dom in domain)\n    else:\n        size = sum(hash(dom) % 100 for dom in domain)\n    return size",
  "def create_object_of_size(size, typ=\"vector\"):\n    \"Return object, consisting of NaNs, of the right shape\"\n    if typ == \"vector\":\n        return np.nan * np.ones((size, 1))\n    elif typ == \"matrix\":\n        return np.nan * np.ones((size, size))",
  "def evaluate_for_shape_using_domain(domain, auxiliary_domains=None, typ=\"vector\"):\n    \"\"\"\n    Return a vector of the appropriate shape, based on the domain.\n    Domain 'sizes' can clash, but are unlikely to, and won't cause failures if they do.\n    \"\"\"\n    _domain_size = domain_size(domain)\n    if auxiliary_domains is None:\n        _auxiliary_domain_sizes = 1\n    else:\n        _auxiliary_domain_sizes = int(\n            np.prod([domain_size(dom) for dom in auxiliary_domains.values()])\n        )\n    return create_object_of_size(_domain_size * _auxiliary_domain_sizes, typ)",
  "class Symbol(anytree.NodeMixin):\n    \"\"\"Base node class for the expression tree\n\n    Parameters\n    ----------\n\n    name : str\n        name for the node\n    children : iterable :class:`Symbol`, optional\n        children to attach to this node, default to an empty list\n    domain : iterable of str, or str\n        list of domains over which the node is valid (empty list indicates the symbol\n        is valid over all domains)\n    auxiliary_domains : dict of str\n        dictionary of auxiliary domains over which the node is valid (empty dictionary\n        indicates no auxiliary domains). Keys can be \"secondary\" or \"tertiary\". The\n        symbol is broadcast over its auxiliary domains.\n        For example, a symbol might have domain \"negative particle\", secondary domain\n        \"separator\" and tertiary domain \"current collector\" (`domain=\"negative\n        particle\", auxiliary_domains={\"secondary\": \"separator\", \"tertiary\": \"current\n        collector\"}`).\n\n    \"\"\"\n\n    def __init__(self, name, children=None, domain=None, auxiliary_domains=None):\n        super(Symbol, self).__init__()\n        self.name = name\n\n        if children is None:\n            children = []\n        if domain is None:\n            domain = []\n        elif isinstance(domain, str):\n            domain = [domain]\n        if auxiliary_domains is None:\n            auxiliary_domains = {}\n        for level, dom in auxiliary_domains.items():\n            if isinstance(dom, str):\n                auxiliary_domains[level] = [dom]\n\n        for child in children:\n            # copy child before adding\n            # this also adds copy.copy(child) to self.children\n            copy.copy(child).parent = self\n\n        # cache children\n        self.cached_children = super(Symbol, self).children\n\n        # Set auxiliary domains\n        self.auxiliary_domains = auxiliary_domains\n        # Set domain (and hence id)\n        self.domain = domain\n\n        # Test shape on everything but nodes that contain the base Symbol class or\n        # the base BinaryOperator class\n        if pybamm.settings.debug_mode is True:\n            if not any(\n                issubclass(pybamm.Symbol, type(x))\n                or issubclass(pybamm.BinaryOperator, type(x))\n                for x in self.pre_order()\n            ):\n                self.test_shape()\n\n    @property\n    def children(self):\n        \"\"\"\n        returns the cached children of this node.\n\n        Note: it is assumed that children of a node are not modified after initial\n        creation\n\n        \"\"\"\n        return self.cached_children\n\n    @property\n    def name(self):\n        \"\"\"name of the node\"\"\"\n        return self._name\n\n    @name.setter\n    def name(self, value):\n        assert isinstance(value, str)\n        self._name = value\n\n    @property\n    def domain(self):\n        \"\"\"list of applicable domains\n\n        Returns\n        -------\n            iterable of str\n        \"\"\"\n        return self._domain\n\n    @domain.setter\n    def domain(self, domain):\n        if isinstance(domain, str):\n            domain = [domain]\n        try:\n            iter(domain)\n        except TypeError:\n            raise TypeError(\"Domain: argument domain is not iterable\")\n        else:\n            self._domain = domain\n            # Update id since domain has changed\n            self.set_id()\n\n    def get_children_auxiliary_domains(self, children):\n        \"Combine auxiliary domains from children, at all levels\"\n        aux_domains = {}\n        for child in children:\n            for level in child.auxiliary_domains.keys():\n                if (\n                    level not in aux_domains\n                    or aux_domains[level] == []\n                    or child.auxiliary_domains[level] == aux_domains[level]\n                ):\n                    aux_domains[level] = child.auxiliary_domains[level]\n                else:\n                    raise pybamm.DomainError(\n                        \"\"\"children must have same or empty auxiliary domains,\n                        not {!s} and {!s}\"\"\".format(\n                            aux_domains[level], child.auxiliary_domains[level]\n                        )\n                    )\n\n        return aux_domains\n\n    @property\n    def id(self):\n        return self._id\n\n    def set_id(self):\n        \"\"\"\n        Set the immutable \"identity\" of a variable (e.g. for identifying y_slices).\n\n        This is identical to what we'd put in a __hash__ function\n        However, implementing __hash__ requires also implementing __eq__,\n        which would then mess with loop-checking in the anytree module.\n\n        Hashing can be slow, so we set the id when we create the node, and hence only\n        need to hash once.\n        \"\"\"\n        self._id = hash(\n            (self.__class__, self.name)\n            + tuple([child.id for child in self.children])\n            + tuple(self.domain)\n            + tuple([(k, tuple(v)) for k, v in self.auxiliary_domains.items()])\n        )\n\n    @property\n    def orphans(self):\n        \"\"\"\n        Returning new copies of the children, with parents removed to avoid corrupting\n        the expression tree internal data\n        \"\"\"\n        return tuple([child.new_copy() for child in self.children])\n\n    def render(self):  # pragma: no cover\n        \"\"\"print out a visual representation of the tree (this node and its\n        children)\n        \"\"\"\n        for pre, _, node in anytree.RenderTree(self):\n            if isinstance(node, pybamm.Scalar) and node.name != str(node.value):\n                print(\"{}{} = {}\".format(pre, node.name, node.value))\n            else:\n                print(\"{}{}\".format(pre, node.name))\n\n    def visualise(self, filename):\n        \"\"\"\n        Produces a .png file of the tree (this node and its children) with the\n        name filename\n\n        Parameters\n        ----------\n\n        filename : str\n            filename to output, must end in \".png\"\n\n        \"\"\"\n\n        # check that filename ends in .png.\n        if filename[-4:] != \".png\":\n            raise ValueError(\"filename should end in .png\")\n\n        new_node, counter = self.relabel_tree(self, 0)\n\n        DotExporter(\n            new_node, nodeattrfunc=lambda node: 'label=\"{}\"'.format(node.label)\n        ).to_picture(filename)\n\n    def relabel_tree(self, symbol, counter):\n        \"\"\" Finds all children of a symbol and assigns them a new id so that they can be\n                visualised properly using the graphviz output\n        \"\"\"\n        name = symbol.name\n        if name == \"div\":\n            name = \"&nabla;&sdot;\"\n        elif name == \"grad\":\n            name = \"&nabla;\"\n        elif name == \"/\":\n            name = \"&divide;\"\n        elif name == \"*\":\n            name = \"&times;\"\n        elif name == \"-\":\n            name = \"&minus;\"\n        elif name == \"+\":\n            name = \"&#43;\"\n        elif name == \"**\":\n            name = \"^\"\n        elif name == \"epsilon_s\":\n            name = \"&#603;\"\n\n        new_node = anytree.Node(str(counter), label=name)\n        counter += 1\n\n        new_children = []\n        for child in symbol.children:\n            new_child, counter = self.relabel_tree(child, counter)\n            new_children.append(new_child)\n        new_node.children = new_children\n\n        return new_node, counter\n\n    def pre_order(self):\n        \"\"\"returns an iterable that steps through the tree in pre-order\n        fashion\n\n        Examples\n        --------\n\n        >>> import pybamm\n        >>> a = pybamm.Symbol('a')\n        >>> b = pybamm.Symbol('b')\n        >>> for node in (a*b).pre_order():\n        ...     print(node.name)\n        *\n        a\n        b\n\n        \"\"\"\n        return anytree.PreOrderIter(self)\n\n    def __str__(self):\n        \"\"\"return a string representation of the node and its children\"\"\"\n        return self._name\n\n    def __repr__(self):\n        \"\"\"returns the string `__class__(id, name, children, domain)`\"\"\"\n        return (\n            \"{!s}({}, {!s}, children={!s}, domain={!s}, auxiliary_domains={!s})\"\n        ).format(\n            self.__class__.__name__,\n            hex(self.id),\n            self._name,\n            [str(child) for child in self.children],\n            [str(subdomain) for subdomain in self.domain],\n            {k: str(v) for k, v in self.auxiliary_domains.items()},\n        )\n\n    def __add__(self, other):\n        \"\"\"return an :class:`Addition` object\"\"\"\n        if isinstance(other, (Symbol, numbers.Number)):\n            return pybamm.Addition(self, other)\n        else:\n            raise NotImplementedError\n\n    def __radd__(self, other):\n        \"\"\"return an :class:`Addition` object\"\"\"\n        if isinstance(other, (Symbol, numbers.Number)):\n            return pybamm.Addition(other, self)\n        else:\n            raise NotImplementedError\n\n    def __sub__(self, other):\n        \"\"\"return a :class:`Subtraction` object\"\"\"\n        if isinstance(other, (Symbol, numbers.Number)):\n            return pybamm.Subtraction(self, other)\n        else:\n            raise NotImplementedError\n\n    def __rsub__(self, other):\n        \"\"\"return a :class:`Subtraction` object\"\"\"\n        if isinstance(other, (Symbol, numbers.Number)):\n            return pybamm.Subtraction(other, self)\n        else:\n            raise NotImplementedError\n\n    def __mul__(self, other):\n        \"\"\"return a :class:`Multiplication` object\"\"\"\n        if isinstance(other, (Symbol, numbers.Number)):\n            return pybamm.Multiplication(self, other)\n        else:\n            raise NotImplementedError\n\n    def __rmul__(self, other):\n        \"\"\"return a :class:`Multiplication` object\"\"\"\n        if isinstance(other, (Symbol, numbers.Number)):\n            return pybamm.Multiplication(other, self)\n        else:\n            raise NotImplementedError\n\n    def __matmul__(self, other):\n        \"\"\"return a :class:`MatrixMultiplication` object\"\"\"\n        if isinstance(other, (Symbol, numbers.Number)):\n            return pybamm.MatrixMultiplication(self, other)\n        else:\n            raise NotImplementedError\n\n    def __rmatmul__(self, other):\n        \"\"\"return a :class:`MatrixMultiplication` object\"\"\"\n        if isinstance(other, (Symbol, numbers.Number)):\n            return pybamm.MatrixMultiplication(other, self)\n        else:\n            raise NotImplementedError\n\n    def __truediv__(self, other):\n        \"\"\"return a :class:`Division` object\"\"\"\n        if isinstance(other, (Symbol, numbers.Number)):\n            return pybamm.Division(self, other)\n        else:\n            raise NotImplementedError\n\n    def __rtruediv__(self, other):\n        \"\"\"return a :class:`Division` object\"\"\"\n        if isinstance(other, (Symbol, numbers.Number)):\n            return pybamm.Division(other, self)\n        else:\n            raise NotImplementedError\n\n    def __pow__(self, other):\n        \"\"\"return a :class:`Power` object\"\"\"\n        if isinstance(other, (Symbol, numbers.Number)):\n            return pybamm.Power(self, other)\n        else:\n            raise NotImplementedError\n\n    def __rpow__(self, other):\n        \"\"\"return a :class:`Power` object\"\"\"\n        if isinstance(other, (Symbol, numbers.Number)):\n            return pybamm.Power(other, self)\n        else:\n            raise NotImplementedError\n\n    def __neg__(self):\n        \"\"\"return a :class:`Negate` object\"\"\"\n        return pybamm.Negate(self)\n\n    def __abs__(self):\n        \"\"\"return an :class:`AbsoluteValue` object\"\"\"\n        return pybamm.AbsoluteValue(self)\n\n    def __getitem__(self, key):\n        \"\"\"return a :class:`Index` object\"\"\"\n        return pybamm.Index(self, key)\n\n    def diff(self, variable):\n        \"\"\"\n        Differentiate a symbol with respect to a variable. For any symbol that can be\n        differentiated, return `1` if differentiating with respect to yourself,\n        `self._diff(variable)` if `variable` is in the expression tree of the symbol,\n        and zero otherwise.\n\n        Parameters\n        ----------\n        variable : :class:`pybamm.Symbol`\n            The variable with respect to which to differentiate\n\n        \"\"\"\n        if variable.id == self.id:\n            return pybamm.Scalar(1)\n        elif any(variable.id == x.id for x in self.pre_order()):\n            return self._diff(variable)\n        else:\n            return pybamm.Scalar(0)\n\n    def _diff(self, variable):\n        \"Default behaviour for differentiation, overriden by Binary and Unary Operators\"\n        raise NotImplementedError\n\n    def jac(self, variable, known_jacs=None):\n        \"\"\"\n        Differentiate a symbol with respect to a (slice of) a State Vector.\n        See :class:`pybamm.Jacobian`.\n        \"\"\"\n        return pybamm.Jacobian(known_jacs).jac(self, variable)\n\n    def _jac(self, variable):\n        \"\"\"\n        Default behaviour for jacobian, will raise a ``NotImplementedError``\n        if this member function has not been defined for the node.\n        \"\"\"\n        raise NotImplementedError\n\n    def _base_evaluate(self, t=None, y=None):\n        \"\"\"evaluate expression tree\n\n        will raise a ``NotImplementedError`` if this member function has not\n        been defined for the node. For example, :class:`Scalar` returns its\n        scalar value, but :class:`Variable` will raise ``NotImplementedError``\n\n        Parameters\n        ----------\n\n        t : float or numeric type, optional\n            time at which to evaluate (default None)\n\n        y : numpy.array, optional\n            array to evaluate when solving (default None)\n\n        \"\"\"\n        raise NotImplementedError(\n            \"\"\"method self.evaluate() not implemented\n               for symbol {!s} of type {}\"\"\".format(\n                self, type(self)\n            )\n        )\n\n    def evaluate(self, t=None, y=None, known_evals=None):\n        \"\"\"Evaluate expression tree (wrapper to allow using dict of known values).\n        If the dict 'known_evals' is provided, the dict is searched for self.id; if\n        self.id is in the keys, return that value; otherwise, evaluate using\n        :meth:`_base_evaluate()` and add that value to known_evals\n\n        Parameters\n        ----------\n        t : float or numeric type, optional\n            time at which to evaluate (default None)\n        y : numpy.array, optional\n            array to evaluate when solving (default None)\n        known_evals : dict, optional\n            dictionary containing known values (default None)\n\n        Returns\n        -------\n        number or array\n            the node evaluated at (t,y)\n        known_evals (if known_evals input is not None) : dict\n            the dictionary of known values\n        \"\"\"\n        if known_evals is not None:\n            if self.id not in known_evals:\n                known_evals[self.id] = self._base_evaluate(t, y)\n            return known_evals[self.id], known_evals\n        else:\n            return self._base_evaluate(t, y)\n\n    def evaluate_for_shape(self):\n        \"\"\"Evaluate expression tree to find its shape. For symbols that cannot be\n        evaluated directly (e.g. `Variable` or `Parameter`), a vector of the appropriate\n        shape is returned instead, using the symbol's domain.\n        See :meth:`pybamm.Symbol.evaluate()`\n        \"\"\"\n        return self.evaluate()\n\n    def is_constant(self):\n        \"\"\"returns true if evaluating the expression is not dependent on `t` or `y`\n\n        See Also\n        --------\n        evaluate : evaluate the expression\n\n        \"\"\"\n        # if any of the nodes are instances of any of these types, then the whole\n        # expression depends on either t or y\n        search_types = (pybamm.Variable, pybamm.StateVector, pybamm.IndependentVariable)\n\n        # do the search, return true if no relevent nodes are found\n        return not any((isinstance(n, search_types)) for n in self.pre_order())\n\n    def evaluate_ignoring_errors(self):\n        \"\"\"\n        Evaluates the expression. If a node exists in the tree that cannot be evaluated\n        as a scalar or vectr (e.g. Parameter, Variable, StateVector), then None is\n        returned. Otherwise the result of the evaluation is given\n\n        See Also\n        --------\n        evaluate : evaluate the expression\n\n        \"\"\"\n        try:\n            result = self.evaluate(t=0)\n        except NotImplementedError:\n            # return false if NotImplementedError is raised\n            # (there is a e.g. Parameter, Variable, ... in the tree)\n            return None\n        except TypeError as error:\n            # return false if specific TypeError is raised\n            # (there is a e.g. StateVector in the tree)\n            if error.args[0] == \"StateVector cannot evaluate input 'y=None'\":\n                return None\n            else:\n                raise error\n\n        return result\n\n    def evaluates_to_number(self):\n        \"\"\"\n        Returns True if evaluating the expression returns a number.\n        Returns False otherwise, including if NotImplementedError or TyperError\n        is raised.\n        !Not to be confused with isinstance(self, pybamm.Scalar)!\n\n        See Also\n        --------\n        evaluate : evaluate the expression\n\n        \"\"\"\n        result = self.evaluate_ignoring_errors()\n\n        if isinstance(result, numbers.Number):\n            return True\n        else:\n            return False\n\n    def evaluates_on_edges(self):\n        \"\"\"\n        Returns True if a symbol evaluates on an edge, i.e. symbol contains a gradient\n        operator, but not a divergence operator, and is not an IndefiniteIntegral.\n        \"\"\"\n        # Default behaviour: return False\n        return False\n\n    def has_symbol_of_classes(self, symbol_classes):\n        \"\"\"Returns True if equation has a term of the class(es) `symbol_class`.\n\n        Parameters\n        ----------\n        symbol_classes : pybamm class or iterable of classes\n            The classes to test the symbol against\n        \"\"\"\n        return any(isinstance(symbol, symbol_classes) for symbol in self.pre_order())\n\n    def simplify(self, simplified_symbols=None):\n        \"\"\" Simplify the expression tree. See :class:`pybamm.Simplification`. \"\"\"\n        return pybamm.Simplification(simplified_symbols).simplify(self)\n\n    def new_copy(self):\n        \"\"\"\n        Make a new copy of a symbol, to avoid Tree corruption errors while bypassing\n        copy.deepcopy(), which is slow.\n        \"\"\"\n        raise NotImplementedError(\n            \"\"\"method self.new_copy() not implemented\n               for symbol {!s} of type {}\"\"\".format(\n                self, type(self)\n            )\n        )\n\n    @property\n    def size(self):\n        \"\"\"\n        Size of an object, found by evaluating it with appropriate t and y\n        \"\"\"\n        return np.prod(self.shape)\n\n    @property\n    def shape(self):\n        \"\"\"\n        Shape of an object, found by evaluating it with appropriate t and y.\n        \"\"\"\n        # Default behaviour is to try to evaluate the object directly\n        # Try with some large y, to avoid having to use pre_order (slow)\n        try:\n            y = np.linspace(0.1, 0.9, int(1e4))\n            evaluated_self = self.evaluate(0, y)\n        # If that fails, fall back to calculating how big y should really be\n        except ValueError:\n            state_vectors_in_node = [\n                x for x in self.pre_order() if isinstance(x, pybamm.StateVector)\n            ]\n            if state_vectors_in_node == []:\n                y = None\n            else:\n                min_y_size = max(\n                    len(x._evaluation_array) for x in state_vectors_in_node\n                )\n                # Pick a y that won't cause RuntimeWarnings\n                y = np.linspace(0.1, 0.9, min_y_size)\n            evaluated_self = self.evaluate(0, y)\n\n        # Return shape of evaluated object\n        if isinstance(evaluated_self, numbers.Number):\n            return ()\n        else:\n            return evaluated_self.shape\n\n    @property\n    def size_for_testing(self):\n        \"\"\"\n        Size of an object, based on shape for testing\n        \"\"\"\n        return np.prod(self.shape_for_testing)\n\n    @property\n    def shape_for_testing(self):\n        \"\"\"\n        Shape of an object for cases where it cannot be evaluated directly. If a symbol\n        cannot be evaluated directly (e.g. it is a `Variable` or `Parameter`), it is\n        instead given an arbitrary domain-dependent shape.\n        \"\"\"\n        evaluated_self = self.evaluate_for_shape()\n        if isinstance(evaluated_self, numbers.Number):\n            return ()\n        else:\n            return evaluated_self.shape\n\n    def test_shape(self):\n        \"\"\"\n        Check that the discretised self has a pybamm `shape`, i.e. can be evaluated\n\n        Raises\n        ------\n        pybamm.ShapeError\n            If the shape of the object cannot be found\n        \"\"\"\n        try:\n            self.shape_for_testing\n        except ValueError as e:\n            raise pybamm.ShapeError(\"Cannot find shape (original error: {})\".format(e))",
  "def __init__(self, name, children=None, domain=None, auxiliary_domains=None):\n        super(Symbol, self).__init__()\n        self.name = name\n\n        if children is None:\n            children = []\n        if domain is None:\n            domain = []\n        elif isinstance(domain, str):\n            domain = [domain]\n        if auxiliary_domains is None:\n            auxiliary_domains = {}\n        for level, dom in auxiliary_domains.items():\n            if isinstance(dom, str):\n                auxiliary_domains[level] = [dom]\n\n        for child in children:\n            # copy child before adding\n            # this also adds copy.copy(child) to self.children\n            copy.copy(child).parent = self\n\n        # cache children\n        self.cached_children = super(Symbol, self).children\n\n        # Set auxiliary domains\n        self.auxiliary_domains = auxiliary_domains\n        # Set domain (and hence id)\n        self.domain = domain\n\n        # Test shape on everything but nodes that contain the base Symbol class or\n        # the base BinaryOperator class\n        if pybamm.settings.debug_mode is True:\n            if not any(\n                issubclass(pybamm.Symbol, type(x))\n                or issubclass(pybamm.BinaryOperator, type(x))\n                for x in self.pre_order()\n            ):\n                self.test_shape()",
  "def children(self):\n        \"\"\"\n        returns the cached children of this node.\n\n        Note: it is assumed that children of a node are not modified after initial\n        creation\n\n        \"\"\"\n        return self.cached_children",
  "def name(self):\n        \"\"\"name of the node\"\"\"\n        return self._name",
  "def name(self, value):\n        assert isinstance(value, str)\n        self._name = value",
  "def domain(self):\n        \"\"\"list of applicable domains\n\n        Returns\n        -------\n            iterable of str\n        \"\"\"\n        return self._domain",
  "def domain(self, domain):\n        if isinstance(domain, str):\n            domain = [domain]\n        try:\n            iter(domain)\n        except TypeError:\n            raise TypeError(\"Domain: argument domain is not iterable\")\n        else:\n            self._domain = domain\n            # Update id since domain has changed\n            self.set_id()",
  "def get_children_auxiliary_domains(self, children):\n        \"Combine auxiliary domains from children, at all levels\"\n        aux_domains = {}\n        for child in children:\n            for level in child.auxiliary_domains.keys():\n                if (\n                    level not in aux_domains\n                    or aux_domains[level] == []\n                    or child.auxiliary_domains[level] == aux_domains[level]\n                ):\n                    aux_domains[level] = child.auxiliary_domains[level]\n                else:\n                    raise pybamm.DomainError(\n                        \"\"\"children must have same or empty auxiliary domains,\n                        not {!s} and {!s}\"\"\".format(\n                            aux_domains[level], child.auxiliary_domains[level]\n                        )\n                    )\n\n        return aux_domains",
  "def id(self):\n        return self._id",
  "def set_id(self):\n        \"\"\"\n        Set the immutable \"identity\" of a variable (e.g. for identifying y_slices).\n\n        This is identical to what we'd put in a __hash__ function\n        However, implementing __hash__ requires also implementing __eq__,\n        which would then mess with loop-checking in the anytree module.\n\n        Hashing can be slow, so we set the id when we create the node, and hence only\n        need to hash once.\n        \"\"\"\n        self._id = hash(\n            (self.__class__, self.name)\n            + tuple([child.id for child in self.children])\n            + tuple(self.domain)\n            + tuple([(k, tuple(v)) for k, v in self.auxiliary_domains.items()])\n        )",
  "def orphans(self):\n        \"\"\"\n        Returning new copies of the children, with parents removed to avoid corrupting\n        the expression tree internal data\n        \"\"\"\n        return tuple([child.new_copy() for child in self.children])",
  "def render(self):  # pragma: no cover\n        \"\"\"print out a visual representation of the tree (this node and its\n        children)\n        \"\"\"\n        for pre, _, node in anytree.RenderTree(self):\n            if isinstance(node, pybamm.Scalar) and node.name != str(node.value):\n                print(\"{}{} = {}\".format(pre, node.name, node.value))\n            else:\n                print(\"{}{}\".format(pre, node.name))",
  "def visualise(self, filename):\n        \"\"\"\n        Produces a .png file of the tree (this node and its children) with the\n        name filename\n\n        Parameters\n        ----------\n\n        filename : str\n            filename to output, must end in \".png\"\n\n        \"\"\"\n\n        # check that filename ends in .png.\n        if filename[-4:] != \".png\":\n            raise ValueError(\"filename should end in .png\")\n\n        new_node, counter = self.relabel_tree(self, 0)\n\n        DotExporter(\n            new_node, nodeattrfunc=lambda node: 'label=\"{}\"'.format(node.label)\n        ).to_picture(filename)",
  "def relabel_tree(self, symbol, counter):\n        \"\"\" Finds all children of a symbol and assigns them a new id so that they can be\n                visualised properly using the graphviz output\n        \"\"\"\n        name = symbol.name\n        if name == \"div\":\n            name = \"&nabla;&sdot;\"\n        elif name == \"grad\":\n            name = \"&nabla;\"\n        elif name == \"/\":\n            name = \"&divide;\"\n        elif name == \"*\":\n            name = \"&times;\"\n        elif name == \"-\":\n            name = \"&minus;\"\n        elif name == \"+\":\n            name = \"&#43;\"\n        elif name == \"**\":\n            name = \"^\"\n        elif name == \"epsilon_s\":\n            name = \"&#603;\"\n\n        new_node = anytree.Node(str(counter), label=name)\n        counter += 1\n\n        new_children = []\n        for child in symbol.children:\n            new_child, counter = self.relabel_tree(child, counter)\n            new_children.append(new_child)\n        new_node.children = new_children\n\n        return new_node, counter",
  "def pre_order(self):\n        \"\"\"returns an iterable that steps through the tree in pre-order\n        fashion\n\n        Examples\n        --------\n\n        >>> import pybamm\n        >>> a = pybamm.Symbol('a')\n        >>> b = pybamm.Symbol('b')\n        >>> for node in (a*b).pre_order():\n        ...     print(node.name)\n        *\n        a\n        b\n\n        \"\"\"\n        return anytree.PreOrderIter(self)",
  "def __str__(self):\n        \"\"\"return a string representation of the node and its children\"\"\"\n        return self._name",
  "def __repr__(self):\n        \"\"\"returns the string `__class__(id, name, children, domain)`\"\"\"\n        return (\n            \"{!s}({}, {!s}, children={!s}, domain={!s}, auxiliary_domains={!s})\"\n        ).format(\n            self.__class__.__name__,\n            hex(self.id),\n            self._name,\n            [str(child) for child in self.children],\n            [str(subdomain) for subdomain in self.domain],\n            {k: str(v) for k, v in self.auxiliary_domains.items()},\n        )",
  "def __add__(self, other):\n        \"\"\"return an :class:`Addition` object\"\"\"\n        if isinstance(other, (Symbol, numbers.Number)):\n            return pybamm.Addition(self, other)\n        else:\n            raise NotImplementedError",
  "def __radd__(self, other):\n        \"\"\"return an :class:`Addition` object\"\"\"\n        if isinstance(other, (Symbol, numbers.Number)):\n            return pybamm.Addition(other, self)\n        else:\n            raise NotImplementedError",
  "def __sub__(self, other):\n        \"\"\"return a :class:`Subtraction` object\"\"\"\n        if isinstance(other, (Symbol, numbers.Number)):\n            return pybamm.Subtraction(self, other)\n        else:\n            raise NotImplementedError",
  "def __rsub__(self, other):\n        \"\"\"return a :class:`Subtraction` object\"\"\"\n        if isinstance(other, (Symbol, numbers.Number)):\n            return pybamm.Subtraction(other, self)\n        else:\n            raise NotImplementedError",
  "def __mul__(self, other):\n        \"\"\"return a :class:`Multiplication` object\"\"\"\n        if isinstance(other, (Symbol, numbers.Number)):\n            return pybamm.Multiplication(self, other)\n        else:\n            raise NotImplementedError",
  "def __rmul__(self, other):\n        \"\"\"return a :class:`Multiplication` object\"\"\"\n        if isinstance(other, (Symbol, numbers.Number)):\n            return pybamm.Multiplication(other, self)\n        else:\n            raise NotImplementedError",
  "def __matmul__(self, other):\n        \"\"\"return a :class:`MatrixMultiplication` object\"\"\"\n        if isinstance(other, (Symbol, numbers.Number)):\n            return pybamm.MatrixMultiplication(self, other)\n        else:\n            raise NotImplementedError",
  "def __rmatmul__(self, other):\n        \"\"\"return a :class:`MatrixMultiplication` object\"\"\"\n        if isinstance(other, (Symbol, numbers.Number)):\n            return pybamm.MatrixMultiplication(other, self)\n        else:\n            raise NotImplementedError",
  "def __truediv__(self, other):\n        \"\"\"return a :class:`Division` object\"\"\"\n        if isinstance(other, (Symbol, numbers.Number)):\n            return pybamm.Division(self, other)\n        else:\n            raise NotImplementedError",
  "def __rtruediv__(self, other):\n        \"\"\"return a :class:`Division` object\"\"\"\n        if isinstance(other, (Symbol, numbers.Number)):\n            return pybamm.Division(other, self)\n        else:\n            raise NotImplementedError",
  "def __pow__(self, other):\n        \"\"\"return a :class:`Power` object\"\"\"\n        if isinstance(other, (Symbol, numbers.Number)):\n            return pybamm.Power(self, other)\n        else:\n            raise NotImplementedError",
  "def __rpow__(self, other):\n        \"\"\"return a :class:`Power` object\"\"\"\n        if isinstance(other, (Symbol, numbers.Number)):\n            return pybamm.Power(other, self)\n        else:\n            raise NotImplementedError",
  "def __neg__(self):\n        \"\"\"return a :class:`Negate` object\"\"\"\n        return pybamm.Negate(self)",
  "def __abs__(self):\n        \"\"\"return an :class:`AbsoluteValue` object\"\"\"\n        return pybamm.AbsoluteValue(self)",
  "def __getitem__(self, key):\n        \"\"\"return a :class:`Index` object\"\"\"\n        return pybamm.Index(self, key)",
  "def diff(self, variable):\n        \"\"\"\n        Differentiate a symbol with respect to a variable. For any symbol that can be\n        differentiated, return `1` if differentiating with respect to yourself,\n        `self._diff(variable)` if `variable` is in the expression tree of the symbol,\n        and zero otherwise.\n\n        Parameters\n        ----------\n        variable : :class:`pybamm.Symbol`\n            The variable with respect to which to differentiate\n\n        \"\"\"\n        if variable.id == self.id:\n            return pybamm.Scalar(1)\n        elif any(variable.id == x.id for x in self.pre_order()):\n            return self._diff(variable)\n        else:\n            return pybamm.Scalar(0)",
  "def _diff(self, variable):\n        \"Default behaviour for differentiation, overriden by Binary and Unary Operators\"\n        raise NotImplementedError",
  "def jac(self, variable, known_jacs=None):\n        \"\"\"\n        Differentiate a symbol with respect to a (slice of) a State Vector.\n        See :class:`pybamm.Jacobian`.\n        \"\"\"\n        return pybamm.Jacobian(known_jacs).jac(self, variable)",
  "def _jac(self, variable):\n        \"\"\"\n        Default behaviour for jacobian, will raise a ``NotImplementedError``\n        if this member function has not been defined for the node.\n        \"\"\"\n        raise NotImplementedError",
  "def _base_evaluate(self, t=None, y=None):\n        \"\"\"evaluate expression tree\n\n        will raise a ``NotImplementedError`` if this member function has not\n        been defined for the node. For example, :class:`Scalar` returns its\n        scalar value, but :class:`Variable` will raise ``NotImplementedError``\n\n        Parameters\n        ----------\n\n        t : float or numeric type, optional\n            time at which to evaluate (default None)\n\n        y : numpy.array, optional\n            array to evaluate when solving (default None)\n\n        \"\"\"\n        raise NotImplementedError(\n            \"\"\"method self.evaluate() not implemented\n               for symbol {!s} of type {}\"\"\".format(\n                self, type(self)\n            )\n        )",
  "def evaluate(self, t=None, y=None, known_evals=None):\n        \"\"\"Evaluate expression tree (wrapper to allow using dict of known values).\n        If the dict 'known_evals' is provided, the dict is searched for self.id; if\n        self.id is in the keys, return that value; otherwise, evaluate using\n        :meth:`_base_evaluate()` and add that value to known_evals\n\n        Parameters\n        ----------\n        t : float or numeric type, optional\n            time at which to evaluate (default None)\n        y : numpy.array, optional\n            array to evaluate when solving (default None)\n        known_evals : dict, optional\n            dictionary containing known values (default None)\n\n        Returns\n        -------\n        number or array\n            the node evaluated at (t,y)\n        known_evals (if known_evals input is not None) : dict\n            the dictionary of known values\n        \"\"\"\n        if known_evals is not None:\n            if self.id not in known_evals:\n                known_evals[self.id] = self._base_evaluate(t, y)\n            return known_evals[self.id], known_evals\n        else:\n            return self._base_evaluate(t, y)",
  "def evaluate_for_shape(self):\n        \"\"\"Evaluate expression tree to find its shape. For symbols that cannot be\n        evaluated directly (e.g. `Variable` or `Parameter`), a vector of the appropriate\n        shape is returned instead, using the symbol's domain.\n        See :meth:`pybamm.Symbol.evaluate()`\n        \"\"\"\n        return self.evaluate()",
  "def is_constant(self):\n        \"\"\"returns true if evaluating the expression is not dependent on `t` or `y`\n\n        See Also\n        --------\n        evaluate : evaluate the expression\n\n        \"\"\"\n        # if any of the nodes are instances of any of these types, then the whole\n        # expression depends on either t or y\n        search_types = (pybamm.Variable, pybamm.StateVector, pybamm.IndependentVariable)\n\n        # do the search, return true if no relevent nodes are found\n        return not any((isinstance(n, search_types)) for n in self.pre_order())",
  "def evaluate_ignoring_errors(self):\n        \"\"\"\n        Evaluates the expression. If a node exists in the tree that cannot be evaluated\n        as a scalar or vectr (e.g. Parameter, Variable, StateVector), then None is\n        returned. Otherwise the result of the evaluation is given\n\n        See Also\n        --------\n        evaluate : evaluate the expression\n\n        \"\"\"\n        try:\n            result = self.evaluate(t=0)\n        except NotImplementedError:\n            # return false if NotImplementedError is raised\n            # (there is a e.g. Parameter, Variable, ... in the tree)\n            return None\n        except TypeError as error:\n            # return false if specific TypeError is raised\n            # (there is a e.g. StateVector in the tree)\n            if error.args[0] == \"StateVector cannot evaluate input 'y=None'\":\n                return None\n            else:\n                raise error\n\n        return result",
  "def evaluates_to_number(self):\n        \"\"\"\n        Returns True if evaluating the expression returns a number.\n        Returns False otherwise, including if NotImplementedError or TyperError\n        is raised.\n        !Not to be confused with isinstance(self, pybamm.Scalar)!\n\n        See Also\n        --------\n        evaluate : evaluate the expression\n\n        \"\"\"\n        result = self.evaluate_ignoring_errors()\n\n        if isinstance(result, numbers.Number):\n            return True\n        else:\n            return False",
  "def evaluates_on_edges(self):\n        \"\"\"\n        Returns True if a symbol evaluates on an edge, i.e. symbol contains a gradient\n        operator, but not a divergence operator, and is not an IndefiniteIntegral.\n        \"\"\"\n        # Default behaviour: return False\n        return False",
  "def has_symbol_of_classes(self, symbol_classes):\n        \"\"\"Returns True if equation has a term of the class(es) `symbol_class`.\n\n        Parameters\n        ----------\n        symbol_classes : pybamm class or iterable of classes\n            The classes to test the symbol against\n        \"\"\"\n        return any(isinstance(symbol, symbol_classes) for symbol in self.pre_order())",
  "def simplify(self, simplified_symbols=None):\n        \"\"\" Simplify the expression tree. See :class:`pybamm.Simplification`. \"\"\"\n        return pybamm.Simplification(simplified_symbols).simplify(self)",
  "def new_copy(self):\n        \"\"\"\n        Make a new copy of a symbol, to avoid Tree corruption errors while bypassing\n        copy.deepcopy(), which is slow.\n        \"\"\"\n        raise NotImplementedError(\n            \"\"\"method self.new_copy() not implemented\n               for symbol {!s} of type {}\"\"\".format(\n                self, type(self)\n            )\n        )",
  "def size(self):\n        \"\"\"\n        Size of an object, found by evaluating it with appropriate t and y\n        \"\"\"\n        return np.prod(self.shape)",
  "def shape(self):\n        \"\"\"\n        Shape of an object, found by evaluating it with appropriate t and y.\n        \"\"\"\n        # Default behaviour is to try to evaluate the object directly\n        # Try with some large y, to avoid having to use pre_order (slow)\n        try:\n            y = np.linspace(0.1, 0.9, int(1e4))\n            evaluated_self = self.evaluate(0, y)\n        # If that fails, fall back to calculating how big y should really be\n        except ValueError:\n            state_vectors_in_node = [\n                x for x in self.pre_order() if isinstance(x, pybamm.StateVector)\n            ]\n            if state_vectors_in_node == []:\n                y = None\n            else:\n                min_y_size = max(\n                    len(x._evaluation_array) for x in state_vectors_in_node\n                )\n                # Pick a y that won't cause RuntimeWarnings\n                y = np.linspace(0.1, 0.9, min_y_size)\n            evaluated_self = self.evaluate(0, y)\n\n        # Return shape of evaluated object\n        if isinstance(evaluated_self, numbers.Number):\n            return ()\n        else:\n            return evaluated_self.shape",
  "def size_for_testing(self):\n        \"\"\"\n        Size of an object, based on shape for testing\n        \"\"\"\n        return np.prod(self.shape_for_testing)",
  "def shape_for_testing(self):\n        \"\"\"\n        Shape of an object for cases where it cannot be evaluated directly. If a symbol\n        cannot be evaluated directly (e.g. it is a `Variable` or `Parameter`), it is\n        instead given an arbitrary domain-dependent shape.\n        \"\"\"\n        evaluated_self = self.evaluate_for_shape()\n        if isinstance(evaluated_self, numbers.Number):\n            return ()\n        else:\n            return evaluated_self.shape",
  "def test_shape(self):\n        \"\"\"\n        Check that the discretised self has a pybamm `shape`, i.e. can be evaluated\n\n        Raises\n        ------\n        pybamm.ShapeError\n            If the shape of the object cannot be found\n        \"\"\"\n        try:\n            self.shape_for_testing\n        except ValueError as e:\n            raise pybamm.ShapeError(\"Cannot find shape (original error: {})\".format(e))",
  "class Matrix(pybamm.Array):\n    \"\"\"node in the expression tree that holds a matrix type (e.g. :class:`numpy.array`)\n\n    **Extends:** :class:`Array`\n\n    \"\"\"\n\n    def __init__(\n        self,\n        entries,\n        name=None,\n        domain=None,\n        auxiliary_domains=None,\n        entries_string=None,\n    ):\n        if name is None:\n            name = \"Matrix {!s}\".format(entries.shape)\n            if issparse(entries):\n                name = \"Sparse \" + name\n        super().__init__(entries, name, domain, auxiliary_domains, entries_string)",
  "def __init__(\n        self,\n        entries,\n        name=None,\n        domain=None,\n        auxiliary_domains=None,\n        entries_string=None,\n    ):\n        if name is None:\n            name = \"Matrix {!s}\".format(entries.shape)\n            if issparse(entries):\n                name = \"Sparse \" + name\n        super().__init__(entries, name, domain, auxiliary_domains, entries_string)",
  "class Interpolant(pybamm.Function):\n    \"\"\"\n    Interpolate data in 1D.\n\n    Parameters\n    ----------\n    data : :class:`numpy.ndarray`\n        Numpy array of data to use for interpolation. Must have exactly two columns (x\n        and y data)\n    child : :class:`pybamm.Symbol`\n        Node to use when evaluating the interpolant\n    name : str, optional\n        Name of the interpolant. Default is None, in which case the name \"interpolating\n        function\" is given.\n    interpolator : str, optional\n        Which interpolator to use (\"pchip\" or \"cubic spline\"). Note that whichever\n        interpolator is used must be differentiable (for ``Interpolator._diff``).\n        Default is \"cubic spline\". Note that \"pchip\" may give slow results.\n    extrapolate : bool, optional\n        Whether to extrapolate for points that are outside of the parametrisation\n        range, or return NaN (following default behaviour from scipy). Default is True.\n\n    **Extends**: :class:`pybamm.Function`\n    \"\"\"\n\n    def __init__(\n        self, data, child, name=None, interpolator=\"cubic spline\", extrapolate=True\n    ):\n        if data.ndim != 2 or data.shape[1] != 2:\n            raise ValueError(\n                \"\"\"\n                data should have exactly two columns (x and y) but has shape {}\n                \"\"\".format(\n                    data.shape\n                )\n            )\n        elif interpolator == \"pchip\":\n            interpolating_function = interpolate.PchipInterpolator(\n                data[:, 0], data[:, 1], extrapolate=extrapolate\n            )\n        elif interpolator == \"cubic spline\":\n            interpolating_function = interpolate.CubicSpline(\n                data[:, 0], data[:, 1], extrapolate=extrapolate\n            )\n        else:\n            raise ValueError(\"interpolator '{}' not recognised\".format(interpolator))\n        # Set name\n        if name is not None:\n            name = \"interpolating function ({})\".format(name)\n        else:\n            name = \"interpolating function\"\n        super().__init__(\n            interpolating_function, child, name=name, derivative=\"derivative\"\n        )\n        # Store information as attributes\n        self.interpolator = interpolator\n        self.extrapolate = extrapolate",
  "def __init__(\n        self, data, child, name=None, interpolator=\"cubic spline\", extrapolate=True\n    ):\n        if data.ndim != 2 or data.shape[1] != 2:\n            raise ValueError(\n                \"\"\"\n                data should have exactly two columns (x and y) but has shape {}\n                \"\"\".format(\n                    data.shape\n                )\n            )\n        elif interpolator == \"pchip\":\n            interpolating_function = interpolate.PchipInterpolator(\n                data[:, 0], data[:, 1], extrapolate=extrapolate\n            )\n        elif interpolator == \"cubic spline\":\n            interpolating_function = interpolate.CubicSpline(\n                data[:, 0], data[:, 1], extrapolate=extrapolate\n            )\n        else:\n            raise ValueError(\"interpolator '{}' not recognised\".format(interpolator))\n        # Set name\n        if name is not None:\n            name = \"interpolating function ({})\".format(name)\n        else:\n            name = \"interpolating function\"\n        super().__init__(\n            interpolating_function, child, name=name, derivative=\"derivative\"\n        )\n        # Store information as attributes\n        self.interpolator = interpolator\n        self.extrapolate = extrapolate",
  "class UnaryOperator(pybamm.Symbol):\n    \"\"\"A node in the expression tree representing a unary operator\n    (e.g. '-', grad, div)\n\n    Derived classes will specify the particular operator\n\n    **Extends:** :class:`Symbol`\n\n    Parameters\n    ----------\n    name : str\n        name of the node\n    child : :class:`Symbol`\n        child node\n\n    \"\"\"\n\n    def __init__(self, name, child, domain=None, auxiliary_domains=None):\n        if domain is None:\n            domain = child.domain\n        if auxiliary_domains is None:\n            auxiliary_domains = child.auxiliary_domains\n        super().__init__(\n            name, children=[child], domain=domain, auxiliary_domains=auxiliary_domains\n        )\n        self.child = self.children[0]\n\n    def __str__(self):\n        \"\"\" See :meth:`pybamm.Symbol.__str__()`. \"\"\"\n        return \"{}({!s})\".format(self.name, self.child)\n\n    def new_copy(self):\n        \"\"\" See :meth:`pybamm.Symbol.new_copy()`. \"\"\"\n        new_child = self.child.new_copy()\n        return self._unary_new_copy(new_child)\n\n    def _unary_new_copy(self, child):\n        \"\"\"Make a new copy of the unary operator, with child `child`\"\"\"\n\n        return self.__class__(child)\n\n    def _unary_jac(self, child_jac):\n        \"\"\" Calculate the jacobian of a unary operator. \"\"\"\n        raise NotImplementedError\n\n    def _unary_simplify(self, simplified_child):\n        \"\"\"\n        Simplify a unary operator. Default behaviour is to make a new copy, with\n        simplified child.\n        \"\"\"\n\n        return self._unary_new_copy(simplified_child)\n\n    def _unary_evaluate(self, child):\n        \"\"\"Perform unary operation on a child. \"\"\"\n        raise NotImplementedError\n\n    def evaluate(self, t=None, y=None, known_evals=None):\n        \"\"\" See :meth:`pybamm.Symbol.evaluate()`. \"\"\"\n        if known_evals is not None:\n            if self.id not in known_evals:\n                child, known_evals = self.child.evaluate(t, y, known_evals)\n                known_evals[self.id] = self._unary_evaluate(child)\n            return known_evals[self.id], known_evals\n        else:\n            child = self.child.evaluate(t, y)\n            return self._unary_evaluate(child)\n\n    def evaluate_for_shape(self):\n        \"\"\"\n        Default behaviour: unary operator has same shape as child\n        See :meth:`pybamm.Symbol.evaluate_for_shape()`\n        \"\"\"\n        return self.children[0].evaluate_for_shape()\n\n    def evaluates_on_edges(self):\n        \"\"\" See :meth:`pybamm.Symbol.evaluates_on_edges()`. \"\"\"\n        return self.child.evaluates_on_edges()",
  "class Negate(UnaryOperator):\n    \"\"\"A node in the expression tree representing a `-` negation operator\n\n    **Extends:** :class:`UnaryOperator`\n    \"\"\"\n\n    def __init__(self, child):\n        \"\"\" See :meth:`pybamm.UnaryOperator.__init__()`. \"\"\"\n        super().__init__(\"-\", child)\n\n    def __str__(self):\n        \"\"\" See :meth:`pybamm.Symbol.__str__()`. \"\"\"\n        return \"{}{!s}\".format(self.name, self.child)\n\n    def _diff(self, variable):\n        \"\"\" See :meth:`pybamm.Symbol._diff()`. \"\"\"\n        return -self.child.diff(variable)\n\n    def _unary_jac(self, child_jac):\n        \"\"\" See :meth:`pybamm.UnaryOperator._unary_jac()`. \"\"\"\n        return -child_jac\n\n    def _unary_evaluate(self, child):\n        \"\"\" See :meth:`UnaryOperator._unary_evaluate()`. \"\"\"\n        return -child",
  "class AbsoluteValue(UnaryOperator):\n    \"\"\"A node in the expression tree representing an `abs` operator\n\n    **Extends:** :class:`UnaryOperator`\n    \"\"\"\n\n    def __init__(self, child):\n        \"\"\" See :meth:`pybamm.UnaryOperator.__init__()`. \"\"\"\n        super().__init__(\"abs\", child)\n\n    def diff(self, variable):\n        \"\"\" See :meth:`pybamm.Symbol.diff()`. \"\"\"\n        # Derivative is not well-defined\n        raise pybamm.UndefinedOperationError(\n            \"Derivative of absolute function is not defined\"\n        )\n\n    def _unary_jac(self, child_jac):\n        \"\"\" See :meth:`pybamm.UnaryOperator._unary_jac()`. \"\"\"\n        # Derivative is not well-defined\n        raise pybamm.UndefinedOperationError(\n            \"Derivative of absolute function is not defined\"\n        )\n\n    def _unary_evaluate(self, child):\n        \"\"\" See :meth:`UnaryOperator._unary_evaluate()`. \"\"\"\n        return np.abs(child)",
  "class Index(UnaryOperator):\n    \"\"\"A node in the expression tree, which stores the index that should be\n    extracted from its child after the child has been evaluated.\n\n    Parameters\n    ----------\n    child : :class:`pybamm.Symbol`\n        The symbol of which to take the index\n    index : int or slice\n        The index (if int) or indices (if slice) to extract from the symbol\n    name : str, optional\n        The name of the symbol\n    check_size : bool, optional\n        Whether to check if the slice size exceeds the child size. Default is True.\n        This should always be True when creating a new symbol so that the appropriate\n        check is performed, but should be False for creating a new copy to avoid\n        unnecessarily repeating the check.\n    \"\"\"\n\n    def __init__(self, child, index, name=None, check_size=True):\n        self.index = index\n        if index == -1:\n            self.slice = slice(index, None)\n            if name is None:\n                name = \"Index[-1]\"\n        elif isinstance(index, int):\n            self.slice = slice(index, index + 1)\n            if name is None:\n                name = \"Index[\" + str(index) + \"]\"\n        elif isinstance(index, slice):\n            self.slice = index\n            if name is None:\n                if index.start is None:\n                    name = \"Index[:{:d}]\".format(index.stop)\n                else:\n                    name = \"Index[{:d}:{:d}]\".format(index.start, index.stop)\n        else:\n            raise TypeError(\"index must be integer or slice\")\n\n        if check_size:\n            if self.slice in (slice(0, 1), slice(-1, None)):\n                pass\n            elif self.slice.stop > child.size:\n                raise ValueError(\"slice size exceeds child size\")\n\n        super().__init__(name, child)\n\n        # no domain for integer value\n        if isinstance(index, int):\n            self.domain = []\n\n    def _unary_jac(self, child_jac):\n        \"\"\" See :meth:`pybamm.UnaryOperator._unary_jac()`. \"\"\"\n\n        # if child.jac returns a matrix of zeros, this subsequently gives a bug\n        # when trying to simplify the node Index(child_jac). Instead, search the\n        # tree for StateVectors and return a matrix of zeros of the correct size\n        # if none are found.\n        if all([not (isinstance(n, pybamm.StateVector)) for n in self.pre_order()]):\n            jac = csr_matrix((1, child_jac.shape[1]))\n            return pybamm.Matrix(jac)\n        else:\n            return Index(child_jac, self.index)\n\n    def set_id(self):\n        \"\"\" See :meth:`pybamm.Symbol.set_id()` \"\"\"\n        self._id = hash(\n            (\n                self.__class__,\n                self.name,\n                self.slice.start,\n                self.slice.stop,\n                self.children[0].id,\n            )\n            + tuple(self.domain)\n        )\n\n    def _unary_evaluate(self, child):\n        \"\"\" See :meth:`UnaryOperator._unary_evaluate()`. \"\"\"\n        return child[self.slice]\n\n    def _unary_new_copy(self, child):\n        \"\"\" See :meth:`UnaryOperator._unary_new_copy()`. \"\"\"\n\n        return self.__class__(child, self.index, check_size=False)\n\n    def evaluate_for_shape(self):\n        return self._unary_evaluate(self.children[0].evaluate_for_shape())\n\n    def evaluates_on_edges(self):\n        \"\"\" See :meth:`pybamm.Symbol.evaluates_on_edges()`. \"\"\"\n        return False",
  "class SpatialOperator(UnaryOperator):\n    \"\"\"A node in the expression tree representing a unary spatial operator\n    (e.g. grad, div)\n\n    Derived classes will specify the particular operator\n\n    This type of node will be replaced by the :class:`Discretisation`\n    class with a :class:`Matrix`\n\n    **Extends:** :class:`UnaryOperator`\n\n    Parameters\n    ----------\n\n    name : str\n        name of the node\n    child : :class:`Symbol`\n        child node\n\n    \"\"\"\n\n    def __init__(self, name, child, domain=None, auxiliary_domains=None):\n        super().__init__(name, child, domain, auxiliary_domains)\n\n    def diff(self, variable):\n        \"\"\" See :meth:`pybamm.Symbol.diff()`. \"\"\"\n        # We shouldn't need this\n        raise NotImplementedError\n\n    def _unary_simplify(self, child):\n        \"\"\" See :meth:`pybamm.UnaryOperator.simplify()`. \"\"\"\n\n        # if there are none of these nodes in the child tree, then this expression\n        # does not depend on space, and therefore the spatial operator result is zero\n        search_types = (pybamm.Variable, pybamm.StateVector, pybamm.SpatialVariable)\n\n        # do the search, return a scalar zero node if no relevent nodes are found\n        if all([not (isinstance(n, search_types)) for n in self.pre_order()]):\n            return pybamm.Scalar(0)\n        else:\n            return self.__class__(child)",
  "class Gradient(SpatialOperator):\n    \"\"\"A node in the expression tree representing a grad operator\n\n    **Extends:** :class:`SpatialOperator`\n    \"\"\"\n\n    def __init__(self, child):\n        super().__init__(\"grad\", child)\n\n    def evaluates_on_edges(self):\n        \"\"\" See :meth:`pybamm.Symbol.evaluates_on_edges()`. \"\"\"\n        return True",
  "class Divergence(SpatialOperator):\n    \"\"\"A node in the expression tree representing a div operator\n\n    **Extends:** :class:`SpatialOperator`\n    \"\"\"\n\n    def __init__(self, child):\n        super().__init__(\"div\", child)\n\n    def evaluates_on_edges(self):\n        \"\"\" See :meth:`pybamm.Symbol.evaluates_on_edges()`. \"\"\"\n        return False",
  "class Laplacian(SpatialOperator):\n    \"\"\"A node in the expression tree representing a laplacian operator. This is\n    currently only implemeted in the weak form for finite element formulations.\n\n    **Extends:** :class:`SpatialOperator`\n    \"\"\"\n\n    def __init__(self, child):\n        super().__init__(\"laplacian\", child)\n\n    def evaluates_on_edges(self):\n        \"\"\" See :meth:`pybamm.Symbol.evaluates_on_edges()`. \"\"\"\n        return False",
  "class Gradient_Squared(SpatialOperator):\n    \"\"\"A node in the expression tree representing a the inner product of the grad\n    operator with itself. In particular, this is useful in the finite element\n    formualtion where we only require the (sclar valued) square of the gradient,\n    and  not the gradient itself.\n\n    **Extends:** :class:`SpatialOperator`\n    \"\"\"\n\n    def __init__(self, child):\n        super().__init__(\"grad squared\", child)\n\n    def evaluates_on_edges(self):\n        \"\"\" See :meth:`pybamm.Symbol.evaluates_on_edges()`. \"\"\"\n        return True",
  "class Mass(SpatialOperator):\n    \"\"\"Returns the mass matrix for a given symbol, accounting for Dirchlet boundary\n    conditions where necessary (e.g. in the finite element formualtion)\n    **Extends:** :class:`SpatialOperator`\n    \"\"\"\n\n    def __init__(self, child):\n        super().__init__(\"mass\", child)\n\n    def evaluate_for_shape(self):\n        return pybamm.evaluate_for_shape_using_domain(self.domain, typ=\"matrix\")",
  "class BoundaryMass(SpatialOperator):\n    \"\"\"Returns the mass matrix for a given symbol assembled over the boundary of\n    the domain, accounting for Dirchlet boundary conditions where necessary\n    (e.g. in the finite element formualtion)\n    **Extends:** :class:`SpatialOperator`\n    \"\"\"\n\n    def __init__(self, child):\n        super().__init__(\"boundary mass\", child)\n\n    def evaluate_for_shape(self):\n        return pybamm.evaluate_for_shape_using_domain(self.domain, typ=\"matrix\")",
  "class Integral(SpatialOperator):\n    \"\"\"A node in the expression tree representing an integral operator\n\n    .. math::\n        I = \\\\int_{a}^{b}\\\\!f(u)\\\\,du,\n\n    where :math:`a` and :math:`b` are the left-hand and right-hand boundaries of\n    the domain respectively, and :math:`u\\\\in\\\\text{domain}`.\n    Can be integration with respect to time or space.\n\n    Parameters\n    ----------\n    function : :class:`pybamm.Symbol`\n        The function to be integrated (will become self.children[0])\n    integration_variable : :class:`pybamm.IndependentVariable`\n        The variable over which to integrate\n\n    **Extends:** :class:`SpatialOperator`\n    \"\"\"\n\n    def __init__(self, child, integration_variable):\n        if not isinstance(integration_variable, list):\n            integration_variable = [integration_variable]\n\n        # integral of a child takes the domain from auxiliary domain of the child\n        if child.auxiliary_domains != {}:\n            domain = child.auxiliary_domains[\"secondary\"]\n            try:\n                auxiliary_domains = {\"secondary\": child.auxiliary_domains[\"tertiary\"]}\n            except KeyError:\n                auxiliary_domains = {}\n        # if child has no auxiliary domain, integral removes domain\n        else:\n            domain = []\n            auxiliary_domains = {}\n        name = \"integral\"\n        for var in integration_variable:\n            if isinstance(var, pybamm.SpatialVariable):\n                # Check that child and integration_variable domains agree\n                if child.domain != var.domain:\n                    raise pybamm.DomainError(\n                        \"child and integration_variable must have the same domain\"\n                    )\n            elif not isinstance(var, pybamm.IndependentVariable):\n                raise ValueError(\n                    \"\"\"integration_variable must be of type pybamm.IndependentVariable,\n                           not {}\"\"\".format(\n                        type(var)\n                    )\n                )\n            name += \" d{}\".format(var.name)\n\n        if any(isinstance(var, pybamm.SpatialVariable) for var in integration_variable):\n            name += \" {}\".format(child.domain)\n\n        self._integration_variable = integration_variable\n        super().__init__(\n            name, child, domain=domain, auxiliary_domains=auxiliary_domains\n        )\n\n    @property\n    def integration_variable(self):\n        return self._integration_variable\n\n    def set_id(self):\n        \"\"\" See :meth:`pybamm.Symbol.set_id()` \"\"\"\n        if not isinstance(self.integration_variable, list):\n            self.integration_variable = [self.integration_variable]\n        self._id = hash(\n            (self.__class__, self.name)\n            + tuple(\n                [\n                    integration_variable.id\n                    for integration_variable in self.integration_variable\n                ]\n            )\n            + (self.children[0].id,)\n            + tuple(self.domain)\n        )\n\n    def _unary_simplify(self, simplified_child):\n        \"\"\" See :meth:`UnaryOperator._unary_simplify()`. \"\"\"\n\n        return self.__class__(simplified_child, self.integration_variable)\n\n    def _unary_new_copy(self, child):\n        \"\"\" See :meth:`UnaryOperator._unary_new_copy()`. \"\"\"\n\n        return self.__class__(child, self.integration_variable)\n\n    def evaluate_for_shape(self):\n        \"\"\" See :meth:`pybamm.Symbol.evaluate_for_shape_using_domain()` \"\"\"\n        return pybamm.evaluate_for_shape_using_domain(self.domain)\n\n    def evaluates_on_edges(self):\n        \"\"\" See :meth:`pybamm.Symbol.evaluates_on_edges()`. \"\"\"\n        return False",
  "class IndefiniteIntegral(Integral):\n    \"\"\"A node in the expression tree representing an indefinite integral operator\n\n    .. math::\n        I = \\\\int_{x_\\text{min}}^{x}\\\\!f(u)\\\\,du\n\n    where :math:`u\\\\in\\\\text{domain}` which can represent either a\n    spatial or temporal variable.\n\n    Parameters\n    ----------\n    function : :class:`pybamm.Symbol`\n        The function to be integrated (will become self.children[0])\n    integration_variable : :class:`pybamm.IndependentVariable`\n        The variable over which to integrate\n\n    **Extends:** :class:`Integral`\n    \"\"\"\n\n    def __init__(self, child, integration_variable):\n        if isinstance(integration_variable, list):\n            if len(integration_variable) > 1:\n                raise NotImplementedError(\n                    \"Indefinite integral only implemeted w.r.t. one variable\"\n                )\n            else:\n                integration_variable = integration_variable[0]\n        super().__init__(child, integration_variable)\n        # overwrite domains with child domains\n        self.auxiliary_domains = child.auxiliary_domains\n        self.domain = child.domain\n        # Overwrite the name\n        self.name = \"{} integrated w.r.t {}\".format(\n            child.name, integration_variable.name\n        )\n        if isinstance(integration_variable, pybamm.SpatialVariable):\n            self.name += \" on {}\".format(integration_variable.domain)\n\n    def evaluate_for_shape(self):\n        return self.children[0].evaluate_for_shape()",
  "class DefiniteIntegralVector(SpatialOperator):\n    \"\"\"A node in the expression tree representing an integral of the basis used\n    for discretisation\n\n    .. math::\n        I = \\\\int_{a}^{b}\\\\!\\\\psi(x)\\\\,dx,\n\n    where :math:`a` and :math:`b` are the left-hand and right-hand boundaries of\n    the domain respectively and :math:`\\\\psi` is the basis function.\n\n    Parameters\n    ----------\n    variable : :class:`pybamm.Symbol`\n        The variable whose basis will be integrated over the entire domain\n    vector_type : str, optional\n        Whether to return a row or column vector (default is row)\n\n    **Extends:** :class:`SpatialOperator`\n    \"\"\"\n\n    def __init__(self, child, vector_type=\"row\"):\n        name = \"basis integral\"\n        self.vector_type = vector_type\n        super().__init__(name, child)\n        # integrating removes the domain\n        self.domain = []\n\n    def set_id(self):\n        \"\"\" See :meth:`pybamm.Symbol.set_id()` \"\"\"\n        self._id = hash(\n            (self.__class__, self.name, self.vector_type)\n            + (self.children[0].id,)\n            + tuple(self.domain)\n        )\n\n    def _unary_simplify(self, simplified_child):\n        \"\"\" See :meth:`UnaryOperator._unary_simplify()`. \"\"\"\n\n        return self.__class__(simplified_child, vector_type=self.vector_type)\n\n    def _unary_new_copy(self, child):\n        \"\"\" See :meth:`UnaryOperator._unary_new_copy()`. \"\"\"\n\n        return self.__class__(child, vector_type=self.vector_type)\n\n    def evaluate_for_shape(self):\n        \"\"\" See :meth:`pybamm.Symbol.evaluate_for_shape_using_domain()` \"\"\"\n        return pybamm.evaluate_for_shape_using_domain(self.domain)",
  "class BoundaryIntegral(SpatialOperator):\n    \"\"\"A node in the expression tree representing an integral operator over the\n    boundary of a domain\n\n    .. math::\n        I = \\\\int_{\\\\partial a}\\\\!f(u)\\\\,du,\n\n    where :math:`\\\\partial a` is the boundary of the domain, and\n    :math:`u\\\\in\\\\text{domain boundary}`.\n\n    Parameters\n    ----------\n    function : :class:`pybamm.Symbol`\n        The function to be integrated (will become self.children[0])\n    region : str, optional\n        The region of the boundary over which to integrate. If region is `entire`\n        (default) the integration is carried out over the entire boundary. If\n        region is `negative tab` or `positive tab` then the integration is only\n        carried out over the appropriate part of the boundary corresponding to\n        the tab.\n    **Extends:** :class:`SpatialOperator`\n    \"\"\"\n\n    def __init__(self, child, region=\"entire\"):\n        # boundary integral removes domain\n        domain = []\n        auxiliary_domains = {}\n\n        name = \"boundary integral over \"\n        if region == \"entire\":\n            name += \"entire boundary\"\n        elif region == \"negative tab\":\n            name += \"negative tab\"\n        elif region == \"positive tab\":\n            name += \"positive tab\"\n        self.region = region\n        super().__init__(\n            name, child, domain=domain, auxiliary_domains=auxiliary_domains\n        )\n\n    def set_id(self):\n        \"\"\" See :meth:`pybamm.Symbol.set_id()` \"\"\"\n        self._id = hash(\n            (self.__class__, self.name) + (self.children[0].id,) + tuple(self.domain)\n        )\n\n    def _unary_simplify(self, simplified_child):\n        \"\"\" See :meth:`UnaryOperator._unary_simplify()`. \"\"\"\n\n        return self.__class__(simplified_child, region=self.region)\n\n    def _unary_new_copy(self, child):\n        \"\"\" See :meth:`UnaryOperator._unary_new_copy()`. \"\"\"\n\n        return self.__class__(child, region=self.region)\n\n    def evaluate_for_shape(self):\n        \"\"\" See :meth:`pybamm.Symbol.evaluate_for_shape_using_domain()` \"\"\"\n        return pybamm.evaluate_for_shape_using_domain(self.domain)\n\n    def evaluates_on_edges(self):\n        \"\"\" See :meth:`pybamm.Symbol.evaluates_on_edges()`. \"\"\"\n        return False",
  "class DeltaFunction(SpatialOperator):\n    \"\"\"Delta function. Currently can only be implemented at the edge of a domain\n\n    Parameters\n    ----------\n    child : :class:`pybamm.Symbol`\n        The variable that sets the strength of the delta function\n    side : str\n        Which side of the domain to implement the delta function on\n\n    **Extends:** :class:`SpatialOperator`\n    \"\"\"\n\n    def __init__(self, child, side, domain):\n        self.side = side\n        if child.domain != []:\n            auxiliary_domains = {\"secondary\": child.domain}\n        else:\n            auxiliary_domains = {}\n        super().__init__(\"delta function\", child, domain, auxiliary_domains)\n\n    def set_id(self):\n        \"\"\" See :meth:`pybamm.Symbol.set_id()` \"\"\"\n        self._id = hash(\n            (self.__class__, self.name, self.side, self.children[0].id)\n            + tuple(self.domain)\n            + tuple([(k, tuple(v)) for k, v in self.auxiliary_domains.items()])\n        )\n\n    def evaluates_on_edges(self):\n        \"\"\" See :meth:`pybamm.Symbol.evaluates_on_edges()`. \"\"\"\n        return False\n\n    def _unary_simplify(self, simplified_child):\n        \"\"\" See :meth:`UnaryOperator._unary_simplify()`. \"\"\"\n        return self.__class__(simplified_child, self.side, self.domain)\n\n    def _unary_new_copy(self, child):\n        \"\"\" See :meth:`UnaryOperator._unary_new_copy()`. \"\"\"\n        return self.__class__(child, self.side, self.domain)",
  "class BoundaryOperator(SpatialOperator):\n    \"\"\"A node in the expression tree which gets the boundary value of a variable.\n\n    Parameters\n    ----------\n    name : str\n        The name of the symbol\n    child : :class:`pybamm.Symbol`\n        The variable whose boundary value to take\n    side : str\n        Which side to take the boundary value on (\"left\" or \"right\")\n\n    **Extends:** :class:`SpatialOperator`\n    \"\"\"\n\n    def __init__(self, name, child, side):\n        # side can only be \"negative tab\" or \"positive tab\" if domain is\n        # \"current collector\"\n        if side in [\"negative tab\", \"positive tab\"]:\n            if child.domain[0] != \"current collector\":\n                raise pybamm.ModelError(\n                    \"\"\"Can only take boundary value on the tabs in the domain\n                'current collector', but {} has domain {}\"\"\".format(\n                        child, child.domain[0]\n                    )\n                )\n        self.side = side\n        # boundary value of a child takes the domain from auxiliary domain of the child\n        if child.auxiliary_domains != {}:\n            domain = child.auxiliary_domains[\"secondary\"]\n        # if child has no auxiliary domain, integral removes domain\n        else:\n            domain = []\n        # tertiary auxiliary domain shift down to secondary\n        try:\n            auxiliary_domains = {\"secondary\": child.auxiliary_domains[\"tertiary\"]}\n        except KeyError:\n            auxiliary_domains = {}\n        super().__init__(\n            name, child, domain=domain, auxiliary_domains=auxiliary_domains\n        )\n\n    def set_id(self):\n        \"\"\" See :meth:`pybamm.Symbol.set_id()` \"\"\"\n        self._id = hash(\n            (self.__class__, self.name, self.side, self.children[0].id)\n            + tuple(self.domain)\n            + tuple([(k, tuple(v)) for k, v in self.auxiliary_domains.items()])\n        )\n\n    def _unary_simplify(self, simplified_child):\n        \"\"\" See :meth:`UnaryOperator._unary_simplify()`. \"\"\"\n        return self.__class__(simplified_child, self.side)\n\n    def _unary_new_copy(self, child):\n        \"\"\" See :meth:`UnaryOperator._unary_new_copy()`. \"\"\"\n        return self.__class__(child, self.side)\n\n    def evaluate_for_shape(self):\n        \"\"\" See :meth:`pybamm.Symbol.evaluate_for_shape_using_domain()` \"\"\"\n        return pybamm.evaluate_for_shape_using_domain(\n            self.domain, self.auxiliary_domains\n        )",
  "class BoundaryValue(BoundaryOperator):\n    \"\"\"A node in the expression tree which gets the boundary value of a variable.\n\n    Parameters\n    ----------\n    child : :class:`pybamm.Symbol`\n        The variable whose boundary value to take\n    side : str\n        Which side to take the boundary value on (\"left\" or \"right\")\n\n    **Extends:** :class:`BoundaryOperator`\n    \"\"\"\n\n    def __init__(self, child, side):\n        super().__init__(\"boundary value\", child, side)",
  "class BoundaryGradient(BoundaryOperator):\n    \"\"\"A node in the expression tree which gets the boundary flux of a variable.\n\n    Parameters\n    ----------\n    child : :class:`pybamm.Symbol`\n        The variable whose boundary flux to take\n    side : str\n        Which side to take the boundary flux on (\"left\" or \"right\")\n\n    **Extends:** :class:`BoundaryOperator`\n    \"\"\"\n\n    def __init__(self, child, side):\n        super().__init__(\"boundary flux\", child, side)",
  "def grad(expression):\n    \"\"\"convenience function for creating a :class:`Gradient`\n\n    Parameters\n    ----------\n\n    expression : :class:`Symbol`\n        the gradient will be performed on this sub-expression\n\n    Returns\n    -------\n\n    :class:`Gradient`\n        the gradient of ``expression``\n    \"\"\"\n\n    return Gradient(expression)",
  "def div(expression):\n    \"\"\"convenience function for creating a :class:`Divergence`\n\n    Parameters\n    ----------\n\n    expression : :class:`Symbol`\n        the divergence will be performed on this sub-expression\n\n    Returns\n    -------\n\n    :class:`Divergence`\n        the divergence of ``expression``\n    \"\"\"\n\n    return Divergence(expression)",
  "def laplacian(expression):\n    \"\"\"convenience function for creating a :class:`Laplacian`\n\n    Parameters\n    ----------\n\n    expression : :class:`Symbol`\n        the laplacian will be performed on this sub-expression\n\n    Returns\n    -------\n\n    :class:`Laplacian`\n        the laplacian of ``expression``\n    \"\"\"\n\n    return Laplacian(expression)",
  "def grad_squared(expression):\n    \"\"\"convenience function for creating a :class:`Gradient_Squared`\n\n    Parameters\n    ----------\n\n    expression : :class:`Symbol`\n        the inner product of the gradient with itself will be performed on this\n        sub-expression\n\n    Returns\n    -------\n\n    :class:`Gradient_Squared`\n        inner product of the gradient of ``expression`` with itself\n    \"\"\"\n\n    return Gradient_Squared(expression)",
  "def surf(symbol, set_domain=False):\n    \"\"\"convenience function for creating a right :class:`BoundaryValue`, usually in the\n    spherical geometry\n\n    Parameters\n    ----------\n\n    symbol : :class:`pybamm.Symbol`\n        the surface value of this symbol will be returned\n\n    Returns\n    -------\n    :class:`pybamm.BoundaryValue`\n        the surface value of ``symbol``\n    \"\"\"\n    if symbol.domain in [[\"negative electrode\"], [\"positive electrode\"]] and isinstance(\n        symbol, pybamm.PrimaryBroadcast\n    ):\n        child_surf = boundary_value(symbol.orphans[0], \"right\")\n        out = pybamm.PrimaryBroadcast(child_surf, symbol.domain)\n    else:\n        out = boundary_value(symbol, \"right\")\n        if set_domain:\n            if symbol.domain == [\"negative particle\"]:\n                out.domain = [\"negative electrode\"]\n            elif symbol.domain == [\"positive particle\"]:\n                out.domain = [\"positive electrode\"]\n    return out",
  "def x_average(symbol):\n    \"\"\"convenience function for creating an average in the x-direction\n\n    Parameters\n    ----------\n    symbol : :class:`pybamm.Symbol`\n        The function to be averaged\n\n    Returns\n    -------\n    :class:`Symbol`\n        the new averaged symbol\n    \"\"\"\n    # If symbol doesn't have a domain, its average value is itself\n    if symbol.domain in [[], [\"current collector\"]]:\n        new_symbol = symbol.new_copy()\n        new_symbol.parent = None\n        return new_symbol\n    # If symbol is a Broadcast, its average value is its child\n    elif isinstance(symbol, pybamm.Broadcast):\n        return symbol.orphans[0]\n    # If symbol is a concatenation of Broadcasts, its average value is its child\n    elif (\n        isinstance(symbol, pybamm.Concatenation)\n        and all(isinstance(child, pybamm.Broadcast) for child in symbol.children)\n        and symbol.domain == [\"negative electrode\", \"separator\", \"positive electrode\"]\n    ):\n        a, b, c = [orp.orphans[0] for orp in symbol.orphans]\n        if a.id == b.id == c.id:\n            return a\n        else:\n            l_n = pybamm.geometric_parameters.l_n\n            l_s = pybamm.geometric_parameters.l_s\n            l_p = pybamm.geometric_parameters.l_p\n            return (l_n * a + l_s * b + l_p * c) / (l_n + l_s + l_p)\n    # Otherwise, use Integral to calculate average value\n    else:\n        if symbol.domain == [\"negative electrode\"]:\n            x = pybamm.standard_spatial_vars.x_n\n            l = pybamm.geometric_parameters.l_n\n        elif symbol.domain == [\"separator\"]:\n            x = pybamm.standard_spatial_vars.x_s\n            l = pybamm.geometric_parameters.l_s\n        elif symbol.domain == [\"positive electrode\"]:\n            x = pybamm.standard_spatial_vars.x_p\n            l = pybamm.geometric_parameters.l_p\n        elif symbol.domain == [\"negative electrode\", \"separator\", \"positive electrode\"]:\n            x = pybamm.standard_spatial_vars.x\n            l = pybamm.Scalar(1)\n        elif symbol.domain == [\"negative particle\"]:\n            x = pybamm.standard_spatial_vars.x_n\n            l = pybamm.geometric_parameters.l_n\n        elif symbol.domain == [\"positive particle\"]:\n            x = pybamm.standard_spatial_vars.x_p\n            l = pybamm.geometric_parameters.l_p\n        else:\n            raise pybamm.DomainError(\"domain '{}' not recognised\".format(symbol.domain))\n\n        return Integral(symbol, x) / l",
  "def z_average(symbol):\n    \"\"\"convenience function for creating an average in the z-direction\n\n    Parameters\n    ----------\n    symbol : :class:`pybamm.Symbol`\n        The function to be averaged\n\n    Returns\n    -------\n    :class:`Symbol`\n        the new averaged symbol\n    \"\"\"\n    # Symbol must have domain [] or [\"current collector\"]\n    if symbol.domain not in [[], [\"current collector\"]]:\n        raise pybamm.DomainError(\n            \"\"\"z-average only implemented in the 'current collector' domain,\n            but symbol has domains {}\"\"\".format(\n                symbol.domain\n            )\n        )\n    # If symbol doesn't have a domain, its average value is itself\n    if symbol.domain == []:\n        new_symbol = symbol.new_copy()\n        new_symbol.parent = None\n        return new_symbol\n    # If symbol is a Broadcast, its average value is its child\n    elif isinstance(symbol, pybamm.Broadcast):\n        return symbol.orphans[0]\n    # Otherwise, use Integral to calculate average value\n    else:\n        z = pybamm.standard_spatial_vars.z\n        l_z = pybamm.geometric_parameters.l_z\n        return Integral(symbol, z) / l_z",
  "def yz_average(symbol):\n    \"\"\"convenience function for creating an average in the y-z-direction\n\n    Parameters\n    ----------\n    symbol : :class:`pybamm.Symbol`\n        The function to be averaged\n\n    Returns\n    -------\n    :class:`Symbol`\n        the new averaged symbol\n    \"\"\"\n    # Symbol must have domain [] or [\"current collector\"]\n    if symbol.domain not in [[], [\"current collector\"]]:\n        raise pybamm.DomainError(\n            \"\"\"y-z-average only implemented in the 'current collector' domain,\n            but symbol has domains {}\"\"\".format(\n                symbol.domain\n            )\n        )\n    # If symbol doesn't have a domain, its average value is itself\n    if symbol.domain == []:\n        new_symbol = symbol.new_copy()\n        new_symbol.parent = None\n        return new_symbol\n    # If symbol is a Broadcast, its average value is its child\n    elif isinstance(symbol, pybamm.Broadcast):\n        return symbol.orphans[0]\n    # Otherwise, use Integral to calculate average value\n    else:\n        y = pybamm.standard_spatial_vars.y\n        z = pybamm.standard_spatial_vars.z\n        l_y = pybamm.geometric_parameters.l_y\n        l_z = pybamm.geometric_parameters.l_z\n        return Integral(symbol, [y, z]) / (l_y * l_z)",
  "def boundary_value(symbol, side):\n    \"\"\"convenience function for creating a :class:`pybamm.BoundaryValue`\n\n    Parameters\n    ----------\n    symbol : `pybamm.Symbol`\n        The symbol whose boundary value to take\n    side : str\n        Which side to take the boundary value on (\"left\" or \"right\")\n\n    Returns\n    -------\n    :class:`BoundaryValue`\n        the new integrated expression tree\n    \"\"\"\n    # If symbol doesn't have a domain, its boundary value is itself\n    if symbol.domain == []:\n        new_symbol = symbol.new_copy()\n        new_symbol.parent = None\n        return new_symbol\n    # If symbol is a Broadcast, its boundary value is its child\n    if isinstance(symbol, pybamm.Broadcast):\n        return symbol.orphans[0]\n    # Otherwise, calculate boundary value\n    else:\n        return BoundaryValue(symbol, side)",
  "def r_average(symbol):\n    \"\"\"convenience function for creating an average in the r-direction\n\n    Parameters\n    ----------\n    symbol : :class:`pybamm.Symbol`\n        The function to be averaged\n\n    Returns\n    -------\n    :class:`Symbol`\n        the new averaged symbol\n    \"\"\"\n    # If symbol doesn't have a particle domain, its r-averaged value is itself\n    if symbol.domain not in [[\"positive particle\"], [\"negative particle\"]]:\n        new_symbol = symbol.new_copy()\n        new_symbol.parent = None\n        return new_symbol\n    # If symbol is a Broadcast, its average value is its child\n    elif isinstance(symbol, pybamm.Broadcast):\n        return symbol.orphans[0]\n    else:\n        r = pybamm.SpatialVariable(\"r\", symbol.domain)\n        v = pybamm.Broadcast(pybamm.Scalar(1), symbol.domain)\n        return Integral(symbol, r) / Integral(v, r)",
  "def __init__(self, name, child, domain=None, auxiliary_domains=None):\n        if domain is None:\n            domain = child.domain\n        if auxiliary_domains is None:\n            auxiliary_domains = child.auxiliary_domains\n        super().__init__(\n            name, children=[child], domain=domain, auxiliary_domains=auxiliary_domains\n        )\n        self.child = self.children[0]",
  "def __str__(self):\n        \"\"\" See :meth:`pybamm.Symbol.__str__()`. \"\"\"\n        return \"{}({!s})\".format(self.name, self.child)",
  "def new_copy(self):\n        \"\"\" See :meth:`pybamm.Symbol.new_copy()`. \"\"\"\n        new_child = self.child.new_copy()\n        return self._unary_new_copy(new_child)",
  "def _unary_new_copy(self, child):\n        \"\"\"Make a new copy of the unary operator, with child `child`\"\"\"\n\n        return self.__class__(child)",
  "def _unary_jac(self, child_jac):\n        \"\"\" Calculate the jacobian of a unary operator. \"\"\"\n        raise NotImplementedError",
  "def _unary_simplify(self, simplified_child):\n        \"\"\"\n        Simplify a unary operator. Default behaviour is to make a new copy, with\n        simplified child.\n        \"\"\"\n\n        return self._unary_new_copy(simplified_child)",
  "def _unary_evaluate(self, child):\n        \"\"\"Perform unary operation on a child. \"\"\"\n        raise NotImplementedError",
  "def evaluate(self, t=None, y=None, known_evals=None):\n        \"\"\" See :meth:`pybamm.Symbol.evaluate()`. \"\"\"\n        if known_evals is not None:\n            if self.id not in known_evals:\n                child, known_evals = self.child.evaluate(t, y, known_evals)\n                known_evals[self.id] = self._unary_evaluate(child)\n            return known_evals[self.id], known_evals\n        else:\n            child = self.child.evaluate(t, y)\n            return self._unary_evaluate(child)",
  "def evaluate_for_shape(self):\n        \"\"\"\n        Default behaviour: unary operator has same shape as child\n        See :meth:`pybamm.Symbol.evaluate_for_shape()`\n        \"\"\"\n        return self.children[0].evaluate_for_shape()",
  "def evaluates_on_edges(self):\n        \"\"\" See :meth:`pybamm.Symbol.evaluates_on_edges()`. \"\"\"\n        return self.child.evaluates_on_edges()",
  "def __init__(self, child):\n        \"\"\" See :meth:`pybamm.UnaryOperator.__init__()`. \"\"\"\n        super().__init__(\"-\", child)",
  "def __str__(self):\n        \"\"\" See :meth:`pybamm.Symbol.__str__()`. \"\"\"\n        return \"{}{!s}\".format(self.name, self.child)",
  "def _diff(self, variable):\n        \"\"\" See :meth:`pybamm.Symbol._diff()`. \"\"\"\n        return -self.child.diff(variable)",
  "def _unary_jac(self, child_jac):\n        \"\"\" See :meth:`pybamm.UnaryOperator._unary_jac()`. \"\"\"\n        return -child_jac",
  "def _unary_evaluate(self, child):\n        \"\"\" See :meth:`UnaryOperator._unary_evaluate()`. \"\"\"\n        return -child",
  "def __init__(self, child):\n        \"\"\" See :meth:`pybamm.UnaryOperator.__init__()`. \"\"\"\n        super().__init__(\"abs\", child)",
  "def diff(self, variable):\n        \"\"\" See :meth:`pybamm.Symbol.diff()`. \"\"\"\n        # Derivative is not well-defined\n        raise pybamm.UndefinedOperationError(\n            \"Derivative of absolute function is not defined\"\n        )",
  "def _unary_jac(self, child_jac):\n        \"\"\" See :meth:`pybamm.UnaryOperator._unary_jac()`. \"\"\"\n        # Derivative is not well-defined\n        raise pybamm.UndefinedOperationError(\n            \"Derivative of absolute function is not defined\"\n        )",
  "def _unary_evaluate(self, child):\n        \"\"\" See :meth:`UnaryOperator._unary_evaluate()`. \"\"\"\n        return np.abs(child)",
  "def __init__(self, child, index, name=None, check_size=True):\n        self.index = index\n        if index == -1:\n            self.slice = slice(index, None)\n            if name is None:\n                name = \"Index[-1]\"\n        elif isinstance(index, int):\n            self.slice = slice(index, index + 1)\n            if name is None:\n                name = \"Index[\" + str(index) + \"]\"\n        elif isinstance(index, slice):\n            self.slice = index\n            if name is None:\n                if index.start is None:\n                    name = \"Index[:{:d}]\".format(index.stop)\n                else:\n                    name = \"Index[{:d}:{:d}]\".format(index.start, index.stop)\n        else:\n            raise TypeError(\"index must be integer or slice\")\n\n        if check_size:\n            if self.slice in (slice(0, 1), slice(-1, None)):\n                pass\n            elif self.slice.stop > child.size:\n                raise ValueError(\"slice size exceeds child size\")\n\n        super().__init__(name, child)\n\n        # no domain for integer value\n        if isinstance(index, int):\n            self.domain = []",
  "def _unary_jac(self, child_jac):\n        \"\"\" See :meth:`pybamm.UnaryOperator._unary_jac()`. \"\"\"\n\n        # if child.jac returns a matrix of zeros, this subsequently gives a bug\n        # when trying to simplify the node Index(child_jac). Instead, search the\n        # tree for StateVectors and return a matrix of zeros of the correct size\n        # if none are found.\n        if all([not (isinstance(n, pybamm.StateVector)) for n in self.pre_order()]):\n            jac = csr_matrix((1, child_jac.shape[1]))\n            return pybamm.Matrix(jac)\n        else:\n            return Index(child_jac, self.index)",
  "def set_id(self):\n        \"\"\" See :meth:`pybamm.Symbol.set_id()` \"\"\"\n        self._id = hash(\n            (\n                self.__class__,\n                self.name,\n                self.slice.start,\n                self.slice.stop,\n                self.children[0].id,\n            )\n            + tuple(self.domain)\n        )",
  "def _unary_evaluate(self, child):\n        \"\"\" See :meth:`UnaryOperator._unary_evaluate()`. \"\"\"\n        return child[self.slice]",
  "def _unary_new_copy(self, child):\n        \"\"\" See :meth:`UnaryOperator._unary_new_copy()`. \"\"\"\n\n        return self.__class__(child, self.index, check_size=False)",
  "def evaluate_for_shape(self):\n        return self._unary_evaluate(self.children[0].evaluate_for_shape())",
  "def evaluates_on_edges(self):\n        \"\"\" See :meth:`pybamm.Symbol.evaluates_on_edges()`. \"\"\"\n        return False",
  "def __init__(self, name, child, domain=None, auxiliary_domains=None):\n        super().__init__(name, child, domain, auxiliary_domains)",
  "def diff(self, variable):\n        \"\"\" See :meth:`pybamm.Symbol.diff()`. \"\"\"\n        # We shouldn't need this\n        raise NotImplementedError",
  "def _unary_simplify(self, child):\n        \"\"\" See :meth:`pybamm.UnaryOperator.simplify()`. \"\"\"\n\n        # if there are none of these nodes in the child tree, then this expression\n        # does not depend on space, and therefore the spatial operator result is zero\n        search_types = (pybamm.Variable, pybamm.StateVector, pybamm.SpatialVariable)\n\n        # do the search, return a scalar zero node if no relevent nodes are found\n        if all([not (isinstance(n, search_types)) for n in self.pre_order()]):\n            return pybamm.Scalar(0)\n        else:\n            return self.__class__(child)",
  "def __init__(self, child):\n        super().__init__(\"grad\", child)",
  "def evaluates_on_edges(self):\n        \"\"\" See :meth:`pybamm.Symbol.evaluates_on_edges()`. \"\"\"\n        return True",
  "def __init__(self, child):\n        super().__init__(\"div\", child)",
  "def evaluates_on_edges(self):\n        \"\"\" See :meth:`pybamm.Symbol.evaluates_on_edges()`. \"\"\"\n        return False",
  "def __init__(self, child):\n        super().__init__(\"laplacian\", child)",
  "def evaluates_on_edges(self):\n        \"\"\" See :meth:`pybamm.Symbol.evaluates_on_edges()`. \"\"\"\n        return False",
  "def __init__(self, child):\n        super().__init__(\"grad squared\", child)",
  "def evaluates_on_edges(self):\n        \"\"\" See :meth:`pybamm.Symbol.evaluates_on_edges()`. \"\"\"\n        return True",
  "def __init__(self, child):\n        super().__init__(\"mass\", child)",
  "def evaluate_for_shape(self):\n        return pybamm.evaluate_for_shape_using_domain(self.domain, typ=\"matrix\")",
  "def __init__(self, child):\n        super().__init__(\"boundary mass\", child)",
  "def evaluate_for_shape(self):\n        return pybamm.evaluate_for_shape_using_domain(self.domain, typ=\"matrix\")",
  "def __init__(self, child, integration_variable):\n        if not isinstance(integration_variable, list):\n            integration_variable = [integration_variable]\n\n        # integral of a child takes the domain from auxiliary domain of the child\n        if child.auxiliary_domains != {}:\n            domain = child.auxiliary_domains[\"secondary\"]\n            try:\n                auxiliary_domains = {\"secondary\": child.auxiliary_domains[\"tertiary\"]}\n            except KeyError:\n                auxiliary_domains = {}\n        # if child has no auxiliary domain, integral removes domain\n        else:\n            domain = []\n            auxiliary_domains = {}\n        name = \"integral\"\n        for var in integration_variable:\n            if isinstance(var, pybamm.SpatialVariable):\n                # Check that child and integration_variable domains agree\n                if child.domain != var.domain:\n                    raise pybamm.DomainError(\n                        \"child and integration_variable must have the same domain\"\n                    )\n            elif not isinstance(var, pybamm.IndependentVariable):\n                raise ValueError(\n                    \"\"\"integration_variable must be of type pybamm.IndependentVariable,\n                           not {}\"\"\".format(\n                        type(var)\n                    )\n                )\n            name += \" d{}\".format(var.name)\n\n        if any(isinstance(var, pybamm.SpatialVariable) for var in integration_variable):\n            name += \" {}\".format(child.domain)\n\n        self._integration_variable = integration_variable\n        super().__init__(\n            name, child, domain=domain, auxiliary_domains=auxiliary_domains\n        )",
  "def integration_variable(self):\n        return self._integration_variable",
  "def set_id(self):\n        \"\"\" See :meth:`pybamm.Symbol.set_id()` \"\"\"\n        if not isinstance(self.integration_variable, list):\n            self.integration_variable = [self.integration_variable]\n        self._id = hash(\n            (self.__class__, self.name)\n            + tuple(\n                [\n                    integration_variable.id\n                    for integration_variable in self.integration_variable\n                ]\n            )\n            + (self.children[0].id,)\n            + tuple(self.domain)\n        )",
  "def _unary_simplify(self, simplified_child):\n        \"\"\" See :meth:`UnaryOperator._unary_simplify()`. \"\"\"\n\n        return self.__class__(simplified_child, self.integration_variable)",
  "def _unary_new_copy(self, child):\n        \"\"\" See :meth:`UnaryOperator._unary_new_copy()`. \"\"\"\n\n        return self.__class__(child, self.integration_variable)",
  "def evaluate_for_shape(self):\n        \"\"\" See :meth:`pybamm.Symbol.evaluate_for_shape_using_domain()` \"\"\"\n        return pybamm.evaluate_for_shape_using_domain(self.domain)",
  "def evaluates_on_edges(self):\n        \"\"\" See :meth:`pybamm.Symbol.evaluates_on_edges()`. \"\"\"\n        return False",
  "def __init__(self, child, integration_variable):\n        if isinstance(integration_variable, list):\n            if len(integration_variable) > 1:\n                raise NotImplementedError(\n                    \"Indefinite integral only implemeted w.r.t. one variable\"\n                )\n            else:\n                integration_variable = integration_variable[0]\n        super().__init__(child, integration_variable)\n        # overwrite domains with child domains\n        self.auxiliary_domains = child.auxiliary_domains\n        self.domain = child.domain\n        # Overwrite the name\n        self.name = \"{} integrated w.r.t {}\".format(\n            child.name, integration_variable.name\n        )\n        if isinstance(integration_variable, pybamm.SpatialVariable):\n            self.name += \" on {}\".format(integration_variable.domain)",
  "def evaluate_for_shape(self):\n        return self.children[0].evaluate_for_shape()",
  "def __init__(self, child, vector_type=\"row\"):\n        name = \"basis integral\"\n        self.vector_type = vector_type\n        super().__init__(name, child)\n        # integrating removes the domain\n        self.domain = []",
  "def set_id(self):\n        \"\"\" See :meth:`pybamm.Symbol.set_id()` \"\"\"\n        self._id = hash(\n            (self.__class__, self.name, self.vector_type)\n            + (self.children[0].id,)\n            + tuple(self.domain)\n        )",
  "def _unary_simplify(self, simplified_child):\n        \"\"\" See :meth:`UnaryOperator._unary_simplify()`. \"\"\"\n\n        return self.__class__(simplified_child, vector_type=self.vector_type)",
  "def _unary_new_copy(self, child):\n        \"\"\" See :meth:`UnaryOperator._unary_new_copy()`. \"\"\"\n\n        return self.__class__(child, vector_type=self.vector_type)",
  "def evaluate_for_shape(self):\n        \"\"\" See :meth:`pybamm.Symbol.evaluate_for_shape_using_domain()` \"\"\"\n        return pybamm.evaluate_for_shape_using_domain(self.domain)",
  "def __init__(self, child, region=\"entire\"):\n        # boundary integral removes domain\n        domain = []\n        auxiliary_domains = {}\n\n        name = \"boundary integral over \"\n        if region == \"entire\":\n            name += \"entire boundary\"\n        elif region == \"negative tab\":\n            name += \"negative tab\"\n        elif region == \"positive tab\":\n            name += \"positive tab\"\n        self.region = region\n        super().__init__(\n            name, child, domain=domain, auxiliary_domains=auxiliary_domains\n        )",
  "def set_id(self):\n        \"\"\" See :meth:`pybamm.Symbol.set_id()` \"\"\"\n        self._id = hash(\n            (self.__class__, self.name) + (self.children[0].id,) + tuple(self.domain)\n        )",
  "def _unary_simplify(self, simplified_child):\n        \"\"\" See :meth:`UnaryOperator._unary_simplify()`. \"\"\"\n\n        return self.__class__(simplified_child, region=self.region)",
  "def _unary_new_copy(self, child):\n        \"\"\" See :meth:`UnaryOperator._unary_new_copy()`. \"\"\"\n\n        return self.__class__(child, region=self.region)",
  "def evaluate_for_shape(self):\n        \"\"\" See :meth:`pybamm.Symbol.evaluate_for_shape_using_domain()` \"\"\"\n        return pybamm.evaluate_for_shape_using_domain(self.domain)",
  "def evaluates_on_edges(self):\n        \"\"\" See :meth:`pybamm.Symbol.evaluates_on_edges()`. \"\"\"\n        return False",
  "def __init__(self, child, side, domain):\n        self.side = side\n        if child.domain != []:\n            auxiliary_domains = {\"secondary\": child.domain}\n        else:\n            auxiliary_domains = {}\n        super().__init__(\"delta function\", child, domain, auxiliary_domains)",
  "def set_id(self):\n        \"\"\" See :meth:`pybamm.Symbol.set_id()` \"\"\"\n        self._id = hash(\n            (self.__class__, self.name, self.side, self.children[0].id)\n            + tuple(self.domain)\n            + tuple([(k, tuple(v)) for k, v in self.auxiliary_domains.items()])\n        )",
  "def evaluates_on_edges(self):\n        \"\"\" See :meth:`pybamm.Symbol.evaluates_on_edges()`. \"\"\"\n        return False",
  "def _unary_simplify(self, simplified_child):\n        \"\"\" See :meth:`UnaryOperator._unary_simplify()`. \"\"\"\n        return self.__class__(simplified_child, self.side, self.domain)",
  "def _unary_new_copy(self, child):\n        \"\"\" See :meth:`UnaryOperator._unary_new_copy()`. \"\"\"\n        return self.__class__(child, self.side, self.domain)",
  "def __init__(self, name, child, side):\n        # side can only be \"negative tab\" or \"positive tab\" if domain is\n        # \"current collector\"\n        if side in [\"negative tab\", \"positive tab\"]:\n            if child.domain[0] != \"current collector\":\n                raise pybamm.ModelError(\n                    \"\"\"Can only take boundary value on the tabs in the domain\n                'current collector', but {} has domain {}\"\"\".format(\n                        child, child.domain[0]\n                    )\n                )\n        self.side = side\n        # boundary value of a child takes the domain from auxiliary domain of the child\n        if child.auxiliary_domains != {}:\n            domain = child.auxiliary_domains[\"secondary\"]\n        # if child has no auxiliary domain, integral removes domain\n        else:\n            domain = []\n        # tertiary auxiliary domain shift down to secondary\n        try:\n            auxiliary_domains = {\"secondary\": child.auxiliary_domains[\"tertiary\"]}\n        except KeyError:\n            auxiliary_domains = {}\n        super().__init__(\n            name, child, domain=domain, auxiliary_domains=auxiliary_domains\n        )",
  "def set_id(self):\n        \"\"\" See :meth:`pybamm.Symbol.set_id()` \"\"\"\n        self._id = hash(\n            (self.__class__, self.name, self.side, self.children[0].id)\n            + tuple(self.domain)\n            + tuple([(k, tuple(v)) for k, v in self.auxiliary_domains.items()])\n        )",
  "def _unary_simplify(self, simplified_child):\n        \"\"\" See :meth:`UnaryOperator._unary_simplify()`. \"\"\"\n        return self.__class__(simplified_child, self.side)",
  "def _unary_new_copy(self, child):\n        \"\"\" See :meth:`UnaryOperator._unary_new_copy()`. \"\"\"\n        return self.__class__(child, self.side)",
  "def evaluate_for_shape(self):\n        \"\"\" See :meth:`pybamm.Symbol.evaluate_for_shape_using_domain()` \"\"\"\n        return pybamm.evaluate_for_shape_using_domain(\n            self.domain, self.auxiliary_domains\n        )",
  "def __init__(self, child, side):\n        super().__init__(\"boundary value\", child, side)",
  "def __init__(self, child, side):\n        super().__init__(\"boundary flux\", child, side)",
  "class StateVector(pybamm.Symbol):\n    \"\"\"\n    node in the expression tree that holds a slice to read from an external vector type\n\n    Parameters\n    ----------\n\n    y_slice: slice\n        the slice of an external y to read\n    name: str, optional\n        the name of the node\n    domain : iterable of str, optional\n        list of domains the parameter is valid over, defaults to empty list\n    auxiliary_domains : dict of str, optional\n        dictionary of auxiliary domains\n    evaluation_array : list, optional\n        List of boolean arrays representing slices. Default is None, in which case the\n        evaluation_array is computed from y_slices.\n\n    *Extends:* :class:`Array`\n    \"\"\"\n\n    def __init__(\n        self,\n        *y_slices,\n        name=None,\n        domain=None,\n        auxiliary_domains=None,\n        evaluation_array=None,\n    ):\n        for y_slice in y_slices:\n            if not isinstance(y_slice, slice):\n                raise TypeError(\"all y_slices must be slice objects\")\n        if name is None:\n            if y_slices[0].start is None:\n                name = \"y[:{:d}]\".format(y_slice.stop)\n            else:\n                name = \"y[{:d}:{:d}\".format(y_slices[0].start, y_slices[0].stop)\n            if len(y_slices) > 1:\n                name += \",{:d}:{:d}\".format(y_slices[1].start, y_slices[1].stop)\n                if len(y_slices) > 2:\n                    name += \",...,{:d}:{:d}]\".format(\n                        y_slices[-1].start, y_slices[-1].stop\n                    )\n                else:\n                    name += \"]\"\n            else:\n                name += \"]\"\n        if domain is None:\n            domain = []\n        if auxiliary_domains is None:\n            auxiliary_domains = {}\n        self._y_slices = y_slices\n        self._first_point = y_slices[0].start\n        self._last_point = y_slices[-1].stop\n        self.set_evaluation_array(y_slices, evaluation_array)\n        super().__init__(name=name, domain=domain, auxiliary_domains=auxiliary_domains)\n\n    @property\n    def y_slices(self):\n        return self._y_slices\n\n    @property\n    def first_point(self):\n        return self._first_point\n\n    @property\n    def last_point(self):\n        return self._last_point\n\n    @property\n    def evaluation_array(self):\n        \"\"\"Array to use for evaluating\"\"\"\n        return self._evaluation_array\n\n    @property\n    def size(self):\n        return self.evaluation_array.count(True)\n\n    def set_evaluation_array(self, y_slices, evaluation_array):\n        \"Set evaluation array using slices\"\n        if evaluation_array is not None and pybamm.settings.debug_mode is False:\n            self._evaluation_array = evaluation_array\n        else:\n            array = np.zeros(y_slices[-1].stop)\n            for y_slice in y_slices:\n                array[y_slice] = True\n            self._evaluation_array = [bool(x) for x in array]\n\n    def set_id(self):\n        \"\"\" See :meth:`pybamm.Symbol.set_id()` \"\"\"\n        self._id = hash(\n            (self.__class__, self.name, tuple(self.evaluation_array))\n            + tuple(self.domain)\n        )\n\n    def _base_evaluate(self, t=None, y=None):\n        \"\"\" See :meth:`pybamm.Symbol._base_evaluate()`. \"\"\"\n        if y is None:\n            raise TypeError(\"StateVector cannot evaluate input 'y=None'\")\n        if y.shape[0] < len(self.evaluation_array):\n            raise ValueError(\n                \"y is too short, so value with slice is smaller than expected\"\n            )\n        else:\n            out = (y[: len(self._evaluation_array)])[self._evaluation_array]\n            if out.ndim == 1:\n                out = out[:, np.newaxis]\n            return out\n\n    def _jac(self, variable):\n        \"\"\"\n        Differentiate a slice of a StateVector of size m with respect to another\n        slice of a StateVector of size n. This returns a (sparse) matrix of size\n        m x n with ones where the y slices match, and zeros elsewhere.\n\n        Parameters\n        ----------\n        variable : :class:`pybamm.Symbol`\n            The variable with respect to which to differentiate\n\n        \"\"\"\n        if len(variable.y_slices) > 1:\n            raise NotImplementedError(\n                \"Jacobian only implemented for a single-slice StateVector\"\n            )\n        variable_y_indices = np.arange(variable.first_point, variable.last_point)\n\n        jac = csr_matrix((0, np.size(variable_y_indices)))\n        for y_slice in self.y_slices:\n            # Get indices of state vectors\n            slice_indices = np.arange(y_slice.start, y_slice.stop)\n\n            # Return zeros of correct size if no entries match\n            if np.size(np.intersect1d(slice_indices, variable_y_indices)) == 0:\n                jac = csr_matrix((np.size(slice_indices), np.size(variable_y_indices)))\n            else:\n                # Populate entries corresponding to matching y slices, and shift so\n                # that the matrix is the correct size\n                row = np.intersect1d(slice_indices, variable_y_indices) - y_slice.start\n                col = (\n                    np.intersect1d(slice_indices, variable_y_indices)\n                    - variable.first_point\n                )\n                data = np.ones_like(row)\n                jac = vstack(\n                    [\n                        jac,\n                        csr_matrix(\n                            (data, (row, col)),\n                            shape=(np.size(slice_indices), np.size(variable_y_indices)),\n                        ),\n                    ]\n                )\n        return pybamm.Matrix(jac)\n\n    def new_copy(self):\n        \"\"\" See :meth:`pybamm.Symbol.new_copy()`. \"\"\"\n        return StateVector(\n            *self.y_slices,\n            name=self.name,\n            domain=self.domain,\n            auxiliary_domains=self.auxiliary_domains,\n            evaluation_array=self.evaluation_array,\n        )\n\n    def evaluate_for_shape(self):\n        \"\"\"\n        Returns a vector of NaNs to represent the shape of a StateVector.\n        The size of a StateVector is the number of True elements in its evaluation_array\n        See :meth:`pybamm.Symbol.evaluate_for_shape()`\n        \"\"\"\n        return np.nan * np.ones((self.size, 1))",
  "def __init__(\n        self,\n        *y_slices,\n        name=None,\n        domain=None,\n        auxiliary_domains=None,\n        evaluation_array=None,\n    ):\n        for y_slice in y_slices:\n            if not isinstance(y_slice, slice):\n                raise TypeError(\"all y_slices must be slice objects\")\n        if name is None:\n            if y_slices[0].start is None:\n                name = \"y[:{:d}]\".format(y_slice.stop)\n            else:\n                name = \"y[{:d}:{:d}\".format(y_slices[0].start, y_slices[0].stop)\n            if len(y_slices) > 1:\n                name += \",{:d}:{:d}\".format(y_slices[1].start, y_slices[1].stop)\n                if len(y_slices) > 2:\n                    name += \",...,{:d}:{:d}]\".format(\n                        y_slices[-1].start, y_slices[-1].stop\n                    )\n                else:\n                    name += \"]\"\n            else:\n                name += \"]\"\n        if domain is None:\n            domain = []\n        if auxiliary_domains is None:\n            auxiliary_domains = {}\n        self._y_slices = y_slices\n        self._first_point = y_slices[0].start\n        self._last_point = y_slices[-1].stop\n        self.set_evaluation_array(y_slices, evaluation_array)\n        super().__init__(name=name, domain=domain, auxiliary_domains=auxiliary_domains)",
  "def y_slices(self):\n        return self._y_slices",
  "def first_point(self):\n        return self._first_point",
  "def last_point(self):\n        return self._last_point",
  "def evaluation_array(self):\n        \"\"\"Array to use for evaluating\"\"\"\n        return self._evaluation_array",
  "def size(self):\n        return self.evaluation_array.count(True)",
  "def set_evaluation_array(self, y_slices, evaluation_array):\n        \"Set evaluation array using slices\"\n        if evaluation_array is not None and pybamm.settings.debug_mode is False:\n            self._evaluation_array = evaluation_array\n        else:\n            array = np.zeros(y_slices[-1].stop)\n            for y_slice in y_slices:\n                array[y_slice] = True\n            self._evaluation_array = [bool(x) for x in array]",
  "def set_id(self):\n        \"\"\" See :meth:`pybamm.Symbol.set_id()` \"\"\"\n        self._id = hash(\n            (self.__class__, self.name, tuple(self.evaluation_array))\n            + tuple(self.domain)\n        )",
  "def _base_evaluate(self, t=None, y=None):\n        \"\"\" See :meth:`pybamm.Symbol._base_evaluate()`. \"\"\"\n        if y is None:\n            raise TypeError(\"StateVector cannot evaluate input 'y=None'\")\n        if y.shape[0] < len(self.evaluation_array):\n            raise ValueError(\n                \"y is too short, so value with slice is smaller than expected\"\n            )\n        else:\n            out = (y[: len(self._evaluation_array)])[self._evaluation_array]\n            if out.ndim == 1:\n                out = out[:, np.newaxis]\n            return out",
  "def _jac(self, variable):\n        \"\"\"\n        Differentiate a slice of a StateVector of size m with respect to another\n        slice of a StateVector of size n. This returns a (sparse) matrix of size\n        m x n with ones where the y slices match, and zeros elsewhere.\n\n        Parameters\n        ----------\n        variable : :class:`pybamm.Symbol`\n            The variable with respect to which to differentiate\n\n        \"\"\"\n        if len(variable.y_slices) > 1:\n            raise NotImplementedError(\n                \"Jacobian only implemented for a single-slice StateVector\"\n            )\n        variable_y_indices = np.arange(variable.first_point, variable.last_point)\n\n        jac = csr_matrix((0, np.size(variable_y_indices)))\n        for y_slice in self.y_slices:\n            # Get indices of state vectors\n            slice_indices = np.arange(y_slice.start, y_slice.stop)\n\n            # Return zeros of correct size if no entries match\n            if np.size(np.intersect1d(slice_indices, variable_y_indices)) == 0:\n                jac = csr_matrix((np.size(slice_indices), np.size(variable_y_indices)))\n            else:\n                # Populate entries corresponding to matching y slices, and shift so\n                # that the matrix is the correct size\n                row = np.intersect1d(slice_indices, variable_y_indices) - y_slice.start\n                col = (\n                    np.intersect1d(slice_indices, variable_y_indices)\n                    - variable.first_point\n                )\n                data = np.ones_like(row)\n                jac = vstack(\n                    [\n                        jac,\n                        csr_matrix(\n                            (data, (row, col)),\n                            shape=(np.size(slice_indices), np.size(variable_y_indices)),\n                        ),\n                    ]\n                )\n        return pybamm.Matrix(jac)",
  "def new_copy(self):\n        \"\"\" See :meth:`pybamm.Symbol.new_copy()`. \"\"\"\n        return StateVector(\n            *self.y_slices,\n            name=self.name,\n            domain=self.domain,\n            auxiliary_domains=self.auxiliary_domains,\n            evaluation_array=self.evaluation_array,\n        )",
  "def evaluate_for_shape(self):\n        \"\"\"\n        Returns a vector of NaNs to represent the shape of a StateVector.\n        The size of a StateVector is the number of True elements in its evaluation_array\n        See :meth:`pybamm.Symbol.evaluate_for_shape()`\n        \"\"\"\n        return np.nan * np.ones((self.size, 1))",
  "class Geometry(dict):\n\n    \"\"\"\n    A geometry class to store the details features of the cell geometry.\n\n    Geometry extends the class dictionary and uses the key words: \"negative electrode\",\n    \"positive electrode\", etc to indicate the subdomain.  Within each subdomain, there\n    are \"primary\", \"secondary\" or \"tabs\" dimensions.  \"primary\" dimensions correspond to\n    dimensions on which spatial operators will be applied (e.g. the gradient and\n    divergence). In contrast, spatial operators do not act along \"secondary\" dimensions.\n    This allows for multiple independent particles to be included into a model.\n\n    The values assigned to each domain are dictionaries containing the spatial variables\n    in that domain, along with expression trees giving their min and maximum extents.\n    For example, the following dictionary structure would represent a Geometry with a\n    single domain \"negative electrode\", defined using the variable `x_n` which has a\n    range from 0 to the pre-defined parameter `l_n`.\n\n    .. code-block:: python\n\n       {\n           \"negative electrode\": {\n               \"primary\": {x_n: {\"min\": pybamm.Scalar(0), \"max\": l_n}}\n           }\n       }\n\n    A user can create a new Geometry by combining one or more of the pre-defined\n    geometries defined with the names given below.\n\n    - \"1D macro\": macroscopic 1D cell geometry (i.e. electrodes)\n    - \"3D macro\": macroscopic 3D cell geometry\n    - \"1+1D macro\": 1D macroscopic cell geometry with a 1D current collector\n    - \"1+2D macro\": 1D macroscopic cell geometry with a 2D current collector\n    - \"1D micro\": 1D microscopic cell geometry (i.e. particles)\n    - \"1+1D micro\": This is the geometry used in the standard DFN or P2D model\n    - \"(1+0)+1D micro\": 0D macroscopic cell geometry with 1D current collector,\n                        along with the microscopic 1D particle geometry.\n    - \"(2+0)+1D micro\": 0D macroscopic cell geometry with 1D current collector,\n                        along with the microscopic 1D particle geometry.\n    - \"(1+1)+1D micro\": 1D macroscopic cell geometry, with 1D current collector model,\n                        along with the microscopic 1D particle geometry.\n    - \"(2+1)+1D micro\": 1D macroscopic cell geometry, with 2D current collector model,\n                        along with the microscopic 1D particle geometry.\n    - \"2D current collector\": macroscopic 2D current collector geometry\n\n    **Extends**: :class:`dict`\n\n    Parameters\n    ----------\n\n    geometries: one or more strings or Geometry objects. A string will be assumed to be\n                one of the predefined Geometries given above\n\n    custom_geometry : dict containing any extra user defined geometry\n    \"\"\"\n\n    def __init__(self, *geometries, custom_geometry={}):\n        for geometry in geometries:\n            if geometry == \"1D macro\":\n                geometry = Geometry1DMacro()\n            elif geometry == \"3D macro\":\n                geometry = Geometry3DMacro()\n            elif geometry == \"1+1D macro\":\n                geometry = Geometryxp1DMacro(cc_dimension=1)\n            elif geometry == \"2+1D macro\":\n                geometry = Geometryxp1DMacro(cc_dimension=2)\n            elif geometry == \"1D micro\":\n                geometry = Geometry1DMicro()\n            elif geometry == \"1+1D micro\":\n                geometry = Geometry1p1DMicro()\n            elif geometry == \"(1+0)+1D micro\":\n                geometry = Geometryxp0p1DMicro(cc_dimension=1)\n            elif geometry == \"(2+0)+1D micro\":\n                geometry = Geometryxp0p1DMicro(cc_dimension=2)\n            elif geometry == \"(1+1)+1D micro\":\n                geometry = Geometryxp1p1DMicro(cc_dimension=1)\n            elif geometry == \"(2+1)+1D micro\":\n                geometry = Geometryxp1p1DMicro(cc_dimension=2)\n            elif geometry == \"2D current collector\":\n                geometry = Geometry2DCurrentCollector()\n            # avoid combining geometries that clash\n            if any([k in self.keys() for k in geometry.keys()]):\n                raise ValueError(\"trying to overwrite existing geometry\")\n\n            for k, v in geometry.items():\n                self.add_domain(k, v)\n\n        # Allow overwriting with a custom geometry\n        for k, v in custom_geometry.items():\n            self.add_domain(k, v)\n\n    def add_domain(self, name, geometry):\n        \"\"\"\n        Add a new domain to the geometry\n\n        Parameters\n        ----------\n\n        name: string giving the name of the domain\n\n        geometry: dict of variables in the domain, along with the minimum and maximum\n                extents (e.g. {\"primary\": {x_n: {\"min\": pybamm.Scalar(0), \"max\": l_n}}}\n        \"\"\"\n        if not isinstance(name, str):\n            raise ValueError(\"name must be a string\")\n\n        for k, v in geometry.items():\n            if k not in [\"primary\", \"secondary\", \"tabs\"]:\n                raise ValueError(\n                    'keys of geometry must be either \"primary\", \"secondary\" or '\n                    '\"tabs\"'\n                )\n            if k != \"tabs\":\n                for variable, rnge in v.items():\n                    if not isinstance(variable, pybamm.SpatialVariable):\n                        raise ValueError(\n                            \"inner dict of geometry must have pybamm.SpatialVariable \"\n                            \"as keys\"\n                        )\n                    if list(rnge.keys()) != [\"position\"]:\n                        if \"min\" not in rnge.keys():\n                            raise ValueError(\n                                \"no minimum extents for variable {}\".format(variable)\n                            )\n                        if \"max\" not in rnge.keys():\n                            raise ValueError(\n                                \"no maximum extents for variable {}\".format(variable)\n                            )\n            else:\n                for region, params in v.items():\n                    if region not in [\"negative\", \"positive\"]:\n                        raise ValueError('tabs region must be \"negative\" or \"positive\"')\n                    for pname in params.keys():\n                        if pname not in [\"y_centre\", \"z_centre\", \"width\"]:\n                            raise ValueError(\n                                'tabs region params must be \"y_centre\", '\n                                '\"z_centre\" or \"width\"'\n                            )\n\n        self.update({name: geometry})",
  "class Geometry1DMacro(Geometry):\n    \"\"\"\n    A geometry class to store the details features of the macroscopic 1D cell geometry.\n\n    **Extends**: :class:`Geometry`\n\n    Parameters\n    ----------\n\n    custom_geometry : dict containing any extra user defined geometry\n    \"\"\"\n\n    def __init__(self, custom_geometry={}):\n        super().__init__()\n        var = pybamm.standard_spatial_vars\n        l_n = pybamm.geometric_parameters.l_n\n        l_s = pybamm.geometric_parameters.l_s\n\n        self[\"negative electrode\"] = {\n            \"primary\": {var.x_n: {\"min\": pybamm.Scalar(0), \"max\": l_n}}\n        }\n        self[\"separator\"] = {\"primary\": {var.x_s: {\"min\": l_n, \"max\": l_n + l_s}}}\n        self[\"positive electrode\"] = {\n            \"primary\": {var.x_p: {\"min\": l_n + l_s, \"max\": pybamm.Scalar(1)}}\n        }\n        self[\"current collector\"] = {\"primary\": {var.z: {\"position\": pybamm.Scalar(1)}}}\n\n        # update with custom geometry if non empty\n        self.update(custom_geometry)",
  "class Geometry3DMacro(Geometry1DMacro):\n    \"\"\"\n    A geometry class to store the details features of the macroscopic 3D cell geometry.\n\n    **Extends**: :class:`Geometry1DMacro`\n\n    Parameters\n    ----------\n\n    custom_geometry : dict containing any extra user defined geometry\n    \"\"\"\n\n    def __init__(self, custom_geometry={}):\n        super().__init__()\n\n        var = pybamm.standard_spatial_vars\n\n        y_lim = {\"min\": pybamm.Scalar(0), \"max\": pybamm.geometric_parameters.l_y}\n\n        z_lim = {\"min\": pybamm.Scalar(0), \"max\": pybamm.geometric_parameters.l_z}\n\n        for domain in self.keys():\n            self[domain][\"primary\"][var.y] = y_lim\n            self[domain][\"primary\"][var.z] = z_lim\n        self.update(custom_geometry)",
  "class Geometry1DMicro(Geometry):\n    \"\"\"\n    A geometry class to store the details features of the microscopic 1D particle\n    geometry.\n\n    **Extends**: :class:`Geometry`\n\n    Parameters\n    ----------\n\n    custom_geometry : dict containing any extra user defined geometry\n    \"\"\"\n\n    def __init__(self, custom_geometry={}):\n        super().__init__()\n\n        var = pybamm.standard_spatial_vars\n\n        self[\"negative particle\"] = {\n            \"primary\": {var.r_n: {\"min\": pybamm.Scalar(0), \"max\": pybamm.Scalar(1)}}\n        }\n        self[\"positive particle\"] = {\n            \"primary\": {var.r_p: {\"min\": pybamm.Scalar(0), \"max\": pybamm.Scalar(1)}}\n        }\n        # update with custom geometry if non empty\n        self.update(custom_geometry)",
  "class Geometry1p1DMicro(Geometry):\n    \"\"\"\n    A geometry class to store the details features of the 1+1D cell geometry.\n    This is the geometry used in the standard DFN or P2D model.\n\n    **Extends**: :class:`Geometry`\n\n    Parameters\n    ----------\n\n    custom_geometry : dict containing any extra user defined geometry\n    \"\"\"\n\n    def __init__(self, custom_geometry={}):\n        super().__init__()\n\n        var = pybamm.standard_spatial_vars\n        l_n = pybamm.geometric_parameters.l_n\n        l_s = pybamm.geometric_parameters.l_s\n\n        self[\"negative particle\"] = {\n            \"primary\": {var.r_n: {\"min\": pybamm.Scalar(0), \"max\": pybamm.Scalar(1)}},\n            \"secondary\": {var.x_n: {\"min\": pybamm.Scalar(0), \"max\": l_n}},\n        }\n        self[\"positive particle\"] = {\n            \"primary\": {var.r_p: {\"min\": pybamm.Scalar(0), \"max\": pybamm.Scalar(1)}},\n            \"secondary\": {var.x_p: {\"min\": l_n + l_s, \"max\": pybamm.Scalar(1)}},\n        }\n        # update with custom geometry if non empty\n        self.update(custom_geometry)",
  "class Geometryxp1DMacro(Geometry1DMacro):\n    \"\"\"\n    A geometry class to store the details features of x+1D macroscopic cell\n    geometry, where x is the dimension of the current collector model.\n\n    **Extends**: :class:`Geometry1DMacro`\n\n    Parameters\n    ----------\n\n    cc_dimension : int, optional\n        the dimension of the current collector model\n    custom_geometry : dict, optional\n        dictionary containing any extra user defined geometry\n    \"\"\"\n\n    def __init__(self, cc_dimension=1, custom_geometry={}):\n        super().__init__()\n\n        var = pybamm.standard_spatial_vars\n\n        if cc_dimension == 1:\n            # Add secondary domains to x-domains\n            for geom in self.values():\n                geom[\"secondary\"] = {\n                    var.z: {\n                        \"min\": pybamm.Scalar(0),\n                        \"max\": pybamm.geometric_parameters.l_z,\n                    }\n                }\n            # Add primary current collector domain\n            self[\"current collector\"] = {\n                \"primary\": {\n                    var.z: {\n                        \"min\": pybamm.Scalar(0),\n                        \"max\": pybamm.geometric_parameters.l_z,\n                    }\n                },\n                \"tabs\": {\n                    \"negative\": {\n                        \"z_centre\": pybamm.geometric_parameters.centre_z_tab_n\n                    },\n                    \"positive\": {\n                        \"z_centre\": pybamm.geometric_parameters.centre_z_tab_p\n                    },\n                },\n            }\n        elif cc_dimension == 2:\n            # Add secondary domains to x-domains\n            for geom in self.values():\n                geom[\"secondary\"] = {\n                    var.y: {\n                        \"min\": pybamm.Scalar(0),\n                        \"max\": pybamm.geometric_parameters.l_y,\n                    },\n                    var.z: {\n                        \"min\": pybamm.Scalar(0),\n                        \"max\": pybamm.geometric_parameters.l_z,\n                    },\n                }\n            # Add primary current collector domain\n            self[\"current collector\"] = {\n                \"primary\": {\n                    var.y: {\n                        \"min\": pybamm.Scalar(0),\n                        \"max\": pybamm.geometric_parameters.l_y,\n                    },\n                    var.z: {\n                        \"min\": pybamm.Scalar(0),\n                        \"max\": pybamm.geometric_parameters.l_z,\n                    },\n                },\n                \"tabs\": {\n                    \"negative\": {\n                        \"y_centre\": pybamm.geometric_parameters.centre_y_tab_n,\n                        \"z_centre\": pybamm.geometric_parameters.centre_z_tab_n,\n                        \"width\": pybamm.geometric_parameters.l_tab_n,\n                    },\n                    \"positive\": {\n                        \"y_centre\": pybamm.geometric_parameters.centre_y_tab_p,\n                        \"z_centre\": pybamm.geometric_parameters.centre_z_tab_p,\n                        \"width\": pybamm.geometric_parameters.l_tab_p,\n                    },\n                },\n            }\n        else:\n            raise pybamm.GeometryError(\n                \"current collector dimension must be 1 or 2, not {}\".format(\n                    cc_dimension\n                )\n            )\n\n        # update with custom geometry if non empty\n        self.update(custom_geometry)",
  "class Geometryxp0p1DMicro(Geometry1DMicro):\n    \"\"\"\n    A geometry class to store the details features of x+0D macroscopic cell\n    geometry, where x is the dimension of the current collector model, along with\n    the microscopic 1D particle geometry.\n\n    **Extends**: :class:`Geometry1DMicro`\n\n    Parameters\n    ----------\n\n    cc_dimension : int, optional\n        the dimension of the current collector model\n    custom_geometry : dict, optional\n        dictionary containing any extra user defined geometry\n    \"\"\"\n\n    def __init__(self, cc_dimension=1, custom_geometry={}):\n        super().__init__()\n\n        var = pybamm.standard_spatial_vars\n\n        # Add secondary domains to x-domains\n        if cc_dimension == 1:\n            for domain in self.keys():\n                self[domain][\"secondary\"] = {\n                    var.z: {\n                        \"min\": pybamm.Scalar(0),\n                        \"max\": pybamm.geometric_parameters.l_z,\n                    }\n                }\n        elif cc_dimension == 2:\n            for domain in self.keys():\n                self[domain][\"secondary\"] = {\n                    var.y: {\n                        \"min\": pybamm.Scalar(0),\n                        \"max\": pybamm.geometric_parameters.l_y,\n                    },\n                    var.z: {\n                        \"min\": pybamm.Scalar(0),\n                        \"max\": pybamm.geometric_parameters.l_z,\n                    },\n                }\n        else:\n            raise pybamm.GeometryError(\n                \"current collector dimension must be 1 or 2, not {}\".format(\n                    cc_dimension\n                )\n            )\n\n        # update with custom geometry if non empty\n        self.update(custom_geometry)",
  "class Geometryxp1p1DMicro(Geometry1DMicro):\n    \"\"\"\n    A geometry class to store the details features of x+1D macroscopic cell\n    geometry, where x is the dimension of the current collector model, along with\n    the microscopic 1D particle geometry.\n\n    **Extends**: :class:`Geometry1DMicro`\n\n    Parameters\n    ----------\n\n    cc_dimension : int, optional\n        the dimension of the current collector model\n    custom_geometry : dict, optional\n        dictionary containing any extra user defined geometry\n    \"\"\"\n\n    def __init__(self, cc_dimension=1, custom_geometry={}):\n        super().__init__()\n\n        var = pybamm.standard_spatial_vars\n        l_n = pybamm.geometric_parameters.l_n\n        l_s = pybamm.geometric_parameters.l_s\n\n        # Add secondary domains to x-domains\n        if cc_dimension == 1:\n            self[\"negative particle\"][\"secondary\"] = {\n                var.x_n: {\"min\": pybamm.Scalar(0), \"max\": l_n},\n                var.z: {\n                    \"min\": pybamm.Scalar(0),\n                    \"max\": pybamm.geometric_parameters.l_z,\n                },\n            }\n            self[\"positive particle\"][\"secondary\"] = {\n                var.x_p: {\"min\": l_n + l_s, \"max\": pybamm.Scalar(1)},\n                var.z: {\n                    \"min\": pybamm.Scalar(0),\n                    \"max\": pybamm.geometric_parameters.l_z,\n                },\n            }\n        elif cc_dimension == 2:\n            self[\"negative particle\"][\"secondary\"] = {\n                var.x_n: {\"min\": pybamm.Scalar(0), \"max\": l_n},\n                var.y: {\n                    \"min\": pybamm.Scalar(0),\n                    \"max\": pybamm.geometric_parameters.l_y,\n                },\n                var.z: {\n                    \"min\": pybamm.Scalar(0),\n                    \"max\": pybamm.geometric_parameters.l_z,\n                },\n            }\n            self[\"positive particle\"][\"secondary\"] = {\n                var.x_p: {\"min\": l_n + l_s, \"max\": pybamm.Scalar(1)},\n                var.y: {\n                    \"min\": pybamm.Scalar(0),\n                    \"max\": pybamm.geometric_parameters.l_y,\n                },\n                var.z: {\n                    \"min\": pybamm.Scalar(0),\n                    \"max\": pybamm.geometric_parameters.l_z,\n                },\n            }\n        else:\n            raise pybamm.GeometryError(\n                \"current collector dimension must be 1 or 2, not {}\".format(\n                    cc_dimension\n                )\n            )\n\n        # update with custom geometry if non empty\n        self.update(custom_geometry)",
  "class Geometry2DCurrentCollector(Geometry):\n    \"\"\"\n    A geometry class to store the details features of the macroscopic 2D\n    current collector geometry.\n\n    **Extends**: :class:`Geometry`\n\n    Parameters\n    ----------\n\n    custom_geometry : dict containing any extra user defined geometry\n    \"\"\"\n\n    def __init__(self, custom_geometry={}):\n        super().__init__()\n        var = pybamm.standard_spatial_vars\n\n        self[\"current collector\"] = {\n            \"primary\": {\n                var.y: {\n                    \"min\": pybamm.Scalar(0),\n                    \"max\": pybamm.geometric_parameters.l_y,\n                },\n                var.z: {\n                    \"min\": pybamm.Scalar(0),\n                    \"max\": pybamm.geometric_parameters.l_z,\n                },\n            },\n            \"tabs\": {\n                \"negative\": {\n                    \"y_centre\": pybamm.geometric_parameters.centre_y_tab_n,\n                    \"z_centre\": pybamm.geometric_parameters.centre_z_tab_n,\n                    \"width\": pybamm.geometric_parameters.l_tab_n,\n                },\n                \"positive\": {\n                    \"y_centre\": pybamm.geometric_parameters.centre_y_tab_p,\n                    \"z_centre\": pybamm.geometric_parameters.centre_z_tab_p,\n                    \"width\": pybamm.geometric_parameters.l_tab_p,\n                },\n            },\n        }\n\n        # update with custom geometry if non empty\n        self.update(custom_geometry)",
  "def __init__(self, *geometries, custom_geometry={}):\n        for geometry in geometries:\n            if geometry == \"1D macro\":\n                geometry = Geometry1DMacro()\n            elif geometry == \"3D macro\":\n                geometry = Geometry3DMacro()\n            elif geometry == \"1+1D macro\":\n                geometry = Geometryxp1DMacro(cc_dimension=1)\n            elif geometry == \"2+1D macro\":\n                geometry = Geometryxp1DMacro(cc_dimension=2)\n            elif geometry == \"1D micro\":\n                geometry = Geometry1DMicro()\n            elif geometry == \"1+1D micro\":\n                geometry = Geometry1p1DMicro()\n            elif geometry == \"(1+0)+1D micro\":\n                geometry = Geometryxp0p1DMicro(cc_dimension=1)\n            elif geometry == \"(2+0)+1D micro\":\n                geometry = Geometryxp0p1DMicro(cc_dimension=2)\n            elif geometry == \"(1+1)+1D micro\":\n                geometry = Geometryxp1p1DMicro(cc_dimension=1)\n            elif geometry == \"(2+1)+1D micro\":\n                geometry = Geometryxp1p1DMicro(cc_dimension=2)\n            elif geometry == \"2D current collector\":\n                geometry = Geometry2DCurrentCollector()\n            # avoid combining geometries that clash\n            if any([k in self.keys() for k in geometry.keys()]):\n                raise ValueError(\"trying to overwrite existing geometry\")\n\n            for k, v in geometry.items():\n                self.add_domain(k, v)\n\n        # Allow overwriting with a custom geometry\n        for k, v in custom_geometry.items():\n            self.add_domain(k, v)",
  "def add_domain(self, name, geometry):\n        \"\"\"\n        Add a new domain to the geometry\n\n        Parameters\n        ----------\n\n        name: string giving the name of the domain\n\n        geometry: dict of variables in the domain, along with the minimum and maximum\n                extents (e.g. {\"primary\": {x_n: {\"min\": pybamm.Scalar(0), \"max\": l_n}}}\n        \"\"\"\n        if not isinstance(name, str):\n            raise ValueError(\"name must be a string\")\n\n        for k, v in geometry.items():\n            if k not in [\"primary\", \"secondary\", \"tabs\"]:\n                raise ValueError(\n                    'keys of geometry must be either \"primary\", \"secondary\" or '\n                    '\"tabs\"'\n                )\n            if k != \"tabs\":\n                for variable, rnge in v.items():\n                    if not isinstance(variable, pybamm.SpatialVariable):\n                        raise ValueError(\n                            \"inner dict of geometry must have pybamm.SpatialVariable \"\n                            \"as keys\"\n                        )\n                    if list(rnge.keys()) != [\"position\"]:\n                        if \"min\" not in rnge.keys():\n                            raise ValueError(\n                                \"no minimum extents for variable {}\".format(variable)\n                            )\n                        if \"max\" not in rnge.keys():\n                            raise ValueError(\n                                \"no maximum extents for variable {}\".format(variable)\n                            )\n            else:\n                for region, params in v.items():\n                    if region not in [\"negative\", \"positive\"]:\n                        raise ValueError('tabs region must be \"negative\" or \"positive\"')\n                    for pname in params.keys():\n                        if pname not in [\"y_centre\", \"z_centre\", \"width\"]:\n                            raise ValueError(\n                                'tabs region params must be \"y_centre\", '\n                                '\"z_centre\" or \"width\"'\n                            )\n\n        self.update({name: geometry})",
  "def __init__(self, custom_geometry={}):\n        super().__init__()\n        var = pybamm.standard_spatial_vars\n        l_n = pybamm.geometric_parameters.l_n\n        l_s = pybamm.geometric_parameters.l_s\n\n        self[\"negative electrode\"] = {\n            \"primary\": {var.x_n: {\"min\": pybamm.Scalar(0), \"max\": l_n}}\n        }\n        self[\"separator\"] = {\"primary\": {var.x_s: {\"min\": l_n, \"max\": l_n + l_s}}}\n        self[\"positive electrode\"] = {\n            \"primary\": {var.x_p: {\"min\": l_n + l_s, \"max\": pybamm.Scalar(1)}}\n        }\n        self[\"current collector\"] = {\"primary\": {var.z: {\"position\": pybamm.Scalar(1)}}}\n\n        # update with custom geometry if non empty\n        self.update(custom_geometry)",
  "def __init__(self, custom_geometry={}):\n        super().__init__()\n\n        var = pybamm.standard_spatial_vars\n\n        y_lim = {\"min\": pybamm.Scalar(0), \"max\": pybamm.geometric_parameters.l_y}\n\n        z_lim = {\"min\": pybamm.Scalar(0), \"max\": pybamm.geometric_parameters.l_z}\n\n        for domain in self.keys():\n            self[domain][\"primary\"][var.y] = y_lim\n            self[domain][\"primary\"][var.z] = z_lim\n        self.update(custom_geometry)",
  "def __init__(self, custom_geometry={}):\n        super().__init__()\n\n        var = pybamm.standard_spatial_vars\n\n        self[\"negative particle\"] = {\n            \"primary\": {var.r_n: {\"min\": pybamm.Scalar(0), \"max\": pybamm.Scalar(1)}}\n        }\n        self[\"positive particle\"] = {\n            \"primary\": {var.r_p: {\"min\": pybamm.Scalar(0), \"max\": pybamm.Scalar(1)}}\n        }\n        # update with custom geometry if non empty\n        self.update(custom_geometry)",
  "def __init__(self, custom_geometry={}):\n        super().__init__()\n\n        var = pybamm.standard_spatial_vars\n        l_n = pybamm.geometric_parameters.l_n\n        l_s = pybamm.geometric_parameters.l_s\n\n        self[\"negative particle\"] = {\n            \"primary\": {var.r_n: {\"min\": pybamm.Scalar(0), \"max\": pybamm.Scalar(1)}},\n            \"secondary\": {var.x_n: {\"min\": pybamm.Scalar(0), \"max\": l_n}},\n        }\n        self[\"positive particle\"] = {\n            \"primary\": {var.r_p: {\"min\": pybamm.Scalar(0), \"max\": pybamm.Scalar(1)}},\n            \"secondary\": {var.x_p: {\"min\": l_n + l_s, \"max\": pybamm.Scalar(1)}},\n        }\n        # update with custom geometry if non empty\n        self.update(custom_geometry)",
  "def __init__(self, cc_dimension=1, custom_geometry={}):\n        super().__init__()\n\n        var = pybamm.standard_spatial_vars\n\n        if cc_dimension == 1:\n            # Add secondary domains to x-domains\n            for geom in self.values():\n                geom[\"secondary\"] = {\n                    var.z: {\n                        \"min\": pybamm.Scalar(0),\n                        \"max\": pybamm.geometric_parameters.l_z,\n                    }\n                }\n            # Add primary current collector domain\n            self[\"current collector\"] = {\n                \"primary\": {\n                    var.z: {\n                        \"min\": pybamm.Scalar(0),\n                        \"max\": pybamm.geometric_parameters.l_z,\n                    }\n                },\n                \"tabs\": {\n                    \"negative\": {\n                        \"z_centre\": pybamm.geometric_parameters.centre_z_tab_n\n                    },\n                    \"positive\": {\n                        \"z_centre\": pybamm.geometric_parameters.centre_z_tab_p\n                    },\n                },\n            }\n        elif cc_dimension == 2:\n            # Add secondary domains to x-domains\n            for geom in self.values():\n                geom[\"secondary\"] = {\n                    var.y: {\n                        \"min\": pybamm.Scalar(0),\n                        \"max\": pybamm.geometric_parameters.l_y,\n                    },\n                    var.z: {\n                        \"min\": pybamm.Scalar(0),\n                        \"max\": pybamm.geometric_parameters.l_z,\n                    },\n                }\n            # Add primary current collector domain\n            self[\"current collector\"] = {\n                \"primary\": {\n                    var.y: {\n                        \"min\": pybamm.Scalar(0),\n                        \"max\": pybamm.geometric_parameters.l_y,\n                    },\n                    var.z: {\n                        \"min\": pybamm.Scalar(0),\n                        \"max\": pybamm.geometric_parameters.l_z,\n                    },\n                },\n                \"tabs\": {\n                    \"negative\": {\n                        \"y_centre\": pybamm.geometric_parameters.centre_y_tab_n,\n                        \"z_centre\": pybamm.geometric_parameters.centre_z_tab_n,\n                        \"width\": pybamm.geometric_parameters.l_tab_n,\n                    },\n                    \"positive\": {\n                        \"y_centre\": pybamm.geometric_parameters.centre_y_tab_p,\n                        \"z_centre\": pybamm.geometric_parameters.centre_z_tab_p,\n                        \"width\": pybamm.geometric_parameters.l_tab_p,\n                    },\n                },\n            }\n        else:\n            raise pybamm.GeometryError(\n                \"current collector dimension must be 1 or 2, not {}\".format(\n                    cc_dimension\n                )\n            )\n\n        # update with custom geometry if non empty\n        self.update(custom_geometry)",
  "def __init__(self, cc_dimension=1, custom_geometry={}):\n        super().__init__()\n\n        var = pybamm.standard_spatial_vars\n\n        # Add secondary domains to x-domains\n        if cc_dimension == 1:\n            for domain in self.keys():\n                self[domain][\"secondary\"] = {\n                    var.z: {\n                        \"min\": pybamm.Scalar(0),\n                        \"max\": pybamm.geometric_parameters.l_z,\n                    }\n                }\n        elif cc_dimension == 2:\n            for domain in self.keys():\n                self[domain][\"secondary\"] = {\n                    var.y: {\n                        \"min\": pybamm.Scalar(0),\n                        \"max\": pybamm.geometric_parameters.l_y,\n                    },\n                    var.z: {\n                        \"min\": pybamm.Scalar(0),\n                        \"max\": pybamm.geometric_parameters.l_z,\n                    },\n                }\n        else:\n            raise pybamm.GeometryError(\n                \"current collector dimension must be 1 or 2, not {}\".format(\n                    cc_dimension\n                )\n            )\n\n        # update with custom geometry if non empty\n        self.update(custom_geometry)",
  "def __init__(self, cc_dimension=1, custom_geometry={}):\n        super().__init__()\n\n        var = pybamm.standard_spatial_vars\n        l_n = pybamm.geometric_parameters.l_n\n        l_s = pybamm.geometric_parameters.l_s\n\n        # Add secondary domains to x-domains\n        if cc_dimension == 1:\n            self[\"negative particle\"][\"secondary\"] = {\n                var.x_n: {\"min\": pybamm.Scalar(0), \"max\": l_n},\n                var.z: {\n                    \"min\": pybamm.Scalar(0),\n                    \"max\": pybamm.geometric_parameters.l_z,\n                },\n            }\n            self[\"positive particle\"][\"secondary\"] = {\n                var.x_p: {\"min\": l_n + l_s, \"max\": pybamm.Scalar(1)},\n                var.z: {\n                    \"min\": pybamm.Scalar(0),\n                    \"max\": pybamm.geometric_parameters.l_z,\n                },\n            }\n        elif cc_dimension == 2:\n            self[\"negative particle\"][\"secondary\"] = {\n                var.x_n: {\"min\": pybamm.Scalar(0), \"max\": l_n},\n                var.y: {\n                    \"min\": pybamm.Scalar(0),\n                    \"max\": pybamm.geometric_parameters.l_y,\n                },\n                var.z: {\n                    \"min\": pybamm.Scalar(0),\n                    \"max\": pybamm.geometric_parameters.l_z,\n                },\n            }\n            self[\"positive particle\"][\"secondary\"] = {\n                var.x_p: {\"min\": l_n + l_s, \"max\": pybamm.Scalar(1)},\n                var.y: {\n                    \"min\": pybamm.Scalar(0),\n                    \"max\": pybamm.geometric_parameters.l_y,\n                },\n                var.z: {\n                    \"min\": pybamm.Scalar(0),\n                    \"max\": pybamm.geometric_parameters.l_z,\n                },\n            }\n        else:\n            raise pybamm.GeometryError(\n                \"current collector dimension must be 1 or 2, not {}\".format(\n                    cc_dimension\n                )\n            )\n\n        # update with custom geometry if non empty\n        self.update(custom_geometry)",
  "def __init__(self, custom_geometry={}):\n        super().__init__()\n        var = pybamm.standard_spatial_vars\n\n        self[\"current collector\"] = {\n            \"primary\": {\n                var.y: {\n                    \"min\": pybamm.Scalar(0),\n                    \"max\": pybamm.geometric_parameters.l_y,\n                },\n                var.z: {\n                    \"min\": pybamm.Scalar(0),\n                    \"max\": pybamm.geometric_parameters.l_z,\n                },\n            },\n            \"tabs\": {\n                \"negative\": {\n                    \"y_centre\": pybamm.geometric_parameters.centre_y_tab_n,\n                    \"z_centre\": pybamm.geometric_parameters.centre_z_tab_n,\n                    \"width\": pybamm.geometric_parameters.l_tab_n,\n                },\n                \"positive\": {\n                    \"y_centre\": pybamm.geometric_parameters.centre_y_tab_p,\n                    \"z_centre\": pybamm.geometric_parameters.centre_z_tab_p,\n                    \"width\": pybamm.geometric_parameters.l_tab_p,\n                },\n            },\n        }\n\n        # update with custom geometry if non empty\n        self.update(custom_geometry)"
]