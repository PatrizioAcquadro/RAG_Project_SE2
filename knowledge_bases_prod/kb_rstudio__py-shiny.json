[
  "def gen_init_py(package_name: str) -> None:\n    \"\"\"\n    Generate imports for __init__.py for a package or subpackage.\n    \"\"\"\n    pkg = importlib.import_module(package_name)\n    print(\"\")\n    print(\"=\" * 80)\n    print(pkg)\n    print(\"=\" * 80)\n\n    all_imports: list[str] = []\n    for name in dir(pkg):\n        submodule = getattr(pkg, name)\n        if isinstance(submodule, ModuleType):\n            # print(submodule)\n            all = getattr(submodule, \"__all__\", None)\n            all = cast(Union[tuple[str], None], all)\n            if all is not None:\n                if not submodule.__name__.startswith(pkg.__name__ + \".\"):\n                    continue\n                    # print(\n                    #     f\"{name}: {submodule.__name__} does not appear to be a submodule of {pkg.__name__}\"\n                    # )\n\n                all_imports.extend(all)\n\n                submodule_relname = submodule.__name__.removeprefix(pkg.__name__)\n                out = f\"from {submodule_relname} import \" + \", \".join(all)\n                print(out)",
  "class _InputHandlers(Dict[str, InputHandlerType]):\n    def __init__(self):\n        super().__init__()\n\n    def add(self, type: str, force: bool = False) -> Callable[[InputHandlerType], None]:\n        def _(func: InputHandlerType):\n            if type in self and not force:\n                raise ValueError(f\"Input handler {type} already registered\")\n            self[type] = func\n            return None\n\n        return _\n\n    def remove(self, type: str):\n        del self[type]\n\n    def _process_value(self, type: str, value: Any, name: str, session: Session) -> Any:\n        handler = self.get(type)\n        if handler is None:\n            raise ValueError(\"No input handler registered for type: \" + type)\n        return handler(value, name, session)",
  "def _(value: str | list[str], name: str, session: Session) -> date | tuple[date, date]:\n    if isinstance(value, str):\n        return datetime.strptime(value, \"%Y-%m-%d\").date()\n    return tuple(datetime.strptime(v, \"%Y-%m-%d\").date() for v in value)",
  "def _(\n    value: int | float | list[int] | list[float], name: str, session: Session\n) -> datetime | tuple[datetime, datetime]:\n    if isinstance(value, (int, float)):\n        return datetime.utcfromtimestamp(value)\n    return tuple(datetime.utcfromtimestamp(v) for v in value)",
  "def _(value: int, name: str, session: Session) -> ActionButtonValue:\n    # TODO: ActionButtonValue() class can probably be removed\n    return ActionButtonValue(value)",
  "def _(value: str, name: str, session: Session) -> str:\n    return value",
  "def _(value: str, name: str, session: Session) -> str:\n    return value",
  "def _(value: Any, name: str, session: Session) -> Any:\n    return value",
  "def __init__(self):\n        super().__init__()",
  "def add(self, type: str, force: bool = False) -> Callable[[InputHandlerType], None]:\n        def _(func: InputHandlerType):\n            if type in self and not force:\n                raise ValueError(f\"Input handler {type} already registered\")\n            self[type] = func\n            return None\n\n        return _",
  "def remove(self, type: str):\n        del self[type]",
  "def _process_value(self, type: str, value: Any, name: str, session: Session) -> Any:\n        handler = self.get(type)\n        if handler is None:\n            raise ValueError(\"No input handler registered for type: \" + type)\n        return handler(value, name, session)",
  "def _(func: InputHandlerType):\n            if type in self and not force:\n                raise ValueError(f\"Input handler {type} already registered\")\n            self[type] = func\n            return None",
  "class ErrorMiddleware:\n    \"\"\"Inserts shiny-autoreload.js into the head.\n\n    It's necessary to do it using middleware instead of in a nice htmldependency,\n    because we want autoreload to be effective even when displaying an error page.\n    \"\"\"\n\n    def __init__(self, app: ASGIApp):\n        self.app = app\n\n    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:\n        try:\n            return await self.app(scope, receive, send)\n        except exceptions.HTTPException as e:\n            resp = responses.PlainTextResponse(\n                e.detail,\n                e.status_code,\n                headers=cast(\n                    \"dict[str, str]\",\n                    e.headers,  # pyright: ignore[reportUnknownMemberType]\n                ),\n                media_type=\"text/plain\",\n            )\n            await resp(scope, receive, send)\n        except Exception as e:\n            # Seems super weird this is just going to stdout, should we use logger or\n            # at least stderr?\n            print(\"Unhandled error: \" + str(e))\n            resp = responses.PlainTextResponse(\n                \"An internal server error occurred\", 500, media_type=\"text/plain\"\n            )\n            await resp(scope, receive, send)",
  "def __init__(self, app: ASGIApp):\n        self.app = app",
  "async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:\n        try:\n            return await self.app(scope, receive, send)\n        except exceptions.HTTPException as e:\n            resp = responses.PlainTextResponse(\n                e.detail,\n                e.status_code,\n                headers=cast(\n                    \"dict[str, str]\",\n                    e.headers,  # pyright: ignore[reportUnknownMemberType]\n                ),\n                media_type=\"text/plain\",\n            )\n            await resp(scope, receive, send)\n        except Exception as e:\n            # Seems super weird this is just going to stdout, should we use logger or\n            # at least stderr?\n            print(\"Unhandled error: \" + str(e))\n            resp = responses.PlainTextResponse(\n                \"An internal server error occurred\", 500, media_type=\"text/plain\"\n            )\n            await resp(scope, receive, send)",
  "class ResolvedId(str):\n    def __call__(self, id: Id) -> ResolvedId:\n        if isinstance(id, ResolvedId):\n            return id\n\n        validate_id(id)\n\n        if self == \"\":\n            return ResolvedId(id)\n        else:\n            return ResolvedId(self + \"-\" + id)",
  "def current_namespace() -> ResolvedId:\n    return _current_namespace.get()",
  "def resolve_id(id: Id) -> ResolvedId:\n    \"\"\"\n    Resolve an ID, possibly with a module namespace.\n\n    Parameters\n    ----------\n    Args\n        id: An ID.\n\n    Returns\n        An ID (if in a module, this will contain a namespace prefix).\n    \"\"\"\n    curr_ns = _current_namespace.get()\n    return curr_ns(id)",
  "def resolve_id_or_none(id: None) -> None:\n    ...",
  "def resolve_id_or_none(id: Id) -> ResolvedId:\n    ...",
  "def resolve_id_or_none(id: Id | None) -> ResolvedId | None:\n    \"\"\"\n    Resolve an ID, possibly with a module namespace. With `None` support.\n\n    This method should only be used if `None` values are allowed. If not, use `resolve_id(id=)`.\n\n    Parameters\n    ----------\n    Args\n        id: An ID or `None`.\n\n    Returns\n        If `id=None`, then `None`. Otherwise, an ID (if in a module, this will contain a namespace prefix).\n    \"\"\"\n    if id is None:\n        return None\n    return resolve_id(id)",
  "def validate_id(id: str):\n    if not re_valid_id.match(id):\n        raise ValueError(\n            f\"The string '{id}' is not a valid id; only letters, numbers, and \"\n            \"underscore are permitted\"\n        )",
  "def namespace_context(id: Id | None):\n    namespace = resolve_id(id) if id else Root\n    token: Token[ResolvedId] = _current_namespace.set(namespace)\n    try:\n        yield\n    finally:\n        _current_namespace.reset(token)",
  "def __call__(self, id: Id) -> ResolvedId:\n        if isinstance(id, ResolvedId):\n            return id\n\n        validate_id(id)\n\n        if self == \"\":\n            return ResolvedId(id)\n        else:\n            return ResolvedId(self + \"-\" + id)",
  "def shiny_deps() -> HTMLDependency:\n    return HTMLDependency(\n        name=\"shiny\",\n        version=\"0.0.1\",\n        source={\"package\": \"shiny\", \"subdir\": \"www/shared/\"},\n        script={\"src\": \"shiny.js\"},\n        stylesheet={\"href\": \"shiny.min.css\"},\n    )",
  "def jquery_deps() -> HTMLDependency:\n    return HTMLDependency(\n        name=\"jquery\",\n        version=\"3.6.0\",\n        source={\"package\": \"shiny\", \"subdir\": \"www/shared/jquery/\"},\n        script={\"src\": \"jquery-3.6.0.min.js\"},\n    )",
  "def require_deps() -> HTMLDependency:\n    return HTMLDependency(\n        name=\"requirejs\",\n        version=\"2.3.6\",\n        source={\"package\": \"shiny\", \"subdir\": \"www/shared/requirejs/\"},\n        script={\"src\": \"require.min.js\"},\n    )",
  "class Connection(ABC):\n    \"\"\"Abstract class to serve a session and send/receive messages to the\n    client.\"\"\"\n\n    @abstractmethod\n    async def send(self, message: str) -> None:\n        ...\n\n    @abstractmethod\n    async def receive(self) -> str:\n        ...\n\n    @abstractmethod\n    async def close(self, code: int, reason: Optional[str]) -> None:\n        ...\n\n    @abstractmethod\n    def get_http_conn(self) -> HTTPConnection:\n        ...",
  "class MockConnection(Connection):\n    def __init__(self):\n        # This currently hard-codes some basic values for scope. In the future, we could\n        # make those more configurable if we need to customize the HTTPConnection (like\n        # \"scheme\", \"path\", and \"query_string\").\n        self._http_conn = HTTPConnection(scope={\"type\": \"websocket\", \"headers\": {}})\n        self._queue: asyncio.Queue[str] = asyncio.Queue()\n\n    async def send(self, message: str) -> None:\n        pass\n\n    async def receive(self) -> str:\n        msg = await self._queue.get()\n        if msg == \"\":\n            raise ConnectionClosed()\n        return msg\n\n    async def close(self, code: int, reason: Optional[str]) -> None:\n        pass\n\n    def get_http_conn(self) -> HTTPConnection:\n        return self._http_conn\n\n    def cause_receive(self, message: str) -> None:\n        \"\"\"Call from tests to simulate the other side sending a message\"\"\"\n        self._queue.put_nowait(message)\n\n    def cause_disconnect(self) -> None:\n        \"\"\"Call from tests to simulate the other side disconnecting\"\"\"\n        self.cause_receive(\"\")",
  "class StarletteConnection(Connection):\n    conn: starlette.websockets.WebSocket\n\n    def __init__(self, conn: starlette.websockets.WebSocket):\n        self.conn: starlette.websockets.WebSocket = conn\n        self._closed = False\n\n    async def accept(self, subprotocol: Optional[str] = None):\n        await self.conn.accept(subprotocol)  # type: ignore\n\n    async def send(self, message: str) -> None:\n        if self._is_closed():\n            return\n\n        try:\n            await self.conn.send_text(message)\n            return\n        # For the record, websockets.exceptions.ConnectionClosed is one exception I see\n        # when hammering on the browser reload button\n        except Exception:\n            # The contract of WebSocket.send() is to never throw (unless the websocket\n            # is not yet connected; sending a message after the ws has closed is OK.)\n            # However, it's also not very safe to keep using this websocket if we can't\n            # be sure they've received this message. So close it, and then continue as\n            # if nothing is wrong.\n            if not self._is_closed():\n                await self.close(1008, \"Send failure\")\n            return\n\n    async def receive(self) -> str:\n        if self._is_closed():\n            raise ConnectionClosed()\n\n        try:\n            return await self.conn.receive_text()\n        except starlette.websockets.WebSocketDisconnect:\n            raise ConnectionClosed()\n        except Exception:\n            # From RFC6455:\n            # 1008 indicates that an endpoint is terminating the connection because it\n            # has received a message that violates its policy.  This is a generic status\n            # code that can be returned when there is no other more suitable status code\n            # (e.g., 1003 or 1009) or if there is a need to hide specific details about\n            # the policy.\n            try:\n                await self.close(1008, \"Receive operation failed\")\n            except Exception:\n                pass\n            raise\n\n    async def close(self, code: int, reason: Optional[str]) -> None:\n        if self._is_closed():\n            return\n\n        # Even if self.conn.close() fails, treat this as closed.\n        self._closed = True\n\n        try:\n            await self.conn.close(code)\n        except Exception:\n            # WebSocket failed to close (usually because it already terminated in some\n            # unusual fashion); ignoring because the contract of WebSocket.close() is to\n            # never throw. (Not in Python, but in the browser, and it's pretty hard to\n            # reason about otherwise.)\n            pass\n\n    def _is_closed(self) -> bool:\n        return (\n            self.conn.application_state == WebSocketState.DISCONNECTED  # type: ignore\n            or self.conn.client_state == WebSocketState.DISCONNECTED  # type: ignore\n            or self._closed\n        )\n\n    def get_http_conn(self) -> HTTPConnection:\n        return self.conn",
  "class ConnectionClosed(Exception):\n    \"\"\"Raised when a Connection is closed from the other side.\"\"\"\n\n    pass",
  "async def send(self, message: str) -> None:\n        ...",
  "async def receive(self) -> str:\n        ...",
  "async def close(self, code: int, reason: Optional[str]) -> None:\n        ...",
  "def get_http_conn(self) -> HTTPConnection:\n        ...",
  "def __init__(self):\n        # This currently hard-codes some basic values for scope. In the future, we could\n        # make those more configurable if we need to customize the HTTPConnection (like\n        # \"scheme\", \"path\", and \"query_string\").\n        self._http_conn = HTTPConnection(scope={\"type\": \"websocket\", \"headers\": {}})\n        self._queue: asyncio.Queue[str] = asyncio.Queue()",
  "async def send(self, message: str) -> None:\n        pass",
  "async def receive(self) -> str:\n        msg = await self._queue.get()\n        if msg == \"\":\n            raise ConnectionClosed()\n        return msg",
  "async def close(self, code: int, reason: Optional[str]) -> None:\n        pass",
  "def get_http_conn(self) -> HTTPConnection:\n        return self._http_conn",
  "def cause_receive(self, message: str) -> None:\n        \"\"\"Call from tests to simulate the other side sending a message\"\"\"\n        self._queue.put_nowait(message)",
  "def cause_disconnect(self) -> None:\n        \"\"\"Call from tests to simulate the other side disconnecting\"\"\"\n        self.cause_receive(\"\")",
  "def __init__(self, conn: starlette.websockets.WebSocket):\n        self.conn: starlette.websockets.WebSocket = conn\n        self._closed = False",
  "async def accept(self, subprotocol: Optional[str] = None):\n        await self.conn.accept(subprotocol)",
  "async def send(self, message: str) -> None:\n        if self._is_closed():\n            return\n\n        try:\n            await self.conn.send_text(message)\n            return\n        # For the record, websockets.exceptions.ConnectionClosed is one exception I see\n        # when hammering on the browser reload button\n        except Exception:\n            # The contract of WebSocket.send() is to never throw (unless the websocket\n            # is not yet connected; sending a message after the ws has closed is OK.)\n            # However, it's also not very safe to keep using this websocket if we can't\n            # be sure they've received this message. So close it, and then continue as\n            # if nothing is wrong.\n            if not self._is_closed():\n                await self.close(1008, \"Send failure\")\n            return",
  "async def receive(self) -> str:\n        if self._is_closed():\n            raise ConnectionClosed()\n\n        try:\n            return await self.conn.receive_text()\n        except starlette.websockets.WebSocketDisconnect:\n            raise ConnectionClosed()\n        except Exception:\n            # From RFC6455:\n            # 1008 indicates that an endpoint is terminating the connection because it\n            # has received a message that violates its policy.  This is a generic status\n            # code that can be returned when there is no other more suitable status code\n            # (e.g., 1003 or 1009) or if there is a need to hide specific details about\n            # the policy.\n            try:\n                await self.close(1008, \"Receive operation failed\")\n            except Exception:\n                pass\n            raise",
  "async def close(self, code: int, reason: Optional[str]) -> None:\n        if self._is_closed():\n            return\n\n        # Even if self.conn.close() fails, treat this as closed.\n        self._closed = True\n\n        try:\n            await self.conn.close(code)\n        except Exception:\n            # WebSocket failed to close (usually because it already terminated in some\n            # unusual fashion); ignoring because the contract of WebSocket.close() is to\n            # never throw. (Not in Python, but in the browser, and it's pretty hard to\n            # reason about otherwise.)\n            pass",
  "def _is_closed(self) -> bool:\n        return (\n            self.conn.application_state == WebSocketState.DISCONNECTED  # type: ignore\n            or self.conn.client_state == WebSocketState.DISCONNECTED  # type: ignore\n            or self._closed\n        )",
  "def get_http_conn(self) -> HTTPConnection:\n        return self.conn",
  "def ui(fn: Callable[P, R]) -> Callable[Concatenate[str, P], R]:\n    def wrapper(id: Id, *args: P.args, **kwargs: P.kwargs) -> R:\n        with namespace_context(id):\n            return fn(*args, **kwargs)\n\n    return wrapper",
  "def server(\n    fn: Callable[Concatenate[Inputs, Outputs, Session, P], R]\n) -> Callable[Concatenate[str, P], R]:\n    def wrapper(id: Id, *args: P.args, **kwargs: P.kwargs) -> R:\n        sess = require_active_session(None)\n        child_sess = sess.make_scope(id)\n        with session_context(child_sess):\n            return fn(child_sess.input, child_sess.output, child_sess, *args, **kwargs)\n\n    return wrapper",
  "def wrapper(id: Id, *args: P.args, **kwargs: P.kwargs) -> R:\n        with namespace_context(id):\n            return fn(*args, **kwargs)",
  "def wrapper(id: Id, *args: P.args, **kwargs: P.kwargs) -> R:\n        sess = require_active_session(None)\n        child_sess = sess.make_scope(id)\n        with session_context(child_sess):\n            return fn(child_sess.input, child_sess.output, child_sess, *args, **kwargs)",
  "def main() -> None:\n    pass",
  "def run(\n    app: str | shiny.App,\n    host: str,\n    port: int,\n    autoreload_port: int,\n    reload: bool,\n    reload_dirs: tuple[str, ...],\n    ws_max_size: int,\n    log_level: str,\n    app_dir: str,\n    factory: bool,\n    launch_browser: bool,\n) -> None:\n    return run_app(\n        app,\n        host=host,\n        port=port,\n        autoreload_port=autoreload_port,\n        reload=reload,\n        reload_dirs=list(reload_dirs),\n        ws_max_size=ws_max_size,\n        log_level=log_level,\n        app_dir=app_dir,\n        factory=factory,\n        launch_browser=launch_browser,\n    )",
  "def run_app(\n    app: str | shiny.App = \"app:app\",\n    host: str = \"127.0.0.1\",\n    port: int = 8000,\n    autoreload_port: int = 0,\n    reload: bool = False,\n    reload_dirs: Optional[list[str]] = None,\n    ws_max_size: int = 16777216,\n    log_level: Optional[str] = None,\n    app_dir: Optional[str] = \".\",\n    factory: bool = False,\n    launch_browser: bool = False,\n) -> None:\n    \"\"\"\n    Starts a Shiny app. Press ``Ctrl+C`` (or ``Ctrl+Break`` on Windows) to stop.\n\n    Parameters\n    ----------\n    app\n        The app to run. The default, ``app:app``, represents the \"usual\" case where the\n        application is named ``app`` inside a ``app.py`` file within the current working\n        directory. In other cases, the app location can be specified as a\n        ``<module>:<attribute>`` string where the ``:<attribute>`` is only necessary if\n        the application is named something other than ``app``. Note that ``<module>``\n        can be relative path to a ``.py`` file or a directory (with an ``app.py`` file\n        inside it); and in this case, the relative path is resolved relative to the\n        ``app_dir`` directory.\n    host\n        The address that the app should listen on.\n    port\n        The port that the app should listen on. Set to 0 to use a random port.\n    autoreload_port\n        The port that should be used for an additional websocket that is used to support\n        hot-reload. Set to 0 to use a random port.\n    reload\n        Enable auto-reload.\n    ws_max_size\n        WebSocket max size message in bytes.\n    log_level\n        Log level.\n    app_dir\n        Look for ``app`` under this directory (by adding this to the ``PYTHONPATH``).\n    factory\n        Treat ``app`` as an application factory, i.e. a () -> <ASGI app> callable.\n    launch_browser\n        Launch app browser after app starts, using the Python webbrowser module.\n\n    Tip\n    ---\n    The ``shiny run`` command-line interface (which comes installed with Shiny) provides\n    the same functionality as this function.\n\n    Examples\n    --------\n\n    ```{python}\n    #|eval: false\n    from shiny import run_app\n\n    # Run ``app`` inside ``./app.py``\n    run_app()\n\n    # Run ``app`` inside ``./myapp.py`` (or ``./myapp/app.py``)\n    run_app(\"myapp\")\n\n    # Run ``my_app`` inside ``./myapp.py`` (or ``./myapp/app.py``)\n    run_app(\"myapp:my_app\")\n\n    # Run ``my_app`` inside ``../myapp.py`` (or ``../myapp/app.py``)\n    run_app(\"myapp:my_app\", app_dir=\"..\")\n    ```\n    \"\"\"\n\n    # If port is 0, randomize\n    if port == 0:\n        port = _utils.random_port(host=host)\n\n    os.environ[\"SHINY_HOST\"] = host\n    os.environ[\"SHINY_PORT\"] = str(port)\n\n    if isinstance(app, str):\n        app, app_dir = resolve_app(app, app_dir)\n\n    if app_dir:\n        app_dir = os.path.realpath(app_dir)\n\n    log_config: dict[str, Any] = copy.deepcopy(uvicorn.config.LOGGING_CONFIG)\n\n    if reload_dirs is None:\n        reload_dirs = []\n\n    if reload:\n        # Always watch the app_dir\n        if app_dir:\n            reload_dirs.append(app_dir)\n        # For developers of Shiny itself; autoreload the app when Shiny package changes\n        if os.getenv(\"SHINY_PKG_AUTORELOAD\"):\n            shinypath = Path(inspect.getfile(shiny)).parent\n            reload_dirs.append(str(shinypath))\n\n        if autoreload_port == 0:\n            autoreload_port = _utils.random_port(host=host)\n\n        if autoreload_port == port:\n            sys.stderr.write(\n                \"Autoreload port is already being used by the app; disabling autoreload\\n\"\n            )\n            reload = False\n        else:\n            setup_hot_reload(log_config, autoreload_port, port, launch_browser)\n\n    reload_args: ReloadArgs = {}\n    if reload:\n        reload_dirs = []\n        if app_dir is not None:\n            reload_dirs = [app_dir]\n\n        reload_args = {\n            \"reload\": reload,\n            # Adding `reload_includes` param while `reload=False` produces an warning\n            # https://github.com/encode/uvicorn/blob/d43afed1cfa018a85c83094da8a2dd29f656d676/uvicorn/config.py#L298-L304\n            \"reload_includes\": [\"*.py\", \"*.css\", \"*.js\", \"*.htm\", \"*.html\", \"*.png\"],\n            \"reload_dirs\": reload_dirs,\n        }\n\n    if launch_browser and not reload:\n        setup_launch_browser(log_config)\n\n    maybe_setup_rsw_proxying(log_config)\n\n    uvicorn.run(  # pyright: ignore[reportUnknownMemberType]\n        app,\n        host=host,\n        port=port,\n        ws_max_size=ws_max_size,\n        log_level=log_level,\n        log_config=log_config,\n        app_dir=app_dir,\n        factory=factory,\n        **reload_args,\n    )",
  "def setup_hot_reload(\n    log_config: dict[str, Any],\n    autoreload_port: int,\n    app_port: int,\n    launch_browser: bool,\n) -> None:\n    # The only way I've found to get notified when uvicorn decides to reload, is by\n    # inserting a custom log handler.\n    log_config[\"handlers\"][\"shiny_hot_reload\"] = {\n        \"class\": \"shiny._autoreload.HotReloadHandler\",\n        \"level\": \"INFO\",\n    }\n    if \"handlers\" not in log_config[\"loggers\"][\"uvicorn.error\"]:\n        log_config[\"loggers\"][\"uvicorn.error\"][\"handlers\"] = []\n    log_config[\"loggers\"][\"uvicorn.error\"][\"handlers\"].append(\"shiny_hot_reload\")\n\n    _autoreload.start_server(autoreload_port, app_port, launch_browser)",
  "def setup_launch_browser(log_config: dict[str, Any]):\n    log_config[\"handlers\"][\"shiny_launch_browser\"] = {\n        \"class\": \"shiny._launchbrowser.LaunchBrowserHandler\",\n        \"level\": \"INFO\",\n    }\n    if \"handlers\" not in log_config[\"loggers\"][\"uvicorn.error\"]:\n        log_config[\"loggers\"][\"uvicorn.error\"][\"handlers\"] = []\n    log_config[\"loggers\"][\"uvicorn.error\"][\"handlers\"].append(\"shiny_launch_browser\")",
  "def maybe_setup_rsw_proxying(log_config: dict[str, Any]) -> None:\n    # Replace localhost URLs emitted to the log, with proxied URLs\n    if _hostenv.is_workbench():\n        if \"filters\" not in log_config:\n            log_config[\"filters\"] = {}\n        log_config[\"filters\"][\"rsw_proxy\"] = {\"()\": \"shiny._hostenv.ProxyUrlFilter\"}\n        if \"filters\" not in log_config[\"handlers\"][\"default\"]:\n            log_config[\"handlers\"][\"default\"][\"filters\"] = []\n        log_config[\"handlers\"][\"default\"][\"filters\"].append(\"rsw_proxy\")",
  "def is_file(app: str) -> bool:\n    return \"/\" in app or app.endswith(\".py\")",
  "def resolve_app(app: str, app_dir: Optional[str]) -> tuple[str, Optional[str]]:\n    # The `app` parameter can be:\n    #\n    # - A module:attribute name\n    # - An absolute or relative path to a:\n    #   - .py file (look for app inside of it)\n    #   - directory (look for app:app inside of it)\n    # - A module name (look for :app) inside of it\n\n    if platform.system() == \"Windows\" and re.match(\"^[a-zA-Z]:[/\\\\\\\\]\", app):\n        # On Windows, need special handling of ':' in some cases, like these:\n        #   shiny run c:/Users/username/Documents/myapp/app.py\n        #   shiny run c:\\Users\\username\\Documents\\myapp\\app.py\n        module, attr = app, \"\"\n    else:\n        module, _, attr = app.partition(\":\")\n    if not module:\n        raise ImportError(\"The APP parameter cannot start with ':'.\")\n    if not attr:\n        attr = \"app\"\n\n    if is_file(module):\n        # Before checking module path, resolve it relative to app_dir if provided\n        module_path = module if app_dir is None else os.path.join(app_dir, module)\n        # TODO: We should probably be using some kind of loader\n        # TODO: I don't like that we exit here, if we ever export this it would be bad;\n        #       but also printing a massive stack trace for a `shiny run badpath` is way\n        #       unfriendly. We should probably throw a custom error that the shiny run\n        #       entrypoint knows not to print the stack trace for.\n        if not os.path.exists(module_path):\n            sys.stderr.write(f\"Error: {module_path} not found\\n\")\n            sys.exit(1)\n        if not os.path.isfile(module_path):\n            sys.stderr.write(f\"Error: {module_path} is not a file\\n\")\n            sys.exit(1)\n        dirname, filename = os.path.split(module_path)\n        module = filename[:-3] if filename.endswith(\".py\") else filename\n        app_dir = dirname\n\n    return f\"{module}:{attr}\", app_dir",
  "def try_import_module(module: str) -> Optional[types.ModuleType]:\n    try:\n        if not importlib.util.find_spec(module):\n            return None\n    except ModuleNotFoundError:\n        # find_spec throws this when the module contains both '/' and '.' characters\n        return None\n    except ImportError:\n        # find_spec throws this when the module starts with \".\"\n        return None\n\n    # It's important for ModuleNotFoundError and ImportError (and any other error) NOT\n    # to be caught here, as we want to report the true error to the user. Otherwise,\n    # missing dependencies can be misreported to the user as the app module itself not\n    # being found.\n    return importlib.import_module(module)",
  "def create(appdir: str) -> None:\n    app_dir = Path(appdir)\n    app_path = app_dir / \"app.py\"\n    if app_path.exists():\n        print(f\"Error: Can't create {app_path} because it already exists.\")\n        sys.exit(1)\n\n    if not app_dir.exists():\n        app_dir.mkdir()\n\n    shutil.copyfile(\n        Path(__file__).parent / \"api-examples\" / \"template\" / \"app.py\", app_path\n    )\n\n    print(f\"Created Shiny app at {app_dir / 'app.py'}\")",
  "def static() -> None:\n    print(\n        \"\"\"The functionality from `shiny static` has been moved to the shinylive package.\nPlease install shinylive and use `shinylive export` instead of `shiny static`:\n\n  shiny static-assets remove\n  pip install shinylive\n  shinylive export APPDIR DESTDIR\n\"\"\"\n    )\n    sys.exit(1)",
  "def static_assets(command: str) -> None:\n    dir = _static.get_default_shinylive_dir()\n\n    if command == \"remove\":\n        print(f\"Removing {dir}\")\n        _static.remove_shinylive_local(shinylive_dir=dir)\n    elif command == \"info\":\n        _static.print_shinylive_local_info()\n    else:\n        raise click.UsageError(f\"Unknown command: {command}\")",
  "class ReloadArgs(TypedDict):\n    reload: NotRequired[bool]\n    reload_includes: NotRequired[list[str]]\n    reload_dirs: NotRequired[list[str]]",
  "class App:\n    \"\"\"\n    Create a Shiny app instance.\n\n    Parameters\n    ----------\n    ui\n        The UI definition for the app (e.g., a call to :func:`~shiny.ui.page_fluid` or\n        :func:`~shiny.ui.page_fixed`, with layouts and controls nested inside). You can\n        also pass a function that takes a :class:`~starlette.requests.Request` and\n        returns a UI definition, if you need the UI definition to be created dynamically\n        for each pageview.\n    server\n        A function which is called once for each session, ensuring that each app is\n        independent.\n    static_assets\n        An absolute directory containing static files to be served by the app.\n    debug\n        Whether to enable debug mode.\n\n    Example\n    -------\n\n    ```{python}\n    #| eval: false\n    from shiny import  App, Inputs, Outputs, Session, ui\n\n    app_ui = ui.page_fluid(\"Hello Shiny!\")\n\n    def server(input: Inputs, output: Outputs, session: Session):\n        pass\n\n    app = App(app_ui, server)\n    ```\n    \"\"\"\n\n    lib_prefix: str = \"lib/\"\n    \"\"\"\n    A path prefix to place before all HTML dependencies processed by\n    ``register_web_dependency()``.\n    \"\"\"\n\n    sanitize_errors: bool = False\n    \"\"\"\n    Whether or not to show a generic message (``SANITIZE_ERRORS=True``) or the actual\n    message (``SANITIZE_ERRORS=False``) in the app UI when an error occurs. This flag\n    may default to ``True`` in some production environments (e.g., Posit Connect).\n    \"\"\"\n\n    sanitize_error_msg: str = \"An error has occurred. Check your logs or contact the app author for clarification.\"\n    \"\"\"\n    The message to show when an error occurs and ``SANITIZE_ERRORS=True``.\n    \"\"\"\n\n    ui: RenderedHTML | Callable[[Request], Tag | TagList]\n    server: Callable[[Inputs, Outputs, Session], None]\n\n    def __init__(\n        self,\n        ui: Tag | TagList | Callable[[Request], Tag | TagList],\n        server: Optional[Callable[[Inputs, Outputs, Session], None]],\n        *,\n        static_assets: Optional[\"str\" | \"os.PathLike[str]\"] = None,\n        debug: bool = False,\n    ) -> None:\n        if server is None:\n\n            def _server(inputs: Inputs, outputs: Outputs, session: Session):\n                pass\n\n            server = _server\n\n        self.server = server\n\n        self._debug: bool = debug\n\n        # Settings that the user can change after creating the App object.\n        self.lib_prefix: str = LIB_PREFIX\n        self.sanitize_errors: bool = SANITIZE_ERRORS\n        self.sanitize_error_msg: str = SANITIZE_ERROR_MSG\n\n        if static_assets is not None:\n            if not os.path.isdir(static_assets):\n                raise ValueError(f\"static_assets must be a directory: {static_assets}\")\n            if not os.path.isabs(static_assets):\n                raise ValueError(\n                    f\"static_assets must be an absolute path: {static_assets}\"\n                )\n\n        self._static_assets: str | os.PathLike[str] | None = static_assets\n\n        self._sessions: dict[str, Session] = {}\n\n        self._sessions_needing_flush: dict[int, Session] = {}\n\n        self._registered_dependencies: dict[str, HTMLDependency] = {}\n        self._dependency_handler = starlette.routing.Router()\n\n        if self._static_assets is not None:\n            self._dependency_handler.routes.append(\n                starlette.routing.Mount(\n                    \"/\",\n                    StaticFiles(directory=self._static_assets),\n                    name=\"shiny-app-static-assets-directory\",\n                )\n            )\n\n        starlette_app = self.init_starlette_app()\n\n        self.starlette_app = starlette_app\n\n        if is_uifunc(ui):\n            if is_async_callable(cast(Callable[[Request], Any], ui)):\n                raise TypeError(\"App UI cannot be a coroutine function\")\n            # Dynamic UI: just store the function for later\n            self.ui = cast(\"Callable[[Request], Tag | TagList]\", ui)\n        else:\n            # Static UI: render the UI now and save the results\n            self.ui = self._render_page(\n                cast(\"Tag | TagList\", ui), lib_prefix=self.lib_prefix\n            )\n\n    def init_starlette_app(self):\n        routes: list[starlette.routing.BaseRoute] = [\n            starlette.routing.WebSocketRoute(\"/websocket/\", self._on_connect_cb),\n            starlette.routing.Route(\"/\", self._on_root_request_cb, methods=[\"GET\"]),\n            starlette.routing.Route(\n                \"/session/{session_id}/{action}/{subpath:path}\",\n                self._on_session_request_cb,\n                methods=[\"GET\", \"POST\"],\n            ),\n            starlette.routing.Mount(\"/\", app=self._dependency_handler),\n        ]\n        middleware: list[starlette.middleware.Middleware] = []\n        if autoreload_url():\n            shared_dir = os.path.join(os.path.dirname(__file__), \"www\", \"shared\")\n            routes.insert(\n                0,\n                starlette.routing.Mount(\n                    \"/__shared\",\n                    app=StaticFiles(directory=shared_dir),\n                ),\n            )\n            middleware.append(\n                starlette.middleware.Middleware(InjectAutoreloadMiddleware)\n            )\n        # In Pyodide mode, an HTTPException(404) being thrown resulted in\n        # some default error handler (that happened not to be async) being\n        # run in a threadpool, which Pyodide could not handle. So in Pyodide\n        # mode, install our own async error handler at the outermost layer\n        # that we can.\n        if is_pyodide:\n            middleware.append(starlette.middleware.Middleware(ErrorMiddleware))\n\n        starlette_app = starlette.applications.Starlette(\n            routes=routes,\n            middleware=middleware,\n        )\n\n        return starlette_app\n\n    def _create_session(self, conn: Connection) -> Session:\n        id = secrets.token_hex(32)\n        session = Session(self, id, conn, debug=self._debug)\n        self._sessions[id] = session\n        return session\n\n    def _remove_session(self, session: Session | str) -> None:\n        if isinstance(session, Session):\n            session = session.id\n\n        if self._debug:\n            print(f\"remove_session: {session}\", flush=True)\n        del self._sessions[session]\n\n    def run(self, **kwargs: object) -> None:\n        \"\"\"\n        Run the app.\n\n        Parameters\n        ----------\n        kwargs\n            Keyword arguments passed to :func:`~shiny.run_app`.\n        \"\"\"\n        from ._main import run_app\n\n        run_app(self, **kwargs)\n\n    # ASGI entrypoint. Handles HTTP, WebSocket, and lifespan.\n    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:\n        await self.starlette_app(scope, receive, send)\n\n    async def call_pyodide(self, scope: Scope, receive: Receive, send: Send) -> None:\n        \"\"\"\n        Communicate with pyodide.\n\n        Warning\n        -------\n        This method is not intended for public usage. It's exported for use by\n        shinylive.\n        \"\"\"\n\n        # TODO: Pretty sure there are objects that need to be destroy()'d here?\n        scope = cast(Any, scope).to_py()\n\n        # ASGI requires some values to be byte strings, not character strings. Those are\n        # not that easy to create in JavaScript, so we let the JS side pass us strings\n        # and we convert them to bytes here.\n        if \"headers\" in scope:\n            # JS doesn't have `bytes` so we pass as strings and convert here\n            scope[\"headers\"] = [\n                [value.encode(\"latin-1\") for value in header]\n                for header in scope[\"headers\"]\n            ]\n        if \"query_string\" in scope and scope[\"query_string\"]:\n            scope[\"query_string\"] = scope[\"query_string\"].encode(\"latin-1\")\n        if \"raw_path\" in scope and scope[\"raw_path\"]:\n            scope[\"raw_path\"] = scope[\"raw_path\"].encode(\"latin-1\")\n\n        async def rcv() -> Message:\n            event = await receive()\n            return cast(Message, cast(Any, event).to_py())\n\n        async def snd(event: Message):\n            await send(event)\n\n        await self(scope, rcv, snd)\n\n    async def stop(self) -> None:\n        \"\"\"\n        Stop the app (i.e., close all sessions).\n\n        See Also\n        --------\n        ~shiny.Session.close\n        \"\"\"\n        # convert to list to avoid modifying the dict while iterating over it, which\n        # throws an error\n        for session in list(self._sessions.values()):\n            await session.close()\n\n    # ==========================================================================\n    # Connection callbacks\n    # ==========================================================================\n    async def _on_root_request_cb(self, request: Request) -> Response:\n        \"\"\"\n        Callback passed to the ConnectionManager which is invoked when a HTTP\n        request for / occurs.\n        \"\"\"\n        ui: RenderedHTML\n        if callable(self.ui):\n            ui = self._render_page(self.ui(request), self.lib_prefix)\n        else:\n            ui = self.ui\n        return HTMLResponse(content=ui[\"html\"])\n\n    async def _on_connect_cb(self, ws: starlette.websockets.WebSocket) -> None:\n        \"\"\"\n        Callback which is invoked when a new WebSocket connection is established.\n        \"\"\"\n        await ws.accept()\n        conn = StarletteConnection(ws)\n        session = self._create_session(conn)\n\n        await session._run()\n\n    async def _on_session_request_cb(self, request: Request) -> ASGIApp:\n        \"\"\"\n        Callback passed to the ConnectionManager which is invoked when a HTTP\n        request for /session/* occurs.\n        \"\"\"\n        session_id: str = request.path_params[\"session_id\"]  # type: ignore\n        action: str = request.path_params[\"action\"]  # type: ignore\n        subpath: str = request.path_params[\"subpath\"]  # type: ignore\n\n        if session_id in self._sessions:\n            session: Session = self._sessions[session_id]\n            with session_context(session):\n                return await session._handle_request(request, action, subpath)\n\n        return JSONResponse({\"detail\": \"Not Found\"}, status_code=404)\n\n    # ==========================================================================\n    # Flush\n    # ==========================================================================\n    def _request_flush(self, session: Session) -> None:\n        # TODO: Until we have reactive domains, because we can't yet keep track\n        # of which sessions need a flush.\n        pass\n        # self._sessions_needing_flush[session.id] = session\n\n    # ==========================================================================\n    # HTML Dependency stuff\n    # ==========================================================================\n    def _ensure_web_dependencies(self, deps: list[HTMLDependency]) -> None:\n        for dep in deps:\n            self._register_web_dependency(dep)\n\n    def _register_web_dependency(self, dep: HTMLDependency) -> None:\n        # If the dependency has been seen before, quit early.\n\n        # Even if the htmldependency version is higher or lower, the HTML being sent to\n        # the user is requesting THIS dependency. Therefore, it should be available to\n        # the user independent of any previous versions of the dependency being served.\n\n        # Note: htmltools does de-duplicate dependencies and finds the highest version\n        # to return. However, dynamic UI and callable UI do not run through the same\n        # filter over time. When using callable UI functions, UI dependencies are reset\n        # on refresh. So if a dependency makes it here, it is not necessarily the\n        # highest version served over time but is the highest version for this\n        # particular UI. Therefore, serve it must be served.\n        dep_name = html_dep_name(dep)\n        if dep_name in self._registered_dependencies:\n            return\n\n        # For HTMLDependencies that have sources on disk, mount the source dir.\n        # (Some HTMLDependencies only carry head content, and have no source on disk.)\n        if dep.source:\n            paths = dep.source_path_map(lib_prefix=self.lib_prefix)\n            if paths[\"source\"] != \"\":\n                self._dependency_handler.routes.insert(\n                    0,\n                    starlette.routing.Mount(\n                        \"/\" + paths[\"href\"],\n                        StaticFiles(directory=paths[\"source\"]),\n                        name=dep_name,\n                    ),\n                )\n\n        self._registered_dependencies[dep_name] = dep\n\n    def _render_page(self, ui: Tag | TagList, lib_prefix: str) -> RenderedHTML:\n        ui_res = copy.copy(ui)\n        # Make sure requirejs, jQuery, and Shiny come before any other dependencies.\n        # (see require_deps() for a comment about why we even include it)\n        ui_res.insert(0, [require_deps(), jquery_deps(), shiny_deps()])\n        rendered = HTMLDocument(ui_res).render(lib_prefix=lib_prefix)\n        self._ensure_web_dependencies(rendered[\"dependencies\"])\n        return rendered",
  "def is_uifunc(x: Tag | TagList | Callable[[Request], Tag | TagList]):\n    if isinstance(x, Tag) or isinstance(x, TagList) or not callable(x):\n        return False\n    else:\n        return True",
  "def html_dep_name(dep: HTMLDependency) -> str:\n    return dep.name + \"-\" + str(dep.version)",
  "def __init__(\n        self,\n        ui: Tag | TagList | Callable[[Request], Tag | TagList],\n        server: Optional[Callable[[Inputs, Outputs, Session], None]],\n        *,\n        static_assets: Optional[\"str\" | \"os.PathLike[str]\"] = None,\n        debug: bool = False,\n    ) -> None:\n        if server is None:\n\n            def _server(inputs: Inputs, outputs: Outputs, session: Session):\n                pass\n\n            server = _server\n\n        self.server = server\n\n        self._debug: bool = debug\n\n        # Settings that the user can change after creating the App object.\n        self.lib_prefix: str = LIB_PREFIX\n        self.sanitize_errors: bool = SANITIZE_ERRORS\n        self.sanitize_error_msg: str = SANITIZE_ERROR_MSG\n\n        if static_assets is not None:\n            if not os.path.isdir(static_assets):\n                raise ValueError(f\"static_assets must be a directory: {static_assets}\")\n            if not os.path.isabs(static_assets):\n                raise ValueError(\n                    f\"static_assets must be an absolute path: {static_assets}\"\n                )\n\n        self._static_assets: str | os.PathLike[str] | None = static_assets\n\n        self._sessions: dict[str, Session] = {}\n\n        self._sessions_needing_flush: dict[int, Session] = {}\n\n        self._registered_dependencies: dict[str, HTMLDependency] = {}\n        self._dependency_handler = starlette.routing.Router()\n\n        if self._static_assets is not None:\n            self._dependency_handler.routes.append(\n                starlette.routing.Mount(\n                    \"/\",\n                    StaticFiles(directory=self._static_assets),\n                    name=\"shiny-app-static-assets-directory\",\n                )\n            )\n\n        starlette_app = self.init_starlette_app()\n\n        self.starlette_app = starlette_app\n\n        if is_uifunc(ui):\n            if is_async_callable(cast(Callable[[Request], Any], ui)):\n                raise TypeError(\"App UI cannot be a coroutine function\")\n            # Dynamic UI: just store the function for later\n            self.ui = cast(\"Callable[[Request], Tag | TagList]\", ui)\n        else:\n            # Static UI: render the UI now and save the results\n            self.ui = self._render_page(\n                cast(\"Tag | TagList\", ui), lib_prefix=self.lib_prefix\n            )",
  "def init_starlette_app(self):\n        routes: list[starlette.routing.BaseRoute] = [\n            starlette.routing.WebSocketRoute(\"/websocket/\", self._on_connect_cb),\n            starlette.routing.Route(\"/\", self._on_root_request_cb, methods=[\"GET\"]),\n            starlette.routing.Route(\n                \"/session/{session_id}/{action}/{subpath:path}\",\n                self._on_session_request_cb,\n                methods=[\"GET\", \"POST\"],\n            ),\n            starlette.routing.Mount(\"/\", app=self._dependency_handler),\n        ]\n        middleware: list[starlette.middleware.Middleware] = []\n        if autoreload_url():\n            shared_dir = os.path.join(os.path.dirname(__file__), \"www\", \"shared\")\n            routes.insert(\n                0,\n                starlette.routing.Mount(\n                    \"/__shared\",\n                    app=StaticFiles(directory=shared_dir),\n                ),\n            )\n            middleware.append(\n                starlette.middleware.Middleware(InjectAutoreloadMiddleware)\n            )\n        # In Pyodide mode, an HTTPException(404) being thrown resulted in\n        # some default error handler (that happened not to be async) being\n        # run in a threadpool, which Pyodide could not handle. So in Pyodide\n        # mode, install our own async error handler at the outermost layer\n        # that we can.\n        if is_pyodide:\n            middleware.append(starlette.middleware.Middleware(ErrorMiddleware))\n\n        starlette_app = starlette.applications.Starlette(\n            routes=routes,\n            middleware=middleware,\n        )\n\n        return starlette_app",
  "def _create_session(self, conn: Connection) -> Session:\n        id = secrets.token_hex(32)\n        session = Session(self, id, conn, debug=self._debug)\n        self._sessions[id] = session\n        return session",
  "def _remove_session(self, session: Session | str) -> None:\n        if isinstance(session, Session):\n            session = session.id\n\n        if self._debug:\n            print(f\"remove_session: {session}\", flush=True)\n        del self._sessions[session]",
  "def run(self, **kwargs: object) -> None:\n        \"\"\"\n        Run the app.\n\n        Parameters\n        ----------\n        kwargs\n            Keyword arguments passed to :func:`~shiny.run_app`.\n        \"\"\"\n        from ._main import run_app\n\n        run_app(self, **kwargs)",
  "async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:\n        await self.starlette_app(scope, receive, send)",
  "async def call_pyodide(self, scope: Scope, receive: Receive, send: Send) -> None:\n        \"\"\"\n        Communicate with pyodide.\n\n        Warning\n        -------\n        This method is not intended for public usage. It's exported for use by\n        shinylive.\n        \"\"\"\n\n        # TODO: Pretty sure there are objects that need to be destroy()'d here?\n        scope = cast(Any, scope).to_py()\n\n        # ASGI requires some values to be byte strings, not character strings. Those are\n        # not that easy to create in JavaScript, so we let the JS side pass us strings\n        # and we convert them to bytes here.\n        if \"headers\" in scope:\n            # JS doesn't have `bytes` so we pass as strings and convert here\n            scope[\"headers\"] = [\n                [value.encode(\"latin-1\") for value in header]\n                for header in scope[\"headers\"]\n            ]\n        if \"query_string\" in scope and scope[\"query_string\"]:\n            scope[\"query_string\"] = scope[\"query_string\"].encode(\"latin-1\")\n        if \"raw_path\" in scope and scope[\"raw_path\"]:\n            scope[\"raw_path\"] = scope[\"raw_path\"].encode(\"latin-1\")\n\n        async def rcv() -> Message:\n            event = await receive()\n            return cast(Message, cast(Any, event).to_py())\n\n        async def snd(event: Message):\n            await send(event)\n\n        await self(scope, rcv, snd)",
  "async def stop(self) -> None:\n        \"\"\"\n        Stop the app (i.e., close all sessions).\n\n        See Also\n        --------\n        ~shiny.Session.close\n        \"\"\"\n        # convert to list to avoid modifying the dict while iterating over it, which\n        # throws an error\n        for session in list(self._sessions.values()):\n            await session.close()",
  "async def _on_root_request_cb(self, request: Request) -> Response:\n        \"\"\"\n        Callback passed to the ConnectionManager which is invoked when a HTTP\n        request for / occurs.\n        \"\"\"\n        ui: RenderedHTML\n        if callable(self.ui):\n            ui = self._render_page(self.ui(request), self.lib_prefix)\n        else:\n            ui = self.ui\n        return HTMLResponse(content=ui[\"html\"])",
  "async def _on_connect_cb(self, ws: starlette.websockets.WebSocket) -> None:\n        \"\"\"\n        Callback which is invoked when a new WebSocket connection is established.\n        \"\"\"\n        await ws.accept()\n        conn = StarletteConnection(ws)\n        session = self._create_session(conn)\n\n        await session._run()",
  "async def _on_session_request_cb(self, request: Request) -> ASGIApp:\n        \"\"\"\n        Callback passed to the ConnectionManager which is invoked when a HTTP\n        request for /session/* occurs.\n        \"\"\"\n        session_id: str = request.path_params[\"session_id\"]  # type: ignore\n        action: str = request.path_params[\"action\"]  # type: ignore\n        subpath: str = request.path_params[\"subpath\"]  # type: ignore\n\n        if session_id in self._sessions:\n            session: Session = self._sessions[session_id]\n            with session_context(session):\n                return await session._handle_request(request, action, subpath)\n\n        return JSONResponse({\"detail\": \"Not Found\"}, status_code=404)",
  "def _request_flush(self, session: Session) -> None:\n        # TODO: Until we have reactive domains, because we can't yet keep track\n        # of which sessions need a flush.\n        pass",
  "def _ensure_web_dependencies(self, deps: list[HTMLDependency]) -> None:\n        for dep in deps:\n            self._register_web_dependency(dep)",
  "def _register_web_dependency(self, dep: HTMLDependency) -> None:\n        # If the dependency has been seen before, quit early.\n\n        # Even if the htmldependency version is higher or lower, the HTML being sent to\n        # the user is requesting THIS dependency. Therefore, it should be available to\n        # the user independent of any previous versions of the dependency being served.\n\n        # Note: htmltools does de-duplicate dependencies and finds the highest version\n        # to return. However, dynamic UI and callable UI do not run through the same\n        # filter over time. When using callable UI functions, UI dependencies are reset\n        # on refresh. So if a dependency makes it here, it is not necessarily the\n        # highest version served over time but is the highest version for this\n        # particular UI. Therefore, serve it must be served.\n        dep_name = html_dep_name(dep)\n        if dep_name in self._registered_dependencies:\n            return\n\n        # For HTMLDependencies that have sources on disk, mount the source dir.\n        # (Some HTMLDependencies only carry head content, and have no source on disk.)\n        if dep.source:\n            paths = dep.source_path_map(lib_prefix=self.lib_prefix)\n            if paths[\"source\"] != \"\":\n                self._dependency_handler.routes.insert(\n                    0,\n                    starlette.routing.Mount(\n                        \"/\" + paths[\"href\"],\n                        StaticFiles(directory=paths[\"source\"]),\n                        name=dep_name,\n                    ),\n                )\n\n        self._registered_dependencies[dep_name] = dep",
  "def _render_page(self, ui: Tag | TagList, lib_prefix: str) -> RenderedHTML:\n        ui_res = copy.copy(ui)\n        # Make sure requirejs, jQuery, and Shiny come before any other dependencies.\n        # (see require_deps() for a comment about why we even include it)\n        ui_res.insert(0, [require_deps(), jquery_deps(), shiny_deps()])\n        rendered = HTMLDocument(ui_res).render(lib_prefix=lib_prefix)\n        self._ensure_web_dependencies(rendered[\"dependencies\"])\n        return rendered",
  "async def rcv() -> Message:\n            event = await receive()\n            return cast(Message, cast(Any, event).to_py())",
  "async def snd(event: Message):\n            await send(event)",
  "def _server(inputs: Inputs, outputs: Outputs, session: Session):\n                pass",
  "def autoreload_url() -> Optional[str]:\n    port = os.getenv(\"SHINY_AUTORELOAD_PORT\")\n    if not port:\n        return None\n    else:\n        return get_proxy_url(f\"ws://127.0.0.1:{port}/autoreload\")",
  "class HotReloadHandler(logging.Handler):\n    \"\"\"Uvicorn log reader, detects reload events.\"\"\"\n\n    def __init__(self):\n        logging.Handler.__init__(self)\n\n    def emit(self, record: logging.LogRecord) -> None:\n        # https://github.com/encode/uvicorn/blob/266db48888f3f1ba56710a49ec82e12eecde3aa3/uvicorn/supervisors/statreload.py#L46\n        # https://github.com/encode/uvicorn/blob/266db48888f3f1ba56710a49ec82e12eecde3aa3/uvicorn/supervisors/watchgodreload.py#L148\n        if \"Reloading...\" in record.getMessage():\n            reload_begin()\n        # https://github.com/encode/uvicorn/blob/926a8f5dc2c9265d5fb5daaafce13878f477e264/uvicorn/lifespan/on.py#L59\n        elif \"Application startup complete.\" in record.getMessage():\n            reload_end()",
  "def reload_begin():\n    pass",
  "def reload_end():\n    # os.kill(os.getppid(), signal.SIGUSR1)\n\n    port = os.getenv(\"SHINY_AUTORELOAD_PORT\")\n    if not port:\n        return None\n\n    url = f\"ws://127.0.0.1:{port}/notify\"\n\n    async def _() -> None:\n        options = {\n            \"extra_headers\": {\n                \"Shiny-Autoreload-Secret\": os.getenv(\"SHINY_AUTORELOAD_SECRET\", \"\"),\n            }\n        }\n        try:\n            async with connect(url, **options) as websocket:\n                await websocket.send(\"reload_end\")\n        except websockets.exceptions.ConnectionClosed:\n            pass\n\n    asyncio.create_task(_())",
  "class InjectAutoreloadMiddleware:\n    \"\"\"Inserts shiny-autoreload.js into the head.\n\n    It's necessary to do it using middleware instead of in a nice htmldependency,\n    because we want autoreload to be effective even when displaying an error page.\n    \"\"\"\n\n    def __init__(self, app: ASGI3Application):\n        self.app = app\n        ws_url = autoreload_url()\n        self.script = (\n            f\"\"\"  <script src=\"__shared/shiny-autoreload.js\" data-ws-url=\"{html.escape(ws_url)}\"></script>\n</head>\"\"\".encode(\n                \"ascii\"\n            )\n            if ws_url\n            else bytes()\n        )\n\n    async def __call__(\n        self, scope: Scope, receive: ASGIReceiveCallable, send: ASGISendCallable\n    ) -> None:\n        if scope[\"type\"] != \"http\" or scope[\"path\"] != \"/\" or len(self.script) == 0:\n            return await self.app(scope, receive, send)\n\n        def mangle_callback(body: bytes) -> tuple[bytes, bool]:\n            if b\"</head>\" in body:\n                return (body.replace(b\"</head>\", self.script, 1), True)\n            else:\n                return (body, False)\n\n        mangler = ResponseMangler(send, mangle_callback)\n        await self.app(scope, receive, mangler.send)",
  "def start_server(port: int, app_port: int, launch_browser: bool):\n    \"\"\"Starts a websocket server that listens on its own port (separate from the main\n    Shiny listener).\n\n    Clients can connect on either the /autoreload or /notify path.\n\n    Clients from the uvicorn worker process connect to the /notify path to notify us\n    that a successful startup or reload has occurred.\n\n    Clients from browsers (on localhost only) connect to the /autoreload path to be\n    notified when a successful startup or reload has occurred.\n    \"\"\"\n\n    # Store port and secret in environment variables so they are inherited by uvicorn\n    # worker processes.\n    secret = secrets.token_hex(32)\n    os.environ[\"SHINY_AUTORELOAD_PORT\"] = str(port)\n    os.environ[\"SHINY_AUTORELOAD_SECRET\"] = secret\n\n    app_url = get_proxy_url(f\"http://127.0.0.1:{app_port}/\")\n\n    # Run on a background thread so our event loop doesn't interfere with uvicorn.\n    # Set daemon=True because we don't want to keep the process alive with this thread.\n    threading.Thread(\n        None, _thread_main, args=[port, app_url, secret, launch_browser], daemon=True\n    ).start()",
  "def _thread_main(port: int, app_url: str, secret: str, launch_browser: bool):\n    asyncio.run(_coro_main(port, app_url, secret, launch_browser))",
  "async def _coro_main(\n    port: int, app_url: str, secret: str, launch_browser: bool\n) -> None:\n    reload_now: asyncio.Event = asyncio.Event()\n\n    def nudge():\n        nonlocal launch_browser\n        if launch_browser:\n            # Only launch the browser once, not every time autoreload occurs\n            launch_browser = False\n            webbrowser.open(app_url, 1)\n        reload_now.set()\n        reload_now.clear()\n\n    async def reload_server(conn: WebSocketServerProtocol):\n        try:\n            if conn.path == \"/autoreload\":\n                # The client wants to be notified when the app has reloaded. The client\n                # in this case is the web browser, specifically shiny-autoreload.js.\n                while True:\n                    await reload_now.wait()\n                    await conn.send(\"autoreload\")\n            elif conn.path == \"/notify\":\n                # The client is notifying us that the app has reloaded. The client in\n                # this case is the uvicorn worker process (see reload_end(), above).\n                req_secret = conn.request_headers.get(\"Shiny-Autoreload-Secret\", \"\")\n                if req_secret != secret:\n                    # The client couldn't prove that they were from a child process\n                    return\n                data = await conn.recv()\n                if isinstance(data, str) and data == \"reload_end\":\n                    nudge()\n        except websockets.exceptions.ConnectionClosed:\n            pass\n\n    # Handle non-WebSocket requests to the autoreload HTTP server. Without this, if you\n    # happen to visit the autoreload endpoint in a browser, you get an error message\n    # about only WebSockets being supported. This is not an academic problem as the\n    # VSCode extension used in RSW sniffs out ports that are being listened on, which\n    # leads to confusion if all you get is an error.\n    async def process_request(\n        path: str, request_headers: websockets.datastructures.Headers\n    ) -> Optional[tuple[http.HTTPStatus, websockets.datastructures.HeadersLike, bytes]]:\n        # If there's no Upgrade header, it's not a WebSocket request.\n        if request_headers.get(\"Upgrade\") is None:\n            return (http.HTTPStatus.MOVED_PERMANENTLY, [(\"Location\", app_url)], b\"\")\n\n    async with serve(reload_server, \"127.0.0.1\", port, process_request=process_request):\n        await asyncio.Future()",
  "class ResponseMangler:\n    \"\"\"A class that assists with intercepting and rewriting response bodies being sent\n    over ASGI. This would be easy if not for 1) response bodies are potentially sent in\n    chunks, over multiple events; 2) the first response event we receive is the one that\n    contains the Content-Length, which can be affected when we do rewriting later on.\n    The ResponseMangler handles the buffering and content-length rewriting, leaving the\n    caller to only have to worry about the actual body-modifying logic.\n    \"\"\"\n\n    def __init__(\n        self, send: ASGISendCallable, mangler: Callable[[bytes], tuple[bytes, bool]]\n    ) -> None:\n        # The underlying ASGI send function\n        self._send = send\n        # The caller-provided logic for rewriting the body. Takes a single `bytes`\n        # argument that is _all_ of the body bytes seen _so far_, and returns a tuple of\n        # (bytes, bool) where the bytes are the (possibly modified) body bytes and the\n        # bool is True if the mangler does not care to see any more data.\n        self._mangler = mangler\n\n        # If True, the mangler is done and any further data can simply be passed along\n        self._done: bool = False\n\n        # Holds the http.response.start event, which may need its Content-Length header\n        # rewritten before we send it\n        self._response_start: Optional[HTTPResponseStartEvent] = None\n        # All the response body bytes we have seen so far\n        self._body: bytes = b\"\"\n\n    async def send(self, event: ASGISendEvent) -> None:\n        if self._done:\n            await self._send(event)\n            return\n\n        if event[\"type\"] == \"http.response.start\":\n            self._response_start = event\n        elif event[\"type\"] == \"http.response.body\":\n            # This check is mostly to make pyright happy\n            if self._response_start is None:\n                raise AssertionError(\n                    \"http.response.body ASGI event sent before http.response.start\"\n                )\n\n            # Add the newly received body data to what we've seen already\n            self._body += event[\"body\"]\n            # Snapshot length before we mess with the body\n            old_len = len(self._body)\n            # Mangle away! If done is True, the mangler doesn't want to do any further\n            # mangling.\n            self._body, done = self._mangler(self._body)\n\n            new_len = len(self._body)\n            if new_len != old_len:\n                # The mangling check changed the length of the body. Add the difference\n                # to the content-length header (if content-length is even present)\n                _add_to_content_length(self._response_start, new_len - old_len)\n\n            more_body = event.get(\"more_body\", False)\n\n            if done or not more_body:\n                # Either we've seen the whole body by now (`not more_body`) or the\n                # mangler has seen all the data it cares to (`done`). Either way, we can\n                # send all the data we have.\n                self._done = True\n                await self._send(self._response_start)\n                await self._send(\n                    {\n                        \"type\": \"http.response.body\",\n                        \"body\": self._body,\n                        \"more_body\": more_body,\n                    }\n                )\n                # Allow gc\n                self._response_start = None\n                self._body = b\"\"\n            else:\n                # If we get here, then the mangler isn't done and we are expecting to\n                # see more data. Do nothing.\n                pass",
  "def _add_to_content_length(event: HTTPResponseStartEvent, offset: int) -> None:\n    \"\"\"If event has a Content-Length header, add the specified number of bytes to it\n    (may be negative)\"\"\"\n    event[\"headers\"] = [\n        (\n            (name, str(int(value) + offset).encode(\"latin-1\"))\n            if name.decode(\"ascii\").lower() == \"content-length\"\n            else (name, value)\n        )\n        for (name, value) in event[\"headers\"]\n    ]",
  "def __init__(self):\n        logging.Handler.__init__(self)",
  "def emit(self, record: logging.LogRecord) -> None:\n        # https://github.com/encode/uvicorn/blob/266db48888f3f1ba56710a49ec82e12eecde3aa3/uvicorn/supervisors/statreload.py#L46\n        # https://github.com/encode/uvicorn/blob/266db48888f3f1ba56710a49ec82e12eecde3aa3/uvicorn/supervisors/watchgodreload.py#L148\n        if \"Reloading...\" in record.getMessage():\n            reload_begin()\n        # https://github.com/encode/uvicorn/blob/926a8f5dc2c9265d5fb5daaafce13878f477e264/uvicorn/lifespan/on.py#L59\n        elif \"Application startup complete.\" in record.getMessage():\n            reload_end()",
  "async def _() -> None:\n        options = {\n            \"extra_headers\": {\n                \"Shiny-Autoreload-Secret\": os.getenv(\"SHINY_AUTORELOAD_SECRET\", \"\"),\n            }\n        }\n        try:\n            async with connect(url, **options) as websocket:\n                await websocket.send(\"reload_end\")\n        except websockets.exceptions.ConnectionClosed:\n            pass",
  "def __init__(self, app: ASGI3Application):\n        self.app = app\n        ws_url = autoreload_url()\n        self.script = (\n            f\"\"\"  <script src=\"__shared/shiny-autoreload.js\" data-ws-url=\"{html.escape(ws_url)}\"></script>\n</head>\"\"\".encode(\n                \"ascii\"\n            )\n            if ws_url\n            else bytes()\n        )",
  "async def __call__(\n        self, scope: Scope, receive: ASGIReceiveCallable, send: ASGISendCallable\n    ) -> None:\n        if scope[\"type\"] != \"http\" or scope[\"path\"] != \"/\" or len(self.script) == 0:\n            return await self.app(scope, receive, send)\n\n        def mangle_callback(body: bytes) -> tuple[bytes, bool]:\n            if b\"</head>\" in body:\n                return (body.replace(b\"</head>\", self.script, 1), True)\n            else:\n                return (body, False)\n\n        mangler = ResponseMangler(send, mangle_callback)\n        await self.app(scope, receive, mangler.send)",
  "def nudge():\n        nonlocal launch_browser\n        if launch_browser:\n            # Only launch the browser once, not every time autoreload occurs\n            launch_browser = False\n            webbrowser.open(app_url, 1)\n        reload_now.set()\n        reload_now.clear()",
  "async def reload_server(conn: WebSocketServerProtocol):\n        try:\n            if conn.path == \"/autoreload\":\n                # The client wants to be notified when the app has reloaded. The client\n                # in this case is the web browser, specifically shiny-autoreload.js.\n                while True:\n                    await reload_now.wait()\n                    await conn.send(\"autoreload\")\n            elif conn.path == \"/notify\":\n                # The client is notifying us that the app has reloaded. The client in\n                # this case is the uvicorn worker process (see reload_end(), above).\n                req_secret = conn.request_headers.get(\"Shiny-Autoreload-Secret\", \"\")\n                if req_secret != secret:\n                    # The client couldn't prove that they were from a child process\n                    return\n                data = await conn.recv()\n                if isinstance(data, str) and data == \"reload_end\":\n                    nudge()\n        except websockets.exceptions.ConnectionClosed:\n            pass",
  "async def process_request(\n        path: str, request_headers: websockets.datastructures.Headers\n    ) -> Optional[tuple[http.HTTPStatus, websockets.datastructures.HeadersLike, bytes]]:\n        # If there's no Upgrade header, it's not a WebSocket request.\n        if request_headers.get(\"Upgrade\") is None:\n            return (http.HTTPStatus.MOVED_PERMANENTLY, [(\"Location\", app_url)], b\"\")",
  "def __init__(\n        self, send: ASGISendCallable, mangler: Callable[[bytes], tuple[bytes, bool]]\n    ) -> None:\n        # The underlying ASGI send function\n        self._send = send\n        # The caller-provided logic for rewriting the body. Takes a single `bytes`\n        # argument that is _all_ of the body bytes seen _so far_, and returns a tuple of\n        # (bytes, bool) where the bytes are the (possibly modified) body bytes and the\n        # bool is True if the mangler does not care to see any more data.\n        self._mangler = mangler\n\n        # If True, the mangler is done and any further data can simply be passed along\n        self._done: bool = False\n\n        # Holds the http.response.start event, which may need its Content-Length header\n        # rewritten before we send it\n        self._response_start: Optional[HTTPResponseStartEvent] = None\n        # All the response body bytes we have seen so far\n        self._body: bytes = b\"\"",
  "async def send(self, event: ASGISendEvent) -> None:\n        if self._done:\n            await self._send(event)\n            return\n\n        if event[\"type\"] == \"http.response.start\":\n            self._response_start = event\n        elif event[\"type\"] == \"http.response.body\":\n            # This check is mostly to make pyright happy\n            if self._response_start is None:\n                raise AssertionError(\n                    \"http.response.body ASGI event sent before http.response.start\"\n                )\n\n            # Add the newly received body data to what we've seen already\n            self._body += event[\"body\"]\n            # Snapshot length before we mess with the body\n            old_len = len(self._body)\n            # Mangle away! If done is True, the mangler doesn't want to do any further\n            # mangling.\n            self._body, done = self._mangler(self._body)\n\n            new_len = len(self._body)\n            if new_len != old_len:\n                # The mangling check changed the length of the body. Add the difference\n                # to the content-length header (if content-length is even present)\n                _add_to_content_length(self._response_start, new_len - old_len)\n\n            more_body = event.get(\"more_body\", False)\n\n            if done or not more_body:\n                # Either we've seen the whole body by now (`not more_body`) or the\n                # mangler has seen all the data it cares to (`done`). Either way, we can\n                # send all the data we have.\n                self._done = True\n                await self._send(self._response_start)\n                await self._send(\n                    {\n                        \"type\": \"http.response.body\",\n                        \"body\": self._body,\n                        \"more_body\": more_body,\n                    }\n                )\n                # Allow gc\n                self._response_start = None\n                self._body = b\"\"\n            else:\n                # If we get here, then the mangler isn't done and we are expecting to\n                # see more data. Do nothing.\n                pass",
  "def mangle_callback(body: bytes) -> tuple[bytes, bool]:\n            if b\"</head>\" in body:\n                return (body.replace(b\"</head>\", self.script, 1), True)\n            else:\n                return (body, False)",
  "class MISSING_TYPE:\n    pass",
  "class FileInfo(TypedDict):\n    \"\"\"\n    Information about a file upload.\n\n    See Also\n    --------\n    ~shiny.ui.input_file\n\n    Example\n    -------\n    See :func:`~shiny.ui.input_file`.\n    \"\"\"\n\n    name: str\n    \"\"\"The name of the file.\"\"\"\n    size: int\n    \"\"\"The size of the file in bytes.\"\"\"\n    type: str\n    \"\"\"The MIME type of the file.\"\"\"\n    datapath: str\n    \"\"\"The path to the file on the server.\"\"\"",
  "class ImgData(TypedDict):\n    \"\"\"\n    Return type for :func:`~shiny.render.image`.\n\n    See Also\n    --------\n    ~shiny.render.image\n\n    Example\n    -------\n    See :func:`~shiny.render.image`.\n    \"\"\"\n\n    src: str\n    \"\"\"The ``src`` attribute of the ``<img>`` tag.\"\"\"\n    width: NotRequired[str | float]\n    \"\"\"The ``width`` attribute of the ``<img>`` tag.\"\"\"\n    height: NotRequired[str | float]\n    \"\"\"The ``height`` attribute of the ``<img>`` tag.\"\"\"\n    alt: NotRequired[str]\n    \"\"\"The ``alt`` attribute of the ``<img>`` tag.\"\"\"\n    style: NotRequired[str]\n    \"\"\"The ``style`` attribute of the ``<img>`` tag.\"\"\"\n    coordmap: NotRequired[Any]\n    \"\"\"TODO \"\"\"",
  "class SafeException(Exception):\n    \"\"\"\n    Throw a safe exception.\n\n    When ``shiny.App.SANITIZE_ERRORS`` is ``True`` (which is the case\n    in some production environments like Posit Connect), exceptions are sanitized\n    to prevent leaking of sensitive information. This class provides a way to\n    generate an error that is OK to be displayed to the user.\n    \"\"\"\n\n    pass",
  "class SilentException(Exception):\n    \"\"\"\n    Throw a silent exception.\n\n    Normally, when an exception occurs inside a reactive context, it's either:\n\n    - Displayed to the user (as a big red error message)\n        - This happens when the exception is raised from an output context (e.g., :func:`shiny.render.ui`)\n    - Crashes the application\n        - This happens when the exception is raised from an :func:`shiny.reactive.Effect`\n\n    This exception is used to silently throw inside a reactive context, meaning that\n    execution is paused, and no output is shown to users (or the python console).\n\n    See Also\n    --------\n    ~SilentCancelOutputException\n    \"\"\"\n\n    pass",
  "class SilentCancelOutputException(Exception):\n    \"\"\"\n    Throw a silent exception and don't clear output\n\n    Similar to :class:`~SilentException`, but if thrown in an output context,\n    existing output isn't cleared.\n\n    See Also\n    --------\n    ~SilentException\n    \"\"\"\n\n    pass",
  "class ActionButtonValue(int):\n    pass",
  "class NavSetArg(Protocol):\n    \"\"\"\n    An value suitable for passing to a navigation container (e.g.,\n    :func:`~shiny.ui.navset_tab`).\n    \"\"\"\n\n    def resolve(\n        self, selected: Optional[str], context: dict[str, Any]\n    ) -> tuple[TagChild, TagChild]:\n        \"\"\"\n        Resolve information provided by the navigation container.\n\n        Parameters\n        ----------\n        selected\n            The value of the navigation item to be shown on page load.\n        context\n            Additional context supplied by the navigation container.\n        \"\"\"\n        ...\n\n    def get_value(self) -> Optional[str]:\n        \"\"\"\n        Get the value of this navigation item (if any).\n\n        This value is only used to determine what navigation item should be shown\n        by default when none is specified (i.e., the first navigation item that\n        returns a value is used to determine the container's ``selected`` value).\n        \"\"\"\n        ...",
  "class PlotnineFigure(Protocol):\n    scales: list[Any]\n    coordinates: Any\n    facet: Any\n    layout: Any\n    mapping: dict[str, str]\n\n    def save(\n        self,\n        filename: BinaryIO,\n        format: str,\n        units: str,\n        dpi: float,\n        width: float,\n        height: float,\n        verbose: bool,\n        bbox_inches: object = None,\n    ):\n        ...\n\n    def draw(self, show: bool) -> Figure:\n        ...",
  "class CoordmapDims(TypedDict):\n    width: float\n    height: float",
  "class CoordmapPanelLog(TypedDict):\n    x: float | None\n    y: float | None",
  "class CoordmapPanelDomain(TypedDict):\n    left: float\n    right: float\n    bottom: float\n    top: float",
  "class CoordmapPanelRange(TypedDict):\n    left: float\n    right: float\n    bottom: float\n    top: float",
  "class CoordmapPanelMapping(TypedDict):\n    x: str | None\n    y: str | None\n    panelvar1: NotRequired[str]\n    panelvar2: NotRequired[str]",
  "class CoordmapPanelvarValues(TypedDict):\n    panelvar1: NotRequired[float]\n    panelvar2: NotRequired[float]",
  "class CoordmapPanel(TypedDict):\n    panel: int\n    row: NotRequired[int]\n    col: NotRequired[int]\n    panel_vars: NotRequired[CoordmapPanelvarValues]\n    log: CoordmapPanelLog\n    domain: CoordmapPanelDomain\n    mapping: CoordmapPanelMapping\n    range: CoordmapPanelRange",
  "class Coordmap(TypedDict):\n    panels: list[CoordmapPanel]\n    dims: CoordmapDims",
  "class CoordXY(TypedDict):\n    x: float\n    y: float",
  "class CoordInfo(TypedDict):\n    x: float\n    y: float\n    coords_css: CoordXY\n    coords_img: CoordXY\n    img_css_ratio: CoordXY\n    panelvar1: NotRequired[str]\n    panelvar2: NotRequired[str]\n    mapping: CoordmapPanelMapping\n    domain: CoordmapPanelDomain\n    range: CoordmapPanelRange\n    log: CoordmapPanelLog",
  "class BrushInfo(TypedDict):\n    xmin: float\n    xmax: float\n    ymin: float\n    ymax: float\n    coords_css: CoordXY\n    coords_img: CoordXY\n    img_css_ratio: CoordXY\n    panelvar1: NotRequired[str]\n    panelvar2: NotRequired[str]\n    mapping: CoordmapPanelMapping\n    domain: CoordmapPanelDomain\n    range: CoordmapPanelRange\n    log: CoordmapPanelLog\n    direction: Literal[\"x\", \"y\", \"xy\"]",
  "def resolve(\n        self, selected: Optional[str], context: dict[str, Any]\n    ) -> tuple[TagChild, TagChild]:\n        \"\"\"\n        Resolve information provided by the navigation container.\n\n        Parameters\n        ----------\n        selected\n            The value of the navigation item to be shown on page load.\n        context\n            Additional context supplied by the navigation container.\n        \"\"\"\n        ...",
  "def get_value(self) -> Optional[str]:\n        \"\"\"\n        Get the value of this navigation item (if any).\n\n        This value is only used to determine what navigation item should be shown\n        by default when none is specified (i.e., the first navigation item that\n        returns a value is used to determine the container's ``selected`` value).\n        \"\"\"\n        ...",
  "def save(\n        self,\n        filename: BinaryIO,\n        format: str,\n        units: str,\n        dpi: float,\n        width: float,\n        height: float,\n        verbose: bool,\n        bbox_inches: object = None,\n    ):\n        ...",
  "def draw(self, show: bool) -> Figure:\n        ...",
  "def is_workbench() -> bool:\n    return bool(os.getenv(\"RS_SERVER_URL\") and os.getenv(\"RS_SESSION_URL\"))",
  "def is_proxy_env() -> bool:\n    return is_workbench()",
  "def get_proxy_url(url: str) -> str:\n    if not is_workbench():\n        return url\n\n    parts = urlparse(url)\n    is_loopback = parts.hostname == \"localhost\"\n    if not is_loopback:\n        try:\n            is_loopback = ip_address(parts.hostname or \"\").is_loopback\n        except ValueError:\n            pass\n    if not is_loopback:\n        return url\n\n    path = parts.path or \"/\"\n\n    server_url = os.getenv(\"RS_SERVER_URL\", \"\")\n    session_url = os.getenv(\"RS_SESSION_URL\", \"\")\n\n    if parts.scheme.lower() in [\"ws\", \"wss\"]:\n        server_url = re.sub(\"^http\", \"ws\", server_url)\n    server_url = re.sub(\"/$\", \"\", server_url)\n    session_url = re.sub(\"^/\", \"\", session_url)\n\n    port = (\n        parts.port\n        if parts.port\n        else 80\n        if parts.scheme in [\"ws\", \"http\"]\n        else 443\n        if parts.scheme in [\"wss\", \"https\"]\n        else 0\n    )\n    if port == 0:\n        return url\n\n    if port in port_cache:\n        ptoken = port_cache[port]\n    else:\n        try:\n            res = run(\n                [\"/usr/lib/rstudio-server/bin/rserver-url\", str(port)],\n                capture_output=True,\n                encoding=\"ascii\",\n            )\n        except FileNotFoundError:\n            return url\n        if res.returncode != 0:\n            return url\n        ptoken = res.stdout\n        port_cache[port] = ptoken\n\n    return f\"{server_url}/{session_url}p/{ptoken}{path}{'?' if parts.query else ''}{parts.query}\"",
  "class ProxyUrlFilter:\n    def __init__(self):\n        pass\n\n    def filter(self, record: logging.LogRecord) -> int:\n        record.msg = pat_local_url.sub(self.url_replacement, record.getMessage())\n        if hasattr(record, \"color_message\"):\n            color_msg = str(record.color_message)  # type: ignore\n            if record.args:\n                color_msg = color_msg % record.args\n            record.color_message = pat_local_url.sub(  # type: ignore\n                self.url_replacement, color_msg\n            )\n        record.args = ()\n        return 1\n\n    def url_replacement(self, match: typing.Match[str]) -> str:\n        return get_proxy_url(match.group(0))",
  "def __init__(self):\n        pass",
  "def filter(self, record: logging.LogRecord) -> int:\n        record.msg = pat_local_url.sub(self.url_replacement, record.getMessage())\n        if hasattr(record, \"color_message\"):\n            color_msg = str(record.color_message)  # type: ignore\n            if record.args:\n                color_msg = color_msg % record.args\n            record.color_message = pat_local_url.sub(  # type: ignore\n                self.url_replacement, color_msg\n            )\n        record.args = ()\n        return 1",
  "def url_replacement(self, match: typing.Match[str]) -> str:\n        return get_proxy_url(match.group(0))",
  "class ShinyDeprecationWarning(RuntimeWarning):\n    pass",
  "def warn_deprecated(message: str):\n    warnings.warn(message, ShinyDeprecationWarning, stacklevel=3)",
  "def render_text():\n    \"\"\"Deprecated. Please use render.text() instead of render_text().\"\"\"\n    warn_deprecated(\"render_text() is deprecated. Use render.text() instead.\")\n    return render.text()",
  "def render_ui():\n    \"\"\"Deprecated. Please use render.ui() instead of render_ui().\"\"\"\n    warn_deprecated(\"render_ui() is deprecated. Use render.ui() instead.\")\n    return render.ui()",
  "def render_plot(*args: Any, **kwargs: Any):  # type: ignore\n    \"\"\"Deprecated. Please use render.plot() instead of render_plot().\"\"\"\n    warn_deprecated(\"render_plot() is deprecated. Use render.plot() instead.\")\n    return render.plot(*args, **kwargs)",
  "def render_image(*args: Any, **kwargs: Any):  # type: ignore\n    \"\"\"Deprecated. Please use render.image() instead of render_image().\"\"\"\n    warn_deprecated(\"render_image() is deprecated. Use render.image() instead.\")\n    return render.image(*args, **kwargs)",
  "def event(*args: Any, **kwargs: Any):\n    \"\"\"Deprecated. Please use @reactive.event() instead of @event().\"\"\"\n    warn_deprecated(\"@event() is deprecated. Use @reactive.event() instead.\")\n    return reactive.event(*args, **kwargs)",
  "def remove_shinylive_local(\n    shinylive_dir: Optional[Path] = None,\n    version: Optional[str] = None,\n) -> None:\n    \"\"\"Removes local copy of shinylive.\n\n    Parameters\n    ----------\n    shinylive_dir\n        The directory where shinylive is stored. If None, the default directory will\n        be used.\n\n    version\n        If a version is specified, only that version will be removed.\n        If None, all local versions of shinylive will be removed.\n    \"\"\"\n\n    if shinylive_dir is None:\n        shinylive_dir = get_default_shinylive_dir()\n\n    target_dir = shinylive_dir\n    if version is not None:\n        target_dir = target_dir / f\"shinylive-{version}\"\n\n    if target_dir.exists():\n        shutil.rmtree(target_dir)",
  "def get_default_shinylive_dir() -> Path:\n    import appdirs  # pyright: ignore[reportMissingTypeStubs]\n\n    return Path(appdirs.user_cache_dir(\"shiny\")) / \"shinylive\"",
  "def _installed_shinylive_versions(shinylive_dir: Optional[Path] = None) -> list[str]:\n    if shinylive_dir is None:\n        shinylive_dir = get_default_shinylive_dir()\n\n    if not shinylive_dir.exists():\n        return []\n    subdirs = next(os.walk(shinylive_dir))[1]\n    subdirs = [re.sub(\"^shinylive-\", \"\", str(s)) for s in subdirs]\n    return subdirs",
  "def print_shinylive_local_info() -> None:\n    print(\n        f\"\"\"    Local shinylive dir:\n        {get_default_shinylive_dir()}\n\n    Installed versions:\n        {\", \".join(_installed_shinylive_versions())}\"\"\"\n    )",
  "def rand_hex(bytes: int) -> str:\n    \"\"\"\n    Creates a random hexadecimal string of size `bytes`. The length in\n    characters will be bytes*2.\n    \"\"\"\n    format_str = \"{{:0{}x}}\".format(bytes * 2)\n    return format_str.format(secrets.randbits(bytes * 8))",
  "def drop_none(x: dict[str, Any]) -> dict[str, object]:\n    return {k: v for k, v in x.items() if v is not None}",
  "def lists_to_tuples(x: object) -> object:\n    if isinstance(x, dict):\n        x = cast(\"dict[str, object]\", x)\n        return {k: lists_to_tuples(v) for k, v in x.items()}\n    elif isinstance(x, list):\n        x = cast(\"list[object]\", x)\n        return tuple(lists_to_tuples(y) for y in x)\n    else:\n        # TODO: are there other mutable iterators that we want to make read only?\n        return x",
  "def guess_mime_type(\n    url: \"str | os.PathLike[str]\",\n    default: str = \"application/octet-stream\",\n    strict: bool = True,\n) -> str:\n    \"\"\"\n    Guess the MIME type of a file. This is a wrapper for mimetypes.guess_type, but it\n    only returns the type (and not encoding), and it allows a default value.\n    \"\"\"\n    # Note that in the parameters above, \"os.PathLike[str]\" is in quotes to avoid\n    # \"TypeError: 'ABCMeta' object is not subscriptable\", in Python<=3.8.\n    return mimetypes.guess_type(url, strict)[0] or default",
  "def random_port(\n    min: int = 1024, max: int = 49151, host: str = \"127.0.0.1\", n: int = 20\n) -> int:\n    \"\"\"Find an open TCP port\n\n    Finds a random available TCP port for listening on, within a specified range\n    of ports. The default range of ports to check is 1024 to 49151, which is the\n    set of TCP User Ports. This function automatically excludes some ports which\n    are considered unsafe by web browsers.\n\n    Parameters\n    ----------\n    min\n        Minimum port number.\n    max\n        Maximum port number, inclusive.\n    host\n        Before returning a port number, ensure that we can successfully bind it on this\n        host.\n    n\n        Number of times to attempt before giving up.\n    \"\"\"\n\n    # From https://chromium.googlesource.com/chromium/src.git/+/refs/heads/master/net/base/port_util.cc\n    unsafe_ports = [\n        1,\n        7,\n        9,\n        11,\n        13,\n        15,\n        17,\n        19,\n        20,\n        21,\n        22,\n        23,\n        25,\n        37,\n        42,\n        43,\n        53,\n        69,\n        77,\n        79,\n        87,\n        95,\n        101,\n        102,\n        103,\n        104,\n        109,\n        110,\n        111,\n        113,\n        115,\n        117,\n        119,\n        123,\n        135,\n        137,\n        139,\n        143,\n        161,\n        179,\n        389,\n        427,\n        465,\n        512,\n        513,\n        514,\n        515,\n        526,\n        530,\n        531,\n        532,\n        540,\n        548,\n        554,\n        556,\n        563,\n        587,\n        601,\n        636,\n        989,\n        990,\n        993,\n        995,\n        1719,\n        1720,\n        1723,\n        2049,\n        3659,\n        4045,\n        5060,\n        5061,\n        6000,\n        6566,\n        6665,\n        6666,\n        6667,\n        6668,\n        6669,\n        6697,\n        10080,\n    ]\n\n    unusable = set([x for x in unsafe_ports if x >= min and x <= max])\n    while n > 0:\n        if (max - min + 1) <= len(unusable):\n            break\n        port = random.randint(min, max)\n        if port in unusable:\n            continue\n        try:\n            # See if we can successfully bind\n            with socketserver.TCPServer(\n                (host, port), socketserver.BaseRequestHandler, bind_and_activate=False\n            ) as s:\n                s.server_bind()\n                return port\n        except Exception:\n            n -= 1\n            continue\n\n    raise RuntimeError(\"Failed to find a usable random port\")",
  "def private_random_int(min: int, max: int) -> str:\n    with private_seed():\n        return str(random.randint(min, max))",
  "def private_seed():\n    state = random.getstate()\n    global own_random_state\n    try:\n        random.setstate(own_random_state)\n        yield\n    finally:\n        own_random_state = random.getstate()\n        random.setstate(state)",
  "def wrap_async(\n    fn: Callable[P, T] | Callable[P, Awaitable[T]]\n) -> Callable[P, Awaitable[T]]:\n    \"\"\"\n    Given a synchronous function that returns T, return an async function that wraps the\n    original function. If the input function is already async, then return it unchanged.\n    \"\"\"\n\n    if is_async_callable(fn):\n        return fn\n\n    fn = cast(Callable[P, T], fn)\n\n    @functools.wraps(fn)\n    async def fn_async(*args: P.args, **kwargs: P.kwargs) -> T:\n        return fn(*args, **kwargs)\n\n    return fn_async",
  "def is_async_callable(\n    obj: Callable[P, T] | Callable[P, Awaitable[T]]\n) -> TypeGuard[Callable[P, Awaitable[T]]]:\n    \"\"\"\n    Determine if an object is an async function.\n\n    This is a more general version of `inspect.iscoroutinefunction()`, which only works\n    on functions. This function works on any object that has a `__call__` method, such\n    as a class instance.\n\n    Returns\n    -------\n    :\n        Returns True if `obj` is an `async def` function, or if it's an object with a\n        `__call__` method which is an `async def` function.\n    \"\"\"\n    if inspect.iscoroutinefunction(obj):\n        return True\n    if hasattr(obj, \"__call__\"):  # noqa: B004\n        if inspect.iscoroutinefunction(obj.__call__):  # type: ignore\n            return True\n\n    return False",
  "def run_coro_sync(coro: Awaitable[T]) -> T:\n    \"\"\"\n    Run a coroutine that is in fact synchronous. Given a coroutine (which is\n    returned by calling an `async def` function), this function will run the\n    coroutine for one iteration. If the coroutine completes, then return the\n    value. If it does not complete, then it will throw a `RuntimeError`.\n\n    What it means to be \"in fact synchronous\": the coroutine must not yield\n    control to the event loop. A coroutine may have an `await` expression in it, and that may call another function that has an `await`, but the chain will\n    only yield control if a `yield` statement bubbles through `await`s all the\n    way up. For example, `await asyncio.sleep(0)` will have a `yield` which\n    bubbles up to the next level. Note that a `yield` in a generator used the\n    regular way (not with `await`) will not bubble up, since it is not awaited\n    on.\n    \"\"\"\n    if not inspect.iscoroutine(coro):\n        raise TypeError(\"run_coro_sync requires a Coroutine object.\")\n\n    try:\n        coro.send(None)\n    except StopIteration as e:\n        return e.value\n\n    raise RuntimeError(\n        \"async function yielded control; it did not finish in one iteration.\"\n    )",
  "def run_coro_hybrid(coro: Awaitable[T]) -> \"asyncio.Future[T]\":\n    \"\"\"\n    Synchronously runs the given coro up to its first yield, then runs the rest of the\n    coro by scheduling it on the current event loop, as per normal. You can think of\n    this as either a run_coro_sync() that keeps running in the future, or, as an\n    asyncio.create_task() that starts executing immediately instead of via call_soon.\n\n    The status/result/exception can be access through the returned future. Even if an\n    error happens synchronously, run_coro_hybrid() will not throw, but rather the error\n    will be reported through the future object.\n\n    **PLEASE ONLY USE THIS IF IT'S ABSOLUTELY NECESSARY.** Relative to the official\n    asyncio Task implementation, this is a hastily assembled hack job; who knows what\n    unknown unknowns lurk here.\n    \"\"\"\n    result_future: asyncio.Future[T] = asyncio.Future()\n\n    if not inspect.iscoroutine(coro):\n        raise TypeError(\"run_coro_hybrid requires a Coroutine object.\")\n\n    # Inspired by Task.__step method in cpython/Lib/asyncio/tasks.py\n    def _step(fut: Optional[\"asyncio.Future[None]\"] = None):\n        assert result_future.cancelled() or not result_future.done()\n\n        exc: Optional[BaseException] = None\n        if fut:\n            assert fut.done()\n            try:\n                fut.result()\n            except BaseException as e:\n                exc = e\n\n        if result_future.cancelled():\n            # This may cause fut.result()'s exception to be ignored. That's intentional.\n            # The cancellation takes precedent, but if we don't call fut.result() first\n            # to retrieve its error, Python will warn.\n            exc = CancelledError()\n\n        res: Optional[asyncio.Future[None]] = None\n        try:\n            if exc is None:\n                res = coro.send(None)\n            else:\n                # Is it worth throwing here? Or just logging?\n                res = coro.throw(exc)\n        except StopIteration as e:\n            # Done\n            result_future.set_result(e.value)\n            return\n        except CancelledError:\n            result_future.cancel()\n            return\n        except (KeyboardInterrupt, SystemExit) as e:\n            result_future.set_exception(e)\n            raise\n        except BaseException as e:\n            result_future.set_exception(e)\n        else:\n            # If we get here, the coro didn't finish. Schedule it for completion.\n            if isinstance(res, asyncio.Future):\n                res.add_done_callback(_step)\n            elif res is None:\n                # This case happens with asyncio.sleep(0)\n                asyncio.get_running_loop().call_soon(_step)\n            else:\n                raise RuntimeError(f\"coroutine yielded unknown value: {res!r}\")\n\n    _step()\n\n    return result_future",
  "class Callbacks:\n    def __init__(self) -> None:\n        self._callbacks: dict[int, tuple[Callable[[], None], bool]] = {}\n        self._id: int = 0\n\n    def register(\n        self, fn: Callable[[], None], once: bool = False\n    ) -> Callable[[], None]:\n        self._id += 1\n        id = self._id\n        self._callbacks[id] = (fn, once)\n\n        def _():\n            if id in self._callbacks:\n                del self._callbacks[id]\n\n        return _\n\n    def invoke(self) -> None:\n        # The list() wrapper is necessary to force collection of all the items before\n        # iteration begins. This is necessary because self._callbacks may be mutated\n        # by callbacks.\n        for id, value in list(self._callbacks.items()):\n            fn, once = value\n            try:\n                fn()\n            finally:\n                if once:\n                    if id in self._callbacks:\n                        del self._callbacks[id]\n\n    def count(self) -> int:\n        return len(self._callbacks)",
  "class AsyncCallbacks:\n    def __init__(self) -> None:\n        self._callbacks: dict[int, tuple[Callable[[], Awaitable[None]], bool]] = {}\n        self._id: int = 0\n\n    def register(\n        self, fn: Callable[[], Awaitable[None]], once: bool = False\n    ) -> Callable[[], None]:\n        self._id += 1\n        id = self._id\n        self._callbacks[id] = (fn, once)\n\n        def _():\n            if id in self._callbacks:\n                del self._callbacks[id]\n\n        return _\n\n    async def invoke(self) -> None:\n        # The list() wrapper is necessary to force collection of all the items before\n        # iteration begins. This is necessary because self._callbacks may be mutated\n        # by callbacks.\n        for id, value in list(self._callbacks.items()):\n            fn, once = value\n            try:\n                await fn()\n            finally:\n                if once:\n                    if id in self._callbacks:\n                        del self._callbacks[id]\n\n    def count(self) -> int:\n        return len(self._callbacks)",
  "def package_dir(package: str) -> str:\n    with tempfile.TemporaryDirectory():\n        pkg_file = importlib.import_module(\".\", package=package).__file__\n        if pkg_file is None:\n            raise RuntimeError(f\"Could not find package dir for '{package}'\")\n        return os.path.dirname(pkg_file)",
  "async def fn_async(*args: P.args, **kwargs: P.kwargs) -> T:\n        return fn(*args, **kwargs)",
  "def _step(fut: Optional[\"asyncio.Future[None]\"] = None):\n        assert result_future.cancelled() or not result_future.done()\n\n        exc: Optional[BaseException] = None\n        if fut:\n            assert fut.done()\n            try:\n                fut.result()\n            except BaseException as e:\n                exc = e\n\n        if result_future.cancelled():\n            # This may cause fut.result()'s exception to be ignored. That's intentional.\n            # The cancellation takes precedent, but if we don't call fut.result() first\n            # to retrieve its error, Python will warn.\n            exc = CancelledError()\n\n        res: Optional[asyncio.Future[None]] = None\n        try:\n            if exc is None:\n                res = coro.send(None)\n            else:\n                # Is it worth throwing here? Or just logging?\n                res = coro.throw(exc)\n        except StopIteration as e:\n            # Done\n            result_future.set_result(e.value)\n            return\n        except CancelledError:\n            result_future.cancel()\n            return\n        except (KeyboardInterrupt, SystemExit) as e:\n            result_future.set_exception(e)\n            raise\n        except BaseException as e:\n            result_future.set_exception(e)\n        else:\n            # If we get here, the coro didn't finish. Schedule it for completion.\n            if isinstance(res, asyncio.Future):\n                res.add_done_callback(_step)\n            elif res is None:\n                # This case happens with asyncio.sleep(0)\n                asyncio.get_running_loop().call_soon(_step)\n            else:\n                raise RuntimeError(f\"coroutine yielded unknown value: {res!r}\")",
  "def __init__(self) -> None:\n        self._callbacks: dict[int, tuple[Callable[[], None], bool]] = {}\n        self._id: int = 0",
  "def register(\n        self, fn: Callable[[], None], once: bool = False\n    ) -> Callable[[], None]:\n        self._id += 1\n        id = self._id\n        self._callbacks[id] = (fn, once)\n\n        def _():\n            if id in self._callbacks:\n                del self._callbacks[id]\n\n        return _",
  "def invoke(self) -> None:\n        # The list() wrapper is necessary to force collection of all the items before\n        # iteration begins. This is necessary because self._callbacks may be mutated\n        # by callbacks.\n        for id, value in list(self._callbacks.items()):\n            fn, once = value\n            try:\n                fn()\n            finally:\n                if once:\n                    if id in self._callbacks:\n                        del self._callbacks[id]",
  "def count(self) -> int:\n        return len(self._callbacks)",
  "def __init__(self) -> None:\n        self._callbacks: dict[int, tuple[Callable[[], Awaitable[None]], bool]] = {}\n        self._id: int = 0",
  "def register(\n        self, fn: Callable[[], Awaitable[None]], once: bool = False\n    ) -> Callable[[], None]:\n        self._id += 1\n        id = self._id\n        self._callbacks[id] = (fn, once)\n\n        def _():\n            if id in self._callbacks:\n                del self._callbacks[id]\n\n        return _",
  "async def invoke(self) -> None:\n        # The list() wrapper is necessary to force collection of all the items before\n        # iteration begins. This is necessary because self._callbacks may be mutated\n        # by callbacks.\n        for id, value in list(self._callbacks.items()):\n            fn, once = value\n            try:\n                await fn()\n            finally:\n                if once:\n                    if id in self._callbacks:\n                        del self._callbacks[id]",
  "def count(self) -> int:\n        return len(self._callbacks)",
  "def _():\n            if id in self._callbacks:\n                del self._callbacks[id]",
  "def _():\n            if id in self._callbacks:\n                del self._callbacks[id]",
  "class DocStringWithExample(str):\n    ...",
  "def add_example(\n    directive: Literal[\n        \"shinyapp::\",\n        \"shinylive-editor::\",\n        \"code-block:: python\",\n        \"cell::\",\n        \"terminal::\",\n    ] = \"shinylive-editor::\",\n    **options: object,\n) -> Callable[[F], F]:\n    \"\"\"\n    Add an example to the docstring of a function, method, or class.\n\n    This decorator must, at the moment, be used on a function, method, or class whose\n    ``__name__`` matches the name of directory under ``shiny/api-examples/``, and must\n    also contain a ``app.py`` file in that directory.\n\n    Parameters\n    ----------\n    directive\n        A directive for rendering the example. This can be one of:\n            - ``shinyapp``: A live shiny app (statically served via wasm).\n            - ``code``: A python code snippet.\n            - ``shinylive-editor``: A live shiny app with editor (statically served via wasm).\n            - ``cell``: A executable Python cell.\n            - ``terminal``: A minimal Python IDE\n    **options\n        Options for the directive. See docs/source/sphinxext/pyshinyapp.py for details.\n    \"\"\"\n\n    def _(func: F) -> F:\n        # To avoid a performance hit on `import shiny`, we only add examples to the\n        # docstrings if this env variable is set (as it is in docs/source/conf.py).\n        if os.getenv(\"SHINY_ADD_EXAMPLES\") != \"true\":\n            if func.__doc__ is not None:\n                func.__doc__ = DocStringWithExample(func.__doc__)\n            return func\n\n        fn_name = func.__name__\n        example_dir = os.path.join(ex_dir, fn_name)\n        example_file = os.path.join(example_dir, \"app.py\")\n        if not os.path.exists(example_file):\n            raise ValueError(f\"No example for {fn_name}\")\n\n        other_files: list[str] = []\n        for f in os.listdir(example_dir):\n            abs_f = os.path.join(example_dir, f)\n            if os.path.isfile(abs_f) and f != \"app.py\":\n                other_files.append(abs_f)\n\n        if \"files\" not in options:\n            options[\"files\"] = json.dumps(other_files)\n\n        if func.__doc__ is None:\n            func.__doc__ = \"\"\n\n        # How many leading spaces does the docstring start with?\n        doc = func.__doc__.replace(\"\\n\", \"\")\n        indent = \" \" * (len(doc) - len(doc.lstrip()))\n\n        with open(example_file) as f:\n            example = indent.join([\" \" * 4 + x for x in f.readlines()])\n\n        # When rendering a standalone app, put the code above it (maybe this should be\n        # handled by the directive itself?)\n        example_prefix: list[str] = []\n        if directive == \"shinyapp::\":\n            example_prefix.extend(\n                [\n                    \".. code-block:: python\",\n                    \"\",\n                    example,\n                    \"\",\n                ]\n            )\n\n        example_section = (\"\\n\" + indent).join(\n            [\n                \"\",\n                \"\",\n                \"Example\",\n                \"-------\",\n                \"\",\n                *example_prefix,\n                f\".. {directive}\",\n                *[f\"    :{k}: {v}\" for k, v in options.items()],\n                \"\",\n                example,\n            ]\n        )\n\n        func.__doc__ += example_section\n        func.__doc__ = DocStringWithExample(func.__doc__)\n        return func\n\n    return _",
  "def doc_format(**kwargs: str) -> Callable[[F], F]:\n    def _(func: F) -> F:\n        if isinstance(func.__doc__, DocStringWithExample):\n            raise ValueError(\n                f\"@doc_format() must be applied before @add_example() for {func.__name__}.\"\n            )\n        if func.__doc__:\n            func.__doc__ = func.__doc__.format(**kwargs)\n        return func\n\n    return _",
  "def _(func: F) -> F:\n        # To avoid a performance hit on `import shiny`, we only add examples to the\n        # docstrings if this env variable is set (as it is in docs/source/conf.py).\n        if os.getenv(\"SHINY_ADD_EXAMPLES\") != \"true\":\n            if func.__doc__ is not None:\n                func.__doc__ = DocStringWithExample(func.__doc__)\n            return func\n\n        fn_name = func.__name__\n        example_dir = os.path.join(ex_dir, fn_name)\n        example_file = os.path.join(example_dir, \"app.py\")\n        if not os.path.exists(example_file):\n            raise ValueError(f\"No example for {fn_name}\")\n\n        other_files: list[str] = []\n        for f in os.listdir(example_dir):\n            abs_f = os.path.join(example_dir, f)\n            if os.path.isfile(abs_f) and f != \"app.py\":\n                other_files.append(abs_f)\n\n        if \"files\" not in options:\n            options[\"files\"] = json.dumps(other_files)\n\n        if func.__doc__ is None:\n            func.__doc__ = \"\"\n\n        # How many leading spaces does the docstring start with?\n        doc = func.__doc__.replace(\"\\n\", \"\")\n        indent = \" \" * (len(doc) - len(doc.lstrip()))\n\n        with open(example_file) as f:\n            example = indent.join([\" \" * 4 + x for x in f.readlines()])\n\n        # When rendering a standalone app, put the code above it (maybe this should be\n        # handled by the directive itself?)\n        example_prefix: list[str] = []\n        if directive == \"shinyapp::\":\n            example_prefix.extend(\n                [\n                    \".. code-block:: python\",\n                    \"\",\n                    example,\n                    \"\",\n                ]\n            )\n\n        example_section = (\"\\n\" + indent).join(\n            [\n                \"\",\n                \"\",\n                \"Example\",\n                \"-------\",\n                \"\",\n                *example_prefix,\n                f\".. {directive}\",\n                *[f\"    :{k}: {v}\" for k, v in options.items()],\n                \"\",\n                example,\n            ]\n        )\n\n        func.__doc__ += example_section\n        func.__doc__ = DocStringWithExample(func.__doc__)\n        return func",
  "def _(func: F) -> F:\n        if isinstance(func.__doc__, DocStringWithExample):\n            raise ValueError(\n                f\"@doc_format() must be applied before @add_example() for {func.__name__}.\"\n            )\n        if func.__doc__:\n            func.__doc__ = func.__doc__.format(**kwargs)\n        return func",
  "class PriorityQueueFIFO(Generic[T]):\n    \"\"\"\n    Similar to queue.PriorityQueue, except that if two elements have the same\n    priority, they are returned in the order they were inserted. Also, the item\n    is kept separate from the priority value (with PriorityQueue, the priority\n    is part of the item).\n    \"\"\"\n\n    def __init__(self) -> None:\n        # Using Tuple instead of tuple because in Python 3.8 and earlier, tuple isn't\n        # generic\n        self._pq: PriorityQueue[tuple[int, int, T]] = PriorityQueue()\n        self._counter: int = 0\n\n    def put(self, priority: int, item: T) -> None:\n        \"\"\"\n        Add an item to the queue.\n\n        Parameters:\n           priority (int): The priority of the item. Higher priority items will\n                           come out of the queue before lower priority items.\n           item (T): The item to put in the queue.\n        \"\"\"\n        self._counter += 1\n        self._pq.put((-priority, self._counter, item))\n\n    def get(self) -> T:\n        iteminfo: tuple[int, int, T] = self._pq.get()\n        return iteminfo[2]\n\n    def empty(self) -> bool:\n        return self._pq.empty()",
  "def __init__(self) -> None:\n        # Using Tuple instead of tuple because in Python 3.8 and earlier, tuple isn't\n        # generic\n        self._pq: PriorityQueue[tuple[int, int, T]] = PriorityQueue()\n        self._counter: int = 0",
  "def put(self, priority: int, item: T) -> None:\n        \"\"\"\n        Add an item to the queue.\n\n        Parameters:\n           priority (int): The priority of the item. Higher priority items will\n                           come out of the queue before lower priority items.\n           item (T): The item to put in the queue.\n        \"\"\"\n        self._counter += 1\n        self._pq.put((-priority, self._counter, item))",
  "def get(self) -> T:\n        iteminfo: tuple[int, int, T] = self._pq.get()\n        return iteminfo[2]",
  "def empty(self) -> bool:\n        return self._pq.empty()",
  "class StaticFiles:\n        dir: pathlib.Path\n        root_path: str\n\n        def __init__(self, *, directory: str | os.PathLike[str]):\n            self.dir = pathlib.Path(os.path.realpath(os.path.normpath(directory)))\n\n        async def __call__(self, scope: Scope, receive: Receive, send: Send):\n            if scope[\"type\"] != \"http\":\n                raise AssertionError(\"StaticFiles can't handle non-http request\")\n            path = scope[\"path\"]\n            path_segments = path.split(\"/\")\n            final_path, trailing_slash = _traverse_url_path(self.dir, path_segments)\n            if final_path is None:\n                return await Error404()(scope, receive, send)\n\n            if not final_path.exists():\n                return await Error404()(scope, receive, send)\n\n            # Sanity check that final path is under self.dir, and if not, 404\n            # This construction is like .is_relative_to, but works with Python 3.8\n            try:\n                final_path.relative_to(self.dir)\n            except ValueError:\n                return await Error404()(scope, receive, send)\n\n            # Serve up the path\n\n            if final_path.is_dir():\n                if trailing_slash:\n                    # We could serve up index.html or directory listing if we wanted\n                    return await Error404()(scope, receive, send)\n                else:\n                    # We could redirect with an added \"/\" if we wanted\n                    return await Error404()(scope, receive, send)\n            else:\n                return await FileResponse(final_path)(scope, receive, send)",
  "def _traverse_url_path(\n        dir: pathlib.Path, path_segments: list[str]\n    ) -> tuple[Optional[pathlib.Path], bool]:\n        assert len(path_segments) > 0\n\n        new_dir = dir\n        path_segment = urllib.parse.unquote(path_segments.pop(0))\n        # Gratuitous whitespace is not allowed\n        if path_segment != path_segment.strip():\n            return None, False\n\n        # Check for illegal paths\n        if \"/\" in path_segment:\n            return None, False\n        elif path_segment == \"..\" or path_segment == \".\":\n            return None, False\n\n        if path_segment != \"\":\n            new_dir = dir / path_segment\n\n        if len(path_segments) == 0:\n            return new_dir, path_segment == \"\"\n        else:\n            return _traverse_url_path(new_dir, path_segments)",
  "class Error404(PlainTextResponse):\n        def __init__(self):\n            super().__init__(\"404\", status_code=404)",
  "class FileResponse:\n        file: pathlib.Path\n        headers: Optional[MutableMapping[str, str]]\n        media_type: str\n\n        def __init__(\n            self,\n            file: pathlib.Path,\n            headers: Optional[MutableMapping[str, str]] = None,\n            media_type: Optional[str] = None,\n            background: Optional[BackgroundTask] = None,\n        ) -> None:\n            self.headers = headers\n            self.file = file\n            self.background = background\n\n            if media_type is None:\n                media_type = _utils.guess_mime_type(file, strict=False)\n            self.media_type = media_type\n\n        async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:\n            with open(self.file, \"rb\") as f:\n                await send(\n                    {\n                        \"type\": \"http.response.start\",\n                        \"status\": 200,\n                        \"headers\": _convert_headers(self.headers, self.media_type),\n                    }\n                )\n\n                while True:\n                    # In pyodide mode (the only mode in which we use this codepath) the\n                    # `send()` callback has quite a bit of per-call overhead, so use a\n                    # very large chunk size to keep performance adequate.\n                    data = f.read(262144)\n                    if len(data) == 0:\n                        break\n                    await send(\n                        {\n                            \"type\": \"http.response.body\",\n                            \"body\": data,\n                            \"more_body\": True,\n                        }\n                    )\n\n                await send(\n                    {\"type\": \"http.response.body\", \"body\": b\"\", \"more_body\": False}\n                )\n            if self.background:\n                await self.background()",
  "def _convert_headers(\n        headers: Optional[MutableMapping[str, str]], media_type: Optional[str] = None\n    ) -> Iterable[tuple[bytes, bytes]]:\n        if headers is None:\n            headers = {}\n\n        header_list = [\n            (k.encode(\"latin-1\"), v.encode(\"latin-1\")) for k, v in headers.items()\n        ]\n        if media_type is not None:\n            header_list += [\n                (\n                    b\"Content-Type\",\n                    media_type.encode(\"latin-1\"),\n                )\n            ]\n        return header_list",
  "def __init__(self, *, directory: str | os.PathLike[str]):\n            self.dir = pathlib.Path(os.path.realpath(os.path.normpath(directory)))",
  "async def __call__(self, scope: Scope, receive: Receive, send: Send):\n            if scope[\"type\"] != \"http\":\n                raise AssertionError(\"StaticFiles can't handle non-http request\")\n            path = scope[\"path\"]\n            path_segments = path.split(\"/\")\n            final_path, trailing_slash = _traverse_url_path(self.dir, path_segments)\n            if final_path is None:\n                return await Error404()(scope, receive, send)\n\n            if not final_path.exists():\n                return await Error404()(scope, receive, send)\n\n            # Sanity check that final path is under self.dir, and if not, 404\n            # This construction is like .is_relative_to, but works with Python 3.8\n            try:\n                final_path.relative_to(self.dir)\n            except ValueError:\n                return await Error404()(scope, receive, send)\n\n            # Serve up the path\n\n            if final_path.is_dir():\n                if trailing_slash:\n                    # We could serve up index.html or directory listing if we wanted\n                    return await Error404()(scope, receive, send)\n                else:\n                    # We could redirect with an added \"/\" if we wanted\n                    return await Error404()(scope, receive, send)\n            else:\n                return await FileResponse(final_path)(scope, receive, send)",
  "def __init__(self):\n            super().__init__(\"404\", status_code=404)",
  "def __init__(\n            self,\n            file: pathlib.Path,\n            headers: Optional[MutableMapping[str, str]] = None,\n            media_type: Optional[str] = None,\n            background: Optional[BackgroundTask] = None,\n        ) -> None:\n            self.headers = headers\n            self.file = file\n            self.background = background\n\n            if media_type is None:\n                media_type = _utils.guess_mime_type(file, strict=False)\n            self.media_type = media_type",
  "async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:\n            with open(self.file, \"rb\") as f:\n                await send(\n                    {\n                        \"type\": \"http.response.start\",\n                        \"status\": 200,\n                        \"headers\": _convert_headers(self.headers, self.media_type),\n                    }\n                )\n\n                while True:\n                    # In pyodide mode (the only mode in which we use this codepath) the\n                    # `send()` callback has quite a bit of per-call overhead, so use a\n                    # very large chunk size to keep performance adequate.\n                    data = f.read(262144)\n                    if len(data) == 0:\n                        break\n                    await send(\n                        {\n                            \"type\": \"http.response.body\",\n                            \"body\": data,\n                            \"more_body\": True,\n                        }\n                    )\n\n                await send(\n                    {\"type\": \"http.response.body\", \"body\": b\"\", \"more_body\": False}\n                )\n            if self.background:\n                await self.background()",
  "class FileUploadOperation:\n    def __init__(\n        self, parent: FileUploadManager, id: str, dir: str, file_infos: List[FileInfo]\n    ) -> None:\n        self._parent: FileUploadManager = parent\n        self._id: str = id\n        self._dir: str = dir\n        # Copy file_infos and add a \"datapath\" entry for each file.\n        self._file_infos: list[FileInfo] = [\n            cast(FileInfo, {**fi, \"datapath\": \"\"}) for fi in copy.deepcopy(file_infos)\n        ]\n        self._n_uploaded: int = 0\n        self._current_file_obj: Optional[BinaryIO] = None\n\n    # Start uploading one of the files.\n    def file_begin(self) -> None:\n        file_info: FileInfo = self._file_infos[self._n_uploaded]\n        file_ext = pathlib.Path(file_info[\"name\"]).suffix\n        file_info[\"datapath\"] = os.path.join(\n            self._dir, str(self._n_uploaded) + file_ext\n        )\n        self._current_file_obj = open(file_info[\"datapath\"], \"ab\")\n\n    # Finish uploading one of the files.\n    def file_end(self) -> None:\n        if self._current_file_obj is not None:\n            self._current_file_obj.close()\n        self._current_file_obj = None\n        self._n_uploaded += 1\n\n    # Write a chunk of data for the currently-open file.\n    def write_chunk(self, chunk: bytes) -> None:\n        if self._current_file_obj is None:\n            raise RuntimeError(f\"FileUploadOperation for {self._id} is not open.\")\n        self._current_file_obj.write(chunk)\n\n    # End the entire operation, which can consist of multiple files.\n    def finish(self) -> List[FileInfo]:\n        if self._n_uploaded != len(self._file_infos):\n            raise RuntimeError(\n                f\"Not all files for FileUploadOperation {self._id} were uploaded.\"\n            )\n        self._parent.on_job_finished(self._id)\n        return self._file_infos\n\n    # Context handlers for `with`\n    def __enter__(self) -> None:\n        self.file_begin()\n\n    def __exit__(self, type, value, trace) -> None:  # type: ignore\n        self.file_end()",
  "class FileUploadManager:\n    def __init__(self) -> None:\n        # TODO: Remove basedir when app exits.\n        self._basedir: str = tempfile.mkdtemp(prefix=\"fileupload-\")\n        self._operations: dict[str, FileUploadOperation] = {}\n\n    def create_upload_operation(self, file_infos: List[FileInfo]) -> str:\n        job_id = _utils.rand_hex(12)\n        dir = tempfile.mkdtemp(dir=self._basedir)\n        self._operations[job_id] = FileUploadOperation(self, job_id, dir, file_infos)\n        return job_id\n\n    def get_upload_operation(self, id: str) -> Optional[FileUploadOperation]:\n        if id in self._operations:\n            return self._operations[id]\n        else:\n            return None\n\n    def on_job_finished(self, job_id: str) -> None:\n        del self._operations[job_id]\n\n    # Remove the directories containing file uploads; this is to be called when\n    # a session ends.\n    def rm_upload_dir(self) -> None:\n        shutil.rmtree(self._basedir)",
  "def __init__(\n        self, parent: FileUploadManager, id: str, dir: str, file_infos: List[FileInfo]\n    ) -> None:\n        self._parent: FileUploadManager = parent\n        self._id: str = id\n        self._dir: str = dir\n        # Copy file_infos and add a \"datapath\" entry for each file.\n        self._file_infos: list[FileInfo] = [\n            cast(FileInfo, {**fi, \"datapath\": \"\"}) for fi in copy.deepcopy(file_infos)\n        ]\n        self._n_uploaded: int = 0\n        self._current_file_obj: Optional[BinaryIO] = None",
  "def file_begin(self) -> None:\n        file_info: FileInfo = self._file_infos[self._n_uploaded]\n        file_ext = pathlib.Path(file_info[\"name\"]).suffix\n        file_info[\"datapath\"] = os.path.join(\n            self._dir, str(self._n_uploaded) + file_ext\n        )\n        self._current_file_obj = open(file_info[\"datapath\"], \"ab\")",
  "def file_end(self) -> None:\n        if self._current_file_obj is not None:\n            self._current_file_obj.close()\n        self._current_file_obj = None\n        self._n_uploaded += 1",
  "def write_chunk(self, chunk: bytes) -> None:\n        if self._current_file_obj is None:\n            raise RuntimeError(f\"FileUploadOperation for {self._id} is not open.\")\n        self._current_file_obj.write(chunk)",
  "def finish(self) -> List[FileInfo]:\n        if self._n_uploaded != len(self._file_infos):\n            raise RuntimeError(\n                f\"Not all files for FileUploadOperation {self._id} were uploaded.\"\n            )\n        self._parent.on_job_finished(self._id)\n        return self._file_infos",
  "def __enter__(self) -> None:\n        self.file_begin()",
  "def __exit__(self, type, value, trace) -> None:  # type: ignore\n        self.file_end()",
  "def __init__(self) -> None:\n        # TODO: Remove basedir when app exits.\n        self._basedir: str = tempfile.mkdtemp(prefix=\"fileupload-\")\n        self._operations: dict[str, FileUploadOperation] = {}",
  "def create_upload_operation(self, file_infos: List[FileInfo]) -> str:\n        job_id = _utils.rand_hex(12)\n        dir = tempfile.mkdtemp(dir=self._basedir)\n        self._operations[job_id] = FileUploadOperation(self, job_id, dir, file_infos)\n        return job_id",
  "def get_upload_operation(self, id: str) -> Optional[FileUploadOperation]:\n        if id in self._operations:\n            return self._operations[id]\n        else:\n            return None",
  "def on_job_finished(self, job_id: str) -> None:\n        del self._operations[job_id]",
  "def rm_upload_dir(self) -> None:\n        shutil.rmtree(self._basedir)",
  "def req(*, cancel_output: bool = False) -> None:\n    ...",
  "def req(*args: T, cancel_output: bool = False) -> T:\n    ...",
  "def req(*args: T, cancel_output: bool = False) -> T | None:\n    \"\"\"\n    Throw a silent exception for falsy values.\n\n    This is a convenient shorthand for throwing :func:`~shiny.types.SilentException` /\n    :func:`~shiny.types.SilentCancelOutputException` if any of the arguments are falsy.\n\n    Parameters\n    ----------\n    args\n        Any number of arguments to check.\n    cancel_output\n        If ``True``, throw :func:`~shiny.types.SilentCancelOutputException` instead of\n        :func:`~shiny.types.SilentException`.\n\n    Returns\n    -------\n    :\n        The first argument. If no arguments are provided, returns ``None``.\n    \"\"\"\n    if len(args) == 0:\n        return None\n\n    for arg in args:\n        if not arg:\n            if cancel_output:\n                raise SilentCancelOutputException()\n            else:\n                raise SilentException()\n\n    return args[0]",
  "class LaunchBrowserHandler(logging.Handler):\n    \"\"\"Uvicorn log reader, detects successful app startup so we can launch a browser.\n\n    This class is ONLY used when reload mode is turned off; in the case of reload, the\n    launching of the browser must be tightly coupled to the HotReloadHandler as that is\n    the only way to ensure the browser is only launched at startup, not on every reload.\n    \"\"\"\n\n    def __init__(self):\n        logging.Handler.__init__(self)\n        self._launched = False\n\n    def emit(self, record: logging.LogRecord) -> None:\n        if self._launched:\n            # Ensure that we never launch a browser window twice. In non-reload\n            # scenarios it probably would never happen anyway, as we're unlikely to get\n            # \"Application startup complete.\" in the logs more than once, but just in\n            # case someone does choose to log that string...\n            return\n\n        if \"Application startup complete.\" in record.getMessage():\n            self._launched = True\n            port = os.environ[\"SHINY_PORT\"]\n            if not port.isnumeric():\n                print(\n                    \"SHINY_PORT environment variable not set or unusable; \"\n                    \"--launch-browser will be ignored\"\n                )\n                # For some reason the shiny port isn't set correctly!?\n                return\n            host = os.environ[\"SHINY_HOST\"]\n            url = get_proxy_url(f\"http://{host}:{port}/\")\n            webbrowser.open(url, 1)",
  "def __init__(self):\n        logging.Handler.__init__(self)\n        self._launched = False",
  "def emit(self, record: logging.LogRecord) -> None:\n        if self._launched:\n            # Ensure that we never launch a browser window twice. In non-reload\n            # scenarios it probably would never happen anyway, as we're unlikely to get\n            # \"Application startup complete.\" in the logs more than once, but just in\n            # case someone does choose to log that string...\n            return\n\n        if \"Application startup complete.\" in record.getMessage():\n            self._launched = True\n            port = os.environ[\"SHINY_PORT\"]\n            if not port.isnumeric():\n                print(\n                    \"SHINY_PORT environment variable not set or unusable; \"\n                    \"--launch-browser will be ignored\"\n                )\n                # For some reason the shiny port isn't set correctly!?\n                return\n            host = os.environ[\"SHINY_HOST\"]\n            url = get_proxy_url(f\"http://{host}:{port}/\")\n            webbrowser.open(url, 1)",
  "class SeriesFloatXY(TypedDict):\n    x: pd.Series[float]\n    y: pd.Series[float]",
  "def brushed_points(\n    df: pd.DataFrame,\n    brush: BrushInfo | None,\n    xvar: Optional[str] = None,\n    yvar: Optional[str] = None,\n    panelvar1: Optional[str] = None,\n    panelvar2: Optional[str] = None,\n    *,\n    all_rows: bool = False,\n) -> pd.DataFrame:\n    \"\"\"Find rows of data selected on an interactive plot.\n\n    This function is used with interactive plots. It returns the rows of a data frame\n    which are under a brush.\n\n    It currently supports plots created by matplotlib, seaborn, and plotnine. If\n    plotnine is used, it can usually automatically infer the x and y variables, along\n    with variables used for facets.\n\n    Parameters\n    ----------\n    df\n        A pandas DataFrame from which to select rows.\n    brush\n        The data from a brush, like `input.myplot_brush()`.\n    xvar\n        The name of the column in `df` that contains the x values. (Note that when using\n        plotnine, `xvar`, `yvar`, `panelvar1`, and `panelvar2` can usually be\n        automatically inferred from the brush data.)\n    yvar\n        The name of the column in `df` that contains the y values.\n    panelvar1\n        The name of the column in `df` that contains the first variable used for\n        subpanels (if subpanels are used).\n    panelvar2\n        The name of the column in `df` that contains the second variable used for\n        subpanels.\n    all_rows\n        If `False` (the default), return a data frame containing only the rows that are\n        selected. If `True`, then all rows from the data frame will be returned, along\n        with an additional column named `selected_`, which indicates whether or not each\n        row was selected.\n\n    Returns\n    -------\n    :\n        A pandas DataFrame containing the rows selected by the brush. If `all_rows` is\n        `True`, then all rows from the original data will be returned, along with an\n        additional column named `selected_`, which indicates whether or not each row was\n        selected.\n    \"\"\"\n    import pandas as pd\n\n    new_df = df.copy()\n\n    if brush is None:\n        if all_rows:\n            new_df[\"selected_\"] = False\n        else:\n            new_df = new_df.loc[[]]\n\n        return new_df\n\n    if \"xmin\" not in brush:\n        raise ValueError(\n            \"brushed_points requires a brush object with xmin, xmax, ymin, and ymax.\"\n        )\n\n    # Which direction(s) the brush is selecting over. Direction can be 'x', 'y',\n    # or 'xy'.\n    use_x = \"x\" in brush[\"direction\"]\n    use_y = \"y\" in brush[\"direction\"]\n\n    # Filter out x and y values\n    keep_rows: pd.Series[bool] = pd.Series(\n        True,\n        index=new_df.index,  # pyright: ignore[reportUnknownMemberType]\n    )\n    if use_x:\n        if xvar is None and \"x\" in brush[\"mapping\"]:\n            xvar = brush[\"mapping\"][\"x\"]\n        if xvar is None:\n            raise ValueError(\n                \"brushed_points: not able to automatically infer `xvar` from brush. You must supply `xvar` to brushed_points()\"\n            )\n        if xvar not in new_df:\n            raise ValueError(f\"brushed_points: `xvar` ({xvar}) not in dataframe\")\n        keep_rows &= within_brush(new_df[xvar], brush, \"x\")\n\n    if use_y:\n        if yvar is None and \"y\" in brush[\"mapping\"]:\n            yvar = brush[\"mapping\"][\"y\"]\n        if yvar is None:\n            raise ValueError(\n                \"brushed_points: not able to automatically infer `yvar` from brush. You must supply `yvar` to brushed_points()\"\n            )\n        if yvar not in new_df:\n            raise ValueError(f\"brushed_points: `yvar` ({yvar}) not in dataframe\")\n        keep_rows &= within_brush(new_df[yvar], brush, \"y\")\n\n    # Find which rows are matches for the panel vars (if present)\n    if panelvar1 is None and \"panelvar1\" in brush[\"mapping\"]:\n        panelvar1 = brush[\"mapping\"][\"panelvar1\"]\n        if panelvar1 not in new_df:\n            raise ValueError(\n                f\"brushed_points: `panelvar1` ({panelvar1}) not in dataframe\"\n            )\n        keep_rows &= new_df[panelvar1] == brush[\"panelvar1\"]  # pyright: ignore\n\n    if panelvar2 is None and \"panelvar2\" in brush[\"mapping\"]:\n        panelvar2 = brush[\"mapping\"][\"panelvar2\"]\n        if panelvar2 not in new_df:\n            raise ValueError(\n                f\"brushed_points: `panelvar2` ({panelvar2}) not in dataframe\"\n            )\n        keep_rows &= new_df[panelvar2] == brush[\"panelvar2\"]  # pyright: ignore\n\n    if all_rows:\n        new_df[\"selected_\"] = False\n        new_df.loc[keep_rows, \"selected_\"] = True\n    else:\n        new_df = new_df.loc[keep_rows]\n\n    return new_df",
  "def near_points(\n    df: pd.DataFrame,\n    coordinfo: CoordInfo | None,\n    xvar: Optional[str] = None,\n    yvar: Optional[str] = None,\n    panelvar1: Optional[str] = None,\n    panelvar2: Optional[str] = None,\n    *,\n    threshold: float = 5,\n    max_points: Optional[int] = None,\n    add_dist: bool = False,\n    all_rows: bool = False,\n) -> pd.DataFrame:\n    \"\"\"Find rows of data selected on an interactive plot.\n\n    This function is used with interactive plots. It returns the rows of a data frame\n    which are under a brush.\n\n    It currently supports plots created by matplotlib, seaborn, and plotnine. If\n    plotnine is used, it can usually automatically infer the x and y variables, along\n    with variables used for facets.\n\n    Parameters\n    ----------\n    df\n        A pandas DataFrame from which to select rows.\n    coordinfo\n        The data from a click/dblclick/hover event, like `input.myplot_click()`.\n    xvar\n        The name of the column in `df` that contains the x values. (Note that when using\n        plotnine, `xvar`, `yvar`, `panelvar1`, and `panelvar2` can usually be\n        automatically inferred from the brush data.)\n    yvar\n        The name of the column in `df` that contains the y values.\n    panelvar1\n        The name of the column in `df` that contains the first variable used for\n        subpanels (if subpanels are used).\n    panelvar2\n        The name of the column in `df` that contains the second variable used for\n        subpanels.\n    threshold\n        A maximum distance (in pixels) to the pointer location. Rows in the data frame\n        will be selected if the distance to the pointer is less than `threshold`.\n    max_points\n        Maximum number of rows to return. If `None` (the default), will return all rows\n        within the threshold distance.\n    add_dist\n        If `True`, add a column named `dist_` that contains the distance from the\n        coordinate to the point, in pixels. When no pointer event has yet occurred, the\n        value of `dist_` will be `numpy.NaN`.\n    all_rows\n        If `False` (the default), return a data frame containing only the rows that are\n        selected. If `True`, then all rows from the data frame will be returned, along\n        with an additional column named `selected_`, which indicates whether or not each\n        row was selected.\n\n    Returns\n    -------\n    :\n        A pandas DataFrame containing the rows selected by the brush. If `all_rows` is\n        `True`, then all rows from the original data will be returned, along with an\n        additional column named `selected_`, which indicates whether or not each row was\n        selected.\n    \"\"\"\n    import numpy as np\n\n    new_df = df.copy()\n\n    # For no current coordinfo\n    if coordinfo is None:\n        if add_dist:\n            new_df[\"dist\"] = np.NaN\n\n        if all_rows:\n            new_df[\"selected_\"] = False\n        else:\n            new_df = new_df.loc[[]]\n\n        return new_df\n\n    # Try to extract vars from coordinfo object\n    coordinfo_mapping = coordinfo[\"mapping\"]\n    if xvar is None and \"x\" in coordinfo_mapping:\n        xvar = coordinfo_mapping[\"x\"]\n    if yvar is None and \"y\" in coordinfo_mapping:\n        yvar = coordinfo_mapping[\"y\"]\n\n    if xvar is None:\n        if xvar is None and \"x\" in coordinfo[\"mapping\"]:\n            xvar = coordinfo[\"mapping\"][\"x\"]\n        raise ValueError(\n            \"near_points: not able to automatically infer `xvar` from coordinfo. You must supply `xvar` to near_points()\"\n        )\n    if yvar is None:\n        if yvar is None and \"y\" in coordinfo[\"mapping\"]:\n            yvar = coordinfo[\"mapping\"][\"y\"]\n        raise ValueError(\n            \"near_points: not able to automatically infer `yvar` from coordinfo. You must supply `yvar` to near_points()\"\n        )\n\n    if xvar not in new_df.columns:\n        raise ValueError(f\"near_points: `xvar` ('{xvar}')  not in names of input.\")\n    if yvar not in new_df.columns:\n        raise ValueError(f\"near_points: `yvar` ('{yvar}')  not in names of input.\")\n\n    x: pd.Series[float] = to_float(new_df[xvar])\n    y: pd.Series[float] = to_float(new_df[yvar])\n\n    # Get the coordinates of the point (in img pixel coordinates)\n    point_img: CoordXY = coordinfo[\"coords_img\"]\n\n    # Get coordinates of data points (in img pixel coordinates)\n    data_img: SeriesFloatXY = scale_coords(x, y, coordinfo)\n\n    # Get x/y distances (in css coordinates)\n    dist_css: SeriesFloatXY = {\n        \"x\": (data_img[\"x\"] - point_img[\"x\"]) / coordinfo[\"img_css_ratio\"][\"x\"],\n        \"y\": (data_img[\"y\"] - point_img[\"y\"]) / coordinfo[\"img_css_ratio\"][\"y\"],\n    }\n\n    # Distances of data points to the target point, in css pixels.\n    dists: pd.Series[float] = (dist_css[\"x\"] ** 2 + dist_css[\"y\"] ** 2) ** 0.5\n\n    if add_dist:\n        new_df[\"dist\"] = dists\n\n    keep_rows = dists <= threshold\n\n    # Find which rows are matches for the panel vars (if present)\n    if panelvar1 is None and \"panelvar1\" in coordinfo[\"mapping\"]:\n        panelvar1 = coordinfo[\"mapping\"][\"panelvar1\"]\n        if panelvar1 not in new_df:\n            raise ValueError(f\"near_points: `panelvar1` ({panelvar1}) not in dataframe\")\n        keep_rows &= new_df[panelvar1] == coordinfo[\"panelvar1\"]  # pyright: ignore\n\n    if panelvar2 is None and \"panelvar2\" in coordinfo[\"mapping\"]:\n        panelvar2 = coordinfo[\"mapping\"][\"panelvar2\"]\n        if panelvar2 not in new_df:\n            raise ValueError(f\"near_points: `panelvar2` ({panelvar2}) not in dataframe\")\n        keep_rows &= new_df[panelvar2] == coordinfo[\"panelvar2\"]  # pyright: ignore\n\n    # Track the row indices to keep (note this is the row position, 0, 1, 2, not the\n    # pandas index column, which can have arbitrary values).\n    keep_idx = np.where(keep_rows)[0]\n\n    # Order by distance\n    dists = dists.iloc[keep_idx]\n    keep_idx: npt.NDArray[np.intp] = keep_idx[dists.argsort()]\n\n    # Keep max number of rows\n    if max_points is not None and len(keep_idx) > max_points:\n        keep_idx = keep_idx[:max_points]\n\n    if all_rows:\n        # Add selected_ column if needed\n        new_df[\"selected_\"] = False\n        new_df.iloc[\n            keep_idx,\n            new_df.columns.get_loc(  # pyright: ignore[reportUnknownMemberType]\n                \"selected_\"\n            ),\n        ] = True\n    else:\n        new_df = new_df.iloc[keep_idx]\n\n    return new_df",
  "def within_brush(\n    vals: DataFrameColumn,\n    brush: BrushInfo,\n    var: Literal[\"x\", \"y\"] = \"x\",\n) -> pd.Series[bool]:\n    vals = to_float(vals)\n    return (vals >= brush[var + \"min\"]) & (vals <= brush[var + \"max\"])",
  "def to_float(x: DataFrameColumn) -> pd.Series[float]:\n    import pandas as pd\n    import pandas.api.types as ptypes\n\n    \"\"\"Convert int/float/str/categorical Series to a float Series.\n\n    If the input is a int or float Series, this returns a copy. Otherwise, it returns a\n    new Series object.\n    \"\"\"\n    if ptypes.is_numeric_dtype(x):  # pyright: ignore[reportUnknownMemberType]\n        return cast(\"pd.Series[float]\", x)\n    elif isinstance(x, ptypes.CategoricalDtype):\n        return cast(\"pd.Series[float]\", x.cat.codes + 1)  # pyright: ignore\n    elif ptypes.is_string_dtype(x):  # pyright: ignore[reportUnknownMemberType]\n        return cast(\n            \"pd.Series[float]\", x.astype(\"category\").cat.codes + 1  # pyright: ignore\n        )\n    elif ptypes.is_datetime64_any_dtype(x):  # pyright: ignore[reportUnknownMemberType]\n        # We need to convert the pandas datetimes, which are in nanoseconds since epoch,\n        # to matplotlib datetimes, which are in days since epoch..\n        return (\n            cast(\n                \"pd.Series[int]\",\n                pd.Series(x.astype(\"int64\")),  # pyright: ignore\n            )\n            / (24 * 60 * 60)\n            / 1e9\n        )\n\n    raise ValueError(\"to_float: unsupported dtype for x\")",
  "def map_linear(\n    x: pd.Series[float],\n    domain_min: float,\n    domain_max: float,\n    range_min: float,\n    range_max: float,\n    clip: bool = True,\n) -> pd.Series[float]:\n    factor = (range_max - range_min) / (domain_max - domain_min)\n    val: pd.Series[float] = x - domain_min\n    newval: pd.Series[float] = (val * factor) + range_min\n\n    if clip:\n        maxval = max(range_max, range_min)\n        minval = min(range_max, range_min)\n        newval[newval > maxval] = maxval\n        newval[newval < minval] = minval\n\n    return newval",
  "def scale_1d(\n    val: pd.Series[float],\n    domain_min: float,\n    domain_max: float,\n    range_min: float,\n    range_max: float,\n    logbase: Optional[float] = None,\n    clip: bool = True,\n) -> pd.Series[float]:\n    import numpy as np\n\n    if logbase is not None:\n        val = np.log(val) / np.log(logbase)\n\n    return map_linear(val, domain_min, domain_max, range_min, range_max, clip)",
  "def scale_coords(\n    x: pd.Series[float],\n    y: pd.Series[float],\n    coordinfo: CoordInfo,\n) -> SeriesFloatXY:\n    domain = coordinfo[\"domain\"]\n    range = coordinfo[\"range\"]\n    log = coordinfo[\"log\"]\n\n    return {\n        \"x\": scale_1d(\n            x, domain[\"left\"], domain[\"right\"], range[\"left\"], range[\"right\"], log[\"x\"]\n        ),\n        \"y\": scale_1d(\n            y, domain[\"bottom\"], domain[\"top\"], range[\"bottom\"], range[\"top\"], log[\"y\"]\n        ),\n    }",
  "class ReactiveWarning(RuntimeWarning):\n    pass",
  "class Context:\n    \"\"\"A reactive context\"\"\"\n\n    def __init__(self) -> None:\n        self.id: int = _reactive_environment.next_id()\n        self._invalidated: bool = False\n        self._invalidate_callbacks: list[Callable[[], None]] = []\n        self._flush_callbacks: list[Callable[[], Awaitable[None]]] = []\n\n    def __call__(self) -> typing.ContextManager[None]:\n        return _reactive_environment.use_context(self)\n\n    def invalidate(self) -> None:\n        \"\"\"Invalidate this context. It will immediately call the callbacks\n        that have been registered with onInvalidate().\"\"\"\n\n        if self._invalidated:\n            return\n\n        self._invalidated = True\n\n        for cb in self._invalidate_callbacks:\n            cb()\n\n        self._invalidate_callbacks.clear()\n\n    def on_invalidate(self, func: Callable[[], None]) -> None:\n        \"\"\"Register a function to be called when this context is invalidated\"\"\"\n        if self._invalidated:\n            func()\n        else:\n            self._invalidate_callbacks.append(func)\n\n    def add_pending_flush(self, priority: int) -> None:\n        \"\"\"Tell the reactive environment that this context should be flushed the\n        next time flushReact() called.\"\"\"\n        _reactive_environment.add_pending_flush(self, priority)\n\n    def on_flush(self, func: Callable[[], Awaitable[None]]) -> None:\n        \"\"\"Register a function to be called when this context is flushed.\"\"\"\n        self._flush_callbacks.append(func)\n\n    async def execute_flush_callbacks(self) -> None:\n        \"\"\"Execute all flush callbacks\"\"\"\n        for cb in self._flush_callbacks:\n            await cb()\n\n        self._flush_callbacks.clear()",
  "class Dependents:\n    def __init__(self) -> None:\n        self._dependents: dict[int, Context] = {}\n\n    def register(self) -> None:\n        ctx: Context = get_current_context()\n\n        if ctx.id in self._dependents:\n            # This context is already registered; no need to register it.\n            return\n\n        self._dependents[ctx.id] = ctx\n\n        def on_invalidate_cb() -> None:\n            if ctx.id in self._dependents:\n                del self._dependents[ctx.id]\n\n        ctx.on_invalidate(on_invalidate_cb)\n\n    def invalidate(self) -> None:\n        # TODO: Check sort order\n        # Invalidate all dependents. This gets all the dependents as list, then iterates\n        # over the list. It's done this way instead of iterating over keys because it's\n        # possible that a dependent is removed from the dict while iterating over it.\n        # https://github.com/posit-dev/py-shiny/issues/26\n        ids = sorted(self._dependents.keys())\n        for dep_ctx in [self._dependents[id] for id in ids]:\n            dep_ctx.invalidate()",
  "class ReactiveEnvironment:\n    \"\"\"The reactive environment\"\"\"\n\n    def __init__(self) -> None:\n        self._current_context: ContextVar[Optional[Context]] = ContextVar(\n            \"current_context\", default=None\n        )\n        self._next_id: int = 0\n        self._pending_flush_queue: PriorityQueueFIFO[Context] = PriorityQueueFIFO()\n        self._lock: Optional[asyncio.Lock] = None\n        self._flushed_callbacks = _utils.AsyncCallbacks()\n\n    @property\n    def lock(self) -> asyncio.Lock:\n        \"\"\"\n        Lock that protects this ReactiveEnvironment. It must be lazily created, because\n        at the time the module is loaded, there generally isn't a running asyncio loop\n        yet. This causes the asyncio.Lock to be created with a different loop than it\n        will be invoked from later; when that happens, acquire() will succeed if there's\n        no contention, but throw a \"hey you're on the wrong loop\" error if there is.\n        \"\"\"\n        if self._lock is None:\n            # Ensure we have a loop; get_running_loop() throws an error if we don't\n            asyncio.get_running_loop()\n            self._lock = asyncio.Lock()\n        return self._lock\n\n    def next_id(self) -> int:\n        \"\"\"Return the next available id\"\"\"\n        id = self._next_id\n        self._next_id += 1\n        return id\n\n    @contextlib.contextmanager\n    def use_context(self, ctx: Context) -> typing.Generator[None, None, None]:\n        old = self._current_context.set(ctx)\n        try:\n            yield\n        finally:\n            self._current_context.reset(old)\n\n    def current_context(self) -> Context:\n        \"\"\"Return the current Context object\"\"\"\n        ctx = self._current_context.get()\n        if ctx is None:\n            raise RuntimeError(\"No current reactive context\")\n        return ctx\n\n    def on_flushed(\n        self, func: Callable[[], Awaitable[None]], once: bool = False\n    ) -> Callable[[], None]:\n        return self._flushed_callbacks.register(func, once=once)\n\n    async def flush(self) -> None:\n        \"\"\"Flush all pending operations\"\"\"\n        await self._flush_sequential()\n        await self._flushed_callbacks.invoke()\n\n    async def _flush_sequential(self) -> None:\n        # Sequential flush: instead of storing the tasks in a list and calling gather()\n        # on them later, just run each effect in sequence.\n        while not self._pending_flush_queue.empty():\n            ctx = self._pending_flush_queue.get()\n            await ctx.execute_flush_callbacks()\n\n    def add_pending_flush(self, ctx: Context, priority: int) -> None:\n        self._pending_flush_queue.put(priority, ctx)\n\n    @contextlib.contextmanager\n    def isolate(self):\n        token = self._current_context.set(Context())\n        try:\n            yield\n        finally:\n            self._current_context.reset(token)",
  "def isolate():\n    \"\"\"\n    Create a non-reactive scope within a reactive scope.\n\n    Ordinarily, the simple act of reading a reactive value causes a relationship to be\n    established between the caller and the reactive value, where a change to the\n    reactive value will cause the caller to re-execute. (The same applies for the act of\n    getting a reactive expression's value.) `with isolate()` lets you read a reactive\n    value or expression without establishing this relationship.\n\n    ``with isolate()`` can also be useful for calling reactive expression at the\n    console, which can be useful for debugging. To do so, wrap the calls to the reactive\n    expression with ``with isolate()``.\n\n    Returns\n    -------\n    :\n        A context manager that executes the given expression in a scope where reactive\n        values can be read, but do not cause the reactive scope of the caller to be\n        re-evaluated when they change.\n\n    See Also\n    --------\n    ~shiny.reactive.event\n    \"\"\"\n    with _reactive_environment.isolate():\n        yield",
  "def get_current_context() -> Context:\n    \"\"\"\n    Get the current reactive context.\n\n    Returns\n    -------\n    :\n        A :class:`~Context`.\n\n    Raises\n    ------\n    RuntimeError\n        If called outside of a reactive context.\n    \"\"\"\n    return _reactive_environment.current_context()",
  "async def flush() -> None:\n    \"\"\"\n    Run any pending invalidations (i.e., flush the reactive environment).\n\n    Warning\n    -------\n    This function shouldn't ever need to be called inside a Shiny app. It's only\n    useful for testing and running reactive code interactively in the console.\n    \"\"\"\n    await _reactive_environment.flush()",
  "def on_flushed(\n    func: Callable[[], Awaitable[None]], once: bool = False\n) -> Callable[[], None]:\n    \"\"\"\n    Register a function to be called when the reactive environment is flushed\n\n    Parameters\n    ----------\n    func\n        The function to be called when the reactive environment is flushed\n    once\n        If True, the function will only be called once, and then removed from the\n\n    Returns\n    -------\n    :\n        A function that can be used to unregister the callback.\n\n    See Also\n    --------\n    flush\n    \"\"\"\n\n    return _reactive_environment.on_flushed(func, once)",
  "def lock() -> asyncio.Lock:\n    \"\"\"\n    A lock that should be held whenever manipulating the reactive graph.\n\n    For example, this makes it safe to set a :class:`~reactive.Value` and call\n    :func:`~reactive.flush()` from a different :class:`~asyncio.Task` than the one that\n    is running the Shiny :class:`~shiny.Session`.\n    \"\"\"\n    return _reactive_environment.lock",
  "def invalidate_later(\n    delay: float, *, session: \"MISSING_TYPE | Session | None\" = MISSING\n) -> None:\n    \"\"\"\n    Scheduled Invalidation\n\n    Schedules the current reactive context to be invalidated in the given number of\n    seconds.\n\n    Parameters\n    ----------\n    delay\n        The number of seconds to wait before invalidating.\n\n    Note\n    ----\n    When called within a reactive function (i.e., :func:`Effect`, :func:`Calc`,\n    :func:`render.ui`, etc.), that reactive context is invalidated (and re-executes)\n    after the interval has passed. The re-execution will reset the invalidation flag, so\n    in a typical use case, the object will keep re-executing and waiting for the\n    specified interval. It's possible to stop this cycle by adding conditional logic\n    that prevents the ``invalidate_later`` from being run.\n    \"\"\"\n\n    if isinstance(session, MISSING_TYPE):\n        from ..session import get_current_session\n\n        # If no session is provided, autodetect the current session (this\n        # could be None if outside of a session).\n        session = get_current_session()\n\n    ctx = get_current_context()\n    # Pass an absolute time to our subtask, rather than passing the delay directly, in\n    # case the subtask doesn't get a chance to start sleeping until a significant amount\n    # of time has passed.\n    deadline = time.monotonic() + delay\n\n    cancellable = True\n    # unsub is used to unsubscribe from session.on_ended when time expires. We don't\n    # want a ton of event handler registrations sitting there uselessly, keeping object\n    # graphs from being gc'd.\n    unsub: Optional[Callable[[], None]] = None\n\n    async def _task(ctx: Context, deadline: float):\n        nonlocal cancellable\n        try:\n            delay = deadline - time.monotonic()\n            try:\n                await asyncio.sleep(delay)\n            except asyncio.CancelledError:\n                # This happens when cancel_task is called due to the session ending, or\n                # the context being invalidated due to some other reason. There's no\n                # reason for us to keep waiting at that point, as ctx.invalidate() can\n                # only be a no-op.\n                return\n\n            async with lock():\n                # Prevent the ctx.invalidate() from killing our own task. (Another way\n                # to accomplish this is to unregister our ctx.on_invalidate handler, but\n                # ctx.on_invalidate doesn't currently allow unregistration.)\n                cancellable = False\n\n                ctx.invalidate()\n                await flush()\n\n        except BaseException:\n            traceback.print_exc()\n            raise\n        finally:\n            if unsub:\n                unsub()\n\n    task = asyncio.create_task(_task(ctx, deadline))\n\n    def cancel_task():\n        if cancellable and not task.cancelled():\n            task.cancel()\n\n    ctx.on_invalidate(cancel_task)\n    if session:\n        unsub = session.on_ended(cancel_task)",
  "def __init__(self) -> None:\n        self.id: int = _reactive_environment.next_id()\n        self._invalidated: bool = False\n        self._invalidate_callbacks: list[Callable[[], None]] = []\n        self._flush_callbacks: list[Callable[[], Awaitable[None]]] = []",
  "def __call__(self) -> typing.ContextManager[None]:\n        return _reactive_environment.use_context(self)",
  "def invalidate(self) -> None:\n        \"\"\"Invalidate this context. It will immediately call the callbacks\n        that have been registered with onInvalidate().\"\"\"\n\n        if self._invalidated:\n            return\n\n        self._invalidated = True\n\n        for cb in self._invalidate_callbacks:\n            cb()\n\n        self._invalidate_callbacks.clear()",
  "def on_invalidate(self, func: Callable[[], None]) -> None:\n        \"\"\"Register a function to be called when this context is invalidated\"\"\"\n        if self._invalidated:\n            func()\n        else:\n            self._invalidate_callbacks.append(func)",
  "def add_pending_flush(self, priority: int) -> None:\n        \"\"\"Tell the reactive environment that this context should be flushed the\n        next time flushReact() called.\"\"\"\n        _reactive_environment.add_pending_flush(self, priority)",
  "def on_flush(self, func: Callable[[], Awaitable[None]]) -> None:\n        \"\"\"Register a function to be called when this context is flushed.\"\"\"\n        self._flush_callbacks.append(func)",
  "async def execute_flush_callbacks(self) -> None:\n        \"\"\"Execute all flush callbacks\"\"\"\n        for cb in self._flush_callbacks:\n            await cb()\n\n        self._flush_callbacks.clear()",
  "def __init__(self) -> None:\n        self._dependents: dict[int, Context] = {}",
  "def register(self) -> None:\n        ctx: Context = get_current_context()\n\n        if ctx.id in self._dependents:\n            # This context is already registered; no need to register it.\n            return\n\n        self._dependents[ctx.id] = ctx\n\n        def on_invalidate_cb() -> None:\n            if ctx.id in self._dependents:\n                del self._dependents[ctx.id]\n\n        ctx.on_invalidate(on_invalidate_cb)",
  "def invalidate(self) -> None:\n        # TODO: Check sort order\n        # Invalidate all dependents. This gets all the dependents as list, then iterates\n        # over the list. It's done this way instead of iterating over keys because it's\n        # possible that a dependent is removed from the dict while iterating over it.\n        # https://github.com/posit-dev/py-shiny/issues/26\n        ids = sorted(self._dependents.keys())\n        for dep_ctx in [self._dependents[id] for id in ids]:\n            dep_ctx.invalidate()",
  "def __init__(self) -> None:\n        self._current_context: ContextVar[Optional[Context]] = ContextVar(\n            \"current_context\", default=None\n        )\n        self._next_id: int = 0\n        self._pending_flush_queue: PriorityQueueFIFO[Context] = PriorityQueueFIFO()\n        self._lock: Optional[asyncio.Lock] = None\n        self._flushed_callbacks = _utils.AsyncCallbacks()",
  "def lock(self) -> asyncio.Lock:\n        \"\"\"\n        Lock that protects this ReactiveEnvironment. It must be lazily created, because\n        at the time the module is loaded, there generally isn't a running asyncio loop\n        yet. This causes the asyncio.Lock to be created with a different loop than it\n        will be invoked from later; when that happens, acquire() will succeed if there's\n        no contention, but throw a \"hey you're on the wrong loop\" error if there is.\n        \"\"\"\n        if self._lock is None:\n            # Ensure we have a loop; get_running_loop() throws an error if we don't\n            asyncio.get_running_loop()\n            self._lock = asyncio.Lock()\n        return self._lock",
  "def next_id(self) -> int:\n        \"\"\"Return the next available id\"\"\"\n        id = self._next_id\n        self._next_id += 1\n        return id",
  "def use_context(self, ctx: Context) -> typing.Generator[None, None, None]:\n        old = self._current_context.set(ctx)\n        try:\n            yield\n        finally:\n            self._current_context.reset(old)",
  "def current_context(self) -> Context:\n        \"\"\"Return the current Context object\"\"\"\n        ctx = self._current_context.get()\n        if ctx is None:\n            raise RuntimeError(\"No current reactive context\")\n        return ctx",
  "def on_flushed(\n        self, func: Callable[[], Awaitable[None]], once: bool = False\n    ) -> Callable[[], None]:\n        return self._flushed_callbacks.register(func, once=once)",
  "async def flush(self) -> None:\n        \"\"\"Flush all pending operations\"\"\"\n        await self._flush_sequential()\n        await self._flushed_callbacks.invoke()",
  "async def _flush_sequential(self) -> None:\n        # Sequential flush: instead of storing the tasks in a list and calling gather()\n        # on them later, just run each effect in sequence.\n        while not self._pending_flush_queue.empty():\n            ctx = self._pending_flush_queue.get()\n            await ctx.execute_flush_callbacks()",
  "def add_pending_flush(self, ctx: Context, priority: int) -> None:\n        self._pending_flush_queue.put(priority, ctx)",
  "def isolate(self):\n        token = self._current_context.set(Context())\n        try:\n            yield\n        finally:\n            self._current_context.reset(token)",
  "async def _task(ctx: Context, deadline: float):\n        nonlocal cancellable\n        try:\n            delay = deadline - time.monotonic()\n            try:\n                await asyncio.sleep(delay)\n            except asyncio.CancelledError:\n                # This happens when cancel_task is called due to the session ending, or\n                # the context being invalidated due to some other reason. There's no\n                # reason for us to keep waiting at that point, as ctx.invalidate() can\n                # only be a no-op.\n                return\n\n            async with lock():\n                # Prevent the ctx.invalidate() from killing our own task. (Another way\n                # to accomplish this is to unregister our ctx.on_invalidate handler, but\n                # ctx.on_invalidate doesn't currently allow unregistration.)\n                cancellable = False\n\n                ctx.invalidate()\n                await flush()\n\n        except BaseException:\n            traceback.print_exc()\n            raise\n        finally:\n            if unsub:\n                unsub()",
  "def cancel_task():\n        if cancellable and not task.cancelled():\n            task.cancel()",
  "def on_invalidate_cb() -> None:\n            if ctx.id in self._dependents:\n                del self._dependents[ctx.id]",
  "def poll(\n    poll_func: Callable[[], Any] | Callable[[], Awaitable[Any]],\n    interval_secs: float = 1,\n    *,\n    equals: Callable[[Any, Any], bool] = eq,\n    priority: int = 0,\n    session: MISSING_TYPE | Session | None = MISSING,\n) -> Callable[[Callable[[], T]], Callable[[], T]]:\n    \"\"\"\n    Create a reactive polling object.\n\n    Polling is a technique that approximates \"real-time\" or streaming updates, using a\n    data source that does not actually have push notifications but does have a quick way\n    to repeatedly check for changes on demand.\n\n    A reactive polling object is constructed using two functions: a polling function,\n    which is a fast-running, inexpensive function that is used to determine whether some\n    data source has changed (such as the timestamp of a file, or a `SELECT MAX(updated)\n    FROM table` query); and a slower-running reading function that actually loads and\n    returns the data that is desired. The `poll()` function is intended to be used as a\n    decorator: the poll function is passed as the `poll_func` arg to `@poll()`, while\n    the data reading function is the target of the decorator.\n\n    Reactive consumers can invoke the resulting polling object to get the current data,\n    and will automatically invalidate when the polling function detects a change.\n    Polling objects also cache the results of the read function; for this reason, apps\n    where all sessions depend on the same data source may want to declare the polling\n    object at the top level of app.py (outside of the server function).\n\n    Both `poll_func` and the decorated (data reading) function can read reactive values\n    and ~shiny.reactive.Calc objects. Any invalidations triggered by reactive\n    dependencies will apply to the reactive polling object immediately (not waiting for\n    the `interval_secs` delay to expire).\n\n    Parameters\n    ----------\n    poll_func\n        A function to be called frequently to determine whether a data source has\n        changed. The return value should be something that can be compared inexpensively\n        using `==`. Both regular functions and coroutine functions are allowed.\n\n        Note that the `poll_func` should NOT return a bool that indicates whether the\n        data source has changed. Rather, each `poll_func` return value will be checked\n        for equality with its preceding `poll_func` return value (using `==` semantics\n        by default), and if it differs, the data source will be considered changed.\n    interval_secs\n        The number of seconds to wait after each `poll_func` invocation before polling\n        again. Note: depending on what other tasks are executing, the actual wait time\n        may far exceed this value.\n    equals\n        The function that will be used to compare each `poll_func` return value with its\n        immediate predecessor.\n    priority\n        Reactive polling is implemented using an ~shiny.reactive.Effect to call\n        `poll_func` on a timer; use the `priority` argument to control the order of this\n        Effect's execution versus other Effects in your app. See ~shiny.reactive.Effect\n        for more details.\n    session\n        A :class:`~shiny.Session` instance. If not provided, it is inferred via\n        :func:`~shiny.session.get_current_session`. If there is no current session (i.e.\n        `poll` is being created outside of the server function), the lifetime of this\n        reactive poll object will not be tied to any specific session.\n\n    Returns\n    -------\n    :\n        A decorator that should be applied to a no-argument function that (expensively)\n    reads whatever data is desired. (This function may be a regular function or a\n    coroutine function.) The result of the decorator is a reactive ~shiny.reactive.Calc\n    that always returns up-to-date data, and invalidates callers when changes are\n    detected via polling.\n\n    See Also\n    --------\n    ~shiny.reactive.file_reader\n    \"\"\"\n\n    with reactive.isolate():\n        last_value: reactive.Value[Any] = reactive.Value(poll_func())\n        last_error: reactive.Value[Optional[Exception]] = reactive.Value(None)\n\n    @reactive.Effect(priority=priority, session=session)\n    async def _():\n        try:\n            if _utils.is_async_callable(poll_func):\n                new = await poll_func()\n            else:\n                new = poll_func()\n\n            with reactive.isolate():\n                old = last_value.get()\n\n            try:\n                is_equal = equals(old, new)\n            except Exception as e:\n                # For example, pandas DataFrame throws if you try to compare it to a\n                # non-comparable object\n                raise TypeError(\n                    \"The reactive.poll polling function returned an object that \"\n                    \"couldn't be compared with a previously returned object. Try \"\n                    \"modifying your polling function to return a simpler type, like a \"\n                    \"str, float, list, or dict.\"\n                ) from e\n            if not isinstance(is_equal, bool):\n                # Comparison succeeded, but we don't understand the result\n                if equals is eq:\n                    # We used == but it didn't work\n                    raise TypeError(\n                        \"The reactive.poll polling function returned an object \"\n                        \"that doesn't implement a simple == operator. Try \"\n                        \"modifying your polling function to return a simpler type, \"\n                        \"like a str, float, list, or dict.\"\n                    )\n                else:\n                    # The caller passed in a custom function\n                    raise TypeError(\n                        \"The reactive.poll `equals` function returned a non-bool \"\n                        \"value\"\n                    )\n\n            # If we got here, the comparison succeeded. Need to make sure the error is\n            # cleared, but don't unnecessarily call last_error.set(); at the time of\n            # this writing, we haven't made a final decision on whether reactive.Value\n            # will ignore sets if the new value is identical to the existing one.\n            with reactive.isolate():\n                if last_error.get() is not None:\n                    last_error.set(None)\n\n            if not is_equal:\n                last_value.set(new)\n        except Exception as e:\n            # Either the polling function threw an error, or we failed to compare its\n            # result with a previous result. Either way, we failed; save the error so\n            # that it can be exposed to whoever's trying to use the poll object.\n            last_error.set(e)\n        finally:\n            reactive.invalidate_later(interval_secs)\n\n    def wrapper(fn: Callable[[], T]) -> Callable[[], T]:\n        if _utils.is_async_callable(fn):\n\n            @reactive.Calc(session=session)\n            @functools.wraps(fn)\n            async def result_async() -> T:\n                # If an error occurred, raise it\n                err = last_error.get()\n                if err is not None:\n                    raise err\n\n                # Take dependency on polling result\n                last_value.get()\n\n                # Note that we also depend on the main function\n                return await fn()\n\n            # In this code path, the cast is necessary because result_async() has an\n            # incorrect signature due to limitations in Python's type hints. In this\n            # path, T is already an Awaitable. The signature should really be `async def\n            # result_async() -> Awaited[T]`, but there's no Awaited type in Python. So\n            # instead we'll just cast() it.\n            return cast(Callable[[], T], result_async)\n\n        else:\n\n            @reactive.Calc(session=session)\n            @functools.wraps(fn)\n            def result_sync() -> T:\n                # If an error occurred, raise it\n                err = last_error.get()\n                if err is not None:\n                    raise err\n\n                # Take dependency on polling result\n                last_value.get()\n\n                # Note that we also depend on the main function\n                return fn()\n\n            return result_sync\n\n    return wrapper",
  "def file_reader(\n    filepath: str\n    | os.PathLike[str]\n    | Callable[[], str]\n    | Callable[[], os.PathLike[str]],\n    interval_secs: float = 1,\n    *,\n    priority: int = 1,\n    session: MISSING_TYPE | Session | None = MISSING,\n) -> Callable[[Callable[[], T]], Callable[[], T]]:\n    \"\"\"\n    Create a reactive file reader.\n\n    This is a decorator, meant to be applied to a no-argument function that reads data\n    from a file on disk. Whenever the file changes (or to be precise, the file size or\n    last modified time changes), past readers of the data are reactively invalidated.\n    This makes it incredibly easy to write apps that automatically update all of their\n    outputs as soon as files on disk change.\n\n    Note that `file_reader` works only on single files, not directories of files.\n\n    Both the `filepath` function and the decorated (file reading) function can read\n    reactive values and ~shiny.reactive.Calc objects. Any invalidations triggered by\n    reactive dependencies will apply to the reactive file reader object immediately (not\n    waiting for the `interval_secs` delay to expire).\n\n    Parameters\n    ----------\n    filepath\n        Either a string indicating the file path to be monitored, or, a no-argument\n        function that returns such a string. The latter is useful if the file to be\n        monitored depends on some user input, the current date/time, etc.\n\n        The file path provided MUST exist, otherwise Shiny will treat it as an unhandled\n        error and close the session.\n\n        If a function is used, make sure it is high performance (or is cached, i.e. use\n        a ~shiny.reactive.Calc), as it will be called very frequently.\n    interval_secs\n        The number of seconds to wait after each time the file metadata is checked.\n        Note: depending on what other tasks are executing, the actual wait time may far\n        exceed this value.\n    priority\n        Reactive polling is implemented using an ~shiny.reactive.Effect to call\n        `poll_func` on a timer; use the `priority` argument to control the order of this\n        Effect's execution versus other Effects in your app. See ~shiny.reactive.Effect\n        for more details.\n    session\n        A :class:`~shiny.Session` instance. If not provided, it is inferred via\n        :func:`~shiny.session.get_current_session`. If there is no current session (i.e.\n        `poll` is being created outside of the server function), the lifetime of this\n        reactive poll object will not be tied to any specific session.\n\n    Returns\n    -------\n    :\n        A decorator that should be applied to a no-argument function that (expensively)\n    reads whatever data is desired. (This function may be a regular function or a\n    coroutine function.) The result of the decorator is a reactive ~shiny.reactive.Calc\n    that always returns up-to-date data, and invalidates callers when changes are\n    detected via polling.\n\n    See Also\n    --------\n    ~shiny.reactive.poll\n    \"\"\"\n\n    if isinstance(filepath, str):\n        # Normalize filepath so it's always a function\n\n        filepath_value = filepath\n\n        def filepath_func_str() -> str:\n            return filepath_value\n\n        filepath = filepath_func_str\n    elif isinstance(filepath, os.PathLike):\n        filepath_value = filepath\n\n        def filepath_func_pathlike() -> os.PathLike[str]:\n            return filepath_value\n\n        filepath = filepath_func_pathlike\n\n    def check_timestamp():\n        path = filepath()\n        return (path, os.path.getmtime(path), os.path.getsize(path))\n\n    def wrapper(fn: Callable[[], T]) -> Callable[[], T]:\n        if _utils.is_async_callable(fn):\n\n            @poll(\n                check_timestamp,\n                interval_secs=interval_secs,\n                priority=priority,\n                session=session,\n            )\n            @functools.wraps(fn)\n            async def reader_async():\n                return await fn()\n\n            # See poll() for explanation of why this cast is needed.\n            return cast(Callable[[], T], reader_async)\n        else:\n\n            @poll(\n                check_timestamp,\n                interval_secs=interval_secs,\n                priority=priority,\n                session=session,\n            )\n            @functools.wraps(fn)\n            def reader():\n                return fn()\n\n            return reader\n\n    return wrapper",
  "async def _():\n        try:\n            if _utils.is_async_callable(poll_func):\n                new = await poll_func()\n            else:\n                new = poll_func()\n\n            with reactive.isolate():\n                old = last_value.get()\n\n            try:\n                is_equal = equals(old, new)\n            except Exception as e:\n                # For example, pandas DataFrame throws if you try to compare it to a\n                # non-comparable object\n                raise TypeError(\n                    \"The reactive.poll polling function returned an object that \"\n                    \"couldn't be compared with a previously returned object. Try \"\n                    \"modifying your polling function to return a simpler type, like a \"\n                    \"str, float, list, or dict.\"\n                ) from e\n            if not isinstance(is_equal, bool):\n                # Comparison succeeded, but we don't understand the result\n                if equals is eq:\n                    # We used == but it didn't work\n                    raise TypeError(\n                        \"The reactive.poll polling function returned an object \"\n                        \"that doesn't implement a simple == operator. Try \"\n                        \"modifying your polling function to return a simpler type, \"\n                        \"like a str, float, list, or dict.\"\n                    )\n                else:\n                    # The caller passed in a custom function\n                    raise TypeError(\n                        \"The reactive.poll `equals` function returned a non-bool \"\n                        \"value\"\n                    )\n\n            # If we got here, the comparison succeeded. Need to make sure the error is\n            # cleared, but don't unnecessarily call last_error.set(); at the time of\n            # this writing, we haven't made a final decision on whether reactive.Value\n            # will ignore sets if the new value is identical to the existing one.\n            with reactive.isolate():\n                if last_error.get() is not None:\n                    last_error.set(None)\n\n            if not is_equal:\n                last_value.set(new)\n        except Exception as e:\n            # Either the polling function threw an error, or we failed to compare its\n            # result with a previous result. Either way, we failed; save the error so\n            # that it can be exposed to whoever's trying to use the poll object.\n            last_error.set(e)\n        finally:\n            reactive.invalidate_later(interval_secs)",
  "def wrapper(fn: Callable[[], T]) -> Callable[[], T]:\n        if _utils.is_async_callable(fn):\n\n            @reactive.Calc(session=session)\n            @functools.wraps(fn)\n            async def result_async() -> T:\n                # If an error occurred, raise it\n                err = last_error.get()\n                if err is not None:\n                    raise err\n\n                # Take dependency on polling result\n                last_value.get()\n\n                # Note that we also depend on the main function\n                return await fn()\n\n            # In this code path, the cast is necessary because result_async() has an\n            # incorrect signature due to limitations in Python's type hints. In this\n            # path, T is already an Awaitable. The signature should really be `async def\n            # result_async() -> Awaited[T]`, but there's no Awaited type in Python. So\n            # instead we'll just cast() it.\n            return cast(Callable[[], T], result_async)\n\n        else:\n\n            @reactive.Calc(session=session)\n            @functools.wraps(fn)\n            def result_sync() -> T:\n                # If an error occurred, raise it\n                err = last_error.get()\n                if err is not None:\n                    raise err\n\n                # Take dependency on polling result\n                last_value.get()\n\n                # Note that we also depend on the main function\n                return fn()\n\n            return result_sync",
  "def check_timestamp():\n        path = filepath()\n        return (path, os.path.getmtime(path), os.path.getsize(path))",
  "def wrapper(fn: Callable[[], T]) -> Callable[[], T]:\n        if _utils.is_async_callable(fn):\n\n            @poll(\n                check_timestamp,\n                interval_secs=interval_secs,\n                priority=priority,\n                session=session,\n            )\n            @functools.wraps(fn)\n            async def reader_async():\n                return await fn()\n\n            # See poll() for explanation of why this cast is needed.\n            return cast(Callable[[], T], reader_async)\n        else:\n\n            @poll(\n                check_timestamp,\n                interval_secs=interval_secs,\n                priority=priority,\n                session=session,\n            )\n            @functools.wraps(fn)\n            def reader():\n                return fn()\n\n            return reader",
  "def filepath_func_str() -> str:\n            return filepath_value",
  "async def result_async() -> T:\n                # If an error occurred, raise it\n                err = last_error.get()\n                if err is not None:\n                    raise err\n\n                # Take dependency on polling result\n                last_value.get()\n\n                # Note that we also depend on the main function\n                return await fn()",
  "def result_sync() -> T:\n                # If an error occurred, raise it\n                err = last_error.get()\n                if err is not None:\n                    raise err\n\n                # Take dependency on polling result\n                last_value.get()\n\n                # Note that we also depend on the main function\n                return fn()",
  "def filepath_func_pathlike() -> os.PathLike[str]:\n            return filepath_value",
  "async def reader_async():\n                return await fn()",
  "def reader():\n                return fn()",
  "class Value(Generic[T]):\n    \"\"\"\n    Create a reactive value.\n\n    Reactive values are the source of reactivity in Shiny. Changes to reactive values\n    invalidate downstream reactive functions (:func:`~shiny.reactive.Calc`,\n    :func:`~shiny.reactive.Effect`, and `render` functions decorated with `@output`).\n    When these functions are invalidated, they get scheduled to re-execute.\n\n    Shiny input values are read-only reactive values. For example, `input.x` is a\n    reactive value object, and to get the current value, you can call `input.x()` or\n    `input.x.get()`. When you do that inside of a reactive function, the function takes\n    a dependency on the reactive value.\n\n    Parameters\n    ----------\n    value\n        An optional initial value.\n    read_only\n        If ``True``, then the reactive value cannot be `set()`.\n\n    Returns\n    -------\n    :\n        An instance of a reactive value.\n\n    Raises\n    ------\n    ~shiny.types.SilentException\n        If :func:`~Value.get` is called before a value is provided/set.\n\n    Note\n    ----\n    A reactive value may only be read from within a reactive function (e.g.,\n    :func:`~shiny.reactive.Calc`, :func:`~shiny.reactive.Effect`,\n    :func:`shiny.render.text`, etc.) and, when doing so, the function takes a reactive\n    dependency on the value (i.e., when the value changes, the calling reactive function\n    will re-execute).\n\n    See Also\n    --------\n    ~shiny.Inputs ~shiny.reactive.Calc ~shiny.reactive.Effect\n    \"\"\"\n\n    # These overloads are necessary so that the following hold:\n    # - Value() is marked by the type checker as an error, because the type T is\n    #   unknown. (It is not a run-time error.)\n    # - Value[int]() works.\n    # - Value[int](1) works.\n    # - Value(1) works, with T is inferred to be int.\n    @overload\n    def __init__(\n        self, value: MISSING_TYPE = MISSING, *, read_only: bool = False\n    ) -> None:\n        ...\n\n    @overload\n    def __init__(self, value: T, *, read_only: bool = False) -> None:\n        ...\n\n    # If `value` is MISSING, then `get()` will raise a SilentException, until a new\n    # value is set. Calling `unset()` will set the value to MISSING.\n    def __init__(\n        self, value: T | MISSING_TYPE = MISSING, *, read_only: bool = False\n    ) -> None:\n        self._value: T | MISSING_TYPE = value\n        self._read_only: bool = read_only\n        self._value_dependents: Dependents = Dependents()\n        self._is_set_dependents: Dependents = Dependents()\n\n    def __call__(self) -> T:\n        return self.get()\n\n    def get(self) -> T:\n        \"\"\"\n        Read the reactive value.\n\n        Returns\n        -------\n        :\n            A value.\n\n        Raises\n        ------\n        ~shiny.types.SilentException\n            If the value is not set.\n        RuntimeError\n            If called from outside a reactive function.\n        \"\"\"\n\n        self._value_dependents.register()\n\n        if isinstance(self._value, MISSING_TYPE):\n            raise SilentException\n\n        return self._value\n\n    def set(self, value: T) -> bool:\n        \"\"\"\n        Set the reactive value to a new value.\n\n        Parameters\n        ----------\n        value\n            A value.\n\n        Returns\n        -------\n        :\n            ``True`` if the value was set to a different value and ``False`` otherwise.\n\n        Raises\n        ------\n        RuntimeError\n            If called on a read-only reactive value.\n        \"\"\"\n        if self._read_only:\n            raise RuntimeError(\n                \"Can't set read-only Value. If you are trying to set an input value, use `update_xxx()` instead.\"\n            )\n        return self._set(value)\n\n    # The ._set() method allows setting read-only Value objects. This is used when the\n    # Value is part of a session.Inputs object, and the session wants to set it.\n    def _set(self, value: T) -> bool:\n        if self._value is value:\n            return False\n\n        if isinstance(self._value, MISSING_TYPE) != isinstance(value, MISSING_TYPE):\n            self._is_set_dependents.invalidate()\n\n        self._value = value\n        self._value_dependents.invalidate()\n        return True\n\n    def unset(self) -> None:\n        \"\"\"\n        Unset the reactive value.\n\n        Returns\n        -------\n        :\n            ``True`` if the value was set prior to this unsetting.\n        \"\"\"\n        self.set(MISSING)  # type: ignore\n\n    def is_set(self) -> bool:\n        \"\"\"\n        Check if the reactive value is set.\n\n        Returns\n        -------\n        :\n            ``True`` if the value is set, ``False`` otherwise.\n        \"\"\"\n\n        self._is_set_dependents.register()\n        return not isinstance(self._value, MISSING_TYPE)\n\n    def freeze(self) -> None:\n        \"\"\"\n        Freeze the reactive value.\n\n        Freezing is equivalent to unsetting the value, but it does not invalidate\n        dependents.\n        \"\"\"\n        self._value = MISSING",
  "class Calc_(Generic[T]):\n    \"\"\"\n    Mark a function as a reactive calculation.\n\n    Warning\n    -------\n    Most users shouldn't use this class directly to initialize a reactive calculation\n    (instead, use the :func:`~shiny.reactive.Calc` decorator).\n    \"\"\"\n\n    def __init__(\n        self,\n        fn: CalcFunction[T],\n        *,\n        session: \"MISSING_TYPE | Session | None\" = MISSING,\n    ) -> None:\n        self.__name__ = fn.__name__\n        self.__doc__ = fn.__doc__\n\n        # The CalcAsync subclass will pass in an async function, but it tells the\n        # static type checker that it's synchronous. wrap_async() is smart -- if is\n        # passed an async function, it will not change it.\n        self._fn: CalcFunctionAsync[T] = _utils.wrap_async(fn)\n        self._is_async: bool = _utils.is_async_callable(fn)\n\n        self._dependents: Dependents = Dependents()\n        self._invalidated: bool = True\n        self._running: bool = False\n        self._most_recent_ctx_id: int = -1\n        self._ctx: Optional[Context] = None\n        self._exec_count: int = 0\n\n        self._session: Optional[Session]\n        # Use `isinstance(x, MISSING_TYPE)`` instead of `x is MISSING` because\n        # the type checker doesn't know that MISSING is the only instance of\n        # MISSING_TYPE; this saves us from casting later on.\n        if isinstance(session, MISSING_TYPE):\n            from ..session import get_current_session\n\n            # If no session is provided, autodetect the current session (this\n            # could be None if outside of a session).\n            session = get_current_session()\n        self._session = session\n\n        # Use lists to hold (optional) value and error, instead of Optional[T],\n        # because it makes typing more straightforward. For example if\n        # .get_value() simply returned self._value, self._value had type\n        # Optional[T], then the return type for get_value() would have to be\n        # Optional[T].\n        self._value: list[T] = []\n        self._error: list[Exception] = []\n\n    def __call__(self) -> T:\n        # Run the Coroutine (synchronously), and then return the value.\n        # If the Coroutine yields control, then an error will be raised.\n        return _utils.run_coro_sync(self.get_value())\n\n    # TODO: should this be private?\n    async def get_value(self) -> T:\n        self._dependents.register()\n\n        if self._invalidated or self._running:\n            await self.update_value()\n\n        if self._error:\n            raise self._error[0]\n\n        return self._value[0]\n\n    # TODO: should this be private?\n    async def update_value(self) -> None:\n        self._ctx = Context()\n        self._most_recent_ctx_id = self._ctx.id\n\n        self._ctx.on_invalidate(self._on_invalidate_cb)\n\n        self._exec_count += 1\n        self._invalidated = False\n\n        was_running = self._running\n        self._running = True\n\n        from ..session import session_context\n\n        with session_context(self._session):\n            try:\n                with self._ctx():\n                    await self._run_func()\n            finally:\n                self._running = was_running\n\n    def _on_invalidate_cb(self) -> None:\n        self._invalidated = True\n        self._value.clear()  # Allow old value to be GC'd\n        self._dependents.invalidate()\n        self._ctx = None  # Allow context to be GC'd\n\n    async def _run_func(self) -> None:\n        self._error.clear()\n        try:\n            self._value.append(await self._fn())\n        except Exception as err:\n            self._error.append(err)",
  "class CalcAsync_(Calc_[T]):\n    \"\"\"\n    Mark an async function as a reactive calculation.\n\n    Warning\n    -------\n    Most users shouldn't use this class directly to initialize a reactive calculation\n    (instead, use the :func:`~shiny.reactive.Calc` decorator).\n    \"\"\"\n\n    def __init__(\n        self,\n        fn: CalcFunctionAsync[T],\n        *,\n        session: \"MISSING_TYPE | Session | None\" = MISSING,\n    ) -> None:\n        if not _utils.is_async_callable(fn):\n            raise TypeError(self.__class__.__name__ + \" requires an async function\")\n\n        super().__init__(cast(CalcFunction[T], fn), session=session)\n\n    async def __call__(self) -> T:  # pyright: ignore[reportIncompatibleMethodOverride]\n        return await self.get_value()",
  "def Calc(fn: CalcFunctionAsync[T]) -> CalcAsync_[T]:\n    ...",
  "def Calc(fn: CalcFunction[T]) -> Calc_[T]:\n    ...",
  "def Calc(\n    *, session: \"MISSING_TYPE | Session | None\" = MISSING\n) -> Callable[[CalcFunction[T]], Calc_[T]]:\n    ...",
  "def Calc(\n    fn: Optional[CalcFunction[T] | CalcFunctionAsync[T]] = None,\n    *,\n    session: \"MISSING_TYPE | Session | None\" = MISSING,\n) -> Calc_[T] | Callable[[CalcFunction[T]], Calc_[T]]:\n    \"\"\"\n    Mark a function as a reactive calculation.\n\n    A reactive calculation is a function whose return value depends solely on other\n    reactive value(s) (i.e., :class:`~shiny.Inputs`, :class:`~shiny.reactive.Value`,\n    and other reactive calculations). Whenever a reactive value changes, any reactive\n    calculations that depend on it are \"invalidated\" and automatically re-execute when\n    necessary. If a reactive calculation is marked as invalidated, any other reactive\n    calculations that recently called it are also marked as invalidated. In this way,\n    invalidations ripple through reactive calculations that depend on each other.\n\n    Parameters\n    ----------\n    session\n        A :class:`~shiny.Session` instance. If not provided, it is inferred via\n        :func:`~shiny.session.get_current_session`.\n\n    Returns\n    -------\n    :\n        A decorator that marks a function as a reactive calculation.\n\n    Tip\n    ---\n    Reactive calculations should not produce any side effects; to reactively produce\n    side effects, use :func:`~shiny.reactive.Effect` instead.\n\n    See Also\n    --------\n    ~shiny.Inputs\n    ~shiny.reactive.Value\n    ~shiny.reactive.Effect\n    ~shiny.reactive.invalidate_later\n    ~shiny.reactive.event\n    \"\"\"\n\n    def create_calc(fn: CalcFunction[T] | CalcFunctionAsync[T]) -> Calc_[T]:\n        if _utils.is_async_callable(fn):\n            return CalcAsync_(fn, session=session)\n        else:\n            fn = cast(CalcFunction[T], fn)\n            return Calc_(fn, session=session)\n\n    if fn is None:\n        return create_calc\n    else:\n        return create_calc(fn)",
  "class Effect_:\n    \"\"\"\n    Mark a function as a reactive side effect.\n\n    Warning\n    -------\n    Most users shouldn't use this class directly to initialize a reactive side effect\n    (instead, use the :func:`Effect` decorator).\n    \"\"\"\n\n    def __init__(\n        self,\n        fn: EffectFunction | EffectFunctionAsync,\n        *,\n        suspended: bool = False,\n        priority: int = 0,\n        session: \"MISSING_TYPE | Session | None\" = MISSING,\n    ) -> None:\n        self.__name__ = fn.__name__\n        self.__doc__ = fn.__doc__\n\n        # The EffectAsync subclass will pass in an async function, but it tells the\n        # static type checker that it's synchronous. wrap_async() is smart -- if is\n        # passed an async function, it will not change it.\n        self._fn: EffectFunctionAsync = _utils.wrap_async(fn)\n        # This indicates whether the user's effect function (before wrapping) is async.\n        self._is_async: bool = _utils.is_async_callable(fn)\n\n        self._priority: int = priority\n        self._suspended = suspended\n        self._on_resume: Callable[[], None] = lambda: None\n\n        self._invalidate_callbacks: list[Callable[[], None]] = []\n        self._destroyed: bool = False\n        self._ctx: Optional[Context] = None\n        self._exec_count: int = 0\n\n        self._session: Optional[Session]\n        # Use `isinstance(x, MISSING_TYPE)`` instead of `x is MISSING` because\n        # the type checker doesn't know that MISSING is the only instance of\n        # MISSING_TYPE; this saves us from casting later on.\n        if isinstance(session, MISSING_TYPE):\n            from ..session import get_current_session\n\n            # If no session is provided, autodetect the current session (this\n            # could be None if outside of a session).\n            session = get_current_session()\n        self._session = session\n\n        if self._session is not None:\n            self._session.on_ended(self._on_session_ended_cb)\n\n        # Defer the first running of this until flushReact is called\n        self._create_context().invalidate()\n\n    def _create_context(self) -> Context:\n        ctx = Context()\n\n        # Store the context explicitly in Effect object\n        # TODO: More explanation here\n        self._ctx = ctx\n\n        def on_invalidate_cb() -> None:\n            # Context is invalidated, so we don't need to store a reference to it\n            # anymore.\n            self._ctx = None\n\n            for cb in self._invalidate_callbacks:\n                cb()\n\n            if self._destroyed:\n                return\n\n            def _continue() -> None:\n                ctx.add_pending_flush(self._priority)\n                if self._session:\n                    self._session._send_message_sync({\"busy\": \"busy\"})\n\n            if self._suspended:\n                self._on_resume = _continue\n            else:\n                _continue()\n\n        async def on_flush_cb() -> None:\n            if not self._destroyed:\n                await self._run()\n            if self._session:\n                self._session._send_message_sync({\"busy\": \"idle\"})\n\n        ctx.on_invalidate(on_invalidate_cb)\n        ctx.on_flush(on_flush_cb)\n\n        return ctx\n\n    async def _run(self) -> None:\n        ctx = self._create_context()\n        self._exec_count += 1\n\n        from ..session import session_context\n\n        with session_context(self._session):\n            try:\n                with ctx():\n                    await self._fn()\n            except SilentException:\n                # It's OK for SilentException to cause an Effect to stop running\n                pass\n            except Exception as e:\n                traceback.print_exc()\n\n                warnings.warn(\n                    \"Error in Effect: \" + str(e), ReactiveWarning, stacklevel=2\n                )\n                if self._session:\n                    await self._session._unhandled_error(e)\n\n    def on_invalidate(self, callback: Callable[[], None]) -> None:\n        \"\"\"\n        Register a callback that will be called when this reactive effect is\n        invalidated.\n\n        Parameters\n        ----------\n        callback\n            A callback that will be called when this reactive effect is invalidated.\n        \"\"\"\n        self._invalidate_callbacks.append(callback)\n\n    def destroy(self) -> None:\n        \"\"\"\n        Destroy this reactive effect.\n\n        Stops the observer from executing ever again, even if it is currently scheduled\n        for re-execution.\n        \"\"\"\n        self._destroyed = True\n\n        if self._ctx is not None:\n            self._ctx.invalidate()\n\n    def suspend(self) -> None:\n        \"\"\"\n        Suspend the effect.\n\n        Pauses scheduling of flushes (re-executions) in response to invalidations. If\n        the effect was invalidated prior to this call but it has not re-executed yet\n        (because it waits until on_flush is called) then that re-execution will still\n        occur, because the flush is already scheduled.\n        \"\"\"\n        self._suspended = True\n\n    def resume(self) -> None:\n        \"\"\"\n        Resume the effect.\n\n        Causes this effect to start re-executing in response to invalidations. If the\n        effect was invalidated while suspended, then it will schedule itself for\n        re-execution (pending flush).\n        \"\"\"\n        if self._suspended:\n            self._suspended = False\n            self._on_resume()\n            self._on_resume = lambda: None\n\n    def set_priority(self, priority: int = 0) -> None:\n        \"\"\"\n        Control the execution priority for this effect.\n\n        Parameters\n        ----------\n        priority\n            The new priority. A higher value means higher priority: an effect with a\n            higher priority value will execute before all effects with lower priority\n            values. Positive, negative, and zero values are allowed.\n\n        Note\n        ----\n        If the observer is currently invalidated, then the change in priority will not\n        take effect until the next invalidation--unless the observer is also currently\n        suspended, in which case the priority change will be effective upon resume.\n        \"\"\"\n        self._priority = priority\n\n    def _on_session_ended_cb(self) -> None:\n        self.destroy()",
  "def Effect(fn: EffectFunction | EffectFunctionAsync) -> Effect_:\n    ...",
  "def Effect(\n    *,\n    suspended: bool = False,\n    priority: int = 0,\n    session: \"MISSING_TYPE | Session | None\" = MISSING,\n) -> Callable[[EffectFunction | EffectFunctionAsync], Effect_]:\n    ...",
  "def Effect(\n    fn: Optional[EffectFunction | EffectFunctionAsync] = None,\n    *,\n    suspended: bool = False,\n    priority: int = 0,\n    session: \"MISSING_TYPE | Session | None\" = MISSING,\n) -> Effect_ | Callable[[EffectFunction | EffectFunctionAsync], Effect_]:\n    \"\"\"\n    Mark a function as a reactive side effect.\n\n    A reactive effect is like a reactive calculation (:func:`~shiny.reactive.Calc`) in\n    that it can read reactive values and call reactive calculations, and will\n    automatically re-execute when those dependencies change. But unlike reactive\n    calculations, it doesn't return a result and can't be used as an input to other\n    reactive expressions. Thus, observers are only useful for their side effects (for\n    example, performing I/O).\n\n    Another contrast between reactive calculations and effects is their execution\n    strategy. Reactive calculations use lazy evaluation; that is, when their\n    dependencies change, they don't re-execute right away but rather wait until they are\n    called by someone else. Indeed, if they are not called then they will never\n    re-execute. In contrast, effects use eager evaluation; as soon as their dependencies\n    change, they schedule themselves to re-execute.\n\n    Parameters\n    ----------\n    suspended\n        If ``TRUE``, start the effect in a suspended state (i.e., it will not execute\n        until resumed and invalidated).\n    priority\n        The new priority. A higher value means higher priority: an effect with a higher\n        priority value will execute before all effects with lower priority values.\n        Positive, negative, and zero values are allowed.\n    session\n        A :class:`~shiny.Session` instance. If not provided, it is inferred via\n        :func:`~shiny.session.get_current_session`.\n\n    Returns\n    -------\n    :\n        A decorator that marks a function as a reactive effect (:class:`Effect_`).\n\n    See Also\n    --------\n    ~shiny.Inputs\n    ~shiny.reactive.Value\n    ~shiny.reactive.Effect\n    ~shiny.reactive.invalidate_later\n    ~shiny.reactive.event\n    \"\"\"\n\n    def create_effect(fn: EffectFunction | EffectFunctionAsync) -> Effect_:\n        fn = cast(EffectFunction, fn)\n        return Effect_(fn, suspended=suspended, priority=priority, session=session)\n\n    if fn is None:\n        return create_effect\n    else:\n        return create_effect(fn)",
  "def event(\n    *args: Callable[[], object] | Callable[[], Awaitable[object]],\n    ignore_none: bool = True,\n    ignore_init: bool = False,\n) -> Callable[[Callable[[], T]], Callable[[], T]]:\n    \"\"\"\n    Mark a function to react only when an \"event\" occurs.\n\n    Shiny's reactive programming framework is primarily designed for calculated values\n    (:func:`~shiny.reactive.Calc`) and side-effect-causing actions\n    (:func:`~shiny.reactive.Effect`) that respond to **any** of their inputs changing.\n    That's often what is desired in Shiny apps, but not always: sometimes you want to\n    wait for a specific action to be taken from the user, like clicking an\n    :func:`~shiny.ui.input_action_button`, before calculating or taking an action. A\n    reactive value (or function) which triggers other calculation or action in this way\n    is called an event.\n\n    These situations demand a more imperative, \"event handling\" style of programming,\n    which ``@reactive.event()`` provides. It does this by using the\n    :func:`~shiny.reactive.isolate` primitive under-the-hood to essentially \"limit\" the\n    set of reactive dependencies to those in ``args``.\n\n    Parameters\n    ----------\n    args\n        One or more callables that represent the event; most likely this will be a\n        reactive input value linked to a :func:`~shiny.ui.input_action_button` or\n        similar (e.g., ``input.click``), but it can also be a (reactive or non-reactive)\n        function that returns a value.\n    ignore_none\n        Whether to ignore the event if the value is ``None`` or ``0``.\n    ignore_init\n        If ``False``, the event trigger on the first run.\n\n    Returns\n    -------\n    :\n        A decorator that marks a function as an event handler.\n\n    Tip\n    ----\n    This decorator must be applied before the relevant reactivity decorator (i.e.,\n    ``@reactive.event`` must be applied before ``@reactive.Effect``, ``@reactive.Calc``,\n    ``@render.ui``, etc).\n    \"\"\"\n\n    if any([not callable(arg) for arg in args]):\n        raise TypeError(\n            \"All objects passed to event decorator must be callable.\\n\"\n            + \"If you are calling `@reactive.event(f())`, try calling `@reactive.event(f)` instead.\"\n        )\n\n    if len(args) == 0:\n        raise TypeError(\n            \"`@reactive.event()` requires at least one argument, as in `@reactive.event(input.x)`.\\n\"\n        )\n\n    def decorator(user_fn: Callable[[], T]) -> Callable[[], T]:\n        if not callable(user_fn):\n            raise TypeError(\n                \"`@reactive.event()` must be applied to a function or Callable object.\\n\"\n                + \"It should usually be applied before `@Calc`,` @Effect`, `@output`, or `@render.xx` function.\\n\"\n                + \"In other words, `@reactive.event()` goes below the other decorators.\"\n            )\n\n        if isinstance(user_fn, Calc_):\n            raise TypeError(\n                \"`@reactive.event()` must be applied before `@reactive.Calc`.\\n\"\n                + \"In other words, `@reactive.Calc` must be above `@reactive.event()`.\"\n            )\n\n        if isinstance(user_fn, OutputRenderer):\n            # At some point in the future, we may allow this condition, if we find an\n            # use case. For now we'll disallow it, for simplicity.\n            raise TypeError(\n                \"`@reactive.event()` must be applied before `@render.xx` .\\n\"\n                + \"In other words, `@render.xx` must be above `@reactive.event()`.\"\n            )\n\n        initialized = False\n\n        async def trigger() -> None:\n            vals: list[object] = []\n            for arg in args:\n                if is_async_callable(arg):\n                    v = await arg()\n                else:\n                    v = arg()\n                vals.append(v)\n\n            nonlocal initialized\n            if ignore_init and not initialized:\n                initialized = True\n                req(False)\n            if ignore_none and all(map(_is_none_event, vals)):\n                req(False)\n\n        if is_async_callable(user_fn):\n\n            @functools.wraps(user_fn)\n            # Impossible to specify a return type here; we know T is\n            # Awaitable[something] but I don't think there's a way to refer to the\n            # `something`\n            async def new_user_async_fn():\n                await trigger()\n                with isolate():\n                    return await user_fn()\n\n            return new_user_async_fn  # type: ignore\n\n        elif any([is_async_callable(arg) for arg in args]):\n            raise TypeError(\n                \"When decorating a synchronous function with @reactive.event(), all\"\n                + \"arguments to @reactive.event() must be synchronous functions.\"\n            )\n\n        else:\n\n            @functools.wraps(user_fn)\n            def new_user_fn() -> T:\n                run_coro_sync(trigger())\n                with isolate():\n                    return user_fn()\n\n            return new_user_fn\n\n    return decorator",
  "def _is_none_event(val: object) -> bool:\n    return val is None or (isinstance(val, ActionButtonValue) and val == 0)",
  "def __init__(\n        self, value: MISSING_TYPE = MISSING, *, read_only: bool = False\n    ) -> None:\n        ...",
  "def __init__(self, value: T, *, read_only: bool = False) -> None:\n        ...",
  "def __init__(\n        self, value: T | MISSING_TYPE = MISSING, *, read_only: bool = False\n    ) -> None:\n        self._value: T | MISSING_TYPE = value\n        self._read_only: bool = read_only\n        self._value_dependents: Dependents = Dependents()\n        self._is_set_dependents: Dependents = Dependents()",
  "def __call__(self) -> T:\n        return self.get()",
  "def get(self) -> T:\n        \"\"\"\n        Read the reactive value.\n\n        Returns\n        -------\n        :\n            A value.\n\n        Raises\n        ------\n        ~shiny.types.SilentException\n            If the value is not set.\n        RuntimeError\n            If called from outside a reactive function.\n        \"\"\"\n\n        self._value_dependents.register()\n\n        if isinstance(self._value, MISSING_TYPE):\n            raise SilentException\n\n        return self._value",
  "def set(self, value: T) -> bool:\n        \"\"\"\n        Set the reactive value to a new value.\n\n        Parameters\n        ----------\n        value\n            A value.\n\n        Returns\n        -------\n        :\n            ``True`` if the value was set to a different value and ``False`` otherwise.\n\n        Raises\n        ------\n        RuntimeError\n            If called on a read-only reactive value.\n        \"\"\"\n        if self._read_only:\n            raise RuntimeError(\n                \"Can't set read-only Value. If you are trying to set an input value, use `update_xxx()` instead.\"\n            )\n        return self._set(value)",
  "def _set(self, value: T) -> bool:\n        if self._value is value:\n            return False\n\n        if isinstance(self._value, MISSING_TYPE) != isinstance(value, MISSING_TYPE):\n            self._is_set_dependents.invalidate()\n\n        self._value = value\n        self._value_dependents.invalidate()\n        return True",
  "def unset(self) -> None:\n        \"\"\"\n        Unset the reactive value.\n\n        Returns\n        -------\n        :\n            ``True`` if the value was set prior to this unsetting.\n        \"\"\"\n        self.set(MISSING)",
  "def is_set(self) -> bool:\n        \"\"\"\n        Check if the reactive value is set.\n\n        Returns\n        -------\n        :\n            ``True`` if the value is set, ``False`` otherwise.\n        \"\"\"\n\n        self._is_set_dependents.register()\n        return not isinstance(self._value, MISSING_TYPE)",
  "def freeze(self) -> None:\n        \"\"\"\n        Freeze the reactive value.\n\n        Freezing is equivalent to unsetting the value, but it does not invalidate\n        dependents.\n        \"\"\"\n        self._value = MISSING",
  "def __init__(\n        self,\n        fn: CalcFunction[T],\n        *,\n        session: \"MISSING_TYPE | Session | None\" = MISSING,\n    ) -> None:\n        self.__name__ = fn.__name__\n        self.__doc__ = fn.__doc__\n\n        # The CalcAsync subclass will pass in an async function, but it tells the\n        # static type checker that it's synchronous. wrap_async() is smart -- if is\n        # passed an async function, it will not change it.\n        self._fn: CalcFunctionAsync[T] = _utils.wrap_async(fn)\n        self._is_async: bool = _utils.is_async_callable(fn)\n\n        self._dependents: Dependents = Dependents()\n        self._invalidated: bool = True\n        self._running: bool = False\n        self._most_recent_ctx_id: int = -1\n        self._ctx: Optional[Context] = None\n        self._exec_count: int = 0\n\n        self._session: Optional[Session]\n        # Use `isinstance(x, MISSING_TYPE)`` instead of `x is MISSING` because\n        # the type checker doesn't know that MISSING is the only instance of\n        # MISSING_TYPE; this saves us from casting later on.\n        if isinstance(session, MISSING_TYPE):\n            from ..session import get_current_session\n\n            # If no session is provided, autodetect the current session (this\n            # could be None if outside of a session).\n            session = get_current_session()\n        self._session = session\n\n        # Use lists to hold (optional) value and error, instead of Optional[T],\n        # because it makes typing more straightforward. For example if\n        # .get_value() simply returned self._value, self._value had type\n        # Optional[T], then the return type for get_value() would have to be\n        # Optional[T].\n        self._value: list[T] = []\n        self._error: list[Exception] = []",
  "def __call__(self) -> T:\n        # Run the Coroutine (synchronously), and then return the value.\n        # If the Coroutine yields control, then an error will be raised.\n        return _utils.run_coro_sync(self.get_value())",
  "async def get_value(self) -> T:\n        self._dependents.register()\n\n        if self._invalidated or self._running:\n            await self.update_value()\n\n        if self._error:\n            raise self._error[0]\n\n        return self._value[0]",
  "async def update_value(self) -> None:\n        self._ctx = Context()\n        self._most_recent_ctx_id = self._ctx.id\n\n        self._ctx.on_invalidate(self._on_invalidate_cb)\n\n        self._exec_count += 1\n        self._invalidated = False\n\n        was_running = self._running\n        self._running = True\n\n        from ..session import session_context\n\n        with session_context(self._session):\n            try:\n                with self._ctx():\n                    await self._run_func()\n            finally:\n                self._running = was_running",
  "def _on_invalidate_cb(self) -> None:\n        self._invalidated = True\n        self._value.clear()  # Allow old value to be GC'd\n        self._dependents.invalidate()\n        self._ctx = None",
  "async def _run_func(self) -> None:\n        self._error.clear()\n        try:\n            self._value.append(await self._fn())\n        except Exception as err:\n            self._error.append(err)",
  "def __init__(\n        self,\n        fn: CalcFunctionAsync[T],\n        *,\n        session: \"MISSING_TYPE | Session | None\" = MISSING,\n    ) -> None:\n        if not _utils.is_async_callable(fn):\n            raise TypeError(self.__class__.__name__ + \" requires an async function\")\n\n        super().__init__(cast(CalcFunction[T], fn), session=session)",
  "async def __call__(self) -> T:  # pyright: ignore[reportIncompatibleMethodOverride]\n        return await self.get_value()",
  "def create_calc(fn: CalcFunction[T] | CalcFunctionAsync[T]) -> Calc_[T]:\n        if _utils.is_async_callable(fn):\n            return CalcAsync_(fn, session=session)\n        else:\n            fn = cast(CalcFunction[T], fn)\n            return Calc_(fn, session=session)",
  "def __init__(\n        self,\n        fn: EffectFunction | EffectFunctionAsync,\n        *,\n        suspended: bool = False,\n        priority: int = 0,\n        session: \"MISSING_TYPE | Session | None\" = MISSING,\n    ) -> None:\n        self.__name__ = fn.__name__\n        self.__doc__ = fn.__doc__\n\n        # The EffectAsync subclass will pass in an async function, but it tells the\n        # static type checker that it's synchronous. wrap_async() is smart -- if is\n        # passed an async function, it will not change it.\n        self._fn: EffectFunctionAsync = _utils.wrap_async(fn)\n        # This indicates whether the user's effect function (before wrapping) is async.\n        self._is_async: bool = _utils.is_async_callable(fn)\n\n        self._priority: int = priority\n        self._suspended = suspended\n        self._on_resume: Callable[[], None] = lambda: None\n\n        self._invalidate_callbacks: list[Callable[[], None]] = []\n        self._destroyed: bool = False\n        self._ctx: Optional[Context] = None\n        self._exec_count: int = 0\n\n        self._session: Optional[Session]\n        # Use `isinstance(x, MISSING_TYPE)`` instead of `x is MISSING` because\n        # the type checker doesn't know that MISSING is the only instance of\n        # MISSING_TYPE; this saves us from casting later on.\n        if isinstance(session, MISSING_TYPE):\n            from ..session import get_current_session\n\n            # If no session is provided, autodetect the current session (this\n            # could be None if outside of a session).\n            session = get_current_session()\n        self._session = session\n\n        if self._session is not None:\n            self._session.on_ended(self._on_session_ended_cb)\n\n        # Defer the first running of this until flushReact is called\n        self._create_context().invalidate()",
  "def _create_context(self) -> Context:\n        ctx = Context()\n\n        # Store the context explicitly in Effect object\n        # TODO: More explanation here\n        self._ctx = ctx\n\n        def on_invalidate_cb() -> None:\n            # Context is invalidated, so we don't need to store a reference to it\n            # anymore.\n            self._ctx = None\n\n            for cb in self._invalidate_callbacks:\n                cb()\n\n            if self._destroyed:\n                return\n\n            def _continue() -> None:\n                ctx.add_pending_flush(self._priority)\n                if self._session:\n                    self._session._send_message_sync({\"busy\": \"busy\"})\n\n            if self._suspended:\n                self._on_resume = _continue\n            else:\n                _continue()\n\n        async def on_flush_cb() -> None:\n            if not self._destroyed:\n                await self._run()\n            if self._session:\n                self._session._send_message_sync({\"busy\": \"idle\"})\n\n        ctx.on_invalidate(on_invalidate_cb)\n        ctx.on_flush(on_flush_cb)\n\n        return ctx",
  "async def _run(self) -> None:\n        ctx = self._create_context()\n        self._exec_count += 1\n\n        from ..session import session_context\n\n        with session_context(self._session):\n            try:\n                with ctx():\n                    await self._fn()\n            except SilentException:\n                # It's OK for SilentException to cause an Effect to stop running\n                pass\n            except Exception as e:\n                traceback.print_exc()\n\n                warnings.warn(\n                    \"Error in Effect: \" + str(e), ReactiveWarning, stacklevel=2\n                )\n                if self._session:\n                    await self._session._unhandled_error(e)",
  "def on_invalidate(self, callback: Callable[[], None]) -> None:\n        \"\"\"\n        Register a callback that will be called when this reactive effect is\n        invalidated.\n\n        Parameters\n        ----------\n        callback\n            A callback that will be called when this reactive effect is invalidated.\n        \"\"\"\n        self._invalidate_callbacks.append(callback)",
  "def destroy(self) -> None:\n        \"\"\"\n        Destroy this reactive effect.\n\n        Stops the observer from executing ever again, even if it is currently scheduled\n        for re-execution.\n        \"\"\"\n        self._destroyed = True\n\n        if self._ctx is not None:\n            self._ctx.invalidate()",
  "def suspend(self) -> None:\n        \"\"\"\n        Suspend the effect.\n\n        Pauses scheduling of flushes (re-executions) in response to invalidations. If\n        the effect was invalidated prior to this call but it has not re-executed yet\n        (because it waits until on_flush is called) then that re-execution will still\n        occur, because the flush is already scheduled.\n        \"\"\"\n        self._suspended = True",
  "def resume(self) -> None:\n        \"\"\"\n        Resume the effect.\n\n        Causes this effect to start re-executing in response to invalidations. If the\n        effect was invalidated while suspended, then it will schedule itself for\n        re-execution (pending flush).\n        \"\"\"\n        if self._suspended:\n            self._suspended = False\n            self._on_resume()\n            self._on_resume = lambda: None",
  "def set_priority(self, priority: int = 0) -> None:\n        \"\"\"\n        Control the execution priority for this effect.\n\n        Parameters\n        ----------\n        priority\n            The new priority. A higher value means higher priority: an effect with a\n            higher priority value will execute before all effects with lower priority\n            values. Positive, negative, and zero values are allowed.\n\n        Note\n        ----\n        If the observer is currently invalidated, then the change in priority will not\n        take effect until the next invalidation--unless the observer is also currently\n        suspended, in which case the priority change will be effective upon resume.\n        \"\"\"\n        self._priority = priority",
  "def _on_session_ended_cb(self) -> None:\n        self.destroy()",
  "def create_effect(fn: EffectFunction | EffectFunctionAsync) -> Effect_:\n        fn = cast(EffectFunction, fn)\n        return Effect_(fn, suspended=suspended, priority=priority, session=session)",
  "def decorator(user_fn: Callable[[], T]) -> Callable[[], T]:\n        if not callable(user_fn):\n            raise TypeError(\n                \"`@reactive.event()` must be applied to a function or Callable object.\\n\"\n                + \"It should usually be applied before `@Calc`,` @Effect`, `@output`, or `@render.xx` function.\\n\"\n                + \"In other words, `@reactive.event()` goes below the other decorators.\"\n            )\n\n        if isinstance(user_fn, Calc_):\n            raise TypeError(\n                \"`@reactive.event()` must be applied before `@reactive.Calc`.\\n\"\n                + \"In other words, `@reactive.Calc` must be above `@reactive.event()`.\"\n            )\n\n        if isinstance(user_fn, OutputRenderer):\n            # At some point in the future, we may allow this condition, if we find an\n            # use case. For now we'll disallow it, for simplicity.\n            raise TypeError(\n                \"`@reactive.event()` must be applied before `@render.xx` .\\n\"\n                + \"In other words, `@render.xx` must be above `@reactive.event()`.\"\n            )\n\n        initialized = False\n\n        async def trigger() -> None:\n            vals: list[object] = []\n            for arg in args:\n                if is_async_callable(arg):\n                    v = await arg()\n                else:\n                    v = arg()\n                vals.append(v)\n\n            nonlocal initialized\n            if ignore_init and not initialized:\n                initialized = True\n                req(False)\n            if ignore_none and all(map(_is_none_event, vals)):\n                req(False)\n\n        if is_async_callable(user_fn):\n\n            @functools.wraps(user_fn)\n            # Impossible to specify a return type here; we know T is\n            # Awaitable[something] but I don't think there's a way to refer to the\n            # `something`\n            async def new_user_async_fn():\n                await trigger()\n                with isolate():\n                    return await user_fn()\n\n            return new_user_async_fn  # type: ignore\n\n        elif any([is_async_callable(arg) for arg in args]):\n            raise TypeError(\n                \"When decorating a synchronous function with @reactive.event(), all\"\n                + \"arguments to @reactive.event() must be synchronous functions.\"\n            )\n\n        else:\n\n            @functools.wraps(user_fn)\n            def new_user_fn() -> T:\n                run_coro_sync(trigger())\n                with isolate():\n                    return user_fn()\n\n            return new_user_fn",
  "def on_invalidate_cb() -> None:\n            # Context is invalidated, so we don't need to store a reference to it\n            # anymore.\n            self._ctx = None\n\n            for cb in self._invalidate_callbacks:\n                cb()\n\n            if self._destroyed:\n                return\n\n            def _continue() -> None:\n                ctx.add_pending_flush(self._priority)\n                if self._session:\n                    self._session._send_message_sync({\"busy\": \"busy\"})\n\n            if self._suspended:\n                self._on_resume = _continue\n            else:\n                _continue()",
  "async def on_flush_cb() -> None:\n            if not self._destroyed:\n                await self._run()\n            if self._session:\n                self._session._send_message_sync({\"busy\": \"idle\"})",
  "async def trigger() -> None:\n            vals: list[object] = []\n            for arg in args:\n                if is_async_callable(arg):\n                    v = await arg()\n                else:\n                    v = arg()\n                vals.append(v)\n\n            nonlocal initialized\n            if ignore_init and not initialized:\n                initialized = True\n                req(False)\n            if ignore_none and all(map(_is_none_event, vals)):\n                req(False)",
  "def _continue() -> None:\n                ctx.add_pending_flush(self._priority)\n                if self._session:\n                    self._session._send_message_sync({\"busy\": \"busy\"})",
  "async def new_user_async_fn():\n                await trigger()\n                with isolate():\n                    return await user_fn()",
  "def new_user_fn() -> T:\n                run_coro_sync(trigger())\n                with isolate():\n                    return user_fn()",
  "class ClickOpts(TypedDict):\n    id: NotRequired[str]\n    clip: bool",
  "class DblClickOpts(TypedDict):\n    id: NotRequired[str]\n    clip: bool\n    delay: int",
  "class HoverOpts(TypedDict):\n    id: NotRequired[str]\n    delay: int\n    delayType: Literal[\"debounce\", \"throttle\"]\n    clip: bool\n    nullOutside: bool",
  "class BrushOpts(TypedDict):\n    id: NotRequired[str]\n    fill: str\n    stroke: str\n    opacity: float\n    delay: int\n    delayType: Literal[\"debounce\", \"throttle\"]\n    clip: bool\n    direction: str\n    resetOnNew: bool",
  "def format_opt_names(\n    opts: ClickOpts | DblClickOpts | HoverOpts | BrushOpts,\n    prefix: str,\n) -> dict[str, str]:\n    new_opts: dict[str, str] = dict()\n    for key, value in opts.items():\n        new_key = f\"data-{prefix}-\" + re.sub(\"([A-Z])\", \"-\\\\1\", key).lower()\n        new_value = str(value)\n\n        if isinstance(value, bool):\n            new_value = new_value.lower()\n\n        new_opts[new_key] = new_value\n\n    return new_opts",
  "def click_opts(\n    *,\n    clip: bool = True,\n) -> ClickOpts:\n    return {\n        \"clip\": clip,\n    }",
  "def dblclick_opts(\n    *,\n    delay: int = 400,\n    clip: bool = True,\n) -> DblClickOpts:\n    return {\n        \"delay\": delay,\n        \"clip\": clip,\n    }",
  "def hover_opts(\n    *,\n    delay: int = 300,\n    delay_type: Literal[\"debounce\", \"throttle\"] = \"debounce\",\n    clip: bool = True,\n    null_outside: bool = True,\n) -> HoverOpts:\n    return {\n        \"delay\": delay,\n        \"delayType\": delay_type,\n        \"clip\": clip,\n        \"nullOutside\": null_outside,\n    }",
  "def brush_opts(\n    *,\n    fill: str = \"#9cf\",\n    stroke: str = \"#036\",\n    opacity: float = 0.25,\n    delay: int = 300,\n    delay_type: Literal[\"debounce\", \"throttle\"] = \"debounce\",\n    clip: bool = True,\n    direction: str = \"xy\",\n    reset_on_new: bool = False,\n) -> BrushOpts:\n    return {\n        \"fill\": fill,\n        \"stroke\": stroke,\n        \"opacity\": opacity,\n        \"delay\": delay,\n        \"delayType\": delay_type,\n        \"clip\": clip,\n        \"direction\": direction,\n        \"resetOnNew\": reset_on_new,\n    }",
  "def input_password(\n    id: str,\n    label: TagChild,\n    value: str = \"\",\n    *,\n    width: Optional[str] = None,\n    placeholder: Optional[str] = None,\n) -> Tag:\n    \"\"\"\n    Create an password control for entry of passwords.\n\n    Parameters\n    ----------\n    id\n        An input id.\n    label\n        An input label.\n    value\n        Initial value.\n    width\n        The CSS width, e.g. '400px', or '100%'\n    placeholder\n        The placeholder of the input.\n\n    Returns\n    -------\n    :\n        A UI element.\n\n    Notes\n    ------\n    ::: {.callout-note title=\"Server value\"}\n    A string of the password input. The default value is unless value is provided.\n    :::\n\n    See Also\n    -------\n    ~shiny.ui.update_text\n    \"\"\"\n    resolved_id = resolve_id(id)\n    return div(\n        shiny_input_label(resolved_id, label),\n        tags.input(\n            id=resolved_id,\n            type=\"password\",\n            value=value,\n            class_=\"shiny-input-password form-control\",\n            placeholder=placeholder,\n        ),\n        class_=\"form-group shiny-input-container\",\n        style=css(width=width),\n    )",
  "def input_text(\n    id: str,\n    label: TagChild,\n    value: str = \"\",\n    *,\n    width: Optional[str] = None,\n    placeholder: Optional[str] = None,\n    autocomplete: Optional[str] = \"off\",\n    spellcheck: Optional[Literal[\"true\", \"false\"]] = None,\n) -> Tag:\n    \"\"\"\n    Create an input control for entry of text values\n\n    Parameters\n    ----------\n    id\n        An input id.\n    label\n        An input label.\n    value\n        Initial value.\n    width\n        The CSS width, e.g. '400px', or '100%'\n    placeholder\n        A hint as to what can be entered into the control.\n    autocomplete\n        Whether to enable browser autocompletion of the text input (default is None).\n        If None, then it will use the browser's default behavior. Other possible values\n        include \"on\", \"off\", \"name\", \"username\", and \"email\". See\n        https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/autocomplete for\n        more.\n    spellcheck\n        Whether to enable browser spell checking of the text input (default is None). If\n        None, then it will use the browser's default behavior.\n\n    Returns\n    -------\n    :\n        A UI element\n\n    Notes\n    ------\n    ::: {.callout-note title=\"Server value\"}\n    A string containing the current text input. The default value is ``\"\"`` unless\n    ``value`` is provided.\n    :::\n\n    See Also\n    -------\n    ~shiny.ui.input_text_area\n    \"\"\"\n\n    resolved_id = resolve_id(id)\n    return div(\n        shiny_input_label(resolved_id, label),\n        tags.input(\n            id=resolved_id,\n            type=\"text\",\n            class_=\"shiny-input-text form-control\",\n            value=value,\n            placeholder=placeholder,\n            autocomplete=autocomplete,\n            spellcheck=spellcheck,\n        ),\n        class_=\"form-group shiny-input-container\",\n        style=css(width=width),\n    )",
  "def input_text_area(\n    id: str,\n    label: TagChild,\n    value: str = \"\",\n    *,\n    width: Optional[str] = None,\n    height: Optional[str] = None,\n    cols: Optional[int] = None,\n    rows: Optional[int] = None,\n    placeholder: Optional[str] = None,\n    resize: Optional[Literal[\"none\", \"both\", \"horizontal\", \"vertical\"]] = None,\n    autocomplete: Optional[str] = None,\n    spellcheck: Optional[Literal[\"true\", \"false\"]] = None,\n) -> Tag:\n    \"\"\"\n    Create a textarea input control for entry of unstructured text values.\n\n    Parameters\n    ----------\n    id\n        An input id.\n    label\n        An input label.\n    value\n        Initial value.\n    width\n        The CSS width, e.g. '400px', or '100%'\n    height\n        The CSS height, e.g. '400px', or '100%'\n    cols\n        Value of the visible character columns of the input, e.g. 80. This argument will\n        only take effect if there is not a CSS width rule defined for this element; such\n        a rule could come from the width argument of this function or from a containing\n        page layout such as :func:`~shiny.ui.page_fluid`.\n    rows\n        The value of the visible character rows of the input, e.g. 6. If the height\n        argument is specified, height will take precedence in the browser's rendering.\n    placeholder\n        A hint as to what can be entered into the control.\n    resize\n        Which directions the textarea box can be resized. Can be one of \"both\", \"none\",\n        \"vertical\", and \"horizontal\". The default, ``None``, will use the client\n        browser's default setting for resizing textareas.\n    autocomplete\n        Whether to enable browser autocompletion of the text input (default is \"off\").\n        If None, then it will use the browser's default behavior. Other possible values\n        include \"on\", \"name\", \"username\", and \"email\". See\n        https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/autocomplete for\n        more.\n    spellcheck\n        Whether to enable browser spell checking of the text input (default is None). If\n        None, then it will use the browser's default behavior.\n\n    Returns\n    -------\n    :\n        A UI element\n\n    Notes\n    ------\n    ::: {.callout-note title=\"Server value\"}\n    A string containing the current text input. The default value is ``\"\"`` unless\n    ``value`` is provided.\n    :::\n\n    See Also\n    -------\n    ~shiny.ui.input_text\n    \"\"\"\n\n    if resize and resize not in [\"none\", \"both\", \"horizontal\", \"vertical\"]:\n        raise ValueError(\"Invalid resize value: \" + str(resize))\n\n    resolved_id = resolve_id(id)\n    area = tags.textarea(\n        value,\n        id=resolved_id,\n        class_=\"form-control\",\n        style=css(width=None if width else \"100%\", height=height, resize=resize),\n        placeholder=placeholder,\n        rows=rows,\n        cols=cols,\n        autocomplete=autocomplete,\n        spellcheck=spellcheck,\n    )\n\n    return div(\n        shiny_input_label(resolved_id, label),\n        area,\n        class_=\"shiny-input-textarea form-group shiny-input-container\",\n        style=css(width=width),\n    )",
  "def input_date(\n    id: str,\n    label: TagChild,\n    *,\n    value: Optional[date | str] = None,\n    min: Optional[date | str] = None,\n    max: Optional[date | str] = None,\n    format: str = \"yyyy-mm-dd\",\n    startview: str = \"month\",\n    weekstart: int = 0,\n    language: str = \"en\",\n    width: Optional[str] = None,\n    autoclose: bool = True,\n    datesdisabled: Optional[list[str]] = None,\n    daysofweekdisabled: Optional[list[int]] = None,\n) -> Tag:\n    \"\"\"\n    Creates a text input which, when clicked on, brings up a calendar that the user can\n    click on to select dates.\n\n    Parameters\n    ----------\n    id\n        An input id.\n    label\n        An input label.\n    value\n        The starting date. Either a :class:`~datetime.date` object, or a string in\n        `yyyy-mm-dd` format. If None (the default), will use the current date in the\n        client's time zone.\n    min\n        The minimum allowed date. Either a :class:`~datetime.date` object, or a string in\n        yyyy-mm-dd format.\n    max\n        The maximum allowed date. Either a :class:`~datetime.date` object, or a string in\n        yyyy-mm-dd format.\n    format\n        The format of the date to display in the browser. Defaults to `\"yyyy-mm-dd\"`.\n    startview\n        The date range shown when the input object is first clicked. Can be \"month\" (the\n        default), \"year\", or \"decade\".\n    weekstart\n        Which day is the start of the week. Should be an integer from 0 (Sunday) to 6\n        (Saturday).\n    language\n        The language used for month and day names. Default is \"en\". Other valid values\n        include \"ar\", \"az\", \"bg\", \"bs\", \"ca\", \"cs\", \"cy\", \"da\", \"de\", \"el\", \"en-AU\",\n        \"en-GB\", \"eo\", \"es\", \"et\", \"eu\", \"fa\", \"fi\", \"fo\", \"fr-CH\", \"fr\", \"gl\", \"he\",\n        \"hr\", \"hu\", \"hy\", \"id\", \"is\", \"it-CH\", \"it\", \"ja\", \"ka\", \"kh\", \"kk\", \"ko\", \"kr\",\n        \"lt\", \"lv\", \"me\", \"mk\", \"mn\", \"ms\", \"nb\", \"nl-BE\", \"nl\", \"no\", \"pl\", \"pt-BR\",\n        \"pt\", \"ro\", \"rs-latin\", \"rs\", \"ru\", \"sk\", \"sl\", \"sq\", \"sr-latin\", \"sr\", \"sv\",\n        \"sw\", \"th\", \"tr\", \"uk\", \"vi\", \"zh-CN\", and \"zh-TW\".\n    width\n        The CSS width, e.g. '400px', or '100%'\n    autoclose\n        Whether or not to close the datepicker immediately when a date is selected.\n    datesdisabled\n        Which dates should be disabled (in `yyyy-mm-dd` format).\n    daysofweekdisabled\n        Days of the week that should be disabled. Should be a integer vector with values\n        from 0 (Sunday) to 6 (Saturday).\n\n    Returns\n    -------\n    :\n        A UI element.\n\n    Note\n    ----\n    The date ``format`` string specifies how the date will be displayed in the browser.\n    It allows the following values:\n\n    - ``yy``: Year without century (12)\n    - ``yyyy``: Year with century (2012)\n    - ``mm``: Month number, with leading zero (01-12)\n    - ``m``: Month number, without leading zero (1-12)\n    - ``M``: Abbreviated month name\n    - ``MM``: Full month name\n    - ``dd``: Day of month with leading zero\n    - ``d``: Day of month without leading zero\n    - ``D``: Abbreviated weekday name\n    - ``DD``: Full weekday name\n\n    Notes\n    ------\n    ::: {.callout-note title=\"Server value\"}\n    A :class:`~datetime.date` object.\n    :::\n\n    See Also\n    -------\n    ~shiny.ui.update_date\n    ~shiny.ui.input_date_range\n    \"\"\"\n\n    resolved_id = resolve_id(id)\n    return div(\n        shiny_input_label(resolved_id, label),\n        _date_input_tag(\n            id=resolved_id,\n            value=value,\n            min=min,\n            max=max,\n            format=format,\n            startview=startview,\n            weekstart=weekstart,\n            language=language,\n            autoclose=autoclose,\n            data_date_dates_disabled=json.dumps(datesdisabled),\n            data_date_days_of_week_disabled=json.dumps(daysofweekdisabled),\n        ),\n        id=resolved_id,\n        class_=\"shiny-date-input form-group shiny-input-container\",\n        style=css(width=width),\n    )",
  "def input_date_range(\n    id: str,\n    label: TagChild,\n    *,\n    start: Optional[date | str] = None,\n    end: Optional[date | str] = None,\n    min: Optional[date | str] = None,\n    max: Optional[date | str] = None,\n    format: str = \"yyyy-mm-dd\",\n    startview: str = \"month\",\n    weekstart: int = 0,\n    language: str = \"en\",\n    separator: str = \" to \",\n    width: Optional[str] = None,\n    autoclose: bool = True,\n) -> Tag:\n    \"\"\"\n    Creates a pair of text inputs which, when clicked on, bring up calendars that the\n    user can click on to select dates.\n\n    Parameters\n    ----------\n    id\n        An input id.\n    label\n        An input label.\n    start\n        The initial start date. Either a :class:`~datetime.date` object, or a string in\n        yyyy-mm-dd format. If ``None`` (the default), will use the current date in the\n        client's time zone.\n    end\n        The initial end date. Either a :class:`~datetime.date` object, or a string in\n        yyyy-mm-dd format. If ``None`` (the default), will use the current date in the\n        client's time zone.\n    min\n        The minimum allowed date. Either a :class:`~datetime.date` object, or a string in\n        yyyy-mm-dd format.\n    max\n        The maximum allowed date. Either a :class:`~datetime.date` object, or a string in\n        yyyy-mm-dd format.\n    format\n        The format of the date to display in the browser.\n    startview\n        The date range shown when the input object is first clicked. Can be \"month\" (the\n        default), \"year\", or \"decade\".\n    weekstart\n        Which day is the start of the week. Should be an integer from 0 (Sunday) to 6\n        (Saturday).\n    language\n        The language used for month and day names. Default is \"en\". Other valid values\n        include \"ar\", \"az\", \"bg\", \"bs\", \"ca\", \"cs\", \"cy\", \"da\", \"de\", \"el\", \"en-AU\",\n        \"en-GB\", \"eo\", \"es\", \"et\", \"eu\", \"fa\", \"fi\", \"fo\", \"fr-CH\", \"fr\", \"gl\", \"he\",\n        \"hr\", \"hu\", \"hy\", \"id\", \"is\", \"it-CH\", \"it\", \"ja\", \"ka\", \"kh\", \"kk\", \"ko\", \"kr\",\n        \"lt\", \"lv\", \"me\", \"mk\", \"mn\", \"ms\", \"nb\", \"nl-BE\", \"nl\", \"no\", \"pl\", \"pt-BR\",\n        \"pt\", \"ro\", \"rs-latin\", \"rs\", \"ru\", \"sk\", \"sl\", \"sq\", \"sr-latin\", \"sr\", \"sv\",\n        \"sw\", \"th\", \"tr\", \"uk\", \"vi\", \"zh-CN\", and \"zh-TW\".\n    separator\n        String to display between the start and end input boxes.\n    width\n        The CSS width, e.g. '400px', or '100%'\n    autoclose\n        Whether or not to close the datepicker immediately when a date is selected.\n\n    Returns\n    -------\n    :\n        A UI element.\n\n    Note\n    ----\n    The date ``format`` string specifies how the date will be displayed in the browser.\n    It allows the following values:\n\n    - ``yy``: Year without century (12)\n    - ``yyyy``: Year with century (2012)\n    - ``mm``: Month number, with leading zero (01-12)\n    - ``m``: Month number, without leading zero (1-12)\n    - ``M``: Abbreviated month name\n    - ``MM``: Full month name\n    - ``dd``: Day of month with leading zero\n    - ``d``: Day of month without leading zero\n    - ``D``: Abbreviated weekday name\n    - ``DD``: Full weekday name\n\n    Notes\n    ------\n    ::: {.callout-note title=\"Server value\"}\n    A tuple of :class:`~datetime.date` objects.\n    :::\n\n    See Also\n    -------\n    ~shiny.ui.update_date_range\n    ~shiny.ui.input_date\n    \"\"\"\n\n    resolved_id = resolve_id(id)\n    return div(\n        shiny_input_label(resolved_id, label),\n        div(\n            _date_input_tag(\n                id=resolved_id,\n                value=start,\n                min=min,\n                max=max,\n                format=format,\n                startview=startview,\n                weekstart=weekstart,\n                language=language,\n                autoclose=autoclose,\n            ),\n            # input-group-prepend and input-group-append are for bootstrap 4 forward compat\n            span(\n                span(separator, class_=\"input-group-text\"),\n                class_=\"input-group-addon input-group-prepend input-group-append\",\n            ),\n            _date_input_tag(\n                id=resolved_id,\n                value=end,\n                min=min,\n                max=max,\n                format=format,\n                startview=startview,\n                weekstart=weekstart,\n                language=language,\n                autoclose=autoclose,\n            ),\n            # input-daterange class is needed for dropdown behavior\n            class_=\"input-daterange input-group input-group-sm\",\n        ),\n        id=resolved_id,\n        class_=\"shiny-date-range-input form-group shiny-input-container\",\n        style=css(width=width),\n    )",
  "def _date_input_tag(\n    id: str,\n    value: Optional[date | str],\n    min: Optional[date | str],\n    max: Optional[date | str],\n    format: str,\n    startview: str,\n    weekstart: int,\n    language: str,\n    autoclose: bool,\n    **kwargs: TagAttrValue,\n):\n    return tags.input(\n        datepicker_deps(),\n        {\"class\": \"form-control\"},\n        type=\"text\",\n        # `aria-labelledby` attribute is required for accessibility to avoid doubled labels (#2951).\n        aria_labelledby=id + \"-label\",\n        # title attribute is announced for screen readers for date format.\n        title=\"Date format: \" + format,\n        data_date_language=language,\n        data_date_week_start=weekstart,\n        data_date_format=format,\n        data_date_start_view=startview,\n        data_min_date=_as_date_attr(min),\n        data_max_date=_as_date_attr(max),\n        data_initial_date=_as_date_attr(value),\n        data_date_autoclose=\"true\" if autoclose else \"false\",\n        **kwargs,\n    )",
  "def _as_date_attr(x: Optional[date | str]) -> Optional[str]:\n    if x is None:\n        return None\n    if isinstance(x, date):\n        return str(x)\n    return str(date.fromisoformat(x))",
  "def output_plot(\n    id: str,\n    width: str = \"100%\",\n    height: str = \"400px\",\n    *,\n    inline: bool = False,\n    click: bool | ClickOpts = False,\n    dblclick: bool | DblClickOpts = False,\n    hover: bool | HoverOpts = False,\n    brush: bool | BrushOpts = False,\n) -> Tag:\n    \"\"\"\n    Create a output container for a static plot.\n\n    Place a :func:`~shiny.render.plot` result in the user interface. See\n    :func:`~shiny.render.plot` for more details on what types of plots are supported.\n\n    Parameters\n    ----------\n    id\n        An output id.\n    width\n        The CSS width, e.g. '400px', or '100%'.\n    height\n        The CSS height, e.g. '100%' or '600px'.\n    inline\n        If ``True``, the result is displayed inline.\n    click\n        This can be a boolean or an object created by :func:`~shiny.ui.click_opts`. The\n        default is `False`, but if you use `True` (or equivalently, `click_opts()`), the\n        plot will send coordinates to the server whenever it is clicked, and the value\n        will be accessible via `input.xx_click()`, where `xx` is replaced with the ID of\n        this plot. The input value will be a dictionary with `x` and `y` elements\n        indicating the mouse position.\n    dblclick\n        This is just like the `click` parameter, but for double-click events.\n    hover\n        Similar to the `click` argument, this can be a boolean or an object created by\n        :func:`~shiny.ui.hover_opts`. The default is `False`, but if you use `True` (or\n        equivalently, `hover_opts()`), the plot will send coordinates to the server\n        whenever it is clicked, and the value will be accessible via `input.xx_hover()`,\n        where `xx` is replaced with the ID of this plot. The input value will be a\n        dictionary with `x` and `y` elements indicating the mouse position. To control\n        the hover time or hover delay type, use :func:`~shiny.ui.hover_opts`.\n    brush\n        Similar to the `click` argument, this can be a boolean or an object created by\n        :func:`~shiny.ui.brush_opts`. The default is `False`, but if you use `True` (or\n        equivalently, `brush_opts()`), the plot will allow the user to \"brush\" in the\n        plotting area, and will send information about the brushed area to the server,\n        and the value will be accessible via `input.plot_brush()`. Brushing means that\n        the user will be able to draw a rectangle in the plotting area and drag it\n        around. The value will be a named list with `xmin`, `xmax`, `ymin`, and `ymax`\n        elements indicating the brush area. To control the brush behavior, use\n        :func:`~shiny.ui.brush_opts`. Multiple `output_image`/`output_plot` calls may\n        share the same `id` value; brushing one image or plot will cause any other\n        brushes with the same `id` to disappear.\n\n    Returns\n    -------\n    :\n        A UI element\n\n    See Also\n    -------\n    ~shiny.render.plot ~shiny.ui.output_image\n    \"\"\"\n    res = output_image(\n        id=id,\n        width=width,\n        height=height,\n        inline=inline,\n        click=click,\n        dblclick=dblclick,\n        hover=hover,\n        brush=brush,\n    )\n    res.add_class(\"shiny-plot-output\")\n    return res",
  "def output_image(\n    id: str,\n    width: str = \"100%\",\n    height: str = \"400px\",\n    *,\n    inline: bool = False,\n    click: bool | ClickOpts = False,\n    dblclick: bool | DblClickOpts = False,\n    hover: bool | HoverOpts = False,\n    brush: bool | BrushOpts = False,\n) -> Tag:\n    \"\"\"\n    Create a output container for a static image.\n\n    Parameters\n    ----------\n    id\n        An output id.\n    width\n        The CSS width, e.g. '400px', or '100%'.\n    height\n        The CSS height, e.g. '100%' or '600px'.\n    inline\n        If ``True``, the result is displayed inline.\n    click\n        This can be a boolean or an object created by :func:`~shiny.ui.click_opts`. The\n        default is `False`, but if you use `True` (or equivalently, `click_opts()`), the\n        plot will send coordinates to the server whenever it is clicked, and the value\n        will be accessible via `input.xx_click()`, where `xx` is replaced with the ID of\n        this plot. The input value will be a dictionary with `x` and `y` elements\n        indicating the mouse position.\n    dblclick\n        This is just like the `click` parameter, but for double-click events.\n    hover\n        Similar to the `click` argument, this can be a boolean or an object created by\n        :func:`~shiny.ui.hover_opts`. The default is `False`, but if you use `True` (or\n        equivalently, `hover_opts()`), the plot will send coordinates to the server\n        whenever it is clicked, and the value will be accessible via `input.xx_hover()`,\n        where `xx` is replaced with the ID of this plot. The input value will be a\n        dictionary with `x` and `y` elements indicating the mouse position. To control\n        the hover time or hover delay type, use :func:`~shiny.ui.hover_opts`.\n    brush\n        Similar to the `click` argument, this can be a boolean or an object created by\n        :func:`~shiny.ui.brush_opts`. The default is `False`, but if you use `True` (or\n        equivalently, `brush_opts()`), the plot will allow the user to \"brush\" in the\n        plotting area, and will send information about the brushed area to the server,\n        and the value will be accessible via `input.plot_brush()`. Brushing means that\n        the user will be able to draw a rectangle in the plotting area and drag it\n        around. The value will be a named list with `xmin`, `xmax`, `ymin`, and `ymax`\n        elements indicating the brush area. To control the brush behavior, use\n        :func:`~shiny.ui.brush_opts`. Multiple `output_image`/`output_plot` calls may\n        share the same `id` value; brushing one image or plot will cause any other\n        brushes with the same `id` to disappear.\n\n    Returns\n    -------\n    :\n        A UI element\n\n    See Also\n    -------\n    ~shiny.render.image\n    ~shiny.ui.output_plot\n    \"\"\"\n    func = tags.span if inline else div\n    style = None if inline else css(width=width, height=height)\n\n    args: dict[str, str] = dict()\n\n    id_resolved = resolve_id(id)\n\n    if click is not False:\n        if click is True:\n            click = click_opts()\n        click[\"id\"] = id_resolved + \"_click\"\n        args.update(**format_opt_names(click, \"click\"))\n\n    if dblclick is not False:\n        if dblclick is True:\n            dblclick = dblclick_opts()\n        dblclick[\"id\"] = id_resolved + \"_dblclick\"\n        args.update(**format_opt_names(dblclick, \"dblclick\"))\n\n    if hover is not False:\n        if hover is True:\n            hover = hover_opts()\n        hover[\"id\"] = id_resolved + \"_hover\"\n        args.update(**format_opt_names(hover, \"hover\"))\n\n    if brush is not False:\n        if brush is True:\n            brush = brush_opts()\n        brush[\"id\"] = id_resolved + \"_brush\"\n        args.update(**format_opt_names(brush, \"brush\"))\n\n    return func(\n        id=id_resolved,\n        class_=\"shiny-image-output\",\n        style=style,\n        **args,\n    )",
  "def output_text(\n    id: str, inline: bool = False, container: Optional[TagFunction] = None\n) -> Tag:\n    \"\"\"\n    Create a output container for some text.\n\n    Parameters\n    ----------\n    id\n        An output id.\n    inline\n        If ``True``, the result is displayed inline\n    container\n        A Callable that returns the output container.\n\n    Returns\n    -------\n    :\n        A UI element\n\n    Note\n    ----\n    Text is HTML-escaped prior to rendering.\n\n    See Also\n    -------\n    ~shiny.render.text\n    ~shiny.ui.output_text_verbatim\n    \"\"\"\n\n    if not container:\n        container = tags.span if inline else tags.div\n    return container(id=resolve_id(id), class_=\"shiny-text-output\")",
  "def output_text_verbatim(id: str, placeholder: bool = False) -> Tag:\n    \"\"\"\n    Create a output container for some text.\n\n    Place a :func:`~shiny.render.text` result in the user interface.\n    Differs from :func:`~shiny.ui.output_text` in that it wraps the text in a\n    fixed-width container with a gray-ish background color and border.\n\n    Parameters\n    ----------\n    id\n        An output id.\n    placeholder\n        If the output is empty or ``None``, should an empty rectangle be displayed to\n        serve as a placeholder? (does not affect behavior when the output is nonempty)\n\n    Returns\n    -------\n    :\n        A UI element\n\n    See Also\n    -------\n    ~shiny.render.text\n    ~shiny.ui.output_text\n\n    Example\n    -------\n    See :func:`~shiny.ui.output_text`\n    \"\"\"\n\n    cls = \"shiny-text-output\" + (\" noplaceholder\" if not placeholder else \"\")\n    return tags.pre(id=resolve_id(id), class_=cls)",
  "def output_table(id: str, **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a output container for a table.\n\n    Parameters\n    ----------\n    id\n        An output id.\n    **kwargs\n        Additional attributes to add to the container.\n\n    Returns\n    -------\n    :\n\n    See Also\n    -------\n    ~shiny.render.table\n    \"\"\"\n    return tags.div({\"class\": \"shiny-html-output\"}, id=resolve_id(id), **kwargs)",
  "def output_ui(\n    id: str,\n    inline: bool = False,\n    container: Optional[TagFunction] = None,\n    **kwargs: TagAttrValue,\n) -> Tag:\n    \"\"\"\n    Create a output container for a UI (i.e., HTML) element.\n\n    Parameters\n    ----------\n    id\n        An output id.\n    inline\n        If ``True``, the result is displayed inline\n    container\n        A Callable that returns the output container.\n    kwargs\n        Attributes to be applied to the output container.\n\n    Returns\n    -------\n    :\n        A UI element\n\n    See Also\n    -------\n    ~shiny.render.ui\n    ~shiny.ui.output_text\n    \"\"\"\n\n    if not container:\n        container = tags.span if inline else tags.div\n    return container({\"class\": \"shiny-html-output\"}, id=resolve_id(id), **kwargs)",
  "def page_navbar(\n    *args: NavSetArg | MetadataNode | Sequence[MetadataNode],\n    title: Optional[str | Tag | TagList] = None,\n    id: Optional[str] = None,\n    selected: Optional[str] = None,\n    position: Literal[\"static-top\", \"fixed-top\", \"fixed-bottom\"] = \"static-top\",\n    header: Optional[TagChild] = None,\n    footer: Optional[TagChild] = None,\n    bg: Optional[str] = None,\n    inverse: bool = False,\n    collapsible: bool = True,\n    fluid: bool = True,\n    window_title: str | MISSING_TYPE = MISSING,\n    lang: Optional[str] = None,\n) -> Tag:\n    \"\"\"\n    Create a page with a navbar and a title.\n\n    Parameters\n    ----------\n\n    args\n        UI elements.\n    title\n        The browser window title (defaults to the host URL of the page). Can also be set\n        as a side effect via :func:`~shiny.ui.panel_title`.\n    id\n        If provided, will create an input value that holds the currently selected nav\n        item.\n    selected\n        Choose a particular nav item to select by default value (should match it's\n        ``value``).\n    position\n        Determines whether the navbar should be displayed at the top of the page with\n        normal scrolling behavior (\"static-top\"), pinned at the top (\"fixed-top\"), or\n        pinned at the bottom (\"fixed-bottom\"). Note that using \"fixed-top\" or\n        \"fixed-bottom\" will cause the navbar to overlay your body content, unless you\n        add padding (e.g., ``tags.style(\"body {padding-top: 70px;}\")``).\n    header\n        UI to display above the selected content.\n    footer\n        UI to display below the selected content.\n    bg\n        Background color of the navbar (a CSS color).\n    inverse\n        Either ``True`` for a light text color or ``False`` for a dark text color.\n    collapsible\n        ``True`` to automatically collapse the navigation elements into an expandable menu on mobile devices or narrow window widths.\n    fluid\n        ``True`` to use fluid layout; ``False`` to use fixed layout.\n    window_title\n        The browser's window title (defaults to the host URL of the page). Can also be\n        set as a side effect via :func:`~shiny.ui.panel_title`.\n    lang\n        ISO 639-1 language code for the HTML page, such as ``\"en\"`` or ``\"ko\"``. This\n        will be used as the lang in the ``<html>`` tag, as in ``<html lang=\"en\">``. The\n        default, `None`, results in an empty string.\n\n    Returns\n    -------\n    :\n        A UI element.\n\n    See Also\n    -------\n    :func:`~shiny.ui.nav`\n    :func:`~shiny.ui.nav_menu`\n    :func:`~shiny.ui.navset_bar`\n    :func:`~shiny.ui.page_fluid`\n\n    Example\n    -------\n    See :func:`~shiny.ui.nav`.\n    \"\"\"\n\n    return tags.html(\n        get_window_title(title, window_title),\n        tags.body(\n            navset_bar(\n                *args,\n                title=title,\n                id=resolve_id(id) if id else None,\n                selected=selected,\n                position=position,\n                header=header,\n                footer=footer,\n                bg=bg,\n                inverse=inverse,\n                collapsible=collapsible,\n                fluid=fluid,\n            )\n        ),\n        lang=lang,\n    )",
  "def page_fluid(\n    *args: TagChild | TagAttrs,\n    title: Optional[str] = None,\n    lang: Optional[str] = None,\n    **kwargs: str,\n) -> Tag:\n    \"\"\"\n    Create a fluid page.\n\n    Parameters\n    ----------\n\n    args\n        UI elements.\n    title\n        The browser window title (defaults to the host URL of the page). Can also be set\n        as a side effect via :func:`~shiny.ui.panel_title`.\n    lang\n        ISO 639-1 language code for the HTML page, such as ``\"en\"`` or ``\"ko\"``. This\n        will be used as the lang in the ``<html>`` tag, as in ``<html lang=\"en\">``. The\n        default, `None`, results in an empty string.\n    kwargs\n        Attributes on the page level container.\n\n    Returns\n    -------\n    :\n        A UI element.\n\n    See Also\n    -------\n    :func:`~shiny.ui.page_fixed`\n    :func:`~shiny.ui.page_bootstrap`\n    :func:`~shiny.ui.page_navbar`\n    \"\"\"\n\n    return page_bootstrap(\n        div({\"class\": \"container-fluid\"}, *args, **kwargs), title=title, lang=lang\n    )",
  "def page_fixed(\n    *args: TagChild | TagAttrs,\n    title: Optional[str] = None,\n    lang: Optional[str] = None,\n    **kwargs: str,\n) -> Tag:\n    \"\"\"\n    Create a fixed page.\n\n    Parameters\n    ----------\n\n    args\n        UI elements.\n    title\n        The browser window title (defaults to the host URL of the page). Can also be set\n        as a side effect via :func:`~shiny.ui.panel_title`.\n    lang\n        ISO 639-1 language code for the HTML page, such as ``\"en\"`` or ``\"ko\"``. This\n        will be used as the lang in the ``<html>`` tag, as in ``<html lang=\"en\">``. The\n        default, `None`, results in an empty string.\n    kwargs\n        Attributes on the page level container.\n\n    Returns\n    -------\n    :\n        A UI element.\n\n    See Also\n    -------\n    :func:`~shiny.ui.page_fluid`\n    :func:`~shiny.ui.page_bootstrap`\n    :func:`~shiny.ui.page_navbar`\n    \"\"\"\n\n    return page_bootstrap(\n        div({\"class\": \"container\"}, *args, **kwargs), title=title, lang=lang\n    )",
  "def page_bootstrap(\n    *args: TagChild | TagAttrs, title: Optional[str] = None, lang: Optional[str] = None\n) -> Tag:\n    \"\"\"\n    Create a Bootstrap UI page container.\n\n    Parameters\n    ----------\n\n    args\n        UI elements.\n    title\n        The browser window title (defaults to the host URL of the page). Can also be set\n        as a side effect via :func:`~shiny.ui.panel_title`.\n    lang\n        ISO 639-1 language code for the HTML page, such as ``\"en\"`` or ``\"ko\"``. This\n        will be used as the lang in the ``<html>`` tag, as in ``<html lang=\"en\">``. The\n        default, `None`, results in an empty string.\n\n    Returns\n    -------\n    :\n        A UI element.\n\n    See Also\n    -------\n    :func:`~shiny.ui.page_fluid`\n    :func:`~shiny.ui.page_navbar`\n    \"\"\"\n    head = tags.title(title) if title else None\n    return tags.html(tags.head(head), tags.body(*bootstrap_deps(), *args), lang=lang)",
  "def notification_show(\n    ui: TagChild,\n    *,\n    action: Optional[TagChild] = None,\n    duration: Optional[int | float] = 5,\n    close_button: bool = True,\n    id: Optional[str] = None,\n    type: Literal[\"default\", \"message\", \"warning\", \"error\"] = \"default\",\n    session: Optional[Session] = None,\n) -> str:\n    \"\"\"\n    Show a notification to the user.\n\n    Parameters\n    ----------\n    ui\n        Content of message.\n    action\n        Message content that represents an action. For example, this could be a link\n        that the user can click on. This is separate from ui so customized layouts can\n        handle the main notification content separately from action content.\n    duration\n        Number of seconds to display the message before it disappears. Use ``None`` to\n        make the message not automatically disappear.\n    close_button\n        If ``True``, display a button which will make the notification disappear when\n        clicked. If ``False`` do not display.\n    id\n        An optional unique identifier for the notification. If supplied, any existing\n        notification with the same ``id`` will be replaced with this one (otherwise, a\n        new notification is created).\n    type\n        A string which controls the color of the notification. One of \"default\" (gray),\n        \"message\" (blue), \"warning\" (yellow), or \"error\" (red).\n    session\n        A :class:`~shiny.Session` instance. If not provided, it is inferred via\n        :func:`~shiny.session.get_current_session`.\n\n    Returns\n    -------\n    :\n        The notification's ``id``.\n\n    See Also\n    -------\n    ~shiny.ui.notification_remove\n    ~shiny.ui.modal\n    \"\"\"\n\n    session = require_active_session(session)\n\n    ui_ = session._process_ui(ui)\n    action_ = session._process_ui(action)\n\n    id = id if id else rand_hex(8)\n\n    payload: dict[str, Any] = {\n        \"html\": ui_[\"html\"],\n        \"action\": action_[\"html\"],\n        \"deps\": ui_[\"deps\"] + action_[\"deps\"],\n        \"closeButton\": close_button,\n        \"id\": id,\n        \"type\": type,\n    }\n\n    if duration:\n        payload.update({\"duration\": duration * 1000})\n\n    session._send_message_sync({\"notification\": {\"type\": \"show\", \"message\": payload}})\n\n    return id",
  "def notification_remove(id: str, *, session: Optional[Session] = None) -> str:\n    \"\"\"\n    Remove a notification.\n\n    Parameters\n    ----------\n    id\n        A notification ``id``.\n    session\n        A :class:`~shiny.Session` instance. If not provided, it is inferred via\n        :func:`~shiny.session.get_current_session`.\n\n    Returns\n    -------\n    :\n        The notification's ``id``.\n\n    See Also\n    -------\n    ~shiny.ui.notification_show\n    ~shiny.ui.modal\n\n    Example\n    -------\n    See :func:`notification_show`.\n    \"\"\"\n    session = require_active_session(session)\n    session._send_message_sync({\"notification\": {\"type\": \"remove\", \"message\": id}})\n    return id",
  "def modal_button(label: TagChild, icon: TagChild = None, **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Creates a button that will dismiss a :func:`modal` (useful when customising the\n    ``footer`` of :func:`modal`).\n\n    Parameters\n    ----------\n    label\n        An input label.\n    icon\n        An icon to appear inline with the button/link.\n    kwargs\n        Attributes to be applied to the button.\n\n    Returns\n    -------\n    :\n        A UI element\n\n    See Also\n    -------\n    ~shiny.ui.modal\n    ~shiny.ui.modal_show\n    ~shiny.ui.modal_remove\n\n    Example\n    -------\n    See :func:`modal`.\n    \"\"\"\n    return tags.button(\n        icon,\n        label,\n        {\"class\": \"btn btn-default\"},\n        type=\"button\",\n        data_dismiss=\"modal\",\n        data_bs_dismiss=\"modal\",\n        **kwargs,\n    )",
  "def modal(\n    *args: TagChild | TagAttrs,\n    title: Optional[str] = None,\n    footer: TagChild | MISSING_TYPE = MISSING,\n    size: Literal[\"m\", \"s\", \"l\", \"xl\"] = \"m\",\n    easy_close: bool = False,\n    fade: bool = True,\n    **kwargs: TagAttrValue,\n) -> Tag:\n    \"\"\"\n    Creates the UI for a modal dialog, using Bootstrap's modal class. Modals are\n    typically used for showing important messages, or for presenting UI that requires\n    input from the user, such as a user name and/or password input.\n\n    Parameters\n    ----------\n    args\n        UI elements for the body of the modal.\n    title\n        An optional title for the modal dialog.\n    footer\n        UI for footer. Use ``None`` for no footer.\n    size\n        One of \"s\" for small, \"m\" (the default) for medium, or \"l\" for large.\n    easy_close\n        If ``True``, the modal dialog can be dismissed by clicking outside the dialog\n        box, or be pressing the Escape key. If ``False`` (the default), the modal dialog\n        can't be dismissed in those ways; instead it must be dismissed by clicking on a\n        ``modal_button()``, or from a call to ``modal_remove()`` on the server.\n    fade\n        If ``False``, the modal dialog will have no fade-in animation (it will simply\n        appear rather than fade in to view).\n    kwargs\n        Attributes to be applied to the modal's body tag.\n\n    Returns\n    -------\n    :\n        A UI element\n\n    See Also\n    -------\n    ~shiny.ui.modal_show\n    ~shiny.ui.modal_remove\n    ~shiny.ui.modal_button\n    \"\"\"\n\n    title_div = None\n    if title:\n        title_div = div(tags.h4(title, class_=\"modal-title\"), class_=\"modal-header\")\n\n    if isinstance(footer, MISSING_TYPE):\n        footer = modal_button(\"Dismiss\")\n    if footer is not None:\n        footer = div(footer, class_=\"modal-footer\")\n\n    dialog = div(\n        div(\n            title_div,\n            div({\"class\": \"modal-body\"}, *args, **kwargs),\n            footer,\n            class_=\"modal-content\",\n        ),\n        class_=\"modal-dialog\"\n        + ({\"s\": \" modal-sm\", \"l\": \" modal-lg\", \"xl\": \" modal-xl\"}.get(size, \"\")),\n    )\n\n    # jQuery plugin doesn't work in Bootstrap 5, but vanilla JS doesn't work in Bootstrap 4 :sob:\n    js = \"\\n\".join(\n        [\n            \"if (window.bootstrap && !window.bootstrap.Modal.VERSION.match(/^4\\\\. /)) {\",\n            \"  var modal=new bootstrap.Modal(document.getElementById('shiny-modal'))\",\n            \"  modal.show()\",\n            \"} else {\",\n            \"  $('#shiny-modal').modal().focus()\",\n            \"}\",\n        ]\n    )\n\n    backdrop = None if easy_close else \"static\"\n    keyboard = None if easy_close else \"false\"\n\n    return div(\n        dialog,\n        tags.script(HTML(js)),\n        id=\"shiny-modal\",\n        class_=\"modal fade\" if fade else \"modal\",\n        tabindex=\"-1\",\n        data_backdrop=backdrop,\n        data_bs_backdrop=backdrop,\n        data_keyboard=keyboard,\n        data_bs_keyboard=keyboard,\n    )",
  "def modal_show(modal: Tag, session: Optional[Session] = None) -> None:\n    \"\"\"\n    Show a modal dialog.\n\n    Parameters\n    ----------\n    modal\n        Typically a :func:`modal` instance.\n    session\n        A :class:`~shiny.Session` instance. If not provided, it is inferred via\n        :func:`~shiny.session.get_current_session`.\n\n    See Also\n    -------\n    ~shiny.ui.modal_remove\n    ~shiny.ui.modal\n\n    Example\n    -------\n    See :func:`modal`.\n    \"\"\"\n    session = require_active_session(session)\n    msg = session._process_ui(modal)\n    session._send_message_sync({\"modal\": {\"type\": \"show\", \"message\": msg}})",
  "def modal_remove(session: Optional[Session] = None) -> None:\n    \"\"\"\n    Remove a modal dialog.\n\n    Parameters\n    ----------\n    session\n        A :class:`~shiny.Session` instance. If not provided, it is inferred via\n        :func:`~shiny.session.get_current_session`.\n\n    See Also\n    -------\n    ~shiny.ui.modal_show\n    ~shiny.ui.modal\n\n    Example\n    -------\n    See :func:`modal`.\n    \"\"\"\n    session = require_active_session(session)\n    session._send_message_sync({\"modal\": {\"type\": \"remove\", \"message\": None}})",
  "class Nav:\n    nav: Tag\n    content: Optional[Tag]\n\n    def __init__(self, nav: Tag, content: Optional[Tag] = None) -> None:\n        self.nav = nav\n        # nav_control()/nav_spacer() have None as their content\n        self.content = content\n\n    def resolve(\n        self, selected: Optional[str], context: dict[str, Any]\n    ) -> tuple[TagChild, TagChild]:\n        # Nothing to do for nav_control()/nav_spacer()\n        if self.content is None:\n            return self.nav, None\n\n        # At least currently, in the case where both nav and content are tags\n        # (i.e., nav()), the nav always has a child <a> tag...I'm not sure if\n        # there's a way to statically type this\n        nav = copy.deepcopy(self.nav)\n        a_tag = cast(Tag, nav.children[0])\n        if context.get(\"is_menu\", False):\n            a_tag.add_class(\"dropdown-item\")\n        else:\n            a_tag.add_class(\"nav-link\")\n            nav.add_class(\"nav-item\")\n\n        # Hyperlink the nav to the content\n        content = copy.copy(self.content)\n        if \"tabsetid\" in context and \"index\" in context:\n            id = f\"tab-{context['tabsetid']}-{context['index']}\"\n            content.attrs[\"id\"] = id\n            a_tag.attrs[\"href\"] = f\"#{id}\"\n\n        # Mark the nav/content as active if it should be\n        if isinstance(selected, str) and selected == self.get_value():\n            content.add_class(\"active\")\n            a_tag.add_class(\"active\")\n\n        nav.children[0] = a_tag\n\n        return nav, content\n\n    def get_value(self) -> Optional[str]:\n        if self.content is None:\n            return None\n        a_tag = cast(Tag, self.nav.children[0])\n        return a_tag.attrs.get(\"data-value\", None)\n\n    def tagify(self) -> None:\n        raise NotImplementedError(\n            \"nav() items must appear within navset_*() container.\"\n        )",
  "def nav(\n    title: TagChild,\n    *args: TagChild,\n    value: Optional[str] = None,\n    icon: TagChild = None,\n) -> Nav:\n    \"\"\"\n    Create a nav item pointing to some internal content.\n\n    Parameters\n    ----------\n    title\n        A title to display. Can be a character string or UI elements (i.e., tags).\n    *args\n        UI elements to display when the item is active.\n    value\n        The value of the item. This is used to determine whether the item is active\n        (when an ``id`` is provided to the nav container), programmatically select the\n        item (e.g., :func:`~shiny.ui.update_navs`), and/or be provided to the\n        ``selected`` argument of the navigation container (e.g.,\n        :func:`~shiny.ui.navset_tab`).\n    icon\n        An icon to appear inline with the button/link.\n\n    See Also\n    -------\n    ~shiny.ui.nav_menu\n    ~shiny.ui.nav_control\n    ~shiny.ui.nav_spacer\n    ~shiny.ui.navset_bar\n    ~shiny.ui.navset_tab\n    ~shiny.ui.navset_pill\n    ~shiny.ui.navset_card_tab\n    ~shiny.ui.navset_card_pill\n    ~shiny.ui.navset_hidden\n    \"\"\"\n    if value is None:\n        value = str(title)\n\n    # N.B. at this point, we don't have enough info to link the nav to the content\n    # or add relevant classes. That's done later by consumers (i.e. nav containers)\n    link = tags.a(\n        icon,\n        title,\n        data_bs_toggle=\"tab\",  # Bootstrap 5\n        data_toggle=\"tab\",  # Needed for shiny.js' insert-tab handler\n        data_value=value,\n        role=\"tab\",\n    )\n\n    return Nav(\n        tags.li(link),\n        div(*args, class_=\"tab-pane\", role=\"tabpanel\", data_value=value),\n    )",
  "def nav_control(*args: TagChild) -> Nav:\n    \"\"\"\n    Place a control in the navigation container.\n\n    Parameters\n    ----------\n    *args\n        UI elements to display as the nav item.\n\n    See Also\n    -------\n    ~shiny.ui.nav\n    ~shiny.ui.nav_menu\n    ~shiny.ui.nav_spacer\n    ~shiny.ui.navset_bar\n    ~shiny.ui.navset_tab\n    ~shiny.ui.navset_pill\n    ~shiny.ui.navset_card_tab\n    ~shiny.ui.navset_card_pill\n    ~shiny.ui.navset_hidden\n    Example\n    -------\n    See :func:`~shiny.ui.nav`\n    \"\"\"\n    return Nav(tags.li(*args))",
  "def nav_spacer() -> Nav:\n    \"\"\"\n    Create space between nav items.\n\n    See Also\n    -------\n    ~shiny.ui.nav\n    ~shiny.ui.nav_menu\n    ~shiny.ui.nav_control\n    ~shiny.ui.navset_bar\n    ~shiny.ui.navset_tab\n    ~shiny.ui.navset_pill\n    ~shiny.ui.navset_card_tab\n    ~shiny.ui.navset_card_pill\n    ~shiny.ui.navset_hidden\n\n    Example\n    -------\n    See :func:`~shiny.ui.nav`\n    \"\"\"\n\n    return Nav(tags.li(nav_spacer_deps(), class_=\"bslib-nav-spacer\"))",
  "class NavMenu:\n    nav_controls: list[NavSetArg]\n    title: TagChild\n    value: str\n    align: Literal[\"left\", \"right\"]\n\n    def __init__(\n        self,\n        *args: NavSetArg | str,\n        title: TagChild,\n        value: str,\n        align: Literal[\"left\", \"right\"] = \"left\",\n    ) -> None:\n        self.nav_controls = [menu_string_as_nav(x) for x in args]\n        self.title = title\n        self.value = value\n        self.align = align\n\n    def resolve(\n        self,\n        selected: Optional[str],\n        context: dict[str, Any],\n    ) -> tuple[TagChild, TagChild]:\n        nav, content = render_navset(\n            *self.nav_controls,\n            ul_class=f\"dropdown-menu {'dropdown-menu-right' if self.align == 'right' else ''}\",\n            id=None,\n            selected=selected,\n            context={**context, \"is_menu\": True},\n        )\n\n        active = False\n        for tab in content.children:\n            if isinstance(tab, Tag) and tab.has_class(\"active\"):\n                active = True\n                break\n\n        return (\n            tags.li(\n                tags.a(\n                    self.title,\n                    class_=f\"nav-link dropdown-toggle {'active' if active else ''}\",\n                    data_bs_toggle=\"dropdown\",\n                    # N.B. this value is only relevant for locating the insertion/removal\n                    # of items inside the nav container\n                    data_value=self.value,\n                    href=\"#\",\n                    role=\"button\",\n                ),\n                nav,\n                class_=\"nav-item dropdown\",\n            ),\n            content.children,\n        )\n\n    def get_value(self) -> Optional[str]:\n        for x in self.nav_controls:\n            val = x.get_value()\n            if val:\n                return val\n        return None\n\n    def tagify(self) -> None:\n        raise NotImplementedError(\"nav_menu() must appear within navset_*() container.\")",
  "def menu_string_as_nav(x: str | NavSetArg) -> NavSetArg:\n    if not isinstance(x, str):\n        return x\n\n    if re.match(r\"^\\-+$\", x):\n        nav = tags.li(class_=\"dropdown-divider\")\n    else:\n        nav = tags.li(x, class_=\"dropdown-header\")\n\n    return Nav(nav)",
  "def nav_menu(\n    title: TagChild,\n    *args: Nav | str,\n    value: Optional[str] = None,\n    icon: TagChild = None,\n    align: Literal[\"left\", \"right\"] = \"left\",\n) -> NavMenu:\n    \"\"\"\n    Create a menu of nav items.\n\n    Parameters\n    ----------\n    title\n        A title to display. Can be a character string or UI elements (i.e., tags).\n    *args\n        A collection of nav items (e.g., :func:`~shiny.ui.nav`) and/or strings.\n        Strings will be rendered as a section header unless the string is a set\n        of two or more hyphens (e.g., ``---``), in which case it will be rendered\n        as a divider.\n    value\n        The value of the item. This is used to determine whether the item is active\n        (when an ``id`` is provided to the nav container), programmatically select the\n        item (e.g., :func:`~shiny.ui.update_navs`), and/or be provided to the\n        ``selected`` argument of the navigation container (e.g.,\n        :func:`~shiny.ui.navset_tab`).\n    icon\n        An icon to appear inline with the button/link.\n    align\n        Horizontal alignment of the dropdown menu relative to dropdown toggle.\n\n    Returns\n    -------\n    :\n        A UI element representing both the navigation menu.\n\n    See Also\n    -------\n    ~shiny.ui.nav\n    ~shiny.ui.nav_control\n    ~shiny.ui.nav_spacer\n    ~shiny.ui.navset_bar\n    ~shiny.ui.navset_tab\n    ~shiny.ui.navset_pill\n    ~shiny.ui.navset_card_tab\n    ~shiny.ui.navset_card_pill\n    ~shiny.ui.navset_hidden\n    Example\n    -------\n    See :func:`~shiny.ui.nav`\n    \"\"\"\n    if value is None:\n        value = str(title)\n\n    return NavMenu(\n        *args,\n        title=TagList(icon, title),\n        value=value,\n        align=align,\n    )",
  "class NavSet:\n    args: tuple[NavSetArg | MetadataNode]\n    ul_class: str\n    id: Optional[str]\n    selected: Optional[str]\n    header: TagChild\n    footer: TagChild\n\n    def __init__(\n        self,\n        *args: NavSetArg | MetadataNode,\n        ul_class: str,\n        id: Optional[str],\n        selected: Optional[str],\n        header: TagChild = None,\n        footer: TagChild = None,\n    ) -> None:\n        self.args = args\n        self.ul_class = ul_class\n        self.id = id\n        self.selected = selected\n        self.header = header\n        self.footer = footer\n\n    def tagify(self) -> TagList | Tag:\n        id = self.id\n        ul_class = self.ul_class\n        if id is not None:\n            ul_class += \" shiny-tab-input\"\n\n        nav, content = render_navset(\n            *self.args, ul_class=ul_class, id=id, selected=self.selected, context={}\n        )\n        return self.layout(nav, content).tagify()\n\n    def layout(self, nav: TagChild, content: TagChild) -> TagList | Tag:\n        return TagList(nav, self.header, content, self.footer)",
  "def navset_tab(\n    *args: NavSetArg,\n    id: Optional[str] = None,\n    selected: Optional[str] = None,\n    header: TagChild = None,\n    footer: TagChild = None,\n) -> NavSet:\n    \"\"\"\n    Render nav items as a tabset.\n\n    Parameters\n    ----------\n    *args\n        A collection of nav items (e.g., :func:`shiny.ui.nav`).\n    id\n        If provided, will create an input value that holds the currently selected nav\n        item.\n    selected\n        Choose a particular nav item to select by default value (should match it's\n        ``value``).\n    header\n        UI to display above the selected content.\n    footer\n        UI to display below the selected content.\n\n\n    See Also\n    -------\n    ~shiny.ui.nav\n    ~shiny.ui.nav_menu\n    ~shiny.ui.nav_control\n    ~shiny.ui.nav_spacer\n    ~shiny.ui.navset_bar\n    ~shiny.ui.navset_pill\n    ~shiny.ui.navset_card_tab\n    ~shiny.ui.navset_card_pill\n    ~shiny.ui.navset_hidden\n\n    Example\n    -------\n    See :func:`~shiny.ui.nav`\n    \"\"\"\n\n    return NavSet(\n        *args,\n        ul_class=\"nav nav-tabs\",\n        id=resolve_id_or_none(id),\n        selected=selected,\n        header=header,\n        footer=footer,\n    )",
  "def navset_pill(\n    *args: NavSetArg,\n    id: Optional[str] = None,\n    selected: Optional[str] = None,\n    header: TagChild = None,\n    footer: TagChild = None,\n) -> NavSet:\n    \"\"\"\n    Render nav items as a pillset.\n\n    Parameters\n    ----------\n    *args\n        A collection of nav items (e.g., :func:`shiny.ui.nav`).\n    id\n        If provided, will create an input value that holds the currently selected nav\n        item.\n    selected\n        Choose a particular nav item to select by default value (should match it's\n        ``value``).\n    header\n        UI to display above the selected content.\n    footer\n        UI to display below the selected content.\n\n    See Also\n    -------\n    ~shiny.ui.nav\n    ~shiny.ui.nav_menu\n    ~shiny.ui.nav_control\n    ~shiny.ui.nav_spacer\n    ~shiny.ui.navset_bar\n    ~shiny.ui.navset_tab\n    ~shiny.ui.navset_card_tab\n    ~shiny.ui.navset_card_pill\n    ~shiny.ui.navset_hidden\n\n    Example\n    -------\n    See :func:`~shiny.ui.nav`\n    \"\"\"\n\n    return NavSet(\n        *args,\n        ul_class=\"nav nav-pills\",\n        id=resolve_id_or_none(id),\n        selected=selected,\n        header=header,\n        footer=footer,\n    )",
  "def navset_hidden(\n    *args: NavSetArg,\n    id: Optional[str] = None,\n    selected: Optional[str] = None,\n    header: TagChild = None,\n    footer: TagChild = None,\n) -> NavSet:\n    \"\"\"\n    Render nav contents without the nav items.\n\n    Parameters\n    ----------\n    *args\n        A collection of nav items (e.g., :func:`shiny.ui.nav`).\n    id\n        If provided, will create an input value that holds the currently selected nav\n        item.\n    selected\n        Choose a particular nav item to select by default value (should match it's\n        ``value``).\n    header\n        UI to display above the selected content.\n    footer\n        UI to display below the selected content.\n\n    See Also\n    --------\n    ~shiny.ui.nav\n    ~shiny.ui.nav_menu\n    ~shiny.ui.nav_control\n    ~shiny.ui.nav_spacer\n    ~shiny.ui.navset_tab\n    ~shiny.ui.navset_card_tab\n    ~shiny.ui.navset_pill\n    ~shiny.ui.navset_card_pill\n    ~shiny.ui.navset_pill_list\n    ~shiny.ui.navset_bar\n    \"\"\"\n\n    return NavSet(\n        *args,\n        ul_class=\"nav nav-hidden\",\n        id=resolve_id_or_none(id),\n        selected=selected,\n        header=header,\n        footer=footer,\n    )",
  "class NavSetCard(NavSet):\n    placement: Literal[\"above\", \"below\"]\n\n    def __init__(\n        self,\n        *args: NavSetArg,\n        ul_class: str,\n        id: Optional[str],\n        selected: Optional[str],\n        header: TagChild = None,\n        footer: TagChild = None,\n        placement: Literal[\"above\", \"below\"] = \"above\",\n    ) -> None:\n        super().__init__(\n            *args,\n            ul_class=ul_class,\n            id=id,\n            selected=selected,\n            header=header,\n            footer=footer,\n        )\n        self.placement = placement\n\n    def layout(self, nav: TagChild, content: TagChild) -> Tag:\n        if self.placement == \"below\":\n            return card(self.header, content, self.footer, footer=nav)\n        else:\n            return card(self.header, content, self.footer, header=nav)",
  "def navset_card_tab(\n    *args: NavSetArg,\n    id: Optional[str] = None,\n    selected: Optional[str] = None,\n    header: TagChild = None,\n    footer: TagChild = None,\n) -> NavSetCard:\n    \"\"\"\n    Render nav items as a tabset inside a card container.\n\n    Parameters\n    ----------\n    *args\n        A collection of nav items (e.g., :func:`shiny.ui.nav`).\n    id\n        If provided, will create an input value that holds the currently selected nav\n        item.\n    selected\n        Choose a particular nav item to select by default value (should match it's\n        ``value``).\n    header\n        UI to display above the selected content.\n    footer\n        UI to display below the selected content.\n\n    See Also\n    -------\n    ~shiny.ui.nav\n    ~shiny.ui.nav_menu\n    ~shiny.ui.nav_control\n    ~shiny.ui.nav_spacer\n    ~shiny.ui.navset_bar\n    ~shiny.ui.navset_tab\n    ~shiny.ui.navset_pill\n    ~shiny.ui.navset_card_pill\n    ~shiny.ui.navset_hidden\n\n    Example\n    -------\n    See :func:`~shiny.ui.nav`\n    \"\"\"\n\n    return NavSetCard(\n        *args,\n        ul_class=\"nav nav-tabs card-header-tabs\",\n        id=resolve_id_or_none(id),\n        selected=selected,\n        header=header,\n        footer=footer,\n        placement=\"above\",\n    )",
  "def navset_card_pill(\n    *args: NavSetArg,\n    id: Optional[str] = None,\n    selected: Optional[str] = None,\n    header: TagChild = None,\n    footer: TagChild = None,\n    placement: Literal[\"above\", \"below\"] = \"above\",\n) -> NavSetCard:\n    \"\"\"\n    Render nav items as a pillset inside a card container.\n\n    Parameters\n    ----------\n    *args\n        A collection of nav items (e.g., :func:`shiny.ui.nav`).\n    id\n        If provided, will create an input value that holds the currently selected nav\n        item.\n    selected\n        Choose a particular nav item to select by default value (should match it's\n        ``value``).\n    header\n        UI to display above the selected content.\n    footer\n        UI to display below the selected content.\n    placement\n        Placement of the nav items relative to the content.\n\n    See Also\n    -------\n    ~shiny.ui.nav\n    ~shiny.ui.nav_menu\n    ~shiny.ui.nav_control\n    ~shiny.ui.nav_spacer\n    ~shiny.ui.navset_bar\n    ~shiny.ui.navset_tab\n    ~shiny.ui.navset_pill\n    ~shiny.ui.navset_card_tab\n    ~shiny.ui.navset_hidden\n\n    Example\n    -------\n    See :func:`~shiny.ui.nav`\n    \"\"\"\n\n    return NavSetCard(\n        *args,\n        ul_class=\"nav nav-pills card-header-pills\",\n        id=resolve_id_or_none(id),\n        selected=selected,\n        header=header,\n        footer=footer,\n        placement=placement,\n    )",
  "class NavSetPillList(NavSet):\n    well: bool\n    widths: tuple[int, int]\n\n    def __init__(\n        self,\n        *args: NavSetArg | MetadataNode,\n        ul_class: str,\n        id: Optional[str],\n        selected: Optional[str],\n        header: TagChild = None,\n        footer: TagChild = None,\n        well: bool = True,\n        widths: tuple[int, int] = (4, 8),\n    ) -> None:\n        super().__init__(\n            *args,\n            ul_class=ul_class,\n            id=id,\n            selected=selected,\n            header=header,\n            footer=footer,\n        )\n        self.well = well\n        self.widths = widths\n\n    def layout(self, nav: TagChild, content: TagChild) -> Tag:\n        widths = self.widths\n        return row(\n            column(widths[0], nav, class_=\"well\" if self.well else None),\n            column(widths[1], self.header, content, self.footer),\n        )",
  "def navset_pill_list(\n    *args: NavSetArg | MetadataNode,\n    id: Optional[str] = None,\n    selected: Optional[str] = None,\n    header: TagChild = None,\n    footer: TagChild = None,\n    well: bool = True,\n    widths: tuple[int, int] = (4, 8),\n) -> NavSet:\n    \"\"\"\n    Render nav items as a vertical pillset.\n\n    Parameters\n    ----------\n    *args\n        A collection of nav items (e.g., :func:`shiny.ui.nav`).\n    id\n        If provided, will create an input value that holds the currently selected nav\n        item.\n    selected\n        Choose a particular nav item to select by default value (should match it's\n        ``value``).\n    header\n        UI to display above the selected content.\n    footer\n        UI to display below the selected content.\n    well\n        ``True`` to place a well (gray rounded rectangle) around the navigation list.\n    widths\n        Column widths of the navigation list and tabset content areas respectively.\n\n    See Also\n    -------\n    ~shiny.ui.nav\n    ~shiny.ui.nav_menu\n    ~shiny.ui.nav_control\n    ~shiny.ui.nav_spacer\n    ~shiny.ui.navset_tab\n    ~shiny.ui.navset_card_tab\n    ~shiny.ui.navset_pill\n    ~shiny.ui.navset_card_pill\n    ~shiny.ui.navset_hidden\n    ~shiny.ui.navset_bar\n    ~shiny.ui.navset_hidden\n\n    Example\n    -------\n    See :func:`~shiny.ui.nav`\n    \"\"\"\n\n    return NavSetPillList(\n        *args,\n        ul_class=\"nav nav-pills nav-stacked\",\n        id=resolve_id_or_none(id),\n        selected=selected,\n        header=header,\n        footer=footer,\n        well=well,\n        widths=widths,\n    )",
  "class NavSetBar(NavSet):\n    title: TagChild\n    position: Literal[\"static-top\", \"fixed-top\", \"fixed-bottom\", \"sticky-top\"]\n    bg: Optional[str]\n    inverse: bool\n    collapsible: bool\n    fluid: bool\n\n    def __init__(\n        self,\n        *args: NavSetArg | MetadataNode,\n        ul_class: str,\n        title: TagChild,\n        id: Optional[str],\n        selected: Optional[str],\n        position: Literal[\n            \"static-top\", \"fixed-top\", \"fixed-bottom\", \"sticky-top\"\n        ] = \"static-top\",\n        header: TagChild = None,\n        footer: TagChild = None,\n        bg: Optional[str] = None,\n        # TODO: default to 'auto', like we have in R (parse color via webcolors?)\n        inverse: bool = False,\n        collapsible: bool = True,\n        fluid: bool = True,\n    ) -> None:\n        super().__init__(\n            *args,\n            ul_class=ul_class,\n            id=id,\n            selected=selected,\n            header=header,\n            footer=footer,\n        )\n        self.title = title\n        self.position = position\n        self.bg = bg\n        self.inverse = inverse\n        self.collapsible = collapsible\n        self.fluid = fluid\n\n    def layout(self, nav: TagChild, content: TagChild) -> TagList:\n        nav_container = div(\n            {\"class\": \"container-fluid\" if self.fluid else \"container\"},\n            tags.a({\"class\": \"navbar-brand\", \"href\": \"#\"}, self.title),\n        )\n        if self.collapsible:\n            collapse_id = \"navbar-collapse-\" + private_random_int(1000, 10000)\n            nav_container.append(\n                tags.button(\n                    tags.span(class_=\"navbar-toggler-icon\"),\n                    class_=\"navbar-toggler\",\n                    type=\"button\",\n                    data_bs_toggle=\"collapse\",\n                    data_bs_target=\"#\" + collapse_id,\n                    aria_controls=collapse_id,\n                    aria_expanded=\"false\",\n                    aria_label=\"Toggle navigation\",\n                )\n            )\n            nav = div(nav, id=collapse_id, class_=\"collapse navbar-collapse\")\n\n        nav_container.append(nav)\n        nav_final = tags.nav({\"class\": \"navbar navbar-expand-md\"}, nav_container)\n\n        if self.position != \"static-top\":\n            nav_final.add_class(self.position)\n\n        nav_final.add_class(f\"navbar-{'dark' if self.inverse else 'light'}\")\n\n        if self.bg:\n            nav_final.attrs[\"style\"] = \"background-color: \" + self.bg\n        else:\n            nav_final.add_class(f\"bg-{'dark' if self.inverse else 'light'}\")\n\n        return TagList(\n            nav_final,\n            div(\n                row(self.header) if self.header else None,\n                content,\n                row(self.footer) if self.footer else None,\n                class_=\"container-fluid\" if self.fluid else \"container\",\n            ),\n        )",
  "def navset_bar(\n    *args: NavSetArg | MetadataNode | Sequence[MetadataNode],\n    title: TagChild,\n    id: Optional[str] = None,\n    selected: Optional[str] = None,\n    position: Literal[\n        \"static-top\", \"fixed-top\", \"fixed-bottom\", \"sticky-top\"\n    ] = \"static-top\",\n    header: TagChild = None,\n    footer: TagChild = None,\n    bg: Optional[str] = None,\n    # TODO: default to 'auto', like we have in R (parse color via webcolors?)\n    inverse: bool = False,\n    collapsible: bool = True,\n    fluid: bool = True,\n) -> NavSetBar:\n    \"\"\"\n    Render nav items as a navbar.\n\n    Parameters\n    ----------\n    args\n        A collection of nav items (e.g., :func:`shiny.ui.nav`).\n    title\n        Title to display in the navbar.\n    id\n        If provided, will create an input value that holds the currently selected nav\n        item.\n    selected\n        Choose a particular nav item to select by default value (should match it's\n        ``value``).\n    position\n        Determines whether the navbar should be displayed at the top of the page with\n        normal scrolling behavior (\"static-top\"), pinned at the top (\"fixed-top\"), or\n        pinned at the bottom (\"fixed-bottom\"). Note that using \"fixed-top\" or\n        \"fixed-bottom\" will cause the navbar to overlay your body content, unless you\n        add padding (e.g., ``tags.style(\"body {padding-top: 70px;}\")``).\n    header\n        UI to display above the selected content.\n    footer\n        UI to display below the selected content.\n    bg\n        Background color of the navbar (a CSS color).\n    inverse\n        Either ``True`` for a light text color or ``False`` for a dark text color.\n    collapsible\n        ``True`` to automatically collapse the navigation elements into an expandable menu on mobile devices or narrow window widths.\n    fluid\n        ``True`` to use fluid layout; ``False`` to use fixed layout.\n\n    See Also\n    -------\n    ~shiny.ui.page_navbar\n    ~shiny.ui.nav\n    ~shiny.ui.nav_menu\n    ~shiny.ui.nav_control\n    ~shiny.ui.nav_spacer\n    ~shiny.ui.navset_tab\n    ~shiny.ui.navset_pill\n    ~shiny.ui.navset_card_tab\n    ~shiny.ui.navset_card_pill\n    ~shiny.ui.navset_hidden\n\n    Example\n    -------\n    See :func:`~shiny.ui.nav`.\n    \"\"\"\n\n    # If args contains any lists, flatten them into args.\n    new_args: Sequence[NavSetArg | MetadataNode] = []\n    for arg in args:\n        if isinstance(arg, (list, tuple)):\n            new_args.extend(arg)\n        else:\n            new_args.append(cast(NavSetArg, arg))\n\n    return NavSetBar(\n        *new_args,\n        ul_class=\"nav navbar-nav\",\n        id=resolve_id_or_none(id),\n        selected=selected,\n        title=title,\n        position=position,\n        header=header,\n        footer=footer,\n        bg=bg,\n        inverse=inverse,\n        collapsible=collapsible,\n        fluid=fluid,\n    )",
  "def render_navset(\n    *items: NavSetArg | MetadataNode,\n    ul_class: str,\n    id: Optional[str],\n    selected: Optional[str],\n    context: dict[str, Any],\n) -> tuple[Tag, Tag]:\n    tabsetid = private_random_int(1000, 10000)\n\n    # Separate MetadataNodes from NavSetArgs.\n    metadata_args = [x for x in items if isinstance(x, MetadataNode)]\n    navset_args = [x for x in items if not isinstance(x, MetadataNode)]\n\n    # If the user hasn't provided a selected value, use the first one\n    if selected is None:\n        for x in navset_args:\n            selected = x.get_value()\n            if selected is not None:\n                break\n\n    ul_tag = tags.ul(\n        bootstrap_deps(),\n        metadata_args,\n        class_=ul_class,\n        id=id,\n        data_tabsetid=tabsetid,\n    )\n    div_tag = div(class_=\"tab-content\", data_tabsetid=tabsetid)\n    for i, x in enumerate(navset_args):\n        nav, contents = x.resolve(\n            selected, {**context, \"tabsetid\": tabsetid, \"index\": i}\n        )\n        ul_tag.append(nav)\n        div_tag.append(contents)\n\n    return ul_tag, div_tag",
  "def card(*args: TagChild, header: TagChild = None, footer: TagChild = None) -> Tag:\n    if header:\n        header = div(header, class_=\"card-header\")\n    if footer:\n        footer = div(footer, class_=\"card-footer\")\n\n    return div(\n        header,\n        div(*args, class_=\"card-body\"),\n        footer,\n        bootstrap_deps(),\n        class_=\"card\",\n    )",
  "def navset_pill_card(\n    *args: NavSetArg,\n    id: Optional[str] = None,\n    selected: Optional[str] = None,\n    header: TagChild = None,\n    footer: TagChild = None,\n    placement: Literal[\"above\", \"below\"] = \"above\",\n) -> NavSetCard:\n    \"\"\"Deprecated. Please use `navset_card_pill()` instead of `navset_pill_card()`.\"\"\"\n    warn_deprecated(\n        \"`navset_pill_card()` is deprecated. \"\n        \"This method will be removed in a future version, \"\n        \"please use :func:`~shiny.ui.navset_card_pill` instead.\"\n    )\n    return navset_card_pill(\n        *args,\n        id=id,\n        selected=selected,\n        header=header,\n        footer=footer,\n        placement=placement,\n    )",
  "def navset_tab_card(\n    *args: NavSetArg,\n    id: Optional[str] = None,\n    selected: Optional[str] = None,\n    header: TagChild = None,\n    footer: TagChild = None,\n) -> NavSetCard:\n    \"\"\"Deprecated. Please use `navset_card_tab()` instead of `navset_tab_card()`.\"\"\"\n    warn_deprecated(\n        \"`navset_tab_card()` is deprecated. \"\n        \"This method will be removed in a future version, \"\n        \"please use :func:`~shiny.ui.navset_card_tab` instead.\"\n    )\n    return navset_card_tab(\n        *args,\n        id=id,\n        selected=selected,\n        header=header,\n        footer=footer,\n    )",
  "def __init__(self, nav: Tag, content: Optional[Tag] = None) -> None:\n        self.nav = nav\n        # nav_control()/nav_spacer() have None as their content\n        self.content = content",
  "def resolve(\n        self, selected: Optional[str], context: dict[str, Any]\n    ) -> tuple[TagChild, TagChild]:\n        # Nothing to do for nav_control()/nav_spacer()\n        if self.content is None:\n            return self.nav, None\n\n        # At least currently, in the case where both nav and content are tags\n        # (i.e., nav()), the nav always has a child <a> tag...I'm not sure if\n        # there's a way to statically type this\n        nav = copy.deepcopy(self.nav)\n        a_tag = cast(Tag, nav.children[0])\n        if context.get(\"is_menu\", False):\n            a_tag.add_class(\"dropdown-item\")\n        else:\n            a_tag.add_class(\"nav-link\")\n            nav.add_class(\"nav-item\")\n\n        # Hyperlink the nav to the content\n        content = copy.copy(self.content)\n        if \"tabsetid\" in context and \"index\" in context:\n            id = f\"tab-{context['tabsetid']}-{context['index']}\"\n            content.attrs[\"id\"] = id\n            a_tag.attrs[\"href\"] = f\"#{id}\"\n\n        # Mark the nav/content as active if it should be\n        if isinstance(selected, str) and selected == self.get_value():\n            content.add_class(\"active\")\n            a_tag.add_class(\"active\")\n\n        nav.children[0] = a_tag\n\n        return nav, content",
  "def get_value(self) -> Optional[str]:\n        if self.content is None:\n            return None\n        a_tag = cast(Tag, self.nav.children[0])\n        return a_tag.attrs.get(\"data-value\", None)",
  "def tagify(self) -> None:\n        raise NotImplementedError(\n            \"nav() items must appear within navset_*() container.\"\n        )",
  "def __init__(\n        self,\n        *args: NavSetArg | str,\n        title: TagChild,\n        value: str,\n        align: Literal[\"left\", \"right\"] = \"left\",\n    ) -> None:\n        self.nav_controls = [menu_string_as_nav(x) for x in args]\n        self.title = title\n        self.value = value\n        self.align = align",
  "def resolve(\n        self,\n        selected: Optional[str],\n        context: dict[str, Any],\n    ) -> tuple[TagChild, TagChild]:\n        nav, content = render_navset(\n            *self.nav_controls,\n            ul_class=f\"dropdown-menu {'dropdown-menu-right' if self.align == 'right' else ''}\",\n            id=None,\n            selected=selected,\n            context={**context, \"is_menu\": True},\n        )\n\n        active = False\n        for tab in content.children:\n            if isinstance(tab, Tag) and tab.has_class(\"active\"):\n                active = True\n                break\n\n        return (\n            tags.li(\n                tags.a(\n                    self.title,\n                    class_=f\"nav-link dropdown-toggle {'active' if active else ''}\",\n                    data_bs_toggle=\"dropdown\",\n                    # N.B. this value is only relevant for locating the insertion/removal\n                    # of items inside the nav container\n                    data_value=self.value,\n                    href=\"#\",\n                    role=\"button\",\n                ),\n                nav,\n                class_=\"nav-item dropdown\",\n            ),\n            content.children,\n        )",
  "def get_value(self) -> Optional[str]:\n        for x in self.nav_controls:\n            val = x.get_value()\n            if val:\n                return val\n        return None",
  "def tagify(self) -> None:\n        raise NotImplementedError(\"nav_menu() must appear within navset_*() container.\")",
  "def __init__(\n        self,\n        *args: NavSetArg | MetadataNode,\n        ul_class: str,\n        id: Optional[str],\n        selected: Optional[str],\n        header: TagChild = None,\n        footer: TagChild = None,\n    ) -> None:\n        self.args = args\n        self.ul_class = ul_class\n        self.id = id\n        self.selected = selected\n        self.header = header\n        self.footer = footer",
  "def tagify(self) -> TagList | Tag:\n        id = self.id\n        ul_class = self.ul_class\n        if id is not None:\n            ul_class += \" shiny-tab-input\"\n\n        nav, content = render_navset(\n            *self.args, ul_class=ul_class, id=id, selected=self.selected, context={}\n        )\n        return self.layout(nav, content).tagify()",
  "def layout(self, nav: TagChild, content: TagChild) -> TagList | Tag:\n        return TagList(nav, self.header, content, self.footer)",
  "def __init__(\n        self,\n        *args: NavSetArg,\n        ul_class: str,\n        id: Optional[str],\n        selected: Optional[str],\n        header: TagChild = None,\n        footer: TagChild = None,\n        placement: Literal[\"above\", \"below\"] = \"above\",\n    ) -> None:\n        super().__init__(\n            *args,\n            ul_class=ul_class,\n            id=id,\n            selected=selected,\n            header=header,\n            footer=footer,\n        )\n        self.placement = placement",
  "def layout(self, nav: TagChild, content: TagChild) -> Tag:\n        if self.placement == \"below\":\n            return card(self.header, content, self.footer, footer=nav)\n        else:\n            return card(self.header, content, self.footer, header=nav)",
  "def __init__(\n        self,\n        *args: NavSetArg | MetadataNode,\n        ul_class: str,\n        id: Optional[str],\n        selected: Optional[str],\n        header: TagChild = None,\n        footer: TagChild = None,\n        well: bool = True,\n        widths: tuple[int, int] = (4, 8),\n    ) -> None:\n        super().__init__(\n            *args,\n            ul_class=ul_class,\n            id=id,\n            selected=selected,\n            header=header,\n            footer=footer,\n        )\n        self.well = well\n        self.widths = widths",
  "def layout(self, nav: TagChild, content: TagChild) -> Tag:\n        widths = self.widths\n        return row(\n            column(widths[0], nav, class_=\"well\" if self.well else None),\n            column(widths[1], self.header, content, self.footer),\n        )",
  "def __init__(\n        self,\n        *args: NavSetArg | MetadataNode,\n        ul_class: str,\n        title: TagChild,\n        id: Optional[str],\n        selected: Optional[str],\n        position: Literal[\n            \"static-top\", \"fixed-top\", \"fixed-bottom\", \"sticky-top\"\n        ] = \"static-top\",\n        header: TagChild = None,\n        footer: TagChild = None,\n        bg: Optional[str] = None,\n        # TODO: default to 'auto', like we have in R (parse color via webcolors?)\n        inverse: bool = False,\n        collapsible: bool = True,\n        fluid: bool = True,\n    ) -> None:\n        super().__init__(\n            *args,\n            ul_class=ul_class,\n            id=id,\n            selected=selected,\n            header=header,\n            footer=footer,\n        )\n        self.title = title\n        self.position = position\n        self.bg = bg\n        self.inverse = inverse\n        self.collapsible = collapsible\n        self.fluid = fluid",
  "def layout(self, nav: TagChild, content: TagChild) -> TagList:\n        nav_container = div(\n            {\"class\": \"container-fluid\" if self.fluid else \"container\"},\n            tags.a({\"class\": \"navbar-brand\", \"href\": \"#\"}, self.title),\n        )\n        if self.collapsible:\n            collapse_id = \"navbar-collapse-\" + private_random_int(1000, 10000)\n            nav_container.append(\n                tags.button(\n                    tags.span(class_=\"navbar-toggler-icon\"),\n                    class_=\"navbar-toggler\",\n                    type=\"button\",\n                    data_bs_toggle=\"collapse\",\n                    data_bs_target=\"#\" + collapse_id,\n                    aria_controls=collapse_id,\n                    aria_expanded=\"false\",\n                    aria_label=\"Toggle navigation\",\n                )\n            )\n            nav = div(nav, id=collapse_id, class_=\"collapse navbar-collapse\")\n\n        nav_container.append(nav)\n        nav_final = tags.nav({\"class\": \"navbar navbar-expand-md\"}, nav_container)\n\n        if self.position != \"static-top\":\n            nav_final.add_class(self.position)\n\n        nav_final.add_class(f\"navbar-{'dark' if self.inverse else 'light'}\")\n\n        if self.bg:\n            nav_final.attrs[\"style\"] = \"background-color: \" + self.bg\n        else:\n            nav_final.add_class(f\"bg-{'dark' if self.inverse else 'light'}\")\n\n        return TagList(\n            nav_final,\n            div(\n                row(self.header) if self.header else None,\n                content,\n                row(self.footer) if self.footer else None,\n                class_=\"container-fluid\" if self.fluid else \"container\",\n            ),\n        )",
  "class Progress:\n    \"\"\"\n    Initialize a progress bar.\n\n    Parameters\n    ----------\n    min\n        The value that represents the starting point of the progress bar. Must be less\n        than ``max``.\n    max\n        The value that represents the end of the progress bar. Must be greater than\n        ``min``.\n    session\n        A :class:`~shiny.Session` instance. If not provided, it is inferred via\n        :func:`~shiny.session.get_current_session`.\n    \"\"\"\n\n    _style = \"notification\"\n\n    min: int\n    max: int\n    value: float | None\n\n    def __init__(\n        self, min: int = 0, max: int = 1, session: Optional[Session] = None\n    ) -> None:\n        self.min = min\n        self.max = max\n        self.value = None\n        self._id = rand_hex(8)\n        self._closed = False\n        self._session = require_active_session(session)\n\n        msg = {\"id\": self._id, \"style\": self._style}\n        self._session._send_progress(\"open\", msg)\n\n    def __enter__(self) -> \"Progress\":\n        return self\n\n    def __exit__(\n        self,\n        exctype: Optional[Type[BaseException]],\n        excinst: Optional[BaseException],\n        exctb: Optional[TracebackType],\n    ) -> None:\n        self.close()\n\n    def set(\n        self,\n        value: Optional[float] = None,\n        message: Optional[str] = None,\n        detail: Optional[str] = None,\n    ) -> None:\n        \"\"\"\n        Updates the progress panel. When called the first time, the progress panel is\n        displayed.\n\n        Parameters\n        ----------\n        self\n            The object instance\n        value\n            The value at which to set the progress bar, relative to ``min`` and ``max``.\n            ``None`` hides the progress bar, if it is currently visible.\n        message\n            The message to be displayed to the user or ``None`` to hide the current\n            message (if any).\n        detail\n            The detail message to be displayed to the user or ``None`` to hide the\n            current detail message (if any). The detail message will be shown with a\n            de-emphasized appearance relative to message.\n        \"\"\"\n\n        if self._closed:\n            warn(\"Attempting to set progress, but progress already closed.\")\n            return None\n\n        self.value = value\n        if value:\n            # Normalize value to number between 0 and 1\n            value = min(1, max(0, (value - self.min) / (self.max - self.min)))\n\n        msg = {\n            \"id\": self._id,\n            \"message\": message,\n            \"detail\": detail,\n            \"value\": value,\n            \"style\": self._style,\n        }\n\n        self._session._send_progress(\n            \"update\", {k: v for k, v in msg.items() if v is not None}\n        )\n\n    def inc(\n        self,\n        amount: float = 0.1,\n        message: Optional[str] = None,\n        detail: Optional[str] = None,\n    ) -> None:\n        \"\"\"\n        Increment the progress bar.\n\n        Like ``set``, this updates the progress panel. The difference is that ``inc``\n        increases the progress bar by amount, instead of setting it to a specific value.\n\n        Parameters\n        ----------\n        self\n            The object instance\n        amount\n            The amount to increment in progress.\n        message\n            The message to be displayed to the user or ``None`` to hide the current\n            message (if any).\n        detail\n            The detail message to be displayed to the user or ``None`` to hide the current\n            detail message (if any). The detail message will be shown with a\n            de-emphasized appearance relative to message.\n        \"\"\"\n\n        if self.value is None:\n            self.value = self.min\n\n        value = min(self.value + amount, self.max)\n        self.set(value, message, detail)\n\n    def close(self) -> None:\n        \"\"\"\n        Close the progress bar. You can also use the Progress object as a context\n        manager, which will cause the progress bar to close on exit.\n\n        Parameters\n        ----------\n        self\n            The object instance\n\n        Note\n        ----\n        Removes the progress panel. Future calls to set and close will be ignored.\n        \"\"\"\n        if self._closed:\n            warn(\"Attempting to close progress, but progress already closed.\")\n            return None\n\n        self._session._send_progress(\"close\", {\"id\": self._id, \"style\": self._style})\n        self._closed = True",
  "def __init__(\n        self, min: int = 0, max: int = 1, session: Optional[Session] = None\n    ) -> None:\n        self.min = min\n        self.max = max\n        self.value = None\n        self._id = rand_hex(8)\n        self._closed = False\n        self._session = require_active_session(session)\n\n        msg = {\"id\": self._id, \"style\": self._style}\n        self._session._send_progress(\"open\", msg)",
  "def __enter__(self) -> \"Progress\":\n        return self",
  "def __exit__(\n        self,\n        exctype: Optional[Type[BaseException]],\n        excinst: Optional[BaseException],\n        exctb: Optional[TracebackType],\n    ) -> None:\n        self.close()",
  "def set(\n        self,\n        value: Optional[float] = None,\n        message: Optional[str] = None,\n        detail: Optional[str] = None,\n    ) -> None:\n        \"\"\"\n        Updates the progress panel. When called the first time, the progress panel is\n        displayed.\n\n        Parameters\n        ----------\n        self\n            The object instance\n        value\n            The value at which to set the progress bar, relative to ``min`` and ``max``.\n            ``None`` hides the progress bar, if it is currently visible.\n        message\n            The message to be displayed to the user or ``None`` to hide the current\n            message (if any).\n        detail\n            The detail message to be displayed to the user or ``None`` to hide the\n            current detail message (if any). The detail message will be shown with a\n            de-emphasized appearance relative to message.\n        \"\"\"\n\n        if self._closed:\n            warn(\"Attempting to set progress, but progress already closed.\")\n            return None\n\n        self.value = value\n        if value:\n            # Normalize value to number between 0 and 1\n            value = min(1, max(0, (value - self.min) / (self.max - self.min)))\n\n        msg = {\n            \"id\": self._id,\n            \"message\": message,\n            \"detail\": detail,\n            \"value\": value,\n            \"style\": self._style,\n        }\n\n        self._session._send_progress(\n            \"update\", {k: v for k, v in msg.items() if v is not None}\n        )",
  "def inc(\n        self,\n        amount: float = 0.1,\n        message: Optional[str] = None,\n        detail: Optional[str] = None,\n    ) -> None:\n        \"\"\"\n        Increment the progress bar.\n\n        Like ``set``, this updates the progress panel. The difference is that ``inc``\n        increases the progress bar by amount, instead of setting it to a specific value.\n\n        Parameters\n        ----------\n        self\n            The object instance\n        amount\n            The amount to increment in progress.\n        message\n            The message to be displayed to the user or ``None`` to hide the current\n            message (if any).\n        detail\n            The detail message to be displayed to the user or ``None`` to hide the current\n            detail message (if any). The detail message will be shown with a\n            de-emphasized appearance relative to message.\n        \"\"\"\n\n        if self.value is None:\n            self.value = self.min\n\n        value = min(self.value + amount, self.max)\n        self.set(value, message, detail)",
  "def close(self) -> None:\n        \"\"\"\n        Close the progress bar. You can also use the Progress object as a context\n        manager, which will cause the progress bar to close on exit.\n\n        Parameters\n        ----------\n        self\n            The object instance\n\n        Note\n        ----\n        Removes the progress panel. Future calls to set and close will be ignored.\n        \"\"\"\n        if self._closed:\n            warn(\"Attempting to close progress, but progress already closed.\")\n            return None\n\n        self._session._send_progress(\"close\", {\"id\": self._id, \"style\": self._style})\n        self._closed = True",
  "def input_selectize(\n    id: str,\n    label: TagChild,\n    choices: SelectChoicesArg,\n    *,\n    selected: Optional[str | list[str]] = None,\n    multiple: bool = False,\n    width: Optional[str] = None,\n) -> Tag:\n    \"\"\"\n    Create a select list that can be used to choose a single or multiple items from a\n    list of values.\n\n    Parameters\n    ----------\n    id\n        An input id.\n    label\n        An input label.\n    choices\n        Either a list of choices or a dictionary mapping choice values to labels. Note\n        that if a dictionary is provided, the keys are used as the (input) values so\n        that the dictionary values can hold HTML labels. A dictionary of dictionaries is\n        also supported, and in that case, the top-level keys are treated as\n        ``<optgroup>`` labels.\n    selected\n        The values that should be initially selected, if any.\n    multiple\n        Is selection of multiple items allowed?\n    width\n        The CSS width, e.g. '400px', or '100%'\n\n    Returns\n    -------\n    :\n        A UI element.\n\n    Notes\n    ------\n    ::: {.callout-note title=\"Server value\"}\n    A list of strings, usually of length 1, with the value of the selected items. When\n    ``multiple=True`` and nothing is selected, this value will be ``None``.\n    :::\n\n    See Also\n    -------\n    ~shiny.ui.input_select ~shiny.ui.input_radio_buttons ~shiny.ui.input_checkbox_group\n    \"\"\"\n\n    return input_select(\n        id,\n        label,\n        choices,\n        selected=selected,\n        multiple=multiple,\n        selectize=True,\n        width=width,\n    )",
  "def input_select(\n    id: str,\n    label: TagChild,\n    choices: SelectChoicesArg,\n    *,\n    selected: Optional[str | list[str]] = None,\n    multiple: bool = False,\n    selectize: bool = False,\n    width: Optional[str] = None,\n    size: Optional[str] = None,\n) -> Tag:\n    \"\"\"\n    Create a select list that can be used to choose a single or multiple items from a\n    list of values.\n\n    Parameters\n    ----------\n    id\n        An input id.\n    label\n        An input label.\n    choices\n        Either a list of choices or a dictionary mapping choice values to labels. Note\n        that if a dictionary is provided, the keys are used as the (input) values so\n        that the dictionary values can hold HTML labels. A dictionary of dictionaries is\n        also supported, and in that case, the top-level keys are treated as\n        ``<optgroup>`` labels.\n    selected\n        The values that should be initially selected, if any.\n    multiple\n        Is selection of multiple items allowed?\n    selectize\n        Whether to use selectize.js or not.\n    width\n        The CSS width, e.g. '400px', or '100%'\n    size\n        Number of items to show in the selection box; a larger number will result in a\n        taller box. Normally, when ``multiple=False``, a select input will be a\n        drop-down list, but when size is set, it will be a box instead.\n\n    Returns\n    -------\n    :\n        A UI element.\n\n    Notes\n    ------\n    ::: {.callout-note title=\"Server value\"}\n    A list of strings, usually of length 1, with the value of the selected items. When\n    ``multiple=True`` and nothing is selected, this value will be ``None``.\n    :::\n\n    See Also\n    -------\n    ~shiny.ui.input_selectize\n    ~shiny.ui.update_select\n    ~shiny.ui.input_radio_buttons\n    ~shiny.ui.input_checkbox_group\n    \"\"\"\n\n    choices_ = _normalize_choices(choices)\n    if selected is None and not multiple:\n        selected = _find_first_option(choices_)\n\n    choices_tags = _render_choices(choices_, selected)\n\n    resolved_id = resolve_id(id)\n\n    return div(\n        shiny_input_label(resolved_id, label),\n        div(\n            tags.select(\n                *choices_tags,\n                {\"class\": \"shiny-input-select\"},\n                class_=None if selectize else \"form-select\",\n                id=resolved_id,\n                multiple=multiple,\n                size=size,\n            ),\n            (\n                TagList(\n                    tags.script(\"{}\", type=\"application/json\", data_for=resolved_id),\n                    selectize_deps(),\n                )\n                if selectize\n                else None\n            ),\n        ),\n        class_=\"form-group shiny-input-container\",\n        style=css(width=width),\n    )",
  "def _normalize_choices(x: SelectChoicesArg) -> _SelectChoices:\n    if x is None:\n        raise TypeError(\"`choices` must be a list, tuple, or dict.\")\n    elif isinstance(x, (list, tuple)):\n        return {k: k for k in x}\n    else:\n        return x",
  "def _render_choices(\n    x: _SelectChoices, selected: Optional[str | list[str]] = None\n) -> TagList:\n    result = TagList()\n\n    if x is None:\n        return result\n\n    for k, v in x.items():\n        if isinstance(v, Mapping):\n            result.append(\n                tags.optgroup(\n                    *(_render_choices(cast(_SelectChoices, v), selected)), label=k\n                )\n            )\n        else:\n            is_selected = False\n            if isinstance(selected, list):\n                is_selected = k in selected\n            else:\n                is_selected = k == selected\n\n            result.append(tags.option(v, value=k, selected=is_selected))\n\n    return result",
  "def _find_first_option(x: _SelectChoices) -> Optional[str]:\n    if x is None:\n        return None\n\n    for k, v in x.items():\n        if isinstance(v, dict):\n            result = _find_first_option(cast(_SelectChoices, v))\n            if result is not None:\n                return result\n        else:\n            return k\n\n    return None",
  "def nav_spacer_deps() -> list[HTMLDependency]:\n    return [nav_spacer_dependency()]",
  "def bootstrap_deps() -> list[HTMLDependency]:\n    dep = HTMLDependency(\n        name=\"bootstrap\",\n        version=bootstrap_version,\n        source={\"package\": \"shiny\", \"subdir\": \"www/shared/bootstrap/\"},\n        script={\"src\": \"bootstrap.bundle.min.js\"},\n        stylesheet={\"href\": \"bootstrap.min.css\"},\n        meta={\"name\": \"viewport\", \"content\": \"width=device-width, initial-scale=1\"},\n    )\n    deps = [jquery_deps(), dep]\n    return deps",
  "def ionrangeslider_deps() -> list[HTMLDependency]:\n    return [\n        HTMLDependency(\n            name=\"ionrangeslider\",\n            version=\"2.3.1\",\n            source={\"package\": \"shiny\", \"subdir\": \"www/shared/ionrangeslider/\"},\n            script={\"src\": \"js/ion.rangeSlider.min.js\"},\n        ),\n        HTMLDependency(\n            name=\"preset-shiny-ionrangeslider\",\n            version=shiny_html_deps,\n            source={\"package\": \"shiny\", \"subdir\": \"www/shared/ionrangeslider/\"},\n            stylesheet={\"href\": \"css/ion.rangeSlider.css\"},\n        ),\n        HTMLDependency(\n            name=\"strftime\",\n            version=\"0.9.2\",\n            source={\"package\": \"shiny\", \"subdir\": \"www/shared/strftime/\"},\n            script={\"src\": \"strftime-min.js\"},\n        ),\n    ]",
  "def datepicker_deps() -> HTMLDependency:\n    return HTMLDependency(\n        name=\"bootstrap-datepicker\",\n        version=\"1.9.0\",\n        source={\"package\": \"shiny\", \"subdir\": \"www/shared/datepicker/\"},\n        # TODO: pre-compile the Bootstrap 5 version?\n        stylesheet={\"href\": \"css/bootstrap-datepicker3.min.css\"},\n        script={\"src\": \"js/bootstrap-datepicker.min.js\"},\n        # Need to enable noConflict mode. See #1346.\n        head=HTML(\n            \"<script>(function() { var datepicker = $.fn.datepicker.noConflict(); $.fn.bsDatepicker = datepicker; })();</script>\"\n        ),\n    )",
  "def selectize_deps() -> HTMLDependency:\n    return HTMLDependency(\n        name=\"selectize\",\n        version=\"0.12.6\",\n        source={\"package\": \"shiny\", \"subdir\": \"www/shared/selectize/\"},\n        script=[\n            {\"src\": \"js/selectize.min.js\"},\n            {\"src\": \"accessibility/js/selectize-plugin-a11y.min.js\"},\n        ],\n        # TODO: pre-compile the Bootstrap 5 version?\n        stylesheet={\"href\": \"css/selectize.bootstrap3.css\"},\n    )",
  "def jqui_deps() -> HTMLDependency:\n    return HTMLDependency(\n        name=\"jquery-ui\",\n        version=\"1.12.1\",\n        source={\"package\": \"shiny\", \"subdir\": \"www/shared/jqueryui/\"},\n        script={\"src\": \"jquery-ui.min.js\"},\n        stylesheet={\"href\": \"jquery-ui.min.css\"},\n    )",
  "def markdown(\n    text: str, *, render_func: Optional[Callable[[str], str]] = None, **kwargs: object\n) -> HTML:\n    \"\"\"\n    Convert a string of markdown to :func:`ui.HTML`.\n\n    Parameters\n    ----------\n    text\n        A string of text containing markdown.\n    render_func\n        A function (with at least 1 argument) which accepts a string of markdown and\n        returns a string of HTML. By default, a customized instance of the\n        :class:`MarkdownIt` class (which supports Github-flavored markdown) from the\n        ``markdown-it`` package is used.\n    **kwargs\n        Additional keyword arguments passed to the ``render_func``.\n\n    Returns\n    -------\n    :\n        An :func:`ui.HTML` string of the rendered markdown.\n\n    Note\n    ----\n    Use :func:`ui.include_markdown` instead if you want to include local images (or\n    other files) in the markdown.\n\n    See Also\n    --------\n    :func:`ui.include_markdown`\n    \"\"\"\n\n    if render_func is None:\n        render_func = default_md_renderer()\n\n    html = render_func(textwrap.dedent(text), **kwargs)\n\n    return HTML(html)",
  "def default_md_renderer(\n    preset: Literal[\"commonmark\", \"gfm\"] = \"gfm\"\n) -> Callable[[str], str]:\n    try:\n        from markdown_it.main import MarkdownIt\n    except ModuleNotFoundError:\n        raise ModuleNotFoundError(\n            \"The default markdown parser requires the markdown-it-py package\"\n            \" to be installed. Install it with `pip install markdown-it`.\"\n        )\n\n    if preset == \"commonmark\":\n        parser = MarkdownIt(\"commonmark\")\n    else:\n        try:\n            importlib.import_module(name=\".\", package=\"linkify_it\")\n        except ModuleNotFoundError:\n            warnings.warn(\n                \"The 'autolinking' feature of GitHub flavored markdown requires the \"\n                \"linkify-it package. Install it with `pip install linkify-it`.\",\n                stacklevel=2,\n            )\n        # Inspired by MyST-Parser's gfm-only option\n        # https://github.com/executablebooks/MyST-Parser/blob/ce1245b25/myst_parser/main.py#L257-L269\n        parser = MarkdownIt(\"commonmark\", {\"linkify\": True})\n        parser.enable([\"table\", \"linkify\", \"strikethrough\"])\n\n        try:\n            from mdit_py_plugins.tasklists import tasklists_plugin\n\n            parser.use(tasklists_plugin)  # type: ignore\n        except ModuleNotFoundError:\n            warnings.warn(\n                \"The 'tasklists' feature of GitHub flavored markdown requires the \"\n                \"mdit_py_plugins package. Install it with `pip install mdit_py_plugins`.\",\n                stacklevel=2,\n            )\n\n    def _render(text: str) -> str:\n        return parser.render(text)  # type: ignore\n\n    return _render",
  "def _render(text: str) -> str:\n        return parser.render(text)",
  "def update_action_button(\n    id: str,\n    *,\n    label: Optional[str] = None,\n    icon: TagChild = None,\n    session: Optional[Session] = None,\n) -> None:\n    \"\"\"\n    Change the label and/or icon of an action button on the client.\n\n    Parameters\n    ----------\n    id\n        An input id.\n    label\n        An input label.\n    icon\n        An icon to appear inline with the button/link.\n    session\n        A :class:`~shiny.Session` instance. If not provided, it is inferred via\n       :func:`~shiny.session.get_current_session`.\n\n    Note\n    ----\n    {note}\n\n    See Also\n    -------\n    :func:`~shiny.input_action_button`\n    \"\"\"\n\n    session = require_active_session(session)\n    # TODO: supporting a TagChild for label would require changes to shiny.js\n    # https://github.com/rstudio/shiny/issues/1140\n    msg = {\"label\": label, \"icon\": session._process_ui(icon)[\"html\"] if icon else None}\n    session.send_input_message(id, drop_none(msg))",
  "def update_checkbox(\n    id: str,\n    *,\n    label: Optional[str] = None,\n    value: Optional[bool] = None,\n    session: Optional[Session] = None,\n) -> None:\n    \"\"\"\n    Change the value of a checkbox input on the client.\n\n    Parameters\n    ----------\n    id\n        An input id.\n    label\n        An input label.\n    value\n        A new value.\n    session\n        A :class:`~shiny.Session` instance. If not provided, it is inferred via\n        :func:`~shiny.session.get_current_session`.\n\n    Note\n    ----\n    {note}\n\n    See Also\n    -------\n    ~shiny.ui.input_checkbox\n    \"\"\"\n\n    session = require_active_session(session)\n    msg = {\"label\": label, \"value\": value}\n    session.send_input_message(id, drop_none(msg))",
  "def update_switch(\n    id: str,\n    *,\n    label: Optional[str] = None,\n    value: Optional[bool] = None,\n    session: Optional[Session] = None,\n) -> None:\n    \"\"\"\n    Change the value of a switch input on the client.\n\n    Parameters\n    ----------\n    id\n        An input id.\n    label\n        An input label.\n    value\n        A new value.\n    session\n        A :class:`~shiny.Session` instance. If not provided, it is inferred via\n        :func:`~shiny.session.get_current_session`.\n\n    Note\n    ----\n    {note}\n\n    See Also\n    -------\n    ~shiny.ui.input_switch\n    \"\"\"\n\n    session = require_active_session(session)\n    msg = {\"label\": label, \"value\": value}\n    session.send_input_message(id, drop_none(msg))",
  "def update_checkbox_group(\n    id: str,\n    *,\n    label: Optional[str] = None,\n    choices: Optional[ChoicesArg] = None,\n    selected: Optional[str | list[str] | tuple[str, ...]] = None,\n    inline: bool = False,\n    session: Optional[Session] = None,\n) -> None:\n    \"\"\"\n    Change the value of a checkbox group input on the client.\n\n    Parameters\n    ----------\n    id\n        An input id.\n    label\n        An input label.\n    choices\n        Either a list of choices or a dictionary mapping choice values to labels. Note\n        that if a dictionary is provided, the keys are used as the (input) values so\n        that the dictionary values can hold HTML labels.\n    selected\n        The values that should be initially selected, if any.\n    inline\n        If ``True``, the result is displayed inline\n    session\n        A :class:`~shiny.Session` instance. If not provided, it is inferred via\n        :func:`~shiny.session.get_current_session`.\n\n    Note\n    ----\n    {note}\n\n    See Also\n    -------\n    ~shiny.ui.input_checkbox_group\n    \"\"\"\n\n    _update_choice_input(\n        id=resolve_id(id),\n        type=\"checkbox\",\n        label=label,\n        choices=choices,\n        selected=selected,\n        inline=inline,\n        session=session,\n    )",
  "def update_radio_buttons(\n    id: str,\n    *,\n    label: Optional[str] = None,\n    choices: Optional[ChoicesArg] = None,\n    selected: Optional[str] = None,\n    inline: bool = False,\n    session: Optional[Session] = None,\n) -> None:\n    \"\"\"\n    Change the value of a radio input on the client.\n\n    Parameters\n    ----------\n    id\n        An input id.\n    label\n        An input label.\n    choices\n        Either a list of choices or a dictionary mapping choice values to labels. Note\n        that if a dictionary is provided, the keys are used as the (input) values so\n        that the dictionary values can hold HTML labels.\n    selected\n        The values that should be initially selected, if any.\n    inline\n        If ``True```, the result is displayed inline\n    session\n        A :class:`~shiny.Session` instance. If not provided, it is inferred via\n        :func:`~shiny.session.get_current_session`.\n\n    Note\n    ----\n    {note}\n\n    See Also\n    -------\n    ~shiny.ui.input_radio_buttons\n    \"\"\"\n\n    _update_choice_input(\n        id=resolve_id(id),\n        type=\"radio\",\n        label=label,\n        choices=choices,\n        selected=selected,\n        inline=inline,\n        session=session,\n    )",
  "def _update_choice_input(\n    id: str,\n    *,\n    type: Literal[\"checkbox\", \"radio\"],\n    label: Optional[str] = None,\n    choices: Optional[ChoicesArg] = None,\n    selected: Optional[str | list[str] | tuple[str, ...]] = None,\n    inline: bool = False,\n    session: Optional[Session] = None,\n) -> None:\n    session = require_active_session(session)\n    options = None\n    if choices is not None:\n        # https://github.com/posit-dev/py-shiny/issues/708#issuecomment-1696352934\n        with session_context(session):\n            resolved_id = resolve_id(id)\n\n        opts = _generate_options(\n            id=resolved_id,\n            type=type,\n            choices=choices,\n            selected=selected,\n            inline=inline,\n        )\n        options = session._process_ui(opts)[\"html\"]\n    msg = {\"label\": label, \"options\": options, \"value\": selected}\n    session.send_input_message(id, drop_none(msg))",
  "def update_date(\n    id: str,\n    *,\n    label: Optional[str] = None,\n    value: Optional[date | str] = None,\n    min: Optional[date | str] = None,\n    max: Optional[date | str] = None,\n    session: Optional[Session] = None,\n) -> None:\n    \"\"\"\n    Change the value of a date input on the client.\n\n    Parameters\n    ----------\n    id\n        An input id.\n    label\n        An input label.\n    value\n        The starting date. Either a `date()` object, or a string in yyyy-mm-dd format.\n        If ``None`` (the default), will use the current date in the client's time zone.\n    min\n        The minimum allowed value.\n    max\n        The maximum allowed value.\n    session\n        A :class:`~shiny.Session` instance. If not provided, it is inferred via\n        :func:`~shiny.session.get_current_session`.\n\n    Note\n    ----\n    {note}\n\n    See Also\n    -------\n    ~shiny.ui.input_date\n    \"\"\"\n\n    session = require_active_session(session)\n    msg = {\n        \"label\": label,\n        \"value\": _as_date_attr(value),\n        \"min\": _as_date_attr(min),\n        \"max\": _as_date_attr(max),\n    }\n    session.send_input_message(id, drop_none(msg))",
  "def update_date_range(\n    id: str,\n    *,\n    label: Optional[str] = None,\n    start: Optional[date | str] = None,\n    end: Optional[date | str] = None,\n    min: Optional[date | str] = None,\n    max: Optional[date | str] = None,\n    session: Optional[Session] = None,\n) -> None:\n    \"\"\"\n    Change the start and end values of a date range input on the client.\n\n    Parameters\n    ----------\n    id\n        An input id.\n    label\n        An input label.\n    start\n        The initial start date. Either a :class:`~datetime.date` object, or a string in\n        yyyy-mm-dd format. If ``None`` (the default), will use the current date in the\n        client's time zone.\n    end\n        The initial end date. Either a :class:`~datetime.date` object, or a string in\n        yyyy-mm-dd format. If ``None`` (the default), will use the current date in the\n        client's time zone.\n    min\n        The minimum allowed value.\n    max\n        The maximum allowed value.\n    session\n        A :class:`~shiny.Session` instance. If not provided, it is inferred via\n        :func:`~shiny.session.get_current_session`.\n\n    Note\n    ----\n    {note}\n\n    See Also\n    -------\n    ~shiny.ui.input_date_range\n    \"\"\"\n\n    session = require_active_session(session)\n    value = {\"start\": _as_date_attr(start), \"end\": _as_date_attr(end)}\n    msg = {\n        \"label\": label,\n        \"value\": drop_none(value),\n        \"min\": _as_date_attr(min),\n        \"max\": _as_date_attr(max),\n    }\n    session.send_input_message(id, drop_none(msg))",
  "def update_numeric(\n    id: str,\n    *,\n    label: Optional[str] = None,\n    value: Optional[float] = None,\n    min: Optional[float] = None,\n    max: Optional[float] = None,\n    step: Optional[float] = None,\n    session: Optional[Session] = None,\n) -> None:\n    \"\"\"\n    Change the value of a number input on the client.\n\n    Parameters\n    ----------\n    id\n        An input id.\n    label\n        An input label.\n    value\n        A new value.\n    min\n        The minimum allowed value.\n    max\n        The maximum allowed value.\n    step\n        Interval to use when stepping between min and max.\n    session\n        The :class:`~shiny.Session` object passed to the server function of a :func:`~shiny.App`.\n\n    Note\n    ----\n    {note}\n\n    See Also\n    -------\n    ~shiny.ui.input_numeric\n    \"\"\"\n\n    session = require_active_session(session)\n    msg = {\n        \"label\": label,\n        \"value\": value,\n        \"min\": min,\n        \"max\": max,\n        \"step\": step,\n    }\n    session.send_input_message(id, drop_none(msg))",
  "def update_select(\n    id: str,\n    *,\n    label: Optional[str] = None,\n    choices: Optional[SelectChoicesArg] = None,\n    selected: Optional[str | list[str]] = None,\n    session: Optional[Session] = None,\n) -> None:\n    \"\"\"\n    Change the value of a select input on the client.\n\n    Parameters\n    ----------\n    id\n        An input id.\n    label\n        An input label.\n    choices\n        Either a list of choices or a dictionary mapping choice values to labels. Note\n        that if a dictionary is provided, the keys are used as the (input) values so\n        that the dictionary values can hold HTML labels. A dictionary of dictionaries is\n        also supported, and in that case, the top-level keys are treated as\n        ``<optgroup>`` labels.\n    selected\n        The values that should be initially selected, if any.\n    session\n        A :class:`~shiny.Session` instance. If not provided, it is inferred via\n        :func:`~shiny.session.get_current_session`.\n\n    Note\n    ----\n    {note}\n\n    See Also\n    -------\n    ~shiny.ui.input_select\n    ~shiny.ui.update_selectize\n    \"\"\"\n\n    session = require_active_session(session)\n\n    selected_values = selected\n    if isinstance(selected, str):\n        selected_values = [selected]\n\n    if choices is None:\n        options = None\n    else:\n        option_tags = _render_choices(_normalize_choices(choices), selected)\n        # Typing problem due to a bug in pylance:\n        # https://github.com/microsoft/pylance-release/issues/2377\n        options = session._process_ui(option_tags)[\"html\"]  # type: ignore\n\n    msg = {\n        \"label\": label,\n        \"options\": options,\n        \"value\": selected_values,\n    }\n    session.send_input_message(id, drop_none(msg))",
  "class FlatSelectChoice(TypedDict):\n    label: str\n    value: str\n    optgroup: NotRequired[str]",
  "def update_selectize(\n    id: str,\n    *,\n    label: Optional[str] = None,\n    choices: Optional[SelectChoicesArg] = None,\n    selected: Optional[str | list[str]] = None,\n    # TODO: we need the equivalent of base::I()/htmlwidgets::JS() for marking strings as strings to be evaluated\n    # options: Optional[Dict[str, str]] = None,\n    server: bool = False,\n    session: Optional[Session] = None,\n) -> None:\n    \"\"\"\n    Change the value of a selectize.js powered input on the client.\n\n    Parameters\n    ----------\n    id\n        An input id.\n    label\n        An input label.\n    choices\n        Either a list of choices or a dictionary mapping choice values to labels. Note\n        that if a dictionary is provided, the keys are used as the (input) values so\n        that the dictionary values can hold HTML labels. A dictionary of dictionaries is\n        also supported, and in that case, the top-level keys are treated as\n        ``<optgroup>`` labels.\n    selected\n        The values that should be initially selected, if any.\n    server\n        Whether to store choices on the server side, and load the select options\n        dynamically on searching, instead of writing all choices into the page at once\n        (i.e., only use the client-side version of selectize.js)\n    session\n        A :class:`~shiny.Session` instance. If not provided, it is inferred via\n        :func:`~shiny.session.get_current_session`.\n\n    Note\n    ----\n    {note}\n\n    See Also\n    -------\n    ~shiny.ui.input_selectize\n    \"\"\"\n\n    session = require_active_session(session)\n\n    if not server:\n        return update_select(\n            id, label=label, choices=choices, selected=selected, session=session\n        )\n\n    # Transform choices to a list of dicts (this is the form the client wants)\n    # [{\"label\": \"Foo\", \"value\": \"foo\", \"optgroup\": \"foo\"}, ...]\n    flat_choices: list[FlatSelectChoice] = []\n    if choices is not None:\n        for k, v in _normalize_choices(choices).items():\n            if not isinstance(v, Mapping):\n                flat_choices.append(\n                    FlatSelectChoice(value=k, label=session._process_ui(v)[\"html\"])\n                )\n            else:  # The optgroup case\n                flat_choices.extend(\n                    [\n                        FlatSelectChoice(\n                            optgroup=k, value=k2, label=session._process_ui(v2)[\"html\"]\n                        )\n                        for (k2, v2) in v.items()\n                    ]\n                )\n\n    selected_values = selected\n    if isinstance(selected, str):\n        selected_values = [selected]\n\n    # Find any selected choices now so we have them ready to send to the client\n    if selected_values is None:\n        selected_choices = []\n    else:\n        selected_choices = [x for x in flat_choices if x[\"value\"] in selected_values]\n\n    def selectize_choices_json(request: Request) -> Response:\n        if choices is None:\n            return Response([], status_code=200)\n\n        # N.B. relevant query parameters that shiny.js setscan be found here\n        # https://github.com/rstudio/shiny/blob/78d77ce/srcts/src/bindings/input/selectInput.ts#L138-L142\n        qparams = request.query_params\n\n        # The (space-separated) input value(s) in lower-case (for case-insensitive matching)\n        keywords = set(re.split(r\"\\s+\", qparams.get(\"query\", \"\").lower()))\n\n        # Also note that the user (at least someday) has the ability to customize any of\n        # these options https://github.com/rstudio/shiny/blob/78d77ce/srcts/src/bindings/input/selectInput.ts#L231\n        #\n        # For most options this is fine, but searchField/valueField require some validation.\n\n        # i.e. maxOptions (defaults to 1000)\n        max_options = int(qparams.get(\"maxop\", 1000))\n\n        # i.e. searchConjunction (defaults to 'and', but can also be 'or')\n        conjunction = any if qparams.get(\"conju\", \"and\") == \"or\" else all\n\n        # i.e. searchFields (defaults to ['label'])\n        search_fields: list[str] = json.loads(qparams.get(\"field\", \"['label']\"))\n        if len(search_fields) == 0:\n            raise ValueError(\"The selectize.js searchFields option must be non-empty\")\n\n        # For some odd (probably wrong) reason, shiny.js is wrapping searchFields in an additional array\n        # https://github.com/rstudio/shiny/blob/78d77ce/srcts/src/bindings/input/selectInput.ts#L139\n        # https://github.com/rstudio/shiny/blob/78d77c/R/update-input.R#L801\n        if isinstance(search_fields[0], list):\n            search_fields = search_fields[0]\n\n        if set(search_fields).difference(set([\"label\", \"value\", \"optgroup\"])):\n            raise ValueError(\n                \"The selectize.js searchFields option must contain some combination of: \"\n                + \"'label', 'value', and 'optgroup'\"\n            )\n\n        # i.e. valueField (defaults to 'value')\n        if qparams.get(\"value\", \"value\") != \"value\":\n            raise ValueError(\n                \"The selectize.js valueField option must be set to 'value'\"\n            )\n\n        filtered_choices: list[FlatSelectChoice] = []\n        for choice in flat_choices:\n            # Short-circuit if we've reached the max number of options\n            if (len(filtered_choices) + len(selected_choices)) > max_options:\n                break\n\n            # If this is a selected value, *don't* add it here (add after this loop)\n            if selected_values and choice[\"value\"] in selected_values:\n                continue\n\n            match = False\n            for f in search_fields:\n                val: Optional[str] = choice.get(f, None)\n                # optgroup could be requested, but not necessarily present/relevant\n                if val is None:\n                    continue\n                if conjunction([x in val.lower() for x in keywords]):\n                    match = True\n\n            if match:\n                filtered_choices.append(choice)\n\n        if selected_choices:\n            filtered_choices.extend(selected_choices)\n\n        return JSONResponse(filtered_choices, status_code=200)\n\n    msg = {\n        \"label\": label,\n        \"value\": selected_values,\n        \"url\": session.dynamic_route(f\"update_selectize_{id}\", selectize_choices_json),\n    }\n\n    return session.send_input_message(id, drop_none(msg))",
  "def update_slider(\n    id: str,\n    *,\n    label: Optional[str] = None,\n    value: Optional[SliderValueArg | tuple[SliderValueArg, SliderValueArg]] = None,\n    min: Optional[SliderValueArg] = None,\n    max: Optional[SliderValueArg] = None,\n    step: Optional[SliderStepArg] = None,\n    time_format: Optional[str] = None,\n    timezone: Optional[str] = None,\n    session: Optional[Session] = None,\n) -> None:\n    \"\"\"\n    Change the value of a slider input on the client.\n\n    Parameters\n    ----------\n    id\n        An input id.\n    label\n        An input label.\n    value\n        A new value.\n    min\n        The minimum allowed value.\n    max\n        The maximum allowed value.\n    step\n        Specifies the interval between each selectable value on the slider. Either\n        ``None`` (the default), which uses a heuristic to determine the step size or a\n        single number. If the values are dates, step is in days; if the values are\n        date-times, step is in seconds.\n    time_format\n        Only used if the slider values are :class:`~datetime.date` or\n        :class:`~datetime.datetime` objects. A time format string, to be passed to the\n        Javascript strftime library. See https://github.com/samsonjs/strftime for more\n        details. For Dates, the default is \"%F\" (like \"2015-07-01\"), and for Datetimes,\n        the default is \"%F %T\" (like \"2015-07-01 15:32:10\").\n    timezone\n        Only used if the values are :class:`~datetime.datetime` objects. A string\n        specifying the time zone offset for the displayed times, in the format \"+HHMM\"\n        or \"-HHMM\". If ``None`` (the default), times will be displayed in the browser's\n        time zone. The value \"+0000\" will result in UTC time.\n    session\n        A :class:`~shiny.Session` instance. If not provided, it is inferred via\n        :func:`~shiny.session.get_current_session`.\n\n    Note\n    ----\n    {note}\n\n    See Also\n    -------\n    ~shiny.ui.input_slider\n    \"\"\"\n\n    session = require_active_session(session)\n\n    # Get any non-None value to see if the `data-type` may need to change\n    val = value[0] if isinstance(value, (tuple, list)) else value\n    present_val = next((x for x in [val, min, max] if x is not None), None)\n\n    data_type = None if present_val is None else _slider_type(present_val)\n    if time_format is None and data_type and data_type[0:4] == \"date\":\n        time_format = \"%F\" if data_type == \"date\" else \"%F %T\"\n\n    min_num = None if min is None else _as_numeric(min)\n    max_num = None if max is None else _as_numeric(max)\n    step_num = None if step is None else _as_numeric(step)\n    if isinstance(value, (tuple, list)):\n        value_num = [_as_numeric(x) for x in value]\n    elif value is not None:\n        value_num = _as_numeric(value)\n    else:\n        value_num = None\n\n    msg = {\n        \"label\": label,\n        \"value\": value_num,\n        \"min\": min_num,\n        \"max\": max_num,\n        \"step\": step_num,\n        \"data-type\": data_type,\n        \"time_format\": time_format,\n        \"timezone\": timezone,\n    }\n    session.send_input_message(id, drop_none(msg))",
  "def update_text(\n    id: str,\n    *,\n    label: Optional[str] = None,\n    value: Optional[str] = None,\n    placeholder: Optional[str] = None,\n    session: Optional[Session] = None,\n) -> None:\n    \"\"\"\n    Change the value of a text input on the client.\n\n    Parameters\n    ----------\n    id\n        An input id.\n    label\n        An input label.\n    value\n        A new value.\n    placeholder\n        A hint as to what can be entered into the control.\n    session\n        A :class:`~shiny.Session` instance. If not provided, it is inferred via\n        :func:`~shiny.session.get_current_session`.\n\n    Note\n    ----\n    {note}\n\n    See Also\n    -------\n    ~shiny.ui.input_text\n    \"\"\"\n\n    session = require_active_session(session)\n    msg = {\"label\": label, \"value\": value, \"placeholder\": placeholder}\n    session.send_input_message(id, drop_none(msg))",
  "def update_navs(\n    id: str, selected: Optional[str] = None, session: Optional[Session] = None\n) -> None:\n    \"\"\"\n    Change the value of a navs container on the client.\n\n    Parameters\n    ----------\n    id\n        An input id.\n    selected\n        The values that should be initially selected, if any.\n    session\n        A :class:`~shiny.Session` instance. If not provided, it is inferred via\n        :func:`~shiny.session.get_current_session`.\n\n    Note\n    ----\n    {note}\n\n    See Also\n    -------\n    ~shiny.ui.navset_tab\n    ~shiny.ui.navset_pill\n    ~shiny.ui.page_navbar\n    \"\"\"\n\n    session = require_active_session(session)\n    msg = {\"value\": selected}\n    session.send_input_message(id, drop_none(msg))",
  "def selectize_choices_json(request: Request) -> Response:\n        if choices is None:\n            return Response([], status_code=200)\n\n        # N.B. relevant query parameters that shiny.js setscan be found here\n        # https://github.com/rstudio/shiny/blob/78d77ce/srcts/src/bindings/input/selectInput.ts#L138-L142\n        qparams = request.query_params\n\n        # The (space-separated) input value(s) in lower-case (for case-insensitive matching)\n        keywords = set(re.split(r\"\\s+\", qparams.get(\"query\", \"\").lower()))\n\n        # Also note that the user (at least someday) has the ability to customize any of\n        # these options https://github.com/rstudio/shiny/blob/78d77ce/srcts/src/bindings/input/selectInput.ts#L231\n        #\n        # For most options this is fine, but searchField/valueField require some validation.\n\n        # i.e. maxOptions (defaults to 1000)\n        max_options = int(qparams.get(\"maxop\", 1000))\n\n        # i.e. searchConjunction (defaults to 'and', but can also be 'or')\n        conjunction = any if qparams.get(\"conju\", \"and\") == \"or\" else all\n\n        # i.e. searchFields (defaults to ['label'])\n        search_fields: list[str] = json.loads(qparams.get(\"field\", \"['label']\"))\n        if len(search_fields) == 0:\n            raise ValueError(\"The selectize.js searchFields option must be non-empty\")\n\n        # For some odd (probably wrong) reason, shiny.js is wrapping searchFields in an additional array\n        # https://github.com/rstudio/shiny/blob/78d77ce/srcts/src/bindings/input/selectInput.ts#L139\n        # https://github.com/rstudio/shiny/blob/78d77c/R/update-input.R#L801\n        if isinstance(search_fields[0], list):\n            search_fields = search_fields[0]\n\n        if set(search_fields).difference(set([\"label\", \"value\", \"optgroup\"])):\n            raise ValueError(\n                \"The selectize.js searchFields option must contain some combination of: \"\n                + \"'label', 'value', and 'optgroup'\"\n            )\n\n        # i.e. valueField (defaults to 'value')\n        if qparams.get(\"value\", \"value\") != \"value\":\n            raise ValueError(\n                \"The selectize.js valueField option must be set to 'value'\"\n            )\n\n        filtered_choices: list[FlatSelectChoice] = []\n        for choice in flat_choices:\n            # Short-circuit if we've reached the max number of options\n            if (len(filtered_choices) + len(selected_choices)) > max_options:\n                break\n\n            # If this is a selected value, *don't* add it here (add after this loop)\n            if selected_values and choice[\"value\"] in selected_values:\n                continue\n\n            match = False\n            for f in search_fields:\n                val: Optional[str] = choice.get(f, None)\n                # optgroup could be requested, but not necessarily present/relevant\n                if val is None:\n                    continue\n                if conjunction([x in val.lower() for x in keywords]):\n                    match = True\n\n            if match:\n                filtered_choices.append(choice)\n\n        if selected_choices:\n            filtered_choices.extend(selected_choices)\n\n        return JSONResponse(filtered_choices, status_code=200)",
  "def input_numeric(\n    id: str,\n    label: TagChild,\n    value: float,\n    *,\n    min: Optional[float] = None,\n    max: Optional[float] = None,\n    step: Optional[float] = None,\n    width: Optional[str] = None,\n) -> Tag:\n    \"\"\"\n    Create an input control for entry of numeric values.\n\n    Parameters\n    ----------\n    id\n        An input id.\n    label\n        An input label.\n    value\n        Initial value.\n    min\n        The minimum allowed value.\n    max\n        The maximum allowed value.\n    step\n        Interval to use when stepping between min and max.\n    width\n        The CSS width, e.g. '400px', or '100%'\n\n    Returns\n    -------\n    :\n        A UI element.\n\n    Notes\n    ------\n    ::: {.callout-note title=\"Server value\"}\n    A numeric value.\n    :::\n\n    See Also\n    -------\n    ~shiny.ui.update_numeric\n    \"\"\"\n\n    resolved_id = resolve_id(id)\n    return div(\n        shiny_input_label(resolved_id, label),\n        tags.input(\n            id=resolved_id,\n            type=\"number\",\n            class_=\"shiny-input-number form-control\",\n            value=value,\n            min=min,\n            max=max,\n            step=step,\n        ),\n        class_=\"form-group shiny-input-container\",\n        style=css(width=width),\n    )",
  "def shiny_input_label(id: str, label: TagChild = None) -> Tag:\n    cls = \"control-label\" + (\"\" if label else \" shiny-label-null\")\n    return tags.label(label, class_=cls, id=id + \"-label\", for_=id)",
  "def get_window_title(\n    title: None,\n    window_title: MISSING_TYPE,\n) -> None:\n    ...",
  "def get_window_title(\n    title: None,\n    window_title: str,\n) -> HTMLDependency:\n    ...",
  "def get_window_title(\n    title: str | Tag | TagList,\n    window_title: str | MISSING_TYPE,\n) -> HTMLDependency:\n    ...",
  "def get_window_title(\n    title: Optional[str | Tag | TagList],\n    window_title: str | MISSING_TYPE = MISSING,\n) -> Optional[HTMLDependency]:\n    if title is not None and isinstance(window_title, MISSING_TYPE):\n        window_title = _find_child_strings(title)\n\n    if isinstance(window_title, MISSING_TYPE):\n        return None\n    else:\n        return head_content(tags.title(window_title))",
  "def _find_child_strings(x: TagList | TagNode) -> str:\n    if isinstance(x, Tag) and x.name not in (\"script\", \"style\"):\n        x = x.children\n    if isinstance(x, TagList):\n        strings = [_find_child_strings(y) for y in x]\n        return \" \".join(filter(lambda x: x != \"\", strings))\n    if isinstance(x, str):\n        return x\n    return \"\"",
  "def input_action_button(\n    id: str,\n    label: TagChild,\n    *,\n    icon: TagChild = None,\n    width: Optional[str] = None,\n    **kwargs: TagAttrValue,\n) -> Tag:\n    \"\"\"\n    Creates an action button whose value is initially zero, and increments by one each\n    time it is pressed.\n\n    Parameters\n    ----------\n    id\n        An input id.\n    label\n        An input label.\n    icon\n        An icon to appear inline with the button/link.\n    width\n        The CSS width, e.g. '400px', or '100%'\n    kwargs\n        Attributes to be applied to the button.\n\n    Returns\n    -------\n    :\n        A UI element\n\n    Notes\n    ------\n    ::: {.callout-note title=\"Server value\"}\n    An integer representing the number of clicks.\n    :::\n\n    See Also\n    -------\n    ~shiny.ui.input_action_link\n    ~shiny.reactive.event\n    \"\"\"\n\n    return tags.button(\n        {\"class\": \"btn btn-default action-button\", \"style\": css(width=width)},\n        icon,\n        None if icon is None else \" \",\n        label,\n        id=resolve_id(id),\n        type=\"button\",\n        **kwargs,\n    )",
  "def input_action_link(\n    id: str,\n    label: TagChild,\n    *,\n    icon: TagChild = None,\n    **kwargs: TagAttrValue,\n) -> Tag:\n    \"\"\"\n    Creates a link whose value is initially zero, and increments by one each time it is\n    pressed.\n\n    Parameters\n    ----------\n    id\n        An input id.\n    label\n        An input label.\n    icon\n        An icon to appear inline with the button/link.\n    kwargs\n        Attributes to be applied to the link.\n\n    Returns\n    -------\n    :\n        A UI element\n\n    Notes\n    ------\n    ::: {.callout-note title=\"Server value\"}\n    An integer representing the number of clicks.\n    :::\n\n    See Also\n    -------\n    ~shiny.ui.input_action_button\n    ~shiny.reactive.event\n    \"\"\"\n\n    return tags.a(\n        {\"class\": \"action-button\"},\n        icon,\n        label,\n        id=resolve_id(id),\n        href=\"#\",\n        **kwargs,\n    )",
  "def download_button(\n    id: str,\n    label: TagChild,\n    *,\n    icon: TagChild = None,\n    width: Optional[str] = None,\n    **kwargs: TagAttrValue,\n) -> Tag:\n    \"\"\"\n    Create a download button\n\n    Parameters\n    ----------\n    id\n        An id for the download.\n    label\n        An input label.\n    icon\n        An icon to display on the button.\n    width\n        The width of the button.\n    kwargs\n        Additional attributes for the button.\n\n    Returns\n    -------\n    :\n        A UI element\n\n    See Also\n    --------\n    ~shiny.Session.download\n    ~shiny.ui.download_link\n    \"\"\"\n\n    return tags.a(\n        icon,\n        label,\n        {\"class\": \"btn btn-default shiny-download-link\", \"style\": css(width=width)},\n        id=resolve_id(id),\n        # This is a fake link that just results in a 404. It will be replaced by a\n        # working link after the server side logic runs, so this link will only be\n        # visited in cases where the user clicks the button too fast, or if the server\n        # never defines a handler for this download button.\n        href=\"session/0/download/missing_download\",\n        target=\"_blank\",\n        # We can't use `download` in pyodide mode, because the browser chooses not to\n        # route the download through the service worker in that case. (Observed by\n        # jcheng on 1/7/2022, using Chrome Version 96.0.4664.110.)\n        download=None if is_pyodide else True,\n        **kwargs,\n    )",
  "def download_link(\n    id: str,\n    label: TagChild,\n    *,\n    icon: TagChild = None,\n    width: Optional[str] = None,\n    **kwargs: TagAttrValue,\n) -> Tag:\n    \"\"\"\n    Create a download button\n\n    Parameters\n    ----------\n    id\n        An id for the download.\n    label\n        An input label.\n    icon\n        An icon to display on the button.\n    width\n        The width of the button.\n    kwargs\n        Additional attributes for the button.\n\n    Returns\n    -------\n    :\n        A UI element\n\n    See Also\n    --------\n    ~shiny.Session.download\n    ~shiny.ui.download_link\n    \"\"\"\n\n    return tags.a(\n        icon,\n        label,\n        {\"class\": \"shiny-download-link\", \"style\": css(width=width)},\n        id=resolve_id(id),\n        href=\"session/0/download/missing_download\",\n        target=\"_blank\",\n        download=None if is_pyodide else True,\n        **kwargs,\n    )",
  "class AnimationOptions(TypedDict):\n    \"\"\"\n    Options for the animation of a :func:`input_slider`.\n\n    Parameters\n    ----------\n    interval\n        The interval, in milliseconds, between each animation step.\n    loop\n        ``True`` to automatically restart the animation when it reaches the end.\n    play_button\n        Play button text or HTML.\n    pause_button\n        Pause button text or HTML.\n\n    Returns\n    -------\n    :\n        A TypedDict.\n\n    See Also\n    --------\n    ~shiny.ui.input_slider\n    \"\"\"\n\n    interval: NotRequired[int]\n    loop: NotRequired[bool]\n    play_button: NotRequired[TagChild]\n    pause_button: NotRequired[TagChild]",
  "def input_slider(\n    id: str,\n    label: TagChild,\n    min: SliderValueArg,\n    max: SliderValueArg,\n    value: SliderValueArg | Iterable[SliderValueArg],\n    *,\n    step: Optional[SliderStepArg] = None,\n    ticks: bool = False,\n    animate: bool | AnimationOptions = False,\n    width: Optional[str] = None,\n    sep: str = \",\",\n    pre: Optional[str] = None,\n    post: Optional[str] = None,\n    time_format: Optional[str] = None,\n    timezone: Optional[str] = None,\n    drag_range: bool = True,\n) -> Tag:\n    \"\"\"\n    Constructs a slider widget to select a number, date, or date-time from a range.\n\n    Parameters\n    ----------\n    id\n        An input id.\n    label\n        An input label.\n    min\n        The minimum allowed value.\n    max\n        The maximum allowed value.\n    value\n        Initial value.\n    step\n        Interval to use when stepping between min and max.\n    ticks\n        ``False`` to hide tick marks, ``True`` to show them according to some simple\n        heuristics.\n    animate\n        ``True`` to show simple animation controls with default settings; ``False`` not\n        to; or a custom settings list, such as those created using\n        :class:`AnimationOptions()`.\n    width\n        The CSS width, e.g. '400px', or '100%'\n    sep\n        Separator between thousands places in numbers.\n    pre\n        A prefix string to put in front of the value.\n    post\n        A suffix string to put after the value.\n    time_format\n        Only used if the slider values are :class:`~datetime.date` or\n        :class:`~datetime.datetime` objects. A time format string, to be passed to the\n        Javascript strftime library. See https://github.com/samsonjs/strftime for more\n        details. For Dates, the default is \"%F\" (like \"2015-07-01\"), and for Datetimes,\n        the default is \"%F %T\" (like \"2015-07-01 15:32:10\").\n    timezone\n        Only used if the values are :class:`~datetime.datetime` objects. A string\n        specifying the time zone offset for the displayed times, in the format \"+HHMM\"\n        or \"-HHMM\". If ``None`` (the default), times will be displayed in the browser's\n        time zone. The value \"+0000\" will result in UTC time.\n    drag_range\n        This option is used only if it is a range slider (with two values). If ``True``\n        (the default), the range can be dragged. In other words, the min and max can be\n        dragged together. If ``False``, the range cannot be dragged.\n\n    Returns\n    -------\n    :\n        A UI element\n\n    Notes\n    ------\n    ::: {.callout-note title=\"Server value\"}\n    A number, date, or date-time (depending on the class of value), or in the case of\n    slider range, a list of two numbers/dates/date-times.\n    :::\n\n    See Also\n    -------\n    ~shiny.ui.update_slider\n    \"\"\"\n\n    # Thanks to generic typing, max, value, etc. should be of the same type\n    data_type = _slider_type(min)\n\n    # Make sure min, max, value, and step are all numeric\n    # (converts dates/datetimes to milliseconds since epoch...this is the value JS wants)\n    min_num = _as_numeric(min)\n    max_num = _as_numeric(max)\n    val_nums = (\n        (_as_numeric(value[0]), _as_numeric(value[1]))\n        if isinstance(value, (tuple, list))\n        else (\n            _as_numeric(cast(SliderValueArg, value)),\n            _as_numeric(cast(SliderValueArg, value)),\n        )\n    )\n    step_num = _find_step_size(min_num, max_num) if step is None else _as_numeric(step)\n\n    n_ticks = None\n    if ticks:\n        n_steps = (max_num - min_num) / step_num\n        # Make sure there are <= 10 steps.\n        # n_ticks can be a noninteger, which is good when the range is not an\n        # integer multiple of the step size, e.g., min=1, max=10, step=4\n        scale_factor = math.ceil(n_steps / 10)\n        n_ticks = n_steps / scale_factor\n\n    id = resolve_id(id)\n\n    props: dict[str, TagAttrValue] = {\n        \"class\": \"js-range-slider\",\n        \"id\": id,\n        \"data_skin\": \"shiny\",\n        # TODO: do we need to worry about scientific notation (i.e., formatNoSci()?)\n        \"data_min\": str(min_num),\n        \"data_max\": str(max_num),\n        \"data_from\": str(val_nums[0]),\n        \"data_step\": str(step_num),\n        \"data_grid\": ticks,\n        \"data_grid_num\": n_ticks,\n        \"data_grid_snap\": \"false\",\n        \"data_prettify_separator\": sep,\n        \"data_prettify_enabled\": sep != \"\",\n        \"data_prefix\": pre,\n        \"data_postfix\": post,\n        \"data_keyboard\": \"true\",\n        \"data_data_type\": data_type,\n        \"data_time_format\": time_format,\n        \"data_timezone\": timezone,\n    }\n\n    if isinstance(value, (tuple, list)):\n        props[\"data_type\"] = \"double\"\n        props[\"data_to\"] = str(val_nums[1])\n        props[\"data_drag_interval\"] = drag_range\n\n    if not time_format and data_type[0:4] == \"date\":\n        props[\"data_time_format\"] = \"%F\" if data_type == \"date\" else \"%F %T\"\n\n    # ionRangeSlider wants attr = 'true'/'false'\n    props = {k: str(v).lower() if isinstance(v, bool) else v for k, v in props.items()}\n\n    resolved_id = resolve_id(id)\n    slider_tag = div(\n        shiny_input_label(resolved_id, label),\n        tags.input(**props),\n        *ionrangeslider_deps(),\n        class_=\"form-group shiny-input-container\",\n        style=css(width=width),\n    )\n\n    if animate is False:\n        return slider_tag\n\n    if animate is True:\n        animate = AnimationOptions()\n\n    animate_tag = div(\n        tags.a(\n            tags.span(animate.get(\"play_button\", _play_icon()), class_=\"play\"),\n            tags.span(animate.get(\"pause_button\", _pause_icon()), class_=\"pause\"),\n            href=\"#\",\n            class_=\"slider-animate-button link-secondary\",\n            data_target_id=resolved_id,\n            data_interval=animate.get(\"interval\", 500),\n            data_loop=animate.get(\"loop\", True),\n        ),\n        class_=\"slider-animate-container\",\n    )\n\n    slider_tag.append(animate_tag)\n\n    return slider_tag",
  "def _slider_type(x: SliderValueArg) -> str:\n    if isinstance(x, datetime):\n        return \"datetime\"\n    if isinstance(x, date):\n        return \"date\"\n    return \"number\"",
  "def _as_numeric(x: SliderStepArg | datetime | date) -> float:\n    if isinstance(x, timedelta):\n        return x.total_seconds() * 1000\n    if isinstance(x, datetime):\n        return x.timestamp() * 1000\n    if isinstance(x, date):\n        return datetime(x.year, x.month, x.day).timestamp() * 1000\n    return x",
  "def _find_step_size(min: int | float, max: int | float) -> int | float:\n    # TODO: this is a naive version of shiny::findStepSize() that might be susceptible to\n    # rounding errors? https://github.com/rstudio/shiny/pull/1956\n    range = max - min\n\n    if range < 2 or isinstance(min, float) or isinstance(max, float):\n        step = range / 100\n        # Round the step to get rid of any floating point arithmetic errors by\n        # mimicing what signif(digits = 10, step) does in R (see Description of ?signif)\n        # (the basic intuition is that smaller differences need more precision)\n        return round(step, 10 - math.ceil(math.log10(step)))\n    else:\n        return 1",
  "def _play_icon() -> Tag | HTML:\n    return HTML(play_icon)",
  "def _pause_icon() -> Tag | HTML:\n    return HTML(pause_icon)",
  "def input_file(\n    id: str,\n    label: TagChild,\n    *,\n    multiple: bool = False,\n    accept: Optional[str | list[str]] = None,\n    width: Optional[str] = None,\n    button_label: str = \"Browse...\",\n    placeholder: str = \"No file selected\",\n    capture: Optional[Literal[\"environment\", \"user\"]] = None,\n) -> Tag:\n    \"\"\"\n    Create a file upload control that can be used to upload one or more files.\n\n    Parameters\n    ----------\n    id\n        An input id.\n    label\n        An input label.\n    multiple\n        Whether the user should be allowed to select and upload multiple files at once.\n    accept\n        Unique file type specifier(s) which give the browser a hint as to the type of\n        file the server expects. Many browsers use this to prevent the user from\n        selecting an invalid file. Examples of valid values include a case insensitive\n        extension (e.g. ``.csv`` or ``.rds``), a valid MIME type (e.g. ``text/plain`` or\n        ``application/pdf``) or one of ``audio/*``, ``video/*``, or ``image/*`` meaning\n        any audio, video, or image type, respectively.\n    width\n        The CSS width, e.g. '400px', or '100%'\n    button_label\n        The label used on the button.\n    placeholder\n        The text to show on the input before a file has been uploaded.\n    capture\n        On mobile devices, this can be used to open the device's camera for input. If\n        \"environment\", it will open the rear-facing camera. If \"user\", it will open the\n        front-facing camera. By default, it will accept either still photos or video. To\n        accept only still photos, use ``accept=\"image/*\"``; to accept only video, use\n        ``accept=\"video/*\"``.\n\n    Returns\n    -------\n    :\n        A UI element.\n\n    Notes\n    -----\n\n    ::: {.callout-note title=\"Server value\"}\n    A list of dictionaries (one for each file upload) with the following keys:\n\n    * name: The filename provided by the web browser. This is *not* the path to read\n        to get at the actual data that was uploaded (see 'datapath').\n    * size: The size of the uploaded data, in bytes.\n    * type: The MIME type reported by the browser (for example, 'text/plain'), or\n        empty string if the browser didn't know.\n    * datapath: The path to a temp file that contains the data that was uploaded.\n        This file may be deleted if the user performs another upload operation.\n    :::\n\n    See Also\n    --------\n    ~shiny.ui.download_button\n    \"\"\"\n\n    if isinstance(accept, str):\n        accept = [accept]\n\n    resolved_id = resolve_id(id)\n    btn_file = span(\n        button_label,\n        tags.input(\n            id=resolved_id,\n            name=resolved_id,\n            type=\"file\",\n            multiple=\"multiple\" if multiple else None,\n            accept=\",\".join(accept) if accept else None,\n            capture=capture,\n            # Don't use \"display: none;\" style, which causes keyboard accessibility issue; instead use the following workaround: https://css-tricks.com/places-its-tempting-to-use-display-none-but-dont/\n            style=\"position: absolute !important; top: -99999px !important; left: -99999px !important;\",\n            class_=\"shiny-input-file\",\n        ),\n        class_=\"btn btn-default btn-file\",\n    )\n    return div(\n        shiny_input_label(resolved_id, label),\n        div(\n            tags.label(btn_file, class_=\"input-group-btn input-group-prepend\"),\n            tags.input(\n                type=\"text\",\n                class_=\"form-control\",\n                placeholder=placeholder,\n                readonly=\"readonly\",\n            ),\n            class_=\"input-group\",\n        ),\n        div(\n            div(class_=\"progress-bar\"),\n            id=resolved_id + \"_progress\",\n            class_=\"progress active shiny-file-input-progress\",\n        ),\n        class_=\"form-group shiny-input-container\",\n        style=css(width=width),\n    )",
  "def include_js(\n    path: Path | str,\n    *,\n    method: Literal[\"link\", \"link_files\", \"inline\"] = \"link\",\n    **kwargs: TagAttrValue,\n) -> Tag:\n    \"\"\"\n    Include a JavaScript file\n\n    Parameters\n    ----------\n    path\n        A path to a JS file.\n    method\n        One of the following: ``\"link\"``, ``\"link_files\"``, or ``\"inline\"``. ``\"link\"``\n        is the link to the CSS file via a :func:`~ui.tags.link` tag. This method is\n        generally preferrable to ``\"inline\"`` since it allows the browser to cache the\n        file. ``\"link_files\"`` is the same as ``\"link\"``, but also allow for the CSS\n        file to request other files within ``path``'s immediate parent directory (e.g.,\n        ``@import()`` another file). Note that this isn't the default behavior because\n        you should **be careful not to include files in the same directory as ``path``\n        that contain sensitive information**. A good general rule of thumb to follow is\n        to have ``path`` be located in a subdirectory of the app directory. For example,\n        if the app's source is located at ``/app/app.py``, then ``path`` should be\n        somewhere like ``/app/css/custom.css`` (and all the other relevant accompanying\n        'safe' files should be located under ``/app/css/``). And finally, ``\"inline\"``\n        is the inline the CSS file contents within a :func:`~ui.tags.style` tag.\n    **kwargs\n        Attributes which are passed on to `~ui.tags.script`\n\n\n    Returns\n    -------\n    :\n        A :func:`~ui.tags.script` tag.\n\n    Note\n    ----\n    This places a :func:`~ui.tags.script` tag in the :func:`~ui.tags.body` of the\n    document. If instead, you want to place the tag in the :func:`~ui.tags.head` of the\n    document, you can wrap it in ``head_content`` (in this case, just make sure you're\n    aware that the DOM probably won't be ready when the script is executed).\n\n    ```{python}\n    #| eval: false\n    ui.page_fluid(\n        ui.head_content(ui.include_js(\"custom.js\")),\n    )\n\n    # Alternately you can inline Javscript by changing the method.\n    ui.page_fluid(\n        ui.head_content(ui.include_js(\"custom.js\", method = \"inline\")),\n    )\n    ```\n\n    See Also\n    --------\n    ~ui.tags.script\n    ~include_css\n    \"\"\"\n    file_path = check_path(path)\n\n    if method == \"inline\":\n        return tags.script(read_utf8(file_path), **kwargs)\n\n    include_files = method == \"link_files\"\n    path_dest, hash = maybe_copy_files(file_path, include_files)\n\n    dep, src = create_include_dependency(\"include-js-\" + hash, path_dest, include_files)\n\n    return tags.script(dep, src=src, **kwargs)",
  "def include_css(\n    path: Path | str, *, method: Literal[\"link\", \"link_files\", \"inline\"] = \"link\"\n) -> Tag:\n    \"\"\"\n    Include a CSS file\n\n    Parameters\n    ----------\n    path\n        A path to a CSS file.\n    method\n        One of the following: ``\"link\"``, ``\"link_files\"``, or ``\"inline\"``. ``\"link\"``\n        is the link to the CSS file via a :func:`~ui.tags.link` tag. This method is\n        generally preferrable to ``\"inline\"`` since it allows the browser to cache the\n        file. ``\"link_files\"`` is the same as ``\"link\"``, but also allow for the CSS\n        file to request other files within ``path``'s immediate parent directory (e.g.,\n        ``@import()`` another file). Note that this isn't the default behavior because\n        you should **be careful not to include files in the same directory as ``path``\n        that contain sensitive information**. A good general rule of thumb to follow is\n        to have ``path`` be located in a subdirectory of the app directory. For example,\n        if the app's source is located at ``/app/app.py``, then ``path`` should be\n        somewhere like ``/app/css/custom.css`` (and all the other relevant accompanying\n        'safe' files should be located under ``/app/css/``). And finally, ``\"inline\"``\n        is the inline the CSS file contents within a :func:`~ui.tags.style` tag.\n\n\n    Returns\n    -------\n    :\n\n        If ``method=\"inline\"``, returns a :func:`~ui.tags.style` tag; otherwise, returns a\n        :func:`~ui.tags.link` tag.\n\n    Note\n    ----\n    By default this places a :func:`~ui.tags.link` (or :func:`~ui.tags.style`) tag in\n    the :func:`~ui.tags.body` of the document, which isn't optimal for performance, and\n    may result in a Flash of Unstyled Content (FOUC). To instead place the CSS in the\n    :func:`~ui.tags.head` of the document, you can wrap it in ``head_content``:\n\n    ```{python}\n    #| eval: false\n    from htmltools import head_content\n    from shiny import ui\n\n    ui.page_fluid(\n        ui.head_content(ui.include_css(\"custom.css\")),\n\n        # You can also inline css by passing a dictionary with a `style` element.\n        ui.div(\n            {\"style\": \"font-weight: bold;\"},\n            ui.p(\"Some text!\"),\n        )\n    )\n    ```\n\n    See Also\n    --------\n    ~ui.tags.style\n    ~ui.tags.link\n    ~include_js\n    \"\"\"\n\n    file_path = check_path(path)\n    if method == \"inline\":\n        return tags.style(read_utf8(file_path), type=\"text/css\")\n\n    include_files = method == \"link_files\"\n    path_dest, hash = maybe_copy_files(file_path, include_files)\n\n    dep, src = create_include_dependency(\n        \"include-css-\" + hash, path_dest, include_files\n    )\n\n    return tags.link(dep, href=src, rel=\"stylesheet\")",
  "def check_path(path: Path | str) -> Path:\n    path = Path(path)\n    if not path.exists():\n        err = f\"\"\"\n        {path.absolute()} does not exist.\n        Files are typically placed in the app directory and refered to with 'Path(__file__) / {path.name}'\n        \"\"\"\n        raise RuntimeError(err)\n    return path",
  "def create_include_dependency(\n    name: str, path: str, include_files: bool\n) -> tuple[HTMLDependency, str]:\n    dep = HTMLDependency(\n        name,\n        DEFAULT_VERSION,\n        source={\"subdir\": os.path.dirname(path)},\n        all_files=include_files,\n    )\n\n    # source_path_map() tells us where the source subdir is mapped to on the client\n    # (i.e., session._register_web_dependency() uses the same thing to determine where\n    # to mount the subdir, but we can't assume an active session at this point).\n    src = os.path.join(dep.source_path_map()[\"href\"], os.path.basename(path))\n\n    return dep, src",
  "def maybe_copy_files(path: Path | str, include_files: bool) -> tuple[str, str]:\n    hash = get_hash(path, include_files)\n\n    # To avoid unnecessary work when the same file is included multiple times,\n    # use a directory scoped by a hash of the file.\n    tmpdir = os.path.join(tempfile.gettempdir(), \"shiny_include_files\", hash)\n    path_dest = os.path.join(tmpdir, os.path.basename(path))\n\n    # Since the hash/tmpdir should represent all the files in the path's directory,\n    # we can simply return here\n    if os.path.exists(path_dest):\n        return path_dest, hash\n\n    # Otherwise, make sure we have a clean slate\n    if os.path.exists(tmpdir):\n        shutil.rmtree(tmpdir)\n\n    if include_files:\n        shutil.copytree(os.path.dirname(path), tmpdir)\n    else:\n        os.makedirs(tmpdir, exist_ok=True)\n        shutil.copy(path, path_dest)\n\n    return path_dest, hash",
  "def get_hash(path: Path | str, include_files: bool) -> str:\n    if include_files:\n        key = get_file_key(path)\n    else:\n        dir = os.path.dirname(path)\n        files = glob.iglob(os.path.join(dir, \"**\"), recursive=True)\n        key = \"\\n\".join([get_file_key(x) for x in files])\n    return hash_deterministic(key)",
  "def get_file_key(path: Path | str) -> str:\n    path = Path(path)\n    return str(path) + \"-\" + str(path.stat().st_mtime)",
  "def hash_deterministic(s: str) -> str:\n    \"\"\"\n    Returns a deterministic hash of the given string.\n    \"\"\"\n    return hashlib.sha1(s.encode(\"utf-8\")).hexdigest()",
  "def read_utf8(path: Path | str) -> str:\n    with open(path, \"r\", encoding=\"utf-8\") as f:\n        return f.read()",
  "def insert_ui(\n    ui: TagChild,\n    selector: str,\n    where: Literal[\"beforeBegin\", \"afterBegin\", \"beforeEnd\", \"afterEnd\"] = \"beforeEnd\",\n    multiple: bool = False,\n    immediate: bool = False,\n    session: Optional[Session] = None,\n) -> None:\n    \"\"\"\n    Insert UI objects\n\n    Parameters\n    ----------\n    ui\n        The UI object you want to insert. This can be anything that you usually put\n        inside your apps's ui function. If you're inserting multiple elements in one\n        call, make sure to wrap them in either a :func:`~shiny.ui.TagList` or a\n        :func:`~shiny.ui.tags.div` (the latter option has the advantage that you can\n        give it an id to make it easier to reference or remove it later on). If you want\n        to insert raw html, use :func:`~shiny.ui.HTML`.\n    selector\n        A string that is accepted by jQuery's selector (i.e. the string ``s`` to be\n        placed in a ``$(s)`` jQuery call) which determines the element(s) relative to\n        which you want to insert your UI object.\n    where\n        Where your UI object should go relative to the selector:\n\n        - beforeBegin: Before the selector element itself\n        - afterBegin: Just inside the selector element, before its first child\n        - beforeEnd: Just inside the selector element, after its last child (default)\n        - afterEnd: After the selector element itself\n\n        Adapted from\n        https://developer.mozilla.org/en-US/docs/Web/API/Element/insertAdjacentHTML.\n    multiple\n        In case your selector matches more than one element, multiple determines whether\n        Shiny should insert the UI object relative to all matched elements or just\n        relative to the first matched element (default).\n    immediate\n        Whether the UI object should be immediately inserted or removed, or whether\n        Shiny should wait until all outputs have been updated and all effects have been\n        run (default).\n    session\n        A :class:`~shiny.Session` instance. If not provided, it is inferred via\n        :func:`~shiny.session.get_current_session`.\n\n    Note\n    ----\n    This function allows you to dynamically add arbitrary UI into your app, whenever you\n    want, as many times as you want. Unlike :func:`~shiny.render.ui`, the UI generated\n    with `insert_ui` is persistent: once it's created, it stays there until removed by\n    :func:`remove_ui`. Each new call to `insert_ui` creates more UI objects, in addition\n    to the ones already there (all independent from one another). To update a part of\n    the UI (ex: an input object), you must use the appropriate render function or a\n    customized reactive function.\n\n    See Also\n    --------\n    ~shiny.ui.remove_ui\n    ~shiny.render.ui\n    \"\"\"\n\n    session = require_active_session(session)\n\n    def callback() -> None:\n        session._send_insert_ui(\n            selector=selector,\n            multiple=multiple,\n            where=where,\n            content=session._process_ui(ui),\n        )\n\n    if immediate:\n        callback()\n    else:\n        session.on_flushed(callback, once=True)",
  "def remove_ui(\n    selector: str,\n    multiple: bool = False,\n    immediate: bool = False,\n    session: Optional[Session] = None,\n) -> None:\n    \"\"\"\n    Remove UI objects\n\n    Parameters\n    ----------\n    selector\n        A string that is accepted by jQuery's selector (i.e. the string ``x`` to be\n        placed in a ``$(x)`` jQuery call) which determines the element(s) to remove. If\n        you want to remove a Shiny input or output, note that many of these are wrapped\n        in ``<div>``s, so you may need to use a somewhat complex selector \u2014 see the\n        Examples below. (Alternatively, you could also wrap the inputs/outputs that you\n        want to be able to remove easily in a ``<div>`` with an id.)\n    multiple\n        In case your selector matches more than one element, multiple determines whether\n        Shiny should insert the UI object relative to all matched elements or just\n        relative to the first matched element (default).\n    immediate\n        Whether the UI object should be immediately inserted or removed, or whether\n        Shiny should wait until all outputs have been updated and all effects have been\n        run (default).\n    session\n        A :class:`~shiny.Session` instance. If not provided, it is inferred via\n        :func:`~shiny.session.get_current_session`.\n\n    See Also\n    -------\n    ~shiny.ui.insert_ui\n    ~shiny.render.ui\n    \"\"\"\n\n    session = require_active_session(session)\n\n    def callback():\n        session._send_remove_ui(selector=selector, multiple=multiple)\n\n    if immediate:\n        callback()\n    else:\n        session.on_flushed(callback, once=True)",
  "def callback() -> None:\n        session._send_insert_ui(\n            selector=selector,\n            multiple=multiple,\n            where=where,\n            content=session._process_ui(ui),\n        )",
  "def callback():\n        session._send_remove_ui(selector=selector, multiple=multiple)",
  "def row(*args: TagChild | TagAttrs, **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Responsive row-column based layout\n\n    Layout UI components using Bootstrap's grid layout system. Use ``row()`` to group\n    elements that should appear on the same line (if the browser has adequate width) and\n    :func:`~shiny.ui.column` to define how much horizontal space within a 12-unit wide\n    grid each on of these elements should occupy. See the [layout\n    guide](https://shiny.posit.co/articles/layout-guide.html>) for more context and\n    examples.\n    (The article is about Shiny for R, but the general principles are the same.)\n\n    Parameters\n    ----------\n    args\n        Any number of child elements.\n    kwargs\n        Attributes to place on the row tag.\n\n    Returns\n    -------\n    :\n        A UI element.\n\n    See Also\n    -------\n    :func:`~shiny.ui.column`\n    \"\"\"\n    return div({\"class\": \"row\"}, *args, **kwargs)",
  "def column(\n    width: int, *args: TagChild | TagAttrs, offset: int = 0, **kwargs: TagAttrValue\n) -> Tag:\n    \"\"\"\n    Responsive row-column based layout\n\n    See :func:`~shiny.ui.row` for more information.\n\n    Parameters\n    ----------\n    width\n        The width of the column (an integer between 1 and 12).\n    args\n        UI elements to place within the column.\n    offset\n        The number of columns to offset this column from the end of the previous column.\n    kwargs\n        Attributes to place on the column tag.\n\n    Returns\n    -------\n    :\n        A UI element.\n\n    See Also\n    -------\n    :func:`~shiny.ui.row`\n    \"\"\"\n\n    if width < 1 or width > 12:\n        raise ValueError(\"Column width must be between 1 and 12\")\n    cls = \"col-sm-\" + str(width)\n    if offset > 0:\n        # offset-md-x is for bootstrap 4 forward compat\n        # (every size tier has been bumped up one level)\n        # https://github.com/twbs/bootstrap/blob/74b8fe7/docs/4.3/migration/index.html#L659\n        off = str(offset)\n        cls += f\" offset-md-{off} col-sm-offset-{off}\"\n    return div({\"class\": cls}, *args, **kwargs)",
  "def layout_sidebar(\n    # TODO: also accept a generic list (and wrap in panel in that case)?\n    sidebar: TagChild,\n    main: TagChild,\n    position: Literal[\"left\", \"right\"] = \"left\",\n) -> Tagifiable:\n    \"\"\"\n    Layout a sidebar and main area\n\n    Create a layout with a sidebar (:func:`~shiny.ui.panel_sidebar`) and main area\n    (:func:`~shiny.ui.panel_main`). The sidebar is displayed with a distinct background\n    color and typically contains input controls. By default, the main area occupies 2/3\n    of the horizontal width and typically contains outputs.\n\n    Parameters\n    ----------\n    sidebar\n        A UI element to place in the sidebar (typically a\n        :func:`~shiny.ui.panel_sidebar`)\n    main\n        A UI element to place in the main area (typically a\n        :func:`~shiny.ui.panel_main`)\n    position\n        The position of the sidebar (left or right)\n\n    Returns\n    -------\n    :\n        A UI element\n\n    See Also\n    -------\n    :func:`~shiny.ui.panel_sidebar`\n    :func:`~shiny.ui.panel_main`\n    \"\"\"\n\n    # Not requiring `XPanelSidebar`/`XPanelMain` to not expose the `_x` module if possible\n    if not isinstance(sidebar, XPanelSidebar):\n        sidebar = XPanelSidebar(sidebar)\n    if not isinstance(main, XPanelMain):\n        main = XPanelMain(attrs={}, children=[main])\n\n    return x_layout_sidebar(\n        sidebar.get_sidebar(position=position),\n        main,\n    )",
  "def panel_well(*args: TagChild | TagAttrs, **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a well panel\n\n    Creates a panel with a slightly inset border and grey background. Equivalent to\n    Bootstrap's ``well`` CSS class.\n\n    Parameters\n    ----------\n    args\n        UI elements to include inside the panel.\n    kwargs\n        Attributes to place on the panel tag.\n\n    Returns\n    -------\n    :\n        A UI element.\n\n    See Also\n    -------\n    :func:`~shiny.ui.panel_sidebar`\n    :func:`~shiny.ui.panel_main`\n    \"\"\"\n    return div({\"class\": \"well\"}, *args, **kwargs)",
  "def panel_sidebar(\n    *args: TagChild | TagAttrs,\n    width: int = 4,\n    **kwargs: TagAttrValue,\n) -> Tagifiable:\n    \"\"\"\n    Create a sidebar panel\n\n    See :func:`~shiny.ui.layout_sidebar` for more information and an example.\n\n    Parameters\n    ----------\n\n    args\n        UI elements to include inside the sidebar.\n    width\n        The width of the sidebar (an integer between 1 and 12)\n    kwargs\n        Attributes to place on the sidebar tag.\n\n    Returns\n    -------\n    :\n        A UI element.\n\n    See Also\n    -------\n    :func:`~shiny.ui.panel_sidebar`\n    :func:`~shiny.ui.panel_main`\n    \"\"\"\n    return XPanelSidebar(*args, width=width, **kwargs)",
  "def panel_main(\n    *args: TagChild | TagAttrs,\n    **kwargs: TagAttrValue,\n) -> Tagifiable:\n    \"\"\"\n    Create an main area panel\n\n    See :func:`~shiny.ui.layout_sidebar` for more information and an example.\n\n    Parameters\n    ----------\n    args\n        UI elements to include inside the main area.\n    kwargs\n        Attributes to place on the main area tag.\n\n    Returns\n    -------\n    :\n        A UI element.\n\n    See Also\n    -------\n    :func:`~shiny.ui.panel_sidebar`\n    :func:`~shiny.ui.layout_sidebar`\n    \"\"\"\n    attrs, children = x_consolidate_attrs(*args, **kwargs)\n    if \"width\" in attrs:\n        if attrs[\"width\"] != 8:\n            warn_deprecated(\n                \"panel_main(width=)` is being ignored. Given the sidebar width, the main panel will take up the remaining horizontal space.\"\n            )\n        del attrs[\"width\"]\n\n    if len(attrs) > 0:\n        # While we could return an `XPanelMain()` for empty attrs,\n        # let's try to limit the exposure of the class object\n        return XPanelMain(attrs=attrs, children=children)\n\n    return TagList(*children)",
  "def panel_conditional(\n    condition: str,\n    *args: TagChild | TagAttrs,\n    **kwargs: TagAttrValue,\n) -> Tag:\n    \"\"\"\n    Create a conditional panel\n\n    Show UI elements only if a ``JavaScript`` condition is ``true``.\n\n    Parameters\n    ----------\n    condition\n        A JavaScript expression that will be evaluated repeatedly to determine whether\n        the panel should be displayed.\n    args\n        UI elements to include inside the panel.\n    kwargs\n        Attributes to place on the panel tag.\n\n    Returns\n    -------\n    :\n        A UI element.\n\n    Note\n    ----\n    In the JS expression, you can refer to input and output JavaScript objects that\n    contain the current values of input and output. For example, if you have an input\n    with an id of foo, then you can use input.foo to read its value. (Be sure not to\n    modify the input/output objects, as this may cause unpredictable behavior.)\n\n    You are not recommended to use special JavaScript characters such as a period . in\n    the input id's, but if you do use them anyway, for example, ``id = \"foo.bar\"``, you\n    will have to use ``input[\"foo.bar\"]`` instead of ``input.foo.bar`` to read the input\n    value.\n\n    Tip\n    ---\n    A more powerful (but slower) way to conditionally show UI content is to use\n    :func:`~shiny.render.ui`.\n\n    See Also\n    -------\n    ~shiny.render.ui\n    ~shiny.ui.output_ui\n    \"\"\"\n\n    ns_prefix = current_namespace()\n\n    if ns_prefix != \"\":\n        ns_prefix += \"-\"\n\n    return div(*args, data_display_if=condition, data_ns_prefix=ns_prefix, **kwargs)",
  "def panel_title(\n    title: str | Tag | TagList, window_title: str | MISSING_TYPE = MISSING\n) -> TagList:\n    \"\"\"\n    Create title(s) for the application.\n\n    Parameters\n    ----------\n    title\n        A title to display in the app's UI.\n    window_title\n        A title to display on the browser tab.\n\n    Returns\n    -------\n    :\n        A UI element.\n\n    Note\n    ----\n    This result of this function causes a side effect of adding a title tag to the head\n    of the document (this is necessary for the browser to display the title in the\n    browser window). You can also specify a page title explicitly using the title\n    parameter of the top-level page function (e.g., :func:`~shiny.ui.page_fluid`).\n    \"\"\"\n\n    if isinstance(title, str):\n        title = h2(title)\n\n    return TagList(get_window_title(title, window_title), title)",
  "def panel_fixed(*args: TagChild | TagAttrs, **kwargs: TagAttrValue) -> TagList:\n    \"\"\"\n    Create a panel of absolutely positioned content.\n\n    This function is equivalent to calling :func:`~shiny.ui.panel_absolute` with\n    ``fixed=True`` (i.e., the panel does not scroll with the rest of the page). See\n    :func:`~shiny.ui.panel_absolute` for more information.\n\n    Parameters\n    ----------\n    args\n        UI elements to include inside the panel.\n    kwargs\n        Arguments passed along to :func:`~shiny.ui.panel_absolute`.\n\n    Returns\n    -------\n    :\n        A UI element.\n\n    See Also\n    -------\n    :func:`~shiny.ui.panel_absolute`\n    \"\"\"\n    return panel_absolute(*args, fixed=True, **kwargs)",
  "def panel_absolute(\n    *args: TagChild | TagAttrs,\n    top: Optional[str] = None,\n    left: Optional[str] = None,\n    right: Optional[str] = None,\n    bottom: Optional[str] = None,\n    width: Optional[str] = None,\n    height: Optional[str] = None,\n    draggable: bool = False,\n    fixed: bool = False,\n    cursor: Literal[\"auto\", \"move\", \"default\", \"inherit\"] = \"auto\",\n    **kwargs: TagAttrValue,\n) -> TagList:\n    \"\"\"\n    Create a panel of absolutely positioned content.\n\n    Creates a ``<div>`` tag whose CSS position is set to absolute (or fixed if ``fixed =\n    True``). The way absolute positioning works in HTML is that absolute coordinates are\n    specified relative to its nearest parent element whose position is not set to static\n    (which is the default), and if no such parent is found, then relative to the page\n    borders. If you're not sure what that means, just keep in mind that you may get\n    strange results if you use this function from inside of certain types of panels.\n\n    Parameters\n    ----------\n    args\n        UI elements to include inside the panel.\n    top\n        Distance between the top of the panel, and the top of the page or parent\n        container.\n    left\n        Distance between the left side of the panel, and the left of the page or parent\n        container.\n    right\n        Distance between the right side of the panel, and the right of the page or\n        parent container.\n    bottom\n        Distance between the bottom of the panel, and the bottom of the page or parent\n        container.\n    width\n        Width of the panel.\n    height\n        Height of the panel.\n    draggable\n        If ``True``, allows the user to move the panel by clicking and dragging.\n    fixed\n        Positions the panel relative to the browser window and prevents it from being\n        scrolled with the rest of the page.\n    cursor\n        The type of cursor that should appear when the user mouses over the panel. Use\n        ``\"move\"`` for a north-east-south-west icon, ``\"default\"`` for the usual cursor\n        arrow, or ``\"inherit\"`` for the usual cursor behavior (including changing to an\n        I-beam when the cursor is over text). The default is ``\"auto\"``, which is\n        equivalent to ``\"move\" if draggable else \"inherit\"``.\n    kwargs\n        Attributes added to the content's container tag.\n\n    Returns\n    -------\n    :\n        A UI element\n\n    Tip\n    ----\n    The position (``top``, ``left``, ``right``, ``bottom``) and size (``width``,\n    ``height``) parameters are all optional, but you should specify exactly two of top,\n    bottom, and height and exactly two of left, right, and width for predictable\n    results.\n\n    Like most other distance parameters in Shiny, the position and size parameters take\n    a number (interpreted as pixels) or a valid CSS size string, such as ``\"100px\"``\n    (100 pixels) or ``\"25%\"``.\n\n    For arcane HTML reasons, to have the panel fill the page or parent you should\n    specify 0 for ``top``, ``left``, ``right``, and ``bottom`` rather than the more\n    obvious ``width = \"100%\"`` and ``height = \"100%\"``.\n    \"\"\"\n\n    style = css(\n        top=top,\n        left=left,\n        right=right,\n        bottom=bottom,\n        width=width,\n        height=height,\n        position=\"fixed\" if fixed else \"absolute\",\n        cursor=\"move\" if draggable else \"inherit\" if cursor == \"auto\" else cursor,\n    )\n    divTag = div(*args, style=style, **kwargs)\n    if not draggable:\n        return TagList(divTag)\n    divTag.add_class(\"draggable\")\n    deps = jqui_deps()\n    deps.stylesheet = []\n    return TagList(deps, divTag, tags.script('$(\".draggable\").draggable();'))",
  "def help_text(*args: TagChild | TagAttrs, **kwargs: TagAttrValue) -> Tag:\n    \"\"\"\n    Create a help text element\n\n    Parameters\n    ----------\n    args\n        UI elements to include inside the help text.\n    kwargs\n        Attributes to add to the text container.\n\n    Returns\n    -------\n    :\n        A UI element\n    \"\"\"\n\n    return span({\"class\": \"help-block\"}, *args, **kwargs)",
  "def input_checkbox(\n    id: str, label: TagChild, value: bool = False, *, width: Optional[str] = None\n) -> Tag:\n    \"\"\"\n    Create a checkbox that can be used to specify logical values.\n\n    Parameters\n    ----------\n    id\n        An input id.\n    label\n        An input label.\n    value\n        Initial value.\n    width\n        The CSS width, e.g. '400px', or '100%'\n\n    Returns\n    -------\n    :\n        A UI element.\n\n    Notes\n    ------\n    ::: {.callout-note title=\"Server value\"}\n    ``True`` if checked, ``False`` otherwise.\n    :::\n\n    See Also\n    -------\n    ~shiny.ui.input_switch\n    ~shiny.ui.update_checkbox\n    ~shiny.ui.input_checkbox_group\n    ~shiny.ui.input_radio_buttons\n    \"\"\"\n\n    return div(\n        div(\n            tags.label(\n                tags.input(\n                    id=resolve_id(id),\n                    type=\"checkbox\",\n                    checked=\"checked\" if value else None,\n                    class_=\"shiny-input-checkbox\",\n                ),\n                \" \",\n                span(label),\n            ),\n            class_=\"checkbox\",\n        ),\n        class_=\"form-group shiny-input-container\",\n        style=css(width=width),\n    )",
  "def input_switch(\n    id: str, label: TagChild, value: bool = False, *, width: Optional[str] = None\n) -> Tag:\n    \"\"\"\n    Create a switch that can be used to specify logical values. Similar to\n    ~shiny.ui.input_checkbox, but implies to the user that the change will take effect\n    immediately.\n\n    Parameters\n    ----------\n    id\n        An input id.\n    label\n        An input label.\n    value\n        Initial value.\n    width\n        The CSS width, e.g. '400px', or '100%'\n\n    Returns\n    -------\n    :\n        A UI element.\n\n    Notes\n    ------\n    ::: {.callout-note title=\"Server value\"}\n    ``True`` if checked, ``False`` otherwise.\n    :::\n\n    See Also\n    -------\n    ~shiny.ui.input_checkbox\n    ~shiny.ui.update_switch\n    ~shiny.ui.input_checkbox_group\n    ~shiny.ui.input_radio_buttons\n    \"\"\"\n\n    return _input_checkbox(id, label, \"form-check form-switch\", value, width=width)",
  "def _input_checkbox(\n    id: str,\n    label: TagChild,\n    class_: str = \"form-check\",\n    value: bool = False,\n    *,\n    width: Optional[str] = None,\n) -> Tag:\n    return div(\n        div(\n            tags.input(\n                id=resolve_id(id),\n                class_=\"form-check-input\",\n                type=\"checkbox\",\n                checked=\"checked\" if value else None,\n            ),\n            \" \",\n            tags.label(label, class_=\"form-check-label\", for_=resolve_id(id)),\n            class_=class_,\n        ),\n        bslibshiny_dependency(),\n        class_=\"form-group shiny-input-container\",\n        style=css(width=width),\n    )",
  "def input_checkbox_group(\n    id: str,\n    label: TagChild,\n    choices: ChoicesArg,\n    *,\n    selected: Optional[str | list[str]] = None,\n    inline: bool = False,\n    width: Optional[str] = None,\n) -> Tag:\n    \"\"\"\n    Create a group of checkboxes that can be used to toggle multiple choices\n    independently.\n\n    Parameters\n    ----------\n    id\n        An input id.\n    label\n        An input label.\n    choices\n        Either a list of choices or a dictionary mapping choice values to labels. Note\n        that if a dictionary is provided, the keys are used as the (input) values so\n        that the dictionary values can hold HTML labels.\n    selected\n        The values that should be initially selected, if any.\n    inline\n        If `True`, the result is displayed inline\n    width\n        The CSS width, e.g. '400px', or '100%'\n\n    Returns\n    -------\n    :\n        A UI element.\n\n    Notes\n    ------\n    ::: {.callout-note title=\"Server value\"}\n    A tuple of string(s) with the selected value(s) (if any).\n    :::\n\n    See Also\n    -------\n    ~shiny.ui.update_checkbox_group\n    ~shiny.ui.input_checkbox\n    ~shiny.ui.input_radio_buttons\n    \"\"\"\n\n    resolved_id = resolve_id(id)\n    input_label = shiny_input_label(resolved_id, label)\n    options = _generate_options(\n        id=resolved_id,\n        type=\"checkbox\",\n        choices=choices,\n        selected=selected,\n        inline=inline,\n    )\n    return div(\n        input_label,\n        options,\n        id=resolved_id,\n        style=css(width=width),\n        class_=\"form-group shiny-input-checkboxgroup shiny-input-container\"\n        + (\" shiny-input-container-inline\" if inline else \"\"),\n        # https://www.w3.org/TR/wai-aria-practices/examples/checkbox/checkbox-1/checkbox-1.html\n        role=\"group\",\n        aria_labelledby=input_label.attrs.get(\"id\"),\n    )",
  "def input_radio_buttons(\n    id: str,\n    label: TagChild,\n    choices: ChoicesArg,\n    *,\n    selected: Optional[str] = None,\n    inline: bool = False,\n    width: Optional[str] = None,\n) -> Tag:\n    \"\"\"\n    Create a set of radio buttons used to select an item from a list.\n\n    Parameters\n    ----------\n    id\n        An input id.\n    label\n        An input label.\n    choices\n        Either a list of choices or a dictionary mapping choice values to labels. Note\n        that if a dictionary is provided, the keys are used as the (input) values so\n        that the dictionary values can hold HTML labels.\n    selected\n        The values that should be initially selected, if any.\n    inline\n        If ``True``, the result is displayed inline\n    width\n        The CSS width, e.g. '400px', or '100%'\n\n    Returns\n    -------\n    :\n        A UI element\n\n    Notes\n    ------\n    ::: {.callout-note title=\"Server value\"}\n    A string with the selected value.\n    :::\n\n    See Also\n    -------\n    ~shiny.ui.update_radio_buttons\n    ~shiny.ui.input_checkbox_group\n    ~shiny.ui.input_checkbox\n    \"\"\"\n\n    resolved_id = resolve_id(id)\n    input_label = shiny_input_label(resolved_id, label)\n    options = _generate_options(\n        id=resolved_id,\n        type=\"radio\",\n        choices=choices,\n        selected=selected,\n        inline=inline,\n    )\n    return div(\n        input_label,\n        options,\n        id=resolved_id,\n        style=css(width=width),\n        class_=\"form-group shiny-input-radiogroup shiny-input-container\"\n        + (\" shiny-input-container-inline\" if inline else \"\"),\n        # https://www.w3.org/TR/2017/WD-wai-aria-practices-1.1-20170628/examples/radio/radio-1/radio-1.html\n        role=\"radiogroup\",\n        aria_labelledby=input_label.attrs.get(\"id\"),\n    )",
  "def _generate_options(\n    id: str,\n    type: str,\n    choices: ChoicesArg,\n    selected: Optional[str | list[str] | tuple[str, ...]],\n    inline: bool,\n) -> Tag:\n    choicez = _normalize_choices(choices)\n\n    if selected is None:\n        if type == \"radio\":\n            selected = list(choicez.keys())[0]\n        else:\n            selected = []\n\n    if isinstance(selected, tuple):\n        selected = list(selected)\n    elif not isinstance(selected, list):\n        selected = [selected]\n\n    return div(\n        [\n            _generate_option(\n                id,\n                type,\n                value=choice[0],\n                label=choice[1],\n                checked=choice[0] in selected,\n                inline=inline,\n            )\n            for choice in choicez.items()\n        ],\n        class_=\"shiny-options-group\",\n    )",
  "def _generate_option(\n    id: str,\n    type: str,\n    value: str,\n    label: TagChild,\n    checked: bool,\n    inline: bool,\n) -> Tag:\n    input = tags.input(\n        type=type,\n        name=id,\n        value=value,\n        checked=\"checked\" if checked else None,\n    )\n    if inline:\n        return tags.label(\n            input,\n            \" \",\n            span(label),\n            class_=type + \"-inline\",\n            _add_ws=True,\n        )\n    else:\n        return div(\n            tags.label(input, \" \", span(label)),\n            class_=type,\n        )",
  "def _normalize_choices(x: ChoicesArg) -> _Choices:\n    if isinstance(x, (list, tuple)):\n        return {k: k for k in x}\n    else:\n        return x",
  "def as_css_unit(value: None) -> None:\n    ...",
  "def as_css_unit(value: CssUnit) -> str:\n    ...",
  "def as_css_unit(value: None | CssUnit) -> None | str:\n    # TODO-future: Actually validate. Or don't validate, but then change\n    # the function name to to_css_unit() or something.\n    if isinstance(value, (float, int)):\n        # Explicit check for 0 because floats may format to have many decimals.\n        if value == 0:\n            return \"0\"\n        return \"{:f}px\".format(value)\n    else:\n        return value",
  "def as_css_padding(padding: CssUnit | list[CssUnit]) -> str:\n    ...",
  "def as_css_padding(padding: None) -> None:\n    ...",
  "def as_css_padding(padding: CssUnit | list[CssUnit] | None) -> str | None:\n    if padding is None:\n        return None\n\n    if not isinstance(padding, list):\n        padding = [padding]\n\n    return \" \".join(as_css_unit(p) for p in padding)",
  "def to_width_unit(x: str | float | int) -> str:\n    if isinstance(x, (int, float)):\n        return as_css_unit(x)\n\n    if isinstance(x, str) and x.endswith(\"%\") and x.count(\"%\") == 1:\n        x1_num = float(x[:-1])\n        x2_num = 100 - x1_num\n        return f\"{x1_num}% {x2_num}%\"\n\n    # TODO-bslib: validateCssUnit() should maybe support fr units?\n    # return(paste(x, collapse = \" \"))\n    return as_css_unit(x)",
  "def tag_prepend_class(tag: TagT, *class_: str | None) -> TagT:\n    classes = (\n        *class_,\n        tag.attrs.get(\"class\"),\n    )\n    classes = [c for c in classes if c is not None]\n    if len(classes) == 0:\n        return tag\n    tag.attrs[\"class\"] = \" \".join(classes)\n    return tag",
  "def as_fillable_container(\n    tag: TagT,\n) -> TagT:\n    tag_prepend_class(tag, FILL_CONTAINER_CLASS)\n    tag.append(fill_dependency())\n    return tag",
  "def as_fill_item(\n    tag: TagT,\n) -> TagT:\n    tag_prepend_class(tag, FILL_ITEM_CLASS)\n    tag.append(fill_dependency())\n    return tag",
  "def consolidate_attrs(\n    *args: TagAttrs,\n    **kwargs: TagAttrValue,\n) -> tuple[TagAttrs, list[TagChild]]:\n    ...",
  "def consolidate_attrs(\n    *args: TagChildT | TagAttrs,\n    **kwargs: TagAttrValue,\n) -> tuple[TagAttrs, list[TagChildT]]:\n    ...",
  "def consolidate_attrs(\n    *args: TagChildT | TagAttrs,\n    **kwargs: TagAttrValue,\n) -> tuple[TagAttrs, list[TagChildT]]:\n    tag = div(*args, **kwargs)\n\n    # `TagAttrs` currently isn't compatible with `htmltools._core.TagAttrDict`\n    # https://github.com/posit-dev/py-htmltools/pull/55\n    # Convert to a plain dict to avoid getting custom methods from TagAttrDict\n    # Cast to `TagAttrs` so that `Tag` functions will accept the dictionary.\n    attrs = typing.cast(TagAttrs, dict(tag.attrs))\n\n    # Do not alter children structure (like `TagList` does)\n    children = [child for child in args if not isinstance(child, dict)]\n    return (attrs, children)",
  "def trinary(x: None) -> None:\n    ...",
  "def trinary(x: bool | str) -> str:\n    ...",
  "def trinary(x: bool | str | None) -> None | str:\n    if x is None:\n        return None\n    elif x:\n        return \"true\"\n    else:\n        return \"false\"",
  "def fill_dependency() -> HTMLDependency:\n    return HTMLDependency(\n        \"htmltools-fill\",\n        htmltools_version,\n        source={\n            \"package\": \"shiny\",\n            \"subdir\": _x_fill_path,\n        },\n        stylesheet={\"href\": \"fill.css\"},\n    )",
  "def sidebar_dependency() -> HTMLDependency:\n    return HTMLDependency(\n        \"bslib-sidebar\",\n        bslib_version,\n        source={\n            \"package\": \"shiny\",\n            \"subdir\": _x_sidebar_path,\n        },\n        script={\"src\": \"sidebar.min.js\"},\n        stylesheet={\"href\": \"sidebar.css\"},\n        all_files=True,\n    )",
  "def bslibshiny_dependency() -> HTMLDependency:\n    return HTMLDependency(\n        \"bslib-shiny\",\n        bslib_version,\n        source={\n            \"package\": \"shiny\",\n            \"subdir\": _x_bslibshiny_path,\n        },\n        script={\"src\": \"bslibShiny.min.js\"},\n        all_files=True,\n    )",
  "def nav_spacer_dependency() -> HTMLDependency:\n    return HTMLDependency(\n        \"bslib-nav-spacer\",\n        bslib_version,\n        source={\n            \"package\": \"shiny\",\n            \"subdir\": _x_nav_spacer_path,\n        },\n        stylesheet={\"href\": \"nav_spacer.css\"},\n    )",
  "class Sidebar:\n    def __init__(\n        self,\n        tag: Tag,\n        collapse_tag: Optional[Tag],\n        position: Literal[\"left\", \"right\"],\n        open: Literal[\"desktop\", \"open\", \"closed\", \"always\"],\n        width: CssUnit,\n        max_height_mobile: Optional[str | float],\n        color_fg: Optional[str],\n        color_bg: Optional[str],\n    ):\n        self.tag = tag\n        self.collapse_tag = collapse_tag\n        self.position = position\n        self.open = open\n        self.width = width\n        self.max_height_mobile = max_height_mobile\n        self.color_fg = color_fg\n        self.color_bg = color_bg",
  "def sidebar(\n    *args: TagChild | TagAttrs,\n    width: CssUnit = 250,\n    position: Literal[\"left\", \"right\"] = \"left\",\n    open: Literal[\"desktop\", \"open\", \"closed\", \"always\"] = \"desktop\",\n    id: Optional[str] = None,\n    title: TagChild | str = None,\n    bg: Optional[str] = None,\n    fg: Optional[str] = None,\n    class_: Optional[str] = None,  # TODO-future; Consider using `**kwargs` instead\n    max_height_mobile: Optional[str | float] = None,\n) -> Sidebar:\n    # See [this article](https://rstudio.github.io/bslib/articles/sidebars.html)\n    #   to learn more.\n    # TODO-future; If color contrast is implemented. Docs for `bg` and `fg`:\n    #     If only one of either is provided, an\n    #     accessible contrasting color is provided for the opposite color, e.g. setting\n    #     `bg` chooses an appropriate `fg` color.\n    # TODO-future; validate `open`, bg, fg, class_, max_height_mobile\n\n    if id is None and open != \"always\":\n        # but always provide id when collapsible for accessibility reasons\n        id = f\"bslib-sidebar-{random.randint(1000, 10000)}\"\n\n    # TODO-future; implement\n    # if fg is None and bg is not None:\n    #     fg = get_color_contrast(bg)\n    # if bg is None and fg is not None:\n    #     bg = get_color_contrast(fg)\n\n    if isinstance(title, (str, int, float)):\n        title = div(str(title), class_=\"sidebar-title\")\n\n    collapse_tag = None\n    # Code\n    if open != \"always\":\n        collapse_tag = tags.button(\n            _collapse_icon(),\n            class_=\"collapse-toggle\",\n            type=\"button\",\n            title=\"Toggle sidebar\",\n            aria_expanded=trinary(open in [\"open\", \"desktop\"]),\n            aria_controls=id,\n        )\n\n    tag = div(\n        div(\n            title,\n            {\"class\": \"sidebar-content\"},\n            *args,\n        ),\n        {\"class\": \"bslib-sidebar-input\"} if id is not None else None,\n        {\"class\": \"sidebar\"},\n        id=id,\n        role=\"complementary\",\n        class_=class_,\n    )\n\n    return Sidebar(\n        tag=tag,\n        collapse_tag=collapse_tag,\n        position=position,\n        open=open,\n        width=width,\n        max_height_mobile=max_height_mobile,\n        color_fg=fg,\n        color_bg=bg,\n    )",
  "def layout_sidebar(\n    sidebar: Sidebar,\n    content: PanelMain,\n    fillable: bool = True,\n    fill: bool = True,\n    bg: Optional[str] = None,\n    fg: Optional[str] = None,\n    border: Optional[bool] = None,\n    border_radius: Optional[bool] = None,\n    border_color: Optional[str] = None,\n    gap: Optional[CssUnit] = None,\n    padding: Optional[CssUnit | list[CssUnit]] = None,\n    height: Optional[CssUnit] = None,\n    **kwargs: TagAttrValue,\n) -> Tag:\n    attrs, _ = consolidate_attrs(**content.attrs, **kwargs)\n\n    main = div(\n        {\n            \"role\": \"main\",\n            \"class\": f\"main{' bslib-gap-spacing' if fillable else ''}\",\n            \"\"\n            \"style\": css(\n                background_color=bg,\n                color=fg,\n                gap=as_css_unit(gap),\n                padding=as_css_padding(padding),\n            ),\n        },\n        attrs,\n        content,\n    )\n    if fillable:\n        main = as_fillable_container(main)\n\n    max_height_mobile = sidebar.max_height_mobile or (\n        \"250px\" if height is None else \"50%\"\n    )\n\n    res = div(\n        {\"class\": \"bslib-sidebar-layout\"},\n        {\"class\": \"sidebar-right\"} if sidebar.position == \"right\" else None,\n        {\"class\": \"sidebar-collapsed\"} if sidebar.open == \"closed\" else None,\n        main,\n        sidebar.tag,\n        sidebar.collapse_tag,\n        sidebar_dependency(),\n        _sidebar_init_js(),\n        data_bslib_sidebar_init=\"true\" if sidebar.open != \"always\" else None,\n        data_bslib_sidebar_open=sidebar.open,\n        data_bslib_sidebar_border=trinary(border),\n        data_bslib_sidebar_border_radius=trinary(border_radius),\n        style=css(\n            __bslib_sidebar_width=as_css_unit(sidebar.width),\n            __bslib_sidebar_bg=as_css_unit(sidebar.color_bg),\n            __bslib_sidebar_fg=as_css_unit(sidebar.color_fg),\n            __bs_card_border_color=border_color,\n            height=as_css_unit(height),\n            __bslib_sidebar_max_height_mobile=as_css_unit(max_height_mobile),\n        ),\n    )\n    if fill:\n        res = as_fill_item(res)\n\n    return res",
  "def _collapse_icon() -> Tag:\n    return tags.svg(\n        svgtags.path(\n            fill_rule=\"evenodd\",\n            d=\"M1.646 4.646a.5.5 0 0 1 .708 0L8 10.293l5.646-5.647a.5.5 0 0 1 .708.708l-6 6a.5.5 0 0 1-.708 0l-6-6a.5.5 0 0 1 0-.708z\",\n        ),\n        xmlns=\"http://www.w3.org/2000/svg\",\n        viewBox=\"0 0 16 16\",\n        class_=\"bi bi-chevron-down collapse-icon\",\n        style=\"fill:currentColor;\",\n        aria_hidden=\"true\",\n        role=\"img\",\n    )",
  "def _sidebar_init_js() -> Tag:\n    # Note: if we want to avoid inline `<script>` tags in the future for\n    # initialization code, we might be able to do so by turning the sidebar layout\n    # container into a web component\n    return tags.script(\n        {\"data-bslib-sidebar-init\": True},\n        \"bslib.Sidebar.initCollapsibleAll()\",\n    )",
  "class PanelSidebar:\n    # Store `attrs` for `layout_sidebar()` to retrieve\n    def __init__(\n        self, *args: TagChild | TagAttrs, width: int = 4, **kwargs: TagAttrValue\n    ) -> None:\n        self.args = args\n        self.kwargs = kwargs\n        self.width = width\n\n    def get_sidebar(self, position: Literal[\"left\", \"right\"] = \"left\") -> Sidebar:\n        return sidebar(\n            *self.args,\n            width=f\"{int(self.width / 12 * 100)}%\",\n            position=position,\n            open=\"always\",\n            **self.kwargs,\n        )\n\n    # Hopefully this is never used. But it makes it Tagifiable to allow us to not expose\n    # `Sidebar` and `PanelSidebar` classes\n    def tagify(self) -> Tag:\n        return self.get_sidebar().tag.tagify()",
  "class PanelMain:\n    # Store `attrs` for `layout_sidebar()` to retrieve\n    attrs: TagAttrs\n    # Return `children` in `layout_sidebar()` via `.tagify()` method\n    children: list[TagChild]\n\n    def __init__(self, *, attrs: TagAttrs, children: list[TagChild]) -> None:\n        self.attrs = attrs\n        self.children = children\n\n    def tagify(self) -> TagList:\n        return TagList(self.children).tagify()",
  "def __init__(\n        self,\n        tag: Tag,\n        collapse_tag: Optional[Tag],\n        position: Literal[\"left\", \"right\"],\n        open: Literal[\"desktop\", \"open\", \"closed\", \"always\"],\n        width: CssUnit,\n        max_height_mobile: Optional[str | float],\n        color_fg: Optional[str],\n        color_bg: Optional[str],\n    ):\n        self.tag = tag\n        self.collapse_tag = collapse_tag\n        self.position = position\n        self.open = open\n        self.width = width\n        self.max_height_mobile = max_height_mobile\n        self.color_fg = color_fg\n        self.color_bg = color_bg",
  "def __init__(\n        self, *args: TagChild | TagAttrs, width: int = 4, **kwargs: TagAttrValue\n    ) -> None:\n        self.args = args\n        self.kwargs = kwargs\n        self.width = width",
  "def get_sidebar(self, position: Literal[\"left\", \"right\"] = \"left\") -> Sidebar:\n        return sidebar(\n            *self.args,\n            width=f\"{int(self.width / 12 * 100)}%\",\n            position=position,\n            open=\"always\",\n            **self.kwargs,\n        )",
  "def tagify(self) -> Tag:\n        return self.get_sidebar().tag.tagify()",
  "def __init__(self, *, attrs: TagAttrs, children: list[TagChild]) -> None:\n        self.attrs = attrs\n        self.children = children",
  "def tagify(self) -> TagList:\n        return TagList(self.children).tagify()",
  "def data_frame_deps() -> HTMLDependency:\n    return HTMLDependency(\n        name=\"shiny-data-frame-output\",\n        version=__version__,\n        source={\n            \"package\": \"shiny\",\n            \"subdir\": \"www/shared/dataframe\",\n        },\n        script={\"src\": \"dataframe.js\", \"type\": \"module\"},\n    )",
  "def output_data_frame(id: str) -> Tag:\n    \"\"\"\n    Create an output container for an interactive table or grid. Features fast\n    virtualized scrolling, sorting, filtering, and row selection (single or multiple).\n\n    Parameters\n    ----------\n    id\n        An output id.\n\n    Returns\n    -------\n    :\n        A UI element.\n\n    See Also\n    --------\n    :func:`~shiny.render.data_frame`\n    \"\"\"\n    return bind_fill_role(\n        Tag(\n            \"shiny-data-frame\",\n            data_frame_deps(),\n            id=resolve_id(id),\n        ),\n        item=True,\n        container=True,\n    )",
  "class RenderedDeps(TypedDict):\n    deps: list[dict[str, Any]]\n    html: str",
  "def get_current_session() -> Optional[Session]:\n    \"\"\"\n    Get the current user session.\n\n    Returns\n    -------\n    :\n        The current session if one is active, otherwise ``None``.\n\n    Note\n    ----\n    Shiny apps should not need to call this function directly. Instead, it's intended to\n    be used by Shiny developing who wish to create new functions that should only be\n    called from within an active Shiny session.\n\n    See Also\n    -------\n    ~require_active_session\n    \"\"\"\n    return _current_session.get()",
  "def session_context(session: Optional[Session]):\n    \"\"\"\n    Context manager for current session.\n\n    Parameters\n    ----------\n    session\n        A :class:`~shiny.Session` instance. If not provided, it is inferred via\n        :func:`~shiny.session.get_current_session`.\n    \"\"\"\n    token: Token[Session | None] = _current_session.set(session)\n    try:\n        with namespace_context(session.ns if session else None):\n            yield\n    finally:\n        _current_session.reset(token)",
  "def require_active_session(session: Optional[Session]) -> Session:\n    \"\"\"\n    Raise an exception if no Shiny session is currently active.\n\n    Parameters\n    ----------\n    session\n        A :class:`~shiny.Session` instance. If not provided, it is inferred via\n        :func:`~shiny.session.get_current_session`.\n\n    Returns\n    -------\n    :\n        The session.\n\n    Note\n    ----\n    Shiny apps should not need to call this function directly. Instead, it's intended to\n    be used by Shiny developing who wish to create new functions that should only be\n    called from within an active Shiny session.\n\n    Raises\n    ------\n    ValueError\n        If session is not active.\n\n    See Also\n    -------\n    ~get_current_session\n    \"\"\"\n\n    if session is None:\n        session = get_current_session()\n    if session is None:\n        import inspect\n\n        call_stack = inspect.stack()\n        if len(call_stack) > 1:\n            caller = call_stack[1]\n        else:\n            # Uncommon case: this function is called from the top-level, so the caller\n            # is just require_active_session.\n            caller = call_stack[0]\n\n        calling_fn_name = caller.function\n        if calling_fn_name == \"__init__\":\n            # If the caller is __init__, then we're most likely in the initialization of\n            # an object. This will get the class name.\n            calling_fn_name = caller.frame.f_locals[\"self\"].__class__.__name__\n\n        raise RuntimeError(\n            f\"{calling_fn_name}() must be called from within an active Shiny session.\"\n        )\n    return session",
  "def read_thunk(thunk: Callable[[], T] | T) -> T:\n    if callable(thunk):\n        return thunk()\n    else:\n        return thunk",
  "def read_thunk_opt(thunk: Optional[Callable[[], T] | T]) -> Optional[T]:\n    if thunk is None:\n        return None\n    elif callable(thunk):\n        return thunk()\n    else:\n        return thunk",
  "class ConnectionState(enum.Enum):\n    Start = 0\n    Running = 1\n    Closed = 2",
  "class ProtocolError(Exception):\n    message: str\n\n    def __init__(self, message: str = \"\"):\n        super(ProtocolError, self).__init__(message)\n        self.message = message",
  "class SessionWarning(RuntimeWarning):\n    pass",
  "class ClientMessage(TypedDict):\n    method: str",
  "class ClientMessageInit(ClientMessage):\n    data: dict[str, object]",
  "class ClientMessageUpdate(ClientMessage):\n    data: dict[str, object]",
  "class ClientMessageOther(ClientMessage):\n    args: list[object]\n    tag: int",
  "class DownloadInfo:\n    filename: Callable[[], str] | str | None\n    content_type: Optional[Callable[[], str] | str]\n    handler: DownloadHandler\n    encoding: str",
  "class OutBoundMessageQueues(TypedDict):\n    values: list[dict[str, Any]]\n    input_messages: list[dict[str, Any]]\n    errors: list[dict[str, Any]]",
  "def empty_outbound_message_queues() -> OutBoundMessageQueues:\n    return {\"values\": [], \"input_messages\": [], \"errors\": []}",
  "class SessionMeta(type):\n    def __instancecheck__(self, __instance: Any) -> bool:\n        return isinstance(__instance, SessionProxy)",
  "class Session(object, metaclass=SessionMeta):\n    \"\"\"\n    A class representing a user session.\n    \"\"\"\n\n    ns: ResolvedId = Root\n\n    # These declarations are here only for pyright and stubgen to generate stub files.\n    app: App\n    id: str\n    http_conn: HTTPConnection\n    input: Inputs\n    output: Outputs\n    user: str | None\n    groups: list[str] | None\n\n    # ==========================================================================\n    # Initialization\n    # ==========================================================================\n    def __init__(\n        self, app: App, id: str, conn: Connection, debug: bool = False\n    ) -> None:\n        self.app: App = app\n        self.id: str = id\n        self._conn: Connection = conn\n        self._debug: bool = debug\n\n        # The HTTPConnection representing the WebSocket. This is used so that we can\n        # query information about the request, like headers, cookies, etc.\n        self.http_conn: HTTPConnection = conn.get_http_conn()\n\n        self.input: Inputs = Inputs(dict())\n        self.output: Outputs = Outputs(self, self.ns, dict(), dict())\n\n        self.user: str | None = None\n        self.groups: list[str] | None = None\n        credentials_json: str = \"\"\n        if \"shiny-server-credentials\" in self.http_conn.headers:\n            credentials_json = self.http_conn.headers[\"shiny-server-credentials\"]\n        elif \"rstudio-connect-credentials\" in self.http_conn.headers:\n            # Fall back to \"rstudio-connect-credentials\" if \"shiny-server-credentials\"\n            # isn't available. Note: This is only needed temporarily, because Connect\n            # treates PyShiny apps as FastAPI apps. When there's proper Shiny support,\n            # this can be removed.\n            credentials_json = self.http_conn.headers[\"rstudio-connect-credentials\"]\n        if credentials_json:\n            try:\n                creds = json.loads(credentials_json)\n                self.user = creds[\"user\"]\n                self.groups = creds[\"groups\"]\n            except Exception as e:\n                print(\"Error parsing credentials header: \" + str(e))\n\n        self._outbound_message_queues = empty_outbound_message_queues()\n\n        self._message_handlers: dict[\n            str, Callable[..., Awaitable[object]]\n        ] = self._create_message_handlers()\n        self._file_upload_manager: FileUploadManager = FileUploadManager()\n        self._on_ended_callbacks = _utils.AsyncCallbacks()\n        self._has_run_session_end_tasks: bool = False\n        self._downloads: dict[str, DownloadInfo] = {}\n        self._dynamic_routes: dict[str, DynamicRouteHandler] = {}\n\n        self._register_session_end_callbacks()\n\n        self._flush_callbacks = _utils.AsyncCallbacks()\n        self._flushed_callbacks = _utils.AsyncCallbacks()\n\n    def _register_session_end_callbacks(self) -> None:\n        # This is to be called from the initialization. It registers functions\n        # that are called when a session ends.\n\n        # Clear file upload directories, if present\n        self.on_ended(self._file_upload_manager.rm_upload_dir)\n\n    async def _run_session_end_tasks(self) -> None:\n        if self._has_run_session_end_tasks:\n            return\n        self._has_run_session_end_tasks = True\n\n        try:\n            await self._on_ended_callbacks.invoke()\n        finally:\n            self.app._remove_session(self)\n\n    async def close(self, code: int = 1001) -> None:\n        \"\"\"\n        Close the session.\n        \"\"\"\n        await self._conn.close(code, None)\n        await self._run_session_end_tasks()\n\n    async def _run(self) -> None:\n        conn_state: ConnectionState = ConnectionState.Start\n\n        def verify_state(expected_state: ConnectionState) -> None:\n            if conn_state != expected_state:\n                raise ProtocolError(\"Invalid method for the current session state\")\n\n        with contextlib.ExitStack() as stack:\n            try:\n                await self._send_message(\n                    {\n                        \"config\": {\n                            \"workerId\": \"\",\n                            \"sessionId\": self.id,\n                            \"user\": None,\n                        }\n                    }\n                )\n\n                while True:\n                    message: str = await self._conn.receive()\n                    if self._debug:\n                        print(\"RECV: \" + message, flush=True)\n\n                    try:\n                        message_obj = json.loads(\n                            message, object_hook=_utils.lists_to_tuples\n                        )\n                    except json.JSONDecodeError:\n                        warnings.warn(\n                            \"ERROR: Invalid JSON message\", SessionWarning, stacklevel=2\n                        )\n                        return\n\n                    if \"method\" not in message_obj:\n                        self._send_error_response(\"Message does not contain 'method'.\")\n                        return\n\n                    async with lock():\n                        if message_obj[\"method\"] == \"init\":\n                            verify_state(ConnectionState.Start)\n\n                            # When a reactive flush occurs, flush the session's outputs,\n                            # errors, etc. to the client. Note that this is\n                            # `reactive._core.on_flushed`, not `self.on_flushed`.\n                            unreg = on_flushed(self._flush)\n                            # When the session ends, stop flushing outputs on reactive\n                            # flush.\n                            stack.callback(unreg)\n\n                            conn_state = ConnectionState.Running\n                            message_obj = typing.cast(ClientMessageInit, message_obj)\n                            self._manage_inputs(message_obj[\"data\"])\n\n                            with session_context(self):\n                                self.app.server(self.input, self.output, self)\n\n                        elif message_obj[\"method\"] == \"update\":\n                            verify_state(ConnectionState.Running)\n\n                            message_obj = typing.cast(ClientMessageUpdate, message_obj)\n                            self._manage_inputs(message_obj[\"data\"])\n\n                        elif \"tag\" in message_obj and \"args\" in message_obj:\n                            verify_state(ConnectionState.Running)\n\n                            message_obj = typing.cast(ClientMessageOther, message_obj)\n                            await self._dispatch(message_obj)\n\n                        else:\n                            raise ProtocolError(\n                                f\"Unrecognized method {message_obj['method']}\"\n                            )\n\n                        self._request_flush()\n\n                        await flush()\n\n            except ConnectionClosed:\n                ...\n            except Exception as e:\n                try:\n                    self._send_error_response(str(e))\n                except Exception:\n                    pass\n                finally:\n                    await self.close()\n            finally:\n                await self._run_session_end_tasks()\n\n    def _manage_inputs(self, data: dict[str, object]) -> None:\n        for key, val in data.items():\n            keys = key.split(\":\")\n            if len(keys) > 2:\n                raise ValueError(\n                    \"Input name+type is not allowed to contain more than one ':' -- \"\n                    + key\n                )\n            if len(keys) == 2:\n                val = input_handlers._process_value(keys[1], val, keys[0], self)\n\n            # The keys[0] value is already a fully namespaced id; make that explicit by\n            # wrapping it in ResolvedId, otherwise self.input will throw an id\n            # validation error.\n            self.input[ResolvedId(keys[0])]._set(val)\n\n        self.output._manage_hidden()\n\n    def _is_hidden(self, name: str) -> bool:\n        with isolate():\n            # The .clientdata_output_{name}_hidden string is already a fully namespaced\n            # id; make that explicit by wrapping it in ResolvedId, otherwise self.input\n            # will throw an id validation error.\n            hidden_value_obj = cast(\n                Value[bool], self.input[ResolvedId(f\".clientdata_output_{name}_hidden\")]\n            )\n            if not hidden_value_obj.is_set():\n                return True\n\n            return hidden_value_obj()\n\n    # ==========================================================================\n    # Message handlers\n    # ==========================================================================\n\n    async def _dispatch(self, message: ClientMessageOther) -> None:\n        try:\n            func = self._message_handlers[message[\"method\"]]\n        except AttributeError:\n            self._send_error_response(\"Unknown method: \" + message[\"method\"])\n            return\n\n        try:\n            # TODO: handle `blobs`\n            value: object = await func(*message[\"args\"])\n        except Exception as e:\n            self._send_error_response(\"Error: \" + str(e))\n            return\n\n        await self._send_response(message, value)\n\n    async def _send_response(self, message: ClientMessageOther, value: object) -> None:\n        await self._send_message({\"response\": {\"tag\": message[\"tag\"], \"value\": value}})\n\n    # This is called during __init__.\n    def _create_message_handlers(self) -> dict[str, Callable[..., Awaitable[object]]]:\n        async def uploadInit(file_infos: list[FileInfo]) -> dict[str, object]:\n            with session_context(self):\n                if self._debug:\n                    print(\"Upload init: \" + str(file_infos), flush=True)\n\n                # TODO: Don't alter message in place?\n                for fi in file_infos:\n                    if fi[\"type\"] == \"\":\n                        fi[\"type\"] = _utils.guess_mime_type(fi[\"name\"])\n\n                job_id = self._file_upload_manager.create_upload_operation(file_infos)\n                worker_id = \"\"\n                return {\n                    \"jobId\": job_id,\n                    \"uploadUrl\": f\"session/{self.id}/upload/{job_id}?w={worker_id}\",\n                }\n\n        async def uploadEnd(job_id: str, input_id: str) -> None:\n            upload_op = self._file_upload_manager.get_upload_operation(job_id)\n            if upload_op is None:\n                warnings.warn(\n                    \"Received uploadEnd message for non-existent upload operation.\",\n                    SessionWarning,\n                    stacklevel=2,\n                )\n                return None\n            file_data = upload_op.finish()\n            # The input_id string is already a fully namespaced id; make that explicit\n            # by wrapping it in ResolvedId, otherwise self.input will throw an id\n            # validation error.\n            self.input[ResolvedId(input_id)]._set(file_data)\n            # Explicitly return None to signal that the message was handled.\n            return None\n\n        return {\n            \"uploadInit\": uploadInit,\n            \"uploadEnd\": uploadEnd,\n        }\n\n    # ==========================================================================\n    # Handling /session/{session_id}/{action}/{subpath} requests\n    # ==========================================================================\n    async def _handle_request(\n        self, request: Request, action: str, subpath: Optional[str]\n    ) -> ASGIApp:\n        if action == \"upload\" and request.method == \"POST\":\n            if subpath is None or subpath == \"\":\n                return HTMLResponse(\"<h1>Bad Request</h1>\", 400)\n\n            job_id = subpath\n            upload_op = self._file_upload_manager.get_upload_operation(job_id)\n            if not upload_op:\n                return HTMLResponse(\"<h1>Bad Request</h1>\", 400)\n\n            # The FileUploadOperation can have multiple files; each one will\n            # have a separate POST request. Each call to  `with upload_op` will\n            # open up each file (in sequence) for writing.\n            with upload_op:\n                async for chunk in request.stream():\n                    upload_op.write_chunk(chunk)\n\n            return PlainTextResponse(\"OK\", 200)\n\n        elif action == \"download\" and request.method == \"GET\" and subpath:\n            download_id = subpath\n            if download_id in self._downloads:\n                with session_context(self):\n                    with isolate():\n                        download = self._downloads[download_id]\n                        filename = read_thunk_opt(download.filename)\n                        content_type = read_thunk_opt(download.content_type)\n                        contents = download.handler()\n\n                        if filename is None:\n                            if isinstance(contents, str):\n                                filename = os.path.basename(contents)\n                            else:\n                                warnings.warn(\n                                    \"Unable to infer a filename for the \"\n                                    f\"'{download_id}' download handler; please use \"\n                                    \"@session.download(filename=) to specify one \"\n                                    \"manually\",\n                                    SessionWarning,\n                                    stacklevel=2,\n                                )\n                                filename = download_id\n\n                        if content_type is None:\n                            content_type = _utils.guess_mime_type(filename)\n                        content_disposition_filename = urllib.parse.quote(filename)\n                        if content_disposition_filename != filename:\n                            content_disposition = f\"attachment; filename*=utf-8''{content_disposition_filename}\"\n                        else:\n                            content_disposition = f'attachment; filename=\"{filename}\"'\n                        headers = {\n                            \"Content-Disposition\": content_disposition,\n                            \"Cache-Control\": \"no-store\",\n                        }\n\n                        if isinstance(contents, str):\n                            # contents is the path to a file\n                            return FileResponse(\n                                Path(contents),\n                                headers=headers,\n                                media_type=content_type,\n                            )\n\n                        wrapped_contents: AsyncIterable[bytes]\n\n                        if isinstance(contents, AsyncIterable):\n                            # Need to wrap the app-author-provided iterator in a\n                            # callback that installs the appropriate context mgrs.\n                            # We already use this context mgrs further up in the\n                            # implementation of handle_request(), but the iterators\n                            # aren't invoked until after handle_request() returns.\n                            async def wrap_content_async() -> AsyncIterable[bytes]:\n                                with session_context(self):\n                                    with isolate():\n                                        async for chunk in contents:\n                                            if isinstance(chunk, str):\n                                                yield chunk.encode(download.encoding)\n                                            else:\n                                                yield chunk\n\n                            wrapped_contents = wrap_content_async()\n\n                        else:  # isinstance(contents, Iterable):\n\n                            async def wrap_content_sync() -> AsyncIterable[bytes]:\n                                with session_context(self):\n                                    with isolate():\n                                        for chunk in contents:\n                                            if isinstance(chunk, str):\n                                                yield chunk.encode(download.encoding)\n                                            else:\n                                                yield chunk\n\n                            wrapped_contents = wrap_content_sync()\n\n                        # In streaming downloads, we send a 200 response, but if an\n                        # error occurs in the middle of it, the client needs to know.\n                        # With chunked encoding, the client will know if an error occurs\n                        # if it does not receive a terminating (empty) chunk.\n                        headers[\"Transfer-Encoding\"] = \"chunked\"\n\n                        return StreamingResponse(\n                            wrapped_contents,\n                            200,\n                            headers=headers,\n                            media_type=content_type,  # type: ignore\n                        )\n\n        elif action == \"dynamic_route\" and request.method == \"GET\" and subpath:\n            name = subpath\n            handler = self._dynamic_routes.get(name, None)\n            if handler is None:\n                return HTMLResponse(\"<h1>Bad Request</h1>\", 400)\n\n            with session_context(self):\n                with isolate():\n                    if _utils.is_async_callable(handler):\n                        return await handler(request)\n                    else:\n                        return handler(request)\n\n        return HTMLResponse(\"<h1>Not Found</h1>\", 404)\n\n    def send_input_message(self, id: str, message: dict[str, object]) -> None:\n        \"\"\"\n        Send an input message to the session.\n\n        Sends a message to an input on the session's client web page; if the input is\n        present and bound on the page at the time the message is received, then the\n        input binding object's ``receiveMessage(el, message)`` method will be called.\n        This method should generally not be called directly from Shiny apps, but through\n        friendlier wrapper functions like ``ui.update_text()``.\n\n        Parameters\n        ----------\n        id\n            An id matching the id of an input to update.\n        message\n            The message to send.\n        \"\"\"\n        msg: dict[str, object] = {\"id\": id, \"message\": message}\n        self._outbound_message_queues[\"input_messages\"].append(msg)\n        self._request_flush()\n\n    def _send_insert_ui(\n        self, selector: str, multiple: bool, where: str, content: RenderedDeps\n    ) -> None:\n        msg = {\n            \"selector\": selector,\n            \"multiple\": multiple,\n            \"where\": where,\n            \"content\": content,\n        }\n        self._send_message_sync({\"shiny-insert-ui\": msg})\n\n    def _send_remove_ui(self, selector: str, multiple: bool) -> None:\n        msg = {\"selector\": selector, \"multiple\": multiple}\n        self._send_message_sync({\"shiny-remove-ui\": msg})\n\n    def _send_progress(self, type: str, message: object) -> None:\n        msg: dict[str, object] = {\"progress\": {\"type\": type, \"message\": message}}\n        self._send_message_sync(msg)\n\n    @add_example()\n    async def send_custom_message(self, type: str, message: dict[str, object]) -> None:\n        \"\"\"\n        Send a message to the client.\n\n        Parameters\n        ----------\n        type\n            The type of message to send.\n        message\n            The message to send.\n\n        Note\n        ----\n        Sends messages to the client which can be handled in JavaScript with\n        ``Shiny.addCustomMessageHandler(type, function(message){...})``. Once the\n        message handler is added, it will be invoked each time ``send_custom_message()``\n        is called on the server.\n        \"\"\"\n        await self._send_message({\"custom\": {type: message}})\n\n    async def _send_message(self, message: dict[str, object]) -> None:\n        message_str: str = json.dumps(message) + \"\\n\"\n        if self._debug:\n            print(\n                \"SEND: \"\n                + re.sub(\"(?m)base64,[a-zA-Z0-9+/=]+\", \"[base64 data]\", message_str),\n                end=\"\",\n                flush=True,\n            )\n        await self._conn.send(json.dumps(message))\n\n    def _send_message_sync(self, message: dict[str, object]) -> None:\n        \"\"\"\n        Same as _send_message, except that if the message isn't too large and the socket\n        isn't too backed up, then the message may be sent synchronously instead of\n        having to wait until the current task yields (and potentially much longer than\n        that, if there is a lot of contention for the main thread).\n        \"\"\"\n        _utils.run_coro_hybrid(self._send_message(message))\n\n    def _send_error_response(self, message_str: str) -> None:\n        print(\"_send_error_response: \" + message_str)\n        pass\n\n    # ==========================================================================\n    # Flush\n    # ==========================================================================\n    @add_example()\n    def on_flush(\n        self,\n        fn: Callable[[], None] | Callable[[], Awaitable[None]],\n        once: bool = True,\n    ) -> Callable[[], None]:\n        \"\"\"\n        Register a function to call before the next reactive flush.\n\n        Parameters\n        ----------\n        fn\n            The function to call.\n        once\n            Whether to call the function only once or on every flush.\n\n        Returns\n        -------\n        :\n            A function that can be used to cancel the registration.\n        \"\"\"\n        return self._flush_callbacks.register(wrap_async(fn), once)\n\n    @add_example()\n    def on_flushed(\n        self,\n        fn: Callable[[], None] | Callable[[], Awaitable[None]],\n        once: bool = True,\n    ) -> Callable[[], None]:\n        \"\"\"\n        Register a function to call after the next reactive flush.\n\n        Parameters\n        ----------\n        fn\n            The function to call.\n        once\n            Whether to call the function only once or on every flush.\n\n        Returns\n        -------\n        :\n            A function that can be used to cancel the registration.\n        \"\"\"\n        return self._flushed_callbacks.register(wrap_async(fn), once)\n\n    def _request_flush(self) -> None:\n        self.app._request_flush(self)\n\n    async def _flush(self) -> None:\n        with session_context(self):\n            await self._flush_callbacks.invoke()\n\n        try:\n            omq = self._outbound_message_queues\n\n            values: dict[str, object] = {}\n            for v in omq[\"values\"]:\n                values.update(v)\n\n            errors: dict[str, object] = {}\n            for err in omq[\"errors\"]:\n                errors.update(err)\n\n            message: dict[str, object] = {\n                \"values\": values,\n                \"inputMessages\": omq[\"input_messages\"],\n                \"errors\": errors,\n            }\n\n            try:\n                await self._send_message(message)\n            finally:\n                self._outbound_message_queues = empty_outbound_message_queues()\n        finally:\n            with session_context(self):\n                await self._flushed_callbacks.invoke()\n\n    # ==========================================================================\n    # On session ended\n    # ==========================================================================\n    @add_example()\n    def on_ended(\n        self,\n        fn: Callable[[], None] | Callable[[], Awaitable[None]],\n    ) -> Callable[[], None]:\n        \"\"\"\n        Registers a function to be called after the client has disconnected.\n\n        Parameters\n        ----------\n        fn\n            The function to call.\n\n        Returns\n        -------\n        :\n            A function that can be used to cancel the registration.\n        \"\"\"\n        return self._on_ended_callbacks.register(wrap_async(fn))\n\n    # ==========================================================================\n    # Misc\n    # ==========================================================================\n    async def _unhandled_error(self, e: Exception) -> None:\n        print(\"Unhandled error: \" + str(e))\n        await self.close()\n\n    @add_example()\n    def download(\n        self,\n        id: Optional[str] = None,\n        filename: Optional[str | Callable[[], str]] = None,\n        media_type: None | str | Callable[[], str] = None,\n        encoding: str = \"utf-8\",\n    ) -> Callable[[DownloadHandler], None]:\n        \"\"\"\n        Decorator to register a function to handle a download.\n\n        Parameters\n        ----------\n        id\n            The name of the download.\n        filename\n            The filename of the download.\n        media_type\n            The media type of the download.\n        encoding\n            The encoding of the download.\n\n        Returns\n        -------\n        :\n            The decorated function.\n        \"\"\"\n\n        def wrapper(fn: DownloadHandler):\n            effective_name = id or fn.__name__\n\n            self._downloads[effective_name] = DownloadInfo(\n                filename=filename,\n                content_type=media_type,\n                handler=fn,\n                encoding=encoding,\n            )\n\n            @self.output(id=effective_name)\n            @render.text\n            @functools.wraps(fn)\n            def _():\n                # TODO: the `w=` parameter should eventually be a worker ID, if we add those\n                return f\"session/{urllib.parse.quote(self.id)}/download/{urllib.parse.quote(effective_name)}?w=\"\n\n        return wrapper\n\n    @add_example()\n    def dynamic_route(self, name: str, handler: DynamicRouteHandler) -> str:\n        \"\"\"\n        Register a function to call when a dynamically generated, session-specific,\n        route is requested.\n\n        Provides a convenient way to serve-up session-dependent values for other\n        clients/applications to consume.\n\n        Parameters\n        ----------\n        name\n            A name for the route (used to determine part of the URL path).\n        handler\n            The function to call when a request is made to the route. This function\n            should take a single argument (a :class:`starlette.requests.Request` object)\n            and return a :class:`starlette.types.ASGIApp` object.\n\n\n        Returns\n        -------\n        :\n            The URL path for the route.\n        \"\"\"\n\n        self._dynamic_routes.update({name: handler})\n        nonce = _utils.rand_hex(8)\n        return f\"session/{urllib.parse.quote(self.id)}/dynamic_route/{urllib.parse.quote(name)}?nonce={urllib.parse.quote(nonce)}\"\n\n    def _process_ui(self, ui: TagChild) -> RenderedDeps:\n        res = TagList(ui).render()\n        deps: list[dict[str, Any]] = []\n        for dep in res[\"dependencies\"]:\n            self.app._register_web_dependency(dep)\n            dep_dict = dep.as_dict(lib_prefix=self.app.lib_prefix)\n            deps.append(dep_dict)\n\n        return {\"deps\": deps, \"html\": res[\"html\"]}\n\n    def make_scope(self, id: Id) -> Session:\n        ns = self.ns(id)\n        return SessionProxy(parent=self, ns=ns)  # type: ignore\n\n    def root_scope(self) -> Session:\n        return self",
  "class SessionProxy:\n    ns: ResolvedId\n    input: Inputs\n    output: Outputs\n\n    def __init__(self, parent: Session, ns: ResolvedId) -> None:\n        self._parent = parent\n        self.ns = ns\n        self.input = Inputs(values=parent.input._map, ns=ns)\n        self.output = Outputs(\n            session=cast(Session, self),\n            effects=self.output._effects,\n            suspend_when_hidden=self.output._suspend_when_hidden,\n            ns=ns,\n        )\n\n    def __getattr__(self, attr: str) -> Any:\n        return getattr(self._parent, attr)\n\n    def make_scope(self, id: str) -> Session:\n        return self._parent.make_scope(self.ns(id))\n\n    def root_scope(self) -> Session:\n        res = self\n        while isinstance(res, SessionProxy):\n            res = res._parent\n        return res\n\n    def send_input_message(self, id: str, message: dict[str, object]) -> None:\n        return self._parent.send_input_message(self.ns(id), message)\n\n    def dynamic_route(self, name: str, handler: DynamicRouteHandler) -> str:\n        return self._parent.dynamic_route(self.ns(name), handler)\n\n    def download(\n        self, id: Optional[str] = None, **kwargs: object\n    ) -> Callable[[DownloadHandler], None]:\n        def wrapper(fn: DownloadHandler):\n            id_ = self.ns(id or fn.__name__)\n            return self._parent.download(id=id_, **kwargs)(fn)\n\n        return wrapper",
  "class Inputs:\n    \"\"\"\n    A class representing Shiny input values.\n\n    This class provides access to a :class:`~shiny.Session`'s input values. The\n    input values are reactive :class:`~shiny.reactive.Value`s, and can be accessed with\n    the ``[]`` operator, or with ``.``. For example, if there is an input named ``x``,\n    it can be accessed via `input[\"x\"]()` or ``input.x()``.\n    \"\"\"\n\n    def __init__(\n        self, values: dict[str, Value[Any]], ns: Callable[[str], str] = Root\n    ) -> None:\n        self._map = values\n        self._ns = ns\n\n    def __setitem__(self, key: str, value: Value[Any]) -> None:\n        if not isinstance(value, Value):\n            raise TypeError(\"`value` must be a reactive.Value object.\")\n\n        self._map[self._ns(key)] = value\n\n    def __getitem__(self, key: str) -> Value[Any]:\n        key = self._ns(key)\n        # Auto-populate key if accessed but not yet set. Needed to take reactive\n        # dependencies on input values that haven't been received from client\n        # yet.\n        if key not in self._map:\n            self._map[key] = Value[Any](read_only=True)\n\n        return self._map[key]\n\n    def __delitem__(self, key: str) -> None:\n        del self._map[self._ns(key)]\n\n    # Allow access of values as attributes.\n    def __setattr__(self, attr: str, value: Value[Any]) -> None:\n        if attr in (\"_map\", \"_ns\"):\n            super().__setattr__(attr, value)\n            return\n\n        self.__setitem__(attr, value)\n\n    def __getattr__(self, attr: str) -> Value[Any]:\n        if attr in (\"_map\", \"_ns\"):\n            return object.__getattribute__(self, attr)\n        return self.__getitem__(attr)\n\n    def __delattr__(self, key: str) -> None:\n        self.__delitem__(key)\n\n    def __contains__(self, key: str) -> bool:\n        # This looks simple, but does a number of things. By accessing `self[key]`, it\n        # indirectly calls `__getitem__`, which applies a namespace to the key, and\n        # it populates the key if it doesn't exist yet. It then calls `is_set()`, which\n        # creates a reactive dependency, and returns whether the value is set.\n        return self[key].is_set()",
  "class Outputs:\n    \"\"\"\n    A class representing Shiny output definitions.\n    \"\"\"\n\n    def __init__(\n        self,\n        session: Session,\n        ns: Callable[[str], str],\n        effects: dict[str, Effect_],\n        suspend_when_hidden: dict[str, bool],\n    ) -> None:\n        self._session = session\n        self._ns = ns\n        self._effects = effects\n        self._suspend_when_hidden = suspend_when_hidden\n\n    @overload\n    def __call__(self, renderer_fn: OutputRenderer[Any]) -> None:\n        ...\n\n    @overload\n    def __call__(\n        self,\n        *,\n        id: Optional[str] = None,\n        suspend_when_hidden: bool = True,\n        priority: int = 0,\n        name: Optional[str] = None,\n    ) -> Callable[[OutputRenderer[Any]], None]:\n        ...\n\n    def __call__(\n        self,\n        renderer_fn: Optional[OutputRenderer[OT]] = None,\n        *,\n        id: Optional[str] = None,\n        suspend_when_hidden: bool = True,\n        priority: int = 0,\n        name: Optional[str] = None,\n    ) -> None | Callable[[OutputRenderer[OT]], None]:\n        if name is not None:\n            from .. import _deprecated\n\n            _deprecated.warn_deprecated(\n                \"`@output(name=...)` is deprecated. Use `@output(id=...)` instead.\"\n            )\n            id = name\n\n        def set_renderer(renderer_fn: OutputRenderer[OT]) -> None:\n            # Get the (possibly namespaced) output id\n            output_name = self._ns(id or renderer_fn.__name__)\n\n            if not isinstance(renderer_fn, OutputRenderer):\n                raise TypeError(\n                    \"`@output` must be applied to a `@render.xx` function.\\n\"\n                    + \"In other words, `@output` must be above `@render.xx`.\"\n                )\n\n            # renderer_fn is a Renderer object. Give it a bit of metadata.\n            renderer_fn._set_metadata(self._session, output_name)\n\n            if output_name in self._effects:\n                self._effects[output_name].destroy()\n\n            self._suspend_when_hidden[output_name] = suspend_when_hidden\n\n            @Effect(\n                suspended=suspend_when_hidden and self._session._is_hidden(output_name),\n                priority=priority,\n            )\n            async def output_obs():\n                await self._session._send_message(\n                    {\"recalculating\": {\"name\": output_name, \"status\": \"recalculating\"}}\n                )\n\n                message: dict[str, Optional[OT]] = {}\n                try:\n                    if _utils.is_async_callable(renderer_fn):\n                        message[output_name] = await renderer_fn()\n                    else:\n                        message[output_name] = renderer_fn()\n                except SilentCancelOutputException:\n                    return\n                except SilentException:\n                    message[output_name] = None\n                except Exception as e:\n                    # Print traceback to the console\n                    traceback.print_exc()\n                    # Possibly sanitize error for the user\n                    if self._session.app.sanitize_errors and not isinstance(\n                        e, SafeException\n                    ):\n                        err_msg = self._session.app.sanitize_error_msg\n                    else:\n                        err_msg = str(e)\n                    # Register the outbound error message\n                    err_message = {\n                        output_name: {\n                            \"message\": err_msg,\n                            # TODO: is it possible to get the call?\n                            \"call\": None,\n                            # TODO: I don't think we actually use this for anything client-side\n                            \"type\": None,\n                        }\n                    }\n                    self._session._outbound_message_queues[\"errors\"].append(err_message)\n\n                self._session._outbound_message_queues[\"values\"].append(message)\n\n                await self._session._send_message(\n                    {\"recalculating\": {\"name\": output_name, \"status\": \"recalculated\"}}\n                )\n\n            output_obs.on_invalidate(\n                lambda: self._session._send_progress(\"binding\", {\"id\": output_name})\n            )\n\n            self._effects[output_name] = output_obs\n\n            return None\n\n        if renderer_fn is None:\n            return set_renderer\n        else:\n            return set_renderer(renderer_fn)\n\n    def _manage_hidden(self) -> None:\n        \"Suspends execution of hidden outputs and resumes execution of visible outputs.\"\n        output_names = list(self._suspend_when_hidden.keys())\n        for name in output_names:\n            if self._should_suspend(name):\n                self._effects[name].suspend()\n            else:\n                self._effects[name].resume()\n\n    def _should_suspend(self, name: str) -> bool:\n        return self._suspend_when_hidden[name] and self._session._is_hidden(name)",
  "def __init__(self, message: str = \"\"):\n        super(ProtocolError, self).__init__(message)\n        self.message = message",
  "def __instancecheck__(self, __instance: Any) -> bool:\n        return isinstance(__instance, SessionProxy)",
  "def __init__(\n        self, app: App, id: str, conn: Connection, debug: bool = False\n    ) -> None:\n        self.app: App = app\n        self.id: str = id\n        self._conn: Connection = conn\n        self._debug: bool = debug\n\n        # The HTTPConnection representing the WebSocket. This is used so that we can\n        # query information about the request, like headers, cookies, etc.\n        self.http_conn: HTTPConnection = conn.get_http_conn()\n\n        self.input: Inputs = Inputs(dict())\n        self.output: Outputs = Outputs(self, self.ns, dict(), dict())\n\n        self.user: str | None = None\n        self.groups: list[str] | None = None\n        credentials_json: str = \"\"\n        if \"shiny-server-credentials\" in self.http_conn.headers:\n            credentials_json = self.http_conn.headers[\"shiny-server-credentials\"]\n        elif \"rstudio-connect-credentials\" in self.http_conn.headers:\n            # Fall back to \"rstudio-connect-credentials\" if \"shiny-server-credentials\"\n            # isn't available. Note: This is only needed temporarily, because Connect\n            # treates PyShiny apps as FastAPI apps. When there's proper Shiny support,\n            # this can be removed.\n            credentials_json = self.http_conn.headers[\"rstudio-connect-credentials\"]\n        if credentials_json:\n            try:\n                creds = json.loads(credentials_json)\n                self.user = creds[\"user\"]\n                self.groups = creds[\"groups\"]\n            except Exception as e:\n                print(\"Error parsing credentials header: \" + str(e))\n\n        self._outbound_message_queues = empty_outbound_message_queues()\n\n        self._message_handlers: dict[\n            str, Callable[..., Awaitable[object]]\n        ] = self._create_message_handlers()\n        self._file_upload_manager: FileUploadManager = FileUploadManager()\n        self._on_ended_callbacks = _utils.AsyncCallbacks()\n        self._has_run_session_end_tasks: bool = False\n        self._downloads: dict[str, DownloadInfo] = {}\n        self._dynamic_routes: dict[str, DynamicRouteHandler] = {}\n\n        self._register_session_end_callbacks()\n\n        self._flush_callbacks = _utils.AsyncCallbacks()\n        self._flushed_callbacks = _utils.AsyncCallbacks()",
  "def _register_session_end_callbacks(self) -> None:\n        # This is to be called from the initialization. It registers functions\n        # that are called when a session ends.\n\n        # Clear file upload directories, if present\n        self.on_ended(self._file_upload_manager.rm_upload_dir)",
  "async def _run_session_end_tasks(self) -> None:\n        if self._has_run_session_end_tasks:\n            return\n        self._has_run_session_end_tasks = True\n\n        try:\n            await self._on_ended_callbacks.invoke()\n        finally:\n            self.app._remove_session(self)",
  "async def close(self, code: int = 1001) -> None:\n        \"\"\"\n        Close the session.\n        \"\"\"\n        await self._conn.close(code, None)\n        await self._run_session_end_tasks()",
  "async def _run(self) -> None:\n        conn_state: ConnectionState = ConnectionState.Start\n\n        def verify_state(expected_state: ConnectionState) -> None:\n            if conn_state != expected_state:\n                raise ProtocolError(\"Invalid method for the current session state\")\n\n        with contextlib.ExitStack() as stack:\n            try:\n                await self._send_message(\n                    {\n                        \"config\": {\n                            \"workerId\": \"\",\n                            \"sessionId\": self.id,\n                            \"user\": None,\n                        }\n                    }\n                )\n\n                while True:\n                    message: str = await self._conn.receive()\n                    if self._debug:\n                        print(\"RECV: \" + message, flush=True)\n\n                    try:\n                        message_obj = json.loads(\n                            message, object_hook=_utils.lists_to_tuples\n                        )\n                    except json.JSONDecodeError:\n                        warnings.warn(\n                            \"ERROR: Invalid JSON message\", SessionWarning, stacklevel=2\n                        )\n                        return\n\n                    if \"method\" not in message_obj:\n                        self._send_error_response(\"Message does not contain 'method'.\")\n                        return\n\n                    async with lock():\n                        if message_obj[\"method\"] == \"init\":\n                            verify_state(ConnectionState.Start)\n\n                            # When a reactive flush occurs, flush the session's outputs,\n                            # errors, etc. to the client. Note that this is\n                            # `reactive._core.on_flushed`, not `self.on_flushed`.\n                            unreg = on_flushed(self._flush)\n                            # When the session ends, stop flushing outputs on reactive\n                            # flush.\n                            stack.callback(unreg)\n\n                            conn_state = ConnectionState.Running\n                            message_obj = typing.cast(ClientMessageInit, message_obj)\n                            self._manage_inputs(message_obj[\"data\"])\n\n                            with session_context(self):\n                                self.app.server(self.input, self.output, self)\n\n                        elif message_obj[\"method\"] == \"update\":\n                            verify_state(ConnectionState.Running)\n\n                            message_obj = typing.cast(ClientMessageUpdate, message_obj)\n                            self._manage_inputs(message_obj[\"data\"])\n\n                        elif \"tag\" in message_obj and \"args\" in message_obj:\n                            verify_state(ConnectionState.Running)\n\n                            message_obj = typing.cast(ClientMessageOther, message_obj)\n                            await self._dispatch(message_obj)\n\n                        else:\n                            raise ProtocolError(\n                                f\"Unrecognized method {message_obj['method']}\"\n                            )\n\n                        self._request_flush()\n\n                        await flush()\n\n            except ConnectionClosed:\n                ...\n            except Exception as e:\n                try:\n                    self._send_error_response(str(e))\n                except Exception:\n                    pass\n                finally:\n                    await self.close()\n            finally:\n                await self._run_session_end_tasks()",
  "def _manage_inputs(self, data: dict[str, object]) -> None:\n        for key, val in data.items():\n            keys = key.split(\":\")\n            if len(keys) > 2:\n                raise ValueError(\n                    \"Input name+type is not allowed to contain more than one ':' -- \"\n                    + key\n                )\n            if len(keys) == 2:\n                val = input_handlers._process_value(keys[1], val, keys[0], self)\n\n            # The keys[0] value is already a fully namespaced id; make that explicit by\n            # wrapping it in ResolvedId, otherwise self.input will throw an id\n            # validation error.\n            self.input[ResolvedId(keys[0])]._set(val)\n\n        self.output._manage_hidden()",
  "def _is_hidden(self, name: str) -> bool:\n        with isolate():\n            # The .clientdata_output_{name}_hidden string is already a fully namespaced\n            # id; make that explicit by wrapping it in ResolvedId, otherwise self.input\n            # will throw an id validation error.\n            hidden_value_obj = cast(\n                Value[bool], self.input[ResolvedId(f\".clientdata_output_{name}_hidden\")]\n            )\n            if not hidden_value_obj.is_set():\n                return True\n\n            return hidden_value_obj()",
  "async def _dispatch(self, message: ClientMessageOther) -> None:\n        try:\n            func = self._message_handlers[message[\"method\"]]\n        except AttributeError:\n            self._send_error_response(\"Unknown method: \" + message[\"method\"])\n            return\n\n        try:\n            # TODO: handle `blobs`\n            value: object = await func(*message[\"args\"])\n        except Exception as e:\n            self._send_error_response(\"Error: \" + str(e))\n            return\n\n        await self._send_response(message, value)",
  "async def _send_response(self, message: ClientMessageOther, value: object) -> None:\n        await self._send_message({\"response\": {\"tag\": message[\"tag\"], \"value\": value}})",
  "def _create_message_handlers(self) -> dict[str, Callable[..., Awaitable[object]]]:\n        async def uploadInit(file_infos: list[FileInfo]) -> dict[str, object]:\n            with session_context(self):\n                if self._debug:\n                    print(\"Upload init: \" + str(file_infos), flush=True)\n\n                # TODO: Don't alter message in place?\n                for fi in file_infos:\n                    if fi[\"type\"] == \"\":\n                        fi[\"type\"] = _utils.guess_mime_type(fi[\"name\"])\n\n                job_id = self._file_upload_manager.create_upload_operation(file_infos)\n                worker_id = \"\"\n                return {\n                    \"jobId\": job_id,\n                    \"uploadUrl\": f\"session/{self.id}/upload/{job_id}?w={worker_id}\",\n                }\n\n        async def uploadEnd(job_id: str, input_id: str) -> None:\n            upload_op = self._file_upload_manager.get_upload_operation(job_id)\n            if upload_op is None:\n                warnings.warn(\n                    \"Received uploadEnd message for non-existent upload operation.\",\n                    SessionWarning,\n                    stacklevel=2,\n                )\n                return None\n            file_data = upload_op.finish()\n            # The input_id string is already a fully namespaced id; make that explicit\n            # by wrapping it in ResolvedId, otherwise self.input will throw an id\n            # validation error.\n            self.input[ResolvedId(input_id)]._set(file_data)\n            # Explicitly return None to signal that the message was handled.\n            return None\n\n        return {\n            \"uploadInit\": uploadInit,\n            \"uploadEnd\": uploadEnd,\n        }",
  "async def _handle_request(\n        self, request: Request, action: str, subpath: Optional[str]\n    ) -> ASGIApp:\n        if action == \"upload\" and request.method == \"POST\":\n            if subpath is None or subpath == \"\":\n                return HTMLResponse(\"<h1>Bad Request</h1>\", 400)\n\n            job_id = subpath\n            upload_op = self._file_upload_manager.get_upload_operation(job_id)\n            if not upload_op:\n                return HTMLResponse(\"<h1>Bad Request</h1>\", 400)\n\n            # The FileUploadOperation can have multiple files; each one will\n            # have a separate POST request. Each call to  `with upload_op` will\n            # open up each file (in sequence) for writing.\n            with upload_op:\n                async for chunk in request.stream():\n                    upload_op.write_chunk(chunk)\n\n            return PlainTextResponse(\"OK\", 200)\n\n        elif action == \"download\" and request.method == \"GET\" and subpath:\n            download_id = subpath\n            if download_id in self._downloads:\n                with session_context(self):\n                    with isolate():\n                        download = self._downloads[download_id]\n                        filename = read_thunk_opt(download.filename)\n                        content_type = read_thunk_opt(download.content_type)\n                        contents = download.handler()\n\n                        if filename is None:\n                            if isinstance(contents, str):\n                                filename = os.path.basename(contents)\n                            else:\n                                warnings.warn(\n                                    \"Unable to infer a filename for the \"\n                                    f\"'{download_id}' download handler; please use \"\n                                    \"@session.download(filename=) to specify one \"\n                                    \"manually\",\n                                    SessionWarning,\n                                    stacklevel=2,\n                                )\n                                filename = download_id\n\n                        if content_type is None:\n                            content_type = _utils.guess_mime_type(filename)\n                        content_disposition_filename = urllib.parse.quote(filename)\n                        if content_disposition_filename != filename:\n                            content_disposition = f\"attachment; filename*=utf-8''{content_disposition_filename}\"\n                        else:\n                            content_disposition = f'attachment; filename=\"{filename}\"'\n                        headers = {\n                            \"Content-Disposition\": content_disposition,\n                            \"Cache-Control\": \"no-store\",\n                        }\n\n                        if isinstance(contents, str):\n                            # contents is the path to a file\n                            return FileResponse(\n                                Path(contents),\n                                headers=headers,\n                                media_type=content_type,\n                            )\n\n                        wrapped_contents: AsyncIterable[bytes]\n\n                        if isinstance(contents, AsyncIterable):\n                            # Need to wrap the app-author-provided iterator in a\n                            # callback that installs the appropriate context mgrs.\n                            # We already use this context mgrs further up in the\n                            # implementation of handle_request(), but the iterators\n                            # aren't invoked until after handle_request() returns.\n                            async def wrap_content_async() -> AsyncIterable[bytes]:\n                                with session_context(self):\n                                    with isolate():\n                                        async for chunk in contents:\n                                            if isinstance(chunk, str):\n                                                yield chunk.encode(download.encoding)\n                                            else:\n                                                yield chunk\n\n                            wrapped_contents = wrap_content_async()\n\n                        else:  # isinstance(contents, Iterable):\n\n                            async def wrap_content_sync() -> AsyncIterable[bytes]:\n                                with session_context(self):\n                                    with isolate():\n                                        for chunk in contents:\n                                            if isinstance(chunk, str):\n                                                yield chunk.encode(download.encoding)\n                                            else:\n                                                yield chunk\n\n                            wrapped_contents = wrap_content_sync()\n\n                        # In streaming downloads, we send a 200 response, but if an\n                        # error occurs in the middle of it, the client needs to know.\n                        # With chunked encoding, the client will know if an error occurs\n                        # if it does not receive a terminating (empty) chunk.\n                        headers[\"Transfer-Encoding\"] = \"chunked\"\n\n                        return StreamingResponse(\n                            wrapped_contents,\n                            200,\n                            headers=headers,\n                            media_type=content_type,  # type: ignore\n                        )\n\n        elif action == \"dynamic_route\" and request.method == \"GET\" and subpath:\n            name = subpath\n            handler = self._dynamic_routes.get(name, None)\n            if handler is None:\n                return HTMLResponse(\"<h1>Bad Request</h1>\", 400)\n\n            with session_context(self):\n                with isolate():\n                    if _utils.is_async_callable(handler):\n                        return await handler(request)\n                    else:\n                        return handler(request)\n\n        return HTMLResponse(\"<h1>Not Found</h1>\", 404)",
  "def send_input_message(self, id: str, message: dict[str, object]) -> None:\n        \"\"\"\n        Send an input message to the session.\n\n        Sends a message to an input on the session's client web page; if the input is\n        present and bound on the page at the time the message is received, then the\n        input binding object's ``receiveMessage(el, message)`` method will be called.\n        This method should generally not be called directly from Shiny apps, but through\n        friendlier wrapper functions like ``ui.update_text()``.\n\n        Parameters\n        ----------\n        id\n            An id matching the id of an input to update.\n        message\n            The message to send.\n        \"\"\"\n        msg: dict[str, object] = {\"id\": id, \"message\": message}\n        self._outbound_message_queues[\"input_messages\"].append(msg)\n        self._request_flush()",
  "def _send_insert_ui(\n        self, selector: str, multiple: bool, where: str, content: RenderedDeps\n    ) -> None:\n        msg = {\n            \"selector\": selector,\n            \"multiple\": multiple,\n            \"where\": where,\n            \"content\": content,\n        }\n        self._send_message_sync({\"shiny-insert-ui\": msg})",
  "def _send_remove_ui(self, selector: str, multiple: bool) -> None:\n        msg = {\"selector\": selector, \"multiple\": multiple}\n        self._send_message_sync({\"shiny-remove-ui\": msg})",
  "def _send_progress(self, type: str, message: object) -> None:\n        msg: dict[str, object] = {\"progress\": {\"type\": type, \"message\": message}}\n        self._send_message_sync(msg)",
  "async def send_custom_message(self, type: str, message: dict[str, object]) -> None:\n        \"\"\"\n        Send a message to the client.\n\n        Parameters\n        ----------\n        type\n            The type of message to send.\n        message\n            The message to send.\n\n        Note\n        ----\n        Sends messages to the client which can be handled in JavaScript with\n        ``Shiny.addCustomMessageHandler(type, function(message){...})``. Once the\n        message handler is added, it will be invoked each time ``send_custom_message()``\n        is called on the server.\n        \"\"\"\n        await self._send_message({\"custom\": {type: message}})",
  "async def _send_message(self, message: dict[str, object]) -> None:\n        message_str: str = json.dumps(message) + \"\\n\"\n        if self._debug:\n            print(\n                \"SEND: \"\n                + re.sub(\"(?m)base64,[a-zA-Z0-9+/=]+\", \"[base64 data]\", message_str),\n                end=\"\",\n                flush=True,\n            )\n        await self._conn.send(json.dumps(message))",
  "def _send_message_sync(self, message: dict[str, object]) -> None:\n        \"\"\"\n        Same as _send_message, except that if the message isn't too large and the socket\n        isn't too backed up, then the message may be sent synchronously instead of\n        having to wait until the current task yields (and potentially much longer than\n        that, if there is a lot of contention for the main thread).\n        \"\"\"\n        _utils.run_coro_hybrid(self._send_message(message))",
  "def _send_error_response(self, message_str: str) -> None:\n        print(\"_send_error_response: \" + message_str)\n        pass",
  "def on_flush(\n        self,\n        fn: Callable[[], None] | Callable[[], Awaitable[None]],\n        once: bool = True,\n    ) -> Callable[[], None]:\n        \"\"\"\n        Register a function to call before the next reactive flush.\n\n        Parameters\n        ----------\n        fn\n            The function to call.\n        once\n            Whether to call the function only once or on every flush.\n\n        Returns\n        -------\n        :\n            A function that can be used to cancel the registration.\n        \"\"\"\n        return self._flush_callbacks.register(wrap_async(fn), once)",
  "def on_flushed(\n        self,\n        fn: Callable[[], None] | Callable[[], Awaitable[None]],\n        once: bool = True,\n    ) -> Callable[[], None]:\n        \"\"\"\n        Register a function to call after the next reactive flush.\n\n        Parameters\n        ----------\n        fn\n            The function to call.\n        once\n            Whether to call the function only once or on every flush.\n\n        Returns\n        -------\n        :\n            A function that can be used to cancel the registration.\n        \"\"\"\n        return self._flushed_callbacks.register(wrap_async(fn), once)",
  "def _request_flush(self) -> None:\n        self.app._request_flush(self)",
  "async def _flush(self) -> None:\n        with session_context(self):\n            await self._flush_callbacks.invoke()\n\n        try:\n            omq = self._outbound_message_queues\n\n            values: dict[str, object] = {}\n            for v in omq[\"values\"]:\n                values.update(v)\n\n            errors: dict[str, object] = {}\n            for err in omq[\"errors\"]:\n                errors.update(err)\n\n            message: dict[str, object] = {\n                \"values\": values,\n                \"inputMessages\": omq[\"input_messages\"],\n                \"errors\": errors,\n            }\n\n            try:\n                await self._send_message(message)\n            finally:\n                self._outbound_message_queues = empty_outbound_message_queues()\n        finally:\n            with session_context(self):\n                await self._flushed_callbacks.invoke()",
  "def on_ended(\n        self,\n        fn: Callable[[], None] | Callable[[], Awaitable[None]],\n    ) -> Callable[[], None]:\n        \"\"\"\n        Registers a function to be called after the client has disconnected.\n\n        Parameters\n        ----------\n        fn\n            The function to call.\n\n        Returns\n        -------\n        :\n            A function that can be used to cancel the registration.\n        \"\"\"\n        return self._on_ended_callbacks.register(wrap_async(fn))",
  "async def _unhandled_error(self, e: Exception) -> None:\n        print(\"Unhandled error: \" + str(e))\n        await self.close()",
  "def download(\n        self,\n        id: Optional[str] = None,\n        filename: Optional[str | Callable[[], str]] = None,\n        media_type: None | str | Callable[[], str] = None,\n        encoding: str = \"utf-8\",\n    ) -> Callable[[DownloadHandler], None]:\n        \"\"\"\n        Decorator to register a function to handle a download.\n\n        Parameters\n        ----------\n        id\n            The name of the download.\n        filename\n            The filename of the download.\n        media_type\n            The media type of the download.\n        encoding\n            The encoding of the download.\n\n        Returns\n        -------\n        :\n            The decorated function.\n        \"\"\"\n\n        def wrapper(fn: DownloadHandler):\n            effective_name = id or fn.__name__\n\n            self._downloads[effective_name] = DownloadInfo(\n                filename=filename,\n                content_type=media_type,\n                handler=fn,\n                encoding=encoding,\n            )\n\n            @self.output(id=effective_name)\n            @render.text\n            @functools.wraps(fn)\n            def _():\n                # TODO: the `w=` parameter should eventually be a worker ID, if we add those\n                return f\"session/{urllib.parse.quote(self.id)}/download/{urllib.parse.quote(effective_name)}?w=\"\n\n        return wrapper",
  "def dynamic_route(self, name: str, handler: DynamicRouteHandler) -> str:\n        \"\"\"\n        Register a function to call when a dynamically generated, session-specific,\n        route is requested.\n\n        Provides a convenient way to serve-up session-dependent values for other\n        clients/applications to consume.\n\n        Parameters\n        ----------\n        name\n            A name for the route (used to determine part of the URL path).\n        handler\n            The function to call when a request is made to the route. This function\n            should take a single argument (a :class:`starlette.requests.Request` object)\n            and return a :class:`starlette.types.ASGIApp` object.\n\n\n        Returns\n        -------\n        :\n            The URL path for the route.\n        \"\"\"\n\n        self._dynamic_routes.update({name: handler})\n        nonce = _utils.rand_hex(8)\n        return f\"session/{urllib.parse.quote(self.id)}/dynamic_route/{urllib.parse.quote(name)}?nonce={urllib.parse.quote(nonce)}\"",
  "def _process_ui(self, ui: TagChild) -> RenderedDeps:\n        res = TagList(ui).render()\n        deps: list[dict[str, Any]] = []\n        for dep in res[\"dependencies\"]:\n            self.app._register_web_dependency(dep)\n            dep_dict = dep.as_dict(lib_prefix=self.app.lib_prefix)\n            deps.append(dep_dict)\n\n        return {\"deps\": deps, \"html\": res[\"html\"]}",
  "def make_scope(self, id: Id) -> Session:\n        ns = self.ns(id)\n        return SessionProxy(parent=self, ns=ns)",
  "def root_scope(self) -> Session:\n        return self",
  "def __init__(self, parent: Session, ns: ResolvedId) -> None:\n        self._parent = parent\n        self.ns = ns\n        self.input = Inputs(values=parent.input._map, ns=ns)\n        self.output = Outputs(\n            session=cast(Session, self),\n            effects=self.output._effects,\n            suspend_when_hidden=self.output._suspend_when_hidden,\n            ns=ns,\n        )",
  "def __getattr__(self, attr: str) -> Any:\n        return getattr(self._parent, attr)",
  "def make_scope(self, id: str) -> Session:\n        return self._parent.make_scope(self.ns(id))",
  "def root_scope(self) -> Session:\n        res = self\n        while isinstance(res, SessionProxy):\n            res = res._parent\n        return res",
  "def send_input_message(self, id: str, message: dict[str, object]) -> None:\n        return self._parent.send_input_message(self.ns(id), message)",
  "def dynamic_route(self, name: str, handler: DynamicRouteHandler) -> str:\n        return self._parent.dynamic_route(self.ns(name), handler)",
  "def download(\n        self, id: Optional[str] = None, **kwargs: object\n    ) -> Callable[[DownloadHandler], None]:\n        def wrapper(fn: DownloadHandler):\n            id_ = self.ns(id or fn.__name__)\n            return self._parent.download(id=id_, **kwargs)(fn)\n\n        return wrapper",
  "def __init__(\n        self, values: dict[str, Value[Any]], ns: Callable[[str], str] = Root\n    ) -> None:\n        self._map = values\n        self._ns = ns",
  "def __setitem__(self, key: str, value: Value[Any]) -> None:\n        if not isinstance(value, Value):\n            raise TypeError(\"`value` must be a reactive.Value object.\")\n\n        self._map[self._ns(key)] = value",
  "def __getitem__(self, key: str) -> Value[Any]:\n        key = self._ns(key)\n        # Auto-populate key if accessed but not yet set. Needed to take reactive\n        # dependencies on input values that haven't been received from client\n        # yet.\n        if key not in self._map:\n            self._map[key] = Value[Any](read_only=True)\n\n        return self._map[key]",
  "def __delitem__(self, key: str) -> None:\n        del self._map[self._ns(key)]",
  "def __setattr__(self, attr: str, value: Value[Any]) -> None:\n        if attr in (\"_map\", \"_ns\"):\n            super().__setattr__(attr, value)\n            return\n\n        self.__setitem__(attr, value)",
  "def __getattr__(self, attr: str) -> Value[Any]:\n        if attr in (\"_map\", \"_ns\"):\n            return object.__getattribute__(self, attr)\n        return self.__getitem__(attr)",
  "def __delattr__(self, key: str) -> None:\n        self.__delitem__(key)",
  "def __contains__(self, key: str) -> bool:\n        # This looks simple, but does a number of things. By accessing `self[key]`, it\n        # indirectly calls `__getitem__`, which applies a namespace to the key, and\n        # it populates the key if it doesn't exist yet. It then calls `is_set()`, which\n        # creates a reactive dependency, and returns whether the value is set.\n        return self[key].is_set()",
  "def __init__(\n        self,\n        session: Session,\n        ns: Callable[[str], str],\n        effects: dict[str, Effect_],\n        suspend_when_hidden: dict[str, bool],\n    ) -> None:\n        self._session = session\n        self._ns = ns\n        self._effects = effects\n        self._suspend_when_hidden = suspend_when_hidden",
  "def __call__(self, renderer_fn: OutputRenderer[Any]) -> None:\n        ...",
  "def __call__(\n        self,\n        *,\n        id: Optional[str] = None,\n        suspend_when_hidden: bool = True,\n        priority: int = 0,\n        name: Optional[str] = None,\n    ) -> Callable[[OutputRenderer[Any]], None]:\n        ...",
  "def __call__(\n        self,\n        renderer_fn: Optional[OutputRenderer[OT]] = None,\n        *,\n        id: Optional[str] = None,\n        suspend_when_hidden: bool = True,\n        priority: int = 0,\n        name: Optional[str] = None,\n    ) -> None | Callable[[OutputRenderer[OT]], None]:\n        if name is not None:\n            from .. import _deprecated\n\n            _deprecated.warn_deprecated(\n                \"`@output(name=...)` is deprecated. Use `@output(id=...)` instead.\"\n            )\n            id = name\n\n        def set_renderer(renderer_fn: OutputRenderer[OT]) -> None:\n            # Get the (possibly namespaced) output id\n            output_name = self._ns(id or renderer_fn.__name__)\n\n            if not isinstance(renderer_fn, OutputRenderer):\n                raise TypeError(\n                    \"`@output` must be applied to a `@render.xx` function.\\n\"\n                    + \"In other words, `@output` must be above `@render.xx`.\"\n                )\n\n            # renderer_fn is a Renderer object. Give it a bit of metadata.\n            renderer_fn._set_metadata(self._session, output_name)\n\n            if output_name in self._effects:\n                self._effects[output_name].destroy()\n\n            self._suspend_when_hidden[output_name] = suspend_when_hidden\n\n            @Effect(\n                suspended=suspend_when_hidden and self._session._is_hidden(output_name),\n                priority=priority,\n            )\n            async def output_obs():\n                await self._session._send_message(\n                    {\"recalculating\": {\"name\": output_name, \"status\": \"recalculating\"}}\n                )\n\n                message: dict[str, Optional[OT]] = {}\n                try:\n                    if _utils.is_async_callable(renderer_fn):\n                        message[output_name] = await renderer_fn()\n                    else:\n                        message[output_name] = renderer_fn()\n                except SilentCancelOutputException:\n                    return\n                except SilentException:\n                    message[output_name] = None\n                except Exception as e:\n                    # Print traceback to the console\n                    traceback.print_exc()\n                    # Possibly sanitize error for the user\n                    if self._session.app.sanitize_errors and not isinstance(\n                        e, SafeException\n                    ):\n                        err_msg = self._session.app.sanitize_error_msg\n                    else:\n                        err_msg = str(e)\n                    # Register the outbound error message\n                    err_message = {\n                        output_name: {\n                            \"message\": err_msg,\n                            # TODO: is it possible to get the call?\n                            \"call\": None,\n                            # TODO: I don't think we actually use this for anything client-side\n                            \"type\": None,\n                        }\n                    }\n                    self._session._outbound_message_queues[\"errors\"].append(err_message)\n\n                self._session._outbound_message_queues[\"values\"].append(message)\n\n                await self._session._send_message(\n                    {\"recalculating\": {\"name\": output_name, \"status\": \"recalculated\"}}\n                )\n\n            output_obs.on_invalidate(\n                lambda: self._session._send_progress(\"binding\", {\"id\": output_name})\n            )\n\n            self._effects[output_name] = output_obs\n\n            return None\n\n        if renderer_fn is None:\n            return set_renderer\n        else:\n            return set_renderer(renderer_fn)",
  "def _manage_hidden(self) -> None:\n        \"Suspends execution of hidden outputs and resumes execution of visible outputs.\"\n        output_names = list(self._suspend_when_hidden.keys())\n        for name in output_names:\n            if self._should_suspend(name):\n                self._effects[name].suspend()\n            else:\n                self._effects[name].resume()",
  "def _should_suspend(self, name: str) -> bool:\n        return self._suspend_when_hidden[name] and self._session._is_hidden(name)",
  "def verify_state(expected_state: ConnectionState) -> None:\n            if conn_state != expected_state:\n                raise ProtocolError(\"Invalid method for the current session state\")",
  "async def uploadInit(file_infos: list[FileInfo]) -> dict[str, object]:\n            with session_context(self):\n                if self._debug:\n                    print(\"Upload init: \" + str(file_infos), flush=True)\n\n                # TODO: Don't alter message in place?\n                for fi in file_infos:\n                    if fi[\"type\"] == \"\":\n                        fi[\"type\"] = _utils.guess_mime_type(fi[\"name\"])\n\n                job_id = self._file_upload_manager.create_upload_operation(file_infos)\n                worker_id = \"\"\n                return {\n                    \"jobId\": job_id,\n                    \"uploadUrl\": f\"session/{self.id}/upload/{job_id}?w={worker_id}\",\n                }",
  "async def uploadEnd(job_id: str, input_id: str) -> None:\n            upload_op = self._file_upload_manager.get_upload_operation(job_id)\n            if upload_op is None:\n                warnings.warn(\n                    \"Received uploadEnd message for non-existent upload operation.\",\n                    SessionWarning,\n                    stacklevel=2,\n                )\n                return None\n            file_data = upload_op.finish()\n            # The input_id string is already a fully namespaced id; make that explicit\n            # by wrapping it in ResolvedId, otherwise self.input will throw an id\n            # validation error.\n            self.input[ResolvedId(input_id)]._set(file_data)\n            # Explicitly return None to signal that the message was handled.\n            return None",
  "def wrapper(fn: DownloadHandler):\n            effective_name = id or fn.__name__\n\n            self._downloads[effective_name] = DownloadInfo(\n                filename=filename,\n                content_type=media_type,\n                handler=fn,\n                encoding=encoding,\n            )\n\n            @self.output(id=effective_name)\n            @render.text\n            @functools.wraps(fn)\n            def _():\n                # TODO: the `w=` parameter should eventually be a worker ID, if we add those\n                return f\"session/{urllib.parse.quote(self.id)}/download/{urllib.parse.quote(effective_name)}?w=\"",
  "def wrapper(fn: DownloadHandler):\n            id_ = self.ns(id or fn.__name__)\n            return self._parent.download(id=id_, **kwargs)(fn)",
  "def set_renderer(renderer_fn: OutputRenderer[OT]) -> None:\n            # Get the (possibly namespaced) output id\n            output_name = self._ns(id or renderer_fn.__name__)\n\n            if not isinstance(renderer_fn, OutputRenderer):\n                raise TypeError(\n                    \"`@output` must be applied to a `@render.xx` function.\\n\"\n                    + \"In other words, `@output` must be above `@render.xx`.\"\n                )\n\n            # renderer_fn is a Renderer object. Give it a bit of metadata.\n            renderer_fn._set_metadata(self._session, output_name)\n\n            if output_name in self._effects:\n                self._effects[output_name].destroy()\n\n            self._suspend_when_hidden[output_name] = suspend_when_hidden\n\n            @Effect(\n                suspended=suspend_when_hidden and self._session._is_hidden(output_name),\n                priority=priority,\n            )\n            async def output_obs():\n                await self._session._send_message(\n                    {\"recalculating\": {\"name\": output_name, \"status\": \"recalculating\"}}\n                )\n\n                message: dict[str, Optional[OT]] = {}\n                try:\n                    if _utils.is_async_callable(renderer_fn):\n                        message[output_name] = await renderer_fn()\n                    else:\n                        message[output_name] = renderer_fn()\n                except SilentCancelOutputException:\n                    return\n                except SilentException:\n                    message[output_name] = None\n                except Exception as e:\n                    # Print traceback to the console\n                    traceback.print_exc()\n                    # Possibly sanitize error for the user\n                    if self._session.app.sanitize_errors and not isinstance(\n                        e, SafeException\n                    ):\n                        err_msg = self._session.app.sanitize_error_msg\n                    else:\n                        err_msg = str(e)\n                    # Register the outbound error message\n                    err_message = {\n                        output_name: {\n                            \"message\": err_msg,\n                            # TODO: is it possible to get the call?\n                            \"call\": None,\n                            # TODO: I don't think we actually use this for anything client-side\n                            \"type\": None,\n                        }\n                    }\n                    self._session._outbound_message_queues[\"errors\"].append(err_message)\n\n                self._session._outbound_message_queues[\"values\"].append(message)\n\n                await self._session._send_message(\n                    {\"recalculating\": {\"name\": output_name, \"status\": \"recalculated\"}}\n                )\n\n            output_obs.on_invalidate(\n                lambda: self._session._send_progress(\"binding\", {\"id\": output_name})\n            )\n\n            self._effects[output_name] = output_obs\n\n            return None",
  "def _():\n                # TODO: the `w=` parameter should eventually be a worker ID, if we add those\n                return f\"session/{urllib.parse.quote(self.id)}/download/{urllib.parse.quote(effective_name)}?w=\"",
  "async def output_obs():\n                await self._session._send_message(\n                    {\"recalculating\": {\"name\": output_name, \"status\": \"recalculating\"}}\n                )\n\n                message: dict[str, Optional[OT]] = {}\n                try:\n                    if _utils.is_async_callable(renderer_fn):\n                        message[output_name] = await renderer_fn()\n                    else:\n                        message[output_name] = renderer_fn()\n                except SilentCancelOutputException:\n                    return\n                except SilentException:\n                    message[output_name] = None\n                except Exception as e:\n                    # Print traceback to the console\n                    traceback.print_exc()\n                    # Possibly sanitize error for the user\n                    if self._session.app.sanitize_errors and not isinstance(\n                        e, SafeException\n                    ):\n                        err_msg = self._session.app.sanitize_error_msg\n                    else:\n                        err_msg = str(e)\n                    # Register the outbound error message\n                    err_message = {\n                        output_name: {\n                            \"message\": err_msg,\n                            # TODO: is it possible to get the call?\n                            \"call\": None,\n                            # TODO: I don't think we actually use this for anything client-side\n                            \"type\": None,\n                        }\n                    }\n                    self._session._outbound_message_queues[\"errors\"].append(err_message)\n\n                self._session._outbound_message_queues[\"values\"].append(message)\n\n                await self._session._send_message(\n                    {\"recalculating\": {\"name\": output_name, \"status\": \"recalculated\"}}\n                )",
  "async def wrap_content_async() -> AsyncIterable[bytes]:\n                                with session_context(self):\n                                    with isolate():\n                                        async for chunk in contents:\n                                            if isinstance(chunk, str):\n                                                yield chunk.encode(download.encoding)\n                                            else:\n                                                yield chunk",
  "async def wrap_content_sync() -> AsyncIterable[bytes]:\n                                with session_context(self):\n                                    with isolate():\n                                        for chunk in contents:\n                                            if isinstance(chunk, str):\n                                                yield chunk.encode(download.encoding)\n                                            else:\n                                                yield chunk",
  "def value_box(\n    title: TagChild,\n    value: TagChild,\n    *args: TagChild | TagAttrs,\n    showcase: Optional[TagChild] = None,\n    showcase_layout: Callable[[TagChild, Tag], CardItem] | None = None,\n    full_screen: bool = False,\n    theme_color: Optional[str] = \"primary\",\n    height: Optional[CssUnit] = None,\n    max_height: Optional[CssUnit] = None,\n    fill: bool = True,\n    class_: Optional[str] = None,\n    **kwargs: TagAttrValue,\n) -> Tag:\n    \"\"\"\n    Value box\n\n    An opinionated (:func:`~shiny.experimental.ui.card`-powered) box, designed for\n    displaying a `value` and `title`. Optionally, a `showcase` can provide for context\n    for what the `value` represents (for example, it could hold an icon, or even a\n    :func:`~shiny.ui.output_plot`).\n\n    Parameters\n    ----------\n    title,value\n        A string, number, or :class:`~htmltools.Tag` child to display as\n        the title or value of the value box. The `title` appears above the `value`.\n    *args\n        Unnamed arguments may be any :class:`~htmltools.Tag` children to display below\n        `value`. Named arguments are passed to :func:`~shiny.experimental.ui.card` as\n        element attributes.\n    showcase\n        A :class:`~htmltools.Tag` child to showcase (e.g., an icon, a\n        :func:`~shiny.ui.output_plot`, etc).\n    showcase_layout\n        Either :func:`~shiny.experimental.ui.showcase_left_center` or\n        :func:`~shiny.experimental.ui.showcase_top_right`.\n    theme_color\n        A theme color to use for the background color. Should match a name in the\n        Bootstrap Sass variable `$theme-colors` (e.g., `\"secondary\"`, `\"success\"`,\n        `\"danger\"`, etc).\n    height,max_height\n        Any valid CSS unit (e.g., `height=\"200px\"`). Doesn't apply when a card is made\n        `full_screen` (in this case, consider setting a `height` in\n        :func:`~shiny.experimental.ui.card_body`).\n    fill\n        Whether to allow the value box to grow/shrink to fit a fillable container with\n        an opinionated height (e.g., :func:`~shiny.experimental.ui.page_fillable`).\n    class_\n        Utility classes for customizing the appearance of the summary card. Use `bg-*`\n        and `text-*` classes (e.g, `\"bg-danger\"` and `\"text-light\"`) to customize the\n        background/foreground colors.\n    **kwargs\n        Additional attributes to pass to :func:`~shiny.experimental.ui.card`.\n\n    Returns\n    -------\n    :\n        A :func:`~shiny.experimental.ui.card`\n\n    See Also\n    --------\n    * :func:`~shiny.experimental.ui.card`\n    \"\"\"\n    attrs, children = consolidate_attrs(\n        # Must be before `attrs` so that `class_` is applied before any `attrs` values\n        {\"class\": \"bslib-value-box border-0\"},\n        {\"class\": f\"bg-{theme_color}\"} if theme_color else None,\n        *args,\n        class_=class_,\n        **kwargs,\n    )\n\n    if showcase_layout is None:\n        showcase_layout = showcase_left_center()\n    if isinstance(title, (str, int, float)):\n        title = tags.p(str(title), class_=\"h6 mb-1\")\n    if isinstance(value, (str, int, float)):\n        value = tags.p(str(value), class_=\"h2 mb-2\")\n\n    contents = div(\n        title,\n        value,\n        *children,\n        class_=\"value-box-area\",\n    )\n    contents = as_fill_carrier(contents)\n\n    if showcase is not None:\n        contents = showcase_layout(showcase, contents)\n\n    return card(\n        contents,\n        attrs,\n        value_box_dependency(),\n        full_screen=full_screen,\n        height=height,\n        max_height=max_height,\n        fill=fill,\n    )",
  "def showcase_left_center(\n    width: CssUnit = \"30%\",\n    max_height: CssUnit = \"100px\",\n    max_height_full_screen: CssUnit = \"67%\",\n) -> Callable[[TagChild | TagAttrs, Tag], CardItem]:\n    \"\"\"\n    Left center showcase for a value box\n\n    Gives the showcase a width and centers it vertically.\n\n    Parameters\n    ----------\n    width\n        A proportion (i.e., a number between 0 and 1) of available width to allocate to\n        the showcase. Or, A vector of length 2 valid CSS unit defining the width of each\n        column (for `showcase_left_center()` the 1st unit defines the showcase width and\n        for `showcase_top_right` the 2nd unit defines the showcase width). Note that any\n        units supported by the CSS grid `grid-template-columns` property may be used\n        (e.g., `fr` units).\n    max_height,max_height_full_screen\n        A proportion (i.e., a number between 0 and 1) or any valid CSS unit defining the\n        showcase max_height.\n\n    Returns\n    -------\n    :\n        A function that takes a showcase and contents and returns a :func:`~shiny.experimental.ui.card_body`\n    \"\"\"\n    return _showcase_layout(\n        width=width,\n        max_height=max_height,\n        max_height_full_screen=max_height_full_screen,\n        top_right=False,\n    )",
  "def showcase_top_right(\n    width: CssUnit = \"30%\",\n    max_height: CssUnit = \"75px\",\n    max_height_full_screen: CssUnit = \"67%\",\n) -> Callable[[TagChild | TagAttrs, Tag], CardItem]:\n    \"\"\"\n    Top right showcase for a value box\n\n    Gives the showcase a width and in the top right corner.\n\n    Parameters\n    ----------\n    width\n        A proportion (i.e., a number between 0 and 1) of available width to allocate to\n        the showcase. Or, A vector of length 2 valid CSS unit defining the width of each\n        column (for `showcase_left_center()` the 1st unit defines the showcase width and\n        for `showcase_top_right` the 2nd unit defines the showcase width). Note that any\n        units supported by the CSS grid `grid-template-columns` property may be used\n        (e.g., `fr` units).\n    max_height,max_height_full_screen\n        A proportion (i.e., a number between 0 and 1) or any valid CSS unit defining the\n        showcase max_height.\n\n    Returns\n    -------\n    :\n        A function that takes a showcase and contents and returns a :func:`~shiny.experimental.ui.card_body`\n    \"\"\"\n\n    if is_01_scalar(width):\n        width = 1 - width\n    return _showcase_layout(\n        width=width,\n        max_height=max_height,\n        max_height_full_screen=max_height_full_screen,\n        top_right=True,\n    )",
  "def _showcase_layout(\n    width: CssUnit,\n    max_height: CssUnit,\n    max_height_full_screen: CssUnit,\n    top_right: bool,\n) -> Callable[[TagChild | TagAttrs, Tag], CardItem]:\n    # Do not \"magically\" turn `0.3` into `\"30%\"` as it is not clear to the user when it happens\n    width_css_unit = as_width_unit(width)\n    max_height_css_unit = as_css_unit(max_height)\n    max_height_full_screen_css_unit = as_css_unit(max_height_full_screen)\n\n    def _layout(showcase: TagChild | TagAttrs, contents: Tag) -> CardItem:\n        css_args = {\n            \"--bslib-value-box-max-height\": max_height_css_unit,\n            \"--bslib-value-box-max-height-full-screen\": max_height_full_screen_css_unit,\n        }\n        showcase_container = div(\n            showcase,\n            {\"class\": \"value-box-showcase overflow-hidden\"},\n            {\"class\": \"showcase-top-right\"} if top_right else None,\n            style=css(**css_args),\n        )\n        showcase_container = as_fill_carrier(showcase_container)\n\n        if not top_right:\n            contents.add_class(\"border-start\")\n\n        items = [showcase_container, contents]\n        width_fs = [\"1fr\", \"auto\"]\n        if top_right:\n            items = reversed(items)\n            width_fs = reversed(width_fs)\n\n        width_fs = \" \".join(width_fs)\n\n        layout_css_args = {\n            \"--bslib-value-box-widths\": width_css_unit,\n            \"--bslib-value-box-widths-full-screen\": width_fs,\n        }\n        return card_body(\n            layout_column_wrap(\n                None,  # width\n                *items,\n                style=css(**layout_css_args),\n                gap=0,\n                heights_equal=\"row\",\n                class_=\"value-box-grid\",\n            ),\n            style=css(padding=0),\n        )\n\n    return _layout",
  "def _layout(showcase: TagChild | TagAttrs, contents: Tag) -> CardItem:\n        css_args = {\n            \"--bslib-value-box-max-height\": max_height_css_unit,\n            \"--bslib-value-box-max-height-full-screen\": max_height_full_screen_css_unit,\n        }\n        showcase_container = div(\n            showcase,\n            {\"class\": \"value-box-showcase overflow-hidden\"},\n            {\"class\": \"showcase-top-right\"} if top_right else None,\n            style=css(**css_args),\n        )\n        showcase_container = as_fill_carrier(showcase_container)\n\n        if not top_right:\n            contents.add_class(\"border-start\")\n\n        items = [showcase_container, contents]\n        width_fs = [\"1fr\", \"auto\"]\n        if top_right:\n            items = reversed(items)\n            width_fs = reversed(width_fs)\n\n        width_fs = \" \".join(width_fs)\n\n        layout_css_args = {\n            \"--bslib-value-box-widths\": width_css_unit,\n            \"--bslib-value-box-widths-full-screen\": width_fs,\n        }\n        return card_body(\n            layout_column_wrap(\n                None,  # width\n                *items,\n                style=css(**layout_css_args),\n                gap=0,\n                heights_equal=\"row\",\n                class_=\"value-box-grid\",\n            ),\n            style=css(padding=0),\n        )",
  "def input_text_area(\n    id: str,\n    label: TagChild,\n    value: str = \"\",\n    *,\n    width: Optional[str] = None,\n    height: Optional[str] = None,\n    cols: Optional[int] = None,\n    rows: Optional[int] = None,\n    placeholder: Optional[str] = None,\n    resize: Optional[Literal[\"none\", \"both\", \"horizontal\", \"vertical\"]] = None,\n    autoresize: bool = False,\n    autocomplete: Optional[str] = None,\n    spellcheck: Optional[Literal[\"true\", \"false\"]] = None,\n) -> Tag:\n    \"\"\"\n    Create a textarea input control for entry of unstructured text values. This is an\n    experimental version of :func:`~shiny.ui.input_text_area` that can automatically\n    resize to fit the input text.\n\n    Parameters\n    ----------\n    id\n        An input id.\n    label\n        An input label.\n    value\n        Initial value.\n    width\n        The CSS width, e.g. '400px', or '100%'\n    height\n        The CSS height, e.g. '400px', or '100%'\n    cols\n        Value of the visible character columns of the input, e.g. 80. This argument will\n        only take effect if there is not a CSS width rule defined for this element; such\n        a rule could come from the width argument of this function or from a containing\n        page layout such as :func:`~shiny.ui.page_fluid`.\n    rows\n        The value of the visible character rows of the input, e.g. 6. If the height\n        argument is specified, height will take precedence in the browser's rendering.\n    placeholder\n        A hint as to what can be entered into the control.\n    resize\n        Which directions the textarea box can be resized. Can be one of \"both\", \"none\",\n        \"vertical\", and \"horizontal\". The default, ``None``, will use the client\n        browser's default setting for resizing textareas.\n    autoresize\n        If True, then the textarea will automatically resize the height to fit the input\n        text.\n    autocomplete\n        Whether to enable browser autocompletion of the text input (default is \"off\").\n        If `None`, then it will use the browser's default behavior. Other possible\n        values include \"on\", \"name\", \"username\", and \"email\". See [Mozila's autocomplete\n        documentation](https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/autocomplete)\n        for more.\n    spellcheck\n        Whether to enable browser spell checking of the text input (default is None). If\n        None, then it will use the browser's default behavior.\n\n    Returns\n    -------\n    :\n        A UI element\n\n    Notes\n    ------\n\n    ::: {.callout-note title=\"Server value\"}\n    A string containing the current text input. The default value is ``\"\"`` unless\n    ``value`` is provided.\n    :::\n\n    See Also\n    -------\n    :func:`~shiny.ui.input_text`\n    \"\"\"\n\n    if resize and resize not in [\"none\", \"both\", \"horizontal\", \"vertical\"]:\n        raise ValueError(\"Invalid resize value: \" + str(resize))\n\n    classes = [\"form-control\"]\n    if autoresize:\n        classes.append(\"textarea-autoresize\")\n        if rows is None:\n            rows = 1\n\n    resolved_id = resolve_id(id)\n    area = tags.textarea(\n        value,\n        id=resolved_id,\n        class_=\" \".join(classes),\n        style=css(width=None if width else \"100%\", height=height, resize=resize),\n        placeholder=placeholder,\n        rows=rows,\n        cols=cols,\n        autocomplete=autocomplete,\n        spellcheck=spellcheck,\n    )\n\n    return div(\n        shiny_input_label(resolved_id, label),\n        area,\n        autoresize_dependency() if autoresize else None,\n        class_=\"shiny-input-textarea form-group shiny-input-container\",\n        style=css(width=width),\n    )",
  "def output_plot(\n    id: str,\n    width: str = \"100%\",\n    height: str = \"400px\",\n    *,\n    inline: bool = False,\n    click: bool | ClickOpts = False,\n    dblclick: bool | DblClickOpts = False,\n    hover: bool | HoverOpts = False,\n    brush: bool | BrushOpts = False,\n    # NEW\n    fill: bool | MISSING_TYPE = MISSING,\n    # /NEW\n) -> Tag:\n    \"\"\"\n    Create a output container for a static plot.\n\n    Place a :func:`~shiny.render.plot` result in the user interface. See\n    :func:`~shiny.render.plot` for more details on what types of plots are supported.\n\n    Parameters\n    ----------\n    id\n        An output id.\n    width\n        The CSS width, e.g. '400px', or '100%'.\n    height\n        The CSS height, e.g. '100%' or '600px'.\n    inline\n        If ``True``, the result is displayed inline.\n    click\n        This can be a boolean or an object created by :func:`~shiny.ui.click_opts`. The\n        default is `False`, but if you use `True` (or equivalently, `click_opts()`), the\n        plot will send coordinates to the server whenever it is clicked, and the value\n        will be accessible via `input.xx_click()`, where `xx` is replaced with the ID of\n        this plot. The input value will be a dictionary with `x` and `y` elements\n        indicating the mouse position.\n    dblclick\n        This is just like the `click` parameter, but for double-click events.\n    hover\n        Similar to the `click` argument, this can be a boolean or an object created by\n        :func:`~shiny.ui.hover_opts`. The default is `False`, but if you use `True` (or\n        equivalently, `hover_opts()`), the plot will send coordinates to the server\n        whenever it is clicked, and the value will be accessible via `input.xx_hover()`,\n        where `xx` is replaced with the ID of this plot. The input value will be a\n        dictionary with `x` and `y` elements indicating the mouse position. To control\n        the hover time or hover delay type, use :func:`~shiny.ui.hover_opts`.\n    brush\n        Similar to the `click` argument, this can be a boolean or an object created by\n        :func:`~shiny.ui.brush_opts`. The default is `False`, but if you use `True` (or\n        equivalently, `brush_opts()`), the plot will allow the user to \"brush\" in the\n        plotting area, and will send information about the brushed area to the server,\n        and the value will be accessible via `input.plot_brush()`. Brushing means that\n        the user will be able to draw a rectangle in the plotting area and drag it\n        around. The value will be a named list with `xmin`, `xmax`, `ymin`, and `ymax`\n        elements indicating the brush area. To control the brush behavior, use\n        :func:`~shiny.ui.brush_opts`. Multiple `output_image`/`output_plot` calls may\n        share the same `id` value; brushing one image or plot will cause any other\n        brushes with the same `id` to disappear.\n\n    Returns\n    -------\n    :\n        A UI element\n\n    See Also\n    -------\n    * :func:`~shiny.render.plot`\n    * :func:`~shiny.ui.output_image`\n    \"\"\"\n\n    # NEW\n    if isinstance(fill, MISSING_TYPE):\n        fill = not inline\n    # /NEW\n\n    res = output_image(\n        id=id,\n        width=width,\n        height=height,\n        inline=inline,\n        click=click,\n        dblclick=dblclick,\n        hover=hover,\n        brush=brush,\n        # NEW\n        fill=fill,\n        # /NEW\n    )\n    res.add_class(\"shiny-plot-output\")\n    return res",
  "def output_image(\n    id: str,\n    width: str = \"100%\",\n    height: str = \"400px\",\n    *,\n    inline: bool = False,\n    click: bool | ClickOpts = False,\n    dblclick: bool | DblClickOpts = False,\n    hover: bool | HoverOpts = False,\n    brush: bool | BrushOpts = False,\n    # NEW\n    fill: bool = False,\n    # /NEW\n) -> Tag:\n    \"\"\"\n    Create a output container for a static image.\n\n    Parameters\n    ----------\n    id\n        An output id.\n    width\n        The CSS width, e.g. '400px', or '100%'.\n    height\n        The CSS height, e.g. '100%' or '600px'.\n    inline\n        If ``True``, the result is displayed inline.\n    click\n        This can be a boolean or an object created by :func:`~shiny.ui.click_opts`. The\n        default is `False`, but if you use `True` (or equivalently, `click_opts()`), the\n        plot will send coordinates to the server whenever it is clicked, and the value\n        will be accessible via `input.xx_click()`, where `xx` is replaced with the ID of\n        this plot. The input value will be a dictionary with `x` and `y` elements\n        indicating the mouse position.\n    dblclick\n        This is just like the `click` parameter, but for double-click events.\n    hover\n        Similar to the `click` argument, this can be a boolean or an object created by\n        :func:`~shiny.ui.hover_opts`. The default is `False`, but if you use `True` (or\n        equivalently, `hover_opts()`), the plot will send coordinates to the server\n        whenever it is clicked, and the value will be accessible via `input.xx_hover()`,\n        where `xx` is replaced with the ID of this plot. The input value will be a\n        dictionary with `x` and `y` elements indicating the mouse position. To control\n        the hover time or hover delay type, use :func:`~shiny.ui.hover_opts`.\n    brush\n        Similar to the `click` argument, this can be a boolean or an object created by\n        :func:`~shiny.ui.brush_opts`. The default is `False`, but if you use `True` (or\n        equivalently, `brush_opts()`), the plot will allow the user to \"brush\" in the\n        plotting area, and will send information about the brushed area to the server,\n        and the value will be accessible via `input.plot_brush()`. Brushing means that\n        the user will be able to draw a rectangle in the plotting area and drag it\n        around. The value will be a named list with `xmin`, `xmax`, `ymin`, and `ymax`\n        elements indicating the brush area. To control the brush behavior, use\n        :func:`~shiny.ui.brush_opts`. Multiple `output_image`/`output_plot` calls may\n        share the same `id` value; brushing one image or plot will cause any other\n        brushes with the same `id` to disappear.\n\n    Returns\n    -------\n    :\n        A UI element\n\n    See Also\n    -------\n    ~shiny.render.image\n    ~shiny.ui.output_plot\n    \"\"\"\n    func = tags.span if inline else div\n    style = None if inline else css(width=width, height=height)\n\n    args: dict[str, str] = dict()\n\n    id_resolved = resolve_id(id)\n\n    if click is not False:\n        if click is True:\n            click = click_opts()\n        click[\"id\"] = id_resolved + \"_click\"\n        args.update(**format_opt_names(click, \"click\"))\n\n    if dblclick is not False:\n        if dblclick is True:\n            dblclick = dblclick_opts()\n        dblclick[\"id\"] = id_resolved + \"_dblclick\"\n        args.update(**format_opt_names(dblclick, \"dblclick\"))\n\n    if hover is not False:\n        if hover is True:\n            hover = hover_opts()\n        hover[\"id\"] = id_resolved + \"_hover\"\n        args.update(**format_opt_names(hover, \"hover\"))\n\n    if brush is not False:\n        if brush is True:\n            brush = brush_opts()\n        brush[\"id\"] = id_resolved + \"_brush\"\n        args.update(**format_opt_names(brush, \"brush\"))\n\n    container = func(\n        id=id_resolved,\n        class_=\"shiny-image-output\",\n        style=style,\n        **args,\n    )\n    if fill:\n        container = as_fill_item(container)\n\n    return container",
  "def output_ui(\n    id: str,\n    inline: bool = False,\n    container: Optional[TagFunction] = None,\n    # NEW\n    fill: bool = False,\n    fillable: bool = False,\n    # /NEW\n    **kwargs: TagAttrValue,\n) -> Tag:\n    \"\"\"\n    Create a output container for a UI (i.e., HTML) element.\n\n    Parameters\n    ----------\n    id\n        An output id.\n    inline\n        If ``True``, the result is displayed inline\n    container\n        A Callable that returns the output container.\n    kwargs\n        Attributes to be applied to the output container.\n\n    Returns\n    -------\n    :\n        A UI element\n\n    See Also\n    -------\n    ~shiny.render.ui\n    ~shiny.ui.output_text\n    \"\"\"\n\n    if not container:\n        container = tags.span if inline else tags.div\n    res = container(\n        {\"class\": \"shiny-html-output\"},\n        id=resolve_id(id),\n        **kwargs,\n    )\n\n    if fillable:\n        res = as_fillable_container(res)\n    if fill:\n        res = as_fill_item(res)\n\n    return res",
  "def tooltip(\n    trigger: TagChild,\n    *args: TagChild | TagAttrs,\n    id: Optional[str] = None,\n    placement: Literal[\"auto\", \"top\", \"right\", \"bottom\", \"left\"] = \"auto\",\n    options: Optional[dict[str, object]] = None,\n    **kwargs: TagAttrValue,\n) -> Tag:\n    \"\"\"\n    Add a tooltip to a UI element\n\n    Display additional information when focusing (or hovering over) a UI element.\n\n    Parameters\n    ----------\n    trigger\n        A UI element (i.e., :class:`~htmltools.Tag`) to serve as the tooltips trigger.\n        It's good practice for this element to be a keyboard-focusable and interactive\n        element (e.g., :func:`~shiny.ui.input_action_button`,\n        :func:`~shiny.ui.input_action_link`, etc.) so that the tooltip is accessible to\n        keyboard and assistive technology users.\n    *args\n        Contents to the tooltip's body. Or tag attributes that are supplied to the\n        resolved :class:`~htmltools.Tag` object.\n    id\n        A character string. Required to re-actively respond to the visibility of the\n        tooltip (via the `input[id]` value) and/or update the visibility/contents of the\n        tooltip.\n    placement\n        The placement of the tooltip relative to its trigger.\n    options\n        A list of additional [Bootstrap\n        options](https://getbootstrap.com/docs/5.2/components/tooltips/#options).\n\n    Details\n    -------\n\n    If `trigger` yields multiple HTML elements (e.g., a :class:`~htmltools.TagList` or\n    complex [`shinywidgets`](https://github.com/posit-dev/py-shinywidgets) object), the\n    last HTML element is used as the trigger. If the `trigger` should contain all of\n    those elements, wrap the object in a :func:`~shiny.ui.tags.div` or\n    :func:`~shiny.ui.tags.span`.\n\n    See Also\n    --------\n\n    * [Bootstrap tooltips documentation](https://getbootstrap.com/docs/5.2/components/tooltips/)\n    \"\"\"\n    attrs, children = consolidate_attrs(*args, **kwargs)\n\n    if len(children) == 0:\n        raise RuntimeError(\"At least one value must be provided to `*args: TagChild`\")\n\n    res = web_component(\n        \"bslib-tooltip\",\n        {\n            \"id\": resolve_id_or_none(id),\n            \"placement\": placement,\n            \"options\": json.dumps(options) if options else None,\n        },\n        attrs,\n        # Use display:none instead of <template> since shiny.js\n        # doesn't bind to the contents of the latter\n        tags.template(*children, {\"style\": \"display:none;\"}),\n        trigger,\n    )\n\n    return res",
  "def _session_on_flush_send_msg(\n    id: str, session: Session | None, msg: dict[str, object]\n) -> None:\n    session = require_active_session(session)\n    session.on_flush(lambda: session.send_input_message(id, msg), once=True)",
  "def toggle_tooltip(\n    id: str, show: Optional[bool] = None, session: Optional[Session] = None\n) -> None:\n    \"\"\"\n    Programmatically show/hide a tooltip\n\n    Parameters\n    ----------\n    id\n        A character string that matches an existing tooltip id.\n    show\n        Whether to show (`True`) or hide (`False`) the tooltip. The default (`None`)\n        will show if currently hidden and hide if currently shown. Note that a tooltip\n        will not be shown if the trigger is not visible (e.g., it's hidden behind a\n        tab).\n    session\n        A Shiny session object (the default should almost always be used).\n    \"\"\"\n    _session_on_flush_send_msg(\n        id,\n        session,\n        {\n            \"method\": \"toggle\",\n            \"value\": _normalize_show_value(show),\n        },\n    )",
  "def update_tooltip(id: str, *args: TagChild, session: Optional[Session] = None) -> None:\n    _session_on_flush_send_msg(\n        id,\n        session,\n        drop_none(\n            {\n                \"method\": \"update\",\n                \"title\": require_active_session(session)._process_ui(TagList(*args))\n                if len(args) > 0\n                else None,\n            }\n        ),\n    )",
  "def _normalize_show_value(show: bool | None) -> Literal[\"toggle\", \"show\", \"hide\"]:\n    if show is None:\n        return \"toggle\"\n    return \"show\" if show else \"hide\"",
  "def page_sidebar(\n    sidebar: Sidebar | TagChild | TagAttrs,\n    *args: TagChild | TagAttrs,\n    title: Optional[str | Tag | TagList] = None,\n    fillable: bool = True,\n    fillable_mobile: bool = False,\n    window_title: str | MISSING_TYPE = MISSING,\n    lang: Optional[str] = None,\n    **kwargs: TagAttrValue,\n) -> Tag:\n    \"\"\"\n    Create a page with a sidebar and a title.\n\n    Parameters\n    ----------\n    sidebar\n        Content to display in the sidebar.\n    args\n        UI elements.\n    title\n        A title to display at the top of the page.\n    fillable\n        Whether or not the main content area should be considered a fillable\n        (i.e., flexbox) container.\n    fillable_mobile\n        Whether or not ``fillable`` should apply on mobile devices.\n    window_title\n        The browser's window title (defaults to the host URL of the page). Can also be\n        set as a side effect via :func:`~shiny.ui.panel_title`.\n    lang\n        ISO 639-1 language code for the HTML page, such as ``\"en\"`` or ``\"ko\"``. This\n        will be used as the lang in the ``<html>`` tag, as in ``<html lang=\"en\">``. The\n        default, `None`, results in an empty string.\n    kwargs\n        Additional attributes passed to :func:`~shiny.ui.layout_sidebar`.\n\n    Returns\n    -------\n    :\n        A UI element.\n    \"\"\"\n\n    if isinstance(title, str):\n        title = tags.h1(title, class_=\"bslib-page-title\")\n\n    attrs, children = consolidate_attrs(*args, **kwargs)\n\n    return page_fillable(\n        title,\n        layout_sidebar(\n            sidebar,\n            *children,\n            attrs,\n            fillable=fillable,\n            border=False,\n            border_radius=False,\n        ),\n        get_window_title(title, window_title=window_title),\n        page_sidebar_dependency(),\n        padding=0,\n        gap=0,\n        lang=lang,\n        fillable_mobile=fillable_mobile,\n    )",
  "def page_navbar(\n    *args: NavSetArg | MetadataNode | Sequence[MetadataNode],\n    title: Optional[str | Tag | TagList] = None,\n    id: Optional[str] = None,\n    selected: Optional[str] = None,\n    sidebar: Optional[Sidebar] = None,\n    # Only page_navbar gets enhancedtreatement for `fillable`\n    # If an `*args`'s `data-value` attr string is in `fillable`, then the component is fillable\n    fillable: bool | list[str] = True,\n    fillable_mobile: bool = False,\n    gap: Optional[CssUnit] = None,\n    padding: Optional[CssUnit | list[CssUnit]] = None,\n    position: Literal[\"static-top\", \"fixed-top\", \"fixed-bottom\"] = \"static-top\",\n    header: Optional[TagChild] = None,\n    footer: Optional[TagChild] = None,\n    bg: Optional[str] = None,\n    inverse: bool = True,\n    collapsible: bool = True,\n    fluid: bool = True,\n    window_title: str | MISSING_TYPE = MISSING,\n    lang: Optional[str] = None,\n) -> Tag:\n    \"\"\"\n    Create a page with a navbar and a title.\n\n    Parameters\n    ----------\n    args\n        UI elements.\n    title\n        The browser window title (defaults to the host URL of the page). Can also be set\n        as a side effect via :func:`~shiny.ui.panel_title`.\n    id\n        If provided, will create an input value that holds the currently selected nav\n        item.\n    selected\n        Choose a particular nav item to select by default value (should match it's\n        ``value``).\n    sidebar\n        A :func:`~shiny.experimental.ui.sidebar` component to display on every page.\n    fillable\n        Whether or not the main content area should be considered a fillable\n        (i.e., flexbox) container.\n    fillable_mobile\n        Whether or not ``fillable`` should apply on mobile devices.\n    position\n        Determines whether the navbar should be displayed at the top of the page with\n        normal scrolling behavior (\"static-top\"), pinned at the top (\"fixed-top\"), or\n        pinned at the bottom (\"fixed-bottom\"). Note that using \"fixed-top\" or\n        \"fixed-bottom\" will cause the navbar to overlay your body content, unless you\n        add padding (e.g., ``tags.style(\"body {padding-top: 70px;}\")``).\n    header\n        UI to display above the selected content.\n    footer\n        UI to display below the selected content.\n    bg\n        Background color of the navbar (a CSS color).\n    inverse\n        Either ``True`` for a light text color or ``False`` for a dark text color.\n    collapsible\n        ``True`` to automatically collapse the elements into an expandable menu on mobile devices or narrow window widths.\n    fluid\n        ``True`` to use fluid layout; ``False`` to use fixed layout.\n    window_title\n        The browser's window title (defaults to the host URL of the page). Can also be\n        set as a side effect via :func:`~shiny.ui.panel_title`.\n    lang\n        ISO 639-1 language code for the HTML page, such as ``\"en\"`` or ``\"ko\"``. This\n        will be used as the lang in the ``<html>`` tag, as in ``<html lang=\"en\">``. The\n        default, `None`, results in an empty string.\n\n    Returns\n    -------\n    :\n        A UI element.\n\n    See Also\n    -------\n    * :func:`~shiny.ui.nav`\n    * :func:`~shiny.ui.nav_menu`\n    * :func:`~shiny.experimental.ui.navset_bar`\n    * :func:`~shiny.ui.page_fluid`\n\n    Example\n    -------\n    See :func:`~shiny.ui.nav`.\n    \"\"\"\n    if sidebar is not None and not isinstance(sidebar, Sidebar):\n        raise TypeError(\n            \"`sidebar=` is not a `Sidebar` instance. Use `ui.sidebar(...)` to create one.\"\n        )\n\n    # If a sidebar is provided, we want the layout_sidebar(fill = TRUE) component\n    # (which is a sibling of the <nav>) to always fill the page\n    if fillable is False and sidebar is None:\n        # `page_func = page_bootstrap` throws type errors. Wrap in a function to get around them\n        def page_func(*args: TagChild | TagAttrs, **kwargs: TagAttrValue) -> Tag:\n            return page_bootstrap(*args, **kwargs)\n\n    else:\n\n        def page_func(*args: TagChild | TagAttrs, **kwargs: TagAttrValue) -> Tag:\n            return page_fillable(\n                *args,\n                fillable_mobile=fillable_mobile,\n                padding=0,\n                gap=0,\n                **kwargs,\n            )\n\n    return page_func(\n        navset_bar(\n            *args,\n            title=title,\n            id=id,\n            selected=selected,\n            sidebar=sidebar,\n            fillable=fillable,\n            gap=gap,\n            padding=padding,\n            position=position,\n            header=header,\n            footer=footer,\n            bg=bg,\n            inverse=inverse,\n            collapsible=collapsible,\n            fluid=fluid,\n        ),\n        get_window_title(title, window_title=window_title),\n        title=None,\n        # theme = theme,\n        lang=lang,\n    )",
  "def page_fillable(\n    *args: TagChild | TagAttrs,\n    padding: Optional[CssUnit | list[CssUnit]] = None,\n    gap: Optional[CssUnit] = None,\n    fillable_mobile: bool = False,\n    title: Optional[str] = None,\n    lang: Optional[str] = None,\n    **kwargs: TagAttrValue,\n) -> Tag:\n    \"\"\"\n    Creates a fillable page\n\n    Parameters\n    ----------\n    *args\n        UI elements.\n    padding\n        Padding to use for the body. See :func:`~shiny.experimental.ui.as_css_padding`\n        for more details.\n    fillable_mobile\n        Whether or not the page should fill the viewport's height on mobile devices\n        (i.e., narrow windows).\n    gap\n        A CSS length unit passed through :func:`~shiny.experimental.ui.as_css_unit`\n        defining the `gap` (i.e., spacing) between elements provided to `*args`.\n    title\n        The browser window title (defaults to the host URL of the page). Can also be set\n        as a side effect via :func:`~shiny.ui.panel_title`.\n    lang\n        ISO 639-1 language code for the HTML page, such as ``\"en\"`` or ``\"ko\"``. This\n        will be used as the lang in the ``<html>`` tag, as in ``<html lang=\"en\">``. The\n        default, `None`, results in an empty string.\n\n    Returns\n    -------\n    :\n        A UI element.\n\n    See Also\n    -------\n    * :func:`~shiny.ui.page_fluid`\n    * :func:`~shiny.ui.page_fixed`\n    \"\"\"\n    attrs, children = consolidate_attrs(*args, **kwargs)\n\n    style = css(\n        padding=as_css_padding(padding),\n        gap=as_css_unit(gap),\n        __bslib_page_fill_mobile_height=\"100%\" if fillable_mobile else \"auto\",\n    )\n\n    return page_bootstrap(\n        head_content(tags.style(\"html { height: 100%; }\")),\n        as_fillable_container(\n            tags.body(\n                {\"class\": \"bslib-page-fill bslib-gap-spacing\", \"style\": style},\n                attrs,\n                *children,\n            )\n        ),\n        page_fillable_dependency(),\n        title=title,\n        lang=lang,\n    )",
  "def page_func(*args: TagChild | TagAttrs, **kwargs: TagAttrValue) -> Tag:\n            return page_bootstrap(*args, **kwargs)",
  "def page_func(*args: TagChild | TagAttrs, **kwargs: TagAttrValue) -> Tag:\n            return page_fillable(\n                *args,\n                fillable_mobile=fillable_mobile,\n                padding=0,\n                gap=0,\n                **kwargs,\n            )",
  "def web_component(\n    tag_name: str,\n    *args: TagChild | TagAttrs,\n    **kwargs: TagAttrValue,\n) -> Tag:\n    return Tag(\n        tag_name,\n        web_component_dependency(),\n        *args,\n        _add_ws=False,\n        **kwargs,\n    )",
  "class Nav:\n    nav: Tag\n    content: Optional[Tag]\n\n    def __init__(self, nav: Tag, content: Optional[Tag] = None) -> None:\n        self.nav = nav\n        # nav_control()/nav_spacer() have None as their content\n        self.content = content\n\n    def resolve(\n        self, selected: Optional[str], context: dict[str, Any]\n    ) -> tuple[TagChild, TagChild]:\n        # Nothing to do for nav_control()/nav_spacer()\n        if self.content is None:\n            return self.nav, None\n\n        # At least currently, in the case where both nav and content are tags\n        # (i.e., nav()), the nav always has a child <a> tag...I'm not sure if\n        # there's a way to statically type this\n        nav = copy.deepcopy(self.nav)\n        a_tag = cast(Tag, nav.children[0])\n        if context.get(\"is_menu\", False):\n            a_tag.add_class(\"dropdown-item\")\n        else:\n            a_tag.add_class(\"nav-link\")\n            nav.add_class(\"nav-item\")\n\n        # Hyperlink the nav to the content\n        content = copy.copy(self.content)\n        if \"tabsetid\" in context and \"index\" in context:\n            id = f\"tab-{context['tabsetid']}-{context['index']}\"\n            content.attrs[\"id\"] = id\n            a_tag.attrs[\"href\"] = f\"#{id}\"\n\n        # Mark the nav/content as active if it should be\n        if isinstance(selected, str) and selected == self.get_value():\n            content.add_class(\"active\")\n            a_tag.add_class(\"active\")\n\n        nav.children[0] = a_tag\n\n        return nav, content\n\n    def get_value(self) -> Optional[str]:\n        if self.content is None:\n            return None\n        a_tag = cast(Tag, self.nav.children[0])\n        return a_tag.attrs.get(\"data-value\", None)\n\n    def tagify(self) -> None:\n        raise NotImplementedError(\n            \"nav() items must appear within navset_*() container.\"\n        )",
  "class NavSet:\n    args: tuple[NavSetArg | MetadataNode]\n    ul_class: str\n    id: Optional[str]\n    selected: Optional[str]\n    header: TagChild\n    footer: TagChild\n\n    def __init__(\n        self,\n        *args: NavSetArg | MetadataNode,\n        ul_class: str,\n        id: Optional[str],\n        selected: Optional[str],\n        header: TagChild = None,\n        footer: TagChild = None,\n    ) -> None:\n        self.args = args\n        self.ul_class = ul_class\n        self.id = id\n        self.selected = selected\n        self.header = header\n        self.footer = footer\n\n    def tagify(self) -> TagList | Tag:\n        id = self.id\n        ul_class = self.ul_class\n        if id is not None:\n            ul_class += \" shiny-tab-input\"\n\n        nav, content = _render_navset(\n            *self.args, ul_class=ul_class, id=id, selected=self.selected, context={}\n        )\n        return self.layout(nav, content).tagify()\n\n    # Types must match output of `_render_navset() -> Tuple[Tag, Tag]`\n    def layout(self, nav: Tag, content: Tag) -> TagList | Tag:\n        return TagList(nav, self.header, content, self.footer)",
  "class NavSetCard(NavSet):\n    placement: Literal[\"above\", \"below\"]\n    sidebar: Optional[Sidebar]\n\n    def __init__(\n        self,\n        *args: NavSetArg,\n        ul_class: str,\n        id: Optional[str],\n        selected: Optional[str],\n        sidebar: Optional[Sidebar] = None,\n        header: TagChild = None,\n        footer: TagChild = None,\n        placement: Literal[\"above\", \"below\"] = \"above\",\n    ) -> None:\n        super().__init__(\n            *args,\n            ul_class=ul_class,\n            id=id,\n            selected=selected,\n            header=header,\n            footer=footer,\n        )\n        self.sidebar = sidebar\n        self.placement = placement\n\n    def layout(self, nav: Tag, content: Tag) -> Tag:\n        # navs = [child for child in content.children if isinstance(child, Nav)]\n        # not_navs = [child for child in content.children if child not in navs]\n        content_val: Tag | CardItem = content\n\n        if self.sidebar:\n            content_val = navset_card_body(content, sidebar=self.sidebar)\n\n        if self.placement == \"below\":\n            # TODO-carson; have carson double check this change\n            return card(\n                card_header(self.header) if self.header else None,\n                content_val,\n                card_body(self.footer, fillable=False, fill=False)\n                if self.footer\n                else None,\n                card_footer(nav),\n            )\n        else:\n            # TODO-carson; have carson double check this change\n            return card(\n                card_header(nav),\n                card_body(self.header, fill=False, fillable=False)\n                if self.header\n                else None,\n                content_val,\n                card_footer(self.footer) if self.footer else None,\n            )",
  "def navset_card_body(content: Tag, sidebar: Optional[Sidebar] = None) -> CardItem:\n    content = _make_tabs_fillable(content, fillable=True, gap=0, padding=0)\n    if sidebar:\n        return layout_sidebar(\n            sidebar,\n            content,\n            fillable=True,\n            border=False,\n        )\n    else:\n        return CardItem(content)",
  "def navset_card_tab(\n    *args: NavSetArg,\n    id: Optional[str] = None,\n    selected: Optional[str] = None,\n    sidebar: Optional[Sidebar] = None,\n    header: TagChild = None,\n    footer: TagChild = None,\n) -> NavSetCard:\n    \"\"\"\n    Render nav items as a tabset inside a card container.\n\n    Parameters\n    ----------\n    *args\n        A collection of nav items (e.g., :func:`shiny.ui.nav`).\n    id\n        If provided, will create an input value that holds the currently selected nav\n        item.\n    selected\n        Choose a particular nav item to select by default value (should match it's\n        ``value``).\n    header\n        UI to display above the selected content.\n    footer\n        UI to display below the selected content.\n\n    See Also\n    -------\n    * ~shiny.ui.nav\n    * ~shiny.ui.nav_menu\n    * ~shiny.ui.nav_control\n    * ~shiny.ui.nav_spacer\n    * ~shiny.experimental.ui.navset_bar\n    * ~shiny.ui.navset_tab\n    * ~shiny.ui.navset_pill\n    * ~shiny.experimental.ui.navset_card_pill\n    * ~shiny.ui.navset_hidden\n\n    Example\n    -------\n    See :func:`~shiny.ui.nav`\n    \"\"\"\n\n    return NavSetCard(\n        *args,\n        ul_class=\"nav nav-tabs card-header-tabs\",\n        id=resolve_id_or_none(id),\n        selected=selected,\n        sidebar=sidebar,\n        header=header,\n        footer=footer,\n        placement=\"above\",\n    )",
  "def navset_card_pill(\n    *args: NavSetArg,\n    id: Optional[str] = None,\n    selected: Optional[str] = None,\n    sidebar: Optional[Sidebar] = None,\n    header: TagChild = None,\n    footer: TagChild = None,\n    placement: Literal[\"above\", \"below\"] = \"above\",\n) -> NavSetCard:\n    \"\"\"\n    Render nav items as a pillset inside a card container.\n\n    Parameters\n    ----------\n    *args\n        A collection of nav items (e.g., :func:`shiny.ui.nav`).\n    id\n        If provided, will create an input value that holds the currently selected nav\n        item.\n    selected\n        Choose a particular nav item to select by default value (should match it's\n        ``value``).\n    header\n        UI to display above the selected content.\n    footer\n        UI to display below the selected content.\n    placement\n        Placement of the nav items relative to the content.\n\n    See Also\n    -------\n    * ~shiny.ui.nav\n    * ~shiny.ui.nav_menu\n    * ~shiny.ui.nav_control\n    * ~shiny.ui.nav_spacer\n    * ~shiny.experimental.ui.navset_bar\n    * ~shiny.ui.navset_tab\n    * ~shiny.ui.navset_pill\n    * ~shiny.experimental.ui.navset_card_tab\n    * ~shiny.ui.navset_hidden\n\n    Example\n    -------\n    See :func:`~shiny.ui.nav`\n    \"\"\"\n\n    return NavSetCard(\n        *args,\n        ul_class=\"nav nav-pills card-header-pills\",\n        id=resolve_id_or_none(id),\n        selected=selected,\n        sidebar=sidebar,\n        header=header,\n        footer=footer,\n        placement=placement,\n    )",
  "class NavSetBar(NavSet):\n    title: TagChild\n    sidebar: Optional[Sidebar]\n    fillable: bool | list[str]\n    gap: Optional[CssUnit]\n    padding: Optional[CssUnit | list[CssUnit]]\n    position: Literal[\"static-top\", \"fixed-top\", \"fixed-bottom\", \"sticky-top\"]\n    bg: Optional[str]\n    inverse: bool\n    collapsible: bool\n    fluid: bool\n\n    def __init__(\n        self,\n        *args: NavSetArg | MetadataNode,\n        ul_class: str,\n        title: TagChild,\n        id: Optional[str],\n        selected: Optional[str],\n        sidebar: Optional[Sidebar] = None,\n        fillable: bool | list[str] = False,\n        gap: Optional[CssUnit],\n        padding: Optional[CssUnit | list[CssUnit]],\n        position: Literal[\n            \"static-top\", \"fixed-top\", \"fixed-bottom\", \"sticky-top\"\n        ] = \"static-top\",\n        header: TagChild = None,\n        footer: TagChild = None,\n        bg: Optional[str] = None,\n        # TODO-bslib: default to 'auto', like we have in R (parse color via webcolors?)\n        inverse: bool = False,\n        collapsible: bool = True,\n        fluid: bool = True,\n    ) -> None:\n        super().__init__(\n            *args,\n            ul_class=ul_class,\n            id=id,\n            selected=selected,\n            header=header,\n            footer=footer,\n        )\n        self.title = title\n        self.sidebar = sidebar\n        self.fillable = fillable\n        self.gap = gap\n        self.padding = padding\n\n        self.position = position\n        self.bg = bg\n        self.inverse = inverse\n        self.collapsible = collapsible\n        self.fluid = fluid\n\n    def layout(self, nav: Tag, content: Tag) -> TagList:\n        nav_container = div(\n            {\"class\": \"container-fluid\" if self.fluid else \"container\"},\n            tags.a({\"class\": \"navbar-brand\", \"href\": \"#\"}, self.title),\n        )\n        if self.collapsible:\n            collapse_id = \"navbar-collapse-\" + private_random_int(1000, 10000)\n            nav_container.append(\n                tags.button(\n                    tags.span(class_=\"navbar-toggler-icon\"),\n                    class_=\"navbar-toggler\",\n                    type=\"button\",\n                    data_bs_toggle=\"collapse\",\n                    data_bs_target=\"#\" + collapse_id,\n                    aria_controls=collapse_id,\n                    aria_expanded=\"false\",\n                    aria_label=\"Toggle navigation\",\n                )\n            )\n            nav = div(nav, id=collapse_id, class_=\"collapse navbar-collapse\")\n\n        nav_container.append(nav)\n        nav_final = tags.nav({\"class\": \"navbar navbar-expand-md\"}, nav_container)\n\n        if self.position != \"static-top\":\n            nav_final.add_class(self.position)\n\n        nav_final.add_class(f\"navbar-{'dark' if self.inverse else 'light'}\")\n\n        if self.bg:\n            nav_final.attrs[\"style\"] = \"background-color: \" + self.bg\n        else:\n            nav_final.add_class(f\"bg-{'dark' if self.inverse else 'light'}\")\n\n        content = _make_tabs_fillable(\n            content, self.fillable, gap=self.gap, padding=self.padding, navbar=True\n        )\n\n        # 2023-05-11; Do not wrap `row()` around `self.header` and `self.footer`\n        contents: list[TagChild] = [\n            child for child in [self.header, content, self.footer] if child is not None\n        ]\n\n        if self.sidebar is None:\n            content_div = div(\n                *contents,\n                class_=\"container-fluid\" if self.fluid else \"container\",\n            )\n            # If fillable is truthy, the .container also needs to be fillable\n            if self.fillable:\n                content_div = as_fill_carrier(content_div)\n        else:\n            content_div = div(\n                # In the fluid case, the sidebar layout should be flush (i.e.,\n                # the .container-fluid class adds padding that we don't want)\n                {\"class\": \"container\"} if not self.fluid else None,\n                layout_sidebar(\n                    self.sidebar,\n                    contents,\n                    fillable=self.fillable is not False,\n                    border_radius=False,\n                    border=not self.fluid,\n                ),\n            )\n            # Always have the sidebar layout fill its parent (in this case\n            # fillable controls whether the _main_ content portion is fillable)\n            content_div = as_fill_carrier(content_div)\n\n        return TagList(nav_final, content_div)",
  "def _make_tabs_fillable(\n    content: Tag,\n    fillable: bool | list[str] = True,\n    gap: Optional[CssUnit] = None,\n    padding: Optional[CssUnit | list[CssUnit]] = None,\n    navbar: bool = False,\n) -> Tag:\n    if not fillable:\n        return content\n\n    # Even if only one .tab-pane wants fillable behavior, the .tab-content\n    # must to be a fillable container.\n    content = as_fill_carrier(content)\n\n    for child in content.children:\n        # Only work on Tags\n        if not isinstance(child, Tag):\n            continue\n        # Only work on .tab-pane children\n        if not child.has_class(\"tab-pane\"):\n            continue\n        # If `fillable` is a list, only fill the .tab-pane if its data-value is contained in `fillable`\n        if isinstance(fillable, list):\n            child_attr = child.attrs.get(\"data-value\")\n            if child_attr is None or child_attr not in fillable:\n                continue\n        styles = css(\n            gap=as_css_unit(gap),\n            padding=as_css_padding(padding),\n            __bslib_navbar_margin=\"0;\" if navbar else None,\n        )\n        child = tag_add_style(child, styles)\n        child = as_fill_carrier(child)\n\n    return content",
  "def navset_bar(\n    *args: NavSetArg | MetadataNode | Sequence[MetadataNode],\n    title: TagChild,\n    id: Optional[str] = None,\n    selected: Optional[str] = None,\n    sidebar: Optional[Sidebar] = None,\n    fillable: bool | list[str] = True,\n    gap: Optional[CssUnit] = None,\n    padding: Optional[CssUnit | list[CssUnit]] = None,\n    position: Literal[\n        \"static-top\", \"fixed-top\", \"fixed-bottom\", \"sticky-top\"\n    ] = \"static-top\",\n    header: TagChild = None,\n    footer: TagChild = None,\n    bg: Optional[str] = None,\n    # TODO-bslib: default to 'auto', like we have in R (parse color via webcolors?)\n    inverse: bool = False,\n    collapsible: bool = True,\n    fluid: bool = True,\n) -> NavSetBar:\n    \"\"\"\n    Render nav items as a navbar.\n\n    Parameters\n    ----------\n    *args\n        A collection of nav items (e.g., :func:`shiny.ui.nav`).\n    title\n        Title to display in the navbar.\n    id\n        If provided, will create an input value that holds the currently selected nav\n        item.\n    selected\n        Choose a particular nav item to select by default value (should match it's\n        ``value``).\n    position\n        Determines whether the navbar should be displayed at the top of the page with\n        normal scrolling behavior (\"static-top\"), pinned at the top (\"fixed-top\"), or\n        pinned at the bottom (\"fixed-bottom\"). Note that using \"fixed-top\" or\n        \"fixed-bottom\" will cause the navbar to overlay your body content, unless you\n        add padding (e.g., ``tags.style(\"body {padding-top: 70px;}\")``).\n    header\n        UI to display above the selected content.\n    footer\n        UI to display below the selected content.\n    bg\n        Background color of the navbar (a CSS color).\n    inverse\n        Either ``True`` for a light text color or ``False`` for a dark text color.\n    collapsible\n        ``True`` to automatically collapse the navigation elements into an expandable menu on mobile devices or narrow window widths.\n    fluid\n        ``True`` to use fluid layout; ``False`` to use fixed layout.\n\n    See Also\n    -------\n    * ~shiny.ui.page_navbar\n    * ~shiny.ui.nav\n    * ~shiny.ui.nav_menu\n    * ~shiny.ui.nav_control\n    * ~shiny.ui.nav_spacer\n    * ~shiny.ui.navset_tab\n    * ~shiny.ui.navset_pill\n    * ~shiny.experimental.ui.navset_card_tab\n    * ~shiny.experimental.ui.navset_card_pill\n    * ~shiny.ui.navset_hidden\n\n    Example\n    -------\n    See :func:`~shiny.ui.nav`.\n    \"\"\"\n\n    # If args contains any lists, flatten them into args.\n    new_args: Sequence[NavSetArg | MetadataNode] = []\n    for arg in args:\n        if isinstance(arg, (list, tuple)):\n            new_args.extend(arg)\n        else:\n            new_args.append(cast(NavSetArg, arg))\n\n    return NavSetBar(\n        *new_args,\n        ul_class=\"nav navbar-nav\",\n        id=resolve_id_or_none(id),\n        selected=selected,\n        sidebar=sidebar,\n        fillable=fillable,\n        gap=gap,\n        padding=padding,\n        title=title,\n        position=position,\n        header=header,\n        footer=footer,\n        bg=bg,\n        inverse=inverse,\n        collapsible=collapsible,\n        fluid=fluid,\n    )",
  "def _render_navset(\n    *items: NavSetArg | MetadataNode,\n    ul_class: str,\n    id: Optional[str],\n    selected: Optional[str],\n    context: dict[str, Any],\n) -> tuple[Tag, Tag]:\n    tabsetid = private_random_int(1000, 10000)\n\n    # Separate MetadataNodes from NavSetArgs.\n    metadata_args = [x for x in items if isinstance(x, MetadataNode)]\n    navset_args = [x for x in items if not isinstance(x, MetadataNode)]\n\n    # If the user hasn't provided a selected value, use the first one\n    if selected is None:\n        for x in navset_args:\n            selected = x.get_value()\n            if selected is not None:\n                break\n\n    ul_tag = tags.ul(\n        bootstrap_deps(),\n        metadata_args,\n        class_=ul_class,\n        id=id,\n        data_tabsetid=tabsetid,\n    )\n    div_tag = div(class_=\"tab-content\", data_tabsetid=tabsetid)\n    for i, x in enumerate(navset_args):\n        nav, contents = x.resolve(\n            selected, {**context, \"tabsetid\": tabsetid, \"index\": i}\n        )\n        ul_tag.append(nav)\n        div_tag.append(contents)\n\n    return ul_tag, div_tag",
  "def __init__(self, nav: Tag, content: Optional[Tag] = None) -> None:\n        self.nav = nav\n        # nav_control()/nav_spacer() have None as their content\n        self.content = content",
  "def resolve(\n        self, selected: Optional[str], context: dict[str, Any]\n    ) -> tuple[TagChild, TagChild]:\n        # Nothing to do for nav_control()/nav_spacer()\n        if self.content is None:\n            return self.nav, None\n\n        # At least currently, in the case where both nav and content are tags\n        # (i.e., nav()), the nav always has a child <a> tag...I'm not sure if\n        # there's a way to statically type this\n        nav = copy.deepcopy(self.nav)\n        a_tag = cast(Tag, nav.children[0])\n        if context.get(\"is_menu\", False):\n            a_tag.add_class(\"dropdown-item\")\n        else:\n            a_tag.add_class(\"nav-link\")\n            nav.add_class(\"nav-item\")\n\n        # Hyperlink the nav to the content\n        content = copy.copy(self.content)\n        if \"tabsetid\" in context and \"index\" in context:\n            id = f\"tab-{context['tabsetid']}-{context['index']}\"\n            content.attrs[\"id\"] = id\n            a_tag.attrs[\"href\"] = f\"#{id}\"\n\n        # Mark the nav/content as active if it should be\n        if isinstance(selected, str) and selected == self.get_value():\n            content.add_class(\"active\")\n            a_tag.add_class(\"active\")\n\n        nav.children[0] = a_tag\n\n        return nav, content",
  "def get_value(self) -> Optional[str]:\n        if self.content is None:\n            return None\n        a_tag = cast(Tag, self.nav.children[0])\n        return a_tag.attrs.get(\"data-value\", None)",
  "def tagify(self) -> None:\n        raise NotImplementedError(\n            \"nav() items must appear within navset_*() container.\"\n        )",
  "def __init__(\n        self,\n        *args: NavSetArg | MetadataNode,\n        ul_class: str,\n        id: Optional[str],\n        selected: Optional[str],\n        header: TagChild = None,\n        footer: TagChild = None,\n    ) -> None:\n        self.args = args\n        self.ul_class = ul_class\n        self.id = id\n        self.selected = selected\n        self.header = header\n        self.footer = footer",
  "def tagify(self) -> TagList | Tag:\n        id = self.id\n        ul_class = self.ul_class\n        if id is not None:\n            ul_class += \" shiny-tab-input\"\n\n        nav, content = _render_navset(\n            *self.args, ul_class=ul_class, id=id, selected=self.selected, context={}\n        )\n        return self.layout(nav, content).tagify()",
  "def layout(self, nav: Tag, content: Tag) -> TagList | Tag:\n        return TagList(nav, self.header, content, self.footer)",
  "def __init__(\n        self,\n        *args: NavSetArg,\n        ul_class: str,\n        id: Optional[str],\n        selected: Optional[str],\n        sidebar: Optional[Sidebar] = None,\n        header: TagChild = None,\n        footer: TagChild = None,\n        placement: Literal[\"above\", \"below\"] = \"above\",\n    ) -> None:\n        super().__init__(\n            *args,\n            ul_class=ul_class,\n            id=id,\n            selected=selected,\n            header=header,\n            footer=footer,\n        )\n        self.sidebar = sidebar\n        self.placement = placement",
  "def layout(self, nav: Tag, content: Tag) -> Tag:\n        # navs = [child for child in content.children if isinstance(child, Nav)]\n        # not_navs = [child for child in content.children if child not in navs]\n        content_val: Tag | CardItem = content\n\n        if self.sidebar:\n            content_val = navset_card_body(content, sidebar=self.sidebar)\n\n        if self.placement == \"below\":\n            # TODO-carson; have carson double check this change\n            return card(\n                card_header(self.header) if self.header else None,\n                content_val,\n                card_body(self.footer, fillable=False, fill=False)\n                if self.footer\n                else None,\n                card_footer(nav),\n            )\n        else:\n            # TODO-carson; have carson double check this change\n            return card(\n                card_header(nav),\n                card_body(self.header, fill=False, fillable=False)\n                if self.header\n                else None,\n                content_val,\n                card_footer(self.footer) if self.footer else None,\n            )",
  "def __init__(\n        self,\n        *args: NavSetArg | MetadataNode,\n        ul_class: str,\n        title: TagChild,\n        id: Optional[str],\n        selected: Optional[str],\n        sidebar: Optional[Sidebar] = None,\n        fillable: bool | list[str] = False,\n        gap: Optional[CssUnit],\n        padding: Optional[CssUnit | list[CssUnit]],\n        position: Literal[\n            \"static-top\", \"fixed-top\", \"fixed-bottom\", \"sticky-top\"\n        ] = \"static-top\",\n        header: TagChild = None,\n        footer: TagChild = None,\n        bg: Optional[str] = None,\n        # TODO-bslib: default to 'auto', like we have in R (parse color via webcolors?)\n        inverse: bool = False,\n        collapsible: bool = True,\n        fluid: bool = True,\n    ) -> None:\n        super().__init__(\n            *args,\n            ul_class=ul_class,\n            id=id,\n            selected=selected,\n            header=header,\n            footer=footer,\n        )\n        self.title = title\n        self.sidebar = sidebar\n        self.fillable = fillable\n        self.gap = gap\n        self.padding = padding\n\n        self.position = position\n        self.bg = bg\n        self.inverse = inverse\n        self.collapsible = collapsible\n        self.fluid = fluid",
  "def layout(self, nav: Tag, content: Tag) -> TagList:\n        nav_container = div(\n            {\"class\": \"container-fluid\" if self.fluid else \"container\"},\n            tags.a({\"class\": \"navbar-brand\", \"href\": \"#\"}, self.title),\n        )\n        if self.collapsible:\n            collapse_id = \"navbar-collapse-\" + private_random_int(1000, 10000)\n            nav_container.append(\n                tags.button(\n                    tags.span(class_=\"navbar-toggler-icon\"),\n                    class_=\"navbar-toggler\",\n                    type=\"button\",\n                    data_bs_toggle=\"collapse\",\n                    data_bs_target=\"#\" + collapse_id,\n                    aria_controls=collapse_id,\n                    aria_expanded=\"false\",\n                    aria_label=\"Toggle navigation\",\n                )\n            )\n            nav = div(nav, id=collapse_id, class_=\"collapse navbar-collapse\")\n\n        nav_container.append(nav)\n        nav_final = tags.nav({\"class\": \"navbar navbar-expand-md\"}, nav_container)\n\n        if self.position != \"static-top\":\n            nav_final.add_class(self.position)\n\n        nav_final.add_class(f\"navbar-{'dark' if self.inverse else 'light'}\")\n\n        if self.bg:\n            nav_final.attrs[\"style\"] = \"background-color: \" + self.bg\n        else:\n            nav_final.add_class(f\"bg-{'dark' if self.inverse else 'light'}\")\n\n        content = _make_tabs_fillable(\n            content, self.fillable, gap=self.gap, padding=self.padding, navbar=True\n        )\n\n        # 2023-05-11; Do not wrap `row()` around `self.header` and `self.footer`\n        contents: list[TagChild] = [\n            child for child in [self.header, content, self.footer] if child is not None\n        ]\n\n        if self.sidebar is None:\n            content_div = div(\n                *contents,\n                class_=\"container-fluid\" if self.fluid else \"container\",\n            )\n            # If fillable is truthy, the .container also needs to be fillable\n            if self.fillable:\n                content_div = as_fill_carrier(content_div)\n        else:\n            content_div = div(\n                # In the fluid case, the sidebar layout should be flush (i.e.,\n                # the .container-fluid class adds padding that we don't want)\n                {\"class\": \"container\"} if not self.fluid else None,\n                layout_sidebar(\n                    self.sidebar,\n                    contents,\n                    fillable=self.fillable is not False,\n                    border_radius=False,\n                    border=not self.fluid,\n                ),\n            )\n            # Always have the sidebar layout fill its parent (in this case\n            # fillable controls whether the _main_ content portion is fillable)\n            content_div = as_fill_carrier(content_div)\n\n        return TagList(nav_final, content_div)",
  "def as_css_unit(value: None) -> None:\n    ...",
  "def as_css_unit(value: CssUnit) -> str:\n    ...",
  "def as_css_unit(value: None | CssUnit) -> None | str:\n    \"\"\"\n    Convert a value into a CSS unit.\n\n    Parameters\n    ----------\n    value\n        A value to convert into a CSS unit.\n\n    Returns\n    -------\n    :\n        If the `value` is `None`, then `None`. If the value is `0`, then `\"0\"`. If the `value` is numeric, then a formatted pixel value. Otherwise, the `value` as-is.\n    \"\"\"\n    # TODO-future: Actually validate. Or don't validate, but then change\n    # the function name to to_css_unit() or something.\n    if isinstance(value, (float, int)):\n        # Explicit check for 0 because floats may format to have many decimals.\n        if value == 0:\n            return \"0\"\n        return \"{:f}px\".format(value)\n    else:\n        return value",
  "def as_css_padding(padding: CssUnit | list[CssUnit]) -> str:\n    ...",
  "def as_css_padding(padding: None) -> None:\n    ...",
  "def as_css_padding(padding: CssUnit | list[CssUnit] | None) -> str | None:\n    \"\"\"\n    Convert a CSS unit or list of CSS units into a CSS padding value.\n\n    Parameters\n    ----------\n    padding\n        A CSS unit or list of CSS units.\n\n    Returns\n    -------\n    :\n        A CSS padding value.\n    \"\"\"\n    if padding is None:\n        return None\n\n    if not isinstance(padding, list):\n        padding = [padding]\n\n    return \" \".join(as_css_unit(p) for p in padding)",
  "def as_width_unit(x: str | float | int) -> str:\n    if isinstance(x, (int, float)):\n        return as_css_unit(x)\n\n    if isinstance(x, str) and x.endswith(\"%\") and x.count(\"%\") == 1:\n        x1_num = float(x[:-1])\n        x2_num = 100 - x1_num\n        return f\"{x1_num}% {x2_num}%\"\n\n    # TODO-bslib: validateCssUnit() should maybe support fr units?\n    # return(paste(x, collapse = \" \"))\n    return as_css_unit(x)",
  "def layout_column_wrap(\n    width: Optional[CssUnit],\n    *args: TagChild | TagAttrs,\n    fixed_width: bool = False,\n    heights_equal: Literal[\"all\", \"row\"] = \"all\",\n    fill: bool = True,\n    fillable: bool = True,\n    height: Optional[CssUnit] = None,\n    height_mobile: Optional[CssUnit] = None,\n    gap: Optional[CssUnit] = None,\n    class_: Optional[str] = None,\n    **kwargs: TagAttrValue,\n) -> Tag:\n    # For\n    # more explanation and illustrative examples, see\n    # [here](https://rstudio.github.io/bslib/articles/cards.html#multiple-cards)\n    \"\"\"\n    A grid-like, column-first layout\n\n    Wraps a 1d sequence of UI elements into a 2d grid. The number of columns (and rows)\n    in the grid dependent on the column `width` as well as the size of the display.\n\n    Parameters\n    ----------\n    width\n        The desired width of each card. It can be a (unit-less) number between 0 and 1\n        and should be specified as `1/num`, where `num` represents the number of desired\n        columns. It can be a CSS length unit representing either the minimum (when\n        `fixed_width=False`) or fixed width (`fixed_width=True`). It can also be `None`,\n        which allows power users to set the `grid-template-columns` CSS property\n        manually, either via a `style` attribute or a CSS stylesheet.\n    *args\n        Unnamed arguments should be UI elements (e.g.,\n        :func:`~shiny.experimental.ui.card`). Named arguments become attributes on the\n        containing :class:`~htmltools.Tag` element.\n    fixed_width\n        Whether or not to interpret the `width` as a minimum (`fixed_width=False`) or\n        fixed (`fixed_width=True`) width when it is a CSS length unit.\n    heights_equal\n        If `\"all\"` (the default), every card in every row of the grid will have the same\n        height. If `\"row\"`, then every card in _each_ row of the grid will have the same\n        height, but heights may vary between rows.\n    fill\n        Whether or not to allow the layout to grow/shrink to fit a fillable container\n        with an opinionated height (e.g., :func:`~shiny.experimental.ui.page_fillable`).\n    fillable\n        Whether or not each element is wrapped in a fillable container.\n    height\n        Any valid CSS unit to use for the height.\n    height_mobile\n        Any valid CSS unit to use for the height when on mobile devices (or narrow\n        windows).\n    gap\n        Any valid CSS unit to use for the gap between columns.\n    class_\n        A CSS class to apply to the containing element.\n    **kwargs\n        Additional attributes to apply to the containing element.\n\n    Returns\n    -------\n    :\n        A :class:`~htmltools.Tag` element.\n    \"\"\"\n    attrs, children = consolidate_attrs(*args, class_=class_, **kwargs)\n\n    colspec: str | None = None\n    if width is not None:\n        if is_01_scalar(width) and width > 0.0:\n            num_cols = 1.0 / width\n            if not num_cols.is_integer():\n                raise ValueError(\n                    \"Could not interpret `layout_column_wrap(width=)` argument\"\n                )\n            colspec = \" \".join([\"1fr\" for _ in range(int(num_cols))])\n        else:\n            width_css_unit = as_css_unit(width)\n            if fixed_width:\n                colspec = f\"repeat(auto-fit, minmax({width_css_unit}, 1fr))\"\n            else:\n                colspec = f\"repeat(auto-fit, minmax(0, {width_css_unit}))\"\n\n    # Use a new dict so that we don't mutate the original `children` dict\n    upgraded_children: list[TagChild] = []\n    for child_value in children:\n        child = div({\"class\": \"bslib-gap-spacing\"}, child_value)\n        if fillable:\n            child = as_fillable_container(child)\n        upgraded_children.append(child)\n\n    tag_style_css = {\n        \"grid-template-columns\": colspec,\n        \"grid-auto-rows\": \"1fr\" if (heights_equal == \"all\") else None,\n        # Always provide the `height:auto` default so that the CSS variable\n        # doesn't get inherited in a scenario like\n        # layout_column_wrap(height=200, layout, layout_column_wrap(...))\n        \"--bslib-grid-height\": as_css_unit(\"auto\" if height is None else height),\n        \"--bslib-grid-height-mobile\": as_css_unit(\n            \"auto\" if height_mobile is None else height_mobile\n        ),\n        \"gap\": as_css_unit(gap),\n    }\n\n    tag = div(\n        {\n            \"class\": \"bslib-grid bslib-mb-spacing\",\n            \"style\": css(**tag_style_css),\n        },\n        attrs,\n        *upgraded_children,\n        grid_dependency(),\n    )\n    if fill:\n        tag = as_fill_item(tag)\n\n    return tag",
  "def tag_prepend_class(tag: TagT, *class_: str | None) -> TagT:\n    classes = (\n        *class_,\n        tag.attrs.get(\"class\"),\n    )\n    classes = [c for c in classes if c is not None]\n    if len(classes) == 0:\n        return tag\n    tag.attrs[\"class\"] = \" \".join(classes)\n    return tag",
  "def tag_remove_class(tag: TagT, *class_: str | None) -> TagT:\n    \"\"\"\n    Remove a class value from the HTML class attribute.\n\n    Parameters\n    ----------\n    *class_\n        The class name to remove.\n\n    Returns\n    -------\n    :\n        The modified tag.\n    \"\"\"\n    cls = tag.attrs.get(\"class\")\n    # If no class values to remove from, quit\n    if not cls:\n        return tag\n\n    # Remove any `None` values\n    set_to_remove = {c for c in class_ if c is not None}\n\n    # If no classes to remove, quit\n    if len(set_to_remove) == 0:\n        return tag\n\n    # Get new set of classes\n    # Order matters, otherwise we could use `set()` subtraction: `set(cls.split(\" \")) - set(class_)`\n    new_cls: list[str] = []\n    for cls_val in cls.split(\" \"):\n        if cls_val not in set_to_remove:\n            new_cls.append(cls_val)\n\n    # If no classes left, remove the attribute\n    if len(new_cls) == 0:\n        # If here, `attrs.class` must exist\n        tag.attrs.pop(\"class\")\n        return tag\n\n    # Otherwise, set the new class\n    tag.attrs[\"class\"] = \" \".join(new_cls)\n    return tag",
  "def tag_add_style(\n    tag: TagT,\n    *style: str | None,\n) -> TagT:\n    \"\"\"\n    Add a style value(s) to the HTML style attribute.\n\n    Parameters\n    ----------\n    *style\n        CSS properties and values already properly formatted. Each should already contain trailing semicolons.\n\n    See Also\n    --------\n    ~htmltools.css\n\n    Returns\n    -------\n    :\n        The modified tag.\n    \"\"\"\n    styles = (\n        tag.attrs.get(\"style\"),\n        *style,\n    )\n    non_none_style_tuple = (s for s in styles if s is not None)\n    style_str = \"\".join(non_none_style_tuple)\n\n    if style_str:\n        tag.attrs[\"style\"] = style_str\n    return tag",
  "def _add_role(\n    tag: TagT, *, condition: bool | None, class_: str, overwrite: bool = False\n) -> TagT:\n    if condition is None:\n        return tag\n\n    # Remove the class if it already exists and we're going to add it,\n    # or if we're requiring it to be removed\n    if (condition and tag.has_class(class_)) or overwrite:\n        tag = tag_remove_class(tag, class_)\n\n    if condition:\n        tag = tag_prepend_class(tag, class_)\n        tag.append(fill_dependency())\n    return tag",
  "def bind_fill_role(\n    tag: TagT,\n    *,\n    item: Optional[bool] = None,\n    container: Optional[bool] = None,\n    overwrite: bool = False,\n) -> TagT:\n    \"\"\"\n    Allow tags to intelligently fill their container\n\n    Create fill containers and items. If a fill item is a direct child of a fill\n    container, and that container has an opinionated height, then the item is allowed to\n    grow and shrink to its container's size.\n\n    Parameters\n    ----------\n    tag\n        a T object.\n    item\n        whether or not to treat `tag` as a fill item.\n    container\n        whether or not to treat `x` as a fill container. Note, this will set the CSS\n        `display` property on the tag to `flex` which can change how its direct children\n        are rendered. Thus, one should be careful not to mark a tag as a fill container\n        when it needs to rely on other `display` behavior.\n    overwrite\n        whether or not to override previous filling layout calls (e.g., to remove the\n        item/container role from a tag).\n\n    Returns\n    -------\n    :\n        The original :class:`~htmltools.Tag` object (`tag`) with additional attributes\n        (and an :class:`~htmltools.HTMLDependency`).\n    \"\"\"\n    tag = _add_role(\n        tag,\n        condition=item,\n        class_=FILL_ITEM_CLASS,\n        overwrite=overwrite,\n    )\n    tag = _add_role(\n        tag,\n        condition=container,\n        class_=FILL_CONTAINER_CLASS,\n        overwrite=overwrite,\n    )\n    return tag",
  "def as_fill_carrier(\n    tag: TagFillingLayoutT,\n    *,\n    min_height: Optional[CssUnit] = None,\n    max_height: Optional[CssUnit] = None,\n    gap: Optional[CssUnit] = None,\n    # class_: Optional[str] = None,\n    # style: Optional[str] = None,\n    # css_selector: Optional[str],\n) -> TagFillingLayoutT:\n    \"\"\"\n    Make a tag a fill carrier\n\n    Filling layouts are built on the foundation of _fillable containers_ and _fill\n    items_ (_fill carriers_ are both _fillable containers_ and _fill items_). This is\n    why most UI components (e.g., :func:`~shiny.experimental.ui.card`,\n    :func:`~shiny.experimental.ui.card_body`,\n    :func:`~shiny.experimental.ui.layout_sidebar`) possess both `fillable` and `fill`\n    arguments (to control their fill behavior). However, sometimes it's useful to add,\n    remove, and/or test fillable/fill properties on arbitrary :class:`~htmltools.Tag`,\n    which these functions are designed to do.\n\n    Parameters\n    ----------\n    tag\n        a Tag object.\n    min_height,max_height,gap\n        Any valid CSS unit (e.g., `150`) to be applied to `tag`.\n\n    Returns\n    -------\n    :\n        The original :class:`~htmltools.Tag` object (`tag`) with additional attributes\n        (and an :class:`~htmltools.HTMLDependency`).\n\n    See Also\n    --------\n    * :func:`~shiny.experimental.ui.as_fill_item`\n    * :func:`~shiny.experimental.ui.as_fillable_container`\n    * :func:`~shiny.experimental.ui.remove_all_fill`\n    * :func:`~shiny.experimental.ui.is_fill_carrier`\n    * :func:`~shiny.experimental.ui.is_fill_item`\n    * :func:`~shiny.experimental.ui.is_fillable_container`\n    \"\"\"\n    return _add_filling_attrs(\n        tag,\n        item=True,\n        container=True,\n        min_height=min_height,\n        max_height=max_height,\n        gap=gap,\n    )",
  "def as_fillable_container(\n    tag: TagFillingLayoutT,\n    *,\n    min_height: Optional[CssUnit] = None,\n    max_height: Optional[CssUnit] = None,\n    gap: Optional[CssUnit] = None,\n    # class_: Optional[str] = None,\n    # style: Optional[str] = None,\n    # css_selector: Optional[str] = None,\n) -> TagFillingLayoutT:\n    \"\"\"\n    Coerce a tag to be a fillable container\n\n    Filling layouts are built on the foundation of _fillable containers_ and _fill\n    items_ (_fill carriers_ are both _fillable containers_ and _fill items_). This is\n    why most UI components (e.g., :func:`~shiny.experimental.ui.card`,\n    :func:`~shiny.experimental.ui.card_body`,\n    :func:`~shiny.experimental.ui.layout_sidebar`) possess both `fillable` and `fill`\n    arguments (to control their fill behavior). However, sometimes it's useful to add,\n    remove, and/or test fillable/fill properties on arbitrary :class:`~htmltools.Tag`,\n    which these functions are designed to do.\n\n    Parameters\n    ----------\n    tag\n        a Tag object.\n    min_height,max_height,gap\n        Any valid CSS unit (e.g., `150`) to be applied to `tag`.\n\n    Returns\n    -------\n    :\n        The original :class:`~htmltools.Tag` object (`tag`) with additional attributes\n        (and an :class:`~htmltools.HTMLDependency`).\n\n    See Also\n    --------\n    * :func:`~shiny.experimental.ui.as_fill_carrier`\n    * :func:`~shiny.experimental.ui.as_fill_item`\n    * :func:`~shiny.experimental.ui.as_fillable_container`\n    * :func:`~shiny.experimental.ui.remove_all_fill`\n    * :func:`~shiny.experimental.ui.is_fill_carrier`\n    * :func:`~shiny.experimental.ui.is_fill_item`\n    * :func:`~shiny.experimental.ui.is_fillable_container`\n    \"\"\"\n    return _add_filling_attrs(\n        tag,\n        container=True,\n        min_height=min_height,\n        max_height=max_height,\n        gap=gap,\n    )",
  "def as_fill_item(\n    tag: TagFillingLayoutT,\n    *,\n    min_height: Optional[CssUnit] = None,\n    max_height: Optional[CssUnit] = None,\n    # class_: Optional[str] = None,\n    # style: Optional[str] = None,\n    # css_selector: Optional[str] = None,\n) -> TagFillingLayoutT:\n    \"\"\"\n    Coerce a tag to a fill item\n\n    Filling layouts are built on the foundation of _fillable containers_ and _fill\n    items_ (_fill carriers_ are both _fillable containers_ and _fill items_). This is\n    why most UI components (e.g., :func:`~shiny.experimental.ui.card`,\n    :func:`~shiny.experimental.ui.card_body`,\n    :func:`~shiny.experimental.ui.layout_sidebar`) possess both `fillable` and `fill`\n    arguments (to control their fill behavior). However, sometimes it's useful to add,\n    remove, and/or test fillable/fill properties on arbitrary :class:`~htmltools.Tag`,\n    which these functions are designed to do.\n\n    Parameters\n    ----------\n    tag\n        a Tag object.\n    min_height,max_height\n        Any valid CSS unit (e.g., `150`) to be applied to `tag`.\n\n    Returns\n    -------\n    :\n        The original :class:`~htmltools.Tag` object (`tag`) with additional attributes\n        (and an :class:`~htmltools.HTMLDependency`).\n\n    See Also\n    --------\n    * :func:`~shiny.experimental.ui.as_fill_carrier`\n    * :func:`~shiny.experimental.ui.as_fillable_container`\n    * :func:`~shiny.experimental.ui.remove_all_fill`\n    * :func:`~shiny.experimental.ui.is_fill_carrier`\n    * :func:`~shiny.experimental.ui.is_fill_item`\n    * :func:`~shiny.experimental.ui.is_fillable_container`\n    \"\"\"\n    return _add_filling_attrs(\n        tag,\n        item=True,\n        min_height=min_height,\n        max_height=max_height,\n    )",
  "def remove_all_fill(tag: TagFillingLayoutT) -> TagFillingLayoutT:\n    \"\"\"\n    Remove any filling layouts from a tag\n\n    Filling layouts are built on the foundation of _fillable containers_ and _fill\n    items_ (_fill carriers_ are both _fillable containers_ and _fill items_). This is\n    why most UI components (e.g., :func:`~shiny.experimental.ui.card`,\n    :func:`~shiny.experimental.ui.card_body`,\n    :func:`~shiny.experimental.ui.layout_sidebar`) possess both `fillable` and `fill`\n    arguments (to control their fill behavior). However, sometimes it's useful to add,\n    remove, and/or test fillable/fill properties on arbitrary :class:`~htmltools.Tag`,\n    which these functions are designed to do.\n\n    Parameters\n    ----------\n    tag\n        a Tag object.\n\n    Returns\n    -------\n    :\n        The original :class:`~htmltools.Tag` object with filling layout attributes\n        removed.\n\n\n    See Also\n    --------\n    * :func:`~shiny.experimental.ui.as_fill_carrier`\n    * :func:`~shiny.experimental.ui.as_fill_item`\n    * :func:`~shiny.experimental.ui.as_fillable_container`\n    * :func:`~shiny.experimental.ui.is_fill_carrier`\n    * :func:`~shiny.experimental.ui.is_fill_item`\n    * :func:`~shiny.experimental.ui.is_fillable_container`\n    \"\"\"\n\n    if isinstance(tag, FillingLayout):\n        return tag.remove_all_fill()\n\n    return bind_fill_role(\n        tag,\n        item=False,\n        container=False,\n        overwrite=True,\n    )",
  "def is_fill_carrier(tag: Tag | FillingLayout) -> bool:\n    \"\"\"\n    Test a tag for being a fill carrier\n\n    Filling layouts are built on the foundation of _fillable containers_ and _fill\n    items_ (_fill carriers_ are both _fillable containers_ and _fill items_). This is\n    why most UI components (e.g., :func:`~shiny.experimental.ui.card`,\n    :func:`~shiny.experimental.ui.card_body`,\n    :func:`~shiny.experimental.ui.layout_sidebar`) possess both `fillable` and `fill`\n    arguments (to control their fill behavior). However, sometimes it's useful to add,\n    remove, and/or test fillable/fill properties on arbitrary :class:`~htmltools.Tag`,\n    which these functions are designed to do.\n\n    Parameters\n    ----------\n    tag\n        a Tag object.\n\n    Returns\n    -------\n    :\n        Whether or not `tag` is a fill carrier.\n\n    See Also\n    --------\n    * :func:`~shiny.experimental.ui.as_fill_carrier`\n    * :func:`~shiny.experimental.ui.as_fill_item`\n    * :func:`~shiny.experimental.ui.as_fillable_container`\n    * :func:`~shiny.experimental.ui.remove_all_fill`\n    * :func:`~shiny.experimental.ui.is_fill_item`\n    * :func:`~shiny.experimental.ui.is_fillable_container`\n    \"\"\"\n    return is_fillable_container(tag) and is_fill_item(tag)",
  "def is_fillable_container(tag: TagChild | FillingLayout) -> bool:\n    \"\"\"\n    Test a tag for being a fillable container\n\n    Filling layouts are built on the foundation of _fillable containers_ and _fill\n    items_ (_fill carriers_ are both _fillable containers_ and _fill items_). This is\n    why most UI components (e.g., :func:`~shiny.experimental.ui.card`,\n    :func:`~shiny.experimental.ui.card_body`,\n    :func:`~shiny.experimental.ui.layout_sidebar`) possess both `fillable` and `fill`\n    arguments (to control their fill behavior). However, sometimes it's useful to add,\n    remove, and/or test fillable/fill properties on arbitrary :class:`~htmltools.Tag`,\n    which these functions are designed to do.\n\n    Parameters\n    ----------\n    tag\n        a Tag object.\n\n    Returns\n    -------\n    :\n        Whether or not `tag` is a fillable container.\n\n\n    See Also\n    --------\n    * :func:`~shiny.experimental.ui.as_fill_carrier`\n    * :func:`~shiny.experimental.ui.as_fill_item`\n    * :func:`~shiny.experimental.ui.as_fillable_container`\n    * :func:`~shiny.experimental.ui.remove_all_fill`\n    * :func:`~shiny.experimental.ui.is_fill_item`\n    * :func:`~shiny.experimental.ui.is_fillable_container`\n    \"\"\"\n    # TODO-future; Handle widgets\n    # # won't actually work until (htmltools#334) gets fixed\n    # renders_to_tag_class(x, FILL_CONTAINER_CLASS, \".html-widget\")\n\n    return _is_fill_layout(tag, layout=\"fillable\")",
  "def is_fill_item(tag: TagChild | FillingLayout) -> bool:\n    \"\"\"\n    Test a tag for being a fill item\n\n    Filling layouts are built on the foundation of _fillable containers_ and _fill\n    items_ (_fill carriers_ are both _fillable containers_ and _fill items_). This is\n    why most UI components (e.g., :func:`~shiny.experimental.ui.card`,\n    :func:`~shiny.experimental.ui.card_body`,\n    :func:`~shiny.experimental.ui.layout_sidebar`) possess both `fillable` and `fill`\n    arguments (to control their fill behavior). However, sometimes it's useful to add,\n    remove, and/or test fillable/fill properties on arbitrary :class:`~htmltools.Tag`,\n    which these functions are designed to do.\n\n    Parameters\n    ----------\n    tag\n        a Tag object.\n\n    Returns\n    -------\n    :\n        Whether or not `tag` is a fill item.\n\n    See Also\n    --------\n    * :func:`~shiny.experimental.ui.as_fill_carrier`\n    * :func:`~shiny.experimental.ui.as_fill_item`\n    * :func:`~shiny.experimental.ui.as_fillable_container`\n    * :func:`~shiny.experimental.ui.remove_all_fill`\n    * :func:`~shiny.experimental.ui.is_fill_carrier`\n    * :func:`~shiny.experimental.ui.is_fillable_container`\n    \"\"\"\n    # TODO-future; Handle widgets\n    # # won't actually work until (htmltools#334) gets fixed\n    # renders_to_tag_class(x, FILL_ITEM_CLASS, \".html-widget\")\n\n    return _is_fill_layout(tag, layout=\"fill\")",
  "def _is_fill_layout(\n    tag: TagChild | FillingLayout,\n    layout: Literal[\"fill\", \"fillable\"],\n    # recurse: bool = True,\n) -> bool:\n    if not isinstance(tag, (Tag, Tagifiable, FillingLayout)):\n        return False\n\n    # tag: Tag | FillingLayout | Tagifiable\n\n    if layout == \"fill\":\n        if isinstance(tag, Tag):\n            return tag.has_class(FILL_ITEM_CLASS)\n        if isinstance(tag, FillingLayout):\n            return tag.is_fill_item()\n\n    elif layout == \"fillable\":\n        if isinstance(tag, Tag):\n            return tag.has_class(FILL_CONTAINER_CLASS)\n        if isinstance(tag, FillingLayout):\n            return tag.is_fillable_container()\n\n    # tag: Tagifiable and not (Tag or FillingLayout)\n    raise TypeError(\n        f\"`_is_fill_layout(tag=)` must be a `Tag` or implement the `FillingLayout` protocol methods. Received object of type: `{type(tag).__name__}`\"\n    )",
  "class FillingLayout(Protocol):\n    \"\"\"\n    Generic protocol for filling layouts objects\n    \"\"\"\n\n    def add_class(\n        self: T,\n        class_: str,\n        # *,\n        # # Currently Unused\n        # css_selector: Optional[str] = None,\n        # Currently Unused\n        **kwargs: object,\n    ) -> T:\n        \"\"\"\n        Generic method to handle adding a CSS `class` to an object\n\n        Parameters\n        ----------\n        class_\n            A character vector of class names to add to the tag.\n        **kwargs\n            Possible future arguments\n\n        Returns\n        -------\n        :\n            The updated object.\n        \"\"\"\n        ...\n\n    def add_style(\n        self: T,\n        style: str,\n        # *,\n        # # Currently Unused\n        # css_selector: Optional[str] = None,\n        # Currently Unused\n        **kwargs: object,\n    ) -> T:\n        \"\"\"\n        Generic method to handle adding a CSS `style` to an object\n\n        Parameters\n        ----------\n        style\n            A character vector of CSS properties to add to the tag.\n        **kwargs\n            Possible future arguments\n\n        Returns\n        -------\n        :\n            The updated object.\n        \"\"\"\n        ...\n\n    def is_fill_item(self) -> bool:\n        \"\"\"\n        Generic method to handle testing if an object is a fill item\n\n        Returns\n        -------\n        :\n            Whether or not the object is a fill item\n        \"\"\"\n        ...\n\n    def is_fillable_container(self) -> bool:\n        \"\"\"\n        Generic method to handle testing if an object is a fillable container\n\n        Returns\n        -------\n        :\n            Whether or not the object is a fillable container\n        \"\"\"\n        ...\n\n    def as_fill_item(\n        self: T,\n    ) -> T:\n        \"\"\"\n        Generic method to handle coercing an object to a fill item\n\n        Returns\n        -------\n        :\n            The updated object.\n        \"\"\"\n        ...\n\n    def as_fillable_container(\n        self: T,\n    ) -> T:\n        \"\"\"\n        Generic method to handle coercing an object to a fillable container\n\n        Returns\n        -------\n        :\n            The updated object.\n        \"\"\"\n        ...\n\n    def remove_all_fill(\n        self: T,\n    ) -> T:\n        \"\"\"\n        Generic method to handle removing all fill properties from an object\n\n        Returns\n        -------\n        :\n            The updated object.\n        \"\"\"\n        ...",
  "def _style_units_to_str(**kwargs: CssUnit | None) -> str | None:\n    style_items: dict[str, CssUnit] = {}\n    for k, v in kwargs.items():\n        if v is not None:\n            style_items[k] = as_css_unit(v)\n\n    return css(**style_items)",
  "def _add_filling_attrs(\n    tag: TagFillingLayoutT,\n    item: Optional[bool] = None,\n    container: Optional[bool] = None,\n    **kwargs: CssUnit | None,\n) -> TagFillingLayoutT:\n    new_style = _style_units_to_str(**kwargs)\n\n    if isinstance(tag, FillingLayout):\n        if new_style:\n            tag.add_style(new_style)\n        if item:\n            tag.as_fill_item()\n        if container:\n            tag.as_fillable_container()\n        return tag\n\n    # Tag\n    tag = tag_add_style(tag, new_style)\n    return bind_fill_role(tag, item=item, container=container)",
  "def add_class(\n        self: T,\n        class_: str,\n        # *,\n        # # Currently Unused\n        # css_selector: Optional[str] = None,\n        # Currently Unused\n        **kwargs: object,\n    ) -> T:\n        \"\"\"\n        Generic method to handle adding a CSS `class` to an object\n\n        Parameters\n        ----------\n        class_\n            A character vector of class names to add to the tag.\n        **kwargs\n            Possible future arguments\n\n        Returns\n        -------\n        :\n            The updated object.\n        \"\"\"\n        ...",
  "def add_style(\n        self: T,\n        style: str,\n        # *,\n        # # Currently Unused\n        # css_selector: Optional[str] = None,\n        # Currently Unused\n        **kwargs: object,\n    ) -> T:\n        \"\"\"\n        Generic method to handle adding a CSS `style` to an object\n\n        Parameters\n        ----------\n        style\n            A character vector of CSS properties to add to the tag.\n        **kwargs\n            Possible future arguments\n\n        Returns\n        -------\n        :\n            The updated object.\n        \"\"\"\n        ...",
  "def is_fill_item(self) -> bool:\n        \"\"\"\n        Generic method to handle testing if an object is a fill item\n\n        Returns\n        -------\n        :\n            Whether or not the object is a fill item\n        \"\"\"\n        ...",
  "def is_fillable_container(self) -> bool:\n        \"\"\"\n        Generic method to handle testing if an object is a fillable container\n\n        Returns\n        -------\n        :\n            Whether or not the object is a fillable container\n        \"\"\"\n        ...",
  "def as_fill_item(\n        self: T,\n    ) -> T:\n        \"\"\"\n        Generic method to handle coercing an object to a fill item\n\n        Returns\n        -------\n        :\n            The updated object.\n        \"\"\"\n        ...",
  "def as_fillable_container(\n        self: T,\n    ) -> T:\n        \"\"\"\n        Generic method to handle coercing an object to a fillable container\n\n        Returns\n        -------\n        :\n            The updated object.\n        \"\"\"\n        ...",
  "def remove_all_fill(\n        self: T,\n    ) -> T:\n        \"\"\"\n        Generic method to handle removing all fill properties from an object\n\n        Returns\n        -------\n        :\n            The updated object.\n        \"\"\"\n        ...",
  "def popover(\n    trigger: TagChild,\n    *args: TagChild | TagAttrs,\n    title: Optional[TagChild] = None,\n    id: Optional[str] = None,\n    placement: Literal[\"auto\", \"top\", \"right\", \"bottom\", \"left\"] = \"auto\",\n    options: Optional[dict[str, Any]] = None,\n    **kwargs: TagAttrValue,\n) -> Tag:\n    \"\"\"\n    Add a popover to a UI element.\n\n    Display additional information when clicking on a UI element (typically a\n    button).\n\n    Parameters\n    ----------\n    trigger\n        The UI element to serve as the popover trigger (typically a\n        :func:`~shiny.ui.input_action_button` or similar). If `trigger` renders as\n        multiple HTML elements (e.g., it's a :func:`~shiny.ui.tags.TagList`), the last\n        HTML element is used for the trigger. If the `trigger` should contain all of\n        those elements, wrap the object in a :func:`~shiny.ui.tags.div` or\n        :func:`~shiny.ui.tags.span`.\n    *args\n        UI elements for the popover's body. Character strings are\n        automatically escaped unless marked as :func:`~shiny.html`.\n    title\n        A title (header) for the popover.\n    id\n        A character string. Required to re-actively respond to the visibility of the\n        popover (via the `input.<ID>()` value) and/or update the visibility/contents of\n        the popover.\n    placement\n        The placement of the popover relative to its trigger.\n    options\n        A list of additional\n        `options <https://getbootstrap.com/docs/5.3/components/popovers/#options>`_.\n\n\n    Closing popovers\n    ----------------\n\n    In addition to clicking the `close_button`, popovers can be closed by pressing the\n    Esc/Space key when the popover (and/or its trigger) is focused.\n\n    See Also\n    --------\n    * <https://getbootstrap.com/docs/5.3/components/popovers/>\n    * :func:`~shiny.experimental.ui.toggle_popover`\n    * :func:`~shiny.experimental.ui.update_popover`\n    * :func:`~shiny.experimental.ui.tooltip`\n    \"\"\"\n\n    # Theming/Styling\n    # ---------------\n    #\n    # Like other bslib components, popovers can be themed by supplying [relevant theming\n    # variables](https://rstudio.github.io/bslib/articles/bs5-variables.html#popover-bg)\n    # to [bs_theme()], which effects styling of every popover on the page. To style a\n    # _specific_ popover differently from other popovers, utilize the `customClass`\n    # option:\n    #\n    # ```\n    # popover(\n    #     \"Trigger\", \"Popover message\",\n    #     options = list(customClass = \"my-pop\")\n    # )\n    # ```\n    #\n    # And then add relevant rules to [bs_theme()] via [bs_add_rules()]:\n    #\n    # ```\n    # bs_theme() |> bs_add_rules(\".my-pop { max-width: none; }\")\n    # ```\n\n    attrs, children = consolidate_attrs(*args, **kwargs)\n    if len(children) == 0:\n        raise RuntimeError(\"At least one value must be provided to `popover(*args)`.\")\n\n    if options:\n        for name in (\"content\", \"title\", \"placement\"):\n            if name in options:\n                raise RuntimeError(\n                    f\"The key `{name}` in `popover(options=)` cannot be specified directly.\"\n                )\n\n    res = web_component(\n        \"bslib-popover\",\n        # Use display:none instead of <template> since shiny.js\n        # doesn't bind to the contents of the latter\n        tags.template(\n            div(*children, style=\"display:contents;\"),\n            div(title, style=\"display:contents;\"),\n        ),\n        trigger,\n        id=resolve_id_or_none(id),\n        placement=placement,\n        bsOptions=json.dumps(drop_none(options or {})),\n        **attrs,\n    )\n\n    return res",
  "def toggle_popover(\n    id: str,\n    show: Optional[bool] = None,\n    session: Optional[Session] = None,\n) -> None:\n    \"\"\"\n    Programmatically show/hide a popover.\n\n    Parameters\n    ----------\n    id\n        The id of the popover DOM element to update.\n    show\n        Whether to show (`True`) or hide (`False`) the popover. The default\n        (`None`) will show if currently hidden and hide if currently shown.\n        Note that a popover will not be shown if the trigger is not visible\n        (e.g., it is hidden behind a tab).\n    session\n        A Shiny session object (the default should almost always be used).\n\n    See Also\n    --------\n    * :func:`~shiny.experimental.ui.popover`\n    * :func:`~shiny.experimental.ui.update_popover`\n    \"\"\"\n    session = require_active_session(session)\n\n    _session_on_flush_send_msg(\n        id,\n        session,\n        {\n            \"method\": \"toggle\",\n            \"value\": _normalize_show_value(show),\n        },\n    )",
  "def update_popover(\n    id: str,\n    *args: TagChild,\n    title: Optional[TagChild] = None,\n    session: Optional[Session] = None,\n) -> None:\n    \"\"\"\n    Update the contents or title of a popover.\n\n    Parameters\n    ----------\n    id\n        The id of the popover DOM element to update.\n    args\n        The new contents of the popover.\n    title\n        The new title of the popover.\n    session\n        A Shiny session object (the default should almost always be used).\n\n    See Also\n    --------\n    * :func:`~shiny.experimental.ui.popover`\n    * :func:`~shiny.experimental.ui.toggle_popover`\n    \"\"\"\n    session = require_active_session(session)\n\n    _session_on_flush_send_msg(\n        id,\n        session,\n        drop_none(\n            {\n                \"method\": \"update\",\n                \"content\": session._process_ui(TagList(*args))\n                if len(args) > 0\n                else None,\n                \"header\": session._process_ui(title) if title is not None else None,\n            },\n        ),\n    )",
  "def toggle_switch(\n    id: str, value: Optional[bool] = None, session: Optional[Session] = None\n):\n    \"\"\"\n    Toggle a switch input.\n\n    Parameters\n    ----------\n    id\n        The id of the switch input.\n    value\n        The new value of the switch input. If `NULL`, the value will be toggled.\n    session\n        The session object passed to `server()`.\n    \"\"\"\n\n    if value is not None and not isinstance(value, bool):\n        raise TypeError(\"`value` must be `None` or a single boolean value.\")\n\n    msg = drop_none({\"id\": resolve_id(id), \"value\": value})\n    session = require_active_session(session)\n\n    async def callback():\n        await session.send_custom_message(\"bslib.toggle-input-binary\", msg)\n\n    session.on_flush(callback, once=True)",
  "async def callback():\n        await session.send_custom_message(\"bslib.toggle-input-binary\", msg)",
  "def consolidate_attrs(\n    *args: TagAttrs,\n    **kwargs: TagAttrValue,\n) -> tuple[TagAttrs, list[TagChild]]:\n    ...",
  "def consolidate_attrs(\n    *args: TagChildT | TagAttrs,\n    **kwargs: TagAttrValue,\n) -> tuple[TagAttrs, list[TagChildT]]:\n    ...",
  "def consolidate_attrs(\n    *args: TagChildT | TagAttrs,\n    **kwargs: TagAttrValue,\n) -> tuple[TagAttrs, list[TagChildT]]:\n    tag = div(*args, **kwargs)\n\n    # `TagAttrs` currently isn't compatible with `htmltools._core.TagAttrDict`\n    # https://github.com/posit-dev/py-htmltools/pull/55\n    # Convert to a plain dict to avoid getting custom methods from TagAttrDict\n    # Cast to `TagAttrs` so that `Tag` functions will accept the dictionary.\n    attrs = typing.cast(TagAttrs, dict(tag.attrs))\n\n    # Do not alter children structure (like `TagList` does)\n    children = [child for child in args if not isinstance(child, dict)]\n    return (attrs, children)",
  "def is_01_scalar(x: object) -> TypeGuard[float]:\n    return isinstance(x, (int, float)) and x >= 0.0 and x <= 1.0",
  "def trinary(x: None) -> None:\n    ...",
  "def trinary(x: bool | str) -> str:\n    ...",
  "def trinary(x: bool | str | None) -> None | str:\n    if x is None:\n        return None\n    elif x:\n        return \"true\"\n    else:\n        return \"false\"",
  "def card(\n    *args: TagChild | TagAttrs | CardItem,\n    full_screen: bool = False,\n    height: Optional[CssUnit] = None,\n    max_height: Optional[CssUnit] = None,\n    min_height: Optional[CssUnit] = None,\n    fill: bool = True,\n    class_: Optional[str] = None,\n    wrapper: WrapperCallable | None | MISSING_TYPE = MISSING,\n    **kwargs: TagAttrValue,\n) -> Tag:\n    \"\"\"\n    A Bootstrap card component\n\n    A general purpose container for grouping related UI elements together with a border\n    and optional padding. To learn more about `card()`s, see [this\n    article](https://rstudio.github.io/bslib/articles/cards.html).\n\n    Parameters\n    ----------\n    *args\n        Unnamed arguments can be any valid child of an :class:`~htmltools.Tag` (which\n        includes card items such as :func:`~shiny.experimental.ui.card_body`. Named\n        arguments become HTML attributes on the returned Tag.\n    full_screen\n        If `True`, an icon will appear when hovering over the card body. Clicking the\n        icon expands the card to fit viewport size.\n    height,max_height,min_height\n        Any valid CSS unit (e.g., `height=\"200px\"`). Doesn't apply when a card is made\n        `full_screen` (in this case, consider setting a `height` in\n        :func:`~shiny.experimental.ui.card_body`).\n    fill\n        Whether or not to allow the card to grow/shrink to fit a fillable container with\n        an opinionated height (e.g., :func:`~shiny.experimental.ui.page_fillable`).\n    class_\n        Additional CSS classes for the returned Tag.\n    wrapper\n        A function (which returns a UI element) to call on unnamed arguments in `*args`\n        which are not already card item(s) (like\n        :func:`~shiny.experimental.ui.card_header`,\n        :func:`~shiny.experimental.ui.card_body`, etc.). Note that non-card items are\n        grouped together into one `wrapper` call (e.g. given `card(\"a\", \"b\",\n        card_body(\"c\"), \"d\")`, `wrapper` would be called twice, once with `\"a\"` and\n        `\"b\"` and once with `\"d\"`).\n\n    Returns\n    -------\n    :\n        An :func:`~shiny.ui.tags.div` tag.\n\n    See Also\n    --------\n    * :func:`~shiny.experimental.ui.layout_column_wrap` for laying out multiple cards\n      (or multiple columns inside a card).\n    * :func:`~shiny.experimental.ui.card_header` for creating a header within the card.\n    * :func:`~shiny.experimental.ui.card_title` for creating a title within the card body.\n    * :func:`~shiny.experimental.ui.card_body` for putting content inside the card.\n    * :func:`~shiny.experimental.ui.card_footer` for creating a footer within the card.\n    * :func:`~shiny.experimental.ui.card_image` for adding an image to the card.\n    \"\"\"\n    if isinstance(wrapper, MISSING_TYPE):\n        wrapper = card_body\n\n    attrs, children = consolidate_attrs(*args, class_=class_, **kwargs)\n    children = _wrap_children_in_card(*children, wrapper=wrapper)\n\n    tag = div(\n        {\n            \"class\": \"card bslib-card bslib-mb-spacing\",\n            \"style\": css(\n                height=as_css_unit(height),\n                max_height=as_css_unit(max_height),\n                min_height=as_css_unit(min_height),\n            ),\n            \"data-bslib-card-init\": True,\n            \"data-full-screen\": \"false\" if full_screen else None,\n        },\n        *children,\n        attrs,\n        _full_screen_toggle() if full_screen else None,\n        card_dependency(),\n        _card_js_init(),\n    )\n    tag = as_fillable_container(tag)\n    if fill:\n        tag = as_fill_item(tag)\n\n    return tag",
  "def _card_js_init() -> Tag:\n    return tags.script(\n        {\"data-bslib-card-init\": True},\n        \"window.bslib.Card.initializeAllCards();\",\n    )",
  "def _full_screen_toggle() -> Tag:\n    return tooltip(\n        tags.span(\n            {\"class\": \"bslib-full-screen-enter badge rounded-pill bg-dark\"},\n            _full_screen_toggle_icon(),\n        ),\n        \"Expand\",\n    )",
  "def _full_screen_toggle_icon() -> HTML:\n    return HTML(\n        '<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 16 16\" class=\"bi bi-arrows-fullscreen \" style=\"height:1em;width:1em;fill:currentColor;\" aria-hidden=\"true\" role=\"img\" ><path fill-rule=\"evenodd\" d=\"M5.828 10.172a.5.5 0 0 0-.707 0l-4.096 4.096V11.5a.5.5 0 0 0-1 0v3.975a.5.5 0 0 0 .5.5H4.5a.5.5 0 0 0 0-1H1.732l4.096-4.096a.5.5 0 0 0 0-.707zm4.344 0a.5.5 0 0 1 .707 0l4.096 4.096V11.5a.5.5 0 1 1 1 0v3.975a.5.5 0 0 1-.5.5H11.5a.5.5 0 0 1 0-1h2.768l-4.096-4.096a.5.5 0 0 1 0-.707zm0-4.344a.5.5 0 0 0 .707 0l4.096-4.096V4.5a.5.5 0 1 0 1 0V.525a.5.5 0 0 0-.5-.5H11.5a.5.5 0 0 0 0 1h2.768l-4.096 4.096a.5.5 0 0 0 0 .707zm-4.344 0a.5.5 0 0 1-.707 0L1.025 1.732V4.5a.5.5 0 0 1-1 0V.525a.5.5 0 0 1 .5-.5H4.5a.5.5 0 0 1 0 1H1.732l4.096 4.096a.5.5 0 0 1 0 .707z\"></path></svg>'\n    )",
  "class CardItem:\n    \"\"\"\n    A wrapper around a :class:`~htmltools.Tag` object that represents a card item (e.g.,\n    :func:`~shiny.experimental.ui.card_body`,\n    :func:`~shiny.experimental.ui.card_header`, etc.).\n\n    This class is used to allow for consecutive non-card items to be bundled into a\n    single `card_body` within :func:`~shiny.experimental.ui.card`.\n\n    Parameters\n    ----------\n    item\n        A :class:`~htmltools.Tag` object that represents a card item (e.g.,\n        :func:`~shiny.experimental.ui.card_body`, :func:`~shiny.experimental.ui.card_header`, etc.).\n\n    See Also\n    --------\n    * :func:`~shiny.experimental.ui.card` for creating a card component.\n    * :func:`~shiny.experimental.ui.card_header` for creating a header within the card.\n    * :func:`~shiny.experimental.ui.card_title` for creating a title within the card body.\n    * :func:`~shiny.experimental.ui.card_body` for putting content inside the card.\n    * :func:`~shiny.experimental.ui.card_image` for adding an image to the card.\n    * :func:`~shiny.experimental.ui.card_footer` for creating a footer within the card.\n    \"\"\"\n\n    def __init__(\n        self,\n        item: TagChild,\n    ):\n        self._item = item\n\n    def resolve(self) -> TagChild:\n        \"\"\"\n        Resolves the `CardItem` class by returning the `item` provided at initialization.\n\n        Returns\n        -------\n        :\n            The `item` provided at initialization.\n        \"\"\"\n        return self._item\n\n    def tagify(self) -> TagList:\n        \"\"\"\n        Tagify the `item`\n\n        Returns\n        -------\n        :\n            A tagified :class:`~htmltools.TagList` object.\n        \"\"\"\n        return TagList(self.resolve()).tagify()",
  "def card_body(\n    *args: TagChild | TagAttrs,\n    fillable: bool = True,\n    min_height: Optional[CssUnit] = None,\n    max_height: Optional[CssUnit] = None,\n    max_height_full_screen: Optional[CssUnit] | MISSING_TYPE = MISSING,\n    height: Optional[CssUnit] = None,\n    padding: Optional[CssUnit | list[CssUnit]] = None,\n    gap: Optional[CssUnit] = None,\n    fill: bool = True,\n    class_: Optional[str] = None,\n    **kwargs: TagAttrValue,\n) -> CardItem:\n    # For a general overview of the :func:`~shiny.experimental.ui.card` API, see [this article](https://rstudio.github.io/bslib/articles/cards.html).\n    \"\"\"\n    Card body container\n\n    A general container for the \"main content\" of a :func:`~shiny.experimental.ui.card`. This component is designed\n    to be provided as direct children to :func:`~shiny.experimental.ui.card`.\n\n    Parameters\n    ----------\n    *args\n        Contents to the card's body. Or tag attributes that are supplied to the\n        resolved :class:`~htmltools.Tag` object.\n    fillable\n        Whether or not the card item should be a fillable (i.e. flexbox) container.\n    min_height,max_height,max_height_full_screen\n        Any valid CSS length unit. If `max_height_full_screen` is missing, it is set to\n        `max_height`.\n    height\n        Any valid CSS unit (e.g., `height=\"200px\"`). Doesn't apply when a card is made\n        `full_screen` (in this case, consider setting a `height` in\n        :func:`~shiny.experimental.ui.card_body`).\n    padding\n        Padding to use for the body. This can be a numeric vector\n        (which will be interpreted as pixels) or a character vector with valid CSS\n        lengths. The length can be between one and four. If one, then that value\n        will be used for all four sides. If two, then the first value will be used\n        for the top and bottom, while the second value will be used for left and\n        right. If three, then the first will be used for top, the second will be\n        left and right, and the third will be bottom. If four, then the values will\n        be interpreted as top, right, bottom, and left respectively.\n    gap\n        A CSS length unit defining the `gap` (i.e., spacing) between elements provided\n        to `*args`. This argument is only applicable when `fillable = TRUE`.\n    fill\n        Whether to allow this element to grow/shrink to fit its `card` container.\n    class_\n        Additional CSS classes for the returned Tag.\n    **kwargs\n        Additional HTML attributes for the returned Tag.\n\n    Returns\n    -------\n    :\n        A :class:`~shiny.experimental.ui.CardItem` object.\n\n    See Also\n    --------\n    * :func:`~shiny.experimental.ui.layout_column_wrap` for laying out multiple cards\n        (or multiple columns inside a card).\n    * :func:`~shiny.experimental.ui.card` for creating a card component.\n    * :func:`~shiny.experimental.ui.card_header` for creating a header within the card.\n    * :func:`~shiny.experimental.ui.card_title` for creating a title within the card body.\n    * :func:`~shiny.experimental.ui.card_footer` for creating a footer within the card.\n    * :func:`~shiny.experimental.ui.card_image` for adding an image to the card.\n    \"\"\"\n    if isinstance(max_height_full_screen, MISSING_TYPE):\n        max_height_full_screen = max_height\n\n    div_style_args = {\n        \"min-height\": as_css_unit(min_height),\n        \"--bslib-card-body-max-height\": as_css_unit(max_height),\n        \"--bslib-card-body-max-height-full-screen\": as_css_unit(max_height_full_screen),\n        \"margin-top\": \"auto\",\n        \"margin-bottom\": \"auto\",\n        # .card-body already adds `flex: 1 1 auto` so make sure to override it\n        \"flex\": \"1 1 auto\" if fill else \"0 0 auto\",\n        \"padding\": as_css_padding(padding),\n        \"gap\": as_css_unit(gap),\n        \"height\": as_css_unit(height),\n    }\n    tag = tags.div(\n        {\n            \"class\": \"card-body bslib-gap-spacing\",\n            \"style\": css(**div_style_args),\n        },\n        *args,\n        class_=class_,\n        **kwargs,\n    )\n\n    if fillable:\n        tag = as_fillable_container(tag)\n    if fill:\n        tag = as_fill_item(tag)\n\n    return CardItem(tag)",
  "class WrapperCallable(Protocol):\n    \"\"\"\n    A callable that wraps children into a :class:`~shiny.experimental.ui.CardItem`.\n    \"\"\"\n\n    def __call__(self, *args: TagChild) -> CardItem:\n        \"\"\"\n        Wraps children into a :class:`~shiny.experimental.ui.CardItem`.\n\n        Parameters\n        ----------\n        *args\n            `TagChild` children to wrap.\n\n        Returns\n        -------\n        :\n            A :class:`~shiny.experimental.ui.CardItem` object.\n        \"\"\"\n        ...",
  "def _as_card_items(\n    *children: TagChild | CardItem | None,  # `TagAttrs` are not allowed here\n    wrapper: WrapperCallable | None,\n) -> list[CardItem]:\n    # We don't want `None`s creating empty card bodies\n    children_vals = [child for child in children if child is not None]\n\n    attrs, children_vals = consolidate_attrs(*children_vals)\n    if len(attrs) > 0:\n        raise ValueError(\"`TagAttrs` are not allowed in `_as_card_items(*children=)`.\")\n\n    if not callable(wrapper):\n        ret: list[CardItem] = []\n        for child in children_vals:\n            if isinstance(child, CardItem):\n                ret.append(child)\n            else:\n                ret.append(CardItem(child))\n        return ret\n\n    # Any children that are `is.card_item` should be included verbatim. Any\n    # children that are not, should be wrapped in card_body(). Consecutive children\n    # that are not card_item, should be wrapped in a single card_body().\n    state = \"asis\"  # \"wrap\" | \"asis\"\n    new_children: list[CardItem] = []\n    children_to_wrap: list[TagChild] = []\n\n    def wrap_children():\n        nonlocal children_to_wrap\n        wrapped_children = wrapper(*children_to_wrap)\n        new_children.append(wrapped_children)\n        children_to_wrap = []\n\n    for child in children_vals:\n        if isinstance(child, CardItem):\n            if state == \"wrap\":\n                wrap_children()\n            state = \"asis\"\n            new_children.append(child)\n        else:\n            # Not a card, collect it for wrapping\n            state = \"wrap\"\n            children_to_wrap.append(child)\n    if state == \"wrap\":\n        wrap_children()\n\n    return new_children",
  "def _wrap_children_in_card(\n    *children: TagChild | CardItem | None,  # `TagAttrs` are not allowed here\n    wrapper: WrapperCallable | None,\n) -> list[TagChild]:\n    card_items = _as_card_items(*children, wrapper=wrapper)\n    tag_children = [card_item.resolve() for card_item in card_items]\n    return tag_children",
  "class TagCallable(Protocol):  # Should this be exported from htmltools?\n    \"\"\"\n    Callable definition for a defined :class:`~htmltools.Tag` method.\n\n    This is used to define the `container` argument in :func:`~shiny.experimental.ui.card_title`,\n    :func:`~shiny.experimental.ui.card_header`, and :func:`~shiny.experimental.ui.card_footer`.\n\n    See Also\n    --------\n    * :class:`~htmltools.Tag`\n    \"\"\"\n\n    def __call__(\n        self,\n        *args: TagChild | TagAttrs,\n        _add_ws: bool = True,\n        **kwargs: TagAttrValue,\n    ) -> Tagifiable:\n        \"\"\"\n        A tag method.\n\n        Parameters\n        ----------\n        *args\n            Contents to the tag method. Or tag attributes that are supplied to the\n            resolved :class:`~htmltools.Tag` object.\n        _add_ws\n            Whether or not to add whitespace to the returned :class:`~htmltools.Tag`\n            object.\n        **kwargs\n            Additional HTML attributes for the returned Tag.\n\n        Returns\n        -------\n        :\n            A :class:`~htmltools.Tag` object.\n        \"\"\"\n        ...",
  "def card_title(\n    *args: TagChild | TagAttrs,\n    container: TagCallable = tags.h5,\n    **kwargs: TagAttrValue,\n) -> Tagifiable:\n    \"\"\"\n    Card title container\n\n    A general container for the \"title\" of a :func:`~shiny.experimental.ui.card`. This component is designed\n    to be provided as a direct child to :func:`~shiny.experimental.ui.card`.\n\n    Parameters\n    ----------\n    *args\n        Contents to the card's title. Or tag attributes that are supplied to the\n        resolved :class:`~htmltools.Tag` object.\n    container\n        Method for the returned Tag object. Defaults to :func:`shiny.ui.tags.h5`.\n    **kwargs\n        Additional HTML attributes for the returned Tag.\n\n    Returns\n    -------\n    :\n        A Tag object.\n\n    See Also\n    --------\n    * :func:`~shiny.experimental.ui.card` for creating a card component.\n    * :func:`~shiny.experimental.ui.card_header` for creating a header within the card.\n    * :func:`~shiny.experimental.ui.card_body` for putting content inside the card.\n    * :func:`~shiny.experimental.ui.card_footer` for creating a footer within the card.\n    * :func:`~shiny.experimental.ui.card_image` for adding an image to the card.\n    \"\"\"\n    return container(*args, **kwargs)",
  "def card_header(\n    *args: TagChild | TagAttrs,\n    container: TagCallable = tags.div,\n    **kwargs: TagAttrValue,\n) -> CardItem:\n    \"\"\"\n    Card header container\n\n    A general container for the \"header\" of a :func:`~shiny.experimental.ui.card`. This component is designed\n    to be provided as a direct child to :func:`~shiny.experimental.ui.card`.\n\n    The header has a different background color and border than the rest of the card.\n\n    Parameters\n    ----------\n    *args\n        Contents to the header container. Or tag attributes that are supplied to the\n        resolved :class:`~htmltools.Tag` object.\n    container\n        Method for the returned Tag object. Defaults to :func:`~shiny.ui.tags.div`.\n    **kwargs\n        Additional HTML attributes for the returned Tag.\n\n    Returns\n    -------\n    :\n        A :class:`~shiny.experimental.ui.CardItem` object.\n\n    See Also\n    --------\n    * :func:`~shiny.experimental.ui.card` for creating a card component.\n    * :func:`~shiny.experimental.ui.card_title` for creating a title within the card body.\n    * :func:`~shiny.experimental.ui.card_body` for putting content inside the card.\n    * :func:`~shiny.experimental.ui.card_footer` for creating a footer within the card.\n    * :func:`~shiny.experimental.ui.card_image` for adding an image to the card.\n    \"\"\"\n    return CardItem(\n        container({\"class\": \"card-header\"}, *args, **kwargs),\n    )",
  "def card_footer(\n    *args: TagChild | TagAttrs,\n    **kwargs: TagAttrValue,\n) -> CardItem:\n    \"\"\"\n    Card footer container\n\n    A general container for the \"footer\" of a :func:`~shiny.experimental.ui.card`. This component is designed\n    to be provided as a direct child to :func:`~shiny.experimental.ui.card`.\n\n    The footer has a different background color and border than the rest of the card.\n\n    Parameters\n    ----------\n    *args\n        Contents to the footer container. Or tag attributes that are supplied to the\n        resolved :class:`~htmltools.Tag` object.\n    **kwargs\n        Additional HTML attributes for the returned Tag.\n\n    Returns\n    -------\n    :\n        A :class:`~shiny.experimental.ui.CardItem` object.\n\n    See Also\n    --------\n    * :func:`~shiny.experimental.ui.card` for creating a card component.\n    * :func:`~shiny.experimental.ui.card_title` for creating a title within the card body.\n    * :func:`~shiny.experimental.ui.card_body` for putting content inside the card.\n    * :func:`~shiny.experimental.ui.card_footer` for creating a footer within the card.\n    * :func:`~shiny.experimental.ui.card_image` for adding an image to the card.\n    \"\"\"\n    return CardItem(\n        tags.div({\"class\": \"card-footer\"}, *args, **kwargs),\n    )",
  "class ImgContainer(Protocol):\n    \"\"\"\n    A callable that wraps the return value of `card_image()`. To isolate your object in a card, return a :class:`~shiny.experimental.ui.CardItem`.\n    \"\"\"\n\n    def __call__(self, *args: Tag) -> Tagifiable:\n        \"\"\"\n        Wraps the return value of `card_image()`.\n\n        Parameters\n        ----------\n        *args\n            The return value of `card_image()`.\n\n        Returns\n        -------\n        :\n            A tagifiable object, such as a :class:`~htmltools.Tag` or\n            :class:`~shiny.experimental.ui.CardItem` object.\n        \"\"\"\n        ...",
  "def card_image(\n    file: str | Path | PurePath | io.BytesIO | None,\n    *args: TagAttrs,\n    href: Optional[str] = None,\n    border_radius: Literal[\"top\", \"bottom\", \"all\", \"none\"] = \"top\",\n    mime_type: Optional[str] = None,\n    class_: Optional[str] = None,\n    height: Optional[CssUnit] = None,\n    fill: bool = True,\n    width: Optional[CssUnit] = None,\n    # Required so that multiple `card_images()` are not put in the same `card()`\n    container: ImgContainer = card_body,\n    **kwargs: TagAttrValue,\n) -> Tagifiable:\n    \"\"\"\n    Card image container\n\n    A general container for an image within a :func:`~shiny.experimental.ui.card`. This component is designed to be\n    provided as a direct child to :func:`~shiny.experimental.ui.card`.\n\n    Parameters\n    ----------\n    file\n        A file path pointing an image. The image will be base64 encoded and provided to\n        the `src` attribute of the `<img>`. Alternatively, you may set this value to\n        `None` and provide the `src` yourself via `*args:TagAttrs` or\n        `**kwargs:TagAttrValue` (e.g. `{\"src\": \"HOSTED_PATH_TO_IMAGE\"}` or\n        `src=\"HOSTED_PATH_TO_IMAGE\"`).\n    *args\n        Dictionary of tag attributes that are supplied to the resolved\n        :class:`~htmltools.Tag` object.\n    href\n        An optional URL to link to.\n    border_radius\n        Where to apply `border-radius` on the image.\n    mime_type\n        The mime type of the `file`.\n    class_\n        Additional CSS classes for the resolved Tag.\n    height\n        Any valid CSS unit (e.g., `height=\"200px\"`). Doesn't apply when a card is made\n        `full_screen` (in this case, consider setting a `height` in\n        :func:`~shiny.experimental.ui.card_body`).\n    fill\n        Whether to allow this element to grow/shrink to fit its `card` container.\n    width\n        Any valid CSS unit (e.g., `width=\"100%\"`).\n    container\n        Method to wrap the returned Tag object. Defaults to :func:`~shiny.experimental.ui.card_body`.\n        If :func:`~shiny.experimental.ui.card_body` is used, each image will be in separate cards. If\n        the `container` method does not return a :class:`~shiny.experimental.ui.CardItem`, it\n        allows for consecutive non-`CardItem` objects to be bundled into a single\n        :func:`~shiny.experimental.ui.card_body` within :func:`~shiny.experimental.ui.card`.\n    **kwargs\n        Additional HTML attributes for the resolved Tag.\n    \"\"\"\n    src = None\n    if file is not None:\n        if isinstance(file, io.BytesIO):\n            b64_str = base64.b64encode(file.read()).decode(\"utf-8\")\n            if mime_type is None:\n                raise ValueError(\n                    \"`mime_type` must be provided when passing an in-memory buffer\"\n                )\n            src = f\"data:{mime_type};base64,{b64_str}\"\n\n        elif isinstance(file, (str, Path, PurePath)):\n            with open(file, \"rb\") as img_file:\n                b64_str = base64.b64encode(img_file.read()).decode(\"utf-8\")\n                if mime_type is None:\n                    mime_type = mimetypes.guess_type(file)[0]\n                src = f\"data:{mime_type};base64,{b64_str}\"\n\n    card_class_map = {\n        \"all\": \"card-img\",\n        \"top\": \"card-img-top\",\n        \"bottom\": \"card-img-bottom\",\n    }\n\n    image = tags.img(\n        {\n            \"src\": src,\n            \"class\": \"img-fluid\",\n            \"style\": css(\n                height=as_css_unit(height),\n                width=as_css_unit(width),\n            ),\n        },\n        {\"class\": card_class_map.get(border_radius, None)},\n        *args,\n        class_=class_,\n        **kwargs,\n    )\n\n    if fill:\n        image = as_fill_item(image)\n\n    if href is not None:\n        image = as_fill_carrier(\n            tags.a(\n                image,\n                href=href,\n            )\n        )\n\n    if container:\n        return container(image)\n    else:\n        return CardItem(image)",
  "def __init__(\n        self,\n        item: TagChild,\n    ):\n        self._item = item",
  "def resolve(self) -> TagChild:\n        \"\"\"\n        Resolves the `CardItem` class by returning the `item` provided at initialization.\n\n        Returns\n        -------\n        :\n            The `item` provided at initialization.\n        \"\"\"\n        return self._item",
  "def tagify(self) -> TagList:\n        \"\"\"\n        Tagify the `item`\n\n        Returns\n        -------\n        :\n            A tagified :class:`~htmltools.TagList` object.\n        \"\"\"\n        return TagList(self.resolve()).tagify()",
  "def __call__(self, *args: TagChild) -> CardItem:\n        \"\"\"\n        Wraps children into a :class:`~shiny.experimental.ui.CardItem`.\n\n        Parameters\n        ----------\n        *args\n            `TagChild` children to wrap.\n\n        Returns\n        -------\n        :\n            A :class:`~shiny.experimental.ui.CardItem` object.\n        \"\"\"\n        ...",
  "def wrap_children():\n        nonlocal children_to_wrap\n        wrapped_children = wrapper(*children_to_wrap)\n        new_children.append(wrapped_children)\n        children_to_wrap = []",
  "def __call__(\n        self,\n        *args: TagChild | TagAttrs,\n        _add_ws: bool = True,\n        **kwargs: TagAttrValue,\n    ) -> Tagifiable:\n        \"\"\"\n        A tag method.\n\n        Parameters\n        ----------\n        *args\n            Contents to the tag method. Or tag attributes that are supplied to the\n            resolved :class:`~htmltools.Tag` object.\n        _add_ws\n            Whether or not to add whitespace to the returned :class:`~htmltools.Tag`\n            object.\n        **kwargs\n            Additional HTML attributes for the returned Tag.\n\n        Returns\n        -------\n        :\n            A :class:`~htmltools.Tag` object.\n        \"\"\"\n        ...",
  "def __call__(self, *args: Tag) -> Tagifiable:\n        \"\"\"\n        Wraps the return value of `card_image()`.\n\n        Parameters\n        ----------\n        *args\n            The return value of `card_image()`.\n\n        Returns\n        -------\n        :\n            A tagifiable object, such as a :class:`~htmltools.Tag` or\n            :class:`~shiny.experimental.ui.CardItem` object.\n        \"\"\"\n        ...",
  "def get_color_contrast(color: str) -> str:\n    # TODO-future: Implement\n    return color",
  "class AccordionPanel:\n    \"\"\"\n    Internal class used to represent an accordion panel.\n\n    This class is used to represent an accordion panel. It is not intended to be\n    instantiated directly. Instead, use :func:`~shiny.experimental.ui.accordion_panel`.\n\n    Parameters\n    ----------\n    *args\n        Contents to the accordion panel body. Or tag attributes that are supplied to the\n        returned :class:`~htmltools.Tag` object.\n    data_value\n        A character string that uniquely identifies this panel.\n    icon\n        A :class:`~htmltools.Tag` which is positioned just before the `title`.\n    title\n        A title to appear in the :func:`~shiny.experimental.ui.accordion_panel`'s header.\n    id\n        A unique id for this panel.\n    **kwargs\n        Tag attributes to the `accordion-body` div Tag.\n\n    See Also\n    --------\n    * :func:`~shiny.experimental.ui.accordion`\n    * :func:`~shiny.experimental.ui.accordion_panel_set`\n    * :func:`~shiny.experimental.ui.accordion_panel_open`\n    * :func:`~shiny.experimental.ui.accordion_panel_close`\n    * :func:`~shiny.experimental.ui.accordion_panel_insert`\n    * :func:`~shiny.experimental.ui.accordion_panel_remove`\n    * :func:`~shiny.experimental.ui.update_accordion_panel`\n    \"\"\"\n\n    _args: tuple[TagChild | TagAttrs, ...]\n    _kwargs: dict[str, TagAttrValue]\n\n    _data_value: str  # Read within `accordion()`\n    _icon: TagChild | None\n    _title: TagChild | None\n    _id: str | None\n\n    _is_open: bool  # Set within `accordion()`\n    _is_multiple: bool  # Set within `accordion()`\n\n    def __init__(\n        self,\n        *args: TagChild | TagAttrs,\n        data_value: str,\n        icon: TagChild | None,\n        title: TagChild | None,\n        id: str | None,\n        **kwargs: TagAttrValue,\n    ):\n        self._args = args\n        self._data_value = data_value\n        self._icon = icon\n        self._title = title\n        self._id = id\n        self._kwargs = kwargs\n        self._is_multiple = False\n        self._is_open = True\n\n    def resolve(self) -> Tag:\n        \"\"\"\n        Resolve the :class:`~shiny.experimental.ui.AccordionPanel` into a\n        :class:`~htmltools.Tag`.\n\n        Returns\n        -------\n        :\n            A :class:`~htmltools.Tag` object representing the\n            :class:`~shiny.experimental.ui.AccordionPanel`.\n        \"\"\"\n        btn_attrs = {}\n        if self._is_open:\n            btn_attrs[\"aria-expanded\"] = \"true\"\n        else:\n            btn_attrs[\"class\"] = \"collapsed\"\n            btn_attrs[\"aria-expanded\"] = \"false\"\n\n        if not self._is_multiple:\n            btn_attrs[\"data-bs-parent\"] = f\"#{self._id}\"\n\n        btn = tags.button(\n            {\n                \"class\": \"accordion-button\",\n                \"type\": \"button\",\n                \"data-bs-toggle\": \"collapse\",\n                \"data-bs-target\": f\"#{self._id}\",\n                \"aria-controls\": self._id,\n            },\n            btn_attrs,\n            # Always include an .accordion-icon container to simplify update_accordion_panel() logic\n            tags.div({\"class\": \"accordion-icon\"}, self._icon),\n            tags.div({\"class\": \"accordion-title\"}, self._title),\n        )\n\n        attrs, children = consolidate_attrs(*self._args, **self._kwargs)\n\n        return tags.div(\n            {\n                \"class\": \"accordion-item\",\n                \"data-value\": self._data_value,\n            },\n            # Use a <span.h2> instead of <h2> so that it doesn't get included in rmd/pkgdown/qmd TOC\n            # TODO-bslib: can we provide a way to put more stuff in the header? Like maybe some right-aligned controls?\n            tags.span(\n                {\"class\": \"accordion-header h2\"},\n                btn,\n            ),\n            tags.div(\n                {\n                    \"id\": self._id,\n                    \"class\": \"accordion-collapse collapse\",\n                },\n                {\"class\": \"show\"} if self._is_open else None,\n                tags.div(\n                    {\"class\": \"accordion-body\"},\n                    attrs,\n                    children,\n                ),\n            ),\n        )\n\n    def tagify(self) -> Tag:\n        \"\"\"\n        Resolve the :class:`~shiny.experimental.ui.AccordionPanel` into a\n        :class:`~htmltools.Tag`.\n\n        Returns\n        -------\n        :\n            A tagified `resolve()`d value.\n        \"\"\"\n        return self.resolve().tagify()",
  "def accordion(\n    *args: AccordionPanel | TagAttrs,\n    id: Optional[str] = None,\n    open: Optional[bool | str | list[str]] = None,\n    multiple: bool = True,\n    class_: Optional[str] = None,\n    width: Optional[CssUnit] = None,\n    height: Optional[CssUnit] = None,\n    **kwargs: TagAttrValue,\n) -> Tag:\n    \"\"\"\n    Create a vertically collapsing accordion.\n\n    Parameters\n    ----------\n    *args\n        :class:`~shiny.experimental.ui.AccordionPanel` objects returned from\n        :func:`~shiny.experimental.ui.accordion_panel`. Or tag attributes that are\n        supplied to the returned :class:`~htmltools.Tag` object.\n    id\n        If provided, you can use `input.id()` in your server logic to determine which of\n        the :func:`~shiny.experimental.ui.accordion_panel`s are currently active. The\n        value will correspond to the :func:`~shiny.experimental.ui.accordion_panel`'s\n        `value` argument.\n    open\n        A list of :func:`~shiny.experimental.ui.accordion_panel` values to open (i.e.,\n        show) by default. The default value of `None` will open the first\n        :func:`~shiny.experimental.ui.accordion_panel`. Use a value of `True` to open\n        all (or `False` to open none) of the items. It's only possible to open more than\n        one panel when `multiple=True`.\n    multiple\n        Whether multiple :func:`~shiny.experimental.ui.accordion_panel` can be open at\n        once.\n    class_\n        Additional CSS classes to include on the accordion div.\n    width\n        Any valid CSS unit; for example, height=\"100%\".\n    height\n        Any valid CSS unit; for example, height=\"100%\".\n    **kwargs\n        Attributes to this tag.\n\n    Returns\n    -------\n    :\n        Accordion panel Tag object.\n\n\n    References\n    ----------\n    [Bootstrap Accordion](https://getbootstrap.com/docs/5.2/components/accordion/)\n\n    See Also\n    --------\n    * :func:`~shiny.experimental.ui.accordion_panel`\n    * :func:`~shiny.experimental.ui.accordion_panel_set`\n    * :func:`~shiny.experimental.ui.accordion_panel_open`\n    * :func:`~shiny.experimental.ui.accordion_panel_close`\n    * :func:`~shiny.experimental.ui.accordion_panel_insert`\n    * :func:`~shiny.experimental.ui.accordion_panel_remove`\n    * :func:`~shiny.experimental.ui.update_accordion_panel`\n    \"\"\"\n\n    # TODO-bookmarking: Restore input here\n    # open = restore_input(id = id, default = open)\n\n    attrs, panels = consolidate_attrs(*args, class_=class_, **kwargs)\n    for panel in panels:\n        if not isinstance(panel, AccordionPanel):\n            raise TypeError(\n                \"All `accordion(*args)` must be of type `AccordionPanel` which can be created using `accordion_panel()`\"\n            )\n\n    is_open: list[bool] = []\n    if open is None:\n        is_open = [False for _ in panels]\n    elif isinstance(open, bool):\n        is_open = [open for _ in panels]\n    else:\n        if not isinstance(open, list):\n            open = [open]\n        #\n        is_open = [panel._data_value in open for panel in panels]\n\n    # Open the first panel by default\n    if open is not False and len(is_open) > 0 and not any(is_open):\n        is_open[0] = True\n\n    if (not multiple) and sum(is_open) > 1:\n        raise ValueError(\"Can't select more than one panel when `multiple = False`\")\n\n    # Since multiple=False requires an id, we always include one,\n    # but only create a binding when it is provided\n    binding_class_value: TagAttrs | None = None\n    if id is None:\n        id = f\"bslib-accordion-{random.randint(1000, 10000)}\"\n        binding_class_value = None\n    else:\n        binding_class_value = {\"class\": \"bslib-accordion-input\"}\n\n    for panel, open in zip(panels, is_open):\n        panel._is_multiple = multiple\n        panel._is_open = open\n\n    panel_tags = [panel.resolve() for panel in panels]\n\n    tag = tags.div(\n        {\n            \"id\": resolve_id_or_none(id),\n            \"class\": \"accordion\",\n            \"style\": css(width=as_css_unit(width), height=as_css_unit(height)),\n        },\n        # just for ease of identifying autoclosing client-side\n        {\"class\": \"autoclose\"} if not multiple else None,\n        binding_class_value,\n        accordion_dependency(),\n        attrs,\n        *panel_tags,\n    )\n    return tag",
  "def accordion_panel(\n    title: TagChild,\n    *args: TagChild | TagAttrs,\n    value: Optional[str] | MISSING_TYPE = MISSING,\n    icon: Optional[TagChild] = None,\n    **kwargs: TagAttrValue,\n) -> AccordionPanel:\n    \"\"\"\n    Single accordion panel.\n\n    Parameters\n    ----------\n    title\n        A title to appear in the :func:`~shiny.experimental.ui.accordion_panel`'s header.\n    *args\n        Contents to the accordion panel body. Or tag attributes that are supplied to the\n        returned :class:`~htmltools.Tag` object.\n    value\n        A character string that uniquely identifies this panel. If `MISSING`, the\n        `title` will be used.\n    icon\n        A :class:`~htmltools.Tag` which is positioned just before the `title`.\n    **kwargs\n        Tag attributes to the `accordion-body` div Tag.\n\n    Returns\n    -------\n    :\n        `AccordionPanel` object.\n\n\n    References\n    ----------\n    [Bootstrap Accordion](https://getbootstrap.com/docs/5.2/components/accordion/)\n\n    See Also\n    --------\n    * :func:`~shiny.experimental.ui.accordion`\n    * :func:`~shiny.experimental.ui.accordion_panel_set`\n    * :func:`~shiny.experimental.ui.accordion_panel_open`\n    * :func:`~shiny.experimental.ui.accordion_panel_close`\n    * :func:`~shiny.experimental.ui.accordion_panel_insert`\n    * :func:`~shiny.experimental.ui.accordion_panel_remove`\n    * :func:`~shiny.experimental.ui.update_accordion_panel`\n    \"\"\"\n\n    if value is MISSING:\n        if isinstance(title, str):\n            value = title\n        else:\n            raise ValueError(\"If `title` is not a string, `value` must be provided\")\n        value = title\n    if not isinstance(value, str):\n        raise TypeError(\"`value` must be a string\")\n\n    id = f\"bslib-accordion-panel-{random.randint(1000, 10000)}\"\n\n    return AccordionPanel(\n        *args,\n        data_value=value,\n        icon=icon,\n        title=title,\n        id=id,\n        **kwargs,\n    )",
  "def _send_panel_message(\n    id: str,\n    session: Session | None,\n    **kwargs: object,\n) -> None:\n    message = drop_none(kwargs)\n    session = require_active_session(session)\n    session.on_flush(lambda: session.send_input_message(id, message), once=True)",
  "def _accordion_panel_action(\n    *,\n    id: str,\n    method: str,\n    values: bool | str | list[str],\n    session: Session | None,\n) -> None:\n    if not isinstance(values, bool):\n        if not isinstance(values, list):\n            values = [values]\n        _assert_list_str(values)\n\n    _send_panel_message(\n        id,\n        session,\n        method=method,\n        values=values,\n    )",
  "def accordion_panel_set(\n    id: str,\n    values: bool | str | list[str],\n    session: Optional[Session] = None,\n) -> None:\n    \"\"\"\n    Dynamically set accordions panel state\n\n    Dynamically (i.e., programmatically) update/modify :func:`~shiny.experimental.ui.accordion`s in a Shiny app.\n    These functions require an `id` to be provided to the :func:`~shiny.experimental.ui.accordion` and must also be\n    called within an active Shiny session.\n\n    Parameters\n    ----------\n    id\n        A string that matches an existing :func:`~shiny.experimental.ui.accordion`'s `id`.\n    values\n        either a string or list of strings (used to identify particular\n        :func:`~shiny.experimental.ui.accordion_panel`(s) by their `value`) or a `bool` to set the state of all\n        panels.\n    session\n        A shiny session object (the default should almost always be used).\n\n    References\n    ----------\n    [Bootstrap Accordion](https://getbootstrap.com/docs/5.2/components/accordion/)\n\n    See Also\n    --------\n    * :func:`~shiny.experimental.ui.accordion`\n    * :func:`~shiny.experimental.ui.accordion_panel`\n    * :func:`~shiny.experimental.ui.accordion_panel_open`\n    * :func:`~shiny.experimental.ui.accordion_panel_close`\n    * :func:`~shiny.experimental.ui.accordion_panel_insert`\n    * :func:`~shiny.experimental.ui.accordion_panel_remove`\n    * :func:`~shiny.experimental.ui.update_accordion_panel`\n    \"\"\"\n    _accordion_panel_action(id=id, method=\"set\", values=values, session=session)",
  "def accordion_panel_open(\n    id: str,\n    values: bool | str | list[str],\n    session: Optional[Session] = None,\n) -> None:\n    \"\"\"\n    Open a set of :func:`~shiny.experimental.ui.accordion_panel`s.\n\n    Parameters\n    ----------\n    id\n        A string that matches an existing :func:`~shiny.experimental.ui.accordion`'s `id`.\n    values\n        either a string or list of strings (used to identify particular\n        :func:`~shiny.experimental.ui.accordion_panel`(s) by their `value`) or a `bool` to set the state of all\n        panels.\n    session\n        A shiny session object (the default should almost always be used).\n\n    References\n    ----------\n    [Bootstrap Accordion](https://getbootstrap.com/docs/5.2/components/accordion/)\n\n    See Also\n    --------\n    * :func:`~shiny.experimental.ui.accordion`\n    * :func:`~shiny.experimental.ui.accordion_panel`\n    * :func:`~shiny.experimental.ui.accordion_panel_set`\n    * :func:`~shiny.experimental.ui.accordion_panel_close`\n    * :func:`~shiny.experimental.ui.accordion_panel_insert`\n    * :func:`~shiny.experimental.ui.accordion_panel_remove`\n    * :func:`~shiny.experimental.ui.update_accordion_panel`\n    \"\"\"\n    _accordion_panel_action(id=id, method=\"open\", values=values, session=session)",
  "def accordion_panel_close(\n    id: str,\n    values: bool | str | list[str],\n    session: Optional[Session] = None,\n) -> None:\n    \"\"\"\n    Close a set of accordion panels in an :func:`~shiny.experimental.ui.accordion`.\n\n    Parameters\n    ----------\n    id\n        A string that matches an existing :func:`~shiny.experimental.ui.accordion`'s `id`.\n    values\n        either a string or list of strings (used to identify particular\n        :func:`~shiny.experimental.ui.accordion_panel`(s) by their `value`) or a `bool` to set the state of all\n        panels.\n    session\n        A shiny session object (the default should almost always be used).\n\n    References\n    ----------\n    [Bootstrap Accordion](https://getbootstrap.com/docs/5.2/components/accordion/)\n\n    See Also\n    --------\n    * :func:`~shiny.experimental.ui.accordion`\n    * :func:`~shiny.experimental.ui.accordion_panel`\n    * :func:`~shiny.experimental.ui.accordion_panel_set`\n    * :func:`~shiny.experimental.ui.accordion_panel_open`\n    * :func:`~shiny.experimental.ui.accordion_panel_insert`\n    * :func:`~shiny.experimental.ui.accordion_panel_remove`\n    * :func:`~shiny.experimental.ui.update_accordion_panel`\n    \"\"\"\n    _accordion_panel_action(id=id, method=\"close\", values=values, session=session)",
  "def accordion_panel_insert(\n    id: str,\n    panel: AccordionPanel,\n    target: Optional[str] = None,\n    position: Literal[\"after\", \"before\"] = \"after\",\n    session: Optional[Session] = None,\n) -> None:\n    \"\"\"\n    Insert an :func:`~shiny.experimental.ui.accordion_panel`\n\n    Parameters\n    ----------\n    id\n        A string that matches an existing :func:`~shiny.experimental.ui.accordion`'s `id`.\n    panel\n        An :func:`~shiny.experimental.ui.accordion_panel` object to insert.\n    target\n        The `value` of an existing panel to insert next to.\n    position\n        Should `panel` be added before or after the target? When `target=None`,\n        `\"after\"` will append after the last panel and `\"before\"` will prepend before\n        the first panel.\n    session\n        A shiny session object (the default should almost always be used).\n\n    References\n    ----------\n    [Bootstrap Accordion](https://getbootstrap.com/docs/5.2/components/accordion/)\n\n    See Also\n    --------\n    * :func:`~shiny.experimental.ui.accordion`\n    * :func:`~shiny.experimental.ui.accordion_panel`\n    * :func:`~shiny.experimental.ui.accordion_panel_set`\n    * :func:`~shiny.experimental.ui.accordion_panel_open`\n    * :func:`~shiny.experimental.ui.accordion_panel_close`\n    * :func:`~shiny.experimental.ui.accordion_panel_remove`\n    * :func:`~shiny.experimental.ui.update_accordion_panel`\n    \"\"\"\n\n    if position not in (\"after\", \"before\"):\n        raise ValueError(\"`position` must be either 'after' or 'before'\")\n    session = require_active_session(session)\n    _send_panel_message(\n        id,\n        session,\n        method=\"insert\",\n        panel=session._process_ui(panel.resolve()),\n        target=None if target is None else _assert_str(target),\n        position=position,\n    )",
  "def accordion_panel_remove(\n    id: str,\n    target: str | list[str],\n    session: Optional[Session] = None,\n) -> None:\n    \"\"\"\n    Remove an :func:`~shiny.experimental.ui.accordion_panel`\n\n    Parameters\n    ----------\n    id\n        A string that matches an existing :func:`~shiny.experimental.ui.accordion`'s `id`.\n    target\n        The `value` of an existing panel to remove.\n    session\n        A shiny session object (the default should almost always be used).\n\n    References\n    ----------\n    [Bootstrap Accordion](https://getbootstrap.com/docs/5.2/components/accordion/)\n\n    See Also\n    --------\n    * :func:`~shiny.experimental.ui.accordion`\n    * :func:`~shiny.experimental.ui.accordion_panel`\n    * :func:`~shiny.experimental.ui.accordion_panel_set`\n    * :func:`~shiny.experimental.ui.accordion_panel_open`\n    * :func:`~shiny.experimental.ui.accordion_panel_close`\n    * :func:`~shiny.experimental.ui.accordion_panel_insert`\n    * :func:`~shiny.experimental.ui.update_accordion_panel`\n    \"\"\"\n    if not isinstance(target, list):\n        target = [target]\n\n    _send_panel_message(\n        id,\n        session,\n        method=\"remove\",\n        target=_assert_list_str(target),\n    )",
  "def _missing_none_x(x: T | None | MISSING_TYPE) -> T | Literal[\"\"] | None:\n    if isinstance(x, MISSING_TYPE):\n        return None\n    if x is None:\n        return \"\"\n    return x",
  "def update_accordion_panel(\n    id: str,\n    target: str,\n    *body: TagChild,\n    title: TagChild | None | MISSING_TYPE = MISSING,\n    value: str | None | MISSING_TYPE = MISSING,\n    icon: TagChild | None | MISSING_TYPE = MISSING,\n    session: Optional[Session] = None,\n) -> None:\n    \"\"\"\n    Dynamically update accordions panel contents\n\n    Dynamically (i.e., programmatically) update/modify :func:`~shiny.experimental.ui.accordion` panels in a Shiny app.\n    These functions require an `id` to be provided to the :func:`~shiny.experimental.ui.accordion` and must also be\n    called within an active Shiny session.\n\n    Parameters\n    ----------\n    id\n        A string that matches an existing :func:`~shiny.experimental.ui.accordion`'s `id`.\n    target\n        The `value` of an existing panel to update.\n    *body\n        If provided, the new body contents of the panel.\n    title\n        If not missing, the new title of the panel.\n    value\n        If not missing, the new value of the panel.\n    icon\n        If not missing, the new icon of the panel.\n    session\n        A shiny session object (the default should almost always be used).\n\n    References\n    ----------\n    [Bootstrap Accordion](https://getbootstrap.com/docs/5.2/components/accordion/)\n\n    See Also\n    --------\n    * :func:`~shiny.experimental.ui.accordion`\n    * :func:`~shiny.experimental.ui.accordion_panel`\n    * :func:`~shiny.experimental.ui.accordion_panel_set`\n    * :func:`~shiny.experimental.ui.accordion_panel_open`\n    * :func:`~shiny.experimental.ui.accordion_panel_close`\n    * :func:`~shiny.experimental.ui.accordion_panel_insert`\n    * :func:`~shiny.experimental.ui.accordion_panel_remove`\n    \"\"\"\n\n    session = require_active_session(session)\n\n    title = _missing_none_x(title)\n    value = _missing_none_x(value)\n    icon = _missing_none_x(icon)\n    _send_panel_message(\n        id,\n        session,\n        method=\"update\",\n        target=_assert_str(target),\n        value=None if value is None else _assert_str(value),\n        body=None if len(body) == 0 else session._process_ui(body),\n        title=None if title is None else session._process_ui(title),\n        icon=None if icon is None else session._process_ui(icon),\n    )",
  "def _assert_str(x: str) -> str:\n    if not isinstance(x, str):\n        raise TypeError(f\"Expected str, got {type(x)}\")\n    return x",
  "def _assert_list_str(x: list[str]) -> list[str]:\n    if not isinstance(x, list):\n        raise TypeError(f\"Expected list, got {type(x)}\")\n    for i, x_i in enumerate(x):\n        if not isinstance(x_i, str):\n            raise TypeError(f\"Expected str in x[{i}], got {type(x_i)}\")\n    return x",
  "def __init__(\n        self,\n        *args: TagChild | TagAttrs,\n        data_value: str,\n        icon: TagChild | None,\n        title: TagChild | None,\n        id: str | None,\n        **kwargs: TagAttrValue,\n    ):\n        self._args = args\n        self._data_value = data_value\n        self._icon = icon\n        self._title = title\n        self._id = id\n        self._kwargs = kwargs\n        self._is_multiple = False\n        self._is_open = True",
  "def resolve(self) -> Tag:\n        \"\"\"\n        Resolve the :class:`~shiny.experimental.ui.AccordionPanel` into a\n        :class:`~htmltools.Tag`.\n\n        Returns\n        -------\n        :\n            A :class:`~htmltools.Tag` object representing the\n            :class:`~shiny.experimental.ui.AccordionPanel`.\n        \"\"\"\n        btn_attrs = {}\n        if self._is_open:\n            btn_attrs[\"aria-expanded\"] = \"true\"\n        else:\n            btn_attrs[\"class\"] = \"collapsed\"\n            btn_attrs[\"aria-expanded\"] = \"false\"\n\n        if not self._is_multiple:\n            btn_attrs[\"data-bs-parent\"] = f\"#{self._id}\"\n\n        btn = tags.button(\n            {\n                \"class\": \"accordion-button\",\n                \"type\": \"button\",\n                \"data-bs-toggle\": \"collapse\",\n                \"data-bs-target\": f\"#{self._id}\",\n                \"aria-controls\": self._id,\n            },\n            btn_attrs,\n            # Always include an .accordion-icon container to simplify update_accordion_panel() logic\n            tags.div({\"class\": \"accordion-icon\"}, self._icon),\n            tags.div({\"class\": \"accordion-title\"}, self._title),\n        )\n\n        attrs, children = consolidate_attrs(*self._args, **self._kwargs)\n\n        return tags.div(\n            {\n                \"class\": \"accordion-item\",\n                \"data-value\": self._data_value,\n            },\n            # Use a <span.h2> instead of <h2> so that it doesn't get included in rmd/pkgdown/qmd TOC\n            # TODO-bslib: can we provide a way to put more stuff in the header? Like maybe some right-aligned controls?\n            tags.span(\n                {\"class\": \"accordion-header h2\"},\n                btn,\n            ),\n            tags.div(\n                {\n                    \"id\": self._id,\n                    \"class\": \"accordion-collapse collapse\",\n                },\n                {\"class\": \"show\"} if self._is_open else None,\n                tags.div(\n                    {\"class\": \"accordion-body\"},\n                    attrs,\n                    children,\n                ),\n            ),\n        )",
  "def tagify(self) -> Tag:\n        \"\"\"\n        Resolve the :class:`~shiny.experimental.ui.AccordionPanel` into a\n        :class:`~htmltools.Tag`.\n\n        Returns\n        -------\n        :\n            A tagified `resolve()`d value.\n        \"\"\"\n        return self.resolve().tagify()",
  "def _htmltools_dep(\n    name: str,\n    script: bool = False,\n    stylesheet: bool = False,\n    all_files: bool = True,\n) -> HTMLDependency:\n    return HTMLDependency(\n        name=f\"htmltools-{name}\",\n        version=htmltools_version,\n        source={\n            \"package\": \"shiny\",\n            \"subdir\": str(_x_htmltools_path / \"fill\"),\n        },\n        script={\"src\": f\"{name}.min.js\"} if script else None,\n        stylesheet={\"href\": f\"{name}.css\"} if stylesheet else None,\n        all_files=all_files,\n    )",
  "class _ScriptItemDict(TypedDict):\n    src: str\n    type: NotRequired[Literal[\"module\"]]",
  "def _bslib_component_dep(\n    name: str,\n    script: bool = False,\n    stylesheet: bool = False,\n    all_files: bool = True,\n    script_is_module: bool = False,\n) -> HTMLDependency:\n    script_val: _ScriptItemDict | None = None\n    if script:\n        script_val = {\"src\": f\"{name}.min.js\"}\n        if script_is_module:\n            script_val[\"type\"] = \"module\"\n\n    return HTMLDependency(\n        name=f\"bslib-{name}\",\n        version=bslib_version,\n        source={\n            \"package\": \"shiny\",\n            \"subdir\": str(_x_components_path / name),\n        },\n        script=script_val,  # type: ignore # https://github.com/posit-dev/py-htmltools/issues/59\n        stylesheet={\"href\": f\"{name}.css\"} if stylesheet else None,\n        all_files=all_files,\n    )",
  "def fill_dependency() -> HTMLDependency:\n    return _htmltools_dep(\"fill\", stylesheet=True)",
  "def accordion_dependency() -> HTMLDependency:\n    return _bslib_component_dep(\"accordion\", script=True, stylesheet=True)",
  "def card_dependency() -> HTMLDependency:\n    return _bslib_component_dep(\"card\", script=True, stylesheet=True)",
  "def grid_dependency() -> HTMLDependency:\n    return _bslib_component_dep(\"grid\", stylesheet=True)",
  "def page_fillable_dependency() -> HTMLDependency:\n    return _bslib_component_dep(\"page_fillable\", stylesheet=True)",
  "def page_sidebar_dependency() -> HTMLDependency:\n    return _bslib_component_dep(\"page_sidebar\", stylesheet=True)",
  "def sidebar_dependency() -> HTMLDependency:\n    return _bslib_component_dep(\"sidebar\", script=True, stylesheet=True)",
  "def value_box_dependency() -> HTMLDependency:\n    return _bslib_component_dep(\"value_box\", stylesheet=True)",
  "def web_component_dependency() -> HTMLDependency:\n    return _bslib_component_dep(\"webComponents\", script=True, script_is_module=True)",
  "def autoresize_dependency():\n    return HTMLDependency(\n        \"shiny-textarea-autoresize\",\n        shiny_version,\n        source={\"package\": \"shiny\", \"subdir\": _x_www_path},\n        script={\"src\": \"textarea-autoresize.js\"},\n        stylesheet={\"href\": \"textarea-autoresize.css\"},\n    )",
  "class Sidebar:\n    \"\"\"\n    Sidebar object\n\n    Class returned from :func:`~shiny.experimental.ui.sidebar`. Please do not use this\n    class directly. Instead, supply the :func:`~shiny.experimental.ui.sidebar` object to\n    :func:`~shiny.experimental.ui.layout_sidebar`.\n\n    Attributes\n    ----------\n    tag\n        The :class:`~htmltools.Tag` object that represents the sidebar.\n    collapse_tag\n        The :class:`~htmltools.Tag` object that represents the collapse button.\n    position\n        Where the sidebar should appear relative to the main content.\n    open\n        The initial state of the sidebar.\n    width\n        A valid CSS unit used for the width of the sidebar.\n    max_height_mobile\n        The maximum height of the horizontal sidebar when viewed on mobile devices.\n        The default is `250px` unless the sidebar is included in a\n        :func:`~shiny.experimental.ui.layout_sidebar` with a specified height, in\n        which case the default is to take up no more than 50% of the layout container.\n    color_fg\n        A foreground color.\n    color_bg\n        A background color.\n\n    Parameters\n    ----------\n    tag\n        The :class:`~htmltools.Tag` object that represents the sidebar.\n    collapse_tag\n        The :class:`~htmltools.Tag` object that represents the collapse button.\n    position\n        Where the sidebar should appear relative to the main content.\n    open\n        The initial state of the sidebar.\n    width\n        A valid CSS unit used for the width of the sidebar.\n    max_height_mobile\n        The maximum height of the horizontal sidebar when viewed on mobile devices.\n        The default is `250px` unless the sidebar is included in a\n        :func:`~shiny.experimental.ui.layout_sidebar` with a specified height, in\n        which case the default is to take up no more than 50% of the layout container.\n    color_fg\n        A foreground color.\n    color_bg\n        A background color.\n\n\n    \"\"\"\n\n    def __init__(\n        self,\n        tag: Tag,\n        collapse_tag: Optional[Tag],\n        position: Literal[\"left\", \"right\"],\n        open: Literal[\"desktop\", \"open\", \"closed\", \"always\"],\n        width: CssUnit,\n        max_height_mobile: Optional[str | float],\n        color_fg: Optional[str],\n        color_bg: Optional[str],\n    ):\n        self.tag = tag\n        self.collapse_tag = collapse_tag\n        self.position = position\n        self.open = open\n        self.width = width\n        self.max_height_mobile = max_height_mobile\n        self.color_fg = color_fg\n        self.color_bg = color_bg\n\n    # The `Sidebar` class should use it's fields, not this method\n    def tagify(self) -> Tag:\n        \"\"\"\n        Not implemented\n        \"\"\"\n        # Similar to `NavMenu.tagify()`\n        raise NotImplementedError(\n            \"`Sidebar` objects must be handled by `layout_sidebar(sidebar)`.\"\n        )",
  "def sidebar(\n    *args: TagChild | TagAttrs,\n    width: CssUnit = 250,\n    position: Literal[\"left\", \"right\"] = \"left\",\n    open: Literal[\"desktop\", \"open\", \"closed\", \"always\"] = \"desktop\",\n    id: Optional[str] = None,\n    title: TagChild | str = None,\n    bg: Optional[str] = None,\n    fg: Optional[str] = None,\n    class_: Optional[str] = None,  # TODO-future; Consider using `**kwargs` instead\n    max_height_mobile: Optional[str | float] = None,\n    gap: Optional[CssUnit] = None,\n    padding: Optional[CssUnit | list[CssUnit]] = None,\n) -> Sidebar:\n    # See [this article](https://rstudio.github.io/bslib/articles/sidebars.html)\n    #   to learn more.\n    # TODO-future; If color contrast is implemented. Docs for `bg` and `fg`:\n    #     If only one of either is provided, an\n    #     accessible contrasting color is provided for the opposite color, e.g. setting\n    #     `bg` chooses an appropriate `fg` color.\n\n    \"\"\"\n    Sidebar element\n\n    Create a collapsing sidebar layout by providing a `sidebar()` object to the\n    `sidebar=` argument of:\n\n    * :func:`~shiny.experimental.ui.layout_sidebar`\n      * Creates a sidebar layout component which can be dropped inside any Shiny UI page method (e.g. :func:`~shiny.experimental.ui.page_fillable`) or :func:`~shiny.experimental.ui.card` context.\n    * :func:`~shiny.experimental.ui.navset_bar`, :func:`~shiny.experimental.ui.navset_card_tab`, and :func:`~shiny.experimental.ui.navset_card_pill`\n      * Creates a multi page/tab UI with a singular `sidebar()` (which is\n        shown on every page/tab).\n\n    Parameters\n    ----------\n    *args\n        Contents to the sidebar. Or tag attributes that are supplied to the\n        resolved :class:`~htmltools.Tag` object.\n    width\n        A valid CSS unit used for the width of the sidebar.\n    position\n        Where the sidebar should appear relative to the main content.\n    open\n        The initial state of the sidebar. It can be `\"desktop\"` (the sidebar starts open\n        on desktop screen, closed on mobile), `\"open\"` or `True` (the sidebar starts\n        open), `\"closed\"` or `False` (the sidebar starts closed), or `\"always\"` or\n        `None` (the sidebar is always open and cannot be closed).\n\n        In :func:`~shiny.experimental.ui.toggle_sidebar`, `open` indicates the desired\n        state of the sidebar, where the default of `open = None` will cause the sidebar\n        to be toggled open if closed or vice versa. Note that\n        :func:`~shiny.experimental.ui.toggle_sidebar` can only open or close the\n        sidebar, so it does not support the `\"desktop\"` and `\"always\"` options.\n    id\n        A character string. Required if wanting to re-actively read (or update) the\n        `collapsible` state in a Shiny app.\n    title\n        A character title to be used as the sidebar title, which will be wrapped in a\n        `<div>` element with class `sidebar-title`. You can also provide a custom\n        :class:`~htmltools.Tag` for the title element, in which case you'll\n        likely want to give this element `class = \"sidebar-title\"`.\n    bg,fg\n        A background or foreground color.\n    class_\n        CSS classes for the sidebar container element, in addition to the fixed\n        `.sidebar` class.\n    max_height_mobile\n        The maximum height of the horizontal sidebar when viewed on mobile devices.\n        The default is `250px` unless the sidebar is included in a\n        :func:`~shiny.experimental.ui.layout_sidebar` with a specified height, in\n        which case the default is to take up no more than 50% of the layout container.\n    gap\n        A CSS length unit defining the vertical `gap` (i.e., spacing) between elements\n        provided to `*args`.\n    padding\n        Padding within the sidebar itself. This can be a numeric vector (which will be\n        interpreted as pixels) or a character vector with valid CSS lengths. `padding`\n        may be one to four values. If one, then that value will be used for all four\n        sides. If two, then the first value will be used for the top and bottom, while\n        the second value will be used for left and right. If three, then the first will\n        be used for top, the second will be left and right, and the third will be\n        bottom. If four, then the values will be interpreted as top, right, bottom, and\n        left respectively.\n\n    Returns\n    -------\n    :\n        A :class:`~shiny.experimental.ui.Sidebar` object.\n\n    See Also\n    --------\n    * :func:`~shiny.experimental.ui.layout_sidebar`\n    * :func:`~shiny.experimental.ui.navset_bar`\n    * :func:`~shiny.experimental.ui.navset_card_tab`\n    * :func:`~shiny.experimental.ui.navset_card_pill`\n    \"\"\"\n    # TODO-future; validate `open`, bg, fg, class_, max_height_mobile\n\n    if id is None and open != \"always\":\n        # but always provide id when collapsible for accessibility reasons\n        id = f\"bslib_sidebar_{random.randint(1000, 10000)}\"\n    resolved_id = resolve_id_or_none(id)\n\n    # TODO-future; implement\n    # if fg is None and bg is not None:\n    #     fg = get_color_contrast(bg)\n    # if bg is None and fg is not None:\n    #     bg = get_color_contrast(fg)\n\n    if isinstance(title, (str, int, float)):\n        title = div(str(title), class_=\"sidebar-title\")\n\n    collapse_tag = None\n    if open != \"always\":\n        collapse_tag = tags.button(\n            _collapse_icon(),\n            class_=\"collapse-toggle\",\n            type=\"button\",\n            title=\"Toggle sidebar\",\n            aria_expanded=trinary(open in [\"open\", \"desktop\"]),\n            aria_controls=resolved_id,\n        )\n\n    tag = div(\n        div(\n            title,\n            {\n                \"class\": \"sidebar-content bslib-gap-spacing\",\n                \"style\": css(\n                    gap=as_css_unit(gap),\n                    padding=as_css_padding(padding),\n                ),\n            },\n            *args,\n        ),\n        {\"class\": \"bslib-sidebar-input\"} if resolved_id is not None else None,\n        {\"class\": \"sidebar\"},\n        id=resolved_id,\n        role=\"complementary\",\n        class_=class_,\n    )\n\n    return Sidebar(\n        tag=tag,\n        collapse_tag=collapse_tag,\n        position=position,\n        open=open,\n        width=width,\n        max_height_mobile=max_height_mobile,\n        color_fg=fg,\n        color_bg=bg,\n    )",
  "def layout_sidebar(\n    sidebar: Sidebar | TagChild | TagAttrs,\n    *args: TagChild | TagAttrs,\n    fillable: bool = True,\n    fill: bool = True,\n    bg: Optional[str] = None,\n    fg: Optional[str] = None,\n    border: Optional[bool] = None,\n    border_radius: Optional[bool] = None,\n    border_color: Optional[str] = None,\n    gap: Optional[CssUnit] = None,\n    padding: Optional[CssUnit | list[CssUnit]] = None,\n    height: Optional[CssUnit] = None,\n    **kwargs: TagAttrValue,\n) -> CardItem:\n    \"\"\"\n    Sidebar layout\n\n    Create a sidebar layout component which can be dropped inside any Shiny UI page\n    method (e.g. :func:`~shiny.experimental.ui.page_fillable`) or\n    :func:`~shiny.experimental.ui.card` context.\n\n    Parameters\n    ----------\n    sidebar\n        A :class:`~shiny.experimental.ui.Sidebar` object created by :func:`~shiny.experimental.ui.sidebar`.\n    *args\n        Contents to the main content area. Or tag attributes that are supplied to the\n        resolved :class:`~htmltools.Tag` object.\n    fillable\n        Whether or not the main content area should be wrapped in a fillable container.\n        See :func:`~shiny.experimental.ui.as_fillable_container` for details.\n    fill\n        Whether or not the sidebar layout should be wrapped in a fillable container. See\n        :func:`~shiny.experimental.ui.as_fill_item` for details.\n    bg,fg\n        A background or foreground color.\n    border\n        Whether or not to show a border around the sidebar layout.\n    border_radius\n        Whether or not to round the corners of the sidebar layout.\n    border_color\n        A border color.\n    gap\n        A CSS length unit defining the vertical `gap` (i.e., spacing) between elements\n        provided to `*args`. This value will only be used if `fillable` is `True`.\n    padding\n        Padding within the sidebar itself. This can be a numeric vector (which will be\n        interpreted as pixels) or a character vector with valid CSS lengths. `padding`\n        may be one to four values. If one, then that value will be used for all four\n        sides. If two, then the first value will be used for the top and bottom, while\n        the second value will be used for left and right. If three, then the first will\n        be used for top, the second will be left and right, and the third will be\n        bottom. If four, then the values will be interpreted as top, right, bottom, and\n        left respectively.\n    height\n        Any valid CSS unit to use for the height.\n\n    Returns\n    -------\n    :\n        A :class:`~htmltools.Tag` object.\n\n    See Also\n    --------\n    * :func:`~shiny.experimental.ui.sidebar`\n    \"\"\"\n    updated_args = list(args)\n    has_upgraded: bool = False\n    # Use `args` here so `updated_args` can be safely altered in place\n    for arg in args:\n        if isinstance(arg, Sidebar):\n            raise TypeError(\n                \"Please use the `sidebar=` argument to supply a `sidebar()`\"\n            )\n        # TODO-future: >= 2023-11-01); Once `panel_sidebar()` is removed, we can remove this loop\n        if isinstance(arg, DeprecatedPanelSidebar):\n            if has_upgraded:\n                raise TypeError(\n                    \"Multiple `panel_sidebar()` calls detected. Please use the `sidebar=` argument and supply a `sidebar()`\"\n                )\n            if sidebar is not None:\n                raise TypeError(\n                    \"A `panel_sidebar()` was supplied along with a `sidebar=` value. Please use only `sidebar=` to supply a `sidebar()`.\"\n                )\n            sidebar = arg.sidebar\n            updated_args.remove(arg)\n            has_upgraded = True\n\n    if not isinstance(sidebar, Sidebar):\n        sidebar = _sidebar_func(sidebar)\n\n    # TODO-future; implement\n    # if fg is None and bg is not None:\n    #     fg = get_color_contrast(bg)\n    # if bg is None and fg is not None:\n    #     bg = get_color_contrast(fg)\n\n    attrs, children = consolidate_attrs(*updated_args, **kwargs)\n    # TODO-future: >= 2023-11-01); Once `panel_main()` is removed, we can remove this loop\n    for child in children:\n        if isinstance(child, DeprecatedPanelMain):\n            attrs = consolidate_attrs(attrs, child.attrs)[0]\n            # child.children will be handled when tagified\n\n    main = div(\n        {\n            \"role\": \"main\",\n            \"class\": f\"main{' bslib-gap-spacing' if fillable else ''}\",\n            \"\"\n            \"style\": css(\n                background_color=bg,\n                color=fg,\n                gap=as_css_unit(gap),\n                padding=as_css_padding(padding),\n            ),\n        },\n        attrs,\n        *children,\n    )\n    if fillable:\n        main = as_fillable_container(main)\n\n    max_height_mobile = sidebar.max_height_mobile or (\n        \"250px\" if height is None else \"50%\"\n    )\n\n    res = div(\n        {\"class\": \"bslib-sidebar-layout bslib-mb-spacing\"},\n        {\"class\": \"sidebar-right\"} if sidebar.position == \"right\" else None,\n        {\"class\": \"sidebar-collapsed\"} if sidebar.open == \"closed\" else None,\n        main,\n        sidebar.tag,\n        sidebar.collapse_tag,\n        sidebar_dependency(),\n        _sidebar_init_js(),\n        data_bslib_sidebar_init=\"true\" if sidebar.open != \"always\" else None,\n        data_bslib_sidebar_open=sidebar.open,\n        data_bslib_sidebar_border=trinary(border),\n        data_bslib_sidebar_border_radius=trinary(border_radius),\n        style=css(\n            __bslib_sidebar_width=as_css_unit(sidebar.width),\n            __bslib_sidebar_bg=as_css_unit(sidebar.color_bg),\n            __bslib_sidebar_fg=as_css_unit(sidebar.color_fg),\n            __bs_card_border_color=border_color,\n            height=as_css_unit(height),\n            __bslib_sidebar_max_height_mobile=as_css_unit(max_height_mobile),\n        ),\n    )\n    if fill:\n        res = as_fill_item(res)\n\n    return CardItem(res)",
  "def toggle_sidebar(\n    id: str,\n    open: Literal[\"toggle\", \"open\", \"closed\", \"always\"] | bool | None = None,\n    session: Session | None = None,\n) -> None:\n    \"\"\"\n    Toggle a sidebar\n\n    Toggle a :func:`~shiny.experimental.ui.sidebar` state during an active Shiny user session.\n\n    Parameters\n    ----------\n    id\n        The `id` of the :func:`~shiny.experimental.ui.sidebar` to toggle.\n    open\n        The desired state of the sidebar, choosing from the following options: `None`\n        (toggle sidebar open and closed), `\"open\"` or `True` (open the sidebar),\n        `\"closed\"` or `False` (close the sidebar). Note that `toggle_sidebar()` can only\n        open or close the sidebar, so it does not support the `\"desktop\"` and `\"always\"`\n    session\n        A Shiny session object (the default should almost always be used).\n\n    See Also\n    --------\n    * :func:`~shiny.experimental.ui.sidebar`\n    * :func:`~shiny.experimental.ui.layout_sidebar`\n    \"\"\"\n    session = require_active_session(session)\n\n    method: Literal[\"toggle\", \"open\", \"close\"]\n    if open is None or open == \"toggle\":\n        method = \"toggle\"\n    elif open is True or open == \"open\":\n        method = \"open\"\n    elif open is False or open == \"closed\":\n        method = \"close\"\n    else:\n        if open == \"always\" or open == \"desktop\":\n            raise ValueError(\n                f\"`open = '{open}'` is not supported by `toggle_sidebar()`\"\n            )\n        raise ValueError(\n            \"open must be NULL (or 'toggle'), TRUE (or 'open'), or FALSE (or 'closed')\"\n        )\n\n    def callback() -> None:\n        session.send_input_message(id, {\"method\": method})\n\n    session.on_flush(callback, once=True)",
  "def _collapse_icon() -> Tag:\n    return tags.svg(\n        svgtags.path(\n            fill_rule=\"evenodd\",\n            d=\"M1.646 4.646a.5.5 0 0 1 .708 0L8 10.293l5.646-5.647a.5.5 0 0 1 .708.708l-6 6a.5.5 0 0 1-.708 0l-6-6a.5.5 0 0 1 0-.708z\",\n        ),\n        xmlns=\"http://www.w3.org/2000/svg\",\n        viewBox=\"0 0 16 16\",\n        class_=\"bi bi-chevron-down collapse-icon\",\n        style=\"fill:currentColor;\",\n        aria_hidden=\"true\",\n        role=\"img\",\n    )",
  "def _sidebar_init_js() -> Tag:\n    # Note: if we want to avoid inline `<script>` tags in the future for\n    # initialization code, we might be able to do so by turning the sidebar layout\n    # container into a web component\n    return tags.script(\n        {\"data-bslib-sidebar-init\": True},\n        \"bslib.Sidebar.initCollapsibleAll()\",\n    )",
  "def panel_sidebar(\n    *args: TagChild | TagAttrs,\n    width: int = 4,\n    **kwargs: TagAttrValue,\n) -> DeprecatedPanelSidebar:\n    \"\"\"Deprecated. Please use :func:`~shiny.experimental.ui.sidebar` instead of\n    `ui.panel_sidebar()`.\"\"\"\n    # TODO-future: >= 2023-11-01; Add deprecation message below\n    # Plan of action:\n    # * No deprecation messages today (2023-05-18), and existing code _just works_.\n    # * Change all examples to use the new API.\n    # * In, say, 6 months, start emitting messages for code that uses the old API.\n\n    # warn_deprecated(\"Please use `sidebar()` instead of `panel_sidebar()`. `panel_sidebar()` will go away in a future version of Shiny.\")\n    return DeprecatedPanelSidebar(\n        *args,\n        width=width,\n        **kwargs,\n    )",
  "class DeprecatedPanelSidebar:\n    \"\"\"\n    [Deprecated] Sidebar panel\n\n    Class returned from :func:`~shiny.experimental.ui.panel_sidebar`. Please do not\n    use this class and instead supply your content to\n    :func:`~shiny.experimental.ui.layout_sidebar` directly.\n\n    Parameters\n    ----------\n    *args\n        Contents to the sidebar. Or tag attributes that are supplied to the resolved\n        :class:`~htmltools.Tag` object.\n    width\n        An integeger between 1 and 12, inclusive, that determines the width of the\n        sidebar. The default is 4.\n    **kwargs\n        Tag attributes that are supplied to the resolved :class:`~htmltools.Tag` object.\n\n    Attributes\n    ----------\n    sidebar\n        A output from :func:`~shiny.experimental.ui.sidebar`.\n\n    See Also\n    --------\n    * :func:`~shiny.experimental.ui.layout_sidebar`\n    * :func:`~shiny.experimental.ui.sidebar`\n    \"\"\"\n\n    # Store `attrs` for `layout_sidebar()` to retrieve\n    sidebar: Sidebar\n\n    def __init__(\n        self, *args: TagChild | TagAttrs, width: int = 4, **kwargs: TagAttrValue\n    ) -> None:\n        self.sidebar = sidebar(\n            *args,\n            width=f\"{int(width / 12 * 100)}%\",\n            **kwargs,\n        )\n\n    # Hopefully this is never used. But wanted to try to be safe\n    def tagify(self) -> Tag:\n        \"\"\"\n        Tagify the `self.sidebar.tag` and return the result in a TagList\n        \"\"\"\n        return self.sidebar.tag.tagify()",
  "def panel_main(\n    *args: TagChild | TagAttrs,\n    width: int = 8,\n    **kwargs: TagAttrValue,\n) -> TagList | DeprecatedPanelMain:\n    \"\"\"Deprecated. Please supply `panel_main(*args)` directly to `layout_sidebar()`.\"\"\"\n    # TODO-future: >= 2023-11-01; Add deprecation message below\n    # warn_deprecated(\n    #     \"Please supply `panel_main(*args)` directly to `layout_sidebar()`.\"\n    # )\n    # warn if keys are being ignored\n    attrs, children = consolidate_attrs(*args, **kwargs)\n    if len(attrs) > 0:\n        return DeprecatedPanelMain(attrs=attrs, children=children)\n        warn_deprecated(\n            \"`*args: TagAttrs` or `**kwargs: TagAttrValue` values supplied to `panel_main()` are being ignored. Please supply them directly to `layout_sidebar()`.\"\n        )\n\n    return TagList(*children)",
  "class DeprecatedPanelMain:\n    \"\"\"\n    [Deprecated] Main panel\n\n    Class returned from :func:`~shiny.experimental.ui.panel_main`. Please do not use\n    this class and instead supply your content to\n    :func:`~shiny.experimental.ui.layout_sidebar` directly.\n\n\n    Parameters\n    ----------\n    attrs\n        Attributes to apply to the parent tag of the children.\n    children\n        Children UI Elements to render inside the parent tag.\n\n    Attributes\n    ----------\n    attrs\n        Attributes to apply to the parent tag of the children.\n    children\n        Children UI Elements to render inside the parent tag.\n\n    See Also\n    --------\n    * :func:`~shiny.experimental.ui.layout_sidebar`\n    * :func:`~shiny.experimental.ui.sidebar`\n    \"\"\"\n\n    # Store `attrs` for `layout_sidebar()` to retrieve\n    attrs: TagAttrs\n    # Return `children` in `layout_sidebar()` via `.tagify()` method\n    children: list[TagChild]\n\n    def __init__(self, *, attrs: TagAttrs, children: list[TagChild]) -> None:\n        self.attrs = attrs\n        self.children = children\n\n    def tagify(self) -> TagList:\n        \"\"\"\n        Tagify the `children` and return the result in a TagList\n        \"\"\"\n        return TagList(self.children).tagify()",
  "def __init__(\n        self,\n        tag: Tag,\n        collapse_tag: Optional[Tag],\n        position: Literal[\"left\", \"right\"],\n        open: Literal[\"desktop\", \"open\", \"closed\", \"always\"],\n        width: CssUnit,\n        max_height_mobile: Optional[str | float],\n        color_fg: Optional[str],\n        color_bg: Optional[str],\n    ):\n        self.tag = tag\n        self.collapse_tag = collapse_tag\n        self.position = position\n        self.open = open\n        self.width = width\n        self.max_height_mobile = max_height_mobile\n        self.color_fg = color_fg\n        self.color_bg = color_bg",
  "def tagify(self) -> Tag:\n        \"\"\"\n        Not implemented\n        \"\"\"\n        # Similar to `NavMenu.tagify()`\n        raise NotImplementedError(\n            \"`Sidebar` objects must be handled by `layout_sidebar(sidebar)`.\"\n        )",
  "def callback() -> None:\n        session.send_input_message(id, {\"method\": method})",
  "def __init__(\n        self, *args: TagChild | TagAttrs, width: int = 4, **kwargs: TagAttrValue\n    ) -> None:\n        self.sidebar = sidebar(\n            *args,\n            width=f\"{int(width / 12 * 100)}%\",\n            **kwargs,\n        )",
  "def tagify(self) -> Tag:\n        \"\"\"\n        Tagify the `self.sidebar.tag` and return the result in a TagList\n        \"\"\"\n        return self.sidebar.tag.tagify()",
  "def __init__(self, *, attrs: TagAttrs, children: list[TagChild]) -> None:\n        self.attrs = attrs\n        self.children = children",
  "def tagify(self) -> TagList:\n        \"\"\"\n        Tagify the `children` and return the result in a TagList\n        \"\"\"\n        return TagList(self.children).tagify()",
  "def server(input: Inputs, output: Outputs, session: Session) -> None:\n    @output\n    @render.ui\n    def ui_content():\n        return f\"Hello, {input.adjective()} {input.animal()}!\"\n\n    @reactive.Effect\n    @reactive.event(input.open_all)\n    def _():\n        x.ui.toggle_sidebar(\"sidebar_inner\", open=True)\n        x.ui.toggle_sidebar(\"sidebar_outer\", open=True)\n\n    @reactive.Effect\n    @reactive.event(input.close_all)\n    def _():\n        x.ui.toggle_sidebar(\"sidebar_inner\", open=False)\n        x.ui.toggle_sidebar(\"sidebar_outer\", open=False)\n\n    @reactive.Effect\n    @reactive.event(input.toggle_inner)\n    def _():\n        x.ui.toggle_sidebar(\"sidebar_inner\")\n\n    @reactive.Effect\n    @reactive.event(input.toggle_outer)\n    def _():\n        x.ui.toggle_sidebar(\"sidebar_outer\")",
  "def ui_content():\n        return f\"Hello, {input.adjective()} {input.animal()}!\"",
  "def _():\n        x.ui.toggle_sidebar(\"sidebar_inner\", open=True)\n        x.ui.toggle_sidebar(\"sidebar_outer\", open=True)",
  "def _():\n        x.ui.toggle_sidebar(\"sidebar_inner\", open=False)\n        x.ui.toggle_sidebar(\"sidebar_outer\", open=False)",
  "def _():\n        x.ui.toggle_sidebar(\"sidebar_inner\")",
  "def _():\n        x.ui.toggle_sidebar(\"sidebar_outer\")",
  "def nav_with_content(letter: str, prefix: str) -> ui._navs.Nav:\n    return ui.nav(letter, ui.markdown(f\"`{prefix}`: tab {letter} content\"))",
  "def nav_items(prefix: str) -> list[NavSetArg]:\n    a = nav_with_content(\"a\", prefix)\n    b = nav_with_content(\"b\", prefix)\n    github = ui.nav_control(\n        ui.tags.a(\n            # ui.icon(\"github\"),\n            \"Shiny\",\n            href=\"https://github.com/rstudio/shiny\",\n            target=\"_blank\",\n        ),\n    )\n    space = ui.nav_spacer()\n    other = ui.nav_menu(\n        \"Other links\",\n        nav_with_content(\"c\", prefix),\n        ui.nav_control(\n            ui.tags.a(\n                # icon(\"r-project\"),\n                \"RStudio\",\n                href=\"https://rstudio.com\",\n                target=\"_blank\",\n            ),\n        ),\n        align=\"right\",\n    )\n    return [a, b, github, space, other]",
  "async def TextTransformer(\n    _meta: TransformerMetadata,\n    _fn: ValueFn[str | None],\n) -> str | None:\n    value = await resolve_value_fn(_fn)\n    if value is None:\n        return None\n    return str(value)",
  "def text() -> TextTransformer.OutputRendererDecorator:\n    ...",
  "def text(_fn: TextTransformer.ValueFn) -> TextTransformer.OutputRenderer:\n    ...",
  "def text(\n    _fn: TextTransformer.ValueFn | None = None,\n) -> TextTransformer.OutputRenderer | TextTransformer.OutputRendererDecorator:\n    \"\"\"\n    Reactively render text.\n\n    Returns\n    -------\n    :\n        A decorator for a function that returns a string.\n\n    Tip\n    ----\n    This decorator should be applied **before** the ``@output`` decorator. Also, the\n    name of the decorated function (or ``@output(id=...)``) should match the ``id`` of\n    a :func:`~shiny.ui.output_text` container (see :func:`~shiny.ui.output_text` for\n    example usage).\n\n    See Also\n    --------\n    ~shiny.ui.output_text\n    \"\"\"\n    return TextTransformer(_fn)",
  "async def PlotTransformer(\n    _meta: TransformerMetadata,\n    _fn: ValueFn[object],\n    *,\n    alt: Optional[str] = None,\n    **kwargs: object,\n) -> ImgData | None:\n    is_userfn_async = is_async_callable(_fn)\n    name = _meta.name\n    session = _meta.session\n\n    ppi: float = 96\n\n    inputs = session.root_scope().input\n\n    # Reactively read some information about the plot.\n    pixelratio: float = typing.cast(\n        float, inputs[ResolvedId(\".clientdata_pixelratio\")]()\n    )\n    width: float = typing.cast(\n        float, inputs[ResolvedId(f\".clientdata_output_{name}_width\")]()\n    )\n    height: float = typing.cast(\n        float, inputs[ResolvedId(f\".clientdata_output_{name}_height\")]()\n    )\n\n    # Call the user function to get the plot object.\n    x = await resolve_value_fn(_fn)\n\n    # Note that x might be None; it could be a matplotlib.pyplot\n\n    # Try each type of renderer in turn. The reason we do it this way is to avoid\n    # importing modules that aren't already loaded. That could slow things down, or\n    # worse, cause an error if the module isn't installed.\n    #\n    # Each try_render function should indicate whether it was able to make sense of\n    # the x value (or, in the case of matplotlib, possibly it decided to use the\n    # global pyplot figure) by returning a tuple that starts with True. The second\n    # tuple element may be None in this case, which means the try_render function\n    # explicitly wants the plot to be blanked.\n    #\n    # If a try_render function returns a tuple that starts with False, then the next\n    # try_render function should be tried. If none succeed, an error is raised.\n    ok: bool\n    result: ImgData | None\n\n    if \"plotnine\" in sys.modules:\n        ok, result = try_render_plotnine(\n            x,\n            width,\n            height,\n            pixelratio,\n            ppi,\n            alt,\n            **kwargs,\n        )\n        if ok:\n            return result\n\n    if \"matplotlib\" in sys.modules:\n        ok, result = try_render_matplotlib(\n            x,\n            width,\n            height,\n            pixelratio=pixelratio,\n            ppi=ppi,\n            allow_global=not is_userfn_async,\n            alt=alt,\n            **kwargs,\n        )\n        if ok:\n            return result\n\n    if \"PIL\" in sys.modules:\n        ok, result = try_render_pil(\n            x,\n            width,\n            height,\n            pixelratio,\n            ppi,\n            alt,\n            **kwargs,\n        )\n        if ok:\n            return result\n\n    # This check must happen last because\n    # matplotlib might be able to plot even if x is `None`\n    if x is None:\n        return None\n\n    raise Exception(\n        f\"@render.plot doesn't know to render objects of type '{str(type(x))}'. \"\n        + \"Consider either requesting support for this type of plot object, and/or \"\n        + \" explictly saving the object to a (png) file and using @render.image.\"\n    )",
  "def plot(\n    *,\n    alt: Optional[str] = None,\n    **kwargs: Any,\n) -> PlotTransformer.OutputRendererDecorator:\n    ...",
  "def plot(_fn: PlotTransformer.ValueFn) -> PlotTransformer.OutputRenderer:\n    ...",
  "def plot(\n    _fn: PlotTransformer.ValueFn | None = None,\n    *,\n    alt: Optional[str] = None,\n    **kwargs: Any,\n) -> PlotTransformer.OutputRenderer | PlotTransformer.OutputRendererDecorator:\n    \"\"\"\n    Reactively render a plot object as an HTML image.\n\n    Parameters\n    ----------\n    alt\n        Alternative text for the image if it cannot be displayed or viewed (i.e., the\n        user uses a screen reader).\n    **kwargs\n        Additional keyword arguments passed to the relevant method for saving the image\n        (e.g., for matplotlib, arguments to ``savefig()``; for PIL and plotnine,\n        arguments to ``save()``).\n\n    Returns\n    -------\n    :\n        A decorator for a function that returns any of the following:\n\n        1. A :class:`matplotlib.figure.Figure` instance.\n        2. An :class:`matplotlib.artist.Artist` instance.\n        3. A list/tuple of Figure/Artist instances.\n        4. An object with a 'figure' attribute pointing to a\n           :class:`matplotlib.figure.Figure` instance.\n        5. A :class:`PIL.Image.Image` instance.\n\n    It's also possible to use the ``matplotlib.pyplot`` interface; in that case, your\n    function should just call pyplot functions and not return anything. (Note that if\n    the decorated function is async, then it's not safe to use pyplot. Shiny will detect\n    this case and throw an error asking you to use matplotlib's object-oriented\n    interface instead.)\n\n    Tip\n    ----\n    This decorator should be applied **before** the ``@output`` decorator. Also, the\n    name of the decorated function (or ``@output(id=...)``) should match the ``id`` of a\n    :func:`~shiny.ui.output_plot` container (see :func:`~shiny.ui.output_plot` for\n    example usage).\n\n    See Also\n    --------\n    ~shiny.ui.output_plot\n    ~shiny.render.image\n    \"\"\"\n    return PlotTransformer(_fn, PlotTransformer.params(alt=alt, **kwargs))",
  "async def ImageTransformer(\n    _meta: TransformerMetadata,\n    _fn: ValueFn[ImgData | None],\n    *,\n    delete_file: bool = False,\n) -> ImgData | None:\n    res = await resolve_value_fn(_fn)\n    if res is None:\n        return None\n\n    src: str = res.get(\"src\")\n    try:\n        with open(src, \"rb\") as f:\n            data = base64.b64encode(f.read())\n            data_str = data.decode(\"utf-8\")\n        content_type = _utils.guess_mime_type(src)\n        res[\"src\"] = f\"data:{content_type};base64,{data_str}\"\n        return res\n    finally:\n        if delete_file:\n            os.remove(src)",
  "def image(\n    *,\n    delete_file: bool = False,\n) -> ImageTransformer.OutputRendererDecorator:\n    ...",
  "def image(_fn: ImageTransformer.ValueFn) -> ImageTransformer.OutputRenderer:\n    ...",
  "def image(\n    _fn: ImageTransformer.ValueFn | None = None,\n    *,\n    delete_file: bool = False,\n) -> ImageTransformer.OutputRendererDecorator | ImageTransformer.OutputRenderer:\n    \"\"\"\n    Reactively render a image file as an HTML image.\n\n    Parameters\n    ----------\n    delete_file\n        If ``True``, the image file will be deleted after rendering.\n\n    Returns\n    -------\n    :\n        A decorator for a function that returns an `~shiny.types.ImgData` object.\n\n    Tip\n    ----\n    This decorator should be applied **before** the ``@output`` decorator. Also, the\n    name of the decorated function (or ``@output(id=...)``) should match the ``id`` of\n    a :func:`~shiny.ui.output_image` container (see :func:`~shiny.ui.output_image` for\n    example usage).\n\n    See Also\n    --------\n    ~shiny.ui.output_image\n    ~shiny.types.ImgData\n    ~shiny.render.plot\n    \"\"\"\n    return ImageTransformer(_fn, ImageTransformer.params(delete_file=delete_file))",
  "class PandasCompatible(Protocol):\n    # Signature doesn't matter, runtime_checkable won't look at it anyway\n    def to_pandas(self) -> \"pd.DataFrame\":\n        ...",
  "async def TableTransformer(\n    _meta: TransformerMetadata,\n    _fn: ValueFn[TableResult | None],\n    *,\n    index: bool = False,\n    classes: str = \"table shiny-table w-auto\",\n    border: int = 0,\n    **kwargs: object,\n) -> RenderedDeps | None:\n    x = await resolve_value_fn(_fn)\n\n    if x is None:\n        return None\n\n    import pandas\n    import pandas.io.formats.style\n\n    html: str\n    if isinstance(x, pandas.io.formats.style.Styler):\n        html = cast(  # pyright: ignore[reportUnnecessaryCast]\n            str,\n            x.to_html(  # pyright: ignore[reportUnknownMemberType]\n                **kwargs  # pyright: ignore[reportGeneralTypeIssues]\n            ),\n        )\n    else:\n        if not isinstance(x, pandas.DataFrame):\n            if not isinstance(x, PandasCompatible):\n                raise TypeError(\n                    \"@render.table doesn't know how to render objects of type \"\n                    f\"'{str(type(x))}'. Return either a pandas.DataFrame, or an object \"\n                    \"that has a .to_pandas() method.\"\n                )\n            x = x.to_pandas()\n\n        html = cast(  # pyright: ignore[reportUnnecessaryCast]\n            str,\n            x.to_html(  # pyright: ignore[reportUnknownMemberType]\n                index=index,\n                classes=classes,\n                border=border,\n                **kwargs,  # pyright: ignore[reportGeneralTypeIssues]\n            ),\n        )\n    return {\"deps\": [], \"html\": html}",
  "def table(\n    *,\n    index: bool = False,\n    classes: str = \"table shiny-table w-auto\",\n    border: int = 0,\n    **kwargs: Any,\n) -> TableTransformer.OutputRendererDecorator:\n    ...",
  "def table(_fn: TableTransformer.ValueFn) -> TableTransformer.OutputRenderer:\n    ...",
  "def table(\n    _fn: TableTransformer.ValueFn | None = None,\n    *,\n    index: bool = False,\n    classes: str = \"table shiny-table w-auto\",\n    border: int = 0,\n    **kwargs: object,\n) -> TableTransformer.OutputRenderer | TableTransformer.OutputRendererDecorator:\n    \"\"\"\n    Reactively render a Pandas data frame object (or similar) as a basic HTML table.\n\n    Consider using ~shiny.render.data_frame instead of this renderer, as it provides\n    high performance virtual scrolling, built-in filtering and sorting, and a better\n    default appearance. This renderer may still be helpful if you use pandas styling\n    features that are not currently supported by ~shiny.render.data_frame.\n\n    Parameters\n    ----------\n    index\n        Whether to print index (row) labels. (Ignored for pandas :class:`Styler`\n        objects; call ``style.hide(axis=\"index\")`` from user code instead.)\n    classes\n        CSS classes (space separated) to apply to the resulting table. By default, we\n        use `table shiny-table w-auto` which is designed to look reasonable with Bootstrap 5.\n        (Ignored for pandas :class:`Styler` objects; call\n        ``style.set_table_attributes('class=\"dataframe table shiny-table w-auto\"')``\n        from user code instead.)\n    **kwargs\n        Additional keyword arguments passed to ``pandas.DataFrame.to_html()`` or\n        ``pandas.io.formats.style.Styler.to_html()``.\n\n    Returns\n    -------\n    :\n        A decorator for a function that returns any of the following:\n\n        1. A pandas :class:`DataFrame` object.\n        2. A pandas :class:`Styler` object.\n        3. Any object that has a `.to_pandas()` method (e.g., a Polars data frame or\n           Arrow table).\n\n    Tip\n    ----\n    This decorator should be applied **before** the ``@output`` decorator. Also, the\n    name of the decorated function (or ``@output(id=...)``) should match the ``id`` of\n    a :func:`~shiny.ui.output_table` container (see :func:`~shiny.ui.output_table` for\n    example usage).\n\n    See Also\n    --------\n    ~shiny.ui.output_table for the corresponding UI component to this render function.\n    \"\"\"\n    return TableTransformer(\n        _fn,\n        TableTransformer.params(\n            index=index,\n            classes=classes,\n            border=border,\n            **kwargs,\n        ),\n    )",
  "async def UiTransformer(\n    _meta: TransformerMetadata,\n    _fn: ValueFn[TagChild],\n) -> RenderedDeps | None:\n    ui = await resolve_value_fn(_fn)\n    if ui is None:\n        return None\n\n    return _meta.session._process_ui(ui)",
  "def ui() -> UiTransformer.OutputRendererDecorator:\n    ...",
  "def ui(_fn: UiTransformer.ValueFn) -> UiTransformer.OutputRenderer:\n    ...",
  "def ui(\n    _fn: UiTransformer.ValueFn | None = None,\n) -> UiTransformer.OutputRenderer | UiTransformer.OutputRendererDecorator:\n    \"\"\"\n    Reactively render HTML content.\n\n    Returns\n    -------\n    :\n        A decorator for a function that returns an object of type `~shiny.ui.TagChild`.\n\n    Tip\n    ----\n    This decorator should be applied **before** the ``@output`` decorator. Also, the\n    name of the decorated function (or ``@output(id=...)``) should match the ``id`` of\n    a :func:`~shiny.ui.output_ui` container (see :func:`~shiny.ui.output_ui` for example\n    usage).\n\n    See Also\n    --------\n    ~shiny.ui.output_ui\n    \"\"\"\n    return UiTransformer(_fn)",
  "def to_pandas(self) -> \"pd.DataFrame\":\n        ...",
  "def try_render_matplotlib(\n    x: object,\n    width: float,\n    height: float,\n    pixelratio: float,\n    ppi: float,\n    allow_global: bool,\n    alt: Optional[str],\n    **kwargs: object,\n) -> TryPlotResult:\n    fig = get_matplotlib_figure(x, allow_global)\n\n    if fig is None:\n        return (False, None)\n\n    try:\n        import matplotlib.pyplot as plt  # pyright: ignore[reportUnusedImport] # noqa: F401\n\n        fig.set_size_inches(width / ppi, height / ppi)\n        fig.set_dpi(ppi * pixelratio)\n\n        # Suppress the message `UserWarning: The figure layout has changed to tight`\n        with warnings.catch_warnings():\n            warnings.filterwarnings(\n                action=\"ignore\",\n                category=UserWarning,\n                message=\"The figure layout has changed to tight\",\n            )\n            plt.tight_layout()  # pyright: ignore[reportUnknownMemberType]\n\n        coordmap = get_coordmap(fig)\n\n        with io.BytesIO() as buf:\n            fig.savefig(  # pyright: ignore[reportUnknownMemberType]\n                buf,\n                format=\"png\",\n                dpi=ppi * pixelratio,\n                **kwargs,\n            )\n            buf.seek(0)\n            data = base64.b64encode(buf.read())\n            data_str = data.decode(\"utf-8\")\n\n        res: ImgData = {\n            \"src\": \"data:image/png;base64,\" + data_str,\n            \"width\": \"100%\",\n            \"height\": \"100%\",\n        }\n\n        if alt is not None:\n            res[\"alt\"] = alt\n\n        if coordmap is not None:\n            res[\"coordmap\"] = coordmap\n\n        return (True, res)\n\n    finally:\n        import matplotlib.pyplot\n\n        matplotlib.pyplot.close(fig)",
  "def get_matplotlib_figure(\n    x: object, allow_global: bool\n) -> Figure | None:  # pyright: ignore\n    import matplotlib.pyplot as plt\n    from matplotlib.animation import Animation\n    from matplotlib.artist import Artist\n    from matplotlib.figure import Figure\n\n    # Detect usage of pyplot global figure\n    # TODO: Might be good to detect non-empty plt.get_fignums() before we call the user\n    #   function, which would mean we will false-positive here. Maybe we warn in that\n    #   case, maybe we ignore gcf(), maybe both.\n    if x is None and len(plt.get_fignums()) > 0:\n        if allow_global:\n            return plt.gcf()\n        else:\n            # Must close the global figure so we don't stay in this state forever\n            plt.close(plt.gcf())  # pyright: ignore[reportUnknownMemberType]\n            raise RuntimeError(\n                \"matplotlib.pyplot cannot be used from an async render function; \"\n                \"please use matplotlib's object-oriented interface instead\"\n            )\n\n    if isinstance(x, Figure):\n        return x\n\n    if isinstance(x, Animation):\n        raise RuntimeError(\n            \"Matplotlib's Animation class isn't supported by @render.plot. \"\n            + \"Consider explictly saving the animation to a file and \"\n            + \"then using @render.image instead to render it.\"\n        )\n\n    # Libraries like pandas, xarray, etc have plot() methods that can return a wide\n    # array pf mpl classes, like Lines2D, Subplots, Axes, etc. The Artist ABC class\n    # should cover most, if not all, of these (it doesn't cover Animation, though).\n    # https://matplotlib.org/stable/api/artist_api.html\n    if isinstance(x, Artist):\n        return x.get_figure()\n\n    # Some other custom figure-like classes such as seaborn.axisgrid.FacetGrid attach\n    # their figure as an attribute\n    fig = getattr(x, \"figure\", None)\n    if isinstance(fig, Figure):\n        return fig\n\n    # Sometimes generic plot() methods will return an iterable of Artists,\n    # If they all refer to the same figure, then it seems reasonable to use it\n    # https://docs.xarray.dev/en/latest/user-guide/plotting.html#dimension-along-y-axis\n    if isinstance(x, (list, tuple)):\n        figs = [get_matplotlib_figure(y, allow_global) for y in cast(List[Any], x)]\n        if len(set(figs)) == 1:\n            return figs[0]\n\n    return None",
  "def try_render_pil(\n    x: object,\n    width: float,\n    height: float,\n    pixelratio: float,\n    ppi: float,\n    alt: Optional[str] = None,\n    **kwargs: object,\n) -> TryPlotResult:\n    import PIL.Image\n\n    if not isinstance(x, PIL.Image.Image):\n        return (False, None)\n\n    with io.BytesIO() as buf:\n        x.save(buf, format=\"PNG\", **kwargs)\n        buf.seek(0)\n        data = base64.b64encode(buf.read())\n        data_str = data.decode(\"utf-8\")\n\n    res: ImgData = {\n        \"src\": \"data:image/png;base64,\" + data_str,\n        \"width\": \"100%\",\n        \"height\": \"100%\",\n        \"style\": \"object-fit:contain\",\n    }\n\n    if alt is not None:\n        res[\"alt\"] = alt\n\n    return (True, res)",
  "def try_render_plotnine(\n    x: object,\n    width: float,\n    height: float,\n    pixelratio: float,\n    ppi: float,\n    alt: Optional[str] = None,\n    **kwargs: object,\n) -> TryPlotResult:\n    from plotnine.ggplot import ggplot\n\n    if not isinstance(x, ggplot):\n        return (False, None)\n\n    x = cast(PlotnineFigure, x)\n\n    with io.BytesIO() as buf:\n        # save_helper was added in plotnine 0.10.1-dev. If this method exists, we can\n        # use it to get the matplotlib Figure object, which we can then use to get the\n        # coordmap. Once this version of plotnine is released and in common use, we can\n        # add a version dependency and remove the conditional code.\n        if hasattr(x, \"save_helper\"):\n            res = x.save_helper(  # pyright: ignore[reportUnknownMemberType, reportGeneralTypeIssues, reportUnknownVariableType]\n                filename=buf,\n                format=\"png\",\n                units=\"in\",\n                dpi=ppi * pixelratio,\n                width=width / ppi,\n                height=height / ppi,\n                verbose=False,\n                **kwargs,\n            )\n            coordmap = get_coordmap_plotnine(\n                x,\n                res.figure,  # pyright: ignore[reportUnknownMemberType, reportUnknownArgumentType, reportGeneralTypeIssues]\n            )\n            res.figure.savefig(  # pyright: ignore[reportUnknownMemberType, reportGeneralTypeIssues]\n                **res.kwargs  # pyright: ignore[reportUnknownMemberType, reportGeneralTypeIssues]\n            )\n        else:\n            x.save(\n                filename=buf,\n                format=\"png\",\n                units=\"in\",\n                dpi=ppi * pixelratio,\n                width=width / ppi,\n                height=height / ppi,\n                verbose=False,\n                **kwargs,\n            )\n            coordmap = None\n        buf.seek(0)\n        data = base64.b64encode(buf.read())\n        data_str = data.decode(\"utf-8\")\n\n    res: ImgData = {\n        \"src\": \"data:image/png;base64,\" + data_str,\n        \"width\": \"100%\",\n        \"height\": \"100%\",\n    }\n\n    if alt is not None:\n        res[\"alt\"] = alt\n\n    if coordmap is not None:\n        res[\"coordmap\"] = coordmap\n\n    return (True, res)",
  "class RenderFunction(Generic[IT, OT], OutputRendererSync[OT], ABC):\n    \"\"\"\n    Deprecated. Please use :func:`~shiny.render.renderer_components` instead.\n    \"\"\"\n\n    @abstractmethod\n    def __call__(self) -> OT:\n        ...\n\n    @abstractmethod\n    async def run(self) -> OT:\n        ...\n\n    def __init__(self, fn: ValueFnSync[IT]) -> None:\n        async def transformer(_meta: TransformerMetadata, _fn: ValueFn[IT]) -> OT:\n            ret = await self.run()\n            return ret\n\n        super().__init__(\n            value_fn=fn,\n            transform_fn=transformer,\n            params=TransformerParams.empty_params(),\n        )\n        self._fn = fn",
  "class RenderFunctionAsync(Generic[IT, OT], OutputRendererAsync[OT], ABC):\n    \"\"\"\n    Deprecated. Please use :func:`~shiny.render.renderer_components` instead.\n    \"\"\"\n\n    @abstractmethod\n    async def __call__(self) -> OT:  # pyright: ignore[reportIncompatibleMethodOverride]\n        ...\n\n    @abstractmethod\n    async def run(self) -> OT:\n        ...\n\n    def __init__(self, fn: ValueFnAsync[IT]) -> None:\n        async def transformer(_meta: TransformerMetadata, _fn: ValueFn[IT]) -> OT:\n            ret = await self.run()\n            return ret\n\n        super().__init__(\n            value_fn=fn,\n            transform_fn=transformer,\n            params=TransformerParams.empty_params(),\n        )\n        self._fn = fn",
  "def __call__(self) -> OT:\n        ...",
  "async def run(self) -> OT:\n        ...",
  "def __init__(self, fn: ValueFnSync[IT]) -> None:\n        async def transformer(_meta: TransformerMetadata, _fn: ValueFn[IT]) -> OT:\n            ret = await self.run()\n            return ret\n\n        super().__init__(\n            value_fn=fn,\n            transform_fn=transformer,\n            params=TransformerParams.empty_params(),\n        )\n        self._fn = fn",
  "async def __call__(self) -> OT:  # pyright: ignore[reportIncompatibleMethodOverride]\n        ...",
  "async def run(self) -> OT:\n        ...",
  "def __init__(self, fn: ValueFnAsync[IT]) -> None:\n        async def transformer(_meta: TransformerMetadata, _fn: ValueFn[IT]) -> OT:\n            ret = await self.run()\n            return ret\n\n        super().__init__(\n            value_fn=fn,\n            transform_fn=transformer,\n            params=TransformerParams.empty_params(),\n        )\n        self._fn = fn",
  "async def transformer(_meta: TransformerMetadata, _fn: ValueFn[IT]) -> OT:\n            ret = await self.run()\n            return ret",
  "async def transformer(_meta: TransformerMetadata, _fn: ValueFn[IT]) -> OT:\n            ret = await self.run()\n            return ret",
  "class AbstractTabularData(abc.ABC):\n    @abc.abstractmethod\n    def to_payload(self) -> object:\n        ...",
  "class DataGrid(AbstractTabularData):\n    \"\"\"\n    Holds the data and options for a ``shiny.render.data_frame`` output, for a\n    spreadsheet-like view.\n\n    Parameters\n    ----------\n    data\n        A pandas `DataFrame` object, or any object that has a `.to_pandas()` method\n        (e.g., a Polars data frame or Arrow table).\n    width\n        A _maximum_ amount of vertical space for the data grid to occupy, in CSS units\n        (e.g. `\"400px\"`) or as a number, which will be interpreted as pixels. The\n        default is `fit-content`, which sets the grid's width according to its contents.\n        Set this to `100%` to use the maximum available horizontal space.\n    height\n        A _maximum_ amount of vertical space for the data grid to occupy, in CSS units\n        (e.g. `\"400px\"`) or as a number, which will be interpreted as pixels. If there\n        are more rows than can fit in this space, the grid will scroll. Set the height\n        to `None` to allow the grid to grow to fit all of the rows (this is not\n        recommended for large data sets, as it may crash the browser).\n    summary\n        If `True` (the default), shows a message like \"Viewing rows 1 through 10 of 20\"\n        below the grid when not all of the rows are being shown. If `False`, the message\n        is not displayed. You can also specify a string template to customize the\n        message, containing `{start}`, `{end}`, and `{total}` tokens. For example:\n        `\"Viendo filas {start} a {end} de {total}\"`.\n    filters\n        If `True`, shows a row of filter inputs below the headers, one for each column.\n    row_selection_mode\n        Use `\"none\"` to disable row selection, `\"single\"` to allow a single row to be\n        selected at a time, and `\"multiple\"` to allow multiple rows to be selected by\n        clicking on them individually.\n\n    Returns\n    -------\n    :\n        An object suitable for being returned from a `@render.data_frame`-decorated\n        output function.\n\n    See Also\n    --------\n    :func:`~shiny.ui.output_data_frame`\n    :func:`~shiny.render.data_frame`\n    :class:`~shiny.render.DataTable`\n    \"\"\"\n\n    def __init__(\n        self,\n        data: object,\n        *,\n        width: str | float | None = \"fit-content\",\n        height: Union[str, float, None] = \"500px\",\n        summary: Union[bool, str] = True,\n        filters: bool = False,\n        row_selection_mode: Literal[\"none\", \"single\", \"multiple\"] = \"none\",\n    ):\n        import pandas as pd\n\n        self.data: pd.DataFrame = cast(\n            pd.DataFrame,\n            cast_to_pandas(\n                data,\n                \"The DataGrid() constructor didn't expect a 'data' argument of type\",\n            ),\n        )\n\n        self.width = width\n        self.height = height\n        self.summary = summary\n        self.filters = filters\n        self.row_selection_mode = row_selection_mode\n\n    def to_payload(self) -> object:\n        res = serialize_pandas_df(self.data)\n        res[\"options\"] = dict(\n            width=self.width,\n            height=self.height,\n            summary=self.summary,\n            filters=self.filters,\n            row_selection_mode=self.row_selection_mode,\n            style=\"grid\",\n        )\n        return res",
  "class DataTable(AbstractTabularData):\n    \"\"\"\n    Holds the data and options for a ``shiny.render.data_frame`` output, for a\n    spreadsheet-like view.\n\n    Parameters\n    ----------\n    data\n        A pandas `DataFrame` object, or any object that has a `.to_pandas()` method\n        (e.g., a Polars data frame or Arrow table).\n    width\n        A _maximum_ amount of vertical space for the data table to occupy, in CSS units\n        (e.g. `\"400px\"`) or as a number, which will be interpreted as pixels. The\n        default is `fit-content`, which sets the table's width according to its\n        contents. Set this to `100%` to use the maximum available horizontal space.\n    height\n        A _maximum_ amount of vertical space for the data table to occupy, in CSS units\n        (e.g. `\"400px\"`) or as a number, which will be interpreted as pixels. If there\n        are more rows than can fit in this space, the table body will scroll. Set the\n        height to `None` to allow the table to grow to fit all of the rows (this is not\n        recommended for large data sets, as it may crash the browser).\n    summary\n        If `True` (the default), shows a message like \"Viewing rows 1 through 10 of 20\"\n        below the grid when not all of the rows are being shown. If `False`, the message\n        is not displayed. You can also specify a string template to customize the\n        message, containing `{start}`, `{end}`, and `{total}` tokens. For example:\n        `\"Viendo filas {start} a {end} de {total}\"`.\n    filters\n        If `True`, shows a row of filter inputs below the headers, one for each column.\n    row_selection_mode\n        Use `\"none\"` to disable row selection, `\"single\"` to allow a single row to be\n        selected at a time, and `\"multiple\"` to allow multiple rows to be selected by\n        clicking on them individually.\n\n    Returns\n    -------\n    :\n        An object suitable for being returned from a `@render.data_frame`-decorated\n        output function.\n\n    See Also\n    --------\n    :func:`~shiny.ui.output_data_frame`\n    :func:`~shiny.render.data_frame`\n    :class:`~shiny.render.DataGrid`\n    \"\"\"\n\n    def __init__(\n        self,\n        data: object,\n        *,\n        width: Union[str, float, None] = \"fit-content\",\n        height: Union[str, float, None] = \"500px\",\n        summary: Union[bool, str] = True,\n        filters: bool = False,\n        row_selection_mode: Union[\n            Literal[\"none\"], Literal[\"single\"], Literal[\"multiple\"]\n        ] = \"none\",\n    ):\n        import pandas as pd\n\n        self.data: pd.DataFrame = cast(\n            pd.DataFrame,\n            cast_to_pandas(\n                data,\n                \"The DataTable() constructor didn't expect a 'data' argument of type\",\n            ),\n        )\n\n        self.width = width\n        self.height = height\n        self.summary = summary\n        self.filters = filters\n        self.row_selection_mode = row_selection_mode\n\n    def to_payload(self) -> object:\n        res = serialize_pandas_df(self.data)\n        res[\"options\"] = dict(\n            width=self.width,\n            height=self.height,\n            summary=self.summary,\n            filters=self.filters,\n            row_selection_mode=self.row_selection_mode,\n            style=\"table\",\n        )\n        return res",
  "def serialize_pandas_df(df: \"pd.DataFrame\") -> dict[str, Any]:\n    # Currently, we don't make use of the index; drop it so we don't error trying to\n    # serialize it or something\n    df = df.reset_index(drop=True)\n\n    res = json.loads(\n        # {index: [index], columns: [columns], data: [values]}\n        df.to_json(None, orient=\"split\")  # pyright: ignore[reportUnknownMemberType]\n    )\n\n    res[\"type_hints\"] = serialize_numpy_dtypes(df)\n\n    return res",
  "async def DataFrameTransformer(\n    _meta: TransformerMetadata,\n    _fn: ValueFn[DataFrameResult | None],\n) -> object | None:\n    x = await resolve_value_fn(_fn)\n    if x is None:\n        return None\n\n    if not isinstance(x, AbstractTabularData):\n        x = DataGrid(\n            cast_to_pandas(\n                x, \"@render.data_frame doesn't know how to render objects of type\"\n            )\n        )\n    return x.to_payload()",
  "def data_frame() -> DataFrameTransformer.OutputRendererDecorator:\n    ...",
  "def data_frame(\n    _fn: DataFrameTransformer.ValueFn,\n) -> DataFrameTransformer.OutputRenderer:\n    ...",
  "def data_frame(\n    _fn: DataFrameTransformer.ValueFn | None = None,\n) -> DataFrameTransformer.OutputRenderer | DataFrameTransformer.OutputRendererDecorator:\n    \"\"\"\n    Reactively render a Pandas data frame object (or similar) as an interactive table or\n    grid. Features fast virtualized scrolling, sorting, filtering, and row selection\n    (single or multiple).\n\n    Returns\n    -------\n    :\n        A decorator for a function that returns any of the following:\n\n        1. A :class:`~shiny.render.DataGrid` or :class:`~shiny.render.DataTable` object,\n           which can be used to customize the appearance and behavior of the data frame\n           output.\n        2. A pandas :class:`DataFrame` object. (Equivalent to\n           `shiny.render.DataGrid(df)`.)\n        3. Any object that has a `.to_pandas()` method (e.g., a Polars data frame or\n           Arrow table). (Equivalent to `shiny.render.DataGrid(df.to_pandas())`.)\n\n    Row selection\n    -------------\n    When using the row selection feature, you can access the selected rows by using the\n    `input.<id>_selected_rows()` function, where `<id>` is the `id` of the\n    :func:`~shiny.ui.output_data_frame`. The value returned will be `None` if no rows\n    are selected, or a tuple of integers representing the indices of the selected rows.\n    To filter a pandas data frame down to the selected rows, use\n    `df.iloc[list(input.<id>_selected_rows())]`.\n\n    Tip\n    ----\n    This decorator should be applied **before** the ``@output`` decorator. Also, the\n    name of the decorated function (or ``@output(id=...)``) should match the ``id`` of a\n    :func:`~shiny.ui.output_table` container (see :func:`~shiny.ui.output_table` for\n    example usage).\n\n    See Also\n    --------\n    * :func:`~shiny.ui.output_data_frame`\n    * :class:`~shiny.render.DataGrid` and :class:`~shiny.render.DataTable` are the\n      objects you can return from the rendering function to specify options.\n    \"\"\"\n    return DataFrameTransformer(_fn)",
  "class PandasCompatible(Protocol):\n    # Signature doesn't matter, runtime_checkable won't look at it anyway\n    def to_pandas(self) -> object:\n        ...",
  "def cast_to_pandas(x: object, error_message_begin: str) -> object:\n    import pandas as pd\n\n    if not isinstance(x, pd.DataFrame):\n        if not isinstance(x, PandasCompatible):\n            raise TypeError(\n                error_message_begin\n                + f\" '{str(type(x))}'. Use either a pandas.DataFrame, or an object\"\n                \" that has a .to_pandas() method.\"\n            )\n        return x.to_pandas()\n    return x",
  "def to_payload(self) -> object:\n        ...",
  "def __init__(\n        self,\n        data: object,\n        *,\n        width: str | float | None = \"fit-content\",\n        height: Union[str, float, None] = \"500px\",\n        summary: Union[bool, str] = True,\n        filters: bool = False,\n        row_selection_mode: Literal[\"none\", \"single\", \"multiple\"] = \"none\",\n    ):\n        import pandas as pd\n\n        self.data: pd.DataFrame = cast(\n            pd.DataFrame,\n            cast_to_pandas(\n                data,\n                \"The DataGrid() constructor didn't expect a 'data' argument of type\",\n            ),\n        )\n\n        self.width = width\n        self.height = height\n        self.summary = summary\n        self.filters = filters\n        self.row_selection_mode = row_selection_mode",
  "def to_payload(self) -> object:\n        res = serialize_pandas_df(self.data)\n        res[\"options\"] = dict(\n            width=self.width,\n            height=self.height,\n            summary=self.summary,\n            filters=self.filters,\n            row_selection_mode=self.row_selection_mode,\n            style=\"grid\",\n        )\n        return res",
  "def __init__(\n        self,\n        data: object,\n        *,\n        width: Union[str, float, None] = \"fit-content\",\n        height: Union[str, float, None] = \"500px\",\n        summary: Union[bool, str] = True,\n        filters: bool = False,\n        row_selection_mode: Union[\n            Literal[\"none\"], Literal[\"single\"], Literal[\"multiple\"]\n        ] = \"none\",\n    ):\n        import pandas as pd\n\n        self.data: pd.DataFrame = cast(\n            pd.DataFrame,\n            cast_to_pandas(\n                data,\n                \"The DataTable() constructor didn't expect a 'data' argument of type\",\n            ),\n        )\n\n        self.width = width\n        self.height = height\n        self.summary = summary\n        self.filters = filters\n        self.row_selection_mode = row_selection_mode",
  "def to_payload(self) -> object:\n        res = serialize_pandas_df(self.data)\n        res[\"options\"] = dict(\n            width=self.width,\n            height=self.height,\n            summary=self.summary,\n            filters=self.filters,\n            row_selection_mode=self.row_selection_mode,\n            style=\"table\",\n        )\n        return res",
  "def to_pandas(self) -> object:\n        ...",
  "def get_coordmap(fig: Figure) -> Coordmap | None:\n    dims_ar = fig.get_size_inches() * fig.get_dpi()\n    dims: CoordmapDims = {\n        \"width\": dims_ar[0],\n        \"height\": dims_ar[1],\n    }\n\n    all_axes = cast(\n        \"list[Axes]\",  # pyright: ignore\n        fig.get_axes(),\n    )\n\n    panels: list[CoordmapPanel] = []\n    for i, axes in enumerate(all_axes):\n        panel = get_coordmap_panel(axes, i + 1, dims[\"height\"])\n        panels.append(panel)\n\n    coordmap: Coordmap = {\n        \"panels\": panels,\n        \"dims\": dims,\n    }\n\n    return coordmap",
  "def get_coordmap_panel(axes: Axes, panel_num: int, height: float) -> CoordmapPanel:\n    spspec = cast(\n        \"SubplotSpec\",\n        axes.get_subplotspec(),  # pyright: ignore[reportGeneralTypeIssues]\n    )\n\n    domain_xlim = axes.get_xlim()\n    domain_ylim = axes.get_ylim()\n\n    # Data coordinates of plotting area\n    domain: CoordmapPanelDomain = {\n        \"left\": domain_xlim[0],\n        \"right\": domain_xlim[1],\n        \"bottom\": domain_ylim[0],\n        \"top\": domain_ylim[1],\n    }\n\n    # Pixel coordinates of plotting area\n    transdata = axes.transData\n\n    range_ar = cast(\n        \"npt.NDArray[np.double]\",\n        transdata.transform(\n            [\n                domain[\"left\"],\n                domain[\"bottom\"],\n                domain[\"right\"],\n                domain[\"top\"],\n            ]\n        ),\n    )\n\n    # The values from transData.transform() have origin in the bottom-left, but we need\n    # to provide coordinates with origin in upper-left.\n    range: CoordmapPanelRange = {\n        \"left\": range_ar[0],\n        \"right\": range_ar[2],\n        \"bottom\": height - range_ar[1],\n        \"top\": height - range_ar[3],\n    }\n\n    log: CoordmapPanelLog = {\"x\": None, \"y\": None}\n    xaxis: Any = axes.xaxis  # pyright: ignore[reportGeneralTypeIssues]\n    if xaxis._scale.name == \"log\":\n        log[\"x\"] = xaxis._scale.base\n        domain[\"left\"] = xaxis._scale._transform.transform(domain[\"left\"])\n        domain[\"right\"] = xaxis._scale._transform.transform(domain[\"right\"])\n\n    yaxis: Any = axes.yaxis  # pyright: ignore[reportGeneralTypeIssues]\n    if yaxis._scale.name == \"log\":\n        log[\"y\"] = yaxis._scale.base\n        domain[\"top\"] = yaxis._scale._transform.transform(domain[\"top\"])\n        domain[\"bottom\"] = yaxis._scale._transform.transform(domain[\"bottom\"])\n\n    return {\n        \"panel\": panel_num,\n        \"row\": spspec.rowspan.start + 1,\n        \"col\": spspec.colspan.start + 1,\n        # \"panel_vars\": {\n        #     \"panelvar1\": \"4\",\n        #     \"panelvar2\": \"1\",\n        # },\n        \"domain\": domain,\n        \"range\": range,\n        \"log\": log,\n        \"mapping\": {\n            \"x\": None,\n            \"y\": None,\n            # \"x\": \"wt\",\n            # \"y\": \"mpg\",\n            # \"panelvar1\": \"cyl\",\n            # \"panelvar2\": \"am\",\n        },\n    }",
  "def get_coordmap_plotnine(p: PlotnineFigure, fig: Figure) -> Coordmap | None:\n    coordmap = get_coordmap(fig)\n\n    if coordmap is None:\n        return None\n\n    p = deepcopy(p)\n    p._build()  # pyright: ignore[reportGeneralTypeIssues]\n\n    # Plotnine/ggplot figures can contain some information that is not in the matplotlib\n    # Figure object that is generated.\n\n    # The mappings are shared across all panels, so just get them once.\n    mappings = _get_mappings(p)\n\n    for i in range(len(coordmap[\"panels\"])):\n        # Copy the panel object; we'll mutate it, and then assign the copy back.\n        panel = deepcopy(coordmap[\"panels\"][i])\n        panel_num = panel[\"panel\"]\n\n        panel[\"mapping\"] = mappings.copy()\n\n        # Slice out the row of the layout data frame that corresponds to this panel.\n        layout_row = p.layout.layout.loc[p.layout.layout[\"PANEL\"] == panel_num]\n\n        # Get values of panelvars\n        if \"panelvar1\" in panel[\"mapping\"]:\n            panel[\"panel_vars\"] = {}\n            panelvar1 = panel[\"mapping\"][\"panelvar1\"]  # pyright: ignore\n            # If panelvar1 is, say, \"cyl\", then panelvar1_val will be something like 4.\n            panelvar1_val = _simplify_type(layout_row[panelvar1].iloc[0])\n            panel[\"panel_vars\"][\"panelvar1\"] = panelvar1_val  # pyright: ignore\n\n        if \"panelvar2\" in panel[\"mapping\"]:\n            panelvar2 = panel[\"mapping\"][\"panelvar2\"]  # pyright: ignore\n            panelvar2_val = _simplify_type(layout_row[panelvar2].iloc[0])\n            panel[\"panel_vars\"][\"panelvar2\"] = panelvar2_val  # pyright: ignore\n\n        # Get x and y scales\n        xscale_num = layout_row[\"SCALE_X\"].iloc[0]\n        yscale_num = layout_row[\"SCALE_Y\"].iloc[0]\n        xscale = p.layout.panel_scales_x[xscale_num - 1]\n        yscale = p.layout.panel_scales_y[yscale_num - 1]\n\n        # Plotnine objects handle log scales a bit differently from regular matplotlib\n        # Figures. Instead of using log scales in the matplotlib Figure object, it adds\n        # log scales in the ggplot object.\n        if hasattr(xscale, \"_trans\") and _is_log_trans(xscale._trans):\n            panel[\"log\"][\"x\"] = xscale._trans.base\n        if hasattr(yscale, \"_trans\") and _is_log_trans(yscale._trans):\n            panel[\"log\"][\"y\"] = yscale._trans.base\n\n        if hasattr(xscale, \"_trans\") and _is_reverse_trans(xscale._trans):\n            domain = panel[\"domain\"]\n            panel[\"domain\"][\"left\"] = -domain[\"left\"]\n            panel[\"domain\"][\"right\"] = -domain[\"right\"]\n        if hasattr(yscale, \"_trans\") and _is_reverse_trans(yscale._trans):\n            domain = panel[\"domain\"]\n            panel[\"domain\"][\"top\"] = -domain[\"top\"]\n            panel[\"domain\"][\"bottom\"] = -domain[\"bottom\"]\n\n        # Plotnine figures can also have transforms in the coordinates. We will assume\n        # that log coord transforms are not used along with log scales, because that\n        # would be really strange.\n        if hasattr(p.layout.coord, \"trans_x\") and _is_log_trans(p.layout.coord.trans_x):\n            panel[\"log\"][\"x\"] = p.layout.coord.trans_x.base\n        if hasattr(p.layout.coord, \"trans_y\") and _is_log_trans(p.layout.coord.trans_y):\n            panel[\"log\"][\"y\"] = p.layout.coord.trans_y.base\n\n        # Assign temporary panel object back to coordmap.\n        coordmap[\"panels\"][i] = panel\n\n    return coordmap",
  "def _is_log_trans(trans: object) -> bool:\n    return bool(re.fullmatch(\"log.*_trans\", type(trans).__name__))",
  "def _is_reverse_trans(trans: object) -> bool:\n    return type(trans).__name__ == \"reverse_trans\"",
  "def _get_mappings(p: PlotnineFigure) -> CoordmapPanelMapping:\n    mapping: CoordmapPanelMapping = {\"x\": None, \"y\": None}\n\n    if \"x\" in p.mapping:\n        mapping[\"x\"] = p.mapping[\"x\"]\n    if \"y\" in p.mapping:\n        mapping[\"y\"] = p.mapping[\"y\"]\n\n    if type(p.layout.coord).__name__ == \"coord_flip\":\n        (mapping[\"x\"], mapping[\"y\"]) = (mapping[\"y\"], mapping[\"x\"])\n\n    # The names (not values) of panel vars are the same across all panels.\n    if type(p.layout.facet).__name__ == \"facet_grid\":\n        n = 1\n        if len(p.layout.facet.cols) > 0:\n            mapping[f\"panelvar{n}\"] = p.layout.facet.cols[0]\n            n += 1\n        if len(p.layout.facet.rows) > 0:\n            mapping[f\"panelvar{n}\"] = p.layout.facet.rows[0]\n\n    elif type(p.layout.facet).__name__ == \"facet_wrap\":\n        mapping[\"panelvar1\"] = p.layout.facet.vars[0]\n\n    return mapping",
  "def _simplify_type(x: Any) -> Any:\n    import numpy as np\n\n    if isinstance(x, np.integer):\n        return int(x)  # pyright: ignore[reportUnknownArgumentType]\n    elif isinstance(x, np.floating):\n        return float(x)  # pyright: ignore[reportUnknownArgumentType]\n    else:\n        return x",
  "def serialize_numpy_dtypes(df: \"pd.DataFrame\") -> list[dict[str, Any]]:\n    return [serialize_numpy_dtype(col) for _, col in df.items()]",
  "def serialize_numpy_dtype(\n    col: \"pd.Series\",\n) -> dict[str, Any]:\n    import pandas as pd\n\n    t = pd.api.types.infer_dtype(col)\n    # t can be any of: string, bytes, floating, integer, mixed-integer,\n    #     mixed-integer-float, decimal, complex, categorical, boolean, datetime64,\n    #     datetime, date, timedelta64, timedelta, time, period, mixed, unknown-array\n\n    res: dict[str, Any] = {}\n\n    if t == \"string\":\n        pass\n    elif t in [\"bytes\", \"floating\", \"integer\", \"decimal\", \"mixed-integer-float\"]:\n        t = \"numeric\"\n    elif t == \"categorical\":\n        res[\"categories\"] = [str(x) for x in col.cat.categories.to_list()]\n    else:\n        t = \"unknown\"\n\n    res[\"type\"] = t\n\n    return res",
  "class TransformerMetadata(NamedTuple):\n    \"\"\"\n    Transformer metadata\n\n    This class is used to hold meta information for a transformer function.\n\n    Attributes\n    ----------\n    session\n        The :class:`~shiny.Session` object of the current output value function.\n    name\n        The name of the output being rendered.\n    \"\"\"\n\n    session: Session\n    name: str",
  "class TransformerParams(Generic[P]):\n    \"\"\"\n    Parameters for a transformer function\n\n    This class is used to isolate the transformer function parameters away from\n    internal implementation parameters used by Shiny.\n\n    \"\"\"\n\n    def __init__(self, *args: P.args, **kwargs: P.kwargs) -> None:\n        \"\"\"\n        Parameters\n        ----------\n        *args\n            No positional arguments should be supplied. Only keyword arguments should be\n            supplied. (`*args` is required when using :class:`~typing.ParamSpec` even if\n            transformer is only leveraging `**kwargs`.)\n        **kwargs\n            Keyword arguments for the corresponding renderer function.\n        \"\"\"\n\n        # Make sure there no `args` at run time!\n        # This check is related to `_assert_transform_fn` not accepting any `args`\n        if len(args) > 0:\n            raise RuntimeError(\"`args` should not be supplied\")\n\n        # `*args` must be defined with `**kwargs` (as per PEP612)\n        # (even when expanded later when calling the transform function)\n        # We need to store (and later retrieve) them, even if we know they are empty\n        self.args = args\n        self.kwargs = kwargs\n\n    @staticmethod\n    def empty_params() -> TransformerParams[P]:\n        \"\"\"\n        Return `TransformerParams` definition with no parameters.\n        \"\"\"\n\n        def inner(*args: P.args, **kwargs: P.kwargs) -> TransformerParams[P]:\n            return TransformerParams[P](*args, **kwargs)\n\n        return inner()",
  "class OutputRenderer(Generic[OT], ABC):\n    \"\"\"\n    Output Renderer\n\n    Transforms the output (of type `IT`) of an app-supplied output value function\n    (`value_fn`) into type (`OT`). This transformed value is then sent to be an\n    :class:`~shiny.Outputs` output value.\n\n    When the `.__call__` method is invoked, the transform function (`transform_fn`)\n    (typically defined by package authors) is invoked. The wrapping classes\n    (:class:`~shiny.render.transformer.OutputRendererSync` and\n    :class:`~shiny.render.transformer.OutputRendererAsync`) will enforce whether the\n    transform function is synchronous or asynchronous independent of the awaitable\n    syntax.\n\n    The transform function (`transform_fn`) is given `meta` information\n    (:class:`~shiny.render.transformer.TranformerMetadata`), the (app-supplied) value\n    function (`ValueFn[IT]`), and any keyword arguments supplied to the render decorator\n    (`P`). For consistency, the first two parameters have been (arbitrarily) implemented\n    as `_meta` and `_fn`.\n\n    Typing\n    ------\n    * `IT`\n        * The type returned by the app-supplied output value function (`value_fn`). This\n          value should contain a `None` value to conform to the convention of app authors\n          being able to return `None` to display nothing in the rendered output. Note that\n          in many cases but not all, `IT` and `OT` will be the same.\n    * `OT`\n        * The type of the object returned by the transform function (`transform_fn`). This\n          value should contain a `None` value to conform to display nothing in the\n          rendered output.\n    * `P`\n        * The parameter specification defined by the transform function (`transform_fn`).\n          It should **not** contain any `*args`. All keyword arguments should have a type\n          and default value.\n\n\n    See Also\n    --------\n    * :class:`~shiny.render.transformer.OutputRendererSync`\n    * :class:`~shiny.render.transformer.OutputRendererAsync`\n    \"\"\"\n\n    @abstractmethod\n    def __call__(self) -> OT:\n        \"\"\"\n        Executes the output renderer as a function. Must be implemented by subclasses.\n        \"\"\"\n        ...\n\n    def __init__(\n        self,\n        *,\n        value_fn: ValueFn[IT],\n        transform_fn: TransformFn[IT, P, OT],\n        params: TransformerParams[P],\n    ) -> None:\n        \"\"\"\n        Parameters\n        ----------\n        value_fn\n            App-provided output value function. It should return an object of type `IT`.\n        transform_fn\n            Package author function that transforms an object of type `IT` into type\n            `OT`. The `params` will used as variadic keyword arguments. This method\n            should only use `await` syntax when the value function (`ValueFn[IT]`) is\n            awaitable. If the value function is not awaitable (a _synchronous_\n            function), then the function should execute synchronously.\n        params\n            App-provided parameters for the transform function (`transform_fn`).\n\n        \"\"\"\n\n        # Copy over function name as it is consistent with how Session and Output\n        # retrieve function names\n        self.__name__ = value_fn.__name__\n\n        if not is_async_callable(transform_fn):\n            raise TypeError(\n                self.__class__.__name__\n                + \" requires an async tranformer function (`transform_fn`)\"\n            )\n\n        self._value_fn = value_fn\n        self._transformer = transform_fn\n        self._params = params\n\n    def _set_metadata(self, session: Session, name: str) -> None:\n        \"\"\"\n        When `Renderer`s are assigned to Output object slots, this method is used to\n        pass along Session and name information.\n        \"\"\"\n        self._session: Session = session\n        self._name: str = name\n\n    def _meta(self) -> TransformerMetadata:\n        \"\"\"\n        Returns a named tuple of values: `session` (the :class:`~shiny.Session` object),\n        and `name` (the name of the output being rendered)\n        \"\"\"\n        return TransformerMetadata(\n            session=self._session,\n            name=self._name,\n        )\n\n    async def _run(self) -> OT:\n        \"\"\"\n        Executes the (async) tranform function\n\n        The transform function will receive the following arguments: meta information of\n        type :class:`~shiny.render.transformer.TransformerMetadata`, an app-defined\n        render function of type :class:`~shiny.render.RenderFnAsync`, and `*args` and\n        `**kwargs` of type `P`.\n\n        Note: `*args` will always be empty as it is an expansion of\n        :class:`~shiny.render.transformer.TransformerParams` which does not allow positional arguments.\n        `*args` is required to use with `**kwargs` when using\n        `typing.ParamSpec`.\n        \"\"\"\n        ret = await self._transformer(\n            # TransformerMetadata\n            self._meta(),\n            # Callable[[], Awaitable[IT]] | Callable[[], IT]\n            self._value_fn,\n            # P\n            *self._params.args,\n            **self._params.kwargs,\n        )\n        return ret",
  "class OutputRendererSync(OutputRenderer[OT]):\n    \"\"\"\n    Output Renderer (Synchronous)\n\n    This class is used to define a synchronous renderer. The `.__call__` method is\n    implemented to call the `._run` method synchronously.\n\n    See Also\n    --------\n    * :class:`~shiny.render.transformer.OutputRenderer`\n    * :class:`~shiny.render.transformer.OutputRendererAsync`\n    \"\"\"\n\n    def __init__(\n        self,\n        value_fn: ValueFnSync[IT],\n        transform_fn: TransformFn[IT, P, OT],\n        params: TransformerParams[P],\n    ) -> None:\n        if is_async_callable(value_fn):\n            raise TypeError(\n                self.__class__.__name__ + \" requires a synchronous render function\"\n            )\n        # super == Renderer\n        super().__init__(\n            value_fn=value_fn,\n            transform_fn=transform_fn,\n            params=params,\n        )\n\n    def __call__(self) -> OT:\n        \"\"\"\n        Synchronously executes the output renderer as a function.\n        \"\"\"\n        return _utils.run_coro_sync(self._run())",
  "class OutputRendererAsync(OutputRenderer[OT]):\n    \"\"\"\n    Output Renderer (Asynchronous)\n\n    This class is used to define an asynchronous renderer. The `.__call__` method is\n    implemented to call the `._run` method asynchronously.\n\n    See Also\n    --------\n    * :class:`~shiny.render.transformer.OutputRenderer`\n    * :class:`~shiny.render.transformer.OutputRendererSync`\n    \"\"\"\n\n    def __init__(\n        self,\n        value_fn: ValueFnAsync[IT],\n        transform_fn: TransformFn[IT, P, OT],\n        params: TransformerParams[P],\n    ) -> None:\n        if not is_async_callable(value_fn):\n            raise TypeError(\n                self.__class__.__name__ + \" requires an asynchronous render function\"\n            )\n        # super == Renderer\n        super().__init__(\n            value_fn=value_fn,\n            transform_fn=transform_fn,\n            params=params,\n        )\n\n    async def __call__(self) -> OT:  # pyright: ignore[reportIncompatibleMethodOverride]\n        \"\"\"\n        Asynchronously executes the output renderer as a function.\n        \"\"\"\n        return await self._run()",
  "def _assert_transformer(transform_fn: TransformFn[IT, P, OT]) -> None:\n    params = inspect.Signature.from_callable(transform_fn).parameters\n\n    if len(params) < 2:\n        raise TypeError(\n            \"`transformer=` must have 2 positional parameters which have type \"\n            \"`TransformerMetadata` and `RenderFnAsync` respectively\"\n        )\n\n    for i, param in zip(range(len(params)), params.values()):\n        # # Not a good test as `param.annotation` has type `str` and the type could\n        # # have been renamed. We need to do an `isinstance` check but do not have\n        # # access to the objects\n        # if i == 0:\n        #     assert param.annotation == \"TransformerMetadata\"\n        # if i == 1:\n        #     assert (param.annotation or \"\").startswith(\"RenderFnAsync\")\n        if i < 2 and not (\n            param.kind == inspect.Parameter.POSITIONAL_OR_KEYWORD\n            or param.kind == inspect.Parameter.POSITIONAL_ONLY\n        ):\n            raise TypeError(\n                \"`transformer=` must have 2 positional parameters which have type \"\n                \"`TransformerMetadata` and `RenderFnAsync` respectively\"\n            )\n\n        # Make sure there are no more than 2 positional args\n        if i >= 2 and param.kind == inspect.Parameter.POSITIONAL_OR_KEYWORD:\n            raise TypeError(\n                \"`transformer=` must not contain more than 2 positional parameters\"\n            )\n        # Make sure there are no `*args`\n        if param.kind == inspect.Parameter.VAR_POSITIONAL:\n            raise TypeError(\n                \"No variadic positional parameters (e.g. `*args`) can be supplied to \"\n                f\"`transformer=`. Received: `{param.name}`. Please only use `*`.\"\n            )\n        # Make sure kwargs have default values\n        if (\n            param.kind == inspect.Parameter.KEYWORD_ONLY\n            and param.default is inspect.Parameter.empty\n        ):\n            raise TypeError(\n                f\"In `transformer=`, parameter `{param.name}` did not have a default value\"\n            )",
  "class OutputTransformer(Generic[IT, OT, P]):\n    \"\"\"\n    Output Transformer class\n\n    This class creates helper types and methods for defining an overloaded renderer\n    decorator. By manually defining the overloads locally, the function signatures are\n    as clean as possible (and therefore easier to read and understand).\n\n    When called, an `OutputTransfomer` takes the value returned from the app-supplied\n    output value function and any app-supplied paramters and passes them through the\n    component author's transformer function, and returns the transformed result.\n\n    Attributes\n    ----------\n    ValueFn\n        The function type for the app-supplied output value function. This function may\n        be both synchronous or asynchronous.\n    OutputRenderer\n        The return type for the overload that accepts the app-supplied output value\n        function and returns an object of\n        :class:`~shiny.render.transformer.OutputRenderer`.\n    OutputRendererDecorator\n        The return type for the overload that accepts app-supplied parameters for the\n        transform function. The return value is a decorator that accepts the\n        app-supplied output value function and returns an object of\n        :class:`~shiny.render.transformer.OutputRenderer`.\n\n    See Also\n    --------\n    * :func:`~shiny.render.transformer.output_transformer`\n    * :class:`~shiny.render.transformer.TransformerParams`\n    * :class:`~shiny.render.transformer.OutputRenderer`\n    \"\"\"\n\n    def params(\n        self,\n        *args: P.args,\n        **kwargs: P.kwargs,\n    ) -> TransformerParams[P]:\n        return TransformerParams(*args, **kwargs)\n\n    def __call__(\n        self,\n        value_fn: ValueFn[IT] | None,\n        params: TransformerParams[P] | None = None,\n    ) -> OutputRenderer[OT] | OutputRendererDecorator[IT, OT]:\n        if params is None:\n            params = self.params()\n        if not isinstance(params, TransformerParams):\n            raise TypeError(\n                \"Expected `params` to be of type `TransformerParams` but received \"\n                f\"`{type(params)}`. Please use `.params()` to create a \"\n                \"`TransformerParams` object.\"\n            )\n        return self._fn(value_fn, params)\n\n    def __init__(\n        self,\n        fn: OutputTransformerFn[IT, P, OT],\n    ) -> None:\n        self._fn = fn\n        self.ValueFn = ValueFn[IT]\n        self.OutputRenderer = OutputRenderer[OT]\n        self.OutputRendererDecorator = OutputRendererDecorator[IT, OT]",
  "def output_transformer(\n    transform_fn: TransformFn[IT, P, OT],\n) -> OutputTransformer[IT, OT, P]:\n    \"\"\"\n    Output transformer decorator\n\n    This decorator method is a convenience method to generate the appropriate types and\n    internal implementation for an overloaded renderer method. This method will provide\n    you with all the necessary types to define two different overloads: one for when the\n    decorator is called without parentheses and another for when it is called with\n    parentheses where app authors can pass in parameters to the renderer.\n\n    Transform function\n    ------------------\n\n    The output renderer's transform function (`transform_fn`) is the key building block\n    for `output_transformer`. It is a package author function that calls the app-defined\n    output value function (`value_fn`) transforms the result of type `IT` into type\n    `OT`.\n\n    The transform function is supplied meta output information, the (app-supplied) value\n    function, and any keyword arguments supplied to the output tranformer decorator:\n\n    * The first parameter to the handler function has the class\n      :class:`~shiny.render.transformer.TransformerMetadata` and is typically called\n      `_meta`. This information gives context the to the handler while trying to\n      resolve the app-supplied value function (typically called `_fn`).\n    * The second parameter is the app-defined output value function (e.g. `_fn`). It's\n      return type (`IT`) determines what types can be returned by the app-supplied\n      output value function. For example, if `_fn` has the type `ValueFn[str | None]`,\n      both the `str` and `None` types are allowed to be returned from the app-supplied\n      output value function.\n    * The remaining parameters are the keyword arguments (e.g. `alt:Optional[str] =\n      None` or `**kwargs: object`) that app authors may supply to the renderer (when the\n      renderer decorator is called with parentheses). Variadic positional parameters\n      (e.g. `*args`) are not allowed. All keyword arguments should have a type and\n      default value. No default value is needed for keyword arguments that are passed\n      through (e.g. `**kwargs: Any`).\n\n    The tranform function's return type (`OT`) determines the output type of the\n    :class:`~shiny.render.transformer.OutputRenderer`. Note that in many cases (but not\n    all!) `IT` and `OT` will be the same. The `None` type should typically be defined in\n    both `IT` and `OT`. If `IT` allows for `None` values, it (typically) signals that\n    nothing should be rendered. If `OT` allows for `None` and returns a `None` value,\n    shiny will not render the output.\n\n    Notes\n    -----\n\n    * When defining the renderer decorator overloads, if you have extra parameters of\n      `**kwargs: object`, you may get a type error about incompatible signatures. To fix\n      this, you can use `**kwargs: Any` instead or add `_fn: None = None` as the first\n      parameter in the overload containing the `**kwargs: object`.\n\n    * The `transform_fn` should be defined as an asynchronous function but should only\n      asynchronously yield (i.e. use `await` syntax) when the value function (the second\n      parameter of type `ValueFn[IT]`) is awaitable. If the value function is not\n      awaitable (i.e. it is a _synchronous_ function), then the execution of the\n      transform function should also be synchronous.\n\n\n    Parameters\n    ----------\n    transform_fn\n        Asynchronous function used to determine the app-supplied output value function\n        return type (`IT`), the transformed type (`OT`), and the keyword arguments (`P`)\n        app authors can supply to the renderer decorator.\n\n    Returns\n    -------\n    :\n        An :class:`~shiny.render.transformer.OutputTransformer` object that can be used to\n        define two overloads for your renderer function. One overload is for when the\n        renderer is called without parentheses and the other is for when the renderer is\n        called with parentheses.\n    \"\"\"\n    _assert_transformer(transform_fn)\n\n    def renderer_decorator(\n        value_fn: ValueFn[IT] | None,\n        params: TransformerParams[P],\n    ) -> OutputRenderer[OT] | OutputRendererDecorator[IT, OT]:\n        def as_value_fn(\n            fn: ValueFn[IT],\n        ) -> OutputRenderer[OT]:\n            if is_async_callable(fn):\n                return OutputRendererAsync(fn, transform_fn, params)\n            else:\n                # To avoid duplicate work just for a typeguard, we cast the function\n                fn = cast(ValueFnSync[IT], fn)\n                return OutputRendererSync(fn, transform_fn, params)\n\n        if value_fn is None:\n            return as_value_fn\n        val = as_value_fn(value_fn)\n        return val\n\n    return OutputTransformer(renderer_decorator)",
  "async def resolve_value_fn(value_fn: ValueFn[IT]) -> IT:\n    \"\"\"\n    Resolve the value function\n\n    This function is used to resolve the value function (`value_fn`) to an object of\n    type `IT`. If the value function is asynchronous, it will be awaited. If the value\n    function is synchronous, it will be called.\n\n    While always using an async method within an output transform function is not\n    appropriate, this method may be safely used to avoid boilerplate.\n\n    Replace this:\n    ```python\n    if is_async_callable(_fn):\n        x = await _fn()\n    else:\n        x = cast(ValueFnSync[IT], _fn)()\n    ```\n\n    With this:\n    ```python\n    x = await resolve_value_fn(_fn)\n    ```\n\n    This code substitution is safe as the implementation does not _actually_\n    asynchronously yield to another process if the `value_fn` is synchronous. The\n    `__call__` method of the :class:`~shiny.render.transformer.OutputRendererSync` is\n    built to execute asynchronously defined methods that execute synchronously.\n\n    Parameters\n    ----------\n    value_fn\n        App-supplied output value function which returns type `IT`. This function can be\n        synchronous or asynchronous.\n\n    Returns\n    -------\n    :\n        The resolved value from `value_fn`.\n    \"\"\"\n    if is_async_callable(value_fn):\n        return await value_fn()\n    else:\n        # To avoid duplicate work just for a typeguard, we cast the function\n        value_fn = cast(ValueFnSync[IT], value_fn)\n        return value_fn()",
  "def __init__(self, *args: P.args, **kwargs: P.kwargs) -> None:\n        \"\"\"\n        Parameters\n        ----------\n        *args\n            No positional arguments should be supplied. Only keyword arguments should be\n            supplied. (`*args` is required when using :class:`~typing.ParamSpec` even if\n            transformer is only leveraging `**kwargs`.)\n        **kwargs\n            Keyword arguments for the corresponding renderer function.\n        \"\"\"\n\n        # Make sure there no `args` at run time!\n        # This check is related to `_assert_transform_fn` not accepting any `args`\n        if len(args) > 0:\n            raise RuntimeError(\"`args` should not be supplied\")\n\n        # `*args` must be defined with `**kwargs` (as per PEP612)\n        # (even when expanded later when calling the transform function)\n        # We need to store (and later retrieve) them, even if we know they are empty\n        self.args = args\n        self.kwargs = kwargs",
  "def empty_params() -> TransformerParams[P]:\n        \"\"\"\n        Return `TransformerParams` definition with no parameters.\n        \"\"\"\n\n        def inner(*args: P.args, **kwargs: P.kwargs) -> TransformerParams[P]:\n            return TransformerParams[P](*args, **kwargs)\n\n        return inner()",
  "def __call__(self) -> OT:\n        \"\"\"\n        Executes the output renderer as a function. Must be implemented by subclasses.\n        \"\"\"\n        ...",
  "def __init__(\n        self,\n        *,\n        value_fn: ValueFn[IT],\n        transform_fn: TransformFn[IT, P, OT],\n        params: TransformerParams[P],\n    ) -> None:\n        \"\"\"\n        Parameters\n        ----------\n        value_fn\n            App-provided output value function. It should return an object of type `IT`.\n        transform_fn\n            Package author function that transforms an object of type `IT` into type\n            `OT`. The `params` will used as variadic keyword arguments. This method\n            should only use `await` syntax when the value function (`ValueFn[IT]`) is\n            awaitable. If the value function is not awaitable (a _synchronous_\n            function), then the function should execute synchronously.\n        params\n            App-provided parameters for the transform function (`transform_fn`).\n\n        \"\"\"\n\n        # Copy over function name as it is consistent with how Session and Output\n        # retrieve function names\n        self.__name__ = value_fn.__name__\n\n        if not is_async_callable(transform_fn):\n            raise TypeError(\n                self.__class__.__name__\n                + \" requires an async tranformer function (`transform_fn`)\"\n            )\n\n        self._value_fn = value_fn\n        self._transformer = transform_fn\n        self._params = params",
  "def _set_metadata(self, session: Session, name: str) -> None:\n        \"\"\"\n        When `Renderer`s are assigned to Output object slots, this method is used to\n        pass along Session and name information.\n        \"\"\"\n        self._session: Session = session\n        self._name: str = name",
  "def _meta(self) -> TransformerMetadata:\n        \"\"\"\n        Returns a named tuple of values: `session` (the :class:`~shiny.Session` object),\n        and `name` (the name of the output being rendered)\n        \"\"\"\n        return TransformerMetadata(\n            session=self._session,\n            name=self._name,\n        )",
  "async def _run(self) -> OT:\n        \"\"\"\n        Executes the (async) tranform function\n\n        The transform function will receive the following arguments: meta information of\n        type :class:`~shiny.render.transformer.TransformerMetadata`, an app-defined\n        render function of type :class:`~shiny.render.RenderFnAsync`, and `*args` and\n        `**kwargs` of type `P`.\n\n        Note: `*args` will always be empty as it is an expansion of\n        :class:`~shiny.render.transformer.TransformerParams` which does not allow positional arguments.\n        `*args` is required to use with `**kwargs` when using\n        `typing.ParamSpec`.\n        \"\"\"\n        ret = await self._transformer(\n            # TransformerMetadata\n            self._meta(),\n            # Callable[[], Awaitable[IT]] | Callable[[], IT]\n            self._value_fn,\n            # P\n            *self._params.args,\n            **self._params.kwargs,\n        )\n        return ret",
  "def __init__(\n        self,\n        value_fn: ValueFnSync[IT],\n        transform_fn: TransformFn[IT, P, OT],\n        params: TransformerParams[P],\n    ) -> None:\n        if is_async_callable(value_fn):\n            raise TypeError(\n                self.__class__.__name__ + \" requires a synchronous render function\"\n            )\n        # super == Renderer\n        super().__init__(\n            value_fn=value_fn,\n            transform_fn=transform_fn,\n            params=params,\n        )",
  "def __call__(self) -> OT:\n        \"\"\"\n        Synchronously executes the output renderer as a function.\n        \"\"\"\n        return _utils.run_coro_sync(self._run())",
  "def __init__(\n        self,\n        value_fn: ValueFnAsync[IT],\n        transform_fn: TransformFn[IT, P, OT],\n        params: TransformerParams[P],\n    ) -> None:\n        if not is_async_callable(value_fn):\n            raise TypeError(\n                self.__class__.__name__ + \" requires an asynchronous render function\"\n            )\n        # super == Renderer\n        super().__init__(\n            value_fn=value_fn,\n            transform_fn=transform_fn,\n            params=params,\n        )",
  "async def __call__(self) -> OT:  # pyright: ignore[reportIncompatibleMethodOverride]\n        \"\"\"\n        Asynchronously executes the output renderer as a function.\n        \"\"\"\n        return await self._run()",
  "def params(\n        self,\n        *args: P.args,\n        **kwargs: P.kwargs,\n    ) -> TransformerParams[P]:\n        return TransformerParams(*args, **kwargs)",
  "def __call__(\n        self,\n        value_fn: ValueFn[IT] | None,\n        params: TransformerParams[P] | None = None,\n    ) -> OutputRenderer[OT] | OutputRendererDecorator[IT, OT]:\n        if params is None:\n            params = self.params()\n        if not isinstance(params, TransformerParams):\n            raise TypeError(\n                \"Expected `params` to be of type `TransformerParams` but received \"\n                f\"`{type(params)}`. Please use `.params()` to create a \"\n                \"`TransformerParams` object.\"\n            )\n        return self._fn(value_fn, params)",
  "def __init__(\n        self,\n        fn: OutputTransformerFn[IT, P, OT],\n    ) -> None:\n        self._fn = fn\n        self.ValueFn = ValueFn[IT]\n        self.OutputRenderer = OutputRenderer[OT]\n        self.OutputRendererDecorator = OutputRendererDecorator[IT, OT]",
  "def renderer_decorator(\n        value_fn: ValueFn[IT] | None,\n        params: TransformerParams[P],\n    ) -> OutputRenderer[OT] | OutputRendererDecorator[IT, OT]:\n        def as_value_fn(\n            fn: ValueFn[IT],\n        ) -> OutputRenderer[OT]:\n            if is_async_callable(fn):\n                return OutputRendererAsync(fn, transform_fn, params)\n            else:\n                # To avoid duplicate work just for a typeguard, we cast the function\n                fn = cast(ValueFnSync[IT], fn)\n                return OutputRendererSync(fn, transform_fn, params)\n\n        if value_fn is None:\n            return as_value_fn\n        val = as_value_fn(value_fn)\n        return val",
  "def inner(*args: P.args, **kwargs: P.kwargs) -> TransformerParams[P]:\n            return TransformerParams[P](*args, **kwargs)",
  "def as_value_fn(\n            fn: ValueFn[IT],\n        ) -> OutputRenderer[OT]:\n            if is_async_callable(fn):\n                return OutputRendererAsync(fn, transform_fn, params)\n            else:\n                # To avoid duplicate work just for a typeguard, we cast the function\n                fn = cast(ValueFnSync[IT], fn)\n                return OutputRendererSync(fn, transform_fn, params)"
]