[
  "class PythonLogo(Widget):\n    _sizing = frozenset([Sizing.FIXED])\n\n    def __init__(self) -> None:\n        \"\"\"\n        Create canvas containing an ASCII version of the Python\n        Logo and store it.\n        \"\"\"\n        blu = AttrSpec(\"light blue\", \"default\")\n        yel = AttrSpec(\"yellow\", \"default\")\n        width = 17\n        # fmt: off\n        self._canvas = Text(\n            [\n                (blu, \"     ______\\n\"),\n                (blu, \"   _|_o__  |\"), (yel, \"__\\n\"),\n                (blu, \"  |   _____|\"), (yel, \"  |\\n\"),\n                (blu, \"  |__|  \"), (yel, \"______|\\n\"),\n                (yel, \"     |____o_|\"),\n            ]\n        ).render((width,))\n        # fmt: on\n\n    def pack(self, size=None, focus: bool = False):\n        \"\"\"\n        Return the size from our pre-rendered canvas.\n        \"\"\"\n        return self._canvas.cols(), self._canvas.rows()\n\n    def render(self, size, focus: bool = False):\n        \"\"\"\n        Return the pre-rendered canvas.\n        \"\"\"\n        fixed_size(size)\n        return self._canvas",
  "def _test():\n    import doctest\n\n    doctest.testmod()",
  "def __init__(self) -> None:\n        \"\"\"\n        Create canvas containing an ASCII version of the Python\n        Logo and store it.\n        \"\"\"\n        blu = AttrSpec(\"light blue\", \"default\")\n        yel = AttrSpec(\"yellow\", \"default\")\n        width = 17\n        # fmt: off\n        self._canvas = Text(\n            [\n                (blu, \"     ______\\n\"),\n                (blu, \"   _|_o__  |\"), (yel, \"__\\n\"),\n                (blu, \"  |   _____|\"), (yel, \"  |\\n\"),\n                (blu, \"  |__|  \"), (yel, \"______|\\n\"),\n                (yel, \"     |____o_|\"),\n            ]\n        ).render((width,))",
  "def pack(self, size=None, focus: bool = False):\n        \"\"\"\n        Return the size from our pre-rendered canvas.\n        \"\"\"\n        return self._canvas.cols(), self._canvas.rows()",
  "def render(self, size, focus: bool = False):\n        \"\"\"\n        Return the pre-rendered canvas.\n        \"\"\"\n        fixed_size(size)\n        return self._canvas",
  "def detect_encoding() -> str:\n    # Try to determine if using a supported double-byte encoding\n    import locale\n\n    no_set_locale = locale.getpreferredencoding(False)\n\n    if no_set_locale != \"ascii\":\n        # ascii is fallback locale in case of detect failed\n\n        return no_set_locale\n\n    # Use actual `getpreferredencoding` with public API only\n    old_loc = locale.setlocale(locale.LC_CTYPE)  # == getlocale, but not mangle data\n    try:\n        try:\n            locale.setlocale(locale.LC_CTYPE, \"\")\n        except locale.Error:\n            pass\n        # internally call private `_get_locale_encoding`\n        return locale.getpreferredencoding(False)\n    finally:\n        try:\n            locale.setlocale(locale.LC_CTYPE, old_loc)\n        except locale.Error:\n            pass",
  "def set_encoding( encoding ):\n    \"\"\"\n    Set the byte encoding to assume when processing strings and the\n    encoding to use when converting unicode strings.\n    \"\"\"\n    encoding = encoding.lower()\n\n    global _target_encoding, _use_dec_special\n\n    if encoding in ( 'utf-8', 'utf8', 'utf' ):\n        str_util.set_byte_encoding(\"utf8\")\n\n        _use_dec_special = False\n    elif encoding in ( 'euc-jp' # JISX 0208 only\n            , 'euc-kr', 'euc-cn', 'euc-tw' # CNS 11643 plain 1 only\n            , 'gb2312', 'gbk', 'big5', 'cn-gb', 'uhc'\n            # these shouldn't happen, should they?\n            , 'eucjp', 'euckr', 'euccn', 'euctw', 'cncb' ):\n        str_util.set_byte_encoding(\"wide\")\n\n        _use_dec_special = True\n    else:\n        str_util.set_byte_encoding(\"narrow\")\n        _use_dec_special = True\n\n    # if encoding is valid for conversion from unicode, remember it\n    _target_encoding = 'ascii'\n    try:\n        if encoding:\n            \"\".encode(encoding)\n            _target_encoding = encoding\n    except LookupError: pass",
  "def get_encoding_mode():\n    \"\"\"\n    Get the mode Urwid is using when processing text strings.\n    Returns 'narrow' for 8-bit encodings, 'wide' for CJK encodings\n    or 'utf8' for UTF-8 encodings.\n    \"\"\"\n    return str_util.get_byte_encoding()",
  "def apply_target_encoding(s: str | bytes):\n    \"\"\"\n    Return (encoded byte string, character set rle).\n    \"\"\"\n    if _use_dec_special and isinstance(s, str):\n        # first convert drawing characters\n        s = s.translate(escape.DEC_SPECIAL_CHARMAP)\n\n    if isinstance(s, str):\n        s = s.replace(escape.SI+escape.SO, \"\") # remove redundant shifts\n        s = codecs.encode(s, _target_encoding, 'replace')\n\n    assert isinstance(s, bytes)\n    SO = escape.SO.encode('ascii')\n    SI = escape.SI.encode('ascii')\n\n    sis = s.split(SO)\n\n    assert isinstance(sis[0], bytes)\n\n    sis0 = sis[0].replace(SI, b'')\n    sout = []\n    cout = []\n    if sis0:\n        sout.append( sis0 )\n        cout.append( (None,len(sis0)) )\n\n    if len(sis)==1:\n        return sis0, cout\n\n    for sn in sis[1:]:\n        assert isinstance(sn, bytes)\n        assert isinstance(SI, bytes)\n        sl = sn.split(SI, 1)\n        if len(sl) == 1:\n            sin = sl[0]\n            assert isinstance(sin, bytes)\n            sout.append(sin)\n            rle_append_modify(cout, (escape.DEC_TAG, len(sin)))\n            continue\n        sin, son = sl\n        son = son.replace(SI, b'')\n        if sin:\n            sout.append(sin)\n            rle_append_modify(cout, (escape.DEC_TAG, len(sin)))\n        if son:\n            sout.append(son)\n            rle_append_modify(cout, (None, len(son)))\n\n    outstr = b''.join(sout)\n    return outstr, cout",
  "def supports_unicode():\n    \"\"\"\n    Return True if python is able to convert non-ascii unicode strings\n    to the current encoding.\n    \"\"\"\n    return _target_encoding and _target_encoding != 'ascii'",
  "def calc_trim_text( text, start_offs: int, end_offs: int, start_col: int, end_col: int):\n    \"\"\"\n    Calculate the result of trimming text.\n    start_offs -- offset into text to treat as screen column 0\n    end_offs -- offset into text to treat as the end of the line\n    start_col -- screen column to trim at the left\n    end_col -- screen column to trim at the right\n\n    Returns (start, end, pad_left, pad_right), where:\n    start -- resulting start offset\n    end -- resulting end offset\n    pad_left -- 0 for no pad or 1 for one space to be added\n    pad_right -- 0 for no pad or 1 for one space to be added\n    \"\"\"\n    spos = start_offs\n    pad_left = pad_right = 0\n    if start_col > 0:\n        spos, sc = calc_text_pos( text, spos, end_offs, start_col )\n        if sc < start_col:\n            pad_left = 1\n            spos, sc = calc_text_pos( text, start_offs,\n                end_offs, start_col+1 )\n    run = end_col - start_col - pad_left\n    pos, sc = calc_text_pos( text, spos, end_offs, run )\n    if sc < run:\n        pad_right = 1\n    return ( spos, pos, pad_left, pad_right )",
  "def trim_text_attr_cs(text, attr, cs, start_col: int, end_col: int):\n    \"\"\"\n    Return ( trimmed text, trimmed attr, trimmed cs ).\n    \"\"\"\n    spos, epos, pad_left, pad_right = calc_trim_text(text, 0, len(text), start_col, end_col )\n    attrtr = rle_subseg( attr, spos, epos )\n    cstr = rle_subseg( cs, spos, epos )\n    if pad_left:\n        al = rle_get_at( attr, spos-1 )\n        rle_prepend_modify( attrtr, (al, 1) )\n        rle_prepend_modify( cstr, (None, 1) )\n    if pad_right:\n        al = rle_get_at( attr, epos )\n        rle_append_modify( attrtr, (al, 1) )\n        rle_append_modify( cstr, (None, 1) )\n\n    return (b''.rjust(pad_left) + text[spos:epos] +\n        b''.rjust(pad_right), attrtr, cstr)",
  "def rle_get_at(rle, pos: int):\n    \"\"\"\n    Return the attribute at offset pos.\n    \"\"\"\n    x = 0\n    if pos < 0:\n        return None\n    for a, run in rle:\n        if x+run > pos:\n            return a\n        x += run\n    return None",
  "def rle_subseg(rle, start: int, end: int):\n    \"\"\"Return a sub segment of an rle list.\"\"\"\n    l = []\n    x = 0\n    for a, run in rle:\n        if start:\n            if start >= run:\n                start -= run\n                x += run\n                continue\n            x += start\n            run -= start\n            start = 0\n        if x >= end:\n            break\n        if x+run > end:\n            run = end-x\n        x += run\n        l.append( (a, run) )\n    return l",
  "def rle_len(rle) -> int:\n    \"\"\"\n    Return the number of characters covered by a run length\n    encoded attribute list.\n    \"\"\"\n\n    run = 0\n    for v in rle:\n        assert isinstance(v, tuple), repr(rle)\n        a, r = v\n        run += r\n    return run",
  "def rle_prepend_modify(rle, a_r) -> None:\n    \"\"\"\n    Append (a, r) (unpacked from *a_r*) to BEGINNING of rle.\n    Merge with first run when possible\n\n    MODIFIES rle parameter contents. Returns None.\n    \"\"\"\n    a, r = a_r\n    if not rle:\n        rle[:] = [(a, r)]\n    else:\n        al, run = rle[0]\n        if a == al:\n            rle[0] = (a,run+r)\n        else:\n            rle[0:0] = [(a, r)]",
  "def rle_append_modify(rle, a_r):\n    \"\"\"\n    Append (a, r) (unpacked from *a_r*) to the rle list rle.\n    Merge with last run when possible.\n\n    MODIFIES rle parameter contents. Returns None.\n    \"\"\"\n    a, r = a_r\n    if not rle or rle[-1][0] != a:\n        rle.append( (a,r) )\n        return\n    la,lr = rle[-1]\n    rle[-1] = (a, lr+r)",
  "def rle_join_modify( rle, rle2 ):\n    \"\"\"\n    Append attribute list rle2 to rle.\n    Merge last run of rle with first run of rle2 when possible.\n\n    MODIFIES attr parameter contents. Returns None.\n    \"\"\"\n    if not rle2:\n        return\n    rle_append_modify(rle, rle2[0])\n    rle += rle2[1:]",
  "def rle_product( rle1, rle2 ):\n    \"\"\"\n    Merge the runs of rle1 and rle2 like this:\n    eg.\n    rle1 = [ (\"a\", 10), (\"b\", 5) ]\n    rle2 = [ (\"Q\", 5), (\"P\", 10) ]\n    rle_product: [ ((\"a\",\"Q\"), 5), ((\"a\",\"P\"), 5), ((\"b\",\"P\"), 5) ]\n\n    rle1 and rle2 are assumed to cover the same total run.\n    \"\"\"\n    i1 = i2 = 1 # rle1, rle2 indexes\n    if not rle1 or not rle2: return []\n    a1, r1 = rle1[0]\n    a2, r2 = rle2[0]\n\n    l = []\n    while r1 and r2:\n        r = min(r1, r2)\n        rle_append_modify( l, ((a1,a2),r) )\n        r1 -= r\n        if r1 == 0 and i1< len(rle1):\n            a1, r1 = rle1[i1]\n            i1 += 1\n        r2 -= r\n        if r2 == 0 and i2< len(rle2):\n            a2, r2 = rle2[i2]\n            i2 += 1\n    return l",
  "def rle_factor( rle ):\n    \"\"\"\n    Inverse of rle_product.\n    \"\"\"\n    rle1 = []\n    rle2 = []\n    for (a1, a2), r in rle:\n        rle_append_modify( rle1, (a1, r) )\n        rle_append_modify( rle2, (a2, r) )\n    return rle1, rle2",
  "class TagMarkupException(Exception): pass",
  "def decompose_tagmarkup(tm):\n    \"\"\"Return (text string, attribute list) for tagmarkup passed.\"\"\"\n\n    tl, al = _tagmarkup_recurse(tm, None)\n    # join as unicode or bytes based on type of first element\n    if tl:\n        text = tl[0][:0].join(tl)\n    else:\n        text = \"\"\n\n    if al and al[-1][0] is None:\n        del al[-1]\n\n    return text, al",
  "def _tagmarkup_recurse(tm, attr):\n    \"\"\"Return (text list, attribute list) for tagmarkup passed.\n\n    tm -- tagmarkup\n    attr -- current attribute or None\"\"\"\n\n    if isinstance(tm, list):\n        # for lists recurse to process each subelement\n        rtl = []\n        ral = []\n        for element in tm:\n            tl, al = _tagmarkup_recurse(element, attr)\n            if ral:\n                # merge attributes when possible\n                last_attr, last_run = ral[-1]\n                top_attr, top_run = al[0]\n                if last_attr == top_attr:\n                    ral[-1] = (top_attr, last_run + top_run)\n                    del al[0]\n            rtl += tl\n            ral += al\n        return rtl, ral\n\n    if isinstance(tm, tuple):\n        # tuples mark a new attribute boundary\n        if len(tm) != 2:\n            raise TagMarkupException(f\"Tuples must be in the form (attribute, tagmarkup): {tm!r}\")\n\n        attr, element = tm\n        return _tagmarkup_recurse( element, attr )\n\n    if not isinstance(tm, (str, bytes)):\n        raise TagMarkupException(f\"Invalid markup element: {tm!r}\")\n\n    # text\n    return [tm], [(attr, len(tm))]",
  "def is_mouse_event(ev: tuple[str, int, int, int] | typing.Any) -> bool:\n    return isinstance(ev, tuple) and len(ev) == 4 and \"mouse\" in ev[0]",
  "def is_mouse_press(ev: str) -> bool:\n    return \"press\" in ev",
  "class MetaSuper(type):\n    \"\"\"adding .__super\"\"\"\n    def __init__(cls, name: str, bases, d):\n        super().__init__(name, bases, d)\n        if hasattr(cls, f\"_{name}__super\"):\n            raise AttributeError(\"Class has same name as one of its super classes\")\n\n        @property\n        def _super(self):\n            warnings.warn(\n                f\"`{name}.__super` was a deprecated feature for old python versions.\"\n                f\"Please use `super()` call instead.\",\n                DeprecationWarning,\n                stacklevel=3,\n            )\n            return super(cls, self)\n        setattr(cls, f\"_{name}__super\", _super)",
  "def int_scale(val: int, val_range: int, out_range: int):\n    \"\"\"\n    Scale val in the range [0, val_range-1] to an integer in the range\n    [0, out_range-1].  This implementation uses the \"round-half-up\" rounding\n    method.\n\n    >>> \"%x\" % int_scale(0x7, 0x10, 0x10000)\n    '7777'\n    >>> \"%x\" % int_scale(0x5f, 0x100, 0x10)\n    '6'\n    >>> int_scale(2, 6, 101)\n    40\n    >>> int_scale(1, 3, 4)\n    2\n    \"\"\"\n    num = int(val * (out_range-1) * 2 + (val_range-1))\n    dem = ((val_range-1) * 2)\n    # if num % dem == 0 then we are exactly half-way and have rounded up.\n    return num // dem",
  "class StoppingContext:\n    \"\"\"Context manager that calls ``stop`` on a given object on exit.  Used to\n    make the ``start`` method on `MainLoop` and `BaseScreen` optionally act as\n    context managers.\n    \"\"\"\n    def __init__(self, wrapped):\n        self._wrapped = wrapped\n\n    def __enter__(self) -> Self:\n        return self\n\n    def __exit__(self, *exc_info):\n        self._wrapped.stop()",
  "def __init__(cls, name: str, bases, d):\n        super().__init__(name, bases, d)\n        if hasattr(cls, f\"_{name}__super\"):\n            raise AttributeError(\"Class has same name as one of its super classes\")\n\n        @property\n        def _super(self):\n            warnings.warn(\n                f\"`{name}.__super` was a deprecated feature for old python versions.\"\n                f\"Please use `super()` call instead.\",\n                DeprecationWarning,\n                stacklevel=3,\n            )\n            return super(cls, self)\n        setattr(cls, f\"_{name}__super\", _super)",
  "def __init__(self, wrapped):\n        self._wrapped = wrapped",
  "def __enter__(self) -> Self:\n        return self",
  "def __exit__(self, *exc_info):\n        self._wrapped.stop()",
  "def _super(self):\n            warnings.warn(\n                f\"`{name}.__super` was a deprecated feature for old python versions.\"\n                f\"Please use `super()` call instead.\",\n                DeprecationWarning,\n                stacklevel=3,\n            )\n            return super(cls, self)",
  "class TextLayout:\n    def supports_align_mode(self, align):\n        \"\"\"Return True if align is a supported align mode.\"\"\"\n        return True\n\n    def supports_wrap_mode(self, wrap):\n        \"\"\"Return True if wrap is a supported wrap mode.\"\"\"\n        return True\n\n    def layout(self, text, width, align, wrap ):\n        \"\"\"\n        Return a layout structure for text.\n\n        :param text: string in current encoding or unicode string\n        :param width: number of screen columns available\n        :param align: align mode for text\n        :param wrap: wrap mode for text\n\n        Layout structure is a list of line layouts, one per output line.\n        Line layouts are lists than may contain the following tuples:\n\n        * (column width of text segment, start offset, end offset)\n        * (number of space characters to insert, offset or None)\n        * (column width of insert text, offset, \"insert text\")\n\n        The offset in the last two tuples is used to determine the\n        attribute used for the inserted spaces or text respectively.\n        The attribute used will be the same as the attribute at that\n        text offset.  If the offset is None when inserting spaces\n        then no attribute will be used.\n        \"\"\"\n        raise NotImplementedError(\n            \"This function must be overridden by a real text layout class. (see StandardTextLayout)\"\n        )",
  "class CanNotDisplayText(Exception):\n    pass",
  "class StandardTextLayout(TextLayout):\n    def __init__(self):#, tab_stops=(), tab_stop_every=8):\n        pass\n        #\"\"\"\n        #tab_stops -- list of screen column indexes for tab stops\n        #tab_stop_every -- repeated interval for following tab stops\n        #\"\"\"\n        #assert tab_stop_every is None or type(tab_stop_every)==int\n        #if not tab_stops and tab_stop_every:\n        #    self.tab_stops = (tab_stop_every,)\n        #self.tab_stops = tab_stops\n        #self.tab_stop_every = tab_stop_every\n\n    def supports_align_mode(self, align: str) -> bool:\n        \"\"\"Return True if align is 'left', 'center' or 'right'.\"\"\"\n        return align in ('left', 'center', 'right')\n\n    def supports_wrap_mode(self, wrap: str) -> bool:\n        \"\"\"Return True if wrap is 'any', 'space', 'clip' or 'ellipsis'.\"\"\"\n        return wrap in ('any', 'space', 'clip', 'ellipsis')\n\n    def layout(\n        self,\n        text,\n        width: int,\n        align: Literal['left', 'center', 'right'],\n        wrap: Literal['any', 'space', 'clip', 'ellipsis'],\n    ):\n        \"\"\"Return a layout structure for text.\"\"\"\n        try:\n            segs = self.calculate_text_segments( text, width, wrap )\n            return self.align_layout( text, width, segs, wrap, align )\n        except CanNotDisplayText:\n            return [[]]\n\n    def pack(self, maxcol: int, layout) -> int:\n        \"\"\"\n        Return a minimal maxcol value that would result in the same\n        number of lines for layout.  layout must be a layout structure\n        returned by self.layout().\n        \"\"\"\n        maxwidth = 0\n        assert layout, f\"huh? empty layout?: {layout!r}\"\n        for l in layout:\n            lw = line_width(l)\n            if lw >= maxcol:\n                return maxcol\n            maxwidth = max(maxwidth, lw)\n        return maxwidth\n\n    def align_layout(\n        self,\n        text,\n        width: int,\n        segs,\n        wrap: Literal['any', 'space', 'clip', 'ellipsis'],\n        align: Literal['left', 'center', 'right'],\n    ):\n        \"\"\"Convert the layout segs to an aligned layout.\"\"\"\n        out = []\n        for l in segs:\n            sc = line_width(l)\n            if sc == width or align=='left':\n                out.append(l)\n                continue\n\n            if align == 'right':\n                out.append([(width-sc, None)] + l)\n                continue\n            assert align == 'center'\n            pad_trim_left = (width-sc+1) // 2\n            out.append([(pad_trim_left, None)] + l if pad_trim_left else l)\n        return out\n\n    def calculate_text_segments(\n        self,\n        text,\n        width: int,\n        wrap: Literal['any', 'space', 'clip', 'ellipsis'],\n    ):\n        \"\"\"\n        Calculate the segments of text to display given width screen\n        columns to display them.\n\n        text - unicode text or byte string to display\n        width - number of available screen columns\n        wrap - wrapping mode used\n\n        Returns a layout structure without alignment applied.\n        \"\"\"\n        nl, nl_o, sp_o = \"\\n\", \"\\n\", \" \"\n        if isinstance(text, bytes):\n            nl = nl.encode('iso8859-1')  # can only find bytes in python3 bytestrings\n            nl_o = ord(nl_o)  # + an item of a bytestring is the ordinal value\n            sp_o = ord(sp_o)\n        b = []\n        p = 0\n        if wrap in ('clip', 'ellipsis'):\n            # no wrapping to calculate, so it's easy.\n            while p <= len(text):\n                n_cr = text.find(nl, p)\n                if n_cr == -1:\n                    n_cr = len(text)\n                sc = calc_width(text, p, n_cr)\n\n                # trim line to max width if needed, add ellipsis if trimmed\n                if wrap == 'ellipsis' and sc > width:\n                    trimmed = True\n                    spos, n_end, pad_left, pad_right = calc_trim_text(text, p, n_cr, 0, width-1)\n                    # pad_left should be 0, because the start_col parameter was 0 (no trimming on the left)\n                    # similarly spos should not be changed from p\n                    assert pad_left == 0\n                    assert spos == p\n                    sc = width - 1 - pad_right\n                else:\n                    trimmed = False\n                    n_end = n_cr\n                    pad_right = 0\n\n                l = []\n                if p!=n_end:\n                    l += [(sc, p, n_end)]\n                if trimmed:\n                    l += [(1, n_end, '\u2026'.encode())]\n                l += [(pad_right,n_end)]\n                b.append(l)\n                p = n_cr+1\n            return b\n\n        while p <= len(text):\n            # look for next eligible line break\n            n_cr = text.find(nl, p)\n            if n_cr == -1:\n                n_cr = len(text)\n            sc = calc_width(text, p, n_cr)\n            if sc == 0:\n                # removed character hint\n                b.append([(0, n_cr)])\n                p = n_cr + 1\n                continue\n            if sc <= width:\n                # this segment fits\n                b.append([(sc, p, n_cr), (0, n_cr)])\n                # removed character hint\n\n                p = n_cr + 1\n                continue\n            pos, sc = calc_text_pos( text, p, n_cr, width )\n            if pos == p:  # pathological width=1 double-byte case\n                raise CanNotDisplayText(\"Wide character will not fit in 1-column width\")\n            if wrap == 'any':\n                b.append([(sc, p, pos)])\n                p = pos\n                continue\n            assert wrap == 'space'\n            if text[pos] == sp_o:\n                # perfect space wrap\n                b.append([(sc, p, pos), (0,pos)])\n                # removed character hint\n\n                p = pos + 1\n                continue\n            if is_wide_char(text, pos):\n                # perfect next wide\n                b.append([(sc, p, pos)])\n                p = pos\n                continue\n            prev = pos\n            while prev > p:\n                prev = move_prev_char(text, p, prev)\n                if text[prev] == sp_o:\n                    sc = calc_width(text, p, prev)\n                    l = [(0, prev)]\n                    if p != prev:\n                        l = [(sc, p, prev)] + l\n                    b.append(l)\n                    p = prev+1\n                    break\n                if is_wide_char(text, prev):\n                    # wrap after wide char\n                    next = move_next_char(text, prev, pos)\n                    sc = calc_width(text, p, next)\n                    b.append([(sc, p, next)])\n                    p = next\n                    break\n            else:\n                # unwrap previous line space if possible to\n                # fit more text (we're breaking a word anyway)\n                if b and (len(b[-1]) == 2 or (len(b[-1]) == 1 and len(b[-1][0]) == 2)):\n                    # look for removed space above\n                    if len(b[-1]) == 1:\n                        [(h_sc, h_off)] = b[-1]\n                        p_sc = 0\n                        p_off = p_end = h_off\n                    else:\n                        [(p_sc, p_off, p_end), (h_sc, h_off)] = b[-1]\n                    if p_sc < width and h_sc == 0 and text[h_off] == sp_o:\n                        # combine with previous line\n                        del b[-1]\n                        p = p_off\n                        pos, sc = calc_text_pos(\n                            text, p, n_cr, width )\n                        b.append([(sc, p, pos)])\n                        # check for trailing \" \" or \"\\n\"\n                        p = pos\n                        if p < len(text) and (text[p] in (sp_o, nl_o)):\n                            # removed character hint\n                            b[-1].append((0, p))\n                            p += 1\n                        continue\n\n                # force any char wrap\n                b.append([(sc, p, pos)])\n                p = pos\n        return b",
  "class LayoutSegment:\n    def __init__(self, seg: tuple[int, int, bytes | int] | tuple[int, int | None]) -> None:\n        \"\"\"Create object from line layout segment structure\"\"\"\n\n        assert isinstance(seg, tuple), repr(seg)\n        assert len(seg) in (2, 3), repr(seg)\n\n        self.sc, self.offs = seg[:2]\n\n        assert isinstance(self.sc, int), repr(self.sc)\n\n        if len(seg) == 3:\n            assert isinstance(self.offs, int), repr(self.offs)\n            assert self.sc > 0, repr(seg)\n            t = seg[2]\n            if isinstance(t, bytes):\n                self.text: bytes | None = t\n                self.end = None\n            else:\n                assert isinstance(t, int), repr(t)\n                self.text = None\n                self.end = t\n        else:\n            assert len(seg) == 2, repr(seg)\n            if self.offs is not None:\n                assert self.sc >= 0, repr(seg)\n                assert isinstance(self.offs, int)\n            self.text = self.end = None\n\n    def subseg(self, text, start: int, end: int):\n        \"\"\"\n        Return a \"sub-segment\" list containing segment structures\n        that make up a portion of this segment.\n\n        A list is returned to handle cases where wide characters\n        need to be replaced with a space character at either edge\n        so two or three segments will be returned.\n        \"\"\"\n        if start < 0:\n            start = 0\n        if end > self.sc:\n            end = self.sc\n        if start >= end:\n            return []  # completely gone\n        if self.text:\n            # use text stored in segment (self.text)\n            spos, epos, pad_left, pad_right = calc_trim_text(self.text, 0, len(self.text), start, end)\n            return [(end-start, self.offs, b''.ljust(pad_left) + self.text[spos:epos] + b''.ljust(pad_right))]\n        elif self.end:\n            # use text passed as parameter (text)\n            spos, epos, pad_left, pad_right = calc_trim_text(text, self.offs, self.end, start, end)\n            l = []\n            if pad_left:\n                l.append((1, spos-1))\n            l.append((end-start-pad_left-pad_right, spos, epos))\n            if pad_right:\n                l.append((1, epos))\n            return l\n        else:\n            # simple padding adjustment\n            return [(end-start ,self.offs)]",
  "def line_width(segs):\n    \"\"\"\n    Return the screen column width of one line of a text layout structure.\n\n    This function ignores any existing shift applied to the line,\n    represented by an (amount, None) tuple at the start of the line.\n    \"\"\"\n    sc = 0\n    seglist = segs\n    if segs and len(segs[0]) == 2 and segs[0][1] is None:\n        seglist = segs[1:]\n    for s in seglist:\n        sc += s[0]\n    return sc",
  "def shift_line(segs, amount: int):\n    \"\"\"\n    Return a shifted line from a layout structure to the left or right.\n    segs -- line of a layout structure\n    amount -- screen columns to shift right (+ve) or left (-ve)\n    \"\"\"\n    assert isinstance(amount, int), repr(amount)\n\n    if segs and len(segs[0]) == 2 and segs[0][1] is None:\n        # existing shift\n        amount += segs[0][0]\n        if amount:\n            return [(amount,None)]+segs[1:]\n        return segs[1:]\n\n    if amount:\n        return [(amount,None)]+segs\n    return segs",
  "def trim_line(segs, text, start: int, end: int):\n    \"\"\"\n    Return a trimmed line of a text layout structure.\n    text -- text to which this layout structure applies\n    start -- starting screen column\n    end -- ending screen column\n    \"\"\"\n    l = []\n    x = 0\n    for seg in segs:\n        sc = seg[0]\n        if start or sc < 0:\n            if start >= sc:\n                start -= sc\n                x += sc\n                continue\n            s = LayoutSegment(seg)\n            if x+sc >= end:\n                # can all be done at once\n                return s.subseg( text, start, end-x )\n            l += s.subseg( text, start, sc )\n            start = 0\n            x += sc\n            continue\n        if x >= end:\n            break\n        if x+sc > end:\n            s = LayoutSegment(seg)\n            l += s.subseg( text, 0, end-x )\n            break\n        l.append( seg )\n    return l",
  "def calc_line_pos(text, line_layout, pref_col: Literal['left', 'right'] | int):\n    \"\"\"\n    Calculate the closest linear position to pref_col given a\n    line layout structure.  Returns None if no position found.\n    \"\"\"\n    closest_sc = None\n    closest_pos = None\n    current_sc = 0\n\n    if pref_col == 'left':\n        for seg in line_layout:\n            s = LayoutSegment(seg)\n            if s.offs is not None:\n                return s.offs\n        return\n    elif pref_col == 'right':\n        for seg in line_layout:\n            s = LayoutSegment(seg)\n            if s.offs is not None:\n                closest_pos = s\n        s = closest_pos\n        if s is None:\n            return\n        if s.end is None:\n            return s.offs\n        return calc_text_pos(text, s.offs, s.end, s.sc-1)[0]\n\n    for seg in line_layout:\n        s = LayoutSegment(seg)\n        if s.offs is not None:\n            if s.end is not None:\n                if current_sc <= pref_col < current_sc + s.sc:\n                    # exact match within this segment\n                    return calc_text_pos(text, s.offs, s.end, pref_col - current_sc)[0]\n                elif current_sc <= pref_col:\n                    closest_sc = current_sc + s.sc - 1\n                    closest_pos = s\n\n            if closest_sc is None or (abs(pref_col-current_sc) < abs(pref_col-closest_sc)):\n                # this screen column is closer\n                closest_sc = current_sc\n                closest_pos = s.offs\n            if current_sc > closest_sc:\n                # we're moving past\n                break\n        current_sc += s.sc\n\n    if closest_pos is None or isinstance(closest_pos, int):\n        return closest_pos\n\n    # return the last positions in the segment \"closest_pos\"\n    s = closest_pos\n    return calc_text_pos( text, s.offs, s.end, s.sc-1)[0]",
  "def calc_pos(text, layout, pref_col: Literal['left', 'right'] | int, row: int) -> int:\n    \"\"\"\n    Calculate the closest linear position to pref_col and row given a\n    layout structure.\n    \"\"\"\n\n    if row < 0 or row >= len(layout):\n        raise ValueError(\"calculate_pos: out of layout row range\")\n\n    pos = calc_line_pos(text, layout[row], pref_col)\n    if pos is not None:\n        return pos\n\n    rows_above = list(range(row-1, -1, -1))\n    rows_below = list(range(row+1, len(layout)))\n    while rows_above and rows_below:\n        if rows_above:\n            r = rows_above.pop(0)\n            pos = calc_line_pos(text, layout[r], pref_col)\n            if pos is not None:\n                return pos\n        if rows_below:\n            r = rows_below.pop(0)\n            pos = calc_line_pos(text, layout[r], pref_col)\n            if pos is not None:\n                return pos\n    return 0",
  "def calc_coords(text, layout, pos, clamp: int = 1):\n    \"\"\"\n    Calculate the coordinates closest to position pos in text with layout.\n\n    text -- raw string or unicode string\n    layout -- layout structure applied to text\n    pos -- integer position into text\n    clamp -- ignored right now\n    \"\"\"\n    closest = None\n    y = 0\n    for line_layout in layout:\n        x = 0\n        for seg in line_layout:\n            s = LayoutSegment(seg)\n            if s.offs is None:\n                x += s.sc\n                continue\n            if s.offs == pos:\n                return x, y\n            if s.end is not None and s.offs <= pos < s.end:\n                x += calc_width(text, s.offs, pos)\n                return x, y\n            distance = abs(s.offs - pos)\n            if s.end is not None and s.end<pos:\n                distance = pos - (s.end-1)\n            if closest is None or distance < closest[0]:\n                closest = distance, (x, y)\n            x += s.sc\n        y += 1\n\n    if closest:\n        return closest[1]\n    return 0, 0",
  "def supports_align_mode(self, align):\n        \"\"\"Return True if align is a supported align mode.\"\"\"\n        return True",
  "def supports_wrap_mode(self, wrap):\n        \"\"\"Return True if wrap is a supported wrap mode.\"\"\"\n        return True",
  "def layout(self, text, width, align, wrap ):\n        \"\"\"\n        Return a layout structure for text.\n\n        :param text: string in current encoding or unicode string\n        :param width: number of screen columns available\n        :param align: align mode for text\n        :param wrap: wrap mode for text\n\n        Layout structure is a list of line layouts, one per output line.\n        Line layouts are lists than may contain the following tuples:\n\n        * (column width of text segment, start offset, end offset)\n        * (number of space characters to insert, offset or None)\n        * (column width of insert text, offset, \"insert text\")\n\n        The offset in the last two tuples is used to determine the\n        attribute used for the inserted spaces or text respectively.\n        The attribute used will be the same as the attribute at that\n        text offset.  If the offset is None when inserting spaces\n        then no attribute will be used.\n        \"\"\"\n        raise NotImplementedError(\n            \"This function must be overridden by a real text layout class. (see StandardTextLayout)\"\n        )",
  "def __init__(self):#, tab_stops=(), tab_stop_every=8):\n        pass",
  "def supports_align_mode(self, align: str) -> bool:\n        \"\"\"Return True if align is 'left', 'center' or 'right'.\"\"\"\n        return align in ('left', 'center', 'right')",
  "def supports_wrap_mode(self, wrap: str) -> bool:\n        \"\"\"Return True if wrap is 'any', 'space', 'clip' or 'ellipsis'.\"\"\"\n        return wrap in ('any', 'space', 'clip', 'ellipsis')",
  "def layout(\n        self,\n        text,\n        width: int,\n        align: Literal['left', 'center', 'right'],\n        wrap: Literal['any', 'space', 'clip', 'ellipsis'],\n    ):\n        \"\"\"Return a layout structure for text.\"\"\"\n        try:\n            segs = self.calculate_text_segments( text, width, wrap )\n            return self.align_layout( text, width, segs, wrap, align )\n        except CanNotDisplayText:\n            return [[]]",
  "def pack(self, maxcol: int, layout) -> int:\n        \"\"\"\n        Return a minimal maxcol value that would result in the same\n        number of lines for layout.  layout must be a layout structure\n        returned by self.layout().\n        \"\"\"\n        maxwidth = 0\n        assert layout, f\"huh? empty layout?: {layout!r}\"\n        for l in layout:\n            lw = line_width(l)\n            if lw >= maxcol:\n                return maxcol\n            maxwidth = max(maxwidth, lw)\n        return maxwidth",
  "def align_layout(\n        self,\n        text,\n        width: int,\n        segs,\n        wrap: Literal['any', 'space', 'clip', 'ellipsis'],\n        align: Literal['left', 'center', 'right'],\n    ):\n        \"\"\"Convert the layout segs to an aligned layout.\"\"\"\n        out = []\n        for l in segs:\n            sc = line_width(l)\n            if sc == width or align=='left':\n                out.append(l)\n                continue\n\n            if align == 'right':\n                out.append([(width-sc, None)] + l)\n                continue\n            assert align == 'center'\n            pad_trim_left = (width-sc+1) // 2\n            out.append([(pad_trim_left, None)] + l if pad_trim_left else l)\n        return out",
  "def calculate_text_segments(\n        self,\n        text,\n        width: int,\n        wrap: Literal['any', 'space', 'clip', 'ellipsis'],\n    ):\n        \"\"\"\n        Calculate the segments of text to display given width screen\n        columns to display them.\n\n        text - unicode text or byte string to display\n        width - number of available screen columns\n        wrap - wrapping mode used\n\n        Returns a layout structure without alignment applied.\n        \"\"\"\n        nl, nl_o, sp_o = \"\\n\", \"\\n\", \" \"\n        if isinstance(text, bytes):\n            nl = nl.encode('iso8859-1')  # can only find bytes in python3 bytestrings\n            nl_o = ord(nl_o)  # + an item of a bytestring is the ordinal value\n            sp_o = ord(sp_o)\n        b = []\n        p = 0\n        if wrap in ('clip', 'ellipsis'):\n            # no wrapping to calculate, so it's easy.\n            while p <= len(text):\n                n_cr = text.find(nl, p)\n                if n_cr == -1:\n                    n_cr = len(text)\n                sc = calc_width(text, p, n_cr)\n\n                # trim line to max width if needed, add ellipsis if trimmed\n                if wrap == 'ellipsis' and sc > width:\n                    trimmed = True\n                    spos, n_end, pad_left, pad_right = calc_trim_text(text, p, n_cr, 0, width-1)\n                    # pad_left should be 0, because the start_col parameter was 0 (no trimming on the left)\n                    # similarly spos should not be changed from p\n                    assert pad_left == 0\n                    assert spos == p\n                    sc = width - 1 - pad_right\n                else:\n                    trimmed = False\n                    n_end = n_cr\n                    pad_right = 0\n\n                l = []\n                if p!=n_end:\n                    l += [(sc, p, n_end)]\n                if trimmed:\n                    l += [(1, n_end, '\u2026'.encode())]\n                l += [(pad_right,n_end)]\n                b.append(l)\n                p = n_cr+1\n            return b\n\n        while p <= len(text):\n            # look for next eligible line break\n            n_cr = text.find(nl, p)\n            if n_cr == -1:\n                n_cr = len(text)\n            sc = calc_width(text, p, n_cr)\n            if sc == 0:\n                # removed character hint\n                b.append([(0, n_cr)])\n                p = n_cr + 1\n                continue\n            if sc <= width:\n                # this segment fits\n                b.append([(sc, p, n_cr), (0, n_cr)])\n                # removed character hint\n\n                p = n_cr + 1\n                continue\n            pos, sc = calc_text_pos( text, p, n_cr, width )\n            if pos == p:  # pathological width=1 double-byte case\n                raise CanNotDisplayText(\"Wide character will not fit in 1-column width\")\n            if wrap == 'any':\n                b.append([(sc, p, pos)])\n                p = pos\n                continue\n            assert wrap == 'space'\n            if text[pos] == sp_o:\n                # perfect space wrap\n                b.append([(sc, p, pos), (0,pos)])\n                # removed character hint\n\n                p = pos + 1\n                continue\n            if is_wide_char(text, pos):\n                # perfect next wide\n                b.append([(sc, p, pos)])\n                p = pos\n                continue\n            prev = pos\n            while prev > p:\n                prev = move_prev_char(text, p, prev)\n                if text[prev] == sp_o:\n                    sc = calc_width(text, p, prev)\n                    l = [(0, prev)]\n                    if p != prev:\n                        l = [(sc, p, prev)] + l\n                    b.append(l)\n                    p = prev+1\n                    break\n                if is_wide_char(text, prev):\n                    # wrap after wide char\n                    next = move_next_char(text, prev, pos)\n                    sc = calc_width(text, p, next)\n                    b.append([(sc, p, next)])\n                    p = next\n                    break\n            else:\n                # unwrap previous line space if possible to\n                # fit more text (we're breaking a word anyway)\n                if b and (len(b[-1]) == 2 or (len(b[-1]) == 1 and len(b[-1][0]) == 2)):\n                    # look for removed space above\n                    if len(b[-1]) == 1:\n                        [(h_sc, h_off)] = b[-1]\n                        p_sc = 0\n                        p_off = p_end = h_off\n                    else:\n                        [(p_sc, p_off, p_end), (h_sc, h_off)] = b[-1]\n                    if p_sc < width and h_sc == 0 and text[h_off] == sp_o:\n                        # combine with previous line\n                        del b[-1]\n                        p = p_off\n                        pos, sc = calc_text_pos(\n                            text, p, n_cr, width )\n                        b.append([(sc, p, pos)])\n                        # check for trailing \" \" or \"\\n\"\n                        p = pos\n                        if p < len(text) and (text[p] in (sp_o, nl_o)):\n                            # removed character hint\n                            b[-1].append((0, p))\n                            p += 1\n                        continue\n\n                # force any char wrap\n                b.append([(sc, p, pos)])\n                p = pos\n        return b",
  "def __init__(self, seg: tuple[int, int, bytes | int] | tuple[int, int | None]) -> None:\n        \"\"\"Create object from line layout segment structure\"\"\"\n\n        assert isinstance(seg, tuple), repr(seg)\n        assert len(seg) in (2, 3), repr(seg)\n\n        self.sc, self.offs = seg[:2]\n\n        assert isinstance(self.sc, int), repr(self.sc)\n\n        if len(seg) == 3:\n            assert isinstance(self.offs, int), repr(self.offs)\n            assert self.sc > 0, repr(seg)\n            t = seg[2]\n            if isinstance(t, bytes):\n                self.text: bytes | None = t\n                self.end = None\n            else:\n                assert isinstance(t, int), repr(t)\n                self.text = None\n                self.end = t\n        else:\n            assert len(seg) == 2, repr(seg)\n            if self.offs is not None:\n                assert self.sc >= 0, repr(seg)\n                assert isinstance(self.offs, int)\n            self.text = self.end = None",
  "def subseg(self, text, start: int, end: int):\n        \"\"\"\n        Return a \"sub-segment\" list containing segment structures\n        that make up a portion of this segment.\n\n        A list is returned to handle cases where wide characters\n        need to be replaced with a space character at either edge\n        so two or three segments will be returned.\n        \"\"\"\n        if start < 0:\n            start = 0\n        if end > self.sc:\n            end = self.sc\n        if start >= end:\n            return []  # completely gone\n        if self.text:\n            # use text stored in segment (self.text)\n            spos, epos, pad_left, pad_right = calc_trim_text(self.text, 0, len(self.text), start, end)\n            return [(end-start, self.offs, b''.ljust(pad_left) + self.text[spos:epos] + b''.ljust(pad_right))]\n        elif self.end:\n            # use text passed as parameter (text)\n            spos, epos, pad_left, pad_right = calc_trim_text(text, self.offs, self.end, start, end)\n            l = []\n            if pad_left:\n                l.append((1, spos-1))\n            l.append((end-start-pad_left-pad_right, spos, epos))\n            if pad_right:\n                l.append((1, epos))\n            return l\n        else:\n            # simple padding adjustment\n            return [(end-start ,self.offs)]",
  "class MetaSignals(type):\n    \"\"\"\n    register the list of signals in the class variable signals,\n    including signals in superclasses.\n    \"\"\"\n    def __init__(cls, name: str, bases: tuple[type, ...], d: dict[str, typing.Any]) -> None:\n        signals = d.get(\"signals\", [])\n        for superclass in cls.__bases__:\n            signals.extend(getattr(superclass, 'signals', []))\n        signals = list({x: None for x in signals}.keys())\n        d[\"signals\"] = signals\n        register_signal(cls, signals)\n        super().__init__(name, bases, d)",
  "def setdefaultattr(obj, name, value):\n    # like dict.setdefault() for object attributes\n    if hasattr(obj, name):\n        return getattr(obj, name)\n    setattr(obj, name, value)\n    return value",
  "class Key:\n    \"\"\"\n    Minimal class, whose only purpose is to produce objects with a\n    unique hash\n    \"\"\"\n    __slots__ = ()",
  "class Signals:\n    _signal_attr = '_urwid_signals'  # attribute to attach to signal senders\n\n    def __init__(self):\n        self._supported = {}\n\n    def register(self, sig_cls, signals: Container[str]) -> None:\n        \"\"\"\n        :param sig_class: the class of an object that will be sending signals\n        :type sig_class: class\n        :param signals: a list of signals that may be sent, typically each\n                        signal is represented by a string\n        :type signals: signal names\n\n        This function must be called for a class before connecting any\n        signal callbacks or emitting any signals from that class' objects\n        \"\"\"\n        self._supported[sig_cls] = signals\n\n    def connect(\n        self,\n        obj,\n        name: str,\n        callback: Callable[..., typing.Any],\n        user_arg: typing.Any = None,\n        *,\n        weak_args: Iterable[typing.Any] = (),\n        user_args: Iterable[typing.Any] = (),\n    ) -> Key:\n        \"\"\"\n        :param obj: the object sending a signal\n        :type obj: object\n        :param name: the signal to listen for, typically a string\n        :type name: signal name\n        :param callback: the function to call when that signal is sent\n        :type callback: function\n        :param user_arg: deprecated additional argument to callback (appended\n                         after the arguments passed when the signal is\n                         emitted). If None no arguments will be added.\n                         Don't use this argument, use user_args instead.\n        :param weak_args: additional arguments passed to the callback\n                          (before any arguments passed when the signal\n                          is emitted and before any user_args).\n\n                          These arguments are stored as weak references\n                          (but converted back into their original value\n                          before passing them to callback) to prevent\n                          any objects referenced (indirectly) from\n                          weak_args from being kept alive just because\n                          they are referenced by this signal handler.\n\n                          Use this argument only as a keyword argument,\n                          since user_arg might be removed in the future.\n        :type weak_args: iterable\n        :param user_args: additional arguments to pass to the callback,\n                          (before any arguments passed when the signal\n                          is emitted but after any weak_args).\n\n                          Use this argument only as a keyword argument,\n                          since user_arg might be removed in the future.\n        :type user_args: iterable\n\n        When a matching signal is sent, callback will be called. The\n        arguments it receives will be the user_args passed at connect\n        time (as individual arguments) followed by all the positional\n        parameters sent with the signal.\n\n        As an example of using weak_args, consider the following snippet:\n\n        >>> import urwid\n        >>> debug = urwid.Text('')\n        >>> def handler(widget, newtext):\n        ...    debug.set_text(\"Edit widget changed to %s\" % newtext)\n        >>> edit = urwid.Edit('')\n        >>> key = urwid.connect_signal(edit, 'change', handler)\n\n        If you now build some interface using \"edit\" and \"debug\", the\n        \"debug\" widget will show whatever you type in the \"edit\" widget.\n        However, if you remove all references to the \"debug\" widget, it\n        will still be kept alive by the signal handler. This because the\n        signal handler is a closure that (implicitly) references the\n        \"edit\" widget. If you want to allow the \"debug\" widget to be\n        garbage collected, you can create a \"fake\" or \"weak\" closure\n        (it's not really a closure, since it doesn't reference any\n        outside variables, so it's just a dynamic function):\n\n        >>> debug = urwid.Text('')\n        >>> def handler(weak_debug, widget, newtext):\n        ...    weak_debug.set_text(\"Edit widget changed to %s\" % newtext)\n        >>> edit = urwid.Edit('')\n        >>> key = urwid.connect_signal(edit, 'change', handler, weak_args=[debug])\n\n        Here the weak_debug parameter in print_debug is the value passed\n        in the weak_args list to connect_signal. Note that the\n        weak_debug value passed is not a weak reference anymore, the\n        signals code transparently dereferences the weakref parameter\n        before passing it to print_debug.\n\n        Returns a key associated by this signal handler, which can be\n        used to disconnect the signal later on using\n        urwid.disconnect_signal_by_key. Alternatively, the signal\n        handler can also be disconnected by calling\n        urwid.disconnect_signal, which doesn't need this key.\n        \"\"\"\n        if user_arg is not None:\n            warnings.warn(\n                \"Don't use user_arg argument, use user_args instead.\",\n                DeprecationWarning,\n            )\n\n        sig_cls = obj.__class__\n        if name not in self._supported.get(sig_cls, ()):\n            raise NameError(f\"No such signal {name!r} for object {obj!r}\")\n\n        # Just generate an arbitrary (but unique) key\n        key = Key()\n\n        signals = setdefaultattr(obj, self._signal_attr, {})\n        handlers = signals.setdefault(name, [])\n\n        # Remove the signal handler when any of the weakref'd arguments\n        # are garbage collected. Note that this means that the handlers\n        # dictionary can be modified _at any time_, so it should never\n        # be iterated directly (e.g. iterate only over .keys() and\n        # .items(), never over .iterkeys(), .iteritems() or the object\n        # itself).\n        # We let the callback keep a weakref to the object as well, to\n        # prevent a circular reference between the handler and the\n        # object (via the weakrefs, which keep strong references to\n        # their callbacks) from existing.\n        obj_weak = weakref.ref(obj)\n        def weakref_callback(weakref):\n            o = obj_weak()\n            if o:\n                self.disconnect_by_key(o, name, key)\n\n        user_args = self._prepare_user_args(weak_args, user_args, weakref_callback)\n        handlers.append((key, callback, user_arg, user_args))\n\n        return key\n\n    def _prepare_user_args(\n        self,\n        weak_args: Iterable[typing.Any] = (),\n        user_args: Iterable[typing.Any] = (),\n        callback: Callable[..., typing.Any] | None = None,\n    ) -> tuple[Collection[weakref.ReferenceType], Collection[typing.Any]]:\n        # Turn weak_args into weakrefs and prepend them to user_args\n        w_args = tuple(weakref.ref(w_arg, callback) for w_arg in weak_args)\n        args = tuple(user_args) or ()\n        return (w_args, args)\n\n    def disconnect(\n        self,\n        obj,\n        name: str,\n        callback: Callable[..., typing.Any],\n        user_arg: typing.Any = None,\n        *,\n        weak_args: Iterable[typing.Any] = (),\n        user_args: Iterable[typing.Any] = (),\n    ) -> None:\n        \"\"\"\n        :param obj: the object to disconnect the signal from\n        :type obj: object\n        :param name: the signal to disconnect, typically a string\n        :type name: signal name\n        :param callback: the callback function passed to connect_signal\n        :type callback: function\n        :param user_arg: the user_arg parameter passed to connect_signal\n        :param weak_args: the weak_args parameter passed to connect_signal\n        :param user_args: the weak_args parameter passed to connect_signal\n\n        This function will remove a callback from the list connected\n        to a signal with connect_signal(). The arguments passed should\n        be exactly the same as those passed to connect_signal().\n\n        If the callback is not connected or already disconnected, this\n        function will simply do nothing.\n        \"\"\"\n        signals = setdefaultattr(obj, self._signal_attr, {})\n        if name not in signals:\n            return\n\n        handlers = signals[name]\n\n        # Do the same processing as in connect, so we can compare the\n        # resulting tuple.\n        user_args = self._prepare_user_args(weak_args, user_args)\n\n        # Remove the given handler\n        for h in handlers:\n            if h[1:] == (callback, user_arg, user_args):\n                return self.disconnect_by_key(obj, name, h[0])\n\n    def disconnect_by_key(self, obj, name: str, key: Key) -> None:\n        \"\"\"\n        :param obj: the object to disconnect the signal from\n        :type obj: object\n        :param name: the signal to disconnect, typically a string\n        :type name: signal name\n        :param key: the key for this signal handler, as returned by\n                    connect_signal().\n        :type key: Key\n\n        This function will remove a callback from the list connected\n        to a signal with connect_signal(). The key passed should be the\n        value returned by connect_signal().\n\n        If the callback is not connected or already disconnected, this\n        function will simply do nothing.\n        \"\"\"\n        signals = setdefaultattr(obj, self._signal_attr, {})\n        handlers = signals.get(name, [])\n        handlers[:] = [h for h in handlers if h[0] is not key]\n\n    def emit(self, obj, name: str, *args) -> bool:\n        \"\"\"\n        :param obj: the object sending a signal\n        :type obj: object\n        :param name: the signal to send, typically a string\n        :type name: signal name\n        :param args: zero or more positional arguments to pass to the signal callback functions\n\n        This function calls each of the callbacks connected to this signal\n        with the args arguments as positional parameters.\n\n        This function returns True if any of the callbacks returned True.\n        \"\"\"\n        result = False\n        signals = getattr(obj, self._signal_attr, {})\n        handlers = signals.get(name, [])\n        for key, callback, user_arg, (weak_args, user_args) in handlers:\n            result |= self._call_callback(callback, user_arg, weak_args, user_args, args)\n        return result\n\n    def _call_callback(\n        self,\n        callback,\n        user_arg: typing.Any,\n        weak_args: Collection[weakref.ReferenceType],\n        user_args: Collection[typing.Any],\n        emit_args: Iterable[typing.Any],\n    ) -> bool:\n        args_to_pass = []\n        for w_arg in weak_args:\n            real_arg = w_arg()\n            if real_arg is not None:\n                args_to_pass.append(real_arg)\n            else:\n                # de-referenced\n                return False\n\n        # The deprecated user_arg argument was added to the end\n        # instead of the beginning.\n        args = itertools.chain(args_to_pass, user_args, emit_args, (user_arg,) if user_arg is not None else ())\n\n        return bool(callback(*args))",
  "def __init__(cls, name: str, bases: tuple[type, ...], d: dict[str, typing.Any]) -> None:\n        signals = d.get(\"signals\", [])\n        for superclass in cls.__bases__:\n            signals.extend(getattr(superclass, 'signals', []))\n        signals = list({x: None for x in signals}.keys())\n        d[\"signals\"] = signals\n        register_signal(cls, signals)\n        super().__init__(name, bases, d)",
  "def __init__(self):\n        self._supported = {}",
  "def register(self, sig_cls, signals: Container[str]) -> None:\n        \"\"\"\n        :param sig_class: the class of an object that will be sending signals\n        :type sig_class: class\n        :param signals: a list of signals that may be sent, typically each\n                        signal is represented by a string\n        :type signals: signal names\n\n        This function must be called for a class before connecting any\n        signal callbacks or emitting any signals from that class' objects\n        \"\"\"\n        self._supported[sig_cls] = signals",
  "def connect(\n        self,\n        obj,\n        name: str,\n        callback: Callable[..., typing.Any],\n        user_arg: typing.Any = None,\n        *,\n        weak_args: Iterable[typing.Any] = (),\n        user_args: Iterable[typing.Any] = (),\n    ) -> Key:\n        \"\"\"\n        :param obj: the object sending a signal\n        :type obj: object\n        :param name: the signal to listen for, typically a string\n        :type name: signal name\n        :param callback: the function to call when that signal is sent\n        :type callback: function\n        :param user_arg: deprecated additional argument to callback (appended\n                         after the arguments passed when the signal is\n                         emitted). If None no arguments will be added.\n                         Don't use this argument, use user_args instead.\n        :param weak_args: additional arguments passed to the callback\n                          (before any arguments passed when the signal\n                          is emitted and before any user_args).\n\n                          These arguments are stored as weak references\n                          (but converted back into their original value\n                          before passing them to callback) to prevent\n                          any objects referenced (indirectly) from\n                          weak_args from being kept alive just because\n                          they are referenced by this signal handler.\n\n                          Use this argument only as a keyword argument,\n                          since user_arg might be removed in the future.\n        :type weak_args: iterable\n        :param user_args: additional arguments to pass to the callback,\n                          (before any arguments passed when the signal\n                          is emitted but after any weak_args).\n\n                          Use this argument only as a keyword argument,\n                          since user_arg might be removed in the future.\n        :type user_args: iterable\n\n        When a matching signal is sent, callback will be called. The\n        arguments it receives will be the user_args passed at connect\n        time (as individual arguments) followed by all the positional\n        parameters sent with the signal.\n\n        As an example of using weak_args, consider the following snippet:\n\n        >>> import urwid\n        >>> debug = urwid.Text('')\n        >>> def handler(widget, newtext):\n        ...    debug.set_text(\"Edit widget changed to %s\" % newtext)\n        >>> edit = urwid.Edit('')\n        >>> key = urwid.connect_signal(edit, 'change', handler)\n\n        If you now build some interface using \"edit\" and \"debug\", the\n        \"debug\" widget will show whatever you type in the \"edit\" widget.\n        However, if you remove all references to the \"debug\" widget, it\n        will still be kept alive by the signal handler. This because the\n        signal handler is a closure that (implicitly) references the\n        \"edit\" widget. If you want to allow the \"debug\" widget to be\n        garbage collected, you can create a \"fake\" or \"weak\" closure\n        (it's not really a closure, since it doesn't reference any\n        outside variables, so it's just a dynamic function):\n\n        >>> debug = urwid.Text('')\n        >>> def handler(weak_debug, widget, newtext):\n        ...    weak_debug.set_text(\"Edit widget changed to %s\" % newtext)\n        >>> edit = urwid.Edit('')\n        >>> key = urwid.connect_signal(edit, 'change', handler, weak_args=[debug])\n\n        Here the weak_debug parameter in print_debug is the value passed\n        in the weak_args list to connect_signal. Note that the\n        weak_debug value passed is not a weak reference anymore, the\n        signals code transparently dereferences the weakref parameter\n        before passing it to print_debug.\n\n        Returns a key associated by this signal handler, which can be\n        used to disconnect the signal later on using\n        urwid.disconnect_signal_by_key. Alternatively, the signal\n        handler can also be disconnected by calling\n        urwid.disconnect_signal, which doesn't need this key.\n        \"\"\"\n        if user_arg is not None:\n            warnings.warn(\n                \"Don't use user_arg argument, use user_args instead.\",\n                DeprecationWarning,\n            )\n\n        sig_cls = obj.__class__\n        if name not in self._supported.get(sig_cls, ()):\n            raise NameError(f\"No such signal {name!r} for object {obj!r}\")\n\n        # Just generate an arbitrary (but unique) key\n        key = Key()\n\n        signals = setdefaultattr(obj, self._signal_attr, {})\n        handlers = signals.setdefault(name, [])\n\n        # Remove the signal handler when any of the weakref'd arguments\n        # are garbage collected. Note that this means that the handlers\n        # dictionary can be modified _at any time_, so it should never\n        # be iterated directly (e.g. iterate only over .keys() and\n        # .items(), never over .iterkeys(), .iteritems() or the object\n        # itself).\n        # We let the callback keep a weakref to the object as well, to\n        # prevent a circular reference between the handler and the\n        # object (via the weakrefs, which keep strong references to\n        # their callbacks) from existing.\n        obj_weak = weakref.ref(obj)\n        def weakref_callback(weakref):\n            o = obj_weak()\n            if o:\n                self.disconnect_by_key(o, name, key)\n\n        user_args = self._prepare_user_args(weak_args, user_args, weakref_callback)\n        handlers.append((key, callback, user_arg, user_args))\n\n        return key",
  "def _prepare_user_args(\n        self,\n        weak_args: Iterable[typing.Any] = (),\n        user_args: Iterable[typing.Any] = (),\n        callback: Callable[..., typing.Any] | None = None,\n    ) -> tuple[Collection[weakref.ReferenceType], Collection[typing.Any]]:\n        # Turn weak_args into weakrefs and prepend them to user_args\n        w_args = tuple(weakref.ref(w_arg, callback) for w_arg in weak_args)\n        args = tuple(user_args) or ()\n        return (w_args, args)",
  "def disconnect(\n        self,\n        obj,\n        name: str,\n        callback: Callable[..., typing.Any],\n        user_arg: typing.Any = None,\n        *,\n        weak_args: Iterable[typing.Any] = (),\n        user_args: Iterable[typing.Any] = (),\n    ) -> None:\n        \"\"\"\n        :param obj: the object to disconnect the signal from\n        :type obj: object\n        :param name: the signal to disconnect, typically a string\n        :type name: signal name\n        :param callback: the callback function passed to connect_signal\n        :type callback: function\n        :param user_arg: the user_arg parameter passed to connect_signal\n        :param weak_args: the weak_args parameter passed to connect_signal\n        :param user_args: the weak_args parameter passed to connect_signal\n\n        This function will remove a callback from the list connected\n        to a signal with connect_signal(). The arguments passed should\n        be exactly the same as those passed to connect_signal().\n\n        If the callback is not connected or already disconnected, this\n        function will simply do nothing.\n        \"\"\"\n        signals = setdefaultattr(obj, self._signal_attr, {})\n        if name not in signals:\n            return\n\n        handlers = signals[name]\n\n        # Do the same processing as in connect, so we can compare the\n        # resulting tuple.\n        user_args = self._prepare_user_args(weak_args, user_args)\n\n        # Remove the given handler\n        for h in handlers:\n            if h[1:] == (callback, user_arg, user_args):\n                return self.disconnect_by_key(obj, name, h[0])",
  "def disconnect_by_key(self, obj, name: str, key: Key) -> None:\n        \"\"\"\n        :param obj: the object to disconnect the signal from\n        :type obj: object\n        :param name: the signal to disconnect, typically a string\n        :type name: signal name\n        :param key: the key for this signal handler, as returned by\n                    connect_signal().\n        :type key: Key\n\n        This function will remove a callback from the list connected\n        to a signal with connect_signal(). The key passed should be the\n        value returned by connect_signal().\n\n        If the callback is not connected or already disconnected, this\n        function will simply do nothing.\n        \"\"\"\n        signals = setdefaultattr(obj, self._signal_attr, {})\n        handlers = signals.get(name, [])\n        handlers[:] = [h for h in handlers if h[0] is not key]",
  "def emit(self, obj, name: str, *args) -> bool:\n        \"\"\"\n        :param obj: the object sending a signal\n        :type obj: object\n        :param name: the signal to send, typically a string\n        :type name: signal name\n        :param args: zero or more positional arguments to pass to the signal callback functions\n\n        This function calls each of the callbacks connected to this signal\n        with the args arguments as positional parameters.\n\n        This function returns True if any of the callbacks returned True.\n        \"\"\"\n        result = False\n        signals = getattr(obj, self._signal_attr, {})\n        handlers = signals.get(name, [])\n        for key, callback, user_arg, (weak_args, user_args) in handlers:\n            result |= self._call_callback(callback, user_arg, weak_args, user_args, args)\n        return result",
  "def _call_callback(\n        self,\n        callback,\n        user_arg: typing.Any,\n        weak_args: Collection[weakref.ReferenceType],\n        user_args: Collection[typing.Any],\n        emit_args: Iterable[typing.Any],\n    ) -> bool:\n        args_to_pass = []\n        for w_arg in weak_args:\n            real_arg = w_arg()\n            if real_arg is not None:\n                args_to_pass.append(real_arg)\n            else:\n                # de-referenced\n                return False\n\n        # The deprecated user_arg argument was added to the end\n        # instead of the beginning.\n        args = itertools.chain(args_to_pass, user_args, emit_args, (user_arg,) if user_arg is not None else ())\n\n        return bool(callback(*args))",
  "def weakref_callback(weakref):\n            o = obj_weak()\n            if o:\n                self.disconnect_by_key(o, name, key)",
  "def get_width(o: int) -> Literal[0, 1, 2]:\n    \"\"\"Return the screen column width for unicode ordinal o.\"\"\"\n    global widths\n    if o == 0xe or o == 0xf:\n        return 0\n    for num, wid in widths:\n        if o <= num:\n            return wid\n    return 1",
  "def decode_one(text: bytes| str, pos: int) -> tuple[int, int]:\n    \"\"\"\n    Return (ordinal at pos, next position) for UTF-8 encoded text.\n    \"\"\"\n    lt = len(text) - pos\n\n    b2 = 0  # Fallback, not changing anything\n    b3 = 0  # Fallback, not changing anything\n    b4 = 0  # Fallback, not changing anything\n\n    try:\n        if isinstance(text, str):\n            b1 = ord(text[pos])\n            if lt > 1:\n                b2 = ord(text[pos + 1])\n            if lt > 2:\n                b3 = ord(text[pos + 2])\n            if lt > 3:\n                b4 = ord(text[pos + 3])\n        else:\n            b1 = text[pos]\n            if lt > 1:\n                b2 = text[pos + 1]\n            if lt > 2:\n                b3 = text[pos + 2]\n            if lt > 3:\n                b4 = text[pos + 3]\n    except Exception as e:\n        raise ValueError(f\"{e}: {text=!r}, {pos=!r}, {lt=}\").with_traceback(e.__traceback__) from e\n\n    if not b1 & 0x80:\n        return b1, pos+1\n    error = ord(\"?\"), pos+1\n\n    if lt < 2:\n        return error\n    if b1 & 0xe0 == 0xc0:\n        if b2 & 0xc0 != 0x80:\n            return error\n        o = ((b1 & 0x1f) << 6) | (b2 & 0x3f)\n        if o < 0x80:\n            return error\n        return o, pos+2\n    if lt < 3:\n        return error\n    if b1 & 0xf0 == 0xe0:\n        if b2 & 0xc0 != 0x80:\n            return error\n        if b3 & 0xc0 != 0x80:\n            return error\n        o = ((b1 & 0x0f) << 12) | ((b2 & 0x3f) << 6) | (b3 & 0x3f)\n        if o < 0x800:\n            return error\n        return o, pos+3\n    if lt < 4:\n        return error\n    if b1 & 0xf8 == 0xf0:\n        if b2 & 0xc0 != 0x80:\n            return error\n        if b3 & 0xc0 != 0x80:\n            return error\n        if b4 & 0xc0 != 0x80:\n            return error\n        o = ((b1 & 0x07) << 18) | ((b2 & 0x3f) << 12)|((b3 & 0x3f) << 6) | (b4 & 0x3f)\n        if o < 0x10000:\n            return error\n        return o, pos+4\n    return error",
  "def decode_one_uni(text: str, i: int) -> tuple[int, int]:\n    \"\"\"\n    decode_one implementation for unicode strings\n    \"\"\"\n    return ord(text[i]), i+1",
  "def decode_one_right(text: bytes, pos: int) -> tuple[int, int]:\n    \"\"\"\n    Return (ordinal at pos, next position) for UTF-8 encoded text.\n    pos is assumed to be on the trailing byte of a utf-8 sequence.\n    \"\"\"\n    assert isinstance(text, bytes), text\n    error = ord(\"?\"), pos-1\n    p = pos\n    while p >= 0:\n        if text[p]&0xc0 != 0x80:\n            o, next = decode_one( text, p )\n            return o, p-1\n        p -=1\n        if p == p-4:\n            return error",
  "def set_byte_encoding(enc: Literal['utf8', 'narrow', 'wide']):\n    assert enc in ('utf8', 'narrow', 'wide')\n    global _byte_encoding\n    _byte_encoding = enc",
  "def get_byte_encoding():\n    return _byte_encoding",
  "def calc_text_pos(text: str | bytes, start_offs: int, end_offs: int, pref_col: int) -> tuple[int, int]:\n    \"\"\"\n    Calculate the closest position to the screen column pref_col in text\n    where start_offs is the offset into text assumed to be screen column 0\n    and end_offs is the end of the range to search.\n\n    text may be unicode or a byte string in the target _byte_encoding\n\n    Returns (position, actual_col).\n    \"\"\"\n    assert start_offs <= end_offs, repr((start_offs, end_offs))\n    utfs = isinstance(text, bytes) and _byte_encoding == \"utf8\"\n    unis = isinstance(text, str)\n    if unis or utfs:\n        decode = [decode_one, decode_one_uni][unis]\n        i = start_offs\n        sc = 0\n        n = 1  # number to advance by\n        while i < end_offs:\n            o, n = decode(text, i)\n            w = get_width(o)\n            if w+sc > pref_col:\n                return i, sc\n            i = n\n            sc += w\n        return i, sc\n\n    assert isinstance(text, bytes), repr(text)\n    # \"wide\" and \"narrow\"\n    i = start_offs+pref_col\n    if i >= end_offs:\n        return end_offs, end_offs-start_offs\n    if _byte_encoding == \"wide\":\n        if within_double_byte(text, start_offs, i) == 2:\n            i -= 1\n    return i, i-start_offs",
  "def calc_width(text: str | bytes, start_offs: int, end_offs: int) -> int:\n    \"\"\"\n    Return the screen column width of text between start_offs and end_offs.\n\n    text may be unicode or a byte string in the target _byte_encoding\n\n    Some characters are wide (take two columns) and others affect the\n    previous character (take zero columns).  Use the widths table above\n    to calculate the screen column width of text[start_offs:end_offs]\n    \"\"\"\n\n    assert start_offs <= end_offs, repr((start_offs, end_offs))\n\n    utfs = isinstance(text, bytes) and _byte_encoding == \"utf8\"\n    unis = not isinstance(text, bytes)\n    if (unis and not SAFE_ASCII_RE.match(text)) or (utfs and not SAFE_ASCII_BYTES_RE.match(text)):\n        decode = [decode_one, decode_one_uni][unis]\n        i = start_offs\n        sc = 0\n        n = 1 # number to advance by\n        while i < end_offs:\n            o, n = decode(text, i)\n            w = get_width(o)\n            i = n\n            sc += w\n        return sc\n    # \"wide\", \"narrow\" or all printable ASCII, just return the character count\n    return end_offs - start_offs",
  "def is_wide_char(text: str | bytes, offs: int) -> bool:\n    \"\"\"\n    Test if the character at offs within text is wide.\n\n    text may be unicode or a byte string in the target _byte_encoding\n    \"\"\"\n    if isinstance(text, str):\n        o = ord(text[offs])\n        return get_width(o) == 2\n    assert isinstance(text, bytes)\n    if _byte_encoding == \"utf8\":\n        o, n = decode_one(text, offs)\n        return get_width(o) == 2\n    if _byte_encoding == \"wide\":\n        return within_double_byte(text, offs, offs) == 1\n    return False",
  "def move_prev_char(text: str | bytes, start_offs: int, end_offs: int):\n    \"\"\"\n    Return the position of the character before end_offs.\n    \"\"\"\n    assert start_offs < end_offs\n    if isinstance(text, str):\n        return end_offs-1\n    assert isinstance(text, bytes)\n    if _byte_encoding == \"utf8\":\n        o = end_offs-1\n        while text[o]&0xc0 == 0x80:\n            o -= 1\n        return o\n    if _byte_encoding == \"wide\" and within_double_byte(text,\n        start_offs, end_offs-1) == 2:\n        return end_offs-2\n    return end_offs-1",
  "def move_next_char(text: str | bytes, start_offs: int, end_offs: int) -> int:\n    \"\"\"\n    Return the position of the character after start_offs.\n    \"\"\"\n    assert start_offs < end_offs\n    if isinstance(text, str):\n        return start_offs+1\n    assert isinstance(text, bytes)\n    if _byte_encoding == \"utf8\":\n        o = start_offs+1\n        while o < end_offs and text[o] & 0xc0 == 0x80:\n            o += 1\n        return o\n    if _byte_encoding == \"wide\" and within_double_byte(text, start_offs, start_offs) == 1:\n        return start_offs +2\n    return start_offs+1",
  "def within_double_byte(text: bytes, line_start: int, pos: int) -> Literal[0, 1, 2]:\n    \"\"\"Return whether pos is within a double-byte encoded character.\n\n    text -- byte string in question\n    line_start -- offset of beginning of line (< pos)\n    pos -- offset in question\n\n    Return values:\n    0 -- not within dbe char, or double_byte_encoding == False\n    1 -- pos is on the 1st half of a dbe char\n    2 -- pos is on the 2nd half of a dbe char\n    \"\"\"\n    assert isinstance(text, bytes)\n    v = text[pos]\n\n    if 0x40 <= v < 0x7f:\n        # might be second half of big5, uhc or gbk encoding\n        if pos == line_start:\n            return 0\n\n        if text[pos-1] >= 0x81:\n            if within_double_byte(text, line_start, pos-1) == 1:\n                return 2\n        return 0\n\n    if v < 0x80:\n        return 0\n\n    i = pos - 1\n    while i >= line_start:\n        if text[i] < 0x80:\n            break\n        i -= 1\n\n    if (pos - i) & 1:\n        return 1\n    return 2",
  "def process_east_asian_width() -> None:\n    import sys\n    out = []\n    last = None\n    for line in sys.stdin.readlines():\n        if line[:1] == \"#\": continue\n        line = line.strip()\n        hex,rest = line.split(\";\",1)\n        wid,rest = rest.split(\" # \",1)\n        word1 = rest.split(\" \",1)[0]\n\n        if \".\" in hex:\n            hex = hex.split(\"..\")[1]\n        num = int(hex, 16)\n\n        if word1 in (\"COMBINING\",\"MODIFIER\",\"<control>\"):\n            l = 0\n        elif wid in (\"W\", \"F\"):\n            l = 2\n        else:\n            l = 1\n\n        if last is None:\n            out.append((0, l))\n            last = l\n\n        if last == l:\n            out[-1] = (num, l)\n        else:\n            out.append( (num, l) )\n            last = l\n\n    print(\"widths = [\")\n    for o in out[1:]:  # treat control characters same as ascii\n        print(f\"\\t{o!r},\")\n    print(\"]\")",
  "def separate_glyphs(gdata: str, height: int) -> tuple[dict[str, tuple[int, list[str]]], bool]:\n    \"\"\"return (dictionary of glyphs, utf8 required)\"\"\"\n    gl: list[str] = gdata.split(\"\\n\")[1:-1]\n\n    if any(\"\\t\" in elem for elem in gl):\n        raise ValueError(f\"Incorrect glyphs data:\\n{gdata!r}\")\n\n    if len(gl) != height + 1:\n        raise ValueError(f\"Incorrect glyphs height (expected: {height}):\\n{gdata}\")\n\n    key_line: str = gl[0]\n\n    character: str | None = None  # current character\n    key_index = 0  # index into character key line\n    end_col = 0  # column position at end of glyph\n    start_col = 0  # column position at start of glyph\n    jl: list[int] = [0] * height  # indexes into lines of gdata (gl)\n    result: dict[str, tuple[int, list[str]]] = {}\n    utf8_required = False\n    while True:\n        if character is None:\n            if key_index >= len(key_line):\n                break\n            character = key_line[key_index]\n\n        if key_index < len(key_line) and key_line[key_index] == character:\n            end_col += str_util.get_width(ord(character))\n            key_index += 1\n            continue\n\n        out: list[str] = []\n        y = 0\n        fill = 0\n\n        for k, line in enumerate(gl[1:]):\n            j: int = jl[k]\n            y = 0\n            fill = 0\n            while y < end_col - start_col:\n                if j >= len(line):\n                    fill = end_col - start_col - y\n                    break\n                y += str_util.get_width(ord(line[j]))\n                j += 1\n            if y + fill != end_col - start_col:\n                raise ValueError(repr((y, fill, end_col)))\n\n            segment = line[jl[k] : j]\n            if not SAFE_ASCII_DEC_SPECIAL_RE.match(segment):\n                utf8_required = True\n\n            out.append(segment + \" \" * fill)\n            jl[k] = j\n\n        start_col = end_col\n        result[character] = (y + fill, out)\n        character = None\n    return result, utf8_required",
  "def add_font(name: str, cls: FontRegistry) -> None:\n    warnings.warn(\n        \"`add_font` is deprecated, please set 'name' attribute to the font class,\"\n        \" use metaclass keyword argument 'font_name'\"\n        \" or use `Font.register(<name>)`\",\n        DeprecationWarning,\n        stacklevel=2,\n    )\n    cls.register(name)",
  "class FontRegistryWarning(UserWarning):\n    \"\"\"FontRegistry warning.\"\"\"",
  "class FontRegistry(type):\n    \"\"\"Font registry.\n\n    Store all registered fonts, register during class creation if possible.\n    \"\"\"\n\n    __slots__ = ()\n\n    __registered: typing.ClassVar[dict[str, FontRegistry]] = {}\n\n    def __iter__(self) -> Iterator[str]:\n        \"\"\"Iterate over registered font names.\"\"\"\n        return iter(self.__registered)\n\n    def __getitem__(self, item: str) -> FontRegistry | None:\n        \"\"\"Get font by name if registered.\"\"\"\n        return self.__registered.get(item)\n\n    @property\n    def registered(cls) -> Sequence[str]:\n        \"\"\"Registered font names in alphabetical order.\"\"\"\n        return tuple(sorted(cls.__registered))\n\n    @classmethod\n    def as_list(mcs) -> list[tuple[str, FontRegistry]]:\n        \"\"\"List of (font name, font class) tuples.\"\"\"\n        return list(mcs.__registered.items())\n\n    def __new__(  # noqa: PYI034  # new can not return Self\n        cls: type[FontRegistry],\n        name: str,\n        bases: tuple[type, ...],\n        namespace: dict[str, typing.Any],\n        **kwds: typing.Any,\n    ) -> FontRegistry:\n        font_name: str = namespace.setdefault(\"name\", kwds.get(\"font_name\", \"\"))\n        font_class = super().__new__(cls, name, bases, namespace)\n        if font_name:\n            if font_name not in cls.__registered:\n                cls.__registered[font_name] = font_class\n            if cls.__registered[font_name] != font_class:\n                warnings.warn(\n                    f\"{font_name!r} is already registered, please override explicit if required or change name\",\n                    FontRegistryWarning,\n                    stacklevel=2,\n                )\n        return font_class\n\n    def register(cls, font_name: str) -> None:\n        \"\"\"Register font explicit.\n\n        :param font_name: Font name to use in registration.\n        \"\"\"\n        if not font_name:\n            raise ValueError('\"font_name\" is not set.')\n        cls.__registered[font_name] = cls",
  "class Font(metaclass=FontRegistry):\n    \"\"\"Font base class.\"\"\"\n\n    __slots__ = (\"char\", \"canvas\", \"utf8_required\")\n\n    height: int\n    data: Sequence[str]\n    name: str\n\n    def __init__(self) -> None:\n        if not self.height:\n            raise ValueError(f'\"height\" is invalid: {self.height!r}')\n        if not self.data:\n            raise ValueError(f'\"data\" is empty: {self.data!r}')\n\n        self.char: dict[str, tuple[int, list[str]]] = {}\n        self.canvas: dict[str, TextCanvas] = {}\n        self.utf8_required = False\n        data: list[str] = [self._to_text(block) for block in self.data]\n        for gdata in data:\n            self.add_glyphs(gdata)\n\n    def __repr__(self) -> str:\n        return f\"{self.__class__.__name__}()\"\n\n    def __str__(self) -> str:\n        \"\"\"Font description.\"\"\"\n        return f\"{self.__class__.__name__}():\\n  {self.height!r}\\n  {pformat(self.data, indent=4)}\"\n\n    @staticmethod\n    def _to_text(\n        obj: str | bytes,\n        encoding: str = \"utf-8\",\n        errors: Literal[\"strict\", \"ignore\", \"replace\"] = \"strict\",\n    ) -> str:\n        if isinstance(obj, str):\n            return obj\n\n        if isinstance(obj, bytes):\n            warnings.warn(\n                \"Bytes based fonts are deprecated, please switch to the text one\",\n                DeprecationWarning,\n                stacklevel=3,\n            )\n            return obj.decode(encoding, errors)\n\n        raise TypeError(f\"{obj!r} is not str|bytes\")\n\n    def add_glyphs(self, gdata: str) -> None:\n        d, utf8_required = separate_glyphs(gdata, self.height)\n        self.char.update(d)\n        self.utf8_required |= utf8_required\n\n    def characters(self) -> str:\n        return \"\".join(sorted(self.char))\n\n    def char_width(self, character: str) -> int:\n        if character in self.char:\n            return self.char[character][0]\n        return 0\n\n    def char_data(self, character: str) -> list[str]:\n        return self.char[character][1]\n\n    def render(self, character: str) -> TextCanvas:\n        if character in self.canvas:\n            return self.canvas[character]\n        width, line = self.char[character]\n        byte_lines = []\n        character_set_lines = []\n        for d in line:\n            t, cs = apply_target_encoding(d)\n            byte_lines.append(t)\n            character_set_lines.append(cs)\n\n        try:\n            canv = TextCanvas(byte_lines, None, character_set_lines, maxcol=width, check_width=False)\n        except CanvasError as exc:\n            raise CanvasError(f\"Failed render of {character!r} from line {line!r}:\\n{self}\\n:{exc}\").with_traceback(\n                exc.__traceback__\n            ) from exc\n\n        self.canvas[character] = canv\n        return canv",
  "class Thin3x3Font(Font):\n    name = \"Thin 3x3\"\n    height = 3\n    data = (\n        \"\"\"\n000111222333444555666777888999  !\n\u250c\u2500\u2510 \u2510 \u250c\u2500\u2510\u250c\u2500\u2510  \u2510\u250c\u2500 \u250c\u2500 \u250c\u2500\u2510\u250c\u2500\u2510\u250c\u2500\u2510  \u2502\n\u2502 \u2502 \u2502 \u250c\u2500\u2518 \u2500\u2524\u2514\u2500\u253c\u2514\u2500\u2510\u251c\u2500\u2510  \u253c\u251c\u2500\u2524\u2514\u2500\u2524  \u2502\n\u2514\u2500\u2518 \u2534 \u2514\u2500 \u2514\u2500\u2518  \u2534 \u2500\u2518\u2514\u2500\u2518  \u2534\u2514\u2500\u2518 \u2500\u2518  .\n\"\"\",\n        r\"\"\"\n\"###$$$%%%'*++,--.///:;==???[[\\\\\\]]^__`\n\" \u253c\u253c\u250c\u253c\u2510O /'         /.. _\u250c\u2500\u2510\u250c \\   \u2510^  `\n  \u253c\u253c\u2514\u253c\u2510 /  * \u253c  \u2500  / ., _ \u250c\u2518\u2502  \\  \u2502\n    \u2514\u253c\u2518/ O    ,  ./       . \u2514   \\ \u2518 \u2500\u2500\n\"\"\",\n    )",
  "class Thin4x3Font(Font):\n    name = \"Thin 4x3\"\n    height = 3\n    data = (\n        *Thin3x3Font.data,\n        \"\"\"\n0000111122223333444455556666777788889999  ####$$$$\n\u250c\u2500\u2500\u2510  \u2510 \u250c\u2500\u2500\u2510\u250c\u2500\u2500\u2510   \u2510\u250c\u2500\u2500 \u250c\u2500\u2500 \u250c\u2500\u2500\u2510\u250c\u2500\u2500\u2510\u250c\u2500\u2500\u2510   \u253c\u2500\u253c\u250c\u253c\u253c\u2510\n\u2502  \u2502  \u2502 \u250c\u2500\u2500\u2518  \u2500\u2524\u2514\u2500\u2500\u253c\u2514\u2500\u2500\u2510\u251c\u2500\u2500\u2510   \u253c\u251c\u2500\u2500\u2524\u2514\u2500\u2500\u2524   \u253c\u2500\u253c\u2514\u253c\u253c\u2510\n\u2514\u2500\u2500\u2518  \u2534 \u2514\u2500\u2500 \u2514\u2500\u2500\u2518   \u2534 \u2500\u2500\u2518\u2514\u2500\u2500\u2518   \u2534\u2514\u2500\u2500\u2518 \u2500\u2500\u2518      \u2514\u253c\u253c\u2518\n\"\"\",\n    )",
  "class Sextant3x3Font(Font):\n    name = \"Sextant 3x3\"\n    height = 3\n    data = (\n        \"\"\"\n   !!!###$$$%%%&&&'''((()))***+++,,,---...///\n    \u2590 \ud83e\udf1e\ud83e\udf32\ud83e\udf32\ud83e\udf1e\ud83e\udf0d\ud83e\udf0b\ud83e\udf09\ud83e\udf04\ud83e\udf16\ud83e\udf26\ud83e\udf27  \ud83e\udf09 \ud83e\udf1e\ud83e\udf05 \ud83e\udf01\ud83e\udf22 \ud83e\udf1e\ud83e\udf26\ud83e\udf1e \ud83e\udf26            \ud83e\udf16\n    \ud83e\udf09 \ud83e\udf07\ud83e\udf1b\ud83e\udf1b\ud83e\udf1e\ud83e\udf30\ud83e\udf17\ud83e\udf1e\ud83e\udf05\ud83e\udf2d\ud83e\udf26\ud83e\udf08\ud83e\udf16   \ud83e\udf09\ud83e\udf0f  \ud83e\udf18 \ud83e\udf07\ud83e\udf28\ud83e\udf08\ud83e\udf01\ud83e\udf28\ud83e\udf02 \ud83e\udf2d \ud83e\udf01\ud83e\udf02\ud83e\udf02 \ud83e\udf2d \ud83e\udf1e\ud83e\udf05\n    \ud83e\udf01  \ud83e\udf00\ud83e\udf00 \ud83e\udf01   \ud83e\udf02 \ud83e\udf02\ud83e\udf01    \ud83e\udf01 \ud83e\udf01         \ud83e\udf05     \ud83e\udf02\n\"\"\",\n        \"\"\"\n000111222333444555666777888999\n\ud83e\udf26\ud83e\udf02\ud83e\udf27\ud83e\udf1e\ud83e\udf2b \ud83e\udf07\ud83e\udf02\ud83e\udf27\ud83e\udf01\ud83e\udf02\ud83e\udf27 \ud83e\udf1e\ud83e\udf2b\u2590\ud83e\udf02\ud83e\udf02\ud83e\udf1e\ud83e\udf05\ud83e\udf00\ud83e\udf01\ud83e\udf02\ud83e\udf19\ud83e\udf26\ud83e\udf02\ud83e\udf27\ud83e\udf26\ud83e\udf02\ud83e\udf27\n\u2590\ud83e\udf01\u2590 \u2590 \ud83e\udf1e\ud83e\udf05\ud83e\udf00 \ud83e\udf02\ud83e\udf27\ud83e\udf07\ud83e\udf0c\ud83e\udf2b\ud83e\udf01\ud83e\udf02\ud83e\udf27\u2590\ud83e\udf02\ud83e\udf27 \ud83e\udf14 \ud83e\udf26\ud83e\udf02\ud83e\udf27 \ud83e\udf02\ud83e\udf19\n \ud83e\udf02\ud83e\udf00 \ud83e\udf01 \ud83e\udf01\ud83e\udf02\ud83e\udf02\ud83e\udf01\ud83e\udf02\ud83e\udf00  \ud83e\udf01\ud83e\udf01\ud83e\udf02\ud83e\udf00 \ud83e\udf02\ud83e\udf00 \ud83e\udf00  \ud83e\udf02\ud83e\udf00 \ud83e\udf02\n\"\"\",\n        \"\"\"\n\\\"\\\"\\\"\n \ud83e\udf04\ud83e\udf04\n\n\n\"\"\",\n        \"\"\"\n:::;;;<<<===>>>???@@@\n \ud83e\udf2d  \ud83e\udf2d  \ud83e\udf16\ud83e\udf00   \ud83e\udf01\ud83e\udf22 \ud83e\udf07\ud83e\udf02\ud83e\udf27\ud83e\udf26\ud83e\udf02\ud83e\udf27\n \ud83e\udf30  \ud83e\udf30 \ud83e\udf01\ud83e\udf22 \ud83e\udf20\ud83e\udf30\ud83e\udf30 \ud83e\udf16\ud83e\udf00 \ud83e\udf07\ud83e\udf00\u2590\ud83e\udf09\ud83e\udf05\n \ud83e\udf02  \ud83e\udf05   \ud83e\udf00   \ud83e\udf01   \ud83e\udf01  \ud83e\udf02\ud83e\udf00\n\"\"\",\n        \"\"\"\nAAABBBCCCDDDEEEFFFGGGHHHIIIJJJKKKLLLMMMNNNOOOPPPQQQ\n\ud83e\udf1e\ud83e\udf05\ud83e\udf22\u2590\ud83e\udf02\ud83e\udf27\ud83e\udf26\ud83e\udf02\ud83e\udf08\u2590\ud83e\udf02\ud83e\udf27\u2590\ud83e\udf02\ud83e\udf02\u2590\ud83e\udf02\ud83e\udf02\ud83e\udf26\ud83e\udf02\ud83e\udf08\u2590 \u2590 \ud83e\udf28\ud83e\udf00  \u2590\u2590\ud83e\udf1e\ud83e\udf05\u2590  \u2590\ud83e\udf22\ud83e\udf2b\u2590\ud83e\udf22\u2590\ud83e\udf26\ud83e\udf02\ud83e\udf27\u2590\ud83e\udf02\ud83e\udf27\ud83e\udf26\ud83e\udf02\ud83e\udf27\n\u2590\ud83e\udf0b\ud83e\udf2b\u2590\ud83e\udf02\ud83e\udf27\u2590 \ud83e\udf1e\u2590 \u2590\u2590\ud83e\udf02 \u2590\ud83e\udf02 \u2590 \ud83e\udf28\u2590\ud83e\udf02\ud83e\udf28 \u2590 \ud83e\udf1e \u2590\u2590\ud83e\udf08\ud83e\udf0f\u2590  \u2590\ud83e\udf01\u2590\u2590 \ud83e\udf28\u2590 \u2590\u2590\ud83e\udf02\ud83e\udf00\u2590\ud83e\udf07\ud83e\udf18\n\ud83e\udf01 \ud83e\udf01\ud83e\udf01\ud83e\udf02\ud83e\udf00 \ud83e\udf02\ud83e\udf00\ud83e\udf01\ud83e\udf02\ud83e\udf00\ud83e\udf01\ud83e\udf02\ud83e\udf02\ud83e\udf01   \ud83e\udf02\ud83e\udf02\ud83e\udf01 \ud83e\udf01 \ud83e\udf02\ud83e\udf00 \ud83e\udf02\ud83e\udf00\ud83e\udf01 \ud83e\udf01\ud83e\udf01\ud83e\udf02\ud83e\udf02\ud83e\udf01 \ud83e\udf01\ud83e\udf01 \ud83e\udf01 \ud83e\udf02\ud83e\udf00\ud83e\udf01   \ud83e\udf02\ud83e\udf01\n\"\"\",\n        \"\"\"\nRRRSSSTTTUUUVVVWWWXXXYYYZZZ[[[]]]^^^___```\n\u2590\ud83e\udf02\ud83e\udf27\ud83e\udf26\ud83e\udf02\ud83e\udf08\ud83e\udf01\ud83e\udf28\ud83e\udf02\u2590 \u2590\u2590 \u2590\u2590 \u2590\ud83e\udf09\ud83e\udf0f\ud83e\udf18\u2590 \u2590\ud83e\udf01\ud83e\udf02\ud83e\udf19 \ud83e\udf15\ud83e\udf00 \ud83e\udf02\u258c\ud83e\udf1e\ud83e\udf05\ud83e\udf22    \ud83e\udf08\ud83e\udf0f\n\u2590\ud83e\udf0a\ud83e\udf10\ud83e\udf1e\ud83e\udf02\ud83e\udf27 \u2590 \u2590 \u2590\ud83e\udf09\ud83e\udf0f\ud83e\udf18\u2590\ud83e\udf16\ud83e\udf37\ud83e\udf1e\ud83e\udf05\ud83e\udf22 \ud83e\udf27\ud83e\udf00\ud83e\udf1e\ud83e\udf05  \u258c   \u258c\n\ud83e\udf01 \ud83e\udf01 \ud83e\udf02\ud83e\udf00 \ud83e\udf01  \ud83e\udf02\ud83e\udf00 \ud83e\udf01 \ud83e\udf01 \ud83e\udf01\ud83e\udf01 \ud83e\udf01 \ud83e\udf01 \ud83e\udf01\ud83e\udf02\ud83e\udf02 \ud83e\udf02\ud83e\udf00 \ud83e\udf02\ud83e\udf00   \ud83e\udf02\ud83e\udf02\ud83e\udf02\n\"\"\",\n        \"\"\"\n\\\\\\\\\\\\\n\ud83e\udf07\ud83e\udf0f\n \ud83e\udf01\ud83e\udf22\n\n\"\"\",\n    )",
  "class Sextant2x2Font(Font):\n    name = \"Sextant 2x2\"\n    height = 2\n    data = \"\"\"\n..,,%%00112233445566778899\n    \ud83e\udf01\ud83e\udf16\u2590\ud83e\udf28\ud83e\udf07\u258c\ud83e\udf01\ud83e\udf17\ud83e\udf20\ud83e\udf38\ud83e\udf26\u2590\u2590\ud83e\udf12\u2590\ud83e\udf2d\ud83e\udf01\ud83e\udf19\u2590\ud83e\udf38\u2590\ud83e\udf38\n\ud83e\udf07 \ud83e\udf07\ud83e\udf00\ud83e\udf01\ud83e\udf07\ud83e\udf09\ud83e\udf0d \ud83e\udf04\ud83e\udf09\ud83e\udf0b\ud83e\udf07\ud83e\udf0d\ud83e\udf01\ud83e\udf0a\ud83e\udf07\ud83e\udf05\ud83e\udf09\ud83e\udf0d \ud83e\udf04\ud83e\udf09\ud83e\udf0d \ud83e\udf09\n\"\"\"",
  "class HalfBlock5x4Font(Font):\n    name = \"Half Block 5x4\"\n    height = 4\n    data = (\n        \"\"\"\n00000111112222233333444445555566666777778888899999  !!\n\u2584\u2580\u2580\u2584  \u2584\u2588  \u2584\u2580\u2580\u2584 \u2584\u2580\u2580\u2584 \u2584  \u2588 \u2588\u2580\u2580\u2580 \u2584\u2580\u2580  \u2580\u2580\u2580\u2588 \u2584\u2580\u2580\u2584 \u2584\u2580\u2580\u2584   \u2588\n\u2588  \u2588   \u2588    \u2584\u2580   \u2584\u2580 \u2588\u2584\u2584\u2588 \u2588\u2584\u2584  \u2588\u2584\u2584    \u2590\u258c \u2580\u2584\u2584\u2580 \u2580\u2584\u2584\u2588   \u2588\n\u2588  \u2588   \u2588  \u2584\u2580   \u2584  \u2588    \u2588    \u2588 \u2588  \u2588   \u2588  \u2588  \u2588    \u2588   \u2580\n \u2580\u2580   \u2580\u2580\u2580 \u2580\u2580\u2580\u2580  \u2580\u2580     \u2580 \u2580\u2580\u2580   \u2580\u2580    \u2580   \u2580\u2580   \u2580\u2580    \u2580\n\"\"\",\n        '''\n\"\"\"######$$$$$$%%%%%&&&&&((()))******++++++,,,-----..////::;;;\n\u2588\u2590\u258c \u2588 \u2588  \u2584\u2580\u2588\u2580\u2584 \u2590\u258c\u2590\u258c \u2584\u2580\u2584   \u2588 \u2588   \u2584 \u2584    \u2584              \u2590\u258c\n   \u2580\u2588\u2580\u2588\u2580 \u2580\u2584\u2588\u2584    \u2588  \u2580\u2584\u2580  \u2590\u258c \u2590\u258c \u2584\u2584\u2588\u2584\u2584 \u2584\u2584\u2588\u2584\u2584    \u2584\u2584\u2584\u2584    \u2588  \u2580  \u2580\n   \u2580\u2588\u2580\u2588\u2580 \u2584 \u2588 \u2588  \u2590\u258c\u2584 \u2588 \u2580\u2584\u258c\u2590\u258c \u2590\u258c  \u2584\u2580\u2584    \u2588             \u2590\u258c  \u2580 \u2584\u2580\n    \u2580 \u2580   \u2580\u2580\u2580   \u2580 \u2580  \u2580\u2580   \u2580 \u2580              \u2584\u2580      \u2580 \u2580\n''',\n        r\"\"\"\n<<<<<=====>>>>>?????@@@@@@[[[[\\\\\\\\]]]]^^^^____```{{{{||}}}}~~~~''```\n  \u2584\u2580      \u2580\u2584   \u2584\u2580\u2580\u2584 \u2584\u2580\u2580\u2580\u2584 \u2588\u2580\u2580 \u2590\u258c  \u2580\u2580\u2588 \u2584\u2580\u2584     \u2580\u2584  \u2584\u2580 \u2588 \u2580\u2584   \u2584  \u2588 \u2584\u2580\n\u2584\u2580   \u2580\u2580\u2580\u2580   \u2580\u2584   \u2584\u2580 \u2588 \u2588\u2580\u2588 \u2588    \u2588    \u2588            \u2584\u2580  \u2588  \u2580\u2584 \u2590\u2590\u258c\u258c\n \u2580\u2584  \u2580\u2580\u2580\u2580  \u2584\u2580    \u2580  \u2588 \u2580\u2580\u2580 \u2588    \u2590\u258c   \u2588             \u2588  \u2588  \u2588    \u2580\n   \u2580      \u2580      \u2580   \u2580\u2580\u2580  \u2580\u2580\u2580   \u2580 \u2580\u2580\u2580     \u2580\u2580\u2580\u2580     \u2580 \u2580 \u2580\n\"\"\",\n        \"\"\"\nAAAAABBBBBCCCCCDDDDDEEEEEFFFFFGGGGGHHHHHIIJJJJJKKKKK\n\u2584\u2580\u2580\u2584 \u2588\u2580\u2580\u2584 \u2584\u2580\u2580\u2584 \u2588\u2580\u2580\u2584 \u2588\u2580\u2580\u2580 \u2588\u2580\u2580\u2580 \u2584\u2580\u2580\u2584 \u2588  \u2588 \u2588    \u2588 \u2588  \u2588\n\u2588\u2584\u2584\u2588 \u2588\u2584\u2584\u2580 \u2588    \u2588  \u2588 \u2588\u2584\u2584  \u2588\u2584\u2584  \u2588    \u2588\u2584\u2584\u2588 \u2588    \u2588 \u2588\u2584\u2580\n\u2588  \u2588 \u2588  \u2588 \u2588  \u2584 \u2588  \u2588 \u2588    \u2588    \u2588 \u2580\u2588 \u2588  \u2588 \u2588 \u2584  \u2588 \u2588 \u2580\u2584\n\u2580  \u2580 \u2580\u2580\u2580   \u2580\u2580  \u2580\u2580\u2580  \u2580\u2580\u2580\u2580 \u2580     \u2580\u2580  \u2580  \u2580 \u2580  \u2580\u2580  \u2580  \u2580\n\"\"\",\n        \"\"\"\nLLLLLMMMMMMNNNNNOOOOOPPPPPQQQQQRRRRRSSSSSTTTTT\n\u2588    \u2588\u2584 \u2584\u2588 \u2588\u2588 \u2588 \u2584\u2580\u2580\u2584 \u2588\u2580\u2580\u2584 \u2584\u2580\u2580\u2584 \u2588\u2580\u2580\u2584 \u2584\u2580\u2580\u2584 \u2580\u2580\u2588\u2580\u2580\n\u2588    \u2588 \u2580 \u2588 \u2588\u2590\u258c\u2588 \u2588  \u2588 \u2588\u2584\u2584\u2580 \u2588  \u2588 \u2588\u2584\u2584\u2580 \u2580\u2584\u2584    \u2588\n\u2588    \u2588   \u2588 \u2588 \u2588\u2588 \u2588  \u2588 \u2588    \u2588 \u258c\u2588 \u2588  \u2588 \u2584  \u2588   \u2588\n\u2580\u2580\u2580\u2580 \u2580   \u2580 \u2580  \u2580  \u2580\u2580  \u2580     \u2580\u2580\u258c \u2580  \u2580  \u2580\u2580    \u2580\n\"\"\",\n        \"\"\"\nUUUUUVVVVVVWWWWWWXXXXXXYYYYYYZZZZZ\n\u2588  \u2588 \u2588   \u2588 \u2588   \u2588 \u2588   \u2588 \u2588   \u2588 \u2580\u2580\u2580\u2588\n\u2588  \u2588 \u2590\u258c \u2590\u258c \u2588 \u2584 \u2588  \u2580\u2584\u2580   \u2580\u2584\u2580   \u2584\u2580\n\u2588  \u2588  \u2588 \u2588  \u2590\u258c\u2588\u2590\u258c \u2584\u2580 \u2580\u2584   \u2588   \u2588\n \u2580\u2580    \u2580    \u2580 \u2580  \u2580   \u2580   \u2580   \u2580\u2580\u2580\u2580\n\"\"\",\n        \"\"\"\naaaaabbbbbcccccdddddeeeeeffffggggghhhhhiijjjjkkkkk\n     \u2588            \u2588       \u2584\u2580\u2580     \u2588    \u2584   \u2584 \u2588\n \u2580\u2580\u2584 \u2588\u2580\u2580\u2584 \u2584\u2580\u2580\u2584 \u2584\u2580\u2580\u2588 \u2584\u2580\u2580\u2584 \u2580\u2588\u2580 \u2584\u2580\u2580\u2584 \u2588\u2580\u2580\u2584 \u2584   \u2584 \u2588 \u2584\u2580\n\u2584\u2580\u2580\u2588 \u2588  \u2588 \u2588  \u2584 \u2588  \u2588 \u2588\u2580\u2580   \u2588  \u2580\u2584\u2584\u2588 \u2588  \u2588 \u2588   \u2588 \u2588\u2580\u2584\n \u2580\u2580\u2580 \u2580\u2580\u2580   \u2580\u2580   \u2580\u2580\u2580  \u2580\u2580   \u2580   \u2584\u2584\u2580 \u2580  \u2580 \u2580 \u2584\u2584\u2580 \u2580  \u2580\n\"\"\",\n        \"\"\"\nllmmmmmmnnnnnooooopppppqqqqqrrrrssssstttt\n\u2588                                     \u2588\n\u2588 \u2588\u2580\u2584\u2580\u2584 \u2588\u2580\u2580\u2584 \u2584\u2580\u2580\u2584 \u2588\u2580\u2580\u2584 \u2584\u2580\u2580\u2588 \u2588\u2580\u2580 \u2584\u2580\u2580\u2580 \u2580\u2588\u2580\n\u2588 \u2588 \u2588 \u2588 \u2588  \u2588 \u2588  \u2588 \u2588  \u2588 \u2588  \u2588 \u2588    \u2580\u2580\u2584  \u2588\n\u2580 \u2580   \u2580 \u2580  \u2580  \u2580\u2580  \u2588\u2580\u2580   \u2580\u2580\u2588 \u2580   \u2580\u2580\u2580    \u2580\n\"\"\",\n        \"\"\"\nuuuuuvvvvvwwwwwwxxxxxxyyyyyzzzzz\n\n\u2588  \u2588 \u2588  \u2588 \u2588 \u2584 \u2588 \u2580\u2584 \u2584\u2580 \u2588  \u2588 \u2580\u2580\u2588\u2580\n\u2588  \u2588 \u2590\u258c\u2590\u258c \u2590\u258c\u2588\u2590\u258c  \u2584\u2580\u2584  \u2580\u2584\u2584\u2588 \u2584\u2580\n \u2580\u2580   \u2580\u2580   \u2580 \u2580  \u2580   \u2580  \u2584\u2584\u2580 \u2580\u2580\u2580\u2580\n\"\"\",\n    )",
  "class HalfBlock6x5Font(Font):\n    name = \"Half Block 6x5\"\n    height = 5\n    data = \"\"\"\n000000111111222222333333444444555555666666777777888888999999  ..::////\n\u2584\u2580\u2580\u2580\u2584  \u2584\u2588   \u2584\u2580\u2580\u2580\u2584 \u2584\u2580\u2580\u2580\u2584 \u2584  \u2588  \u2588\u2580\u2580\u2580\u2580 \u2584\u2580\u2580\u2580  \u2580\u2580\u2580\u2580\u2588 \u2584\u2580\u2580\u2580\u2584 \u2584\u2580\u2580\u2580\u2584         \u2588\n\u2588   \u2588   \u2588       \u2588     \u2588 \u2588  \u2588  \u2588     \u2588        \u2590\u258c \u2588   \u2588 \u2588   \u2588     \u2580  \u2590\u258c\n\u2588   \u2588   \u2588     \u2584\u2580    \u2580\u2580\u2584 \u2580\u2580\u2580\u2588\u2580 \u2580\u2580\u2580\u2580\u2584 \u2588\u2580\u2580\u2580\u2584    \u2588  \u2584\u2580\u2580\u2580\u2584  \u2580\u2580\u2580\u2588     \u2584  \u2588\n\u2588   \u2588   \u2588   \u2584\u2580    \u2584   \u2588    \u2588      \u2588 \u2588   \u2588   \u2590\u258c  \u2588   \u2588     \u2588       \u2590\u258c\n \u2580\u2580\u2580   \u2580\u2580\u2580  \u2580\u2580\u2580\u2580\u2580  \u2580\u2580\u2580     \u2580  \u2580\u2580\u2580\u2580   \u2580\u2580\u2580    \u2580    \u2580\u2580\u2580   \u2580\u2580\u2580    \u2580   \u2580\n\"\"\"",
  "class HalfBlockHeavy6x5Font(Font):\n    name = \"Half Block Heavy 6x5\"\n    height = 5\n    data = \"\"\"\n000000111111222222333333444444555555666666777777888888999999  ..::////\n\u2584\u2588\u2588\u2588\u2584  \u2590\u2588\u258c  \u2584\u2588\u2588\u2588\u2584 \u2584\u2588\u2588\u2588\u2584    \u2588\u258c \u2588\u2588\u2588\u2588\u2588 \u2584\u2588\u2588\u2588\u2584 \u2588\u2588\u2588\u2588\u2588 \u2584\u2588\u2588\u2588\u2584 \u2584\u2588\u2588\u2588\u2584         \u2588\u258c\n\u2588\u258c \u2590\u2588  \u2580\u2588\u258c  \u2580  \u2590\u2588 \u2580  \u2590\u2588 \u2588\u258c \u2588\u258c \u2588\u258c    \u2588\u258c       \u2588\u258c \u2588\u258c \u2590\u2588 \u2588\u258c \u2590\u2588     \u2588\u258c \u2590\u2588\n\u2588\u258c \u2590\u2588   \u2588\u258c    \u2584\u2588\u2580   \u2588\u2588\u258c \u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2584 \u2588\u2588\u2588\u2588\u2584   \u2590\u2588  \u2590\u2588\u2588\u2588\u258c \u2580\u2588\u2588\u2588\u2588        \u2588\u258c\n\u2588\u258c \u2590\u2588   \u2588\u258c  \u2584\u2588\u2580   \u2584  \u2590\u2588    \u2588\u258c    \u2590\u2588 \u2588\u258c \u2590\u2588   \u2588\u258c  \u2588\u258c \u2590\u2588    \u2590\u2588     \u2588\u258c\u2590\u2588\n\u2580\u2588\u2588\u2588\u2580  \u2588\u2588\u2588\u258c \u2588\u2588\u2588\u2588\u2588 \u2580\u2588\u2588\u2588\u2580    \u2588\u258c \u2588\u2588\u2588\u2588\u2580 \u2580\u2588\u2588\u2588\u2580  \u2590\u2588   \u2580\u2588\u2588\u2588\u2580 \u2580\u2588\u2588\u2588\u2580   \u2588\u258c  \u2588\u258c\n\"\"\"",
  "class Thin6x6Font(Font):\n    name = \"Thin 6x6\"\n    height = 6\n    data = (\n        \"\"\"\n000000111111222222333333444444555555666666777777888888999999''\n\u250c\u2500\u2500\u2500\u2510   \u2510   \u250c\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2510    \u2510  \u250c\u2500\u2500\u2500  \u250c\u2500\u2500\u2500  \u250c\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2510 \u2502\n\u2502   \u2502   \u2502       \u2502     \u2502 \u250c  \u2502  \u2502     \u2502         \u2502 \u2502   \u2502 \u2502   \u2502\n\u2502 / \u2502   \u2502   \u250c\u2500\u2500\u2500\u2518    \u2500\u2524 \u2514\u2500\u2500\u253c\u2500 \u2514\u2500\u2500\u2500\u2510 \u251c\u2500\u2500\u2500\u2510     \u253c \u251c\u2500\u2500\u2500\u2524 \u2514\u2500\u2500\u2500\u2524\n\u2502   \u2502   \u2502   \u2502         \u2502    \u2502      \u2502 \u2502   \u2502     \u2502 \u2502   \u2502     \u2502\n\u2514\u2500\u2500\u2500\u2518   \u2534   \u2514\u2500\u2500\u2500  \u2514\u2500\u2500\u2500\u2518    \u2534   \u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2518     \u2534 \u2514\u2500\u2500\u2500\u2518  \u2500\u2500\u2500\u2518\n\n\"\"\",\n        r'''\n!!   \"\"\"######$$$$$$%%%%%%&&&&&&((()))******++++++\n\u2502    \u2502\u2502  \u250c \u250c  \u250c\u2500\u253c\u2500\u2510 \u250c\u2510  /  \u250c\u2500\u2510   / \\\n\u2502       \u2500\u253c\u2500\u253c\u2500 \u2502 \u2502   \u2514\u2518 /   \u2502 \u2502  \u2502   \u2502  \\ /    \u2502\n\u2502        \u2502 \u2502  \u2514\u2500\u253c\u2500\u2510   /   \u250c\u2500\\\u2518  \u2502   \u2502 \u2500\u2500X\u2500\u2500 \u2500\u2500\u253c\u2500\u2500\n\u2502       \u2500\u253c\u2500\u253c\u2500   \u2502 \u2502  / \u250c\u2510 \u2502  \\, \u2502   \u2502  / \\    \u2502\n.        \u2518 \u2518  \u2514\u2500\u253c\u2500\u2518 /  \u2514\u2518 \u2514\u2500\u2500\u2500\\  \\ /\n\n''',\n        r\"\"\"\n,,-----..//////::;;<<<<=====>>>>??????@@@@@@\n             /                  \u250c\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2510\n            /  . .   / \u2500\u2500\u2500\u2500 \\       \u2502 \u2502\u250c\u2500\u2500\u2524\n  \u2500\u2500\u2500\u2500     /        /        \\    \u250c\u2500\u2518 \u2502\u2502  \u2502\n          /    . ,  \\  \u2500\u2500\u2500\u2500  /    \u2502   \u2502\u2514\u2500\u2500\u2518\n,      . /           \\      /     .   \u2514\u2500\u2500\u2500\u2518\n\n\"\"\",\n        r\"\"\"\n[[\\\\\\\\\\\\]]^^^____``{{||}}~~~~~~\n\u250c \\     \u2510 /\\     \\ \u250c \u2502 \u2510\n\u2502  \\    \u2502          \u2502 \u2502 \u2502 \u250c\u2500\u2510\n\u2502   \\   \u2502          \u2524 \u2502 \u251c   \u2514\u2500\u2518\n\u2502    \\  \u2502          \u2502 \u2502 \u2502\n\u2514     \\ \u2518    \u2500\u2500\u2500\u2500  \u2514 \u2502 \u2518\n\n\"\"\",\n        \"\"\"\nAAAAAABBBBBBCCCCCCDDDDDDEEEEEEFFFFFFGGGGGGHHHHHHIIJJJJJJ\n\u250c\u2500\u2500\u2500\u2510 \u252c\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2510 \u252c\u2500\u2500\u2500\u2510 \u252c\u2500\u2500\u2500\u2510 \u252c\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2510 \u252c   \u252c \u252c     \u252c\n\u2502   \u2502 \u2502   \u2502 \u2502     \u2502   \u2502 \u2502     \u2502     \u2502     \u2502   \u2502 \u2502     \u2502\n\u251c\u2500\u2500\u2500\u2524 \u251c\u2500\u2500\u2500\u2524 \u2502     \u2502   \u2502 \u251c\u2500\u2500   \u251c\u2500\u2500   \u2502 \u2500\u2500\u252c \u251c\u2500\u2500\u2500\u2524 \u2502     \u2502\n\u2502   \u2502 \u2502   \u2502 \u2502     \u2502   \u2502 \u2502     \u2502     \u2502   \u2502 \u2502   \u2502 \u2502 \u252c   \u2502\n\u2534   \u2534 \u2534\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2518 \u2534\u2500\u2500\u2500\u2518 \u2534\u2500\u2500\u2500\u2518 \u2534     \u2514\u2500\u2500\u2500\u2518 \u2534   \u2534 \u2534 \u2514\u2500\u2500\u2500\u2518\n\n\"\"\",\n        \"\"\"\nKKKKKKLLLLLLMMMMMMNNNNNNOOOOOOPPPPPPQQQQQQRRRRRRSSSSSS\n\u252c   \u252c \u252c     \u250c\u2500\u252c\u2500\u2510 \u252c\u2500\u2510 \u252c \u250c\u2500\u2500\u2500\u2510 \u252c\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2510 \u252c\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2510\n\u2502 \u250c\u2500\u2518 \u2502     \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502   \u2502 \u2502   \u2502 \u2502   \u2502 \u2502   \u2502 \u2502\n\u251c\u2500\u2534\u2510  \u2502     \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502   \u2502 \u251c\u2500\u2500\u2500\u2518 \u2502   \u2502 \u251c\u2500\u252c\u2500\u2518 \u2514\u2500\u2500\u2500\u2510\n\u2502  \u2514\u2510 \u2502     \u2502   \u2502 \u2502 \u2502 \u2502 \u2502   \u2502 \u2502     \u2502  \u2510\u2502 \u2502 \u2514\u2500\u2510     \u2502\n\u2534   \u2534 \u2534\u2500\u2500\u2500\u2518 \u2534   \u2534 \u2534 \u2514\u2500\u2534 \u2514\u2500\u2500\u2500\u2518 \u2534     \u2514\u2500\u2500\u253c\u2518 \u2534   \u2534 \u2514\u2500\u2500\u2500\u2518\n                                       \u2514\n\"\"\",\n        \"\"\"\nTTTTTTUUUUUUVVVVVVWWWWWWXXXXXXYYYYYYZZZZZZ\n\u250c\u2500\u252c\u2500\u2510 \u252c   \u252c \u252c   \u252c \u252c   \u252c \u252c   \u252c \u252c   \u252c \u250c\u2500\u2500\u2500\u2510\n  \u2502   \u2502   \u2502 \u2502   \u2502 \u2502   \u2502 \u2514\u2510 \u250c\u2518 \u2502   \u2502   \u250c\u2500\u2518\n  \u2502   \u2502   \u2502 \u2502   \u2502 \u2502 \u2502 \u2502  \u251c\u2500\u2524  \u2514\u2500\u252c\u2500\u2518  \u250c\u2518\n  \u2502   \u2502   \u2502 \u2514\u2510 \u250c\u2518 \u2502 \u2502 \u2502 \u250c\u2518 \u2514\u2510   \u2502   \u250c\u2518\n  \u2534   \u2514\u2500\u2500\u2500\u2518  \u2514\u2500\u2518  \u2514\u2500\u2534\u2500\u2518 \u2534   \u2534   \u2534   \u2514\u2500\u2500\u2500\u2518\n\n\"\"\",\n        \"\"\"\naaaaaabbbbbbccccccddddddeeeeeefffgggggghhhhhhiijjj\n                              \u250c\u2500\u2510\n      \u2502               \u2502       \u2502        \u2502     .  .\n\u250c\u2500\u2500\u2500\u2510 \u251c\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2524 \u250c\u2500\u2500\u2500\u2510 \u253c  \u250c\u2500\u2500\u2500\u2510 \u251c\u2500\u2500\u2500\u2510 \u2510  \u2510\n\u250c\u2500\u2500\u2500\u2524 \u2502   \u2502 \u2502     \u2502   \u2502 \u251c\u2500\u2500\u2500\u2518 \u2502  \u2502   \u2502 \u2502   \u2502 \u2502  \u2502\n\u2514\u2500\u2500\u2500\u2534 \u2514\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2518 \u2534  \u2514\u2500\u2500\u2500\u2524 \u2534   \u2534 \u2534  \u2502\n                                 \u2514\u2500\u2500\u2500\u2518         \u2500\u2518\n\"\"\",\n        \"\"\"\nkkkkkkllmmmmmmnnnnnnooooooppppppqqqqqqrrrrrssssss\n\n\u2502     \u2502\n\u2502 \u250c\u2500  \u2502 \u252c\u2500\u252c\u2500\u2510 \u252c\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2510 \u252c\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2510\n\u251c\u2500\u2534\u2510  \u2502 \u2502 \u2502 \u2502 \u2502   \u2502 \u2502   \u2502 \u2502   \u2502 \u2502   \u2502 \u2502    \u2514\u2500\u2500\u2500\u2510\n\u2534  \u2514\u2500 \u2514 \u2534   \u2534 \u2534   \u2534 \u2514\u2500\u2500\u2500\u2518 \u251c\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2524 \u2534    \u2514\u2500\u2500\u2500\u2518\n                          \u2502         \u2502\n\"\"\",\n        \"\"\"\nttttuuuuuuvvvvvvwwwwwwxxxxxxyyyyyyzzzzzz\n\n \u2502\n\u2500\u253c\u2500 \u252c   \u252c \u252c   \u252c \u252c   \u252c \u2500\u2510 \u250c\u2500 \u252c   \u252c \u2500\u2500\u2500\u2500\u252c\n \u2502  \u2502   \u2502 \u2514\u2510 \u250c\u2518 \u2502 \u2502 \u2502  \u251c\u2500\u2524  \u2502   \u2502 \u250c\u2500\u2500\u2500\u2518\n \u2514\u2500 \u2514\u2500\u2500\u2500\u2534  \u2514\u2500\u2518  \u2514\u2500\u2534\u2500\u2518 \u2500\u2518 \u2514\u2500 \u2514\u2500\u2500\u2500\u2524 \u2534\u2500\u2500\u2500\u2500\n                            \u2514\u2500\u2500\u2500\u2518\n\"\"\",\n    )",
  "class HalfBlock7x7Font(Font):\n    name = \"Half Block 7x7\"\n    height = 7\n    data = (\n        \"\"\"\n0000000111111122222223333333444444455555556666666777777788888889999999'''\n \u2584\u2588\u2588\u2588\u2584   \u2590\u2588\u258c   \u2584\u2588\u2588\u2588\u2584  \u2584\u2588\u2588\u2588\u2584     \u2588\u258c \u2590\u2588\u2588\u2588\u2588\u2588\u258c \u2584\u2588\u2588\u2588\u2584 \u2590\u2588\u2588\u2588\u2588\u2588\u258c \u2584\u2588\u2588\u2588\u2584  \u2584\u2588\u2588\u2588\u2584 \u2590\u2588\n\u2590\u2588   \u2588\u258c  \u2580\u2588\u258c  \u2590\u2588   \u2588\u258c\u2590\u2588   \u2588\u258c\u2590\u2588  \u2588\u258c \u2590\u2588     \u2590\u2588         \u2590\u2588 \u2590\u2588   \u2588\u258c\u2590\u2588   \u2588\u258c\u2590\u2588\n\u2590\u2588 \u2590 \u2588\u258c   \u2588\u258c       \u2588\u258c   \u2590\u2588\u2588 \u2590\u2588\u2588\u2588\u2588\u2588\u258c\u2590\u2588\u2588\u2588\u2588\u2584 \u2590\u2588\u2588\u2588\u2588\u2584     \u2588\u258c  \u2588\u2588\u2588\u2588\u2588  \u2580\u2588\u2588\u2588\u2588\u258c\n\u2590\u2588 \u258c \u2588\u258c   \u2588\u258c     \u2584\u2588\u2580      \u2588\u258c    \u2588\u258c      \u2588\u258c\u2590\u2588   \u2588\u258c   \u2590\u2588  \u2590\u2588   \u2588\u258c     \u2588\u258c\n\u2590\u2588   \u2588\u258c   \u2588\u258c   \u2584\u2588\u2580   \u2590\u2588   \u2588\u258c    \u2588\u258c      \u2588\u258c\u2590\u2588   \u2588\u258c   \u2588\u258c  \u2590\u2588   \u2588\u258c     \u2588\u258c\n \u2580\u2588\u2588\u2588\u2580   \u2588\u2588\u2588\u258c \u2590\u2588\u2588\u2588\u2588\u2588\u258c \u2580\u2588\u2588\u2588\u2580     \u2588\u258c \u2590\u2588\u2588\u2588\u2588\u2580  \u2580\u2588\u2588\u2588\u2580   \u2590\u2588    \u2580\u2588\u2588\u2588\u2580  \u2580\u2588\u2588\u2588\u2580\n\n\"\"\",\n        '''\n!!!   \"\"\"\"\"#######$$$$$$$%%%%%%%&&&&&&&(((())))*******++++++\n\u2590\u2588    \u2590\u2588 \u2588\u258c \u2590\u2588 \u2588\u258c    \u2588    \u2584  \u2588\u258c   \u2584\u2588\u2584    \u2588\u258c\u2590\u2588   \u2584\u2584 \u2584\u2584\n\u2590\u2588    \u2590\u2588 \u2588\u258c\u2590\u2588\u2588\u2588\u2588\u2588\u258c \u2584\u2588\u2588\u2588\u2584 \u2590\u2588\u258c\u2590\u2588   \u2590\u2588 \u2588\u258c  \u2590\u2588  \u2588\u258c  \u2580\u2588\u2584\u2588\u2580   \u2590\u2588\n\u2590\u2588          \u2590\u2588 \u2588\u258c \u2590\u2588\u2584\u2588\u2584\u2584  \u2580 \u2588\u258c    \u2588\u2588\u2588   \u2588\u258c  \u2590\u2588 \u2590\u2588\u2588\u2588\u2588\u2588\u258c \u2588\u2588\u2588\u2588\u258c\n\u2590\u2588         \u2590\u2588\u2588\u2588\u2588\u2588\u258c \u2580\u2580\u2588\u2580\u2588\u258c  \u2590\u2588 \u2584  \u2588\u2588\u2588\u258c\u2584  \u2588\u258c  \u2590\u2588  \u2584\u2588\u2580\u2588\u2584   \u2590\u2588\n            \u2590\u2588 \u2588\u258c  \u2580\u2588\u2588\u2588\u2580   \u2588\u258c\u2590\u2588\u258c\u2590\u2588  \u2588\u258c  \u2590\u2588  \u2588\u258c  \u2580\u2580 \u2580\u2580\n\u2590\u2588                   \u2588    \u2590\u2588  \u2580  \u2580\u2588\u2588\u2580\u2588\u258c  \u2588\u258c\u2590\u2588\n\n''',\n        \"\"\"\n,,,------.../////:::;;;<<<<<<<======>>>>>>>???????@@@@@@@\n               \u2588\u258c          \u2584\u2588\u258c      \u2590\u2588\u2584     \u2584\u2588\u2588\u2588\u2584  \u2584\u2588\u2588\u2588\u2584\n              \u2590\u2588 \u2590\u2588 \u2590\u2588   \u2584\u2588\u2580  \u2590\u2588\u2588\u2588\u2588\u258c  \u2580\u2588\u2584  \u2590\u2588   \u2588\u258c\u2590\u2588 \u2584\u2584\u2588\u258c\n   \u2590\u2588\u2588\u2588\u2588\u258c     \u2588\u258c       \u2590\u2588\u2588              \u2588\u2588\u258c    \u2588\u258c \u2590\u2588\u2590\u2588\u2580\u2588\u258c\n             \u2590\u2588  \u2590\u2588 \u2590\u2588   \u2580\u2588\u2584  \u2590\u2588\u2588\u2588\u2588\u258c  \u2584\u2588\u2580     \u2588\u258c  \u2590\u2588\u2590\u2588\u2584\u2588\u258c\n             \u2588\u258c     \u2580      \u2580\u2588\u258c      \u2590\u2588\u2580           \u2590\u2588 \u2580\u2580\u2580\n\u2590\u2588       \u2590\u2588 \u2590\u2588                                \u2588\u258c   \u2580\u2588\u2588\u2588\u2580\n\u2580\n\"\"\",\n        r\"\"\"\n[[[[\\\\\\\\\\]]]]^^^^^^^_____```{{{{{|||}}}}}~~~~~~~```\n\u2590\u2588\u2588\u258c\u2590\u2588   \u2590\u2588\u2588\u258c  \u2590\u2588\u258c       \u2590\u2588    \u2588\u258c\u2590\u2588 \u2590\u2588           \u2588\u258c\n\u2590\u2588   \u2588\u258c    \u2588\u258c \u2590\u2588 \u2588\u258c       \u2588\u258c  \u2588\u258c \u2590\u2588  \u2590\u2588   \u2584\u2584    \u2590\u2588\n\u2590\u2588   \u2590\u2588    \u2588\u258c\u2590\u2588   \u2588\u258c         \u2584\u2588\u258c \u2590\u2588  \u2590\u2588\u2584 \u2590\u2580\u2580\u2588\u2584\u2584\u258c\n\u2590\u2588    \u2588\u258c   \u2588\u258c                \u2580\u2588\u258c \u2590\u2588  \u2590\u2588\u2580     \u2580\u2580\n\u2590\u2588    \u2590\u2588   \u2588\u258c                 \u2588\u258c \u2590\u2588  \u2590\u2588\n\u2590\u2588\u2588\u258c   \u2588\u258c\u2590\u2588\u2588\u258c       \u2588\u2588\u2588\u2588\u2588      \u2588\u258c\u2590\u2588 \u2590\u2588\n\n\"\"\",\n        \"\"\"\nAAAAAAABBBBBBBCCCCCCCDDDDDDDEEEEEEEFFFFFFFGGGGGGGHHHHHHHIIIIJJJJJJJ\n \u2584\u2588\u2588\u2588\u2584 \u2590\u2588\u2588\u2588\u2588\u2584  \u2584\u2588\u2588\u2588\u2584 \u2590\u2588\u2588\u2588\u2588\u2584 \u2590\u2588\u2588\u2588\u2588\u2588\u258c\u2590\u2588\u2588\u2588\u2588\u2588\u258c \u2584\u2588\u2588\u2588\u2584 \u2590\u2588   \u2588\u258c \u2588\u2588\u258c     \u2588\u258c\n\u2590\u2588   \u2588\u258c\u2590\u2588   \u2588\u258c\u2590\u2588     \u2590\u2588   \u2588\u258c\u2590\u2588     \u2590\u2588     \u2590\u2588     \u2590\u2588   \u2588\u258c \u2590\u2588      \u2588\u258c\n\u2590\u2588\u2588\u2588\u2588\u2588\u258c\u2590\u2588\u2588\u2588\u2588\u2588 \u2590\u2588     \u2590\u2588   \u2588\u258c\u2590\u2588\u2588\u2588\u2588  \u2590\u2588\u2588\u2588\u2588  \u2590\u2588     \u2590\u2588\u2588\u2588\u2588\u2588\u258c \u2590\u2588      \u2588\u258c\n\u2590\u2588   \u2588\u258c\u2590\u2588   \u2588\u258c\u2590\u2588     \u2590\u2588   \u2588\u258c\u2590\u2588     \u2590\u2588     \u2590\u2588  \u2588\u2588\u258c\u2590\u2588   \u2588\u258c \u2590\u2588      \u2588\u258c\n\u2590\u2588   \u2588\u258c\u2590\u2588   \u2588\u258c\u2590\u2588     \u2590\u2588   \u2588\u258c\u2590\u2588     \u2590\u2588     \u2590\u2588   \u2588\u258c\u2590\u2588   \u2588\u258c \u2590\u2588 \u2590\u2588   \u2588\u258c\n\u2590\u2588   \u2588\u258c\u2590\u2588\u2588\u2588\u2588\u2580  \u2580\u2588\u2588\u2588\u2580 \u2590\u2588\u2588\u2588\u2588\u2580 \u2590\u2588\u2588\u2588\u2588\u2588\u258c\u2590\u2588      \u2580\u2588\u2588\u2588\u2580 \u2590\u2588   \u2588\u258c \u2588\u2588\u258c \u2580\u2588\u2588\u2588\u2580\n\n\"\"\",\n        \"\"\"\nKKKKKKKLLLLLLLMMMMMMMMNNNNNNNOOOOOOOPPPPPPPQQQQQQQRRRRRRRSSSSSSS\n\u2590\u2588   \u2588\u258c\u2590\u2588      \u2584\u2588\u258c\u2590\u2588\u2584 \u2590\u2588\u2588  \u2588\u258c \u2584\u2588\u2588\u2588\u2584 \u2590\u2588\u2588\u2588\u2588\u2584  \u2584\u2588\u2588\u2588\u2584 \u2590\u2588\u2588\u2588\u2588\u2584  \u2584\u2588\u2588\u2588\u2584\n\u2590\u2588  \u2588\u258c \u2590\u2588     \u2590\u2588 \u2590\u258c \u2588\u258c\u2590\u2588\u2588\u258c \u2588\u258c\u2590\u2588   \u2588\u258c\u2590\u2588   \u2588\u258c\u2590\u2588   \u2588\u258c\u2590\u2588   \u2588\u258c\u2590\u2588\n\u2590\u2588\u2584\u2588\u258c  \u2590\u2588     \u2590\u2588 \u2590\u258c \u2588\u258c\u2590\u2588\u2590\u2588 \u2588\u258c\u2590\u2588   \u2588\u258c\u2590\u2588\u2588\u2588\u2588\u2580 \u2590\u2588   \u2588\u258c\u2590\u2588\u2588\u2588\u2588\u2588  \u2580\u2588\u2588\u2588\u2584\n\u2590\u2588\u2580\u2588\u258c  \u2590\u2588     \u2590\u2588    \u2588\u258c\u2590\u2588 \u2588\u258c\u2588\u258c\u2590\u2588   \u2588\u258c\u2590\u2588     \u2590\u2588   \u2588\u258c\u2590\u2588   \u2588\u258c     \u2588\u258c\n\u2590\u2588  \u2588\u258c \u2590\u2588     \u2590\u2588    \u2588\u258c\u2590\u2588 \u2590\u2588\u2588\u258c\u2590\u2588   \u2588\u258c\u2590\u2588     \u2590\u2588 \u2588\u258c\u2588\u258c\u2590\u2588   \u2588\u258c     \u2588\u258c\n\u2590\u2588   \u2588\u258c\u2590\u2588\u2588\u2588\u2588\u2588\u258c\u2590\u2588    \u2588\u258c\u2590\u2588  \u2588\u2588\u258c \u2580\u2588\u2588\u2588\u2580 \u2590\u2588      \u2580\u2588\u2588\u2588\u2580 \u2590\u2588   \u2588\u258c \u2580\u2588\u2588\u2588\u2580\n                                               \u2580\u2580\n\"\"\",\n        \"\"\"\nTTTTTTTUUUUUUUVVVVVVVWWWWWWWWXXXXXXXYYYYYYYZZZZZZZ\n \u2588\u2588\u2588\u2588\u2588\u258c\u2590\u2588   \u2588\u258c\u2590\u2588   \u2588\u258c\u2590\u2588    \u2588\u258c\u2590\u2588   \u2588\u258c \u2588\u258c  \u2588\u258c\u2590\u2588\u2588\u2588\u2588\u2588\u258c\n   \u2588\u258c  \u2590\u2588   \u2588\u258c \u2588\u258c \u2590\u2588 \u2590\u2588    \u2588\u258c \u2590\u2588 \u2588\u258c  \u2590\u2588 \u2590\u2588     \u2588\u258c\n   \u2588\u258c  \u2590\u2588   \u2588\u258c \u2590\u2588 \u2588\u258c \u2590\u2588    \u2588\u258c  \u2590\u2588\u258c    \u2590\u2588\u2588     \u2588\u258c\n   \u2588\u258c  \u2590\u2588   \u2588\u258c  \u2588\u2588\u2588  \u2590\u2588 \u2590\u258c \u2588\u258c  \u2588\u2588\u2588     \u2588\u258c    \u2588\u258c\n   \u2588\u258c  \u2590\u2588   \u2588\u258c  \u2590\u2588\u258c  \u2590\u2588 \u2590\u258c \u2588\u258c \u2588\u258c \u2590\u2588    \u2588\u258c   \u2588\u258c\n   \u2588\u258c   \u2580\u2588\u2588\u2588\u2580    \u2588    \u2580\u2588\u258c\u2590\u2588\u2580 \u2590\u2588   \u2588\u258c   \u2588\u258c  \u2590\u2588\u2588\u2588\u2588\u2588\u258c\n\n\"\"\",\n        \"\"\"\naaaaaaabbbbbbbcccccccdddddddeeeeeeefffffggggggghhhhhhhiiijjjj\n       \u2590\u2588                 \u2588\u258c         \u2584\u2588\u258c       \u2590\u2588      \u2588\u258c  \u2588\u258c\n       \u2590\u2588                 \u2588\u258c        \u2590\u2588         \u2590\u2588\n \u2584\u2588\u2588\u2588\u2584 \u2590\u2588\u2588\u2588\u2588\u2584  \u2584\u2588\u2588\u2588\u2584  \u2584\u2588\u2588\u2588\u2588\u258c \u2584\u2588\u2588\u2588\u2584 \u2590\u2588\u2588\u2588  \u2584\u2588\u2588\u2588\u2584 \u2590\u2588\u2588\u2588\u2588\u2584 \u2590\u2588\u258c \u2590\u2588\u258c\n  \u2584\u2584\u2584\u2588\u258c\u2590\u2588   \u2588\u258c\u2590\u2588     \u2590\u2588   \u2588\u258c\u2590\u2588\u2584\u2584\u2584\u2588\u258c \u2590\u2588  \u2590\u2588   \u2588\u258c\u2590\u2588   \u2588\u258c \u2588\u258c  \u2588\u258c\n\u2590\u2588\u2580\u2580\u2580\u2588\u258c\u2590\u2588   \u2588\u258c\u2590\u2588     \u2590\u2588   \u2588\u258c\u2590\u2588\u2580\u2580\u2580   \u2590\u2588  \u2590\u2588\u2584\u2584\u2584\u2588\u258c\u2590\u2588   \u2588\u258c \u2588\u258c  \u2588\u258c\n \u2580\u2588\u2588\u2588\u2588\u258c\u2590\u2588\u2588\u2588\u2588\u2580  \u2580\u2588\u2588\u2588\u2580  \u2580\u2588\u2588\u2588\u2588\u258c \u2580\u2588\u2588\u2588\u2580  \u2590\u2588    \u2580\u2580\u2580\u2588\u258c\u2590\u2588   \u2588\u258c \u2588\u258c  \u2588\u258c\n                                         \u2580\u2588\u2588\u2588\u2580           \u2590\u2588\u2588\n\"\"\",\n        \"\"\"\nkkkkkkkllllmmmmmmmmnnnnnnnooooooopppppppqqqqqqqrrrrrrsssssss\n\u2590\u2588      \u2588\u2588\n\u2590\u2588      \u2590\u2588\n\u2590\u2588  \u2584\u2588\u258c \u2590\u2588  \u2584\u2588\u258c\u2590\u2588\u2584 \u2590\u2588\u2588\u2588\u2588\u2584  \u2584\u2588\u2588\u2588\u2584 \u2590\u2588\u2588\u2588\u2588\u2584  \u2584\u2588\u2588\u2588\u2588\u258c \u2584\u2588\u2588\u2588\u258c \u2584\u2588\u2588\u2588\u2584\n\u2590\u2588\u2584\u2588\u2580   \u2590\u2588 \u2590\u2588 \u2590\u258c \u2588\u258c\u2590\u2588   \u2588\u258c\u2590\u2588   \u2588\u258c\u2590\u2588   \u2588\u258c\u2590\u2588   \u2588\u258c\u2590\u2588    \u2590\u2588\u2584\u2584\u2584\n\u2590\u2588\u2580\u2580\u2588\u2584  \u2590\u2588 \u2590\u2588 \u2590\u258c \u2588\u258c\u2590\u2588   \u2588\u258c\u2590\u2588   \u2588\u258c\u2590\u2588   \u2588\u258c\u2590\u2588   \u2588\u258c\u2590\u2588      \u2580\u2580\u2580\u2588\u258c\n\u2590\u2588   \u2588\u258c \u2590\u2588\u258c\u2590\u2588    \u2588\u258c\u2590\u2588   \u2588\u258c \u2580\u2588\u2588\u2588\u2580 \u2590\u2588\u2588\u2588\u2588\u2580  \u2580\u2588\u2588\u2588\u2588\u258c\u2590\u2588     \u2580\u2588\u2588\u2588\u2580\n                                 \u2590\u2588          \u2588\u258c\n\"\"\",\n        \"\"\"\ntttttuuuuuuuvvvvvvvwwwwwwwwxxxxxxxyyyyyyyzzzzzzz\n  \u2588\u258c\n  \u2588\u258c\n \u2588\u2588\u2588\u258c\u2590\u2588   \u2588\u258c\u2590\u2588   \u2588\u258c\u2590\u2588    \u2588\u258c\u2590\u2588   \u2588\u258c\u2590\u2588   \u2588\u258c\u2590\u2588\u2588\u2588\u2588\u2588\u258c\n  \u2588\u258c \u2590\u2588   \u2588\u258c \u2588\u258c \u2590\u2588 \u2590\u2588    \u2588\u258c \u2580\u2588\u2584\u2588\u2580 \u2590\u2588   \u2588\u258c   \u2584\u2588\u2580\n  \u2588\u258c \u2590\u2588   \u2588\u258c  \u2588\u2588\u2588  \u2590\u2588 \u2590\u258c \u2588\u258c \u2584\u2588\u2580\u2588\u2584 \u2590\u2588\u2584\u2584\u2584\u2588\u258c \u2584\u2588\u2580\n  \u2588\u258c  \u2580\u2588\u2588\u2588\u2580   \u2590\u2588\u258c   \u2580\u2588\u258c\u2590\u2588\u2580 \u2590\u2588   \u2588\u258c  \u2580\u2580\u2580\u2588\u258c\u2590\u2588\u2588\u2588\u2588\u2588\u258c\n                                   \u2580\u2588\u2588\u2588\u2580\n\"\"\",\n    )",
  "def __iter__(self) -> Iterator[str]:\n        \"\"\"Iterate over registered font names.\"\"\"\n        return iter(self.__registered)",
  "def __getitem__(self, item: str) -> FontRegistry | None:\n        \"\"\"Get font by name if registered.\"\"\"\n        return self.__registered.get(item)",
  "def registered(cls) -> Sequence[str]:\n        \"\"\"Registered font names in alphabetical order.\"\"\"\n        return tuple(sorted(cls.__registered))",
  "def as_list(mcs) -> list[tuple[str, FontRegistry]]:\n        \"\"\"List of (font name, font class) tuples.\"\"\"\n        return list(mcs.__registered.items())",
  "def __new__(  # noqa: PYI034  # new can not return Self\n        cls: type[FontRegistry],\n        name: str,\n        bases: tuple[type, ...],\n        namespace: dict[str, typing.Any],\n        **kwds: typing.Any,\n    ) -> FontRegistry:\n        font_name: str = namespace.setdefault(\"name\", kwds.get(\"font_name\", \"\"))\n        font_class = super().__new__(cls, name, bases, namespace)\n        if font_name:\n            if font_name not in cls.__registered:\n                cls.__registered[font_name] = font_class\n            if cls.__registered[font_name] != font_class:\n                warnings.warn(\n                    f\"{font_name!r} is already registered, please override explicit if required or change name\",\n                    FontRegistryWarning,\n                    stacklevel=2,\n                )\n        return font_class",
  "def register(cls, font_name: str) -> None:\n        \"\"\"Register font explicit.\n\n        :param font_name: Font name to use in registration.\n        \"\"\"\n        if not font_name:\n            raise ValueError('\"font_name\" is not set.')\n        cls.__registered[font_name] = cls",
  "def __init__(self) -> None:\n        if not self.height:\n            raise ValueError(f'\"height\" is invalid: {self.height!r}')\n        if not self.data:\n            raise ValueError(f'\"data\" is empty: {self.data!r}')\n\n        self.char: dict[str, tuple[int, list[str]]] = {}\n        self.canvas: dict[str, TextCanvas] = {}\n        self.utf8_required = False\n        data: list[str] = [self._to_text(block) for block in self.data]\n        for gdata in data:\n            self.add_glyphs(gdata)",
  "def __repr__(self) -> str:\n        return f\"{self.__class__.__name__}()\"",
  "def __str__(self) -> str:\n        \"\"\"Font description.\"\"\"\n        return f\"{self.__class__.__name__}():\\n  {self.height!r}\\n  {pformat(self.data, indent=4)}\"",
  "def _to_text(\n        obj: str | bytes,\n        encoding: str = \"utf-8\",\n        errors: Literal[\"strict\", \"ignore\", \"replace\"] = \"strict\",\n    ) -> str:\n        if isinstance(obj, str):\n            return obj\n\n        if isinstance(obj, bytes):\n            warnings.warn(\n                \"Bytes based fonts are deprecated, please switch to the text one\",\n                DeprecationWarning,\n                stacklevel=3,\n            )\n            return obj.decode(encoding, errors)\n\n        raise TypeError(f\"{obj!r} is not str|bytes\")",
  "def add_glyphs(self, gdata: str) -> None:\n        d, utf8_required = separate_glyphs(gdata, self.height)\n        self.char.update(d)\n        self.utf8_required |= utf8_required",
  "def characters(self) -> str:\n        return \"\".join(sorted(self.char))",
  "def char_width(self, character: str) -> int:\n        if character in self.char:\n            return self.char[character][0]\n        return 0",
  "def char_data(self, character: str) -> list[str]:\n        return self.char[character][1]",
  "def render(self, character: str) -> TextCanvas:\n        if character in self.canvas:\n            return self.canvas[character]\n        width, line = self.char[character]\n        byte_lines = []\n        character_set_lines = []\n        for d in line:\n            t, cs = apply_target_encoding(d)\n            byte_lines.append(t)\n            character_set_lines.append(cs)\n\n        try:\n            canv = TextCanvas(byte_lines, None, character_set_lines, maxcol=width, check_width=False)\n        except CanvasError as exc:\n            raise CanvasError(f\"Failed render of {character!r} from line {line!r}:\\n{self}\\n:{exc}\").with_traceback(\n                exc.__traceback__\n            ) from exc\n\n        self.canvas[character] = canv\n        return canv",
  "class CanvasCache:\n    \"\"\"\n    Cache for rendered canvases.  Automatically populated and\n    accessed by Widget render() MetaClass magic, cleared by\n    Widget._invalidate().\n\n    Stores weakrefs to the canvas objects, so an external class\n    must maintain a reference for this cache to be effective.\n    At present the Screen classes store the last topmost canvas\n    after redrawing the screen, keeping the canvases from being\n    garbage collected.\n\n    _widgets[widget] = {(wcls, size, focus): weakref.ref(canvas), ...}\n    _refs[weakref.ref(canvas)] = (widget, wcls, size, focus)\n    _deps[widget} = [dependent_widget, ...]\n    \"\"\"\n    _widgets = {}\n    _refs = {}\n    _deps: dict[Widget, list[Widget]] = {}\n    hits = 0\n    fetches = 0\n    cleanups = 0\n\n    @classmethod\n    def store(cls, wcls, canvas):\n        \"\"\"\n        Store a weakref to canvas in the cache.\n\n        wcls -- widget class that contains render() function\n        canvas -- rendered canvas with widget_info (widget, size, focus)\n        \"\"\"\n        if not canvas.cacheable:\n            return\n\n        assert canvas.widget_info, \"Can't store canvas without widget_info\"\n        widget, size, focus = canvas.widget_info\n        def walk_depends(canv):\n            \"\"\"\n            Collect all child widgets for determining who we\n            depend on.\n            \"\"\"\n            # FIXME: is this recursion necessary?  The cache\n            # invalidating might work with only one level.\n            depends = []\n            for x, y, c, pos in canv.children:\n                if c.widget_info:\n                    depends.append(c.widget_info[0])\n                elif hasattr(c, 'children'):\n                    depends.extend(walk_depends(c))\n            return depends\n\n        # use explicit depends_on if available from the canvas\n        depends_on = getattr(canvas, 'depends_on', None)\n        if depends_on is None and hasattr(canvas, 'children'):\n            depends_on = walk_depends(canvas)\n        if depends_on:\n            for w in depends_on:\n                if w not in cls._widgets:\n                    return\n            for w in depends_on:\n                cls._deps.setdefault(w,[]).append(widget)\n\n        ref = weakref.ref(canvas, cls.cleanup)\n        cls._refs[ref] = (widget, wcls, size, focus)\n        cls._widgets.setdefault(widget, {})[(wcls, size, focus)] = ref\n\n    @classmethod\n    def fetch(cls, widget, wcls, size, focus):\n        \"\"\"\n        Return the cached canvas or None.\n\n        widget -- widget object requested\n        wcls -- widget class that contains render() function\n        size, focus -- render() parameters\n        \"\"\"\n        cls.fetches += 1 # collect stats\n\n        sizes = cls._widgets.get(widget, None)\n        if not sizes:\n            return None\n        ref = sizes.get((wcls, size, focus), None)\n        if not ref:\n            return None\n        canv = ref()\n        if canv:\n            cls.hits += 1 # more stats\n        return canv\n\n    @classmethod\n    def invalidate(cls, widget):\n        \"\"\"\n        Remove all canvases cached for widget.\n        \"\"\"\n        try:\n            for ref in cls._widgets[widget].values():\n                try:\n                    del cls._refs[ref]\n                except KeyError:\n                    pass\n            del cls._widgets[widget]\n        except KeyError:\n            pass\n        if widget not in cls._deps:\n            return\n        dependants = cls._deps.get(widget, [])\n        try:\n            del cls._deps[widget]\n        except KeyError:\n            pass\n        for w in dependants:\n            cls.invalidate(w)\n\n    @classmethod\n    def cleanup(cls, ref):\n        cls.cleanups += 1  # collect stats\n\n        w = cls._refs.get(ref, None)\n        del cls._refs[ref]\n        if not w:\n            return\n        widget, wcls, size, focus = w\n        sizes = cls._widgets.get(widget, None)\n        if not sizes:\n            return\n        try:\n            del sizes[(wcls, size, focus)]\n        except KeyError:\n            pass\n        if not sizes:\n            try:\n                del cls._widgets[widget]\n                del cls._deps[widget]\n            except KeyError:\n                pass\n\n    @classmethod\n    def clear(cls):\n        \"\"\"\n        Empty the cache.\n        \"\"\"\n        cls._widgets = {}\n        cls._refs = {}\n        cls._deps = {}",
  "class CanvasError(Exception):\n    pass",
  "class Canvas:\n    \"\"\"\n    base class for canvases\n    \"\"\"\n    cacheable = True\n\n    _finalized_error = CanvasError(\n        \"This canvas has been finalized. \"\n        \"Use CompositeCanvas to wrap this canvas if \"\n        \"you need to make changes.\"\n    )\n    _renamed_error = CanvasError(\n        \"The old Canvas class is now called \"\n        \"TextCanvas. Canvas is now the base class for all canvas \"\n        \"classes.\"\n    )\n\n    def __init__(\n        self,\n        value1: typing.Any = None,\n        value2: typing.Any = None,\n        value3: typing.Any = None,\n    ) -> None:\n        \"\"\"\n        value1, value2, value3 -- if not None, raise a helpful error:\n            the old Canvas class is now called TextCanvas.\n        \"\"\"\n        if value1 is not None:\n            raise self._renamed_error\n        self._widget_info = None\n        self.coords = {}\n        self.shortcuts = {}\n\n    def finalize(\n        self,\n        widget: Widget,\n        size: tuple[()] | tuple[int] | tuple[int, int],\n        focus: bool,\n    ) -> None:\n        \"\"\"\n        Mark this canvas as finalized (should not be any future\n        changes to its content). This is required before caching\n        the canvas.  This happens automatically after a widget's\n        'render call returns the canvas thanks to some metaclass\n        magic.\n\n        widget -- widget that rendered this canvas\n        size -- size parameter passed to widget's render method\n        focus -- focus parameter passed to widget's render method\n        \"\"\"\n        if self.widget_info:\n            raise self._finalized_error\n        self._widget_info = widget, size, focus\n\n    @property\n    def widget_info(self):\n        return self._widget_info\n\n    def _get_widget_info(self):\n        warnings.warn(\n            f\"Method `{self.__class__.__name__}._get_widget_info` is deprecated, \"\n            f\"please use property `{self.__class__.__name__}.widget_info`\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        return self.widget_info\n\n    @property\n    def text(self) -> list[bytes]:\n        \"\"\"\n        Return the text content of the canvas as a list of strings,\n        one for each row.\n        \"\"\"\n        return [b''.join([text for (attr, cs, text) in row]) for row in self.content()]\n\n    def _text_content(self):\n        warnings.warn(\n            f\"Method `{self.__class__.__name__}._text_content` is deprecated, \"\n            f\"please use property `{self.__class__.__name__}.text`\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        return self.text\n\n    def content(\n        self,\n        trim_left: int = 0,\n        trim_top: int = 0,\n        cols: int | None = None,\n        rows: int | None = None,\n        attr=None,\n    ):\n        raise NotImplementedError()\n\n    def cols(self):\n        raise NotImplementedError()\n\n    def rows(self):\n        raise NotImplementedError()\n\n    def content_delta(self):\n        raise NotImplementedError()\n\n    def get_cursor(self) -> tuple[int, int] | None:\n        c = self.coords.get(\"cursor\", None)\n        if not c:\n            return None\n        return c[:2]  # trim off data part\n\n    def set_cursor(self, c):\n        if self.widget_info and self.cacheable:\n            raise self._finalized_error\n        if c is None:\n            try:\n                del self.coords[\"cursor\"]\n            except KeyError:\n                pass\n            return\n        self.coords[\"cursor\"] = c + (None,)  # data part\n    cursor = property(get_cursor, set_cursor)\n\n    def get_pop_up(self):\n        c = self.coords.get(\"pop up\", None)\n        if not c:\n            return\n        return c\n\n    def set_pop_up(self, w: Widget, left: int, top: int, overlay_width: int, overlay_height: int):\n        \"\"\"\n        This method adds pop-up information to the canvas.  This information\n        is intercepted by a PopUpTarget widget higher in the chain to\n        display a pop-up at the given (left, top) position relative to the\n        current canvas.\n\n        :param w: widget to use for the pop-up\n        :type w: widget\n        :param left: x position for left edge of pop-up >= 0\n        :type left: int\n        :param top: y position for top edge of pop-up >= 0\n        :type top: int\n        :param overlay_width: width of overlay in screen columns > 0\n        :type overlay_width: int\n        :param overlay_height: height of overlay in screen rows > 0\n        :type overlay_height: int\n        \"\"\"\n        if self.widget_info and self.cacheable:\n            raise self._finalized_error\n\n        self.coords[\"pop up\"] = (left, top, (w, overlay_width, overlay_height))\n\n    def translate_coords(self, dx: int, dy: int):\n        \"\"\"\n        Return coords shifted by (dx, dy).\n        \"\"\"\n        d = {}\n        for name, (x, y, data) in self.coords.items():\n            d[name] = (x+dx, y+dy, data)\n        return d",
  "class TextCanvas(Canvas):\n    \"\"\"\n    class for storing rendered text and attributes\n    \"\"\"\n    def __init__(\n        self,\n        text: Sequence[bytes] | None = None,\n        attr=None,\n        cs=None,\n        cursor: tuple[int, int] | None = None,\n        maxcol: int | None = None,\n        check_width: bool = True,\n    ) -> None:\n        \"\"\"\n        text -- list of strings, one for each line\n        attr -- list of run length encoded attributes for text\n        cs -- list of run length encoded character set for text\n        cursor -- (x,y) of cursor or None\n        maxcol -- screen columns taken by this canvas\n        check_width -- check and fix width of all lines in text\n        \"\"\"\n        super().__init__()\n        if text is None:\n            text = []\n\n        if check_width:\n            widths = []\n            for t in text:\n                if not isinstance(t, bytes):\n                    raise CanvasError(\"Canvas text must be plain strings encoded in the screen's encoding\", repr(text))\n                widths.append(calc_width(t, 0, len(t)))\n        else:\n            assert isinstance(maxcol, int)\n            widths = [maxcol] * len(text)\n\n        if maxcol is None:\n            if widths:\n                # find maxcol ourselves\n                maxcol = max(widths)\n            else:\n                maxcol = 0\n\n        if attr is None:\n            attr = [[] for _ in range(len(text))]\n        if cs is None:\n            cs = [[] for _ in range(len(text))]\n\n        # pad text and attr to maxcol\n        for i in range(len(text)):\n            w = widths[i]\n            if w > maxcol:\n                raise CanvasError(f\"Canvas text is wider than the maxcol specified \\n{maxcol!r}\\n{widths!r}\\n{text!r}\")\n            if w < maxcol:\n                text[i] += b''.rjust(maxcol - w)\n            a_gap = len(text[i]) - rle_len(attr[i])\n            if a_gap < 0:\n                raise CanvasError(f\"Attribute extends beyond text \\n{text[i]!r}\\n{attr[i]!r}\")\n            if a_gap:\n                rle_append_modify(attr[i], (None, a_gap))\n\n            cs_gap = len(text[i]) - rle_len( cs[i] )\n            if cs_gap < 0:\n                raise CanvasError(f\"Character Set extends beyond text \\n{text[i]!r}\\n{cs[i]!r}\" )\n            if cs_gap:\n                rle_append_modify( cs[i], (None, cs_gap))\n\n        self._attr = attr\n        self._cs = cs\n        self.cursor = cursor\n        self._text = text\n        self._maxcol = maxcol\n\n    def rows(self) -> int:\n        \"\"\"Return the number of rows in this canvas.\"\"\"\n        rows = len(self._text)\n        assert isinstance(rows, int)\n        return rows\n\n    def cols(self) -> int:\n        \"\"\"Return the screen column width of this canvas.\"\"\"\n        return self._maxcol\n\n    def translated_coords(self, dx: int, dy: int) -> tuple[int, int] | None:\n        \"\"\"\n        Return cursor coords shifted by (dx, dy), or None if there\n        is no cursor.\n        \"\"\"\n        if self.cursor:\n            x, y = self.cursor\n            return x + dx, y + dy\n        return None\n\n    def content(\n        self,\n        trim_left: int = 0,\n        trim_top: int = 0,\n        cols: int = 0,\n        rows: int = 0,\n        attr_map=None,\n    ):\n        \"\"\"\n        Return the canvas content as a list of rows where each row\n        is a list of (attr, cs, text) tuples.\n\n        trim_left, trim_top, cols, rows may be set by\n        CompositeCanvas when rendering a partially obscured\n        canvas.\n        \"\"\"\n        maxcol, maxrow = self.cols(), self.rows()\n        if not cols:\n            cols = maxcol - trim_left\n        if not rows:\n            rows = maxrow - trim_top\n\n        assert 0 <= trim_left < maxcol\n        assert cols > 0 and trim_left + cols <= maxcol\n        assert 0 <= trim_top < maxrow\n        assert rows > 0 and trim_top + rows <= maxrow\n\n        if trim_top or rows < maxrow:\n            text_attr_cs = zip(\n                self._text[trim_top:trim_top+rows],\n                self._attr[trim_top:trim_top+rows],\n                self._cs[trim_top:trim_top+rows])\n        else:\n            text_attr_cs = zip(self._text, self._attr, self._cs)\n\n        for text, a_row, cs_row in text_attr_cs:\n            if trim_left or cols < self._maxcol:\n                text, a_row, cs_row = trim_text_attr_cs(\n                    text, a_row, cs_row, trim_left,\n                    trim_left + cols)\n            attr_cs = rle_product(a_row, cs_row)\n            i = 0\n            row = []\n            for (a, cs), run in attr_cs:\n                if attr_map and a in attr_map:\n                    a = attr_map[a]\n                row.append((a, cs, text[i:i+run]))\n                i += run\n            yield row\n\n    def content_delta(self, other):\n        \"\"\"\n        Return the differences between other and this canvas.\n\n        If other is the same object as self this will return no\n        differences, otherwise this is the same as calling\n        content().\n        \"\"\"\n        if other is self:\n            return [self.cols()] * self.rows()\n        return self.content()",
  "class BlankCanvas(Canvas):\n    \"\"\"\n    a canvas with nothing on it, only works as part of a composite canvas\n    since it doesn't know its own size\n    \"\"\"\n    def __init__(self) -> None:\n        super().__init__(None)\n\n    def content(\n        self,\n        trim_left: int = 0,\n        trim_top: int = 0,\n        cols: int = 0,\n        rows: int = 0,\n        attr=None,\n    ):\n        \"\"\"\n        return (cols, rows) of spaces with default attributes.\n        \"\"\"\n        def_attr = None\n        if attr and None in attr:\n            def_attr = attr[None]\n        line = [(def_attr, None, b''.rjust(cols))]\n        for _ in range(rows):\n            yield line\n\n    def cols(self) -> typing.NoReturn:\n        raise NotImplementedError(\"BlankCanvas doesn't know its own size!\")\n\n    def rows(self) -> typing.NoReturn:\n        raise NotImplementedError(\"BlankCanvas doesn't know its own size!\")\n\n    def content_delta(self) -> typing.NoReturn:\n        raise NotImplementedError(\"BlankCanvas doesn't know its own size!\")",
  "class SolidCanvas(Canvas):\n    \"\"\"\n    A canvas filled completely with a single character.\n    \"\"\"\n    def __init__(self, fill_char, cols: int, rows: int) -> None:\n        super().__init__()\n        end, col = calc_text_pos(fill_char, 0, len(fill_char), 1)\n        assert col == 1, f\"Invalid fill_char: {fill_char!r}\"\n        self._text, cs = apply_target_encoding(fill_char[:end])\n        self._cs = cs[0][0]\n        self.size = cols, rows\n        self.cursor = None\n\n    def cols(self) -> int:\n        return self.size[0]\n\n    def rows(self) -> int:\n        return self.size[1]\n\n    def content(\n        self,\n        trim_left: int = 0,\n        trim_top: int = 0,\n        cols: int | None = None,\n        rows: int | None = None,\n        attr=None,\n    ):\n        if cols is None:\n            cols = self.size[0]\n        if rows is None:\n            rows = self.size[1]\n        def_attr = None\n        if attr and None in attr:\n            def_attr = attr[None]\n\n        line = [(def_attr, self._cs, self._text*cols)]\n        for _ in range(rows):\n            yield line\n\n    def content_delta(self, other):\n        \"\"\"\n        Return the differences between other and this canvas.\n        \"\"\"\n        if other is self:\n            return [self.cols()]*self.rows()\n        return self.content()",
  "class CompositeCanvas(Canvas):\n    \"\"\"\n    class for storing a combination of canvases\n    \"\"\"\n    def __init__(self, canv: Canvas = None) -> None:\n        \"\"\"\n        canv -- a Canvas object to wrap this CompositeCanvas around.\n\n        if canv is a CompositeCanvas, make a copy of its contents\n        \"\"\"\n        # a \"shard\" is a (num_rows, list of cviews) tuple, one for\n        # each cview starting in this shard\n\n        # a \"cview\" is a tuple that defines a view of a canvas:\n        # (trim_left, trim_top, cols, rows, attr_map, canv)\n\n        # a \"shard tail\" is a list of tuples:\n        # (col_gap, done_rows, content_iter, cview)\n\n        # tuples that define the unfinished cviews that are part of\n        # shards following the first shard.\n        super().__init__()\n\n        if canv is None:\n            self.shards = []\n            self.children = []\n        else:\n            if hasattr(canv, \"shards\"):\n                self.shards = canv.shards\n            else:\n                self.shards = [(canv.rows(), [(0, 0, canv.cols(), canv.rows(), None, canv)])]\n            self.children = [(0, 0, canv, None)]\n            self.coords.update(canv.coords)\n            for shortcut in canv.shortcuts:\n                self.shortcuts[shortcut] = \"wrap\"\n\n    def rows(self) -> int:\n        for r, cv in self.shards:\n            try:\n                assert isinstance(r, int)\n            except AssertionError:\n                raise AssertionError(r, cv)\n        rows = sum([r for r, cv in self.shards])\n        assert isinstance(rows, int)\n        return rows\n\n    def cols(self) -> int:\n        if not self.shards:\n            return 0\n        cols = sum([cv[2] for cv in self.shards[0][1]])\n        assert isinstance(cols, int)\n        return cols\n\n    def content(self):\n        \"\"\"\n        Return the canvas content as a list of rows where each row\n        is a list of (attr, cs, text) tuples.\n        \"\"\"\n        shard_tail = []\n        for num_rows, cviews in self.shards:\n            # combine shard and shard tail\n            sbody = shard_body(cviews, shard_tail)\n\n            # output rows\n            for _ in range(num_rows):\n                yield shard_body_row(sbody)\n\n            # prepare next shard tail\n            shard_tail = shard_body_tail(num_rows, sbody)\n\n    def content_delta(self, other):\n        \"\"\"\n        Return the differences between other and this canvas.\n        \"\"\"\n        if not hasattr(other, 'shards'):\n            for row in self.content():\n                yield row\n            return\n\n        shard_tail = []\n        for num_rows, cviews in shards_delta(self.shards, other.shards):\n            # combine shard and shard tail\n            sbody = shard_body(cviews, shard_tail)\n\n            # output rows\n            row = []\n            for _ in range(num_rows):\n                # if whole shard is unchanged, don't keep\n                # calling shard_body_row\n                if len(row) != 1 or type(row[0]) != int:\n                    row = shard_body_row(sbody)\n                yield row\n\n            # prepare next shard tail\n            shard_tail = shard_body_tail(num_rows, sbody)\n\n    def trim(self, top: int, count: int | None = None) -> None:\n        \"\"\"Trim lines from the top and/or bottom of canvas.\n\n        top -- number of lines to remove from top\n        count -- number of lines to keep, or None for all the rest\n        \"\"\"\n        assert top >= 0, f\"invalid trim amount {top:d}!\"\n        assert top < self.rows(), f\"cannot trim {top:d} lines from {self.rows():d}!\"\n        if self.widget_info:\n            raise self._finalized_error\n\n        if top:\n            self.shards = shards_trim_top(self.shards, top)\n\n        if count == 0:\n            self.shards = []\n        elif count is not None:\n            self.shards = shards_trim_rows(self.shards, count)\n\n        self.coords = self.translate_coords(0, -top)\n\n    def trim_end(self, end: int) -> None:\n        \"\"\"Trim lines from the bottom of the canvas.\n\n        end -- number of lines to remove from the end\n        \"\"\"\n        assert end > 0, f\"invalid trim amount {end:d}!\"\n        assert end <= self.rows(), f\"cannot trim {end:d} lines from {self.rows():d}!\"\n        if self.widget_info:\n            raise self._finalized_error\n\n        self.shards = shards_trim_rows(self.shards, self.rows() - end)\n\n    def pad_trim_left_right(self, left: int, right: int) -> None:\n        \"\"\"\n        Pad or trim this canvas on the left and right\n\n        values > 0 indicate screen columns to pad\n        values < 0 indicate screen columns to trim\n        \"\"\"\n        if self.widget_info:\n            raise self._finalized_error\n        shards = self.shards\n        if left < 0 or right < 0:\n            trim_left = max(0, -left)\n            cols = self.cols() - trim_left - max(0, -right)\n            shards = shards_trim_sides(shards, trim_left, cols)\n\n        rows = self.rows()\n        if left > 0 or right > 0:\n            top_rows, top_cviews = shards[0]\n            if left > 0:\n                new_top_cviews = ([(0, 0, left, rows, None, blank_canvas)] + top_cviews)\n            else:\n                new_top_cviews = top_cviews[:]  #copy\n\n            if right > 0:\n                new_top_cviews.append((0, 0, right, rows, None, blank_canvas))\n            shards = [(top_rows, new_top_cviews)] + shards[1:]\n\n        self.coords = self.translate_coords(left, 0)\n        self.shards = shards\n\n    def pad_trim_top_bottom(self, top: int, bottom: int) -> None:\n        \"\"\"\n        Pad or trim this canvas on the top and bottom.\n        \"\"\"\n        if self.widget_info:\n            raise self._finalized_error\n        orig_shards = self.shards\n\n        if top < 0 or bottom < 0:\n            trim_top = max(0, -top)\n            rows = self.rows() - trim_top - max(0, -bottom)\n            self.trim(trim_top, rows)\n\n        cols = self.cols()\n        if top > 0:\n            self.shards = [(top, [(0, 0, cols, top, None, blank_canvas)])] + self.shards\n            self.coords = self.translate_coords(0, top)\n\n        if bottom > 0:\n            if orig_shards is self.shards:\n                self.shards = self.shards[:]\n            self.shards.append((bottom, [(0, 0, cols, bottom, None, blank_canvas)]))\n\n    def overlay(self, other, left: int, top: int) -> None:\n        \"\"\"Overlay other onto this canvas.\"\"\"\n        if self.widget_info:\n            raise self._finalized_error\n\n        width = other.cols()\n        height = other.rows()\n        right = self.cols() - left - width\n        bottom = self.rows() - top - height\n\n        assert right >= 0, f\"top canvas of overlay not the size expected!{repr((other.cols(), left, right, width))}\"\n        assert bottom >= 0, f\"top canvas of overlay not the size expected!{repr((other.rows(), top, bottom, height))}\"\n\n        shards = self.shards\n        top_shards = []\n        side_shards = self.shards\n        bottom_shards = []\n        if top:\n            side_shards = shards_trim_top(shards, top)\n            top_shards = shards_trim_rows(shards, top)\n        if bottom:\n            bottom_shards = shards_trim_top(side_shards, height)\n            side_shards = shards_trim_rows(side_shards, height)\n\n        left_shards = []\n        right_shards = []\n        if left > 0:\n            left_shards = [shards_trim_sides(side_shards, 0, left)]\n        if right > 0:\n            right_shards = [shards_trim_sides(side_shards, max(0, left + width), right)]\n\n        if not self.rows():\n            middle_shards = []\n        elif left or right:\n            middle_shards = shards_join(left_shards + [other.shards] + right_shards)\n        else:\n            middle_shards = other.shards\n\n        self.shards = top_shards + middle_shards + bottom_shards\n\n        self.coords.update(other.translate_coords(left, top))\n\n    def fill_attr(self, a) -> None:\n        \"\"\"\n        Apply attribute a to all areas of this canvas with default\n        attribute currently set to None, leaving other attributes\n        intact.\"\"\"\n        self.fill_attr_apply({None:a})\n\n    def fill_attr_apply(self, mapping) -> None:\n        \"\"\"\n        Apply an attribute-mapping dictionary to the canvas.\n\n        mapping -- dictionary of original-attribute:new-attribute items\n        \"\"\"\n        if self.widget_info:\n            raise self._finalized_error\n\n        shards = []\n        for num_rows, original_cviews in self.shards:\n            new_cviews = []\n            for cv in original_cviews:\n                # cv[4] == attr_map\n                if cv[4] is None:\n                    new_cviews.append(cv[:4] + (mapping,) + cv[5:])\n                else:\n                    combined = dict(mapping)\n                    combined.update([(k, mapping.get(v, v)) for k,v in cv[4].items()])\n                    new_cviews.append(cv[:4] + (combined,) + cv[5:])\n            shards.append((num_rows, new_cviews))\n        self.shards = shards\n\n    def set_depends(self, widget_list):\n        \"\"\"\n        Explicitly specify the list of widgets that this canvas\n        depends on.  If any of these widgets change this canvas\n        will have to be updated.\n        \"\"\"\n        if self.widget_info:\n            raise self._finalized_error\n\n        self.depends_on = widget_list",
  "def shard_body_row(sbody):\n    \"\"\"\n    Return one row, advancing the iterators in sbody.\n\n    ** MODIFIES sbody by calling next() on its iterators **\n    \"\"\"\n    row = []\n    for done_rows, content_iter, cview in sbody:\n        if content_iter:\n            row.extend(next(content_iter))\n        else:\n            # need to skip this unchanged canvas\n            if row and type(row[-1]) == int:\n                row[-1] = row[-1] + cview[2]\n            else:\n                row.append(cview[2])\n\n    return row",
  "def shard_body_tail(num_rows: int, sbody):\n    \"\"\"\n    Return a new shard tail that follows this shard body.\n    \"\"\"\n    shard_tail = []\n    col_gap = 0\n    done_rows = 0\n    for done_rows, content_iter, cview in sbody:\n        cols, rows = cview[2:4]\n        done_rows += num_rows\n        if done_rows == rows:\n            col_gap += cols\n            continue\n        shard_tail.append((col_gap, done_rows, content_iter, cview))\n        col_gap = 0\n    return shard_tail",
  "def shards_delta(shards, other_shards):\n    \"\"\"\n    Yield shards1 with cviews that are the same as shards2\n    having canv = None.\n    \"\"\"\n    other_shards_iter = iter(other_shards)\n    other_num_rows = other_cviews = None\n    done = other_done = 0\n    for num_rows, cviews in shards:\n        if other_num_rows is None:\n            other_num_rows, other_cviews = next(other_shards_iter)\n        while other_done < done:\n            other_done += other_num_rows\n            other_num_rows, other_cviews = next(other_shards_iter)\n        if other_done > done:\n            yield (num_rows, cviews)\n            done += num_rows\n            continue\n        # top-aligned shards, compare each cview\n        yield (num_rows, shard_cviews_delta(cviews, other_cviews))\n        other_done += other_num_rows\n        other_num_rows = None\n        done += num_rows",
  "def shard_cviews_delta(cviews, other_cviews):\n    \"\"\"\n    \"\"\"\n    other_cviews_iter = iter(other_cviews)\n    other_cv = None\n    cols = other_cols = 0\n    for cv in cviews:\n        if other_cv is None:\n            other_cv = next(other_cviews_iter)\n        while other_cols < cols:\n            other_cols += other_cv[2]\n            other_cv = next(other_cviews_iter)\n        if other_cols > cols:\n            yield cv\n            cols += cv[2]\n            continue\n        # top-left-aligned cviews, compare them\n        if cv[5] is other_cv[5] and cv[:5] == other_cv[:5]:\n            yield cv[:5]+(None,)+cv[6:]\n        else:\n            yield cv\n        other_cols += other_cv[2]\n        other_cv = None\n        cols += cv[2]",
  "def shard_body(cviews, shard_tail, create_iter: bool = True, iter_default=None):\n    \"\"\"\n    Return a list of (done_rows, content_iter, cview) tuples for\n    this shard and shard tail.\n\n    If a canvas in cviews is None (eg. when unchanged from\n    shard_cviews_delta()) or if create_iter is False then no\n    iterator is created for content_iter.\n\n    iter_default is the value used for content_iter when no iterator\n    is created.\n    \"\"\"\n    col = 0\n    body = []  # build the next shard tail\n    cviews_iter = iter(cviews)\n    for col_gap, done_rows, content_iter, tail_cview in shard_tail:\n        while col_gap:\n            try:\n                cview = next(cviews_iter)\n            except StopIteration:\n                break\n            (trim_left, trim_top, cols, rows, attr_map, canv) = cview[:6]\n            col += cols\n            col_gap -= cols\n            if col_gap < 0:\n                raise CanvasError(\"cviews overflow gaps in shard_tail!\")\n            if create_iter and canv:\n                new_iter = canv.content(trim_left, trim_top,\n                    cols, rows, attr_map)\n            else:\n                new_iter = iter_default\n            body.append((0, new_iter, cview))\n        body.append((done_rows, content_iter, tail_cview))\n    for cview in cviews_iter:\n        (trim_left, trim_top, cols, rows, attr_map, canv) = cview[:6]\n        if create_iter and canv:\n            new_iter = canv.content(trim_left, trim_top, cols, rows, attr_map)\n        else:\n            new_iter = iter_default\n        body.append((0, new_iter, cview))\n    return body",
  "def shards_trim_top(shards, top: int):\n    \"\"\"\n    Return shards with top rows removed.\n    \"\"\"\n    assert top > 0\n\n    shard_iter = iter(shards)\n    shard_tail = []\n    # skip over shards that are completely removed\n    for num_rows, cviews in shard_iter:\n        if top < num_rows:\n            break\n        sbody = shard_body(cviews, shard_tail, False)\n        shard_tail = shard_body_tail(num_rows, sbody)\n        top -= num_rows\n    else:\n        raise CanvasError(\"tried to trim shards out of existence\")\n\n    sbody = shard_body(cviews, shard_tail, False)\n    shard_tail = shard_body_tail(num_rows, sbody)\n    # trim the top of this shard\n    new_sbody = []\n    for done_rows, content_iter, cv in sbody:\n        new_sbody.append((0, content_iter, cview_trim_top(cv, done_rows + top)))\n    sbody = new_sbody\n\n    new_shards = [(num_rows - top, [cv for done_rows, content_iter, cv in sbody])]\n\n    # write out the rest of the shards\n    new_shards.extend(shard_iter)\n\n    return new_shards",
  "def shards_trim_rows(shards, keep_rows: int):\n    \"\"\"\n    Return the topmost keep_rows rows from shards.\n    \"\"\"\n    assert keep_rows >= 0, keep_rows\n\n    new_shards = []\n    done_rows = 0\n    for num_rows, cviews in shards:\n        if done_rows >= keep_rows:\n            break\n        new_cviews = []\n        for cv in cviews:\n            if cv[3] + done_rows > keep_rows:\n                new_cviews.append(cview_trim_rows(cv,\n                    keep_rows - done_rows))\n            else:\n                new_cviews.append(cv)\n\n        if num_rows + done_rows > keep_rows:\n            new_shards.append((keep_rows - done_rows, new_cviews))\n        else:\n            new_shards.append((num_rows, new_cviews))\n        done_rows += num_rows\n\n    return new_shards",
  "def shards_trim_sides(shards, left: int, cols: int):\n    \"\"\"\n    Return shards with starting from column left and cols total width.\n    \"\"\"\n    assert left >= 0 and cols > 0, (left, cols)\n    shard_tail = []\n    new_shards = []\n    right = left + cols\n    for num_rows, cviews in shards:\n        sbody = shard_body(cviews, shard_tail, False)\n        shard_tail = shard_body_tail(num_rows, sbody)\n        new_cviews = []\n        col = 0\n        for done_rows, content_iter, cv in sbody:\n            cv_cols = cv[2]\n            next_col = col + cv_cols\n            if done_rows or next_col <= left or col >= right:\n                col = next_col\n                continue\n            if col < left:\n                cv = cview_trim_left(cv, left - col)\n                col = left\n            if next_col > right:\n                cv = cview_trim_cols(cv, right - col)\n            new_cviews.append(cv)\n            col = next_col\n        if not new_cviews:\n            prev_num_rows, prev_cviews = new_shards[-1]\n            new_shards[-1] = (prev_num_rows+num_rows, prev_cviews)\n        else:\n            new_shards.append((num_rows, new_cviews))\n    return new_shards",
  "def shards_join(shard_lists):\n    \"\"\"\n    Return the result of joining shard lists horizontally.\n    All shards lists must have the same number of rows.\n    \"\"\"\n    shards_iters = [iter(sl) for sl in shard_lists]\n    shards_current = [next(i) for i in shards_iters]\n\n    new_shards = []\n    while True:\n        new_cviews = []\n        num_rows = min([r for r,cv in shards_current])\n\n        shards_next = []\n        for rows, cviews in shards_current:\n            if cviews:\n                new_cviews.extend(cviews)\n            shards_next.append((rows - num_rows, None))\n\n        shards_current = shards_next\n        new_shards.append((num_rows, new_cviews))\n\n        # advance to next shards\n        try:\n            for i in range(len(shards_current)):\n                if shards_current[i][0] > 0:\n                    continue\n                shards_current[i] = next(shards_iters[i])\n        except StopIteration:\n            break\n    return new_shards",
  "def cview_trim_rows(cv, rows: int):\n    return cv[:3] + (rows,) + cv[4:]",
  "def cview_trim_top(cv, trim: int):\n    return (cv[0], trim + cv[1], cv[2], cv[3] - trim) + cv[4:]",
  "def cview_trim_left(cv, trim: int):\n    return (cv[0] + trim, cv[1], cv[2] - trim,) + cv[3:]",
  "def cview_trim_cols(cv, cols: int):\n    return cv[:2] + (cols,) + cv[3:]",
  "def CanvasCombine(l):\n    \"\"\"Stack canvases in l vertically and return resulting canvas.\n\n    :param l: list of (canvas, position, focus) tuples:\n\n              position\n                a value that widget.set_focus will accept or None if not\n                allowed\n              focus\n                True if this canvas is the one that would be in focus\n                if the whole widget is in focus\n    \"\"\"\n    clist = [(CompositeCanvas(c), p, f) for c, p, f in l]\n\n    combined_canvas = CompositeCanvas()\n    shards = []\n    children = []\n    row = 0\n    focus_index = 0\n    n = 0\n    for canv, pos, focus in clist:\n        if focus:\n            focus_index = n\n        children.append((0, row, canv, pos))\n        shards.extend(canv.shards)\n        combined_canvas.coords.update(canv.translate_coords(0, row))\n        for shortcut in canv.shortcuts.keys():\n            combined_canvas.shortcuts[shortcut] = pos\n        row += canv.rows()\n        n += 1\n\n    if focus_index:\n        children = [children[focus_index]] + children[:focus_index] + children[focus_index+1:]\n\n    combined_canvas.shards = shards\n    combined_canvas.children = children\n    return combined_canvas",
  "def CanvasOverlay(top_c, bottom_c, left: int, top: int):\n    \"\"\"\n    Overlay canvas top_c onto bottom_c at position (left, top).\n    \"\"\"\n    overlayed_canvas = CompositeCanvas(bottom_c)\n    overlayed_canvas.overlay(top_c, left, top)\n    overlayed_canvas.children = [(left, top, top_c, None), (0, 0, bottom_c, None)]\n    overlayed_canvas.shortcuts = {} # disable background shortcuts\n    for shortcut in top_c.shortcuts.keys():\n        overlayed_canvas.shortcuts[shortcut] = \"fg\"\n    return overlayed_canvas",
  "def CanvasJoin(l):\n    \"\"\"\n    Join canvases in l horizontally. Return result.\n\n    :param l: list of (canvas, position, focus, cols) tuples:\n\n              position\n                value that widget.set_focus will accept or None if not allowed\n              focus\n                True if this canvas is the one that would be in focus if\n                the whole widget is in focus\n              cols\n                is the number of screen columns that this widget will require,\n                if larger than the actual canvas.cols() value then this widget\n                will be padded on the right.\n    \"\"\"\n\n    l2 = []\n    focus_item = 0\n    maxrow = 0\n    n = 0\n    for canv, pos, focus, cols in l:\n        rows = canv.rows()\n        pad_right = cols - canv.cols()\n        if focus:\n            focus_item = n\n        if rows > maxrow:\n            maxrow = rows\n        l2.append((canv, pos, pad_right, rows))\n        n += 1\n\n    shard_lists = []\n    children = []\n    joined_canvas = CompositeCanvas()\n    col = 0\n    for canv, pos, pad_right, rows in l2:\n        canv = CompositeCanvas(canv)\n        if pad_right:\n            canv.pad_trim_left_right(0, pad_right)\n        if rows < maxrow:\n            canv.pad_trim_top_bottom(0, maxrow - rows)\n        joined_canvas.coords.update(canv.translate_coords(col, 0))\n        for shortcut in canv.shortcuts.keys():\n            joined_canvas.shortcuts[shortcut] = pos\n        shard_lists.append(canv.shards)\n        children.append((col, 0, canv, pos))\n        col += canv.cols()\n\n    if focus_item:\n        children = [children[focus_item]] + children[:focus_item] + \\\n            children[focus_item+1:]\n\n    joined_canvas.shards = shards_join(shard_lists)\n    joined_canvas.children = children\n    return joined_canvas",
  "def apply_text_layout(text, attr, ls, maxcol: int):\n    t = []\n    a = []\n    c = []\n\n    class AttrWalk:\n        pass\n\n    aw = AttrWalk\n    aw.k = 0  # counter for moving through elements of a\n    aw.off = 0  # current offset into text of attr[ak]\n\n    def arange(start_offs: int, end_offs: int):\n        \"\"\"Return an attribute list for the range of text specified.\"\"\"\n        if start_offs < aw.off:\n            aw.k = 0\n            aw.off = 0\n        o = []\n        # the loop should run at least once, the '=' part ensures that\n        while aw.off <= end_offs:\n            if len(attr) <= aw.k:\n                # run out of attributes\n                o.append((None,end_offs-max(start_offs,aw.off)))\n                break\n            at,run = attr[aw.k]\n            if aw.off+run <= start_offs:\n                # move forward through attr to find start_offs\n                aw.k += 1\n                aw.off += run\n                continue\n            if end_offs <= aw.off+run:\n                o.append((at, end_offs-max(start_offs,aw.off)))\n                break\n            o.append((at, aw.off+run-max(start_offs, aw.off)))\n            aw.k += 1\n            aw.off += run\n        return o\n\n    for line_layout in ls:\n        # trim the line to fit within maxcol\n        line_layout = trim_line(line_layout, text, 0, maxcol)\n\n        line = []\n        linea = []\n        linec = []\n\n        def attrrange(start_offs: int, end_offs: int, destw: int) -> None:\n            \"\"\"\n            Add attributes based on attributes between\n            start_offs and end_offs.\n            \"\"\"\n            if start_offs == end_offs:\n                [(at,run)] = arange(start_offs, end_offs)\n                rle_append_modify( linea, ( at, destw ))\n                return\n            if destw == end_offs-start_offs:\n                for at, run in arange(start_offs, end_offs):\n                    rle_append_modify( linea, ( at, run ))\n                return\n            # encoded version has different width\n            o = start_offs\n            for at, run in arange(start_offs, end_offs):\n                if o+run == end_offs:\n                    rle_append_modify( linea, ( at, destw ))\n                    return\n                tseg = text[o:o+run]\n                tseg, cs = apply_target_encoding( tseg )\n                segw = rle_len(cs)\n\n                rle_append_modify( linea, ( at, segw ))\n                o += run\n                destw -= segw\n\n        for seg in line_layout:\n            #if seg is None: assert 0, ls\n            s = LayoutSegment(seg)\n            if s.end:\n                tseg, cs = apply_target_encoding(\n                    text[s.offs:s.end])\n                line.append(tseg)\n                attrrange(s.offs, s.end, rle_len(cs))\n                rle_join_modify( linec, cs )\n            elif s.text:\n                tseg, cs = apply_target_encoding( s.text )\n                line.append(tseg)\n                attrrange( s.offs, s.offs, len(tseg) )\n                rle_join_modify( linec, cs )\n            elif s.offs:\n                if s.sc:\n                    line.append(b''.rjust(s.sc))\n                    attrrange( s.offs, s.offs, s.sc )\n            else:\n                line.append(b''.rjust(s.sc))\n                linea.append((None, s.sc))\n                linec.append((None, s.sc))\n\n        t.append(b''.join(line))\n        a.append(linea)\n        c.append(linec)\n\n    return TextCanvas(t, a, c, maxcol=maxcol)",
  "def store(cls, wcls, canvas):\n        \"\"\"\n        Store a weakref to canvas in the cache.\n\n        wcls -- widget class that contains render() function\n        canvas -- rendered canvas with widget_info (widget, size, focus)\n        \"\"\"\n        if not canvas.cacheable:\n            return\n\n        assert canvas.widget_info, \"Can't store canvas without widget_info\"\n        widget, size, focus = canvas.widget_info\n        def walk_depends(canv):\n            \"\"\"\n            Collect all child widgets for determining who we\n            depend on.\n            \"\"\"\n            # FIXME: is this recursion necessary?  The cache\n            # invalidating might work with only one level.\n            depends = []\n            for x, y, c, pos in canv.children:\n                if c.widget_info:\n                    depends.append(c.widget_info[0])\n                elif hasattr(c, 'children'):\n                    depends.extend(walk_depends(c))\n            return depends\n\n        # use explicit depends_on if available from the canvas\n        depends_on = getattr(canvas, 'depends_on', None)\n        if depends_on is None and hasattr(canvas, 'children'):\n            depends_on = walk_depends(canvas)\n        if depends_on:\n            for w in depends_on:\n                if w not in cls._widgets:\n                    return\n            for w in depends_on:\n                cls._deps.setdefault(w,[]).append(widget)\n\n        ref = weakref.ref(canvas, cls.cleanup)\n        cls._refs[ref] = (widget, wcls, size, focus)\n        cls._widgets.setdefault(widget, {})[(wcls, size, focus)] = ref",
  "def fetch(cls, widget, wcls, size, focus):\n        \"\"\"\n        Return the cached canvas or None.\n\n        widget -- widget object requested\n        wcls -- widget class that contains render() function\n        size, focus -- render() parameters\n        \"\"\"\n        cls.fetches += 1 # collect stats\n\n        sizes = cls._widgets.get(widget, None)\n        if not sizes:\n            return None\n        ref = sizes.get((wcls, size, focus), None)\n        if not ref:\n            return None\n        canv = ref()\n        if canv:\n            cls.hits += 1 # more stats\n        return canv",
  "def invalidate(cls, widget):\n        \"\"\"\n        Remove all canvases cached for widget.\n        \"\"\"\n        try:\n            for ref in cls._widgets[widget].values():\n                try:\n                    del cls._refs[ref]\n                except KeyError:\n                    pass\n            del cls._widgets[widget]\n        except KeyError:\n            pass\n        if widget not in cls._deps:\n            return\n        dependants = cls._deps.get(widget, [])\n        try:\n            del cls._deps[widget]\n        except KeyError:\n            pass\n        for w in dependants:\n            cls.invalidate(w)",
  "def cleanup(cls, ref):\n        cls.cleanups += 1  # collect stats\n\n        w = cls._refs.get(ref, None)\n        del cls._refs[ref]\n        if not w:\n            return\n        widget, wcls, size, focus = w\n        sizes = cls._widgets.get(widget, None)\n        if not sizes:\n            return\n        try:\n            del sizes[(wcls, size, focus)]\n        except KeyError:\n            pass\n        if not sizes:\n            try:\n                del cls._widgets[widget]\n                del cls._deps[widget]\n            except KeyError:\n                pass",
  "def clear(cls):\n        \"\"\"\n        Empty the cache.\n        \"\"\"\n        cls._widgets = {}\n        cls._refs = {}\n        cls._deps = {}",
  "def __init__(\n        self,\n        value1: typing.Any = None,\n        value2: typing.Any = None,\n        value3: typing.Any = None,\n    ) -> None:\n        \"\"\"\n        value1, value2, value3 -- if not None, raise a helpful error:\n            the old Canvas class is now called TextCanvas.\n        \"\"\"\n        if value1 is not None:\n            raise self._renamed_error\n        self._widget_info = None\n        self.coords = {}\n        self.shortcuts = {}",
  "def finalize(\n        self,\n        widget: Widget,\n        size: tuple[()] | tuple[int] | tuple[int, int],\n        focus: bool,\n    ) -> None:\n        \"\"\"\n        Mark this canvas as finalized (should not be any future\n        changes to its content). This is required before caching\n        the canvas.  This happens automatically after a widget's\n        'render call returns the canvas thanks to some metaclass\n        magic.\n\n        widget -- widget that rendered this canvas\n        size -- size parameter passed to widget's render method\n        focus -- focus parameter passed to widget's render method\n        \"\"\"\n        if self.widget_info:\n            raise self._finalized_error\n        self._widget_info = widget, size, focus",
  "def widget_info(self):\n        return self._widget_info",
  "def _get_widget_info(self):\n        warnings.warn(\n            f\"Method `{self.__class__.__name__}._get_widget_info` is deprecated, \"\n            f\"please use property `{self.__class__.__name__}.widget_info`\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        return self.widget_info",
  "def text(self) -> list[bytes]:\n        \"\"\"\n        Return the text content of the canvas as a list of strings,\n        one for each row.\n        \"\"\"\n        return [b''.join([text for (attr, cs, text) in row]) for row in self.content()]",
  "def _text_content(self):\n        warnings.warn(\n            f\"Method `{self.__class__.__name__}._text_content` is deprecated, \"\n            f\"please use property `{self.__class__.__name__}.text`\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        return self.text",
  "def content(\n        self,\n        trim_left: int = 0,\n        trim_top: int = 0,\n        cols: int | None = None,\n        rows: int | None = None,\n        attr=None,\n    ):\n        raise NotImplementedError()",
  "def cols(self):\n        raise NotImplementedError()",
  "def rows(self):\n        raise NotImplementedError()",
  "def content_delta(self):\n        raise NotImplementedError()",
  "def get_cursor(self) -> tuple[int, int] | None:\n        c = self.coords.get(\"cursor\", None)\n        if not c:\n            return None\n        return c[:2]",
  "def set_cursor(self, c):\n        if self.widget_info and self.cacheable:\n            raise self._finalized_error\n        if c is None:\n            try:\n                del self.coords[\"cursor\"]\n            except KeyError:\n                pass\n            return\n        self.coords[\"cursor\"] = c + (None,)",
  "def get_pop_up(self):\n        c = self.coords.get(\"pop up\", None)\n        if not c:\n            return\n        return c",
  "def set_pop_up(self, w: Widget, left: int, top: int, overlay_width: int, overlay_height: int):\n        \"\"\"\n        This method adds pop-up information to the canvas.  This information\n        is intercepted by a PopUpTarget widget higher in the chain to\n        display a pop-up at the given (left, top) position relative to the\n        current canvas.\n\n        :param w: widget to use for the pop-up\n        :type w: widget\n        :param left: x position for left edge of pop-up >= 0\n        :type left: int\n        :param top: y position for top edge of pop-up >= 0\n        :type top: int\n        :param overlay_width: width of overlay in screen columns > 0\n        :type overlay_width: int\n        :param overlay_height: height of overlay in screen rows > 0\n        :type overlay_height: int\n        \"\"\"\n        if self.widget_info and self.cacheable:\n            raise self._finalized_error\n\n        self.coords[\"pop up\"] = (left, top, (w, overlay_width, overlay_height))",
  "def translate_coords(self, dx: int, dy: int):\n        \"\"\"\n        Return coords shifted by (dx, dy).\n        \"\"\"\n        d = {}\n        for name, (x, y, data) in self.coords.items():\n            d[name] = (x+dx, y+dy, data)\n        return d",
  "def __init__(\n        self,\n        text: Sequence[bytes] | None = None,\n        attr=None,\n        cs=None,\n        cursor: tuple[int, int] | None = None,\n        maxcol: int | None = None,\n        check_width: bool = True,\n    ) -> None:\n        \"\"\"\n        text -- list of strings, one for each line\n        attr -- list of run length encoded attributes for text\n        cs -- list of run length encoded character set for text\n        cursor -- (x,y) of cursor or None\n        maxcol -- screen columns taken by this canvas\n        check_width -- check and fix width of all lines in text\n        \"\"\"\n        super().__init__()\n        if text is None:\n            text = []\n\n        if check_width:\n            widths = []\n            for t in text:\n                if not isinstance(t, bytes):\n                    raise CanvasError(\"Canvas text must be plain strings encoded in the screen's encoding\", repr(text))\n                widths.append(calc_width(t, 0, len(t)))\n        else:\n            assert isinstance(maxcol, int)\n            widths = [maxcol] * len(text)\n\n        if maxcol is None:\n            if widths:\n                # find maxcol ourselves\n                maxcol = max(widths)\n            else:\n                maxcol = 0\n\n        if attr is None:\n            attr = [[] for _ in range(len(text))]\n        if cs is None:\n            cs = [[] for _ in range(len(text))]\n\n        # pad text and attr to maxcol\n        for i in range(len(text)):\n            w = widths[i]\n            if w > maxcol:\n                raise CanvasError(f\"Canvas text is wider than the maxcol specified \\n{maxcol!r}\\n{widths!r}\\n{text!r}\")\n            if w < maxcol:\n                text[i] += b''.rjust(maxcol - w)\n            a_gap = len(text[i]) - rle_len(attr[i])\n            if a_gap < 0:\n                raise CanvasError(f\"Attribute extends beyond text \\n{text[i]!r}\\n{attr[i]!r}\")\n            if a_gap:\n                rle_append_modify(attr[i], (None, a_gap))\n\n            cs_gap = len(text[i]) - rle_len( cs[i] )\n            if cs_gap < 0:\n                raise CanvasError(f\"Character Set extends beyond text \\n{text[i]!r}\\n{cs[i]!r}\" )\n            if cs_gap:\n                rle_append_modify( cs[i], (None, cs_gap))\n\n        self._attr = attr\n        self._cs = cs\n        self.cursor = cursor\n        self._text = text\n        self._maxcol = maxcol",
  "def rows(self) -> int:\n        \"\"\"Return the number of rows in this canvas.\"\"\"\n        rows = len(self._text)\n        assert isinstance(rows, int)\n        return rows",
  "def cols(self) -> int:\n        \"\"\"Return the screen column width of this canvas.\"\"\"\n        return self._maxcol",
  "def translated_coords(self, dx: int, dy: int) -> tuple[int, int] | None:\n        \"\"\"\n        Return cursor coords shifted by (dx, dy), or None if there\n        is no cursor.\n        \"\"\"\n        if self.cursor:\n            x, y = self.cursor\n            return x + dx, y + dy\n        return None",
  "def content(\n        self,\n        trim_left: int = 0,\n        trim_top: int = 0,\n        cols: int = 0,\n        rows: int = 0,\n        attr_map=None,\n    ):\n        \"\"\"\n        Return the canvas content as a list of rows where each row\n        is a list of (attr, cs, text) tuples.\n\n        trim_left, trim_top, cols, rows may be set by\n        CompositeCanvas when rendering a partially obscured\n        canvas.\n        \"\"\"\n        maxcol, maxrow = self.cols(), self.rows()\n        if not cols:\n            cols = maxcol - trim_left\n        if not rows:\n            rows = maxrow - trim_top\n\n        assert 0 <= trim_left < maxcol\n        assert cols > 0 and trim_left + cols <= maxcol\n        assert 0 <= trim_top < maxrow\n        assert rows > 0 and trim_top + rows <= maxrow\n\n        if trim_top or rows < maxrow:\n            text_attr_cs = zip(\n                self._text[trim_top:trim_top+rows],\n                self._attr[trim_top:trim_top+rows],\n                self._cs[trim_top:trim_top+rows])\n        else:\n            text_attr_cs = zip(self._text, self._attr, self._cs)\n\n        for text, a_row, cs_row in text_attr_cs:\n            if trim_left or cols < self._maxcol:\n                text, a_row, cs_row = trim_text_attr_cs(\n                    text, a_row, cs_row, trim_left,\n                    trim_left + cols)\n            attr_cs = rle_product(a_row, cs_row)\n            i = 0\n            row = []\n            for (a, cs), run in attr_cs:\n                if attr_map and a in attr_map:\n                    a = attr_map[a]\n                row.append((a, cs, text[i:i+run]))\n                i += run\n            yield row",
  "def content_delta(self, other):\n        \"\"\"\n        Return the differences between other and this canvas.\n\n        If other is the same object as self this will return no\n        differences, otherwise this is the same as calling\n        content().\n        \"\"\"\n        if other is self:\n            return [self.cols()] * self.rows()\n        return self.content()",
  "def __init__(self) -> None:\n        super().__init__(None)",
  "def content(\n        self,\n        trim_left: int = 0,\n        trim_top: int = 0,\n        cols: int = 0,\n        rows: int = 0,\n        attr=None,\n    ):\n        \"\"\"\n        return (cols, rows) of spaces with default attributes.\n        \"\"\"\n        def_attr = None\n        if attr and None in attr:\n            def_attr = attr[None]\n        line = [(def_attr, None, b''.rjust(cols))]\n        for _ in range(rows):\n            yield line",
  "def cols(self) -> typing.NoReturn:\n        raise NotImplementedError(\"BlankCanvas doesn't know its own size!\")",
  "def rows(self) -> typing.NoReturn:\n        raise NotImplementedError(\"BlankCanvas doesn't know its own size!\")",
  "def content_delta(self) -> typing.NoReturn:\n        raise NotImplementedError(\"BlankCanvas doesn't know its own size!\")",
  "def __init__(self, fill_char, cols: int, rows: int) -> None:\n        super().__init__()\n        end, col = calc_text_pos(fill_char, 0, len(fill_char), 1)\n        assert col == 1, f\"Invalid fill_char: {fill_char!r}\"\n        self._text, cs = apply_target_encoding(fill_char[:end])\n        self._cs = cs[0][0]\n        self.size = cols, rows\n        self.cursor = None",
  "def cols(self) -> int:\n        return self.size[0]",
  "def rows(self) -> int:\n        return self.size[1]",
  "def content(\n        self,\n        trim_left: int = 0,\n        trim_top: int = 0,\n        cols: int | None = None,\n        rows: int | None = None,\n        attr=None,\n    ):\n        if cols is None:\n            cols = self.size[0]\n        if rows is None:\n            rows = self.size[1]\n        def_attr = None\n        if attr and None in attr:\n            def_attr = attr[None]\n\n        line = [(def_attr, self._cs, self._text*cols)]\n        for _ in range(rows):\n            yield line",
  "def content_delta(self, other):\n        \"\"\"\n        Return the differences between other and this canvas.\n        \"\"\"\n        if other is self:\n            return [self.cols()]*self.rows()\n        return self.content()",
  "def __init__(self, canv: Canvas = None) -> None:\n        \"\"\"\n        canv -- a Canvas object to wrap this CompositeCanvas around.\n\n        if canv is a CompositeCanvas, make a copy of its contents\n        \"\"\"\n        # a \"shard\" is a (num_rows, list of cviews) tuple, one for\n        # each cview starting in this shard\n\n        # a \"cview\" is a tuple that defines a view of a canvas:\n        # (trim_left, trim_top, cols, rows, attr_map, canv)\n\n        # a \"shard tail\" is a list of tuples:\n        # (col_gap, done_rows, content_iter, cview)\n\n        # tuples that define the unfinished cviews that are part of\n        # shards following the first shard.\n        super().__init__()\n\n        if canv is None:\n            self.shards = []\n            self.children = []\n        else:\n            if hasattr(canv, \"shards\"):\n                self.shards = canv.shards\n            else:\n                self.shards = [(canv.rows(), [(0, 0, canv.cols(), canv.rows(), None, canv)])]\n            self.children = [(0, 0, canv, None)]\n            self.coords.update(canv.coords)\n            for shortcut in canv.shortcuts:\n                self.shortcuts[shortcut] = \"wrap\"",
  "def rows(self) -> int:\n        for r, cv in self.shards:\n            try:\n                assert isinstance(r, int)\n            except AssertionError:\n                raise AssertionError(r, cv)\n        rows = sum([r for r, cv in self.shards])\n        assert isinstance(rows, int)\n        return rows",
  "def cols(self) -> int:\n        if not self.shards:\n            return 0\n        cols = sum([cv[2] for cv in self.shards[0][1]])\n        assert isinstance(cols, int)\n        return cols",
  "def content(self):\n        \"\"\"\n        Return the canvas content as a list of rows where each row\n        is a list of (attr, cs, text) tuples.\n        \"\"\"\n        shard_tail = []\n        for num_rows, cviews in self.shards:\n            # combine shard and shard tail\n            sbody = shard_body(cviews, shard_tail)\n\n            # output rows\n            for _ in range(num_rows):\n                yield shard_body_row(sbody)\n\n            # prepare next shard tail\n            shard_tail = shard_body_tail(num_rows, sbody)",
  "def content_delta(self, other):\n        \"\"\"\n        Return the differences between other and this canvas.\n        \"\"\"\n        if not hasattr(other, 'shards'):\n            for row in self.content():\n                yield row\n            return\n\n        shard_tail = []\n        for num_rows, cviews in shards_delta(self.shards, other.shards):\n            # combine shard and shard tail\n            sbody = shard_body(cviews, shard_tail)\n\n            # output rows\n            row = []\n            for _ in range(num_rows):\n                # if whole shard is unchanged, don't keep\n                # calling shard_body_row\n                if len(row) != 1 or type(row[0]) != int:\n                    row = shard_body_row(sbody)\n                yield row\n\n            # prepare next shard tail\n            shard_tail = shard_body_tail(num_rows, sbody)",
  "def trim(self, top: int, count: int | None = None) -> None:\n        \"\"\"Trim lines from the top and/or bottom of canvas.\n\n        top -- number of lines to remove from top\n        count -- number of lines to keep, or None for all the rest\n        \"\"\"\n        assert top >= 0, f\"invalid trim amount {top:d}!\"\n        assert top < self.rows(), f\"cannot trim {top:d} lines from {self.rows():d}!\"\n        if self.widget_info:\n            raise self._finalized_error\n\n        if top:\n            self.shards = shards_trim_top(self.shards, top)\n\n        if count == 0:\n            self.shards = []\n        elif count is not None:\n            self.shards = shards_trim_rows(self.shards, count)\n\n        self.coords = self.translate_coords(0, -top)",
  "def trim_end(self, end: int) -> None:\n        \"\"\"Trim lines from the bottom of the canvas.\n\n        end -- number of lines to remove from the end\n        \"\"\"\n        assert end > 0, f\"invalid trim amount {end:d}!\"\n        assert end <= self.rows(), f\"cannot trim {end:d} lines from {self.rows():d}!\"\n        if self.widget_info:\n            raise self._finalized_error\n\n        self.shards = shards_trim_rows(self.shards, self.rows() - end)",
  "def pad_trim_left_right(self, left: int, right: int) -> None:\n        \"\"\"\n        Pad or trim this canvas on the left and right\n\n        values > 0 indicate screen columns to pad\n        values < 0 indicate screen columns to trim\n        \"\"\"\n        if self.widget_info:\n            raise self._finalized_error\n        shards = self.shards\n        if left < 0 or right < 0:\n            trim_left = max(0, -left)\n            cols = self.cols() - trim_left - max(0, -right)\n            shards = shards_trim_sides(shards, trim_left, cols)\n\n        rows = self.rows()\n        if left > 0 or right > 0:\n            top_rows, top_cviews = shards[0]\n            if left > 0:\n                new_top_cviews = ([(0, 0, left, rows, None, blank_canvas)] + top_cviews)\n            else:\n                new_top_cviews = top_cviews[:]  #copy\n\n            if right > 0:\n                new_top_cviews.append((0, 0, right, rows, None, blank_canvas))\n            shards = [(top_rows, new_top_cviews)] + shards[1:]\n\n        self.coords = self.translate_coords(left, 0)\n        self.shards = shards",
  "def pad_trim_top_bottom(self, top: int, bottom: int) -> None:\n        \"\"\"\n        Pad or trim this canvas on the top and bottom.\n        \"\"\"\n        if self.widget_info:\n            raise self._finalized_error\n        orig_shards = self.shards\n\n        if top < 0 or bottom < 0:\n            trim_top = max(0, -top)\n            rows = self.rows() - trim_top - max(0, -bottom)\n            self.trim(trim_top, rows)\n\n        cols = self.cols()\n        if top > 0:\n            self.shards = [(top, [(0, 0, cols, top, None, blank_canvas)])] + self.shards\n            self.coords = self.translate_coords(0, top)\n\n        if bottom > 0:\n            if orig_shards is self.shards:\n                self.shards = self.shards[:]\n            self.shards.append((bottom, [(0, 0, cols, bottom, None, blank_canvas)]))",
  "def overlay(self, other, left: int, top: int) -> None:\n        \"\"\"Overlay other onto this canvas.\"\"\"\n        if self.widget_info:\n            raise self._finalized_error\n\n        width = other.cols()\n        height = other.rows()\n        right = self.cols() - left - width\n        bottom = self.rows() - top - height\n\n        assert right >= 0, f\"top canvas of overlay not the size expected!{repr((other.cols(), left, right, width))}\"\n        assert bottom >= 0, f\"top canvas of overlay not the size expected!{repr((other.rows(), top, bottom, height))}\"\n\n        shards = self.shards\n        top_shards = []\n        side_shards = self.shards\n        bottom_shards = []\n        if top:\n            side_shards = shards_trim_top(shards, top)\n            top_shards = shards_trim_rows(shards, top)\n        if bottom:\n            bottom_shards = shards_trim_top(side_shards, height)\n            side_shards = shards_trim_rows(side_shards, height)\n\n        left_shards = []\n        right_shards = []\n        if left > 0:\n            left_shards = [shards_trim_sides(side_shards, 0, left)]\n        if right > 0:\n            right_shards = [shards_trim_sides(side_shards, max(0, left + width), right)]\n\n        if not self.rows():\n            middle_shards = []\n        elif left or right:\n            middle_shards = shards_join(left_shards + [other.shards] + right_shards)\n        else:\n            middle_shards = other.shards\n\n        self.shards = top_shards + middle_shards + bottom_shards\n\n        self.coords.update(other.translate_coords(left, top))",
  "def fill_attr(self, a) -> None:\n        \"\"\"\n        Apply attribute a to all areas of this canvas with default\n        attribute currently set to None, leaving other attributes\n        intact.\"\"\"\n        self.fill_attr_apply({None:a})",
  "def fill_attr_apply(self, mapping) -> None:\n        \"\"\"\n        Apply an attribute-mapping dictionary to the canvas.\n\n        mapping -- dictionary of original-attribute:new-attribute items\n        \"\"\"\n        if self.widget_info:\n            raise self._finalized_error\n\n        shards = []\n        for num_rows, original_cviews in self.shards:\n            new_cviews = []\n            for cv in original_cviews:\n                # cv[4] == attr_map\n                if cv[4] is None:\n                    new_cviews.append(cv[:4] + (mapping,) + cv[5:])\n                else:\n                    combined = dict(mapping)\n                    combined.update([(k, mapping.get(v, v)) for k,v in cv[4].items()])\n                    new_cviews.append(cv[:4] + (combined,) + cv[5:])\n            shards.append((num_rows, new_cviews))\n        self.shards = shards",
  "def set_depends(self, widget_list):\n        \"\"\"\n        Explicitly specify the list of widgets that this canvas\n        depends on.  If any of these widgets change this canvas\n        will have to be updated.\n        \"\"\"\n        if self.widget_info:\n            raise self._finalized_error\n\n        self.depends_on = widget_list",
  "class AttrWalk:\n        pass",
  "def arange(start_offs: int, end_offs: int):\n        \"\"\"Return an attribute list for the range of text specified.\"\"\"\n        if start_offs < aw.off:\n            aw.k = 0\n            aw.off = 0\n        o = []\n        # the loop should run at least once, the '=' part ensures that\n        while aw.off <= end_offs:\n            if len(attr) <= aw.k:\n                # run out of attributes\n                o.append((None,end_offs-max(start_offs,aw.off)))\n                break\n            at,run = attr[aw.k]\n            if aw.off+run <= start_offs:\n                # move forward through attr to find start_offs\n                aw.k += 1\n                aw.off += run\n                continue\n            if end_offs <= aw.off+run:\n                o.append((at, end_offs-max(start_offs,aw.off)))\n                break\n            o.append((at, aw.off+run-max(start_offs, aw.off)))\n            aw.k += 1\n            aw.off += run\n        return o",
  "def walk_depends(canv):\n            \"\"\"\n            Collect all child widgets for determining who we\n            depend on.\n            \"\"\"\n            # FIXME: is this recursion necessary?  The cache\n            # invalidating might work with only one level.\n            depends = []\n            for x, y, c, pos in canv.children:\n                if c.widget_info:\n                    depends.append(c.widget_info[0])\n                elif hasattr(c, 'children'):\n                    depends.extend(walk_depends(c))\n            return depends",
  "def attrrange(start_offs: int, end_offs: int, destw: int) -> None:\n            \"\"\"\n            Add attributes based on attributes between\n            start_offs and end_offs.\n            \"\"\"\n            if start_offs == end_offs:\n                [(at,run)] = arange(start_offs, end_offs)\n                rle_append_modify( linea, ( at, destw ))\n                return\n            if destw == end_offs-start_offs:\n                for at, run in arange(start_offs, end_offs):\n                    rle_append_modify( linea, ( at, run ))\n                return\n            # encoded version has different width\n            o = start_offs\n            for at, run in arange(start_offs, end_offs):\n                if o+run == end_offs:\n                    rle_append_modify( linea, ( at, destw ))\n                    return\n                tseg = text[o:o+run]\n                tseg, cs = apply_target_encoding( tseg )\n                segw = rle_len(cs)\n\n                rle_append_modify( linea, ( at, segw ))\n                o += run\n                destw -= segw",
  "class ListWalkerError(Exception):\n    pass",
  "class ListWalker(metaclass=signals.MetaSignals):\n    signals = [\"modified\"]\n\n    def _modified(self):\n        signals.emit_signal(self, \"modified\")\n\n    def get_focus(self):\n        \"\"\"\n        This default implementation relies on a focus attribute and a\n        __getitem__() method defined in a subclass.\n\n        Override and don't call this method if these are not defined.\n        \"\"\"\n        try:\n            focus = self.focus\n            return self[focus], focus\n        except (IndexError, KeyError, TypeError):\n            return None, None\n\n    def get_next(self, position):\n        \"\"\"\n        This default implementation relies on a next_position() method and a\n        __getitem__() method defined in a subclass.\n\n        Override and don't call this method if these are not defined.\n        \"\"\"\n        try:\n            position = self.next_position(position)\n            return self[position], position\n        except (IndexError, KeyError):\n            return None, None\n\n    def get_prev(self, position):\n        \"\"\"\n        This default implementation relies on a prev_position() method and a\n        __getitem__() method defined in a subclass.\n\n        Override and don't call this method if these are not defined.\n        \"\"\"\n        try:\n            position = self.prev_position(position)\n            return self[position], position\n        except (IndexError, KeyError):\n            return None, None",
  "class SimpleListWalker(MonitoredList, ListWalker):\n    def __init__(self, contents: Iterable[typing.Any], wrap_around: bool = False):\n        \"\"\"\n        contents -- list to copy into this object\n\n        wrap_around -- if true, jumps to beginning/end of list on move\n\n        This class inherits :class:`MonitoredList` which means\n        it can be treated as a list.\n\n        Changes made to this object (when it is treated as a list) are\n        detected automatically and will cause ListBox objects using\n        this list walker to be updated.\n        \"\"\"\n        if not isinstance(contents, Iterable):\n            raise ListWalkerError(f\"SimpleListWalker expecting list like object, got: {contents!r}\")\n        MonitoredList.__init__(self, contents)\n        self.focus = 0\n        self.wrap_around = wrap_around\n\n    @property\n    def contents(self):\n        \"\"\"\n        Return self.\n\n        Provides compatibility with old SimpleListWalker class.\n        \"\"\"\n        return self\n\n    def _get_contents(self):\n        warnings.warn(\n            f\"Method `{self.__class__.__name__}._get_contents` is deprecated, \"\n            f\"please use property`{self.__class__.__name__}.contents`\",\n            DeprecationWarning,\n            stacklevel=3,\n        )\n        return self\n\n    def _modified(self):\n        if self.focus >= len(self):\n            self.focus = max(0, len(self) - 1)\n        ListWalker._modified(self)\n\n    def set_modified_callback(self, callback) -> typing.NoReturn:\n        \"\"\"\n        This function inherited from MonitoredList is not\n        implemented in SimpleListWalker.\n\n        Use connect_signal(list_walker, \"modified\", ...) instead.\n        \"\"\"\n        raise NotImplementedError('Use connect_signal(list_walker, \"modified\", ...) instead.')\n\n    def set_focus(self, position: int) -> None:\n        \"\"\"Set focus position.\"\"\"\n        try:\n            if position < 0 or position >= len(self):\n                raise ValueError\n        except (TypeError, ValueError):\n            raise IndexError(f\"No widget at position {position}\")\n        self.focus = position\n        self._modified()\n\n    def next_position(self, position: int) -> int:\n        \"\"\"\n        Return position after start_from.\n        \"\"\"\n        if len(self) - 1 <= position:\n            if self.wrap_around:\n                return 0\n            raise IndexError\n        return position + 1\n\n    def prev_position(self, position: int) -> int:\n        \"\"\"\n        Return position before start_from.\n        \"\"\"\n        if position <= 0:\n            if self.wrap_around:\n                return len(self) - 1\n            raise IndexError\n        return position - 1\n\n    def positions(self, reverse: bool = False):\n        \"\"\"\n        Optional method for returning an iterable of positions.\n        \"\"\"\n        if reverse:\n            return range(len(self) - 1, -1, -1)\n        return range(len(self))",
  "class SimpleFocusListWalker(ListWalker, MonitoredFocusList):\n    def __init__(self, contents: Iterable[typing.Any], wrap_around: bool = False):\n        \"\"\"\n        contents -- list to copy into this object\n\n        wrap_around -- if true, jumps to beginning/end of list on move\n\n        This class inherits :class:`MonitoredList` which means\n        it can be treated as a list.\n\n        Changes made to this object (when it is treated as a list) are\n        detected automatically and will cause ListBox objects using\n        this list walker to be updated.\n\n        Also, items added or removed before the widget in focus with\n        normal list methods will cause the focus to be updated\n        intelligently.\n        \"\"\"\n        if not isinstance(contents, Iterable):\n            raise ListWalkerError(f\"SimpleFocusListWalker expecting iterable object, got: {contents!r}\")\n        MonitoredFocusList.__init__(self, contents)\n        self.wrap_around = wrap_around\n\n    def set_modified_callback(self, callback) -> typing.NoReturn:\n        \"\"\"\n        This function inherited from MonitoredList is not\n        implemented in SimpleFocusListWalker.\n\n        Use connect_signal(list_walker, \"modified\", ...) instead.\n        \"\"\"\n        raise NotImplementedError('Use connect_signal(list_walker, \"modified\", ...) instead.')\n\n    def set_focus(self, position: int) -> None:\n        \"\"\"Set focus position.\"\"\"\n        self.focus = position\n        self._modified()\n\n    def next_position(self, position: int) -> int:\n        \"\"\"\n        Return position after start_from.\n        \"\"\"\n        if len(self) - 1 <= position:\n            if self.wrap_around:\n                return 0\n            raise IndexError\n        return position + 1\n\n    def prev_position(self, position: int) -> int:\n        \"\"\"\n        Return position before start_from.\n        \"\"\"\n        if position <= 0:\n            if self.wrap_around:\n                return len(self) - 1\n            raise IndexError\n        return position - 1\n\n    def positions(self, reverse: bool = False):\n        \"\"\"\n        Optional method for returning an iterable of positions.\n        \"\"\"\n        if reverse:\n            return range(len(self) - 1, -1, -1)\n        return range(len(self))",
  "class ListBoxError(Exception):\n    pass",
  "class ListBox(Widget, WidgetContainerMixin):\n    \"\"\"\n    a horizontally stacked list of widgets\n    \"\"\"\n\n    _selectable = True\n    _sizing = frozenset([Sizing.BOX])\n\n    def __init__(self, body: ListWalker):\n        \"\"\"\n        :param body: a ListWalker subclass such as\n            :class:`SimpleFocusListWalker` that contains\n            widgets to be displayed inside the list box\n        :type body: ListWalker\n        \"\"\"\n        if getattr(body, 'get_focus', None):\n            self._body: ListWalker = body\n        else:\n            self._body = SimpleListWalker(body)\n\n        self.body = self._body  # Initialization hack\n\n        # offset_rows is the number of rows between the top of the view\n        # and the top of the focused item\n        self.offset_rows = 0\n        # inset_fraction is used when the focused widget is off the\n        # top of the view.  it is the fraction of the widget cut off\n        # at the top.  (numerator, denominator)\n        self.inset_fraction = (0, 1)\n\n        # pref_col is the preferred column for the cursor when moving\n        # between widgets that use the cursor (edit boxes etc.)\n        self.pref_col = 'left'\n\n        # variable for delayed focus change used by set_focus\n        self.set_focus_pending = 'first selectable'\n\n        # variable for delayed valign change used by set_focus_valign\n        self.set_focus_valign_pending = None\n\n    @property\n    def body(self):\n        \"\"\"\n        a ListWalker subclass such as :class:`SimpleFocusListWalker` that contains\n        widgets to be displayed inside the list box\n        \"\"\"\n        return self._body\n\n    @body.setter\n    def body(self, body):\n        try:\n            disconnect_signal(self._body, \"modified\", self._invalidate)\n        except AttributeError:\n            # _body is not yet assigned\n            pass\n        if getattr(body, 'get_focus', None):\n            self._body = body\n        else:\n            self._body = SimpleListWalker(body)\n        try:\n            connect_signal(self._body, \"modified\", self._invalidate)\n        except NameError:\n            # our list walker has no modified signal so we must not\n            # cache our canvases because we don't know when our\n            # content has changed\n            self.render = nocache_widget_render_instance(self)\n        self._invalidate()\n\n    def _get_body(self):\n        warnings.warn(\n            f\"Method `{self.__class__.__name__}._get_body` is deprecated, \"\n            f\"please use property `{self.__class__.__name__}.body`\",\n            DeprecationWarning,\n            stacklevel=3,\n        )\n        return self.body\n\n    def _set_body(self, body):\n        warnings.warn(\n            f\"Method `{self.__class__.__name__}._set_body` is deprecated, \"\n            f\"please use property `{self.__class__.__name__}.body`\",\n            DeprecationWarning,\n            stacklevel=3,\n        )\n        self.body = body\n\n    def __len__(self) -> int:\n        if isinstance(self._body, Sized):\n            return len(self._body)\n        raise AttributeError(f\"{self._body.__class__.__name__} is not Sized\")\n\n    def calculate_visible(self, size: tuple[int, int], focus: bool = False):\n        \"\"\"\n        Returns the widgets that would be displayed in\n        the ListBox given the current *size* and *focus*.\n\n        see :meth:`Widget.render` for parameter details\n\n        :returns: (*middle*, *top*, *bottom*) or (``None``, ``None``, ``None``)\n\n        *middle*\n            (*row offset*(when +ve) or *inset*(when -ve),\n            *focus widget*, *focus position*, *focus rows*,\n            *cursor coords* or ``None``)\n        *top*\n            (*# lines to trim off top*,\n            list of (*widget*, *position*, *rows*) tuples above focus\n            in order from bottom to top)\n        *bottom*\n            (*# lines to trim off bottom*,\n            list of (*widget*, *position*, *rows*) tuples below focus\n            in order from top to bottom)\n        \"\"\"\n        (maxcol, maxrow) = size\n\n        # 0. set the focus if a change is pending\n        if self.set_focus_pending or self.set_focus_valign_pending:\n            self._set_focus_complete((maxcol, maxrow), focus)\n\n        # 1. start with the focus widget\n        focus_widget, focus_pos = self._body.get_focus()\n        if focus_widget is None:  # list box is empty?\n            return None, None, None\n        top_pos = focus_pos\n\n        offset_rows, inset_rows = self.get_focus_offset_inset((maxcol, maxrow))\n        #    force at least one line of focus to be visible\n        if maxrow and offset_rows >= maxrow:\n            offset_rows = maxrow - 1\n\n        #    adjust position so cursor remains visible\n        cursor = None\n        if maxrow and focus_widget.selectable() and focus:\n            if hasattr(focus_widget, 'get_cursor_coords'):\n                cursor = focus_widget.get_cursor_coords((maxcol,))\n\n        if cursor is not None:\n            cx, cy = cursor\n            effective_cy = cy + offset_rows - inset_rows\n\n            if effective_cy < 0:  # cursor above top?\n                inset_rows = cy\n            elif effective_cy >= maxrow:  # cursor below bottom?\n                offset_rows = maxrow - cy - 1\n                if offset_rows < 0:  # need to trim the top\n                    inset_rows, offset_rows = -offset_rows, 0\n\n        #    set trim_top by focus trimmimg\n        trim_top = inset_rows\n        focus_rows = focus_widget.rows((maxcol,), True)\n\n        # 2. collect the widgets above the focus\n        pos = focus_pos\n        fill_lines = offset_rows\n        fill_above = []\n        top_pos = pos\n        while fill_lines > 0:\n            prev, pos = self._body.get_prev(pos)\n            if prev is None:  # run out of widgets above?\n                offset_rows -= fill_lines\n                break\n            top_pos = pos\n\n            p_rows = prev.rows((maxcol,))\n            if p_rows:  # filter out 0-height widgets\n                fill_above.append((prev, pos, p_rows))\n            if p_rows > fill_lines:  # crosses top edge?\n                trim_top = p_rows - fill_lines\n                break\n            fill_lines -= p_rows\n\n        trim_bottom = focus_rows + offset_rows - inset_rows - maxrow\n        if trim_bottom < 0:\n            trim_bottom = 0\n\n        # 3. collect the widgets below the focus\n        pos = focus_pos\n        fill_lines = maxrow - focus_rows - offset_rows + inset_rows\n        fill_below = []\n        while fill_lines > 0:\n            next, pos = self._body.get_next(pos)\n            if next is None:  # run out of widgets below?\n                break\n\n            n_rows = next.rows((maxcol,))\n            if n_rows:  # filter out 0-height widgets\n                fill_below.append((next, pos, n_rows))\n            if n_rows > fill_lines:  # crosses bottom edge?\n                trim_bottom = n_rows - fill_lines\n                fill_lines -= n_rows\n                break\n            fill_lines -= n_rows\n\n        # 4. fill from top again if necessary & possible\n        fill_lines = max(0, fill_lines)\n\n        if fill_lines > 0 and trim_top > 0:\n            if fill_lines <= trim_top:\n                trim_top -= fill_lines\n                offset_rows += fill_lines\n                fill_lines = 0\n            else:\n                fill_lines -= trim_top\n                offset_rows += trim_top\n                trim_top = 0\n        pos = top_pos\n        while fill_lines > 0:\n            prev, pos = self._body.get_prev(pos)\n            if prev is None:\n                break\n\n            p_rows = prev.rows((maxcol,))\n            fill_above.append((prev, pos, p_rows))\n            if p_rows > fill_lines:  # more than required\n                trim_top = p_rows - fill_lines\n                offset_rows += fill_lines\n                break\n            fill_lines -= p_rows\n            offset_rows += p_rows\n\n        # 5. return the interesting bits\n        return (\n            (offset_rows - inset_rows, focus_widget, focus_pos, focus_rows, cursor),\n            (trim_top, fill_above),\n            (trim_bottom, fill_below),\n        )\n\n    def render(self, size: tuple[int, int], focus: bool = False) -> CompositeCanvas | SolidCanvas:\n        \"\"\"\n        Render ListBox and return canvas.\n\n        see :meth:`Widget.render` for details\n        \"\"\"\n        (maxcol, maxrow) = size\n\n        middle, top, bottom = self.calculate_visible((maxcol, maxrow), focus=focus)\n        if middle is None:\n            return SolidCanvas(\" \", maxcol, maxrow)\n\n        _ignore, focus_widget, focus_pos, focus_rows, cursor = middle\n        trim_top, fill_above = top\n        trim_bottom, fill_below = bottom\n\n        combinelist = []\n        rows = 0\n        fill_above.reverse()  # fill_above is in bottom-up order\n        for widget, w_pos, w_rows in fill_above:\n            canvas = widget.render((maxcol,))\n            if w_rows != canvas.rows():\n                raise ListBoxError(\n                    f\"Widget {widget!r} at position {w_pos!r} \"\n                    f\"within listbox calculated {w_rows:d} rows \"\n                    f\"but rendered {canvas.rows():d}!\"\n                )\n            rows += w_rows\n            combinelist.append((canvas, w_pos, False))\n\n        focus_canvas = focus_widget.render((maxcol,), focus=focus)\n\n        if focus_canvas.rows() != focus_rows:\n            raise ListBoxError(\n                f\"Focus Widget {focus_widget!r} at position {focus_pos!r} \"\n                f\"within listbox calculated {focus_rows:d} rows \"\n                f\"but rendered {focus_canvas.rows():d}!\"\n            )\n        c_cursor = focus_canvas.cursor\n        if cursor is not None and cursor != c_cursor:\n            raise ListBoxError(\n                f\"Focus Widget {focus_widget!r} at position {focus_pos!r} \"\n                f\"within listbox calculated cursor coords {cursor!r} \"\n                f\"but rendered cursor coords {c_cursor!r}!\"\n            )\n\n        rows += focus_rows\n        combinelist.append((focus_canvas, focus_pos, True))\n\n        for widget, w_pos, w_rows in fill_below:\n            canvas = widget.render((maxcol,))\n            if w_rows != canvas.rows():\n                raise ListBoxError(\n                    f\"Widget {widget!r} at position {w_pos!r} \"\n                    f\"within listbox calculated {w_rows:d} \"\n                    f\"rows but rendered {canvas.rows():d}!\"\n                )\n            rows += w_rows\n            combinelist.append((canvas, w_pos, False))\n\n        final_canvas = CanvasCombine(combinelist)\n\n        if trim_top:\n            final_canvas.trim(trim_top)\n            rows -= trim_top\n        if trim_bottom:\n            final_canvas.trim_end(trim_bottom)\n            rows -= trim_bottom\n\n        if rows > maxrow:\n            raise ListBoxError(\n                f\"Listbox contents too long!  Probably urwid's fault (please report): {top, middle, bottom!r}\"\n            )\n\n        if rows < maxrow:\n            bottom_pos = focus_pos\n            if fill_below:\n                bottom_pos = fill_below[-1][1]\n            if trim_bottom != 0 or self._body.get_next(bottom_pos) != (None, None):\n                raise ListBoxError(\n                    f\"Listbox contents too short!  Probably urwid's fault (please report): {top, middle, bottom!r}\"\n                )\n            final_canvas.pad_trim_top_bottom(0, maxrow - rows)\n\n        return final_canvas\n\n    def get_cursor_coords(self, size: tuple[int, int]) -> tuple[int, int] | None:\n        \"\"\"\n        See :meth:`Widget.get_cursor_coords` for details\n        \"\"\"\n        (maxcol, maxrow) = size\n\n        middle, top, bottom = self.calculate_visible((maxcol, maxrow), True)\n        if middle is None:\n            return None\n\n        offset_inset, _ignore1, _ignore2, _ignore3, cursor = middle\n        if not cursor:\n            return None\n\n        x, y = cursor\n        y += offset_inset\n        if y < 0 or y >= maxrow:\n            return None\n        return (x, y)\n\n    def set_focus_valign(\n        self,\n        valign: Literal['top', 'middle', 'bottom'] | tuple[Literal['fixed top', 'fixed bottom', 'relative'], int],\n    ):\n        \"\"\"Set the focus widget's display offset and inset.\n\n        :param valign: one of:\n            'top', 'middle', 'bottom'\n            ('fixed top', rows)\n            ('fixed bottom', rows)\n            ('relative', percentage 0=top 100=bottom)\n        \"\"\"\n        vt, va = normalize_valign(valign, ListBoxError)\n        self.set_focus_valign_pending = vt, va\n\n    def set_focus(self, position, coming_from: Literal['above', 'below'] | None = None) -> None:\n        \"\"\"\n        Set the focus position and try to keep the old focus in view.\n\n        :param position: a position compatible with :meth:`self._body.set_focus`\n        :param coming_from: set to 'above' or 'below' if you know that\n                            old position is above or below the new position.\n        :type coming_from: str\n        \"\"\"\n        if coming_from not in ('above', 'below', None):\n            raise ListBoxError(f\"coming_from value invalid: {coming_from!r}\")\n        focus_widget, focus_pos = self._body.get_focus()\n        if focus_widget is None:\n            raise IndexError(\"Can't set focus, ListBox is empty\")\n\n        self.set_focus_pending = coming_from, focus_widget, focus_pos\n        self._body.set_focus(position)\n\n    def get_focus(self):\n        \"\"\"\n        Return a `(focus widget, focus position)` tuple, for backwards\n        compatibility. You may also use the new standard container\n        properties :attr:`focus` and :attr:`focus_position` to read these values.\n        \"\"\"\n        warnings.warn(\n            \"only for backwards compatibility.\"\n            \"You may also use the new standard container property `focus` to get the focus \"\n            \"and property `focus_position` to read these values.\",\n            PendingDeprecationWarning,\n            stacklevel=2,\n        )\n        return self._body.get_focus()\n\n    @property\n    def focus(self):\n        \"\"\"\n        the child widget in focus or None when ListBox is empty.\n\n        Return the widget in focus according to our :obj:`list walker <ListWalker>`.\n        \"\"\"\n        return self._body.get_focus()[0]\n\n    def _get_focus(self) -> Widget:\n        warnings.warn(\n            f\"method `{self.__class__.__name__}._get_focus` is deprecated, \"\n            f\"please use `{self.__class__.__name__}.focus` property\",\n            DeprecationWarning,\n            stacklevel=3,\n        )\n        return self.focus\n\n    def _get_focus_position(self):\n        \"\"\"\n        Return the list walker position of the widget in focus. The type\n        of value returned depends on the :obj:`list walker <ListWalker>`.\n\n        \"\"\"\n        w, pos = self._body.get_focus()\n        if w is None:\n            raise IndexError(\"No focus_position, ListBox is empty\")\n        return pos\n\n    focus_position = property(\n        _get_focus_position,\n        set_focus,\n        doc=\"\"\"\n        the position of child widget in focus. The valid values for this\n        position depend on the list walker in use.\n        :exc:`IndexError` will be raised by reading this property when the\n        ListBox is empty or setting this property to an invalid position.\n        \"\"\",\n    )\n\n    def _contents(self):\n        class ListBoxContents:\n            __getitem__ = self._contents__getitem__\n\n        return ListBoxContents()\n\n    def _contents__getitem__(self, key):\n        # try list walker protocol v2 first\n        getitem = getattr(self._body, '__getitem__', None)\n        if getitem:\n            try:\n                return (getitem(key), None)\n            except (IndexError, KeyError):\n                raise KeyError(f\"ListBox.contents key not found: {key!r}\")\n        # fall back to v1\n        w, old_focus = self._body.get_focus()\n        try:\n            try:\n                self._body.set_focus(key)\n                return self._body.get_focus()[0]\n            except (IndexError, KeyError):\n                raise KeyError(f\"ListBox.contents key not found: {key!r}\")\n        finally:\n            self._body.set_focus(old_focus)\n\n    @property\n    def contents(self):\n        \"\"\"\n        An object that allows reading widgets from the ListBox's list\n        walker as a `(widget, options)` tuple. `None` is currently the only\n        value for options.\n\n        .. warning::\n\n            This object may not be used to set or iterate over contents.\n\n            You must use the list walker stored as\n            :attr:`.body` to perform manipulation and iteration, if supported.\n        \"\"\"\n        return self._contents\n\n    def options(self):\n        \"\"\"\n        There are currently no options for ListBox contents.\n\n        Return None as a placeholder for future options.\n        \"\"\"\n        return None\n\n    def _set_focus_valign_complete(self, size: tuple[int, int], focus: bool) -> None:\n        \"\"\"\n        Finish setting the offset and inset now that we have have a\n        maxcol & maxrow.\n        \"\"\"\n        (maxcol, maxrow) = size\n        vt, va = self.set_focus_valign_pending\n        self.set_focus_valign_pending = None\n        self.set_focus_pending = None\n\n        focus_widget, focus_pos = self._body.get_focus()\n        if focus_widget is None:\n            return\n\n        rows = focus_widget.rows((maxcol,), focus)\n        rtop, rbot = calculate_top_bottom_filler(maxrow, vt, va, WHSettings.GIVEN, rows, None, 0, 0)\n\n        self.shift_focus((maxcol, maxrow), rtop)\n\n    def _set_focus_first_selectable(self, size: tuple[int, int], focus: bool) -> None:\n        \"\"\"\n        Choose the first visible, selectable widget below the\n        current focus as the focus widget.\n        \"\"\"\n        (maxcol, maxrow) = size\n        self.set_focus_valign_pending = None\n        self.set_focus_pending = None\n        middle, top, bottom = self.calculate_visible((maxcol, maxrow), focus=focus)\n        if middle is None:\n            return\n\n        row_offset, focus_widget, focus_pos, focus_rows, cursor = middle\n        trim_top, fill_above = top\n        trim_bottom, fill_below = bottom\n\n        if focus_widget.selectable():\n            return\n\n        if trim_bottom:\n            fill_below = fill_below[:-1]\n        new_row_offset = row_offset + focus_rows\n        for widget, pos, rows in fill_below:\n            if widget.selectable():\n                self._body.set_focus(pos)\n                self.shift_focus((maxcol, maxrow), new_row_offset)\n                return\n            new_row_offset += rows\n\n    def _set_focus_complete(self, size: tuple[int, int], focus: bool) -> None:\n        \"\"\"\n        Finish setting the position now that we have maxcol & maxrow.\n        \"\"\"\n        (maxcol, maxrow) = size\n        self._invalidate()\n        if self.set_focus_pending == \"first selectable\":\n            return self._set_focus_first_selectable((maxcol, maxrow), focus)\n        if self.set_focus_valign_pending is not None:\n            return self._set_focus_valign_complete((maxcol, maxrow), focus)\n        coming_from, focus_widget, focus_pos = self.set_focus_pending\n        self.set_focus_pending = None\n\n        # new position\n        new_focus_widget, position = self._body.get_focus()\n        if focus_pos == position:\n            # do nothing\n            return\n\n        # restore old focus temporarily\n        self._body.set_focus(focus_pos)\n\n        middle, top, bottom = self.calculate_visible((maxcol, maxrow), focus)\n        focus_offset, focus_widget, focus_pos, focus_rows, cursor = middle\n        trim_top, fill_above = top\n        trim_bottom, fill_below = bottom\n\n        offset = focus_offset\n        for widget, pos, rows in fill_above:\n            offset -= rows\n            if pos == position:\n                self.change_focus((maxcol, maxrow), pos, offset, 'below')\n                return\n\n        offset = focus_offset + focus_rows\n        for widget, pos, rows in fill_below:\n            if pos == position:\n                self.change_focus((maxcol, maxrow), pos, offset, 'above')\n                return\n            offset += rows\n\n        # failed to find widget among visible widgets\n        self._body.set_focus(position)\n        widget, position = self._body.get_focus()\n        rows = widget.rows((maxcol,), focus)\n\n        if coming_from == 'below':\n            offset = 0\n        elif coming_from == 'above':\n            offset = maxrow - rows\n        else:\n            offset = (maxrow - rows) // 2\n        self.shift_focus((maxcol, maxrow), offset)\n\n    def shift_focus(self, size: tuple[int, int], offset_inset: int) -> None:\n        \"\"\"\n        Move the location of the current focus relative to the top.\n        This is used internally by methods that know the widget's *size*.\n\n        See also :meth:`.set_focus_valign`.\n\n        :param size: see :meth:`Widget.render` for details\n        :param offset_inset: either the number of rows between the\n            top of the listbox and the start of the focus widget (+ve\n            value) or the number of lines of the focus widget hidden off\n            the top edge of the listbox (-ve value) or ``0`` if the top edge\n            of the focus widget is aligned with the top edge of the\n            listbox.\n        :type offset_inset: int\n        \"\"\"\n        (maxcol, maxrow) = size\n\n        if offset_inset >= 0:\n            if offset_inset >= maxrow:\n                raise ListBoxError(f\"Invalid offset_inset: {offset_inset!r}, only {maxrow!r} rows in list box\")\n            self.offset_rows = offset_inset\n            self.inset_fraction = (0, 1)\n        else:\n            target, _ignore = self._body.get_focus()\n            tgt_rows = target.rows((maxcol,), True)\n            if offset_inset + tgt_rows <= 0:\n                raise ListBoxError(f\"Invalid offset_inset: {offset_inset!r}, only {tgt_rows!r} rows in target!\")\n            self.offset_rows = 0\n            self.inset_fraction = (-offset_inset, tgt_rows)\n        self._invalidate()\n\n    def update_pref_col_from_focus(self, size: tuple[int, int]):\n        \"\"\"Update self.pref_col from the focus widget.\"\"\"\n        # TODO: should this not be private?\n        (maxcol, maxrow) = size\n\n        widget, old_pos = self._body.get_focus()\n        if widget is None:\n            return\n\n        pref_col = None\n        if hasattr(widget, 'get_pref_col'):\n            pref_col = widget.get_pref_col((maxcol,))\n        if pref_col is None and hasattr(widget, 'get_cursor_coords'):\n            coords = widget.get_cursor_coords((maxcol,))\n            if isinstance(coords, tuple):\n                pref_col, y = coords\n        if pref_col is not None:\n            self.pref_col = pref_col\n\n    def change_focus(\n        self,\n        size: tuple[int, int],\n        position,\n        offset_inset: int = 0,\n        coming_from: Literal['above', 'below'] | None = None,\n        cursor_coords: tuple[int, int] | None = None,\n        snap_rows: int | None = None,\n    ) -> None:\n        \"\"\"\n        Change the current focus widget.\n        This is used internally by methods that know the widget's *size*.\n\n        See also :meth:`.set_focus`.\n\n        :param size: see :meth:`Widget.render` for details\n        :param position: a position compatible with :meth:`self._body.set_focus`\n        :param offset_inset: either the number of rows between the\n            top of the listbox and the start of the focus widget (+ve\n            value) or the number of lines of the focus widget hidden off\n            the top edge of the listbox (-ve value) or 0 if the top edge\n            of the focus widget is aligned with the top edge of the\n            listbox (default if unspecified)\n        :type offset_inset: int\n        :param coming_from: either 'above', 'below' or unspecified `None`\n        :type coming_from: str\n        :param cursor_coords: (x, y) tuple indicating the desired\n            column and row for the cursor, a (x,) tuple indicating only\n            the column for the cursor, or unspecified\n        :type cursor_coords: (int, int)\n        :param snap_rows: the maximum number of extra rows to scroll\n            when trying to \"snap\" a selectable focus into the view\n        :type snap_rows: int\n        \"\"\"\n        (maxcol, maxrow) = size\n\n        # update pref_col before change\n        if cursor_coords:\n            self.pref_col = cursor_coords[0]\n        else:\n            self.update_pref_col_from_focus((maxcol, maxrow))\n\n        self._invalidate()\n        self._body.set_focus(position)\n        target, _ignore = self._body.get_focus()\n        tgt_rows = target.rows((maxcol,), True)\n        if snap_rows is None:\n            snap_rows = maxrow - 1\n\n        # \"snap\" to selectable widgets\n        align_top = 0\n        align_bottom = maxrow - tgt_rows\n\n        if coming_from == 'above' and target.selectable() and offset_inset > align_bottom:\n            if snap_rows >= offset_inset - align_bottom:\n                offset_inset = align_bottom\n            elif snap_rows >= offset_inset - align_top:\n                offset_inset = align_top\n            else:\n                offset_inset -= snap_rows\n\n        if coming_from == 'below' and target.selectable() and offset_inset < align_top:\n            if snap_rows >= align_top - offset_inset:\n                offset_inset = align_top\n            elif snap_rows >= align_bottom - offset_inset:\n                offset_inset = align_bottom\n            else:\n                offset_inset += snap_rows\n\n        # convert offset_inset to offset_rows or inset_fraction\n        if offset_inset >= 0:\n            self.offset_rows = offset_inset\n            self.inset_fraction = (0, 1)\n        else:\n            if offset_inset + tgt_rows <= 0:\n                raise ListBoxError(f\"Invalid offset_inset: {offset_inset}, only {tgt_rows} rows in target!\")\n            self.offset_rows = 0\n            self.inset_fraction = (-offset_inset, tgt_rows)\n\n        if cursor_coords is None:\n            if coming_from is None:\n                return  # must either know row or coming_from\n            cursor_coords = (self.pref_col,)\n\n        if not hasattr(target, 'move_cursor_to_coords'):\n            return\n\n        attempt_rows = []\n\n        if len(cursor_coords) == 1:\n            # only column (not row) specified\n            # start from closest edge and move inwards\n            (pref_col,) = cursor_coords\n            if coming_from == 'above':\n                attempt_rows = range(0, tgt_rows)\n            else:\n                assert (\n                    coming_from == 'below'\n                ), \"must specify coming_from ('above' or 'below') if cursor row is not specified\"\n                attempt_rows = range(tgt_rows, -1, -1)\n        else:\n            # both column and row specified\n            # start from preferred row and move back to closest edge\n            (pref_col, pref_row) = cursor_coords\n            if pref_row < 0 or pref_row >= tgt_rows:\n                raise ListBoxError(\n                    f\"cursor_coords row outside valid range for target. pref_row:{pref_row!r} target_rows:{tgt_rows!r}\"\n                )\n\n            if coming_from == 'above':\n                attempt_rows = range(pref_row, -1, -1)\n            elif coming_from == 'below':\n                attempt_rows = range(pref_row, tgt_rows)\n            else:\n                attempt_rows = [pref_row]\n\n        for row in attempt_rows:\n            if target.move_cursor_to_coords((maxcol,), pref_col, row):\n                break\n\n    def get_focus_offset_inset(self, size: tuple[int, int]) -> tuple[int, int]:\n        \"\"\"Return (offset rows, inset rows) for focus widget.\"\"\"\n        (maxcol, maxrow) = size\n        focus_widget, pos = self._body.get_focus()\n        focus_rows = focus_widget.rows((maxcol,), True)\n        offset_rows = self.offset_rows\n        inset_rows = 0\n        if offset_rows == 0:\n            inum, iden = self.inset_fraction\n            if inum < 0 or iden < 0 or inum >= iden:\n                raise ListBoxError(f\"Invalid inset_fraction: {self.inset_fraction!r}\")\n            inset_rows = focus_rows * inum // iden\n            if inset_rows and inset_rows >= focus_rows:\n                raise ListBoxError(\"urwid inset_fraction error (please report)\")\n        return offset_rows, inset_rows\n\n    def make_cursor_visible(self, size: tuple[int, int]) -> None:\n        \"\"\"Shift the focus widget so that its cursor is visible.\"\"\"\n        (maxcol, maxrow) = size\n\n        focus_widget, pos = self._body.get_focus()\n        if focus_widget is None:\n            return\n        if not focus_widget.selectable():\n            return\n        if not hasattr(focus_widget, 'get_cursor_coords'):\n            return\n        cursor = focus_widget.get_cursor_coords((maxcol,))\n        if cursor is None:\n            return\n        cx, cy = cursor\n        offset_rows, inset_rows = self.get_focus_offset_inset((maxcol, maxrow))\n\n        if cy < inset_rows:\n            self.shift_focus((maxcol, maxrow), -(cy))\n            return\n\n        if offset_rows - inset_rows + cy >= maxrow:\n            self.shift_focus((maxcol, maxrow), maxrow - cy - 1)\n            return\n\n    def keypress(self, size: tuple[int, int], key: str) -> str | None:\n        \"\"\"Move selection through the list elements scrolling when\n        necessary. Keystrokes are first passed to widget in focus\n        in case that widget can handle them.\n\n        Keystrokes handled by this widget are:\n         'up'        up one line (or widget)\n         'down'      down one line (or widget)\n         'page up'   move cursor up one listbox length (or widget)\n         'page down' move cursor down one listbox length (or widget)\n        \"\"\"\n        (maxcol, maxrow) = size\n\n        if self.set_focus_pending or self.set_focus_valign_pending:\n            self._set_focus_complete((maxcol, maxrow), focus=True)\n\n        focus_widget, pos = self._body.get_focus()\n        if focus_widget is None:  # empty listbox, can't do anything\n            return key\n\n        if focus_widget.selectable():\n            key = focus_widget.keypress((maxcol,), key)\n            if key is None:\n                self.make_cursor_visible((maxcol, maxrow))\n                return None\n\n        def actual_key(unhandled):\n            if unhandled:\n                return key\n\n        # pass off the heavy lifting\n        if self._command_map[key] == Command.UP:\n            return actual_key(self._keypress_up((maxcol, maxrow)))\n\n        if self._command_map[key] == Command.DOWN:\n            return actual_key(self._keypress_down((maxcol, maxrow)))\n\n        if self._command_map[key] == Command.PAGE_UP:\n            return actual_key(self._keypress_page_up((maxcol, maxrow)))\n\n        if self._command_map[key] == Command.PAGE_DOWN:\n            return actual_key(self._keypress_page_down((maxcol, maxrow)))\n\n        if self._command_map[key] == Command.MAX_LEFT:\n            return actual_key(self._keypress_max_left((maxcol, maxrow)))\n\n        if self._command_map[key] == Command.MAX_RIGHT:\n            return actual_key(self._keypress_max_right((maxcol, maxrow)))\n\n        return key\n\n    def _keypress_max_left(self, size: tuple[int, int]) -> bool:\n        self.focus_position = next(iter(self.body.positions()))\n        self.set_focus_valign('top')\n        return True\n\n    def _keypress_max_right(self, size: tuple[int, int]) -> bool:\n        self.focus_position = next(iter(self.body.positions(reverse=True)))\n        self.set_focus_valign('bottom')\n        return True\n\n    def _keypress_up(self, size: tuple[int, int]) -> bool | None:\n        (maxcol, maxrow) = size\n\n        middle, top, bottom = self.calculate_visible((maxcol, maxrow), True)\n        if middle is None:\n            return True\n\n        focus_row_offset, focus_widget, focus_pos, _ignore, cursor = middle\n        trim_top, fill_above = top\n\n        row_offset = focus_row_offset\n\n        # look for selectable widget above\n        pos = focus_pos\n        widget = None\n        for widget, pos, rows in fill_above:\n            row_offset -= rows\n            if rows and widget.selectable():\n                # this one will do\n                self.change_focus((maxcol, maxrow), pos, row_offset, 'below')\n                return\n\n        # at this point we must scroll\n        row_offset += 1\n        self._invalidate()\n\n        while row_offset > 0:\n            # need to scroll in another candidate widget\n            widget, pos = self._body.get_prev(pos)\n            if widget is None:\n                # cannot scroll any further\n                return True  # keypress not handled\n            rows = widget.rows((maxcol,), True)\n            row_offset -= rows\n            if rows and widget.selectable():\n                # this one will do\n                self.change_focus((maxcol, maxrow), pos, row_offset, 'below')\n                return\n\n        if not focus_widget.selectable() or focus_row_offset + 1 >= maxrow:\n            # just take top one if focus is not selectable\n            # or if focus has moved out of view\n            if widget is None:\n                self.shift_focus((maxcol, maxrow), row_offset)\n                return\n            self.change_focus((maxcol, maxrow), pos, row_offset, 'below')\n            return\n\n        # check if cursor will stop scroll from taking effect\n        if cursor is not None:\n            x, y = cursor\n            if y + focus_row_offset + 1 >= maxrow:\n                # cursor position is a problem,\n                # choose another focus\n                if widget is None:\n                    # try harder to get prev widget\n                    widget, pos = self._body.get_prev(pos)\n                    if widget is None:\n                        return  # can't do anything\n                    rows = widget.rows((maxcol,), True)\n                    row_offset -= rows\n\n                if -row_offset >= rows:\n                    # must scroll further than 1 line\n                    row_offset = -(rows - 1)\n\n                self.change_focus((maxcol, maxrow), pos, row_offset, 'below')\n                return\n\n        # if all else fails, just shift the current focus.\n        self.shift_focus((maxcol, maxrow), focus_row_offset + 1)\n\n    def _keypress_down(self, size: tuple[int, int]) -> bool | None:\n        (maxcol, maxrow) = size\n\n        middle, top, bottom = self.calculate_visible((maxcol, maxrow), True)\n        if middle is None:\n            return True\n\n        focus_row_offset, focus_widget, focus_pos, focus_rows, cursor = middle\n        trim_bottom, fill_below = bottom\n\n        row_offset = focus_row_offset + focus_rows\n        rows = focus_rows\n\n        # look for selectable widget below\n        pos = focus_pos\n        widget = None\n        for widget, pos, rows in fill_below:\n            if rows and widget.selectable():\n                # this one will do\n                self.change_focus((maxcol, maxrow), pos, row_offset, 'above')\n                return\n            row_offset += rows\n\n        # at this point we must scroll\n        row_offset -= 1\n        self._invalidate()\n\n        while row_offset < maxrow:\n            # need to scroll in another candidate widget\n            widget, pos = self._body.get_next(pos)\n            if widget is None:\n                # cannot scroll any further\n                return True  # keypress not handled\n            rows = widget.rows((maxcol,))\n            if rows and widget.selectable():\n                # this one will do\n                self.change_focus((maxcol, maxrow), pos, row_offset, 'above')\n                return\n            row_offset += rows\n\n        if not focus_widget.selectable() or focus_row_offset + focus_rows - 1 <= 0:\n            # just take bottom one if current is not selectable\n            # or if focus has moved out of view\n            if widget is None:\n                self.shift_focus((maxcol, maxrow), row_offset - rows)\n                return\n            # FIXME: catch this bug in testcase\n            # self.change_focus((maxcol,maxrow), pos,\n            #    row_offset+rows, 'above')\n            self.change_focus((maxcol, maxrow), pos, row_offset - rows, 'above')\n            return\n\n        # check if cursor will stop scroll from taking effect\n        if cursor is not None:\n            x, y = cursor\n            if y + focus_row_offset - 1 < 0:\n                # cursor position is a problem,\n                # choose another focus\n                if widget is None:\n                    # try harder to get next widget\n                    widget, pos = self._body.get_next(pos)\n                    if widget is None:\n                        return  # can't do anything\n                else:\n                    row_offset -= rows\n\n                if row_offset >= maxrow:\n                    # must scroll further than 1 line\n                    row_offset = maxrow - 1\n\n                self.change_focus(\n                    (maxcol, maxrow),\n                    pos,\n                    row_offset,\n                    'above',\n                )\n                return\n\n        # if all else fails, keep the current focus.\n        self.shift_focus((maxcol, maxrow), focus_row_offset - 1)\n\n    def _keypress_page_up(self, size: tuple[int, int]) -> bool | None:\n        (maxcol, maxrow) = size\n\n        middle, top, bottom = self.calculate_visible((maxcol, maxrow), True)\n        if middle is None:\n            return True\n\n        row_offset, focus_widget, focus_pos, focus_rows, cursor = middle\n        trim_top, fill_above = top\n\n        # topmost_visible is row_offset rows above top row of\n        # focus (+ve) or -row_offset rows below top row of focus (-ve)\n        topmost_visible = row_offset\n\n        # scroll_from_row is (first match)\n        # 1. topmost visible row if focus is not selectable\n        # 2. row containing cursor if focus has a cursor\n        # 3. top row of focus widget if it is visible\n        # 4. topmost visible row otherwise\n        if not focus_widget.selectable():\n            scroll_from_row = topmost_visible\n        elif cursor is not None:\n            x, y = cursor\n            scroll_from_row = -y\n        elif row_offset >= 0:\n            scroll_from_row = 0\n        else:\n            scroll_from_row = topmost_visible\n\n        # snap_rows is maximum extra rows to scroll when\n        # snapping to new a focus\n        snap_rows = topmost_visible - scroll_from_row\n\n        # move row_offset to the new desired value (1 \"page\" up)\n        row_offset = scroll_from_row + maxrow\n\n        # not used below:\n        scroll_from_row = topmost_visible = None\n\n        # gather potential target widgets\n        t = []\n        # add current focus\n        t.append((row_offset, focus_widget, focus_pos, focus_rows))\n        pos = focus_pos\n        # include widgets from calculate_visible(..)\n        for widget, pos, rows in fill_above:\n            row_offset -= rows\n            t.append((row_offset, widget, pos, rows))\n        # add newly visible ones, including within snap_rows\n        snap_region_start = len(t)\n        while row_offset > -snap_rows:\n            widget, pos = self._body.get_prev(pos)\n            if widget is None:\n                break\n            rows = widget.rows((maxcol,))\n            row_offset -= rows\n            # determine if one below puts current one into snap rgn\n            if row_offset > 0:\n                snap_region_start += 1\n            t.append((row_offset, widget, pos, rows))\n\n        # if we can't fill the top we need to adjust the row offsets\n        row_offset, w, p, r = t[-1]\n        if row_offset > 0:\n            adjust = -row_offset\n            t = [(ro + adjust, w, p, r) for (ro, w, p, r) in t]\n\n        # if focus_widget (first in t) is off edge, remove it\n        row_offset, w, p, r = t[0]\n        if row_offset >= maxrow:\n            del t[0]\n            snap_region_start -= 1\n\n        # we'll need this soon\n        self.update_pref_col_from_focus((maxcol, maxrow))\n\n        # choose the topmost selectable and (newly) visible widget\n        # search within snap_rows then visible region\n        search_order = list(range(snap_region_start, len(t))) + list(range(snap_region_start - 1, -1, -1))\n        # assert 0, repr((t, search_order))\n        bad_choices = []\n        cut_off_selectable_chosen = 0\n        for i in search_order:\n            row_offset, widget, pos, rows = t[i]\n            if not widget.selectable():\n                continue\n\n            if not rows:\n                continue\n\n            # try selecting this widget\n            pref_row = max(0, -row_offset)\n\n            # if completely within snap region, adjust row_offset\n            if rows + row_offset <= 0:\n                self.change_focus(\n                    (maxcol, maxrow),\n                    pos,\n                    -(rows - 1),\n                    'below',\n                    (self.pref_col, rows - 1),\n                    snap_rows - ((-row_offset) - (rows - 1)),\n                )\n            else:\n                self.change_focus(\n                    (maxcol, maxrow),\n                    pos,\n                    row_offset,\n                    'below',\n                    (self.pref_col, pref_row),\n                    snap_rows,\n                )\n\n            # if we're as far up as we can scroll, take this one\n            if fill_above and self._body.get_prev(fill_above[-1][1]) == (None, None):\n                pass  # return\n\n            # find out where that actually puts us\n            middle, top, bottom = self.calculate_visible((maxcol, maxrow), True)\n            act_row_offset, _ign1, _ign2, _ign3, _ign4 = middle\n\n            # discard chosen widget if it will reduce scroll amount\n            # because of a fixed cursor (absolute last resort)\n            if act_row_offset > row_offset + snap_rows:\n                bad_choices.append(i)\n                continue\n            if act_row_offset < row_offset:\n                bad_choices.append(i)\n                continue\n\n            # also discard if off top edge (second last resort)\n            if act_row_offset < 0:\n                bad_choices.append(i)\n                cut_off_selectable_chosen = 1\n                continue\n\n            return\n\n        # anything selectable is better than what follows:\n        if cut_off_selectable_chosen:\n            return\n\n        if fill_above and focus_widget.selectable():\n            # if we're at the top and have a selectable, return\n            if self._body.get_prev(fill_above[-1][1]) == (None, None):\n                pass  # return\n\n        # if still none found choose the topmost widget\n        good_choices = [j for j in search_order if j not in bad_choices]\n        for i in good_choices + search_order:\n            row_offset, widget, pos, rows = t[i]\n            if pos == focus_pos:\n                continue\n\n            if not rows:  # never focus a 0-height widget\n                continue\n\n            # if completely within snap region, adjust row_offset\n            if rows + row_offset <= 0:\n                snap_rows -= (-row_offset) - (rows - 1)\n                row_offset = -(rows - 1)\n\n            self.change_focus((maxcol, maxrow), pos, row_offset, 'below', None, snap_rows)\n            return\n\n        # no choices available, just shift current one\n        self.shift_focus((maxcol, maxrow), min(maxrow - 1, row_offset))\n\n        # final check for pathological case where we may fall short\n        middle, top, bottom = self.calculate_visible((maxcol, maxrow), True)\n        act_row_offset, _ign1, pos, _ign2, _ign3 = middle\n        if act_row_offset >= row_offset:\n            # no problem\n            return\n\n        # fell short, try to select anything else above\n        if not t:\n            return\n        _ign1, _ign2, pos, _ign3 = t[-1]\n        widget, pos = self._body.get_prev(pos)\n        if widget is None:\n            # no dice, we're stuck here\n            return\n        # bring in only one row if possible\n        rows = widget.rows((maxcol,), True)\n        self.change_focus((maxcol, maxrow), pos, -(rows - 1), 'below', (self.pref_col, rows - 1), 0)\n\n    def _keypress_page_down(self, size: tuple[int, int]) -> bool | None:\n        (maxcol, maxrow) = size\n\n        middle, top, bottom = self.calculate_visible((maxcol, maxrow), True)\n        if middle is None:\n            return True\n\n        row_offset, focus_widget, focus_pos, focus_rows, cursor = middle\n        trim_bottom, fill_below = bottom\n\n        # bottom_edge is maxrow-focus_pos rows below top row of focus\n        bottom_edge = maxrow - row_offset\n\n        # scroll_from_row is (first match)\n        # 1. bottom edge if focus is not selectable\n        # 2. row containing cursor + 1 if focus has a cursor\n        # 3. bottom edge of focus widget if it is visible\n        # 4. bottom edge otherwise\n        if not focus_widget.selectable():\n            scroll_from_row = bottom_edge\n        elif cursor is not None:\n            x, y = cursor\n            scroll_from_row = y + 1\n        elif bottom_edge >= focus_rows:\n            scroll_from_row = focus_rows\n        else:\n            scroll_from_row = bottom_edge\n\n        # snap_rows is maximum extra rows to scroll when\n        # snapping to new a focus\n        snap_rows = bottom_edge - scroll_from_row\n\n        # move row_offset to the new desired value (1 \"page\" down)\n        row_offset = -scroll_from_row\n\n        # not used below:\n        scroll_from_row = bottom_edge = None\n\n        # gather potential target widgets\n        t = []\n        # add current focus\n        t.append((row_offset, focus_widget, focus_pos, focus_rows))\n        pos = focus_pos\n        row_offset += focus_rows\n        # include widgets from calculate_visible(..)\n        for widget, pos, rows in fill_below:\n            t.append((row_offset, widget, pos, rows))\n            row_offset += rows\n        # add newly visible ones, including within snap_rows\n        snap_region_start = len(t)\n        while row_offset < maxrow + snap_rows:\n            widget, pos = self._body.get_next(pos)\n            if widget is None:\n                break\n            rows = widget.rows((maxcol,))\n            t.append((row_offset, widget, pos, rows))\n            row_offset += rows\n            # determine if one above puts current one into snap rgn\n            if row_offset < maxrow:\n                snap_region_start += 1\n\n        # if we can't fill the bottom we need to adjust the row offsets\n        row_offset, w, p, rows = t[-1]\n        if row_offset + rows < maxrow:\n            adjust = maxrow - (row_offset + rows)\n            t = [(ro + adjust, w, p, r) for (ro, w, p, r) in t]\n\n        # if focus_widget (first in t) is off edge, remove it\n        row_offset, w, p, rows = t[0]\n        if row_offset + rows <= 0:\n            del t[0]\n            snap_region_start -= 1\n\n        # we'll need this soon\n        self.update_pref_col_from_focus((maxcol, maxrow))\n\n        # choose the bottommost selectable and (newly) visible widget\n        # search within snap_rows then visible region\n        search_order = list(range(snap_region_start, len(t))) + list(range(snap_region_start - 1, -1, -1))\n        # assert 0, repr((t, search_order))\n        bad_choices = []\n        cut_off_selectable_chosen = 0\n        for i in search_order:\n            row_offset, widget, pos, rows = t[i]\n            if not widget.selectable():\n                continue\n\n            if not rows:\n                continue\n\n            # try selecting this widget\n            pref_row = min(maxrow - row_offset - 1, rows - 1)\n\n            # if completely within snap region, adjust row_offset\n            if row_offset >= maxrow:\n                self.change_focus(\n                    (maxcol, maxrow),\n                    pos,\n                    maxrow - 1,\n                    'above',\n                    (self.pref_col, 0),\n                    snap_rows + maxrow - row_offset - 1,\n                )\n            else:\n                self.change_focus(\n                    (maxcol, maxrow),\n                    pos,\n                    row_offset,\n                    'above',\n                    (self.pref_col, pref_row),\n                    snap_rows,\n                )\n\n            # find out where that actually puts us\n            middle, top, bottom = self.calculate_visible((maxcol, maxrow), True)\n            act_row_offset, _ign1, _ign2, _ign3, _ign4 = middle\n\n            # discard chosen widget if it will reduce scroll amount\n            # because of a fixed cursor (absolute last resort)\n            if act_row_offset < row_offset - snap_rows:\n                bad_choices.append(i)\n                continue\n            if act_row_offset > row_offset:\n                bad_choices.append(i)\n                continue\n\n            # also discard if off top edge (second last resort)\n            if act_row_offset + rows > maxrow:\n                bad_choices.append(i)\n                cut_off_selectable_chosen = 1\n                continue\n\n            return\n\n        # anything selectable is better than what follows:\n        if cut_off_selectable_chosen:\n            return\n\n        # if still none found choose the bottommost widget\n        good_choices = [j for j in search_order if j not in bad_choices]\n        for i in good_choices + search_order:\n            row_offset, widget, pos, rows = t[i]\n            if pos == focus_pos:\n                continue\n\n            if not rows:  # never focus a 0-height widget\n                continue\n\n            # if completely within snap region, adjust row_offset\n            if row_offset >= maxrow:\n                snap_rows -= snap_rows + maxrow - row_offset - 1\n                row_offset = maxrow - 1\n\n            self.change_focus((maxcol, maxrow), pos, row_offset, 'above', None, snap_rows)\n            return\n\n        # no choices available, just shift current one\n        self.shift_focus((maxcol, maxrow), max(1 - focus_rows, row_offset))\n\n        # final check for pathological case where we may fall short\n        middle, top, bottom = self.calculate_visible((maxcol, maxrow), True)\n        act_row_offset, _ign1, pos, _ign2, _ign3 = middle\n        if act_row_offset <= row_offset:\n            # no problem\n            return\n\n        # fell short, try to select anything else below\n        if not t:\n            return\n        _ign1, _ign2, pos, _ign3 = t[-1]\n        widget, pos = self._body.get_next(pos)\n        if widget is None:\n            # no dice, we're stuck here\n            return\n        # bring in only one row if possible\n        rows = widget.rows((maxcol,), True)\n        self.change_focus((maxcol, maxrow), pos, maxrow - 1, 'above', (self.pref_col, 0), 0)\n\n    def mouse_event(self, size: tuple[int, int], event, button: int, col: int, row: int, focus: bool) -> bool | None:\n        \"\"\"\n        Pass the event to the contained widgets.\n        May change focus on button 1 press.\n        \"\"\"\n        (maxcol, maxrow) = size\n        middle, top, bottom = self.calculate_visible((maxcol, maxrow), focus=True)\n        if middle is None:\n            return False\n\n        _ignore, focus_widget, focus_pos, focus_rows, cursor = middle\n        trim_top, fill_above = top\n        _ignore, fill_below = bottom\n\n        fill_above.reverse()  # fill_above is in bottom-up order\n        w_list = fill_above + [(focus_widget, focus_pos, focus_rows)] + fill_below\n\n        wrow = -trim_top\n        for w, w_pos, w_rows in w_list:\n            if wrow + w_rows > row:\n                break\n            wrow += w_rows\n        else:\n            return False\n\n        focus = focus and w == focus_widget\n        if is_mouse_press(event) and button == 1:\n            if w.selectable():\n                self.change_focus((maxcol, maxrow), w_pos, wrow)\n\n        if not hasattr(w, 'mouse_event'):\n            return False\n\n        return w.mouse_event((maxcol,), event, button, col, row - wrow, focus)\n\n    def ends_visible(self, size: tuple[int, int], focus: bool = False):\n        \"\"\"\n        Return a list that may contain ``'top'`` and/or ``'bottom'``.\n\n        i.e. this function will return one of: [], [``'top'``],\n        [``'bottom'``] or [``'top'``, ``'bottom'``].\n\n        convenience function for checking whether the top and bottom\n        of the list are visible\n        \"\"\"\n        (maxcol, maxrow) = size\n        l = []\n        middle, top, bottom = self.calculate_visible((maxcol, maxrow), focus=focus)\n        if middle is None:  # empty listbox\n            return ['top', 'bottom']\n        trim_top, above = top\n        trim_bottom, below = bottom\n\n        if trim_bottom == 0:\n            row_offset, w, pos, rows, c = middle\n            row_offset += rows\n            for w, pos, rows in below:\n                row_offset += rows\n            if row_offset < maxrow:\n                l.append('bottom')\n            elif self._body.get_next(pos) == (None, None):\n                l.append('bottom')\n\n        if trim_top == 0:\n            row_offset, w, pos, rows, c = middle\n            for w, pos, rows in above:\n                row_offset -= rows\n            if self._body.get_prev(pos) == (None, None):\n                l.insert(0, 'top')\n\n        return l\n\n    def __iter__(self):\n        \"\"\"\n        Return an iterator over the positions in this ListBox.\n\n        If self._body does not implement positions() then iterate\n        from the focus widget down to the bottom, then from above\n        the focus up to the top.  This is the best we can do with\n        a minimal list walker implementation.\n        \"\"\"\n        positions_fn = getattr(self._body, 'positions', None)\n        if positions_fn:\n            for pos in positions_fn():\n                yield pos\n            return\n\n        focus_widget, focus_pos = self._body.get_focus()\n        if focus_widget is None:\n            return\n        pos = focus_pos\n        while True:\n            yield pos\n            w, pos = self._body.get_next(pos)\n            if not w:\n                break\n        pos = focus_pos\n        while True:\n            w, pos = self._body.get_prev(pos)\n            if not w:\n                break\n            yield pos\n\n    def __reversed__(self):\n        \"\"\"\n        Return a reversed iterator over the positions in this ListBox.\n\n        If :attr:`body` does not implement :meth:`positions` then iterate\n        from above the focus widget up to the top, then from the focus\n        widget down to the bottom.  Note that this is not actually the\n        reverse of what `__iter__()` produces, but this is the best we can\n        do with a minimal list walker implementation.\n        \"\"\"\n        positions_fn = getattr(self._body, 'positions', None)\n        if positions_fn:\n            for pos in positions_fn(reverse=True):\n                yield pos\n            return\n\n        focus_widget, focus_pos = self._body.get_focus()\n        if focus_widget is None:\n            return\n        pos = focus_pos\n        while True:\n            w, pos = self._body.get_prev(pos)\n            if not w:\n                break\n            yield pos\n        pos = focus_pos\n        while True:\n            yield pos\n            w, pos = self._body.get_next(pos)\n            if not w:\n                break",
  "def _modified(self):\n        signals.emit_signal(self, \"modified\")",
  "def get_focus(self):\n        \"\"\"\n        This default implementation relies on a focus attribute and a\n        __getitem__() method defined in a subclass.\n\n        Override and don't call this method if these are not defined.\n        \"\"\"\n        try:\n            focus = self.focus\n            return self[focus], focus\n        except (IndexError, KeyError, TypeError):\n            return None, None",
  "def get_next(self, position):\n        \"\"\"\n        This default implementation relies on a next_position() method and a\n        __getitem__() method defined in a subclass.\n\n        Override and don't call this method if these are not defined.\n        \"\"\"\n        try:\n            position = self.next_position(position)\n            return self[position], position\n        except (IndexError, KeyError):\n            return None, None",
  "def get_prev(self, position):\n        \"\"\"\n        This default implementation relies on a prev_position() method and a\n        __getitem__() method defined in a subclass.\n\n        Override and don't call this method if these are not defined.\n        \"\"\"\n        try:\n            position = self.prev_position(position)\n            return self[position], position\n        except (IndexError, KeyError):\n            return None, None",
  "def __init__(self, contents: Iterable[typing.Any], wrap_around: bool = False):\n        \"\"\"\n        contents -- list to copy into this object\n\n        wrap_around -- if true, jumps to beginning/end of list on move\n\n        This class inherits :class:`MonitoredList` which means\n        it can be treated as a list.\n\n        Changes made to this object (when it is treated as a list) are\n        detected automatically and will cause ListBox objects using\n        this list walker to be updated.\n        \"\"\"\n        if not isinstance(contents, Iterable):\n            raise ListWalkerError(f\"SimpleListWalker expecting list like object, got: {contents!r}\")\n        MonitoredList.__init__(self, contents)\n        self.focus = 0\n        self.wrap_around = wrap_around",
  "def contents(self):\n        \"\"\"\n        Return self.\n\n        Provides compatibility with old SimpleListWalker class.\n        \"\"\"\n        return self",
  "def _get_contents(self):\n        warnings.warn(\n            f\"Method `{self.__class__.__name__}._get_contents` is deprecated, \"\n            f\"please use property`{self.__class__.__name__}.contents`\",\n            DeprecationWarning,\n            stacklevel=3,\n        )\n        return self",
  "def _modified(self):\n        if self.focus >= len(self):\n            self.focus = max(0, len(self) - 1)\n        ListWalker._modified(self)",
  "def set_modified_callback(self, callback) -> typing.NoReturn:\n        \"\"\"\n        This function inherited from MonitoredList is not\n        implemented in SimpleListWalker.\n\n        Use connect_signal(list_walker, \"modified\", ...) instead.\n        \"\"\"\n        raise NotImplementedError('Use connect_signal(list_walker, \"modified\", ...) instead.')",
  "def set_focus(self, position: int) -> None:\n        \"\"\"Set focus position.\"\"\"\n        try:\n            if position < 0 or position >= len(self):\n                raise ValueError\n        except (TypeError, ValueError):\n            raise IndexError(f\"No widget at position {position}\")\n        self.focus = position\n        self._modified()",
  "def next_position(self, position: int) -> int:\n        \"\"\"\n        Return position after start_from.\n        \"\"\"\n        if len(self) - 1 <= position:\n            if self.wrap_around:\n                return 0\n            raise IndexError\n        return position + 1",
  "def prev_position(self, position: int) -> int:\n        \"\"\"\n        Return position before start_from.\n        \"\"\"\n        if position <= 0:\n            if self.wrap_around:\n                return len(self) - 1\n            raise IndexError\n        return position - 1",
  "def positions(self, reverse: bool = False):\n        \"\"\"\n        Optional method for returning an iterable of positions.\n        \"\"\"\n        if reverse:\n            return range(len(self) - 1, -1, -1)\n        return range(len(self))",
  "def __init__(self, contents: Iterable[typing.Any], wrap_around: bool = False):\n        \"\"\"\n        contents -- list to copy into this object\n\n        wrap_around -- if true, jumps to beginning/end of list on move\n\n        This class inherits :class:`MonitoredList` which means\n        it can be treated as a list.\n\n        Changes made to this object (when it is treated as a list) are\n        detected automatically and will cause ListBox objects using\n        this list walker to be updated.\n\n        Also, items added or removed before the widget in focus with\n        normal list methods will cause the focus to be updated\n        intelligently.\n        \"\"\"\n        if not isinstance(contents, Iterable):\n            raise ListWalkerError(f\"SimpleFocusListWalker expecting iterable object, got: {contents!r}\")\n        MonitoredFocusList.__init__(self, contents)\n        self.wrap_around = wrap_around",
  "def set_modified_callback(self, callback) -> typing.NoReturn:\n        \"\"\"\n        This function inherited from MonitoredList is not\n        implemented in SimpleFocusListWalker.\n\n        Use connect_signal(list_walker, \"modified\", ...) instead.\n        \"\"\"\n        raise NotImplementedError('Use connect_signal(list_walker, \"modified\", ...) instead.')",
  "def set_focus(self, position: int) -> None:\n        \"\"\"Set focus position.\"\"\"\n        self.focus = position\n        self._modified()",
  "def next_position(self, position: int) -> int:\n        \"\"\"\n        Return position after start_from.\n        \"\"\"\n        if len(self) - 1 <= position:\n            if self.wrap_around:\n                return 0\n            raise IndexError\n        return position + 1",
  "def prev_position(self, position: int) -> int:\n        \"\"\"\n        Return position before start_from.\n        \"\"\"\n        if position <= 0:\n            if self.wrap_around:\n                return len(self) - 1\n            raise IndexError\n        return position - 1",
  "def positions(self, reverse: bool = False):\n        \"\"\"\n        Optional method for returning an iterable of positions.\n        \"\"\"\n        if reverse:\n            return range(len(self) - 1, -1, -1)\n        return range(len(self))",
  "def __init__(self, body: ListWalker):\n        \"\"\"\n        :param body: a ListWalker subclass such as\n            :class:`SimpleFocusListWalker` that contains\n            widgets to be displayed inside the list box\n        :type body: ListWalker\n        \"\"\"\n        if getattr(body, 'get_focus', None):\n            self._body: ListWalker = body\n        else:\n            self._body = SimpleListWalker(body)\n\n        self.body = self._body  # Initialization hack\n\n        # offset_rows is the number of rows between the top of the view\n        # and the top of the focused item\n        self.offset_rows = 0\n        # inset_fraction is used when the focused widget is off the\n        # top of the view.  it is the fraction of the widget cut off\n        # at the top.  (numerator, denominator)\n        self.inset_fraction = (0, 1)\n\n        # pref_col is the preferred column for the cursor when moving\n        # between widgets that use the cursor (edit boxes etc.)\n        self.pref_col = 'left'\n\n        # variable for delayed focus change used by set_focus\n        self.set_focus_pending = 'first selectable'\n\n        # variable for delayed valign change used by set_focus_valign\n        self.set_focus_valign_pending = None",
  "def body(self):\n        \"\"\"\n        a ListWalker subclass such as :class:`SimpleFocusListWalker` that contains\n        widgets to be displayed inside the list box\n        \"\"\"\n        return self._body",
  "def body(self, body):\n        try:\n            disconnect_signal(self._body, \"modified\", self._invalidate)\n        except AttributeError:\n            # _body is not yet assigned\n            pass\n        if getattr(body, 'get_focus', None):\n            self._body = body\n        else:\n            self._body = SimpleListWalker(body)\n        try:\n            connect_signal(self._body, \"modified\", self._invalidate)\n        except NameError:\n            # our list walker has no modified signal so we must not\n            # cache our canvases because we don't know when our\n            # content has changed\n            self.render = nocache_widget_render_instance(self)\n        self._invalidate()",
  "def _get_body(self):\n        warnings.warn(\n            f\"Method `{self.__class__.__name__}._get_body` is deprecated, \"\n            f\"please use property `{self.__class__.__name__}.body`\",\n            DeprecationWarning,\n            stacklevel=3,\n        )\n        return self.body",
  "def _set_body(self, body):\n        warnings.warn(\n            f\"Method `{self.__class__.__name__}._set_body` is deprecated, \"\n            f\"please use property `{self.__class__.__name__}.body`\",\n            DeprecationWarning,\n            stacklevel=3,\n        )\n        self.body = body",
  "def __len__(self) -> int:\n        if isinstance(self._body, Sized):\n            return len(self._body)\n        raise AttributeError(f\"{self._body.__class__.__name__} is not Sized\")",
  "def calculate_visible(self, size: tuple[int, int], focus: bool = False):\n        \"\"\"\n        Returns the widgets that would be displayed in\n        the ListBox given the current *size* and *focus*.\n\n        see :meth:`Widget.render` for parameter details\n\n        :returns: (*middle*, *top*, *bottom*) or (``None``, ``None``, ``None``)\n\n        *middle*\n            (*row offset*(when +ve) or *inset*(when -ve),\n            *focus widget*, *focus position*, *focus rows*,\n            *cursor coords* or ``None``)\n        *top*\n            (*# lines to trim off top*,\n            list of (*widget*, *position*, *rows*) tuples above focus\n            in order from bottom to top)\n        *bottom*\n            (*# lines to trim off bottom*,\n            list of (*widget*, *position*, *rows*) tuples below focus\n            in order from top to bottom)\n        \"\"\"\n        (maxcol, maxrow) = size\n\n        # 0. set the focus if a change is pending\n        if self.set_focus_pending or self.set_focus_valign_pending:\n            self._set_focus_complete((maxcol, maxrow), focus)\n\n        # 1. start with the focus widget\n        focus_widget, focus_pos = self._body.get_focus()\n        if focus_widget is None:  # list box is empty?\n            return None, None, None\n        top_pos = focus_pos\n\n        offset_rows, inset_rows = self.get_focus_offset_inset((maxcol, maxrow))\n        #    force at least one line of focus to be visible\n        if maxrow and offset_rows >= maxrow:\n            offset_rows = maxrow - 1\n\n        #    adjust position so cursor remains visible\n        cursor = None\n        if maxrow and focus_widget.selectable() and focus:\n            if hasattr(focus_widget, 'get_cursor_coords'):\n                cursor = focus_widget.get_cursor_coords((maxcol,))\n\n        if cursor is not None:\n            cx, cy = cursor\n            effective_cy = cy + offset_rows - inset_rows\n\n            if effective_cy < 0:  # cursor above top?\n                inset_rows = cy\n            elif effective_cy >= maxrow:  # cursor below bottom?\n                offset_rows = maxrow - cy - 1\n                if offset_rows < 0:  # need to trim the top\n                    inset_rows, offset_rows = -offset_rows, 0\n\n        #    set trim_top by focus trimmimg\n        trim_top = inset_rows\n        focus_rows = focus_widget.rows((maxcol,), True)\n\n        # 2. collect the widgets above the focus\n        pos = focus_pos\n        fill_lines = offset_rows\n        fill_above = []\n        top_pos = pos\n        while fill_lines > 0:\n            prev, pos = self._body.get_prev(pos)\n            if prev is None:  # run out of widgets above?\n                offset_rows -= fill_lines\n                break\n            top_pos = pos\n\n            p_rows = prev.rows((maxcol,))\n            if p_rows:  # filter out 0-height widgets\n                fill_above.append((prev, pos, p_rows))\n            if p_rows > fill_lines:  # crosses top edge?\n                trim_top = p_rows - fill_lines\n                break\n            fill_lines -= p_rows\n\n        trim_bottom = focus_rows + offset_rows - inset_rows - maxrow\n        if trim_bottom < 0:\n            trim_bottom = 0\n\n        # 3. collect the widgets below the focus\n        pos = focus_pos\n        fill_lines = maxrow - focus_rows - offset_rows + inset_rows\n        fill_below = []\n        while fill_lines > 0:\n            next, pos = self._body.get_next(pos)\n            if next is None:  # run out of widgets below?\n                break\n\n            n_rows = next.rows((maxcol,))\n            if n_rows:  # filter out 0-height widgets\n                fill_below.append((next, pos, n_rows))\n            if n_rows > fill_lines:  # crosses bottom edge?\n                trim_bottom = n_rows - fill_lines\n                fill_lines -= n_rows\n                break\n            fill_lines -= n_rows\n\n        # 4. fill from top again if necessary & possible\n        fill_lines = max(0, fill_lines)\n\n        if fill_lines > 0 and trim_top > 0:\n            if fill_lines <= trim_top:\n                trim_top -= fill_lines\n                offset_rows += fill_lines\n                fill_lines = 0\n            else:\n                fill_lines -= trim_top\n                offset_rows += trim_top\n                trim_top = 0\n        pos = top_pos\n        while fill_lines > 0:\n            prev, pos = self._body.get_prev(pos)\n            if prev is None:\n                break\n\n            p_rows = prev.rows((maxcol,))\n            fill_above.append((prev, pos, p_rows))\n            if p_rows > fill_lines:  # more than required\n                trim_top = p_rows - fill_lines\n                offset_rows += fill_lines\n                break\n            fill_lines -= p_rows\n            offset_rows += p_rows\n\n        # 5. return the interesting bits\n        return (\n            (offset_rows - inset_rows, focus_widget, focus_pos, focus_rows, cursor),\n            (trim_top, fill_above),\n            (trim_bottom, fill_below),\n        )",
  "def render(self, size: tuple[int, int], focus: bool = False) -> CompositeCanvas | SolidCanvas:\n        \"\"\"\n        Render ListBox and return canvas.\n\n        see :meth:`Widget.render` for details\n        \"\"\"\n        (maxcol, maxrow) = size\n\n        middle, top, bottom = self.calculate_visible((maxcol, maxrow), focus=focus)\n        if middle is None:\n            return SolidCanvas(\" \", maxcol, maxrow)\n\n        _ignore, focus_widget, focus_pos, focus_rows, cursor = middle\n        trim_top, fill_above = top\n        trim_bottom, fill_below = bottom\n\n        combinelist = []\n        rows = 0\n        fill_above.reverse()  # fill_above is in bottom-up order\n        for widget, w_pos, w_rows in fill_above:\n            canvas = widget.render((maxcol,))\n            if w_rows != canvas.rows():\n                raise ListBoxError(\n                    f\"Widget {widget!r} at position {w_pos!r} \"\n                    f\"within listbox calculated {w_rows:d} rows \"\n                    f\"but rendered {canvas.rows():d}!\"\n                )\n            rows += w_rows\n            combinelist.append((canvas, w_pos, False))\n\n        focus_canvas = focus_widget.render((maxcol,), focus=focus)\n\n        if focus_canvas.rows() != focus_rows:\n            raise ListBoxError(\n                f\"Focus Widget {focus_widget!r} at position {focus_pos!r} \"\n                f\"within listbox calculated {focus_rows:d} rows \"\n                f\"but rendered {focus_canvas.rows():d}!\"\n            )\n        c_cursor = focus_canvas.cursor\n        if cursor is not None and cursor != c_cursor:\n            raise ListBoxError(\n                f\"Focus Widget {focus_widget!r} at position {focus_pos!r} \"\n                f\"within listbox calculated cursor coords {cursor!r} \"\n                f\"but rendered cursor coords {c_cursor!r}!\"\n            )\n\n        rows += focus_rows\n        combinelist.append((focus_canvas, focus_pos, True))\n\n        for widget, w_pos, w_rows in fill_below:\n            canvas = widget.render((maxcol,))\n            if w_rows != canvas.rows():\n                raise ListBoxError(\n                    f\"Widget {widget!r} at position {w_pos!r} \"\n                    f\"within listbox calculated {w_rows:d} \"\n                    f\"rows but rendered {canvas.rows():d}!\"\n                )\n            rows += w_rows\n            combinelist.append((canvas, w_pos, False))\n\n        final_canvas = CanvasCombine(combinelist)\n\n        if trim_top:\n            final_canvas.trim(trim_top)\n            rows -= trim_top\n        if trim_bottom:\n            final_canvas.trim_end(trim_bottom)\n            rows -= trim_bottom\n\n        if rows > maxrow:\n            raise ListBoxError(\n                f\"Listbox contents too long!  Probably urwid's fault (please report): {top, middle, bottom!r}\"\n            )\n\n        if rows < maxrow:\n            bottom_pos = focus_pos\n            if fill_below:\n                bottom_pos = fill_below[-1][1]\n            if trim_bottom != 0 or self._body.get_next(bottom_pos) != (None, None):\n                raise ListBoxError(\n                    f\"Listbox contents too short!  Probably urwid's fault (please report): {top, middle, bottom!r}\"\n                )\n            final_canvas.pad_trim_top_bottom(0, maxrow - rows)\n\n        return final_canvas",
  "def get_cursor_coords(self, size: tuple[int, int]) -> tuple[int, int] | None:\n        \"\"\"\n        See :meth:`Widget.get_cursor_coords` for details\n        \"\"\"\n        (maxcol, maxrow) = size\n\n        middle, top, bottom = self.calculate_visible((maxcol, maxrow), True)\n        if middle is None:\n            return None\n\n        offset_inset, _ignore1, _ignore2, _ignore3, cursor = middle\n        if not cursor:\n            return None\n\n        x, y = cursor\n        y += offset_inset\n        if y < 0 or y >= maxrow:\n            return None\n        return (x, y)",
  "def set_focus_valign(\n        self,\n        valign: Literal['top', 'middle', 'bottom'] | tuple[Literal['fixed top', 'fixed bottom', 'relative'], int],\n    ):\n        \"\"\"Set the focus widget's display offset and inset.\n\n        :param valign: one of:\n            'top', 'middle', 'bottom'\n            ('fixed top', rows)\n            ('fixed bottom', rows)\n            ('relative', percentage 0=top 100=bottom)\n        \"\"\"\n        vt, va = normalize_valign(valign, ListBoxError)\n        self.set_focus_valign_pending = vt, va",
  "def set_focus(self, position, coming_from: Literal['above', 'below'] | None = None) -> None:\n        \"\"\"\n        Set the focus position and try to keep the old focus in view.\n\n        :param position: a position compatible with :meth:`self._body.set_focus`\n        :param coming_from: set to 'above' or 'below' if you know that\n                            old position is above or below the new position.\n        :type coming_from: str\n        \"\"\"\n        if coming_from not in ('above', 'below', None):\n            raise ListBoxError(f\"coming_from value invalid: {coming_from!r}\")\n        focus_widget, focus_pos = self._body.get_focus()\n        if focus_widget is None:\n            raise IndexError(\"Can't set focus, ListBox is empty\")\n\n        self.set_focus_pending = coming_from, focus_widget, focus_pos\n        self._body.set_focus(position)",
  "def get_focus(self):\n        \"\"\"\n        Return a `(focus widget, focus position)` tuple, for backwards\n        compatibility. You may also use the new standard container\n        properties :attr:`focus` and :attr:`focus_position` to read these values.\n        \"\"\"\n        warnings.warn(\n            \"only for backwards compatibility.\"\n            \"You may also use the new standard container property `focus` to get the focus \"\n            \"and property `focus_position` to read these values.\",\n            PendingDeprecationWarning,\n            stacklevel=2,\n        )\n        return self._body.get_focus()",
  "def focus(self):\n        \"\"\"\n        the child widget in focus or None when ListBox is empty.\n\n        Return the widget in focus according to our :obj:`list walker <ListWalker>`.\n        \"\"\"\n        return self._body.get_focus()[0]",
  "def _get_focus(self) -> Widget:\n        warnings.warn(\n            f\"method `{self.__class__.__name__}._get_focus` is deprecated, \"\n            f\"please use `{self.__class__.__name__}.focus` property\",\n            DeprecationWarning,\n            stacklevel=3,\n        )\n        return self.focus",
  "def _get_focus_position(self):\n        \"\"\"\n        Return the list walker position of the widget in focus. The type\n        of value returned depends on the :obj:`list walker <ListWalker>`.\n\n        \"\"\"\n        w, pos = self._body.get_focus()\n        if w is None:\n            raise IndexError(\"No focus_position, ListBox is empty\")\n        return pos",
  "def _contents(self):\n        class ListBoxContents:\n            __getitem__ = self._contents__getitem__\n\n        return ListBoxContents()",
  "def _contents__getitem__(self, key):\n        # try list walker protocol v2 first\n        getitem = getattr(self._body, '__getitem__', None)\n        if getitem:\n            try:\n                return (getitem(key), None)\n            except (IndexError, KeyError):\n                raise KeyError(f\"ListBox.contents key not found: {key!r}\")\n        # fall back to v1\n        w, old_focus = self._body.get_focus()\n        try:\n            try:\n                self._body.set_focus(key)\n                return self._body.get_focus()[0]\n            except (IndexError, KeyError):\n                raise KeyError(f\"ListBox.contents key not found: {key!r}\")\n        finally:\n            self._body.set_focus(old_focus)",
  "def contents(self):\n        \"\"\"\n        An object that allows reading widgets from the ListBox's list\n        walker as a `(widget, options)` tuple. `None` is currently the only\n        value for options.\n\n        .. warning::\n\n            This object may not be used to set or iterate over contents.\n\n            You must use the list walker stored as\n            :attr:`.body` to perform manipulation and iteration, if supported.\n        \"\"\"\n        return self._contents",
  "def options(self):\n        \"\"\"\n        There are currently no options for ListBox contents.\n\n        Return None as a placeholder for future options.\n        \"\"\"\n        return None",
  "def _set_focus_valign_complete(self, size: tuple[int, int], focus: bool) -> None:\n        \"\"\"\n        Finish setting the offset and inset now that we have have a\n        maxcol & maxrow.\n        \"\"\"\n        (maxcol, maxrow) = size\n        vt, va = self.set_focus_valign_pending\n        self.set_focus_valign_pending = None\n        self.set_focus_pending = None\n\n        focus_widget, focus_pos = self._body.get_focus()\n        if focus_widget is None:\n            return\n\n        rows = focus_widget.rows((maxcol,), focus)\n        rtop, rbot = calculate_top_bottom_filler(maxrow, vt, va, WHSettings.GIVEN, rows, None, 0, 0)\n\n        self.shift_focus((maxcol, maxrow), rtop)",
  "def _set_focus_first_selectable(self, size: tuple[int, int], focus: bool) -> None:\n        \"\"\"\n        Choose the first visible, selectable widget below the\n        current focus as the focus widget.\n        \"\"\"\n        (maxcol, maxrow) = size\n        self.set_focus_valign_pending = None\n        self.set_focus_pending = None\n        middle, top, bottom = self.calculate_visible((maxcol, maxrow), focus=focus)\n        if middle is None:\n            return\n\n        row_offset, focus_widget, focus_pos, focus_rows, cursor = middle\n        trim_top, fill_above = top\n        trim_bottom, fill_below = bottom\n\n        if focus_widget.selectable():\n            return\n\n        if trim_bottom:\n            fill_below = fill_below[:-1]\n        new_row_offset = row_offset + focus_rows\n        for widget, pos, rows in fill_below:\n            if widget.selectable():\n                self._body.set_focus(pos)\n                self.shift_focus((maxcol, maxrow), new_row_offset)\n                return\n            new_row_offset += rows",
  "def _set_focus_complete(self, size: tuple[int, int], focus: bool) -> None:\n        \"\"\"\n        Finish setting the position now that we have maxcol & maxrow.\n        \"\"\"\n        (maxcol, maxrow) = size\n        self._invalidate()\n        if self.set_focus_pending == \"first selectable\":\n            return self._set_focus_first_selectable((maxcol, maxrow), focus)\n        if self.set_focus_valign_pending is not None:\n            return self._set_focus_valign_complete((maxcol, maxrow), focus)\n        coming_from, focus_widget, focus_pos = self.set_focus_pending\n        self.set_focus_pending = None\n\n        # new position\n        new_focus_widget, position = self._body.get_focus()\n        if focus_pos == position:\n            # do nothing\n            return\n\n        # restore old focus temporarily\n        self._body.set_focus(focus_pos)\n\n        middle, top, bottom = self.calculate_visible((maxcol, maxrow), focus)\n        focus_offset, focus_widget, focus_pos, focus_rows, cursor = middle\n        trim_top, fill_above = top\n        trim_bottom, fill_below = bottom\n\n        offset = focus_offset\n        for widget, pos, rows in fill_above:\n            offset -= rows\n            if pos == position:\n                self.change_focus((maxcol, maxrow), pos, offset, 'below')\n                return\n\n        offset = focus_offset + focus_rows\n        for widget, pos, rows in fill_below:\n            if pos == position:\n                self.change_focus((maxcol, maxrow), pos, offset, 'above')\n                return\n            offset += rows\n\n        # failed to find widget among visible widgets\n        self._body.set_focus(position)\n        widget, position = self._body.get_focus()\n        rows = widget.rows((maxcol,), focus)\n\n        if coming_from == 'below':\n            offset = 0\n        elif coming_from == 'above':\n            offset = maxrow - rows\n        else:\n            offset = (maxrow - rows) // 2\n        self.shift_focus((maxcol, maxrow), offset)",
  "def shift_focus(self, size: tuple[int, int], offset_inset: int) -> None:\n        \"\"\"\n        Move the location of the current focus relative to the top.\n        This is used internally by methods that know the widget's *size*.\n\n        See also :meth:`.set_focus_valign`.\n\n        :param size: see :meth:`Widget.render` for details\n        :param offset_inset: either the number of rows between the\n            top of the listbox and the start of the focus widget (+ve\n            value) or the number of lines of the focus widget hidden off\n            the top edge of the listbox (-ve value) or ``0`` if the top edge\n            of the focus widget is aligned with the top edge of the\n            listbox.\n        :type offset_inset: int\n        \"\"\"\n        (maxcol, maxrow) = size\n\n        if offset_inset >= 0:\n            if offset_inset >= maxrow:\n                raise ListBoxError(f\"Invalid offset_inset: {offset_inset!r}, only {maxrow!r} rows in list box\")\n            self.offset_rows = offset_inset\n            self.inset_fraction = (0, 1)\n        else:\n            target, _ignore = self._body.get_focus()\n            tgt_rows = target.rows((maxcol,), True)\n            if offset_inset + tgt_rows <= 0:\n                raise ListBoxError(f\"Invalid offset_inset: {offset_inset!r}, only {tgt_rows!r} rows in target!\")\n            self.offset_rows = 0\n            self.inset_fraction = (-offset_inset, tgt_rows)\n        self._invalidate()",
  "def update_pref_col_from_focus(self, size: tuple[int, int]):\n        \"\"\"Update self.pref_col from the focus widget.\"\"\"\n        # TODO: should this not be private?\n        (maxcol, maxrow) = size\n\n        widget, old_pos = self._body.get_focus()\n        if widget is None:\n            return\n\n        pref_col = None\n        if hasattr(widget, 'get_pref_col'):\n            pref_col = widget.get_pref_col((maxcol,))\n        if pref_col is None and hasattr(widget, 'get_cursor_coords'):\n            coords = widget.get_cursor_coords((maxcol,))\n            if isinstance(coords, tuple):\n                pref_col, y = coords\n        if pref_col is not None:\n            self.pref_col = pref_col",
  "def change_focus(\n        self,\n        size: tuple[int, int],\n        position,\n        offset_inset: int = 0,\n        coming_from: Literal['above', 'below'] | None = None,\n        cursor_coords: tuple[int, int] | None = None,\n        snap_rows: int | None = None,\n    ) -> None:\n        \"\"\"\n        Change the current focus widget.\n        This is used internally by methods that know the widget's *size*.\n\n        See also :meth:`.set_focus`.\n\n        :param size: see :meth:`Widget.render` for details\n        :param position: a position compatible with :meth:`self._body.set_focus`\n        :param offset_inset: either the number of rows between the\n            top of the listbox and the start of the focus widget (+ve\n            value) or the number of lines of the focus widget hidden off\n            the top edge of the listbox (-ve value) or 0 if the top edge\n            of the focus widget is aligned with the top edge of the\n            listbox (default if unspecified)\n        :type offset_inset: int\n        :param coming_from: either 'above', 'below' or unspecified `None`\n        :type coming_from: str\n        :param cursor_coords: (x, y) tuple indicating the desired\n            column and row for the cursor, a (x,) tuple indicating only\n            the column for the cursor, or unspecified\n        :type cursor_coords: (int, int)\n        :param snap_rows: the maximum number of extra rows to scroll\n            when trying to \"snap\" a selectable focus into the view\n        :type snap_rows: int\n        \"\"\"\n        (maxcol, maxrow) = size\n\n        # update pref_col before change\n        if cursor_coords:\n            self.pref_col = cursor_coords[0]\n        else:\n            self.update_pref_col_from_focus((maxcol, maxrow))\n\n        self._invalidate()\n        self._body.set_focus(position)\n        target, _ignore = self._body.get_focus()\n        tgt_rows = target.rows((maxcol,), True)\n        if snap_rows is None:\n            snap_rows = maxrow - 1\n\n        # \"snap\" to selectable widgets\n        align_top = 0\n        align_bottom = maxrow - tgt_rows\n\n        if coming_from == 'above' and target.selectable() and offset_inset > align_bottom:\n            if snap_rows >= offset_inset - align_bottom:\n                offset_inset = align_bottom\n            elif snap_rows >= offset_inset - align_top:\n                offset_inset = align_top\n            else:\n                offset_inset -= snap_rows\n\n        if coming_from == 'below' and target.selectable() and offset_inset < align_top:\n            if snap_rows >= align_top - offset_inset:\n                offset_inset = align_top\n            elif snap_rows >= align_bottom - offset_inset:\n                offset_inset = align_bottom\n            else:\n                offset_inset += snap_rows\n\n        # convert offset_inset to offset_rows or inset_fraction\n        if offset_inset >= 0:\n            self.offset_rows = offset_inset\n            self.inset_fraction = (0, 1)\n        else:\n            if offset_inset + tgt_rows <= 0:\n                raise ListBoxError(f\"Invalid offset_inset: {offset_inset}, only {tgt_rows} rows in target!\")\n            self.offset_rows = 0\n            self.inset_fraction = (-offset_inset, tgt_rows)\n\n        if cursor_coords is None:\n            if coming_from is None:\n                return  # must either know row or coming_from\n            cursor_coords = (self.pref_col,)\n\n        if not hasattr(target, 'move_cursor_to_coords'):\n            return\n\n        attempt_rows = []\n\n        if len(cursor_coords) == 1:\n            # only column (not row) specified\n            # start from closest edge and move inwards\n            (pref_col,) = cursor_coords\n            if coming_from == 'above':\n                attempt_rows = range(0, tgt_rows)\n            else:\n                assert (\n                    coming_from == 'below'\n                ), \"must specify coming_from ('above' or 'below') if cursor row is not specified\"\n                attempt_rows = range(tgt_rows, -1, -1)\n        else:\n            # both column and row specified\n            # start from preferred row and move back to closest edge\n            (pref_col, pref_row) = cursor_coords\n            if pref_row < 0 or pref_row >= tgt_rows:\n                raise ListBoxError(\n                    f\"cursor_coords row outside valid range for target. pref_row:{pref_row!r} target_rows:{tgt_rows!r}\"\n                )\n\n            if coming_from == 'above':\n                attempt_rows = range(pref_row, -1, -1)\n            elif coming_from == 'below':\n                attempt_rows = range(pref_row, tgt_rows)\n            else:\n                attempt_rows = [pref_row]\n\n        for row in attempt_rows:\n            if target.move_cursor_to_coords((maxcol,), pref_col, row):\n                break",
  "def get_focus_offset_inset(self, size: tuple[int, int]) -> tuple[int, int]:\n        \"\"\"Return (offset rows, inset rows) for focus widget.\"\"\"\n        (maxcol, maxrow) = size\n        focus_widget, pos = self._body.get_focus()\n        focus_rows = focus_widget.rows((maxcol,), True)\n        offset_rows = self.offset_rows\n        inset_rows = 0\n        if offset_rows == 0:\n            inum, iden = self.inset_fraction\n            if inum < 0 or iden < 0 or inum >= iden:\n                raise ListBoxError(f\"Invalid inset_fraction: {self.inset_fraction!r}\")\n            inset_rows = focus_rows * inum // iden\n            if inset_rows and inset_rows >= focus_rows:\n                raise ListBoxError(\"urwid inset_fraction error (please report)\")\n        return offset_rows, inset_rows",
  "def make_cursor_visible(self, size: tuple[int, int]) -> None:\n        \"\"\"Shift the focus widget so that its cursor is visible.\"\"\"\n        (maxcol, maxrow) = size\n\n        focus_widget, pos = self._body.get_focus()\n        if focus_widget is None:\n            return\n        if not focus_widget.selectable():\n            return\n        if not hasattr(focus_widget, 'get_cursor_coords'):\n            return\n        cursor = focus_widget.get_cursor_coords((maxcol,))\n        if cursor is None:\n            return\n        cx, cy = cursor\n        offset_rows, inset_rows = self.get_focus_offset_inset((maxcol, maxrow))\n\n        if cy < inset_rows:\n            self.shift_focus((maxcol, maxrow), -(cy))\n            return\n\n        if offset_rows - inset_rows + cy >= maxrow:\n            self.shift_focus((maxcol, maxrow), maxrow - cy - 1)\n            return",
  "def keypress(self, size: tuple[int, int], key: str) -> str | None:\n        \"\"\"Move selection through the list elements scrolling when\n        necessary. Keystrokes are first passed to widget in focus\n        in case that widget can handle them.\n\n        Keystrokes handled by this widget are:\n         'up'        up one line (or widget)\n         'down'      down one line (or widget)\n         'page up'   move cursor up one listbox length (or widget)\n         'page down' move cursor down one listbox length (or widget)\n        \"\"\"\n        (maxcol, maxrow) = size\n\n        if self.set_focus_pending or self.set_focus_valign_pending:\n            self._set_focus_complete((maxcol, maxrow), focus=True)\n\n        focus_widget, pos = self._body.get_focus()\n        if focus_widget is None:  # empty listbox, can't do anything\n            return key\n\n        if focus_widget.selectable():\n            key = focus_widget.keypress((maxcol,), key)\n            if key is None:\n                self.make_cursor_visible((maxcol, maxrow))\n                return None\n\n        def actual_key(unhandled):\n            if unhandled:\n                return key\n\n        # pass off the heavy lifting\n        if self._command_map[key] == Command.UP:\n            return actual_key(self._keypress_up((maxcol, maxrow)))\n\n        if self._command_map[key] == Command.DOWN:\n            return actual_key(self._keypress_down((maxcol, maxrow)))\n\n        if self._command_map[key] == Command.PAGE_UP:\n            return actual_key(self._keypress_page_up((maxcol, maxrow)))\n\n        if self._command_map[key] == Command.PAGE_DOWN:\n            return actual_key(self._keypress_page_down((maxcol, maxrow)))\n\n        if self._command_map[key] == Command.MAX_LEFT:\n            return actual_key(self._keypress_max_left((maxcol, maxrow)))\n\n        if self._command_map[key] == Command.MAX_RIGHT:\n            return actual_key(self._keypress_max_right((maxcol, maxrow)))\n\n        return key",
  "def _keypress_max_left(self, size: tuple[int, int]) -> bool:\n        self.focus_position = next(iter(self.body.positions()))\n        self.set_focus_valign('top')\n        return True",
  "def _keypress_max_right(self, size: tuple[int, int]) -> bool:\n        self.focus_position = next(iter(self.body.positions(reverse=True)))\n        self.set_focus_valign('bottom')\n        return True",
  "def _keypress_up(self, size: tuple[int, int]) -> bool | None:\n        (maxcol, maxrow) = size\n\n        middle, top, bottom = self.calculate_visible((maxcol, maxrow), True)\n        if middle is None:\n            return True\n\n        focus_row_offset, focus_widget, focus_pos, _ignore, cursor = middle\n        trim_top, fill_above = top\n\n        row_offset = focus_row_offset\n\n        # look for selectable widget above\n        pos = focus_pos\n        widget = None\n        for widget, pos, rows in fill_above:\n            row_offset -= rows\n            if rows and widget.selectable():\n                # this one will do\n                self.change_focus((maxcol, maxrow), pos, row_offset, 'below')\n                return\n\n        # at this point we must scroll\n        row_offset += 1\n        self._invalidate()\n\n        while row_offset > 0:\n            # need to scroll in another candidate widget\n            widget, pos = self._body.get_prev(pos)\n            if widget is None:\n                # cannot scroll any further\n                return True  # keypress not handled\n            rows = widget.rows((maxcol,), True)\n            row_offset -= rows\n            if rows and widget.selectable():\n                # this one will do\n                self.change_focus((maxcol, maxrow), pos, row_offset, 'below')\n                return\n\n        if not focus_widget.selectable() or focus_row_offset + 1 >= maxrow:\n            # just take top one if focus is not selectable\n            # or if focus has moved out of view\n            if widget is None:\n                self.shift_focus((maxcol, maxrow), row_offset)\n                return\n            self.change_focus((maxcol, maxrow), pos, row_offset, 'below')\n            return\n\n        # check if cursor will stop scroll from taking effect\n        if cursor is not None:\n            x, y = cursor\n            if y + focus_row_offset + 1 >= maxrow:\n                # cursor position is a problem,\n                # choose another focus\n                if widget is None:\n                    # try harder to get prev widget\n                    widget, pos = self._body.get_prev(pos)\n                    if widget is None:\n                        return  # can't do anything\n                    rows = widget.rows((maxcol,), True)\n                    row_offset -= rows\n\n                if -row_offset >= rows:\n                    # must scroll further than 1 line\n                    row_offset = -(rows - 1)\n\n                self.change_focus((maxcol, maxrow), pos, row_offset, 'below')\n                return\n\n        # if all else fails, just shift the current focus.\n        self.shift_focus((maxcol, maxrow), focus_row_offset + 1)",
  "def _keypress_down(self, size: tuple[int, int]) -> bool | None:\n        (maxcol, maxrow) = size\n\n        middle, top, bottom = self.calculate_visible((maxcol, maxrow), True)\n        if middle is None:\n            return True\n\n        focus_row_offset, focus_widget, focus_pos, focus_rows, cursor = middle\n        trim_bottom, fill_below = bottom\n\n        row_offset = focus_row_offset + focus_rows\n        rows = focus_rows\n\n        # look for selectable widget below\n        pos = focus_pos\n        widget = None\n        for widget, pos, rows in fill_below:\n            if rows and widget.selectable():\n                # this one will do\n                self.change_focus((maxcol, maxrow), pos, row_offset, 'above')\n                return\n            row_offset += rows\n\n        # at this point we must scroll\n        row_offset -= 1\n        self._invalidate()\n\n        while row_offset < maxrow:\n            # need to scroll in another candidate widget\n            widget, pos = self._body.get_next(pos)\n            if widget is None:\n                # cannot scroll any further\n                return True  # keypress not handled\n            rows = widget.rows((maxcol,))\n            if rows and widget.selectable():\n                # this one will do\n                self.change_focus((maxcol, maxrow), pos, row_offset, 'above')\n                return\n            row_offset += rows\n\n        if not focus_widget.selectable() or focus_row_offset + focus_rows - 1 <= 0:\n            # just take bottom one if current is not selectable\n            # or if focus has moved out of view\n            if widget is None:\n                self.shift_focus((maxcol, maxrow), row_offset - rows)\n                return\n            # FIXME: catch this bug in testcase\n            # self.change_focus((maxcol,maxrow), pos,\n            #    row_offset+rows, 'above')\n            self.change_focus((maxcol, maxrow), pos, row_offset - rows, 'above')\n            return\n\n        # check if cursor will stop scroll from taking effect\n        if cursor is not None:\n            x, y = cursor\n            if y + focus_row_offset - 1 < 0:\n                # cursor position is a problem,\n                # choose another focus\n                if widget is None:\n                    # try harder to get next widget\n                    widget, pos = self._body.get_next(pos)\n                    if widget is None:\n                        return  # can't do anything\n                else:\n                    row_offset -= rows\n\n                if row_offset >= maxrow:\n                    # must scroll further than 1 line\n                    row_offset = maxrow - 1\n\n                self.change_focus(\n                    (maxcol, maxrow),\n                    pos,\n                    row_offset,\n                    'above',\n                )\n                return\n\n        # if all else fails, keep the current focus.\n        self.shift_focus((maxcol, maxrow), focus_row_offset - 1)",
  "def _keypress_page_up(self, size: tuple[int, int]) -> bool | None:\n        (maxcol, maxrow) = size\n\n        middle, top, bottom = self.calculate_visible((maxcol, maxrow), True)\n        if middle is None:\n            return True\n\n        row_offset, focus_widget, focus_pos, focus_rows, cursor = middle\n        trim_top, fill_above = top\n\n        # topmost_visible is row_offset rows above top row of\n        # focus (+ve) or -row_offset rows below top row of focus (-ve)\n        topmost_visible = row_offset\n\n        # scroll_from_row is (first match)\n        # 1. topmost visible row if focus is not selectable\n        # 2. row containing cursor if focus has a cursor\n        # 3. top row of focus widget if it is visible\n        # 4. topmost visible row otherwise\n        if not focus_widget.selectable():\n            scroll_from_row = topmost_visible\n        elif cursor is not None:\n            x, y = cursor\n            scroll_from_row = -y\n        elif row_offset >= 0:\n            scroll_from_row = 0\n        else:\n            scroll_from_row = topmost_visible\n\n        # snap_rows is maximum extra rows to scroll when\n        # snapping to new a focus\n        snap_rows = topmost_visible - scroll_from_row\n\n        # move row_offset to the new desired value (1 \"page\" up)\n        row_offset = scroll_from_row + maxrow\n\n        # not used below:\n        scroll_from_row = topmost_visible = None\n\n        # gather potential target widgets\n        t = []\n        # add current focus\n        t.append((row_offset, focus_widget, focus_pos, focus_rows))\n        pos = focus_pos\n        # include widgets from calculate_visible(..)\n        for widget, pos, rows in fill_above:\n            row_offset -= rows\n            t.append((row_offset, widget, pos, rows))\n        # add newly visible ones, including within snap_rows\n        snap_region_start = len(t)\n        while row_offset > -snap_rows:\n            widget, pos = self._body.get_prev(pos)\n            if widget is None:\n                break\n            rows = widget.rows((maxcol,))\n            row_offset -= rows\n            # determine if one below puts current one into snap rgn\n            if row_offset > 0:\n                snap_region_start += 1\n            t.append((row_offset, widget, pos, rows))\n\n        # if we can't fill the top we need to adjust the row offsets\n        row_offset, w, p, r = t[-1]\n        if row_offset > 0:\n            adjust = -row_offset\n            t = [(ro + adjust, w, p, r) for (ro, w, p, r) in t]\n\n        # if focus_widget (first in t) is off edge, remove it\n        row_offset, w, p, r = t[0]\n        if row_offset >= maxrow:\n            del t[0]\n            snap_region_start -= 1\n\n        # we'll need this soon\n        self.update_pref_col_from_focus((maxcol, maxrow))\n\n        # choose the topmost selectable and (newly) visible widget\n        # search within snap_rows then visible region\n        search_order = list(range(snap_region_start, len(t))) + list(range(snap_region_start - 1, -1, -1))\n        # assert 0, repr((t, search_order))\n        bad_choices = []\n        cut_off_selectable_chosen = 0\n        for i in search_order:\n            row_offset, widget, pos, rows = t[i]\n            if not widget.selectable():\n                continue\n\n            if not rows:\n                continue\n\n            # try selecting this widget\n            pref_row = max(0, -row_offset)\n\n            # if completely within snap region, adjust row_offset\n            if rows + row_offset <= 0:\n                self.change_focus(\n                    (maxcol, maxrow),\n                    pos,\n                    -(rows - 1),\n                    'below',\n                    (self.pref_col, rows - 1),\n                    snap_rows - ((-row_offset) - (rows - 1)),\n                )\n            else:\n                self.change_focus(\n                    (maxcol, maxrow),\n                    pos,\n                    row_offset,\n                    'below',\n                    (self.pref_col, pref_row),\n                    snap_rows,\n                )\n\n            # if we're as far up as we can scroll, take this one\n            if fill_above and self._body.get_prev(fill_above[-1][1]) == (None, None):\n                pass  # return\n\n            # find out where that actually puts us\n            middle, top, bottom = self.calculate_visible((maxcol, maxrow), True)\n            act_row_offset, _ign1, _ign2, _ign3, _ign4 = middle\n\n            # discard chosen widget if it will reduce scroll amount\n            # because of a fixed cursor (absolute last resort)\n            if act_row_offset > row_offset + snap_rows:\n                bad_choices.append(i)\n                continue\n            if act_row_offset < row_offset:\n                bad_choices.append(i)\n                continue\n\n            # also discard if off top edge (second last resort)\n            if act_row_offset < 0:\n                bad_choices.append(i)\n                cut_off_selectable_chosen = 1\n                continue\n\n            return\n\n        # anything selectable is better than what follows:\n        if cut_off_selectable_chosen:\n            return\n\n        if fill_above and focus_widget.selectable():\n            # if we're at the top and have a selectable, return\n            if self._body.get_prev(fill_above[-1][1]) == (None, None):\n                pass  # return\n\n        # if still none found choose the topmost widget\n        good_choices = [j for j in search_order if j not in bad_choices]\n        for i in good_choices + search_order:\n            row_offset, widget, pos, rows = t[i]\n            if pos == focus_pos:\n                continue\n\n            if not rows:  # never focus a 0-height widget\n                continue\n\n            # if completely within snap region, adjust row_offset\n            if rows + row_offset <= 0:\n                snap_rows -= (-row_offset) - (rows - 1)\n                row_offset = -(rows - 1)\n\n            self.change_focus((maxcol, maxrow), pos, row_offset, 'below', None, snap_rows)\n            return\n\n        # no choices available, just shift current one\n        self.shift_focus((maxcol, maxrow), min(maxrow - 1, row_offset))\n\n        # final check for pathological case where we may fall short\n        middle, top, bottom = self.calculate_visible((maxcol, maxrow), True)\n        act_row_offset, _ign1, pos, _ign2, _ign3 = middle\n        if act_row_offset >= row_offset:\n            # no problem\n            return\n\n        # fell short, try to select anything else above\n        if not t:\n            return\n        _ign1, _ign2, pos, _ign3 = t[-1]\n        widget, pos = self._body.get_prev(pos)\n        if widget is None:\n            # no dice, we're stuck here\n            return\n        # bring in only one row if possible\n        rows = widget.rows((maxcol,), True)\n        self.change_focus((maxcol, maxrow), pos, -(rows - 1), 'below', (self.pref_col, rows - 1), 0)",
  "def _keypress_page_down(self, size: tuple[int, int]) -> bool | None:\n        (maxcol, maxrow) = size\n\n        middle, top, bottom = self.calculate_visible((maxcol, maxrow), True)\n        if middle is None:\n            return True\n\n        row_offset, focus_widget, focus_pos, focus_rows, cursor = middle\n        trim_bottom, fill_below = bottom\n\n        # bottom_edge is maxrow-focus_pos rows below top row of focus\n        bottom_edge = maxrow - row_offset\n\n        # scroll_from_row is (first match)\n        # 1. bottom edge if focus is not selectable\n        # 2. row containing cursor + 1 if focus has a cursor\n        # 3. bottom edge of focus widget if it is visible\n        # 4. bottom edge otherwise\n        if not focus_widget.selectable():\n            scroll_from_row = bottom_edge\n        elif cursor is not None:\n            x, y = cursor\n            scroll_from_row = y + 1\n        elif bottom_edge >= focus_rows:\n            scroll_from_row = focus_rows\n        else:\n            scroll_from_row = bottom_edge\n\n        # snap_rows is maximum extra rows to scroll when\n        # snapping to new a focus\n        snap_rows = bottom_edge - scroll_from_row\n\n        # move row_offset to the new desired value (1 \"page\" down)\n        row_offset = -scroll_from_row\n\n        # not used below:\n        scroll_from_row = bottom_edge = None\n\n        # gather potential target widgets\n        t = []\n        # add current focus\n        t.append((row_offset, focus_widget, focus_pos, focus_rows))\n        pos = focus_pos\n        row_offset += focus_rows\n        # include widgets from calculate_visible(..)\n        for widget, pos, rows in fill_below:\n            t.append((row_offset, widget, pos, rows))\n            row_offset += rows\n        # add newly visible ones, including within snap_rows\n        snap_region_start = len(t)\n        while row_offset < maxrow + snap_rows:\n            widget, pos = self._body.get_next(pos)\n            if widget is None:\n                break\n            rows = widget.rows((maxcol,))\n            t.append((row_offset, widget, pos, rows))\n            row_offset += rows\n            # determine if one above puts current one into snap rgn\n            if row_offset < maxrow:\n                snap_region_start += 1\n\n        # if we can't fill the bottom we need to adjust the row offsets\n        row_offset, w, p, rows = t[-1]\n        if row_offset + rows < maxrow:\n            adjust = maxrow - (row_offset + rows)\n            t = [(ro + adjust, w, p, r) for (ro, w, p, r) in t]\n\n        # if focus_widget (first in t) is off edge, remove it\n        row_offset, w, p, rows = t[0]\n        if row_offset + rows <= 0:\n            del t[0]\n            snap_region_start -= 1\n\n        # we'll need this soon\n        self.update_pref_col_from_focus((maxcol, maxrow))\n\n        # choose the bottommost selectable and (newly) visible widget\n        # search within snap_rows then visible region\n        search_order = list(range(snap_region_start, len(t))) + list(range(snap_region_start - 1, -1, -1))\n        # assert 0, repr((t, search_order))\n        bad_choices = []\n        cut_off_selectable_chosen = 0\n        for i in search_order:\n            row_offset, widget, pos, rows = t[i]\n            if not widget.selectable():\n                continue\n\n            if not rows:\n                continue\n\n            # try selecting this widget\n            pref_row = min(maxrow - row_offset - 1, rows - 1)\n\n            # if completely within snap region, adjust row_offset\n            if row_offset >= maxrow:\n                self.change_focus(\n                    (maxcol, maxrow),\n                    pos,\n                    maxrow - 1,\n                    'above',\n                    (self.pref_col, 0),\n                    snap_rows + maxrow - row_offset - 1,\n                )\n            else:\n                self.change_focus(\n                    (maxcol, maxrow),\n                    pos,\n                    row_offset,\n                    'above',\n                    (self.pref_col, pref_row),\n                    snap_rows,\n                )\n\n            # find out where that actually puts us\n            middle, top, bottom = self.calculate_visible((maxcol, maxrow), True)\n            act_row_offset, _ign1, _ign2, _ign3, _ign4 = middle\n\n            # discard chosen widget if it will reduce scroll amount\n            # because of a fixed cursor (absolute last resort)\n            if act_row_offset < row_offset - snap_rows:\n                bad_choices.append(i)\n                continue\n            if act_row_offset > row_offset:\n                bad_choices.append(i)\n                continue\n\n            # also discard if off top edge (second last resort)\n            if act_row_offset + rows > maxrow:\n                bad_choices.append(i)\n                cut_off_selectable_chosen = 1\n                continue\n\n            return\n\n        # anything selectable is better than what follows:\n        if cut_off_selectable_chosen:\n            return\n\n        # if still none found choose the bottommost widget\n        good_choices = [j for j in search_order if j not in bad_choices]\n        for i in good_choices + search_order:\n            row_offset, widget, pos, rows = t[i]\n            if pos == focus_pos:\n                continue\n\n            if not rows:  # never focus a 0-height widget\n                continue\n\n            # if completely within snap region, adjust row_offset\n            if row_offset >= maxrow:\n                snap_rows -= snap_rows + maxrow - row_offset - 1\n                row_offset = maxrow - 1\n\n            self.change_focus((maxcol, maxrow), pos, row_offset, 'above', None, snap_rows)\n            return\n\n        # no choices available, just shift current one\n        self.shift_focus((maxcol, maxrow), max(1 - focus_rows, row_offset))\n\n        # final check for pathological case where we may fall short\n        middle, top, bottom = self.calculate_visible((maxcol, maxrow), True)\n        act_row_offset, _ign1, pos, _ign2, _ign3 = middle\n        if act_row_offset <= row_offset:\n            # no problem\n            return\n\n        # fell short, try to select anything else below\n        if not t:\n            return\n        _ign1, _ign2, pos, _ign3 = t[-1]\n        widget, pos = self._body.get_next(pos)\n        if widget is None:\n            # no dice, we're stuck here\n            return\n        # bring in only one row if possible\n        rows = widget.rows((maxcol,), True)\n        self.change_focus((maxcol, maxrow), pos, maxrow - 1, 'above', (self.pref_col, 0), 0)",
  "def mouse_event(self, size: tuple[int, int], event, button: int, col: int, row: int, focus: bool) -> bool | None:\n        \"\"\"\n        Pass the event to the contained widgets.\n        May change focus on button 1 press.\n        \"\"\"\n        (maxcol, maxrow) = size\n        middle, top, bottom = self.calculate_visible((maxcol, maxrow), focus=True)\n        if middle is None:\n            return False\n\n        _ignore, focus_widget, focus_pos, focus_rows, cursor = middle\n        trim_top, fill_above = top\n        _ignore, fill_below = bottom\n\n        fill_above.reverse()  # fill_above is in bottom-up order\n        w_list = fill_above + [(focus_widget, focus_pos, focus_rows)] + fill_below\n\n        wrow = -trim_top\n        for w, w_pos, w_rows in w_list:\n            if wrow + w_rows > row:\n                break\n            wrow += w_rows\n        else:\n            return False\n\n        focus = focus and w == focus_widget\n        if is_mouse_press(event) and button == 1:\n            if w.selectable():\n                self.change_focus((maxcol, maxrow), w_pos, wrow)\n\n        if not hasattr(w, 'mouse_event'):\n            return False\n\n        return w.mouse_event((maxcol,), event, button, col, row - wrow, focus)",
  "def ends_visible(self, size: tuple[int, int], focus: bool = False):\n        \"\"\"\n        Return a list that may contain ``'top'`` and/or ``'bottom'``.\n\n        i.e. this function will return one of: [], [``'top'``],\n        [``'bottom'``] or [``'top'``, ``'bottom'``].\n\n        convenience function for checking whether the top and bottom\n        of the list are visible\n        \"\"\"\n        (maxcol, maxrow) = size\n        l = []\n        middle, top, bottom = self.calculate_visible((maxcol, maxrow), focus=focus)\n        if middle is None:  # empty listbox\n            return ['top', 'bottom']\n        trim_top, above = top\n        trim_bottom, below = bottom\n\n        if trim_bottom == 0:\n            row_offset, w, pos, rows, c = middle\n            row_offset += rows\n            for w, pos, rows in below:\n                row_offset += rows\n            if row_offset < maxrow:\n                l.append('bottom')\n            elif self._body.get_next(pos) == (None, None):\n                l.append('bottom')\n\n        if trim_top == 0:\n            row_offset, w, pos, rows, c = middle\n            for w, pos, rows in above:\n                row_offset -= rows\n            if self._body.get_prev(pos) == (None, None):\n                l.insert(0, 'top')\n\n        return l",
  "def __iter__(self):\n        \"\"\"\n        Return an iterator over the positions in this ListBox.\n\n        If self._body does not implement positions() then iterate\n        from the focus widget down to the bottom, then from above\n        the focus up to the top.  This is the best we can do with\n        a minimal list walker implementation.\n        \"\"\"\n        positions_fn = getattr(self._body, 'positions', None)\n        if positions_fn:\n            for pos in positions_fn():\n                yield pos\n            return\n\n        focus_widget, focus_pos = self._body.get_focus()\n        if focus_widget is None:\n            return\n        pos = focus_pos\n        while True:\n            yield pos\n            w, pos = self._body.get_next(pos)\n            if not w:\n                break\n        pos = focus_pos\n        while True:\n            w, pos = self._body.get_prev(pos)\n            if not w:\n                break\n            yield pos",
  "def __reversed__(self):\n        \"\"\"\n        Return a reversed iterator over the positions in this ListBox.\n\n        If :attr:`body` does not implement :meth:`positions` then iterate\n        from above the focus widget up to the top, then from the focus\n        widget down to the bottom.  Note that this is not actually the\n        reverse of what `__iter__()` produces, but this is the best we can\n        do with a minimal list walker implementation.\n        \"\"\"\n        positions_fn = getattr(self._body, 'positions', None)\n        if positions_fn:\n            for pos in positions_fn(reverse=True):\n                yield pos\n            return\n\n        focus_widget, focus_pos = self._body.get_focus()\n        if focus_widget is None:\n            return\n        pos = focus_pos\n        while True:\n            w, pos = self._body.get_prev(pos)\n            if not w:\n                break\n            yield pos\n        pos = focus_pos\n        while True:\n            yield pos\n            w, pos = self._body.get_next(pos)\n            if not w:\n                break",
  "class ListBoxContents:\n            __getitem__ = self._contents__getitem__",
  "def actual_key(unhandled):\n            if unhandled:\n                return key",
  "class Screen:\n    def __init__(self):\n        self.palette = {}\n        self.has_color = True\n        self._started = False\n\n    @property\n    def started(self):\n        return self._started\n\n    def register_palette( self, l ):\n        \"\"\"Register a list of palette entries.\n\n        l -- list of (name, foreground, background) or\n             (name, same_as_other_name) palette entries.\n\n        calls self.register_palette_entry for each item in l\n        \"\"\"\n\n        for item in l:\n            if len(item) in (3,4):\n                self.register_palette_entry( *item )\n                continue\n            assert len(item) == 2, \"Invalid register_palette usage\"\n            name, like_name = item\n            if like_name not in self.palette:\n                raise Exception(f\"palette entry '{like_name}' doesn't exist\")\n            self.palette[name] = self.palette[like_name]\n\n    def register_palette_entry( self, name, foreground, background,\n        mono=None):\n        \"\"\"Register a single palette entry.\n\n        name -- new entry/attribute name\n        foreground -- foreground colour\n        background -- background colour\n        mono -- monochrome terminal attribute\n\n        See curses_display.register_palette_entry for more info.\n        \"\"\"\n        if foreground == \"default\":\n            foreground = \"black\"\n        if background == \"default\":\n            background = \"light gray\"\n        self.palette[name] = (foreground, background, mono)\n\n    def set_mouse_tracking(self, enable=True):\n        \"\"\"Not yet implemented\"\"\"\n        pass\n\n    def tty_signal_keys(self, *args, **vargs):\n        \"\"\"Do nothing.\"\"\"\n        pass\n\n    def start(self):\n        \"\"\"\n        This function reads the initial screen size, generates a\n        unique id and handles cleanup when fn exits.\n\n        web_display.set_preferences(..) must be called before calling\n        this function for the preferences to take effect\n        \"\"\"\n        global _prefs\n\n        if self._started:\n            return util.StoppingContext(self)\n\n        client_init = sys.stdin.read(50)\n        assert client_init.startswith(\"window resize \"),client_init\n        ignore1,ignore2,x,y = client_init.split(\" \",3)\n        x = int(x)\n        y = int(y)\n        self._set_screen_size( x, y )\n        self.last_screen = {}\n        self.last_screen_width = 0\n\n        self.update_method = os.environ[\"HTTP_X_URWID_METHOD\"]\n        assert self.update_method in (\"multipart\",\"polling\")\n\n        if self.update_method == \"polling\" and not _prefs.allow_polling:\n            sys.stdout.write(\"Status: 403 Forbidden\\r\\n\\r\\n\")\n            sys.exit(0)\n\n        clients = glob.glob(os.path.join(_prefs.pipe_dir,\"urwid*.in\"))\n        if len(clients) >= _prefs.max_clients:\n            sys.stdout.write(\"Status: 503 Sever Busy\\r\\n\\r\\n\")\n            sys.exit(0)\n\n        urwid_id = \"%09d%09d\"%(random.randrange(10**9),\n            random.randrange(10**9))\n        self.pipe_name = os.path.join(_prefs.pipe_dir,f\"urwid{urwid_id}\")\n        os.mkfifo(f\"{self.pipe_name}.in\",0o600)\n        signal.signal(signal.SIGTERM,self._cleanup_pipe)\n\n        self.input_fd = os.open(f\"{self.pipe_name}.in\",\n            os.O_NONBLOCK | os.O_RDONLY)\n        self.input_tail = \"\"\n        self.content_head = (\"Content-type: \"\n            \"multipart/x-mixed-replace;boundary=ZZ\\r\\n\"\n            \"X-Urwid-ID: \"+urwid_id+\"\\r\\n\"\n            \"\\r\\n\\r\\n\"\n            \"--ZZ\\r\\n\")\n        if self.update_method==\"polling\":\n            self.content_head = (\n                f'Content-type: text/plain\\r\\nX-Urwid-ID: {urwid_id}\\r\\n\\r\\n\\r\\n')\n\n        signal.signal(signal.SIGALRM,self._handle_alarm)\n        signal.alarm( ALARM_DELAY )\n        self._started = True\n\n        return util.StoppingContext(self)\n\n    def stop(self):\n        \"\"\"\n        Restore settings and clean up.\n        \"\"\"\n        if not self._started:\n            return\n\n        # XXX which exceptions does this actually raise? EnvironmentError?\n        try:\n            self._close_connection()\n        except Exception:\n            pass\n        signal.signal(signal.SIGTERM,signal.SIG_DFL)\n        self._cleanup_pipe()\n        self._started = False\n\n    def set_input_timeouts(self, *args):\n        pass\n\n    def run_wrapper(self,fn):\n        \"\"\"\n        Run the application main loop, calling start() first\n        and stop() on exit.\n        \"\"\"\n        try:\n            self.start()\n            return fn()\n        finally:\n            self.stop()\n\n\n    def _close_connection(self):\n        if self.update_method == \"polling child\":\n            self.server_socket.settimeout(0)\n            sock, addr = self.server_socket.accept()\n            sock.sendall(\"Z\")\n            sock.close()\n\n        if self.update_method == \"multipart\":\n            sys.stdout.write(\"\\r\\nZ\"\n                \"\\r\\n--ZZ--\\r\\n\")\n            sys.stdout.flush()\n\n    def _cleanup_pipe(self, *args):\n        if not self.pipe_name: return\n        # XXX which exceptions does this actually raise? EnvironmentError?\n        try:\n            os.remove(f\"{self.pipe_name}.in\")\n            os.remove(f\"{self.pipe_name}.update\")\n        except Exception:\n            pass\n\n    def _set_screen_size(self, cols, rows ):\n        \"\"\"Set the screen size (within max size).\"\"\"\n\n        if cols > MAX_COLS:\n            cols = MAX_COLS\n        if rows > MAX_ROWS:\n            rows = MAX_ROWS\n        self.screen_size = cols, rows\n\n    def draw_screen(self, size, r ):\n        \"\"\"Send a screen update to the client.\"\"\"\n\n        (cols, rows) = size\n\n        if cols != self.last_screen_width:\n            self.last_screen = {}\n\n        sendq = [self.content_head]\n\n        if self.update_method == \"polling\":\n            send = sendq.append\n        elif self.update_method == \"polling child\":\n            signal.alarm( 0 )\n            try:\n                s, addr = self.server_socket.accept()\n            except socket.timeout:\n                sys.exit(0)\n            send = s.sendall\n        else:\n            signal.alarm( 0 )\n            send = sendq.append\n            send(\"\\r\\n\")\n            self.content_head = \"\"\n\n        assert r.rows() == rows\n\n        if r.cursor is not None:\n            cx, cy = r.cursor\n        else:\n            cx = cy = None\n\n        new_screen = {}\n\n        y = -1\n        for row in r.content():\n            y += 1\n            row = list(row)\n\n            l = []\n\n            sig = tuple(row)\n            if y == cy: sig = sig + (cx,)\n            new_screen[sig] = new_screen.get(sig,[]) + [y]\n            old_line_numbers = self.last_screen.get(sig, None)\n            if old_line_numbers is not None:\n                if y in old_line_numbers:\n                    old_line = y\n                else:\n                    old_line = old_line_numbers[0]\n                send( \"<%d\\n\"%old_line )\n                continue\n\n            col = 0\n            for (a, cs, run) in row:\n                run = run.translate(_trans_table)\n                if a is None:\n                    fg,bg,mono = \"black\", \"light gray\", None\n                else:\n                    fg,bg,mono = self.palette[a]\n                if y == cy and col <= cx:\n                    run_width = util.calc_width(run, 0,\n                        len(run))\n                    if col+run_width > cx:\n                        l.append(code_span(run, fg, bg,\n                            cx-col))\n                    else:\n                        l.append(code_span(run, fg, bg))\n                    col += run_width\n                else:\n                    l.append(code_span(run, fg, bg))\n\n            send(f\"{''.join(l)}\\n\")\n        self.last_screen = new_screen\n        self.last_screen_width = cols\n\n        if self.update_method == \"polling\":\n            sys.stdout.write(\"\".join(sendq))\n            sys.stdout.flush()\n            sys.stdout.close()\n            self._fork_child()\n        elif self.update_method == \"polling child\":\n            s.close()\n        else: # update_method == \"multipart\"\n            send(\"\\r\\n--ZZ\\r\\n\")\n            sys.stdout.write(\"\".join(sendq))\n            sys.stdout.flush()\n\n        signal.alarm( ALARM_DELAY )\n\n\n    def clear(self):\n        \"\"\"\n        Force the screen to be completely repainted on the next\n        call to draw_screen().\n\n        (does nothing for web_display)\n        \"\"\"\n        pass\n\n\n    def _fork_child(self):\n        \"\"\"\n        Fork a child to run CGI disconnected for polling update method.\n        Force parent process to exit.\n        \"\"\"\n        daemonize( f\"{self.pipe_name}.err\" )\n        self.input_fd = os.open(f\"{self.pipe_name}.in\",\n            os.O_NONBLOCK | os.O_RDONLY)\n        self.update_method = \"polling child\"\n        s = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)\n        s.bind( f\"{self.pipe_name}.update\" )\n        s.listen(1)\n        s.settimeout(POLL_CONNECT)\n        self.server_socket = s\n\n    def _handle_alarm(self, sig, frame):\n        assert self.update_method in (\"multipart\",\"polling child\")\n        if self.update_method == \"polling child\":\n            # send empty update\n            try:\n                s, addr = self.server_socket.accept()\n                s.close()\n            except socket.timeout:\n                sys.exit(0)\n        else:\n            # send empty update\n            sys.stdout.write(\"\\r\\n\\r\\n--ZZ\\r\\n\")\n            sys.stdout.flush()\n        signal.alarm( ALARM_DELAY )\n\n\n    def get_cols_rows(self):\n        \"\"\"Return the screen size.\"\"\"\n        return self.screen_size\n\n    @typing.overload\n    def get_input(self, raw_keys: Literal[False]) -> list[str]:\n        ...\n\n    @typing.overload\n    def get_input(self, raw_keys: Literal[True]) -> tuple[list[str], list[int]]:\n        ...\n\n    def get_input(self, raw_keys: bool = False) -> list[str] | tuple[list[str], list[int]]:\n        \"\"\"Return pending input as a list.\"\"\"\n        l = []\n        resized = False\n\n        try:\n            iready, oready, eready = select.select([self.input_fd],[],[],0.5)\n        except OSError as e:\n            # return on interruptions\n            if e.args[0] == 4:\n                if raw_keys:\n                    return [], []\n                return []\n            raise\n\n        if not iready:\n            if raw_keys:\n                return [], []\n            return []\n\n        keydata = os.read(self.input_fd, MAX_READ)\n        os.close(self.input_fd)\n        self.input_fd = os.open(f\"{self.pipe_name}.in\", os.O_NONBLOCK | os.O_RDONLY)\n        #sys.stderr.write( repr((keydata,self.input_tail))+\"\\n\" )\n        keys = keydata.split(\"\\n\")\n        keys[0] = self.input_tail + keys[0]\n        self.input_tail = keys[-1]\n\n        for k in keys[:-1]:\n            if k.startswith(\"window resize \"):\n                ign1, ign2, x, y = k.split(\" \", 3)\n                x = int(x)\n                y = int(y)\n                self._set_screen_size(x, y)\n                resized = True\n            else:\n                l.append(k)\n        if resized:\n            l.append(\"window resize\")\n\n        if raw_keys:\n            return l, []\n        return l",
  "def code_span( s, fg, bg, cursor = -1):\n    code_fg = _code_colours[ fg ]\n    code_bg = _code_colours[ bg ]\n\n    if cursor >= 0:\n        c_off, _ign = util.calc_text_pos(s, 0, len(s), cursor)\n        c2_off = util.move_next_char(s, c_off, len(s))\n\n        return ( code_fg + code_bg + s[:c_off] + \"\\n\" +\n             code_bg + code_fg + s[c_off:c2_off] + \"\\n\" +\n             code_fg + code_bg + s[c2_off:] + \"\\n\")\n    else:\n        return f\"{code_fg + code_bg + s}\\n\"",
  "def html_escape(text):\n    \"\"\"Escape text so that it will be displayed safely within HTML\"\"\"\n    text = text.replace('&','&amp;')\n    text = text.replace('<','&lt;')\n    text = text.replace('>','&gt;')\n    return text",
  "def is_web_request():\n    \"\"\"\n    Return True if this is a CGI web request.\n    \"\"\"\n    return 'REQUEST_METHOD' in os.environ",
  "def handle_short_request():\n    \"\"\"\n    Handle short requests such as passing keystrokes to the application\n    or sending the initial html page.  If returns True, then this\n    function recognised and handled a short request, and the calling\n    script should immediately exit.\n\n    web_display.set_preferences(..) should be called before calling this\n    function for the preferences to take effect\n    \"\"\"\n    global _prefs\n\n    if not is_web_request():\n        return False\n\n    if os.environ['REQUEST_METHOD'] == \"GET\":\n        # Initial request, send the HTML and javascript.\n        sys.stdout.write(\"Content-type: text/html\\r\\n\\r\\n\" +\n            html_escape(_prefs.app_name).join(_html_page))\n        return True\n\n    if os.environ['REQUEST_METHOD'] != \"POST\":\n        # Don't know what to do with head requests etc.\n        return False\n\n    if 'HTTP_X_URWID_ID' not in os.environ:\n        # If no urwid id, then the application should be started.\n        return False\n\n    urwid_id = os.environ['HTTP_X_URWID_ID']\n    if len(urwid_id)>20:\n        #invalid. handle by ignoring\n        #assert 0, \"urwid id too long!\"\n        sys.stdout.write(\"Status: 414 URI Too Long\\r\\n\\r\\n\")\n        return True\n    for c in urwid_id:\n        if c not in \"0123456789\":\n            # invald. handle by ignoring\n            #assert 0, \"invalid chars in id!\"\n            sys.stdout.write(\"Status: 403 Forbidden\\r\\n\\r\\n\")\n            return True\n\n    if os.environ.get('HTTP_X_URWID_METHOD',None) == \"polling\":\n        # this is a screen update request\n        s = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)\n        try:\n            s.connect( os.path.join(_prefs.pipe_dir,\n                f\"urwid{urwid_id}.update\") )\n            data = f'Content-type: text/plain\\r\\n\\r\\n{s.recv(BUF_SZ)}'\n            while data:\n                sys.stdout.write(data)\n                data = s.recv(BUF_SZ)\n            return True\n        except OSError:\n            sys.stdout.write(\"Status: 404 Not Found\\r\\n\\r\\n\")\n            return True\n\n    # this is a keyboard input request\n    try:\n        fd = os.open((os.path.join(_prefs.pipe_dir,\n            f\"urwid{urwid_id}.in\")), os.O_WRONLY)\n    except OSError:\n        sys.stdout.write(\"Status: 404 Not Found\\r\\n\\r\\n\")\n        return True\n\n    # FIXME: use the correct encoding based on the request\n    keydata = sys.stdin.read(MAX_READ)\n    os.write(fd,keydata.encode('ascii'))\n    os.close(fd)\n    sys.stdout.write(\"Content-type: text/plain\\r\\n\\r\\n\")\n\n    return True",
  "class _Preferences:\n    app_name = \"Unnamed Application\"\n    pipe_dir = \"/tmp\"\n    allow_polling = True\n    max_clients = 20",
  "def set_preferences( app_name, pipe_dir=\"/tmp\", allow_polling=True,\n    max_clients=20 ):\n    \"\"\"\n    Set web_display preferences.\n\n    app_name -- application name to appear in html interface\n    pipe_dir -- directory for input pipes, daemon update sockets\n                and daemon error logs\n    allow_polling -- allow creation of daemon processes for\n                     browsers without multipart support\n    max_clients -- maximum concurrent client connections. This\n               pool is shared by all urwid applications\n               using the same pipe_dir\n    \"\"\"\n    global _prefs\n    _prefs.app_name = app_name\n    _prefs.pipe_dir = pipe_dir\n    _prefs.allow_polling = allow_polling\n    _prefs.max_clients = max_clients",
  "class ErrorLog:\n    def __init__(self, errfile ):\n        self.errfile = errfile\n    def write(self, err):\n        open(self.errfile,\"a\").write(err)",
  "def daemonize( errfile ):\n    \"\"\"\n    Detach process and become a daemon.\n    \"\"\"\n    pid = os.fork()\n    if pid:\n        os._exit(0)\n\n    os.setsid()\n    signal.signal(signal.SIGHUP, signal.SIG_IGN)\n    os.umask(0)\n\n    pid = os.fork()\n    if pid:\n        os._exit(0)\n\n    os.chdir(\"/\")\n    for fd in range(0,20):\n        try:\n            os.close(fd)\n        except OSError:\n            pass\n\n    sys.stdin = open(\"/dev/null\")\n    sys.stdout = open(\"/dev/null\",\"w\")\n    sys.stderr = ErrorLog( errfile )",
  "def __init__(self):\n        self.palette = {}\n        self.has_color = True\n        self._started = False",
  "def started(self):\n        return self._started",
  "def register_palette( self, l ):\n        \"\"\"Register a list of palette entries.\n\n        l -- list of (name, foreground, background) or\n             (name, same_as_other_name) palette entries.\n\n        calls self.register_palette_entry for each item in l\n        \"\"\"\n\n        for item in l:\n            if len(item) in (3,4):\n                self.register_palette_entry( *item )\n                continue\n            assert len(item) == 2, \"Invalid register_palette usage\"\n            name, like_name = item\n            if like_name not in self.palette:\n                raise Exception(f\"palette entry '{like_name}' doesn't exist\")\n            self.palette[name] = self.palette[like_name]",
  "def register_palette_entry( self, name, foreground, background,\n        mono=None):\n        \"\"\"Register a single palette entry.\n\n        name -- new entry/attribute name\n        foreground -- foreground colour\n        background -- background colour\n        mono -- monochrome terminal attribute\n\n        See curses_display.register_palette_entry for more info.\n        \"\"\"\n        if foreground == \"default\":\n            foreground = \"black\"\n        if background == \"default\":\n            background = \"light gray\"\n        self.palette[name] = (foreground, background, mono)",
  "def set_mouse_tracking(self, enable=True):\n        \"\"\"Not yet implemented\"\"\"\n        pass",
  "def tty_signal_keys(self, *args, **vargs):\n        \"\"\"Do nothing.\"\"\"\n        pass",
  "def start(self):\n        \"\"\"\n        This function reads the initial screen size, generates a\n        unique id and handles cleanup when fn exits.\n\n        web_display.set_preferences(..) must be called before calling\n        this function for the preferences to take effect\n        \"\"\"\n        global _prefs\n\n        if self._started:\n            return util.StoppingContext(self)\n\n        client_init = sys.stdin.read(50)\n        assert client_init.startswith(\"window resize \"),client_init\n        ignore1,ignore2,x,y = client_init.split(\" \",3)\n        x = int(x)\n        y = int(y)\n        self._set_screen_size( x, y )\n        self.last_screen = {}\n        self.last_screen_width = 0\n\n        self.update_method = os.environ[\"HTTP_X_URWID_METHOD\"]\n        assert self.update_method in (\"multipart\",\"polling\")\n\n        if self.update_method == \"polling\" and not _prefs.allow_polling:\n            sys.stdout.write(\"Status: 403 Forbidden\\r\\n\\r\\n\")\n            sys.exit(0)\n\n        clients = glob.glob(os.path.join(_prefs.pipe_dir,\"urwid*.in\"))\n        if len(clients) >= _prefs.max_clients:\n            sys.stdout.write(\"Status: 503 Sever Busy\\r\\n\\r\\n\")\n            sys.exit(0)\n\n        urwid_id = \"%09d%09d\"%(random.randrange(10**9),\n            random.randrange(10**9))\n        self.pipe_name = os.path.join(_prefs.pipe_dir,f\"urwid{urwid_id}\")\n        os.mkfifo(f\"{self.pipe_name}.in\",0o600)\n        signal.signal(signal.SIGTERM,self._cleanup_pipe)\n\n        self.input_fd = os.open(f\"{self.pipe_name}.in\",\n            os.O_NONBLOCK | os.O_RDONLY)\n        self.input_tail = \"\"\n        self.content_head = (\"Content-type: \"\n            \"multipart/x-mixed-replace;boundary=ZZ\\r\\n\"\n            \"X-Urwid-ID: \"+urwid_id+\"\\r\\n\"\n            \"\\r\\n\\r\\n\"\n            \"--ZZ\\r\\n\")\n        if self.update_method==\"polling\":\n            self.content_head = (\n                f'Content-type: text/plain\\r\\nX-Urwid-ID: {urwid_id}\\r\\n\\r\\n\\r\\n')\n\n        signal.signal(signal.SIGALRM,self._handle_alarm)\n        signal.alarm( ALARM_DELAY )\n        self._started = True\n\n        return util.StoppingContext(self)",
  "def stop(self):\n        \"\"\"\n        Restore settings and clean up.\n        \"\"\"\n        if not self._started:\n            return\n\n        # XXX which exceptions does this actually raise? EnvironmentError?\n        try:\n            self._close_connection()\n        except Exception:\n            pass\n        signal.signal(signal.SIGTERM,signal.SIG_DFL)\n        self._cleanup_pipe()\n        self._started = False",
  "def set_input_timeouts(self, *args):\n        pass",
  "def run_wrapper(self,fn):\n        \"\"\"\n        Run the application main loop, calling start() first\n        and stop() on exit.\n        \"\"\"\n        try:\n            self.start()\n            return fn()\n        finally:\n            self.stop()",
  "def _close_connection(self):\n        if self.update_method == \"polling child\":\n            self.server_socket.settimeout(0)\n            sock, addr = self.server_socket.accept()\n            sock.sendall(\"Z\")\n            sock.close()\n\n        if self.update_method == \"multipart\":\n            sys.stdout.write(\"\\r\\nZ\"\n                \"\\r\\n--ZZ--\\r\\n\")\n            sys.stdout.flush()",
  "def _cleanup_pipe(self, *args):\n        if not self.pipe_name: return\n        # XXX which exceptions does this actually raise? EnvironmentError?\n        try:\n            os.remove(f\"{self.pipe_name}.in\")\n            os.remove(f\"{self.pipe_name}.update\")\n        except Exception:\n            pass",
  "def _set_screen_size(self, cols, rows ):\n        \"\"\"Set the screen size (within max size).\"\"\"\n\n        if cols > MAX_COLS:\n            cols = MAX_COLS\n        if rows > MAX_ROWS:\n            rows = MAX_ROWS\n        self.screen_size = cols, rows",
  "def draw_screen(self, size, r ):\n        \"\"\"Send a screen update to the client.\"\"\"\n\n        (cols, rows) = size\n\n        if cols != self.last_screen_width:\n            self.last_screen = {}\n\n        sendq = [self.content_head]\n\n        if self.update_method == \"polling\":\n            send = sendq.append\n        elif self.update_method == \"polling child\":\n            signal.alarm( 0 )\n            try:\n                s, addr = self.server_socket.accept()\n            except socket.timeout:\n                sys.exit(0)\n            send = s.sendall\n        else:\n            signal.alarm( 0 )\n            send = sendq.append\n            send(\"\\r\\n\")\n            self.content_head = \"\"\n\n        assert r.rows() == rows\n\n        if r.cursor is not None:\n            cx, cy = r.cursor\n        else:\n            cx = cy = None\n\n        new_screen = {}\n\n        y = -1\n        for row in r.content():\n            y += 1\n            row = list(row)\n\n            l = []\n\n            sig = tuple(row)\n            if y == cy: sig = sig + (cx,)\n            new_screen[sig] = new_screen.get(sig,[]) + [y]\n            old_line_numbers = self.last_screen.get(sig, None)\n            if old_line_numbers is not None:\n                if y in old_line_numbers:\n                    old_line = y\n                else:\n                    old_line = old_line_numbers[0]\n                send( \"<%d\\n\"%old_line )\n                continue\n\n            col = 0\n            for (a, cs, run) in row:\n                run = run.translate(_trans_table)\n                if a is None:\n                    fg,bg,mono = \"black\", \"light gray\", None\n                else:\n                    fg,bg,mono = self.palette[a]\n                if y == cy and col <= cx:\n                    run_width = util.calc_width(run, 0,\n                        len(run))\n                    if col+run_width > cx:\n                        l.append(code_span(run, fg, bg,\n                            cx-col))\n                    else:\n                        l.append(code_span(run, fg, bg))\n                    col += run_width\n                else:\n                    l.append(code_span(run, fg, bg))\n\n            send(f\"{''.join(l)}\\n\")\n        self.last_screen = new_screen\n        self.last_screen_width = cols\n\n        if self.update_method == \"polling\":\n            sys.stdout.write(\"\".join(sendq))\n            sys.stdout.flush()\n            sys.stdout.close()\n            self._fork_child()\n        elif self.update_method == \"polling child\":\n            s.close()\n        else: # update_method == \"multipart\"\n            send(\"\\r\\n--ZZ\\r\\n\")\n            sys.stdout.write(\"\".join(sendq))\n            sys.stdout.flush()\n\n        signal.alarm( ALARM_DELAY )",
  "def clear(self):\n        \"\"\"\n        Force the screen to be completely repainted on the next\n        call to draw_screen().\n\n        (does nothing for web_display)\n        \"\"\"\n        pass",
  "def _fork_child(self):\n        \"\"\"\n        Fork a child to run CGI disconnected for polling update method.\n        Force parent process to exit.\n        \"\"\"\n        daemonize( f\"{self.pipe_name}.err\" )\n        self.input_fd = os.open(f\"{self.pipe_name}.in\",\n            os.O_NONBLOCK | os.O_RDONLY)\n        self.update_method = \"polling child\"\n        s = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)\n        s.bind( f\"{self.pipe_name}.update\" )\n        s.listen(1)\n        s.settimeout(POLL_CONNECT)\n        self.server_socket = s",
  "def _handle_alarm(self, sig, frame):\n        assert self.update_method in (\"multipart\",\"polling child\")\n        if self.update_method == \"polling child\":\n            # send empty update\n            try:\n                s, addr = self.server_socket.accept()\n                s.close()\n            except socket.timeout:\n                sys.exit(0)\n        else:\n            # send empty update\n            sys.stdout.write(\"\\r\\n\\r\\n--ZZ\\r\\n\")\n            sys.stdout.flush()\n        signal.alarm( ALARM_DELAY )",
  "def get_cols_rows(self):\n        \"\"\"Return the screen size.\"\"\"\n        return self.screen_size",
  "def get_input(self, raw_keys: Literal[False]) -> list[str]:\n        ...",
  "def get_input(self, raw_keys: Literal[True]) -> tuple[list[str], list[int]]:\n        ...",
  "def get_input(self, raw_keys: bool = False) -> list[str] | tuple[list[str], list[int]]:\n        \"\"\"Return pending input as a list.\"\"\"\n        l = []\n        resized = False\n\n        try:\n            iready, oready, eready = select.select([self.input_fd],[],[],0.5)\n        except OSError as e:\n            # return on interruptions\n            if e.args[0] == 4:\n                if raw_keys:\n                    return [], []\n                return []\n            raise\n\n        if not iready:\n            if raw_keys:\n                return [], []\n            return []\n\n        keydata = os.read(self.input_fd, MAX_READ)\n        os.close(self.input_fd)\n        self.input_fd = os.open(f\"{self.pipe_name}.in\", os.O_NONBLOCK | os.O_RDONLY)\n        #sys.stderr.write( repr((keydata,self.input_tail))+\"\\n\" )\n        keys = keydata.split(\"\\n\")\n        keys[0] = self.input_tail + keys[0]\n        self.input_tail = keys[-1]\n\n        for k in keys[:-1]:\n            if k.startswith(\"window resize \"):\n                ign1, ign2, x, y = k.split(\" \", 3)\n                x = int(x)\n                y = int(y)\n                self._set_screen_size(x, y)\n                resized = True\n            else:\n                l.append(k)\n        if resized:\n            l.append(\"window resize\")\n\n        if raw_keys:\n            return l, []\n        return l",
  "def __init__(self, errfile ):\n        self.errfile = errfile",
  "def write(self, err):\n        open(self.errfile,\"a\").write(err)",
  "class CSIAlias(typing.NamedTuple):\n    alias_mark: str  # can not have constructor with default first and non-default second arg\n    alias: bytes",
  "class CSICommand(typing.NamedTuple):\n    num_args: int\n    default: int\n    callback: Callable[[TermCanvas, list[int], bool], typing.Any]",
  "class TermModes:\n    # ECMA-48\n    display_ctrl: bool = False\n    insert: bool = False\n    lfnl: bool = False\n\n    # DEC private modes\n    keys_decckm: bool = False\n    reverse_video: bool = False\n    constrain_scrolling: bool = False\n    autowrap: bool = True\n    visible_cursor: bool = True\n    bracketed_paste: bool = False\n\n    # charset stuff\n    main_charset: Literal[1, 2] = CHARSET_DEFAULT\n\n    def reset(self) -> None:\n        # ECMA-48\n        self.display_ctrl = False\n        self.insert = False\n        self.lfnl = False\n\n        # DEC private modes\n        self.keys_decckm = False\n        self.reverse_video = False\n        self.constrain_scrolling = False\n        self.autowrap = True\n        self.visible_cursor = True\n\n        # charset stuff\n        self.main_charset = CHARSET_DEFAULT",
  "class TermCharset:\n    __slots__ = (\"_g\", \"_sgr_mapping\", \"active\", \"current\")\n\n    MAPPING = {\n        'default': None,\n        'vt100':   '0',\n        'ibmpc':   'U',\n        'user':    None,\n    }\n\n    def __init__(self) -> None:\n        self._g = [\n            'default',\n            'vt100',\n        ]\n\n        self._sgr_mapping = False\n\n        # prepare defaults\n        self.active = 0\n        self.current: str | None = None\n\n        self.activate(0)\n\n    def define(self, g: int, charset: str) -> None:\n        \"\"\"\n        Redefine G'g' with new mapping.\n        \"\"\"\n        self._g[g] = charset\n        self.activate(g=self.active)\n\n    def activate(self, g: int) -> None:\n        \"\"\"\n        Activate the given charset slot.\n        \"\"\"\n        self.active = g\n        self.current = self.MAPPING.get(self._g[g], None)\n\n    def set_sgr_ibmpc(self) -> None:\n        \"\"\"\n        Set graphics rendition mapping to IBM PC CP437.\n        \"\"\"\n        self._sgr_mapping = True\n\n    def reset_sgr_ibmpc(self) -> None:\n        \"\"\"\n        Reset graphics rendition mapping to IBM PC CP437.\n        \"\"\"\n        self._sgr_mapping = False\n        self.activate(g=self.active)\n\n    def apply_mapping(self, char: bytes) -> bytes:\n        if self._sgr_mapping or self._g[self.active] == 'ibmpc':\n            dec_pos = DEC_SPECIAL_CHARS.find(char.decode('cp437'))\n            if dec_pos >= 0:\n                self.current = '0'\n                return ALT_DEC_SPECIAL_CHARS[dec_pos].encode(\"cp437\")\n            else:\n                self.current = 'U'\n                return char\n        else:\n            return char",
  "class TermScroller(list):\n    \"\"\"\n    List subclass that handles the terminal scrollback buffer,\n    truncating it as necessary.\n    \"\"\"\n    SCROLLBACK_LINES = 10000\n\n    def __init__(self, iterable: Iterable[typing.Any]) -> None:\n        warnings.warn(\n            \"`TermScroller` is deprecated. Please use `collections.deque` with non-zero `maxlen` instead.\",\n            DeprecationWarning,\n            stacklevel=3,\n        )\n        super().__init__(iterable)\n\n    def trunc(self) -> None:\n        if len(self) >= self.SCROLLBACK_LINES:\n            self.pop(0)\n\n    def append(self, obj) -> None:\n        self.trunc()\n        super().append(obj)\n\n    def insert(self, idx: typing.SupportsIndex, obj) -> None:\n        self.trunc()\n        super().insert(idx, obj)\n\n    def extend(self, seq) -> None:\n        self.trunc()\n        super().extend(seq)",
  "class TermCanvas(Canvas):\n    cacheable = False\n\n    def __init__(self, width: int, height: int, widget: Terminal) -> None:\n        super().__init__()\n\n        self.width, self.height = width, height\n        self.widget = widget\n        self.modes: TermModes = widget.term_modes\n        self.has_focus = False\n\n        self.scrollback_buffer: deque[list[tuple[AttrSpec | None, str | None, bytes]]] = deque(maxlen=10000)\n        self.scrolling_up = 0\n\n        self.utf8_eat_bytes: int | None = None\n        self.utf8_buffer = bytearray()\n        self.escbuf = b''\n\n        self.coords[\"cursor\"] = (0, 0, None)\n\n        self.term_cursor: tuple[int, int] = (0, 0)  # do not allow to shoot in the leg at `set_term_cursor`\n\n        self.within_escape = False\n        self.parsestate = 0\n\n        self.attrspec: AttrSpec | None = None\n\n        self.charset = TermCharset()\n\n        self.saved_cursor: tuple[int, int] | None = None\n        self.saved_attrs: tuple[AttrSpec | None, TermCharset] | None = None\n\n        self.is_rotten_cursor = False\n\n        self.scrollregion_start = 0\n        self.scrollregion_end = self.height - 1\n\n        self.tabstops: list[int] = []\n        self.term: list[list[tuple[AttrSpec | None, str | None, bytes]]] = []\n\n        self.reset()\n\n    def set_term_cursor(self, x: int | None = None, y: int | None = None) -> None:\n        \"\"\"\n        Set terminal cursor to x/y and update canvas cursor. If one or both axes\n        are omitted, use the values of the current position.\n        \"\"\"\n        if x is None:\n            x = self.term_cursor[0]\n        if y is None:\n            y = self.term_cursor[1]\n\n        self.term_cursor = self.constrain_coords(x, y)\n\n        if self.has_focus and self.modes.visible_cursor and self.scrolling_up < self.height - y:\n            self.cursor = (x, y + self.scrolling_up)\n        else:\n            self.cursor = None\n\n    def reset_scroll(self) -> None:\n        \"\"\"\n        Reset scrolling region to full terminal size.\n        \"\"\"\n        self.scrollregion_start = 0\n        self.scrollregion_end = self.height - 1\n\n    def scroll_buffer(self, up: bool = True, reset: bool = False, lines: int | None = None) -> None:\n        \"\"\"\n        Scroll the scrolling buffer up (up=True) or down (up=False) the given\n        amount of lines or half the screen height.\n\n        If just 'reset' is True, set the scrollbuffer view to the current\n        terminal content.\n        \"\"\"\n        if reset:\n            self.scrolling_up = 0\n            self.set_term_cursor()\n            return\n\n        if lines is None:\n            lines = self.height // 2\n\n        if not up:\n            lines = -lines\n\n        maxscroll = len(self.scrollback_buffer)\n        self.scrolling_up += lines\n\n        if self.scrolling_up > maxscroll:\n            self.scrolling_up = maxscroll\n        elif self.scrolling_up < 0:\n            self.scrolling_up = 0\n\n        self.set_term_cursor()\n\n    def reset(self) -> None:\n        \"\"\"\n        Reset the terminal.\n        \"\"\"\n        self.escbuf = b''\n        self.within_escape = False\n        self.parsestate = 0\n\n        self.attrspec = None\n        self.charset = TermCharset()\n\n        self.saved_cursor = None\n        self.saved_attrs = None\n\n        self.is_rotten_cursor = False\n\n        self.reset_scroll()\n\n        self.init_tabstops()\n\n        # terminal modes\n        self.modes.reset()\n\n        # initialize self.term\n        self.clear()\n\n    def init_tabstops(self, extend: bool = False) -> None:\n        tablen, mod = divmod(self.width, 8)\n        if mod > 0:\n            tablen += 1\n\n        if extend:\n            while len(self.tabstops) < tablen:\n                self.tabstops.append(1 << 0)\n        else:\n            self.tabstops = [1 << 0] * tablen\n\n    def set_tabstop(self, x: int | None = None, remove: bool = False, clear: bool = False) -> None:\n        if clear:\n            for tab in range(len(self.tabstops)):\n                self.tabstops[tab] = 0\n            return\n\n        if x is None:\n            x = self.term_cursor[0]\n\n        div, mod = divmod(x, 8)\n        if remove:\n            self.tabstops[div] &= ~(1 << mod)\n        else:\n            self.tabstops[div] |= (1 << mod)\n\n    def is_tabstop(self, x: int | None = None) -> bool:\n        if x is None:\n            x = self.term_cursor[0]\n\n        div, mod = divmod(x, 8)\n        return (self.tabstops[div] & (1 << mod)) > 0\n\n    def empty_line(self, char: bytes = b' ') -> list[tuple[AttrSpec | None, str | None, bytes]]:\n        return [self.empty_char(char)] * self.width\n\n    def empty_char(self, char: bytes = b' ') -> tuple[AttrSpec | None, str | None, bytes]:\n        return (self.attrspec, self.charset.current, char)\n\n    def addstr(self, data: Iterable[int]) -> None:\n        if self.width <= 0 or self.height <= 0:\n            # not displayable, do nothing!\n            return\n\n        for byte in data:\n            self.addbyte(byte)\n\n    def resize(self, width: int, height: int) -> None:\n        \"\"\"\n        Resize the terminal to the given width and height.\n        \"\"\"\n        x, y = self.term_cursor\n\n        if width > self.width:\n            # grow\n            for y in range(self.height):\n                self.term[y] += [self.empty_char()] * (width - self.width)\n        elif width < self.width:\n            # shrink\n            for y in range(self.height):\n                self.term[y] = self.term[y][:width]\n\n        self.width = width\n\n        if height > self.height:\n            # grow\n            for y in range(self.height, height):\n                try:\n                    last_line = self.scrollback_buffer.pop()\n                except IndexError:\n                    # nothing in scrollback buffer, append an empty line\n                    self.term.append(self.empty_line())\n                    self.scrollregion_end += 1\n                    continue\n\n                # adjust x axis of scrollback buffer to the current width\n                padding = self.width - len(last_line)\n                if padding > 0:\n                    last_line += [self.empty_char()] * padding\n                else:\n                    last_line = last_line[:self.width]\n\n                y += 1\n\n                self.term.insert(0, last_line)\n        elif height < self.height:\n            # shrink\n            for y in range(height, self.height):\n                self.scrollback_buffer.append(self.term.pop(0))\n\n        self.height = height\n\n        self.reset_scroll()\n\n        x, y = self.constrain_coords(x, y)\n        self.set_term_cursor(x, y)\n\n        # extend tabs\n        self.init_tabstops(extend=True)\n\n    def set_g01(self, char: bytes, mod: bytes) -> None:\n        \"\"\"\n        Set G0 or G1 according to 'char' and modifier 'mod'.\n        \"\"\"\n        if self.modes.main_charset != CHARSET_DEFAULT:\n            return\n\n        if mod == b'(':\n            g = 0\n        else:\n            g = 1\n\n        if char == b'0':\n            cset = 'vt100'\n        elif char == b'U':\n            cset = 'ibmpc'\n        elif char == b'K':\n            cset = 'user'\n        else:\n            cset = 'default'\n\n        self.charset.define(g, cset)\n\n    def parse_csi(self, char: bytes) -> None:\n        \"\"\"\n        Parse ECMA-48 CSI (Control Sequence Introducer) sequences.\n        \"\"\"\n        qmark = self.escbuf.startswith(b'?')\n\n        escbuf = []\n        for arg in self.escbuf[qmark and 1 or 0:].split(b';'):\n            try:\n                num = int(arg)\n            except ValueError:\n                num = None\n\n            escbuf.append(num)\n\n        cmd_ = CSI_COMMANDS[char]\n        if cmd_ is not None:\n            if isinstance(cmd_, CSIAlias):\n                csi_cmd: CSICommand = CSI_COMMANDS[cmd_.alias]  # type: ignore[assignment]\n            elif isinstance(cmd_, CSICommand):\n                csi_cmd = cmd_\n            elif cmd_[0] == 'alias':  # fallback, hard deprecated\n                csi_cmd = CSI_COMMANDS[CSIAlias(*cmd_).alias]\n            else:\n                csi_cmd = CSICommand(*cmd_)  # fallback, hard deprecated\n\n            number_of_args, default_value, cmd = csi_cmd\n            while len(escbuf) < number_of_args:\n                escbuf.append(default_value)\n            for i in range(len(escbuf)):\n                if escbuf[i] is None or escbuf[i] == 0:\n                    escbuf[i] = default_value\n\n            try:\n                cmd(self, escbuf, qmark)\n            except ValueError:\n                # ignore commands that don't match the\n                # unpacked tuples in CSI_COMMANDS.\n                pass\n\n    def parse_noncsi(self, char: bytes, mod: bytes = b'') -> None:\n        \"\"\"\n        Parse escape sequences which are not CSI.\n        \"\"\"\n        if mod == b'#' and char == b'8':\n            self.decaln()\n        elif mod == b'%':  # select main character set\n            if char == b'@':\n                self.modes.main_charset = CHARSET_DEFAULT\n            elif char in b'G8':\n                # 8 is obsolete and only for backwards compatibility\n                self.modes.main_charset = CHARSET_UTF8\n        elif mod in (b'(', b')'):  # define G0/G1\n            self.set_g01(char, mod)\n        elif char == b'M':  # reverse line feed\n            self.linefeed(reverse=True)\n        elif char == b'D':  # line feed\n            self.linefeed()\n        elif char == b'c':  # reset terminal\n            self.reset()\n        elif char == b'E':  # newline\n            self.newline()\n        elif char == b'H':  # set tabstop\n            self.set_tabstop()\n        elif char == b'Z':  # DECID\n            self.widget.respond(f\"{ESC}[?6c\")\n        elif char == b'7':  # save current state\n            self.save_cursor(with_attrs=True)\n        elif char == b'8':  # restore current state\n            self.restore_cursor(with_attrs=True)\n\n    def parse_osc(self, buf: bytes) -> None:\n        \"\"\"\n        Parse operating system command.\n        \"\"\"\n        if (buf.startswith(b';')\n                or buf.startswith(b'0;')\n                or buf.startswith(b'2;')):\n            # set window title\n            self.widget.set_title(buf.decode().partition(\";\")[2])\n\n    def parse_escape(self, char: bytes) -> None:\n        if self.parsestate == 1:\n            # within CSI\n            if char in CSI_COMMANDS:\n                self.parse_csi(char)\n                self.parsestate = 0\n            elif char in b'0123456789;' or (not self.escbuf and char == b'?'):\n                self.escbuf += char\n                return\n        elif self.parsestate == 0 and char == b']':\n            # start of OSC\n            self.escbuf = b''\n            self.parsestate = 2\n            return\n        elif self.parsestate == 2 and char == b\"\\a\":\n            # end of OSC\n            self.parse_osc(self.escbuf.lstrip(b'0'))\n        elif self.parsestate == 2 and self.escbuf[-1:] + char == f\"{ESC}\\\\\".encode('iso8859-1'):\n            # end of OSC\n            self.parse_osc(self.escbuf[:-1].lstrip(b'0'))\n        elif self.parsestate == 2 and self.escbuf.startswith(b'P') and len(self.escbuf) == 8:\n            # set palette (ESC]Pnrrggbb)\n            pass\n        elif self.parsestate == 2 and not self.escbuf and char == b'R':\n            # reset palette\n            pass\n        elif self.parsestate == 2:\n            self.escbuf += char\n            return\n        elif self.parsestate == 0 and char == b'[':\n            # start of CSI\n            self.escbuf = b''\n            self.parsestate = 1\n            return\n        elif self.parsestate == 0 and char in (b'%', b'#', b'(', b')'):\n            # non-CSI sequence\n            self.escbuf = char\n            self.parsestate = 3\n            return\n        elif self.parsestate == 3:\n            self.parse_noncsi(char, self.escbuf)\n        elif char in (b'c', b'D', b'E', b'H', b'M', b'Z', b'7', b'8', b'>', b'='):\n            self.parse_noncsi(char)\n\n        self.leave_escape()\n\n    def leave_escape(self) -> None:\n        self.within_escape = False\n        self.parsestate = 0\n        self.escbuf = b''\n\n    def get_utf8_len(self, bytenum: int) -> int:\n        \"\"\"\n        Process startbyte and return the number of bytes following it to get a\n        valid UTF-8 multibyte sequence.\n\n        bytenum -- an integer ordinal\n        \"\"\"\n        length = 0\n\n        while bytenum & 0x40:\n            bytenum <<= 1\n            length += 1\n\n        return length\n\n    def addbyte(self, byte: int) -> None:\n        \"\"\"\n        Parse main charset and add the processed byte(s) to the terminal state\n        machine.\n\n        byte -- an integer ordinal\n        \"\"\"\n        if self.modes.main_charset == CHARSET_UTF8 or util._target_encoding == 'utf8':\n            if byte >= 0xc0:\n                # start multibyte sequence\n                self.utf8_eat_bytes = self.get_utf8_len(byte)\n                self.utf8_buffer = bytearray([byte])\n                return\n            elif 0x80 <= byte < 0xc0 and self.utf8_eat_bytes is not None:\n                if self.utf8_eat_bytes > 1:\n                    # continue multibyte sequence\n                    self.utf8_eat_bytes -= 1\n                    self.utf8_buffer.append(byte)\n                    return\n                else:\n                    # end multibyte sequence\n                    self.utf8_eat_bytes = None\n                    sequence = (self.utf8_buffer + bytes([byte])).decode('utf-8', 'ignore')\n                    if len(sequence) == 0:\n                        # invalid multibyte sequence, stop processing\n                        return\n                    char = sequence.encode(util._target_encoding, 'replace')\n            else:\n                self.utf8_eat_bytes = None\n                char = bytes([byte])\n        else:\n            char = bytes([byte])\n\n        self.process_char(char)\n\n    def process_char(self, char: int | bytes) -> None:\n        \"\"\"\n        Process a single character (single- and multi-byte).\n\n        char -- a byte string\n        \"\"\"\n        x, y = self.term_cursor\n\n        if isinstance(char, int):\n            char = chr(char)\n\n        dc = self.modes.display_ctrl\n\n        if char == ESC_B and self.parsestate != 2:  # escape\n            self.within_escape = True\n        elif not dc and char == b'\\r':  # carriage return CR\n            self.carriage_return()\n        elif not dc and char == b\"\\x0f\":  # activate G0\n            self.charset.activate(0)\n        elif not dc and char == b\"\\x0e\":  # activate G1\n            self.charset.activate(1)\n        elif not dc and char in b\"\\n\\v\\f\":  # line feed LF/VT/FF\n            self.linefeed()\n            if self.modes.lfnl:\n                self.carriage_return()\n        elif not dc and char == b\"\\t\":  # char tab\n            self.tab()\n        elif not dc and char == b\"\\b\":  # backspace BS\n            if x > 0:\n                self.set_term_cursor(x - 1, y)\n        elif not dc and char == b\"\\a\" and self.parsestate != 2:  # BEL\n            # we need to check if we're in parsestate 2, as an OSC can be\n            # terminated by the BEL character!\n            self.widget.beep()\n        elif not dc and char in b\"\\x18\\x1a\":  # CAN/SUB\n            self.leave_escape()\n        elif not dc and char in b\"\\x00\\x7f\":  # NUL/DEL\n            pass  # this is ignored\n        elif self.within_escape:\n            self.parse_escape(char)\n        elif not dc and char == b\"\\x9b\":  # CSI (equivalent to \"ESC [\")\n            self.within_escape = True\n            self.escbuf = b''\n            self.parsestate = 1\n        else:\n            self.push_cursor(char)\n\n    def set_char(self, char: bytes, x: int | None = None, y: int | None = None) -> None:\n        \"\"\"\n        Set character of either the current cursor position\n        or a position given by 'x' and/or 'y' to 'char'.\n        \"\"\"\n        if x is None:\n            x = self.term_cursor[0]\n        if y is None:\n            y = self.term_cursor[1]\n\n        x, y = self.constrain_coords(x, y)\n        self.term[y][x] = (self.attrspec, self.charset.current, char)\n\n    def constrain_coords(self, x: int, y: int, ignore_scrolling: bool = False) -> tuple[int, int]:\n        \"\"\"\n        Checks if x/y are within the terminal and returns the corrected version.\n        If 'ignore_scrolling' is set, constrain within the full size of the\n        screen and not within scrolling region.\n        \"\"\"\n        if x >= self.width:\n            x = self.width - 1\n        elif x < 0:\n            x = 0\n\n        if self.modes.constrain_scrolling and not ignore_scrolling:\n            if y > self.scrollregion_end:\n                y = self.scrollregion_end\n            elif y < self.scrollregion_start:\n                y = self.scrollregion_start\n        else:\n            if y >= self.height:\n                y = self.height - 1\n            elif y < 0:\n                y = 0\n\n        return x, y\n\n    def linefeed(self, reverse: bool = False) -> None:\n        \"\"\"\n        Move the cursor down (or up if reverse is True) one line but don't reset\n        horizontal position.\n        \"\"\"\n        x, y = self.term_cursor\n\n        if reverse:\n            if y <= 0 < self.scrollregion_start:\n                pass\n            elif y == self.scrollregion_start:\n                self.scroll(reverse=True)\n            else:\n                y -= 1\n        else:\n            if y >= self.height - 1 > self.scrollregion_end:\n                pass\n            elif y == self.scrollregion_end:\n                self.scroll()\n            else:\n                y += 1\n\n        self.set_term_cursor(x, y)\n\n    def carriage_return(self) -> None:\n        self.set_term_cursor(0, self.term_cursor[1])\n\n    def newline(self) -> None:\n        \"\"\"\n        Do a carriage return followed by a line feed.\n        \"\"\"\n        self.carriage_return()\n        self.linefeed()\n\n    def move_cursor(\n        self,\n        x: int,\n        y: int,\n        relative_x: bool = False,\n        relative_y: bool = False,\n        relative: bool = False,\n    ) -> None:\n        \"\"\"\n        Move cursor to position x/y while constraining terminal sizes.\n        If 'relative' is True, x/y is relative to the current cursor\n        position. 'relative_x' and 'relative_y' is the same but just with\n        the corresponding axis.\n        \"\"\"\n        if relative:\n            relative_y = relative_x = True\n\n        if relative_x:\n            x += self.term_cursor[0]\n\n        if relative_y:\n            y += self.term_cursor[1]\n        elif self.modes.constrain_scrolling:\n            y += self.scrollregion_start\n\n        self.set_term_cursor(x, y)\n\n    def push_char(self, char: bytes | None, x: int, y: int) -> None:\n        \"\"\"\n        Push one character to current position and advance cursor to x/y.\n        \"\"\"\n        if char is not None:\n            char = self.charset.apply_mapping(char)\n            if self.modes.insert:\n                self.insert_chars(char=char)\n            else:\n                self.set_char(char)\n\n        self.set_term_cursor(x, y)\n\n    def push_cursor(self, char: bytes | None = None) -> None:\n        \"\"\"\n        Move cursor one character forward wrapping lines as needed.\n        If 'char' is given, put the character into the former position.\n        \"\"\"\n        x, y = self.term_cursor\n\n        if self.modes.autowrap:\n            if x + 1 >= self.width and not self.is_rotten_cursor:\n                # \"rotten cursor\" - this is when the cursor gets to the rightmost\n                # position of the screen, the cursor position remains the same but\n                # one last set_char() is allowed for that piece of sh^H^H\"border\".\n                self.is_rotten_cursor = True\n                self.push_char(char, x, y)\n            else:\n                x += 1\n\n                if x >= self.width and self.is_rotten_cursor:\n                    if y >= self.scrollregion_end:\n                        self.scroll()\n                    else:\n                        y += 1\n\n                    x = 1\n\n                    self.set_term_cursor(0, y)\n\n                self.push_char(char, x, y)\n\n                self.is_rotten_cursor = False\n        else:\n            if x + 1 < self.width:\n                x += 1\n\n            self.is_rotten_cursor = False\n            self.push_char(char, x, y)\n\n    def save_cursor(self, with_attrs: bool = False) -> None:\n        self.saved_cursor = tuple(self.term_cursor)\n        if with_attrs:\n            self.saved_attrs = (copy.copy(self.attrspec), copy.copy(self.charset))\n\n    def restore_cursor(self, with_attrs: bool = False) -> None:\n        if self.saved_cursor is None:\n            return\n\n        x, y = self.saved_cursor\n        self.set_term_cursor(x, y)\n\n        if with_attrs and self.saved_attrs is not None:\n            self.attrspec, self.charset = (copy.copy(self.saved_attrs[0]), copy.copy(self.saved_attrs[1]))\n\n    def tab(self, tabstop: int = 8) -> None:\n        \"\"\"\n        Moves cursor to the next 'tabstop' filling everything in between\n        with spaces.\n        \"\"\"\n        x, y = self.term_cursor\n\n        while x < self.width - 1:\n            self.set_char(b\" \")\n            x += 1\n\n            if self.is_tabstop(x):\n                break\n\n        self.is_rotten_cursor = False\n        self.set_term_cursor(x, y)\n\n    def scroll(self, reverse: bool = False) -> None:\n        \"\"\"\n        Append a new line at the bottom and put the topmost line into the\n        scrollback buffer.\n\n        If reverse is True, do exactly the opposite, but don't save into\n        scrollback buffer.\n        \"\"\"\n        if reverse:\n            self.term.pop(self.scrollregion_end)\n            self.term.insert(self.scrollregion_start, self.empty_line())\n        else:\n            killed = self.term.pop(self.scrollregion_start)\n            self.scrollback_buffer.append(killed)\n            self.term.insert(self.scrollregion_end, self.empty_line())\n\n    def decaln(self) -> None:\n        \"\"\"\n        DEC screen alignment test: Fill screen with E's.\n        \"\"\"\n        for row in range(self.height):\n            self.term[row] = self.empty_line(b'E')\n\n    def blank_line(self, row: int) -> None:\n        \"\"\"\n        Blank a single line at the specified row, without modifying other lines.\n        \"\"\"\n        self.term[row] = self.empty_line()\n\n    def insert_chars(\n        self,\n        position: tuple[int, int] | None = None,\n        chars: int = 1,\n        char: bytes | None = None,\n    ) -> None:\n        \"\"\"\n        Insert 'chars' number of either empty characters - or those specified by\n        'char' - before 'position' (or the current position if not specified)\n        pushing subsequent characters of the line to the right without wrapping.\n        \"\"\"\n        if position is None:\n            position = self.term_cursor\n\n        if chars == 0:\n            chars = 1\n\n        if char is None:\n            char = self.empty_char()\n        else:\n            char = (self.attrspec, self.charset.current, char)\n\n        x, y = position\n\n        while chars > 0:\n            self.term[y].insert(x, char)\n            self.term[y].pop()\n            chars -= 1\n\n    def remove_chars(self, position: tuple[int, int] | None = None, chars: int = 1) -> None:\n        \"\"\"\n        Remove 'chars' number of empty characters from 'position' (or the current\n        position if not specified) pulling subsequent characters of the line to\n        the left without joining any subsequent lines.\n        \"\"\"\n        if position is None:\n            position = self.term_cursor\n\n        if chars == 0:\n            chars = 1\n\n        x, y = position\n\n        while chars > 0:\n            self.term[y].pop(x)\n            self.term[y].append(self.empty_char())\n            chars -= 1\n\n    def insert_lines(self, row: int | None = None, lines: int = 1) -> None:\n        \"\"\"\n        Insert 'lines' of empty lines after the specified row, pushing all\n        subsequent lines to the bottom. If no 'row' is specified, the current\n        row is used.\n        \"\"\"\n        if row is None:\n            row = self.term_cursor[1]\n        else:\n            row = self.scrollregion_start\n\n        if lines == 0:\n            lines = 1\n\n        while lines > 0:\n            self.term.insert(row, self.empty_line())\n            self.term.pop(self.scrollregion_end)\n            lines -= 1\n\n    def remove_lines(self, row: int | None = None, lines: int = 1) -> None:\n        \"\"\"\n        Remove 'lines' number of lines at the specified row, pulling all\n        subsequent lines to the top. If no 'row' is specified, the current row\n        is used.\n        \"\"\"\n        if row is None:\n            row = self.term_cursor[1]\n        else:\n            row = self.scrollregion_start\n\n        if lines == 0:\n            lines = 1\n\n        while lines > 0:\n            self.term.pop(row)\n            self.term.insert(self.scrollregion_end, self.empty_line())\n            lines -= 1\n\n    def erase(\n        self,\n        start: tuple[int, int] | tuple[int, int, bool],\n        end: tuple[int, int] | tuple[int, int, bool],\n    ) -> None:\n        \"\"\"\n        Erase a region of the terminal. The 'start' tuple (x, y) defines the\n        starting position of the erase, while end (x, y) the last position.\n\n        For example if the terminal size is 4x3, start=(1, 1) and end=(1, 2)\n        would erase the following region:\n\n        ....\n        .XXX\n        XX..\n        \"\"\"\n        sx, sy = self.constrain_coords(*start)\n        ex, ey = self.constrain_coords(*end)\n\n        # within a single row\n        if sy == ey:\n            for x in range(sx, ex + 1):\n                self.term[sy][x] = self.empty_char()\n            return\n\n        # spans multiple rows\n        y = sy\n        while y <= ey:\n            if y == sy:\n                for x in range(sx, self.width):\n                    self.term[y][x] = self.empty_char()\n            elif y == ey:\n                for x in range(ex + 1):\n                    self.term[y][x] = self.empty_char()\n            else:\n                self.blank_line(y)\n\n            y += 1\n\n    def sgi_to_attrspec(self, attrs: Iterable[int], fg: int, bg: int, attributes: set[str], prev_colors: int) -> AttrSpec | None:\n        \"\"\"\n        Parse SGI sequence and return an AttrSpec representing the sequence\n        including all earlier sequences specified as 'fg', 'bg' and\n        'attributes'.\n        \"\"\"\n\n        idx = 0\n        colors = prev_colors\n\n        while idx < len(attrs):\n            attr = attrs[idx]\n            if 30 <= attr <= 37:\n                fg = attr - 30\n                colors = max(16, colors)\n            elif 40 <= attr <= 47:\n                bg = attr - 40\n                colors = max(16, colors)\n            elif attr == 38 or attr == 48:\n                if idx + 2 < len(attrs) and attrs[idx + 1] == 5:\n                    # 8 bit color specification\n                    color = attrs[idx + 2]\n                    colors = max(256, colors)\n                    if attr == 38:\n                        fg = color\n                    else:\n                        bg = color\n                    idx += 2\n                elif idx + 4 < len(attrs) and attrs[idx + 1] == 2:\n                    # 24 bit color specification\n                    color = (attrs[idx + 2] << 16) + \\\n                        (attrs[idx + 3] << 8) + attrs[idx + 4]\n                    colors = 2**24\n                    if attr == 38:\n                        fg = color\n                    else:\n                        bg = color\n                    idx += 4\n            elif attr == 39:\n                # set default foreground color\n                fg = None\n            elif attr == 49:\n                # set default background color\n                bg = None\n            elif attr == 10:\n                self.charset.reset_sgr_ibmpc()\n                self.modes.display_ctrl = False\n            elif attr in (11, 12):\n                self.charset.set_sgr_ibmpc()\n                self.modes.display_ctrl = True\n\n            # set attributes\n            elif attr == 1:\n                attributes.add('bold')\n            elif attr == 4:\n                attributes.add('underline')\n            elif attr == 5:\n                attributes.add('blink')\n            elif attr == 7:\n                attributes.add('standout')\n\n            # unset attributes\n            elif attr == 24:\n                attributes.discard('underline')\n            elif attr == 25:\n                attributes.discard('blink')\n            elif attr == 27:\n                attributes.discard('standout')\n            elif attr == 0:\n                # clear all attributes\n                fg = bg = None\n                attributes.clear()\n\n            idx += 1\n\n        if 'bold' in attributes and colors == 16 and fg is not None and fg < 8:\n            fg += 8\n\n        def _defaulter(color: int | None, colors: int) -> str:\n            if color is None:\n                return 'default'\n            # Note: we can't detect 88 color mode\n            if color > 255 or colors == 2**24:\n                return _color_desc_true(color)\n            if color > 15 or colors == 256:\n                return _color_desc_256(color)\n            return _BASIC_COLORS[color]\n\n        fg = _defaulter(fg, colors)\n        bg = _defaulter(bg, colors)\n\n        if len(attributes) > 0:\n            fg = ','.join([fg] + list(attributes))\n\n        if fg == 'default' and bg == 'default':\n            return None\n        else:\n            if colors:\n                return AttrSpec(fg, bg, colors=colors)\n            else:\n                return AttrSpec(fg, bg)\n\n    def csi_set_attr(self, attrs: Sequence[int]) -> None:\n        \"\"\"\n        Set graphics rendition.\n        \"\"\"\n        if attrs[-1] == 0:\n            self.attrspec = None\n\n        attributes = set()\n        if self.attrspec is None:\n            fg = bg = None\n        else:\n            # set default values from previous attrspec\n            if 'default' in self.attrspec.foreground:\n                fg = None\n            else:\n                fg = self.attrspec.foreground_number\n                if fg >= 8 and self.attrspec._colors() == 16:\n                    fg -= 8\n\n            if 'default' in self.attrspec.background:\n                bg = None\n            else:\n                bg = self.attrspec.background_number\n                if bg >= 8 and self.attrspec._colors() == 16:\n                    bg -= 8\n\n            for attr in ('bold', 'underline', 'blink', 'standout'):\n                if not getattr(self.attrspec, attr):\n                    continue\n\n                attributes.add(attr)\n\n        attrspec = self.sgi_to_attrspec(attrs, fg, bg, attributes,\n                                        self.attrspec._colors()\n                                        if self.attrspec else 1)\n\n        if self.modes.reverse_video:\n            self.attrspec = self.reverse_attrspec(attrspec)\n        else:\n            self.attrspec = attrspec\n\n    def reverse_attrspec(self, attrspec: AttrSpec | None, undo: bool = False) -> AttrSpec:\n        \"\"\"\n        Put standout mode to the 'attrspec' given and remove it if 'undo' is\n        True.\n        \"\"\"\n        if attrspec is None:\n            attrspec = AttrSpec('default', 'default')\n        attrs = [fg.strip() for fg in attrspec.foreground.split(',')]\n        if 'standout' in attrs and undo:\n            attrs.remove('standout')\n            attrspec = attrspec.copy_modified(fg=','.join(attrs))\n        elif 'standout' not in attrs and not undo:\n            attrs.append('standout')\n            attrspec = attrspec.copy_modified(fg=','.join(attrs))\n        return attrspec\n\n    def reverse_video(self, undo: bool = False) -> None:\n        \"\"\"\n        Reverse video/scanmode (DECSCNM) by swapping fg and bg colors.\n        \"\"\"\n        for y in range(self.height):\n            for x in range(self.width):\n                char = self.term[y][x]\n                attrs = self.reverse_attrspec(char[0], undo=undo)\n                self.term[y][x] = (attrs,) + char[1:]\n\n    def set_mode(\n        self,\n        mode: Literal[1, 3, 4, 5, 6, 7, 20, 25, 2004] | int,\n        flag: bool,\n        qmark: bool,\n        reset: bool,\n    ) -> None:\n        \"\"\"\n        Helper method for csi_set_modes: set single mode.\n        \"\"\"\n        if qmark:\n            # DEC private mode\n            if mode == 1:\n                # cursor keys send an ESC O prefix, rather than ESC [\n                self.modes.keys_decckm = flag\n            elif mode == 3:\n                # deccolm just clears the screen\n                self.clear()\n            elif mode == 5:\n                if self.modes.reverse_video != flag:\n                    self.reverse_video(undo=not flag)\n                self.modes.reverse_video = flag\n            elif mode == 6:\n                self.modes.constrain_scrolling = flag\n                self.set_term_cursor(0, 0)\n            elif mode == 7:\n                self.modes.autowrap = flag\n            elif mode == 25:\n                self.modes.visible_cursor = flag\n                self.set_term_cursor()\n            elif mode == 2004:\n                self.modes.bracketed_paste = flag\n        else:\n            # ECMA-48\n            if mode == 3:\n                self.modes.display_ctrl = flag\n            elif mode == 4:\n                self.modes.insert = flag\n            elif mode == 20:\n                self.modes.lfnl = flag\n\n    def csi_set_modes(self, modes: Iterable[int], qmark: bool, reset: bool = False) -> None:\n        \"\"\"\n        Set (DECSET/ECMA-48) or reset modes (DECRST/ECMA-48) if reset is True.\n        \"\"\"\n        flag = not reset\n\n        for mode in modes:\n            self.set_mode(mode, flag, qmark, reset)\n\n    def csi_set_scroll(self, top: int = 0, bottom: int = 0) -> None:\n        \"\"\"\n        Set scrolling region, 'top' is the line number of first line in the\n        scrolling region. 'bottom' is the line number of bottom line. If both\n        are set to 0, the whole screen will be used (default).\n        \"\"\"\n        if not top:\n            top = 1\n        if not bottom:\n            bottom = self.height\n\n        if top < bottom <= self.height:\n            self.scrollregion_start = self.constrain_coords(0, top - 1, ignore_scrolling=True)[1]\n            self.scrollregion_end = self.constrain_coords(0, bottom - 1, ignore_scrolling=True)[1]\n\n            self.set_term_cursor(0, 0)\n\n    def csi_clear_tabstop(self, mode: Literal[0, 3] | int = 0):\n        \"\"\"\n        Clear tabstop at current position or if 'mode' is 3, delete all\n        tabstops.\n        \"\"\"\n        if mode == 0:\n            self.set_tabstop(remove=True)\n        elif mode == 3:\n            self.set_tabstop(clear=True)\n\n    def csi_get_device_attributes(self, qmark: bool) -> None:\n        \"\"\"\n        Report device attributes (what are you?). In our case, we'll report\n        ourself as a VT102 terminal.\n        \"\"\"\n        if not qmark:\n            self.widget.respond(f\"{ESC}[?6c\")\n\n    def csi_status_report(self, mode: Literal[5, 6] | int) -> None:\n        \"\"\"\n        Report various information about the terminal status.\n        Information is queried by 'mode', where possible values are:\n            5 -> device status report\n            6 -> cursor position report\n        \"\"\"\n        if mode == 5:\n            # terminal OK\n            self.widget.respond(f\"{ESC}[0n\")\n        elif mode == 6:\n            x, y = self.term_cursor\n            self.widget.respond(ESC + '[%d;%dR' % (y + 1, x + 1))\n\n    def csi_erase_line(self, mode: Literal[0, 1, 2] | int) -> None:\n        \"\"\"\n        Erase current line, modes are:\n            0 -> erase from cursor to end of line.\n            1 -> erase from start of line to cursor.\n            2 -> erase whole line.\n        \"\"\"\n        x, y = self.term_cursor\n\n        if mode == 0:\n            self.erase(self.term_cursor, (self.width - 1, y))\n        elif mode == 1:\n            self.erase((0, y), (x, y))\n        elif mode == 2:\n            self.blank_line(y)\n\n    def csi_erase_display(self, mode: Literal[0, 1, 2] | int) -> None:\n        \"\"\"\n        Erase display, modes are:\n            0 -> erase from cursor to end of display.\n            1 -> erase from start to cursor.\n            2 -> erase the whole display.\n        \"\"\"\n        if mode == 0:\n            self.erase(self.term_cursor, (self.width - 1, self.height - 1))\n        if mode == 1:\n            self.erase((0, 0), (self.term_cursor[0] - 1, self.term_cursor[1]))\n        elif mode == 2:\n            self.clear(cursor=self.term_cursor)\n\n    def csi_set_keyboard_leds(self, mode: Literal[0, 1, 2, 3] | int = 0) -> None:\n        \"\"\"\n        Set keyboard LEDs, modes are:\n            0 -> clear all LEDs\n            1 -> set scroll lock LED\n            2 -> set num lock LED\n            3 -> set caps lock LED\n\n        This currently just emits a signal, so it can be processed by another\n        widget or the main application.\n        \"\"\"\n        states = {\n            0: 'clear',\n            1: 'scroll_lock',\n            2: 'num_lock',\n            3: 'caps_lock',\n        }\n\n        if mode in states:\n            self.widget.leds(states[mode])\n\n    def clear(self, cursor: tuple[int, int] | None = None) -> None:\n        \"\"\"\n        Clears the whole terminal screen and resets the cursor position\n        to (0, 0) or to the coordinates given by 'cursor'.\n        \"\"\"\n        self.term = [self.empty_line() for _ in range(self.height)]\n\n        if cursor is None:\n            self.set_term_cursor(0, 0)\n        else:\n            self.set_term_cursor(*cursor)\n\n    def cols(self) -> int:\n        return self.width\n\n    def rows(self) -> int:\n        return self.height\n\n    def content(\n        self,\n        trim_left: int = 0,\n        trim_right: int = 0,\n        cols: int | None = None,\n        rows: int | None = None,\n        attr=None,\n    ):\n        if self.scrolling_up == 0:\n            yield from self.term\n        else:\n            buf = self.scrollback_buffer + self.term\n            yield from buf[-(self.height+self.scrolling_up):-self.scrolling_up]\n\n    def content_delta(self, other):\n        if other is self:\n            return [self.cols()]*self.rows()\n        return self.content()",
  "class Terminal(Widget):\n    _selectable = True\n    _sizing = frozenset([Sizing.BOX])\n\n    signals = ['closed', 'beep', 'leds', 'title', 'resize']\n\n    def __init__(\n        self,\n        command: Sequence[str | bytes] | Callable[[], ...] | None,\n        env: Mapping[str, str] | Iterable[tuple[str, str]] | None = None,\n        main_loop: event_loop.EventLoop | None = None,\n        escape_sequence: str | None = None,\n        encoding: str = 'utf-8',\n    ):\n        \"\"\"\n        A terminal emulator within a widget.\n\n        ``command`` is the command to execute inside the terminal,\n        provided as a list of the command followed by its arguments.\n        If 'command' is None, the command is the current user's shell.\n        You can also provide a callable instead of a command, which will be executed in the subprocess.\n\n        ``env`` can be used to pass custom environment variables. If omitted,\n        os.environ is used.\n\n        ``main_loop`` should be provided, because the canvas state machine needs\n        to act on input from the PTY master device. This object must have\n        watch_file and remove_watch_file methods.\n\n        ``escape_sequence`` is the urwid key symbol which should be used to break\n        out of the terminal widget. If it's not specified, ``ctrl a`` is used.\n\n        ``encoding`` specifies the encoding that is being used when local\n        keypresses in Unicode are encoded into raw bytes. UTF-8 is used by default.\n        Set this to the encoding of your terminal if you need to transmit\n        characters to the spawned process in non-UTF8 encoding.\n        Applies to Python 3.x only.\n\n        .. note::\n\n            If you notice your Terminal instance is not printing unicode glyphs\n            correctly, make sure the global encoding for urwid is set to\n            ``utf8`` with ``urwid.set_encoding(\"utf8\")``. See\n            :ref:`text-encodings` for more details.\n        \"\"\"\n        super().__init__()\n\n        self.escape_sequence: str = escape_sequence or \"ctrl a\"\n\n        self.env = dict(env or os.environ)\n\n        self.command = command or [self.env.get('SHELL', '/bin/sh')]\n\n        self.encoding = encoding\n\n        self.keygrab = False\n        self.last_key: str | None = None\n\n        self.response_buffer: list[str] = []\n\n        self.term_modes = TermModes()\n\n        if main_loop is not None:\n            self.main_loop = main_loop\n        else:\n            self.main_loop = event_loop.SelectEventLoop()\n\n        self.master: int | None = None\n        self.pid: int | None = None\n\n        self.width: int | None = None\n        self.height: int | None = None\n        self.term: TermCanvas | None = None\n        self.has_focus = False\n        self.terminated = False\n\n    def get_cursor_coords(self, size: tuple[int, int]) -> tuple[int, int] | None:\n        \"\"\"Return the cursor coordinates for this terminal\n        \"\"\"\n        if self.term is None:\n            return None\n\n        # temporarily set width/height to figure out the new cursor position\n        # given the provided width/height\n        orig_width, orig_height = self.term.width, self.term.height\n\n        self.term.width = size[0]\n        self.term.height = size[1]\n\n        x, y = self.term.constrain_coords(\n            self.term.term_cursor[0],\n            self.term.term_cursor[1],\n        )\n\n        self.term.width, self.term.height = orig_width, orig_height\n\n        return (x, y)\n\n    def spawn(self) -> None:\n        env = self.env\n        env['TERM'] = 'linux'\n\n        self.pid, self.master = pty.fork()\n\n        if self.pid == 0:\n            if callable(self.command):\n                try:\n                    try:\n                        self.command()\n                    except:\n                        sys.stderr.write(traceback.format_exc())\n                        sys.stderr.flush()\n                finally:\n                    os._exit(0)\n            else:\n                os.execvpe(self.command[0], self.command, env)\n\n        if self.main_loop is None:\n            fcntl.fcntl(self.master, fcntl.F_SETFL, os.O_NONBLOCK)\n\n        atexit.register(self.terminate)\n\n    def terminate(self) -> None:\n        if self.terminated:\n            return\n\n        self.terminated = True\n        self.remove_watch()\n        self.change_focus(False)\n\n        if self.pid > 0:\n            self.set_termsize(0, 0)\n            for sig in (signal.SIGHUP, signal.SIGCONT, signal.SIGINT, signal.SIGTERM, signal.SIGKILL):\n                try:\n                    os.kill(self.pid, sig)\n                    pid, status = os.waitpid(self.pid, os.WNOHANG)\n                except OSError:\n                    break\n\n                if pid == 0:\n                    break\n                time.sleep(0.1)\n            try:\n                os.waitpid(self.pid, 0)\n            except OSError:\n                pass\n\n            os.close(self.master)\n\n    def beep(self) -> None:\n        self._emit('beep')\n\n    def leds(self, which: Literal['clear', 'scroll_lock', 'num_lock', 'caps_lock']) -> None:\n        self._emit('leds', which)\n\n    def respond(self, string: str) -> None:\n        \"\"\"\n        Respond to the underlying application with 'string'.\n        \"\"\"\n        self.response_buffer.append(string)\n\n    def flush_responses(self) -> None:\n        for string in self.response_buffer:\n            os.write(self.master, string.encode('ascii'))\n        self.response_buffer = []\n\n    def set_termsize(self, width: int, height: int) -> None:\n        winsize = struct.pack(\"HHHH\", height, width, 0, 0)\n        fcntl.ioctl(self.master, termios.TIOCSWINSZ, winsize)\n\n    def touch_term(self, width: int, height: int) -> None:\n        process_opened = False\n\n        if self.pid is None:\n            self.spawn()\n            process_opened = True\n\n        if self.width == width and self.height == height:\n            return\n\n        self.set_termsize(width, height)\n\n        if not self.term:\n            self.term = TermCanvas(width, height, self)\n        else:\n            self.term.resize(width, height)\n\n        self.width = width\n        self.height = height\n\n        if process_opened:\n            self.add_watch()\n\n        self._emit(\"resize\", (width, height))\n\n    def set_title(self, title) -> None:\n        self._emit('title', title)\n\n    def change_focus(self, has_focus) -> None:\n        \"\"\"\n        Ignore SIGINT if this widget has focus.\n        \"\"\"\n        if self.terminated:\n            return\n\n        self.has_focus = has_focus\n\n        if self.term is not None:\n            self.term.has_focus = has_focus\n            self.term.set_term_cursor()\n\n        if has_focus:\n            self.old_tios = RealTerminal().tty_signal_keys()\n            RealTerminal().tty_signal_keys(*(['undefined'] * 5))\n        else:\n            if hasattr(self, \"old_tios\"):\n                RealTerminal().tty_signal_keys(*self.old_tios)\n\n    def render(self, size: tuple[int, int], focus: bool = False):\n        if not self.terminated:\n            self.change_focus(focus)\n\n            width, height = size\n            self.touch_term(width, height)\n\n            if self.main_loop is None:\n                self.feed()\n\n        return self.term\n\n    def add_watch(self) -> None:\n        if self.main_loop is None:\n            return\n        self.main_loop.watch_file(self.master, self.feed)\n\n    def remove_watch(self) -> None:\n        if self.main_loop is None:\n            return\n        self.main_loop.remove_watch_file(self.master)\n\n    def wait_and_feed(self, timeout: float = 1.0) -> None:\n        while True:\n            try:\n                select.select([self.master], [], [], timeout)\n                break\n            except OSError as e:\n                if e.args[0] != 4:\n                    raise\n        self.feed()\n\n    def feed(self) -> None:\n        data = EOF\n\n        try:\n            data = os.read(self.master, 4096)\n        except OSError as e:\n            if e.errno == errno.EIO:  # EIO, child terminated\n                data = EOF\n            elif e.errno == errno.EWOULDBLOCK:  # empty buffer\n                return\n            else:\n                raise\n\n        if data == EOF:\n            self.terminate()\n            self._emit('closed')\n            return\n\n        self.term.addstr(data)\n\n        self.flush_responses()\n\n    def keypress(self, size: tuple[int, int], key: str) -> str | None:\n        if self.terminated:\n            return key\n\n        if key == \"begin paste\" or key == \"end paste\":\n            if self.term_modes.bracketed_paste:\n                pass  # passthrough bracketed paste sequences\n            else:  # swallow bracketed paste sequences\n                self.last_key = key\n                return None\n            \n        if key == \"window resize\":\n            width, height = size\n            self.touch_term(width, height)\n            return None\n\n        if self.last_key == self.escape_sequence and key == self.escape_sequence:\n            # escape sequence pressed twice...\n            self.last_key = key\n            self.keygrab = True\n            # ... so pass it to the terminal\n        elif self.keygrab:\n            if self.escape_sequence == key:\n                # stop grabbing the terminal\n                self.keygrab = False\n                self.last_key = key\n                return None\n        else:\n            if key == 'page up':\n                self.term.scroll_buffer()\n                self.last_key = key\n                self._invalidate()\n                return None\n\n            if key == 'page down':\n                self.term.scroll_buffer(up=False)\n                self.last_key = key\n                self._invalidate()\n                return None\n\n            if self.last_key == self.escape_sequence and key != self.escape_sequence:\n                # hand down keypress directly after ungrab.\n                self.last_key = key\n                return key\n\n            if self.escape_sequence == key:\n                # start grabbing the terminal\n                self.keygrab = True\n                self.last_key = key\n                return None\n\n            if self._command_map[key] is None or key == 'enter':\n                # printable character or escape sequence means:\n                # lock in terminal...\n                self.keygrab = True\n                # ... and do key processing\n            else:\n                # hand down keypress\n                self.last_key = key\n                return key\n\n        self.last_key = key\n\n        self.term.scroll_buffer(reset=True)\n\n        if key.startswith(\"ctrl \"):\n            if key[-1].islower():\n                key = chr(ord(key[-1]) - ord('a') + 1)\n            else:\n                key = chr(ord(key[-1]) - ord('A') + 1)\n        else:\n            if self.term_modes.keys_decckm and key in KEY_TRANSLATIONS_DECCKM:\n                key = KEY_TRANSLATIONS_DECCKM[key]\n            else:\n                key = KEY_TRANSLATIONS.get(key, key)\n\n        # ENTER transmits both a carriage return and linefeed in LF/NL mode.\n        if self.term_modes.lfnl and key == \"\\r\":\n            key += \"\\n\"\n\n        os.write(self.master, key.encode(self.encoding, 'ignore'))\n\n        return None",
  "def reset(self) -> None:\n        # ECMA-48\n        self.display_ctrl = False\n        self.insert = False\n        self.lfnl = False\n\n        # DEC private modes\n        self.keys_decckm = False\n        self.reverse_video = False\n        self.constrain_scrolling = False\n        self.autowrap = True\n        self.visible_cursor = True\n\n        # charset stuff\n        self.main_charset = CHARSET_DEFAULT",
  "def __init__(self) -> None:\n        self._g = [\n            'default',\n            'vt100',\n        ]\n\n        self._sgr_mapping = False\n\n        # prepare defaults\n        self.active = 0\n        self.current: str | None = None\n\n        self.activate(0)",
  "def define(self, g: int, charset: str) -> None:\n        \"\"\"\n        Redefine G'g' with new mapping.\n        \"\"\"\n        self._g[g] = charset\n        self.activate(g=self.active)",
  "def activate(self, g: int) -> None:\n        \"\"\"\n        Activate the given charset slot.\n        \"\"\"\n        self.active = g\n        self.current = self.MAPPING.get(self._g[g], None)",
  "def set_sgr_ibmpc(self) -> None:\n        \"\"\"\n        Set graphics rendition mapping to IBM PC CP437.\n        \"\"\"\n        self._sgr_mapping = True",
  "def reset_sgr_ibmpc(self) -> None:\n        \"\"\"\n        Reset graphics rendition mapping to IBM PC CP437.\n        \"\"\"\n        self._sgr_mapping = False\n        self.activate(g=self.active)",
  "def apply_mapping(self, char: bytes) -> bytes:\n        if self._sgr_mapping or self._g[self.active] == 'ibmpc':\n            dec_pos = DEC_SPECIAL_CHARS.find(char.decode('cp437'))\n            if dec_pos >= 0:\n                self.current = '0'\n                return ALT_DEC_SPECIAL_CHARS[dec_pos].encode(\"cp437\")\n            else:\n                self.current = 'U'\n                return char\n        else:\n            return char",
  "def __init__(self, iterable: Iterable[typing.Any]) -> None:\n        warnings.warn(\n            \"`TermScroller` is deprecated. Please use `collections.deque` with non-zero `maxlen` instead.\",\n            DeprecationWarning,\n            stacklevel=3,\n        )\n        super().__init__(iterable)",
  "def trunc(self) -> None:\n        if len(self) >= self.SCROLLBACK_LINES:\n            self.pop(0)",
  "def append(self, obj) -> None:\n        self.trunc()\n        super().append(obj)",
  "def insert(self, idx: typing.SupportsIndex, obj) -> None:\n        self.trunc()\n        super().insert(idx, obj)",
  "def extend(self, seq) -> None:\n        self.trunc()\n        super().extend(seq)",
  "def __init__(self, width: int, height: int, widget: Terminal) -> None:\n        super().__init__()\n\n        self.width, self.height = width, height\n        self.widget = widget\n        self.modes: TermModes = widget.term_modes\n        self.has_focus = False\n\n        self.scrollback_buffer: deque[list[tuple[AttrSpec | None, str | None, bytes]]] = deque(maxlen=10000)\n        self.scrolling_up = 0\n\n        self.utf8_eat_bytes: int | None = None\n        self.utf8_buffer = bytearray()\n        self.escbuf = b''\n\n        self.coords[\"cursor\"] = (0, 0, None)\n\n        self.term_cursor: tuple[int, int] = (0, 0)  # do not allow to shoot in the leg at `set_term_cursor`\n\n        self.within_escape = False\n        self.parsestate = 0\n\n        self.attrspec: AttrSpec | None = None\n\n        self.charset = TermCharset()\n\n        self.saved_cursor: tuple[int, int] | None = None\n        self.saved_attrs: tuple[AttrSpec | None, TermCharset] | None = None\n\n        self.is_rotten_cursor = False\n\n        self.scrollregion_start = 0\n        self.scrollregion_end = self.height - 1\n\n        self.tabstops: list[int] = []\n        self.term: list[list[tuple[AttrSpec | None, str | None, bytes]]] = []\n\n        self.reset()",
  "def set_term_cursor(self, x: int | None = None, y: int | None = None) -> None:\n        \"\"\"\n        Set terminal cursor to x/y and update canvas cursor. If one or both axes\n        are omitted, use the values of the current position.\n        \"\"\"\n        if x is None:\n            x = self.term_cursor[0]\n        if y is None:\n            y = self.term_cursor[1]\n\n        self.term_cursor = self.constrain_coords(x, y)\n\n        if self.has_focus and self.modes.visible_cursor and self.scrolling_up < self.height - y:\n            self.cursor = (x, y + self.scrolling_up)\n        else:\n            self.cursor = None",
  "def reset_scroll(self) -> None:\n        \"\"\"\n        Reset scrolling region to full terminal size.\n        \"\"\"\n        self.scrollregion_start = 0\n        self.scrollregion_end = self.height - 1",
  "def scroll_buffer(self, up: bool = True, reset: bool = False, lines: int | None = None) -> None:\n        \"\"\"\n        Scroll the scrolling buffer up (up=True) or down (up=False) the given\n        amount of lines or half the screen height.\n\n        If just 'reset' is True, set the scrollbuffer view to the current\n        terminal content.\n        \"\"\"\n        if reset:\n            self.scrolling_up = 0\n            self.set_term_cursor()\n            return\n\n        if lines is None:\n            lines = self.height // 2\n\n        if not up:\n            lines = -lines\n\n        maxscroll = len(self.scrollback_buffer)\n        self.scrolling_up += lines\n\n        if self.scrolling_up > maxscroll:\n            self.scrolling_up = maxscroll\n        elif self.scrolling_up < 0:\n            self.scrolling_up = 0\n\n        self.set_term_cursor()",
  "def reset(self) -> None:\n        \"\"\"\n        Reset the terminal.\n        \"\"\"\n        self.escbuf = b''\n        self.within_escape = False\n        self.parsestate = 0\n\n        self.attrspec = None\n        self.charset = TermCharset()\n\n        self.saved_cursor = None\n        self.saved_attrs = None\n\n        self.is_rotten_cursor = False\n\n        self.reset_scroll()\n\n        self.init_tabstops()\n\n        # terminal modes\n        self.modes.reset()\n\n        # initialize self.term\n        self.clear()",
  "def init_tabstops(self, extend: bool = False) -> None:\n        tablen, mod = divmod(self.width, 8)\n        if mod > 0:\n            tablen += 1\n\n        if extend:\n            while len(self.tabstops) < tablen:\n                self.tabstops.append(1 << 0)\n        else:\n            self.tabstops = [1 << 0] * tablen",
  "def set_tabstop(self, x: int | None = None, remove: bool = False, clear: bool = False) -> None:\n        if clear:\n            for tab in range(len(self.tabstops)):\n                self.tabstops[tab] = 0\n            return\n\n        if x is None:\n            x = self.term_cursor[0]\n\n        div, mod = divmod(x, 8)\n        if remove:\n            self.tabstops[div] &= ~(1 << mod)\n        else:\n            self.tabstops[div] |= (1 << mod)",
  "def is_tabstop(self, x: int | None = None) -> bool:\n        if x is None:\n            x = self.term_cursor[0]\n\n        div, mod = divmod(x, 8)\n        return (self.tabstops[div] & (1 << mod)) > 0",
  "def empty_line(self, char: bytes = b' ') -> list[tuple[AttrSpec | None, str | None, bytes]]:\n        return [self.empty_char(char)] * self.width",
  "def empty_char(self, char: bytes = b' ') -> tuple[AttrSpec | None, str | None, bytes]:\n        return (self.attrspec, self.charset.current, char)",
  "def addstr(self, data: Iterable[int]) -> None:\n        if self.width <= 0 or self.height <= 0:\n            # not displayable, do nothing!\n            return\n\n        for byte in data:\n            self.addbyte(byte)",
  "def resize(self, width: int, height: int) -> None:\n        \"\"\"\n        Resize the terminal to the given width and height.\n        \"\"\"\n        x, y = self.term_cursor\n\n        if width > self.width:\n            # grow\n            for y in range(self.height):\n                self.term[y] += [self.empty_char()] * (width - self.width)\n        elif width < self.width:\n            # shrink\n            for y in range(self.height):\n                self.term[y] = self.term[y][:width]\n\n        self.width = width\n\n        if height > self.height:\n            # grow\n            for y in range(self.height, height):\n                try:\n                    last_line = self.scrollback_buffer.pop()\n                except IndexError:\n                    # nothing in scrollback buffer, append an empty line\n                    self.term.append(self.empty_line())\n                    self.scrollregion_end += 1\n                    continue\n\n                # adjust x axis of scrollback buffer to the current width\n                padding = self.width - len(last_line)\n                if padding > 0:\n                    last_line += [self.empty_char()] * padding\n                else:\n                    last_line = last_line[:self.width]\n\n                y += 1\n\n                self.term.insert(0, last_line)\n        elif height < self.height:\n            # shrink\n            for y in range(height, self.height):\n                self.scrollback_buffer.append(self.term.pop(0))\n\n        self.height = height\n\n        self.reset_scroll()\n\n        x, y = self.constrain_coords(x, y)\n        self.set_term_cursor(x, y)\n\n        # extend tabs\n        self.init_tabstops(extend=True)",
  "def set_g01(self, char: bytes, mod: bytes) -> None:\n        \"\"\"\n        Set G0 or G1 according to 'char' and modifier 'mod'.\n        \"\"\"\n        if self.modes.main_charset != CHARSET_DEFAULT:\n            return\n\n        if mod == b'(':\n            g = 0\n        else:\n            g = 1\n\n        if char == b'0':\n            cset = 'vt100'\n        elif char == b'U':\n            cset = 'ibmpc'\n        elif char == b'K':\n            cset = 'user'\n        else:\n            cset = 'default'\n\n        self.charset.define(g, cset)",
  "def parse_csi(self, char: bytes) -> None:\n        \"\"\"\n        Parse ECMA-48 CSI (Control Sequence Introducer) sequences.\n        \"\"\"\n        qmark = self.escbuf.startswith(b'?')\n\n        escbuf = []\n        for arg in self.escbuf[qmark and 1 or 0:].split(b';'):\n            try:\n                num = int(arg)\n            except ValueError:\n                num = None\n\n            escbuf.append(num)\n\n        cmd_ = CSI_COMMANDS[char]\n        if cmd_ is not None:\n            if isinstance(cmd_, CSIAlias):\n                csi_cmd: CSICommand = CSI_COMMANDS[cmd_.alias]  # type: ignore[assignment]\n            elif isinstance(cmd_, CSICommand):\n                csi_cmd = cmd_\n            elif cmd_[0] == 'alias':  # fallback, hard deprecated\n                csi_cmd = CSI_COMMANDS[CSIAlias(*cmd_).alias]\n            else:\n                csi_cmd = CSICommand(*cmd_)  # fallback, hard deprecated\n\n            number_of_args, default_value, cmd = csi_cmd\n            while len(escbuf) < number_of_args:\n                escbuf.append(default_value)\n            for i in range(len(escbuf)):\n                if escbuf[i] is None or escbuf[i] == 0:\n                    escbuf[i] = default_value\n\n            try:\n                cmd(self, escbuf, qmark)\n            except ValueError:\n                # ignore commands that don't match the\n                # unpacked tuples in CSI_COMMANDS.\n                pass",
  "def parse_noncsi(self, char: bytes, mod: bytes = b'') -> None:\n        \"\"\"\n        Parse escape sequences which are not CSI.\n        \"\"\"\n        if mod == b'#' and char == b'8':\n            self.decaln()\n        elif mod == b'%':  # select main character set\n            if char == b'@':\n                self.modes.main_charset = CHARSET_DEFAULT\n            elif char in b'G8':\n                # 8 is obsolete and only for backwards compatibility\n                self.modes.main_charset = CHARSET_UTF8\n        elif mod in (b'(', b')'):  # define G0/G1\n            self.set_g01(char, mod)\n        elif char == b'M':  # reverse line feed\n            self.linefeed(reverse=True)\n        elif char == b'D':  # line feed\n            self.linefeed()\n        elif char == b'c':  # reset terminal\n            self.reset()\n        elif char == b'E':  # newline\n            self.newline()\n        elif char == b'H':  # set tabstop\n            self.set_tabstop()\n        elif char == b'Z':  # DECID\n            self.widget.respond(f\"{ESC}[?6c\")\n        elif char == b'7':  # save current state\n            self.save_cursor(with_attrs=True)\n        elif char == b'8':  # restore current state\n            self.restore_cursor(with_attrs=True)",
  "def parse_osc(self, buf: bytes) -> None:\n        \"\"\"\n        Parse operating system command.\n        \"\"\"\n        if (buf.startswith(b';')\n                or buf.startswith(b'0;')\n                or buf.startswith(b'2;')):\n            # set window title\n            self.widget.set_title(buf.decode().partition(\";\")[2])",
  "def parse_escape(self, char: bytes) -> None:\n        if self.parsestate == 1:\n            # within CSI\n            if char in CSI_COMMANDS:\n                self.parse_csi(char)\n                self.parsestate = 0\n            elif char in b'0123456789;' or (not self.escbuf and char == b'?'):\n                self.escbuf += char\n                return\n        elif self.parsestate == 0 and char == b']':\n            # start of OSC\n            self.escbuf = b''\n            self.parsestate = 2\n            return\n        elif self.parsestate == 2 and char == b\"\\a\":\n            # end of OSC\n            self.parse_osc(self.escbuf.lstrip(b'0'))\n        elif self.parsestate == 2 and self.escbuf[-1:] + char == f\"{ESC}\\\\\".encode('iso8859-1'):\n            # end of OSC\n            self.parse_osc(self.escbuf[:-1].lstrip(b'0'))\n        elif self.parsestate == 2 and self.escbuf.startswith(b'P') and len(self.escbuf) == 8:\n            # set palette (ESC]Pnrrggbb)\n            pass\n        elif self.parsestate == 2 and not self.escbuf and char == b'R':\n            # reset palette\n            pass\n        elif self.parsestate == 2:\n            self.escbuf += char\n            return\n        elif self.parsestate == 0 and char == b'[':\n            # start of CSI\n            self.escbuf = b''\n            self.parsestate = 1\n            return\n        elif self.parsestate == 0 and char in (b'%', b'#', b'(', b')'):\n            # non-CSI sequence\n            self.escbuf = char\n            self.parsestate = 3\n            return\n        elif self.parsestate == 3:\n            self.parse_noncsi(char, self.escbuf)\n        elif char in (b'c', b'D', b'E', b'H', b'M', b'Z', b'7', b'8', b'>', b'='):\n            self.parse_noncsi(char)\n\n        self.leave_escape()",
  "def leave_escape(self) -> None:\n        self.within_escape = False\n        self.parsestate = 0\n        self.escbuf = b''",
  "def get_utf8_len(self, bytenum: int) -> int:\n        \"\"\"\n        Process startbyte and return the number of bytes following it to get a\n        valid UTF-8 multibyte sequence.\n\n        bytenum -- an integer ordinal\n        \"\"\"\n        length = 0\n\n        while bytenum & 0x40:\n            bytenum <<= 1\n            length += 1\n\n        return length",
  "def addbyte(self, byte: int) -> None:\n        \"\"\"\n        Parse main charset and add the processed byte(s) to the terminal state\n        machine.\n\n        byte -- an integer ordinal\n        \"\"\"\n        if self.modes.main_charset == CHARSET_UTF8 or util._target_encoding == 'utf8':\n            if byte >= 0xc0:\n                # start multibyte sequence\n                self.utf8_eat_bytes = self.get_utf8_len(byte)\n                self.utf8_buffer = bytearray([byte])\n                return\n            elif 0x80 <= byte < 0xc0 and self.utf8_eat_bytes is not None:\n                if self.utf8_eat_bytes > 1:\n                    # continue multibyte sequence\n                    self.utf8_eat_bytes -= 1\n                    self.utf8_buffer.append(byte)\n                    return\n                else:\n                    # end multibyte sequence\n                    self.utf8_eat_bytes = None\n                    sequence = (self.utf8_buffer + bytes([byte])).decode('utf-8', 'ignore')\n                    if len(sequence) == 0:\n                        # invalid multibyte sequence, stop processing\n                        return\n                    char = sequence.encode(util._target_encoding, 'replace')\n            else:\n                self.utf8_eat_bytes = None\n                char = bytes([byte])\n        else:\n            char = bytes([byte])\n\n        self.process_char(char)",
  "def process_char(self, char: int | bytes) -> None:\n        \"\"\"\n        Process a single character (single- and multi-byte).\n\n        char -- a byte string\n        \"\"\"\n        x, y = self.term_cursor\n\n        if isinstance(char, int):\n            char = chr(char)\n\n        dc = self.modes.display_ctrl\n\n        if char == ESC_B and self.parsestate != 2:  # escape\n            self.within_escape = True\n        elif not dc and char == b'\\r':  # carriage return CR\n            self.carriage_return()\n        elif not dc and char == b\"\\x0f\":  # activate G0\n            self.charset.activate(0)\n        elif not dc and char == b\"\\x0e\":  # activate G1\n            self.charset.activate(1)\n        elif not dc and char in b\"\\n\\v\\f\":  # line feed LF/VT/FF\n            self.linefeed()\n            if self.modes.lfnl:\n                self.carriage_return()\n        elif not dc and char == b\"\\t\":  # char tab\n            self.tab()\n        elif not dc and char == b\"\\b\":  # backspace BS\n            if x > 0:\n                self.set_term_cursor(x - 1, y)\n        elif not dc and char == b\"\\a\" and self.parsestate != 2:  # BEL\n            # we need to check if we're in parsestate 2, as an OSC can be\n            # terminated by the BEL character!\n            self.widget.beep()\n        elif not dc and char in b\"\\x18\\x1a\":  # CAN/SUB\n            self.leave_escape()\n        elif not dc and char in b\"\\x00\\x7f\":  # NUL/DEL\n            pass  # this is ignored\n        elif self.within_escape:\n            self.parse_escape(char)\n        elif not dc and char == b\"\\x9b\":  # CSI (equivalent to \"ESC [\")\n            self.within_escape = True\n            self.escbuf = b''\n            self.parsestate = 1\n        else:\n            self.push_cursor(char)",
  "def set_char(self, char: bytes, x: int | None = None, y: int | None = None) -> None:\n        \"\"\"\n        Set character of either the current cursor position\n        or a position given by 'x' and/or 'y' to 'char'.\n        \"\"\"\n        if x is None:\n            x = self.term_cursor[0]\n        if y is None:\n            y = self.term_cursor[1]\n\n        x, y = self.constrain_coords(x, y)\n        self.term[y][x] = (self.attrspec, self.charset.current, char)",
  "def constrain_coords(self, x: int, y: int, ignore_scrolling: bool = False) -> tuple[int, int]:\n        \"\"\"\n        Checks if x/y are within the terminal and returns the corrected version.\n        If 'ignore_scrolling' is set, constrain within the full size of the\n        screen and not within scrolling region.\n        \"\"\"\n        if x >= self.width:\n            x = self.width - 1\n        elif x < 0:\n            x = 0\n\n        if self.modes.constrain_scrolling and not ignore_scrolling:\n            if y > self.scrollregion_end:\n                y = self.scrollregion_end\n            elif y < self.scrollregion_start:\n                y = self.scrollregion_start\n        else:\n            if y >= self.height:\n                y = self.height - 1\n            elif y < 0:\n                y = 0\n\n        return x, y",
  "def linefeed(self, reverse: bool = False) -> None:\n        \"\"\"\n        Move the cursor down (or up if reverse is True) one line but don't reset\n        horizontal position.\n        \"\"\"\n        x, y = self.term_cursor\n\n        if reverse:\n            if y <= 0 < self.scrollregion_start:\n                pass\n            elif y == self.scrollregion_start:\n                self.scroll(reverse=True)\n            else:\n                y -= 1\n        else:\n            if y >= self.height - 1 > self.scrollregion_end:\n                pass\n            elif y == self.scrollregion_end:\n                self.scroll()\n            else:\n                y += 1\n\n        self.set_term_cursor(x, y)",
  "def carriage_return(self) -> None:\n        self.set_term_cursor(0, self.term_cursor[1])",
  "def newline(self) -> None:\n        \"\"\"\n        Do a carriage return followed by a line feed.\n        \"\"\"\n        self.carriage_return()\n        self.linefeed()",
  "def move_cursor(\n        self,\n        x: int,\n        y: int,\n        relative_x: bool = False,\n        relative_y: bool = False,\n        relative: bool = False,\n    ) -> None:\n        \"\"\"\n        Move cursor to position x/y while constraining terminal sizes.\n        If 'relative' is True, x/y is relative to the current cursor\n        position. 'relative_x' and 'relative_y' is the same but just with\n        the corresponding axis.\n        \"\"\"\n        if relative:\n            relative_y = relative_x = True\n\n        if relative_x:\n            x += self.term_cursor[0]\n\n        if relative_y:\n            y += self.term_cursor[1]\n        elif self.modes.constrain_scrolling:\n            y += self.scrollregion_start\n\n        self.set_term_cursor(x, y)",
  "def push_char(self, char: bytes | None, x: int, y: int) -> None:\n        \"\"\"\n        Push one character to current position and advance cursor to x/y.\n        \"\"\"\n        if char is not None:\n            char = self.charset.apply_mapping(char)\n            if self.modes.insert:\n                self.insert_chars(char=char)\n            else:\n                self.set_char(char)\n\n        self.set_term_cursor(x, y)",
  "def push_cursor(self, char: bytes | None = None) -> None:\n        \"\"\"\n        Move cursor one character forward wrapping lines as needed.\n        If 'char' is given, put the character into the former position.\n        \"\"\"\n        x, y = self.term_cursor\n\n        if self.modes.autowrap:\n            if x + 1 >= self.width and not self.is_rotten_cursor:\n                # \"rotten cursor\" - this is when the cursor gets to the rightmost\n                # position of the screen, the cursor position remains the same but\n                # one last set_char() is allowed for that piece of sh^H^H\"border\".\n                self.is_rotten_cursor = True\n                self.push_char(char, x, y)\n            else:\n                x += 1\n\n                if x >= self.width and self.is_rotten_cursor:\n                    if y >= self.scrollregion_end:\n                        self.scroll()\n                    else:\n                        y += 1\n\n                    x = 1\n\n                    self.set_term_cursor(0, y)\n\n                self.push_char(char, x, y)\n\n                self.is_rotten_cursor = False\n        else:\n            if x + 1 < self.width:\n                x += 1\n\n            self.is_rotten_cursor = False\n            self.push_char(char, x, y)",
  "def save_cursor(self, with_attrs: bool = False) -> None:\n        self.saved_cursor = tuple(self.term_cursor)\n        if with_attrs:\n            self.saved_attrs = (copy.copy(self.attrspec), copy.copy(self.charset))",
  "def restore_cursor(self, with_attrs: bool = False) -> None:\n        if self.saved_cursor is None:\n            return\n\n        x, y = self.saved_cursor\n        self.set_term_cursor(x, y)\n\n        if with_attrs and self.saved_attrs is not None:\n            self.attrspec, self.charset = (copy.copy(self.saved_attrs[0]), copy.copy(self.saved_attrs[1]))",
  "def tab(self, tabstop: int = 8) -> None:\n        \"\"\"\n        Moves cursor to the next 'tabstop' filling everything in between\n        with spaces.\n        \"\"\"\n        x, y = self.term_cursor\n\n        while x < self.width - 1:\n            self.set_char(b\" \")\n            x += 1\n\n            if self.is_tabstop(x):\n                break\n\n        self.is_rotten_cursor = False\n        self.set_term_cursor(x, y)",
  "def scroll(self, reverse: bool = False) -> None:\n        \"\"\"\n        Append a new line at the bottom and put the topmost line into the\n        scrollback buffer.\n\n        If reverse is True, do exactly the opposite, but don't save into\n        scrollback buffer.\n        \"\"\"\n        if reverse:\n            self.term.pop(self.scrollregion_end)\n            self.term.insert(self.scrollregion_start, self.empty_line())\n        else:\n            killed = self.term.pop(self.scrollregion_start)\n            self.scrollback_buffer.append(killed)\n            self.term.insert(self.scrollregion_end, self.empty_line())",
  "def decaln(self) -> None:\n        \"\"\"\n        DEC screen alignment test: Fill screen with E's.\n        \"\"\"\n        for row in range(self.height):\n            self.term[row] = self.empty_line(b'E')",
  "def blank_line(self, row: int) -> None:\n        \"\"\"\n        Blank a single line at the specified row, without modifying other lines.\n        \"\"\"\n        self.term[row] = self.empty_line()",
  "def insert_chars(\n        self,\n        position: tuple[int, int] | None = None,\n        chars: int = 1,\n        char: bytes | None = None,\n    ) -> None:\n        \"\"\"\n        Insert 'chars' number of either empty characters - or those specified by\n        'char' - before 'position' (or the current position if not specified)\n        pushing subsequent characters of the line to the right without wrapping.\n        \"\"\"\n        if position is None:\n            position = self.term_cursor\n\n        if chars == 0:\n            chars = 1\n\n        if char is None:\n            char = self.empty_char()\n        else:\n            char = (self.attrspec, self.charset.current, char)\n\n        x, y = position\n\n        while chars > 0:\n            self.term[y].insert(x, char)\n            self.term[y].pop()\n            chars -= 1",
  "def remove_chars(self, position: tuple[int, int] | None = None, chars: int = 1) -> None:\n        \"\"\"\n        Remove 'chars' number of empty characters from 'position' (or the current\n        position if not specified) pulling subsequent characters of the line to\n        the left without joining any subsequent lines.\n        \"\"\"\n        if position is None:\n            position = self.term_cursor\n\n        if chars == 0:\n            chars = 1\n\n        x, y = position\n\n        while chars > 0:\n            self.term[y].pop(x)\n            self.term[y].append(self.empty_char())\n            chars -= 1",
  "def insert_lines(self, row: int | None = None, lines: int = 1) -> None:\n        \"\"\"\n        Insert 'lines' of empty lines after the specified row, pushing all\n        subsequent lines to the bottom. If no 'row' is specified, the current\n        row is used.\n        \"\"\"\n        if row is None:\n            row = self.term_cursor[1]\n        else:\n            row = self.scrollregion_start\n\n        if lines == 0:\n            lines = 1\n\n        while lines > 0:\n            self.term.insert(row, self.empty_line())\n            self.term.pop(self.scrollregion_end)\n            lines -= 1",
  "def remove_lines(self, row: int | None = None, lines: int = 1) -> None:\n        \"\"\"\n        Remove 'lines' number of lines at the specified row, pulling all\n        subsequent lines to the top. If no 'row' is specified, the current row\n        is used.\n        \"\"\"\n        if row is None:\n            row = self.term_cursor[1]\n        else:\n            row = self.scrollregion_start\n\n        if lines == 0:\n            lines = 1\n\n        while lines > 0:\n            self.term.pop(row)\n            self.term.insert(self.scrollregion_end, self.empty_line())\n            lines -= 1",
  "def erase(\n        self,\n        start: tuple[int, int] | tuple[int, int, bool],\n        end: tuple[int, int] | tuple[int, int, bool],\n    ) -> None:\n        \"\"\"\n        Erase a region of the terminal. The 'start' tuple (x, y) defines the\n        starting position of the erase, while end (x, y) the last position.\n\n        For example if the terminal size is 4x3, start=(1, 1) and end=(1, 2)\n        would erase the following region:\n\n        ....\n        .XXX\n        XX..\n        \"\"\"\n        sx, sy = self.constrain_coords(*start)\n        ex, ey = self.constrain_coords(*end)\n\n        # within a single row\n        if sy == ey:\n            for x in range(sx, ex + 1):\n                self.term[sy][x] = self.empty_char()\n            return\n\n        # spans multiple rows\n        y = sy\n        while y <= ey:\n            if y == sy:\n                for x in range(sx, self.width):\n                    self.term[y][x] = self.empty_char()\n            elif y == ey:\n                for x in range(ex + 1):\n                    self.term[y][x] = self.empty_char()\n            else:\n                self.blank_line(y)\n\n            y += 1",
  "def sgi_to_attrspec(self, attrs: Iterable[int], fg: int, bg: int, attributes: set[str], prev_colors: int) -> AttrSpec | None:\n        \"\"\"\n        Parse SGI sequence and return an AttrSpec representing the sequence\n        including all earlier sequences specified as 'fg', 'bg' and\n        'attributes'.\n        \"\"\"\n\n        idx = 0\n        colors = prev_colors\n\n        while idx < len(attrs):\n            attr = attrs[idx]\n            if 30 <= attr <= 37:\n                fg = attr - 30\n                colors = max(16, colors)\n            elif 40 <= attr <= 47:\n                bg = attr - 40\n                colors = max(16, colors)\n            elif attr == 38 or attr == 48:\n                if idx + 2 < len(attrs) and attrs[idx + 1] == 5:\n                    # 8 bit color specification\n                    color = attrs[idx + 2]\n                    colors = max(256, colors)\n                    if attr == 38:\n                        fg = color\n                    else:\n                        bg = color\n                    idx += 2\n                elif idx + 4 < len(attrs) and attrs[idx + 1] == 2:\n                    # 24 bit color specification\n                    color = (attrs[idx + 2] << 16) + \\\n                        (attrs[idx + 3] << 8) + attrs[idx + 4]\n                    colors = 2**24\n                    if attr == 38:\n                        fg = color\n                    else:\n                        bg = color\n                    idx += 4\n            elif attr == 39:\n                # set default foreground color\n                fg = None\n            elif attr == 49:\n                # set default background color\n                bg = None\n            elif attr == 10:\n                self.charset.reset_sgr_ibmpc()\n                self.modes.display_ctrl = False\n            elif attr in (11, 12):\n                self.charset.set_sgr_ibmpc()\n                self.modes.display_ctrl = True\n\n            # set attributes\n            elif attr == 1:\n                attributes.add('bold')\n            elif attr == 4:\n                attributes.add('underline')\n            elif attr == 5:\n                attributes.add('blink')\n            elif attr == 7:\n                attributes.add('standout')\n\n            # unset attributes\n            elif attr == 24:\n                attributes.discard('underline')\n            elif attr == 25:\n                attributes.discard('blink')\n            elif attr == 27:\n                attributes.discard('standout')\n            elif attr == 0:\n                # clear all attributes\n                fg = bg = None\n                attributes.clear()\n\n            idx += 1\n\n        if 'bold' in attributes and colors == 16 and fg is not None and fg < 8:\n            fg += 8\n\n        def _defaulter(color: int | None, colors: int) -> str:\n            if color is None:\n                return 'default'\n            # Note: we can't detect 88 color mode\n            if color > 255 or colors == 2**24:\n                return _color_desc_true(color)\n            if color > 15 or colors == 256:\n                return _color_desc_256(color)\n            return _BASIC_COLORS[color]\n\n        fg = _defaulter(fg, colors)\n        bg = _defaulter(bg, colors)\n\n        if len(attributes) > 0:\n            fg = ','.join([fg] + list(attributes))\n\n        if fg == 'default' and bg == 'default':\n            return None\n        else:\n            if colors:\n                return AttrSpec(fg, bg, colors=colors)\n            else:\n                return AttrSpec(fg, bg)",
  "def csi_set_attr(self, attrs: Sequence[int]) -> None:\n        \"\"\"\n        Set graphics rendition.\n        \"\"\"\n        if attrs[-1] == 0:\n            self.attrspec = None\n\n        attributes = set()\n        if self.attrspec is None:\n            fg = bg = None\n        else:\n            # set default values from previous attrspec\n            if 'default' in self.attrspec.foreground:\n                fg = None\n            else:\n                fg = self.attrspec.foreground_number\n                if fg >= 8 and self.attrspec._colors() == 16:\n                    fg -= 8\n\n            if 'default' in self.attrspec.background:\n                bg = None\n            else:\n                bg = self.attrspec.background_number\n                if bg >= 8 and self.attrspec._colors() == 16:\n                    bg -= 8\n\n            for attr in ('bold', 'underline', 'blink', 'standout'):\n                if not getattr(self.attrspec, attr):\n                    continue\n\n                attributes.add(attr)\n\n        attrspec = self.sgi_to_attrspec(attrs, fg, bg, attributes,\n                                        self.attrspec._colors()\n                                        if self.attrspec else 1)\n\n        if self.modes.reverse_video:\n            self.attrspec = self.reverse_attrspec(attrspec)\n        else:\n            self.attrspec = attrspec",
  "def reverse_attrspec(self, attrspec: AttrSpec | None, undo: bool = False) -> AttrSpec:\n        \"\"\"\n        Put standout mode to the 'attrspec' given and remove it if 'undo' is\n        True.\n        \"\"\"\n        if attrspec is None:\n            attrspec = AttrSpec('default', 'default')\n        attrs = [fg.strip() for fg in attrspec.foreground.split(',')]\n        if 'standout' in attrs and undo:\n            attrs.remove('standout')\n            attrspec = attrspec.copy_modified(fg=','.join(attrs))\n        elif 'standout' not in attrs and not undo:\n            attrs.append('standout')\n            attrspec = attrspec.copy_modified(fg=','.join(attrs))\n        return attrspec",
  "def reverse_video(self, undo: bool = False) -> None:\n        \"\"\"\n        Reverse video/scanmode (DECSCNM) by swapping fg and bg colors.\n        \"\"\"\n        for y in range(self.height):\n            for x in range(self.width):\n                char = self.term[y][x]\n                attrs = self.reverse_attrspec(char[0], undo=undo)\n                self.term[y][x] = (attrs,) + char[1:]",
  "def set_mode(\n        self,\n        mode: Literal[1, 3, 4, 5, 6, 7, 20, 25, 2004] | int,\n        flag: bool,\n        qmark: bool,\n        reset: bool,\n    ) -> None:\n        \"\"\"\n        Helper method for csi_set_modes: set single mode.\n        \"\"\"\n        if qmark:\n            # DEC private mode\n            if mode == 1:\n                # cursor keys send an ESC O prefix, rather than ESC [\n                self.modes.keys_decckm = flag\n            elif mode == 3:\n                # deccolm just clears the screen\n                self.clear()\n            elif mode == 5:\n                if self.modes.reverse_video != flag:\n                    self.reverse_video(undo=not flag)\n                self.modes.reverse_video = flag\n            elif mode == 6:\n                self.modes.constrain_scrolling = flag\n                self.set_term_cursor(0, 0)\n            elif mode == 7:\n                self.modes.autowrap = flag\n            elif mode == 25:\n                self.modes.visible_cursor = flag\n                self.set_term_cursor()\n            elif mode == 2004:\n                self.modes.bracketed_paste = flag\n        else:\n            # ECMA-48\n            if mode == 3:\n                self.modes.display_ctrl = flag\n            elif mode == 4:\n                self.modes.insert = flag\n            elif mode == 20:\n                self.modes.lfnl = flag",
  "def csi_set_modes(self, modes: Iterable[int], qmark: bool, reset: bool = False) -> None:\n        \"\"\"\n        Set (DECSET/ECMA-48) or reset modes (DECRST/ECMA-48) if reset is True.\n        \"\"\"\n        flag = not reset\n\n        for mode in modes:\n            self.set_mode(mode, flag, qmark, reset)",
  "def csi_set_scroll(self, top: int = 0, bottom: int = 0) -> None:\n        \"\"\"\n        Set scrolling region, 'top' is the line number of first line in the\n        scrolling region. 'bottom' is the line number of bottom line. If both\n        are set to 0, the whole screen will be used (default).\n        \"\"\"\n        if not top:\n            top = 1\n        if not bottom:\n            bottom = self.height\n\n        if top < bottom <= self.height:\n            self.scrollregion_start = self.constrain_coords(0, top - 1, ignore_scrolling=True)[1]\n            self.scrollregion_end = self.constrain_coords(0, bottom - 1, ignore_scrolling=True)[1]\n\n            self.set_term_cursor(0, 0)",
  "def csi_clear_tabstop(self, mode: Literal[0, 3] | int = 0):\n        \"\"\"\n        Clear tabstop at current position or if 'mode' is 3, delete all\n        tabstops.\n        \"\"\"\n        if mode == 0:\n            self.set_tabstop(remove=True)\n        elif mode == 3:\n            self.set_tabstop(clear=True)",
  "def csi_get_device_attributes(self, qmark: bool) -> None:\n        \"\"\"\n        Report device attributes (what are you?). In our case, we'll report\n        ourself as a VT102 terminal.\n        \"\"\"\n        if not qmark:\n            self.widget.respond(f\"{ESC}[?6c\")",
  "def csi_status_report(self, mode: Literal[5, 6] | int) -> None:\n        \"\"\"\n        Report various information about the terminal status.\n        Information is queried by 'mode', where possible values are:\n            5 -> device status report\n            6 -> cursor position report\n        \"\"\"\n        if mode == 5:\n            # terminal OK\n            self.widget.respond(f\"{ESC}[0n\")\n        elif mode == 6:\n            x, y = self.term_cursor\n            self.widget.respond(ESC + '[%d;%dR' % (y + 1, x + 1))",
  "def csi_erase_line(self, mode: Literal[0, 1, 2] | int) -> None:\n        \"\"\"\n        Erase current line, modes are:\n            0 -> erase from cursor to end of line.\n            1 -> erase from start of line to cursor.\n            2 -> erase whole line.\n        \"\"\"\n        x, y = self.term_cursor\n\n        if mode == 0:\n            self.erase(self.term_cursor, (self.width - 1, y))\n        elif mode == 1:\n            self.erase((0, y), (x, y))\n        elif mode == 2:\n            self.blank_line(y)",
  "def csi_erase_display(self, mode: Literal[0, 1, 2] | int) -> None:\n        \"\"\"\n        Erase display, modes are:\n            0 -> erase from cursor to end of display.\n            1 -> erase from start to cursor.\n            2 -> erase the whole display.\n        \"\"\"\n        if mode == 0:\n            self.erase(self.term_cursor, (self.width - 1, self.height - 1))\n        if mode == 1:\n            self.erase((0, 0), (self.term_cursor[0] - 1, self.term_cursor[1]))\n        elif mode == 2:\n            self.clear(cursor=self.term_cursor)",
  "def csi_set_keyboard_leds(self, mode: Literal[0, 1, 2, 3] | int = 0) -> None:\n        \"\"\"\n        Set keyboard LEDs, modes are:\n            0 -> clear all LEDs\n            1 -> set scroll lock LED\n            2 -> set num lock LED\n            3 -> set caps lock LED\n\n        This currently just emits a signal, so it can be processed by another\n        widget or the main application.\n        \"\"\"\n        states = {\n            0: 'clear',\n            1: 'scroll_lock',\n            2: 'num_lock',\n            3: 'caps_lock',\n        }\n\n        if mode in states:\n            self.widget.leds(states[mode])",
  "def clear(self, cursor: tuple[int, int] | None = None) -> None:\n        \"\"\"\n        Clears the whole terminal screen and resets the cursor position\n        to (0, 0) or to the coordinates given by 'cursor'.\n        \"\"\"\n        self.term = [self.empty_line() for _ in range(self.height)]\n\n        if cursor is None:\n            self.set_term_cursor(0, 0)\n        else:\n            self.set_term_cursor(*cursor)",
  "def cols(self) -> int:\n        return self.width",
  "def rows(self) -> int:\n        return self.height",
  "def content(\n        self,\n        trim_left: int = 0,\n        trim_right: int = 0,\n        cols: int | None = None,\n        rows: int | None = None,\n        attr=None,\n    ):\n        if self.scrolling_up == 0:\n            yield from self.term\n        else:\n            buf = self.scrollback_buffer + self.term\n            yield from buf[-(self.height+self.scrolling_up):-self.scrolling_up]",
  "def content_delta(self, other):\n        if other is self:\n            return [self.cols()]*self.rows()\n        return self.content()",
  "def __init__(\n        self,\n        command: Sequence[str | bytes] | Callable[[], ...] | None,\n        env: Mapping[str, str] | Iterable[tuple[str, str]] | None = None,\n        main_loop: event_loop.EventLoop | None = None,\n        escape_sequence: str | None = None,\n        encoding: str = 'utf-8',\n    ):\n        \"\"\"\n        A terminal emulator within a widget.\n\n        ``command`` is the command to execute inside the terminal,\n        provided as a list of the command followed by its arguments.\n        If 'command' is None, the command is the current user's shell.\n        You can also provide a callable instead of a command, which will be executed in the subprocess.\n\n        ``env`` can be used to pass custom environment variables. If omitted,\n        os.environ is used.\n\n        ``main_loop`` should be provided, because the canvas state machine needs\n        to act on input from the PTY master device. This object must have\n        watch_file and remove_watch_file methods.\n\n        ``escape_sequence`` is the urwid key symbol which should be used to break\n        out of the terminal widget. If it's not specified, ``ctrl a`` is used.\n\n        ``encoding`` specifies the encoding that is being used when local\n        keypresses in Unicode are encoded into raw bytes. UTF-8 is used by default.\n        Set this to the encoding of your terminal if you need to transmit\n        characters to the spawned process in non-UTF8 encoding.\n        Applies to Python 3.x only.\n\n        .. note::\n\n            If you notice your Terminal instance is not printing unicode glyphs\n            correctly, make sure the global encoding for urwid is set to\n            ``utf8`` with ``urwid.set_encoding(\"utf8\")``. See\n            :ref:`text-encodings` for more details.\n        \"\"\"\n        super().__init__()\n\n        self.escape_sequence: str = escape_sequence or \"ctrl a\"\n\n        self.env = dict(env or os.environ)\n\n        self.command = command or [self.env.get('SHELL', '/bin/sh')]\n\n        self.encoding = encoding\n\n        self.keygrab = False\n        self.last_key: str | None = None\n\n        self.response_buffer: list[str] = []\n\n        self.term_modes = TermModes()\n\n        if main_loop is not None:\n            self.main_loop = main_loop\n        else:\n            self.main_loop = event_loop.SelectEventLoop()\n\n        self.master: int | None = None\n        self.pid: int | None = None\n\n        self.width: int | None = None\n        self.height: int | None = None\n        self.term: TermCanvas | None = None\n        self.has_focus = False\n        self.terminated = False",
  "def get_cursor_coords(self, size: tuple[int, int]) -> tuple[int, int] | None:\n        \"\"\"Return the cursor coordinates for this terminal\n        \"\"\"\n        if self.term is None:\n            return None\n\n        # temporarily set width/height to figure out the new cursor position\n        # given the provided width/height\n        orig_width, orig_height = self.term.width, self.term.height\n\n        self.term.width = size[0]\n        self.term.height = size[1]\n\n        x, y = self.term.constrain_coords(\n            self.term.term_cursor[0],\n            self.term.term_cursor[1],\n        )\n\n        self.term.width, self.term.height = orig_width, orig_height\n\n        return (x, y)",
  "def spawn(self) -> None:\n        env = self.env\n        env['TERM'] = 'linux'\n\n        self.pid, self.master = pty.fork()\n\n        if self.pid == 0:\n            if callable(self.command):\n                try:\n                    try:\n                        self.command()\n                    except:\n                        sys.stderr.write(traceback.format_exc())\n                        sys.stderr.flush()\n                finally:\n                    os._exit(0)\n            else:\n                os.execvpe(self.command[0], self.command, env)\n\n        if self.main_loop is None:\n            fcntl.fcntl(self.master, fcntl.F_SETFL, os.O_NONBLOCK)\n\n        atexit.register(self.terminate)",
  "def terminate(self) -> None:\n        if self.terminated:\n            return\n\n        self.terminated = True\n        self.remove_watch()\n        self.change_focus(False)\n\n        if self.pid > 0:\n            self.set_termsize(0, 0)\n            for sig in (signal.SIGHUP, signal.SIGCONT, signal.SIGINT, signal.SIGTERM, signal.SIGKILL):\n                try:\n                    os.kill(self.pid, sig)\n                    pid, status = os.waitpid(self.pid, os.WNOHANG)\n                except OSError:\n                    break\n\n                if pid == 0:\n                    break\n                time.sleep(0.1)\n            try:\n                os.waitpid(self.pid, 0)\n            except OSError:\n                pass\n\n            os.close(self.master)",
  "def beep(self) -> None:\n        self._emit('beep')",
  "def leds(self, which: Literal['clear', 'scroll_lock', 'num_lock', 'caps_lock']) -> None:\n        self._emit('leds', which)",
  "def respond(self, string: str) -> None:\n        \"\"\"\n        Respond to the underlying application with 'string'.\n        \"\"\"\n        self.response_buffer.append(string)",
  "def flush_responses(self) -> None:\n        for string in self.response_buffer:\n            os.write(self.master, string.encode('ascii'))\n        self.response_buffer = []",
  "def set_termsize(self, width: int, height: int) -> None:\n        winsize = struct.pack(\"HHHH\", height, width, 0, 0)\n        fcntl.ioctl(self.master, termios.TIOCSWINSZ, winsize)",
  "def touch_term(self, width: int, height: int) -> None:\n        process_opened = False\n\n        if self.pid is None:\n            self.spawn()\n            process_opened = True\n\n        if self.width == width and self.height == height:\n            return\n\n        self.set_termsize(width, height)\n\n        if not self.term:\n            self.term = TermCanvas(width, height, self)\n        else:\n            self.term.resize(width, height)\n\n        self.width = width\n        self.height = height\n\n        if process_opened:\n            self.add_watch()\n\n        self._emit(\"resize\", (width, height))",
  "def set_title(self, title) -> None:\n        self._emit('title', title)",
  "def change_focus(self, has_focus) -> None:\n        \"\"\"\n        Ignore SIGINT if this widget has focus.\n        \"\"\"\n        if self.terminated:\n            return\n\n        self.has_focus = has_focus\n\n        if self.term is not None:\n            self.term.has_focus = has_focus\n            self.term.set_term_cursor()\n\n        if has_focus:\n            self.old_tios = RealTerminal().tty_signal_keys()\n            RealTerminal().tty_signal_keys(*(['undefined'] * 5))\n        else:\n            if hasattr(self, \"old_tios\"):\n                RealTerminal().tty_signal_keys(*self.old_tios)",
  "def render(self, size: tuple[int, int], focus: bool = False):\n        if not self.terminated:\n            self.change_focus(focus)\n\n            width, height = size\n            self.touch_term(width, height)\n\n            if self.main_loop is None:\n                self.feed()\n\n        return self.term",
  "def add_watch(self) -> None:\n        if self.main_loop is None:\n            return\n        self.main_loop.watch_file(self.master, self.feed)",
  "def remove_watch(self) -> None:\n        if self.main_loop is None:\n            return\n        self.main_loop.remove_watch_file(self.master)",
  "def wait_and_feed(self, timeout: float = 1.0) -> None:\n        while True:\n            try:\n                select.select([self.master], [], [], timeout)\n                break\n            except OSError as e:\n                if e.args[0] != 4:\n                    raise\n        self.feed()",
  "def feed(self) -> None:\n        data = EOF\n\n        try:\n            data = os.read(self.master, 4096)\n        except OSError as e:\n            if e.errno == errno.EIO:  # EIO, child terminated\n                data = EOF\n            elif e.errno == errno.EWOULDBLOCK:  # empty buffer\n                return\n            else:\n                raise\n\n        if data == EOF:\n            self.terminate()\n            self._emit('closed')\n            return\n\n        self.term.addstr(data)\n\n        self.flush_responses()",
  "def keypress(self, size: tuple[int, int], key: str) -> str | None:\n        if self.terminated:\n            return key\n\n        if key == \"begin paste\" or key == \"end paste\":\n            if self.term_modes.bracketed_paste:\n                pass  # passthrough bracketed paste sequences\n            else:  # swallow bracketed paste sequences\n                self.last_key = key\n                return None\n            \n        if key == \"window resize\":\n            width, height = size\n            self.touch_term(width, height)\n            return None\n\n        if self.last_key == self.escape_sequence and key == self.escape_sequence:\n            # escape sequence pressed twice...\n            self.last_key = key\n            self.keygrab = True\n            # ... so pass it to the terminal\n        elif self.keygrab:\n            if self.escape_sequence == key:\n                # stop grabbing the terminal\n                self.keygrab = False\n                self.last_key = key\n                return None\n        else:\n            if key == 'page up':\n                self.term.scroll_buffer()\n                self.last_key = key\n                self._invalidate()\n                return None\n\n            if key == 'page down':\n                self.term.scroll_buffer(up=False)\n                self.last_key = key\n                self._invalidate()\n                return None\n\n            if self.last_key == self.escape_sequence and key != self.escape_sequence:\n                # hand down keypress directly after ungrab.\n                self.last_key = key\n                return key\n\n            if self.escape_sequence == key:\n                # start grabbing the terminal\n                self.keygrab = True\n                self.last_key = key\n                return None\n\n            if self._command_map[key] is None or key == 'enter':\n                # printable character or escape sequence means:\n                # lock in terminal...\n                self.keygrab = True\n                # ... and do key processing\n            else:\n                # hand down keypress\n                self.last_key = key\n                return key\n\n        self.last_key = key\n\n        self.term.scroll_buffer(reset=True)\n\n        if key.startswith(\"ctrl \"):\n            if key[-1].islower():\n                key = chr(ord(key[-1]) - ord('a') + 1)\n            else:\n                key = chr(ord(key[-1]) - ord('A') + 1)\n        else:\n            if self.term_modes.keys_decckm and key in KEY_TRANSLATIONS_DECCKM:\n                key = KEY_TRANSLATIONS_DECCKM[key]\n            else:\n                key = KEY_TRANSLATIONS.get(key, key)\n\n        # ENTER transmits both a carriage return and linefeed in LF/NL mode.\n        if self.term_modes.lfnl and key == \"\\r\":\n            key += \"\\n\"\n\n        os.write(self.master, key.encode(self.encoding, 'ignore'))\n\n        return None",
  "def _defaulter(color: int | None, colors: int) -> str:\n            if color is None:\n                return 'default'\n            # Note: we can't detect 88 color mode\n            if color > 255 or colors == 2**24:\n                return _color_desc_true(color)\n            if color > 15 or colors == 256:\n                return _color_desc_256(color)\n            return _BASIC_COLORS[color]",
  "class LCDScreen(BaseScreen):\n    def set_terminal_properties(self, colors=None, bright_is_bold=None,\n        has_underline=None):\n        pass\n\n    def set_mouse_tracking(self, enable=True):\n        pass\n\n    def set_input_timeouts(self, *args):\n        pass\n\n    def reset_default_terminal_palette(self, *args):\n        pass\n\n    def draw_screen(self, size, r ):\n        pass\n\n    def clear(self):\n        pass\n\n    def get_cols_rows(self):\n        return self.DISPLAY_SIZE",
  "class CFLCDScreen(LCDScreen):\n    \"\"\"\n    Common methods for Crystal Fontz LCD displays\n    \"\"\"\n    KEYS = [None, # no key with code 0\n        'up_press', 'down_press', 'left_press',\n        'right_press', 'enter_press', 'exit_press',\n        'up_release', 'down_release', 'left_release',\n        'right_release', 'enter_release', 'exit_release',\n        'ul_press', 'ur_press', 'll_press', 'lr_press',\n        'ul_release', 'ur_release', 'll_release', 'lr_release']\n    CMD_PING = 0\n    CMD_VERSION = 1\n    CMD_CLEAR = 6\n    CMD_CGRAM = 9\n    CMD_CURSOR_POSITION = 11 # data = [col, row]\n    CMD_CURSOR_STYLE = 12 # data = [style (0-4)]\n    CMD_LCD_CONTRAST = 13 # data = [contrast (0-255)]\n    CMD_BACKLIGHT = 14 # data = [power (0-100)]\n    CMD_LCD_DATA = 31 # data = [col, row] + text\n    CMD_GPO = 34 # data = [pin(0-12), value(0-100)]\n\n    # sent from device\n    CMD_KEY_ACTIVITY = 0x80\n    CMD_ACK = 0x40  # in high two bits ie. & 0xc0\n\n    CURSOR_NONE = 0\n    CURSOR_BLINKING_BLOCK = 1\n    CURSOR_UNDERSCORE = 2\n    CURSOR_BLINKING_BLOCK_UNDERSCORE = 3\n    CURSOR_INVERTING_BLINKING_BLOCK = 4\n\n    MAX_PACKET_DATA_LENGTH = 22\n\n    colors = 1\n    has_underline = False\n\n    def __init__(self, device_path: str, baud: int):\n        \"\"\"\n        device_path -- eg. '/dev/ttyUSB0'\n        baud -- baud rate\n        \"\"\"\n        super().__init__()\n        self.device_path = device_path\n        from serial import Serial\n        self._device = Serial(device_path, baud, timeout=0)\n        self._unprocessed = bytearray()\n\n    @classmethod\n    def get_crc(cls, buf: bytearray) -> int:\n        # This seed makes the output of this shift based algorithm match\n        # the table based algorithm. The center 16 bits of the 32-bit\n        # \"newCRC\" are used for the CRC. The MSB of the lower byte is used\n        # to see what bit was shifted out of the center 16 bit CRC\n        # accumulator (\"carry flag analog\");\n        new_crc = 0x00F32100\n        for byte in buf:\n            # Push this byte\u2019s bits through a software\n            # implementation of a hardware shift & xor.\n            for bit_count in range(8):\n                # Shift the CRC accumulator\n                new_crc >>= 1\n                # The new MSB of the CRC accumulator comes\n                # from the LSB of the current data byte.\n                if byte & (0x01 << bit_count):\n                    new_crc |= 0x00800000\n                # If the low bit of the current CRC accumulator was set\n                # before the shift, then we need to XOR the accumulator\n                # with the polynomial (center 16 bits of 0x00840800)\n                if new_crc & 0x00000080:\n                    new_crc ^= 0x00840800\n        # All the data has been done. Do 16 more bits of 0 data.\n        for bit_count in range(16):\n            # Shift the CRC accumulator\n            new_crc >>= 1\n            # If the low bit of the current CRC accumulator was set\n            # before the shift we need to XOR the accumulator with\n            # 0x00840800.\n            if new_crc & 0x00000080:\n                new_crc ^= 0x00840800\n        # Return the center 16 bits, making this CRC match the one\u2019s\n        # complement that is sent in the packet.\n        return ((~new_crc) >> 8) & 0xffff\n\n    def _send_packet(self, command, data):\n        \"\"\"\n        low-level packet sending.\n        Following the protocol requires waiting for ack packet between\n        sending each packet to the device.\n        \"\"\"\n        buf = chr(command) + chr(len(data)) + data\n        crc = self.get_crc(buf)\n        buf = buf + chr(crc & 0xff) + chr(crc >> 8)\n        self._device.write(buf)\n\n    def _read_packet(self) -> tuple[int, bytearray] | None:\n        \"\"\"\n        low-level packet reading.\n        returns (command/report code, data) or None\n\n        This method stored data read and tries to resync when bad data\n        is received.\n        \"\"\"\n        # pull in any new data available\n        self._unprocessed += self._device.read()\n        while True:\n            try:\n                command, data, unprocessed = self._parse_data(self._unprocessed)\n                self._unprocessed = unprocessed\n                return command, data\n            except self.MoreDataRequired:\n                return None\n            except self.InvalidPacket:\n                # throw out a byte and try to parse again\n                self._unprocessed = self._unprocessed[1:]\n\n    class InvalidPacket(Exception):\n        pass\n\n    class MoreDataRequired(Exception):\n        pass\n\n    @classmethod\n    def _parse_data(cls, data: bytearray) -> tuple[int, bytearray, bytearray]:\n        \"\"\"\n        Try to read a packet from the start of data, returning\n        (command/report code, packet_data, remaining_data)\n        or raising InvalidPacket or MoreDataRequired\n        \"\"\"\n        if len(data) < 2:\n            raise cls.MoreDataRequired\n\n        command: int = data[0]\n        packet_len: int = data[1]\n\n        if packet_len > cls.MAX_PACKET_DATA_LENGTH:\n            raise cls.InvalidPacket(\"length value too large\")\n\n        if len(data) < packet_len + 4:\n            raise cls.MoreDataRequired\n\n        data_end = 2 + packet_len\n        crc = cls.get_crc(data[:data_end])\n        pcrc = ord(data[data_end: data_end + 1]) + (ord(data[data_end + 1: data_end + 2]) << 8)\n        if crc != pcrc:\n            raise cls.InvalidPacket(\"CRC doesn't match\")\n        return command, data[2: data_end], data[data_end + 2:]",
  "class KeyRepeatSimulator:\n    \"\"\"\n    Provide simulated repeat key events when given press and\n    release events.\n\n    If two or more keys are pressed disable repeating until all\n    keys are released.\n    \"\"\"\n    def __init__(self, repeat_delay: float | int, repeat_next: float | int) -> None:\n        \"\"\"\n        repeat_delay -- seconds to wait before starting to repeat keys\n        repeat_next -- time between each repeated key\n        \"\"\"\n        self.repeat_delay = repeat_delay\n        self.repeat_next = repeat_next\n        self.pressed: dict[str, float] = {}\n        self.multiple_pressed = False\n\n    def press(self, key: str) -> None:\n        if self.pressed:\n            self.multiple_pressed = True\n        self.pressed[key] = time.time()\n\n    def release(self, key: str) -> None:\n        if key not in self.pressed:\n            return  # ignore extra release events\n        del self.pressed[key]\n        if not self.pressed:\n            self.multiple_pressed = False\n\n    def next_event(self) -> tuple[float, str] | None:\n        \"\"\"\n        Return (remaining, key) where remaining is the number of seconds\n        (float) until the key repeat event should be sent, or None if no\n        events are pending.\n        \"\"\"\n        if len(self.pressed) != 1 or self.multiple_pressed:\n            return None\n        for key in self.pressed:\n            return max(0., self.pressed[key] + self.repeat_delay - time.time()), key\n        return None\n\n    def sent_event(self) -> None:\n        \"\"\"\n        Cakk this method when you have sent a key repeat event so the\n        timer will be reset for the next event\n        \"\"\"\n        if len(self.pressed) != 1:\n            return  # ignore event that shouldn't have been sent\n        for key in self.pressed:\n            self.pressed[key] = (time.time() - self.repeat_delay + self.repeat_next)\n            return",
  "class CF635Screen(CFLCDScreen):\n    \"\"\"\n    Crystal Fontz 635 display\n\n    20x4 character display + cursor\n    no foreground/background colors or settings supported\n\n    see CGROM for list of close unicode matches to characters available\n\n    6 button input\n    up, down, left, right, enter (check mark), exit (cross)\n    \"\"\"\n    DISPLAY_SIZE = (20, 4)\n\n    # \u2460 through \u2467 are programmable CGRAM (chars 0-7, repeated at 8-15)\n    # double arrows (\u21d1\u21d3) appear as double arrowheads (chars 18, 19)\n    # \u2474 resembles a bell\n    # \u2475 resembles a filled-in \"Y\"\n    # \u2476 is the letters \"Pt\" together\n    # partial blocks (\u2587\u2586\u2584\u2583\u2581) are actually shorter versions of (\u2589\u258b\u258c\u258d\u258f)\n    #   both groups are intended to draw horizontal bars with pixel\n    #   precision, use \u2587*[\u2586\u2584\u2583\u2581]? for a thin bar or \u2589*[\u258b\u258c\u258d\u258f]? for a thick bar\n    CGROM = (\n        \"\u2460\u2461\u2462\u2463\u2464\u2465\u2466\u2467\u2460\u2461\u2462\u2463\u2464\u2465\u2466\u2467\"\n        \"\u25ba\u25c4\u21d1\u21d3\u00ab\u00bb\u2196\u2197\u2199\u2198\u25b2\u25bc\u21b2^\u02c7\u2588\"\n        \" !\\\"#\u00a4%&'()*+,-./\"\n        \"0123456789:;<=>?\"\n        \"\u00a1ABCDEFGHIJKLMNO\"\n        \"PQRSTUVWXYZ\u00c4\u00d6\u00d1\u00dc\u00a7\"\n        \"\u00bfabcdefghijklmno\"\n        \"pqrstuvwxyz\u00e4\u00f6\u00f1\u00fc\u00e0\"\n        \"\u2070\u00b9\u00b2\u00b3\u2074\u2075\u2076\u2077\u2078\u2079\u00bd\u00bc\u00b1\u2265\u2264\u03bc\"\n        \"\u266a\u266b\u2474\u2665\u2666\u2475\u231c\u231f\u201c\u201d()\u03b1\u025b\u03b4\u221e\"\n        \"@\u00a3$\u00a5\u00e8\u00e9\u00f9\u00ec\u00f2\u00c7\u1d3e\u00d8\u00f8\u02b3\u00c5\u00e5\"\n        \"\u2302\u00a2\u03a6\u03c4\u03bb\u03a9\u03c0\u03a8\u03a3\u03b8\u039e\u2648\u00c6\u00e6\u00df\u00c9\"\n        \"\u0393\u039b\u03a0\u03d2_\u00c8\u00ca\u00ea\u00e7\u011f\u015e\u015f\u0130\u03b9~\u25ca\"\n        \"\u2587\u2586\u2584\u2583\u2581\u0192\u2589\u258b\u258c\u258d\u258f\u2476\u25fd\u25aa\u2191\u2192\"\n        \"\u2193\u2190\u00c1\u00cd\u00d3\u00da\u00dd\u00e1\u00ed\u00f3\u00fa\u00fd\u00d4\u00f4\u016e\u016f\"\n        r\"\u010c\u0114\u0158\u0160\u017d\u010d\u0115\u0159\u0161\u017e[\\]{|}\")\n\n    cursor_style = CFLCDScreen.CURSOR_INVERTING_BLINKING_BLOCK\n\n    def __init__(\n        self,\n        device_path: str,\n        baud: int = 115200,\n        repeat_delay: float = 0.5,\n        repeat_next: float = 0.125,\n        key_map: Iterable[str] = ('up', 'down', 'left', 'right', 'enter', 'esc'),\n    ):\n        \"\"\"\n        device_path -- eg. '/dev/ttyUSB0'\n        baud -- baud rate\n        repeat_delay -- seconds to wait before starting to repeat keys\n        repeat_next -- time between each repeated key\n        key_map -- the keys to send for this device's buttons\n        \"\"\"\n        super().__init__(device_path, baud)\n\n        self.repeat_delay = repeat_delay\n        self.repeat_next = repeat_next\n        self.key_repeat = KeyRepeatSimulator(repeat_delay, repeat_next)\n        self.key_map = tuple(key_map)\n\n        self._last_command = None\n        self._last_command_time = 0\n        self._command_queue = []\n        self._screen_buf = None\n        self._previous_canvas = None\n        self._update_cursor = False\n\n    def get_input_descriptors(self):\n        \"\"\"\n        return the fd from our serial device so we get called\n        on input and responses\n        \"\"\"\n        return [self._device.fd]\n\n    def get_input_nonblocking(self) -> tuple[None, list[str], list[int]]:\n        \"\"\"\n        Return a (next_input_timeout, keys_pressed, raw_keycodes)\n        tuple.\n\n        The protocol for our device requires waiting for acks between\n        each command, so this method responds to those as well as key\n        press and release events.\n\n        Key repeat events are simulated here as the device doesn't send\n        any for us.\n\n        raw_keycodes are the bytes of messages we received, which might\n        not seem to have any correspondence to keys_pressed.\n        \"\"\"\n        data_input: list[str] = []\n        raw_data_input: list[int] = []\n        timeout = None\n\n        packet = self._read_packet()\n        while packet:\n            command, data = packet\n\n            if command == self.CMD_KEY_ACTIVITY and data:\n                d0 = data[0]\n                if 1 <= d0 <= 12:\n                    release = d0 > 6\n                    keycode = d0 - (release * 6) - 1\n                    key = self.key_map[keycode]\n                    if release:\n                        self.key_repeat.release(key)\n                    else:\n                        data_input.append(key)\n                        self.key_repeat.press(key)\n                    raw_data_input.append(d0)\n\n            elif command & 0xc0 == 0x40:  # \"ACK\"\n                if command & 0x3f == self._last_command:\n                    self._send_next_command()\n\n            packet = self._read_packet()\n\n        next_repeat = self.key_repeat.next_event()\n        if next_repeat:\n            timeout, key = next_repeat\n            if not timeout:\n                data_input.append(key)\n                self.key_repeat.sent_event()\n                timeout = None\n\n        return timeout, data_input, raw_data_input\n\n    def _send_next_command(self) -> None:\n        \"\"\"\n        send out the next command in the queue\n        \"\"\"\n        if not self._command_queue:\n            self._last_command = None\n            return\n        command, data = self._command_queue.pop(0)\n        self._send_packet(command, data)\n        self._last_command = command # record command for ACK\n        self._last_command_time = time.time()\n\n    def queue_command(self, command: int, data: str) -> None:\n        self._command_queue.append((command, data))\n        # not waiting? send away!\n        if self._last_command is None:\n            self._send_next_command()\n\n    def draw_screen(self, size: tuple[int, int], canvas):\n        assert size == self.DISPLAY_SIZE\n\n        if self._screen_buf:\n            osb = self._screen_buf\n        else:\n            osb = []\n        sb = []\n\n        y = 0\n        for row in canvas.content():\n            text = []\n            for a, cs, run in row:\n                text.append(run)\n            if not osb or osb[y] != text:\n                self.queue_command(self.CMD_LCD_DATA, chr(0) + chr(y) + \"\".join(text))\n            sb.append(text)\n            y += 1\n\n        if (self._previous_canvas and\n                self._previous_canvas.cursor == canvas.cursor and\n                (not self._update_cursor or not canvas.cursor)):\n            pass\n        elif canvas.cursor is None:\n            self.queue_command(self.CMD_CURSOR_STYLE, chr(self.CURSOR_NONE))\n        else:\n            x, y = canvas.cursor\n            self.queue_command(self.CMD_CURSOR_POSITION, chr(x) + chr(y))\n            self.queue_command(self.CMD_CURSOR_STYLE, chr(self.cursor_style))\n\n        self._update_cursor = False\n        self._screen_buf = sb\n        self._previous_canvas = canvas\n\n    def program_cgram(self, index: int, data: Sequence[int]) -> None:\n        \"\"\"\n        Program character data.  Characters available as chr(0) through\n        chr(7), and repeated as chr(8) through chr(15).\n\n        index -- 0 to 7 index of character to program\n\n        data -- list of 8, 6-bit integer values top to bottom with MSB\n        on the left side of the character.\n        \"\"\"\n        assert 0 <= index <= 7\n        assert len(data) == 8\n        self.queue_command(self.CMD_CGRAM, chr(index) + \"\".join([chr(x) for x in data]))\n\n    def set_cursor_style(self, style: Literal[1, 2, 3, 4]) -> None:\n        \"\"\"\n        style -- CURSOR_BLINKING_BLOCK, CURSOR_UNDERSCORE,\n            CURSOR_BLINKING_BLOCK_UNDERSCORE or\n            CURSOR_INVERTING_BLINKING_BLOCK\n        \"\"\"\n        assert 1 <= style <= 4\n        self.cursor_style = style\n        self._update_cursor = True\n\n    def set_backlight(self, value: int) -> None:\n        \"\"\"\n        Set backlight brightness\n\n        value -- 0 to 100\n        \"\"\"\n        assert 0 <= value <= 100\n        self.queue_command(self.CMD_BACKLIGHT, chr(value))\n\n    def set_lcd_contrast(self, value: int) -> None:\n        \"\"\"\n        value -- 0 to 255\n        \"\"\"\n        assert 0 <= value <= 255\n        self.queue_command(self.CMD_LCD_CONTRAST, chr(value))\n\n    def set_led_pin(self, led: Literal[0, 1, 2, 3], rg: Literal[0, 1], value: int):\n        \"\"\"\n        led -- 0 to 3\n        rg -- 0 for red, 1 for green\n        value -- 0 to 100\n        \"\"\"\n        assert 0 <= led <= 3\n        assert rg in (0, 1)\n        assert 0 <= value <= 100\n        self.queue_command(self.CMD_GPO, chr(12 - 2 * led - rg) + chr(value))",
  "def set_terminal_properties(self, colors=None, bright_is_bold=None,\n        has_underline=None):\n        pass",
  "def set_mouse_tracking(self, enable=True):\n        pass",
  "def set_input_timeouts(self, *args):\n        pass",
  "def reset_default_terminal_palette(self, *args):\n        pass",
  "def draw_screen(self, size, r ):\n        pass",
  "def clear(self):\n        pass",
  "def get_cols_rows(self):\n        return self.DISPLAY_SIZE",
  "def __init__(self, device_path: str, baud: int):\n        \"\"\"\n        device_path -- eg. '/dev/ttyUSB0'\n        baud -- baud rate\n        \"\"\"\n        super().__init__()\n        self.device_path = device_path\n        from serial import Serial\n        self._device = Serial(device_path, baud, timeout=0)\n        self._unprocessed = bytearray()",
  "def get_crc(cls, buf: bytearray) -> int:\n        # This seed makes the output of this shift based algorithm match\n        # the table based algorithm. The center 16 bits of the 32-bit\n        # \"newCRC\" are used for the CRC. The MSB of the lower byte is used\n        # to see what bit was shifted out of the center 16 bit CRC\n        # accumulator (\"carry flag analog\");\n        new_crc = 0x00F32100\n        for byte in buf:\n            # Push this byte\u2019s bits through a software\n            # implementation of a hardware shift & xor.\n            for bit_count in range(8):\n                # Shift the CRC accumulator\n                new_crc >>= 1\n                # The new MSB of the CRC accumulator comes\n                # from the LSB of the current data byte.\n                if byte & (0x01 << bit_count):\n                    new_crc |= 0x00800000\n                # If the low bit of the current CRC accumulator was set\n                # before the shift, then we need to XOR the accumulator\n                # with the polynomial (center 16 bits of 0x00840800)\n                if new_crc & 0x00000080:\n                    new_crc ^= 0x00840800\n        # All the data has been done. Do 16 more bits of 0 data.\n        for bit_count in range(16):\n            # Shift the CRC accumulator\n            new_crc >>= 1\n            # If the low bit of the current CRC accumulator was set\n            # before the shift we need to XOR the accumulator with\n            # 0x00840800.\n            if new_crc & 0x00000080:\n                new_crc ^= 0x00840800\n        # Return the center 16 bits, making this CRC match the one\u2019s\n        # complement that is sent in the packet.\n        return ((~new_crc) >> 8) & 0xffff",
  "def _send_packet(self, command, data):\n        \"\"\"\n        low-level packet sending.\n        Following the protocol requires waiting for ack packet between\n        sending each packet to the device.\n        \"\"\"\n        buf = chr(command) + chr(len(data)) + data\n        crc = self.get_crc(buf)\n        buf = buf + chr(crc & 0xff) + chr(crc >> 8)\n        self._device.write(buf)",
  "def _read_packet(self) -> tuple[int, bytearray] | None:\n        \"\"\"\n        low-level packet reading.\n        returns (command/report code, data) or None\n\n        This method stored data read and tries to resync when bad data\n        is received.\n        \"\"\"\n        # pull in any new data available\n        self._unprocessed += self._device.read()\n        while True:\n            try:\n                command, data, unprocessed = self._parse_data(self._unprocessed)\n                self._unprocessed = unprocessed\n                return command, data\n            except self.MoreDataRequired:\n                return None\n            except self.InvalidPacket:\n                # throw out a byte and try to parse again\n                self._unprocessed = self._unprocessed[1:]",
  "class InvalidPacket(Exception):\n        pass",
  "class MoreDataRequired(Exception):\n        pass",
  "def _parse_data(cls, data: bytearray) -> tuple[int, bytearray, bytearray]:\n        \"\"\"\n        Try to read a packet from the start of data, returning\n        (command/report code, packet_data, remaining_data)\n        or raising InvalidPacket or MoreDataRequired\n        \"\"\"\n        if len(data) < 2:\n            raise cls.MoreDataRequired\n\n        command: int = data[0]\n        packet_len: int = data[1]\n\n        if packet_len > cls.MAX_PACKET_DATA_LENGTH:\n            raise cls.InvalidPacket(\"length value too large\")\n\n        if len(data) < packet_len + 4:\n            raise cls.MoreDataRequired\n\n        data_end = 2 + packet_len\n        crc = cls.get_crc(data[:data_end])\n        pcrc = ord(data[data_end: data_end + 1]) + (ord(data[data_end + 1: data_end + 2]) << 8)\n        if crc != pcrc:\n            raise cls.InvalidPacket(\"CRC doesn't match\")\n        return command, data[2: data_end], data[data_end + 2:]",
  "def __init__(self, repeat_delay: float | int, repeat_next: float | int) -> None:\n        \"\"\"\n        repeat_delay -- seconds to wait before starting to repeat keys\n        repeat_next -- time between each repeated key\n        \"\"\"\n        self.repeat_delay = repeat_delay\n        self.repeat_next = repeat_next\n        self.pressed: dict[str, float] = {}\n        self.multiple_pressed = False",
  "def press(self, key: str) -> None:\n        if self.pressed:\n            self.multiple_pressed = True\n        self.pressed[key] = time.time()",
  "def release(self, key: str) -> None:\n        if key not in self.pressed:\n            return  # ignore extra release events\n        del self.pressed[key]\n        if not self.pressed:\n            self.multiple_pressed = False",
  "def next_event(self) -> tuple[float, str] | None:\n        \"\"\"\n        Return (remaining, key) where remaining is the number of seconds\n        (float) until the key repeat event should be sent, or None if no\n        events are pending.\n        \"\"\"\n        if len(self.pressed) != 1 or self.multiple_pressed:\n            return None\n        for key in self.pressed:\n            return max(0., self.pressed[key] + self.repeat_delay - time.time()), key\n        return None",
  "def sent_event(self) -> None:\n        \"\"\"\n        Cakk this method when you have sent a key repeat event so the\n        timer will be reset for the next event\n        \"\"\"\n        if len(self.pressed) != 1:\n            return  # ignore event that shouldn't have been sent\n        for key in self.pressed:\n            self.pressed[key] = (time.time() - self.repeat_delay + self.repeat_next)\n            return",
  "def __init__(\n        self,\n        device_path: str,\n        baud: int = 115200,\n        repeat_delay: float = 0.5,\n        repeat_next: float = 0.125,\n        key_map: Iterable[str] = ('up', 'down', 'left', 'right', 'enter', 'esc'),\n    ):\n        \"\"\"\n        device_path -- eg. '/dev/ttyUSB0'\n        baud -- baud rate\n        repeat_delay -- seconds to wait before starting to repeat keys\n        repeat_next -- time between each repeated key\n        key_map -- the keys to send for this device's buttons\n        \"\"\"\n        super().__init__(device_path, baud)\n\n        self.repeat_delay = repeat_delay\n        self.repeat_next = repeat_next\n        self.key_repeat = KeyRepeatSimulator(repeat_delay, repeat_next)\n        self.key_map = tuple(key_map)\n\n        self._last_command = None\n        self._last_command_time = 0\n        self._command_queue = []\n        self._screen_buf = None\n        self._previous_canvas = None\n        self._update_cursor = False",
  "def get_input_descriptors(self):\n        \"\"\"\n        return the fd from our serial device so we get called\n        on input and responses\n        \"\"\"\n        return [self._device.fd]",
  "def get_input_nonblocking(self) -> tuple[None, list[str], list[int]]:\n        \"\"\"\n        Return a (next_input_timeout, keys_pressed, raw_keycodes)\n        tuple.\n\n        The protocol for our device requires waiting for acks between\n        each command, so this method responds to those as well as key\n        press and release events.\n\n        Key repeat events are simulated here as the device doesn't send\n        any for us.\n\n        raw_keycodes are the bytes of messages we received, which might\n        not seem to have any correspondence to keys_pressed.\n        \"\"\"\n        data_input: list[str] = []\n        raw_data_input: list[int] = []\n        timeout = None\n\n        packet = self._read_packet()\n        while packet:\n            command, data = packet\n\n            if command == self.CMD_KEY_ACTIVITY and data:\n                d0 = data[0]\n                if 1 <= d0 <= 12:\n                    release = d0 > 6\n                    keycode = d0 - (release * 6) - 1\n                    key = self.key_map[keycode]\n                    if release:\n                        self.key_repeat.release(key)\n                    else:\n                        data_input.append(key)\n                        self.key_repeat.press(key)\n                    raw_data_input.append(d0)\n\n            elif command & 0xc0 == 0x40:  # \"ACK\"\n                if command & 0x3f == self._last_command:\n                    self._send_next_command()\n\n            packet = self._read_packet()\n\n        next_repeat = self.key_repeat.next_event()\n        if next_repeat:\n            timeout, key = next_repeat\n            if not timeout:\n                data_input.append(key)\n                self.key_repeat.sent_event()\n                timeout = None\n\n        return timeout, data_input, raw_data_input",
  "def _send_next_command(self) -> None:\n        \"\"\"\n        send out the next command in the queue\n        \"\"\"\n        if not self._command_queue:\n            self._last_command = None\n            return\n        command, data = self._command_queue.pop(0)\n        self._send_packet(command, data)\n        self._last_command = command # record command for ACK\n        self._last_command_time = time.time()",
  "def queue_command(self, command: int, data: str) -> None:\n        self._command_queue.append((command, data))\n        # not waiting? send away!\n        if self._last_command is None:\n            self._send_next_command()",
  "def draw_screen(self, size: tuple[int, int], canvas):\n        assert size == self.DISPLAY_SIZE\n\n        if self._screen_buf:\n            osb = self._screen_buf\n        else:\n            osb = []\n        sb = []\n\n        y = 0\n        for row in canvas.content():\n            text = []\n            for a, cs, run in row:\n                text.append(run)\n            if not osb or osb[y] != text:\n                self.queue_command(self.CMD_LCD_DATA, chr(0) + chr(y) + \"\".join(text))\n            sb.append(text)\n            y += 1\n\n        if (self._previous_canvas and\n                self._previous_canvas.cursor == canvas.cursor and\n                (not self._update_cursor or not canvas.cursor)):\n            pass\n        elif canvas.cursor is None:\n            self.queue_command(self.CMD_CURSOR_STYLE, chr(self.CURSOR_NONE))\n        else:\n            x, y = canvas.cursor\n            self.queue_command(self.CMD_CURSOR_POSITION, chr(x) + chr(y))\n            self.queue_command(self.CMD_CURSOR_STYLE, chr(self.cursor_style))\n\n        self._update_cursor = False\n        self._screen_buf = sb\n        self._previous_canvas = canvas",
  "def program_cgram(self, index: int, data: Sequence[int]) -> None:\n        \"\"\"\n        Program character data.  Characters available as chr(0) through\n        chr(7), and repeated as chr(8) through chr(15).\n\n        index -- 0 to 7 index of character to program\n\n        data -- list of 8, 6-bit integer values top to bottom with MSB\n        on the left side of the character.\n        \"\"\"\n        assert 0 <= index <= 7\n        assert len(data) == 8\n        self.queue_command(self.CMD_CGRAM, chr(index) + \"\".join([chr(x) for x in data]))",
  "def set_cursor_style(self, style: Literal[1, 2, 3, 4]) -> None:\n        \"\"\"\n        style -- CURSOR_BLINKING_BLOCK, CURSOR_UNDERSCORE,\n            CURSOR_BLINKING_BLOCK_UNDERSCORE or\n            CURSOR_INVERTING_BLINKING_BLOCK\n        \"\"\"\n        assert 1 <= style <= 4\n        self.cursor_style = style\n        self._update_cursor = True",
  "def set_backlight(self, value: int) -> None:\n        \"\"\"\n        Set backlight brightness\n\n        value -- 0 to 100\n        \"\"\"\n        assert 0 <= value <= 100\n        self.queue_command(self.CMD_BACKLIGHT, chr(value))",
  "def set_lcd_contrast(self, value: int) -> None:\n        \"\"\"\n        value -- 0 to 255\n        \"\"\"\n        assert 0 <= value <= 255\n        self.queue_command(self.CMD_LCD_CONTRAST, chr(value))",
  "def set_led_pin(self, led: Literal[0, 1, 2, 3], rg: Literal[0, 1], value: int):\n        \"\"\"\n        led -- 0 to 3\n        rg -- 0 for red, 1 for green\n        value -- 0 to 100\n        \"\"\"\n        assert 0 <= led <= 3\n        assert rg in (0, 1)\n        assert 0 <= value <= 100\n        self.queue_command(self.CMD_GPO, chr(12 - 2 * led - rg) + chr(value))",
  "def split_repr(self):\n    \"\"\"\n    Return a helpful description of the object using\n    self._repr_words() and self._repr_attrs() to add\n    to the description.  This function may be used by\n    adding code to your class like this:\n\n    >>> class Foo(object):\n    ...     __repr__ = split_repr\n    ...     def _repr_words(self):\n    ...         return [\"words\", \"here\"]\n    ...     def _repr_attrs(self):\n    ...         return {'attrs': \"appear too\"}\n    >>> Foo()\n    <Foo words here attrs='appear too'>\n    >>> class Bar(Foo):\n    ...     def _repr_words(self):\n    ...         return Foo._repr_words(self) + [\"too\"]\n    ...     def _repr_attrs(self):\n    ...         return dict(Foo._repr_attrs(self), barttr=42)\n    >>> Bar()\n    <Bar words here too attrs='appear too' barttr=42>\n    \"\"\"\n    alist = sorted((str(k), normalize_repr(v)) for k, v in self._repr_attrs().items())\n\n    words = self._repr_words()\n    if not words and not alist:\n        # if we're just going to print the classname fall back\n        # to the previous __repr__ implementation instead\n        return super(self.__class__, self).__repr__()\n    if words and alist: words.append(\"\")\n    return \"<%s %s>\" % (self.__class__.__name__,\n        \" \".join(words) +\n        \" \".join([\"%s=%s\" % itm for itm in alist]))",
  "def normalize_repr(v):\n    \"\"\"\n    Return dictionary repr sorted by keys, leave others unchanged\n\n    >>> normalize_repr({1:2,3:4,5:6,7:8})\n    '{1: 2, 3: 4, 5: 6, 7: 8}'\n    >>> normalize_repr('foo')\n    \"'foo'\"\n    \"\"\"\n    if isinstance(v, dict):\n        items = sorted((repr(k), repr(v)) for k, v in v.items())\n\n        return f\"{{{', '.join([('%s: %s' % itm) for itm in items])}}}\"\n\n    return repr(v)",
  "def remove_defaults(d, fn):\n    \"\"\"\n    Remove keys in d that are set to the default values from\n    fn.  This method is used to unclutter the _repr_attrs()\n    return value.\n\n    d will be modified by this function.\n\n    Returns d.\n\n    >>> class Foo(object):\n    ...     def __init__(self, a=1, b=2):\n    ...         self.values = a, b\n    ...     __repr__ = split_repr\n    ...     def _repr_words(self):\n    ...         return [\"object\"]\n    ...     def _repr_attrs(self):\n    ...         d = dict(a=self.values[0], b=self.values[1])\n    ...         return remove_defaults(d, Foo.__init__)\n    >>> Foo(42, 100)\n    <Foo object a=42 b=100>\n    >>> Foo(10, 2)\n    <Foo object a=10>\n    >>> Foo()\n    <Foo object>\n    \"\"\"\n    args, varargs, varkw, defaults, _, _, _ = getfullargspec(fn)\n\n    # ignore *varargs and **kwargs\n    if varkw:\n        del args[-1]\n    if varargs:\n        del args[-1]\n\n    # create a dictionary of args with default values\n    ddict = dict(list(zip(args[len(args) - len(defaults):], defaults)))\n\n    for k in list(d.keys()):\n        if k in ddict:\n            # remove values that match their defaults\n            if ddict[k] == d[k]:\n                del d[k]\n\n    return d",
  "def _test():\n    import doctest\n    doctest.testmod()",
  "def _call_modified(fn: Callable[ArgSpec, Ret]) -> Callable[ArgSpec, Ret]:\n    @functools.wraps(fn)\n    def call_modified_wrapper(self: MonitoredList, *args, **kwargs):\n        rval = fn(self, *args, **kwargs)\n        self._modified()\n        return rval\n    return call_modified_wrapper",
  "class MonitoredList(list):\n    \"\"\"\n    This class can trigger a callback any time its contents are changed\n    with the usual list operations append, extend, etc.\n    \"\"\"\n\n    def _modified(self):\n        pass\n\n    def set_modified_callback(self, callback):\n        \"\"\"\n        Assign a callback function with no parameters that is called any\n        time the list is modified.  Callback's return value is ignored.\n\n        >>> import sys\n        >>> ml = MonitoredList([1,2,3])\n        >>> ml.set_modified_callback(lambda: sys.stdout.write(\"modified\\\\n\"))\n        >>> ml\n        MonitoredList([1, 2, 3])\n        >>> ml.append(10)\n        modified\n        >>> len(ml)\n        4\n        >>> ml += [11, 12, 13]\n        modified\n        >>> ml[:] = ml[:2] + ml[-2:]\n        modified\n        >>> ml\n        MonitoredList([1, 2, 12, 13])\n        \"\"\"\n        self._modified = callback\n\n    def __repr__(self):\n        return f\"{self.__class__.__name__}({list(self)!r})\"\n\n    __add__ = _call_modified(list.__add__)\n    __delitem__ = _call_modified(list.__delitem__)\n\n    __iadd__ = _call_modified(list.__iadd__)\n    __imul__ = _call_modified(list.__imul__)\n    __rmul__ = _call_modified(list.__rmul__)\n    __setitem__ = _call_modified(list.__setitem__)\n\n    append = _call_modified(list.append)\n    extend = _call_modified(list.extend)\n    insert = _call_modified(list.insert)\n    pop = _call_modified(list.pop)\n    remove = _call_modified(list.remove)\n    reverse = _call_modified(list.reverse)\n    sort = _call_modified(list.sort)\n    if hasattr(list, 'clear'):\n        clear = _call_modified(list.clear)",
  "class MonitoredFocusList(MonitoredList):\n    \"\"\"\n    This class can trigger a callback any time its contents are modified,\n    before and/or after modification, and any time the focus index is changed.\n    \"\"\"\n    def __init__(self, *argl, **argd):\n        \"\"\"\n        This is a list that tracks one item as the focus item.  If items\n        are inserted or removed it will update the focus.\n\n        >>> ml = MonitoredFocusList([10, 11, 12, 13, 14], focus=3)\n        >>> ml\n        MonitoredFocusList([10, 11, 12, 13, 14], focus=3)\n        >>> del(ml[1])\n        >>> ml\n        MonitoredFocusList([10, 12, 13, 14], focus=2)\n        >>> ml[:2] = [50, 51, 52, 53]\n        >>> ml\n        MonitoredFocusList([50, 51, 52, 53, 13, 14], focus=4)\n        >>> ml[4] = 99\n        >>> ml\n        MonitoredFocusList([50, 51, 52, 53, 99, 14], focus=4)\n        >>> ml[:] = []\n        >>> ml\n        MonitoredFocusList([], focus=None)\n        \"\"\"\n        focus = argd.pop('focus', 0)\n\n        super().__init__(*argl, **argd)\n\n        self._focus = focus\n        self._focus_modified = lambda ml, indices, new_items: None\n\n    def __repr__(self):\n        return f\"{self.__class__.__name__}({list(self)!r}, focus={self.focus!r})\"\n\n    @property\n    def focus(self) -> int | None:\n        \"\"\"\n        Get/set the focus index.  This value is read as None when the list\n        is empty, and may only be set to a value between 0 and len(self)-1\n        or an IndexError will be raised.\n\n        Return the index of the item \"in focus\" or None if\n        the list is empty.\n\n        >>> MonitoredFocusList([1,2,3], focus=2).focus\n        2\n        >>> MonitoredFocusList().focus\n        \"\"\"\n        if not self:\n            return None\n        return self._focus\n\n    @focus.setter\n    def focus(self, index: int) -> None:\n        \"\"\"\n        index -- index into this list, any index out of range will\n            raise an IndexError, except when the list is empty and\n            the index passed is ignored.\n\n        This function may call self._focus_changed when the focus\n        is modified, passing the new focus position to the\n        callback just before changing the old focus setting.\n        That method may be overridden on the\n        instance with set_focus_changed_callback().\n\n        >>> ml = MonitoredFocusList([9, 10, 11])\n        >>> ml.focus = 2; ml.focus\n        2\n        >>> ml.focus = 0; ml.focus\n        0\n        >>> ml.focus = -2\n        Traceback (most recent call last):\n        ...\n        IndexError: focus index is out of range: -2\n        \"\"\"\n        if not self:\n            self._focus = 0\n            return\n        if index < 0 or index >= len(self):\n            raise IndexError(f'focus index is out of range: {index}')\n        if index != int(index):\n            raise IndexError(f'invalid focus index: {index}')\n        index = int(index)\n        if index != self._focus:\n            self._focus_changed(index)\n        self._focus = index\n\n    def _get_focus(self) -> int | None:\n        warnings.warn(\n            f\"method `{self.__class__.__name__}._get_focus` is deprecated, \"\n            f\"please use `{self.__class__.__name__}.focus` property\",\n            DeprecationWarning,\n            stacklevel=3,\n        )\n        return self.focus\n\n    def _set_focus(self, index: int) -> None:\n        warnings.warn(\n            f\"method `{self.__class__.__name__}._set_focus` is deprecated, \"\n            f\"please use `{self.__class__.__name__}.focus` property\",\n            DeprecationWarning,\n            stacklevel=3,\n        )\n        self.focus = index\n\n    def _focus_changed(self, new_focus: int):\n        pass\n\n    def set_focus_changed_callback(self, callback: Callable[[int], typing.Any]) -> None:\n        \"\"\"\n        Assign a callback to be called when the focus index changes\n        for any reason.  The callback is in the form:\n\n        callback(new_focus)\n        new_focus -- new focus index\n\n        >>> import sys\n        >>> ml = MonitoredFocusList([1,2,3], focus=1)\n        >>> ml.set_focus_changed_callback(lambda f: sys.stdout.write(\"focus: %d\\\\n\" % (f,)))\n        >>> ml\n        MonitoredFocusList([1, 2, 3], focus=1)\n        >>> ml.append(10)\n        >>> ml.insert(1, 11)\n        focus: 2\n        >>> ml\n        MonitoredFocusList([1, 11, 2, 3, 10], focus=2)\n        >>> del ml[:2]\n        focus: 0\n        >>> ml[:0] = [12, 13, 14]\n        focus: 3\n        >>> ml.focus = 5\n        focus: 5\n        >>> ml\n        MonitoredFocusList([12, 13, 14, 2, 3, 10], focus=5)\n        \"\"\"\n        self._focus_changed = callback\n\n    def _validate_contents_modified(self, indices, new_items):\n        return None\n\n    def set_validate_contents_modified(self, callback):\n        \"\"\"\n        Assign a callback function to handle validating changes to the list.\n        This may raise an exception if the change should not be performed.\n        It may also return an integer position to be the new focus after the\n        list is modified, or None to use the default behaviour.\n\n        The callback is in the form:\n\n        callback(indices, new_items)\n        indices -- a (start, stop, step) tuple whose range covers the\n            items being modified\n        new_items -- an iterable of items replacing those at range(*indices),\n            empty if items are being removed, if step==1 this list may\n            contain any number of items\n        \"\"\"\n        self._validate_contents_modified = callback\n\n    def _adjust_focus_on_contents_modified(self, slc: slice, new_items=()) -> int:\n        \"\"\"\n        Default behaviour is to move the focus to the item following\n        any removed items, unless that item was simply replaced.\n\n        Failing that choose the last item in the list.\n\n        returns focus position for after change is applied\n        \"\"\"\n        num_new_items = len(new_items)\n        start, stop, step = indices = slc.indices(len(self))\n        num_removed = len(list(range(*indices)))\n\n        focus = self._validate_contents_modified(indices, new_items)\n        if focus is not None:\n            return focus\n\n        focus = self._focus\n        if step == 1:\n            if start + num_new_items <= focus < stop:\n                focus = stop\n            # adjust for added/removed items\n            if stop <= focus:\n                focus += num_new_items - (stop - start)\n\n        else:\n            if not num_new_items:\n                # extended slice being removed\n                if focus in range(start, stop, step):\n                    focus += 1\n\n                # adjust for removed items\n                focus -= len(list(range(start, min(focus, stop), step)))\n\n        return min(focus, len(self) + num_new_items - num_removed -1)\n\n    # override all the list methods that modify the list\n\n    def __delitem__(self, y: int | slice):\n        \"\"\"\n        >>> ml = MonitoredFocusList([0,1,2,3,4], focus=2)\n        >>> del ml[3]; ml\n        MonitoredFocusList([0, 1, 2, 4], focus=2)\n        >>> del ml[-1]; ml\n        MonitoredFocusList([0, 1, 2], focus=2)\n        >>> del ml[0]; ml\n        MonitoredFocusList([1, 2], focus=1)\n        >>> del ml[1]; ml\n        MonitoredFocusList([1], focus=0)\n        >>> del ml[0]; ml\n        MonitoredFocusList([], focus=None)\n        >>> ml = MonitoredFocusList([5,4,6,4,5,4,6,4,5], focus=4)\n        >>> del ml[1::2]; ml\n        MonitoredFocusList([5, 6, 5, 6, 5], focus=2)\n        >>> del ml[::2]; ml\n        MonitoredFocusList([6, 6], focus=1)\n        >>> ml = MonitoredFocusList([0,1,2,3,4,6,7], focus=2)\n        >>> del ml[-2:]; ml\n        MonitoredFocusList([0, 1, 2, 3, 4], focus=2)\n        >>> del ml[-4:-2]; ml\n        MonitoredFocusList([0, 3, 4], focus=1)\n        >>> del ml[:]; ml\n        MonitoredFocusList([], focus=None)\n        \"\"\"\n        if isinstance(y, slice):\n            focus = self._adjust_focus_on_contents_modified(y)\n        else:\n            focus = self._adjust_focus_on_contents_modified(slice(y, y+1 or None))\n        rval = super().__delitem__(y)\n        self.focus = focus\n        return rval\n\n    def __setitem__(self, i: int | slice, y):\n        \"\"\"\n        >>> def modified(indices, new_items):\n        ...     print(\"range%r <- %r\" % (indices, new_items))\n        >>> ml = MonitoredFocusList([0,1,2,3], focus=2)\n        >>> ml.set_validate_contents_modified(modified)\n        >>> ml[0] = 9\n        range(0, 1, 1) <- [9]\n        >>> ml[2] = 6\n        range(2, 3, 1) <- [6]\n        >>> ml.focus\n        2\n        >>> ml[-1] = 8\n        range(3, 4, 1) <- [8]\n        >>> ml\n        MonitoredFocusList([9, 1, 6, 8], focus=2)\n        >>> ml[1::2] = [12, 13]\n        range(1, 4, 2) <- [12, 13]\n        >>> ml[::2] = [10, 11]\n        range(0, 4, 2) <- [10, 11]\n        >>> ml[-3:-1] = [21, 22, 23]\n        range(1, 3, 1) <- [21, 22, 23]\n        >>> ml\n        MonitoredFocusList([10, 21, 22, 23, 13], focus=2)\n        >>> ml[:] = []\n        range(0, 5, 1) <- []\n        >>> ml\n        MonitoredFocusList([], focus=None)\n        \"\"\"\n        if isinstance(i, slice):\n            focus = self._adjust_focus_on_contents_modified(i, y)\n        else:\n            focus = self._adjust_focus_on_contents_modified(slice(i, i+1 or None), [y])\n        rval = super().__setitem__(i, y)\n        self.focus = focus\n        return rval\n\n    def __imul__(self, n: int):\n        \"\"\"\n        >>> def modified(indices, new_items):\n        ...     print(\"range%r <- %r\" % (indices, list(new_items)))\n        >>> ml = MonitoredFocusList([0,1,2], focus=2)\n        >>> ml.set_validate_contents_modified(modified)\n        >>> ml *= 3\n        range(3, 3, 1) <- [0, 1, 2, 0, 1, 2]\n        >>> ml\n        MonitoredFocusList([0, 1, 2, 0, 1, 2, 0, 1, 2], focus=2)\n        >>> ml *= 0\n        range(0, 9, 1) <- []\n        >>> print(ml.focus)\n        None\n        \"\"\"\n        if n > 0:\n            focus = self._adjust_focus_on_contents_modified(slice(len(self), len(self)), list(self) * (n-1))\n        else:  # all contents are being removed\n            focus = self._adjust_focus_on_contents_modified(slice(0, len(self)))\n        rval = super().__imul__(n)\n        self.focus = focus\n        return rval\n\n    def append(self, item):\n        \"\"\"\n        >>> def modified(indices, new_items):\n        ...     print(\"range%r <- %r\" % (indices, new_items))\n        >>> ml = MonitoredFocusList([0,1,2], focus=2)\n        >>> ml.set_validate_contents_modified(modified)\n        >>> ml.append(6)\n        range(3, 3, 1) <- [6]\n        \"\"\"\n        focus = self._adjust_focus_on_contents_modified(\n            slice(len(self), len(self)), [item])\n        rval = super().append(item)\n        self.focus = focus\n        return rval\n\n    def extend(self, items):\n        \"\"\"\n        >>> def modified(indices, new_items):\n        ...     print(\"range%r <- %r\" % (indices, list(new_items)))\n        >>> ml = MonitoredFocusList([0,1,2], focus=2)\n        >>> ml.set_validate_contents_modified(modified)\n        >>> ml.extend((6,7,8))\n        range(3, 3, 1) <- [6, 7, 8]\n        \"\"\"\n        focus = self._adjust_focus_on_contents_modified(\n            slice(len(self), len(self)), items)\n        rval = super().extend(items)\n        self.focus = focus\n        return rval\n\n    def insert(self, index: int, item):\n        \"\"\"\n        >>> ml = MonitoredFocusList([0,1,2,3], focus=2)\n        >>> ml.insert(-1, -1); ml\n        MonitoredFocusList([0, 1, 2, -1, 3], focus=2)\n        >>> ml.insert(0, -2); ml\n        MonitoredFocusList([-2, 0, 1, 2, -1, 3], focus=3)\n        >>> ml.insert(3, -3); ml\n        MonitoredFocusList([-2, 0, 1, -3, 2, -1, 3], focus=4)\n        \"\"\"\n        focus = self._adjust_focus_on_contents_modified(slice(index, index), [item])\n        rval = super().insert(index, item)\n        self.focus = focus\n        return rval\n\n    def pop(self, index: int = -1):\n        \"\"\"\n        >>> ml = MonitoredFocusList([-2,0,1,-3,2,3], focus=4)\n        >>> ml.pop(3); ml\n        -3\n        MonitoredFocusList([-2, 0, 1, 2, 3], focus=3)\n        >>> ml.pop(0); ml\n        -2\n        MonitoredFocusList([0, 1, 2, 3], focus=2)\n        >>> ml.pop(-1); ml\n        3\n        MonitoredFocusList([0, 1, 2], focus=2)\n        >>> ml.pop(2); ml\n        2\n        MonitoredFocusList([0, 1], focus=1)\n        \"\"\"\n        focus = self._adjust_focus_on_contents_modified(slice(index, index + 1 or None))\n        rval = super().pop(index)\n        self.focus = focus\n        return rval\n\n    def remove(self, value):\n        \"\"\"\n        >>> ml = MonitoredFocusList([-2,0,1,-3,2,-1,3], focus=4)\n        >>> ml.remove(-3); ml\n        MonitoredFocusList([-2, 0, 1, 2, -1, 3], focus=3)\n        >>> ml.remove(-2); ml\n        MonitoredFocusList([0, 1, 2, -1, 3], focus=2)\n        >>> ml.remove(3); ml\n        MonitoredFocusList([0, 1, 2, -1], focus=2)\n        \"\"\"\n        index = self.index(value)\n        focus = self._adjust_focus_on_contents_modified(slice(index,\n            index+1 or None))\n        rval = super().remove(value)\n        self.focus = focus\n        return rval\n\n    def reverse(self):\n        \"\"\"\n        >>> ml = MonitoredFocusList([0,1,2,3,4], focus=1)\n        >>> ml.reverse(); ml\n        MonitoredFocusList([4, 3, 2, 1, 0], focus=3)\n        \"\"\"\n        rval = super().reverse()\n        self.focus = max(0, len(self) - self._focus - 1)\n        return rval\n\n    def sort(self, **kwargs):\n        \"\"\"\n        >>> ml = MonitoredFocusList([-2,0,1,-3,2,-1,3], focus=4)\n        >>> ml.sort(); ml\n        MonitoredFocusList([-3, -2, -1, 0, 1, 2, 3], focus=5)\n        \"\"\"\n        if not self:\n            return\n        value = self[self._focus]\n        rval = super().sort(**kwargs)\n        self.focus = self.index(value)\n        return rval\n\n    if hasattr(list, 'clear'):\n        def clear(self):\n            focus = self._adjust_focus_on_contents_modified(slice(0, 0))\n            rval = super().clear()\n            self._set_focus(focus)\n            return rval",
  "def _test():\n    import doctest\n    doctest.testmod()",
  "def call_modified_wrapper(self: MonitoredList, *args, **kwargs):\n        rval = fn(self, *args, **kwargs)\n        self._modified()\n        return rval",
  "def _modified(self):\n        pass",
  "def set_modified_callback(self, callback):\n        \"\"\"\n        Assign a callback function with no parameters that is called any\n        time the list is modified.  Callback's return value is ignored.\n\n        >>> import sys\n        >>> ml = MonitoredList([1,2,3])\n        >>> ml.set_modified_callback(lambda: sys.stdout.write(\"modified\\\\n\"))\n        >>> ml\n        MonitoredList([1, 2, 3])\n        >>> ml.append(10)\n        modified\n        >>> len(ml)\n        4\n        >>> ml += [11, 12, 13]\n        modified\n        >>> ml[:] = ml[:2] + ml[-2:]\n        modified\n        >>> ml\n        MonitoredList([1, 2, 12, 13])\n        \"\"\"\n        self._modified = callback",
  "def __repr__(self):\n        return f\"{self.__class__.__name__}({list(self)!r})\"",
  "def __init__(self, *argl, **argd):\n        \"\"\"\n        This is a list that tracks one item as the focus item.  If items\n        are inserted or removed it will update the focus.\n\n        >>> ml = MonitoredFocusList([10, 11, 12, 13, 14], focus=3)\n        >>> ml\n        MonitoredFocusList([10, 11, 12, 13, 14], focus=3)\n        >>> del(ml[1])\n        >>> ml\n        MonitoredFocusList([10, 12, 13, 14], focus=2)\n        >>> ml[:2] = [50, 51, 52, 53]\n        >>> ml\n        MonitoredFocusList([50, 51, 52, 53, 13, 14], focus=4)\n        >>> ml[4] = 99\n        >>> ml\n        MonitoredFocusList([50, 51, 52, 53, 99, 14], focus=4)\n        >>> ml[:] = []\n        >>> ml\n        MonitoredFocusList([], focus=None)\n        \"\"\"\n        focus = argd.pop('focus', 0)\n\n        super().__init__(*argl, **argd)\n\n        self._focus = focus\n        self._focus_modified = lambda ml, indices, new_items: None",
  "def __repr__(self):\n        return f\"{self.__class__.__name__}({list(self)!r}, focus={self.focus!r})\"",
  "def focus(self) -> int | None:\n        \"\"\"\n        Get/set the focus index.  This value is read as None when the list\n        is empty, and may only be set to a value between 0 and len(self)-1\n        or an IndexError will be raised.\n\n        Return the index of the item \"in focus\" or None if\n        the list is empty.\n\n        >>> MonitoredFocusList([1,2,3], focus=2).focus\n        2\n        >>> MonitoredFocusList().focus\n        \"\"\"\n        if not self:\n            return None\n        return self._focus",
  "def focus(self, index: int) -> None:\n        \"\"\"\n        index -- index into this list, any index out of range will\n            raise an IndexError, except when the list is empty and\n            the index passed is ignored.\n\n        This function may call self._focus_changed when the focus\n        is modified, passing the new focus position to the\n        callback just before changing the old focus setting.\n        That method may be overridden on the\n        instance with set_focus_changed_callback().\n\n        >>> ml = MonitoredFocusList([9, 10, 11])\n        >>> ml.focus = 2; ml.focus\n        2\n        >>> ml.focus = 0; ml.focus\n        0\n        >>> ml.focus = -2\n        Traceback (most recent call last):\n        ...\n        IndexError: focus index is out of range: -2\n        \"\"\"\n        if not self:\n            self._focus = 0\n            return\n        if index < 0 or index >= len(self):\n            raise IndexError(f'focus index is out of range: {index}')\n        if index != int(index):\n            raise IndexError(f'invalid focus index: {index}')\n        index = int(index)\n        if index != self._focus:\n            self._focus_changed(index)\n        self._focus = index",
  "def _get_focus(self) -> int | None:\n        warnings.warn(\n            f\"method `{self.__class__.__name__}._get_focus` is deprecated, \"\n            f\"please use `{self.__class__.__name__}.focus` property\",\n            DeprecationWarning,\n            stacklevel=3,\n        )\n        return self.focus",
  "def _set_focus(self, index: int) -> None:\n        warnings.warn(\n            f\"method `{self.__class__.__name__}._set_focus` is deprecated, \"\n            f\"please use `{self.__class__.__name__}.focus` property\",\n            DeprecationWarning,\n            stacklevel=3,\n        )\n        self.focus = index",
  "def _focus_changed(self, new_focus: int):\n        pass",
  "def set_focus_changed_callback(self, callback: Callable[[int], typing.Any]) -> None:\n        \"\"\"\n        Assign a callback to be called when the focus index changes\n        for any reason.  The callback is in the form:\n\n        callback(new_focus)\n        new_focus -- new focus index\n\n        >>> import sys\n        >>> ml = MonitoredFocusList([1,2,3], focus=1)\n        >>> ml.set_focus_changed_callback(lambda f: sys.stdout.write(\"focus: %d\\\\n\" % (f,)))\n        >>> ml\n        MonitoredFocusList([1, 2, 3], focus=1)\n        >>> ml.append(10)\n        >>> ml.insert(1, 11)\n        focus: 2\n        >>> ml\n        MonitoredFocusList([1, 11, 2, 3, 10], focus=2)\n        >>> del ml[:2]\n        focus: 0\n        >>> ml[:0] = [12, 13, 14]\n        focus: 3\n        >>> ml.focus = 5\n        focus: 5\n        >>> ml\n        MonitoredFocusList([12, 13, 14, 2, 3, 10], focus=5)\n        \"\"\"\n        self._focus_changed = callback",
  "def _validate_contents_modified(self, indices, new_items):\n        return None",
  "def set_validate_contents_modified(self, callback):\n        \"\"\"\n        Assign a callback function to handle validating changes to the list.\n        This may raise an exception if the change should not be performed.\n        It may also return an integer position to be the new focus after the\n        list is modified, or None to use the default behaviour.\n\n        The callback is in the form:\n\n        callback(indices, new_items)\n        indices -- a (start, stop, step) tuple whose range covers the\n            items being modified\n        new_items -- an iterable of items replacing those at range(*indices),\n            empty if items are being removed, if step==1 this list may\n            contain any number of items\n        \"\"\"\n        self._validate_contents_modified = callback",
  "def _adjust_focus_on_contents_modified(self, slc: slice, new_items=()) -> int:\n        \"\"\"\n        Default behaviour is to move the focus to the item following\n        any removed items, unless that item was simply replaced.\n\n        Failing that choose the last item in the list.\n\n        returns focus position for after change is applied\n        \"\"\"\n        num_new_items = len(new_items)\n        start, stop, step = indices = slc.indices(len(self))\n        num_removed = len(list(range(*indices)))\n\n        focus = self._validate_contents_modified(indices, new_items)\n        if focus is not None:\n            return focus\n\n        focus = self._focus\n        if step == 1:\n            if start + num_new_items <= focus < stop:\n                focus = stop\n            # adjust for added/removed items\n            if stop <= focus:\n                focus += num_new_items - (stop - start)\n\n        else:\n            if not num_new_items:\n                # extended slice being removed\n                if focus in range(start, stop, step):\n                    focus += 1\n\n                # adjust for removed items\n                focus -= len(list(range(start, min(focus, stop), step)))\n\n        return min(focus, len(self) + num_new_items - num_removed -1)",
  "def __delitem__(self, y: int | slice):\n        \"\"\"\n        >>> ml = MonitoredFocusList([0,1,2,3,4], focus=2)\n        >>> del ml[3]; ml\n        MonitoredFocusList([0, 1, 2, 4], focus=2)\n        >>> del ml[-1]; ml\n        MonitoredFocusList([0, 1, 2], focus=2)\n        >>> del ml[0]; ml\n        MonitoredFocusList([1, 2], focus=1)\n        >>> del ml[1]; ml\n        MonitoredFocusList([1], focus=0)\n        >>> del ml[0]; ml\n        MonitoredFocusList([], focus=None)\n        >>> ml = MonitoredFocusList([5,4,6,4,5,4,6,4,5], focus=4)\n        >>> del ml[1::2]; ml\n        MonitoredFocusList([5, 6, 5, 6, 5], focus=2)\n        >>> del ml[::2]; ml\n        MonitoredFocusList([6, 6], focus=1)\n        >>> ml = MonitoredFocusList([0,1,2,3,4,6,7], focus=2)\n        >>> del ml[-2:]; ml\n        MonitoredFocusList([0, 1, 2, 3, 4], focus=2)\n        >>> del ml[-4:-2]; ml\n        MonitoredFocusList([0, 3, 4], focus=1)\n        >>> del ml[:]; ml\n        MonitoredFocusList([], focus=None)\n        \"\"\"\n        if isinstance(y, slice):\n            focus = self._adjust_focus_on_contents_modified(y)\n        else:\n            focus = self._adjust_focus_on_contents_modified(slice(y, y+1 or None))\n        rval = super().__delitem__(y)\n        self.focus = focus\n        return rval",
  "def __setitem__(self, i: int | slice, y):\n        \"\"\"\n        >>> def modified(indices, new_items):\n        ...     print(\"range%r <- %r\" % (indices, new_items))\n        >>> ml = MonitoredFocusList([0,1,2,3], focus=2)\n        >>> ml.set_validate_contents_modified(modified)\n        >>> ml[0] = 9\n        range(0, 1, 1) <- [9]\n        >>> ml[2] = 6\n        range(2, 3, 1) <- [6]\n        >>> ml.focus\n        2\n        >>> ml[-1] = 8\n        range(3, 4, 1) <- [8]\n        >>> ml\n        MonitoredFocusList([9, 1, 6, 8], focus=2)\n        >>> ml[1::2] = [12, 13]\n        range(1, 4, 2) <- [12, 13]\n        >>> ml[::2] = [10, 11]\n        range(0, 4, 2) <- [10, 11]\n        >>> ml[-3:-1] = [21, 22, 23]\n        range(1, 3, 1) <- [21, 22, 23]\n        >>> ml\n        MonitoredFocusList([10, 21, 22, 23, 13], focus=2)\n        >>> ml[:] = []\n        range(0, 5, 1) <- []\n        >>> ml\n        MonitoredFocusList([], focus=None)\n        \"\"\"\n        if isinstance(i, slice):\n            focus = self._adjust_focus_on_contents_modified(i, y)\n        else:\n            focus = self._adjust_focus_on_contents_modified(slice(i, i+1 or None), [y])\n        rval = super().__setitem__(i, y)\n        self.focus = focus\n        return rval",
  "def __imul__(self, n: int):\n        \"\"\"\n        >>> def modified(indices, new_items):\n        ...     print(\"range%r <- %r\" % (indices, list(new_items)))\n        >>> ml = MonitoredFocusList([0,1,2], focus=2)\n        >>> ml.set_validate_contents_modified(modified)\n        >>> ml *= 3\n        range(3, 3, 1) <- [0, 1, 2, 0, 1, 2]\n        >>> ml\n        MonitoredFocusList([0, 1, 2, 0, 1, 2, 0, 1, 2], focus=2)\n        >>> ml *= 0\n        range(0, 9, 1) <- []\n        >>> print(ml.focus)\n        None\n        \"\"\"\n        if n > 0:\n            focus = self._adjust_focus_on_contents_modified(slice(len(self), len(self)), list(self) * (n-1))\n        else:  # all contents are being removed\n            focus = self._adjust_focus_on_contents_modified(slice(0, len(self)))\n        rval = super().__imul__(n)\n        self.focus = focus\n        return rval",
  "def append(self, item):\n        \"\"\"\n        >>> def modified(indices, new_items):\n        ...     print(\"range%r <- %r\" % (indices, new_items))\n        >>> ml = MonitoredFocusList([0,1,2], focus=2)\n        >>> ml.set_validate_contents_modified(modified)\n        >>> ml.append(6)\n        range(3, 3, 1) <- [6]\n        \"\"\"\n        focus = self._adjust_focus_on_contents_modified(\n            slice(len(self), len(self)), [item])\n        rval = super().append(item)\n        self.focus = focus\n        return rval",
  "def extend(self, items):\n        \"\"\"\n        >>> def modified(indices, new_items):\n        ...     print(\"range%r <- %r\" % (indices, list(new_items)))\n        >>> ml = MonitoredFocusList([0,1,2], focus=2)\n        >>> ml.set_validate_contents_modified(modified)\n        >>> ml.extend((6,7,8))\n        range(3, 3, 1) <- [6, 7, 8]\n        \"\"\"\n        focus = self._adjust_focus_on_contents_modified(\n            slice(len(self), len(self)), items)\n        rval = super().extend(items)\n        self.focus = focus\n        return rval",
  "def insert(self, index: int, item):\n        \"\"\"\n        >>> ml = MonitoredFocusList([0,1,2,3], focus=2)\n        >>> ml.insert(-1, -1); ml\n        MonitoredFocusList([0, 1, 2, -1, 3], focus=2)\n        >>> ml.insert(0, -2); ml\n        MonitoredFocusList([-2, 0, 1, 2, -1, 3], focus=3)\n        >>> ml.insert(3, -3); ml\n        MonitoredFocusList([-2, 0, 1, -3, 2, -1, 3], focus=4)\n        \"\"\"\n        focus = self._adjust_focus_on_contents_modified(slice(index, index), [item])\n        rval = super().insert(index, item)\n        self.focus = focus\n        return rval",
  "def pop(self, index: int = -1):\n        \"\"\"\n        >>> ml = MonitoredFocusList([-2,0,1,-3,2,3], focus=4)\n        >>> ml.pop(3); ml\n        -3\n        MonitoredFocusList([-2, 0, 1, 2, 3], focus=3)\n        >>> ml.pop(0); ml\n        -2\n        MonitoredFocusList([0, 1, 2, 3], focus=2)\n        >>> ml.pop(-1); ml\n        3\n        MonitoredFocusList([0, 1, 2], focus=2)\n        >>> ml.pop(2); ml\n        2\n        MonitoredFocusList([0, 1], focus=1)\n        \"\"\"\n        focus = self._adjust_focus_on_contents_modified(slice(index, index + 1 or None))\n        rval = super().pop(index)\n        self.focus = focus\n        return rval",
  "def remove(self, value):\n        \"\"\"\n        >>> ml = MonitoredFocusList([-2,0,1,-3,2,-1,3], focus=4)\n        >>> ml.remove(-3); ml\n        MonitoredFocusList([-2, 0, 1, 2, -1, 3], focus=3)\n        >>> ml.remove(-2); ml\n        MonitoredFocusList([0, 1, 2, -1, 3], focus=2)\n        >>> ml.remove(3); ml\n        MonitoredFocusList([0, 1, 2, -1], focus=2)\n        \"\"\"\n        index = self.index(value)\n        focus = self._adjust_focus_on_contents_modified(slice(index,\n            index+1 or None))\n        rval = super().remove(value)\n        self.focus = focus\n        return rval",
  "def reverse(self):\n        \"\"\"\n        >>> ml = MonitoredFocusList([0,1,2,3,4], focus=1)\n        >>> ml.reverse(); ml\n        MonitoredFocusList([4, 3, 2, 1, 0], focus=3)\n        \"\"\"\n        rval = super().reverse()\n        self.focus = max(0, len(self) - self._focus - 1)\n        return rval",
  "def sort(self, **kwargs):\n        \"\"\"\n        >>> ml = MonitoredFocusList([-2,0,1,-3,2,-1,3], focus=4)\n        >>> ml.sort(); ml\n        MonitoredFocusList([-3, -2, -1, 0, 1, 2, 3], focus=5)\n        \"\"\"\n        if not self:\n            return\n        value = self[self._focus]\n        rval = super().sort(**kwargs)\n        self.focus = self.index(value)\n        return rval",
  "def clear(self):\n            focus = self._adjust_focus_on_contents_modified(slice(0, 0))\n            rval = super().clear()\n            self._set_focus(focus)\n            return rval",
  "def _value_lookup_table(values: Sequence[int], size: int) -> list[int]:\n    \"\"\"\n    Generate a lookup table for finding the closest item in values.\n    Lookup returns (index into values)+1\n\n    values -- list of values in ascending order, all < size\n    size -- size of lookup table and maximum value\n\n    >>> _value_lookup_table([0, 7, 9], 10)\n    [0, 0, 0, 0, 1, 1, 1, 1, 2, 2]\n    \"\"\"\n\n    middle_values = [0] + [(values[i] + values[i + 1] + 1) // 2\n        for i in range(len(values) - 1)] + [size]\n    lookup_table = []\n    for i in range(len(middle_values)-1):\n        count = middle_values[i + 1] - middle_values[i]\n        lookup_table.extend([i] * count)\n    return lookup_table",
  "def _gray_num_256(gnum: int) -> int:\n    \"\"\"Return ths color number for gray number gnum.\n\n    Color cube black and white are returned for 0 and 25 respectively\n    since those values aren't included in the gray scale.\n\n    \"\"\"\n    # grays start from index 1\n    gnum -= 1\n\n    if gnum < 0:\n        return _CUBE_BLACK\n    if gnum >= _GRAY_SIZE_256:\n        return _CUBE_WHITE_256\n    return _GRAY_START_256 + gnum",
  "def _gray_num_88(gnum: int) -> int:\n    \"\"\"Return ths color number for gray number gnum.\n\n    Color cube black and white are returned for 0 and 9 respectively\n    since those values aren't included in the gray scale.\n\n    \"\"\"\n    # gnums start from index 1\n    gnum -= 1\n\n    if gnum < 0:\n        return _CUBE_BLACK\n    if gnum >= _GRAY_SIZE_88:\n        return _CUBE_WHITE_88\n    return _GRAY_START_88 + gnum",
  "def _color_desc_true(num: int) -> str:\n\n    return f\"#{num:06x}\"",
  "def _color_desc_256(num: int) -> str:\n    \"\"\"\n    Return a string description of color number num.\n    0..15 -> 'h0'..'h15' basic colors (as high-colors)\n    16..231 -> '#000'..'#fff' color cube colors\n    232..255 -> 'g3'..'g93' grays\n\n    >>> _color_desc_256(15)\n    'h15'\n    >>> _color_desc_256(16)\n    '#000'\n    >>> _color_desc_256(17)\n    '#006'\n    >>> _color_desc_256(230)\n    '#ffd'\n    >>> _color_desc_256(233)\n    'g7'\n    >>> _color_desc_256(234)\n    'g11'\n\n    \"\"\"\n    assert num >= 0 and num < 256, num\n    if num < _CUBE_START:\n        return f'h{num:d}'\n    if num < _GRAY_START_256:\n        num -= _CUBE_START\n        b, num = num % _CUBE_SIZE_256, num // _CUBE_SIZE_256\n        g, num = num % _CUBE_SIZE_256, num // _CUBE_SIZE_256\n        r = num % _CUBE_SIZE_256\n        return f'#{_CUBE_STEPS_256_16[r]:x}{_CUBE_STEPS_256_16[g]:x}{_CUBE_STEPS_256_16[b]:x}'\n    return f'g{_GRAY_STEPS_256_101[num - _GRAY_START_256]:d}'",
  "def _color_desc_88(num: int) -> str:\n    \"\"\"\n    Return a string description of color number num.\n    0..15 -> 'h0'..'h15' basic colors (as high-colors)\n    16..79 -> '#000'..'#fff' color cube colors\n    80..87 -> 'g18'..'g90' grays\n\n    >>> _color_desc_88(15)\n    'h15'\n    >>> _color_desc_88(16)\n    '#000'\n    >>> _color_desc_88(17)\n    '#008'\n    >>> _color_desc_88(78)\n    '#ffc'\n    >>> _color_desc_88(81)\n    'g36'\n    >>> _color_desc_88(82)\n    'g45'\n\n    \"\"\"\n    assert 0 < num < 88\n    if num < _CUBE_START:\n        return f'h{num:d}'\n    if num < _GRAY_START_88:\n        num -= _CUBE_START\n        b, num = num % _CUBE_SIZE_88, num // _CUBE_SIZE_88\n        g, r = num % _CUBE_SIZE_88, num // _CUBE_SIZE_88\n        return f'#{_CUBE_STEPS_88_16[r]:x}{_CUBE_STEPS_88_16[g]:x}{_CUBE_STEPS_88_16[b]:x}'\n    return f'g{_GRAY_STEPS_88_101[num - _GRAY_START_88]:d}'",
  "def _parse_color_true(desc: str) -> int | None:\n\n    c = _parse_color_256(desc)\n    if c is not None:\n        (r, g, b) = _COLOR_VALUES_256[c]\n        return (r << 16) + (g << 8) + b\n\n    if not desc.startswith(\"#\"):\n        return None\n    if len(desc) == 7:\n        h = desc[1:]\n        return int(h, 16)\n    elif len(desc) == 4:\n        h = f\"0x{desc[1]}0{desc[2]}0{desc[3]}\"\n        return int(h, 16)\n    return None",
  "def _parse_color_256(desc: str) -> int | None:\n    \"\"\"\n    Return a color number for the description desc.\n    'h0'..'h255' -> 0..255 actual color number\n    '#000'..'#fff' -> 16..231 color cube colors\n    'g0'..'g100' -> 16, 232..255, 231 grays and color cube black/white\n    'g#00'..'g#ff' -> 16, 232...255, 231 gray and color cube black/white\n\n    Returns None if desc is invalid.\n\n    >>> _parse_color_256('h142')\n    142\n    >>> _parse_color_256('#f00')\n    196\n    >>> _parse_color_256('g100')\n    231\n    >>> _parse_color_256('g#80')\n    244\n    \"\"\"\n    if len(desc) > 4:\n        # keep the length within reason before parsing\n        return None\n    try:\n        if desc.startswith('h'):\n            # high-color number\n            num = int(desc[1:], 10)\n            if num < 0 or num > 255:\n                return None\n            return num\n\n        if desc.startswith('#') and len(desc) == 4:\n            # color-cube coordinates\n            rgb = int(desc[1:], 16)\n            if rgb < 0:\n                return None\n            b, rgb = rgb % 16, rgb // 16\n            g, r = rgb % 16, rgb // 16\n            # find the closest rgb values\n            r = _CUBE_256_LOOKUP_16[r]\n            g = _CUBE_256_LOOKUP_16[g]\n            b = _CUBE_256_LOOKUP_16[b]\n            return _CUBE_START + (r * _CUBE_SIZE_256 + g) * _CUBE_SIZE_256 + b\n\n        # Only remaining possibility is gray value\n        if desc.startswith('g#'):\n            # hex value 00..ff\n            gray = int(desc[2:], 16)\n            if gray < 0 or gray > 255:\n                return None\n            gray = _GRAY_256_LOOKUP[gray]\n        elif desc.startswith('g'):\n            # decimal value 0..100\n            gray = int(desc[1:], 10)\n            if gray < 0 or gray > 100:\n                return None\n            gray = _GRAY_256_LOOKUP_101[gray]\n        else:\n            return None\n        if gray == 0:\n            return _CUBE_BLACK\n        gray -= 1\n        if gray == _GRAY_SIZE_256:\n            return _CUBE_WHITE_256\n        return _GRAY_START_256 + gray\n\n    except ValueError:\n        return None",
  "def _true_to_256(desc: str) -> str | None:\n\n    if not (desc.startswith('#') and len(desc) == 7):\n        return None\n\n    c256 = _parse_color_256(\"#\" + \"\".join([\n        format(int(x, 16)//16, \"x\")\n        for x in [desc[1:3], desc[3:5], desc[5:7] ]\n    ]\n    ))\n    return _color_desc_256(c256)",
  "def _parse_color_88(desc: str) -> int | None:\n    \"\"\"\n    Return a color number for the description desc.\n    'h0'..'h87' -> 0..87 actual color number\n    '#000'..'#fff' -> 16..79 color cube colors\n    'g0'..'g100' -> 16, 80..87, 79 grays and color cube black/white\n    'g#00'..'g#ff' -> 16, 80...87, 79 gray and color cube black/white\n\n    Returns None if desc is invalid.\n\n    >>> _parse_color_88('h142')\n    >>> _parse_color_88('h42')\n    42\n    >>> _parse_color_88('#f00')\n    64\n    >>> _parse_color_88('g100')\n    79\n    >>> _parse_color_88('g#80')\n    83\n    \"\"\"\n    if len(desc) == 7:\n        desc = desc[0:2] + desc[3] + desc[5]\n    if len(desc) > 4:\n        # keep the length within reason before parsing\n        return None\n    try:\n        if desc.startswith('h'):\n            # high-color number\n            num = int(desc[1:], 10)\n            if num < 0 or num > 87:\n                return None\n            return num\n\n        if desc.startswith('#') and len(desc) == 4:\n            # color-cube coordinates\n            rgb = int(desc[1:], 16)\n            if rgb < 0:\n                return None\n            b, rgb = rgb % 16, rgb // 16\n            g, r = rgb % 16, rgb // 16\n            # find the closest rgb values\n            r = _CUBE_88_LOOKUP_16[r]\n            g = _CUBE_88_LOOKUP_16[g]\n            b = _CUBE_88_LOOKUP_16[b]\n            return _CUBE_START + (r * _CUBE_SIZE_88 + g) * _CUBE_SIZE_88 + b\n\n        # Only remaining possibility is gray value\n        if desc.startswith('g#'):\n            # hex value 00..ff\n            gray = int(desc[2:], 16)\n            if gray < 0 or gray > 255:\n                return None\n            gray = _GRAY_88_LOOKUP[gray]\n        elif desc.startswith('g'):\n            # decimal value 0..100\n            gray = int(desc[1:], 10)\n            if gray < 0 or gray > 100:\n                return None\n            gray = _GRAY_88_LOOKUP_101[gray]\n        else:\n            return None\n        if gray == 0:\n            return _CUBE_BLACK\n        gray -= 1\n        if gray == _GRAY_SIZE_88:\n            return _CUBE_WHITE_88\n        return _GRAY_START_88 + gray\n\n    except ValueError:\n        return None",
  "class AttrSpecError(Exception):\n    pass",
  "class AttrSpec:\n    __slots__ = (\"__value\",)\n\n    def __init__(self, fg: str, bg: str, colors: Literal[1, 16, 88, 256, 16777216] = 256) -> None:\n        \"\"\"\n        fg -- a string containing a comma-separated foreground color\n              and settings\n\n              Color values:\n              'default' (use the terminal's default foreground),\n              'black', 'dark red', 'dark green', 'brown', 'dark blue',\n              'dark magenta', 'dark cyan', 'light gray', 'dark gray',\n              'light red', 'light green', 'yellow', 'light blue',\n              'light magenta', 'light cyan', 'white'\n\n              High-color example values:\n              '#009' (0% red, 0% green, 60% red, like HTML colors)\n              '#23facc' (RRGGBB hex color code)\n              '#fcc' (100% red, 80% green, 80% blue)\n              'g40' (40% gray, decimal), 'g#cc' (80% gray, hex),\n              '#000', 'g0', 'g#00' (black),\n              '#fff', 'g100', 'g#ff' (white)\n              'h8' (color number 8), 'h255' (color number 255)\n\n              Setting:\n              'bold', 'italics', 'underline', 'blink', 'standout',\n              'strikethrough'\n\n              Some terminals use 'bold' for bright colors.  Most terminals\n              ignore the 'blink' setting.  If the color is not given then\n              'default' will be assumed.\n\n        bg -- a string containing the background color\n\n              Color values:\n              'default' (use the terminal's default background),\n              'black', 'dark red', 'dark green', 'brown', 'dark blue',\n              'dark magenta', 'dark cyan', 'light gray'\n\n              High-color exaples:\n              see fg examples above\n\n              An empty string will be treated the same as 'default'.\n\n        colors -- the maximum colors available for the specification\n\n                   Valid values include: 1, 16, 88, 256, and 2**24.  High-color\n                   values are only usable with 88, 256, or 2**24 colors.  With\n                   1 color only the foreground settings may be used.\n\n        >>> AttrSpec('dark red', 'light gray', 16)\n        AttrSpec('dark red', 'light gray')\n        >>> AttrSpec('yellow, underline, bold', 'dark blue')\n        AttrSpec('yellow,bold,underline', 'dark blue')\n        >>> AttrSpec('#ddb', '#004', 256) # closest colors will be found\n        AttrSpec('#dda', '#006')\n        >>> AttrSpec('#ddb', '#004', 88)\n        AttrSpec('#ccc', '#000', colors=88)\n        \"\"\"\n        if colors not in (1, 16, 88, 256, 2**24):\n            raise AttrSpecError(f'invalid number of colors ({colors:d}).')\n        self.__value = 0 | _HIGH_88_COLOR * (colors == 88) | _HIGH_TRUE_COLOR * (colors == 2 ** 24)\n        self.__set_foreground(fg)\n        self.__set_background(bg)\n        if self.colors > colors:\n            raise AttrSpecError(\n                f'foreground/background ({fg!r}/{bg!r}) '\n                f'require more colors than have been specified ({colors:d}).'\n            )\n\n    def copy_modified(\n        self,\n        fg: str | None = None,\n        bg: str | None = None,\n        colors: Literal[1, 16, 88, 256, 16777216] | None = None,\n    ) -> Self:\n        if fg is None:\n            foreground = self.foreground\n        else:\n            foreground = fg\n\n        if bg is None:\n            background = self.background\n        else:\n            background = bg\n\n        if colors is None:\n            new_colors = self.colors\n        else:\n            new_colors = colors\n\n        return self.__class__(foreground, background, new_colors)\n\n    def __hash__(self) -> int:\n        \"\"\"Instance is immutable and hashable.\"\"\"\n        return hash((self.__class__, self.__value))\n\n    @property\n    def _value(self) -> int:\n        \"\"\"Read-only value access.\"\"\"\n        return self.__value\n\n    @property\n    def foreground_basic(self) -> bool:\n        return self.__value & _FG_BASIC_COLOR != 0\n\n    @property\n    def foreground_high(self) -> bool:\n        return self.__value & _FG_HIGH_COLOR != 0\n\n    @property\n    def foreground_true(self) -> bool:\n        return self.__value & _FG_TRUE_COLOR != 0\n\n    @property\n    def foreground_number(self) -> int:\n        return self.__value & _FG_COLOR_MASK\n\n    @property\n    def background_basic(self) -> bool:\n        return self.__value & _BG_BASIC_COLOR != 0\n\n    @property\n    def background_high(self) -> bool:\n        return self.__value & _BG_HIGH_COLOR != 0\n\n    @property\n    def background_true(self) -> bool:\n        return self.__value & _BG_TRUE_COLOR != 0\n\n    @property\n    def background_number(self) -> int:\n        return (self.__value & _BG_COLOR_MASK) >> _BG_SHIFT\n\n    @property\n    def italics(self) -> bool:\n        return self.__value & _ITALICS != 0\n\n    @property\n    def bold(self) -> bool:\n        return self.__value & _BOLD != 0\n\n    @property\n    def underline(self) -> bool:\n        return self.__value & _UNDERLINE != 0\n\n    @property\n    def blink(self) -> bool:\n        return self.__value & _BLINK != 0\n\n    @property\n    def standout(self) -> bool:\n        return self.__value & _STANDOUT != 0\n\n    @property\n    def strikethrough(self) -> bool:\n        return self.__value & _STRIKETHROUGH != 0\n\n    @property\n    def colors(self) -> int:\n        \"\"\"\n        Return the maximum colors required for this object.\n\n        Returns 256, 88, 16 or 1.\n        \"\"\"\n        if self.__value & _HIGH_88_COLOR:\n            return 88\n        if self.__value & (_BG_HIGH_COLOR | _FG_HIGH_COLOR):\n            return 256\n        if self.__value & (_BG_TRUE_COLOR | _FG_TRUE_COLOR):\n            return 2**24\n        if self.__value & (_BG_BASIC_COLOR | _FG_BASIC_COLOR):\n            return 16\n        return 1\n\n    def _colors(self) -> int:\n        warnings.warn(\n            f\"Method `{self.__class__.__name__}._colors` is deprecated, \"\n            f\"please use property `{self.__class__.__name__}.colors`\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        return self.colors\n\n    def __repr__(self) -> str:\n        \"\"\"\n        Return an executable python representation of the AttrSpec\n        object.\n        \"\"\"\n        args = f\"{self.foreground!r}, {self.background!r}\"\n        if self.colors == 88:\n            # 88-color mode is the only one that is handled differently\n            args = f\"{args}, colors=88\"\n        return f\"{self.__class__.__name__}({args})\"\n\n    def _foreground_color(self) -> str:\n        \"\"\"Return only the color component of the foreground.\"\"\"\n        if not (self.foreground_basic or self.foreground_high or self.foreground_true):\n            return 'default'\n        if self.foreground_basic:\n            return _BASIC_COLORS[self.foreground_number]\n        if self.colors == 88:\n            return _color_desc_88(self.foreground_number)\n        if self.colors == 2**24:\n            return _color_desc_true(self.foreground_number)\n        return _color_desc_256(self.foreground_number)\n\n    @property\n    def foreground(self) -> str:\n        return (\n            self._foreground_color()\n            + ',bold' * self.bold\n            + ',italics' * self.italics\n            + ',standout' * self.standout\n            + ',blink' * self.blink\n            + ',underline' * self.underline\n            + ',strikethrough' * self.strikethrough\n        )\n\n    def __set_foreground(self, foreground: str) -> None:\n        color = None\n        flags = 0\n        # handle comma-separated foreground\n        for part in foreground.split(','):\n            part = part.strip()\n            if part in _ATTRIBUTES:\n                # parse and store \"settings\"/attributes in flags\n                if flags & _ATTRIBUTES[part]:\n                    raise AttrSpecError(\n                        f\"Setting {part!r} specified more than once in foreground ({foreground!r})\")\n                flags |= _ATTRIBUTES[part]\n                continue\n            # past this point we must be specifying a color\n            if part in ('', 'default'):\n                scolor = 0\n            elif part in _BASIC_COLORS:\n                scolor = _BASIC_COLORS.index(part)\n                flags |= _FG_BASIC_COLOR\n            elif self.__value & _HIGH_88_COLOR:\n                scolor = _parse_color_88(part)\n                flags |= _FG_HIGH_COLOR\n            elif self.__value & _HIGH_TRUE_COLOR:\n                scolor = _parse_color_true(part)\n                flags |= _FG_TRUE_COLOR\n            else:\n                scolor = _parse_color_256(_true_to_256(part) or part)\n                flags |= _FG_HIGH_COLOR\n            # _parse_color_*() return None for unrecognised colors\n            if scolor is None:\n                raise AttrSpecError(f\"Unrecognised color specification {part!r} in foreground ({foreground!r})\")\n            if color is not None:\n                raise AttrSpecError(f\"More than one color given for foreground ({foreground!r})\")\n            color = scolor\n        if color is None:\n            color = 0\n        self.__value = (self.__value & ~_FG_MASK) | color | flags\n\n    def _foreground(self) -> str:\n        warnings.warn(\n            f\"Method `{self.__class__.__name__}._foreground` is deprecated, \"\n            f\"please use property `{self.__class__.__name__}.foreground`\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        return self.foreground\n\n    @property\n    def background(self) -> str:\n        \"\"\"Return the background color.\"\"\"\n        if not (self.background_basic or self.background_high or self.background_true):\n            return 'default'\n        if self.background_basic:\n            return _BASIC_COLORS[self.background_number]\n        if self.__value & _HIGH_88_COLOR:\n            return _color_desc_88(self.background_number)\n        if self.colors == 2**24:\n            return _color_desc_true(self.background_number)\n        return _color_desc_256(self.background_number)\n\n    def __set_background(self, background: str) -> None:\n        flags = 0\n        if background in ('', 'default'):\n            color = 0\n        elif background in _BASIC_COLORS:\n            color = _BASIC_COLORS.index(background)\n            flags |= _BG_BASIC_COLOR\n        elif self.__value & _HIGH_88_COLOR:\n            color = _parse_color_88(background)\n            flags |= _BG_HIGH_COLOR\n        elif self.__value & _HIGH_TRUE_COLOR:\n            color = _parse_color_true(background)\n            flags |= _BG_TRUE_COLOR\n        else:\n            color = _parse_color_256(_true_to_256(background) or background)\n            flags |= _BG_HIGH_COLOR\n        if color is None:\n            raise AttrSpecError(f\"Unrecognised color specification in background ({background!r})\")\n        self.__value = (self.__value & ~_BG_MASK) | (color << _BG_SHIFT) | flags\n\n    def _background(self) -> str:\n        warnings.warn(\n            f\"Method `{self.__class__.__name__}._background` is deprecated, \"\n            f\"please use property `{self.__class__.__name__}.background`\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        return self.background\n\n    def get_rgb_values(self):\n        \"\"\"\n        Return (fg_red, fg_green, fg_blue, bg_red, bg_green, bg_blue) color\n        components.  Each component is in the range 0-255.  Values are taken\n        from the XTerm defaults and may not exactly match the user's terminal.\n\n        If the foreground or background is 'default' then all their compenents\n        will be returned as None.\n\n        >>> AttrSpec('yellow', '#ccf', colors=88).get_rgb_values()\n        (255, 255, 0, 205, 205, 255)\n        >>> AttrSpec('default', 'g92').get_rgb_values()\n        (None, None, None, 238, 238, 238)\n        \"\"\"\n        if not (self.foreground_basic or self.foreground_high or self.foreground_true):\n            vals = (None, None, None)\n        elif self.colors == 88:\n            assert self.foreground_number < 88, \"Invalid AttrSpec _value\"\n            vals = _COLOR_VALUES_88[self.foreground_number]\n        elif self.colors == 2**24:\n            h = f\"{self.foreground_number:06x}\"\n            vals = tuple([int(x, 16) for x in [h[0:2], h[2:4], h[4:6]]])\n        else:\n            vals = _COLOR_VALUES_256[self.foreground_number]\n\n        if not (self.background_basic or self.background_high or self.background_true):\n            return vals + (None, None, None)\n        elif self.colors == 88:\n            assert self.background_number < 88, \"Invalid AttrSpec _value\"\n            return vals + _COLOR_VALUES_88[self.background_number]\n        elif self.colors == 2**24:\n            h = f\"{self.background_number:06x}\"\n            return vals + tuple([int(x, 16) for x in [h[0:2], h[2:4], h[4:6]]])\n        else:\n            return vals + _COLOR_VALUES_256[self.background_number]\n\n    def __eq__(self, other: typing.Any) -> bool:\n        return isinstance(other, AttrSpec) and self.__value == other.__value\n\n    def __ne__(self, other: typing.Any) -> bool:\n        return not self == other",
  "class RealTerminal:\n    def __init__(self) -> None:\n        super().__init__()\n        self._signal_keys_set = False\n        self._old_signal_keys = None\n\n    def tty_signal_keys(\n        self,\n        intr: Literal['undefined'] | int | None = None,\n        quit: Literal['undefined'] | int | None = None,\n        start: Literal['undefined'] | int | None = None,\n        stop: Literal['undefined'] | int | None = None,\n        susp: Literal['undefined'] | int | None = None,\n        fileno: int | None = None,\n    ):\n        \"\"\"\n        Read and/or set the tty's signal character settings.\n        This function returns the current settings as a tuple.\n\n        Use the string 'undefined' to unmap keys from their signals.\n        The value None is used when no change is being made.\n        Setting signal keys is done using the integer ascii\n        code for the key, eg.  3 for CTRL+C.\n\n        If this function is called after start() has been called\n        then the original settings will be restored when stop()\n        is called.\n        \"\"\"\n        if fileno is None:\n            fileno = sys.stdin.fileno()\n        if not os.isatty(fileno):\n            return\n\n        tattr = termios.tcgetattr(fileno)\n        sattr = tattr[6]\n        skeys = (\n            sattr[termios.VINTR],\n            sattr[termios.VQUIT],\n            sattr[termios.VSTART],\n            sattr[termios.VSTOP],\n            sattr[termios.VSUSP],\n        )\n\n        if intr == 'undefined': intr = 0\n        if quit == 'undefined': quit = 0\n        if start == 'undefined': start = 0\n        if stop == 'undefined': stop = 0\n        if susp == 'undefined': susp = 0\n\n        if intr is not None: tattr[6][termios.VINTR] = intr\n        if quit is not None: tattr[6][termios.VQUIT] = quit\n        if start is not None: tattr[6][termios.VSTART] = start\n        if stop is not None: tattr[6][termios.VSTOP] = stop\n        if susp is not None: tattr[6][termios.VSUSP] = susp\n\n        if any(item is not None for item in (intr, quit, start, stop, susp)):\n            termios.tcsetattr(fileno, termios.TCSADRAIN, tattr)\n            self._signal_keys_set = True\n\n        return skeys",
  "class ScreenError(Exception):\n    pass",
  "class BaseScreen(metaclass=signals.MetaSignals):\n    \"\"\"\n    Base class for Screen classes (raw_display.Screen, .. etc)\n    \"\"\"\n    signals = [UPDATE_PALETTE_ENTRY, INPUT_DESCRIPTORS_CHANGED]\n\n    def __init__(self) -> None:\n        super().__init__()\n        self._palette = {}\n        self._started = False\n\n    @property\n    def started(self) -> bool:\n        return self._started\n\n    def start(self, *args, **kwargs) -> StoppingContext:\n        \"\"\"Set up the screen.  If the screen has already been started, does\n        nothing.\n\n        May be used as a context manager, in which case :meth:`stop` will\n        automatically be called at the end of the block:\n\n            with screen.start():\n                ...\n\n        You shouldn't override this method in a subclass; instead, override\n        :meth:`_start`.\n        \"\"\"\n        if not self._started:\n            self._started = True\n            self._start(*args, **kwargs)\n        return StoppingContext(self)\n\n    def _start(self):\n        pass\n\n    def stop(self) -> None:\n        if self._started:\n            self._stop()\n        self._started = False\n\n    def _stop(self):\n        pass\n\n    def run_wrapper(self, fn, *args, **kwargs):\n        \"\"\"Start the screen, call a function, then stop the screen.  Extra\n        arguments are passed to `start`.\n\n        Deprecated in favor of calling `start` as a context manager.\n        \"\"\"\n        warnings.warn(\n            \"run_wrapper is deprecated in favor of calling `start` as a context manager.\",\n            DeprecationWarning,\n        )\n        with self.start(*args, **kwargs):\n            return fn()\n\n    def register_palette(\n        self,\n        palette: Iterable[\n            tuple[str, str]\n            | tuple[str, str, str]\n            | tuple[str, str, str, str]\n            | tuple[str, str, str, str, str, str]\n        ]\n    ) -> None:\n        \"\"\"Register a set of palette entries.\n\n        palette -- a list of (name, like_other_name) or\n        (name, foreground, background, mono, foreground_high, background_high) tuples\n\n            The (name, like_other_name) format will copy the settings\n            from the palette entry like_other_name, which must appear\n            before this tuple in the list.\n\n            The mono and foreground/background_high values are\n            optional ie. the second tuple format may have 3, 4 or 6\n            values.  See register_palette_entry() for a description\n            of the tuple values.\n        \"\"\"\n\n        for item in palette:\n            if len(item) in (3, 4, 6):\n                self.register_palette_entry(*item)\n                continue\n            if len(item) != 2:\n                raise ScreenError(f\"Invalid register_palette entry: {item!r}\")\n            name, like_name = item\n            if like_name not in self._palette:\n                raise ScreenError(f\"palette entry '{like_name}' doesn't exist\")\n            self._palette[name] = self._palette[like_name]\n\n    def register_palette_entry(\n        self,\n        name: str,\n        foreground: str,\n        background: str,\n        mono: str | None = None,\n        foreground_high: str | None = None,\n        background_high: str | None = None,\n    ) -> None:\n        \"\"\"Register a single palette entry.\n\n        name -- new entry/attribute name\n\n        foreground -- a string containing a comma-separated foreground\n        color and settings\n\n            Color values:\n            'default' (use the terminal's default foreground),\n            'black', 'dark red', 'dark green', 'brown', 'dark blue',\n            'dark magenta', 'dark cyan', 'light gray', 'dark gray',\n            'light red', 'light green', 'yellow', 'light blue',\n            'light magenta', 'light cyan', 'white'\n\n            Settings:\n            'bold', 'underline', 'blink', 'standout', 'strikethrough'\n\n            Some terminals use 'bold' for bright colors.  Most terminals\n            ignore the 'blink' setting.  If the color is not given then\n            'default' will be assumed.\n\n        background -- a string containing the background color\n\n            Background color values:\n            'default' (use the terminal's default background),\n            'black', 'dark red', 'dark green', 'brown', 'dark blue',\n            'dark magenta', 'dark cyan', 'light gray'\n\n        mono -- a comma-separated string containing monochrome terminal\n        settings (see \"Settings\" above.)\n\n            None = no terminal settings (same as 'default')\n\n        foreground_high -- a string containing a comma-separated\n        foreground color and settings, standard foreground\n        colors (see \"Color values\" above) or high-colors may\n        be used\n\n            High-color example values:\n            '#009' (0% red, 0% green, 60% red, like HTML colors)\n            '#fcc' (100% red, 80% green, 80% blue)\n            'g40' (40% gray, decimal), 'g#cc' (80% gray, hex),\n            '#000', 'g0', 'g#00' (black),\n            '#fff', 'g100', 'g#ff' (white)\n            'h8' (color number 8), 'h255' (color number 255)\n\n            None = use foreground parameter value\n\n        background_high -- a string containing the background color,\n        standard background colors (see \"Background colors\" above)\n        or high-colors (see \"High-color example values\" above)\n        may be used\n\n            None = use background parameter value\n        \"\"\"\n        basic = AttrSpec(foreground, background, 16)\n\n        if isinstance(mono, tuple):\n            # old style of specifying mono attributes was to put them\n            # in a tuple.  convert to comma-separated string\n            mono = \",\".join(mono)\n        if mono is None:\n            mono = DEFAULT\n        mono = AttrSpec(mono, DEFAULT, 1)\n\n        if foreground_high is None:\n            foreground_high = foreground\n        if background_high is None:\n            background_high = background\n\n        high_256 = AttrSpec(foreground_high, background_high, 256)\n        high_true = AttrSpec(foreground_high, background_high, 2**24)\n\n        # 'hX' where X > 15 are different in 88/256 color, use\n        # basic colors for 88-color mode if high colors are specified\n        # in this way (also avoids crash when X > 87)\n        def large_h(desc: str) -> bool:\n            if not desc.startswith('h'):\n                return False\n            if ',' in desc:\n                desc = desc.split(',',1)[0]\n            num = int(desc[1:], 10)\n            return num > 15\n\n        if large_h(foreground_high) or large_h(background_high):\n            high_88 = basic\n        else:\n            high_88 = AttrSpec(foreground_high, background_high, 88)\n\n        signals.emit_signal(self, UPDATE_PALETTE_ENTRY,\n                            name, basic, mono, high_88, high_256, high_true)\n        self._palette[name] = (basic, mono, high_88, high_256, high_true)",
  "def _test():\n    import doctest\n    doctest.testmod()",
  "def __init__(self, fg: str, bg: str, colors: Literal[1, 16, 88, 256, 16777216] = 256) -> None:\n        \"\"\"\n        fg -- a string containing a comma-separated foreground color\n              and settings\n\n              Color values:\n              'default' (use the terminal's default foreground),\n              'black', 'dark red', 'dark green', 'brown', 'dark blue',\n              'dark magenta', 'dark cyan', 'light gray', 'dark gray',\n              'light red', 'light green', 'yellow', 'light blue',\n              'light magenta', 'light cyan', 'white'\n\n              High-color example values:\n              '#009' (0% red, 0% green, 60% red, like HTML colors)\n              '#23facc' (RRGGBB hex color code)\n              '#fcc' (100% red, 80% green, 80% blue)\n              'g40' (40% gray, decimal), 'g#cc' (80% gray, hex),\n              '#000', 'g0', 'g#00' (black),\n              '#fff', 'g100', 'g#ff' (white)\n              'h8' (color number 8), 'h255' (color number 255)\n\n              Setting:\n              'bold', 'italics', 'underline', 'blink', 'standout',\n              'strikethrough'\n\n              Some terminals use 'bold' for bright colors.  Most terminals\n              ignore the 'blink' setting.  If the color is not given then\n              'default' will be assumed.\n\n        bg -- a string containing the background color\n\n              Color values:\n              'default' (use the terminal's default background),\n              'black', 'dark red', 'dark green', 'brown', 'dark blue',\n              'dark magenta', 'dark cyan', 'light gray'\n\n              High-color exaples:\n              see fg examples above\n\n              An empty string will be treated the same as 'default'.\n\n        colors -- the maximum colors available for the specification\n\n                   Valid values include: 1, 16, 88, 256, and 2**24.  High-color\n                   values are only usable with 88, 256, or 2**24 colors.  With\n                   1 color only the foreground settings may be used.\n\n        >>> AttrSpec('dark red', 'light gray', 16)\n        AttrSpec('dark red', 'light gray')\n        >>> AttrSpec('yellow, underline, bold', 'dark blue')\n        AttrSpec('yellow,bold,underline', 'dark blue')\n        >>> AttrSpec('#ddb', '#004', 256) # closest colors will be found\n        AttrSpec('#dda', '#006')\n        >>> AttrSpec('#ddb', '#004', 88)\n        AttrSpec('#ccc', '#000', colors=88)\n        \"\"\"\n        if colors not in (1, 16, 88, 256, 2**24):\n            raise AttrSpecError(f'invalid number of colors ({colors:d}).')\n        self.__value = 0 | _HIGH_88_COLOR * (colors == 88) | _HIGH_TRUE_COLOR * (colors == 2 ** 24)\n        self.__set_foreground(fg)\n        self.__set_background(bg)\n        if self.colors > colors:\n            raise AttrSpecError(\n                f'foreground/background ({fg!r}/{bg!r}) '\n                f'require more colors than have been specified ({colors:d}).'\n            )",
  "def copy_modified(\n        self,\n        fg: str | None = None,\n        bg: str | None = None,\n        colors: Literal[1, 16, 88, 256, 16777216] | None = None,\n    ) -> Self:\n        if fg is None:\n            foreground = self.foreground\n        else:\n            foreground = fg\n\n        if bg is None:\n            background = self.background\n        else:\n            background = bg\n\n        if colors is None:\n            new_colors = self.colors\n        else:\n            new_colors = colors\n\n        return self.__class__(foreground, background, new_colors)",
  "def __hash__(self) -> int:\n        \"\"\"Instance is immutable and hashable.\"\"\"\n        return hash((self.__class__, self.__value))",
  "def _value(self) -> int:\n        \"\"\"Read-only value access.\"\"\"\n        return self.__value",
  "def foreground_basic(self) -> bool:\n        return self.__value & _FG_BASIC_COLOR != 0",
  "def foreground_high(self) -> bool:\n        return self.__value & _FG_HIGH_COLOR != 0",
  "def foreground_true(self) -> bool:\n        return self.__value & _FG_TRUE_COLOR != 0",
  "def foreground_number(self) -> int:\n        return self.__value & _FG_COLOR_MASK",
  "def background_basic(self) -> bool:\n        return self.__value & _BG_BASIC_COLOR != 0",
  "def background_high(self) -> bool:\n        return self.__value & _BG_HIGH_COLOR != 0",
  "def background_true(self) -> bool:\n        return self.__value & _BG_TRUE_COLOR != 0",
  "def background_number(self) -> int:\n        return (self.__value & _BG_COLOR_MASK) >> _BG_SHIFT",
  "def italics(self) -> bool:\n        return self.__value & _ITALICS != 0",
  "def bold(self) -> bool:\n        return self.__value & _BOLD != 0",
  "def underline(self) -> bool:\n        return self.__value & _UNDERLINE != 0",
  "def blink(self) -> bool:\n        return self.__value & _BLINK != 0",
  "def standout(self) -> bool:\n        return self.__value & _STANDOUT != 0",
  "def strikethrough(self) -> bool:\n        return self.__value & _STRIKETHROUGH != 0",
  "def colors(self) -> int:\n        \"\"\"\n        Return the maximum colors required for this object.\n\n        Returns 256, 88, 16 or 1.\n        \"\"\"\n        if self.__value & _HIGH_88_COLOR:\n            return 88\n        if self.__value & (_BG_HIGH_COLOR | _FG_HIGH_COLOR):\n            return 256\n        if self.__value & (_BG_TRUE_COLOR | _FG_TRUE_COLOR):\n            return 2**24\n        if self.__value & (_BG_BASIC_COLOR | _FG_BASIC_COLOR):\n            return 16\n        return 1",
  "def _colors(self) -> int:\n        warnings.warn(\n            f\"Method `{self.__class__.__name__}._colors` is deprecated, \"\n            f\"please use property `{self.__class__.__name__}.colors`\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        return self.colors",
  "def __repr__(self) -> str:\n        \"\"\"\n        Return an executable python representation of the AttrSpec\n        object.\n        \"\"\"\n        args = f\"{self.foreground!r}, {self.background!r}\"\n        if self.colors == 88:\n            # 88-color mode is the only one that is handled differently\n            args = f\"{args}, colors=88\"\n        return f\"{self.__class__.__name__}({args})\"",
  "def _foreground_color(self) -> str:\n        \"\"\"Return only the color component of the foreground.\"\"\"\n        if not (self.foreground_basic or self.foreground_high or self.foreground_true):\n            return 'default'\n        if self.foreground_basic:\n            return _BASIC_COLORS[self.foreground_number]\n        if self.colors == 88:\n            return _color_desc_88(self.foreground_number)\n        if self.colors == 2**24:\n            return _color_desc_true(self.foreground_number)\n        return _color_desc_256(self.foreground_number)",
  "def foreground(self) -> str:\n        return (\n            self._foreground_color()\n            + ',bold' * self.bold\n            + ',italics' * self.italics\n            + ',standout' * self.standout\n            + ',blink' * self.blink\n            + ',underline' * self.underline\n            + ',strikethrough' * self.strikethrough\n        )",
  "def __set_foreground(self, foreground: str) -> None:\n        color = None\n        flags = 0\n        # handle comma-separated foreground\n        for part in foreground.split(','):\n            part = part.strip()\n            if part in _ATTRIBUTES:\n                # parse and store \"settings\"/attributes in flags\n                if flags & _ATTRIBUTES[part]:\n                    raise AttrSpecError(\n                        f\"Setting {part!r} specified more than once in foreground ({foreground!r})\")\n                flags |= _ATTRIBUTES[part]\n                continue\n            # past this point we must be specifying a color\n            if part in ('', 'default'):\n                scolor = 0\n            elif part in _BASIC_COLORS:\n                scolor = _BASIC_COLORS.index(part)\n                flags |= _FG_BASIC_COLOR\n            elif self.__value & _HIGH_88_COLOR:\n                scolor = _parse_color_88(part)\n                flags |= _FG_HIGH_COLOR\n            elif self.__value & _HIGH_TRUE_COLOR:\n                scolor = _parse_color_true(part)\n                flags |= _FG_TRUE_COLOR\n            else:\n                scolor = _parse_color_256(_true_to_256(part) or part)\n                flags |= _FG_HIGH_COLOR\n            # _parse_color_*() return None for unrecognised colors\n            if scolor is None:\n                raise AttrSpecError(f\"Unrecognised color specification {part!r} in foreground ({foreground!r})\")\n            if color is not None:\n                raise AttrSpecError(f\"More than one color given for foreground ({foreground!r})\")\n            color = scolor\n        if color is None:\n            color = 0\n        self.__value = (self.__value & ~_FG_MASK) | color | flags",
  "def _foreground(self) -> str:\n        warnings.warn(\n            f\"Method `{self.__class__.__name__}._foreground` is deprecated, \"\n            f\"please use property `{self.__class__.__name__}.foreground`\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        return self.foreground",
  "def background(self) -> str:\n        \"\"\"Return the background color.\"\"\"\n        if not (self.background_basic or self.background_high or self.background_true):\n            return 'default'\n        if self.background_basic:\n            return _BASIC_COLORS[self.background_number]\n        if self.__value & _HIGH_88_COLOR:\n            return _color_desc_88(self.background_number)\n        if self.colors == 2**24:\n            return _color_desc_true(self.background_number)\n        return _color_desc_256(self.background_number)",
  "def __set_background(self, background: str) -> None:\n        flags = 0\n        if background in ('', 'default'):\n            color = 0\n        elif background in _BASIC_COLORS:\n            color = _BASIC_COLORS.index(background)\n            flags |= _BG_BASIC_COLOR\n        elif self.__value & _HIGH_88_COLOR:\n            color = _parse_color_88(background)\n            flags |= _BG_HIGH_COLOR\n        elif self.__value & _HIGH_TRUE_COLOR:\n            color = _parse_color_true(background)\n            flags |= _BG_TRUE_COLOR\n        else:\n            color = _parse_color_256(_true_to_256(background) or background)\n            flags |= _BG_HIGH_COLOR\n        if color is None:\n            raise AttrSpecError(f\"Unrecognised color specification in background ({background!r})\")\n        self.__value = (self.__value & ~_BG_MASK) | (color << _BG_SHIFT) | flags",
  "def _background(self) -> str:\n        warnings.warn(\n            f\"Method `{self.__class__.__name__}._background` is deprecated, \"\n            f\"please use property `{self.__class__.__name__}.background`\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        return self.background",
  "def get_rgb_values(self):\n        \"\"\"\n        Return (fg_red, fg_green, fg_blue, bg_red, bg_green, bg_blue) color\n        components.  Each component is in the range 0-255.  Values are taken\n        from the XTerm defaults and may not exactly match the user's terminal.\n\n        If the foreground or background is 'default' then all their compenents\n        will be returned as None.\n\n        >>> AttrSpec('yellow', '#ccf', colors=88).get_rgb_values()\n        (255, 255, 0, 205, 205, 255)\n        >>> AttrSpec('default', 'g92').get_rgb_values()\n        (None, None, None, 238, 238, 238)\n        \"\"\"\n        if not (self.foreground_basic or self.foreground_high or self.foreground_true):\n            vals = (None, None, None)\n        elif self.colors == 88:\n            assert self.foreground_number < 88, \"Invalid AttrSpec _value\"\n            vals = _COLOR_VALUES_88[self.foreground_number]\n        elif self.colors == 2**24:\n            h = f\"{self.foreground_number:06x}\"\n            vals = tuple([int(x, 16) for x in [h[0:2], h[2:4], h[4:6]]])\n        else:\n            vals = _COLOR_VALUES_256[self.foreground_number]\n\n        if not (self.background_basic or self.background_high or self.background_true):\n            return vals + (None, None, None)\n        elif self.colors == 88:\n            assert self.background_number < 88, \"Invalid AttrSpec _value\"\n            return vals + _COLOR_VALUES_88[self.background_number]\n        elif self.colors == 2**24:\n            h = f\"{self.background_number:06x}\"\n            return vals + tuple([int(x, 16) for x in [h[0:2], h[2:4], h[4:6]]])\n        else:\n            return vals + _COLOR_VALUES_256[self.background_number]",
  "def __eq__(self, other: typing.Any) -> bool:\n        return isinstance(other, AttrSpec) and self.__value == other.__value",
  "def __ne__(self, other: typing.Any) -> bool:\n        return not self == other",
  "def __init__(self) -> None:\n        super().__init__()\n        self._signal_keys_set = False\n        self._old_signal_keys = None",
  "def tty_signal_keys(\n        self,\n        intr: Literal['undefined'] | int | None = None,\n        quit: Literal['undefined'] | int | None = None,\n        start: Literal['undefined'] | int | None = None,\n        stop: Literal['undefined'] | int | None = None,\n        susp: Literal['undefined'] | int | None = None,\n        fileno: int | None = None,\n    ):\n        \"\"\"\n        Read and/or set the tty's signal character settings.\n        This function returns the current settings as a tuple.\n\n        Use the string 'undefined' to unmap keys from their signals.\n        The value None is used when no change is being made.\n        Setting signal keys is done using the integer ascii\n        code for the key, eg.  3 for CTRL+C.\n\n        If this function is called after start() has been called\n        then the original settings will be restored when stop()\n        is called.\n        \"\"\"\n        if fileno is None:\n            fileno = sys.stdin.fileno()\n        if not os.isatty(fileno):\n            return\n\n        tattr = termios.tcgetattr(fileno)\n        sattr = tattr[6]\n        skeys = (\n            sattr[termios.VINTR],\n            sattr[termios.VQUIT],\n            sattr[termios.VSTART],\n            sattr[termios.VSTOP],\n            sattr[termios.VSUSP],\n        )\n\n        if intr == 'undefined': intr = 0\n        if quit == 'undefined': quit = 0\n        if start == 'undefined': start = 0\n        if stop == 'undefined': stop = 0\n        if susp == 'undefined': susp = 0\n\n        if intr is not None: tattr[6][termios.VINTR] = intr\n        if quit is not None: tattr[6][termios.VQUIT] = quit\n        if start is not None: tattr[6][termios.VSTART] = start\n        if stop is not None: tattr[6][termios.VSTOP] = stop\n        if susp is not None: tattr[6][termios.VSUSP] = susp\n\n        if any(item is not None for item in (intr, quit, start, stop, susp)):\n            termios.tcsetattr(fileno, termios.TCSADRAIN, tattr)\n            self._signal_keys_set = True\n\n        return skeys",
  "def __init__(self) -> None:\n        super().__init__()\n        self._palette = {}\n        self._started = False",
  "def started(self) -> bool:\n        return self._started",
  "def start(self, *args, **kwargs) -> StoppingContext:\n        \"\"\"Set up the screen.  If the screen has already been started, does\n        nothing.\n\n        May be used as a context manager, in which case :meth:`stop` will\n        automatically be called at the end of the block:\n\n            with screen.start():\n                ...\n\n        You shouldn't override this method in a subclass; instead, override\n        :meth:`_start`.\n        \"\"\"\n        if not self._started:\n            self._started = True\n            self._start(*args, **kwargs)\n        return StoppingContext(self)",
  "def _start(self):\n        pass",
  "def stop(self) -> None:\n        if self._started:\n            self._stop()\n        self._started = False",
  "def _stop(self):\n        pass",
  "def run_wrapper(self, fn, *args, **kwargs):\n        \"\"\"Start the screen, call a function, then stop the screen.  Extra\n        arguments are passed to `start`.\n\n        Deprecated in favor of calling `start` as a context manager.\n        \"\"\"\n        warnings.warn(\n            \"run_wrapper is deprecated in favor of calling `start` as a context manager.\",\n            DeprecationWarning,\n        )\n        with self.start(*args, **kwargs):\n            return fn()",
  "def register_palette(\n        self,\n        palette: Iterable[\n            tuple[str, str]\n            | tuple[str, str, str]\n            | tuple[str, str, str, str]\n            | tuple[str, str, str, str, str, str]\n        ]\n    ) -> None:\n        \"\"\"Register a set of palette entries.\n\n        palette -- a list of (name, like_other_name) or\n        (name, foreground, background, mono, foreground_high, background_high) tuples\n\n            The (name, like_other_name) format will copy the settings\n            from the palette entry like_other_name, which must appear\n            before this tuple in the list.\n\n            The mono and foreground/background_high values are\n            optional ie. the second tuple format may have 3, 4 or 6\n            values.  See register_palette_entry() for a description\n            of the tuple values.\n        \"\"\"\n\n        for item in palette:\n            if len(item) in (3, 4, 6):\n                self.register_palette_entry(*item)\n                continue\n            if len(item) != 2:\n                raise ScreenError(f\"Invalid register_palette entry: {item!r}\")\n            name, like_name = item\n            if like_name not in self._palette:\n                raise ScreenError(f\"palette entry '{like_name}' doesn't exist\")\n            self._palette[name] = self._palette[like_name]",
  "def register_palette_entry(\n        self,\n        name: str,\n        foreground: str,\n        background: str,\n        mono: str | None = None,\n        foreground_high: str | None = None,\n        background_high: str | None = None,\n    ) -> None:\n        \"\"\"Register a single palette entry.\n\n        name -- new entry/attribute name\n\n        foreground -- a string containing a comma-separated foreground\n        color and settings\n\n            Color values:\n            'default' (use the terminal's default foreground),\n            'black', 'dark red', 'dark green', 'brown', 'dark blue',\n            'dark magenta', 'dark cyan', 'light gray', 'dark gray',\n            'light red', 'light green', 'yellow', 'light blue',\n            'light magenta', 'light cyan', 'white'\n\n            Settings:\n            'bold', 'underline', 'blink', 'standout', 'strikethrough'\n\n            Some terminals use 'bold' for bright colors.  Most terminals\n            ignore the 'blink' setting.  If the color is not given then\n            'default' will be assumed.\n\n        background -- a string containing the background color\n\n            Background color values:\n            'default' (use the terminal's default background),\n            'black', 'dark red', 'dark green', 'brown', 'dark blue',\n            'dark magenta', 'dark cyan', 'light gray'\n\n        mono -- a comma-separated string containing monochrome terminal\n        settings (see \"Settings\" above.)\n\n            None = no terminal settings (same as 'default')\n\n        foreground_high -- a string containing a comma-separated\n        foreground color and settings, standard foreground\n        colors (see \"Color values\" above) or high-colors may\n        be used\n\n            High-color example values:\n            '#009' (0% red, 0% green, 60% red, like HTML colors)\n            '#fcc' (100% red, 80% green, 80% blue)\n            'g40' (40% gray, decimal), 'g#cc' (80% gray, hex),\n            '#000', 'g0', 'g#00' (black),\n            '#fff', 'g100', 'g#ff' (white)\n            'h8' (color number 8), 'h255' (color number 255)\n\n            None = use foreground parameter value\n\n        background_high -- a string containing the background color,\n        standard background colors (see \"Background colors\" above)\n        or high-colors (see \"High-color example values\" above)\n        may be used\n\n            None = use background parameter value\n        \"\"\"\n        basic = AttrSpec(foreground, background, 16)\n\n        if isinstance(mono, tuple):\n            # old style of specifying mono attributes was to put them\n            # in a tuple.  convert to comma-separated string\n            mono = \",\".join(mono)\n        if mono is None:\n            mono = DEFAULT\n        mono = AttrSpec(mono, DEFAULT, 1)\n\n        if foreground_high is None:\n            foreground_high = foreground\n        if background_high is None:\n            background_high = background\n\n        high_256 = AttrSpec(foreground_high, background_high, 256)\n        high_true = AttrSpec(foreground_high, background_high, 2**24)\n\n        # 'hX' where X > 15 are different in 88/256 color, use\n        # basic colors for 88-color mode if high colors are specified\n        # in this way (also avoids crash when X > 87)\n        def large_h(desc: str) -> bool:\n            if not desc.startswith('h'):\n                return False\n            if ',' in desc:\n                desc = desc.split(',',1)[0]\n            num = int(desc[1:], 10)\n            return num > 15\n\n        if large_h(foreground_high) or large_h(background_high):\n            high_88 = basic\n        else:\n            high_88 = AttrSpec(foreground_high, background_high, 88)\n\n        signals.emit_signal(self, UPDATE_PALETTE_ENTRY,\n                            name, basic, mono, high_88, high_256, high_true)\n        self._palette[name] = (basic, mono, high_88, high_256, high_true)",
  "def large_h(desc: str) -> bool:\n            if not desc.startswith('h'):\n                return False\n            if ',' in desc:\n                desc = desc.split(',',1)[0]\n            num = int(desc[1:], 10)\n            return num > 15",
  "class Screen(BaseScreen, RealTerminal):\n    def __init__(self, input=sys.stdin, output=sys.stdout, bracketed_paste_mode=False):\n        \"\"\"Initialize a screen that directly prints escape codes to an output\n        terminal.\n\n        bracketed_paste_mode -- enable bracketed paste mode in the host terminal.\n            If the host terminal supports it, the application will receive `begin paste`\n            and `end paste` keystrokes when the user pastes text.\n        \"\"\"\n        super().__init__()\n        self._pal_escape = {}\n        self._pal_attrspec = {}\n        signals.connect_signal(self, UPDATE_PALETTE_ENTRY, self._on_update_palette_entry)\n        self.colors = 16  # FIXME: detect this\n        self.has_underline = True  # FIXME: detect this\n        self._keyqueue = []\n        self.prev_input_resize = 0\n        self.set_input_timeouts()\n        self.screen_buf = None\n        self._screen_buf_canvas = None\n        self._resized = False\n        self.maxrow = None\n        self.gpm_mev: Popen | None = None\n        self.gpm_event_pending: bool = False\n        self._mouse_tracking_enabled = False\n        self.last_bstate = 0\n        self._setup_G1_done = False\n        self._rows_used = None\n        self._cy = 0\n        self.term = os.environ.get('TERM', '')\n        self.fg_bright_is_bold = not self.term.startswith(\"xterm\")\n        self.bg_bright_is_blink = (self.term == \"linux\")\n        self.back_color_erase = not self.term.startswith(\"screen\")\n        self.register_palette_entry( None, 'default','default')\n        self._next_timeout = None\n        self.signal_handler_setter = signal.signal\n        self.bracketed_paste_mode = bracketed_paste_mode\n\n        # Our connections to the world\n        self._term_output_file = output\n        self._term_input_file = input\n\n        # pipe for signalling external event loops about resize events\n        self._resize_pipe_rd, self._resize_pipe_wr = os.pipe()\n        fcntl.fcntl(self._resize_pipe_rd, fcntl.F_SETFL, os.O_NONBLOCK)\n\n        # These store the previous signal handlers after setting ours\n        self._prev_sigcont_handler = None\n        self._prev_sigtstp_handler = None\n        self._prev_sigwinch_handler = None\n\n    def _input_fileno(self):\n        \"\"\"Returns the fileno of the input stream, or None if it doesn't have one.  A stream without a fileno can't participate in whatever.\n        \"\"\"\n        if hasattr(self._term_input_file, 'fileno'):\n            return self._term_input_file.fileno()\n        else:\n            return None\n\n    def _on_update_palette_entry(self, name, *attrspecs):\n        # copy the attribute to a dictionary containing the escape seqences\n        a = attrspecs[{16:0,1:1,88:2,256:3,2**24:4}[self.colors]]\n        self._pal_attrspec[name] = a\n        self._pal_escape[name] = self._attrspec_to_escape(a)\n\n    def set_input_timeouts(self, max_wait=None, complete_wait=0.125,\n        resize_wait=0.125):\n        \"\"\"\n        Set the get_input timeout values.  All values are in floating\n        point numbers of seconds.\n\n        max_wait -- amount of time in seconds to wait for input when\n            there is no input pending, wait forever if None\n        complete_wait -- amount of time in seconds to wait when\n            get_input detects an incomplete escape sequence at the\n            end of the available input\n        resize_wait -- amount of time in seconds to wait for more input\n            after receiving two screen resize requests in a row to\n            stop Urwid from consuming 100% cpu during a gradual\n            window resize operation\n        \"\"\"\n        self.max_wait = max_wait\n        if max_wait is not None:\n            if self._next_timeout is None:\n                self._next_timeout = max_wait\n            else:\n                self._next_timeout = min(self._next_timeout, self.max_wait)\n        self.complete_wait = complete_wait\n        self.resize_wait = resize_wait\n\n    def _sigwinch_handler(self, signum, frame=None):\n        \"\"\"\n        frame -- will always be None when the GLib event loop is being used.\n        \"\"\"\n\n        if not self._resized:\n            os.write(self._resize_pipe_wr, b'R')\n        self._resized = True\n        self.screen_buf = None\n\n        if callable(self._prev_sigwinch_handler):\n            self._prev_sigwinch_handler(signum, frame)\n\n    def _sigtstp_handler(self, signum, frame=None):\n        self.stop() # Restores the previous signal handlers\n        self._prev_sigcont_handler = self.signal_handler_setter(signal.SIGCONT, self._sigcont_handler)\n        # Handled by the previous handler.\n        # If non-default, it may set its own SIGCONT handler which should hopefully call our own.\n        os.kill(os.getpid(), signal.SIGTSTP)\n\n    def _sigcont_handler(self, signum, frame=None):\n        \"\"\"\n        frame -- will always be None when the GLib event loop is being used.\n        \"\"\"\n        self.signal_restore()\n\n        if callable(self._prev_sigcont_handler):\n            # May set its own SIGTSTP handler which would be stored and replaced in\n            # `signal_init()` (via `start()`).\n            self._prev_sigcont_handler(signum, frame)\n\n        self.start()\n        self._sigwinch_handler(None, None)\n\n    def signal_init(self):\n        \"\"\"\n        Called in the startup of run wrapper to set the SIGWINCH\n        and SIGTSTP signal handlers.\n\n        Override this function to call from main thread in threaded\n        applications.\n        \"\"\"\n        self._prev_sigwinch_handler = self.signal_handler_setter(signal.SIGWINCH, self._sigwinch_handler)\n        self._prev_sigtstp_handler = self.signal_handler_setter(signal.SIGTSTP, self._sigtstp_handler)\n\n    def signal_restore(self):\n        \"\"\"\n        Called in the finally block of run wrapper to restore the\n        SIGTSTP, SIGCONT and SIGWINCH signal handlers.\n\n        Override this function to call from main thread in threaded\n        applications.\n        \"\"\"\n        self.signal_handler_setter(signal.SIGTSTP, self._prev_sigtstp_handler or signal.SIG_DFL)\n        self.signal_handler_setter(signal.SIGCONT, self._prev_sigcont_handler or signal.SIG_DFL)\n        self.signal_handler_setter(signal.SIGWINCH, self._prev_sigwinch_handler or signal.SIG_DFL)\n\n    def set_mouse_tracking(self, enable=True):\n        \"\"\"\n        Enable (or disable) mouse tracking.\n\n        After calling this function get_input will include mouse\n        click events along with keystrokes.\n        \"\"\"\n        enable = bool(enable)\n        if enable == self._mouse_tracking_enabled:\n            return\n\n        self._mouse_tracking(enable)\n        self._mouse_tracking_enabled = enable\n\n    def _mouse_tracking(self, enable):\n        if enable:\n            self.write(escape.MOUSE_TRACKING_ON)\n            self._start_gpm_tracking()\n        else:\n            self.write(escape.MOUSE_TRACKING_OFF)\n            self._stop_gpm_tracking()\n\n    def _start_gpm_tracking(self):\n        if not os.path.isfile(\"/usr/bin/mev\"):\n            return\n        if not os.environ.get('TERM', \"\").lower().startswith(\"linux\"):\n            return\n\n        m = Popen([\"/usr/bin/mev\", \"-e\", \"158\"], stdin=PIPE, stdout=PIPE, close_fds=True, encoding=\"ascii\")\n        fcntl.fcntl(m.stdout.fileno(), fcntl.F_SETFL, os.O_NONBLOCK)\n        self.gpm_mev = m\n\n    def _stop_gpm_tracking(self):\n        if not self.gpm_mev:\n            return\n        os.kill(self.gpm_mev.pid, signal.SIGINT)\n        os.waitpid(self.gpm_mev.pid, 0)\n        self.gpm_mev = None\n\n    def _start(self, alternate_buffer=True):\n        \"\"\"\n        Initialize the screen and input mode.\n\n        alternate_buffer -- use alternate screen buffer\n        \"\"\"\n        if alternate_buffer:\n            self.write(escape.SWITCH_TO_ALTERNATE_BUFFER)\n            self._rows_used = None\n        else:\n            self._rows_used = 0\n\n        if (self.bracketed_paste_mode):\n            self.write(escape.ENABLE_BRACKETED_PASTE_MODE)\n            \n        fd = self._input_fileno()\n        if fd is not None and os.isatty(fd):\n            self._old_termios_settings = termios.tcgetattr(fd)\n            tty.setcbreak(fd)\n\n        self.signal_init()\n        self._alternate_buffer = alternate_buffer\n        self._next_timeout = self.max_wait\n\n        if not self._signal_keys_set:\n            self._old_signal_keys = self.tty_signal_keys(fileno=fd)\n\n        signals.emit_signal(self, INPUT_DESCRIPTORS_CHANGED)\n        # restore mouse tracking to previous state\n        self._mouse_tracking(self._mouse_tracking_enabled)\n\n        return super()._start()\n\n    def _stop(self):\n        \"\"\"\n        Restore the screen.\n        \"\"\"\n        self.clear()\n\n        if (self.bracketed_paste_mode):\n            self.write(escape.DISABLE_BRACKETED_PASTE_MODE)\n        \n        signals.emit_signal(self, INPUT_DESCRIPTORS_CHANGED)\n\n        self.signal_restore()\n\n        fd = self._input_fileno()\n        if fd is not None and os.isatty(fd):\n            termios.tcsetattr(fd, termios.TCSADRAIN, self._old_termios_settings)\n\n        self._mouse_tracking(False)\n\n        move_cursor = \"\"\n        if self._alternate_buffer:\n            move_cursor = escape.RESTORE_NORMAL_BUFFER\n        elif self.maxrow is not None:\n            move_cursor = escape.set_cursor_position(\n                0, self.maxrow)\n        self.write(\n            self._attrspec_to_escape(AttrSpec('',''))\n            + escape.SI\n            + move_cursor\n            + escape.SHOW_CURSOR)\n        self.flush()\n\n        if self._old_signal_keys:\n            self.tty_signal_keys(*(self._old_signal_keys + (fd,)))\n\n        super()._stop()\n\n\n    def write(self, data):\n        \"\"\"Write some data to the terminal.\n\n        You may wish to override this if you're using something other than\n        regular files for input and output.\n        \"\"\"\n        self._term_output_file.write(data)\n\n    def flush(self):\n        \"\"\"Flush the output buffer.\n\n        You may wish to override this if you're using something other than\n        regular files for input and output.\n        \"\"\"\n        self._term_output_file.flush()\n\n    @typing.overload\n    def get_input(self, raw_keys: Literal[False]) -> list[str]:\n        ...\n\n    @typing.overload\n    def get_input(self, raw_keys: Literal[True]) -> tuple[list[str], list[int]]:\n        ...\n\n    def get_input(self, raw_keys: bool = False) -> list[str] | tuple[list[str], list[int]]:\n        \"\"\"Return pending input as a list.\n\n        raw_keys -- return raw keycodes as well as translated versions\n\n        This function will immediately return all the input since the\n        last time it was called.  If there is no input pending it will\n        wait before returning an empty list.  The wait time may be\n        configured with the set_input_timeouts function.\n\n        If raw_keys is False (default) this function will return a list\n        of keys pressed.  If raw_keys is True this function will return\n        a ( keys pressed, raw keycodes ) tuple instead.\n\n        Examples of keys returned:\n\n        * ASCII printable characters:  \" \", \"a\", \"0\", \"A\", \"-\", \"/\"\n        * ASCII control characters:  \"tab\", \"enter\"\n        * Escape sequences:  \"up\", \"page up\", \"home\", \"insert\", \"f1\"\n        * Key combinations:  \"shift f1\", \"meta a\", \"ctrl b\"\n        * Window events:  \"window resize\"\n\n        When a narrow encoding is not enabled:\n\n        * \"Extended ASCII\" characters:  \"\\\\xa1\", \"\\\\xb2\", \"\\\\xfe\"\n\n        When a wide encoding is enabled:\n\n        * Double-byte characters:  \"\\\\xa1\\\\xea\", \"\\\\xb2\\\\xd4\"\n\n        When utf8 encoding is enabled:\n\n        * Unicode characters: u\"\\\\u00a5\", u'\\\\u253c\"\n\n        Examples of mouse events returned:\n\n        * Mouse button press: ('mouse press', 1, 15, 13),\n                              ('meta mouse press', 2, 17, 23)\n        * Mouse drag: ('mouse drag', 1, 16, 13),\n                      ('mouse drag', 1, 17, 13),\n                      ('ctrl mouse drag', 1, 18, 13)\n        * Mouse button release: ('mouse release', 0, 18, 13),\n                                ('ctrl mouse release', 0, 17, 23)\n        \"\"\"\n        assert self._started\n\n        self._wait_for_input_ready(self._next_timeout)\n        keys, raw = self.parse_input(None, None, self.get_available_raw_input())\n\n        # Avoid pegging CPU at 100% when slowly resizing\n        if keys == ['window resize'] and self.prev_input_resize:\n            while True:\n                self._wait_for_input_ready(self.resize_wait)\n                keys, raw2 = self.parse_input(None, None, self.get_available_raw_input())\n                raw += raw2\n                # if not keys:\n                #     keys, raw2 = self._get_input(\n                #         self.resize_wait)\n                #     raw += raw2\n                if keys != ['window resize']:\n                    break\n            if keys[-1:] != ['window resize']:\n                keys.append('window resize')\n\n        if keys == ['window resize']:\n            self.prev_input_resize = 2\n        elif self.prev_input_resize == 2 and not keys:\n            self.prev_input_resize = 1\n        else:\n            self.prev_input_resize = 0\n\n        if raw_keys:\n            return keys, raw\n        return keys\n\n    def get_input_descriptors(self) -> list[int]:\n        \"\"\"\n        Return a list of integer file descriptors that should be\n        polled in external event loops to check for user input.\n\n        Use this method if you are implementing your own event loop.\n\n        This method is only called by `hook_event_loop`, so if you override\n        that, you can safely ignore this.\n        \"\"\"\n        if not self._started:\n            return []\n\n        fd_list = [self._resize_pipe_rd]\n        fd = self._input_fileno()\n        if fd is not None:\n            fd_list.append(fd)\n        if self.gpm_mev is not None:\n            fd_list.append(self.gpm_mev.stdout.fileno())\n        return fd_list\n\n    _current_event_loop_handles = ()\n\n    def unhook_event_loop(self, event_loop):\n        \"\"\"\n        Remove any hooks added by hook_event_loop.\n        \"\"\"\n        for handle in self._current_event_loop_handles:\n            event_loop.remove_watch_file(handle)\n\n        if self._input_timeout:\n            event_loop.remove_alarm(self._input_timeout)\n            self._input_timeout = None\n\n    def hook_event_loop(self, event_loop, callback):\n        \"\"\"\n        Register the given callback with the event loop, to be called with new\n        input whenever it's available.  The callback should be passed a list of\n        processed keys and a list of unprocessed keycodes.\n\n        Subclasses may wish to use parse_input to wrap the callback.\n        \"\"\"\n        if hasattr(self, 'get_input_nonblocking'):\n            wrapper = self._make_legacy_input_wrapper(event_loop, callback)\n        else:\n            wrapper = lambda: self.parse_input(\n                event_loop, callback, self.get_available_raw_input())\n        fds = self.get_input_descriptors()\n        handles = [event_loop.watch_file(fd, wrapper) for fd in fds]\n        self._current_event_loop_handles = handles\n\n    _input_timeout = None\n    _partial_codes = None\n\n    def _make_legacy_input_wrapper(self, event_loop, callback):\n        \"\"\"\n        Support old Screen classes that still have a get_input_nonblocking and\n        expect it to work.\n        \"\"\"\n        def wrapper():\n            if self._input_timeout:\n                event_loop.remove_alarm(self._input_timeout)\n                self._input_timeout = None\n            timeout, keys, raw = self.get_input_nonblocking()\n            if timeout is not None:\n                self._input_timeout = event_loop.alarm(timeout, wrapper)\n\n            callback(keys, raw)\n\n        return wrapper\n\n    def get_available_raw_input(self):\n        \"\"\"\n        Return any currently-available input.  Does not block.\n\n        This method is only used by the default `hook_event_loop`\n        implementation; you can safely ignore it if you implement your own.\n        \"\"\"\n        codes = self._get_gpm_codes() + self._get_keyboard_codes()\n\n        if self._partial_codes:\n            codes = self._partial_codes + codes\n            self._partial_codes = None\n\n        # clean out the pipe used to signal external event loops\n        # that a resize has occurred\n        try:\n            while True: os.read(self._resize_pipe_rd, 1)\n        except OSError:\n            pass\n\n        return codes\n\n    def parse_input(self, event_loop, callback, codes, wait_for_more=True):\n        \"\"\"\n        Read any available input from get_available_raw_input, parses it into\n        keys, and calls the given callback.\n\n        The current implementation tries to avoid any assumptions about what\n        the screen or event loop look like; it only deals with parsing keycodes\n        and setting a timeout when an incomplete one is detected.\n\n        `codes` should be a sequence of keycodes, i.e. bytes.  A bytearray is\n        appropriate, but beware of using bytes, which only iterates as integers\n        on Python 3.\n        \"\"\"\n        # Note: event_loop may be None for 100% synchronous support, only used\n        # by get_input.  Not documented because you shouldn't be doing it.\n        if self._input_timeout and event_loop:\n            event_loop.remove_alarm(self._input_timeout)\n            self._input_timeout = None\n\n        original_codes = codes\n        processed = []\n        try:\n            while codes:\n                run, codes = escape.process_keyqueue(\n                    codes, wait_for_more)\n                processed.extend(run)\n        except escape.MoreInputRequired:\n            # Set a timer to wait for the rest of the input; if it goes off\n            # without any new input having come in, use the partial input\n            k = len(original_codes) - len(codes)\n            processed_codes = original_codes[:k]\n            self._partial_codes = codes\n\n            def _parse_incomplete_input():\n                self._input_timeout = None\n                self._partial_codes = None\n                self.parse_input(\n                    event_loop, callback, codes, wait_for_more=False)\n            if event_loop:\n                self._input_timeout = event_loop.alarm(\n                    self.complete_wait, _parse_incomplete_input)\n\n        else:\n            processed_codes = original_codes\n            self._partial_codes = None\n\n        if self._resized:\n            processed.append('window resize')\n            self._resized = False\n\n        if callback:\n            callback(processed, processed_codes)\n        else:\n            # For get_input\n            return processed, processed_codes\n\n    def _get_keyboard_codes(self):\n        codes = []\n        while True:\n            code = self._getch_nodelay()\n            if code < 0:\n                break\n            codes.append(code)\n        return codes\n\n    def _get_gpm_codes(self):\n        codes = []\n        try:\n            while self.gpm_mev is not None and self.gpm_event_pending:\n                codes.extend(self._encode_gpm_event())\n        except OSError as e:\n            if e.args[0] != 11:\n                raise\n        return codes\n\n    def _wait_for_input_ready(self, timeout):\n        ready = None\n        fd_list = [self._resize_pipe_rd]\n        fd = self._input_fileno()\n        if fd is not None:\n            fd_list.append(fd)\n        if self.gpm_mev is not None:\n            fd_list.append(self.gpm_mev.stdout.fileno())\n        while True:\n            try:\n                if timeout is None:\n                    ready,w,err = select.select(\n                        fd_list, [], fd_list)\n                else:\n                    ready,w,err = select.select(\n                        fd_list,[],fd_list, timeout)\n                break\n            except OSError as e:\n                if e.args[0] != 4:\n                    raise\n                if self._resized:\n                    ready = []\n                    break\n        return ready\n\n    def _getch(self, timeout: int) ->int:\n        ready = self._wait_for_input_ready(timeout)\n        if self.gpm_mev is not None:\n            if self.gpm_mev.stdout.fileno() in ready:\n                self.gpm_event_pending = True\n        fd = self._input_fileno()\n        if fd is not None and fd in ready:\n            return ord(os.read(fd, 1))\n        return -1\n\n    def _encode_gpm_event(self) -> list[int]:\n        self.gpm_event_pending = False\n        s = self.gpm_mev.stdout.readline()\n        l = s.split(\", \")\n        if len(l) != 6:\n            # unexpected output, stop tracking\n            self._stop_gpm_tracking()\n            signals.emit_signal(self, INPUT_DESCRIPTORS_CHANGED)\n            return []\n        ev, x, y, ign, b, m = s.split(\",\")\n        ev = int(ev.split(\"x\")[-1], 16)\n        x = int( x.split(\" \")[-1] )\n        y = int( y.lstrip().split(\" \")[0] )\n        b = int( b.split(\" \")[-1] )\n        m = int( m.split(\"x\")[-1].rstrip(), 16 )\n\n        # convert to xterm-like escape sequence\n\n        last = next = self.last_bstate\n        l = []\n\n        mod = 0\n        if m & 1:\n            mod |= 4 # shift\n        if m & 10:\n            mod |= 8 # alt\n        if m & 4:\n            mod |= 16 # ctrl\n\n        def append_button(b):\n            b |= mod\n            l.extend([27, ord('['), ord('M'), b+32, x+32, y+32])\n\n        def determine_button_release(flag: int) -> None:\n            if b & 4 and last & 1:\n                append_button( 0 + flag )\n                next |= 1\n            if b & 2 and last & 2:\n                append_button( 1 + flag )\n                next |= 2\n            if b & 1 and last & 4:\n                append_button( 2 + flag )\n                next |= 4\n\n        if ev == 20 or ev == 36 or ev == 52: # press\n            if b & 4 and last & 1 == 0:\n                append_button( 0 )\n                next |= 1\n            if b & 2 and last & 2 == 0:\n                append_button( 1 )\n                next |= 2\n            if b & 1 and last & 4 == 0:\n                append_button( 2 )\n                next |= 4\n        elif ev == 146: # drag\n            if b & 4:\n                append_button( 0 + escape.MOUSE_DRAG_FLAG )\n            elif b & 2:\n                append_button( 1 + escape.MOUSE_DRAG_FLAG )\n            elif b & 1:\n                append_button( 2 + escape.MOUSE_DRAG_FLAG )\n        else: # release\n            if b & 4 and last & 1:\n                append_button( 0 + escape.MOUSE_RELEASE_FLAG )\n                next &= ~ 1\n            if b & 2 and last & 2:\n                append_button( 1 + escape.MOUSE_RELEASE_FLAG )\n                next &= ~ 2\n            if b & 1 and last & 4:\n                append_button( 2 + escape.MOUSE_RELEASE_FLAG )\n                next &= ~ 4\n        if ev == 40: # double click (release)\n            if b & 4 and last & 1:\n                append_button( 0 + escape.MOUSE_MULTIPLE_CLICK_FLAG )\n            if b & 2 and last & 2:\n                append_button( 1 + escape.MOUSE_MULTIPLE_CLICK_FLAG )\n            if b & 1 and last & 4:\n                append_button( 2 + escape.MOUSE_MULTIPLE_CLICK_FLAG )\n        elif ev == 52:\n            if b & 4 and last & 1:\n                append_button( 0 + escape.MOUSE_MULTIPLE_CLICK_FLAG*2 )\n            if b & 2 and last & 2:\n                append_button( 1 + escape.MOUSE_MULTIPLE_CLICK_FLAG*2 )\n            if b & 1 and last & 4:\n                append_button( 2 + escape.MOUSE_MULTIPLE_CLICK_FLAG*2 )\n\n        self.last_bstate = next\n        return l\n\n    def _getch_nodelay(self):\n        return self._getch(0)\n\n    def get_cols_rows(self):\n        \"\"\"Return the terminal dimensions (num columns, num rows).\"\"\"\n        y, x = 24, 80\n        try:\n            if hasattr(self._term_output_file, 'fileno'):\n                buf = fcntl.ioctl(self._term_output_file.fileno(), termios.TIOCGWINSZ, ' '*4)\n                y, x = struct.unpack('hh', buf)\n        except OSError:\n            # Term size could not be determined\n            pass\n        # Provide some lightweight fallbacks in case the TIOCWINSZ doesn't\n        # give sane answers\n        if (x <= 0 or y <= 0) and self.term in ('ansi', 'vt100'):\n                y, x = 24, 80\n        self.maxrow = y\n        return x, y\n\n    def _setup_G1(self):\n        \"\"\"\n        Initialize the G1 character set to graphics mode if required.\n        \"\"\"\n        if self._setup_G1_done:\n            return\n\n        while True:\n            try:\n                self.write(escape.DESIGNATE_G1_SPECIAL)\n                self.flush()\n                break\n            except OSError:\n                pass\n        self._setup_G1_done = True\n\n\n    def draw_screen(self, maxres, r ):\n        \"\"\"Paint screen with rendered canvas.\"\"\"\n\n        (maxcol, maxrow) = maxres\n\n        assert self._started\n\n        assert maxrow == r.rows()\n\n        # quick return if nothing has changed\n        if self.screen_buf and r is self._screen_buf_canvas:\n            return\n\n        self._setup_G1()\n\n        if self._resized:\n            # handle resize before trying to draw screen\n            return\n\n        o = [escape.HIDE_CURSOR, self._attrspec_to_escape(AttrSpec('',''))]\n\n        def partial_display():\n            # returns True if the screen is in partial display mode\n            # ie. only some rows belong to the display\n            return self._rows_used is not None\n\n        if not partial_display():\n            o.append(escape.CURSOR_HOME)\n\n        if self.screen_buf:\n            osb = self.screen_buf\n        else:\n            osb = []\n        sb = []\n        cy = self._cy\n        y = -1\n\n        def set_cursor_home():\n            if not partial_display():\n                return escape.set_cursor_position(0, 0)\n            return (escape.CURSOR_HOME_COL +\n                escape.move_cursor_up(cy))\n\n        def set_cursor_row(y):\n            if not partial_display():\n                return escape.set_cursor_position(0, y)\n            return escape.move_cursor_down(y - cy)\n\n        def set_cursor_position(x, y):\n            if not partial_display():\n                return escape.set_cursor_position(x, y)\n            if cy > y:\n                return ('\\b' + escape.CURSOR_HOME_COL +\n                    escape.move_cursor_up(cy - y) +\n                    escape.move_cursor_right(x))\n            return ('\\b' + escape.CURSOR_HOME_COL +\n                escape.move_cursor_down(y - cy) +\n                escape.move_cursor_right(x))\n\n        def is_blank_row(row):\n            if len(row) > 1:\n                return False\n            if row[0][2].strip():\n                return False\n            return True\n\n        def attr_to_escape(a):\n            if a in self._pal_escape:\n                return self._pal_escape[a]\n            elif isinstance(a, AttrSpec):\n                return self._attrspec_to_escape(a)\n            # undefined attributes use default/default\n            # TODO: track and report these\n            return self._attrspec_to_escape(\n                AttrSpec('default','default'))\n\n        def using_standout_or_underline(a):\n            a = self._pal_attrspec.get(a, a)\n            return isinstance(a, AttrSpec) and (a.standout or a.underline)\n\n        ins = None\n        o.append(set_cursor_home())\n        cy = 0\n        for row in r.content():\n            y += 1\n            if osb and y < len(osb) and osb[y] == row:\n                # this row of the screen buffer matches what is\n                # currently displayed, so we can skip this line\n                sb.append( osb[y] )\n                continue\n\n            sb.append(row)\n\n            # leave blank lines off display when we are using\n            # the default screen buffer (allows partial screen)\n            if partial_display() and y > self._rows_used:\n                if is_blank_row(row):\n                    continue\n                self._rows_used = y\n\n            if y or partial_display():\n                o.append(set_cursor_position(0, y))\n            # after updating the line we will be just over the\n            # edge, but terminals still treat this as being\n            # on the same line\n            cy = y\n\n            whitespace_at_end = False\n            if row:\n                a, cs, run = row[-1]\n                if (run[-1:] == b' ' and self.back_color_erase\n                        and not using_standout_or_underline(a)):\n                    whitespace_at_end = True\n                    row = row[:-1] + [(a, cs, run.rstrip(b' '))]\n                elif y == maxrow-1 and maxcol > 1:\n                    row, back, ins = self._last_row(row)\n\n            first = True\n            lasta = lastcs = None\n            for (a,cs, run) in row:\n                assert isinstance(run, bytes) # canvases should render with bytes\n                if cs != 'U':\n                    run = run.translate(UNPRINTABLE_TRANS_TABLE)\n                if first or lasta != a:\n                    o.append(attr_to_escape(a))\n                    lasta = a\n                if first or lastcs != cs:\n                    assert cs in [None, \"0\", \"U\"], repr(cs)\n                    if lastcs == \"U\":\n                        o.append( escape.IBMPC_OFF )\n\n                    if cs is None:\n                        o.append( escape.SI )\n                    elif cs == \"U\":\n                        o.append( escape.IBMPC_ON )\n                    else:\n                        o.append( escape.SO )\n                    lastcs = cs\n                o.append( run )\n                first = False\n            if ins:\n                (inserta, insertcs, inserttext) = ins\n                ias = attr_to_escape(inserta)\n                assert insertcs in [None, \"0\", \"U\"], repr(insertcs)\n                if cs is None:\n                    icss = escape.SI\n                elif cs == \"U\":\n                    icss = escape.IBMPC_ON\n                else:\n                    icss = escape.SO\n                o += [\"\\x08\" * back,\n                    ias, icss,\n                    escape.INSERT_ON, inserttext,\n                    escape.INSERT_OFF ]\n\n                if cs == \"U\":\n                    o.append(escape.IBMPC_OFF)\n            if whitespace_at_end:\n                o.append(escape.ERASE_IN_LINE_RIGHT)\n\n        if r.cursor is not None:\n            x,y = r.cursor\n            o += [set_cursor_position(x, y),\n                escape.SHOW_CURSOR  ]\n            self._cy = y\n\n        if self._resized:\n            # handle resize before trying to draw screen\n            return\n        try:\n            for l in o:\n                if isinstance(l, bytes):\n                    l = l.decode('utf-8', 'replace')\n                self.write(l)\n            self.flush()\n        except OSError as e:\n            # ignore interrupted syscall\n            if e.args[0] != 4:\n                raise\n\n        self.screen_buf = sb\n        self._screen_buf_canvas = r\n\n\n    def _last_row(self, row):\n        \"\"\"On the last row we need to slide the bottom right character\n        into place. Calculate the new line, attr and an insert sequence\n        to do that.\n\n        eg. last row:\n        XXXXXXXXXXXXXXXXXXXXYZ\n\n        Y will be drawn after Z, shifting Z into position.\n        \"\"\"\n\n        new_row = row[:-1]\n        z_attr, z_cs, last_text = row[-1]\n        last_cols = util.calc_width(last_text, 0, len(last_text))\n        last_offs, z_col = util.calc_text_pos(last_text, 0,\n            len(last_text), last_cols-1)\n        if last_offs == 0:\n            z_text = last_text\n            del new_row[-1]\n            # we need another segment\n            y_attr, y_cs, nlast_text = row[-2]\n            nlast_cols = util.calc_width(nlast_text, 0,\n                len(nlast_text))\n            z_col += nlast_cols\n            nlast_offs, y_col = util.calc_text_pos(nlast_text, 0,\n                len(nlast_text), nlast_cols-1)\n            y_text = nlast_text[nlast_offs:]\n            if nlast_offs:\n                new_row.append((y_attr, y_cs,\n                    nlast_text[:nlast_offs]))\n        else:\n            z_text = last_text[last_offs:]\n            y_attr, y_cs = z_attr, z_cs\n            nlast_cols = util.calc_width(last_text, 0,\n                last_offs)\n            nlast_offs, y_col = util.calc_text_pos(last_text, 0,\n                last_offs, nlast_cols-1)\n            y_text = last_text[nlast_offs:last_offs]\n            if nlast_offs:\n                new_row.append((y_attr, y_cs,\n                    last_text[:nlast_offs]))\n\n        new_row.append((z_attr, z_cs, z_text))\n        return new_row, z_col-y_col, (y_attr, y_cs, y_text)\n\n\n\n    def clear(self):\n        \"\"\"\n        Force the screen to be completely repainted on the next\n        call to draw_screen().\n        \"\"\"\n        self.screen_buf = None\n        self.setup_G1 = True\n\n\n    def _attrspec_to_escape(self, a):\n        \"\"\"\n        Convert AttrSpec instance a to an escape sequence for the terminal\n\n        >>> s = Screen()\n        >>> s.set_terminal_properties(colors=256)\n        >>> a2e = s._attrspec_to_escape\n        >>> a2e(s.AttrSpec('brown', 'dark green'))\n        '\\\\x1b[0;33;42m'\n        >>> a2e(s.AttrSpec('#fea,underline', '#d0d'))\n        '\\\\x1b[0;38;5;229;4;48;5;164m'\n        \"\"\"\n        if self.term == 'fbterm':\n            fg = escape.ESC + '[1;%d}' % (a.foreground_number,)\n            bg = escape.ESC + '[2;%d}' % (a.background_number,)\n            return fg + bg\n\n        if a.foreground_true:\n            fg = \"38;2;%d;%d;%d\" %(a.get_rgb_values()[0:3])\n        elif a.foreground_high:\n            fg = \"38;5;%d\" % a.foreground_number\n        elif a.foreground_basic:\n            if a.foreground_number > 7:\n                if self.fg_bright_is_bold:\n                    fg = \"1;%d\" % (a.foreground_number - 8 + 30)\n                else:\n                    fg = \"%d\" % (a.foreground_number - 8 + 90)\n            else:\n                fg = \"%d\" % (a.foreground_number + 30)\n        else:\n            fg = \"39\"\n        st = (\"1;\" * a.bold + \"3;\" * a.italics +\n              \"4;\" * a.underline + \"5;\" * a.blink +\n              \"7;\" * a.standout + \"9;\" * a.strikethrough)\n        if a.background_true:\n             bg = \"48;2;%d;%d;%d\" %(a.get_rgb_values()[3:6])\n        elif a.background_high:\n            bg = \"48;5;%d\" % a.background_number\n        elif a.background_basic:\n            if a.background_number > 7:\n                if self.bg_bright_is_blink:\n                    bg = \"5;%d\" % (a.background_number - 8 + 40)\n                else:\n                    # this doesn't work on most terminals\n                    bg = \"%d\" % (a.background_number - 8 + 100)\n            else:\n                bg = \"%d\" % (a.background_number + 40)\n        else:\n            bg = \"49\"\n        return f\"{escape.ESC}[0;{fg};{st}{bg}m\"\n\n\n    def set_terminal_properties(self, colors=None, bright_is_bold=None,\n        has_underline=None):\n        \"\"\"\n        colors -- number of colors terminal supports (1, 16, 88, 256, or 2**24)\n            or None to leave unchanged\n        bright_is_bold -- set to True if this terminal uses the bold\n            setting to create bright colors (numbers 8-15), set to False\n            if this Terminal can create bright colors without bold or\n            None to leave unchanged\n        has_underline -- set to True if this terminal can use the\n            underline setting, False if it cannot or None to leave\n            unchanged\n        \"\"\"\n        if colors is None:\n            colors = self.colors\n        if bright_is_bold is None:\n            bright_is_bold = self.fg_bright_is_bold\n        if has_underline is None:\n            has_underline = self.has_underline\n\n        if colors == self.colors and bright_is_bold == self.fg_bright_is_bold \\\n            and has_underline == self.has_underline:\n            return\n\n        self.colors = colors\n        self.fg_bright_is_bold = bright_is_bold\n        self.has_underline = has_underline\n\n        self.clear()\n        self._pal_escape = {}\n        for p,v in self._palette.items():\n            self._on_update_palette_entry(p, *v)\n\n\n\n    def reset_default_terminal_palette(self):\n        \"\"\"\n        Attempt to set the terminal palette to default values as taken\n        from xterm.  Uses number of colors from current\n        set_terminal_properties() screen setting.\n        \"\"\"\n        if self.colors == 1:\n            return\n        elif self.colors == 2**24:\n            colors = 256\n        else:\n            colors = self.colors\n\n        def rgb_values(n):\n            if colors == 16:\n                aspec = AttrSpec(\"h%d\"%n, \"\", 256)\n            else:\n                aspec = AttrSpec(\"h%d\"%n, \"\", colors)\n            return aspec.get_rgb_values()[:3]\n\n        entries = [(n,) + rgb_values(n) for n in range(min(colors, 256))]\n        self.modify_terminal_palette(entries)\n\n\n    def modify_terminal_palette(self, entries):\n        \"\"\"\n        entries - list of (index, red, green, blue) tuples.\n\n        Attempt to set part of the terminal palette (this does not work\n        on all terminals.)  The changes are sent as a single escape\n        sequence so they should all take effect at the same time.\n\n        0 <= index < 256 (some terminals will only have 16 or 88 colors)\n        0 <= red, green, blue < 256\n        \"\"\"\n\n        if self.term == 'fbterm':\n            modify = [\"%d;%d;%d;%d\" % (index, red, green, blue)\n                for index, red, green, blue in entries]\n            self.write(f\"\\x1b[3;{';'.join(modify)}}}\")\n        else:\n            modify = [\"%d;rgb:%02x/%02x/%02x\" % (index, red, green, blue)\n                for index, red, green, blue in entries]\n            self.write(f\"\\x1b]4;{';'.join(modify)}\\x1b\\\\\")\n        self.flush()\n\n\n    # shortcut for creating an AttrSpec with this screen object's\n    # number of colors\n    AttrSpec = lambda self, fg, bg: AttrSpec(fg, bg, self.colors)",
  "def _test():\n    import doctest\n    doctest.testmod()",
  "def __init__(self, input=sys.stdin, output=sys.stdout, bracketed_paste_mode=False):\n        \"\"\"Initialize a screen that directly prints escape codes to an output\n        terminal.\n\n        bracketed_paste_mode -- enable bracketed paste mode in the host terminal.\n            If the host terminal supports it, the application will receive `begin paste`\n            and `end paste` keystrokes when the user pastes text.\n        \"\"\"\n        super().__init__()\n        self._pal_escape = {}\n        self._pal_attrspec = {}\n        signals.connect_signal(self, UPDATE_PALETTE_ENTRY, self._on_update_palette_entry)\n        self.colors = 16  # FIXME: detect this\n        self.has_underline = True  # FIXME: detect this\n        self._keyqueue = []\n        self.prev_input_resize = 0\n        self.set_input_timeouts()\n        self.screen_buf = None\n        self._screen_buf_canvas = None\n        self._resized = False\n        self.maxrow = None\n        self.gpm_mev: Popen | None = None\n        self.gpm_event_pending: bool = False\n        self._mouse_tracking_enabled = False\n        self.last_bstate = 0\n        self._setup_G1_done = False\n        self._rows_used = None\n        self._cy = 0\n        self.term = os.environ.get('TERM', '')\n        self.fg_bright_is_bold = not self.term.startswith(\"xterm\")\n        self.bg_bright_is_blink = (self.term == \"linux\")\n        self.back_color_erase = not self.term.startswith(\"screen\")\n        self.register_palette_entry( None, 'default','default')\n        self._next_timeout = None\n        self.signal_handler_setter = signal.signal\n        self.bracketed_paste_mode = bracketed_paste_mode\n\n        # Our connections to the world\n        self._term_output_file = output\n        self._term_input_file = input\n\n        # pipe for signalling external event loops about resize events\n        self._resize_pipe_rd, self._resize_pipe_wr = os.pipe()\n        fcntl.fcntl(self._resize_pipe_rd, fcntl.F_SETFL, os.O_NONBLOCK)\n\n        # These store the previous signal handlers after setting ours\n        self._prev_sigcont_handler = None\n        self._prev_sigtstp_handler = None\n        self._prev_sigwinch_handler = None",
  "def _input_fileno(self):\n        \"\"\"Returns the fileno of the input stream, or None if it doesn't have one.  A stream without a fileno can't participate in whatever.\n        \"\"\"\n        if hasattr(self._term_input_file, 'fileno'):\n            return self._term_input_file.fileno()\n        else:\n            return None",
  "def _on_update_palette_entry(self, name, *attrspecs):\n        # copy the attribute to a dictionary containing the escape seqences\n        a = attrspecs[{16:0,1:1,88:2,256:3,2**24:4}[self.colors]]\n        self._pal_attrspec[name] = a\n        self._pal_escape[name] = self._attrspec_to_escape(a)",
  "def set_input_timeouts(self, max_wait=None, complete_wait=0.125,\n        resize_wait=0.125):\n        \"\"\"\n        Set the get_input timeout values.  All values are in floating\n        point numbers of seconds.\n\n        max_wait -- amount of time in seconds to wait for input when\n            there is no input pending, wait forever if None\n        complete_wait -- amount of time in seconds to wait when\n            get_input detects an incomplete escape sequence at the\n            end of the available input\n        resize_wait -- amount of time in seconds to wait for more input\n            after receiving two screen resize requests in a row to\n            stop Urwid from consuming 100% cpu during a gradual\n            window resize operation\n        \"\"\"\n        self.max_wait = max_wait\n        if max_wait is not None:\n            if self._next_timeout is None:\n                self._next_timeout = max_wait\n            else:\n                self._next_timeout = min(self._next_timeout, self.max_wait)\n        self.complete_wait = complete_wait\n        self.resize_wait = resize_wait",
  "def _sigwinch_handler(self, signum, frame=None):\n        \"\"\"\n        frame -- will always be None when the GLib event loop is being used.\n        \"\"\"\n\n        if not self._resized:\n            os.write(self._resize_pipe_wr, b'R')\n        self._resized = True\n        self.screen_buf = None\n\n        if callable(self._prev_sigwinch_handler):\n            self._prev_sigwinch_handler(signum, frame)",
  "def _sigtstp_handler(self, signum, frame=None):\n        self.stop() # Restores the previous signal handlers\n        self._prev_sigcont_handler = self.signal_handler_setter(signal.SIGCONT, self._sigcont_handler)\n        # Handled by the previous handler.\n        # If non-default, it may set its own SIGCONT handler which should hopefully call our own.\n        os.kill(os.getpid(), signal.SIGTSTP)",
  "def _sigcont_handler(self, signum, frame=None):\n        \"\"\"\n        frame -- will always be None when the GLib event loop is being used.\n        \"\"\"\n        self.signal_restore()\n\n        if callable(self._prev_sigcont_handler):\n            # May set its own SIGTSTP handler which would be stored and replaced in\n            # `signal_init()` (via `start()`).\n            self._prev_sigcont_handler(signum, frame)\n\n        self.start()\n        self._sigwinch_handler(None, None)",
  "def signal_init(self):\n        \"\"\"\n        Called in the startup of run wrapper to set the SIGWINCH\n        and SIGTSTP signal handlers.\n\n        Override this function to call from main thread in threaded\n        applications.\n        \"\"\"\n        self._prev_sigwinch_handler = self.signal_handler_setter(signal.SIGWINCH, self._sigwinch_handler)\n        self._prev_sigtstp_handler = self.signal_handler_setter(signal.SIGTSTP, self._sigtstp_handler)",
  "def signal_restore(self):\n        \"\"\"\n        Called in the finally block of run wrapper to restore the\n        SIGTSTP, SIGCONT and SIGWINCH signal handlers.\n\n        Override this function to call from main thread in threaded\n        applications.\n        \"\"\"\n        self.signal_handler_setter(signal.SIGTSTP, self._prev_sigtstp_handler or signal.SIG_DFL)\n        self.signal_handler_setter(signal.SIGCONT, self._prev_sigcont_handler or signal.SIG_DFL)\n        self.signal_handler_setter(signal.SIGWINCH, self._prev_sigwinch_handler or signal.SIG_DFL)",
  "def set_mouse_tracking(self, enable=True):\n        \"\"\"\n        Enable (or disable) mouse tracking.\n\n        After calling this function get_input will include mouse\n        click events along with keystrokes.\n        \"\"\"\n        enable = bool(enable)\n        if enable == self._mouse_tracking_enabled:\n            return\n\n        self._mouse_tracking(enable)\n        self._mouse_tracking_enabled = enable",
  "def _mouse_tracking(self, enable):\n        if enable:\n            self.write(escape.MOUSE_TRACKING_ON)\n            self._start_gpm_tracking()\n        else:\n            self.write(escape.MOUSE_TRACKING_OFF)\n            self._stop_gpm_tracking()",
  "def _start_gpm_tracking(self):\n        if not os.path.isfile(\"/usr/bin/mev\"):\n            return\n        if not os.environ.get('TERM', \"\").lower().startswith(\"linux\"):\n            return\n\n        m = Popen([\"/usr/bin/mev\", \"-e\", \"158\"], stdin=PIPE, stdout=PIPE, close_fds=True, encoding=\"ascii\")\n        fcntl.fcntl(m.stdout.fileno(), fcntl.F_SETFL, os.O_NONBLOCK)\n        self.gpm_mev = m",
  "def _stop_gpm_tracking(self):\n        if not self.gpm_mev:\n            return\n        os.kill(self.gpm_mev.pid, signal.SIGINT)\n        os.waitpid(self.gpm_mev.pid, 0)\n        self.gpm_mev = None",
  "def _start(self, alternate_buffer=True):\n        \"\"\"\n        Initialize the screen and input mode.\n\n        alternate_buffer -- use alternate screen buffer\n        \"\"\"\n        if alternate_buffer:\n            self.write(escape.SWITCH_TO_ALTERNATE_BUFFER)\n            self._rows_used = None\n        else:\n            self._rows_used = 0\n\n        if (self.bracketed_paste_mode):\n            self.write(escape.ENABLE_BRACKETED_PASTE_MODE)\n            \n        fd = self._input_fileno()\n        if fd is not None and os.isatty(fd):\n            self._old_termios_settings = termios.tcgetattr(fd)\n            tty.setcbreak(fd)\n\n        self.signal_init()\n        self._alternate_buffer = alternate_buffer\n        self._next_timeout = self.max_wait\n\n        if not self._signal_keys_set:\n            self._old_signal_keys = self.tty_signal_keys(fileno=fd)\n\n        signals.emit_signal(self, INPUT_DESCRIPTORS_CHANGED)\n        # restore mouse tracking to previous state\n        self._mouse_tracking(self._mouse_tracking_enabled)\n\n        return super()._start()",
  "def _stop(self):\n        \"\"\"\n        Restore the screen.\n        \"\"\"\n        self.clear()\n\n        if (self.bracketed_paste_mode):\n            self.write(escape.DISABLE_BRACKETED_PASTE_MODE)\n        \n        signals.emit_signal(self, INPUT_DESCRIPTORS_CHANGED)\n\n        self.signal_restore()\n\n        fd = self._input_fileno()\n        if fd is not None and os.isatty(fd):\n            termios.tcsetattr(fd, termios.TCSADRAIN, self._old_termios_settings)\n\n        self._mouse_tracking(False)\n\n        move_cursor = \"\"\n        if self._alternate_buffer:\n            move_cursor = escape.RESTORE_NORMAL_BUFFER\n        elif self.maxrow is not None:\n            move_cursor = escape.set_cursor_position(\n                0, self.maxrow)\n        self.write(\n            self._attrspec_to_escape(AttrSpec('',''))\n            + escape.SI\n            + move_cursor\n            + escape.SHOW_CURSOR)\n        self.flush()\n\n        if self._old_signal_keys:\n            self.tty_signal_keys(*(self._old_signal_keys + (fd,)))\n\n        super()._stop()",
  "def write(self, data):\n        \"\"\"Write some data to the terminal.\n\n        You may wish to override this if you're using something other than\n        regular files for input and output.\n        \"\"\"\n        self._term_output_file.write(data)",
  "def flush(self):\n        \"\"\"Flush the output buffer.\n\n        You may wish to override this if you're using something other than\n        regular files for input and output.\n        \"\"\"\n        self._term_output_file.flush()",
  "def get_input(self, raw_keys: Literal[False]) -> list[str]:\n        ...",
  "def get_input(self, raw_keys: Literal[True]) -> tuple[list[str], list[int]]:\n        ...",
  "def get_input(self, raw_keys: bool = False) -> list[str] | tuple[list[str], list[int]]:\n        \"\"\"Return pending input as a list.\n\n        raw_keys -- return raw keycodes as well as translated versions\n\n        This function will immediately return all the input since the\n        last time it was called.  If there is no input pending it will\n        wait before returning an empty list.  The wait time may be\n        configured with the set_input_timeouts function.\n\n        If raw_keys is False (default) this function will return a list\n        of keys pressed.  If raw_keys is True this function will return\n        a ( keys pressed, raw keycodes ) tuple instead.\n\n        Examples of keys returned:\n\n        * ASCII printable characters:  \" \", \"a\", \"0\", \"A\", \"-\", \"/\"\n        * ASCII control characters:  \"tab\", \"enter\"\n        * Escape sequences:  \"up\", \"page up\", \"home\", \"insert\", \"f1\"\n        * Key combinations:  \"shift f1\", \"meta a\", \"ctrl b\"\n        * Window events:  \"window resize\"\n\n        When a narrow encoding is not enabled:\n\n        * \"Extended ASCII\" characters:  \"\\\\xa1\", \"\\\\xb2\", \"\\\\xfe\"\n\n        When a wide encoding is enabled:\n\n        * Double-byte characters:  \"\\\\xa1\\\\xea\", \"\\\\xb2\\\\xd4\"\n\n        When utf8 encoding is enabled:\n\n        * Unicode characters: u\"\\\\u00a5\", u'\\\\u253c\"\n\n        Examples of mouse events returned:\n\n        * Mouse button press: ('mouse press', 1, 15, 13),\n                              ('meta mouse press', 2, 17, 23)\n        * Mouse drag: ('mouse drag', 1, 16, 13),\n                      ('mouse drag', 1, 17, 13),\n                      ('ctrl mouse drag', 1, 18, 13)\n        * Mouse button release: ('mouse release', 0, 18, 13),\n                                ('ctrl mouse release', 0, 17, 23)\n        \"\"\"\n        assert self._started\n\n        self._wait_for_input_ready(self._next_timeout)\n        keys, raw = self.parse_input(None, None, self.get_available_raw_input())\n\n        # Avoid pegging CPU at 100% when slowly resizing\n        if keys == ['window resize'] and self.prev_input_resize:\n            while True:\n                self._wait_for_input_ready(self.resize_wait)\n                keys, raw2 = self.parse_input(None, None, self.get_available_raw_input())\n                raw += raw2\n                # if not keys:\n                #     keys, raw2 = self._get_input(\n                #         self.resize_wait)\n                #     raw += raw2\n                if keys != ['window resize']:\n                    break\n            if keys[-1:] != ['window resize']:\n                keys.append('window resize')\n\n        if keys == ['window resize']:\n            self.prev_input_resize = 2\n        elif self.prev_input_resize == 2 and not keys:\n            self.prev_input_resize = 1\n        else:\n            self.prev_input_resize = 0\n\n        if raw_keys:\n            return keys, raw\n        return keys",
  "def get_input_descriptors(self) -> list[int]:\n        \"\"\"\n        Return a list of integer file descriptors that should be\n        polled in external event loops to check for user input.\n\n        Use this method if you are implementing your own event loop.\n\n        This method is only called by `hook_event_loop`, so if you override\n        that, you can safely ignore this.\n        \"\"\"\n        if not self._started:\n            return []\n\n        fd_list = [self._resize_pipe_rd]\n        fd = self._input_fileno()\n        if fd is not None:\n            fd_list.append(fd)\n        if self.gpm_mev is not None:\n            fd_list.append(self.gpm_mev.stdout.fileno())\n        return fd_list",
  "def unhook_event_loop(self, event_loop):\n        \"\"\"\n        Remove any hooks added by hook_event_loop.\n        \"\"\"\n        for handle in self._current_event_loop_handles:\n            event_loop.remove_watch_file(handle)\n\n        if self._input_timeout:\n            event_loop.remove_alarm(self._input_timeout)\n            self._input_timeout = None",
  "def hook_event_loop(self, event_loop, callback):\n        \"\"\"\n        Register the given callback with the event loop, to be called with new\n        input whenever it's available.  The callback should be passed a list of\n        processed keys and a list of unprocessed keycodes.\n\n        Subclasses may wish to use parse_input to wrap the callback.\n        \"\"\"\n        if hasattr(self, 'get_input_nonblocking'):\n            wrapper = self._make_legacy_input_wrapper(event_loop, callback)\n        else:\n            wrapper = lambda: self.parse_input(\n                event_loop, callback, self.get_available_raw_input())\n        fds = self.get_input_descriptors()\n        handles = [event_loop.watch_file(fd, wrapper) for fd in fds]\n        self._current_event_loop_handles = handles",
  "def _make_legacy_input_wrapper(self, event_loop, callback):\n        \"\"\"\n        Support old Screen classes that still have a get_input_nonblocking and\n        expect it to work.\n        \"\"\"\n        def wrapper():\n            if self._input_timeout:\n                event_loop.remove_alarm(self._input_timeout)\n                self._input_timeout = None\n            timeout, keys, raw = self.get_input_nonblocking()\n            if timeout is not None:\n                self._input_timeout = event_loop.alarm(timeout, wrapper)\n\n            callback(keys, raw)\n\n        return wrapper",
  "def get_available_raw_input(self):\n        \"\"\"\n        Return any currently-available input.  Does not block.\n\n        This method is only used by the default `hook_event_loop`\n        implementation; you can safely ignore it if you implement your own.\n        \"\"\"\n        codes = self._get_gpm_codes() + self._get_keyboard_codes()\n\n        if self._partial_codes:\n            codes = self._partial_codes + codes\n            self._partial_codes = None\n\n        # clean out the pipe used to signal external event loops\n        # that a resize has occurred\n        try:\n            while True: os.read(self._resize_pipe_rd, 1)\n        except OSError:\n            pass\n\n        return codes",
  "def parse_input(self, event_loop, callback, codes, wait_for_more=True):\n        \"\"\"\n        Read any available input from get_available_raw_input, parses it into\n        keys, and calls the given callback.\n\n        The current implementation tries to avoid any assumptions about what\n        the screen or event loop look like; it only deals with parsing keycodes\n        and setting a timeout when an incomplete one is detected.\n\n        `codes` should be a sequence of keycodes, i.e. bytes.  A bytearray is\n        appropriate, but beware of using bytes, which only iterates as integers\n        on Python 3.\n        \"\"\"\n        # Note: event_loop may be None for 100% synchronous support, only used\n        # by get_input.  Not documented because you shouldn't be doing it.\n        if self._input_timeout and event_loop:\n            event_loop.remove_alarm(self._input_timeout)\n            self._input_timeout = None\n\n        original_codes = codes\n        processed = []\n        try:\n            while codes:\n                run, codes = escape.process_keyqueue(\n                    codes, wait_for_more)\n                processed.extend(run)\n        except escape.MoreInputRequired:\n            # Set a timer to wait for the rest of the input; if it goes off\n            # without any new input having come in, use the partial input\n            k = len(original_codes) - len(codes)\n            processed_codes = original_codes[:k]\n            self._partial_codes = codes\n\n            def _parse_incomplete_input():\n                self._input_timeout = None\n                self._partial_codes = None\n                self.parse_input(\n                    event_loop, callback, codes, wait_for_more=False)\n            if event_loop:\n                self._input_timeout = event_loop.alarm(\n                    self.complete_wait, _parse_incomplete_input)\n\n        else:\n            processed_codes = original_codes\n            self._partial_codes = None\n\n        if self._resized:\n            processed.append('window resize')\n            self._resized = False\n\n        if callback:\n            callback(processed, processed_codes)\n        else:\n            # For get_input\n            return processed, processed_codes",
  "def _get_keyboard_codes(self):\n        codes = []\n        while True:\n            code = self._getch_nodelay()\n            if code < 0:\n                break\n            codes.append(code)\n        return codes",
  "def _get_gpm_codes(self):\n        codes = []\n        try:\n            while self.gpm_mev is not None and self.gpm_event_pending:\n                codes.extend(self._encode_gpm_event())\n        except OSError as e:\n            if e.args[0] != 11:\n                raise\n        return codes",
  "def _wait_for_input_ready(self, timeout):\n        ready = None\n        fd_list = [self._resize_pipe_rd]\n        fd = self._input_fileno()\n        if fd is not None:\n            fd_list.append(fd)\n        if self.gpm_mev is not None:\n            fd_list.append(self.gpm_mev.stdout.fileno())\n        while True:\n            try:\n                if timeout is None:\n                    ready,w,err = select.select(\n                        fd_list, [], fd_list)\n                else:\n                    ready,w,err = select.select(\n                        fd_list,[],fd_list, timeout)\n                break\n            except OSError as e:\n                if e.args[0] != 4:\n                    raise\n                if self._resized:\n                    ready = []\n                    break\n        return ready",
  "def _getch(self, timeout: int) ->int:\n        ready = self._wait_for_input_ready(timeout)\n        if self.gpm_mev is not None:\n            if self.gpm_mev.stdout.fileno() in ready:\n                self.gpm_event_pending = True\n        fd = self._input_fileno()\n        if fd is not None and fd in ready:\n            return ord(os.read(fd, 1))\n        return -1",
  "def _encode_gpm_event(self) -> list[int]:\n        self.gpm_event_pending = False\n        s = self.gpm_mev.stdout.readline()\n        l = s.split(\", \")\n        if len(l) != 6:\n            # unexpected output, stop tracking\n            self._stop_gpm_tracking()\n            signals.emit_signal(self, INPUT_DESCRIPTORS_CHANGED)\n            return []\n        ev, x, y, ign, b, m = s.split(\",\")\n        ev = int(ev.split(\"x\")[-1], 16)\n        x = int( x.split(\" \")[-1] )\n        y = int( y.lstrip().split(\" \")[0] )\n        b = int( b.split(\" \")[-1] )\n        m = int( m.split(\"x\")[-1].rstrip(), 16 )\n\n        # convert to xterm-like escape sequence\n\n        last = next = self.last_bstate\n        l = []\n\n        mod = 0\n        if m & 1:\n            mod |= 4 # shift\n        if m & 10:\n            mod |= 8 # alt\n        if m & 4:\n            mod |= 16 # ctrl\n\n        def append_button(b):\n            b |= mod\n            l.extend([27, ord('['), ord('M'), b+32, x+32, y+32])\n\n        def determine_button_release(flag: int) -> None:\n            if b & 4 and last & 1:\n                append_button( 0 + flag )\n                next |= 1\n            if b & 2 and last & 2:\n                append_button( 1 + flag )\n                next |= 2\n            if b & 1 and last & 4:\n                append_button( 2 + flag )\n                next |= 4\n\n        if ev == 20 or ev == 36 or ev == 52: # press\n            if b & 4 and last & 1 == 0:\n                append_button( 0 )\n                next |= 1\n            if b & 2 and last & 2 == 0:\n                append_button( 1 )\n                next |= 2\n            if b & 1 and last & 4 == 0:\n                append_button( 2 )\n                next |= 4\n        elif ev == 146: # drag\n            if b & 4:\n                append_button( 0 + escape.MOUSE_DRAG_FLAG )\n            elif b & 2:\n                append_button( 1 + escape.MOUSE_DRAG_FLAG )\n            elif b & 1:\n                append_button( 2 + escape.MOUSE_DRAG_FLAG )\n        else: # release\n            if b & 4 and last & 1:\n                append_button( 0 + escape.MOUSE_RELEASE_FLAG )\n                next &= ~ 1\n            if b & 2 and last & 2:\n                append_button( 1 + escape.MOUSE_RELEASE_FLAG )\n                next &= ~ 2\n            if b & 1 and last & 4:\n                append_button( 2 + escape.MOUSE_RELEASE_FLAG )\n                next &= ~ 4\n        if ev == 40: # double click (release)\n            if b & 4 and last & 1:\n                append_button( 0 + escape.MOUSE_MULTIPLE_CLICK_FLAG )\n            if b & 2 and last & 2:\n                append_button( 1 + escape.MOUSE_MULTIPLE_CLICK_FLAG )\n            if b & 1 and last & 4:\n                append_button( 2 + escape.MOUSE_MULTIPLE_CLICK_FLAG )\n        elif ev == 52:\n            if b & 4 and last & 1:\n                append_button( 0 + escape.MOUSE_MULTIPLE_CLICK_FLAG*2 )\n            if b & 2 and last & 2:\n                append_button( 1 + escape.MOUSE_MULTIPLE_CLICK_FLAG*2 )\n            if b & 1 and last & 4:\n                append_button( 2 + escape.MOUSE_MULTIPLE_CLICK_FLAG*2 )\n\n        self.last_bstate = next\n        return l",
  "def _getch_nodelay(self):\n        return self._getch(0)",
  "def get_cols_rows(self):\n        \"\"\"Return the terminal dimensions (num columns, num rows).\"\"\"\n        y, x = 24, 80\n        try:\n            if hasattr(self._term_output_file, 'fileno'):\n                buf = fcntl.ioctl(self._term_output_file.fileno(), termios.TIOCGWINSZ, ' '*4)\n                y, x = struct.unpack('hh', buf)\n        except OSError:\n            # Term size could not be determined\n            pass\n        # Provide some lightweight fallbacks in case the TIOCWINSZ doesn't\n        # give sane answers\n        if (x <= 0 or y <= 0) and self.term in ('ansi', 'vt100'):\n                y, x = 24, 80\n        self.maxrow = y\n        return x, y",
  "def _setup_G1(self):\n        \"\"\"\n        Initialize the G1 character set to graphics mode if required.\n        \"\"\"\n        if self._setup_G1_done:\n            return\n\n        while True:\n            try:\n                self.write(escape.DESIGNATE_G1_SPECIAL)\n                self.flush()\n                break\n            except OSError:\n                pass\n        self._setup_G1_done = True",
  "def draw_screen(self, maxres, r ):\n        \"\"\"Paint screen with rendered canvas.\"\"\"\n\n        (maxcol, maxrow) = maxres\n\n        assert self._started\n\n        assert maxrow == r.rows()\n\n        # quick return if nothing has changed\n        if self.screen_buf and r is self._screen_buf_canvas:\n            return\n\n        self._setup_G1()\n\n        if self._resized:\n            # handle resize before trying to draw screen\n            return\n\n        o = [escape.HIDE_CURSOR, self._attrspec_to_escape(AttrSpec('',''))]\n\n        def partial_display():\n            # returns True if the screen is in partial display mode\n            # ie. only some rows belong to the display\n            return self._rows_used is not None\n\n        if not partial_display():\n            o.append(escape.CURSOR_HOME)\n\n        if self.screen_buf:\n            osb = self.screen_buf\n        else:\n            osb = []\n        sb = []\n        cy = self._cy\n        y = -1\n\n        def set_cursor_home():\n            if not partial_display():\n                return escape.set_cursor_position(0, 0)\n            return (escape.CURSOR_HOME_COL +\n                escape.move_cursor_up(cy))\n\n        def set_cursor_row(y):\n            if not partial_display():\n                return escape.set_cursor_position(0, y)\n            return escape.move_cursor_down(y - cy)\n\n        def set_cursor_position(x, y):\n            if not partial_display():\n                return escape.set_cursor_position(x, y)\n            if cy > y:\n                return ('\\b' + escape.CURSOR_HOME_COL +\n                    escape.move_cursor_up(cy - y) +\n                    escape.move_cursor_right(x))\n            return ('\\b' + escape.CURSOR_HOME_COL +\n                escape.move_cursor_down(y - cy) +\n                escape.move_cursor_right(x))\n\n        def is_blank_row(row):\n            if len(row) > 1:\n                return False\n            if row[0][2].strip():\n                return False\n            return True\n\n        def attr_to_escape(a):\n            if a in self._pal_escape:\n                return self._pal_escape[a]\n            elif isinstance(a, AttrSpec):\n                return self._attrspec_to_escape(a)\n            # undefined attributes use default/default\n            # TODO: track and report these\n            return self._attrspec_to_escape(\n                AttrSpec('default','default'))\n\n        def using_standout_or_underline(a):\n            a = self._pal_attrspec.get(a, a)\n            return isinstance(a, AttrSpec) and (a.standout or a.underline)\n\n        ins = None\n        o.append(set_cursor_home())\n        cy = 0\n        for row in r.content():\n            y += 1\n            if osb and y < len(osb) and osb[y] == row:\n                # this row of the screen buffer matches what is\n                # currently displayed, so we can skip this line\n                sb.append( osb[y] )\n                continue\n\n            sb.append(row)\n\n            # leave blank lines off display when we are using\n            # the default screen buffer (allows partial screen)\n            if partial_display() and y > self._rows_used:\n                if is_blank_row(row):\n                    continue\n                self._rows_used = y\n\n            if y or partial_display():\n                o.append(set_cursor_position(0, y))\n            # after updating the line we will be just over the\n            # edge, but terminals still treat this as being\n            # on the same line\n            cy = y\n\n            whitespace_at_end = False\n            if row:\n                a, cs, run = row[-1]\n                if (run[-1:] == b' ' and self.back_color_erase\n                        and not using_standout_or_underline(a)):\n                    whitespace_at_end = True\n                    row = row[:-1] + [(a, cs, run.rstrip(b' '))]\n                elif y == maxrow-1 and maxcol > 1:\n                    row, back, ins = self._last_row(row)\n\n            first = True\n            lasta = lastcs = None\n            for (a,cs, run) in row:\n                assert isinstance(run, bytes) # canvases should render with bytes\n                if cs != 'U':\n                    run = run.translate(UNPRINTABLE_TRANS_TABLE)\n                if first or lasta != a:\n                    o.append(attr_to_escape(a))\n                    lasta = a\n                if first or lastcs != cs:\n                    assert cs in [None, \"0\", \"U\"], repr(cs)\n                    if lastcs == \"U\":\n                        o.append( escape.IBMPC_OFF )\n\n                    if cs is None:\n                        o.append( escape.SI )\n                    elif cs == \"U\":\n                        o.append( escape.IBMPC_ON )\n                    else:\n                        o.append( escape.SO )\n                    lastcs = cs\n                o.append( run )\n                first = False\n            if ins:\n                (inserta, insertcs, inserttext) = ins\n                ias = attr_to_escape(inserta)\n                assert insertcs in [None, \"0\", \"U\"], repr(insertcs)\n                if cs is None:\n                    icss = escape.SI\n                elif cs == \"U\":\n                    icss = escape.IBMPC_ON\n                else:\n                    icss = escape.SO\n                o += [\"\\x08\" * back,\n                    ias, icss,\n                    escape.INSERT_ON, inserttext,\n                    escape.INSERT_OFF ]\n\n                if cs == \"U\":\n                    o.append(escape.IBMPC_OFF)\n            if whitespace_at_end:\n                o.append(escape.ERASE_IN_LINE_RIGHT)\n\n        if r.cursor is not None:\n            x,y = r.cursor\n            o += [set_cursor_position(x, y),\n                escape.SHOW_CURSOR  ]\n            self._cy = y\n\n        if self._resized:\n            # handle resize before trying to draw screen\n            return\n        try:\n            for l in o:\n                if isinstance(l, bytes):\n                    l = l.decode('utf-8', 'replace')\n                self.write(l)\n            self.flush()\n        except OSError as e:\n            # ignore interrupted syscall\n            if e.args[0] != 4:\n                raise\n\n        self.screen_buf = sb\n        self._screen_buf_canvas = r",
  "def _last_row(self, row):\n        \"\"\"On the last row we need to slide the bottom right character\n        into place. Calculate the new line, attr and an insert sequence\n        to do that.\n\n        eg. last row:\n        XXXXXXXXXXXXXXXXXXXXYZ\n\n        Y will be drawn after Z, shifting Z into position.\n        \"\"\"\n\n        new_row = row[:-1]\n        z_attr, z_cs, last_text = row[-1]\n        last_cols = util.calc_width(last_text, 0, len(last_text))\n        last_offs, z_col = util.calc_text_pos(last_text, 0,\n            len(last_text), last_cols-1)\n        if last_offs == 0:\n            z_text = last_text\n            del new_row[-1]\n            # we need another segment\n            y_attr, y_cs, nlast_text = row[-2]\n            nlast_cols = util.calc_width(nlast_text, 0,\n                len(nlast_text))\n            z_col += nlast_cols\n            nlast_offs, y_col = util.calc_text_pos(nlast_text, 0,\n                len(nlast_text), nlast_cols-1)\n            y_text = nlast_text[nlast_offs:]\n            if nlast_offs:\n                new_row.append((y_attr, y_cs,\n                    nlast_text[:nlast_offs]))\n        else:\n            z_text = last_text[last_offs:]\n            y_attr, y_cs = z_attr, z_cs\n            nlast_cols = util.calc_width(last_text, 0,\n                last_offs)\n            nlast_offs, y_col = util.calc_text_pos(last_text, 0,\n                last_offs, nlast_cols-1)\n            y_text = last_text[nlast_offs:last_offs]\n            if nlast_offs:\n                new_row.append((y_attr, y_cs,\n                    last_text[:nlast_offs]))\n\n        new_row.append((z_attr, z_cs, z_text))\n        return new_row, z_col-y_col, (y_attr, y_cs, y_text)",
  "def clear(self):\n        \"\"\"\n        Force the screen to be completely repainted on the next\n        call to draw_screen().\n        \"\"\"\n        self.screen_buf = None\n        self.setup_G1 = True",
  "def _attrspec_to_escape(self, a):\n        \"\"\"\n        Convert AttrSpec instance a to an escape sequence for the terminal\n\n        >>> s = Screen()\n        >>> s.set_terminal_properties(colors=256)\n        >>> a2e = s._attrspec_to_escape\n        >>> a2e(s.AttrSpec('brown', 'dark green'))\n        '\\\\x1b[0;33;42m'\n        >>> a2e(s.AttrSpec('#fea,underline', '#d0d'))\n        '\\\\x1b[0;38;5;229;4;48;5;164m'\n        \"\"\"\n        if self.term == 'fbterm':\n            fg = escape.ESC + '[1;%d}' % (a.foreground_number,)\n            bg = escape.ESC + '[2;%d}' % (a.background_number,)\n            return fg + bg\n\n        if a.foreground_true:\n            fg = \"38;2;%d;%d;%d\" %(a.get_rgb_values()[0:3])\n        elif a.foreground_high:\n            fg = \"38;5;%d\" % a.foreground_number\n        elif a.foreground_basic:\n            if a.foreground_number > 7:\n                if self.fg_bright_is_bold:\n                    fg = \"1;%d\" % (a.foreground_number - 8 + 30)\n                else:\n                    fg = \"%d\" % (a.foreground_number - 8 + 90)\n            else:\n                fg = \"%d\" % (a.foreground_number + 30)\n        else:\n            fg = \"39\"\n        st = (\"1;\" * a.bold + \"3;\" * a.italics +\n              \"4;\" * a.underline + \"5;\" * a.blink +\n              \"7;\" * a.standout + \"9;\" * a.strikethrough)\n        if a.background_true:\n             bg = \"48;2;%d;%d;%d\" %(a.get_rgb_values()[3:6])\n        elif a.background_high:\n            bg = \"48;5;%d\" % a.background_number\n        elif a.background_basic:\n            if a.background_number > 7:\n                if self.bg_bright_is_blink:\n                    bg = \"5;%d\" % (a.background_number - 8 + 40)\n                else:\n                    # this doesn't work on most terminals\n                    bg = \"%d\" % (a.background_number - 8 + 100)\n            else:\n                bg = \"%d\" % (a.background_number + 40)\n        else:\n            bg = \"49\"\n        return f\"{escape.ESC}[0;{fg};{st}{bg}m\"",
  "def set_terminal_properties(self, colors=None, bright_is_bold=None,\n        has_underline=None):\n        \"\"\"\n        colors -- number of colors terminal supports (1, 16, 88, 256, or 2**24)\n            or None to leave unchanged\n        bright_is_bold -- set to True if this terminal uses the bold\n            setting to create bright colors (numbers 8-15), set to False\n            if this Terminal can create bright colors without bold or\n            None to leave unchanged\n        has_underline -- set to True if this terminal can use the\n            underline setting, False if it cannot or None to leave\n            unchanged\n        \"\"\"\n        if colors is None:\n            colors = self.colors\n        if bright_is_bold is None:\n            bright_is_bold = self.fg_bright_is_bold\n        if has_underline is None:\n            has_underline = self.has_underline\n\n        if colors == self.colors and bright_is_bold == self.fg_bright_is_bold \\\n            and has_underline == self.has_underline:\n            return\n\n        self.colors = colors\n        self.fg_bright_is_bold = bright_is_bold\n        self.has_underline = has_underline\n\n        self.clear()\n        self._pal_escape = {}\n        for p,v in self._palette.items():\n            self._on_update_palette_entry(p, *v)",
  "def reset_default_terminal_palette(self):\n        \"\"\"\n        Attempt to set the terminal palette to default values as taken\n        from xterm.  Uses number of colors from current\n        set_terminal_properties() screen setting.\n        \"\"\"\n        if self.colors == 1:\n            return\n        elif self.colors == 2**24:\n            colors = 256\n        else:\n            colors = self.colors\n\n        def rgb_values(n):\n            if colors == 16:\n                aspec = AttrSpec(\"h%d\"%n, \"\", 256)\n            else:\n                aspec = AttrSpec(\"h%d\"%n, \"\", colors)\n            return aspec.get_rgb_values()[:3]\n\n        entries = [(n,) + rgb_values(n) for n in range(min(colors, 256))]\n        self.modify_terminal_palette(entries)",
  "def modify_terminal_palette(self, entries):\n        \"\"\"\n        entries - list of (index, red, green, blue) tuples.\n\n        Attempt to set part of the terminal palette (this does not work\n        on all terminals.)  The changes are sent as a single escape\n        sequence so they should all take effect at the same time.\n\n        0 <= index < 256 (some terminals will only have 16 or 88 colors)\n        0 <= red, green, blue < 256\n        \"\"\"\n\n        if self.term == 'fbterm':\n            modify = [\"%d;%d;%d;%d\" % (index, red, green, blue)\n                for index, red, green, blue in entries]\n            self.write(f\"\\x1b[3;{';'.join(modify)}}}\")\n        else:\n            modify = [\"%d;rgb:%02x/%02x/%02x\" % (index, red, green, blue)\n                for index, red, green, blue in entries]\n            self.write(f\"\\x1b]4;{';'.join(modify)}\\x1b\\\\\")\n        self.flush()",
  "def wrapper():\n            if self._input_timeout:\n                event_loop.remove_alarm(self._input_timeout)\n                self._input_timeout = None\n            timeout, keys, raw = self.get_input_nonblocking()\n            if timeout is not None:\n                self._input_timeout = event_loop.alarm(timeout, wrapper)\n\n            callback(keys, raw)",
  "def append_button(b):\n            b |= mod\n            l.extend([27, ord('['), ord('M'), b+32, x+32, y+32])",
  "def determine_button_release(flag: int) -> None:\n            if b & 4 and last & 1:\n                append_button( 0 + flag )\n                next |= 1\n            if b & 2 and last & 2:\n                append_button( 1 + flag )\n                next |= 2\n            if b & 1 and last & 4:\n                append_button( 2 + flag )\n                next |= 4",
  "def partial_display():\n            # returns True if the screen is in partial display mode\n            # ie. only some rows belong to the display\n            return self._rows_used is not None",
  "def set_cursor_home():\n            if not partial_display():\n                return escape.set_cursor_position(0, 0)\n            return (escape.CURSOR_HOME_COL +\n                escape.move_cursor_up(cy))",
  "def set_cursor_row(y):\n            if not partial_display():\n                return escape.set_cursor_position(0, y)\n            return escape.move_cursor_down(y - cy)",
  "def set_cursor_position(x, y):\n            if not partial_display():\n                return escape.set_cursor_position(x, y)\n            if cy > y:\n                return ('\\b' + escape.CURSOR_HOME_COL +\n                    escape.move_cursor_up(cy - y) +\n                    escape.move_cursor_right(x))\n            return ('\\b' + escape.CURSOR_HOME_COL +\n                escape.move_cursor_down(y - cy) +\n                escape.move_cursor_right(x))",
  "def is_blank_row(row):\n            if len(row) > 1:\n                return False\n            if row[0][2].strip():\n                return False\n            return True",
  "def attr_to_escape(a):\n            if a in self._pal_escape:\n                return self._pal_escape[a]\n            elif isinstance(a, AttrSpec):\n                return self._attrspec_to_escape(a)\n            # undefined attributes use default/default\n            # TODO: track and report these\n            return self._attrspec_to_escape(\n                AttrSpec('default','default'))",
  "def using_standout_or_underline(a):\n            a = self._pal_attrspec.get(a, a)\n            return isinstance(a, AttrSpec) and (a.standout or a.underline)",
  "def rgb_values(n):\n            if colors == 16:\n                aspec = AttrSpec(\"h%d\"%n, \"\", 256)\n            else:\n                aspec = AttrSpec(\"h%d\"%n, \"\", colors)\n            return aspec.get_rgb_values()[:3]",
  "def _parse_incomplete_input():\n                self._input_timeout = None\n                self._partial_codes = None\n                self.parse_input(\n                    event_loop, callback, codes, wait_for_more=False)",
  "class TreeWidgetError(RuntimeError):\n    pass",
  "class TreeWidget(urwid.WidgetWrap):\n    \"\"\"A widget representing something in a nested tree display.\"\"\"\n    indent_cols = 3\n    unexpanded_icon = SelectableIcon('+', 0)\n    expanded_icon = SelectableIcon('-', 0)\n\n    def __init__(self, node):\n        self._node = node\n        self._innerwidget = None\n        self.is_leaf = not hasattr(node, 'get_first_child')\n        self.expanded = True\n        widget = self.get_indented_widget()\n        super().__init__(widget)\n\n    def selectable(self):\n        \"\"\"\n        Allow selection of non-leaf nodes so children may be (un)expanded\n        \"\"\"\n        return not self.is_leaf\n\n    def get_indented_widget(self):\n        widget = self.get_inner_widget()\n        if not self.is_leaf:\n            widget = urwid.Columns([('fixed', 1,\n                [self.unexpanded_icon, self.expanded_icon][self.expanded]),\n                widget], dividechars=1)\n        indent_cols = self.get_indent_cols()\n        return urwid.Padding(widget, width=('relative', 100), left=indent_cols)\n\n    def update_expanded_icon(self):\n        \"\"\"Update display widget text for parent widgets\"\"\"\n        # icon is first element in columns indented widget\n        self._w.base_widget.widget_list[0] = [\n            self.unexpanded_icon, self.expanded_icon][self.expanded]\n\n    def get_indent_cols(self):\n        return self.indent_cols * self.get_node().get_depth()\n\n    def get_inner_widget(self):\n        if self._innerwidget is None:\n            self._innerwidget = self.load_inner_widget()\n        return self._innerwidget\n\n    def load_inner_widget(self):\n        return urwid.Text(self.get_display_text())\n\n    def get_node(self):\n        return self._node\n\n    def get_display_text(self):\n        return (f\"{self.get_node().get_key()}: {str(self.get_node().get_value())}\")\n\n    def next_inorder(self):\n        \"\"\"Return the next TreeWidget depth first from this one.\"\"\"\n        # first check if there's a child widget\n        firstchild = self.first_child()\n        if firstchild is not None:\n            return firstchild\n\n        # now we need to hunt for the next sibling\n        thisnode = self.get_node()\n        nextnode = thisnode.next_sibling()\n        depth = thisnode.get_depth()\n        while nextnode is None and depth > 0:\n            # keep going up the tree until we find an ancestor next sibling\n            thisnode = thisnode.get_parent()\n            nextnode = thisnode.next_sibling()\n            depth -= 1\n            assert depth == thisnode.get_depth()\n        if nextnode is None:\n            # we're at the end of the tree\n            return None\n        else:\n            return nextnode.get_widget()\n\n    def prev_inorder(self):\n        \"\"\"Return the previous TreeWidget depth first from this one.\"\"\"\n        thisnode = self._node\n        prevnode = thisnode.prev_sibling()\n        if prevnode is not None:\n            # we need to find the last child of the previous widget if its\n            # expanded\n            prevwidget = prevnode.get_widget()\n            lastchild = prevwidget.last_child()\n            if lastchild is None:\n                return prevwidget\n            else:\n                return lastchild\n        else:\n            # need to hunt for the parent\n            depth = thisnode.get_depth()\n            if prevnode is None and depth == 0:\n                return None\n            elif prevnode is None:\n                prevnode = thisnode.get_parent()\n            return prevnode.get_widget()\n\n    def keypress(self, size, key: str) -> str | None:\n        \"\"\"Handle expand & collapse requests (non-leaf nodes)\"\"\"\n        if self.is_leaf:\n            return key\n\n        if key in (\"+\", \"right\"):\n            self.expanded = True\n            self.update_expanded_icon()\n        elif key == \"-\":\n            self.expanded = False\n            self.update_expanded_icon()\n        elif self._w.selectable():\n            return super().keypress(size, key)\n        else:\n            return key\n\n    def mouse_event(self, size, event, button: int, col: int, row: int, focus: bool) -> bool:\n        if self.is_leaf or event != 'mouse press' or button !=1:\n            return False\n\n        if row == 0 and col == self.get_indent_cols():\n            self.expanded = not self.expanded\n            self.update_expanded_icon()\n            return True\n\n        return False\n\n    def first_child(self):\n        \"\"\"Return first child if expanded.\"\"\"\n        if self.is_leaf or not self.expanded:\n            return None\n        else:\n            if self._node.has_children():\n                firstnode = self._node.get_first_child()\n                return firstnode.get_widget()\n            else:\n                return None\n\n    def last_child(self):\n        \"\"\"Return last child if expanded.\"\"\"\n        if self.is_leaf or not self.expanded:\n            return None\n        else:\n            if self._node.has_children():\n                lastchild = self._node.get_last_child().get_widget()\n            else:\n                return None\n            # recursively search down for the last descendant\n            lastdescendant = lastchild.last_child()\n            if lastdescendant is None:\n                return lastchild\n            else:\n                return lastdescendant",
  "class TreeNode:\n    \"\"\"\n    Store tree contents and cache TreeWidget objects.\n    A TreeNode consists of the following elements:\n    *  key: accessor token for parent nodes\n    *  value: subclass-specific data\n    *  parent: a TreeNode which contains a pointer back to this object\n    *  widget: The widget used to render the object\n    \"\"\"\n    def __init__(self, value, parent=None, key=None, depth=None):\n        self._key = key\n        self._parent = parent\n        self._value = value\n        self._depth = depth\n        self._widget = None\n\n    def get_widget(self, reload=False):\n        \"\"\" Return the widget for this node.\"\"\"\n        if self._widget is None or reload == True:\n            self._widget = self.load_widget()\n        return self._widget\n\n    def load_widget(self):\n        return TreeWidget(self)\n\n    def get_depth(self):\n        if self._depth is None and self._parent is None:\n            self._depth = 0\n        elif self._depth is None:\n            self._depth = self._parent.get_depth() + 1\n        return self._depth\n\n    def get_index(self):\n        if self.get_depth() == 0:\n            return None\n        else:\n            key = self.get_key()\n            parent = self.get_parent()\n            return parent.get_child_index(key)\n\n    def get_key(self):\n        return self._key\n\n    def set_key(self, key):\n        self._key = key\n\n    def change_key(self, key):\n        self.get_parent().change_child_key(self._key, key)\n\n    def get_parent(self):\n        if self._parent is None and self.get_depth() > 0:\n            self._parent = self.load_parent()\n        return self._parent\n\n    def load_parent(self):\n        \"\"\"Provide TreeNode with a parent for the current node.  This function\n        is only required if the tree was instantiated from a child node\n        (virtual function)\"\"\"\n        raise TreeWidgetError(\"virtual function.  Implement in subclass\")\n\n    def get_value(self):\n        return self._value\n\n    def is_root(self):\n        return self.get_depth() == 0\n\n    def next_sibling(self):\n        if self.get_depth() > 0:\n            return self.get_parent().next_child(self.get_key())\n        else:\n            return None\n\n    def prev_sibling(self):\n        if self.get_depth() > 0:\n            return self.get_parent().prev_child(self.get_key())\n        else:\n            return None\n\n    def get_root(self):\n        root = self\n        while root.get_parent() is not None:\n            root = root.get_parent()\n        return root",
  "class ParentNode(TreeNode):\n    \"\"\"Maintain sort order for TreeNodes.\"\"\"\n    def __init__(self, value, parent=None, key=None, depth=None):\n        super().__init__(value, parent=parent, key=key, depth=depth)\n\n        self._child_keys = None\n        self._children = {}\n\n    def get_child_keys(self, reload=False):\n        \"\"\"Return a possibly ordered list of child keys\"\"\"\n        if self._child_keys is None or reload == True:\n            self._child_keys = self.load_child_keys()\n        return self._child_keys\n\n    def load_child_keys(self):\n        \"\"\"Provide ParentNode with an ordered list of child keys (virtual\n        function)\"\"\"\n        raise TreeWidgetError(\"virtual function.  Implement in subclass\")\n\n    def get_child_widget(self, key):\n        \"\"\"Return the widget for a given key.  Create if necessary.\"\"\"\n\n        child = self.get_child_node(key)\n        return child.get_widget()\n\n    def get_child_node(self, key, reload=False):\n        \"\"\"Return the child node for a given key.  Create if necessary.\"\"\"\n        if key not in self._children or reload == True:\n            self._children[key] = self.load_child_node(key)\n        return self._children[key]\n\n    def load_child_node(self, key):\n        \"\"\"Load the child node for a given key (virtual function)\"\"\"\n        raise TreeWidgetError(\"virtual function.  Implement in subclass\")\n\n    def set_child_node(self, key, node):\n        \"\"\"Set the child node for a given key.  Useful for bottom-up, lazy\n        population of a tree.\"\"\"\n        self._children[key] = node\n\n    def change_child_key(self, oldkey, newkey):\n        if newkey in self._children:\n            raise TreeWidgetError(f\"{newkey} is already in use\")\n        self._children[newkey] = self._children.pop(oldkey)\n        self._children[newkey].set_key(newkey)\n\n    def get_child_index(self, key):\n        try:\n            return self.get_child_keys().index(key)\n        except ValueError:\n            errorstring = f\"Can't find key %s in ParentNode %s\\nParentNode items: %s\"\n            raise TreeWidgetError(errorstring % (key, self.get_key(),\n                                  str(self.get_child_keys())))\n\n    def next_child(self, key):\n        \"\"\"Return the next child node in index order from the given key.\"\"\"\n\n        index = self.get_child_index(key)\n        # the given node may have just been deleted\n        if index is None:\n            return None\n        index += 1\n\n        child_keys = self.get_child_keys()\n        if index < len(child_keys):\n            # get the next item at same level\n            return self.get_child_node(child_keys[index])\n        else:\n            return None\n\n    def prev_child(self, key):\n        \"\"\"Return the previous child node in index order from the given key.\"\"\"\n        index = self.get_child_index(key)\n        if index is None:\n            return None\n\n        child_keys = self.get_child_keys()\n        index -= 1\n\n        if index >= 0:\n            # get the previous item at same level\n            return self.get_child_node(child_keys[index])\n        else:\n            return None\n\n    def get_first_child(self):\n        \"\"\"Return the first TreeNode in the directory.\"\"\"\n        child_keys = self.get_child_keys()\n        return self.get_child_node(child_keys[0])\n\n    def get_last_child(self):\n        \"\"\"Return the last TreeNode in the directory.\"\"\"\n        child_keys = self.get_child_keys()\n        return self.get_child_node(child_keys[-1])\n\n    def has_children(self):\n        \"\"\"Does this node have any children?\"\"\"\n        return len(self.get_child_keys())>0",
  "class TreeWalker(urwid.ListWalker):\n    \"\"\"ListWalker-compatible class for displaying TreeWidgets\n\n    positions are TreeNodes.\"\"\"\n\n    def __init__(self, start_from):\n        \"\"\"start_from: TreeNode with the initial focus.\"\"\"\n        self.focus = start_from\n\n    def get_focus(self):\n        widget = self.focus.get_widget()\n        return widget, self.focus\n\n    def set_focus(self, focus):\n        self.focus = focus\n        self._modified()\n\n    def get_next(self, start_from):\n        widget = start_from.get_widget()\n        target = widget.next_inorder()\n        if target is None:\n            return None, None\n        else:\n            return target, target.get_node()\n\n    def get_prev(self, start_from):\n        widget = start_from.get_widget()\n        target = widget.prev_inorder()\n        if target is None:\n            return None, None\n        else:\n            return target, target.get_node()",
  "class TreeListBox(urwid.ListBox):\n    \"\"\"A ListBox with special handling for navigation and\n    collapsing of TreeWidgets\"\"\"\n\n    def keypress(self, size: tuple[int, int], key: str) -> str | None:\n        key = super().keypress(size, key)\n        return self.unhandled_input(size, key)\n\n    def unhandled_input(self, size: tuple[int, int], input: str) -> str | None:\n        \"\"\"Handle macro-navigation keys\"\"\"\n        if input == 'left':\n            self.move_focus_to_parent(size)\n        elif input == '-':\n            self.collapse_focus_parent(size)\n        else:\n            return input\n\n    def collapse_focus_parent(self, size: tuple[int, int]) -> None:\n        \"\"\"Collapse parent directory.\"\"\"\n\n        widget, pos = self.body.get_focus()\n        self.move_focus_to_parent(size)\n\n        pwidget, ppos = self.body.get_focus()\n        if pos != ppos:\n            self.keypress(size, \"-\")\n\n    def move_focus_to_parent(self, size: tuple[int, int]) -> None:\n        \"\"\"Move focus to parent of widget in focus.\"\"\"\n\n        widget, pos = self.body.get_focus()\n\n        parentpos = pos.get_parent()\n\n        if parentpos is None:\n            return\n\n        middle, top, bottom = self.calculate_visible(size)\n\n        row_offset, focus_widget, focus_pos, focus_rows, cursor = middle\n        trim_top, fill_above = top\n\n        for widget, pos, rows in fill_above:\n            row_offset -= rows\n            if pos == parentpos:\n                self.change_focus(size, pos, row_offset)\n                return\n\n        self.change_focus(size, pos.get_parent())\n\n    def _keypress_max_left(self, size: tuple[int, int]) -> None:\n        return self.focus_home(size)\n\n    def _keypress_max_right(self, size: tuple[int, int]) -> None:\n        return self.focus_end(size)\n\n    def focus_home(self, size: tuple[int, int]) -> None:\n        \"\"\"Move focus to very top.\"\"\"\n\n        widget, pos = self.body.get_focus()\n        rootnode = pos.get_root()\n        self.change_focus(size, rootnode)\n\n    def focus_end(self, size: tuple[int, int]) -> None:\n        \"\"\"Move focus to far bottom.\"\"\"\n\n        maxrow, maxcol = size\n        widget, pos = self.body.get_focus()\n        rootnode = pos.get_root()\n        rootwidget = rootnode.get_widget()\n        lastwidget = rootwidget.last_child()\n        if lastwidget:\n            lastnode = lastwidget.get_node()\n\n            self.change_focus(size, lastnode, maxrow-1)",
  "def __init__(self, node):\n        self._node = node\n        self._innerwidget = None\n        self.is_leaf = not hasattr(node, 'get_first_child')\n        self.expanded = True\n        widget = self.get_indented_widget()\n        super().__init__(widget)",
  "def selectable(self):\n        \"\"\"\n        Allow selection of non-leaf nodes so children may be (un)expanded\n        \"\"\"\n        return not self.is_leaf",
  "def get_indented_widget(self):\n        widget = self.get_inner_widget()\n        if not self.is_leaf:\n            widget = urwid.Columns([('fixed', 1,\n                [self.unexpanded_icon, self.expanded_icon][self.expanded]),\n                widget], dividechars=1)\n        indent_cols = self.get_indent_cols()\n        return urwid.Padding(widget, width=('relative', 100), left=indent_cols)",
  "def update_expanded_icon(self):\n        \"\"\"Update display widget text for parent widgets\"\"\"\n        # icon is first element in columns indented widget\n        self._w.base_widget.widget_list[0] = [\n            self.unexpanded_icon, self.expanded_icon][self.expanded]",
  "def get_indent_cols(self):\n        return self.indent_cols * self.get_node().get_depth()",
  "def get_inner_widget(self):\n        if self._innerwidget is None:\n            self._innerwidget = self.load_inner_widget()\n        return self._innerwidget",
  "def load_inner_widget(self):\n        return urwid.Text(self.get_display_text())",
  "def get_node(self):\n        return self._node",
  "def get_display_text(self):\n        return (f\"{self.get_node().get_key()}: {str(self.get_node().get_value())}\")",
  "def next_inorder(self):\n        \"\"\"Return the next TreeWidget depth first from this one.\"\"\"\n        # first check if there's a child widget\n        firstchild = self.first_child()\n        if firstchild is not None:\n            return firstchild\n\n        # now we need to hunt for the next sibling\n        thisnode = self.get_node()\n        nextnode = thisnode.next_sibling()\n        depth = thisnode.get_depth()\n        while nextnode is None and depth > 0:\n            # keep going up the tree until we find an ancestor next sibling\n            thisnode = thisnode.get_parent()\n            nextnode = thisnode.next_sibling()\n            depth -= 1\n            assert depth == thisnode.get_depth()\n        if nextnode is None:\n            # we're at the end of the tree\n            return None\n        else:\n            return nextnode.get_widget()",
  "def prev_inorder(self):\n        \"\"\"Return the previous TreeWidget depth first from this one.\"\"\"\n        thisnode = self._node\n        prevnode = thisnode.prev_sibling()\n        if prevnode is not None:\n            # we need to find the last child of the previous widget if its\n            # expanded\n            prevwidget = prevnode.get_widget()\n            lastchild = prevwidget.last_child()\n            if lastchild is None:\n                return prevwidget\n            else:\n                return lastchild\n        else:\n            # need to hunt for the parent\n            depth = thisnode.get_depth()\n            if prevnode is None and depth == 0:\n                return None\n            elif prevnode is None:\n                prevnode = thisnode.get_parent()\n            return prevnode.get_widget()",
  "def keypress(self, size, key: str) -> str | None:\n        \"\"\"Handle expand & collapse requests (non-leaf nodes)\"\"\"\n        if self.is_leaf:\n            return key\n\n        if key in (\"+\", \"right\"):\n            self.expanded = True\n            self.update_expanded_icon()\n        elif key == \"-\":\n            self.expanded = False\n            self.update_expanded_icon()\n        elif self._w.selectable():\n            return super().keypress(size, key)\n        else:\n            return key",
  "def mouse_event(self, size, event, button: int, col: int, row: int, focus: bool) -> bool:\n        if self.is_leaf or event != 'mouse press' or button !=1:\n            return False\n\n        if row == 0 and col == self.get_indent_cols():\n            self.expanded = not self.expanded\n            self.update_expanded_icon()\n            return True\n\n        return False",
  "def first_child(self):\n        \"\"\"Return first child if expanded.\"\"\"\n        if self.is_leaf or not self.expanded:\n            return None\n        else:\n            if self._node.has_children():\n                firstnode = self._node.get_first_child()\n                return firstnode.get_widget()\n            else:\n                return None",
  "def last_child(self):\n        \"\"\"Return last child if expanded.\"\"\"\n        if self.is_leaf or not self.expanded:\n            return None\n        else:\n            if self._node.has_children():\n                lastchild = self._node.get_last_child().get_widget()\n            else:\n                return None\n            # recursively search down for the last descendant\n            lastdescendant = lastchild.last_child()\n            if lastdescendant is None:\n                return lastchild\n            else:\n                return lastdescendant",
  "def __init__(self, value, parent=None, key=None, depth=None):\n        self._key = key\n        self._parent = parent\n        self._value = value\n        self._depth = depth\n        self._widget = None",
  "def get_widget(self, reload=False):\n        \"\"\" Return the widget for this node.\"\"\"\n        if self._widget is None or reload == True:\n            self._widget = self.load_widget()\n        return self._widget",
  "def load_widget(self):\n        return TreeWidget(self)",
  "def get_depth(self):\n        if self._depth is None and self._parent is None:\n            self._depth = 0\n        elif self._depth is None:\n            self._depth = self._parent.get_depth() + 1\n        return self._depth",
  "def get_index(self):\n        if self.get_depth() == 0:\n            return None\n        else:\n            key = self.get_key()\n            parent = self.get_parent()\n            return parent.get_child_index(key)",
  "def get_key(self):\n        return self._key",
  "def set_key(self, key):\n        self._key = key",
  "def change_key(self, key):\n        self.get_parent().change_child_key(self._key, key)",
  "def get_parent(self):\n        if self._parent is None and self.get_depth() > 0:\n            self._parent = self.load_parent()\n        return self._parent",
  "def load_parent(self):\n        \"\"\"Provide TreeNode with a parent for the current node.  This function\n        is only required if the tree was instantiated from a child node\n        (virtual function)\"\"\"\n        raise TreeWidgetError(\"virtual function.  Implement in subclass\")",
  "def get_value(self):\n        return self._value",
  "def is_root(self):\n        return self.get_depth() == 0",
  "def next_sibling(self):\n        if self.get_depth() > 0:\n            return self.get_parent().next_child(self.get_key())\n        else:\n            return None",
  "def prev_sibling(self):\n        if self.get_depth() > 0:\n            return self.get_parent().prev_child(self.get_key())\n        else:\n            return None",
  "def get_root(self):\n        root = self\n        while root.get_parent() is not None:\n            root = root.get_parent()\n        return root",
  "def __init__(self, value, parent=None, key=None, depth=None):\n        super().__init__(value, parent=parent, key=key, depth=depth)\n\n        self._child_keys = None\n        self._children = {}",
  "def get_child_keys(self, reload=False):\n        \"\"\"Return a possibly ordered list of child keys\"\"\"\n        if self._child_keys is None or reload == True:\n            self._child_keys = self.load_child_keys()\n        return self._child_keys",
  "def load_child_keys(self):\n        \"\"\"Provide ParentNode with an ordered list of child keys (virtual\n        function)\"\"\"\n        raise TreeWidgetError(\"virtual function.  Implement in subclass\")",
  "def get_child_widget(self, key):\n        \"\"\"Return the widget for a given key.  Create if necessary.\"\"\"\n\n        child = self.get_child_node(key)\n        return child.get_widget()",
  "def get_child_node(self, key, reload=False):\n        \"\"\"Return the child node for a given key.  Create if necessary.\"\"\"\n        if key not in self._children or reload == True:\n            self._children[key] = self.load_child_node(key)\n        return self._children[key]",
  "def load_child_node(self, key):\n        \"\"\"Load the child node for a given key (virtual function)\"\"\"\n        raise TreeWidgetError(\"virtual function.  Implement in subclass\")",
  "def set_child_node(self, key, node):\n        \"\"\"Set the child node for a given key.  Useful for bottom-up, lazy\n        population of a tree.\"\"\"\n        self._children[key] = node",
  "def change_child_key(self, oldkey, newkey):\n        if newkey in self._children:\n            raise TreeWidgetError(f\"{newkey} is already in use\")\n        self._children[newkey] = self._children.pop(oldkey)\n        self._children[newkey].set_key(newkey)",
  "def get_child_index(self, key):\n        try:\n            return self.get_child_keys().index(key)\n        except ValueError:\n            errorstring = f\"Can't find key %s in ParentNode %s\\nParentNode items: %s\"\n            raise TreeWidgetError(errorstring % (key, self.get_key(),\n                                  str(self.get_child_keys())))",
  "def next_child(self, key):\n        \"\"\"Return the next child node in index order from the given key.\"\"\"\n\n        index = self.get_child_index(key)\n        # the given node may have just been deleted\n        if index is None:\n            return None\n        index += 1\n\n        child_keys = self.get_child_keys()\n        if index < len(child_keys):\n            # get the next item at same level\n            return self.get_child_node(child_keys[index])\n        else:\n            return None",
  "def prev_child(self, key):\n        \"\"\"Return the previous child node in index order from the given key.\"\"\"\n        index = self.get_child_index(key)\n        if index is None:\n            return None\n\n        child_keys = self.get_child_keys()\n        index -= 1\n\n        if index >= 0:\n            # get the previous item at same level\n            return self.get_child_node(child_keys[index])\n        else:\n            return None",
  "def get_first_child(self):\n        \"\"\"Return the first TreeNode in the directory.\"\"\"\n        child_keys = self.get_child_keys()\n        return self.get_child_node(child_keys[0])",
  "def get_last_child(self):\n        \"\"\"Return the last TreeNode in the directory.\"\"\"\n        child_keys = self.get_child_keys()\n        return self.get_child_node(child_keys[-1])",
  "def has_children(self):\n        \"\"\"Does this node have any children?\"\"\"\n        return len(self.get_child_keys())>0",
  "def __init__(self, start_from):\n        \"\"\"start_from: TreeNode with the initial focus.\"\"\"\n        self.focus = start_from",
  "def get_focus(self):\n        widget = self.focus.get_widget()\n        return widget, self.focus",
  "def set_focus(self, focus):\n        self.focus = focus\n        self._modified()",
  "def get_next(self, start_from):\n        widget = start_from.get_widget()\n        target = widget.next_inorder()\n        if target is None:\n            return None, None\n        else:\n            return target, target.get_node()",
  "def get_prev(self, start_from):\n        widget = start_from.get_widget()\n        target = widget.prev_inorder()\n        if target is None:\n            return None, None\n        else:\n            return target, target.get_node()",
  "def keypress(self, size: tuple[int, int], key: str) -> str | None:\n        key = super().keypress(size, key)\n        return self.unhandled_input(size, key)",
  "def unhandled_input(self, size: tuple[int, int], input: str) -> str | None:\n        \"\"\"Handle macro-navigation keys\"\"\"\n        if input == 'left':\n            self.move_focus_to_parent(size)\n        elif input == '-':\n            self.collapse_focus_parent(size)\n        else:\n            return input",
  "def collapse_focus_parent(self, size: tuple[int, int]) -> None:\n        \"\"\"Collapse parent directory.\"\"\"\n\n        widget, pos = self.body.get_focus()\n        self.move_focus_to_parent(size)\n\n        pwidget, ppos = self.body.get_focus()\n        if pos != ppos:\n            self.keypress(size, \"-\")",
  "def move_focus_to_parent(self, size: tuple[int, int]) -> None:\n        \"\"\"Move focus to parent of widget in focus.\"\"\"\n\n        widget, pos = self.body.get_focus()\n\n        parentpos = pos.get_parent()\n\n        if parentpos is None:\n            return\n\n        middle, top, bottom = self.calculate_visible(size)\n\n        row_offset, focus_widget, focus_pos, focus_rows, cursor = middle\n        trim_top, fill_above = top\n\n        for widget, pos, rows in fill_above:\n            row_offset -= rows\n            if pos == parentpos:\n                self.change_focus(size, pos, row_offset)\n                return\n\n        self.change_focus(size, pos.get_parent())",
  "def _keypress_max_left(self, size: tuple[int, int]) -> None:\n        return self.focus_home(size)",
  "def _keypress_max_right(self, size: tuple[int, int]) -> None:\n        return self.focus_end(size)",
  "def focus_home(self, size: tuple[int, int]) -> None:\n        \"\"\"Move focus to very top.\"\"\"\n\n        widget, pos = self.body.get_focus()\n        rootnode = pos.get_root()\n        self.change_focus(size, rootnode)",
  "def focus_end(self, size: tuple[int, int]) -> None:\n        \"\"\"Move focus to far bottom.\"\"\"\n\n        maxrow, maxcol = size\n        widget, pos = self.body.get_focus()\n        rootnode = pos.get_root()\n        rootwidget = rootnode.get_widget()\n        lastwidget = rootwidget.last_child()\n        if lastwidget:\n            lastnode = lastwidget.get_node()\n\n            self.change_focus(size, lastnode, maxrow-1)",
  "class MoreInputRequired(Exception):\n    pass",
  "def escape_modifier(digit):\n    mode = ord(digit) - ord(\"1\")\n    return \"shift \" * (mode & 1) + \"meta \" * ((mode & 2) // 2) + \"ctrl \" * ((mode & 4) // 4)",
  "class KeyqueueTrie:\n    def __init__(self, sequences) -> None:\n        self.data = {}\n        for s, result in sequences:\n            if isinstance(result, dict):\n                raise TypeError(result)\n            self.add(self.data, s, result)\n\n    def add(self, root, s, result):\n        if not isinstance(root, MutableMapping) or len(s) <= 0:\n            raise RuntimeError(\"trie conflict detected\")\n\n        if ord(s[0]) in root:\n            return self.add(root[ord(s[0])], s[1:], result)\n        if len(s) > 1:\n            d = {}\n            root[ord(s[0])] = d\n            return self.add(d, s[1:], result)\n        root[ord(s)] = result\n        return None\n\n    def get(self, keys, more_available: bool):\n        result = self.get_recurse(self.data, keys, more_available)\n        if not result:\n            result = self.read_cursor_position(keys, more_available)\n        return result\n\n    def get_recurse(self, root, keys, more_available: bool):\n        if not isinstance(root, MutableMapping):\n            if root == \"mouse\":\n                return self.read_mouse_info(keys, more_available)\n\n            if root == \"sgrmouse\":\n                return self.read_sgrmouse_info(keys, more_available)\n\n            return (root, keys)\n        if not keys:\n            # get more keys\n            if more_available:\n                raise MoreInputRequired()\n            return None\n        if keys[0] not in root:\n            return None\n        return self.get_recurse(root[keys[0]], keys[1:], more_available)\n\n    def read_mouse_info(self, keys, more_available: bool):\n        if len(keys) < 3:\n            if more_available:\n                raise MoreInputRequired()\n            return None\n\n        b = keys[0] - 32\n        x, y = (keys[1] - 33) % 256, (keys[2] - 33) % 256  # supports 0-255\n\n        prefix = \"\"\n        if b & 4:\n            prefix = f\"{prefix}shift \"\n        if b & 8:\n            prefix = f\"{prefix}meta \"\n        if b & 16:\n            prefix = f\"{prefix}ctrl \"\n        if (b & MOUSE_MULTIPLE_CLICK_MASK) >> 9 == 1:\n            prefix = f\"{prefix}double \"\n        if (b & MOUSE_MULTIPLE_CLICK_MASK) >> 9 == 2:\n            prefix = f\"{prefix}triple \"\n\n        # 0->1, 1->2, 2->3, 64->4, 65->5\n        button = ((b & 64) // 64 * 3) + (b & 3) + 1\n\n        if b & 3 == 3:\n            action = \"release\"\n            button = 0\n        elif b & MOUSE_RELEASE_FLAG:\n            action = \"release\"\n        elif b & MOUSE_DRAG_FLAG:\n            action = \"drag\"\n        elif b & MOUSE_MULTIPLE_CLICK_MASK:\n            action = \"click\"\n        else:\n            action = \"press\"\n\n        return ((f\"{prefix}mouse {action}\", button, x, y), keys[3:])\n\n    def read_sgrmouse_info(self, keys, more_available: bool):\n        # Helpful links:\n        # https://stackoverflow.com/questions/5966903/how-to-get-mousemove-and-mouseclick-in-bash\n        # http://invisible-island.net/xterm/ctlseqs/ctlseqs.pdf\n\n        if not keys:\n            if more_available:\n                raise MoreInputRequired()\n            return None\n\n        value = \"\"\n        pos_m = 0\n        found_m = False\n        for k in keys:\n            value = value + chr(k)\n            if k in (ord(\"M\"), ord(\"m\")):\n                found_m = True\n                break\n            pos_m += 1\n        if not found_m:\n            if more_available:\n                raise MoreInputRequired()\n            return None\n\n        (b, x, y) = value[:-1].split(\";\")\n\n        # shift, meta, ctrl etc. is not communicated on my machine, so I\n        # can't and won't be able to add support for it.\n        # Double and triple clicks are not supported as well. They can be\n        # implemented by using a timer. This timer can check if the last\n        # registered click is below a certain threshold. This threshold\n        # is normally set in the operating system itself, so setting one\n        # here will cause an inconsistent behaviour. I do not plan to use\n        # that feature, so I won't implement it.\n\n        button = ((int(b) & 64) // 64 * 3) + (int(b) & 3) + 1\n        x = int(x) - 1\n        y = int(y) - 1\n\n        if value[-1] == \"M\":\n            if int(b) & MOUSE_DRAG_FLAG:\n                action = \"drag\"\n            else:\n                action = \"press\"\n        else:\n            action = \"release\"\n\n        return ((f\"mouse {action}\", button, x, y), keys[pos_m + 1 :])\n\n    def read_cursor_position(self, keys, more_available: bool):\n        \"\"\"\n        Interpret cursor position information being sent by the\n        user's terminal.  Returned as ('cursor position', x, y)\n        where (x, y) == (0, 0) is the top left of the screen.\n        \"\"\"\n        if not keys:\n            if more_available:\n                raise MoreInputRequired()\n            return None\n        if keys[0] != ord(\"[\"):\n            return None\n        # read y value\n        y = 0\n        i = 1\n        for k in keys[i:]:\n            i += 1\n            if k == ord(\";\"):\n                if not y:\n                    return None\n                break\n            if k < ord(\"0\") or k > ord(\"9\"):\n                return None\n            if not y and k == ord(\"0\"):\n                return None\n            y = y * 10 + k - ord(\"0\")\n        if not keys[i:]:\n            if more_available:\n                raise MoreInputRequired()\n            return None\n        # read x value\n        x = 0\n        for k in keys[i:]:\n            i += 1\n            if k == ord(\"R\"):\n                if not x:\n                    return None\n                return ((\"cursor position\", x - 1, y - 1), keys[i:])\n            if k < ord(\"0\") or k > ord(\"9\"):\n                return None\n            if not x and k == ord(\"0\"):\n                return None\n            x = x * 10 + k - ord(\"0\")\n        if not keys[i:] and more_available:\n            raise MoreInputRequired()\n        return None",
  "def process_keyqueue(codes: Sequence[int], more_available: bool) -> tuple[list[str], Sequence[int]]:\n    \"\"\"\n    codes -- list of key codes\n    more_available -- if True then raise MoreInputRequired when in the\n        middle of a character sequence (escape/utf8/wide) and caller\n        will attempt to send more key codes on the next call.\n\n    returns (list of input, list of remaining key codes).\n    \"\"\"\n    code = codes[0]\n    if 32 <= code <= 126:\n        key = chr(code)\n        return [key], codes[1:]\n    if code in _keyconv:\n        return [_keyconv[code]], codes[1:]\n    if 0 < code < 27:\n        return [f\"ctrl {chr(ord('a') + code - 1)}\"], codes[1:]\n    if 27 < code < 32:\n        return [f\"ctrl {chr(ord('A') + code - 1)}\"], codes[1:]\n\n    em = str_util.get_byte_encoding()\n\n    if em == \"wide\" and code < 256 and within_double_byte(code.to_bytes(1, \"little\"), 0, 0):\n        if not codes[1:] and more_available:\n            raise MoreInputRequired()\n        if codes[1:] and codes[1] < 256:\n            db = chr(code) + chr(codes[1])\n            if within_double_byte(db, 0, 1):\n                return [db], codes[2:]\n    if em == \"utf8\" and 127 < code < 256:\n        if code & 0xE0 == 0xC0:  # 2-byte form\n            need_more = 1\n        elif code & 0xF0 == 0xE0:  # 3-byte form\n            need_more = 2\n        elif code & 0xF8 == 0xF0:  # 4-byte form\n            need_more = 3\n        else:\n            return [f\"<{code:d}>\"], codes[1:]\n\n        for i in range(need_more):\n            if len(codes) - 1 <= i:\n                if more_available:\n                    raise MoreInputRequired()\n\n                return [f\"<{code:d}>\"], codes[1:]\n\n            k = codes[i + 1]\n            if k > 256 or k & 0xC0 != 0x80:\n                return [f\"<{code:d}>\"], codes[1:]\n\n        s = bytes(codes[: need_more + 1])\n\n        try:\n            return [s.decode(\"utf-8\")], codes[need_more + 1 :]\n        except UnicodeDecodeError:\n            return [f\"<{code:d}>\"], codes[1:]\n\n    if 127 < code < 256:\n        key = chr(code)\n        return [key], codes[1:]\n    if code != 27:\n        return [f\"<{code:d}>\"], codes[1:]\n\n    result = input_trie.get(codes[1:], more_available)\n\n    if result is not None:\n        result, remaining_codes = result\n        return [result], remaining_codes\n\n    if codes[1:]:\n        # Meta keys -- ESC+Key form\n        run, remaining_codes = process_keyqueue(codes[1:], more_available)\n        if urwid.util.is_mouse_event(run[0]):\n            return [\"esc\", *run], remaining_codes\n        if run[0] == \"esc\" or run[0].find(\"meta \") >= 0:\n            return [\"esc\", *run], remaining_codes\n        return [f\"meta {run[0]}\"] + run[1:], remaining_codes\n\n    return [\"esc\"], codes[1:]",
  "def set_cursor_position(x: int, y: int) -> str:\n    if not isinstance(x, int):\n        raise TypeError(x)\n    if not isinstance(y, int):\n        raise TypeError(y)\n\n    return ESC + f\"[{y + 1:d};{x + 1:d}H\"",
  "def move_cursor_right(x: int) -> str:\n    if x < 1:\n        return \"\"\n    return ESC + f\"[{x:d}C\"",
  "def move_cursor_up(x: int) -> str:\n    if x < 1:\n        return \"\"\n    return ESC + f\"[{x:d}A\"",
  "def move_cursor_down(x: int) -> str:\n    if x < 1:\n        return \"\"\n    return ESC + f\"[{x:d}B\"",
  "def __init__(self, sequences) -> None:\n        self.data = {}\n        for s, result in sequences:\n            if isinstance(result, dict):\n                raise TypeError(result)\n            self.add(self.data, s, result)",
  "def add(self, root, s, result):\n        if not isinstance(root, MutableMapping) or len(s) <= 0:\n            raise RuntimeError(\"trie conflict detected\")\n\n        if ord(s[0]) in root:\n            return self.add(root[ord(s[0])], s[1:], result)\n        if len(s) > 1:\n            d = {}\n            root[ord(s[0])] = d\n            return self.add(d, s[1:], result)\n        root[ord(s)] = result\n        return None",
  "def get(self, keys, more_available: bool):\n        result = self.get_recurse(self.data, keys, more_available)\n        if not result:\n            result = self.read_cursor_position(keys, more_available)\n        return result",
  "def get_recurse(self, root, keys, more_available: bool):\n        if not isinstance(root, MutableMapping):\n            if root == \"mouse\":\n                return self.read_mouse_info(keys, more_available)\n\n            if root == \"sgrmouse\":\n                return self.read_sgrmouse_info(keys, more_available)\n\n            return (root, keys)\n        if not keys:\n            # get more keys\n            if more_available:\n                raise MoreInputRequired()\n            return None\n        if keys[0] not in root:\n            return None\n        return self.get_recurse(root[keys[0]], keys[1:], more_available)",
  "def read_mouse_info(self, keys, more_available: bool):\n        if len(keys) < 3:\n            if more_available:\n                raise MoreInputRequired()\n            return None\n\n        b = keys[0] - 32\n        x, y = (keys[1] - 33) % 256, (keys[2] - 33) % 256  # supports 0-255\n\n        prefix = \"\"\n        if b & 4:\n            prefix = f\"{prefix}shift \"\n        if b & 8:\n            prefix = f\"{prefix}meta \"\n        if b & 16:\n            prefix = f\"{prefix}ctrl \"\n        if (b & MOUSE_MULTIPLE_CLICK_MASK) >> 9 == 1:\n            prefix = f\"{prefix}double \"\n        if (b & MOUSE_MULTIPLE_CLICK_MASK) >> 9 == 2:\n            prefix = f\"{prefix}triple \"\n\n        # 0->1, 1->2, 2->3, 64->4, 65->5\n        button = ((b & 64) // 64 * 3) + (b & 3) + 1\n\n        if b & 3 == 3:\n            action = \"release\"\n            button = 0\n        elif b & MOUSE_RELEASE_FLAG:\n            action = \"release\"\n        elif b & MOUSE_DRAG_FLAG:\n            action = \"drag\"\n        elif b & MOUSE_MULTIPLE_CLICK_MASK:\n            action = \"click\"\n        else:\n            action = \"press\"\n\n        return ((f\"{prefix}mouse {action}\", button, x, y), keys[3:])",
  "def read_sgrmouse_info(self, keys, more_available: bool):\n        # Helpful links:\n        # https://stackoverflow.com/questions/5966903/how-to-get-mousemove-and-mouseclick-in-bash\n        # http://invisible-island.net/xterm/ctlseqs/ctlseqs.pdf\n\n        if not keys:\n            if more_available:\n                raise MoreInputRequired()\n            return None\n\n        value = \"\"\n        pos_m = 0\n        found_m = False\n        for k in keys:\n            value = value + chr(k)\n            if k in (ord(\"M\"), ord(\"m\")):\n                found_m = True\n                break\n            pos_m += 1\n        if not found_m:\n            if more_available:\n                raise MoreInputRequired()\n            return None\n\n        (b, x, y) = value[:-1].split(\";\")\n\n        # shift, meta, ctrl etc. is not communicated on my machine, so I\n        # can't and won't be able to add support for it.\n        # Double and triple clicks are not supported as well. They can be\n        # implemented by using a timer. This timer can check if the last\n        # registered click is below a certain threshold. This threshold\n        # is normally set in the operating system itself, so setting one\n        # here will cause an inconsistent behaviour. I do not plan to use\n        # that feature, so I won't implement it.\n\n        button = ((int(b) & 64) // 64 * 3) + (int(b) & 3) + 1\n        x = int(x) - 1\n        y = int(y) - 1\n\n        if value[-1] == \"M\":\n            if int(b) & MOUSE_DRAG_FLAG:\n                action = \"drag\"\n            else:\n                action = \"press\"\n        else:\n            action = \"release\"\n\n        return ((f\"mouse {action}\", button, x, y), keys[pos_m + 1 :])",
  "def read_cursor_position(self, keys, more_available: bool):\n        \"\"\"\n        Interpret cursor position information being sent by the\n        user's terminal.  Returned as ('cursor position', x, y)\n        where (x, y) == (0, 0) is the top left of the screen.\n        \"\"\"\n        if not keys:\n            if more_available:\n                raise MoreInputRequired()\n            return None\n        if keys[0] != ord(\"[\"):\n            return None\n        # read y value\n        y = 0\n        i = 1\n        for k in keys[i:]:\n            i += 1\n            if k == ord(\";\"):\n                if not y:\n                    return None\n                break\n            if k < ord(\"0\") or k > ord(\"9\"):\n                return None\n            if not y and k == ord(\"0\"):\n                return None\n            y = y * 10 + k - ord(\"0\")\n        if not keys[i:]:\n            if more_available:\n                raise MoreInputRequired()\n            return None\n        # read x value\n        x = 0\n        for k in keys[i:]:\n            i += 1\n            if k == ord(\"R\"):\n                if not x:\n                    return None\n                return ((\"cursor position\", x - 1, y - 1), keys[i:])\n            if k < ord(\"0\") or k > ord(\"9\"):\n                return None\n            if not x and k == ord(\"0\"):\n                return None\n            x = x * 10 + k - ord(\"0\")\n        if not keys[i:] and more_available:\n            raise MoreInputRequired()\n        return None",
  "class NumEdit(Edit):\n    \"\"\"NumEdit - edit numerical types\n\n    based on the characters in 'allowed' different numerical types\n    can be edited:\n      + regular int: 0123456789\n      + regular float: 0123456789.\n      + regular oct: 01234567\n      + regular hex: 0123456789abcdef\n    \"\"\"\n    ALLOWED = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n\n    def __init__(\n        self,\n        allowed: Container[str],\n        caption,\n        default: str | bytes,\n        trimLeadingZeros: bool = True,\n    ):\n        super().__init__(caption, default)\n        self._allowed = allowed\n        self.trimLeadingZeros = trimLeadingZeros\n\n    def valid_char(self, ch: str) -> bool:\n        \"\"\"\n        Return true for allowed characters.\n        \"\"\"\n        return len(ch) == 1 and ch.upper() in self._allowed\n\n    def keypress(self, size: tuple[int], key: str) -> str | None:\n        \"\"\"\n        Handle editing keystrokes.  Remove leading zeros.\n\n        >>> e, size = NumEdit(\"0123456789\", u\"\", \"5002\"), (10,)\n        >>> e.keypress(size, 'home')\n        >>> e.keypress(size, 'delete')\n        >>> assert e.edit_text == \"002\"\n        >>> e.keypress(size, 'end')\n        >>> assert e.edit_text == \"2\"\n        >>> # binary only\n        >>> e, size = NumEdit(\"01\", u\"\", \"\"), (10,)\n        >>> assert e.edit_text == \"\"\n        >>> e.keypress(size, '1')\n        >>> e.keypress(size, '0')\n        >>> e.keypress(size, '1')\n        >>> assert e.edit_text == \"101\"\n        \"\"\"\n        (maxcol,) = size\n        unhandled = Edit.keypress(self, (maxcol,), key)\n\n        if not unhandled and self.trimLeadingZeros:\n            # trim leading zeros\n            while self.edit_pos > 0 and self.edit_text[:1] == \"0\":\n                self.set_edit_pos(self.edit_pos - 1)\n                self.set_edit_text(self.edit_text[1:])\n\n        return unhandled",
  "class IntegerEdit(NumEdit):\n    \"\"\"Edit widget for integer values\"\"\"\n\n    def __init__(\n        self,\n        caption=\"\",\n        default: int | str | Decimal | None = None,\n        base: int = 10,\n    ) -> None:\n        \"\"\"\n        caption -- caption markup\n        default -- default edit value\n\n        >>> IntegerEdit(u\"\", 42)\n        <IntegerEdit selectable flow widget '42' edit_pos=2>\n        >>> e, size = IntegerEdit(u\"\", \"5002\"), (10,)\n        >>> e.keypress(size, 'home')\n        >>> e.keypress(size, 'delete')\n        >>> assert e.edit_text == \"002\"\n        >>> e.keypress(size, 'end')\n        >>> assert e.edit_text == \"2\"\n        >>> e.keypress(size, '9')\n        >>> e.keypress(size, '0')\n        >>> assert e.edit_text == \"290\"\n        >>> e, size = IntegerEdit(\"\", \"\"), (10,)\n        >>> assert e.value() is None\n        >>> # binary\n        >>> e, size = IntegerEdit(u\"\", \"1010\", base=2), (10,)\n        >>> e.keypress(size, 'end')\n        >>> e.keypress(size, '1')\n        >>> assert e.edit_text == \"10101\"\n        >>> assert e.value() == Decimal(\"21\")\n        >>> # HEX\n        >>> e, size = IntegerEdit(u\"\", \"10\", base=16), (10,)\n        >>> e.keypress(size, 'end')\n        >>> e.keypress(size, 'F')\n        >>> e.keypress(size, 'f')\n        >>> assert e.edit_text == \"10Ff\"\n        >>> assert e.keypress(size, 'G') == 'G'  # unhandled key\n        >>> assert e.edit_text == \"10Ff\"\n        >>> # keep leading 0's when not base 10\n        >>> e, size = IntegerEdit(u\"\", \"10FF\", base=16), (10,)\n        >>> assert e.edit_text == \"10FF\"\n        >>> assert e.value() == Decimal(\"4351\")\n        >>> e.keypress(size, 'home')\n        >>> e.keypress(size, 'delete')\n        >>> e.keypress(size, '0')\n        >>> assert e.edit_text == \"00FF\"\n        >>> # test exception on incompatible value for base\n        >>> e, size = IntegerEdit(u\"\", \"10FG\", base=16), (10,)\n        Traceback (most recent call last):\n            ...\n        ValueError: invalid value: 10FG for base 16\n        >>> # test exception on float init value\n        >>> e, size = IntegerEdit(u\"\", 10.0), (10,)\n        Traceback (most recent call last):\n            ...\n        ValueError: default: Only 'str', 'int', 'long' or Decimal input allowed\n        >>> e, size = IntegerEdit(u\"\", Decimal(\"10.0\")), (10,)\n        Traceback (most recent call last):\n            ...\n        ValueError: not an 'integer Decimal' instance\n        \"\"\"\n        self.base = base\n        val = \"\"\n        allowed_chars = self.ALLOWED[:self.base]\n        if default is not None:\n            if not isinstance(default, (int, str, Decimal)):\n                raise ValueError(\"default: Only 'str', 'int' or Decimal input allowed\")\n\n            # convert to a long first, this will raise a ValueError\n            # in case a float is passed or some other error\n            if isinstance(default, str) and len(default):\n                # check if it is a valid initial value\n                validation_re = f\"^[{allowed_chars}]+$\"\n                if not re.match(validation_re, str(default), re.IGNORECASE):\n                    raise ValueError(f\"invalid value: {default} for base {base}\")\n\n            elif isinstance(default, Decimal):\n                # a Decimal instance with no fractional part\n                if default.as_tuple()[2] != 0:\n                    raise ValueError(\"not an 'integer Decimal' instance\")\n\n            # convert possible int, long or Decimal to str\n            val = str(default)\n\n        super().__init__(allowed_chars, caption, val, trimLeadingZeros=(self.base == 10))\n\n    def value(self) -> Decimal | None:\n        \"\"\"\n        Return the numeric value of self.edit_text.\n\n        >>> e, size = IntegerEdit(), (10,)\n        >>> e.keypress(size, '5')\n        >>> e.keypress(size, '1')\n        >>> assert e.value() == 51\n        \"\"\"\n        if self.edit_text:\n            return Decimal(int(self.edit_text, self.base))\n\n        return None",
  "class FloatEdit(NumEdit):\n    \"\"\"Edit widget for float values.\"\"\"\n\n    def __init__(\n        self,\n        caption=\"\",\n        default: str | int | Decimal | None = None,\n        preserveSignificance: bool = True,\n        decimalSeparator: str = '.',\n    ) -> None:\n        \"\"\"\n        caption -- caption markup\n        default -- default edit value\n        preserveSignificance -- return value has the same signif. as default\n        decimalSeparator -- use '.' as separator by default, optionally a ','\n\n        >>> FloatEdit(u\"\",  \"1.065434\")\n        <FloatEdit selectable flow widget '1.065434' edit_pos=8>\n        >>> e, size = FloatEdit(u\"\", \"1.065434\"), (10,)\n        >>> e.keypress(size, 'home')\n        >>> e.keypress(size, 'delete')\n        >>> assert e.edit_text == \".065434\"\n        >>> e.keypress(size, 'end')\n        >>> e.keypress(size, 'backspace')\n        >>> assert e.edit_text == \".06543\"\n        >>> e, size = FloatEdit(), (10,)\n        >>> e.keypress(size, '5')\n        >>> e.keypress(size, '1')\n        >>> e.keypress(size, '.')\n        >>> e.keypress(size, '5')\n        >>> e.keypress(size, '1')\n        >>> assert e.value() == Decimal(\"51.51\"), e.value()\n        >>> e, size = FloatEdit(decimalSeparator=\":\"), (10,)\n        Traceback (most recent call last):\n            ...\n        ValueError: invalid decimalSeparator: :\n        >>> e, size = FloatEdit(decimalSeparator=\",\"), (10,)\n        >>> e.keypress(size, '5')\n        >>> e.keypress(size, '1')\n        >>> e.keypress(size, ',')\n        >>> e.keypress(size, '5')\n        >>> e.keypress(size, '1')\n        >>> assert e.edit_text == \"51,51\"\n        >>> e, size = FloatEdit(\"\", \"3.1415\", preserveSignificance=True), (10,)\n        >>> e.keypress(size, 'end')\n        >>> e.keypress(size, 'backspace')\n        >>> e.keypress(size, 'backspace')\n        >>> assert e.edit_text == \"3.14\"\n        >>> assert e.value() == Decimal(\"3.1400\")\n        >>> e.keypress(size, '1')\n        >>> e.keypress(size, '5')\n        >>> e.keypress(size, '9')\n        >>> assert e.value() == Decimal(\"3.1416\"), e.value()\n        >>> e, size = FloatEdit(\"\", \"\"), (10,)\n        >>> assert e.value() is None\n        >>> e, size = FloatEdit(u\"\", 10.0), (10,)\n        Traceback (most recent call last):\n            ...\n        ValueError: default: Only 'str', 'int', 'long' or Decimal input allowed\n        \"\"\"\n        self.significance = None\n        self._decimalSeparator = decimalSeparator\n        if decimalSeparator not in ['.', ',']:\n            raise ValueError(f\"invalid decimalSeparator: {decimalSeparator}\")\n\n        val = \"\"\n        if default is not None and default != \"\":\n            if not isinstance(default, (int, str, Decimal)):\n                raise ValueError(\"default: Only 'str', 'int' or Decimal input allowed\")\n\n            if isinstance(default, str) and default:\n                # check if it is a float, raises a ValueError otherwise\n                float(default)\n                default = Decimal(default)\n\n            if preserveSignificance and isinstance(default, Decimal):\n                self.significance = default\n\n            val = str(default)\n\n        super().__init__(self.ALLOWED[0:10] + decimalSeparator,\n                                        caption, val)\n\n    def value(self) -> Decimal | None:\n        \"\"\"\n        Return the numeric value of self.edit_text.\n        \"\"\"\n        if self.edit_text:\n            normalized = Decimal(self.edit_text.replace(self._decimalSeparator, '.'))\n            if self.significance is not None:\n                return normalized.quantize(self.significance)\n            return normalized\n\n        return None",
  "def __init__(\n        self,\n        allowed: Container[str],\n        caption,\n        default: str | bytes,\n        trimLeadingZeros: bool = True,\n    ):\n        super().__init__(caption, default)\n        self._allowed = allowed\n        self.trimLeadingZeros = trimLeadingZeros",
  "def valid_char(self, ch: str) -> bool:\n        \"\"\"\n        Return true for allowed characters.\n        \"\"\"\n        return len(ch) == 1 and ch.upper() in self._allowed",
  "def keypress(self, size: tuple[int], key: str) -> str | None:\n        \"\"\"\n        Handle editing keystrokes.  Remove leading zeros.\n\n        >>> e, size = NumEdit(\"0123456789\", u\"\", \"5002\"), (10,)\n        >>> e.keypress(size, 'home')\n        >>> e.keypress(size, 'delete')\n        >>> assert e.edit_text == \"002\"\n        >>> e.keypress(size, 'end')\n        >>> assert e.edit_text == \"2\"\n        >>> # binary only\n        >>> e, size = NumEdit(\"01\", u\"\", \"\"), (10,)\n        >>> assert e.edit_text == \"\"\n        >>> e.keypress(size, '1')\n        >>> e.keypress(size, '0')\n        >>> e.keypress(size, '1')\n        >>> assert e.edit_text == \"101\"\n        \"\"\"\n        (maxcol,) = size\n        unhandled = Edit.keypress(self, (maxcol,), key)\n\n        if not unhandled and self.trimLeadingZeros:\n            # trim leading zeros\n            while self.edit_pos > 0 and self.edit_text[:1] == \"0\":\n                self.set_edit_pos(self.edit_pos - 1)\n                self.set_edit_text(self.edit_text[1:])\n\n        return unhandled",
  "def __init__(\n        self,\n        caption=\"\",\n        default: int | str | Decimal | None = None,\n        base: int = 10,\n    ) -> None:\n        \"\"\"\n        caption -- caption markup\n        default -- default edit value\n\n        >>> IntegerEdit(u\"\", 42)\n        <IntegerEdit selectable flow widget '42' edit_pos=2>\n        >>> e, size = IntegerEdit(u\"\", \"5002\"), (10,)\n        >>> e.keypress(size, 'home')\n        >>> e.keypress(size, 'delete')\n        >>> assert e.edit_text == \"002\"\n        >>> e.keypress(size, 'end')\n        >>> assert e.edit_text == \"2\"\n        >>> e.keypress(size, '9')\n        >>> e.keypress(size, '0')\n        >>> assert e.edit_text == \"290\"\n        >>> e, size = IntegerEdit(\"\", \"\"), (10,)\n        >>> assert e.value() is None\n        >>> # binary\n        >>> e, size = IntegerEdit(u\"\", \"1010\", base=2), (10,)\n        >>> e.keypress(size, 'end')\n        >>> e.keypress(size, '1')\n        >>> assert e.edit_text == \"10101\"\n        >>> assert e.value() == Decimal(\"21\")\n        >>> # HEX\n        >>> e, size = IntegerEdit(u\"\", \"10\", base=16), (10,)\n        >>> e.keypress(size, 'end')\n        >>> e.keypress(size, 'F')\n        >>> e.keypress(size, 'f')\n        >>> assert e.edit_text == \"10Ff\"\n        >>> assert e.keypress(size, 'G') == 'G'  # unhandled key\n        >>> assert e.edit_text == \"10Ff\"\n        >>> # keep leading 0's when not base 10\n        >>> e, size = IntegerEdit(u\"\", \"10FF\", base=16), (10,)\n        >>> assert e.edit_text == \"10FF\"\n        >>> assert e.value() == Decimal(\"4351\")\n        >>> e.keypress(size, 'home')\n        >>> e.keypress(size, 'delete')\n        >>> e.keypress(size, '0')\n        >>> assert e.edit_text == \"00FF\"\n        >>> # test exception on incompatible value for base\n        >>> e, size = IntegerEdit(u\"\", \"10FG\", base=16), (10,)\n        Traceback (most recent call last):\n            ...\n        ValueError: invalid value: 10FG for base 16\n        >>> # test exception on float init value\n        >>> e, size = IntegerEdit(u\"\", 10.0), (10,)\n        Traceback (most recent call last):\n            ...\n        ValueError: default: Only 'str', 'int', 'long' or Decimal input allowed\n        >>> e, size = IntegerEdit(u\"\", Decimal(\"10.0\")), (10,)\n        Traceback (most recent call last):\n            ...\n        ValueError: not an 'integer Decimal' instance\n        \"\"\"\n        self.base = base\n        val = \"\"\n        allowed_chars = self.ALLOWED[:self.base]\n        if default is not None:\n            if not isinstance(default, (int, str, Decimal)):\n                raise ValueError(\"default: Only 'str', 'int' or Decimal input allowed\")\n\n            # convert to a long first, this will raise a ValueError\n            # in case a float is passed or some other error\n            if isinstance(default, str) and len(default):\n                # check if it is a valid initial value\n                validation_re = f\"^[{allowed_chars}]+$\"\n                if not re.match(validation_re, str(default), re.IGNORECASE):\n                    raise ValueError(f\"invalid value: {default} for base {base}\")\n\n            elif isinstance(default, Decimal):\n                # a Decimal instance with no fractional part\n                if default.as_tuple()[2] != 0:\n                    raise ValueError(\"not an 'integer Decimal' instance\")\n\n            # convert possible int, long or Decimal to str\n            val = str(default)\n\n        super().__init__(allowed_chars, caption, val, trimLeadingZeros=(self.base == 10))",
  "def value(self) -> Decimal | None:\n        \"\"\"\n        Return the numeric value of self.edit_text.\n\n        >>> e, size = IntegerEdit(), (10,)\n        >>> e.keypress(size, '5')\n        >>> e.keypress(size, '1')\n        >>> assert e.value() == 51\n        \"\"\"\n        if self.edit_text:\n            return Decimal(int(self.edit_text, self.base))\n\n        return None",
  "def __init__(\n        self,\n        caption=\"\",\n        default: str | int | Decimal | None = None,\n        preserveSignificance: bool = True,\n        decimalSeparator: str = '.',\n    ) -> None:\n        \"\"\"\n        caption -- caption markup\n        default -- default edit value\n        preserveSignificance -- return value has the same signif. as default\n        decimalSeparator -- use '.' as separator by default, optionally a ','\n\n        >>> FloatEdit(u\"\",  \"1.065434\")\n        <FloatEdit selectable flow widget '1.065434' edit_pos=8>\n        >>> e, size = FloatEdit(u\"\", \"1.065434\"), (10,)\n        >>> e.keypress(size, 'home')\n        >>> e.keypress(size, 'delete')\n        >>> assert e.edit_text == \".065434\"\n        >>> e.keypress(size, 'end')\n        >>> e.keypress(size, 'backspace')\n        >>> assert e.edit_text == \".06543\"\n        >>> e, size = FloatEdit(), (10,)\n        >>> e.keypress(size, '5')\n        >>> e.keypress(size, '1')\n        >>> e.keypress(size, '.')\n        >>> e.keypress(size, '5')\n        >>> e.keypress(size, '1')\n        >>> assert e.value() == Decimal(\"51.51\"), e.value()\n        >>> e, size = FloatEdit(decimalSeparator=\":\"), (10,)\n        Traceback (most recent call last):\n            ...\n        ValueError: invalid decimalSeparator: :\n        >>> e, size = FloatEdit(decimalSeparator=\",\"), (10,)\n        >>> e.keypress(size, '5')\n        >>> e.keypress(size, '1')\n        >>> e.keypress(size, ',')\n        >>> e.keypress(size, '5')\n        >>> e.keypress(size, '1')\n        >>> assert e.edit_text == \"51,51\"\n        >>> e, size = FloatEdit(\"\", \"3.1415\", preserveSignificance=True), (10,)\n        >>> e.keypress(size, 'end')\n        >>> e.keypress(size, 'backspace')\n        >>> e.keypress(size, 'backspace')\n        >>> assert e.edit_text == \"3.14\"\n        >>> assert e.value() == Decimal(\"3.1400\")\n        >>> e.keypress(size, '1')\n        >>> e.keypress(size, '5')\n        >>> e.keypress(size, '9')\n        >>> assert e.value() == Decimal(\"3.1416\"), e.value()\n        >>> e, size = FloatEdit(\"\", \"\"), (10,)\n        >>> assert e.value() is None\n        >>> e, size = FloatEdit(u\"\", 10.0), (10,)\n        Traceback (most recent call last):\n            ...\n        ValueError: default: Only 'str', 'int', 'long' or Decimal input allowed\n        \"\"\"\n        self.significance = None\n        self._decimalSeparator = decimalSeparator\n        if decimalSeparator not in ['.', ',']:\n            raise ValueError(f\"invalid decimalSeparator: {decimalSeparator}\")\n\n        val = \"\"\n        if default is not None and default != \"\":\n            if not isinstance(default, (int, str, Decimal)):\n                raise ValueError(\"default: Only 'str', 'int' or Decimal input allowed\")\n\n            if isinstance(default, str) and default:\n                # check if it is a float, raises a ValueError otherwise\n                float(default)\n                default = Decimal(default)\n\n            if preserveSignificance and isinstance(default, Decimal):\n                self.significance = default\n\n            val = str(default)\n\n        super().__init__(self.ALLOWED[0:10] + decimalSeparator,\n                                        caption, val)",
  "def value(self) -> Decimal | None:\n        \"\"\"\n        Return the numeric value of self.edit_text.\n        \"\"\"\n        if self.edit_text:\n            normalized = Decimal(self.edit_text.replace(self._decimalSeparator, '.'))\n            if self.significance is not None:\n                return normalized.quantize(self.significance)\n            return normalized\n\n        return None",
  "class Command(str, enum.Enum):\n    REDRAW_SCREEN = \"redraw screen\"\n    UP = \"cursor up\"\n    DOWN = \"cursor down\"\n    LEFT = \"cursor left\"\n    RIGHT = \"cursor right\"\n    PAGE_UP = \"cursor page up\"\n    PAGE_DOWN = \"cursor page down\"\n    MAX_LEFT = \"cursor max left\"\n    MAX_RIGHT = \"cursor max right\"\n    ACTIVATE = \"activate\"\n    MENU = \"menu\"",
  "class CommandMap(typing.Mapping[str, typing.Union[str, Command, None]]):\n    \"\"\"\n    dict-like object for looking up commands from keystrokes\n\n    Default values (key: command)::\n\n        'tab':       'next selectable',\n        'ctrl n':    'next selectable',\n        'shift tab': 'prev selectable',\n        'ctrl p':    'prev selectable',\n        'ctrl l':    'redraw screen',\n        'esc':       'menu',\n        'up':        'cursor up',\n        'down':      'cursor down',\n        'left':      'cursor left',\n        'right':     'cursor right',\n        'page up':   'cursor page up',\n        'page down': 'cursor page down',\n        'home':      'cursor max left',\n        'end':       'cursor max right',\n        ' ':         'activate',\n        'enter':     'activate',\n    \"\"\"\n\n    def __iter__(self) -> Iterator[str]:\n        return iter(self._command)\n\n    def __len__(self) -> int:\n        return len(self._command)\n\n    _command_defaults: typing.ClassVar[dict[str, str | Command]] = {\n        \"tab\": \"next selectable\",\n        \"ctrl n\": \"next selectable\",\n        \"shift tab\": \"prev selectable\",\n        \"ctrl p\": \"prev selectable\",\n        \"ctrl l\": Command.REDRAW_SCREEN,\n        \"esc\": Command.MENU,\n        \"up\": Command.UP,\n        \"down\": Command.DOWN,\n        \"left\": Command.LEFT,\n        \"right\": Command.RIGHT,\n        \"page up\": Command.PAGE_UP,\n        \"page down\": Command.PAGE_DOWN,\n        \"home\": Command.MAX_LEFT,\n        \"end\": Command.MAX_RIGHT,\n        \" \": Command.ACTIVATE,\n        \"enter\": Command.ACTIVATE,\n    }\n\n    def __init__(self) -> None:\n        self._command = dict(self._command_defaults)\n\n    def restore_defaults(self) -> None:\n        self._command = dict(self._command_defaults)\n\n    def __getitem__(self, key: str) -> str | Command | None:\n        return self._command.get(key, None)\n\n    def __setitem__(self, key, command: str | Command) -> None:\n        self._command[key] = command\n\n    def __delitem__(self, key: str) -> None:\n        del self._command[key]\n\n    def clear_command(self, command: str | Command) -> None:\n        dk = [k for k, v in self._command.items() if v == command]\n        for k in dk:\n            del self._command[k]\n\n    def copy(self) -> Self:\n        \"\"\"\n        Return a new copy of this CommandMap, likely so we can modify\n        it separate from a shared one.\n        \"\"\"\n        c = self.__class__()\n        c._command = dict(self._command)\n        return c",
  "def __iter__(self) -> Iterator[str]:\n        return iter(self._command)",
  "def __len__(self) -> int:\n        return len(self._command)",
  "def __init__(self) -> None:\n        self._command = dict(self._command_defaults)",
  "def restore_defaults(self) -> None:\n        self._command = dict(self._command_defaults)",
  "def __getitem__(self, key: str) -> str | Command | None:\n        return self._command.get(key, None)",
  "def __setitem__(self, key, command: str | Command) -> None:\n        self._command[key] = command",
  "def __delitem__(self, key: str) -> None:\n        del self._command[key]",
  "def clear_command(self, command: str | Command) -> None:\n        dk = [k for k, v in self._command.items() if v == command]\n        for k in dk:\n            del self._command[k]",
  "def copy(self) -> Self:\n        \"\"\"\n        Return a new copy of this CommandMap, likely so we can modify\n        it separate from a shared one.\n        \"\"\"\n        c = self.__class__()\n        c._command = dict(self._command)\n        return c",
  "class HtmlGeneratorSimulationError(Exception):\n    pass",
  "class HtmlGenerator(BaseScreen):\n    # class variables\n    fragments = []\n    sizes = []\n    keys = []\n    started = True\n\n    def __init__(self):\n        super().__init__()\n        self.colors = 16\n        self.bright_is_bold = False  # ignored\n        self.has_underline = True  # ignored\n        self.register_palette_entry(None, _default_foreground, _default_background)\n\n    def set_terminal_properties(\n        self,\n        colors: int | None = None,\n        bright_is_bold: bool | None = None,\n        has_underline: bool | None = None,\n    ) -> None:\n\n        if colors is None:\n            colors = self.colors\n        if bright_is_bold is None:\n            bright_is_bold = self.bright_is_bold\n        if has_underline is None:\n            has_underline = self.has_underline\n\n        self.colors = colors\n        self.bright_is_bold = bright_is_bold\n        self.has_underline = has_underline\n\n    def set_mouse_tracking(self, enable=True):\n        \"\"\"Not yet implemented\"\"\"\n        pass\n\n    def set_input_timeouts(self, *args):\n        pass\n\n    def reset_default_terminal_palette(self, *args):\n        pass\n\n    def draw_screen(self, size, r ):\n        \"\"\"Create an html fragment from the render object.\n        Append it to HtmlGenerator.fragments list.\n        \"\"\"\n        # collect output in l\n        l = []\n\n        cols, rows = size\n\n        assert r.rows() == rows\n\n        if r.cursor is not None:\n            cx, cy = r.cursor\n        else:\n            cx = cy = None\n\n        y = -1\n        for row in r.content():\n            y += 1\n            col = 0\n\n            for a, cs, run in row:\n                run = run.decode().translate(_trans_table)\n                if isinstance(a, AttrSpec):\n                    aspec = a\n                else:\n                    aspec = self._palette[a][\n                        {1: 1, 16: 0, 88:2, 256:3}[self.colors]]\n\n                if y == cy and col <= cx:\n                    run_width = util.calc_width(run, 0,\n                        len(run))\n                    if col+run_width > cx:\n                        l.append(html_span(run,\n                            aspec, cx-col))\n                    else:\n                        l.append(html_span(run, aspec))\n                    col += run_width\n                else:\n                    l.append(html_span(run, aspec))\n\n            l.append(\"\\n\")\n\n        # add the fragment to the list\n        self.fragments.append( f\"<pre>{''.join(l)}</pre>\" )\n\n    def clear(self):\n        \"\"\"\n        Force the screen to be completely repainted on the next\n        call to draw_screen().\n\n        (does nothing for html_fragment)\n        \"\"\"\n        pass\n\n    def get_cols_rows(self):\n        \"\"\"Return the next screen size in HtmlGenerator.sizes.\"\"\"\n        if not self.sizes:\n            raise HtmlGeneratorSimulationError(\"Ran out of screen sizes to return!\")\n        return self.sizes.pop(0)\n\n    @typing.overload\n    def get_input(self, raw_keys: Literal[False]) -> list[str]:\n        ...\n\n    @typing.overload\n    def get_input(self, raw_keys: Literal[True]) -> tuple[list[str], list[int]]:\n        ...\n\n    def get_input(self, raw_keys: bool = False) -> list[str] | tuple[list[str], list[int]]:\n        \"\"\"Return the next list of keypresses in HtmlGenerator.keys.\"\"\"\n        if not self.keys:\n            raise ExitMainLoop()\n        if raw_keys:\n            return (self.keys.pop(0), [])\n        return self.keys.pop(0)",
  "def html_span(s, aspec, cursor: int = -1):\n    fg_r, fg_g, fg_b, bg_r, bg_g, bg_b = aspec.get_rgb_values()\n    # use real colours instead of default fg/bg\n    if fg_r is None:\n        fg_r, fg_g, fg_b = _d_fg_r, _d_fg_g, _d_fg_b\n    if bg_r is None:\n        bg_r, bg_g, bg_b = _d_bg_r, _d_bg_g, _d_bg_b\n    html_fg = f\"#{fg_r:02x}{fg_g:02x}{fg_b:02x}\"\n    html_bg = f\"#{bg_r:02x}{bg_g:02x}{bg_b:02x}\"\n    if aspec.standout:\n        html_fg, html_bg = html_bg, html_fg\n    extra = (\";text-decoration:underline\" * aspec.underline + \";font-weight:bold\" * aspec.bold)\n    def html_span(fg, bg, s):\n        if not s: return \"\"\n        return f'<span style=\"color:{fg};background:{bg}{extra}\">{html_escape(s)}</span>'\n\n    if cursor >= 0:\n        c_off, _ign = util.calc_text_pos(s, 0, len(s), cursor)\n        c2_off = util.move_next_char(s, c_off, len(s))\n        return (html_span(html_fg, html_bg, s[:c_off]) +\n            html_span(html_bg, html_fg, s[c_off:c2_off]) +\n            html_span(html_fg, html_bg, s[c2_off:]))\n    else:\n        return html_span(html_fg, html_bg, s)",
  "def html_escape(text: str) -> str:\n    \"\"\"Escape text so that it will be displayed safely within HTML\"\"\"\n    text = text.replace('&','&amp;')\n    text = text.replace('<','&lt;')\n    text = text.replace('>','&gt;')\n    return text",
  "def screenshot_init(sizes: list[tuple[int, int]], keys: list[list[str]]) -> None:\n    \"\"\"\n    Replace curses_display.Screen and raw_display.Screen class with\n    HtmlGenerator.\n\n    Call this function before executing an application that uses\n    curses_display.Screen to have that code use HtmlGenerator instead.\n\n    sizes -- list of ( columns, rows ) tuples to be returned by each call\n             to HtmlGenerator.get_cols_rows()\n    keys -- list of lists of keys to be returned by each call to\n            HtmlGenerator.get_input()\n\n    Lists of keys may include \"window resize\" to force the application to\n    call get_cols_rows and read a new screen size.\n\n    For example, the following call will prepare an application to:\n     1. start in 80x25 with its first call to get_cols_rows()\n     2. take a screenshot when it calls draw_screen(..)\n     3. simulate 5 \"down\" keys from get_input()\n     4. take a screenshot when it calls draw_screen(..)\n     5. simulate keys \"a\", \"b\", \"c\" and a \"window resize\"\n     6. resize to 20x10 on its second call to get_cols_rows()\n     7. take a screenshot when it calls draw_screen(..)\n     8. simulate a \"Q\" keypress to quit the application\n\n    screenshot_init( [ (80,25), (20,10) ],\n        [ [\"down\"]*5, [\"a\",\"b\",\"c\",\"window resize\"], [\"Q\"] ] )\n    \"\"\"\n    try:\n        for (row, col) in sizes:\n            assert isinstance(row, int)\n            assert row > 0 and col > 0\n    except (AssertionError, ValueError):\n        raise Exception(\"sizes must be in the form [ (col1,row1), (col2,row2), ...]\")\n\n    try:\n        for l in keys:\n            assert isinstance(l, list)\n            for k in l:\n                assert isinstance(k, str)\n    except (AssertionError, ValueError):\n        raise Exception(\"keys must be in the form [ [keyA1, keyA2, ..], [keyB1, ..], ...]\")\n\n    from . import curses_display\n    curses_display.Screen = HtmlGenerator\n    from . import raw_display\n    raw_display.Screen = HtmlGenerator\n\n    HtmlGenerator.sizes = sizes\n    HtmlGenerator.keys = keys",
  "def screenshot_collect():\n    \"\"\"Return screenshots as a list of HTML fragments.\"\"\"\n    l = HtmlGenerator.fragments\n    HtmlGenerator.fragments = []\n    return l",
  "def __init__(self):\n        super().__init__()\n        self.colors = 16\n        self.bright_is_bold = False  # ignored\n        self.has_underline = True  # ignored\n        self.register_palette_entry(None, _default_foreground, _default_background)",
  "def set_terminal_properties(\n        self,\n        colors: int | None = None,\n        bright_is_bold: bool | None = None,\n        has_underline: bool | None = None,\n    ) -> None:\n\n        if colors is None:\n            colors = self.colors\n        if bright_is_bold is None:\n            bright_is_bold = self.bright_is_bold\n        if has_underline is None:\n            has_underline = self.has_underline\n\n        self.colors = colors\n        self.bright_is_bold = bright_is_bold\n        self.has_underline = has_underline",
  "def set_mouse_tracking(self, enable=True):\n        \"\"\"Not yet implemented\"\"\"\n        pass",
  "def set_input_timeouts(self, *args):\n        pass",
  "def reset_default_terminal_palette(self, *args):\n        pass",
  "def draw_screen(self, size, r ):\n        \"\"\"Create an html fragment from the render object.\n        Append it to HtmlGenerator.fragments list.\n        \"\"\"\n        # collect output in l\n        l = []\n\n        cols, rows = size\n\n        assert r.rows() == rows\n\n        if r.cursor is not None:\n            cx, cy = r.cursor\n        else:\n            cx = cy = None\n\n        y = -1\n        for row in r.content():\n            y += 1\n            col = 0\n\n            for a, cs, run in row:\n                run = run.decode().translate(_trans_table)\n                if isinstance(a, AttrSpec):\n                    aspec = a\n                else:\n                    aspec = self._palette[a][\n                        {1: 1, 16: 0, 88:2, 256:3}[self.colors]]\n\n                if y == cy and col <= cx:\n                    run_width = util.calc_width(run, 0,\n                        len(run))\n                    if col+run_width > cx:\n                        l.append(html_span(run,\n                            aspec, cx-col))\n                    else:\n                        l.append(html_span(run, aspec))\n                    col += run_width\n                else:\n                    l.append(html_span(run, aspec))\n\n            l.append(\"\\n\")\n\n        # add the fragment to the list\n        self.fragments.append( f\"<pre>{''.join(l)}</pre>\" )",
  "def clear(self):\n        \"\"\"\n        Force the screen to be completely repainted on the next\n        call to draw_screen().\n\n        (does nothing for html_fragment)\n        \"\"\"\n        pass",
  "def get_cols_rows(self):\n        \"\"\"Return the next screen size in HtmlGenerator.sizes.\"\"\"\n        if not self.sizes:\n            raise HtmlGeneratorSimulationError(\"Ran out of screen sizes to return!\")\n        return self.sizes.pop(0)",
  "def get_input(self, raw_keys: Literal[False]) -> list[str]:\n        ...",
  "def get_input(self, raw_keys: Literal[True]) -> tuple[list[str], list[int]]:\n        ...",
  "def get_input(self, raw_keys: bool = False) -> list[str] | tuple[list[str], list[int]]:\n        \"\"\"Return the next list of keypresses in HtmlGenerator.keys.\"\"\"\n        if not self.keys:\n            raise ExitMainLoop()\n        if raw_keys:\n            return (self.keys.pop(0), [])\n        return self.keys.pop(0)",
  "def html_span(fg, bg, s):\n        if not s: return \"\"\n        return f'<span style=\"color:{fg};background:{bg}{extra}\">{html_escape(s)}</span>'",
  "class Screen(BaseScreen, RealTerminal):\n    def __init__(self):\n        super().__init__()\n        self.curses_pairs = [\n            (None,None), # Can't be sure what pair 0 will default to\n        ]\n        self.palette = {}\n        self.has_color = False\n        self.s = None\n        self.cursor_state = None\n        self._keyqueue = []\n        self.prev_input_resize = 0\n        self.set_input_timeouts()\n        self.last_bstate = 0\n        self._mouse_tracking_enabled = False\n\n        self.register_palette_entry(None, 'default','default')\n\n    def set_mouse_tracking(self, enable: bool = True) -> None:\n        \"\"\"\n        Enable mouse tracking.\n\n        After calling this function get_input will include mouse\n        click events along with keystrokes.\n        \"\"\"\n        enable = bool(enable)\n        if enable == self._mouse_tracking_enabled:\n            return\n\n        if enable:\n            curses.mousemask(0\n                | curses.BUTTON1_PRESSED | curses.BUTTON1_RELEASED\n                | curses.BUTTON2_PRESSED | curses.BUTTON2_RELEASED\n                | curses.BUTTON3_PRESSED | curses.BUTTON3_RELEASED\n                | curses.BUTTON4_PRESSED | curses.BUTTON4_RELEASED\n                | curses.BUTTON1_DOUBLE_CLICKED | curses.BUTTON1_TRIPLE_CLICKED\n                | curses.BUTTON2_DOUBLE_CLICKED | curses.BUTTON2_TRIPLE_CLICKED\n                | curses.BUTTON3_DOUBLE_CLICKED | curses.BUTTON3_TRIPLE_CLICKED\n                | curses.BUTTON4_DOUBLE_CLICKED | curses.BUTTON4_TRIPLE_CLICKED\n                | curses.BUTTON_SHIFT | curses.BUTTON_ALT\n                | curses.BUTTON_CTRL)\n        else:\n            raise NotImplementedError()\n\n        self._mouse_tracking_enabled = enable\n\n    def _start(self) -> None:\n        \"\"\"\n        Initialize the screen and input mode.\n        \"\"\"\n        self.s = curses.initscr()\n        self.has_color = curses.has_colors()\n        if self.has_color:\n            curses.start_color()\n            if curses.COLORS < 8:\n                # not colourful enough\n                self.has_color = False\n        if self.has_color:\n            try:\n                curses.use_default_colors()\n                self.has_default_colors=True\n            except _curses.error:\n                self.has_default_colors=False\n        self._setup_colour_pairs()\n        curses.noecho()\n        curses.meta(1)\n        curses.halfdelay(10) # use set_input_timeouts to adjust\n        self.s.keypad(0)\n\n        if not self._signal_keys_set:\n            self._old_signal_keys = self.tty_signal_keys()\n\n        super()._start()\n\n    def _stop(self) -> None:\n        \"\"\"\n        Restore the screen.\n        \"\"\"\n        curses.echo()\n        self._curs_set(1)\n        try:\n            curses.endwin()\n        except _curses.error:\n            pass # don't block original error with curses error\n\n        if self._old_signal_keys:\n            self.tty_signal_keys(*self._old_signal_keys)\n\n        super()._stop()\n\n    def _setup_colour_pairs(self) -> None:\n        \"\"\"\n        Initialize all 63 color pairs based on the term:\n        bg * 8 + 7 - fg\n        So to get a color, we just need to use that term and get the right color\n        pair number.\n        \"\"\"\n        if not self.has_color:\n            return\n\n        for fg in range(8):\n            for bg in range(8):\n                # leave out white on black\n                if fg == curses.COLOR_WHITE and \\\n                   bg == curses.COLOR_BLACK:\n                    continue\n\n                curses.init_pair(bg * 8 + 7 - fg, fg, bg)\n\n    def _curs_set(self, x):\n        if self.cursor_state == \"fixed\" or x == self.cursor_state:\n            return\n        try:\n            curses.curs_set(x)\n            self.cursor_state = x\n        except _curses.error:\n            self.cursor_state = \"fixed\"\n\n    def _clear(self) -> None:\n        self.s.clear()\n        self.s.refresh()\n\n    def _getch(self, wait_tenths: int | None) -> int:\n        if wait_tenths == 0:\n            return self._getch_nodelay()\n        if wait_tenths is None:\n            curses.cbreak()\n        else:\n            curses.halfdelay(wait_tenths)\n        self.s.nodelay(0)\n        return self.s.getch()\n\n    def _getch_nodelay(self) -> int:\n        self.s.nodelay(1)\n        while 1:\n            # this call fails sometimes, but seems to work when I try again\n            try:\n                curses.cbreak()\n                break\n            except _curses.error:\n                pass\n\n        return self.s.getch()\n\n    def set_input_timeouts(\n        self,\n        max_wait: int | float | None = None,\n        complete_wait: int | float = 0.1,\n        resize_wait: int | float = 0.1,\n    ):\n        \"\"\"\n        Set the get_input timeout values.  All values have a granularity\n        of 0.1s, ie. any value between 0.15 and 0.05 will be treated as\n        0.1 and any value less than 0.05 will be treated as 0.  The\n        maximum timeout value for this module is 25.5 seconds.\n\n        max_wait -- amount of time in seconds to wait for input when\n            there is no input pending, wait forever if None\n        complete_wait -- amount of time in seconds to wait when\n            get_input detects an incomplete escape sequence at the\n            end of the available input\n        resize_wait -- amount of time in seconds to wait for more input\n            after receiving two screen resize requests in a row to\n            stop urwid from consuming 100% cpu during a gradual\n            window resize operation\n        \"\"\"\n\n        def convert_to_tenths( s ):\n            if s is None:\n                return None\n            return int( (s+0.05)*10 )\n\n        self.max_tenths = convert_to_tenths(max_wait)\n        self.complete_tenths = convert_to_tenths(complete_wait)\n        self.resize_tenths = convert_to_tenths(resize_wait)\n\n    @typing.overload\n    def get_input(self, raw_keys: Literal[False]) -> list[str]:\n        ...\n\n    @typing.overload\n    def get_input(self, raw_keys: Literal[True]) -> tuple[list[str], list[int]]:\n        ...\n\n    def get_input(self, raw_keys: bool = False) -> list[str] | tuple[list[str], list[int]]:\n        \"\"\"Return pending input as a list.\n\n        raw_keys -- return raw keycodes as well as translated versions\n\n        This function will immediately return all the input since the\n        last time it was called.  If there is no input pending it will\n        wait before returning an empty list.  The wait time may be\n        configured with the set_input_timeouts function.\n\n        If raw_keys is False (default) this function will return a list\n        of keys pressed.  If raw_keys is True this function will return\n        a ( keys pressed, raw keycodes ) tuple instead.\n\n        Examples of keys returned:\n\n        * ASCII printable characters:  \" \", \"a\", \"0\", \"A\", \"-\", \"/\"\n        * ASCII control characters:  \"tab\", \"enter\"\n        * Escape sequences:  \"up\", \"page up\", \"home\", \"insert\", \"f1\"\n        * Key combinations:  \"shift f1\", \"meta a\", \"ctrl b\"\n        * Window events:  \"window resize\"\n\n        When a narrow encoding is not enabled:\n\n        * \"Extended ASCII\" characters:  \"\\\\xa1\", \"\\\\xb2\", \"\\\\xfe\"\n\n        When a wide encoding is enabled:\n\n        * Double-byte characters:  \"\\\\xa1\\\\xea\", \"\\\\xb2\\\\xd4\"\n\n        When utf8 encoding is enabled:\n\n        * Unicode characters: u\"\\\\u00a5\", u'\\\\u253c\"\n\n        Examples of mouse events returned:\n\n        * Mouse button press: ('mouse press', 1, 15, 13),\n                            ('meta mouse press', 2, 17, 23)\n        * Mouse button release: ('mouse release', 0, 18, 13),\n                              ('ctrl mouse release', 0, 17, 23)\n        \"\"\"\n        assert self._started\n\n        keys, raw = self._get_input(self.max_tenths)\n\n        # Avoid pegging CPU at 100% when slowly resizing, and work\n        # around a bug with some braindead curses implementations that\n        # return \"no key\" between \"window resize\" commands\n        if keys == ['window resize'] and self.prev_input_resize:\n            while True:\n                keys, raw2 = self._get_input(self.resize_tenths)\n                raw += raw2\n                if not keys:\n                    keys, raw2 = self._get_input(self.resize_tenths)\n                    raw += raw2\n                if keys != ['window resize']:\n                    break\n            if keys[-1:] != ['window resize']:\n                keys.append('window resize')\n\n        if keys == ['window resize']:\n            self.prev_input_resize = 2\n        elif self.prev_input_resize == 2 and not keys:\n            self.prev_input_resize = 1\n        else:\n            self.prev_input_resize = 0\n\n        if raw_keys:\n            return keys, raw\n        return keys\n\n    def _get_input(self, wait_tenths: int | None) -> tuple[list[str], list[int]]:\n        # this works around a strange curses bug with window resizing\n        # not being reported correctly with repeated calls to this\n        # function without a doupdate call in between\n        curses.doupdate()\n\n        key = self._getch(wait_tenths)\n        resize = False\n        raw = []\n        keys = []\n\n        while key >= 0:\n            raw.append(key)\n            if key == KEY_RESIZE:\n                resize = True\n            elif key == KEY_MOUSE:\n                keys += self._encode_mouse_event()\n            else:\n                keys.append(key)\n            key = self._getch_nodelay()\n\n        processed = []\n\n        try:\n            while keys:\n                run, keys = escape.process_keyqueue(keys, True)\n                processed += run\n        except escape.MoreInputRequired:\n            key = self._getch(self.complete_tenths)\n            while key >= 0:\n                raw.append(key)\n                if key == KEY_RESIZE:\n                    resize = True\n                elif key == KEY_MOUSE:\n                    keys += self._encode_mouse_event()\n                else:\n                    keys.append(key)\n                key = self._getch_nodelay()\n            while keys:\n                run, keys = escape.process_keyqueue(keys, False)\n                processed += run\n\n        if resize:\n            processed.append('window resize')\n\n        return processed, raw\n\n    def _encode_mouse_event(self) -> list[int]:\n        # convert to escape sequence\n        last = next = self.last_bstate\n        (id, x, y, z, bstate) = curses.getmouse()\n\n        mod = 0\n        if bstate & curses.BUTTON_SHIFT:\n            mod |= 4\n        if bstate & curses.BUTTON_ALT:\n            mod |= 8\n        if bstate & curses.BUTTON_CTRL:\n            mod |= 16\n\n        l = []\n\n        def append_button(b: int) -> None:\n            b |= mod\n            l.extend([27, ord('['), ord('M'), b+32, x+33, y+33])\n\n        if bstate & curses.BUTTON1_PRESSED and last & 1 == 0:\n            append_button( 0 )\n            next |= 1\n        if bstate & curses.BUTTON2_PRESSED and last & 2 == 0:\n            append_button( 1 )\n            next |= 2\n        if bstate & curses.BUTTON3_PRESSED and last & 4 == 0:\n            append_button( 2 )\n            next |= 4\n        if bstate & curses.BUTTON4_PRESSED and last & 8 == 0:\n            append_button( 64 )\n            next |= 8\n        if bstate & curses.BUTTON1_RELEASED and last & 1:\n            append_button( 0 + escape.MOUSE_RELEASE_FLAG )\n            next &= ~ 1\n        if bstate & curses.BUTTON2_RELEASED and last & 2:\n            append_button( 1 + escape.MOUSE_RELEASE_FLAG )\n            next &= ~ 2\n        if bstate & curses.BUTTON3_RELEASED and last & 4:\n            append_button( 2 + escape.MOUSE_RELEASE_FLAG )\n            next &= ~ 4\n        if bstate & curses.BUTTON4_RELEASED and last & 8:\n            append_button( 64 + escape.MOUSE_RELEASE_FLAG )\n            next &= ~ 8\n\n        if bstate & curses.BUTTON1_DOUBLE_CLICKED:\n            append_button( 0 + escape.MOUSE_MULTIPLE_CLICK_FLAG )\n        if bstate & curses.BUTTON2_DOUBLE_CLICKED:\n            append_button( 1 + escape.MOUSE_MULTIPLE_CLICK_FLAG )\n        if bstate & curses.BUTTON3_DOUBLE_CLICKED:\n            append_button( 2 + escape.MOUSE_MULTIPLE_CLICK_FLAG )\n        if bstate & curses.BUTTON4_DOUBLE_CLICKED:\n            append_button( 64 + escape.MOUSE_MULTIPLE_CLICK_FLAG )\n\n        if bstate & curses.BUTTON1_TRIPLE_CLICKED:\n            append_button( 0 + escape.MOUSE_MULTIPLE_CLICK_FLAG*2 )\n        if bstate & curses.BUTTON2_TRIPLE_CLICKED:\n            append_button( 1 + escape.MOUSE_MULTIPLE_CLICK_FLAG*2 )\n        if bstate & curses.BUTTON3_TRIPLE_CLICKED:\n            append_button( 2 + escape.MOUSE_MULTIPLE_CLICK_FLAG*2 )\n        if bstate & curses.BUTTON4_TRIPLE_CLICKED:\n            append_button( 64 + escape.MOUSE_MULTIPLE_CLICK_FLAG*2 )\n\n        self.last_bstate = next\n        return l\n\n    def _dbg_instr(self):  # messy input string (intended for debugging)\n        curses.echo()\n        self.s.nodelay(0)\n        curses.halfdelay(100)\n        str = self.s.getstr()\n        curses.noecho()\n        return str\n\n    def _dbg_out(self, str) -> None:  # messy output function (intended for debugging)\n        self.s.clrtoeol()\n        self.s.addstr(str)\n        self.s.refresh()\n        self._curs_set(1)\n\n    def _dbg_query(self,question):  # messy query (intended for debugging)\n        self._dbg_out(question)\n        return self._dbg_instr()\n\n    def _dbg_refresh(self) -> None:\n        self.s.refresh()\n\n    def get_cols_rows(self) -> tuple[int, int]:\n        \"\"\"Return the terminal dimensions (num columns, num rows).\"\"\"\n        rows,cols = self.s.getmaxyx()\n        return cols, rows\n\n    def _setattr(self, a):\n        if a is None:\n            self.s.attrset(0)\n            return\n        elif not isinstance(a, AttrSpec):\n            p = self._palette.get(a, (AttrSpec('default', 'default'),))\n            a = p[0]\n\n        if self.has_color:\n            if a.foreground_basic:\n                if a.foreground_number >= 8:\n                    fg = a.foreground_number - 8\n                else:\n                    fg = a.foreground_number\n            else:\n                fg = 7\n\n            if a.background_basic:\n                bg = a.background_number\n            else:\n                bg = 0\n\n            attr = curses.color_pair(bg * 8 + 7 - fg)\n        else:\n            attr = 0\n\n        if a.bold:\n            attr |= curses.A_BOLD\n        if a.standout:\n            attr |= curses.A_STANDOUT\n        if a.underline:\n            attr |= curses.A_UNDERLINE\n        if a.blink:\n            attr |= curses.A_BLINK\n\n        self.s.attrset(attr)\n\n    def draw_screen(self, size: tuple[int, int], r):\n        \"\"\"Paint screen with rendered canvas.\"\"\"\n        assert self._started\n\n        cols, rows = size\n\n        assert r.rows() == rows, \"canvas size and passed size don't match\"\n\n        y = -1\n        for row in r.content():\n            y += 1\n            try:\n                self.s.move( y, 0 )\n            except _curses.error:\n                # terminal shrunk?\n                # move failed so stop rendering.\n                return\n\n            first = True\n            lasta = None\n            nr = 0\n            for a, cs, seg in row:\n                if cs != 'U':\n                    seg = seg.translate(UNPRINTABLE_TRANS_TABLE)\n                    assert isinstance(seg, bytes)\n\n                if first or lasta != a:\n                    self._setattr(a)\n                    lasta = a\n                try:\n                    if cs in (\"0\", \"U\"):\n                        for i in range(len(seg)):\n                            self.s.addch(0x400000 + seg[i])\n                    else:\n                        assert cs is None\n                        assert isinstance(seg, bytes)\n                        self.s.addstr(seg.decode('utf-8'))\n                except _curses.error:\n                    # it's ok to get out of the\n                    # screen on the lower right\n                    if (y == rows-1 and nr == len(row)-1):\n                        pass\n                    else:\n                        # perhaps screen size changed\n                        # quietly abort.\n                        return\n                nr += 1\n        if r.cursor is not None:\n            x,y = r.cursor\n            self._curs_set(1)\n            try:\n                self.s.move(y,x)\n            except _curses.error:\n                pass\n        else:\n            self._curs_set(0)\n            self.s.move(0,0)\n\n        self.s.refresh()\n        self.keep_cache_alive_link = r\n\n    def clear(self) -> None:\n        \"\"\"\n        Force the screen to be completely repainted on the next\n        call to draw_screen().\n        \"\"\"\n        self.s.clear()",
  "class _test:\n    def __init__(self):\n        self.ui = Screen()\n        self.l = sorted(_curses_colours)\n\n        for c in self.l:\n            self.ui.register_palette( [\n                (f\"{c} on black\", c, 'black', 'underline'),\n                (f\"{c} on dark blue\",c, 'dark blue', 'bold'),\n                (f\"{c} on light gray\",c,'light gray', 'standout'),\n                ])\n\n        with self.ui.start():\n            self.run()\n\n    def run(self) -> None:\n        class FakeRender: pass\n        r = FakeRender()\n        text = [f\"  has_color = {self.ui.has_color!r}\",\"\"]\n        attr = [[], []]\n        r.coords = {}\n        r.cursor = None\n\n        for c in self.l:\n            t = \"\"\n            a = []\n            for p in f\"{c} on black\", f\"{c} on dark blue\", f\"{c} on light gray\":\n\n                a.append((p, 27))\n                t += (p + 27 * \" \")[:27]\n            text.append( t )\n            attr.append( a )\n\n        text += [\"\",\"return values from get_input(): (q exits)\", \"\"]\n        attr += [[],[],[]]\n        cols,rows = self.ui.get_cols_rows()\n        keys = None\n        while keys != ['q']:\n            r.text = ([t.ljust(cols) for t in text] + [\"\"] * rows)[:rows]\n            r.attr = (attr + [[] for _ in range(rows)])[:rows]\n            self.ui.draw_screen((cols, rows), r)\n            keys, raw = self.ui.get_input( raw_keys = True )\n            if 'window resize' in keys:\n                cols, rows = self.ui.get_cols_rows()\n            if not keys:\n                continue\n            t = \"\"\n            a = []\n            for k in keys:\n                if isinstance(k, str):\n                    k = k.encode(\"utf-8\")\n\n                t += f\"'{k}' \"\n                a += [(None, 1), ('yellow on dark blue', len(k)), (None, 2)]\n\n            text.append(f\"{t}: {raw!r}\")\n            attr.append(a)\n            text = text[-rows:]\n            attr = attr[-rows:]",
  "def __init__(self):\n        super().__init__()\n        self.curses_pairs = [\n            (None,None), # Can't be sure what pair 0 will default to\n        ]\n        self.palette = {}\n        self.has_color = False\n        self.s = None\n        self.cursor_state = None\n        self._keyqueue = []\n        self.prev_input_resize = 0\n        self.set_input_timeouts()\n        self.last_bstate = 0\n        self._mouse_tracking_enabled = False\n\n        self.register_palette_entry(None, 'default','default')",
  "def set_mouse_tracking(self, enable: bool = True) -> None:\n        \"\"\"\n        Enable mouse tracking.\n\n        After calling this function get_input will include mouse\n        click events along with keystrokes.\n        \"\"\"\n        enable = bool(enable)\n        if enable == self._mouse_tracking_enabled:\n            return\n\n        if enable:\n            curses.mousemask(0\n                | curses.BUTTON1_PRESSED | curses.BUTTON1_RELEASED\n                | curses.BUTTON2_PRESSED | curses.BUTTON2_RELEASED\n                | curses.BUTTON3_PRESSED | curses.BUTTON3_RELEASED\n                | curses.BUTTON4_PRESSED | curses.BUTTON4_RELEASED\n                | curses.BUTTON1_DOUBLE_CLICKED | curses.BUTTON1_TRIPLE_CLICKED\n                | curses.BUTTON2_DOUBLE_CLICKED | curses.BUTTON2_TRIPLE_CLICKED\n                | curses.BUTTON3_DOUBLE_CLICKED | curses.BUTTON3_TRIPLE_CLICKED\n                | curses.BUTTON4_DOUBLE_CLICKED | curses.BUTTON4_TRIPLE_CLICKED\n                | curses.BUTTON_SHIFT | curses.BUTTON_ALT\n                | curses.BUTTON_CTRL)\n        else:\n            raise NotImplementedError()\n\n        self._mouse_tracking_enabled = enable",
  "def _start(self) -> None:\n        \"\"\"\n        Initialize the screen and input mode.\n        \"\"\"\n        self.s = curses.initscr()\n        self.has_color = curses.has_colors()\n        if self.has_color:\n            curses.start_color()\n            if curses.COLORS < 8:\n                # not colourful enough\n                self.has_color = False\n        if self.has_color:\n            try:\n                curses.use_default_colors()\n                self.has_default_colors=True\n            except _curses.error:\n                self.has_default_colors=False\n        self._setup_colour_pairs()\n        curses.noecho()\n        curses.meta(1)\n        curses.halfdelay(10) # use set_input_timeouts to adjust\n        self.s.keypad(0)\n\n        if not self._signal_keys_set:\n            self._old_signal_keys = self.tty_signal_keys()\n\n        super()._start()",
  "def _stop(self) -> None:\n        \"\"\"\n        Restore the screen.\n        \"\"\"\n        curses.echo()\n        self._curs_set(1)\n        try:\n            curses.endwin()\n        except _curses.error:\n            pass # don't block original error with curses error\n\n        if self._old_signal_keys:\n            self.tty_signal_keys(*self._old_signal_keys)\n\n        super()._stop()",
  "def _setup_colour_pairs(self) -> None:\n        \"\"\"\n        Initialize all 63 color pairs based on the term:\n        bg * 8 + 7 - fg\n        So to get a color, we just need to use that term and get the right color\n        pair number.\n        \"\"\"\n        if not self.has_color:\n            return\n\n        for fg in range(8):\n            for bg in range(8):\n                # leave out white on black\n                if fg == curses.COLOR_WHITE and \\\n                   bg == curses.COLOR_BLACK:\n                    continue\n\n                curses.init_pair(bg * 8 + 7 - fg, fg, bg)",
  "def _curs_set(self, x):\n        if self.cursor_state == \"fixed\" or x == self.cursor_state:\n            return\n        try:\n            curses.curs_set(x)\n            self.cursor_state = x\n        except _curses.error:\n            self.cursor_state = \"fixed\"",
  "def _clear(self) -> None:\n        self.s.clear()\n        self.s.refresh()",
  "def _getch(self, wait_tenths: int | None) -> int:\n        if wait_tenths == 0:\n            return self._getch_nodelay()\n        if wait_tenths is None:\n            curses.cbreak()\n        else:\n            curses.halfdelay(wait_tenths)\n        self.s.nodelay(0)\n        return self.s.getch()",
  "def _getch_nodelay(self) -> int:\n        self.s.nodelay(1)\n        while 1:\n            # this call fails sometimes, but seems to work when I try again\n            try:\n                curses.cbreak()\n                break\n            except _curses.error:\n                pass\n\n        return self.s.getch()",
  "def set_input_timeouts(\n        self,\n        max_wait: int | float | None = None,\n        complete_wait: int | float = 0.1,\n        resize_wait: int | float = 0.1,\n    ):\n        \"\"\"\n        Set the get_input timeout values.  All values have a granularity\n        of 0.1s, ie. any value between 0.15 and 0.05 will be treated as\n        0.1 and any value less than 0.05 will be treated as 0.  The\n        maximum timeout value for this module is 25.5 seconds.\n\n        max_wait -- amount of time in seconds to wait for input when\n            there is no input pending, wait forever if None\n        complete_wait -- amount of time in seconds to wait when\n            get_input detects an incomplete escape sequence at the\n            end of the available input\n        resize_wait -- amount of time in seconds to wait for more input\n            after receiving two screen resize requests in a row to\n            stop urwid from consuming 100% cpu during a gradual\n            window resize operation\n        \"\"\"\n\n        def convert_to_tenths( s ):\n            if s is None:\n                return None\n            return int( (s+0.05)*10 )\n\n        self.max_tenths = convert_to_tenths(max_wait)\n        self.complete_tenths = convert_to_tenths(complete_wait)\n        self.resize_tenths = convert_to_tenths(resize_wait)",
  "def get_input(self, raw_keys: Literal[False]) -> list[str]:\n        ...",
  "def get_input(self, raw_keys: Literal[True]) -> tuple[list[str], list[int]]:\n        ...",
  "def get_input(self, raw_keys: bool = False) -> list[str] | tuple[list[str], list[int]]:\n        \"\"\"Return pending input as a list.\n\n        raw_keys -- return raw keycodes as well as translated versions\n\n        This function will immediately return all the input since the\n        last time it was called.  If there is no input pending it will\n        wait before returning an empty list.  The wait time may be\n        configured with the set_input_timeouts function.\n\n        If raw_keys is False (default) this function will return a list\n        of keys pressed.  If raw_keys is True this function will return\n        a ( keys pressed, raw keycodes ) tuple instead.\n\n        Examples of keys returned:\n\n        * ASCII printable characters:  \" \", \"a\", \"0\", \"A\", \"-\", \"/\"\n        * ASCII control characters:  \"tab\", \"enter\"\n        * Escape sequences:  \"up\", \"page up\", \"home\", \"insert\", \"f1\"\n        * Key combinations:  \"shift f1\", \"meta a\", \"ctrl b\"\n        * Window events:  \"window resize\"\n\n        When a narrow encoding is not enabled:\n\n        * \"Extended ASCII\" characters:  \"\\\\xa1\", \"\\\\xb2\", \"\\\\xfe\"\n\n        When a wide encoding is enabled:\n\n        * Double-byte characters:  \"\\\\xa1\\\\xea\", \"\\\\xb2\\\\xd4\"\n\n        When utf8 encoding is enabled:\n\n        * Unicode characters: u\"\\\\u00a5\", u'\\\\u253c\"\n\n        Examples of mouse events returned:\n\n        * Mouse button press: ('mouse press', 1, 15, 13),\n                            ('meta mouse press', 2, 17, 23)\n        * Mouse button release: ('mouse release', 0, 18, 13),\n                              ('ctrl mouse release', 0, 17, 23)\n        \"\"\"\n        assert self._started\n\n        keys, raw = self._get_input(self.max_tenths)\n\n        # Avoid pegging CPU at 100% when slowly resizing, and work\n        # around a bug with some braindead curses implementations that\n        # return \"no key\" between \"window resize\" commands\n        if keys == ['window resize'] and self.prev_input_resize:\n            while True:\n                keys, raw2 = self._get_input(self.resize_tenths)\n                raw += raw2\n                if not keys:\n                    keys, raw2 = self._get_input(self.resize_tenths)\n                    raw += raw2\n                if keys != ['window resize']:\n                    break\n            if keys[-1:] != ['window resize']:\n                keys.append('window resize')\n\n        if keys == ['window resize']:\n            self.prev_input_resize = 2\n        elif self.prev_input_resize == 2 and not keys:\n            self.prev_input_resize = 1\n        else:\n            self.prev_input_resize = 0\n\n        if raw_keys:\n            return keys, raw\n        return keys",
  "def _get_input(self, wait_tenths: int | None) -> tuple[list[str], list[int]]:\n        # this works around a strange curses bug with window resizing\n        # not being reported correctly with repeated calls to this\n        # function without a doupdate call in between\n        curses.doupdate()\n\n        key = self._getch(wait_tenths)\n        resize = False\n        raw = []\n        keys = []\n\n        while key >= 0:\n            raw.append(key)\n            if key == KEY_RESIZE:\n                resize = True\n            elif key == KEY_MOUSE:\n                keys += self._encode_mouse_event()\n            else:\n                keys.append(key)\n            key = self._getch_nodelay()\n\n        processed = []\n\n        try:\n            while keys:\n                run, keys = escape.process_keyqueue(keys, True)\n                processed += run\n        except escape.MoreInputRequired:\n            key = self._getch(self.complete_tenths)\n            while key >= 0:\n                raw.append(key)\n                if key == KEY_RESIZE:\n                    resize = True\n                elif key == KEY_MOUSE:\n                    keys += self._encode_mouse_event()\n                else:\n                    keys.append(key)\n                key = self._getch_nodelay()\n            while keys:\n                run, keys = escape.process_keyqueue(keys, False)\n                processed += run\n\n        if resize:\n            processed.append('window resize')\n\n        return processed, raw",
  "def _encode_mouse_event(self) -> list[int]:\n        # convert to escape sequence\n        last = next = self.last_bstate\n        (id, x, y, z, bstate) = curses.getmouse()\n\n        mod = 0\n        if bstate & curses.BUTTON_SHIFT:\n            mod |= 4\n        if bstate & curses.BUTTON_ALT:\n            mod |= 8\n        if bstate & curses.BUTTON_CTRL:\n            mod |= 16\n\n        l = []\n\n        def append_button(b: int) -> None:\n            b |= mod\n            l.extend([27, ord('['), ord('M'), b+32, x+33, y+33])\n\n        if bstate & curses.BUTTON1_PRESSED and last & 1 == 0:\n            append_button( 0 )\n            next |= 1\n        if bstate & curses.BUTTON2_PRESSED and last & 2 == 0:\n            append_button( 1 )\n            next |= 2\n        if bstate & curses.BUTTON3_PRESSED and last & 4 == 0:\n            append_button( 2 )\n            next |= 4\n        if bstate & curses.BUTTON4_PRESSED and last & 8 == 0:\n            append_button( 64 )\n            next |= 8\n        if bstate & curses.BUTTON1_RELEASED and last & 1:\n            append_button( 0 + escape.MOUSE_RELEASE_FLAG )\n            next &= ~ 1\n        if bstate & curses.BUTTON2_RELEASED and last & 2:\n            append_button( 1 + escape.MOUSE_RELEASE_FLAG )\n            next &= ~ 2\n        if bstate & curses.BUTTON3_RELEASED and last & 4:\n            append_button( 2 + escape.MOUSE_RELEASE_FLAG )\n            next &= ~ 4\n        if bstate & curses.BUTTON4_RELEASED and last & 8:\n            append_button( 64 + escape.MOUSE_RELEASE_FLAG )\n            next &= ~ 8\n\n        if bstate & curses.BUTTON1_DOUBLE_CLICKED:\n            append_button( 0 + escape.MOUSE_MULTIPLE_CLICK_FLAG )\n        if bstate & curses.BUTTON2_DOUBLE_CLICKED:\n            append_button( 1 + escape.MOUSE_MULTIPLE_CLICK_FLAG )\n        if bstate & curses.BUTTON3_DOUBLE_CLICKED:\n            append_button( 2 + escape.MOUSE_MULTIPLE_CLICK_FLAG )\n        if bstate & curses.BUTTON4_DOUBLE_CLICKED:\n            append_button( 64 + escape.MOUSE_MULTIPLE_CLICK_FLAG )\n\n        if bstate & curses.BUTTON1_TRIPLE_CLICKED:\n            append_button( 0 + escape.MOUSE_MULTIPLE_CLICK_FLAG*2 )\n        if bstate & curses.BUTTON2_TRIPLE_CLICKED:\n            append_button( 1 + escape.MOUSE_MULTIPLE_CLICK_FLAG*2 )\n        if bstate & curses.BUTTON3_TRIPLE_CLICKED:\n            append_button( 2 + escape.MOUSE_MULTIPLE_CLICK_FLAG*2 )\n        if bstate & curses.BUTTON4_TRIPLE_CLICKED:\n            append_button( 64 + escape.MOUSE_MULTIPLE_CLICK_FLAG*2 )\n\n        self.last_bstate = next\n        return l",
  "def _dbg_instr(self):  # messy input string (intended for debugging)\n        curses.echo()\n        self.s.nodelay(0)\n        curses.halfdelay(100)\n        str = self.s.getstr()\n        curses.noecho()\n        return str",
  "def _dbg_out(self, str) -> None:  # messy output function (intended for debugging)\n        self.s.clrtoeol()\n        self.s.addstr(str)\n        self.s.refresh()\n        self._curs_set(1)",
  "def _dbg_query(self,question):  # messy query (intended for debugging)\n        self._dbg_out(question)\n        return self._dbg_instr()",
  "def _dbg_refresh(self) -> None:\n        self.s.refresh()",
  "def get_cols_rows(self) -> tuple[int, int]:\n        \"\"\"Return the terminal dimensions (num columns, num rows).\"\"\"\n        rows,cols = self.s.getmaxyx()\n        return cols, rows",
  "def _setattr(self, a):\n        if a is None:\n            self.s.attrset(0)\n            return\n        elif not isinstance(a, AttrSpec):\n            p = self._palette.get(a, (AttrSpec('default', 'default'),))\n            a = p[0]\n\n        if self.has_color:\n            if a.foreground_basic:\n                if a.foreground_number >= 8:\n                    fg = a.foreground_number - 8\n                else:\n                    fg = a.foreground_number\n            else:\n                fg = 7\n\n            if a.background_basic:\n                bg = a.background_number\n            else:\n                bg = 0\n\n            attr = curses.color_pair(bg * 8 + 7 - fg)\n        else:\n            attr = 0\n\n        if a.bold:\n            attr |= curses.A_BOLD\n        if a.standout:\n            attr |= curses.A_STANDOUT\n        if a.underline:\n            attr |= curses.A_UNDERLINE\n        if a.blink:\n            attr |= curses.A_BLINK\n\n        self.s.attrset(attr)",
  "def draw_screen(self, size: tuple[int, int], r):\n        \"\"\"Paint screen with rendered canvas.\"\"\"\n        assert self._started\n\n        cols, rows = size\n\n        assert r.rows() == rows, \"canvas size and passed size don't match\"\n\n        y = -1\n        for row in r.content():\n            y += 1\n            try:\n                self.s.move( y, 0 )\n            except _curses.error:\n                # terminal shrunk?\n                # move failed so stop rendering.\n                return\n\n            first = True\n            lasta = None\n            nr = 0\n            for a, cs, seg in row:\n                if cs != 'U':\n                    seg = seg.translate(UNPRINTABLE_TRANS_TABLE)\n                    assert isinstance(seg, bytes)\n\n                if first or lasta != a:\n                    self._setattr(a)\n                    lasta = a\n                try:\n                    if cs in (\"0\", \"U\"):\n                        for i in range(len(seg)):\n                            self.s.addch(0x400000 + seg[i])\n                    else:\n                        assert cs is None\n                        assert isinstance(seg, bytes)\n                        self.s.addstr(seg.decode('utf-8'))\n                except _curses.error:\n                    # it's ok to get out of the\n                    # screen on the lower right\n                    if (y == rows-1 and nr == len(row)-1):\n                        pass\n                    else:\n                        # perhaps screen size changed\n                        # quietly abort.\n                        return\n                nr += 1\n        if r.cursor is not None:\n            x,y = r.cursor\n            self._curs_set(1)\n            try:\n                self.s.move(y,x)\n            except _curses.error:\n                pass\n        else:\n            self._curs_set(0)\n            self.s.move(0,0)\n\n        self.s.refresh()\n        self.keep_cache_alive_link = r",
  "def clear(self) -> None:\n        \"\"\"\n        Force the screen to be completely repainted on the next\n        call to draw_screen().\n        \"\"\"\n        self.s.clear()",
  "def __init__(self):\n        self.ui = Screen()\n        self.l = sorted(_curses_colours)\n\n        for c in self.l:\n            self.ui.register_palette( [\n                (f\"{c} on black\", c, 'black', 'underline'),\n                (f\"{c} on dark blue\",c, 'dark blue', 'bold'),\n                (f\"{c} on light gray\",c,'light gray', 'standout'),\n                ])\n\n        with self.ui.start():\n            self.run()",
  "def run(self) -> None:\n        class FakeRender: pass\n        r = FakeRender()\n        text = [f\"  has_color = {self.ui.has_color!r}\",\"\"]\n        attr = [[], []]\n        r.coords = {}\n        r.cursor = None\n\n        for c in self.l:\n            t = \"\"\n            a = []\n            for p in f\"{c} on black\", f\"{c} on dark blue\", f\"{c} on light gray\":\n\n                a.append((p, 27))\n                t += (p + 27 * \" \")[:27]\n            text.append( t )\n            attr.append( a )\n\n        text += [\"\",\"return values from get_input(): (q exits)\", \"\"]\n        attr += [[],[],[]]\n        cols,rows = self.ui.get_cols_rows()\n        keys = None\n        while keys != ['q']:\n            r.text = ([t.ljust(cols) for t in text] + [\"\"] * rows)[:rows]\n            r.attr = (attr + [[] for _ in range(rows)])[:rows]\n            self.ui.draw_screen((cols, rows), r)\n            keys, raw = self.ui.get_input( raw_keys = True )\n            if 'window resize' in keys:\n                cols, rows = self.ui.get_cols_rows()\n            if not keys:\n                continue\n            t = \"\"\n            a = []\n            for k in keys:\n                if isinstance(k, str):\n                    k = k.encode(\"utf-8\")\n\n                t += f\"'{k}' \"\n                a += [(None, 1), ('yellow on dark blue', len(k)), (None, 2)]\n\n            text.append(f\"{t}: {raw!r}\")\n            attr.append(a)\n            text = text[-rows:]\n            attr = attr[-rows:]",
  "def convert_to_tenths( s ):\n            if s is None:\n                return None\n            return int( (s+0.05)*10 )",
  "def append_button(b: int) -> None:\n            b |= mod\n            l.extend([27, ord('['), ord('M'), b+32, x+33, y+33])",
  "class FakeRender: pass",
  "class BarGraphMeta(WidgetMeta):\n    \"\"\"\n    Detect subclass get_data() method and dynamic change to\n    get_data() method and disable caching in these cases.\n\n    This is for backwards compatibility only, new programs\n    should use set_data() instead of overriding get_data().\n    \"\"\"\n\n    def __init__(cls, name, bases, d):\n        super().__init__(name, bases, d)\n\n        if \"get_data\" in d:\n            cls.render = nocache_widget_render(cls)\n            cls._get_data = cls.get_data\n        cls.get_data = property(lambda self: self._get_data, nocache_bargraph_get_data)",
  "def nocache_bargraph_get_data(self, get_data_fn):\n    \"\"\"\n    Disable caching on this bargraph because get_data_fn needs\n    to be polled to get the latest data.\n    \"\"\"\n    self.render = nocache_widget_render_instance(self)\n    self._get_data = get_data_fn",
  "class BarGraphError(Exception):\n    pass",
  "class BarGraph(Widget, metaclass=BarGraphMeta):\n    _sizing = frozenset([Sizing.BOX])\n\n    ignore_focus = True\n\n    eighths = \" \u2581\u2582\u2583\u2584\u2585\u2586\u2587\"\n    hlines = \"_\u23ba\u23bb\u2500\u23bc\u23bd\"\n\n    def __init__(self, attlist, hatt=None, satt=None):\n        \"\"\"\n        Create a bar graph with the passed display characteristics.\n        see set_segment_attributes for a description of the parameters.\n        \"\"\"\n\n        self.set_segment_attributes(attlist, hatt, satt)\n        self.set_data([], 1, None)\n        self.set_bar_width(None)\n\n    def set_segment_attributes(self, attlist, hatt=None, satt=None):\n        \"\"\"\n        :param attlist: list containing display attribute or\n                        (display attribute, character) tuple for background,\n                        first segment, and optionally following segments.\n                        ie. len(attlist) == num segments+1\n                        character defaults to ' ' if not specified.\n        :param hatt: list containing attributes for horizontal lines. First\n                     element is for lines on background, second is for lines\n                     on first segment, third is for lines on second segment\n                     etc.\n        :param satt: dictionary containing attributes for smoothed\n                     transitions of bars in UTF-8 display mode. The values\n                     are in the form:\n\n                       (fg,bg) : attr\n\n                     fg and bg are integers where 0 is the graph background,\n                     1 is the first segment, 2 is the second, ...\n                     fg > bg in all values.  attr is an attribute with a\n                     foreground corresponding to fg and a background\n                     corresponding to bg.\n\n        If satt is not None and the bar graph is being displayed in\n        a terminal using the UTF-8 encoding then the character cell\n        that is shared between the segments specified will be smoothed\n        with using the UTF-8 vertical eighth characters.\n\n        eg: set_segment_attributes( ['no', ('unsure',\"?\"), 'yes'] )\n        will use the attribute 'no' for the background (the area from\n        the top of the graph to the top of the bar), question marks\n        with the attribute 'unsure' will be used for the topmost\n        segment of the bar, and the attribute 'yes' will be used for\n        the bottom segment of the bar.\n        \"\"\"\n        self.attr = []\n        self.char = []\n        if len(attlist) < 2:\n            raise BarGraphError(f\"attlist must include at least background and seg1: {attlist!r}\")\n        if len(attlist) < 2:\n            raise BarGraphError(\"must at least specify bg and fg!\")\n        for a in attlist:\n            if not isinstance(a, tuple):\n                self.attr.append(a)\n                self.char.append(\" \")\n            else:\n                attr, ch = a\n                self.attr.append(attr)\n                self.char.append(ch)\n\n        self.hatt = []\n        if hatt is None:\n            hatt = [self.attr[0]]\n        elif not isinstance(hatt, list):\n            hatt = [hatt]\n        self.hatt = hatt\n\n        if satt is None:\n            satt = {}\n        for i in satt.items():\n            try:\n                (fg, bg), attr = i\n            except ValueError as exc:\n                raise BarGraphError(f\"satt not in (fg,bg:attr) form: {i!r}\").with_traceback(exc.__traceback__) from exc\n            if not isinstance(fg, int) or fg >= len(attlist):\n                raise BarGraphError(f\"fg not valid integer: {fg!r}\")\n            if not isinstance(bg, int) or bg >= len(attlist):\n                raise BarGraphError(f\"bg not valid integer: {fg!r}\")\n            if fg <= bg:\n                raise BarGraphError(f\"fg ({fg}) not > bg ({bg})\")\n        self.satt = satt\n\n    def set_data(self, bardata, top, hlines=None):\n        \"\"\"\n        Store bar data, bargraph top and horizontal line positions.\n\n        bardata -- a list of bar values.\n        top -- maximum value for segments within bardata\n        hlines -- None or a bar value marking horizontal line positions\n\n        bar values are [ segment1, segment2, ... ] lists where top is\n        the maximal value corresponding to the top of the bar graph and\n        segment1, segment2, ... are the values for the top of each\n        segment of this bar.  Simple bar graphs will only have one\n        segment in each bar value.\n\n        Eg: if top is 100 and there is a bar value of [ 80, 30 ] then\n        the top of this bar will be at 80% of full height of the graph\n        and it will have a second segment that starts at 30%.\n        \"\"\"\n        if hlines is not None:\n            hlines = sorted(hlines[:], reverse=True)  # shallow copy\n\n        self.data = bardata, top, hlines\n        self._invalidate()\n\n    def _get_data(self, size: tuple[int, int]):\n        \"\"\"\n        Return (bardata, top, hlines)\n\n        This function is called by render to retrieve the data for\n        the graph. It may be overloaded to create a dynamic bar graph.\n\n        This implementation will truncate the bardata list returned\n        if not all bars will fit within maxcol.\n        \"\"\"\n        (maxcol, maxrow) = size\n        bardata, top, hlines = self.data\n        widths = self.calculate_bar_widths((maxcol, maxrow), bardata)\n\n        if len(bardata) > len(widths):\n            return bardata[: len(widths)], top, hlines\n\n        return bardata, top, hlines\n\n    def set_bar_width(self, width: int | None):\n        \"\"\"\n        Set a preferred bar width for calculate_bar_widths to use.\n\n        width -- width of bar or None for automatic width adjustment\n        \"\"\"\n        if width is not None and width <= 0:\n            raise ValueError(width)\n        self.bar_width = width\n        self._invalidate()\n\n    def calculate_bar_widths(self, size: tuple[int, int], bardata):\n        \"\"\"\n        Return a list of bar widths, one for each bar in data.\n\n        If self.bar_width is None this implementation will stretch\n        the bars across the available space specified by maxcol.\n        \"\"\"\n        (maxcol, maxrow) = size\n\n        if self.bar_width is not None:\n            return [self.bar_width] * min(len(bardata), maxcol // self.bar_width)\n\n        if len(bardata) >= maxcol:\n            return [1] * maxcol\n\n        widths = []\n        grow = maxcol\n        remain = len(bardata)\n        for _row in bardata:\n            w = int(float(grow) / remain + 0.5)\n            widths.append(w)\n            grow -= w\n            remain -= 1\n        return widths\n\n    def selectable(self) -> Literal[False]:\n        \"\"\"\n        Return False.\n        \"\"\"\n        return False\n\n    def use_smoothed(self) -> bool:\n        return self.satt and get_encoding_mode() == \"utf8\"\n\n    def calculate_display(self, size: tuple[int, int]):\n        \"\"\"\n        Calculate display data.\n        \"\"\"\n        (maxcol, maxrow) = size\n        bardata, top, hlines = self.get_data((maxcol, maxrow))\n        widths = self.calculate_bar_widths((maxcol, maxrow), bardata)\n\n        if self.use_smoothed():\n            disp = calculate_bargraph_display(bardata, top, widths, maxrow * 8)\n            disp = self.smooth_display(disp)\n\n        else:\n            disp = calculate_bargraph_display(bardata, top, widths, maxrow)\n\n        if hlines:\n            disp = self.hlines_display(disp, top, hlines, maxrow)\n\n        return disp\n\n    def hlines_display(self, disp, top: int, hlines, maxrow: int):\n        \"\"\"\n        Add hlines to display structure represented as bar_type tuple\n        values:\n        (bg, 0-5)\n        bg is the segment that has the hline on it\n        0-5 is the hline graphic to use where 0 is a regular underscore\n        and 1-5 are the UTF-8 horizontal scan line characters.\n        \"\"\"\n        if self.use_smoothed():\n            shiftr = 0\n            r = [\n                (0.2, 1),\n                (0.4, 2),\n                (0.6, 3),\n                (0.8, 4),\n                (1.0, 5),\n            ]\n        else:\n            shiftr = 0.5\n            r = [\n                (1.0, 0),\n            ]\n\n        # reverse the hlines to match screen ordering\n        rhl = []\n        for h in hlines:\n            rh = float(top - h) * maxrow / top - shiftr\n            if rh < 0:\n                continue\n            rhl.append(rh)\n\n        # build a list of rows that will have hlines\n        hrows = []\n        last_i = -1\n        for rh in rhl:\n            i = int(rh)\n            if i == last_i:\n                continue\n            f = rh - i\n            for spl, chnum in r:\n                if f < spl:\n                    hrows.append((i, chnum))\n                    break\n            last_i = i\n\n        # fill hlines into disp data\n        def fill_row(row, chnum):\n            rout = []\n            for bar_type, width in row:\n                if isinstance(bar_type, int) and len(self.hatt) > bar_type:\n                    rout.append(((bar_type, chnum), width))\n                    continue\n                rout.append((bar_type, width))\n            return rout\n\n        o = []\n        k = 0\n        rnum = 0\n        for y_count, row in disp:\n            if k >= len(hrows):\n                o.append((y_count, row))\n                continue\n            end_block = rnum + y_count\n            while k < len(hrows) and hrows[k][0] < end_block:\n                i, chnum = hrows[k]\n                if i - rnum > 0:\n                    o.append((i - rnum, row))\n                o.append((1, fill_row(row, chnum)))\n                rnum = i + 1\n                k += 1\n            if rnum < end_block:\n                o.append((end_block - rnum, row))\n                rnum = end_block\n\n        # assert 0, o\n        return o\n\n    def smooth_display(self, disp):\n        \"\"\"\n        smooth (col, row*8) display into (col, row) display using\n        UTF vertical eighth characters represented as bar_type\n        tuple values:\n        ( fg, bg, 1-7 )\n        where fg is the lower segment, bg is the upper segment and\n        1-7 is the vertical eighth character to use.\n        \"\"\"\n        o = []\n        r = 0  # row remainder\n\n        def seg_combine(a, b):\n            (bt1, w1), (bt2, w2) = a, b\n            if (bt1, w1) == (bt2, w2):\n                return (bt1, w1), None, None\n            wmin = min(w1, w2)\n            l1 = l2 = None\n            if w1 > w2:\n                l1 = (bt1, w1 - w2)\n            elif w2 > w1:\n                l2 = (bt2, w2 - w1)\n            if isinstance(bt1, tuple):\n                return (bt1, wmin), l1, l2\n            if (bt2, bt1) not in self.satt:\n                if r < 4:\n                    return (bt2, wmin), l1, l2\n                return (bt1, wmin), l1, l2\n            return ((bt2, bt1, 8 - r), wmin), l1, l2\n\n        def row_combine_last(count: int, row):\n            o_count, o_row = o[-1]\n            row = row[:]  # shallow copy, so we don't destroy orig.\n            o_row = o_row[:]\n            widget_list = []\n            while row:\n                (bt, w), l1, l2 = seg_combine(o_row.pop(0), row.pop(0))\n                if widget_list and widget_list[-1][0] == bt:\n                    widget_list[-1] = (bt, widget_list[-1][1] + w)\n                else:\n                    widget_list.append((bt, w))\n                if l1:\n                    o_row = [l1, *o_row]\n                if l2:\n                    row = [l2, *row]\n\n            if o_row:\n                raise BarGraphError(o_row)\n\n            o[-1] = (o_count + count, widget_list)\n\n        # regroup into actual rows (8 disp rows == 1 actual row)\n        for y_count, row in disp:\n            if r:\n                count = min(8 - r, y_count)\n                row_combine_last(count, row)\n                y_count -= count  # noqa: PLW2901\n                r += count\n                r = r % 8\n                if not y_count:\n                    continue\n            if r != 0:\n                raise BarGraphError\n            # copy whole blocks\n            if y_count > 7:\n                o.append((y_count // 8 * 8, row))\n                y_count %= 8  # noqa: PLW2901\n                if not y_count:\n                    continue\n            o.append((y_count, row))\n            r = y_count\n        return [(y // 8, row) for (y, row) in o]\n\n    def render(self, size: tuple[int, int], focus: bool = False) -> CompositeCanvas:\n        \"\"\"\n        Render BarGraph.\n        \"\"\"\n        (maxcol, maxrow) = size\n        disp = self.calculate_display((maxcol, maxrow))\n\n        combinelist = []\n        for y_count, row in disp:\n            widget_list = []\n            for bar_type, width in row:\n                if isinstance(bar_type, tuple):\n                    if len(bar_type) == 3:\n                        # vertical eighths\n                        fg, bg, k = bar_type\n                        a = self.satt[(fg, bg)]\n                        t = self.eighths[k] * width\n                    else:\n                        # horizontal lines\n                        bg, k = bar_type\n                        a = self.hatt[bg]\n                        t = self.hlines[k] * width\n                else:\n                    a = self.attr[bar_type]\n                    t = self.char[bar_type] * width\n                widget_list.append((a, t))\n            c = Text(widget_list).render((maxcol,))\n            if c.rows() != 1:\n                raise BarGraphError(\"Invalid characters in BarGraph!\")\n            combinelist += [(c, None, False)] * y_count\n\n        canv = CanvasCombine(combinelist)\n        return canv",
  "def calculate_bargraph_display(bardata, top, bar_widths, maxrow: int):\n    \"\"\"\n    Calculate a rendering of the bar graph described by data, bar_widths\n    and height.\n\n    bardata -- bar information with same structure as BarGraph.data\n    top -- maximal value for bardata segments\n    bar_widths -- list of integer column widths for each bar\n    maxrow -- rows for display of bargraph\n\n    Returns a structure as follows:\n      [ ( y_count, [ ( bar_type, width), ... ] ), ... ]\n\n    The outer tuples represent a set of identical rows. y_count is\n    the number of rows in this set, the list contains the data to be\n    displayed in the row repeated through the set.\n\n    The inner tuple describes a run of width characters of bar_type.\n    bar_type is an integer starting from 0 for the background, 1 for\n    the 1st segment, 2 for the 2nd segment etc..\n\n    This function should complete in approximately O(n+m) time, where\n    n is the number of bars displayed and m is the number of rows.\n    \"\"\"\n\n    if len(bardata) != len(bar_widths):\n        raise BarGraphError\n\n    maxcol = sum(bar_widths)\n\n    # build intermediate data structure\n    rows = [None] * maxrow\n\n    def add_segment(seg_num: int, col: int, row: int, width: int, rows=rows) -> None:\n        if rows[row]:\n            last_seg, last_col, last_end = rows[row][-1]\n            if last_end > col:\n                if last_col >= col:\n                    del rows[row][-1]\n                else:\n                    rows[row][-1] = (last_seg, last_col, col)\n            elif last_seg == seg_num and last_end == col:\n                rows[row][-1] = (last_seg, last_col, last_end + width)\n                return\n        elif rows[row] is None:\n            rows[row] = []\n        rows[row].append((seg_num, col, col + width))\n\n    col = 0\n    barnum = 0\n    for bar in bardata:\n        width = bar_widths[barnum]\n        if width < 1:\n            continue\n        # loop through in reverse order\n        tallest = maxrow\n        segments = scale_bar_values(bar, top, maxrow)\n        for k in range(len(bar) - 1, -1, -1):\n            s = segments[k]\n\n            if s >= maxrow:\n                continue\n            if s < 0:\n                s = 0\n            if s < tallest:\n                # add only properly-overlapped bars\n                tallest = s\n                add_segment(k + 1, col, s, width)\n        col += width\n        barnum += 1\n\n    # print(repr(rows))\n    # build rowsets data structure\n    rowsets = []\n    y_count = 0\n    last = [(0, maxcol)]\n\n    for r in rows:\n        if r is None:\n            y_count = y_count + 1\n            continue\n        if y_count:\n            rowsets.append((y_count, last))\n            y_count = 0\n\n        i = 0  # index into \"last\"\n        la, ln = last[i]  # last attribute, last run length\n        c = 0  # current column\n        o = []  # output list to be added to rowsets\n        for seg_num, start, end in r:\n            while start > c + ln:\n                o.append((la, ln))\n                i += 1\n                c += ln\n                la, ln = last[i]\n\n            if la == seg_num:\n                # same attribute, can combine\n                o.append((la, end - c))\n            else:\n                if start - c > 0:\n                    o.append((la, start - c))\n                o.append((seg_num, end - start))\n\n            if end == maxcol:\n                i = len(last)\n                break\n\n            # skip past old segments covered by new one\n            while end >= c + ln:\n                i += 1\n                c += ln\n                la, ln = last[i]\n\n            if la != seg_num:\n                ln = c + ln - end\n                c = end\n                continue\n\n            # same attribute, can extend\n            oa, on = o[-1]\n            on += c + ln - end\n            o[-1] = oa, on\n\n            i += 1\n            c += ln\n            if c == maxcol:\n                break\n            if i >= len(last):\n                raise ValueError(repr((on, maxcol)))\n            la, ln = last[i]\n\n        if i < len(last):\n            o += [(la, ln)] + last[i + 1 :]\n        last = o\n        y_count += 1\n\n    if y_count:\n        rowsets.append((y_count, last))\n\n    return rowsets",
  "class GraphVScale(Widget):\n    _sizing = frozenset([Sizing.BOX])\n\n    def __init__(self, labels, top):\n        \"\"\"\n        GraphVScale( [(label1 position, label1 markup),...], top )\n        label position -- 0 < position < top for the y position\n        label markup -- text markup for this label\n        top -- top y position\n\n        This widget is a vertical scale for the BarGraph widget that\n        can correspond to the BarGraph's horizontal lines\n        \"\"\"\n        self.set_scale(labels, top)\n\n    def set_scale(self, labels, top):\n        \"\"\"\n        set_scale( [(label1 position, label1 markup),...], top )\n        label position -- 0 < position < top for the y position\n        label markup -- text markup for this label\n        top -- top y position\n        \"\"\"\n\n        labels = sorted(labels[:], reverse=True)  # shallow copy\n\n        self.pos = []\n        self.txt = []\n        for y, markup in labels:\n            self.pos.append(y)\n            self.txt.append(Text(markup))\n        self.top = top\n\n    def selectable(self) -> Literal[False]:\n        \"\"\"\n        Return False.\n        \"\"\"\n        return False\n\n    def render(self, size: tuple[int, int], focus: bool = False):\n        \"\"\"\n        Render GraphVScale.\n        \"\"\"\n        (maxcol, maxrow) = size\n        pl = scale_bar_values(self.pos, self.top, maxrow)\n\n        combinelist = []\n        rows = 0\n        for p, t in zip(pl, self.txt):\n            p -= 1  # noqa: PLW2901\n            if p >= maxrow:\n                break\n            if p < rows:\n                continue\n            c = t.render((maxcol,))\n            if p > rows:\n                run = p - rows\n                c = CompositeCanvas(c)\n                c.pad_trim_top_bottom(run, 0)\n            rows += c.rows()\n            combinelist.append((c, None, False))\n        if not combinelist:\n            return SolidCanvas(\" \", size[0], size[1])\n\n        c = CanvasCombine(combinelist)\n        if maxrow - rows:\n            c.pad_trim_top_bottom(0, maxrow - rows)\n        return c",
  "def scale_bar_values(bar, top, maxrow: int):\n    \"\"\"\n    Return a list of bar values aliased to integer values of maxrow.\n    \"\"\"\n    return [maxrow - int(float(v) * maxrow / top + 0.5) for v in bar]",
  "def __init__(cls, name, bases, d):\n        super().__init__(name, bases, d)\n\n        if \"get_data\" in d:\n            cls.render = nocache_widget_render(cls)\n            cls._get_data = cls.get_data\n        cls.get_data = property(lambda self: self._get_data, nocache_bargraph_get_data)",
  "def __init__(self, attlist, hatt=None, satt=None):\n        \"\"\"\n        Create a bar graph with the passed display characteristics.\n        see set_segment_attributes for a description of the parameters.\n        \"\"\"\n\n        self.set_segment_attributes(attlist, hatt, satt)\n        self.set_data([], 1, None)\n        self.set_bar_width(None)",
  "def set_segment_attributes(self, attlist, hatt=None, satt=None):\n        \"\"\"\n        :param attlist: list containing display attribute or\n                        (display attribute, character) tuple for background,\n                        first segment, and optionally following segments.\n                        ie. len(attlist) == num segments+1\n                        character defaults to ' ' if not specified.\n        :param hatt: list containing attributes for horizontal lines. First\n                     element is for lines on background, second is for lines\n                     on first segment, third is for lines on second segment\n                     etc.\n        :param satt: dictionary containing attributes for smoothed\n                     transitions of bars in UTF-8 display mode. The values\n                     are in the form:\n\n                       (fg,bg) : attr\n\n                     fg and bg are integers where 0 is the graph background,\n                     1 is the first segment, 2 is the second, ...\n                     fg > bg in all values.  attr is an attribute with a\n                     foreground corresponding to fg and a background\n                     corresponding to bg.\n\n        If satt is not None and the bar graph is being displayed in\n        a terminal using the UTF-8 encoding then the character cell\n        that is shared between the segments specified will be smoothed\n        with using the UTF-8 vertical eighth characters.\n\n        eg: set_segment_attributes( ['no', ('unsure',\"?\"), 'yes'] )\n        will use the attribute 'no' for the background (the area from\n        the top of the graph to the top of the bar), question marks\n        with the attribute 'unsure' will be used for the topmost\n        segment of the bar, and the attribute 'yes' will be used for\n        the bottom segment of the bar.\n        \"\"\"\n        self.attr = []\n        self.char = []\n        if len(attlist) < 2:\n            raise BarGraphError(f\"attlist must include at least background and seg1: {attlist!r}\")\n        if len(attlist) < 2:\n            raise BarGraphError(\"must at least specify bg and fg!\")\n        for a in attlist:\n            if not isinstance(a, tuple):\n                self.attr.append(a)\n                self.char.append(\" \")\n            else:\n                attr, ch = a\n                self.attr.append(attr)\n                self.char.append(ch)\n\n        self.hatt = []\n        if hatt is None:\n            hatt = [self.attr[0]]\n        elif not isinstance(hatt, list):\n            hatt = [hatt]\n        self.hatt = hatt\n\n        if satt is None:\n            satt = {}\n        for i in satt.items():\n            try:\n                (fg, bg), attr = i\n            except ValueError as exc:\n                raise BarGraphError(f\"satt not in (fg,bg:attr) form: {i!r}\").with_traceback(exc.__traceback__) from exc\n            if not isinstance(fg, int) or fg >= len(attlist):\n                raise BarGraphError(f\"fg not valid integer: {fg!r}\")\n            if not isinstance(bg, int) or bg >= len(attlist):\n                raise BarGraphError(f\"bg not valid integer: {fg!r}\")\n            if fg <= bg:\n                raise BarGraphError(f\"fg ({fg}) not > bg ({bg})\")\n        self.satt = satt",
  "def set_data(self, bardata, top, hlines=None):\n        \"\"\"\n        Store bar data, bargraph top and horizontal line positions.\n\n        bardata -- a list of bar values.\n        top -- maximum value for segments within bardata\n        hlines -- None or a bar value marking horizontal line positions\n\n        bar values are [ segment1, segment2, ... ] lists where top is\n        the maximal value corresponding to the top of the bar graph and\n        segment1, segment2, ... are the values for the top of each\n        segment of this bar.  Simple bar graphs will only have one\n        segment in each bar value.\n\n        Eg: if top is 100 and there is a bar value of [ 80, 30 ] then\n        the top of this bar will be at 80% of full height of the graph\n        and it will have a second segment that starts at 30%.\n        \"\"\"\n        if hlines is not None:\n            hlines = sorted(hlines[:], reverse=True)  # shallow copy\n\n        self.data = bardata, top, hlines\n        self._invalidate()",
  "def _get_data(self, size: tuple[int, int]):\n        \"\"\"\n        Return (bardata, top, hlines)\n\n        This function is called by render to retrieve the data for\n        the graph. It may be overloaded to create a dynamic bar graph.\n\n        This implementation will truncate the bardata list returned\n        if not all bars will fit within maxcol.\n        \"\"\"\n        (maxcol, maxrow) = size\n        bardata, top, hlines = self.data\n        widths = self.calculate_bar_widths((maxcol, maxrow), bardata)\n\n        if len(bardata) > len(widths):\n            return bardata[: len(widths)], top, hlines\n\n        return bardata, top, hlines",
  "def set_bar_width(self, width: int | None):\n        \"\"\"\n        Set a preferred bar width for calculate_bar_widths to use.\n\n        width -- width of bar or None for automatic width adjustment\n        \"\"\"\n        if width is not None and width <= 0:\n            raise ValueError(width)\n        self.bar_width = width\n        self._invalidate()",
  "def calculate_bar_widths(self, size: tuple[int, int], bardata):\n        \"\"\"\n        Return a list of bar widths, one for each bar in data.\n\n        If self.bar_width is None this implementation will stretch\n        the bars across the available space specified by maxcol.\n        \"\"\"\n        (maxcol, maxrow) = size\n\n        if self.bar_width is not None:\n            return [self.bar_width] * min(len(bardata), maxcol // self.bar_width)\n\n        if len(bardata) >= maxcol:\n            return [1] * maxcol\n\n        widths = []\n        grow = maxcol\n        remain = len(bardata)\n        for _row in bardata:\n            w = int(float(grow) / remain + 0.5)\n            widths.append(w)\n            grow -= w\n            remain -= 1\n        return widths",
  "def selectable(self) -> Literal[False]:\n        \"\"\"\n        Return False.\n        \"\"\"\n        return False",
  "def use_smoothed(self) -> bool:\n        return self.satt and get_encoding_mode() == \"utf8\"",
  "def calculate_display(self, size: tuple[int, int]):\n        \"\"\"\n        Calculate display data.\n        \"\"\"\n        (maxcol, maxrow) = size\n        bardata, top, hlines = self.get_data((maxcol, maxrow))\n        widths = self.calculate_bar_widths((maxcol, maxrow), bardata)\n\n        if self.use_smoothed():\n            disp = calculate_bargraph_display(bardata, top, widths, maxrow * 8)\n            disp = self.smooth_display(disp)\n\n        else:\n            disp = calculate_bargraph_display(bardata, top, widths, maxrow)\n\n        if hlines:\n            disp = self.hlines_display(disp, top, hlines, maxrow)\n\n        return disp",
  "def hlines_display(self, disp, top: int, hlines, maxrow: int):\n        \"\"\"\n        Add hlines to display structure represented as bar_type tuple\n        values:\n        (bg, 0-5)\n        bg is the segment that has the hline on it\n        0-5 is the hline graphic to use where 0 is a regular underscore\n        and 1-5 are the UTF-8 horizontal scan line characters.\n        \"\"\"\n        if self.use_smoothed():\n            shiftr = 0\n            r = [\n                (0.2, 1),\n                (0.4, 2),\n                (0.6, 3),\n                (0.8, 4),\n                (1.0, 5),\n            ]\n        else:\n            shiftr = 0.5\n            r = [\n                (1.0, 0),\n            ]\n\n        # reverse the hlines to match screen ordering\n        rhl = []\n        for h in hlines:\n            rh = float(top - h) * maxrow / top - shiftr\n            if rh < 0:\n                continue\n            rhl.append(rh)\n\n        # build a list of rows that will have hlines\n        hrows = []\n        last_i = -1\n        for rh in rhl:\n            i = int(rh)\n            if i == last_i:\n                continue\n            f = rh - i\n            for spl, chnum in r:\n                if f < spl:\n                    hrows.append((i, chnum))\n                    break\n            last_i = i\n\n        # fill hlines into disp data\n        def fill_row(row, chnum):\n            rout = []\n            for bar_type, width in row:\n                if isinstance(bar_type, int) and len(self.hatt) > bar_type:\n                    rout.append(((bar_type, chnum), width))\n                    continue\n                rout.append((bar_type, width))\n            return rout\n\n        o = []\n        k = 0\n        rnum = 0\n        for y_count, row in disp:\n            if k >= len(hrows):\n                o.append((y_count, row))\n                continue\n            end_block = rnum + y_count\n            while k < len(hrows) and hrows[k][0] < end_block:\n                i, chnum = hrows[k]\n                if i - rnum > 0:\n                    o.append((i - rnum, row))\n                o.append((1, fill_row(row, chnum)))\n                rnum = i + 1\n                k += 1\n            if rnum < end_block:\n                o.append((end_block - rnum, row))\n                rnum = end_block\n\n        # assert 0, o\n        return o",
  "def smooth_display(self, disp):\n        \"\"\"\n        smooth (col, row*8) display into (col, row) display using\n        UTF vertical eighth characters represented as bar_type\n        tuple values:\n        ( fg, bg, 1-7 )\n        where fg is the lower segment, bg is the upper segment and\n        1-7 is the vertical eighth character to use.\n        \"\"\"\n        o = []\n        r = 0  # row remainder\n\n        def seg_combine(a, b):\n            (bt1, w1), (bt2, w2) = a, b\n            if (bt1, w1) == (bt2, w2):\n                return (bt1, w1), None, None\n            wmin = min(w1, w2)\n            l1 = l2 = None\n            if w1 > w2:\n                l1 = (bt1, w1 - w2)\n            elif w2 > w1:\n                l2 = (bt2, w2 - w1)\n            if isinstance(bt1, tuple):\n                return (bt1, wmin), l1, l2\n            if (bt2, bt1) not in self.satt:\n                if r < 4:\n                    return (bt2, wmin), l1, l2\n                return (bt1, wmin), l1, l2\n            return ((bt2, bt1, 8 - r), wmin), l1, l2\n\n        def row_combine_last(count: int, row):\n            o_count, o_row = o[-1]\n            row = row[:]  # shallow copy, so we don't destroy orig.\n            o_row = o_row[:]\n            widget_list = []\n            while row:\n                (bt, w), l1, l2 = seg_combine(o_row.pop(0), row.pop(0))\n                if widget_list and widget_list[-1][0] == bt:\n                    widget_list[-1] = (bt, widget_list[-1][1] + w)\n                else:\n                    widget_list.append((bt, w))\n                if l1:\n                    o_row = [l1, *o_row]\n                if l2:\n                    row = [l2, *row]\n\n            if o_row:\n                raise BarGraphError(o_row)\n\n            o[-1] = (o_count + count, widget_list)\n\n        # regroup into actual rows (8 disp rows == 1 actual row)\n        for y_count, row in disp:\n            if r:\n                count = min(8 - r, y_count)\n                row_combine_last(count, row)\n                y_count -= count  # noqa: PLW2901\n                r += count\n                r = r % 8\n                if not y_count:\n                    continue\n            if r != 0:\n                raise BarGraphError\n            # copy whole blocks\n            if y_count > 7:\n                o.append((y_count // 8 * 8, row))\n                y_count %= 8  # noqa: PLW2901\n                if not y_count:\n                    continue\n            o.append((y_count, row))\n            r = y_count\n        return [(y // 8, row) for (y, row) in o]",
  "def render(self, size: tuple[int, int], focus: bool = False) -> CompositeCanvas:\n        \"\"\"\n        Render BarGraph.\n        \"\"\"\n        (maxcol, maxrow) = size\n        disp = self.calculate_display((maxcol, maxrow))\n\n        combinelist = []\n        for y_count, row in disp:\n            widget_list = []\n            for bar_type, width in row:\n                if isinstance(bar_type, tuple):\n                    if len(bar_type) == 3:\n                        # vertical eighths\n                        fg, bg, k = bar_type\n                        a = self.satt[(fg, bg)]\n                        t = self.eighths[k] * width\n                    else:\n                        # horizontal lines\n                        bg, k = bar_type\n                        a = self.hatt[bg]\n                        t = self.hlines[k] * width\n                else:\n                    a = self.attr[bar_type]\n                    t = self.char[bar_type] * width\n                widget_list.append((a, t))\n            c = Text(widget_list).render((maxcol,))\n            if c.rows() != 1:\n                raise BarGraphError(\"Invalid characters in BarGraph!\")\n            combinelist += [(c, None, False)] * y_count\n\n        canv = CanvasCombine(combinelist)\n        return canv",
  "def add_segment(seg_num: int, col: int, row: int, width: int, rows=rows) -> None:\n        if rows[row]:\n            last_seg, last_col, last_end = rows[row][-1]\n            if last_end > col:\n                if last_col >= col:\n                    del rows[row][-1]\n                else:\n                    rows[row][-1] = (last_seg, last_col, col)\n            elif last_seg == seg_num and last_end == col:\n                rows[row][-1] = (last_seg, last_col, last_end + width)\n                return\n        elif rows[row] is None:\n            rows[row] = []\n        rows[row].append((seg_num, col, col + width))",
  "def __init__(self, labels, top):\n        \"\"\"\n        GraphVScale( [(label1 position, label1 markup),...], top )\n        label position -- 0 < position < top for the y position\n        label markup -- text markup for this label\n        top -- top y position\n\n        This widget is a vertical scale for the BarGraph widget that\n        can correspond to the BarGraph's horizontal lines\n        \"\"\"\n        self.set_scale(labels, top)",
  "def set_scale(self, labels, top):\n        \"\"\"\n        set_scale( [(label1 position, label1 markup),...], top )\n        label position -- 0 < position < top for the y position\n        label markup -- text markup for this label\n        top -- top y position\n        \"\"\"\n\n        labels = sorted(labels[:], reverse=True)  # shallow copy\n\n        self.pos = []\n        self.txt = []\n        for y, markup in labels:\n            self.pos.append(y)\n            self.txt.append(Text(markup))\n        self.top = top",
  "def selectable(self) -> Literal[False]:\n        \"\"\"\n        Return False.\n        \"\"\"\n        return False",
  "def render(self, size: tuple[int, int], focus: bool = False):\n        \"\"\"\n        Render GraphVScale.\n        \"\"\"\n        (maxcol, maxrow) = size\n        pl = scale_bar_values(self.pos, self.top, maxrow)\n\n        combinelist = []\n        rows = 0\n        for p, t in zip(pl, self.txt):\n            p -= 1  # noqa: PLW2901\n            if p >= maxrow:\n                break\n            if p < rows:\n                continue\n            c = t.render((maxcol,))\n            if p > rows:\n                run = p - rows\n                c = CompositeCanvas(c)\n                c.pad_trim_top_bottom(run, 0)\n            rows += c.rows()\n            combinelist.append((c, None, False))\n        if not combinelist:\n            return SolidCanvas(\" \", size[0], size[1])\n\n        c = CanvasCombine(combinelist)\n        if maxrow - rows:\n            c.pad_trim_top_bottom(0, maxrow - rows)\n        return c",
  "def fill_row(row, chnum):\n            rout = []\n            for bar_type, width in row:\n                if isinstance(bar_type, int) and len(self.hatt) > bar_type:\n                    rout.append(((bar_type, chnum), width))\n                    continue\n                rout.append((bar_type, width))\n            return rout",
  "def seg_combine(a, b):\n            (bt1, w1), (bt2, w2) = a, b\n            if (bt1, w1) == (bt2, w2):\n                return (bt1, w1), None, None\n            wmin = min(w1, w2)\n            l1 = l2 = None\n            if w1 > w2:\n                l1 = (bt1, w1 - w2)\n            elif w2 > w1:\n                l2 = (bt2, w2 - w1)\n            if isinstance(bt1, tuple):\n                return (bt1, wmin), l1, l2\n            if (bt2, bt1) not in self.satt:\n                if r < 4:\n                    return (bt2, wmin), l1, l2\n                return (bt1, wmin), l1, l2\n            return ((bt2, bt1, 8 - r), wmin), l1, l2",
  "def row_combine_last(count: int, row):\n            o_count, o_row = o[-1]\n            row = row[:]  # shallow copy, so we don't destroy orig.\n            o_row = o_row[:]\n            widget_list = []\n            while row:\n                (bt, w), l1, l2 = seg_combine(o_row.pop(0), row.pop(0))\n                if widget_list and widget_list[-1][0] == bt:\n                    widget_list[-1] = (bt, widget_list[-1][1] + w)\n                else:\n                    widget_list.append((bt, w))\n                if l1:\n                    o_row = [l1, *o_row]\n                if l2:\n                    row = [l2, *row]\n\n            if o_row:\n                raise BarGraphError(o_row)\n\n            o[-1] = (o_count + count, widget_list)",
  "class BoxAdapterError(Exception):\n    pass",
  "class BoxAdapter(WidgetDecoration):\n    \"\"\"\n    Adapter for using a box widget where a flow widget would usually go\n    \"\"\"\n\n    no_cache: typing.ClassVar[list[str]] = [\"rows\"]\n\n    def __init__(self, box_widget, height):\n        \"\"\"\n        Create a flow widget that contains a box widget\n\n        :param box_widget: box widget to wrap\n        :type box_widget: Widget\n        :param height: number of rows for box widget\n        :type height: int\n\n        >>> from urwid import SolidFill\n        >>> BoxAdapter(SolidFill(u\"x\"), 5) # 5-rows of x's\n        <BoxAdapter flow widget <SolidFill box widget 'x'> height=5>\n        \"\"\"\n        if hasattr(box_widget, \"sizing\") and Sizing.BOX not in box_widget.sizing():\n            raise BoxAdapterError(f\"{box_widget!r} is not a box widget\")\n        super().__init__(box_widget)\n\n        self.height = height\n\n    def _repr_attrs(self):\n        return dict(super()._repr_attrs(), height=self.height)\n\n    # originally stored as box_widget, keep for compatibility\n    @property\n    def box_widget(self) -> Widget:\n        warnings.warn(\n            \"original stored as original_widget, keep for compatibility\",\n            PendingDeprecationWarning,\n            stacklevel=2,\n        )\n        return self.original_widget\n\n    @box_widget.setter\n    def box_widget(self, widget: Widget):\n        warnings.warn(\n            \"original stored as original_widget, keep for compatibility\",\n            PendingDeprecationWarning,\n            stacklevel=2,\n        )\n        self.original_widget = widget\n\n    def sizing(self):\n        return {Sizing.FLOW}\n\n    def rows(self, size: tuple[int], focus: bool = False) -> int:\n        \"\"\"\n        Return the predetermined height (behave like a flow widget)\n\n        >>> from urwid import SolidFill\n        >>> BoxAdapter(SolidFill(u\"x\"), 5).rows((20,))\n        5\n        \"\"\"\n        return self.height\n\n    # The next few functions simply tack-on our height and pass through\n    # to self._original_widget\n    def get_cursor_coords(self, size: tuple[int]) -> int | None:\n        (maxcol,) = size\n        if not hasattr(self._original_widget, \"get_cursor_coords\"):\n            return None\n        return self._original_widget.get_cursor_coords((maxcol, self.height))\n\n    def get_pref_col(self, size: tuple[int]) -> int | None:\n        (maxcol,) = size\n        if not hasattr(self._original_widget, \"get_pref_col\"):\n            return None\n        return self._original_widget.get_pref_col((maxcol, self.height))\n\n    def keypress(self, size: tuple[int], key: str) -> str | None:\n        (maxcol,) = size\n        return self._original_widget.keypress((maxcol, self.height), key)\n\n    def move_cursor_to_coords(self, size: tuple[int], col: int, row: int):\n        (maxcol,) = size\n        if not hasattr(self._original_widget, \"move_cursor_to_coords\"):\n            return True\n        return self._original_widget.move_cursor_to_coords((maxcol, self.height), col, row)\n\n    def mouse_event(\n        self,\n        size: tuple[int],\n        event,\n        button: int,\n        col: int,\n        row: int,\n        focus: bool,\n    ) -> bool:\n        (maxcol,) = size\n        if not hasattr(self._original_widget, \"mouse_event\"):\n            return False\n        return self._original_widget.mouse_event((maxcol, self.height), event, button, col, row, focus)\n\n    def render(self, size: tuple[int], focus: bool = False) -> CompositeCanvas:\n        (maxcol,) = size\n        canv = CompositeCanvas(self._original_widget.render((maxcol, self.height), focus))\n        return canv\n\n    def __getattr__(self, name: str):\n        \"\"\"\n        Pass calls to box widget.\n        \"\"\"\n        return getattr(self.original_widget, name)",
  "def __init__(self, box_widget, height):\n        \"\"\"\n        Create a flow widget that contains a box widget\n\n        :param box_widget: box widget to wrap\n        :type box_widget: Widget\n        :param height: number of rows for box widget\n        :type height: int\n\n        >>> from urwid import SolidFill\n        >>> BoxAdapter(SolidFill(u\"x\"), 5) # 5-rows of x's\n        <BoxAdapter flow widget <SolidFill box widget 'x'> height=5>\n        \"\"\"\n        if hasattr(box_widget, \"sizing\") and Sizing.BOX not in box_widget.sizing():\n            raise BoxAdapterError(f\"{box_widget!r} is not a box widget\")\n        super().__init__(box_widget)\n\n        self.height = height",
  "def _repr_attrs(self):\n        return dict(super()._repr_attrs(), height=self.height)",
  "def box_widget(self) -> Widget:\n        warnings.warn(\n            \"original stored as original_widget, keep for compatibility\",\n            PendingDeprecationWarning,\n            stacklevel=2,\n        )\n        return self.original_widget",
  "def box_widget(self, widget: Widget):\n        warnings.warn(\n            \"original stored as original_widget, keep for compatibility\",\n            PendingDeprecationWarning,\n            stacklevel=2,\n        )\n        self.original_widget = widget",
  "def sizing(self):\n        return {Sizing.FLOW}",
  "def rows(self, size: tuple[int], focus: bool = False) -> int:\n        \"\"\"\n        Return the predetermined height (behave like a flow widget)\n\n        >>> from urwid import SolidFill\n        >>> BoxAdapter(SolidFill(u\"x\"), 5).rows((20,))\n        5\n        \"\"\"\n        return self.height",
  "def get_cursor_coords(self, size: tuple[int]) -> int | None:\n        (maxcol,) = size\n        if not hasattr(self._original_widget, \"get_cursor_coords\"):\n            return None\n        return self._original_widget.get_cursor_coords((maxcol, self.height))",
  "def get_pref_col(self, size: tuple[int]) -> int | None:\n        (maxcol,) = size\n        if not hasattr(self._original_widget, \"get_pref_col\"):\n            return None\n        return self._original_widget.get_pref_col((maxcol, self.height))",
  "def keypress(self, size: tuple[int], key: str) -> str | None:\n        (maxcol,) = size\n        return self._original_widget.keypress((maxcol, self.height), key)",
  "def move_cursor_to_coords(self, size: tuple[int], col: int, row: int):\n        (maxcol,) = size\n        if not hasattr(self._original_widget, \"move_cursor_to_coords\"):\n            return True\n        return self._original_widget.move_cursor_to_coords((maxcol, self.height), col, row)",
  "def mouse_event(\n        self,\n        size: tuple[int],\n        event,\n        button: int,\n        col: int,\n        row: int,\n        focus: bool,\n    ) -> bool:\n        (maxcol,) = size\n        if not hasattr(self._original_widget, \"mouse_event\"):\n            return False\n        return self._original_widget.mouse_event((maxcol, self.height), event, button, col, row, focus)",
  "def render(self, size: tuple[int], focus: bool = False) -> CompositeCanvas:\n        (maxcol,) = size\n        canv = CompositeCanvas(self._original_widget.render((maxcol, self.height), focus))\n        return canv",
  "def __getattr__(self, name: str):\n        \"\"\"\n        Pass calls to box widget.\n        \"\"\"\n        return getattr(self.original_widget, name)",
  "class AttrMapError(WidgetError):\n    pass",
  "class AttrMap(delegate_to_widget_mixin(\"_original_widget\"), WidgetDecoration):\n    \"\"\"\n    AttrMap is a decoration that maps one set of attributes to another.\n    This object will pass all function calls and variable references to the\n    wrapped widget.\n    \"\"\"\n\n    def __init__(self, w: Widget, attr_map, focus_map=None) -> None:\n        \"\"\"\n        :param w: widget to wrap (stored as self.original_widget)\n        :type w: widget\n\n        :param attr_map: attribute to apply to *w*, or dict of old display\n            attribute: new display attribute mappings\n        :type attr_map: display attribute or dict\n\n        :param focus_map: attribute to apply when in focus or dict of\n            old display attribute: new display attribute mappings;\n            if ``None`` use *attr*\n        :type focus_map: display attribute or dict\n\n        >>> from urwid import Divider, Edit, Text\n        >>> AttrMap(Divider(u\"!\"), 'bright')\n        <AttrMap flow widget <Divider flow widget '!'> attr_map={None: 'bright'}>\n        >>> AttrMap(Edit(), 'notfocus', 'focus').attr_map\n        {None: 'notfocus'}\n        >>> AttrMap(Edit(), 'notfocus', 'focus').focus_map\n        {None: 'focus'}\n        >>> size = (5,)\n        >>> am = AttrMap(Text(u\"hi\"), 'greeting', 'fgreet')\n        >>> next(am.render(size, focus=False).content()) # ... = b in Python 3\n        [('greeting', None, ...'hi   ')]\n        >>> next(am.render(size, focus=True).content())\n        [('fgreet', None, ...'hi   ')]\n        >>> am2 = AttrMap(Text(('word', u\"hi\")), {'word':'greeting', None:'bg'})\n        >>> am2\n        <AttrMap flow widget <Text flow widget 'hi'> attr_map={'word': 'greeting', None: 'bg'}>\n        >>> next(am2.render(size).content())\n        [('greeting', None, ...'hi'), ('bg', None, ...'   ')]\n        \"\"\"\n        super().__init__(w)\n\n        if isinstance(attr_map, Mapping):\n            self.attr_map = dict(attr_map)\n        else:\n            self.attr_map = {None: attr_map}\n\n        if isinstance(focus_map, Mapping):\n            self.focus_map = dict(focus_map)\n        elif focus_map is None:\n            self.focus_map = focus_map\n        else:\n            self.focus_map = {None: focus_map}\n\n    def _repr_attrs(self):\n        # only include the focus_attr when it takes effect (not None)\n        d = dict(super()._repr_attrs(), attr_map=self._attr_map)\n        if self._focus_map is not None:\n            d[\"focus_map\"] = self._focus_map\n        return d\n\n    def get_attr_map(self) -> dict[Hashable | None, Hashable]:\n        # make a copy so ours is not accidentally modified\n        # FIXME: a dictionary that detects modifications would be better\n        return dict(self._attr_map)\n\n    def set_attr_map(self, attr_map: dict[Hashable | None, Hashable]) -> None:\n        \"\"\"\n        Set the attribute mapping dictionary {from_attr: to_attr, ...}\n\n        Note this function does not accept a single attribute the way the\n        constructor does.  You must specify {None: attribute} instead.\n\n        >>> from urwid import Text\n        >>> w = AttrMap(Text(u\"hi\"), None)\n        >>> w.set_attr_map({'a':'b'})\n        >>> w\n        <AttrMap flow widget <Text flow widget 'hi'> attr_map={'a': 'b'}>\n        \"\"\"\n        for from_attr, to_attr in attr_map.items():\n            if not isinstance(from_attr, Hashable) or not isinstance(to_attr, Hashable):\n                raise AttrMapError(\n                    f\"{from_attr!r}:{to_attr!r} attribute mapping is invalid. Attributes must be hashable\"\n                )\n\n        self._attr_map = attr_map\n        self._invalidate()\n\n    attr_map = property(get_attr_map, set_attr_map)\n\n    def get_focus_map(self) -> dict[Hashable | None, Hashable] | None:\n        # make a copy so ours is not accidentally modified\n        # FIXME: a dictionary that detects modifications would be better\n        if self._focus_map:\n            return dict(self._focus_map)\n        return None\n\n    def set_focus_map(self, focus_map: dict[Hashable | None, Hashable]) -> None:\n        \"\"\"\n        Set the focus attribute mapping dictionary\n        {from_attr: to_attr, ...}\n\n        If None this widget will use the attr mapping instead (no change\n        when in focus).\n\n        Note this function does not accept a single attribute the way the\n        constructor does.  You must specify {None: attribute} instead.\n\n        >>> from urwid import Text\n        >>> w = AttrMap(Text(u\"hi\"), {})\n        >>> w.set_focus_map({'a':'b'})\n        >>> w\n        <AttrMap flow widget <Text flow widget 'hi'> attr_map={} focus_map={'a': 'b'}>\n        >>> w.set_focus_map(None)\n        >>> w\n        <AttrMap flow widget <Text flow widget 'hi'> attr_map={}>\n        \"\"\"\n        if focus_map is not None:\n            for from_attr, to_attr in focus_map.items():\n                if not isinstance(from_attr, Hashable) or not isinstance(to_attr, Hashable):\n                    raise AttrMapError(\n                        f\"{from_attr!r}:{to_attr!r} attribute mapping is invalid. Attributes must be hashable\"\n                    )\n        self._focus_map = focus_map\n        self._invalidate()\n\n    focus_map = property(get_focus_map, set_focus_map)\n\n    def render(self, size, focus: bool = False) -> CompositeCanvas:\n        \"\"\"\n        Render wrapped widget and apply attribute. Return canvas.\n        \"\"\"\n        attr_map = self._attr_map\n        if focus and self._focus_map is not None:\n            attr_map = self._focus_map\n        canv = self._original_widget.render(size, focus=focus)\n        canv = CompositeCanvas(canv)\n        canv.fill_attr_apply(attr_map)\n        return canv",
  "def __init__(self, w: Widget, attr_map, focus_map=None) -> None:\n        \"\"\"\n        :param w: widget to wrap (stored as self.original_widget)\n        :type w: widget\n\n        :param attr_map: attribute to apply to *w*, or dict of old display\n            attribute: new display attribute mappings\n        :type attr_map: display attribute or dict\n\n        :param focus_map: attribute to apply when in focus or dict of\n            old display attribute: new display attribute mappings;\n            if ``None`` use *attr*\n        :type focus_map: display attribute or dict\n\n        >>> from urwid import Divider, Edit, Text\n        >>> AttrMap(Divider(u\"!\"), 'bright')\n        <AttrMap flow widget <Divider flow widget '!'> attr_map={None: 'bright'}>\n        >>> AttrMap(Edit(), 'notfocus', 'focus').attr_map\n        {None: 'notfocus'}\n        >>> AttrMap(Edit(), 'notfocus', 'focus').focus_map\n        {None: 'focus'}\n        >>> size = (5,)\n        >>> am = AttrMap(Text(u\"hi\"), 'greeting', 'fgreet')\n        >>> next(am.render(size, focus=False).content()) # ... = b in Python 3\n        [('greeting', None, ...'hi   ')]\n        >>> next(am.render(size, focus=True).content())\n        [('fgreet', None, ...'hi   ')]\n        >>> am2 = AttrMap(Text(('word', u\"hi\")), {'word':'greeting', None:'bg'})\n        >>> am2\n        <AttrMap flow widget <Text flow widget 'hi'> attr_map={'word': 'greeting', None: 'bg'}>\n        >>> next(am2.render(size).content())\n        [('greeting', None, ...'hi'), ('bg', None, ...'   ')]\n        \"\"\"\n        super().__init__(w)\n\n        if isinstance(attr_map, Mapping):\n            self.attr_map = dict(attr_map)\n        else:\n            self.attr_map = {None: attr_map}\n\n        if isinstance(focus_map, Mapping):\n            self.focus_map = dict(focus_map)\n        elif focus_map is None:\n            self.focus_map = focus_map\n        else:\n            self.focus_map = {None: focus_map}",
  "def _repr_attrs(self):\n        # only include the focus_attr when it takes effect (not None)\n        d = dict(super()._repr_attrs(), attr_map=self._attr_map)\n        if self._focus_map is not None:\n            d[\"focus_map\"] = self._focus_map\n        return d",
  "def get_attr_map(self) -> dict[Hashable | None, Hashable]:\n        # make a copy so ours is not accidentally modified\n        # FIXME: a dictionary that detects modifications would be better\n        return dict(self._attr_map)",
  "def set_attr_map(self, attr_map: dict[Hashable | None, Hashable]) -> None:\n        \"\"\"\n        Set the attribute mapping dictionary {from_attr: to_attr, ...}\n\n        Note this function does not accept a single attribute the way the\n        constructor does.  You must specify {None: attribute} instead.\n\n        >>> from urwid import Text\n        >>> w = AttrMap(Text(u\"hi\"), None)\n        >>> w.set_attr_map({'a':'b'})\n        >>> w\n        <AttrMap flow widget <Text flow widget 'hi'> attr_map={'a': 'b'}>\n        \"\"\"\n        for from_attr, to_attr in attr_map.items():\n            if not isinstance(from_attr, Hashable) or not isinstance(to_attr, Hashable):\n                raise AttrMapError(\n                    f\"{from_attr!r}:{to_attr!r} attribute mapping is invalid. Attributes must be hashable\"\n                )\n\n        self._attr_map = attr_map\n        self._invalidate()",
  "def get_focus_map(self) -> dict[Hashable | None, Hashable] | None:\n        # make a copy so ours is not accidentally modified\n        # FIXME: a dictionary that detects modifications would be better\n        if self._focus_map:\n            return dict(self._focus_map)\n        return None",
  "def set_focus_map(self, focus_map: dict[Hashable | None, Hashable]) -> None:\n        \"\"\"\n        Set the focus attribute mapping dictionary\n        {from_attr: to_attr, ...}\n\n        If None this widget will use the attr mapping instead (no change\n        when in focus).\n\n        Note this function does not accept a single attribute the way the\n        constructor does.  You must specify {None: attribute} instead.\n\n        >>> from urwid import Text\n        >>> w = AttrMap(Text(u\"hi\"), {})\n        >>> w.set_focus_map({'a':'b'})\n        >>> w\n        <AttrMap flow widget <Text flow widget 'hi'> attr_map={} focus_map={'a': 'b'}>\n        >>> w.set_focus_map(None)\n        >>> w\n        <AttrMap flow widget <Text flow widget 'hi'> attr_map={}>\n        \"\"\"\n        if focus_map is not None:\n            for from_attr, to_attr in focus_map.items():\n                if not isinstance(from_attr, Hashable) or not isinstance(to_attr, Hashable):\n                    raise AttrMapError(\n                        f\"{from_attr!r}:{to_attr!r} attribute mapping is invalid. Attributes must be hashable\"\n                    )\n        self._focus_map = focus_map\n        self._invalidate()",
  "def render(self, size, focus: bool = False) -> CompositeCanvas:\n        \"\"\"\n        Render wrapped widget and apply attribute. Return canvas.\n        \"\"\"\n        attr_map = self._attr_map\n        if focus and self._focus_map is not None:\n            attr_map = self._focus_map\n        canv = self._original_widget.render(size, focus=focus)\n        canv = CompositeCanvas(canv)\n        canv.fill_attr_apply(attr_map)\n        return canv",
  "class WidgetMeta(MetaSuper, signals.MetaSignals):\n    \"\"\"\n    Bases: :class:`MetaSuper`, :class:`MetaSignals`\n\n    Automatic caching of render and rows methods.\n\n    Class variable *no_cache* is a list of names of methods to not cache\n    automatically.  Valid method names for *no_cache* are ``'render'`` and\n    ``'rows'``.\n\n    Class variable *ignore_focus* if defined and set to ``True`` indicates\n    that the canvas this widget renders is not affected by the focus\n    parameter, so it may be ignored when caching.\n    \"\"\"\n\n    def __init__(cls, name, bases, d):\n        no_cache = d.get(\"no_cache\", [])\n\n        super().__init__(name, bases, d)\n\n        if \"render\" in d:\n            if \"render\" not in no_cache:\n                render_fn = cache_widget_render(cls)\n            else:\n                render_fn = nocache_widget_render(cls)\n            cls.render = render_fn\n\n        if \"rows\" in d and \"rows\" not in no_cache:\n            cls.rows = cache_widget_rows(cls)\n        if \"no_cache\" in d:\n            del cls.no_cache\n        if \"ignore_focus\" in d:\n            del cls.ignore_focus",
  "class WidgetError(Exception):\n    pass",
  "def validate_size(widget, size, canv):\n    \"\"\"\n    Raise a WidgetError if a canv does not match size.\n    \"\"\"\n    if (size and size[1:] != (0,) and size[0] != canv.cols()) or (len(size) > 1 and size[1] != canv.rows()):\n        raise WidgetError(\n            f\"Widget {widget!r} rendered ({canv.cols():d} x {canv.rows():d}) canvas when passed size {size!r}!\"\n        )",
  "def cache_widget_render(cls):\n    \"\"\"\n    Return a function that wraps the cls.render() method\n    and fetches and stores canvases with CanvasCache.\n    \"\"\"\n    ignore_focus = bool(getattr(cls, \"ignore_focus\", False))\n    fn = cls.render\n\n    @functools.wraps(fn)\n    def cached_render(self, size, focus=False):\n        focus = focus and not ignore_focus\n        canv = CanvasCache.fetch(self, cls, size, focus)\n        if canv:\n            return canv\n\n        canv = fn(self, size, focus=focus)\n        validate_size(self, size, canv)\n        if canv.widget_info:\n            canv = CompositeCanvas(canv)\n        canv.finalize(self, size, focus)\n        CanvasCache.store(cls, canv)\n        return canv\n\n    cached_render.original_fn = fn\n    return cached_render",
  "def nocache_widget_render(cls):\n    \"\"\"\n    Return a function that wraps the cls.render() method\n    and finalizes the canvas that it returns.\n    \"\"\"\n    fn = cls.render\n    if hasattr(fn, \"original_fn\"):\n        fn = fn.original_fn\n\n    @functools.wraps(fn)\n    def finalize_render(self, size, focus=False):\n        canv = fn(self, size, focus=focus)\n        if canv.widget_info:\n            canv = CompositeCanvas(canv)\n        validate_size(self, size, canv)\n        canv.finalize(self, size, focus)\n        return canv\n\n    finalize_render.original_fn = fn\n    return finalize_render",
  "def nocache_widget_render_instance(self):\n    \"\"\"\n    Return a function that wraps the cls.render() method\n    and finalizes the canvas that it returns, but does not\n    cache the canvas.\n    \"\"\"\n    fn = self.render.original_fn\n\n    @functools.wraps(fn)\n    def finalize_render(size, focus=False):\n        canv = fn(self, size, focus=focus)\n        if canv.widget_info:\n            canv = CompositeCanvas(canv)\n        canv.finalize(self, size, focus)\n        return canv\n\n    finalize_render.original_fn = fn\n    return finalize_render",
  "def cache_widget_rows(cls):\n    \"\"\"\n    Return a function that wraps the cls.rows() method\n    and returns rows from the CanvasCache if available.\n    \"\"\"\n    ignore_focus = bool(getattr(cls, \"ignore_focus\", False))\n    fn = cls.rows\n\n    @functools.wraps(fn)\n    def cached_rows(self, size, focus=False):\n        focus = focus and not ignore_focus\n        canv = CanvasCache.fetch(self, cls, size, focus)\n        if canv:\n            return canv.rows()\n\n        return fn(self, size, focus)\n\n    return cached_rows",
  "class Widget(metaclass=WidgetMeta):\n    \"\"\"\n    Widget base class\n\n    .. attribute:: _selectable\n       :annotation: = False\n\n       The default :meth:`.selectable` method returns this\n       value.\n\n    .. attribute:: _sizing\n       :annotation: = frozenset(['flow', 'box', 'fixed'])\n\n       The default :meth:`.sizing` method returns this value.\n\n    .. attribute:: _command_map\n       :annotation: = urwid.command_map\n\n       A shared :class:`CommandMap` instance. May be redefined\n       in subclasses or widget instances.\n\n    .. method:: render(size, focus=False)\n\n       .. note::\n\n          This method is not implemented in :class:`.Widget` but\n          must be implemented by any concrete subclass\n\n       :param size: One of the following,\n                    *maxcol* and *maxrow* are integers > 0:\n\n                    (*maxcol*, *maxrow*)\n                      for box sizing -- the parent chooses the exact\n                      size of this widget\n\n                    (*maxcol*,)\n                      for flow sizing -- the parent chooses only the\n                      number of columns for this widget\n\n                    ()\n                      for fixed sizing -- this widget is a fixed size\n                      which can't be adjusted by the parent\n       :type size: widget size\n       :param focus: set to ``True`` if this widget or one of its children\n                     is in focus\n       :type focus: bool\n\n       :returns: A :class:`Canvas` subclass instance containing the\n                 rendered content of this widget\n\n       :class:`Text` widgets return a :class:`TextCanvas` (arbitrary text and\n       display attributes), :class:`SolidFill` widgets return a\n       :class:`SolidCanvas` (a single character repeated across\n       the whole surface) and container widgets return a\n       :class:`CompositeCanvas` (one or more other canvases\n       arranged arbitrarily).\n\n       If *focus* is ``False``, the returned canvas may not have a cursor\n       position set.\n\n       There is some metaclass magic defined in the :class:`Widget`\n       metaclass :class:`WidgetMeta` that causes the\n       result of this method to be cached by :class:`CanvasCache`.\n       Later calls will automatically look up the value in the cache first.\n\n       As a small optimization the class variable :attr:`ignore_focus`\n       may be defined and set to ``True`` if this widget renders the same\n       canvas regardless of the value of the *focus* parameter.\n\n       Any time the content of a widget changes it should call\n       :meth:`_invalidate` to remove any cached canvases, or the widget\n       may render the cached canvas instead of creating a new one.\n\n\n    .. method:: rows(size, focus=False)\n\n       .. note::\n\n          This method is not implemented in :class:`.Widget` but\n          must be implemented by any flow widget.  See :meth:`.sizing`.\n\n       See :meth:`Widget.render` for parameter details.\n\n       :returns: The number of rows required for this widget given a number\n                 of columns in *size*\n\n       This is the method flow widgets use to communicate their size to other\n       widgets without having to render a canvas. This should be a quick\n       calculation as this function may be called a number of times in normal\n       operation. If your implementation may take a long time you should add\n       your own caching here.\n\n       There is some metaclass magic defined in the :class:`Widget`\n       metaclass :class:`WidgetMeta` that causes the\n       result of this function to be retrieved from any\n       canvas cached by :class:`CanvasCache`, so if your widget\n       has been rendered you may not receive calls to this function. The class\n       variable :attr:`ignore_focus` may be defined and set to ``True`` if this\n       widget renders the same size regardless of the value of the *focus*\n       parameter.\n\n\n    .. method:: keypress(size, key)\n\n       .. note::\n\n          This method is not implemented in :class:`.Widget` but\n          must be implemented by any selectable widget.\n          See :meth:`.selectable`.\n\n       :param size: See :meth:`Widget.render` for details\n       :type size: widget size\n       :param key: a single keystroke value; see :ref:`keyboard-input`\n       :type key: bytes or unicode\n\n       :returns: ``None`` if *key* was handled by this widget or\n                 *key* (the same value passed) if *key* was not handled\n                 by this widget\n\n       Container widgets will typically call the :meth:`keypress` method on\n       whichever of their children is set as the focus.\n\n       The standard widgets use :attr:`_command_map` to\n       determine what action should be performed for a given *key*. You may\n       modify these values to your liking globally, at some level in the\n       widget hierarchy or on individual widgets. See :class:`CommandMap`\n       for the defaults.\n\n       In your own widgets you may use whatever logic you like: filtering or\n       translating keys, selectively passing along events etc.\n\n\n\n    .. method:: mouse_event(size, event, button, col, row, focus)\n\n       .. note::\n\n          This method is not implemented in :class:`.Widget` but\n          may be implemented by a subclass.  Not implementing this\n          method is equivalent to having a method that always returns\n          ``False``.\n\n       :param size: See :meth:`Widget.render` for details.\n       :type size: widget size\n       :param event: Values such as ``'mouse press'``, ``'ctrl mouse press'``,\n                     ``'mouse release'``, ``'meta mouse release'``,\n                     ``'mouse drag'``; see :ref:`mouse-input`\n       :type event: mouse event\n       :param button: 1 through 5 for press events, often 0 for release events\n                      (which button was released is often not known)\n       :type button: int\n       :param col: Column of the event, 0 is the left edge of this widget\n       :type col: int\n       :param row: Row of the event, 0 it the top row of this widget\n       :type row: int\n       :param focus: Set to ``True`` if this widget or one of its children\n                     is in focus\n       :type focus: bool\n\n       :returns: ``True`` if the event was handled by this widget, ``False``\n                 otherwise\n\n       Container widgets will typically call the :meth:`mouse_event` method on\n       whichever of their children is at the position (*col*, *row*).\n\n\n    .. method:: get_cursor_coords(size)\n\n       .. note::\n\n          This method is not implemented in :class:`.Widget` but\n          must be implemented by any widget that may return cursor\n          coordinates as part of the canvas that :meth:`render` returns.\n\n       :param size: See :meth:`Widget.render` for details.\n       :type size: widget size\n\n       :returns: (*col*, *row*) if this widget has a cursor, ``None`` otherwise\n\n       Return the cursor coordinates (*col*, *row*) of a cursor that will appear\n       as part of the canvas rendered by this widget when in focus, or ``None``\n       if no cursor is displayed.\n\n       The :class:`ListBox` widget\n       uses this method to make sure a cursor in the focus widget is not\n       scrolled out of view.  It is a separate method to avoid having to render\n       the whole widget while calculating layout.\n\n       Container widgets will typically call the :meth:`.get_cursor_coords`\n       method on their focus widget.\n\n\n    .. method:: get_pref_col(size)\n\n       .. note::\n\n          This method is not implemented in :class:`.Widget` but\n          may be implemented by a subclass.\n\n       :param size: See :meth:`Widget.render` for details.\n       :type size: widget size\n\n       :returns: a column number or ``'left'`` for the leftmost available\n                 column or ``'right'`` for the rightmost available column\n\n       Return the preferred column for the cursor to be displayed in this\n       widget. This value might not be the same as the column returned from\n       :meth:`get_cursor_coords`.\n\n       The :class:`ListBox` and :class:`Pile`\n       widgets call this method on a widget losing focus and use the value\n       returned to call :meth:`.move_cursor_to_coords` on the widget becoming\n       the focus. This allows the focus to move up and down through widgets\n       while keeping the cursor in approximately the same column on screen.\n\n\n    .. method:: move_cursor_to_coords(size, col, row)\n\n       .. note::\n\n          This method is not implemented in :class:`.Widget` but\n          may be implemented by a subclass.  Not implementing this\n          method is equivalent to having a method that always returns\n          ``False``.\n\n       :param size: See :meth:`Widget.render` for details.\n       :type size: widget size\n       :param col: new column for the cursor, 0 is the left edge of this widget\n       :type col: int\n       :param row: new row for the cursor, 0 it the top row of this widget\n       :type row: int\n\n       :returns: ``True`` if the position was set successfully anywhere on\n                 *row*, ``False`` otherwise\n    \"\"\"\n\n    _selectable = False\n    _sizing = frozenset([Sizing.FLOW, Sizing.BOX, Sizing.FIXED])\n    _command_map = command_map\n\n    def _invalidate(self) -> None:\n        \"\"\"\n        Mark cached canvases rendered by this widget as dirty so that\n        they will not be used again.\n        \"\"\"\n        CanvasCache.invalidate(self)\n\n    def _emit(self, name: str, *args):\n        \"\"\"\n        Convenience function to emit signals with self as first\n        argument.\n        \"\"\"\n        signals.emit_signal(self, name, self, *args)\n\n    def selectable(self):\n        \"\"\"\n        :returns: ``True`` if this is a widget that is designed to take the\n                  focus, i.e. it contains something the user might want to\n                  interact with, ``False`` otherwise,\n\n        This default implementation returns :attr:`._selectable`.\n        Subclasses may leave these is if the are not selectable,\n        or if they are always selectable they may\n        set the :attr:`_selectable` class variable to ``True``.\n\n        If this method returns ``True`` then the :meth:`.keypress` method\n        must be implemented.\n\n        Returning ``False`` does not guarantee that this widget will never be in\n        focus, only that this widget will usually be skipped over when changing\n        focus. It is still possible for non selectable widgets to have the focus\n        (typically when there are no other selectable widgets visible).\n        \"\"\"\n        return self._selectable\n\n    def sizing(self):\n        \"\"\"\n        :returns: A frozenset including one or more of ``'box'``, ``'flow'`` and\n                  ``'fixed'``.  Default implementation returns the value of\n                  :attr:`._sizing`, which for this class includes all three.\n\n        The sizing modes returned indicate the modes that may be\n        supported by this widget, but is not sufficient to know\n        that using that sizing mode will work.  Subclasses should\n        make an effort to remove sizing modes they know will not\n        work given the state of the widget, but many do not yet\n        do this.\n\n        If a sizing mode is missing from the set then the widget\n        should fail when used in that mode.\n\n        If ``'flow'`` is among the values returned then the other\n        methods in this widget must be able to accept a\n        single-element tuple (*maxcol*,) to their ``size``\n        parameter, and the :meth:`rows` method must be defined.\n\n        If ``'box'`` is among the values returned then the other\n        methods must be able to accept a two-element tuple\n        (*maxcol*, *maxrow*) to their size parameter.\n\n        If ``'fixed'`` is among the values returned then the other\n        methods must be able to accept an empty tuple () to\n        their size parameter, and the :meth:`pack` method must\n        be defined.\n        \"\"\"\n        return self._sizing\n\n    def pack(self, size: tuple[()] | tuple[int] | tuple[int, int], focus: bool = False) -> tuple[int, int]:\n        \"\"\"\n        See :meth:`Widget.render` for parameter details.\n\n        :returns: A \"packed\" size (*maxcol*, *maxrow*) for this widget\n\n        Calculate and return a minimum\n        size where all content could still be displayed. Fixed widgets must\n        implement this method and return their size when ``()`` is passed as the\n        *size* parameter.\n\n        This default implementation returns the *size* passed, or the *maxcol*\n        passed and the value of :meth:`rows` as the *maxrow* when (*maxcol*,)\n        is passed as the *size* parameter.\n\n        .. note::\n\n           This is a new method that hasn't been fully implemented across the\n           standard widget types. In particular it has not yet been\n           implemented for container widgets.\n\n        :class:`Text` widgets have implemented this method.\n        You can use :meth:`Text.pack` to calculate the minimum\n        columns and rows required to display a text widget without wrapping,\n        or call it iteratively to calculate the minimum number of columns\n        required to display the text wrapped into a target number of rows.\n        \"\"\"\n        if not size:\n            if Sizing.FIXED in self.sizing():\n                raise NotImplementedError(\"Fixed widgets must override Widget.pack()\")\n            raise WidgetError(f\"Cannot pack () size, this is not a fixed widget: {self!r}\")\n\n        if len(size) == 1:\n            if Sizing.FLOW in self.sizing():\n                return (*size, self.rows(size, focus))\n\n            raise WidgetError(f\"Cannot pack (maxcol,) size, this is not a flow widget: {self!r}\")\n\n        return size\n\n    @property\n    def base_widget(self) -> Widget:\n        \"\"\"\n        Read-only property that steps through decoration widgets\n        and returns the one at the base.  This default implementation\n        returns self.\n        \"\"\"\n        return self\n\n    @property\n    def focus(self) -> Widget | None:\n        \"\"\"\n        Read-only property returning the child widget in focus for\n        container widgets.  This default implementation\n        always returns ``None``, indicating that this widget has no children.\n        \"\"\"\n        return None\n\n    def _not_a_container(self, val=None):\n        raise IndexError(f\"No focus_position, {self!r} is not a container widget\")\n\n    focus_position = property(\n        _not_a_container,\n        _not_a_container,\n        doc=\"\"\"\n        Property for reading and setting the focus position for\n        container widgets. This default implementation raises\n        :exc:`IndexError`, making normal widgets fail the same way\n        accessing :attr:`.focus_position` on an empty container widget would.\n        \"\"\",\n    )\n\n    def __repr__(self):\n        \"\"\"\n        A friendly __repr__ for widgets, designed to be extended\n        by subclasses with _repr_words and _repr_attr methods.\n        \"\"\"\n        return split_repr(self)\n\n    def _repr_words(self):\n        words = []\n        if self.selectable():\n            words = [\"selectable\", *words]\n        if self.sizing() and self.sizing() != frozenset([Sizing.FLOW, Sizing.BOX, Sizing.FIXED]):\n            words.append(\"/\".join(sorted(self.sizing())))\n        return [*words, \"widget\"]\n\n    def _repr_attrs(self):\n        return {}",
  "class FlowWidget(Widget):\n    \"\"\"\n    Deprecated.  Inherit from Widget and add:\n\n        _sizing = frozenset(['flow'])\n\n    at the top of your class definition instead.\n\n    Base class of widgets that determine their rows from the number of\n    columns available.\n    \"\"\"\n\n    _sizing = frozenset([Sizing.FLOW])\n\n    def __init__(self, *args, **kwargs):\n        warnings.warn(\n            \"\"\"\n            FlowWidget is deprecated. Inherit from Widget and add:\n\n                _sizing = frozenset(['flow'])\n\n            at the top of your class definition instead.\"\"\",\n            DeprecationWarning,\n            stacklevel=3,\n        )\n\n    def rows(self, size: int, focus: bool = False) -> int:\n        \"\"\"\n        All flow widgets must implement this function.\n        \"\"\"\n        raise NotImplementedError()\n\n    def render(self, size: tuple[int], focus: bool = False):\n        \"\"\"\n        All widgets must implement this function.\n        \"\"\"\n        raise NotImplementedError()",
  "class BoxWidget(Widget):\n    \"\"\"\n    Deprecated.  Inherit from Widget and add:\n\n        _sizing = frozenset(['box'])\n        _selectable = True\n\n    at the top of your class definition instead.\n\n    Base class of width and height constrained widgets such as\n    the top level widget attached to the display object\n    \"\"\"\n\n    _selectable = True\n    _sizing = frozenset([Sizing.BOX])\n\n    def __init__(self, *args, **kwargs):\n        warnings.warn(\n            \"\"\"\n            BoxWidget is deprecated. Inherit from Widget and add:\n\n                _sizing = frozenset(['box'])\n                _selectable = True\n\n            at the top of your class definition instead.\"\"\",\n            DeprecationWarning,\n            stacklevel=3,\n        )\n\n    def render(self, size: tuple[int, int], focus: bool = False):\n        \"\"\"\n        All widgets must implement this function.\n        \"\"\"\n        raise NotImplementedError()",
  "def fixed_size(size):\n    \"\"\"\n    raise ValueError if size != ().\n\n    Used by FixedWidgets to test size parameter.\n    \"\"\"\n    if size != ():\n        raise ValueError(f\"FixedWidget takes only () for size.passed: {size!r}\")",
  "class FixedWidget(Widget):\n    \"\"\"\n    Deprecated.  Inherit from Widget and add:\n\n        _sizing = frozenset(['fixed'])\n\n    at the top of your class definition instead.\n\n    Base class of widgets that know their width and height and\n    cannot be resized\n    \"\"\"\n\n    _sizing = frozenset([Sizing.FIXED])\n\n    def __init__(self, *args, **kwargs):\n        warnings.warn(\n            \"\"\"\n            FixedWidget is deprecated. Inherit from Widget and add:\n\n                _sizing = frozenset(['fixed'])\n\n            at the top of your class definition instead.\"\"\",\n            DeprecationWarning,\n            stacklevel=3,\n        )\n\n    def render(self, size, focus=False):\n        \"\"\"\n        All widgets must implement this function.\n        \"\"\"\n        raise NotImplementedError()\n\n    def pack(self, size=None, focus=False):\n        \"\"\"\n        All fixed widgets must implement this function.\n        \"\"\"\n        raise NotImplementedError()",
  "def delegate_to_widget_mixin(attribute_name: str):\n    \"\"\"\n    Return a mixin class that delegates all standard widget methods\n    to an attribute given by attribute_name.\n\n    This mixin is designed to be used as a superclass of another widget.\n    \"\"\"\n    # FIXME: this is so common, let's add proper support for it\n    # when layout and rendering are separated\n\n    get_delegate = attrgetter(attribute_name)\n\n    class DelegateToWidgetMixin(Widget):\n        no_cache: typing.ClassVar[list[str]] = [\"rows\"]  # crufty metaclass work-around\n\n        def render(self, size, focus: bool = False) -> CompositeCanvas:\n            canv = get_delegate(self).render(size, focus=focus)\n            return CompositeCanvas(canv)\n\n        @property\n        def selectable(self) -> Callable[[], bool]:\n            return get_delegate(self).selectable\n\n        @property\n        def get_cursor_coords(self):\n            return get_delegate(self).get_cursor_coords\n\n        @property\n        def get_pref_col(self):\n            return get_delegate(self).get_pref_col\n\n        @property\n        def keypress(self):\n            return get_delegate(self).keypress\n\n        @property\n        def move_cursor_to_coords(self):\n            return get_delegate(self).move_cursor_to_coords\n\n        @property\n        def rows(self):\n            return get_delegate(self).rows\n\n        @property\n        def mouse_event(\n            self,\n        ) -> Callable[[tuple[()] | tuple[int] | tuple[int, int], str, int, int, int, bool], bool | None,]:\n            return get_delegate(self).mouse_event\n\n        @property\n        def sizing(self):\n            return get_delegate(self).sizing\n\n        @property\n        def pack(self):\n            return get_delegate(self).pack\n\n    return DelegateToWidgetMixin",
  "class WidgetWrapError(Exception):\n    pass",
  "class WidgetWrap(delegate_to_widget_mixin(\"_wrapped_widget\"), Widget):\n    def __init__(self, w: Widget):\n        \"\"\"\n        w -- widget to wrap, stored as self._w\n\n        This object will pass the functions defined in Widget interface\n        definition to self._w.\n\n        The purpose of this widget is to provide a base class for\n        widgets that compose other widgets for their display and\n        behaviour.  The details of that composition should not affect\n        users of the subclass.  The subclass may decide to expose some\n        of the wrapped widgets by behaving like a ContainerWidget or\n        WidgetDecoration, or it may hide them from outside access.\n        \"\"\"\n        self._wrapped_widget = w\n\n    @property\n    def _w(self) -> Widget:\n        return self._wrapped_widget\n\n    @_w.setter\n    def _w(self, new_widget: Widget) -> None:\n        \"\"\"\n        Change the wrapped widget.  This is meant to be called\n        only by subclasses.\n\n        >>> size = (10,)\n        >>> ww = WidgetWrap(Edit(\"hello? \",\"hi\"))\n        >>> ww.render(size).text # ... = b in Python 3\n        [...'hello? hi ']\n        >>> ww.selectable()\n        True\n        >>> ww._w = Text(\"goodbye\") # calls _set_w()\n        >>> ww.render(size).text\n        [...'goodbye   ']\n        >>> ww.selectable()\n        False\n        \"\"\"\n        self._wrapped_widget = new_widget\n        self._invalidate()\n\n    def _set_w(self, w):\n        \"\"\"\n        Change the wrapped widget.  This is meant to be called\n        only by subclasses.\n        >>> from urwid import Edit, Text\n        >>> size = (10,)\n        >>> ww = WidgetWrap(Edit(\"hello? \",\"hi\"))\n        >>> ww.render(size).text # ... = b in Python 3\n        [...'hello? hi ']\n        >>> ww.selectable()\n        True\n        >>> ww._w = Text(\"goodbye\") # calls _set_w()\n        >>> ww.render(size).text\n        [...'goodbye   ']\n        >>> ww.selectable()\n        False\n        \"\"\"\n        warnings.warn(\n            \"_set_w is deprecated. Please use 'WidgetWrap._w' property directly\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        self._wrapped_widget = w\n        self._invalidate()",
  "def _test():\n    import doctest\n\n    doctest.testmod()",
  "def __init__(cls, name, bases, d):\n        no_cache = d.get(\"no_cache\", [])\n\n        super().__init__(name, bases, d)\n\n        if \"render\" in d:\n            if \"render\" not in no_cache:\n                render_fn = cache_widget_render(cls)\n            else:\n                render_fn = nocache_widget_render(cls)\n            cls.render = render_fn\n\n        if \"rows\" in d and \"rows\" not in no_cache:\n            cls.rows = cache_widget_rows(cls)\n        if \"no_cache\" in d:\n            del cls.no_cache\n        if \"ignore_focus\" in d:\n            del cls.ignore_focus",
  "def cached_render(self, size, focus=False):\n        focus = focus and not ignore_focus\n        canv = CanvasCache.fetch(self, cls, size, focus)\n        if canv:\n            return canv\n\n        canv = fn(self, size, focus=focus)\n        validate_size(self, size, canv)\n        if canv.widget_info:\n            canv = CompositeCanvas(canv)\n        canv.finalize(self, size, focus)\n        CanvasCache.store(cls, canv)\n        return canv",
  "def finalize_render(self, size, focus=False):\n        canv = fn(self, size, focus=focus)\n        if canv.widget_info:\n            canv = CompositeCanvas(canv)\n        validate_size(self, size, canv)\n        canv.finalize(self, size, focus)\n        return canv",
  "def finalize_render(size, focus=False):\n        canv = fn(self, size, focus=focus)\n        if canv.widget_info:\n            canv = CompositeCanvas(canv)\n        canv.finalize(self, size, focus)\n        return canv",
  "def cached_rows(self, size, focus=False):\n        focus = focus and not ignore_focus\n        canv = CanvasCache.fetch(self, cls, size, focus)\n        if canv:\n            return canv.rows()\n\n        return fn(self, size, focus)",
  "def _invalidate(self) -> None:\n        \"\"\"\n        Mark cached canvases rendered by this widget as dirty so that\n        they will not be used again.\n        \"\"\"\n        CanvasCache.invalidate(self)",
  "def _emit(self, name: str, *args):\n        \"\"\"\n        Convenience function to emit signals with self as first\n        argument.\n        \"\"\"\n        signals.emit_signal(self, name, self, *args)",
  "def selectable(self):\n        \"\"\"\n        :returns: ``True`` if this is a widget that is designed to take the\n                  focus, i.e. it contains something the user might want to\n                  interact with, ``False`` otherwise,\n\n        This default implementation returns :attr:`._selectable`.\n        Subclasses may leave these is if the are not selectable,\n        or if they are always selectable they may\n        set the :attr:`_selectable` class variable to ``True``.\n\n        If this method returns ``True`` then the :meth:`.keypress` method\n        must be implemented.\n\n        Returning ``False`` does not guarantee that this widget will never be in\n        focus, only that this widget will usually be skipped over when changing\n        focus. It is still possible for non selectable widgets to have the focus\n        (typically when there are no other selectable widgets visible).\n        \"\"\"\n        return self._selectable",
  "def sizing(self):\n        \"\"\"\n        :returns: A frozenset including one or more of ``'box'``, ``'flow'`` and\n                  ``'fixed'``.  Default implementation returns the value of\n                  :attr:`._sizing`, which for this class includes all three.\n\n        The sizing modes returned indicate the modes that may be\n        supported by this widget, but is not sufficient to know\n        that using that sizing mode will work.  Subclasses should\n        make an effort to remove sizing modes they know will not\n        work given the state of the widget, but many do not yet\n        do this.\n\n        If a sizing mode is missing from the set then the widget\n        should fail when used in that mode.\n\n        If ``'flow'`` is among the values returned then the other\n        methods in this widget must be able to accept a\n        single-element tuple (*maxcol*,) to their ``size``\n        parameter, and the :meth:`rows` method must be defined.\n\n        If ``'box'`` is among the values returned then the other\n        methods must be able to accept a two-element tuple\n        (*maxcol*, *maxrow*) to their size parameter.\n\n        If ``'fixed'`` is among the values returned then the other\n        methods must be able to accept an empty tuple () to\n        their size parameter, and the :meth:`pack` method must\n        be defined.\n        \"\"\"\n        return self._sizing",
  "def pack(self, size: tuple[()] | tuple[int] | tuple[int, int], focus: bool = False) -> tuple[int, int]:\n        \"\"\"\n        See :meth:`Widget.render` for parameter details.\n\n        :returns: A \"packed\" size (*maxcol*, *maxrow*) for this widget\n\n        Calculate and return a minimum\n        size where all content could still be displayed. Fixed widgets must\n        implement this method and return their size when ``()`` is passed as the\n        *size* parameter.\n\n        This default implementation returns the *size* passed, or the *maxcol*\n        passed and the value of :meth:`rows` as the *maxrow* when (*maxcol*,)\n        is passed as the *size* parameter.\n\n        .. note::\n\n           This is a new method that hasn't been fully implemented across the\n           standard widget types. In particular it has not yet been\n           implemented for container widgets.\n\n        :class:`Text` widgets have implemented this method.\n        You can use :meth:`Text.pack` to calculate the minimum\n        columns and rows required to display a text widget without wrapping,\n        or call it iteratively to calculate the minimum number of columns\n        required to display the text wrapped into a target number of rows.\n        \"\"\"\n        if not size:\n            if Sizing.FIXED in self.sizing():\n                raise NotImplementedError(\"Fixed widgets must override Widget.pack()\")\n            raise WidgetError(f\"Cannot pack () size, this is not a fixed widget: {self!r}\")\n\n        if len(size) == 1:\n            if Sizing.FLOW in self.sizing():\n                return (*size, self.rows(size, focus))\n\n            raise WidgetError(f\"Cannot pack (maxcol,) size, this is not a flow widget: {self!r}\")\n\n        return size",
  "def base_widget(self) -> Widget:\n        \"\"\"\n        Read-only property that steps through decoration widgets\n        and returns the one at the base.  This default implementation\n        returns self.\n        \"\"\"\n        return self",
  "def focus(self) -> Widget | None:\n        \"\"\"\n        Read-only property returning the child widget in focus for\n        container widgets.  This default implementation\n        always returns ``None``, indicating that this widget has no children.\n        \"\"\"\n        return None",
  "def _not_a_container(self, val=None):\n        raise IndexError(f\"No focus_position, {self!r} is not a container widget\")",
  "def __repr__(self):\n        \"\"\"\n        A friendly __repr__ for widgets, designed to be extended\n        by subclasses with _repr_words and _repr_attr methods.\n        \"\"\"\n        return split_repr(self)",
  "def _repr_words(self):\n        words = []\n        if self.selectable():\n            words = [\"selectable\", *words]\n        if self.sizing() and self.sizing() != frozenset([Sizing.FLOW, Sizing.BOX, Sizing.FIXED]):\n            words.append(\"/\".join(sorted(self.sizing())))\n        return [*words, \"widget\"]",
  "def _repr_attrs(self):\n        return {}",
  "def __init__(self, *args, **kwargs):\n        warnings.warn(\n            \"\"\"\n            FlowWidget is deprecated. Inherit from Widget and add:\n\n                _sizing = frozenset(['flow'])\n\n            at the top of your class definition instead.\"\"\",\n            DeprecationWarning,\n            stacklevel=3,\n        )",
  "def rows(self, size: int, focus: bool = False) -> int:\n        \"\"\"\n        All flow widgets must implement this function.\n        \"\"\"\n        raise NotImplementedError()",
  "def render(self, size: tuple[int], focus: bool = False):\n        \"\"\"\n        All widgets must implement this function.\n        \"\"\"\n        raise NotImplementedError()",
  "def __init__(self, *args, **kwargs):\n        warnings.warn(\n            \"\"\"\n            BoxWidget is deprecated. Inherit from Widget and add:\n\n                _sizing = frozenset(['box'])\n                _selectable = True\n\n            at the top of your class definition instead.\"\"\",\n            DeprecationWarning,\n            stacklevel=3,\n        )",
  "def render(self, size: tuple[int, int], focus: bool = False):\n        \"\"\"\n        All widgets must implement this function.\n        \"\"\"\n        raise NotImplementedError()",
  "def __init__(self, *args, **kwargs):\n        warnings.warn(\n            \"\"\"\n            FixedWidget is deprecated. Inherit from Widget and add:\n\n                _sizing = frozenset(['fixed'])\n\n            at the top of your class definition instead.\"\"\",\n            DeprecationWarning,\n            stacklevel=3,\n        )",
  "def render(self, size, focus=False):\n        \"\"\"\n        All widgets must implement this function.\n        \"\"\"\n        raise NotImplementedError()",
  "def pack(self, size=None, focus=False):\n        \"\"\"\n        All fixed widgets must implement this function.\n        \"\"\"\n        raise NotImplementedError()",
  "class DelegateToWidgetMixin(Widget):\n        no_cache: typing.ClassVar[list[str]] = [\"rows\"]  # crufty metaclass work-around\n\n        def render(self, size, focus: bool = False) -> CompositeCanvas:\n            canv = get_delegate(self).render(size, focus=focus)\n            return CompositeCanvas(canv)\n\n        @property\n        def selectable(self) -> Callable[[], bool]:\n            return get_delegate(self).selectable\n\n        @property\n        def get_cursor_coords(self):\n            return get_delegate(self).get_cursor_coords\n\n        @property\n        def get_pref_col(self):\n            return get_delegate(self).get_pref_col\n\n        @property\n        def keypress(self):\n            return get_delegate(self).keypress\n\n        @property\n        def move_cursor_to_coords(self):\n            return get_delegate(self).move_cursor_to_coords\n\n        @property\n        def rows(self):\n            return get_delegate(self).rows\n\n        @property\n        def mouse_event(\n            self,\n        ) -> Callable[[tuple[()] | tuple[int] | tuple[int, int], str, int, int, int, bool], bool | None,]:\n            return get_delegate(self).mouse_event\n\n        @property\n        def sizing(self):\n            return get_delegate(self).sizing\n\n        @property\n        def pack(self):\n            return get_delegate(self).pack",
  "def __init__(self, w: Widget):\n        \"\"\"\n        w -- widget to wrap, stored as self._w\n\n        This object will pass the functions defined in Widget interface\n        definition to self._w.\n\n        The purpose of this widget is to provide a base class for\n        widgets that compose other widgets for their display and\n        behaviour.  The details of that composition should not affect\n        users of the subclass.  The subclass may decide to expose some\n        of the wrapped widgets by behaving like a ContainerWidget or\n        WidgetDecoration, or it may hide them from outside access.\n        \"\"\"\n        self._wrapped_widget = w",
  "def _w(self) -> Widget:\n        return self._wrapped_widget",
  "def _w(self, new_widget: Widget) -> None:\n        \"\"\"\n        Change the wrapped widget.  This is meant to be called\n        only by subclasses.\n\n        >>> size = (10,)\n        >>> ww = WidgetWrap(Edit(\"hello? \",\"hi\"))\n        >>> ww.render(size).text # ... = b in Python 3\n        [...'hello? hi ']\n        >>> ww.selectable()\n        True\n        >>> ww._w = Text(\"goodbye\") # calls _set_w()\n        >>> ww.render(size).text\n        [...'goodbye   ']\n        >>> ww.selectable()\n        False\n        \"\"\"\n        self._wrapped_widget = new_widget\n        self._invalidate()",
  "def _set_w(self, w):\n        \"\"\"\n        Change the wrapped widget.  This is meant to be called\n        only by subclasses.\n        >>> from urwid import Edit, Text\n        >>> size = (10,)\n        >>> ww = WidgetWrap(Edit(\"hello? \",\"hi\"))\n        >>> ww.render(size).text # ... = b in Python 3\n        [...'hello? hi ']\n        >>> ww.selectable()\n        True\n        >>> ww._w = Text(\"goodbye\") # calls _set_w()\n        >>> ww.render(size).text\n        [...'goodbye   ']\n        >>> ww.selectable()\n        False\n        \"\"\"\n        warnings.warn(\n            \"_set_w is deprecated. Please use 'WidgetWrap._w' property directly\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        self._wrapped_widget = w\n        self._invalidate()",
  "def render(self, size, focus: bool = False) -> CompositeCanvas:\n            canv = get_delegate(self).render(size, focus=focus)\n            return CompositeCanvas(canv)",
  "def selectable(self) -> Callable[[], bool]:\n            return get_delegate(self).selectable",
  "def get_cursor_coords(self):\n            return get_delegate(self).get_cursor_coords",
  "def get_pref_col(self):\n            return get_delegate(self).get_pref_col",
  "def keypress(self):\n            return get_delegate(self).keypress",
  "def move_cursor_to_coords(self):\n            return get_delegate(self).move_cursor_to_coords",
  "def rows(self):\n            return get_delegate(self).rows",
  "def mouse_event(\n            self,\n        ) -> Callable[[tuple[()] | tuple[int] | tuple[int, int], str, int, int, int, bool], bool | None,]:\n            return get_delegate(self).mouse_event",
  "def sizing(self):\n            return get_delegate(self).sizing",
  "def pack(self):\n            return get_delegate(self).pack",
  "class Sizing(str, enum.Enum):\n    \"\"\"Widget sizing methods.\"\"\"\n\n    FLOW = \"flow\"\n    BOX = \"box\"\n    FIXED = \"fixed\"",
  "class Align(str, enum.Enum):\n    \"\"\"Text alignment modes\"\"\"\n\n    LEFT = \"left\"\n    RIGHT = \"right\"\n    CENTER = \"center\"",
  "class VAlign(str, enum.Enum):\n    \"\"\"Filler alignment\"\"\"\n\n    TOP = \"top\"\n    MIDDLE = \"middle\"\n    BOTTOM = \"bottom\"",
  "class WrapMode(str, enum.Enum):\n    \"\"\"Text wrapping modes\"\"\"\n\n    SPACE = \"space\"\n    ANY = \"any\"\n    CLIP = \"clip\"\n    ELLIPSIS = \"ellipsis\"",
  "class WHSettings(str, enum.Enum):\n    \"\"\"Width and Height settings\"\"\"\n\n    PACK = \"pack\"\n    GIVEN = \"given\"\n    RELATIVE = \"relative\"\n    WEIGHT = \"weight\"\n    CLIP = WrapMode.CLIP  # Used as \"given\" for widgets with fixed width (with clipping part of it)\n    FLOW = Sizing.FLOW",
  "def normalize_align(\n    align: Literal[\"left\", \"center\", \"right\"] | Align,\n    err: type[BaseException],\n) -> tuple[Align, None]:\n    ...",
  "def normalize_align(\n    align: tuple[Literal[\"relative\", WHSettings.RELATIVE], int],\n    err: type[BaseException],\n) -> tuple[Literal[WHSettings.RELATIVE], int]:\n    ...",
  "def normalize_align(\n    align: Literal[\"left\", \"center\", \"right\"] | Align | tuple[Literal[\"relative\", WHSettings.RELATIVE], int],\n    err: type[BaseException],\n) -> tuple[Align, None] | tuple[Literal[WHSettings.RELATIVE], int]:\n    \"\"\"\n    Split align into (align_type, align_amount).  Raise exception err\n    if align doesn't match a valid alignment.\n    \"\"\"\n    if align in (Align.LEFT, Align.CENTER, Align.RIGHT):\n        return (Align(align), None)\n\n    if isinstance(align, tuple) and len(align) == 2 and align[0] == WHSettings.RELATIVE:\n        align_type, align_amount = align\n        return (WHSettings(align_type), align_amount)\n\n    raise err(\n        f\"align value {align!r} is not one of 'left', 'center', 'right', ('relative', percentage 0=left 100=right)\"\n    )",
  "def simplify_align(\n    align_type: Literal[\"relative\", WHSettings.RELATIVE],\n    align_amount: int,\n) -> tuple[Literal[WHSettings.RELATIVE], int]:\n    ...",
  "def simplify_align(\n    align_type: Literal[\"relative\", WHSettings.RELATIVE],\n    align_amount: None,\n) -> typing.NoReturn:\n    ...",
  "def simplify_align(\n    align_type: Literal[\"left\", \"center\", \"right\"] | Align,\n    align_amount: int | None,\n) -> Align:\n    ...",
  "def simplify_align(\n    align_type: Literal[\"left\", \"center\", \"right\", \"relative\", WHSettings.RELATIVE] | Align,\n    align_amount: int | None,\n) -> Align | tuple[Literal[WHSettings.RELATIVE], int]:\n    \"\"\"\n    Recombine (align_type, align_amount) into an align value.\n    Inverse of normalize_align.\n    \"\"\"\n    if align_type == WHSettings.RELATIVE:\n        if not isinstance(align_amount, int):\n            raise TypeError(align_amount)\n\n        return (WHSettings(align_type), align_amount)\n    return Align(align_type)",
  "def normalize_valign(\n    valign: Literal[\"top\", \"middle\", \"bottom\"] | VAlign,\n    err: type[BaseException],\n) -> tuple[VAlign, None]:\n    ...",
  "def normalize_valign(\n    valign: tuple[Literal[\"relative\", WHSettings.RELATIVE], int],\n    err: type[BaseException],\n) -> tuple[Literal[WHSettings.RELATIVE], int]:\n    ...",
  "def normalize_valign(\n    valign: Literal[\"top\", \"middle\", \"bottom\"] | VAlign | tuple[Literal[\"relative\", WHSettings.RELATIVE], int],\n    err: type[BaseException],\n) -> tuple[VAlign, None] | tuple[Literal[WHSettings.RELATIVE], int]:\n    \"\"\"\n    Split align into (valign_type, valign_amount).  Raise exception err\n    if align doesn't match a valid alignment.\n    \"\"\"\n    if valign in (VAlign.TOP, VAlign.MIDDLE, VAlign.BOTTOM):\n        return (VAlign(valign), None)\n\n    if isinstance(valign, tuple) and len(valign) == 2 and valign[0] == WHSettings.RELATIVE:\n        valign_type, valign_amount = valign\n        return (WHSettings(valign_type), valign_amount)\n\n    raise err(\n        f\"valign value {valign!r} is not one of 'top', 'middle', 'bottom', ('relative', percentage 0=left 100=right)\"\n    )",
  "def simplify_valign(\n    valign_type: Literal[\"top\", \"middle\", \"bottom\"] | VAlign,\n    valign_amount: int | None,\n) -> VAlign:\n    ...",
  "def simplify_valign(\n    valign_type: Literal[\"relative\", WHSettings.RELATIVE],\n    valign_amount: int,\n) -> tuple[Literal[WHSettings.RELATIVE], int]:\n    ...",
  "def simplify_valign(\n    valign_type: Literal[\"relative\", WHSettings.RELATIVE],\n    valign_amount: None,\n) -> typing.NoReturn:\n    ...",
  "def simplify_valign(\n    valign_type: Literal[\"top\", \"middle\", \"bottom\", \"relative\", WHSettings.RELATIVE] | VAlign,\n    valign_amount: int | None,\n) -> VAlign | tuple[Literal[WHSettings.RELATIVE], int]:\n    \"\"\"\n    Recombine (valign_type, valign_amount) into an valign value.\n    Inverse of normalize_valign.\n    \"\"\"\n    if valign_type == WHSettings.RELATIVE:\n        if not isinstance(valign_amount, int):\n            raise TypeError(valign_amount)\n        return (WHSettings(valign_type), valign_amount)\n    return VAlign(valign_type)",
  "def normalize_width(\n    width: (Literal[\"clip\", \"pack\", WHSettings.CLIP, WHSettings.PACK]),\n    err: type[BaseException],\n) -> tuple[Literal[WHSettings.CLIP, WHSettings.PACK], None]:\n    ...",
  "def normalize_width(\n    width: int,\n    err: type[BaseException],\n) -> tuple[Literal[WHSettings.GIVEN], int]:\n    ...",
  "def normalize_width(\n    width: (tuple[Literal[\"relative\", WHSettings.RELATIVE], int]),\n    err: type[BaseException],\n) -> tuple[Literal[WHSettings.RELATIVE], int]:\n    ...",
  "def normalize_width(\n    width: (tuple[Literal[\"weight\", WHSettings.WEIGHT], int]),\n    err: type[BaseException],\n) -> tuple[Literal[WHSettings.WEIGHT], int]:\n    ...",
  "def normalize_width(\n    width: (\n        Literal[\"clip\", \"pack\", WHSettings.CLIP, WHSettings.PACK]\n        | int\n        | tuple[Literal[\"relative\", \"weight\", WHSettings.RELATIVE, WHSettings.WEIGHT], int]\n    ),\n    err: type[BaseException],\n) -> (\n    tuple[Literal[WHSettings.CLIP, WHSettings.PACK], None]\n    | tuple[Literal[WHSettings.GIVEN, WHSettings.RELATIVE, WHSettings.WEIGHT], int]\n):\n    \"\"\"\n    Split width into (width_type, width_amount).  Raise exception err\n    if width doesn't match a valid alignment.\n    \"\"\"\n    if width in (WHSettings.CLIP, WHSettings.PACK):\n        return (WHSettings(width), None)\n\n    if isinstance(width, int):\n        return (WHSettings.GIVEN, width)\n\n    if isinstance(width, tuple) and len(width) == 2 and width[0] in (WHSettings.RELATIVE, WHSettings.WEIGHT):\n        width_type, width_amount = width\n        return (WHSettings(width_type), width_amount)\n\n    raise err(\n        f\"width value {width!r} is not one of\"\n        f\"fixed number of columns, 'pack', ('relative', percentage of total width), 'clip'\"\n    )",
  "def simplify_width(\n    width_type: Literal[\"clip\", \"pack\", WHSettings.CLIP, WHSettings.PACK],\n    width_amount: int | None,\n) -> Literal[WHSettings.CLIP, WHSettings.PACK]:\n    ...",
  "def simplify_width(\n    width_type: Literal[\"given\", WHSettings.GIVEN],\n    width_amount: int,\n) -> int:\n    ...",
  "def simplify_width(\n    width_type: Literal[\"relative\", WHSettings.RELATIVE],\n    width_amount: int,\n) -> tuple[Literal[WHSettings.RELATIVE], int]:\n    ...",
  "def simplify_width(\n    width_type: Literal[\"weight\", WHSettings.WEIGHT],\n    width_amount: int,\n) -> tuple[Literal[WHSettings.WEIGHT], int]:\n    ...",
  "def simplify_width(\n    width_type: Literal[\"given\", \"relative\", \"weight\", WHSettings.GIVEN, WHSettings.RELATIVE, WHSettings.WEIGHT],\n    width_amount: None,\n) -> typing.NoReturn:\n    ...",
  "def simplify_width(\n    width_type: Literal[\"clip\", \"pack\", \"given\", \"relative\", \"weight\"] | WHSettings,\n    width_amount: int | None,\n) -> Literal[WHSettings.CLIP, WHSettings.PACK] | int | tuple[Literal[WHSettings.RELATIVE, WHSettings.WEIGHT], int]:\n    \"\"\"\n    Recombine (width_type, width_amount) into an width value.\n    Inverse of normalize_width.\n    \"\"\"\n    if width_type in (WHSettings.CLIP, WHSettings.PACK):\n        return WHSettings(width_type)\n\n    if not isinstance(width_amount, int):\n        raise TypeError(width_amount)\n\n    if width_type == WHSettings.GIVEN:\n        return width_amount\n\n    return (WHSettings(width_type), width_amount)",
  "def normalize_height(\n    height: (int),\n    err: type[BaseException],\n) -> tuple[Literal[WHSettings.GIVEN], int]:\n    ...",
  "def normalize_height(\n    height: (Literal[\"flow\", \"pack\", Sizing.FLOW, WHSettings.PACK]),\n    err: type[BaseException],\n) -> tuple[Literal[Sizing.FLOW, WHSettings.PACK], None]:\n    ...",
  "def normalize_height(\n    height: (tuple[Literal[\"relative\", WHSettings.RELATIVE], int]),\n    err: type[BaseException],\n) -> tuple[Literal[WHSettings.RELATIVE], int]:\n    ...",
  "def normalize_height(\n    height: (tuple[Literal[\"weight\", WHSettings.WEIGHT], int]),\n    err: type[BaseException],\n) -> tuple[Literal[WHSettings.WEIGHT], int]:\n    ...",
  "def normalize_height(\n    height: (\n        int\n        | Literal[\"flow\", \"pack\", Sizing.FLOW, WHSettings.PACK]\n        | tuple[Literal[\"relative\", \"weight\", WHSettings.RELATIVE, WHSettings.WEIGHT], int]\n    ),\n    err: type[BaseException],\n) -> (\n    tuple[Literal[Sizing.FLOW, WHSettings.PACK], None]\n    | tuple[Literal[WHSettings.RELATIVE, WHSettings.GIVEN, WHSettings.WEIGHT], int]\n):\n    \"\"\"\n    Split height into (height_type, height_amount).  Raise exception err\n    if height isn't valid.\n    \"\"\"\n    if height == Sizing.FLOW:\n        return (Sizing.FLOW, None)\n\n    if height == WHSettings.PACK:\n        return (WHSettings.PACK, None)\n\n    if isinstance(height, tuple) and len(height) == 2 and height[0] in (WHSettings.RELATIVE, WHSettings.WEIGHT):\n        return (WHSettings(height[0]), height[1])\n\n    if isinstance(height, int):\n        return (WHSettings.GIVEN, height)\n\n    raise err(\n        f\"height value {height!r} is not one of \"\n        f\"fixed number of columns, 'pack', ('relative', percentage of total height)\"\n    )",
  "def simplify_height(\n    height_type: Literal[\"flow\", \"pack\", WHSettings.FLOW, WHSettings.PACK],\n    height_amount: int | None,\n) -> Literal[WHSettings.FLOW, WHSettings.PACK]:\n    ...",
  "def simplify_height(\n    height_type: Literal[\"given\", WHSettings.GIVEN],\n    height_amount: int,\n) -> int:\n    ...",
  "def simplify_height(\n    height_type: Literal[\"relative\", WHSettings.RELATIVE],\n    height_amount: int | None,\n) -> tuple[Literal[WHSettings.RELATIVE], int]:\n    ...",
  "def simplify_height(\n    height_type: Literal[\"weight\", WHSettings.WEIGHT],\n    height_amount: int | None,\n) -> tuple[Literal[WHSettings.WEIGHT], int]:\n    ...",
  "def simplify_height(\n    height_type: Literal[\"relative\", \"given\", \"weight\", WHSettings.RELATIVE, WHSettings.GIVEN, WHSettings.WEIGHT],\n    height_amount: None,\n) -> typing.NoReturn:\n    ...",
  "def simplify_height(\n    height_type: Literal[\n        \"flow\",\n        \"pack\",\n        \"relative\",\n        \"given\",\n        \"weight\",\n        WHSettings.FLOW,\n        WHSettings.PACK,\n        WHSettings.RELATIVE,\n        WHSettings.GIVEN,\n        WHSettings.WEIGHT,\n    ],\n    height_amount: int | None,\n) -> int | Literal[WHSettings.FLOW, WHSettings.PACK] | tuple[Literal[WHSettings.RELATIVE, WHSettings.WEIGHT], int]:\n    \"\"\"\n    Recombine (height_type, height_amount) into a height value.\n    Inverse of normalize_height.\n    \"\"\"\n    if height_type in (WHSettings.FLOW, WHSettings.PACK):\n        return WHSettings(height_type)\n\n    if not isinstance(height_amount, int):\n        raise TypeError(height_amount)\n\n    if height_type == WHSettings.GIVEN:\n        return height_amount\n\n    return (WHSettings(height_type), height_amount)",
  "class EditError(TextError):\n    pass",
  "class Edit(Text):\n    \"\"\"\n    Text editing widget implements cursor movement, text insertion and\n    deletion.  A caption may prefix the editing area.  Uses text class\n    for text layout.\n\n    Users of this class may listen for ``\"change\"`` or ``\"postchange\"``\n    events.  See :func:``connect_signal``.\n\n    * ``\"change\"`` is sent just before the value of edit_text changes.\n      It receives the new text as an argument.  Note that ``\"change\"`` cannot\n      change the text in question as edit_text changes the text afterwards.\n    * ``\"postchange\"`` is sent after the value of edit_text changes.\n      It receives the old value of the text as an argument and thus is\n      appropriate for changing the text.  It is possible for a ``\"postchange\"``\n      event handler to get into a loop of changing the text and then being\n      called when the event is re-emitted.  It is up to the event\n      handler to guard against this case (for instance, by not changing the\n      text if it is signaled for for text that it has already changed once).\n    \"\"\"\n\n    _selectable = True\n    ignore_focus = False\n    # (this variable is picked up by the MetaSignals metaclass)\n    signals: typing.ClassVar[list[str]] = [\"change\", \"postchange\"]\n\n    def valid_char(self, ch: str) -> bool:\n        \"\"\"\n        Filter for text that may be entered into this widget by the user\n\n        :param ch: character to be inserted\n        :type ch: str\n\n        This implementation returns True for all printable characters.\n        \"\"\"\n        return is_wide_char(ch, 0) or (len(ch) == 1 and ord(ch) >= 32)\n\n    def __init__(\n        self,\n        caption=\"\",\n        edit_text: str | bytes = \"\",\n        multiline: bool = False,\n        align: Literal[\"left\", \"center\", \"right\"] | Align = Align.LEFT,\n        wrap: Literal[\"space\", \"any\", \"clip\", \"ellipsis\"] | WrapMode = WrapMode.SPACE,\n        allow_tab: bool = False,\n        edit_pos: int | None = None,\n        layout=None,\n        mask: str | bytes | None = None,\n    ) -> None:\n        \"\"\"\n        :param caption: markup for caption preceding edit_text, see\n                        :class:`Text` for description of text markup.\n        :type caption: text markup\n        :param edit_text: initial text for editing, type (bytes or unicode)\n                          must match the text in the caption\n        :type edit_text: bytes or unicode\n        :param multiline: True: 'enter' inserts newline  False: return it\n        :type multiline: bool\n        :param align: typically 'left', 'center' or 'right'\n        :type align: text alignment mode\n        :param wrap: typically 'space', 'any' or 'clip'\n        :type wrap: text wrapping mode\n        :param allow_tab: True: 'tab' inserts 1-8 spaces  False: return it\n        :type allow_tab: bool\n        :param edit_pos: initial position for cursor, None:end of edit_text\n        :type edit_pos: int\n        :param layout: defaults to a shared :class:`StandardTextLayout` instance\n        :type layout: text layout instance\n        :param mask: hide text entered with this character, None:disable mask\n        :type mask: bytes or unicode\n\n        >>> Edit()\n        <Edit selectable flow widget '' edit_pos=0>\n        >>> Edit(u\"Y/n? \", u\"yes\")\n        <Edit selectable flow widget 'yes' caption='Y/n? ' edit_pos=3>\n        >>> Edit(u\"Name \", u\"Smith\", edit_pos=1)\n        <Edit selectable flow widget 'Smith' caption='Name ' edit_pos=1>\n        >>> Edit(u\"\", u\"3.14\", align='right')\n        <Edit selectable flow widget '3.14' align='right' edit_pos=4>\n        \"\"\"\n\n        super().__init__(\"\", align, wrap, layout)\n        self.multiline = multiline\n        self.allow_tab = allow_tab\n        self._edit_pos = 0\n        self.set_caption(caption)\n        self._edit_text = \"\"\n        self.set_edit_text(edit_text)\n        if edit_pos is None:\n            edit_pos = len(edit_text)\n        self.set_edit_pos(edit_pos)\n        self.set_mask(mask)\n        self._shift_view_to_cursor = False\n\n    def _repr_words(self) -> list[str]:\n        return (\n            super()._repr_words()[:-1]\n            + [repr(self._edit_text)]\n            + [f\"caption={self._caption!r}\"] * bool(self._caption)\n            + [\"multiline\"] * (self.multiline is True)\n        )\n\n    def _repr_attrs(self):\n        attrs = dict(super()._repr_attrs(), edit_pos=self._edit_pos)\n        return remove_defaults(attrs, Edit.__init__)\n\n    def get_text(self):\n        \"\"\"\n        Returns ``(text, display attributes)``. See :meth:`Text.get_text`\n        for details.\n\n        Text returned includes the caption and edit_text, possibly masked.\n\n        >>> Edit(u\"What? \",\"oh, nothing.\").get_text() # ... = u in Python 2\n        (...'What? oh, nothing.', [])\n        >>> Edit(('bright',u\"user@host:~$ \"),\"ls\").get_text()\n        (...'user@host:~$ ls', [('bright', 13)])\n        >>> Edit(u\"password:\", u\"seekrit\", mask=u\"*\").get_text()\n        (...'password:*******', [])\n        \"\"\"\n\n        if self._mask is None:\n            return self._caption + self._edit_text, self._attrib\n\n        return self._caption + (self._mask * len(self._edit_text)), self._attrib\n\n    def set_text(self, markup) -> None:\n        \"\"\"\n        Not supported by Edit widget.\n\n        >>> Edit().set_text(\"test\")\n        Traceback (most recent call last):\n        EditError: set_text() not supported.  Use set_caption() or set_edit_text() instead.\n        \"\"\"\n        # FIXME: this smells. reimplement Edit as a WidgetWrap subclass to\n        # clean this up\n\n        # hack to let Text.__init__() work\n        if not hasattr(self, \"_text\") and markup == \"\":\n            self._text = None\n            return\n\n        raise EditError(\"set_text() not supported.  Use set_caption() or set_edit_text() instead.\")\n\n    def get_pref_col(self, size: tuple[int]) -> int:\n        \"\"\"\n        Return the preferred column for the cursor, or the\n        current cursor x value.  May also return ``'left'`` or ``'right'``\n        to indicate the leftmost or rightmost column available.\n\n        This method is used internally and by other widgets when\n        moving the cursor up or down between widgets so that the\n        column selected is one that the user would expect.\n\n        >>> size = (10,)\n        >>> Edit().get_pref_col(size)\n        0\n        >>> e = Edit(u\"\", u\"word\")\n        >>> e.get_pref_col(size)\n        4\n        >>> e.keypress(size, 'left')\n        >>> e.get_pref_col(size)\n        3\n        >>> e.keypress(size, 'end')\n        >>> e.get_pref_col(size)\n        <Align.RIGHT: 'right'>\n        >>> e = Edit(u\"\", u\"2\\\\nwords\")\n        >>> e.keypress(size, 'left')\n        >>> e.keypress(size, 'up')\n        >>> e.get_pref_col(size)\n        4\n        >>> e.keypress(size, 'left')\n        >>> e.get_pref_col(size)\n        0\n        \"\"\"\n        (maxcol,) = size\n        pref_col, then_maxcol = self.pref_col_maxcol\n        if then_maxcol != maxcol:\n            return self.get_cursor_coords((maxcol,))[0]\n\n        return pref_col\n\n    def set_caption(self, caption) -> None:\n        \"\"\"\n        Set the caption markup for this widget.\n\n        :param caption: markup for caption preceding edit_text, see\n                        :meth:`Text.__init__` for description of text markup.\n\n        >>> e = Edit(\"\")\n        >>> e.set_caption(\"cap1\")\n        >>> print(e.caption)\n        cap1\n        >>> e.set_caption(('bold', \"cap2\"))\n        >>> print(e.caption)\n        cap2\n        >>> e.attrib\n        [('bold', 4)]\n        >>> e.caption = \"cap3\"  # not supported because caption stores text but set_caption() takes markup\n        Traceback (most recent call last):\n        AttributeError: can't set attribute\n        \"\"\"\n        self._caption, self._attrib = decompose_tagmarkup(caption)\n        self._invalidate()\n\n    @property\n    def caption(self) -> str:\n        \"\"\"\n        Read-only property returning the caption for this widget.\n        \"\"\"\n        return self._caption\n\n    def set_edit_pos(self, pos: int) -> None:\n        \"\"\"\n        Set the cursor position with a self.edit_text offset.\n        Clips pos to [0, len(edit_text)].\n\n        :param pos: cursor position\n        :type pos: int\n\n        >>> e = Edit(u\"\", u\"word\")\n        >>> e.edit_pos\n        4\n        >>> e.set_edit_pos(2)\n        >>> e.edit_pos\n        2\n        >>> e.edit_pos = -1  # Urwid 0.9.9 or later\n        >>> e.edit_pos\n        0\n        >>> e.edit_pos = 20\n        >>> e.edit_pos\n        4\n        \"\"\"\n        if pos < 0:\n            pos = 0\n        if pos > len(self._edit_text):\n            pos = len(self._edit_text)\n        self.highlight = None\n        self.pref_col_maxcol = None, None\n        self._edit_pos = pos\n        self._invalidate()\n\n    edit_pos = property(\n        lambda self: self._edit_pos,\n        set_edit_pos,\n        doc=\"\"\"\n        Property controlling the edit position for this widget.\n        \"\"\",\n    )\n\n    def set_mask(self, mask: str | bytes | None) -> None:\n        \"\"\"\n        Set the character for masking text away.\n\n        :param mask: hide text entered with this character, None:disable mask\n        :type mask: bytes or unicode\n        \"\"\"\n\n        self._mask = mask\n        self._invalidate()\n\n    def set_edit_text(self, text: str | bytes) -> None:\n        \"\"\"\n        Set the edit text for this widget.\n\n        :param text: text for editing, type (bytes or unicode)\n                     must match the text in the caption\n        :type text: bytes or unicode\n\n        >>> e = Edit()\n        >>> e.set_edit_text(u\"yes\")\n        >>> print(e.edit_text)\n        yes\n        >>> e\n        <Edit selectable flow widget 'yes' edit_pos=0>\n        >>> e.edit_text = u\"no\"  # Urwid 0.9.9 or later\n        >>> print(e.edit_text)\n        no\n        \"\"\"\n        text = self._normalize_to_caption(text)\n        self.highlight = None\n        self._emit(\"change\", text)\n        old_text = self._edit_text\n        self._edit_text = text\n        if self.edit_pos > len(text):\n            self.edit_pos = len(text)\n        self._emit(\"postchange\", old_text)\n        self._invalidate()\n\n    def get_edit_text(self) -> str:\n        \"\"\"\n        Return the edit text for this widget.\n\n        >>> e = Edit(u\"What? \", u\"oh, nothing.\")\n        >>> print(e.get_edit_text())\n        oh, nothing.\n        >>> print(e.edit_text)\n        oh, nothing.\n        \"\"\"\n        return self._edit_text\n\n    edit_text = property(\n        get_edit_text,\n        set_edit_text,\n        doc=\"\"\"\n        Property controlling the edit text for this widget.\n        \"\"\",\n    )\n\n    def insert_text(self, text: str | bytes) -> None:\n        \"\"\"\n        Insert text at the cursor position and update cursor.\n        This method is used by the keypress() method when inserting\n        one or more characters into edit_text.\n\n        :param text: text for inserting, type (bytes or unicode)\n                     must match the text in the caption\n        :type text: bytes or unicode\n\n        >>> e = Edit(u\"\", u\"42\")\n        >>> e.insert_text(u\".5\")\n        >>> e\n        <Edit selectable flow widget '42.5' edit_pos=4>\n        >>> e.set_edit_pos(2)\n        >>> e.insert_text(u\"a\")\n        >>> print(e.edit_text)\n        42a.5\n        \"\"\"\n        text = self._normalize_to_caption(text)\n        result_text, result_pos = self.insert_text_result(text)\n        self.set_edit_text(result_text)\n        self.set_edit_pos(result_pos)\n        self.highlight = None\n\n    def _normalize_to_caption(self, text: str | bytes) -> str | bytes:\n        \"\"\"\n        Return text converted to the same type as self.caption\n        (bytes or unicode)\n        \"\"\"\n        tu = isinstance(text, str)\n        cu = isinstance(self._caption, str)\n        if tu == cu:\n            return text\n        if tu:\n            return text.encode(\"ascii\")  # follow python2's implicit conversion\n        return text.decode(\"ascii\")\n\n    def insert_text_result(self, text: str | bytes) -> tuple[str | bytes, int]:\n        \"\"\"\n        Return result of insert_text(text) without actually performing the\n        insertion.  Handy for pre-validation.\n\n        :param text: text for inserting, type (bytes or unicode)\n                     must match the text in the caption\n        :type text: bytes or unicode\n        \"\"\"\n\n        # if there's highlighted text, it'll get replaced by the new text\n        text = self._normalize_to_caption(text)\n        if self.highlight:\n            start, stop = self.highlight\n            btext, etext = self.edit_text[:start], self.edit_text[stop:]\n            result_text = btext + etext\n            result_pos = start\n        else:\n            result_text = self.edit_text\n            result_pos = self.edit_pos\n\n        try:\n            result_text = result_text[:result_pos] + text + result_text[result_pos:]\n        except (IndexError, TypeError) as exc:\n            raise ValueError(repr((self.edit_text, result_text, text))).with_traceback(exc.__traceback__) from exc\n\n        result_pos += len(text)\n        return (result_text, result_pos)\n\n    def keypress(self, size: tuple[int], key: str) -> str | None:\n        \"\"\"\n        Handle editing keystrokes, return others.\n\n        >>> e, size = Edit(), (20,)\n        >>> e.keypress(size, 'x')\n        >>> e.keypress(size, 'left')\n        >>> e.keypress(size, '1')\n        >>> print(e.edit_text)\n        1x\n        >>> e.keypress(size, 'backspace')\n        >>> e.keypress(size, 'end')\n        >>> e.keypress(size, '2')\n        >>> print(e.edit_text)\n        x2\n        >>> e.keypress(size, 'shift f1')\n        'shift f1'\n        \"\"\"\n        (maxcol,) = size\n\n        pos = self.edit_pos\n        if self.valid_char(key):\n            if isinstance(key, str) and not isinstance(self._caption, str):\n                # screen is sending us unicode input, must be using utf-8\n                # encoding because that's all we support, so convert it\n                # to bytes to match our caption's type\n                key = key.encode(\"utf-8\")\n            self.insert_text(key)\n            return None\n\n        if key == \"tab\" and self.allow_tab:\n            key = \" \" * (8 - (self.edit_pos % 8))\n            self.insert_text(key)\n            return None\n\n        if key == \"enter\" and self.multiline:\n            key = \"\\n\"\n            self.insert_text(key)\n            return None\n\n        if self._command_map[key] == Command.LEFT:\n            if pos == 0:\n                return key\n            pos = move_prev_char(self.edit_text, 0, pos)\n            self.set_edit_pos(pos)\n            return None\n\n        if self._command_map[key] == Command.RIGHT:\n            if pos >= len(self.edit_text):\n                return key\n            pos = move_next_char(self.edit_text, pos, len(self.edit_text))\n            self.set_edit_pos(pos)\n            return None\n\n        if self._command_map[key] in (Command.UP, Command.DOWN):\n            self.highlight = None\n\n            x, y = self.get_cursor_coords((maxcol,))\n            pref_col = self.get_pref_col((maxcol,))\n            if pref_col is None:\n                raise ValueError(pref_col)\n\n            # if pref_col is None:\n            #    pref_col = x\n\n            if self._command_map[key] == Command.UP:\n                y -= 1\n            else:\n                y += 1\n\n            if not self.move_cursor_to_coords((maxcol,), pref_col, y):\n                return key\n            return None\n\n        if key == \"backspace\":\n            self.pref_col_maxcol = None, None\n            if not self._delete_highlighted():\n                if pos == 0:\n                    return key\n                pos = move_prev_char(self.edit_text, 0, pos)\n                self.set_edit_text(self.edit_text[:pos] + self.edit_text[self.edit_pos :])\n                self.set_edit_pos(pos)\n                return None\n            return None\n\n        if key == \"delete\":\n            self.pref_col_maxcol = None, None\n            if not self._delete_highlighted():\n                if pos >= len(self.edit_text):\n                    return key\n                pos = move_next_char(self.edit_text, pos, len(self.edit_text))\n                self.set_edit_text(self.edit_text[: self.edit_pos] + self.edit_text[pos:])\n                return None\n            return None\n\n        if self._command_map[key] in (Command.MAX_LEFT, Command.MAX_RIGHT):\n            self.highlight = None\n            self.pref_col_maxcol = None, None\n\n            x, y = self.get_cursor_coords((maxcol,))\n\n            if self._command_map[key] == Command.MAX_LEFT:\n                self.move_cursor_to_coords((maxcol,), Align.LEFT, y)\n            else:\n                self.move_cursor_to_coords((maxcol,), Align.RIGHT, y)\n            return None\n\n        # key wasn't handled\n        return key\n\n    def move_cursor_to_coords(\n        self,\n        size: tuple[int],\n        x: int | Literal[Align.LEFT, Align.RIGHT],\n        y: int,\n    ) -> bool:\n        \"\"\"\n        Set the cursor position with (x,y) coordinates.\n        Returns True if move succeeded, False otherwise.\n\n        >>> size = (10,)\n        >>> e = Edit(\"\",\"edit\\\\ntext\")\n        >>> e.move_cursor_to_coords(size, 5, 0)\n        True\n        >>> e.edit_pos\n        4\n        >>> e.move_cursor_to_coords(size, 5, 3)\n        False\n        >>> e.move_cursor_to_coords(size, 0, 1)\n        True\n        >>> e.edit_pos\n        5\n        \"\"\"\n        (maxcol,) = size\n        trans = self.get_line_translation(maxcol)\n        top_x, top_y = self.position_coords(maxcol, 0)\n        if y < top_y or y >= len(trans):\n            return False\n\n        pos = text_layout.calc_pos(self.get_text()[0], trans, x, y)\n        e_pos = pos - len(self.caption)\n        if e_pos < 0:\n            e_pos = 0\n        if e_pos > len(self.edit_text):\n            e_pos = len(self.edit_text)\n        self.edit_pos = e_pos\n        self.pref_col_maxcol = x, maxcol\n        self._invalidate()\n        return True\n\n    def mouse_event(self, size: tuple[int], event, button: int, x: int, y: int, focus: bool) -> bool:\n        \"\"\"\n        Move the cursor to the location clicked for button 1.\n\n        >>> size = (20,)\n        >>> e = Edit(\"\",\"words here\")\n        >>> e.mouse_event(size, 'mouse press', 1, 2, 0, True)\n        True\n        >>> e.edit_pos\n        2\n        \"\"\"\n        (maxcol,) = size\n        if button == 1:\n            return self.move_cursor_to_coords((maxcol,), x, y)\n        return False\n\n    def _delete_highlighted(self) -> bool:\n        \"\"\"\n        Delete all highlighted text and update cursor position, if any\n        text is highlighted.\n        \"\"\"\n        if not self.highlight:\n            return False\n        start, stop = self.highlight\n        btext, etext = self.edit_text[:start], self.edit_text[stop:]\n        self.set_edit_text(btext + etext)\n        self.edit_pos = start\n        self.highlight = None\n        return True\n\n    def render(self, size: tuple[int], focus: bool = False) -> TextCanvas | CompositeCanvas:\n        \"\"\"\n        Render edit widget and return canvas.  Include cursor when in\n        focus.\n\n        >>> c = Edit(\"? \",\"yes\").render((10,), focus=True)\n        >>> c.text # ... = b in Python 3\n        [...'? yes     ']\n        >>> c.cursor\n        (5, 0)\n        \"\"\"\n        (maxcol,) = size\n        self._shift_view_to_cursor = bool(focus)\n\n        canv: TextCanvas | CompositeCanvas = Text.render(self, (maxcol,))\n        if focus:\n            canv = CompositeCanvas(canv)\n            canv.cursor = self.get_cursor_coords((maxcol,))\n\n        # .. will need to FIXME if I want highlight to work again\n        # if self.highlight:\n        #    hstart, hstop = self.highlight_coords()\n        #    d.coords['highlight'] = [ hstart, hstop ]\n        return canv\n\n    def get_line_translation(self, maxcol: int, ta=None):\n        trans = Text.get_line_translation(self, maxcol, ta)\n        if not self._shift_view_to_cursor:\n            return trans\n\n        text, ignore = self.get_text()\n        x, y = text_layout.calc_coords(text, trans, self.edit_pos + len(self.caption))\n        if x < 0:\n            return [\n                *trans[:y],\n                *[text_layout.shift_line(trans[y], -x)],\n                *trans[y + 1 :],\n            ]\n\n        if x >= maxcol:\n            return [\n                *trans[:y],\n                *[text_layout.shift_line(trans[y], -(x - maxcol + 1))],\n                *trans[y + 1 :],\n            ]\n\n        return trans\n\n    def get_cursor_coords(self, size: tuple[int]) -> tuple[int, int]:\n        \"\"\"\n        Return the (*x*, *y*) coordinates of cursor within widget.\n\n        >>> Edit(\"? \",\"yes\").get_cursor_coords((10,))\n        (5, 0)\n        \"\"\"\n        (maxcol,) = size\n\n        self._shift_view_to_cursor = True\n        return self.position_coords(maxcol, self.edit_pos)\n\n    def position_coords(self, maxcol: int, pos) -> tuple[int, int]:\n        \"\"\"\n        Return (*x*, *y*) coordinates for an offset into self.edit_text.\n        \"\"\"\n\n        p = pos + len(self.caption)\n        trans = self.get_line_translation(maxcol)\n        x, y = text_layout.calc_coords(self.get_text()[0], trans, p)\n        return x, y",
  "class IntEdit(Edit):\n    \"\"\"Edit widget for integer values\"\"\"\n\n    def valid_char(self, ch):\n        \"\"\"\n        Return true for decimal digits.\n        \"\"\"\n        return len(ch) == 1 and ch in \"0123456789\"\n\n    def __init__(self, caption=\"\", default: int | str | None = None) -> None:\n        \"\"\"\n        caption -- caption markup\n        default -- default edit value\n\n        >>> IntEdit(u\"\", 42)\n        <IntEdit selectable flow widget '42' edit_pos=2>\n        \"\"\"\n        if default is not None:\n            val = str(default)\n        else:\n            val = \"\"\n        super().__init__(caption, val)\n\n    def keypress(self, size: tuple[int], key: str) -> str | None:\n        \"\"\"\n        Handle editing keystrokes.  Remove leading zeros.\n\n        >>> e, size = IntEdit(u\"\", 5002), (10,)\n        >>> e.keypress(size, 'home')\n        >>> e.keypress(size, 'delete')\n        >>> print(e.edit_text)\n        002\n        >>> e.keypress(size, 'end')\n        >>> print(e.edit_text)\n        2\n        \"\"\"\n        (maxcol,) = size\n        unhandled = Edit.keypress(self, (maxcol,), key)\n\n        if not unhandled:\n            # trim leading zeros\n            while self.edit_pos > 0 and self.edit_text[:1] == \"0\":\n                self.set_edit_pos(self.edit_pos - 1)\n                self.set_edit_text(self.edit_text[1:])\n\n        return unhandled\n\n    def value(self) -> int:\n        \"\"\"\n        Return the numeric value of self.edit_text.\n\n        >>> e, size = IntEdit(), (10,)\n        >>> e.keypress(size, '5')\n        >>> e.keypress(size, '1')\n        >>> e.value() == 51\n        True\n        \"\"\"\n        if self.edit_text:\n            return int(self.edit_text)\n\n        return 0",
  "def valid_char(self, ch: str) -> bool:\n        \"\"\"\n        Filter for text that may be entered into this widget by the user\n\n        :param ch: character to be inserted\n        :type ch: str\n\n        This implementation returns True for all printable characters.\n        \"\"\"\n        return is_wide_char(ch, 0) or (len(ch) == 1 and ord(ch) >= 32)",
  "def __init__(\n        self,\n        caption=\"\",\n        edit_text: str | bytes = \"\",\n        multiline: bool = False,\n        align: Literal[\"left\", \"center\", \"right\"] | Align = Align.LEFT,\n        wrap: Literal[\"space\", \"any\", \"clip\", \"ellipsis\"] | WrapMode = WrapMode.SPACE,\n        allow_tab: bool = False,\n        edit_pos: int | None = None,\n        layout=None,\n        mask: str | bytes | None = None,\n    ) -> None:\n        \"\"\"\n        :param caption: markup for caption preceding edit_text, see\n                        :class:`Text` for description of text markup.\n        :type caption: text markup\n        :param edit_text: initial text for editing, type (bytes or unicode)\n                          must match the text in the caption\n        :type edit_text: bytes or unicode\n        :param multiline: True: 'enter' inserts newline  False: return it\n        :type multiline: bool\n        :param align: typically 'left', 'center' or 'right'\n        :type align: text alignment mode\n        :param wrap: typically 'space', 'any' or 'clip'\n        :type wrap: text wrapping mode\n        :param allow_tab: True: 'tab' inserts 1-8 spaces  False: return it\n        :type allow_tab: bool\n        :param edit_pos: initial position for cursor, None:end of edit_text\n        :type edit_pos: int\n        :param layout: defaults to a shared :class:`StandardTextLayout` instance\n        :type layout: text layout instance\n        :param mask: hide text entered with this character, None:disable mask\n        :type mask: bytes or unicode\n\n        >>> Edit()\n        <Edit selectable flow widget '' edit_pos=0>\n        >>> Edit(u\"Y/n? \", u\"yes\")\n        <Edit selectable flow widget 'yes' caption='Y/n? ' edit_pos=3>\n        >>> Edit(u\"Name \", u\"Smith\", edit_pos=1)\n        <Edit selectable flow widget 'Smith' caption='Name ' edit_pos=1>\n        >>> Edit(u\"\", u\"3.14\", align='right')\n        <Edit selectable flow widget '3.14' align='right' edit_pos=4>\n        \"\"\"\n\n        super().__init__(\"\", align, wrap, layout)\n        self.multiline = multiline\n        self.allow_tab = allow_tab\n        self._edit_pos = 0\n        self.set_caption(caption)\n        self._edit_text = \"\"\n        self.set_edit_text(edit_text)\n        if edit_pos is None:\n            edit_pos = len(edit_text)\n        self.set_edit_pos(edit_pos)\n        self.set_mask(mask)\n        self._shift_view_to_cursor = False",
  "def _repr_words(self) -> list[str]:\n        return (\n            super()._repr_words()[:-1]\n            + [repr(self._edit_text)]\n            + [f\"caption={self._caption!r}\"] * bool(self._caption)\n            + [\"multiline\"] * (self.multiline is True)\n        )",
  "def _repr_attrs(self):\n        attrs = dict(super()._repr_attrs(), edit_pos=self._edit_pos)\n        return remove_defaults(attrs, Edit.__init__)",
  "def get_text(self):\n        \"\"\"\n        Returns ``(text, display attributes)``. See :meth:`Text.get_text`\n        for details.\n\n        Text returned includes the caption and edit_text, possibly masked.\n\n        >>> Edit(u\"What? \",\"oh, nothing.\").get_text() # ... = u in Python 2\n        (...'What? oh, nothing.', [])\n        >>> Edit(('bright',u\"user@host:~$ \"),\"ls\").get_text()\n        (...'user@host:~$ ls', [('bright', 13)])\n        >>> Edit(u\"password:\", u\"seekrit\", mask=u\"*\").get_text()\n        (...'password:*******', [])\n        \"\"\"\n\n        if self._mask is None:\n            return self._caption + self._edit_text, self._attrib\n\n        return self._caption + (self._mask * len(self._edit_text)), self._attrib",
  "def set_text(self, markup) -> None:\n        \"\"\"\n        Not supported by Edit widget.\n\n        >>> Edit().set_text(\"test\")\n        Traceback (most recent call last):\n        EditError: set_text() not supported.  Use set_caption() or set_edit_text() instead.\n        \"\"\"\n        # FIXME: this smells. reimplement Edit as a WidgetWrap subclass to\n        # clean this up\n\n        # hack to let Text.__init__() work\n        if not hasattr(self, \"_text\") and markup == \"\":\n            self._text = None\n            return\n\n        raise EditError(\"set_text() not supported.  Use set_caption() or set_edit_text() instead.\")",
  "def get_pref_col(self, size: tuple[int]) -> int:\n        \"\"\"\n        Return the preferred column for the cursor, or the\n        current cursor x value.  May also return ``'left'`` or ``'right'``\n        to indicate the leftmost or rightmost column available.\n\n        This method is used internally and by other widgets when\n        moving the cursor up or down between widgets so that the\n        column selected is one that the user would expect.\n\n        >>> size = (10,)\n        >>> Edit().get_pref_col(size)\n        0\n        >>> e = Edit(u\"\", u\"word\")\n        >>> e.get_pref_col(size)\n        4\n        >>> e.keypress(size, 'left')\n        >>> e.get_pref_col(size)\n        3\n        >>> e.keypress(size, 'end')\n        >>> e.get_pref_col(size)\n        <Align.RIGHT: 'right'>\n        >>> e = Edit(u\"\", u\"2\\\\nwords\")\n        >>> e.keypress(size, 'left')\n        >>> e.keypress(size, 'up')\n        >>> e.get_pref_col(size)\n        4\n        >>> e.keypress(size, 'left')\n        >>> e.get_pref_col(size)\n        0\n        \"\"\"\n        (maxcol,) = size\n        pref_col, then_maxcol = self.pref_col_maxcol\n        if then_maxcol != maxcol:\n            return self.get_cursor_coords((maxcol,))[0]\n\n        return pref_col",
  "def set_caption(self, caption) -> None:\n        \"\"\"\n        Set the caption markup for this widget.\n\n        :param caption: markup for caption preceding edit_text, see\n                        :meth:`Text.__init__` for description of text markup.\n\n        >>> e = Edit(\"\")\n        >>> e.set_caption(\"cap1\")\n        >>> print(e.caption)\n        cap1\n        >>> e.set_caption(('bold', \"cap2\"))\n        >>> print(e.caption)\n        cap2\n        >>> e.attrib\n        [('bold', 4)]\n        >>> e.caption = \"cap3\"  # not supported because caption stores text but set_caption() takes markup\n        Traceback (most recent call last):\n        AttributeError: can't set attribute\n        \"\"\"\n        self._caption, self._attrib = decompose_tagmarkup(caption)\n        self._invalidate()",
  "def caption(self) -> str:\n        \"\"\"\n        Read-only property returning the caption for this widget.\n        \"\"\"\n        return self._caption",
  "def set_edit_pos(self, pos: int) -> None:\n        \"\"\"\n        Set the cursor position with a self.edit_text offset.\n        Clips pos to [0, len(edit_text)].\n\n        :param pos: cursor position\n        :type pos: int\n\n        >>> e = Edit(u\"\", u\"word\")\n        >>> e.edit_pos\n        4\n        >>> e.set_edit_pos(2)\n        >>> e.edit_pos\n        2\n        >>> e.edit_pos = -1  # Urwid 0.9.9 or later\n        >>> e.edit_pos\n        0\n        >>> e.edit_pos = 20\n        >>> e.edit_pos\n        4\n        \"\"\"\n        if pos < 0:\n            pos = 0\n        if pos > len(self._edit_text):\n            pos = len(self._edit_text)\n        self.highlight = None\n        self.pref_col_maxcol = None, None\n        self._edit_pos = pos\n        self._invalidate()",
  "def set_mask(self, mask: str | bytes | None) -> None:\n        \"\"\"\n        Set the character for masking text away.\n\n        :param mask: hide text entered with this character, None:disable mask\n        :type mask: bytes or unicode\n        \"\"\"\n\n        self._mask = mask\n        self._invalidate()",
  "def set_edit_text(self, text: str | bytes) -> None:\n        \"\"\"\n        Set the edit text for this widget.\n\n        :param text: text for editing, type (bytes or unicode)\n                     must match the text in the caption\n        :type text: bytes or unicode\n\n        >>> e = Edit()\n        >>> e.set_edit_text(u\"yes\")\n        >>> print(e.edit_text)\n        yes\n        >>> e\n        <Edit selectable flow widget 'yes' edit_pos=0>\n        >>> e.edit_text = u\"no\"  # Urwid 0.9.9 or later\n        >>> print(e.edit_text)\n        no\n        \"\"\"\n        text = self._normalize_to_caption(text)\n        self.highlight = None\n        self._emit(\"change\", text)\n        old_text = self._edit_text\n        self._edit_text = text\n        if self.edit_pos > len(text):\n            self.edit_pos = len(text)\n        self._emit(\"postchange\", old_text)\n        self._invalidate()",
  "def get_edit_text(self) -> str:\n        \"\"\"\n        Return the edit text for this widget.\n\n        >>> e = Edit(u\"What? \", u\"oh, nothing.\")\n        >>> print(e.get_edit_text())\n        oh, nothing.\n        >>> print(e.edit_text)\n        oh, nothing.\n        \"\"\"\n        return self._edit_text",
  "def insert_text(self, text: str | bytes) -> None:\n        \"\"\"\n        Insert text at the cursor position and update cursor.\n        This method is used by the keypress() method when inserting\n        one or more characters into edit_text.\n\n        :param text: text for inserting, type (bytes or unicode)\n                     must match the text in the caption\n        :type text: bytes or unicode\n\n        >>> e = Edit(u\"\", u\"42\")\n        >>> e.insert_text(u\".5\")\n        >>> e\n        <Edit selectable flow widget '42.5' edit_pos=4>\n        >>> e.set_edit_pos(2)\n        >>> e.insert_text(u\"a\")\n        >>> print(e.edit_text)\n        42a.5\n        \"\"\"\n        text = self._normalize_to_caption(text)\n        result_text, result_pos = self.insert_text_result(text)\n        self.set_edit_text(result_text)\n        self.set_edit_pos(result_pos)\n        self.highlight = None",
  "def _normalize_to_caption(self, text: str | bytes) -> str | bytes:\n        \"\"\"\n        Return text converted to the same type as self.caption\n        (bytes or unicode)\n        \"\"\"\n        tu = isinstance(text, str)\n        cu = isinstance(self._caption, str)\n        if tu == cu:\n            return text\n        if tu:\n            return text.encode(\"ascii\")  # follow python2's implicit conversion\n        return text.decode(\"ascii\")",
  "def insert_text_result(self, text: str | bytes) -> tuple[str | bytes, int]:\n        \"\"\"\n        Return result of insert_text(text) without actually performing the\n        insertion.  Handy for pre-validation.\n\n        :param text: text for inserting, type (bytes or unicode)\n                     must match the text in the caption\n        :type text: bytes or unicode\n        \"\"\"\n\n        # if there's highlighted text, it'll get replaced by the new text\n        text = self._normalize_to_caption(text)\n        if self.highlight:\n            start, stop = self.highlight\n            btext, etext = self.edit_text[:start], self.edit_text[stop:]\n            result_text = btext + etext\n            result_pos = start\n        else:\n            result_text = self.edit_text\n            result_pos = self.edit_pos\n\n        try:\n            result_text = result_text[:result_pos] + text + result_text[result_pos:]\n        except (IndexError, TypeError) as exc:\n            raise ValueError(repr((self.edit_text, result_text, text))).with_traceback(exc.__traceback__) from exc\n\n        result_pos += len(text)\n        return (result_text, result_pos)",
  "def keypress(self, size: tuple[int], key: str) -> str | None:\n        \"\"\"\n        Handle editing keystrokes, return others.\n\n        >>> e, size = Edit(), (20,)\n        >>> e.keypress(size, 'x')\n        >>> e.keypress(size, 'left')\n        >>> e.keypress(size, '1')\n        >>> print(e.edit_text)\n        1x\n        >>> e.keypress(size, 'backspace')\n        >>> e.keypress(size, 'end')\n        >>> e.keypress(size, '2')\n        >>> print(e.edit_text)\n        x2\n        >>> e.keypress(size, 'shift f1')\n        'shift f1'\n        \"\"\"\n        (maxcol,) = size\n\n        pos = self.edit_pos\n        if self.valid_char(key):\n            if isinstance(key, str) and not isinstance(self._caption, str):\n                # screen is sending us unicode input, must be using utf-8\n                # encoding because that's all we support, so convert it\n                # to bytes to match our caption's type\n                key = key.encode(\"utf-8\")\n            self.insert_text(key)\n            return None\n\n        if key == \"tab\" and self.allow_tab:\n            key = \" \" * (8 - (self.edit_pos % 8))\n            self.insert_text(key)\n            return None\n\n        if key == \"enter\" and self.multiline:\n            key = \"\\n\"\n            self.insert_text(key)\n            return None\n\n        if self._command_map[key] == Command.LEFT:\n            if pos == 0:\n                return key\n            pos = move_prev_char(self.edit_text, 0, pos)\n            self.set_edit_pos(pos)\n            return None\n\n        if self._command_map[key] == Command.RIGHT:\n            if pos >= len(self.edit_text):\n                return key\n            pos = move_next_char(self.edit_text, pos, len(self.edit_text))\n            self.set_edit_pos(pos)\n            return None\n\n        if self._command_map[key] in (Command.UP, Command.DOWN):\n            self.highlight = None\n\n            x, y = self.get_cursor_coords((maxcol,))\n            pref_col = self.get_pref_col((maxcol,))\n            if pref_col is None:\n                raise ValueError(pref_col)\n\n            # if pref_col is None:\n            #    pref_col = x\n\n            if self._command_map[key] == Command.UP:\n                y -= 1\n            else:\n                y += 1\n\n            if not self.move_cursor_to_coords((maxcol,), pref_col, y):\n                return key\n            return None\n\n        if key == \"backspace\":\n            self.pref_col_maxcol = None, None\n            if not self._delete_highlighted():\n                if pos == 0:\n                    return key\n                pos = move_prev_char(self.edit_text, 0, pos)\n                self.set_edit_text(self.edit_text[:pos] + self.edit_text[self.edit_pos :])\n                self.set_edit_pos(pos)\n                return None\n            return None\n\n        if key == \"delete\":\n            self.pref_col_maxcol = None, None\n            if not self._delete_highlighted():\n                if pos >= len(self.edit_text):\n                    return key\n                pos = move_next_char(self.edit_text, pos, len(self.edit_text))\n                self.set_edit_text(self.edit_text[: self.edit_pos] + self.edit_text[pos:])\n                return None\n            return None\n\n        if self._command_map[key] in (Command.MAX_LEFT, Command.MAX_RIGHT):\n            self.highlight = None\n            self.pref_col_maxcol = None, None\n\n            x, y = self.get_cursor_coords((maxcol,))\n\n            if self._command_map[key] == Command.MAX_LEFT:\n                self.move_cursor_to_coords((maxcol,), Align.LEFT, y)\n            else:\n                self.move_cursor_to_coords((maxcol,), Align.RIGHT, y)\n            return None\n\n        # key wasn't handled\n        return key",
  "def move_cursor_to_coords(\n        self,\n        size: tuple[int],\n        x: int | Literal[Align.LEFT, Align.RIGHT],\n        y: int,\n    ) -> bool:\n        \"\"\"\n        Set the cursor position with (x,y) coordinates.\n        Returns True if move succeeded, False otherwise.\n\n        >>> size = (10,)\n        >>> e = Edit(\"\",\"edit\\\\ntext\")\n        >>> e.move_cursor_to_coords(size, 5, 0)\n        True\n        >>> e.edit_pos\n        4\n        >>> e.move_cursor_to_coords(size, 5, 3)\n        False\n        >>> e.move_cursor_to_coords(size, 0, 1)\n        True\n        >>> e.edit_pos\n        5\n        \"\"\"\n        (maxcol,) = size\n        trans = self.get_line_translation(maxcol)\n        top_x, top_y = self.position_coords(maxcol, 0)\n        if y < top_y or y >= len(trans):\n            return False\n\n        pos = text_layout.calc_pos(self.get_text()[0], trans, x, y)\n        e_pos = pos - len(self.caption)\n        if e_pos < 0:\n            e_pos = 0\n        if e_pos > len(self.edit_text):\n            e_pos = len(self.edit_text)\n        self.edit_pos = e_pos\n        self.pref_col_maxcol = x, maxcol\n        self._invalidate()\n        return True",
  "def mouse_event(self, size: tuple[int], event, button: int, x: int, y: int, focus: bool) -> bool:\n        \"\"\"\n        Move the cursor to the location clicked for button 1.\n\n        >>> size = (20,)\n        >>> e = Edit(\"\",\"words here\")\n        >>> e.mouse_event(size, 'mouse press', 1, 2, 0, True)\n        True\n        >>> e.edit_pos\n        2\n        \"\"\"\n        (maxcol,) = size\n        if button == 1:\n            return self.move_cursor_to_coords((maxcol,), x, y)\n        return False",
  "def _delete_highlighted(self) -> bool:\n        \"\"\"\n        Delete all highlighted text and update cursor position, if any\n        text is highlighted.\n        \"\"\"\n        if not self.highlight:\n            return False\n        start, stop = self.highlight\n        btext, etext = self.edit_text[:start], self.edit_text[stop:]\n        self.set_edit_text(btext + etext)\n        self.edit_pos = start\n        self.highlight = None\n        return True",
  "def render(self, size: tuple[int], focus: bool = False) -> TextCanvas | CompositeCanvas:\n        \"\"\"\n        Render edit widget and return canvas.  Include cursor when in\n        focus.\n\n        >>> c = Edit(\"? \",\"yes\").render((10,), focus=True)\n        >>> c.text # ... = b in Python 3\n        [...'? yes     ']\n        >>> c.cursor\n        (5, 0)\n        \"\"\"\n        (maxcol,) = size\n        self._shift_view_to_cursor = bool(focus)\n\n        canv: TextCanvas | CompositeCanvas = Text.render(self, (maxcol,))\n        if focus:\n            canv = CompositeCanvas(canv)\n            canv.cursor = self.get_cursor_coords((maxcol,))\n\n        # .. will need to FIXME if I want highlight to work again\n        # if self.highlight:\n        #    hstart, hstop = self.highlight_coords()\n        #    d.coords['highlight'] = [ hstart, hstop ]\n        return canv",
  "def get_line_translation(self, maxcol: int, ta=None):\n        trans = Text.get_line_translation(self, maxcol, ta)\n        if not self._shift_view_to_cursor:\n            return trans\n\n        text, ignore = self.get_text()\n        x, y = text_layout.calc_coords(text, trans, self.edit_pos + len(self.caption))\n        if x < 0:\n            return [\n                *trans[:y],\n                *[text_layout.shift_line(trans[y], -x)],\n                *trans[y + 1 :],\n            ]\n\n        if x >= maxcol:\n            return [\n                *trans[:y],\n                *[text_layout.shift_line(trans[y], -(x - maxcol + 1))],\n                *trans[y + 1 :],\n            ]\n\n        return trans",
  "def get_cursor_coords(self, size: tuple[int]) -> tuple[int, int]:\n        \"\"\"\n        Return the (*x*, *y*) coordinates of cursor within widget.\n\n        >>> Edit(\"? \",\"yes\").get_cursor_coords((10,))\n        (5, 0)\n        \"\"\"\n        (maxcol,) = size\n\n        self._shift_view_to_cursor = True\n        return self.position_coords(maxcol, self.edit_pos)",
  "def position_coords(self, maxcol: int, pos) -> tuple[int, int]:\n        \"\"\"\n        Return (*x*, *y*) coordinates for an offset into self.edit_text.\n        \"\"\"\n\n        p = pos + len(self.caption)\n        trans = self.get_line_translation(maxcol)\n        x, y = text_layout.calc_coords(self.get_text()[0], trans, p)\n        return x, y",
  "def valid_char(self, ch):\n        \"\"\"\n        Return true for decimal digits.\n        \"\"\"\n        return len(ch) == 1 and ch in \"0123456789\"",
  "def __init__(self, caption=\"\", default: int | str | None = None) -> None:\n        \"\"\"\n        caption -- caption markup\n        default -- default edit value\n\n        >>> IntEdit(u\"\", 42)\n        <IntEdit selectable flow widget '42' edit_pos=2>\n        \"\"\"\n        if default is not None:\n            val = str(default)\n        else:\n            val = \"\"\n        super().__init__(caption, val)",
  "def keypress(self, size: tuple[int], key: str) -> str | None:\n        \"\"\"\n        Handle editing keystrokes.  Remove leading zeros.\n\n        >>> e, size = IntEdit(u\"\", 5002), (10,)\n        >>> e.keypress(size, 'home')\n        >>> e.keypress(size, 'delete')\n        >>> print(e.edit_text)\n        002\n        >>> e.keypress(size, 'end')\n        >>> print(e.edit_text)\n        2\n        \"\"\"\n        (maxcol,) = size\n        unhandled = Edit.keypress(self, (maxcol,), key)\n\n        if not unhandled:\n            # trim leading zeros\n            while self.edit_pos > 0 and self.edit_text[:1] == \"0\":\n                self.set_edit_pos(self.edit_pos - 1)\n                self.set_edit_text(self.edit_text[1:])\n\n        return unhandled",
  "def value(self) -> int:\n        \"\"\"\n        Return the numeric value of self.edit_text.\n\n        >>> e, size = IntEdit(), (10,)\n        >>> e.keypress(size, '5')\n        >>> e.keypress(size, '1')\n        >>> e.value() == 51\n        True\n        \"\"\"\n        if self.edit_text:\n            return int(self.edit_text)\n\n        return 0",
  "class LineBox(WidgetDecoration, WidgetWrap):\n    def __init__(\n        self,\n        original_widget: Widget,\n        title: str = \"\",\n        title_align: Literal[\"left\", \"center\", \"right\"] | Align = Align.CENTER,\n        title_attr=None,\n        tlcorner: str = \"\u250c\",\n        tline: str = \"\u2500\",\n        lline: str = \"\u2502\",\n        trcorner: str = \"\u2510\",\n        blcorner: str = \"\u2514\",\n        rline: str = \"\u2502\",\n        bline: str = \"\u2500\",\n        brcorner: str = \"\u2518\",\n    ) -> None:\n        \"\"\"\n        Draw a line around original_widget.\n\n        Use 'title' to set an initial title text with will be centered\n        on top of the box.\n\n        Use `title_attr` to apply a specific attribute to the title text.\n\n        Use `title_align` to align the title to the 'left', 'right', or 'center'.\n        The default is 'center'.\n\n        You can also override the widgets used for the lines/corners:\n            tline: top line\n            bline: bottom line\n            lline: left line\n            rline: right line\n            tlcorner: top left corner\n            trcorner: top right corner\n            blcorner: bottom left corner\n            brcorner: bottom right corner\n\n        If empty string is specified for one of the lines/corners, then no\n        character will be output there.  This allows for seamless use of\n        adjoining LineBoxes.\n        \"\"\"\n\n        if tline:\n            tline = Divider(tline)\n        if bline:\n            bline = Divider(bline)\n        if lline:\n            lline = SolidFill(lline)\n        if rline:\n            rline = SolidFill(rline)\n\n        tlcorner, trcorner = Text(tlcorner), Text(trcorner)\n        blcorner, brcorner = Text(blcorner), Text(brcorner)\n\n        if not tline and title:\n            raise ValueError(\"Cannot have a title when tline is empty string\")\n\n        if title_attr:\n            self.title_widget = Text((title_attr, self.format_title(title)))\n        else:\n            self.title_widget = Text(self.format_title(title))\n\n        if tline:\n            if title_align not in (\"left\", \"center\", \"right\"):\n                raise ValueError('title_align must be one of \"left\", \"right\", or \"center\"')\n            if title_align == Align.LEFT:\n                tline_widgets = [(\"flow\", self.title_widget), tline]\n            else:\n                tline_widgets = [tline, (Sizing.FLOW, self.title_widget)]\n                if title_align == \"center\":\n                    tline_widgets.append(tline)\n            self.tline_widget = Columns(tline_widgets)\n            top = Columns([(Sizing.FIXED, 1, tlcorner), self.tline_widget, (Sizing.FIXED, 1, trcorner)])\n\n        else:\n            self.tline_widget = None\n            top = None\n\n        middle_widgets = []\n        if lline:\n            middle_widgets.append((\"fixed\", 1, lline))\n        else:\n            # Note: We need to define a fixed first widget (even if it's 0 width) so that the other\n            # widgets have something to anchor onto\n            middle_widgets.append((\"fixed\", 0, SolidFill(\"\")))\n        middle_widgets.append(original_widget)\n        focus_col = len(middle_widgets) - 1\n        if rline:\n            middle_widgets.append((Sizing.FIXED, 1, rline))\n\n        middle = Columns(middle_widgets, box_columns=[0, 2], focus_column=focus_col)\n\n        if bline:\n            bottom = Columns([(Sizing.FIXED, 1, blcorner), bline, (Sizing.FIXED, 1, brcorner)])\n        else:\n            bottom = None\n\n        pile_widgets = []\n        if top:\n            pile_widgets.append((\"flow\", top))\n        pile_widgets.append(middle)\n        focus_pos = len(pile_widgets) - 1\n        if bottom:\n            pile_widgets.append((\"flow\", bottom))\n        pile = Pile(pile_widgets, focus_item=focus_pos)\n\n        WidgetDecoration.__init__(self, original_widget)\n        WidgetWrap.__init__(self, pile)\n\n    def format_title(self, text: str) -> str:\n        if len(text) > 0:\n            return f\" {text} \"\n\n        return \"\"\n\n    def set_title(self, text):\n        if not self.title_widget:\n            raise ValueError(\"Cannot set title when tline is unset\")\n        self.title_widget.set_text(self.format_title(text))\n        self.tline_widget._invalidate()\n\n    def pack(self, size=None, focus: bool = False) -> tuple[int, int]:\n        \"\"\"\n        Return the number of screen columns and rows required for\n        this Linebox widget to be displayed without wrapping or\n        clipping, as a single element tuple.\n\n        :param size: ``None`` for unlimited screen columns or (*maxcol*,) to\n                     specify a maximum column size\n        :type size: widget size\n        \"\"\"\n        size = list(self._original_widget.pack(size, focus))\n        size[0] += 2\n        size[1] += 2\n        return size",
  "def __init__(\n        self,\n        original_widget: Widget,\n        title: str = \"\",\n        title_align: Literal[\"left\", \"center\", \"right\"] | Align = Align.CENTER,\n        title_attr=None,\n        tlcorner: str = \"\u250c\",\n        tline: str = \"\u2500\",\n        lline: str = \"\u2502\",\n        trcorner: str = \"\u2510\",\n        blcorner: str = \"\u2514\",\n        rline: str = \"\u2502\",\n        bline: str = \"\u2500\",\n        brcorner: str = \"\u2518\",\n    ) -> None:\n        \"\"\"\n        Draw a line around original_widget.\n\n        Use 'title' to set an initial title text with will be centered\n        on top of the box.\n\n        Use `title_attr` to apply a specific attribute to the title text.\n\n        Use `title_align` to align the title to the 'left', 'right', or 'center'.\n        The default is 'center'.\n\n        You can also override the widgets used for the lines/corners:\n            tline: top line\n            bline: bottom line\n            lline: left line\n            rline: right line\n            tlcorner: top left corner\n            trcorner: top right corner\n            blcorner: bottom left corner\n            brcorner: bottom right corner\n\n        If empty string is specified for one of the lines/corners, then no\n        character will be output there.  This allows for seamless use of\n        adjoining LineBoxes.\n        \"\"\"\n\n        if tline:\n            tline = Divider(tline)\n        if bline:\n            bline = Divider(bline)\n        if lline:\n            lline = SolidFill(lline)\n        if rline:\n            rline = SolidFill(rline)\n\n        tlcorner, trcorner = Text(tlcorner), Text(trcorner)\n        blcorner, brcorner = Text(blcorner), Text(brcorner)\n\n        if not tline and title:\n            raise ValueError(\"Cannot have a title when tline is empty string\")\n\n        if title_attr:\n            self.title_widget = Text((title_attr, self.format_title(title)))\n        else:\n            self.title_widget = Text(self.format_title(title))\n\n        if tline:\n            if title_align not in (\"left\", \"center\", \"right\"):\n                raise ValueError('title_align must be one of \"left\", \"right\", or \"center\"')\n            if title_align == Align.LEFT:\n                tline_widgets = [(\"flow\", self.title_widget), tline]\n            else:\n                tline_widgets = [tline, (Sizing.FLOW, self.title_widget)]\n                if title_align == \"center\":\n                    tline_widgets.append(tline)\n            self.tline_widget = Columns(tline_widgets)\n            top = Columns([(Sizing.FIXED, 1, tlcorner), self.tline_widget, (Sizing.FIXED, 1, trcorner)])\n\n        else:\n            self.tline_widget = None\n            top = None\n\n        middle_widgets = []\n        if lline:\n            middle_widgets.append((\"fixed\", 1, lline))\n        else:\n            # Note: We need to define a fixed first widget (even if it's 0 width) so that the other\n            # widgets have something to anchor onto\n            middle_widgets.append((\"fixed\", 0, SolidFill(\"\")))\n        middle_widgets.append(original_widget)\n        focus_col = len(middle_widgets) - 1\n        if rline:\n            middle_widgets.append((Sizing.FIXED, 1, rline))\n\n        middle = Columns(middle_widgets, box_columns=[0, 2], focus_column=focus_col)\n\n        if bline:\n            bottom = Columns([(Sizing.FIXED, 1, blcorner), bline, (Sizing.FIXED, 1, brcorner)])\n        else:\n            bottom = None\n\n        pile_widgets = []\n        if top:\n            pile_widgets.append((\"flow\", top))\n        pile_widgets.append(middle)\n        focus_pos = len(pile_widgets) - 1\n        if bottom:\n            pile_widgets.append((\"flow\", bottom))\n        pile = Pile(pile_widgets, focus_item=focus_pos)\n\n        WidgetDecoration.__init__(self, original_widget)\n        WidgetWrap.__init__(self, pile)",
  "def format_title(self, text: str) -> str:\n        if len(text) > 0:\n            return f\" {text} \"\n\n        return \"\"",
  "def set_title(self, text):\n        if not self.title_widget:\n            raise ValueError(\"Cannot set title when tline is unset\")\n        self.title_widget.set_text(self.format_title(text))\n        self.tline_widget._invalidate()",
  "def pack(self, size=None, focus: bool = False) -> tuple[int, int]:\n        \"\"\"\n        Return the number of screen columns and rows required for\n        this Linebox widget to be displayed without wrapping or\n        clipping, as a single element tuple.\n\n        :param size: ``None`` for unlimited screen columns or (*maxcol*,) to\n                     specify a maximum column size\n        :type size: widget size\n        \"\"\"\n        size = list(self._original_widget.pack(size, focus))\n        size[0] += 2\n        size[1] += 2\n        return size",
  "class PopUpLauncher(delegate_to_widget_mixin(\"_original_widget\"), WidgetDecoration):\n    def __init__(self, original_widget: Widget) -> None:\n        super().__init__(original_widget)\n        self._pop_up_widget = None\n\n    def create_pop_up(self):\n        \"\"\"\n        Subclass must override this method and return a widget\n        to be used for the pop-up.  This method is called once each time\n        the pop-up is opened.\n        \"\"\"\n        raise NotImplementedError(\"Subclass must override this method\")\n\n    def get_pop_up_parameters(self):\n        \"\"\"\n        Subclass must override this method and have it return a dict, eg:\n\n        {'left':0, 'top':1, 'overlay_width':30, 'overlay_height':4}\n\n        This method is called each time this widget is rendered.\n        \"\"\"\n        raise NotImplementedError(\"Subclass must override this method\")\n\n    def open_pop_up(self) -> None:\n        self._pop_up_widget = self.create_pop_up()\n        self._invalidate()\n\n    def close_pop_up(self) -> None:\n        self._pop_up_widget = None\n        self._invalidate()\n\n    def render(self, size, focus: bool = False) -> CompositeCanvas | Canvas:\n        canv = super().render(size, focus)\n        if self._pop_up_widget:\n            canv = CompositeCanvas(canv)\n            canv.set_pop_up(self._pop_up_widget, **self.get_pop_up_parameters())\n        return canv",
  "class PopUpTarget(WidgetDecoration):\n    # FIXME: this whole class is a terrible hack and must be fixed\n    # when layout and rendering are separated\n    _sizing = frozenset((Sizing.BOX,))\n    _selectable = True\n\n    def __init__(self, original_widget: Widget) -> None:\n        super().__init__(original_widget)\n        self._pop_up = None\n        self._current_widget = self._original_widget\n\n    def _update_overlay(self, size: tuple[int, int], focus: bool) -> None:\n        canv = self._original_widget.render(size, focus=focus)\n        self._cache_original_canvas = canv  # imperfect performance hack\n        pop_up = canv.get_pop_up()\n        if pop_up:\n            left, top, (w, overlay_width, overlay_height) = pop_up\n            if self._pop_up != w:\n                self._pop_up = w\n                self._current_widget = Overlay(\n                    w,\n                    self._original_widget,\n                    (\"fixed left\", left),\n                    overlay_width,\n                    (\"fixed top\", top),\n                    overlay_height,\n                )\n            else:\n                self._current_widget.set_overlay_parameters(\n                    (\"fixed left\", left),\n                    overlay_width,\n                    (\"fixed top\", top),\n                    overlay_height,\n                )\n        else:\n            self._pop_up = None\n            self._current_widget = self._original_widget\n\n    def render(self, size: tuple[int, int], focus: bool = False) -> Canvas:\n        self._update_overlay(size, focus)\n        return self._current_widget.render(size, focus=focus)\n\n    def get_cursor_coords(self, size: tuple[int, int]) -> tuple[int, int] | None:\n        self._update_overlay(size, True)\n        return self._current_widget.get_cursor_coords(size)\n\n    def get_pref_col(self, size: tuple[int, int]) -> int:\n        self._update_overlay(size, True)\n        return self._current_widget.get_pref_col(size)\n\n    def keypress(self, size: tuple[int, int], key: str) -> str | None:\n        self._update_overlay(size, True)\n        return self._current_widget.keypress(size, key)\n\n    def move_cursor_to_coords(self, size: tuple[int, int], x: int, y: int):\n        self._update_overlay(size, True)\n        return self._current_widget.move_cursor_to_coords(size, x, y)\n\n    def mouse_event(self, size: tuple[int, int], event, button: int, x: int, y: int, focus: bool) -> bool | None:\n        self._update_overlay(size, focus)\n        return self._current_widget.mouse_event(size, event, button, x, y, focus)\n\n    def pack(self, size: tuple[int, int] | None = None, focus: bool = False) -> tuple[int, int]:\n        self._update_overlay(size, focus)\n        return self._current_widget.pack(size)",
  "def _test():\n    import doctest\n\n    doctest.testmod()",
  "def __init__(self, original_widget: Widget) -> None:\n        super().__init__(original_widget)\n        self._pop_up_widget = None",
  "def create_pop_up(self):\n        \"\"\"\n        Subclass must override this method and return a widget\n        to be used for the pop-up.  This method is called once each time\n        the pop-up is opened.\n        \"\"\"\n        raise NotImplementedError(\"Subclass must override this method\")",
  "def get_pop_up_parameters(self):\n        \"\"\"\n        Subclass must override this method and have it return a dict, eg:\n\n        {'left':0, 'top':1, 'overlay_width':30, 'overlay_height':4}\n\n        This method is called each time this widget is rendered.\n        \"\"\"\n        raise NotImplementedError(\"Subclass must override this method\")",
  "def open_pop_up(self) -> None:\n        self._pop_up_widget = self.create_pop_up()\n        self._invalidate()",
  "def close_pop_up(self) -> None:\n        self._pop_up_widget = None\n        self._invalidate()",
  "def render(self, size, focus: bool = False) -> CompositeCanvas | Canvas:\n        canv = super().render(size, focus)\n        if self._pop_up_widget:\n            canv = CompositeCanvas(canv)\n            canv.set_pop_up(self._pop_up_widget, **self.get_pop_up_parameters())\n        return canv",
  "def __init__(self, original_widget: Widget) -> None:\n        super().__init__(original_widget)\n        self._pop_up = None\n        self._current_widget = self._original_widget",
  "def _update_overlay(self, size: tuple[int, int], focus: bool) -> None:\n        canv = self._original_widget.render(size, focus=focus)\n        self._cache_original_canvas = canv  # imperfect performance hack\n        pop_up = canv.get_pop_up()\n        if pop_up:\n            left, top, (w, overlay_width, overlay_height) = pop_up\n            if self._pop_up != w:\n                self._pop_up = w\n                self._current_widget = Overlay(\n                    w,\n                    self._original_widget,\n                    (\"fixed left\", left),\n                    overlay_width,\n                    (\"fixed top\", top),\n                    overlay_height,\n                )\n            else:\n                self._current_widget.set_overlay_parameters(\n                    (\"fixed left\", left),\n                    overlay_width,\n                    (\"fixed top\", top),\n                    overlay_height,\n                )\n        else:\n            self._pop_up = None\n            self._current_widget = self._original_widget",
  "def render(self, size: tuple[int, int], focus: bool = False) -> Canvas:\n        self._update_overlay(size, focus)\n        return self._current_widget.render(size, focus=focus)",
  "def get_cursor_coords(self, size: tuple[int, int]) -> tuple[int, int] | None:\n        self._update_overlay(size, True)\n        return self._current_widget.get_cursor_coords(size)",
  "def get_pref_col(self, size: tuple[int, int]) -> int:\n        self._update_overlay(size, True)\n        return self._current_widget.get_pref_col(size)",
  "def keypress(self, size: tuple[int, int], key: str) -> str | None:\n        self._update_overlay(size, True)\n        return self._current_widget.keypress(size, key)",
  "def move_cursor_to_coords(self, size: tuple[int, int], x: int, y: int):\n        self._update_overlay(size, True)\n        return self._current_widget.move_cursor_to_coords(size, x, y)",
  "def mouse_event(self, size: tuple[int, int], event, button: int, x: int, y: int, focus: bool) -> bool | None:\n        self._update_overlay(size, focus)\n        return self._current_widget.mouse_event(size, event, button, x, y, focus)",
  "def pack(self, size: tuple[int, int] | None = None, focus: bool = False) -> tuple[int, int]:\n        self._update_overlay(size, focus)\n        return self._current_widget.pack(size)",
  "class SelectableIcon(Text):\n    ignore_focus = False\n    _selectable = True\n\n    def __init__(\n        self,\n        text,\n        cursor_position: int = 0,\n        align: Literal[\"left\", \"center\", \"right\"] | Align = Align.LEFT,\n        wrap: Literal[\"space\", \"any\", \"clip\", \"ellipsis\"] | WrapMode = WrapMode.SPACE,\n        layout: TextLayout | None = None,\n    ) -> None:\n        \"\"\"\n        :param text: markup for this widget; see :class:`Text` for\n                     description of text markup\n        :param cursor_position: position the cursor will appear in the\n                                text when this widget is in focus\n        :param align: typically ``'left'``, ``'center'`` or ``'right'``\n        :type align: text alignment mode\n        :param wrap: typically ``'space'``, ``'any'``, ``'clip'`` or ``'ellipsis'``\n        :type wrap: text wrapping mode\n        :param layout: defaults to a shared :class:`StandardTextLayout` instance\n        :type layout: text layout instance\n\n        This is a text widget that is selectable.  A cursor\n        displayed at a fixed location in the text when in focus.\n        This widget has no special handling of keyboard or mouse input.\n        \"\"\"\n        super().__init__(text, align=align, wrap=wrap, layout=layout)\n        self._cursor_position = cursor_position\n\n    def render(self, size: tuple[int], focus: bool = False) -> TextCanvas | CompositeCanvas:\n        \"\"\"\n        Render the text content of this widget with a cursor when\n        in focus.\n\n        >>> si = SelectableIcon(u\"[!]\")\n        >>> si\n        <SelectableIcon selectable flow widget '[!]'>\n        >>> si.render((4,), focus=True).cursor\n        (0, 0)\n        >>> si = SelectableIcon(\"((*))\", 2)\n        >>> si.render((8,), focus=True).cursor\n        (2, 0)\n        >>> si.render((2,), focus=True).cursor\n        (0, 1)\n        \"\"\"\n        c = super().render(size, focus)\n        if focus:\n            # create a new canvas so we can add a cursor\n            c = CompositeCanvas(c)\n            c.cursor = self.get_cursor_coords(size)\n        return c\n\n    def get_cursor_coords(self, size: tuple[int]) -> tuple[int, int] | None:\n        \"\"\"\n        Return the position of the cursor if visible.  This method\n        is required for widgets that display a cursor.\n        \"\"\"\n        if self._cursor_position > len(self.text):\n            return None\n        # find out where the cursor will be displayed based on\n        # the text layout\n        (maxcol,) = size\n        trans = self.get_line_translation(maxcol)\n        x, y = calc_coords(self.text, trans, self._cursor_position)\n        if maxcol <= x:\n            return None\n        return x, y\n\n    def keypress(self, size: tuple[int], key: str) -> str:\n        \"\"\"\n        No keys are handled by this widget.  This method is\n        required for selectable widgets.\n        \"\"\"\n        return key",
  "class CheckBoxError(Exception):\n    pass",
  "class CheckBox(WidgetWrap):\n    def sizing(self):\n        return frozenset([Sizing.FLOW])\n\n    states: typing.ClassVar[dict[bool | Literal[\"mixed\"], SelectableIcon]] = {\n        True: SelectableIcon(\"[X]\", 1),\n        False: SelectableIcon(\"[ ]\", 1),\n        \"mixed\": SelectableIcon(\"[#]\", 1),\n    }\n    reserve_columns = 4\n\n    # allow users of this class to listen for change events\n    # sent when the state of this widget is modified\n    # (this variable is picked up by the MetaSignals metaclass)\n    signals: typing.ClassVar[list[str]] = [\"change\", \"postchange\"]\n\n    def __init__(\n        self,\n        label,\n        state: bool | Literal[\"mixed\"] = False,\n        has_mixed: bool = False,\n        on_state_change: Callable[[Self, bool, _T], typing.Any] | Callable[[Self, bool], typing.Any] | None = None,\n        user_data: _T | None = None,\n        checked_symbol: str | None = None,\n    ):\n        \"\"\"\n        :param label: markup for check box label\n        :param state: False, True or \"mixed\"\n        :param has_mixed: True if \"mixed\" is a state to cycle through\n        :param on_state_change: shorthand for connect_signal()\n                                function call for a single callback\n        :param user_data: user_data for on_state_change\n\n        Signals supported: ``'change'``, ``\"postchange\"``\n\n        Register signal handler with::\n\n          urwid.connect_signal(check_box, 'change', callback, user_data)\n\n        where callback is callback(check_box, new_state [,user_data])\n        Unregister signal handlers with::\n\n          urwid.disconnect_signal(check_box, 'change', callback, user_data)\n\n        >>> CheckBox(\"Confirm\")\n        <CheckBox selectable flow widget 'Confirm' state=False>\n        >>> CheckBox(\"Yogourt\", \"mixed\", True)\n        <CheckBox selectable flow widget 'Yogourt' state='mixed'>\n        >>> cb = CheckBox(\"Extra onions\", True)\n        >>> cb\n        <CheckBox selectable flow widget 'Extra onions' state=True>\n        >>> cb.render((20,), focus=True).text\n        [b'[X] Extra onions    ']\n        >>> CheckBox(\"Test\", None)\n        Traceback (most recent call last):\n        ...\n        ValueError: None not in (True, False, 'mixed')\n        \"\"\"\n        if state not in self.states:\n            raise ValueError(f\"{state!r} not in {tuple(self.states.keys())}\")\n\n        self._label = Text(label)\n        self.has_mixed = has_mixed\n\n        self._state = state\n        if checked_symbol:\n            self.states[True] = SelectableIcon(f\"[{checked_symbol}]\", 1)\n        # The old way of listening for a change was to pass the callback\n        # in to the constructor.  Just convert it to the new way:\n        if on_state_change:\n            connect_signal(self, \"change\", on_state_change, user_data)\n\n        # Initial create expect no callbacks call, create explicit\n        super().__init__(\n            Columns(\n                [(Sizing.FIXED, self.reserve_columns, self.states[state]), self._label],\n                focus_column=0,\n            ),\n        )\n\n    def _repr_words(self) -> list[str]:\n        return [*super()._repr_words(), repr(self.label)]\n\n    def _repr_attrs(self):\n        return dict(super()._repr_attrs(), state=self.state)\n\n    def set_label(self, label):\n        \"\"\"\n        Change the check box label.\n\n        label -- markup for label.  See Text widget for description\n        of text markup.\n\n        >>> cb = CheckBox(u\"foo\")\n        >>> cb\n        <CheckBox selectable flow widget 'foo' state=False>\n        >>> cb.set_label(('bright_attr', u\"bar\"))\n        >>> cb\n        <CheckBox selectable flow widget 'bar' state=False>\n        \"\"\"\n        self._label.set_text(label)\n        # no need to call self._invalidate(). WidgetWrap takes care of\n        # that when self.w changes\n\n    def get_label(self):\n        \"\"\"\n        Return label text.\n\n        >>> cb = CheckBox(u\"Seriously\")\n        >>> print(cb.get_label())\n        Seriously\n        >>> print(cb.label)\n        Seriously\n        >>> cb.set_label([('bright_attr', u\"flashy\"), u\" normal\"])\n        >>> print(cb.label)  #  only text is returned\n        flashy normal\n        \"\"\"\n        return self._label.text\n\n    label = property(get_label)\n\n    def set_state(\n        self,\n        state: bool | Literal[\"mixed\"],\n        do_callback: bool = True,\n    ) -> None:\n        \"\"\"\n        Set the CheckBox state.\n\n        state -- True, False or \"mixed\"\n        do_callback -- False to suppress signal from this change\n\n        >>> from urwid import disconnect_signal\n        >>> changes = []\n        >>> def callback_a(user_data, cb, state):\n        ...     changes.append(\"A %r %r\" % (state, user_data))\n        >>> def callback_b(cb, state):\n        ...     changes.append(\"B %r\" % state)\n        >>> cb = CheckBox('test', False, False)\n        >>> key1 = connect_signal(cb, 'change', callback_a, user_args=(\"user_a\",))\n        >>> key2 = connect_signal(cb, 'change', callback_b)\n        >>> cb.set_state(True) # both callbacks will be triggered\n        >>> cb.state\n        True\n        >>> disconnect_signal(cb, 'change', callback_a, user_args=(\"user_a\",))\n        >>> cb.state = False\n        >>> cb.state\n        False\n        >>> cb.set_state(True)\n        >>> cb.state\n        True\n        >>> cb.set_state(False, False) # don't send signal\n        >>> changes\n        [\"A True 'user_a'\", 'B True', 'B False', 'B True']\n        \"\"\"\n        if self._state == state:\n            return\n\n        if state not in self.states:\n            raise CheckBoxError(f\"{self!r} Invalid state: {state!r}\")\n\n        # self._state is None is a special case when the CheckBox\n        # has just been created\n        old_state = self._state\n        if do_callback:\n            self._emit(\"change\", state)\n        self._state = state\n        # rebuild the display widget with the new state\n        self._w = Columns([(Sizing.FIXED, self.reserve_columns, self.states[state]), self._label], focus_column=0)\n        if do_callback:\n            self._emit(\"postchange\", old_state)\n\n    def get_state(self) -> bool | Literal[\"mixed\"]:\n        \"\"\"Return the state of the checkbox.\"\"\"\n        return self._state\n\n    state = property(get_state, set_state)\n\n    def keypress(self, size: tuple[int], key: str) -> str | None:\n        \"\"\"\n        Toggle state on 'activate' command.\n\n        >>> assert CheckBox._command_map[' '] == 'activate'\n        >>> assert CheckBox._command_map['enter'] == 'activate'\n        >>> size = (10,)\n        >>> cb = CheckBox('press me')\n        >>> cb.state\n        False\n        >>> cb.keypress(size, ' ')\n        >>> cb.state\n        True\n        >>> cb.keypress(size, ' ')\n        >>> cb.state\n        False\n        \"\"\"\n        if self._command_map[key] != Command.ACTIVATE:\n            return key\n\n        self.toggle_state()\n        return None\n\n    def toggle_state(self) -> None:\n        \"\"\"\n        Cycle to the next valid state.\n\n        >>> cb = CheckBox(\"3-state\", has_mixed=True)\n        >>> cb.state\n        False\n        >>> cb.toggle_state()\n        >>> cb.state\n        True\n        >>> cb.toggle_state()\n        >>> cb.state\n        'mixed'\n        >>> cb.toggle_state()\n        >>> cb.state\n        False\n        \"\"\"\n        if self.state is False:\n            self.set_state(True)\n        elif self.state is True:\n            if self.has_mixed:\n                self.set_state(\"mixed\")\n            else:\n                self.set_state(False)\n        elif self.state == \"mixed\":\n            self.set_state(False)\n\n    def mouse_event(self, size: tuple[int], event, button: int, x: int, y: int, focus: bool) -> bool:\n        \"\"\"\n        Toggle state on button 1 press.\n\n        >>> size = (20,)\n        >>> cb = CheckBox(\"clickme\")\n        >>> cb.state\n        False\n        >>> cb.mouse_event(size, 'mouse press', 1, 2, 0, True)\n        True\n        >>> cb.state\n        True\n        \"\"\"\n        if button != 1 or not is_mouse_press(event):\n            return False\n        self.toggle_state()\n        return True",
  "class RadioButton(CheckBox):\n    states: typing.ClassVar[dict[bool | Literal[\"mixed\"], SelectableIcon]] = {\n        True: SelectableIcon(\"(X)\", 1),\n        False: SelectableIcon(\"( )\", 1),\n        \"mixed\": SelectableIcon(\"(#)\", 1),\n    }\n    reserve_columns = 4\n\n    def __init__(\n        self,\n        group: MutableSequence[CheckBox],\n        label,\n        state: bool | Literal[\"mixed\", \"first True\"] = \"first True\",\n        on_state_change: Callable[[Self, bool, _T], typing.Any] | Callable[[Self, bool], typing.Any] | None = None,\n        user_data: _T | None = None,\n    ) -> None:\n        \"\"\"\n        :param group: list for radio buttons in same group\n        :param label: markup for radio button label\n        :param state: False, True, \"mixed\" or \"first True\"\n        :param on_state_change: shorthand for connect_signal()\n                                function call for a single 'change' callback\n        :param user_data: user_data for on_state_change\n\n        This function will append the new radio button to group.\n        \"first True\" will set to True if group is empty.\n\n        Signals supported: ``'change'``, ``\"postchange\"``\n\n        Register signal handler with::\n\n          urwid.connect_signal(radio_button, 'change', callback, user_data)\n\n        where callback is callback(radio_button, new_state [,user_data])\n        Unregister signal handlers with::\n\n          urwid.disconnect_signal(radio_button, 'change', callback, user_data)\n\n        >>> bgroup = [] # button group\n        >>> b1 = RadioButton(bgroup, u\"Agree\")\n        >>> b2 = RadioButton(bgroup, u\"Disagree\")\n        >>> len(bgroup)\n        2\n        >>> b1\n        <RadioButton selectable flow widget 'Agree' state=True>\n        >>> b2\n        <RadioButton selectable flow widget 'Disagree' state=False>\n        >>> b2.render((15,), focus=True).text # ... = b in Python 3\n        [...'( ) Disagree   ']\n        \"\"\"\n        if state == \"first True\":\n            state = not group\n\n        self.group = group\n        super().__init__(label, state, False, on_state_change, user_data)\n        group.append(self)\n\n    def set_state(self, state: bool | Literal[\"mixed\"], do_callback: bool = True) -> None:\n        \"\"\"\n        Set the RadioButton state.\n\n        state -- True, False or \"mixed\"\n\n        do_callback -- False to suppress signal from this change\n\n        If state is True all other radio buttons in the same button\n        group will be set to False.\n\n        >>> bgroup = [] # button group\n        >>> b1 = RadioButton(bgroup, u\"Agree\")\n        >>> b2 = RadioButton(bgroup, u\"Disagree\")\n        >>> b3 = RadioButton(bgroup, u\"Unsure\")\n        >>> b1.state, b2.state, b3.state\n        (True, False, False)\n        >>> b2.set_state(True)\n        >>> b1.state, b2.state, b3.state\n        (False, True, False)\n        >>> def relabel_button(radio_button, new_state):\n        ...     radio_button.set_label(u\"Think Harder!\")\n        >>> key = connect_signal(b3, 'change', relabel_button)\n        >>> b3\n        <RadioButton selectable flow widget 'Unsure' state=False>\n        >>> b3.set_state(True) # this will trigger the callback\n        >>> b3\n        <RadioButton selectable flow widget 'Think Harder!' state=True>\n        \"\"\"\n        if self._state == state:\n            return\n\n        super().set_state(state, do_callback)\n\n        # if we're clearing the state we don't have to worry about\n        # other buttons in the button group\n        if state is not True:\n            return\n\n        # clear the state of each other radio button\n        for cb in self.group:\n            if cb is self:\n                continue\n            if cb._state:\n                cb.set_state(False)\n\n    def toggle_state(self) -> None:\n        \"\"\"\n        Set state to True.\n\n        >>> bgroup = [] # button group\n        >>> b1 = RadioButton(bgroup, \"Agree\")\n        >>> b2 = RadioButton(bgroup, \"Disagree\")\n        >>> b1.state, b2.state\n        (True, False)\n        >>> b2.toggle_state()\n        >>> b1.state, b2.state\n        (False, True)\n        >>> b2.toggle_state()\n        >>> b1.state, b2.state\n        (False, True)\n        \"\"\"\n        self.set_state(True)",
  "class Button(WidgetWrap):\n    def sizing(self):\n        return frozenset([Sizing.FLOW])\n\n    button_left = Text(\"<\")\n    button_right = Text(\">\")\n\n    signals: typing.ClassVar[list[str]] = [\"click\"]\n\n    def __init__(\n        self,\n        label,\n        on_press: Callable[[Self, _T], typing.Any] | Callable[[Self], typing.Any] | None = None,\n        user_data: _T | None = None,\n        *,\n        align: Literal[\"left\", \"center\", \"right\"] | Align = Align.LEFT,\n        wrap: Literal[\"space\", \"any\", \"clip\", \"ellipsis\"] | WrapMode = WrapMode.SPACE,\n        layout: TextLayout | None = None,\n    ) -> None:\n        \"\"\"\n        :param label: markup for button label\n        :param on_press: shorthand for connect_signal()\n                         function call for a single callback\n        :param user_data: user_data for on_press\n        :param align: typically ``'left'``, ``'center'`` or ``'right'``\n        :type align: label alignment mode\n        :param wrap: typically ``'space'``, ``'any'``, ``'clip'`` or ``'ellipsis'``\n        :type wrap: label wrapping mode\n        :param layout: defaults to a shared :class:`StandardTextLayout` instance\n        :type layout: text layout instance\n\n        Signals supported: ``'click'``\n\n        Register signal handler with::\n\n          urwid.connect_signal(button, 'click', callback, user_data)\n\n        where callback is callback(button [,user_data])\n        Unregister signal handlers with::\n\n          urwid.disconnect_signal(button, 'click', callback, user_data)\n\n        >>> Button(u\"Ok\")\n        <Button selectable flow widget 'Ok'>\n        >>> b = Button(\"Cancel\")\n        >>> b.render((15,), focus=True).text # ... = b in Python 3\n        [b'< Cancel      >']\n        >>> aligned_button = Button(\"Test\", align=Align.CENTER)\n        >>> aligned_button.render((10,), focus=True).text\n        [b'<  Test  >']\n        >>> wrapped_button = Button(\"Long label\", wrap=WrapMode.ELLIPSIS)\n        >>> wrapped_button.render((7,), focus=False).text[0].decode('utf-8')\n        '< Lo\u2026 >'\n        \"\"\"\n        self._label = SelectableIcon(label, 0, align=align, wrap=wrap, layout=layout)\n        cols = Columns(\n            [\n                (Sizing.FIXED, 1, self.button_left),\n                self._label,\n                (Sizing.FIXED, 1, self.button_right),\n            ],\n            dividechars=1,\n        )\n        super().__init__(cols)\n\n        # The old way of listening for a change was to pass the callback\n        # in to the constructor.  Just convert it to the new way:\n        if on_press:\n            connect_signal(self, \"click\", on_press, user_data)\n\n    def _repr_words(self) -> list[str]:\n        # include button.label in repr(button)\n        return [*super()._repr_words(), repr(self.label)]\n\n    def set_label(self, label) -> None:\n        \"\"\"\n        Change the button label.\n\n        label -- markup for button label\n\n        >>> b = Button(\"Ok\")\n        >>> b.set_label(u\"Yup yup\")\n        >>> b\n        <Button selectable flow widget 'Yup yup'>\n        \"\"\"\n        self._label.set_text(label)\n\n    def get_label(self) -> str:\n        \"\"\"\n        Return label text.\n\n        >>> b = Button(u\"Ok\")\n        >>> print(b.get_label())\n        Ok\n        >>> print(b.label)\n        Ok\n        \"\"\"\n        return self._label.text\n\n    label = property(get_label)\n\n    def keypress(self, size: tuple[int], key: str) -> str | None:\n        \"\"\"\n        Send 'click' signal on 'activate' command.\n\n        >>> assert Button._command_map[' '] == 'activate'\n        >>> assert Button._command_map['enter'] == 'activate'\n        >>> size = (15,)\n        >>> b = Button(u\"Cancel\")\n        >>> clicked_buttons = []\n        >>> def handle_click(button):\n        ...     clicked_buttons.append(button.label)\n        >>> key = connect_signal(b, 'click', handle_click)\n        >>> b.keypress(size, 'enter')\n        >>> b.keypress(size, ' ')\n        >>> clicked_buttons # ... = u in Python 2\n        [...'Cancel', ...'Cancel']\n        \"\"\"\n        if self._command_map[key] != Command.ACTIVATE:\n            return key\n\n        self._emit(\"click\")\n        return None\n\n    def mouse_event(self, size: tuple[int], event, button: int, x: int, y: int, focus: bool) -> bool:\n        \"\"\"\n        Send 'click' signal on button 1 press.\n\n        >>> size = (15,)\n        >>> b = Button(u\"Ok\")\n        >>> clicked_buttons = []\n        >>> def handle_click(button):\n        ...     clicked_buttons.append(button.label)\n        >>> key = connect_signal(b, 'click', handle_click)\n        >>> b.mouse_event(size, 'mouse press', 1, 4, 0, True)\n        True\n        >>> b.mouse_event(size, 'mouse press', 2, 4, 0, True) # ignored\n        False\n        >>> clicked_buttons # ... = u in Python 2\n        [...'Ok']\n        \"\"\"\n        if button != 1 or not is_mouse_press(event):\n            return False\n\n        self._emit(\"click\")\n        return True",
  "def _test():\n    import doctest\n\n    doctest.testmod()",
  "def __init__(\n        self,\n        text,\n        cursor_position: int = 0,\n        align: Literal[\"left\", \"center\", \"right\"] | Align = Align.LEFT,\n        wrap: Literal[\"space\", \"any\", \"clip\", \"ellipsis\"] | WrapMode = WrapMode.SPACE,\n        layout: TextLayout | None = None,\n    ) -> None:\n        \"\"\"\n        :param text: markup for this widget; see :class:`Text` for\n                     description of text markup\n        :param cursor_position: position the cursor will appear in the\n                                text when this widget is in focus\n        :param align: typically ``'left'``, ``'center'`` or ``'right'``\n        :type align: text alignment mode\n        :param wrap: typically ``'space'``, ``'any'``, ``'clip'`` or ``'ellipsis'``\n        :type wrap: text wrapping mode\n        :param layout: defaults to a shared :class:`StandardTextLayout` instance\n        :type layout: text layout instance\n\n        This is a text widget that is selectable.  A cursor\n        displayed at a fixed location in the text when in focus.\n        This widget has no special handling of keyboard or mouse input.\n        \"\"\"\n        super().__init__(text, align=align, wrap=wrap, layout=layout)\n        self._cursor_position = cursor_position",
  "def render(self, size: tuple[int], focus: bool = False) -> TextCanvas | CompositeCanvas:\n        \"\"\"\n        Render the text content of this widget with a cursor when\n        in focus.\n\n        >>> si = SelectableIcon(u\"[!]\")\n        >>> si\n        <SelectableIcon selectable flow widget '[!]'>\n        >>> si.render((4,), focus=True).cursor\n        (0, 0)\n        >>> si = SelectableIcon(\"((*))\", 2)\n        >>> si.render((8,), focus=True).cursor\n        (2, 0)\n        >>> si.render((2,), focus=True).cursor\n        (0, 1)\n        \"\"\"\n        c = super().render(size, focus)\n        if focus:\n            # create a new canvas so we can add a cursor\n            c = CompositeCanvas(c)\n            c.cursor = self.get_cursor_coords(size)\n        return c",
  "def get_cursor_coords(self, size: tuple[int]) -> tuple[int, int] | None:\n        \"\"\"\n        Return the position of the cursor if visible.  This method\n        is required for widgets that display a cursor.\n        \"\"\"\n        if self._cursor_position > len(self.text):\n            return None\n        # find out where the cursor will be displayed based on\n        # the text layout\n        (maxcol,) = size\n        trans = self.get_line_translation(maxcol)\n        x, y = calc_coords(self.text, trans, self._cursor_position)\n        if maxcol <= x:\n            return None\n        return x, y",
  "def keypress(self, size: tuple[int], key: str) -> str:\n        \"\"\"\n        No keys are handled by this widget.  This method is\n        required for selectable widgets.\n        \"\"\"\n        return key",
  "def sizing(self):\n        return frozenset([Sizing.FLOW])",
  "def __init__(\n        self,\n        label,\n        state: bool | Literal[\"mixed\"] = False,\n        has_mixed: bool = False,\n        on_state_change: Callable[[Self, bool, _T], typing.Any] | Callable[[Self, bool], typing.Any] | None = None,\n        user_data: _T | None = None,\n        checked_symbol: str | None = None,\n    ):\n        \"\"\"\n        :param label: markup for check box label\n        :param state: False, True or \"mixed\"\n        :param has_mixed: True if \"mixed\" is a state to cycle through\n        :param on_state_change: shorthand for connect_signal()\n                                function call for a single callback\n        :param user_data: user_data for on_state_change\n\n        Signals supported: ``'change'``, ``\"postchange\"``\n\n        Register signal handler with::\n\n          urwid.connect_signal(check_box, 'change', callback, user_data)\n\n        where callback is callback(check_box, new_state [,user_data])\n        Unregister signal handlers with::\n\n          urwid.disconnect_signal(check_box, 'change', callback, user_data)\n\n        >>> CheckBox(\"Confirm\")\n        <CheckBox selectable flow widget 'Confirm' state=False>\n        >>> CheckBox(\"Yogourt\", \"mixed\", True)\n        <CheckBox selectable flow widget 'Yogourt' state='mixed'>\n        >>> cb = CheckBox(\"Extra onions\", True)\n        >>> cb\n        <CheckBox selectable flow widget 'Extra onions' state=True>\n        >>> cb.render((20,), focus=True).text\n        [b'[X] Extra onions    ']\n        >>> CheckBox(\"Test\", None)\n        Traceback (most recent call last):\n        ...\n        ValueError: None not in (True, False, 'mixed')\n        \"\"\"\n        if state not in self.states:\n            raise ValueError(f\"{state!r} not in {tuple(self.states.keys())}\")\n\n        self._label = Text(label)\n        self.has_mixed = has_mixed\n\n        self._state = state\n        if checked_symbol:\n            self.states[True] = SelectableIcon(f\"[{checked_symbol}]\", 1)\n        # The old way of listening for a change was to pass the callback\n        # in to the constructor.  Just convert it to the new way:\n        if on_state_change:\n            connect_signal(self, \"change\", on_state_change, user_data)\n\n        # Initial create expect no callbacks call, create explicit\n        super().__init__(\n            Columns(\n                [(Sizing.FIXED, self.reserve_columns, self.states[state]), self._label],\n                focus_column=0,\n            ),\n        )",
  "def _repr_words(self) -> list[str]:\n        return [*super()._repr_words(), repr(self.label)]",
  "def _repr_attrs(self):\n        return dict(super()._repr_attrs(), state=self.state)",
  "def set_label(self, label):\n        \"\"\"\n        Change the check box label.\n\n        label -- markup for label.  See Text widget for description\n        of text markup.\n\n        >>> cb = CheckBox(u\"foo\")\n        >>> cb\n        <CheckBox selectable flow widget 'foo' state=False>\n        >>> cb.set_label(('bright_attr', u\"bar\"))\n        >>> cb\n        <CheckBox selectable flow widget 'bar' state=False>\n        \"\"\"\n        self._label.set_text(label)",
  "def get_label(self):\n        \"\"\"\n        Return label text.\n\n        >>> cb = CheckBox(u\"Seriously\")\n        >>> print(cb.get_label())\n        Seriously\n        >>> print(cb.label)\n        Seriously\n        >>> cb.set_label([('bright_attr', u\"flashy\"), u\" normal\"])\n        >>> print(cb.label)  #  only text is returned\n        flashy normal\n        \"\"\"\n        return self._label.text",
  "def set_state(\n        self,\n        state: bool | Literal[\"mixed\"],\n        do_callback: bool = True,\n    ) -> None:\n        \"\"\"\n        Set the CheckBox state.\n\n        state -- True, False or \"mixed\"\n        do_callback -- False to suppress signal from this change\n\n        >>> from urwid import disconnect_signal\n        >>> changes = []\n        >>> def callback_a(user_data, cb, state):\n        ...     changes.append(\"A %r %r\" % (state, user_data))\n        >>> def callback_b(cb, state):\n        ...     changes.append(\"B %r\" % state)\n        >>> cb = CheckBox('test', False, False)\n        >>> key1 = connect_signal(cb, 'change', callback_a, user_args=(\"user_a\",))\n        >>> key2 = connect_signal(cb, 'change', callback_b)\n        >>> cb.set_state(True) # both callbacks will be triggered\n        >>> cb.state\n        True\n        >>> disconnect_signal(cb, 'change', callback_a, user_args=(\"user_a\",))\n        >>> cb.state = False\n        >>> cb.state\n        False\n        >>> cb.set_state(True)\n        >>> cb.state\n        True\n        >>> cb.set_state(False, False) # don't send signal\n        >>> changes\n        [\"A True 'user_a'\", 'B True', 'B False', 'B True']\n        \"\"\"\n        if self._state == state:\n            return\n\n        if state not in self.states:\n            raise CheckBoxError(f\"{self!r} Invalid state: {state!r}\")\n\n        # self._state is None is a special case when the CheckBox\n        # has just been created\n        old_state = self._state\n        if do_callback:\n            self._emit(\"change\", state)\n        self._state = state\n        # rebuild the display widget with the new state\n        self._w = Columns([(Sizing.FIXED, self.reserve_columns, self.states[state]), self._label], focus_column=0)\n        if do_callback:\n            self._emit(\"postchange\", old_state)",
  "def get_state(self) -> bool | Literal[\"mixed\"]:\n        \"\"\"Return the state of the checkbox.\"\"\"\n        return self._state",
  "def keypress(self, size: tuple[int], key: str) -> str | None:\n        \"\"\"\n        Toggle state on 'activate' command.\n\n        >>> assert CheckBox._command_map[' '] == 'activate'\n        >>> assert CheckBox._command_map['enter'] == 'activate'\n        >>> size = (10,)\n        >>> cb = CheckBox('press me')\n        >>> cb.state\n        False\n        >>> cb.keypress(size, ' ')\n        >>> cb.state\n        True\n        >>> cb.keypress(size, ' ')\n        >>> cb.state\n        False\n        \"\"\"\n        if self._command_map[key] != Command.ACTIVATE:\n            return key\n\n        self.toggle_state()\n        return None",
  "def toggle_state(self) -> None:\n        \"\"\"\n        Cycle to the next valid state.\n\n        >>> cb = CheckBox(\"3-state\", has_mixed=True)\n        >>> cb.state\n        False\n        >>> cb.toggle_state()\n        >>> cb.state\n        True\n        >>> cb.toggle_state()\n        >>> cb.state\n        'mixed'\n        >>> cb.toggle_state()\n        >>> cb.state\n        False\n        \"\"\"\n        if self.state is False:\n            self.set_state(True)\n        elif self.state is True:\n            if self.has_mixed:\n                self.set_state(\"mixed\")\n            else:\n                self.set_state(False)\n        elif self.state == \"mixed\":\n            self.set_state(False)",
  "def mouse_event(self, size: tuple[int], event, button: int, x: int, y: int, focus: bool) -> bool:\n        \"\"\"\n        Toggle state on button 1 press.\n\n        >>> size = (20,)\n        >>> cb = CheckBox(\"clickme\")\n        >>> cb.state\n        False\n        >>> cb.mouse_event(size, 'mouse press', 1, 2, 0, True)\n        True\n        >>> cb.state\n        True\n        \"\"\"\n        if button != 1 or not is_mouse_press(event):\n            return False\n        self.toggle_state()\n        return True",
  "def __init__(\n        self,\n        group: MutableSequence[CheckBox],\n        label,\n        state: bool | Literal[\"mixed\", \"first True\"] = \"first True\",\n        on_state_change: Callable[[Self, bool, _T], typing.Any] | Callable[[Self, bool], typing.Any] | None = None,\n        user_data: _T | None = None,\n    ) -> None:\n        \"\"\"\n        :param group: list for radio buttons in same group\n        :param label: markup for radio button label\n        :param state: False, True, \"mixed\" or \"first True\"\n        :param on_state_change: shorthand for connect_signal()\n                                function call for a single 'change' callback\n        :param user_data: user_data for on_state_change\n\n        This function will append the new radio button to group.\n        \"first True\" will set to True if group is empty.\n\n        Signals supported: ``'change'``, ``\"postchange\"``\n\n        Register signal handler with::\n\n          urwid.connect_signal(radio_button, 'change', callback, user_data)\n\n        where callback is callback(radio_button, new_state [,user_data])\n        Unregister signal handlers with::\n\n          urwid.disconnect_signal(radio_button, 'change', callback, user_data)\n\n        >>> bgroup = [] # button group\n        >>> b1 = RadioButton(bgroup, u\"Agree\")\n        >>> b2 = RadioButton(bgroup, u\"Disagree\")\n        >>> len(bgroup)\n        2\n        >>> b1\n        <RadioButton selectable flow widget 'Agree' state=True>\n        >>> b2\n        <RadioButton selectable flow widget 'Disagree' state=False>\n        >>> b2.render((15,), focus=True).text # ... = b in Python 3\n        [...'( ) Disagree   ']\n        \"\"\"\n        if state == \"first True\":\n            state = not group\n\n        self.group = group\n        super().__init__(label, state, False, on_state_change, user_data)\n        group.append(self)",
  "def set_state(self, state: bool | Literal[\"mixed\"], do_callback: bool = True) -> None:\n        \"\"\"\n        Set the RadioButton state.\n\n        state -- True, False or \"mixed\"\n\n        do_callback -- False to suppress signal from this change\n\n        If state is True all other radio buttons in the same button\n        group will be set to False.\n\n        >>> bgroup = [] # button group\n        >>> b1 = RadioButton(bgroup, u\"Agree\")\n        >>> b2 = RadioButton(bgroup, u\"Disagree\")\n        >>> b3 = RadioButton(bgroup, u\"Unsure\")\n        >>> b1.state, b2.state, b3.state\n        (True, False, False)\n        >>> b2.set_state(True)\n        >>> b1.state, b2.state, b3.state\n        (False, True, False)\n        >>> def relabel_button(radio_button, new_state):\n        ...     radio_button.set_label(u\"Think Harder!\")\n        >>> key = connect_signal(b3, 'change', relabel_button)\n        >>> b3\n        <RadioButton selectable flow widget 'Unsure' state=False>\n        >>> b3.set_state(True) # this will trigger the callback\n        >>> b3\n        <RadioButton selectable flow widget 'Think Harder!' state=True>\n        \"\"\"\n        if self._state == state:\n            return\n\n        super().set_state(state, do_callback)\n\n        # if we're clearing the state we don't have to worry about\n        # other buttons in the button group\n        if state is not True:\n            return\n\n        # clear the state of each other radio button\n        for cb in self.group:\n            if cb is self:\n                continue\n            if cb._state:\n                cb.set_state(False)",
  "def toggle_state(self) -> None:\n        \"\"\"\n        Set state to True.\n\n        >>> bgroup = [] # button group\n        >>> b1 = RadioButton(bgroup, \"Agree\")\n        >>> b2 = RadioButton(bgroup, \"Disagree\")\n        >>> b1.state, b2.state\n        (True, False)\n        >>> b2.toggle_state()\n        >>> b1.state, b2.state\n        (False, True)\n        >>> b2.toggle_state()\n        >>> b1.state, b2.state\n        (False, True)\n        \"\"\"\n        self.set_state(True)",
  "def sizing(self):\n        return frozenset([Sizing.FLOW])",
  "def __init__(\n        self,\n        label,\n        on_press: Callable[[Self, _T], typing.Any] | Callable[[Self], typing.Any] | None = None,\n        user_data: _T | None = None,\n        *,\n        align: Literal[\"left\", \"center\", \"right\"] | Align = Align.LEFT,\n        wrap: Literal[\"space\", \"any\", \"clip\", \"ellipsis\"] | WrapMode = WrapMode.SPACE,\n        layout: TextLayout | None = None,\n    ) -> None:\n        \"\"\"\n        :param label: markup for button label\n        :param on_press: shorthand for connect_signal()\n                         function call for a single callback\n        :param user_data: user_data for on_press\n        :param align: typically ``'left'``, ``'center'`` or ``'right'``\n        :type align: label alignment mode\n        :param wrap: typically ``'space'``, ``'any'``, ``'clip'`` or ``'ellipsis'``\n        :type wrap: label wrapping mode\n        :param layout: defaults to a shared :class:`StandardTextLayout` instance\n        :type layout: text layout instance\n\n        Signals supported: ``'click'``\n\n        Register signal handler with::\n\n          urwid.connect_signal(button, 'click', callback, user_data)\n\n        where callback is callback(button [,user_data])\n        Unregister signal handlers with::\n\n          urwid.disconnect_signal(button, 'click', callback, user_data)\n\n        >>> Button(u\"Ok\")\n        <Button selectable flow widget 'Ok'>\n        >>> b = Button(\"Cancel\")\n        >>> b.render((15,), focus=True).text # ... = b in Python 3\n        [b'< Cancel      >']\n        >>> aligned_button = Button(\"Test\", align=Align.CENTER)\n        >>> aligned_button.render((10,), focus=True).text\n        [b'<  Test  >']\n        >>> wrapped_button = Button(\"Long label\", wrap=WrapMode.ELLIPSIS)\n        >>> wrapped_button.render((7,), focus=False).text[0].decode('utf-8')\n        '< Lo\u2026 >'\n        \"\"\"\n        self._label = SelectableIcon(label, 0, align=align, wrap=wrap, layout=layout)\n        cols = Columns(\n            [\n                (Sizing.FIXED, 1, self.button_left),\n                self._label,\n                (Sizing.FIXED, 1, self.button_right),\n            ],\n            dividechars=1,\n        )\n        super().__init__(cols)\n\n        # The old way of listening for a change was to pass the callback\n        # in to the constructor.  Just convert it to the new way:\n        if on_press:\n            connect_signal(self, \"click\", on_press, user_data)",
  "def _repr_words(self) -> list[str]:\n        # include button.label in repr(button)\n        return [*super()._repr_words(), repr(self.label)]",
  "def set_label(self, label) -> None:\n        \"\"\"\n        Change the button label.\n\n        label -- markup for button label\n\n        >>> b = Button(\"Ok\")\n        >>> b.set_label(u\"Yup yup\")\n        >>> b\n        <Button selectable flow widget 'Yup yup'>\n        \"\"\"\n        self._label.set_text(label)",
  "def get_label(self) -> str:\n        \"\"\"\n        Return label text.\n\n        >>> b = Button(u\"Ok\")\n        >>> print(b.get_label())\n        Ok\n        >>> print(b.label)\n        Ok\n        \"\"\"\n        return self._label.text",
  "def keypress(self, size: tuple[int], key: str) -> str | None:\n        \"\"\"\n        Send 'click' signal on 'activate' command.\n\n        >>> assert Button._command_map[' '] == 'activate'\n        >>> assert Button._command_map['enter'] == 'activate'\n        >>> size = (15,)\n        >>> b = Button(u\"Cancel\")\n        >>> clicked_buttons = []\n        >>> def handle_click(button):\n        ...     clicked_buttons.append(button.label)\n        >>> key = connect_signal(b, 'click', handle_click)\n        >>> b.keypress(size, 'enter')\n        >>> b.keypress(size, ' ')\n        >>> clicked_buttons # ... = u in Python 2\n        [...'Cancel', ...'Cancel']\n        \"\"\"\n        if self._command_map[key] != Command.ACTIVATE:\n            return key\n\n        self._emit(\"click\")\n        return None",
  "def mouse_event(self, size: tuple[int], event, button: int, x: int, y: int, focus: bool) -> bool:\n        \"\"\"\n        Send 'click' signal on button 1 press.\n\n        >>> size = (15,)\n        >>> b = Button(u\"Ok\")\n        >>> clicked_buttons = []\n        >>> def handle_click(button):\n        ...     clicked_buttons.append(button.label)\n        >>> key = connect_signal(b, 'click', handle_click)\n        >>> b.mouse_event(size, 'mouse press', 1, 4, 0, True)\n        True\n        >>> b.mouse_event(size, 'mouse press', 2, 4, 0, True) # ignored\n        False\n        >>> clicked_buttons # ... = u in Python 2\n        [...'Ok']\n        \"\"\"\n        if button != 1 or not is_mouse_press(event):\n            return False\n\n        self._emit(\"click\")\n        return True",
  "class AttrWrap(AttrMap):\n    def __init__(self, w: Widget, attr, focus_attr=None):\n        \"\"\"\n        w -- widget to wrap (stored as self.original_widget)\n        attr -- attribute to apply to w\n        focus_attr -- attribute to apply when in focus, if None use attr\n\n        This widget is a special case of the new AttrMap widget, and it\n        will pass all function calls and variable references to the wrapped\n        widget.  This class is maintained for backwards compatibility only,\n        new code should use AttrMap instead.\n\n        >>> from urwid import Divider, Edit, Text\n        >>> AttrWrap(Divider(u\"!\"), 'bright')\n        <AttrWrap flow widget <Divider flow widget '!'> attr='bright'>\n        >>> AttrWrap(Edit(), 'notfocus', 'focus')\n        <AttrWrap selectable flow widget <Edit selectable flow widget '' edit_pos=0> attr='notfocus' focus_attr='focus'>\n        >>> size = (5,)\n        >>> aw = AttrWrap(Text(u\"hi\"), 'greeting', 'fgreet')\n        >>> next(aw.render(size, focus=False).content())\n        [('greeting', None, ...'hi   ')]\n        >>> next(aw.render(size, focus=True).content())\n        [('fgreet', None, ...'hi   ')]\n        \"\"\"\n        super().__init__(w, attr, focus_attr)\n\n    def _repr_attrs(self):\n        # only include the focus_attr when it takes effect (not None)\n        d = dict(super()._repr_attrs(), attr=self.attr)\n        del d[\"attr_map\"]\n        if \"focus_map\" in d:\n            del d[\"focus_map\"]\n        if self.focus_attr is not None:\n            d[\"focus_attr\"] = self.focus_attr\n        return d\n\n    @property\n    def w(self) -> Widget:\n        \"\"\"backwards compatibility, widget used to be stored as w\"\"\"\n        warnings.warn(\n            \"backwards compatibility, widget used to be stored as original_widget\",\n            PendingDeprecationWarning,\n            stacklevel=2,\n        )\n        return self.original_widget\n\n    @w.setter\n    def w(self, new_widget: Widget) -> None:\n        warnings.warn(\n            \"backwards compatibility, widget used to be stored as original_widget\",\n            PendingDeprecationWarning,\n            stacklevel=2,\n        )\n        self.original_widget = new_widget\n\n    def get_w(self):\n        warnings.warn(\n            \"backwards compatibility, widget used to be stored as original_widget\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        return self.original_widget\n\n    def set_w(self, new_widget: Widget) -> None:\n        warnings.warn(\n            \"backwards compatibility, widget used to be stored as original_widget\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        self.original_widget = new_widget\n\n    def get_attr(self):\n        return self.attr_map[None]\n\n    def set_attr(self, attr):\n        \"\"\"\n        Set the attribute to apply to the wrapped widget\n\n        >> w = AttrWrap(Divider(\"-\"), None)\n        >> w.set_attr('new_attr')\n        >> w\n        <AttrWrap flow widget <Divider flow widget '-'> attr='new_attr'>\n        \"\"\"\n        self.set_attr_map({None: attr})\n\n    attr = property(get_attr, set_attr)\n\n    def get_focus_attr(self):\n        focus_map = self.focus_map\n        if focus_map:\n            return focus_map[None]\n        return None\n\n    def set_focus_attr(self, focus_attr):\n        \"\"\"\n        Set the attribute to apply to the wapped widget when it is in\n        focus\n\n        If None this widget will use the attr instead (no change when in\n        focus).\n\n        >> w = AttrWrap(Divider(\"-\"), 'old')\n        >> w.set_focus_attr('new_attr')\n        >> w\n        <AttrWrap flow widget <Divider flow widget '-'> attr='old' focus_attr='new_attr'>\n        >> w.set_focus_attr(None)\n        >> w\n        <AttrWrap flow widget <Divider flow widget '-'> attr='old'>\n        \"\"\"\n        self.set_focus_map({None: focus_attr})\n\n    focus_attr = property(get_focus_attr, set_focus_attr)\n\n    def __getattr__(self, name: str):\n        \"\"\"\n        Call getattr on wrapped widget.  This has been the longstanding\n        behaviour of AttrWrap, but is discouraged.  New code should be\n        using AttrMap and .base_widget or .original_widget instead.\n        \"\"\"\n        return getattr(self._original_widget, name)\n\n    def sizing(self):\n        return self._original_widget.sizing()",
  "def __init__(self, w: Widget, attr, focus_attr=None):\n        \"\"\"\n        w -- widget to wrap (stored as self.original_widget)\n        attr -- attribute to apply to w\n        focus_attr -- attribute to apply when in focus, if None use attr\n\n        This widget is a special case of the new AttrMap widget, and it\n        will pass all function calls and variable references to the wrapped\n        widget.  This class is maintained for backwards compatibility only,\n        new code should use AttrMap instead.\n\n        >>> from urwid import Divider, Edit, Text\n        >>> AttrWrap(Divider(u\"!\"), 'bright')\n        <AttrWrap flow widget <Divider flow widget '!'> attr='bright'>\n        >>> AttrWrap(Edit(), 'notfocus', 'focus')\n        <AttrWrap selectable flow widget <Edit selectable flow widget '' edit_pos=0> attr='notfocus' focus_attr='focus'>\n        >>> size = (5,)\n        >>> aw = AttrWrap(Text(u\"hi\"), 'greeting', 'fgreet')\n        >>> next(aw.render(size, focus=False).content())\n        [('greeting', None, ...'hi   ')]\n        >>> next(aw.render(size, focus=True).content())\n        [('fgreet', None, ...'hi   ')]\n        \"\"\"\n        super().__init__(w, attr, focus_attr)",
  "def _repr_attrs(self):\n        # only include the focus_attr when it takes effect (not None)\n        d = dict(super()._repr_attrs(), attr=self.attr)\n        del d[\"attr_map\"]\n        if \"focus_map\" in d:\n            del d[\"focus_map\"]\n        if self.focus_attr is not None:\n            d[\"focus_attr\"] = self.focus_attr\n        return d",
  "def w(self) -> Widget:\n        \"\"\"backwards compatibility, widget used to be stored as w\"\"\"\n        warnings.warn(\n            \"backwards compatibility, widget used to be stored as original_widget\",\n            PendingDeprecationWarning,\n            stacklevel=2,\n        )\n        return self.original_widget",
  "def w(self, new_widget: Widget) -> None:\n        warnings.warn(\n            \"backwards compatibility, widget used to be stored as original_widget\",\n            PendingDeprecationWarning,\n            stacklevel=2,\n        )\n        self.original_widget = new_widget",
  "def get_w(self):\n        warnings.warn(\n            \"backwards compatibility, widget used to be stored as original_widget\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        return self.original_widget",
  "def set_w(self, new_widget: Widget) -> None:\n        warnings.warn(\n            \"backwards compatibility, widget used to be stored as original_widget\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        self.original_widget = new_widget",
  "def get_attr(self):\n        return self.attr_map[None]",
  "def set_attr(self, attr):\n        \"\"\"\n        Set the attribute to apply to the wrapped widget\n\n        >> w = AttrWrap(Divider(\"-\"), None)\n        >> w.set_attr('new_attr')\n        >> w\n        <AttrWrap flow widget <Divider flow widget '-'> attr='new_attr'>\n        \"\"\"\n        self.set_attr_map({None: attr})",
  "def get_focus_attr(self):\n        focus_map = self.focus_map\n        if focus_map:\n            return focus_map[None]\n        return None",
  "def set_focus_attr(self, focus_attr):\n        \"\"\"\n        Set the attribute to apply to the wapped widget when it is in\n        focus\n\n        If None this widget will use the attr instead (no change when in\n        focus).\n\n        >> w = AttrWrap(Divider(\"-\"), 'old')\n        >> w.set_focus_attr('new_attr')\n        >> w\n        <AttrWrap flow widget <Divider flow widget '-'> attr='old' focus_attr='new_attr'>\n        >> w.set_focus_attr(None)\n        >> w\n        <AttrWrap flow widget <Divider flow widget '-'> attr='old'>\n        \"\"\"\n        self.set_focus_map({None: focus_attr})",
  "def __getattr__(self, name: str):\n        \"\"\"\n        Call getattr on wrapped widget.  This has been the longstanding\n        behaviour of AttrWrap, but is discouraged.  New code should be\n        using AttrMap and .base_widget or .original_widget instead.\n        \"\"\"\n        return getattr(self._original_widget, name)",
  "def sizing(self):\n        return self._original_widget.sizing()",
  "class ProgressBar(Widget):\n    _sizing = frozenset([Sizing.FLOW])\n\n    eighths = \" \u258f\u258e\u258d\u258c\u258b\u258a\u2589\"\n\n    text_align = Align.CENTER\n\n    def __init__(self, normal, complete, current: int = 0, done: int = 100, satt=None):\n        \"\"\"\n        :param normal: display attribute for incomplete part of progress bar\n        :param complete: display attribute for complete part of progress bar\n        :param current: current progress\n        :param done: progress amount at 100%\n        :param satt: display attribute for smoothed part of bar where the\n                     foreground of satt corresponds to the normal part and the\n                     background corresponds to the complete part.  If satt\n                     is ``None`` then no smoothing will be done.\n\n        >>> pb = ProgressBar('a', 'b')\n        >>> pb\n        <ProgressBar flow widget>\n        >>> print(pb.get_text())\n        0 %\n        >>> pb.set_completion(34.42)\n        >>> print(pb.get_text())\n        34 %\n        >>> class CustomProgressBar(ProgressBar):\n        ...     def get_text(self):\n        ...         return u'Foobar'\n        >>> cpb = CustomProgressBar('a', 'b')\n        >>> print(cpb.get_text())\n        Foobar\n        >>> for x in range(101):\n        ...     cpb.set_completion(x)\n        ...     s = cpb.render((10, ))\n        >>> cpb2 = CustomProgressBar('a', 'b', satt='c')\n        >>> for x in range(101):\n        ...     cpb2.set_completion(x)\n        ...     s = cpb2.render((10, ))\n        \"\"\"\n        self.normal = normal\n        self.complete = complete\n        self._current = current\n        self._done = done\n        self.satt = satt\n\n    def set_completion(self, current):\n        \"\"\"\n        current -- current progress\n        \"\"\"\n        self._current = current\n        self._invalidate()\n\n    current = property(lambda self: self._current, set_completion)\n\n    @property\n    def done(self):\n        return self._done\n\n    @done.setter\n    def done(self, done):\n        \"\"\"\n        done -- progress amount at 100%\n        \"\"\"\n        self._done = done\n        self._invalidate()\n\n    def _set_done(self, done):\n        warnings.warn(\n            f\"Method `{self.__class__.__name__}._set_done` is deprecated, \"\n            f\"please use property `{self.__class__.__name__}.done`\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        self.done = done\n\n    def rows(self, size, focus: bool = False) -> int:\n        return 1\n\n    def get_text(self) -> str:\n        \"\"\"\n        Return the progress bar percentage text.\n        You can override this method to display custom text.\n        \"\"\"\n        percent = min(100, max(0, int(self.current * 100 / self.done)))\n        return f\"{percent!s} %\"\n\n    def render(self, size: tuple[int], focus: bool = False) -> TextCanvas:\n        \"\"\"\n        Render the progress bar.\n        \"\"\"\n        (maxcol,) = size\n        txt = Text(self.get_text(), self.text_align, WrapMode.CLIP)\n        c = txt.render((maxcol,))\n\n        cf = float(self.current) * maxcol / self.done\n        ccol_dirty = int(cf)\n        ccol = len(c._text[0][:ccol_dirty].decode(\"utf-8\", \"ignore\").encode(\"utf-8\"))\n        cs = 0\n        if self.satt is not None:\n            cs = int((cf - ccol) * 8)\n        if ccol < 0 or (ccol == 0 and cs == 0):\n            c._attr = [[(self.normal, maxcol)]]\n        elif ccol >= maxcol:\n            c._attr = [[(self.complete, maxcol)]]\n        elif cs and c._text[0][ccol] == 32:\n            t = c._text[0]\n            cenc = self.eighths[cs].encode(\"utf-8\")\n            c._text[0] = t[:ccol] + cenc + t[ccol + 1 :]\n            a = []\n            if ccol > 0:\n                a.append((self.complete, ccol))\n            a.append((self.satt, len(cenc)))\n            if maxcol - ccol - 1 > 0:\n                a.append((self.normal, maxcol - ccol - 1))\n            c._attr = [a]\n            c._cs = [[(None, len(c._text[0]))]]\n        else:\n            c._attr = [[(self.complete, ccol), (self.normal, maxcol - ccol)]]\n        return c",
  "def __init__(self, normal, complete, current: int = 0, done: int = 100, satt=None):\n        \"\"\"\n        :param normal: display attribute for incomplete part of progress bar\n        :param complete: display attribute for complete part of progress bar\n        :param current: current progress\n        :param done: progress amount at 100%\n        :param satt: display attribute for smoothed part of bar where the\n                     foreground of satt corresponds to the normal part and the\n                     background corresponds to the complete part.  If satt\n                     is ``None`` then no smoothing will be done.\n\n        >>> pb = ProgressBar('a', 'b')\n        >>> pb\n        <ProgressBar flow widget>\n        >>> print(pb.get_text())\n        0 %\n        >>> pb.set_completion(34.42)\n        >>> print(pb.get_text())\n        34 %\n        >>> class CustomProgressBar(ProgressBar):\n        ...     def get_text(self):\n        ...         return u'Foobar'\n        >>> cpb = CustomProgressBar('a', 'b')\n        >>> print(cpb.get_text())\n        Foobar\n        >>> for x in range(101):\n        ...     cpb.set_completion(x)\n        ...     s = cpb.render((10, ))\n        >>> cpb2 = CustomProgressBar('a', 'b', satt='c')\n        >>> for x in range(101):\n        ...     cpb2.set_completion(x)\n        ...     s = cpb2.render((10, ))\n        \"\"\"\n        self.normal = normal\n        self.complete = complete\n        self._current = current\n        self._done = done\n        self.satt = satt",
  "def set_completion(self, current):\n        \"\"\"\n        current -- current progress\n        \"\"\"\n        self._current = current\n        self._invalidate()",
  "def done(self):\n        return self._done",
  "def done(self, done):\n        \"\"\"\n        done -- progress amount at 100%\n        \"\"\"\n        self._done = done\n        self._invalidate()",
  "def _set_done(self, done):\n        warnings.warn(\n            f\"Method `{self.__class__.__name__}._set_done` is deprecated, \"\n            f\"please use property `{self.__class__.__name__}.done`\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        self.done = done",
  "def rows(self, size, focus: bool = False) -> int:\n        return 1",
  "def get_text(self) -> str:\n        \"\"\"\n        Return the progress bar percentage text.\n        You can override this method to display custom text.\n        \"\"\"\n        percent = min(100, max(0, int(self.current * 100 / self.done)))\n        return f\"{percent!s} %\"",
  "def render(self, size: tuple[int], focus: bool = False) -> TextCanvas:\n        \"\"\"\n        Render the progress bar.\n        \"\"\"\n        (maxcol,) = size\n        txt = Text(self.get_text(), self.text_align, WrapMode.CLIP)\n        c = txt.render((maxcol,))\n\n        cf = float(self.current) * maxcol / self.done\n        ccol_dirty = int(cf)\n        ccol = len(c._text[0][:ccol_dirty].decode(\"utf-8\", \"ignore\").encode(\"utf-8\"))\n        cs = 0\n        if self.satt is not None:\n            cs = int((cf - ccol) * 8)\n        if ccol < 0 or (ccol == 0 and cs == 0):\n            c._attr = [[(self.normal, maxcol)]]\n        elif ccol >= maxcol:\n            c._attr = [[(self.complete, maxcol)]]\n        elif cs and c._text[0][ccol] == 32:\n            t = c._text[0]\n            cenc = self.eighths[cs].encode(\"utf-8\")\n            c._text[0] = t[:ccol] + cenc + t[ccol + 1 :]\n            a = []\n            if ccol > 0:\n                a.append((self.complete, ccol))\n            a.append((self.satt, len(cenc)))\n            if maxcol - ccol - 1 > 0:\n                a.append((self.normal, maxcol - ccol - 1))\n            c._attr = [a]\n            c._cs = [[(None, len(c._text[0]))]]\n        else:\n            c._attr = [[(self.complete, ccol), (self.normal, maxcol - ccol)]]\n        return c",
  "class PileError(Exception):\n    pass",
  "class Pile(Widget, WidgetContainerMixin, WidgetContainerListContentsMixin):\n    \"\"\"\n    A pile of widgets stacked vertically from top to bottom\n    \"\"\"\n\n    _sizing = frozenset([Sizing.FLOW, Sizing.BOX])\n\n    def __init__(self, widget_list: Iterable[Widget], focus_item: Widget | int | None = None) -> None:\n        \"\"\"\n        :param widget_list: child widgets\n        :type widget_list: iterable\n        :param focus_item: child widget that gets the focus initially.\n            Chooses the first selectable widget if unset.\n        :type focus_item: Widget or int\n\n        *widget_list* may also contain tuples such as:\n\n        (*given_height*, *widget*)\n            always treat *widget* as a box widget and give it *given_height* rows,\n            where given_height is an int\n        (``'pack'``, *widget*)\n            allow *widget* to calculate its own height by calling its :meth:`rows`\n            method, ie. treat it as a flow widget.\n        (``'weight'``, *weight*, *widget*)\n            if the pile is treated as a box widget then treat widget as a box\n            widget with a height based on its relative weight value, otherwise\n            treat the same as (``'pack'``, *widget*).\n\n        Widgets not in a tuple are the same as (``'weight'``, ``1``, *widget*)`\n\n        .. note:: If the Pile is treated as a box widget there must be at least\n            one ``'weight'`` tuple in :attr:`widget_list`.\n        \"\"\"\n        self._selectable = False\n        super().__init__()\n        self._contents = MonitoredFocusList()\n        self._contents.set_modified_callback(self._contents_modified)\n        self._contents.set_focus_changed_callback(lambda f: self._invalidate())\n        self._contents.set_validate_contents_modified(self._validate_contents_modified)\n\n        for i, original in enumerate(widget_list):\n            w = original\n            if not isinstance(w, tuple):\n                self.contents.append((w, (WHSettings.WEIGHT, 1)))\n            elif w[0] in (Sizing.FLOW, WHSettings.PACK):\n                f, w = w\n                self.contents.append((w, (WHSettings.PACK, None)))\n            elif len(w) == 2:\n                height, w = w\n                self.contents.append((w, (WHSettings.GIVEN, height)))\n            elif w[0] == Sizing.FIXED:  # backwards compatibility\n                _ignore, height, w = w\n                self.contents.append((w, (WHSettings.GIVEN, height)))\n            elif w[0] == WHSettings.WEIGHT:\n                f, height, w = w\n                self.contents.append((w, (f, height)))\n            else:\n                raise PileError(f\"initial widget list item invalid {original!r}\")\n            if focus_item is None and w.selectable():\n                focus_item = i\n\n        if self.contents and focus_item is not None:\n            self.focus = focus_item\n\n        self.pref_col = 0\n\n    def _contents_modified(self) -> None:\n        \"\"\"\n        Recalculate whether this widget should be selectable whenever the\n        contents has been changed.\n        \"\"\"\n        self._selectable = any(w.selectable() for w, o in self.contents)\n        self._invalidate()\n\n    def _validate_contents_modified(self, slc, new_items):\n        for item in new_items:\n            try:\n                w, (t, n) = item\n                if t not in (WHSettings.PACK, WHSettings.GIVEN, WHSettings.WEIGHT):\n                    raise PileError(f\"added content invalid: {item!r}\")\n            except (TypeError, ValueError) as exc:  # noqa: PERF203\n                raise PileError(f\"added content invalid: {item!r}\").with_traceback(exc.__traceback__) from exc\n\n    @property\n    def widget_list(self):\n        \"\"\"\n        A list of the widgets in this Pile\n\n        .. note:: only for backwards compatibility. You should use the new\n            standard container property :attr:`contents`.\n        \"\"\"\n        warnings.warn(\n            \"only for backwards compatibility. You should use the new standard container property `contents`\",\n            PendingDeprecationWarning,\n            stacklevel=2,\n        )\n        ml = MonitoredList(w for w, t in self.contents)\n\n        def user_modified():\n            self.widget_list = ml\n\n        ml.set_modified_callback(user_modified)\n        return ml\n\n    @widget_list.setter\n    def widget_list(self, widgets):\n        focus_position = self.focus_position\n        self.contents = [\n            (new, options)\n            for (new, (w, options)) in zip(\n                widgets,\n                # need to grow contents list if widgets is longer\n                chain(self.contents, repeat((None, (WHSettings.WEIGHT, 1)))),\n            )\n        ]\n        if focus_position < len(widgets):\n            self.focus_position = focus_position\n\n    @property\n    def item_types(self):\n        \"\"\"\n        A list of the options values for widgets in this Pile.\n\n        .. note:: only for backwards compatibility. You should use the new\n            standard container property :attr:`contents`.\n        \"\"\"\n        warnings.warn(\n            \"only for backwards compatibility. You should use the new standard container property `contents`\",\n            PendingDeprecationWarning,\n            stacklevel=2,\n        )\n        ml = MonitoredList(\n            # return the old item type names\n            ({WHSettings.GIVEN: Sizing.FIXED, WHSettings.PACK: Sizing.FLOW}.get(f, f), height)\n            for w, (f, height) in self.contents\n        )\n\n        def user_modified():\n            self.item_types = ml\n\n        ml.set_modified_callback(user_modified)\n        return ml\n\n    @item_types.setter\n    def item_types(self, item_types):\n        warnings.warn(\n            \"only for backwards compatibility. You should use the new standard container property `contents`\",\n            PendingDeprecationWarning,\n            stacklevel=2,\n        )\n        focus_position = self.focus_position\n        self.contents = [\n            (w, ({Sizing.FIXED: WHSettings.GIVEN, Sizing.FLOW: WHSettings.PACK}.get(new_t, new_t), new_height))\n            for ((new_t, new_height), (w, options)) in zip(item_types, self.contents)\n        ]\n        if focus_position < len(item_types):\n            self.focus_position = focus_position\n\n    @property\n    def contents(self):\n        \"\"\"\n        The contents of this Pile as a list of (widget, options) tuples.\n\n        options currently may be one of\n\n        (``'pack'``, ``None``)\n            allow widget to calculate its own height by calling its\n            :meth:`rows <Widget.rows>` method, i.e. treat it as a flow widget.\n        (``'given'``, *n*)\n            Always treat widget as a box widget with a given height of *n* rows.\n        (``'weight'``, *w*)\n            If the Pile itself is treated as a box widget then\n            the value *w* will be used as a relative weight for assigning rows\n            to this box widget. If the Pile is being treated as a flow\n            widget then this is the same as (``'pack'``, ``None``) and the *w*\n            value is ignored.\n\n        If the Pile itself is treated as a box widget then at least one\n        widget must have a (``'weight'``, *w*) options value, or the Pile will\n        not be able to grow to fill the required number of rows.\n\n        This list may be modified like a normal list and the Pile widget\n        will updated automatically.\n\n        .. seealso:: Create new options tuples with the :meth:`options` method\n        \"\"\"\n        return self._contents\n\n    @contents.setter\n    def contents(self, c):\n        self._contents[:] = c\n\n    @staticmethod\n    def options(\n        height_type: Literal[\"pack\", \"given\", \"weight\"] = WHSettings.WEIGHT,\n        height_amount: int | None = 1,\n    ) -> tuple[Literal[\"pack\"], None] | tuple[Literal[\"given\", \"weight\"], int]:\n        \"\"\"\n        Return a new options tuple for use in a Pile's :attr:`contents` list.\n\n        :param height_type: ``'pack'``, ``'given'`` or ``'weight'``\n        :param height_amount: ``None`` for ``'pack'``, a number of rows for\n            ``'fixed'`` or a weight value (number) for ``'weight'``\n        \"\"\"\n\n        if height_type == WHSettings.PACK:\n            return (WHSettings.PACK, None)\n        if height_type not in (WHSettings.GIVEN, WHSettings.WEIGHT):\n            raise PileError(f\"invalid height_type: {height_type!r}\")\n        return (height_type, height_amount)\n\n    @property\n    def focus(self) -> Widget | None:\n        \"\"\"the child widget in focus or None when Pile is empty\"\"\"\n        if not self.contents:\n            return None\n        return self.contents[self.focus_position][0]\n\n    @focus.setter\n    def focus(self, item: Widget | int) -> None:\n        \"\"\"\n        Set the item in focus, for backwards compatibility.\n\n        .. note:: only for backwards compatibility. You should use the new\n            standard container property :attr:`focus_position`.\n            to set the position by integer index instead.\n\n        :param item: element to focus\n        :type item: Widget or int\n        \"\"\"\n        if isinstance(item, int):\n            self.focus_position = item\n            return\n        for i, (w, _options) in enumerate(self.contents):\n            if item == w:\n                self.focus_position = i\n                return\n        raise ValueError(f\"Widget not found in Pile contents: {item!r}\")\n\n    def _get_focus(self) -> Widget:\n        warnings.warn(\n            f\"method `{self.__class__.__name__}._get_focus` is deprecated, \"\n            f\"please use `{self.__class__.__name__}.focus` property\",\n            DeprecationWarning,\n            stacklevel=3,\n        )\n        if not self.contents:\n            return None\n        return self.contents[self.focus_position][0]\n\n    def get_focus(self) -> Widget | None:\n        \"\"\"\n        Return the widget in focus, for backwards compatibility.  You may\n        also use the new standard container property .focus to get the\n        child widget in focus.\n        \"\"\"\n        warnings.warn(\n            \"for backwards compatibility.\"\n            \"You may also use the new standard container property .focus to get the child widget in focus.\",\n            PendingDeprecationWarning,\n            stacklevel=2,\n        )\n        if not self.contents:\n            return None\n        return self.contents[self.focus_position][0]\n\n    def set_focus(self, item: Widget | int) -> None:\n        warnings.warn(\n            \"for backwards compatibility.\"\n            \"You may also use the new standard container property .focus to get the child widget in focus.\",\n            PendingDeprecationWarning,\n            stacklevel=2,\n        )\n        if isinstance(item, int):\n            self.focus_position = item\n            return\n        for i, (w, _options) in enumerate(self.contents):\n            if item == w:\n                self.focus_position = i\n                return\n        raise ValueError(f\"Widget not found in Pile contents: {item!r}\")\n\n    @property\n    def focus_item(self):\n        warnings.warn(\n            \"only for backwards compatibility.\"\n            \"You should use the new standard container properties \"\n            \"`focus` and `focus_position` to get the child widget in focus or modify the focus position.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        return self.focus\n\n    @focus_item.setter\n    def focus_item(self, new_item):\n        warnings.warn(\n            \"only for backwards compatibility.\"\n            \"You should use the new standard container properties \"\n            \"`focus` and `focus_position` to get the child widget in focus or modify the focus position.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        self.focus = new_item\n\n    @property\n    def focus_position(self) -> int:\n        \"\"\"\n        index of child widget in focus.\n        Raises :exc:`IndexError` if read when Pile is empty, or when set to an invalid index.\n        \"\"\"\n        if not self.contents:\n            raise IndexError(\"No focus_position, Pile is empty\")\n        return self.contents.focus\n\n    @focus_position.setter\n    def focus_position(self, position: int) -> None:\n        \"\"\"\n        Set the widget in focus.\n\n        position -- index of child widget to be made focus\n        \"\"\"\n        try:\n            if position < 0 or position >= len(self.contents):\n                raise IndexError(f\"No Pile child widget at position {position}\")\n        except TypeError as exc:\n            raise IndexError(f\"No Pile child widget at position {position}\").with_traceback(exc.__traceback__) from exc\n        self.contents.focus = position\n\n    def _get_focus_position(self) -> int | None:\n        warnings.warn(\n            f\"method `{self.__class__.__name__}._get_focus_position` is deprecated, \"\n            f\"please use `{self.__class__.__name__}.focus_position` property\",\n            DeprecationWarning,\n            stacklevel=3,\n        )\n        if not self.contents:\n            raise IndexError(\"No focus_position, Pile is empty\")\n        return self.contents.focus\n\n    def _set_focus_position(self, position: int) -> None:\n        \"\"\"\n        Set the widget in focus.\n\n        position -- index of child widget to be made focus\n        \"\"\"\n        warnings.warn(\n            f\"method `{self.__class__.__name__}._set_focus_position` is deprecated, \"\n            f\"please use `{self.__class__.__name__}.focus_position` property\",\n            DeprecationWarning,\n            stacklevel=3,\n        )\n        try:\n            if position < 0 or position >= len(self.contents):\n                raise IndexError(f\"No Pile child widget at position {position}\")\n        except TypeError as exc:\n            raise IndexError(f\"No Pile child widget at position {position}\").with_traceback(exc.__traceback__) from exc\n        self.contents.focus = position\n\n    def get_pref_col(self, size):\n        \"\"\"Return the preferred column for the cursor, or None.\"\"\"\n        if not self.selectable():\n            return None\n        self._update_pref_col_from_focus(size)\n        return self.pref_col\n\n    def get_item_size(\n        self,\n        size: tuple[int] | tuple[int, int],\n        i: int,\n        focus: bool,\n        item_rows: list[int] | None = None,\n    ) -> tuple[int] | tuple[int, int]:\n        \"\"\"\n        Return a size appropriate for passing to self.contents[i][0].render\n        \"\"\"\n        maxcol = size[0]\n        w, (f, height) = self.contents[i]\n        if f == WHSettings.GIVEN:\n            return (maxcol, height)\n\n        if f == WHSettings.WEIGHT and len(size) == 2:\n            if not item_rows:\n                item_rows = self.get_item_rows(size, focus)\n            return (maxcol, item_rows[i])\n\n        return (maxcol,)\n\n    def get_item_rows(self, size: tuple[int] | tuple[int, int], focus: bool) -> list[int]:\n        \"\"\"\n        Return a list of the number of rows used by each widget\n        in self.contents\n        \"\"\"\n        remaining = None\n        maxcol = size[0]\n        if len(size) == 2:\n            remaining = size[1]\n\n        rows_numbers = []\n\n        if remaining is None:\n            # pile is a flow widget\n            for w, (f, height) in self.contents:\n                if f == WHSettings.GIVEN:\n                    rows_numbers.append(height)\n                else:\n                    rows_numbers.append(w.rows((maxcol,), focus=focus and self.focus == w))\n            return rows_numbers\n\n        # pile is a box widget\n        # do an extra pass to calculate rows for each widget\n        wtotal = 0\n        for w, (f, height) in self.contents:\n            if f == WHSettings.PACK:\n                rows = w.rows((maxcol,), focus=focus and self.focus == w)\n                rows_numbers.append(rows)\n                remaining -= rows\n            elif f == WHSettings.GIVEN:\n                rows_numbers.append(height)\n                remaining -= height\n            elif height:\n                rows_numbers.append(None)\n                wtotal += height\n            else:\n                rows_numbers.append(0)  # zero-weighted items treated as ('given', 0)\n\n        if wtotal == 0:\n            raise PileError(\"No weighted widgets found for Pile treated as a box widget\")\n\n        if remaining < 0:\n            remaining = 0\n\n        for i, (_w, (_f, height)) in enumerate(self.contents):\n            li = rows_numbers[i]\n            if li is None:\n                rows = int(float(remaining) * height / wtotal + 0.5)\n                rows_numbers[i] = rows\n                remaining -= rows\n                wtotal -= height\n        return rows_numbers\n\n    def render(self, size, focus=False):\n        maxcol = size[0]\n        item_rows = None\n\n        combinelist = []\n        for i, (w, (f, height)) in enumerate(self.contents):\n            item_focus = self.focus == w\n            canv = None\n            if f == WHSettings.GIVEN:\n                canv = w.render((maxcol, height), focus=focus and item_focus)\n            elif f == WHSettings.PACK or len(size) == 1:\n                canv = w.render((maxcol,), focus=focus and item_focus)\n            else:\n                if item_rows is None:\n                    item_rows = self.get_item_rows(size, focus)\n                rows = item_rows[i]\n                if rows > 0:\n                    canv = w.render((maxcol, rows), focus=focus and item_focus)\n            if canv:\n                combinelist.append((canv, i, item_focus))\n        if not combinelist:\n            return SolidCanvas(\" \", size[0], (size[1:] + (0,))[0])\n\n        out = CanvasCombine(combinelist)\n        if len(size) == 2 and size[1] != out.rows():\n            # flow/fixed widgets rendered too large/small\n            out = CompositeCanvas(out)\n            out.pad_trim_top_bottom(0, size[1] - out.rows())\n        return out\n\n    def get_cursor_coords(self, size: tuple[int] | tuple[int, int]) -> tuple[int, int] | None:\n        \"\"\"Return the cursor coordinates of the focus widget.\"\"\"\n        if not self.selectable():\n            return None\n        if not hasattr(self.focus, \"get_cursor_coords\"):\n            return None\n\n        i = self.focus_position\n        w, (f, height) = self.contents[i]\n        item_rows = None\n        maxcol = size[0]\n        if f == WHSettings.GIVEN or (f == WHSettings.WEIGHT and len(size) == 2):\n            if f == WHSettings.GIVEN:\n                maxrow = height\n            else:\n                if item_rows is None:\n                    item_rows = self.get_item_rows(size, focus=True)\n                maxrow = item_rows[i]\n            coords = self.focus.get_cursor_coords((maxcol, maxrow))\n        else:\n            coords = self.focus.get_cursor_coords((maxcol,))\n\n        if coords is None:\n            return None\n        x, y = coords\n        if i > 0:\n            if item_rows is None:\n                item_rows = self.get_item_rows(size, focus=True)\n            for r in item_rows[:i]:\n                y += r\n        return x, y\n\n    def rows(self, size: tuple[int] | tuple[int, int], focus: bool = False) -> int:\n        return sum(self.get_item_rows(size, focus))\n\n    def keypress(self, size: tuple[int] | tuple[int, int], key: str) -> str | None:\n        \"\"\"Pass the keypress to the widget in focus.\n        Unhandled 'up' and 'down' keys may cause a focus change.\"\"\"\n        if not self.contents:\n            return key\n\n        item_rows = None\n        if len(size) == 2:\n            item_rows = self.get_item_rows(size, focus=True)\n\n        i = self.focus_position\n        if self.selectable():\n            tsize = self.get_item_size(size, i, True, item_rows)\n            key = self.focus.keypress(tsize, key)\n            if self._command_map[key] not in (\"cursor up\", \"cursor down\"):\n                return key\n\n        if self._command_map[key] == \"cursor up\":\n            candidates = list(range(i - 1, -1, -1))  # count backwards to 0\n        else:  # self._command_map[key] == 'cursor down'\n            candidates = list(range(i + 1, len(self.contents)))\n\n        if not item_rows:\n            item_rows = self.get_item_rows(size, focus=True)\n\n        for j in candidates:\n            if not self.contents[j][0].selectable():\n                continue\n\n            self._update_pref_col_from_focus(size)\n            self.focus_position = j\n            if not hasattr(self.focus, \"move_cursor_to_coords\"):\n                return None\n\n            rows = item_rows[j]\n            if self._command_map[key] == \"cursor up\":\n                rowlist = list(range(rows - 1, -1, -1))\n            else:  # self._command_map[key] == 'cursor down'\n                rowlist = list(range(rows))\n            for row in rowlist:\n                tsize = self.get_item_size(size, j, True, item_rows)\n                if self.focus.move_cursor_to_coords(tsize, self.pref_col, row):\n                    break\n            return None\n\n        # nothing to select\n        return key\n\n    def _update_pref_col_from_focus(self, size: tuple[int] | tuple[int, int]) -> None:\n        \"\"\"Update self.pref_col from the focus widget.\"\"\"\n\n        if not hasattr(self.focus, \"get_pref_col\"):\n            return\n        i = self.focus_position\n        tsize = self.get_item_size(size, i, True)\n        pref_col = self.focus.get_pref_col(tsize)\n        if pref_col is not None:\n            self.pref_col = pref_col\n\n    def move_cursor_to_coords(self, size: tuple[int] | tuple[int, int], col: int, row: int) -> bool:\n        \"\"\"Capture pref col and set new focus.\"\"\"\n        self.pref_col = col\n\n        # FIXME guessing focus==True\n        focus = True\n        wrow = 0\n        item_rows = self.get_item_rows(size, focus)\n        for i, (r, w) in enumerate(zip(item_rows, (w for (w, options) in self.contents))):  # noqa: B007\n            if wrow + r > row:\n                break\n            wrow += r\n        else:\n            return False\n\n        if not w.selectable():\n            return False\n\n        if hasattr(w, \"move_cursor_to_coords\"):\n            tsize = self.get_item_size(size, i, focus, item_rows)\n            rval = w.move_cursor_to_coords(tsize, col, row - wrow)\n            if rval is False:\n                return False\n\n        self.focus_position = i\n        return True\n\n    def mouse_event(\n        self,\n        size: tuple[int] | tuple[int, int],\n        event,\n        button: int,\n        col: int,\n        row: int,\n        focus: bool,\n    ) -> bool | None:\n        \"\"\"\n        Pass the event to the contained widget.\n        May change focus on button 1 press.\n        \"\"\"\n        wrow = 0\n        item_rows = self.get_item_rows(size, focus)\n        for i, (r, w) in enumerate(zip(item_rows, (w for (w, options) in self.contents))):  # noqa: B007\n            if wrow + r > row:\n                break\n            wrow += r\n        else:\n            return False\n\n        focus = focus and self.focus == w\n        if is_mouse_press(event) and button == 1 and w.selectable():\n            self.focus_position = i\n\n        if not hasattr(w, \"mouse_event\"):\n            return False\n\n        tsize = self.get_item_size(size, i, focus, item_rows)\n        return w.mouse_event(tsize, event, button, col, row - wrow, focus)",
  "def __init__(self, widget_list: Iterable[Widget], focus_item: Widget | int | None = None) -> None:\n        \"\"\"\n        :param widget_list: child widgets\n        :type widget_list: iterable\n        :param focus_item: child widget that gets the focus initially.\n            Chooses the first selectable widget if unset.\n        :type focus_item: Widget or int\n\n        *widget_list* may also contain tuples such as:\n\n        (*given_height*, *widget*)\n            always treat *widget* as a box widget and give it *given_height* rows,\n            where given_height is an int\n        (``'pack'``, *widget*)\n            allow *widget* to calculate its own height by calling its :meth:`rows`\n            method, ie. treat it as a flow widget.\n        (``'weight'``, *weight*, *widget*)\n            if the pile is treated as a box widget then treat widget as a box\n            widget with a height based on its relative weight value, otherwise\n            treat the same as (``'pack'``, *widget*).\n\n        Widgets not in a tuple are the same as (``'weight'``, ``1``, *widget*)`\n\n        .. note:: If the Pile is treated as a box widget there must be at least\n            one ``'weight'`` tuple in :attr:`widget_list`.\n        \"\"\"\n        self._selectable = False\n        super().__init__()\n        self._contents = MonitoredFocusList()\n        self._contents.set_modified_callback(self._contents_modified)\n        self._contents.set_focus_changed_callback(lambda f: self._invalidate())\n        self._contents.set_validate_contents_modified(self._validate_contents_modified)\n\n        for i, original in enumerate(widget_list):\n            w = original\n            if not isinstance(w, tuple):\n                self.contents.append((w, (WHSettings.WEIGHT, 1)))\n            elif w[0] in (Sizing.FLOW, WHSettings.PACK):\n                f, w = w\n                self.contents.append((w, (WHSettings.PACK, None)))\n            elif len(w) == 2:\n                height, w = w\n                self.contents.append((w, (WHSettings.GIVEN, height)))\n            elif w[0] == Sizing.FIXED:  # backwards compatibility\n                _ignore, height, w = w\n                self.contents.append((w, (WHSettings.GIVEN, height)))\n            elif w[0] == WHSettings.WEIGHT:\n                f, height, w = w\n                self.contents.append((w, (f, height)))\n            else:\n                raise PileError(f\"initial widget list item invalid {original!r}\")\n            if focus_item is None and w.selectable():\n                focus_item = i\n\n        if self.contents and focus_item is not None:\n            self.focus = focus_item\n\n        self.pref_col = 0",
  "def _contents_modified(self) -> None:\n        \"\"\"\n        Recalculate whether this widget should be selectable whenever the\n        contents has been changed.\n        \"\"\"\n        self._selectable = any(w.selectable() for w, o in self.contents)\n        self._invalidate()",
  "def _validate_contents_modified(self, slc, new_items):\n        for item in new_items:\n            try:\n                w, (t, n) = item\n                if t not in (WHSettings.PACK, WHSettings.GIVEN, WHSettings.WEIGHT):\n                    raise PileError(f\"added content invalid: {item!r}\")\n            except (TypeError, ValueError) as exc:  # noqa: PERF203\n                raise PileError(f\"added content invalid: {item!r}\").with_traceback(exc.__traceback__) from exc",
  "def widget_list(self):\n        \"\"\"\n        A list of the widgets in this Pile\n\n        .. note:: only for backwards compatibility. You should use the new\n            standard container property :attr:`contents`.\n        \"\"\"\n        warnings.warn(\n            \"only for backwards compatibility. You should use the new standard container property `contents`\",\n            PendingDeprecationWarning,\n            stacklevel=2,\n        )\n        ml = MonitoredList(w for w, t in self.contents)\n\n        def user_modified():\n            self.widget_list = ml\n\n        ml.set_modified_callback(user_modified)\n        return ml",
  "def widget_list(self, widgets):\n        focus_position = self.focus_position\n        self.contents = [\n            (new, options)\n            for (new, (w, options)) in zip(\n                widgets,\n                # need to grow contents list if widgets is longer\n                chain(self.contents, repeat((None, (WHSettings.WEIGHT, 1)))),\n            )\n        ]\n        if focus_position < len(widgets):\n            self.focus_position = focus_position",
  "def item_types(self):\n        \"\"\"\n        A list of the options values for widgets in this Pile.\n\n        .. note:: only for backwards compatibility. You should use the new\n            standard container property :attr:`contents`.\n        \"\"\"\n        warnings.warn(\n            \"only for backwards compatibility. You should use the new standard container property `contents`\",\n            PendingDeprecationWarning,\n            stacklevel=2,\n        )\n        ml = MonitoredList(\n            # return the old item type names\n            ({WHSettings.GIVEN: Sizing.FIXED, WHSettings.PACK: Sizing.FLOW}.get(f, f), height)\n            for w, (f, height) in self.contents\n        )\n\n        def user_modified():\n            self.item_types = ml\n\n        ml.set_modified_callback(user_modified)\n        return ml",
  "def item_types(self, item_types):\n        warnings.warn(\n            \"only for backwards compatibility. You should use the new standard container property `contents`\",\n            PendingDeprecationWarning,\n            stacklevel=2,\n        )\n        focus_position = self.focus_position\n        self.contents = [\n            (w, ({Sizing.FIXED: WHSettings.GIVEN, Sizing.FLOW: WHSettings.PACK}.get(new_t, new_t), new_height))\n            for ((new_t, new_height), (w, options)) in zip(item_types, self.contents)\n        ]\n        if focus_position < len(item_types):\n            self.focus_position = focus_position",
  "def contents(self):\n        \"\"\"\n        The contents of this Pile as a list of (widget, options) tuples.\n\n        options currently may be one of\n\n        (``'pack'``, ``None``)\n            allow widget to calculate its own height by calling its\n            :meth:`rows <Widget.rows>` method, i.e. treat it as a flow widget.\n        (``'given'``, *n*)\n            Always treat widget as a box widget with a given height of *n* rows.\n        (``'weight'``, *w*)\n            If the Pile itself is treated as a box widget then\n            the value *w* will be used as a relative weight for assigning rows\n            to this box widget. If the Pile is being treated as a flow\n            widget then this is the same as (``'pack'``, ``None``) and the *w*\n            value is ignored.\n\n        If the Pile itself is treated as a box widget then at least one\n        widget must have a (``'weight'``, *w*) options value, or the Pile will\n        not be able to grow to fill the required number of rows.\n\n        This list may be modified like a normal list and the Pile widget\n        will updated automatically.\n\n        .. seealso:: Create new options tuples with the :meth:`options` method\n        \"\"\"\n        return self._contents",
  "def contents(self, c):\n        self._contents[:] = c",
  "def options(\n        height_type: Literal[\"pack\", \"given\", \"weight\"] = WHSettings.WEIGHT,\n        height_amount: int | None = 1,\n    ) -> tuple[Literal[\"pack\"], None] | tuple[Literal[\"given\", \"weight\"], int]:\n        \"\"\"\n        Return a new options tuple for use in a Pile's :attr:`contents` list.\n\n        :param height_type: ``'pack'``, ``'given'`` or ``'weight'``\n        :param height_amount: ``None`` for ``'pack'``, a number of rows for\n            ``'fixed'`` or a weight value (number) for ``'weight'``\n        \"\"\"\n\n        if height_type == WHSettings.PACK:\n            return (WHSettings.PACK, None)\n        if height_type not in (WHSettings.GIVEN, WHSettings.WEIGHT):\n            raise PileError(f\"invalid height_type: {height_type!r}\")\n        return (height_type, height_amount)",
  "def focus(self) -> Widget | None:\n        \"\"\"the child widget in focus or None when Pile is empty\"\"\"\n        if not self.contents:\n            return None\n        return self.contents[self.focus_position][0]",
  "def focus(self, item: Widget | int) -> None:\n        \"\"\"\n        Set the item in focus, for backwards compatibility.\n\n        .. note:: only for backwards compatibility. You should use the new\n            standard container property :attr:`focus_position`.\n            to set the position by integer index instead.\n\n        :param item: element to focus\n        :type item: Widget or int\n        \"\"\"\n        if isinstance(item, int):\n            self.focus_position = item\n            return\n        for i, (w, _options) in enumerate(self.contents):\n            if item == w:\n                self.focus_position = i\n                return\n        raise ValueError(f\"Widget not found in Pile contents: {item!r}\")",
  "def _get_focus(self) -> Widget:\n        warnings.warn(\n            f\"method `{self.__class__.__name__}._get_focus` is deprecated, \"\n            f\"please use `{self.__class__.__name__}.focus` property\",\n            DeprecationWarning,\n            stacklevel=3,\n        )\n        if not self.contents:\n            return None\n        return self.contents[self.focus_position][0]",
  "def get_focus(self) -> Widget | None:\n        \"\"\"\n        Return the widget in focus, for backwards compatibility.  You may\n        also use the new standard container property .focus to get the\n        child widget in focus.\n        \"\"\"\n        warnings.warn(\n            \"for backwards compatibility.\"\n            \"You may also use the new standard container property .focus to get the child widget in focus.\",\n            PendingDeprecationWarning,\n            stacklevel=2,\n        )\n        if not self.contents:\n            return None\n        return self.contents[self.focus_position][0]",
  "def set_focus(self, item: Widget | int) -> None:\n        warnings.warn(\n            \"for backwards compatibility.\"\n            \"You may also use the new standard container property .focus to get the child widget in focus.\",\n            PendingDeprecationWarning,\n            stacklevel=2,\n        )\n        if isinstance(item, int):\n            self.focus_position = item\n            return\n        for i, (w, _options) in enumerate(self.contents):\n            if item == w:\n                self.focus_position = i\n                return\n        raise ValueError(f\"Widget not found in Pile contents: {item!r}\")",
  "def focus_item(self):\n        warnings.warn(\n            \"only for backwards compatibility.\"\n            \"You should use the new standard container properties \"\n            \"`focus` and `focus_position` to get the child widget in focus or modify the focus position.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        return self.focus",
  "def focus_item(self, new_item):\n        warnings.warn(\n            \"only for backwards compatibility.\"\n            \"You should use the new standard container properties \"\n            \"`focus` and `focus_position` to get the child widget in focus or modify the focus position.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        self.focus = new_item",
  "def focus_position(self) -> int:\n        \"\"\"\n        index of child widget in focus.\n        Raises :exc:`IndexError` if read when Pile is empty, or when set to an invalid index.\n        \"\"\"\n        if not self.contents:\n            raise IndexError(\"No focus_position, Pile is empty\")\n        return self.contents.focus",
  "def focus_position(self, position: int) -> None:\n        \"\"\"\n        Set the widget in focus.\n\n        position -- index of child widget to be made focus\n        \"\"\"\n        try:\n            if position < 0 or position >= len(self.contents):\n                raise IndexError(f\"No Pile child widget at position {position}\")\n        except TypeError as exc:\n            raise IndexError(f\"No Pile child widget at position {position}\").with_traceback(exc.__traceback__) from exc\n        self.contents.focus = position",
  "def _get_focus_position(self) -> int | None:\n        warnings.warn(\n            f\"method `{self.__class__.__name__}._get_focus_position` is deprecated, \"\n            f\"please use `{self.__class__.__name__}.focus_position` property\",\n            DeprecationWarning,\n            stacklevel=3,\n        )\n        if not self.contents:\n            raise IndexError(\"No focus_position, Pile is empty\")\n        return self.contents.focus",
  "def _set_focus_position(self, position: int) -> None:\n        \"\"\"\n        Set the widget in focus.\n\n        position -- index of child widget to be made focus\n        \"\"\"\n        warnings.warn(\n            f\"method `{self.__class__.__name__}._set_focus_position` is deprecated, \"\n            f\"please use `{self.__class__.__name__}.focus_position` property\",\n            DeprecationWarning,\n            stacklevel=3,\n        )\n        try:\n            if position < 0 or position >= len(self.contents):\n                raise IndexError(f\"No Pile child widget at position {position}\")\n        except TypeError as exc:\n            raise IndexError(f\"No Pile child widget at position {position}\").with_traceback(exc.__traceback__) from exc\n        self.contents.focus = position",
  "def get_pref_col(self, size):\n        \"\"\"Return the preferred column for the cursor, or None.\"\"\"\n        if not self.selectable():\n            return None\n        self._update_pref_col_from_focus(size)\n        return self.pref_col",
  "def get_item_size(\n        self,\n        size: tuple[int] | tuple[int, int],\n        i: int,\n        focus: bool,\n        item_rows: list[int] | None = None,\n    ) -> tuple[int] | tuple[int, int]:\n        \"\"\"\n        Return a size appropriate for passing to self.contents[i][0].render\n        \"\"\"\n        maxcol = size[0]\n        w, (f, height) = self.contents[i]\n        if f == WHSettings.GIVEN:\n            return (maxcol, height)\n\n        if f == WHSettings.WEIGHT and len(size) == 2:\n            if not item_rows:\n                item_rows = self.get_item_rows(size, focus)\n            return (maxcol, item_rows[i])\n\n        return (maxcol,)",
  "def get_item_rows(self, size: tuple[int] | tuple[int, int], focus: bool) -> list[int]:\n        \"\"\"\n        Return a list of the number of rows used by each widget\n        in self.contents\n        \"\"\"\n        remaining = None\n        maxcol = size[0]\n        if len(size) == 2:\n            remaining = size[1]\n\n        rows_numbers = []\n\n        if remaining is None:\n            # pile is a flow widget\n            for w, (f, height) in self.contents:\n                if f == WHSettings.GIVEN:\n                    rows_numbers.append(height)\n                else:\n                    rows_numbers.append(w.rows((maxcol,), focus=focus and self.focus == w))\n            return rows_numbers\n\n        # pile is a box widget\n        # do an extra pass to calculate rows for each widget\n        wtotal = 0\n        for w, (f, height) in self.contents:\n            if f == WHSettings.PACK:\n                rows = w.rows((maxcol,), focus=focus and self.focus == w)\n                rows_numbers.append(rows)\n                remaining -= rows\n            elif f == WHSettings.GIVEN:\n                rows_numbers.append(height)\n                remaining -= height\n            elif height:\n                rows_numbers.append(None)\n                wtotal += height\n            else:\n                rows_numbers.append(0)  # zero-weighted items treated as ('given', 0)\n\n        if wtotal == 0:\n            raise PileError(\"No weighted widgets found for Pile treated as a box widget\")\n\n        if remaining < 0:\n            remaining = 0\n\n        for i, (_w, (_f, height)) in enumerate(self.contents):\n            li = rows_numbers[i]\n            if li is None:\n                rows = int(float(remaining) * height / wtotal + 0.5)\n                rows_numbers[i] = rows\n                remaining -= rows\n                wtotal -= height\n        return rows_numbers",
  "def render(self, size, focus=False):\n        maxcol = size[0]\n        item_rows = None\n\n        combinelist = []\n        for i, (w, (f, height)) in enumerate(self.contents):\n            item_focus = self.focus == w\n            canv = None\n            if f == WHSettings.GIVEN:\n                canv = w.render((maxcol, height), focus=focus and item_focus)\n            elif f == WHSettings.PACK or len(size) == 1:\n                canv = w.render((maxcol,), focus=focus and item_focus)\n            else:\n                if item_rows is None:\n                    item_rows = self.get_item_rows(size, focus)\n                rows = item_rows[i]\n                if rows > 0:\n                    canv = w.render((maxcol, rows), focus=focus and item_focus)\n            if canv:\n                combinelist.append((canv, i, item_focus))\n        if not combinelist:\n            return SolidCanvas(\" \", size[0], (size[1:] + (0,))[0])\n\n        out = CanvasCombine(combinelist)\n        if len(size) == 2 and size[1] != out.rows():\n            # flow/fixed widgets rendered too large/small\n            out = CompositeCanvas(out)\n            out.pad_trim_top_bottom(0, size[1] - out.rows())\n        return out",
  "def get_cursor_coords(self, size: tuple[int] | tuple[int, int]) -> tuple[int, int] | None:\n        \"\"\"Return the cursor coordinates of the focus widget.\"\"\"\n        if not self.selectable():\n            return None\n        if not hasattr(self.focus, \"get_cursor_coords\"):\n            return None\n\n        i = self.focus_position\n        w, (f, height) = self.contents[i]\n        item_rows = None\n        maxcol = size[0]\n        if f == WHSettings.GIVEN or (f == WHSettings.WEIGHT and len(size) == 2):\n            if f == WHSettings.GIVEN:\n                maxrow = height\n            else:\n                if item_rows is None:\n                    item_rows = self.get_item_rows(size, focus=True)\n                maxrow = item_rows[i]\n            coords = self.focus.get_cursor_coords((maxcol, maxrow))\n        else:\n            coords = self.focus.get_cursor_coords((maxcol,))\n\n        if coords is None:\n            return None\n        x, y = coords\n        if i > 0:\n            if item_rows is None:\n                item_rows = self.get_item_rows(size, focus=True)\n            for r in item_rows[:i]:\n                y += r\n        return x, y",
  "def rows(self, size: tuple[int] | tuple[int, int], focus: bool = False) -> int:\n        return sum(self.get_item_rows(size, focus))",
  "def keypress(self, size: tuple[int] | tuple[int, int], key: str) -> str | None:\n        \"\"\"Pass the keypress to the widget in focus.\n        Unhandled 'up' and 'down' keys may cause a focus change.\"\"\"\n        if not self.contents:\n            return key\n\n        item_rows = None\n        if len(size) == 2:\n            item_rows = self.get_item_rows(size, focus=True)\n\n        i = self.focus_position\n        if self.selectable():\n            tsize = self.get_item_size(size, i, True, item_rows)\n            key = self.focus.keypress(tsize, key)\n            if self._command_map[key] not in (\"cursor up\", \"cursor down\"):\n                return key\n\n        if self._command_map[key] == \"cursor up\":\n            candidates = list(range(i - 1, -1, -1))  # count backwards to 0\n        else:  # self._command_map[key] == 'cursor down'\n            candidates = list(range(i + 1, len(self.contents)))\n\n        if not item_rows:\n            item_rows = self.get_item_rows(size, focus=True)\n\n        for j in candidates:\n            if not self.contents[j][0].selectable():\n                continue\n\n            self._update_pref_col_from_focus(size)\n            self.focus_position = j\n            if not hasattr(self.focus, \"move_cursor_to_coords\"):\n                return None\n\n            rows = item_rows[j]\n            if self._command_map[key] == \"cursor up\":\n                rowlist = list(range(rows - 1, -1, -1))\n            else:  # self._command_map[key] == 'cursor down'\n                rowlist = list(range(rows))\n            for row in rowlist:\n                tsize = self.get_item_size(size, j, True, item_rows)\n                if self.focus.move_cursor_to_coords(tsize, self.pref_col, row):\n                    break\n            return None\n\n        # nothing to select\n        return key",
  "def _update_pref_col_from_focus(self, size: tuple[int] | tuple[int, int]) -> None:\n        \"\"\"Update self.pref_col from the focus widget.\"\"\"\n\n        if not hasattr(self.focus, \"get_pref_col\"):\n            return\n        i = self.focus_position\n        tsize = self.get_item_size(size, i, True)\n        pref_col = self.focus.get_pref_col(tsize)\n        if pref_col is not None:\n            self.pref_col = pref_col",
  "def move_cursor_to_coords(self, size: tuple[int] | tuple[int, int], col: int, row: int) -> bool:\n        \"\"\"Capture pref col and set new focus.\"\"\"\n        self.pref_col = col\n\n        # FIXME guessing focus==True\n        focus = True\n        wrow = 0\n        item_rows = self.get_item_rows(size, focus)\n        for i, (r, w) in enumerate(zip(item_rows, (w for (w, options) in self.contents))):  # noqa: B007\n            if wrow + r > row:\n                break\n            wrow += r\n        else:\n            return False\n\n        if not w.selectable():\n            return False\n\n        if hasattr(w, \"move_cursor_to_coords\"):\n            tsize = self.get_item_size(size, i, focus, item_rows)\n            rval = w.move_cursor_to_coords(tsize, col, row - wrow)\n            if rval is False:\n                return False\n\n        self.focus_position = i\n        return True",
  "def mouse_event(\n        self,\n        size: tuple[int] | tuple[int, int],\n        event,\n        button: int,\n        col: int,\n        row: int,\n        focus: bool,\n    ) -> bool | None:\n        \"\"\"\n        Pass the event to the contained widget.\n        May change focus on button 1 press.\n        \"\"\"\n        wrow = 0\n        item_rows = self.get_item_rows(size, focus)\n        for i, (r, w) in enumerate(zip(item_rows, (w for (w, options) in self.contents))):  # noqa: B007\n            if wrow + r > row:\n                break\n            wrow += r\n        else:\n            return False\n\n        focus = focus and self.focus == w\n        if is_mouse_press(event) and button == 1 and w.selectable():\n            self.focus_position = i\n\n        if not hasattr(w, \"mouse_event\"):\n            return False\n\n        tsize = self.get_item_size(size, i, focus, item_rows)\n        return w.mouse_event(tsize, event, button, col, row - wrow, focus)",
  "def user_modified():\n            self.widget_list = ml",
  "def user_modified():\n            self.item_types = ml",
  "class WidgetContainerMixin:\n    \"\"\"\n    Mixin class for widget containers implementing common container methods\n    \"\"\"\n\n    def __getitem__(self, position) -> Widget:\n        \"\"\"\n        Container short-cut for self.contents[position][0].base_widget\n        which means \"give me the child widget at position without any\n        widget decorations\".\n\n        This allows for concise traversal of nested container widgets\n        such as:\n\n            my_widget[position0][position1][position2] ...\n        \"\"\"\n        return self.contents[position][0].base_widget\n\n    def get_focus_path(self):\n        \"\"\"\n        Return the .focus_position values starting from this container\n        and proceeding along each child widget until reaching a leaf\n        (non-container) widget.\n        \"\"\"\n        out = []\n        w = self\n        while True:\n            try:\n                p = w.focus_position\n            except IndexError:\n                return out\n            out.append(p)\n            w = w.focus.base_widget\n\n    def set_focus_path(self, positions):\n        \"\"\"\n        Set the .focus_position property starting from this container\n        widget and proceeding along newly focused child widgets.  Any\n        failed assignment due do incompatible position types or invalid\n        positions will raise an IndexError.\n\n        This method may be used to restore a particular widget to the\n        focus by passing in the value returned from an earlier call to\n        get_focus_path().\n\n        positions -- sequence of positions\n        \"\"\"\n        w = self\n        for p in positions:\n            if p != w.focus_position:\n                w.focus_position = p  # modifies w.focus\n            w = w.focus.base_widget\n\n    def get_focus_widgets(self) -> list[Widget]:\n        \"\"\"\n        Return the .focus values starting from this container\n        and proceeding along each child widget until reaching a leaf\n        (non-container) widget.\n\n        Note that the list does not contain the topmost container widget\n        (i.e., on which this method is called), but does include the\n        lowest leaf widget.\n        \"\"\"\n        out = []\n        w = self\n        while True:\n            w = w.base_widget.focus\n            if w is None:\n                return out\n            out.append(w)\n\n    @property\n    @abc.abstractmethod\n    def focus(self) -> Widget:\n        \"\"\"\n        Read-only property returning the child widget in focus for\n        container widgets.  This default implementation\n        always returns ``None``, indicating that this widget has no children.\n        \"\"\"\n\n    def _get_focus(self) -> Widget:\n        warnings.warn(\n            f\"method `{self.__class__.__name__}._get_focus` is deprecated, \"\n            f\"please use `{self.__class__.__name__}.focus` property\",\n            DeprecationWarning,\n            stacklevel=3,\n        )\n        return self.focus",
  "class WidgetContainerListContentsMixin:\n    \"\"\"\n    Mixin class for widget containers whose positions are indexes into\n    a list available as self.contents.\n    \"\"\"\n\n    def __iter__(self) -> Iterator[int]:\n        \"\"\"\n        Return an iterable of positions for this container from first\n        to last.\n        \"\"\"\n        return iter(range(len(self.contents)))\n\n    def __reversed__(self) -> Iterator[int]:\n        \"\"\"\n        Return an iterable of positions for this container from last\n        to first.\n        \"\"\"\n        return iter(range(len(self.contents) - 1, -1, -1))\n\n    def __len__(self) -> int:\n        return len(self.contents)\n\n    @property\n    @abc.abstractmethod\n    def contents(self) -> list[tuple[Widget, typing.Any]]:\n        \"\"\"The contents of container as a list of (widget, options)\"\"\"\n\n    @contents.setter\n    def contents(self, new_contents: list[tuple[Widget, typing.Any]]) -> None:\n        \"\"\"The contents of container as a list of (widget, options)\"\"\"\n\n    def _get_contents(self) -> list[tuple[Widget, typing.Any]]:\n        warnings.warn(\n            f\"method `{self.__class__.__name__}._get_contents` is deprecated, \"\n            f\"please use `{self.__class__.__name__}.contents` property\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        return self.contents\n\n    def _set_contents(self, c: list[tuple[Widget, typing.Any]]) -> None:\n        warnings.warn(\n            f\"method `{self.__class__.__name__}._set_contents` is deprecated, \"\n            f\"please use `{self.__class__.__name__}.contents` property\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        self.contents = c\n\n    @property\n    @abc.abstractmethod\n    def focus_position(self) -> int | None:\n        \"\"\"\n        index of child widget in focus.\n        \"\"\"\n\n    @focus_position.setter\n    def focus_position(self, position: int) -> None:\n        \"\"\"\n        index of child widget in focus.\n        \"\"\"\n\n    def _get_focus_position(self) -> int | None:\n        warnings.warn(\n            f\"method `{self.__class__.__name__}._get_focus_position` is deprecated, \"\n            f\"please use `{self.__class__.__name__}.focus_position` property\",\n            DeprecationWarning,\n            stacklevel=3,\n        )\n        return self.focus_position\n\n    def _set_focus_position(self, position: int) -> None:\n        \"\"\"\n        Set the widget in focus.\n\n        position -- index of child widget to be made focus\n        \"\"\"\n        warnings.warn(\n            f\"method `{self.__class__.__name__}._set_focus_position` is deprecated, \"\n            f\"please use `{self.__class__.__name__}.focus_position` property\",\n            DeprecationWarning,\n            stacklevel=3,\n        )\n        self.focus_position = position",
  "class FrameError(Exception):\n    pass",
  "class Frame(Widget, WidgetContainerMixin):\n    \"\"\"\n    Frame widget is a box widget with optional header and footer\n    flow widgets placed above and below the box widget.\n\n    .. note:: The main difference between a Frame and a :class:`Pile` widget\n        defined as: `Pile([('pack', header), body, ('pack', footer)])` is that\n        the Frame will not automatically change focus up and down in response to\n        keystrokes.\n    \"\"\"\n\n    _selectable = True\n    _sizing = frozenset([Sizing.BOX])\n\n    def __init__(\n        self,\n        body: Widget,\n        header: Widget | None = None,\n        footer: Widget | None = None,\n        focus_part: Literal[\"header\", \"footer\", \"body\"] = \"body\",\n    ):\n        \"\"\"\n        :param body: a box widget for the body of the frame\n        :type body: Widget\n        :param header: a flow widget for above the body (or None)\n        :type header: Widget\n        :param footer: a flow widget for below the body (or None)\n        :type footer: Widget\n        :param focus_part:  'header', 'footer' or 'body'\n        :type focus_part: str\n        \"\"\"\n        super().__init__()\n\n        self._header = header\n        self._body = body\n        self._footer = footer\n        self.focus_part = focus_part\n\n    @property\n    def header(self) -> Widget | None:\n        return self._header\n\n    @header.setter\n    def header(self, header: Widget | None):\n        self._header = header\n        if header is None and self.focus_part == \"header\":\n            self.focus_part = \"body\"\n        self._invalidate()\n\n    def get_header(self) -> Widget | None:\n        warnings.warn(\n            f\"method `{self.__class__.__name__}.get_header` is deprecated, \"\n            f\"standard property `{self.__class__.__name__}.header` should be used instead\",\n            PendingDeprecationWarning,\n            stacklevel=2,\n        )\n        return self.header\n\n    def set_header(self, header: Widget | None):\n        warnings.warn(\n            f\"method `{self.__class__.__name__}.set_header` is deprecated, \"\n            f\"standard property `{self.__class__.__name__}.header` should be used instead\",\n            PendingDeprecationWarning,\n            stacklevel=2,\n        )\n        self.header = header\n\n    @property\n    def body(self) -> Widget:\n        return self._body\n\n    @body.setter\n    def body(self, body: Widget) -> None:\n        self._body = body\n        self._invalidate()\n\n    def get_body(self) -> Widget:\n        warnings.warn(\n            f\"method `{self.__class__.__name__}.get_body` is deprecated, \"\n            f\"standard property {self.__class__.__name__}.body should be used instead\",\n            PendingDeprecationWarning,\n            stacklevel=2,\n        )\n        return self.body\n\n    def set_body(self, body: Widget) -> None:\n        warnings.warn(\n            f\"method `{self.__class__.__name__}.set_body` is deprecated, \"\n            f\"standard property `{self.__class__.__name__}.body` should be used instead\",\n            PendingDeprecationWarning,\n            stacklevel=2,\n        )\n        self.body = body\n\n    @property\n    def footer(self) -> Widget | None:\n        return self._footer\n\n    @footer.setter\n    def footer(self, footer: Widget | None) -> None:\n        self._footer = footer\n        if footer is None and self.focus_part == \"footer\":\n            self.focus_part = \"body\"\n        self._invalidate()\n\n    def get_footer(self) -> Widget | None:\n        warnings.warn(\n            f\"method `{self.__class__.__name__}.get_footer` is deprecated, \"\n            f\"standard property `{self.__class__.__name__}.footer` should be used instead\",\n            PendingDeprecationWarning,\n            stacklevel=2,\n        )\n        return self.footer\n\n    def set_footer(self, footer: Widget | None) -> None:\n        warnings.warn(\n            f\"method `{self.__class__.__name__}.set_footer` is deprecated, \"\n            f\"standard property `{self.__class__.__name__}.footer` should be used instead\",\n            PendingDeprecationWarning,\n            stacklevel=2,\n        )\n        self.footer = footer\n\n    @property\n    def focus_position(self) -> Literal[\"header\", \"footer\", \"body\"]:\n        \"\"\"\n        writeable property containing an indicator which part of the frame\n        that is in focus: `'body', 'header'` or `'footer'`.\n\n        :returns: one of 'header', 'footer' or 'body'.\n        :rtype: str\n        \"\"\"\n        return self.focus_part\n\n    @focus_position.setter\n    def focus_position(self, part: Literal[\"header\", \"footer\", \"body\"]) -> None:\n        \"\"\"\n        Determine which part of the frame is in focus.\n\n        :param part: 'header', 'footer' or 'body'\n        :type part: str\n        \"\"\"\n        if part not in (\"header\", \"footer\", \"body\"):\n            raise IndexError(f\"Invalid position for Frame: {part}\")\n        if (part == \"header\" and self._header is None) or (part == \"footer\" and self._footer is None):\n            raise IndexError(f\"This Frame has no {part}\")\n        self.focus_part = part\n        self._invalidate()\n\n    def get_focus(self) -> Literal[\"header\", \"footer\", \"body\"]:\n        \"\"\"\n        writeable property containing an indicator which part of the frame\n        that is in focus: `'body', 'header'` or `'footer'`.\n\n        .. note:: included for backwards compatibility. You should rather use\n            the container property :attr:`.focus_position` to get this value.\n\n        :returns: one of 'header', 'footer' or 'body'.\n        :rtype: str\n        \"\"\"\n        warnings.warn(\n            \"included for backwards compatibility.\"\n            \"You should rather use the container property `.focus_position` to get this value.\",\n            PendingDeprecationWarning,\n            stacklevel=2,\n        )\n        return self.focus_position\n\n    def set_focus(self, part: Literal[\"header\", \"footer\", \"body\"]) -> None:\n        warnings.warn(\n            \"included for backwards compatibility.\"\n            \"You should rather use the container property `.focus_position` to set this value.\",\n            PendingDeprecationWarning,\n            stacklevel=2,\n        )\n        self.focus_position = part\n\n    @property\n    def focus(self) -> Widget:\n        \"\"\"\n        child :class:`Widget` in focus: the body, header or footer widget.\n        This is a read-only property.\"\"\"\n        return {\"header\": self._header, \"footer\": self._footer, \"body\": self._body}[self.focus_part]\n\n    def _get_focus(self) -> Widget:\n        warnings.warn(\n            f\"method `{self.__class__.__name__}._get_focus` is deprecated, \"\n            f\"please use `{self.__class__.__name__}.focus` property\",\n            DeprecationWarning,\n            stacklevel=3,\n        )\n        return {\"header\": self._header, \"footer\": self._footer, \"body\": self._body}[self.focus_part]\n\n    @property\n    def contents(self):\n        \"\"\"\n        a dict-like object similar to::\n\n            {\n                'body': (body_widget, None),\n                'header': (header_widget, None),  # if frame has a header\n                'footer': (footer_widget, None) # if frame has a footer\n            }\n\n        This object may be used to read or update the contents of the Frame.\n\n        The values are similar to the list-like .contents objects used\n        in other containers with (:class:`Widget`, options) tuples, but are\n        constrained to keys for each of the three usual parts of a Frame.\n        When other keys are used a :exc:`KeyError` will be raised.\n\n        Currently all options are `None`, but using the :meth:`options` method\n        to create the options value is recommended for forwards\n        compatibility.\n        \"\"\"\n\n        class FrameContents:\n            def __len__(inner_self):\n                return len(inner_self.keys())\n\n            def items(inner_self):\n                return [(k, inner_self[k]) for k in inner_self]\n\n            def values(inner_self):\n                return [inner_self[k] for k in inner_self]\n\n            def update(inner_self, E=None, **F):\n                if E:\n                    keys = getattr(E, \"keys\", None)\n                    if keys:\n                        for k in E:\n                            inner_self[k] = E[k]\n                    else:\n                        for k, v in E:\n                            inner_self[k] = v\n                for k in F:\n                    inner_self[k] = F[k]\n\n            keys = self._contents_keys\n            __getitem__ = self._contents__getitem__\n            __setitem__ = self._contents__setitem__\n            __delitem__ = self._contents__delitem__\n\n        return FrameContents()\n\n    def _contents_keys(self) -> list[Literal[\"header\", \"footer\", \"body\"]]:\n        keys = [\"body\"]\n        if self._header:\n            keys.append(\"header\")\n        if self._footer:\n            keys.append(\"footer\")\n        return keys\n\n    def _contents__getitem__(self, key: Literal[\"header\", \"footer\", \"body\"]):\n        if key == \"body\":\n            return (self._body, None)\n        if key == \"header\" and self._header:\n            return (self._header, None)\n        if key == \"footer\" and self._footer:\n            return (self._footer, None)\n        raise KeyError(f\"Frame.contents has no key: {key!r}\")\n\n    def _contents__setitem__(self, key: Literal[\"header\", \"footer\", \"body\"], value):\n        if key not in (\"body\", \"header\", \"footer\"):\n            raise KeyError(f\"Frame.contents has no key: {key!r}\")\n        try:\n            value_w, value_options = value\n            if value_options is not None:\n                raise FrameError(f\"added content invalid: {value!r}\")\n        except (ValueError, TypeError) as exc:\n            raise FrameError(f\"added content invalid: {value!r}\").with_traceback(exc.__traceback__) from exc\n        if key == \"body\":\n            self.body = value_w\n        elif key == \"footer\":\n            self.footer = value_w\n        else:\n            self.header = value_w\n\n    def _contents__delitem__(self, key: Literal[\"header\", \"footer\", \"body\"]):\n        if key not in (\"header\", \"footer\"):\n            raise KeyError(f\"Frame.contents can't remove key: {key!r}\")\n        if (key == \"header\" and self._header is None) or (key == \"footer\" and self._footer is None):\n            raise KeyError(f\"Frame.contents has no key: {key!r}\")\n        if key == \"header\":\n            self.header = None\n        else:\n            self.footer = None\n\n    def _contents(self):\n        warnings.warn(\n            f\"method `{self.__class__.__name__}._contents` is deprecated, \"\n            f\"please use property `{self.__class__.__name__}.contents`\",\n            DeprecationWarning,\n            stacklevel=3,\n        )\n        return self.contents\n\n    def options(self) -> None:\n        \"\"\"\n        There are currently no options for Frame contents.\n\n        Return None as a placeholder for future options.\n        \"\"\"\n        return\n\n    def frame_top_bottom(self, size: tuple[int, int], focus: bool) -> tuple[tuple[int, int], tuple[int, int]]:\n        \"\"\"\n        Calculate the number of rows for the header and footer.\n\n        :param size: See :meth:`Widget.render` for details\n        :type size: widget size\n        :param focus: ``True`` if this widget is in focus\n        :type focus: bool\n        :returns: `(head rows, foot rows),(orig head, orig foot)`\n                  orig head/foot are from rows() calls.\n        :rtype: (int, int), (int, int)\n        \"\"\"\n        (maxcol, maxrow) = size\n        frows = hrows = 0\n\n        if self.header:\n            hrows = self.header.rows((maxcol,), self.focus_part == \"header\" and focus)\n\n        if self.footer:\n            frows = self.footer.rows((maxcol,), self.focus_part == \"footer\" and focus)\n\n        remaining = maxrow\n\n        if self.focus_part == \"footer\":\n            if frows >= remaining:\n                return (0, remaining), (hrows, frows)\n\n            remaining -= frows\n            if hrows >= remaining:\n                return (remaining, frows), (hrows, frows)\n\n        elif self.focus_part == \"header\":\n            if hrows >= maxrow:\n                return (remaining, 0), (hrows, frows)\n\n            remaining -= hrows\n            if frows >= remaining:\n                return (hrows, remaining), (hrows, frows)\n\n        elif hrows + frows >= remaining:\n            # self.focus_part == 'body'\n            rless1 = max(0, remaining - 1)\n            if frows >= remaining - 1:\n                return (0, rless1), (hrows, frows)\n\n            remaining -= frows\n            rless1 = max(0, remaining - 1)\n            return (rless1, frows), (hrows, frows)\n\n        return (hrows, frows), (hrows, frows)\n\n    def render(self, size: tuple[int, int], focus: bool = False) -> CompositeCanvas:\n        (maxcol, maxrow) = size\n        (htrim, ftrim), (hrows, frows) = self.frame_top_bottom((maxcol, maxrow), focus)\n\n        combinelist = []\n        depends_on = []\n\n        head = None\n        if htrim and htrim < hrows:\n            head = Filler(self.header, \"top\").render((maxcol, htrim), focus and self.focus_part == \"header\")\n        elif htrim:\n            head = self.header.render((maxcol,), focus and self.focus_part == \"header\")\n            if head.rows() != hrows:\n                raise RuntimeError(\"rows, render mismatch\")\n        if head:\n            combinelist.append((head, \"header\", self.focus_part == \"header\"))\n            depends_on.append(self.header)\n\n        if ftrim + htrim < maxrow:\n            body = self.body.render((maxcol, maxrow - ftrim - htrim), focus and self.focus_part == \"body\")\n            combinelist.append((body, \"body\", self.focus_part == \"body\"))\n            depends_on.append(self.body)\n\n        foot = None\n        if ftrim and ftrim < frows:\n            foot = Filler(self.footer, \"bottom\").render((maxcol, ftrim), focus and self.focus_part == \"footer\")\n        elif ftrim:\n            foot = self.footer.render((maxcol,), focus and self.focus_part == \"footer\")\n            if foot.rows() != frows:\n                raise RuntimeError(\"rows, render mismatch\")\n        if foot:\n            combinelist.append((foot, \"footer\", self.focus_part == \"footer\"))\n            depends_on.append(self.footer)\n\n        return CanvasCombine(combinelist)\n\n    def keypress(self, size: tuple[int, int], key: str) -> str | None:\n        \"\"\"Pass keypress to widget in focus.\"\"\"\n        (maxcol, maxrow) = size\n\n        if self.focus_part == \"header\" and self.header is not None:\n            if not self.header.selectable():\n                return key\n            return self.header.keypress((maxcol,), key)\n        if self.focus_part == \"footer\" and self.footer is not None:\n            if not self.footer.selectable():\n                return key\n            return self.footer.keypress((maxcol,), key)\n        if self.focus_part != \"body\":\n            return key\n        remaining = maxrow\n        if self.header is not None:\n            remaining -= self.header.rows((maxcol,))\n        if self.footer is not None:\n            remaining -= self.footer.rows((maxcol,))\n        if remaining <= 0:\n            return key\n\n        if not self.body.selectable():\n            return key\n        return self.body.keypress((maxcol, remaining), key)\n\n    def mouse_event(self, size: tuple[int, int], event, button: int, col: int, row: int, focus: bool) -> bool | None:\n        \"\"\"\n        Pass mouse event to appropriate part of frame.\n        Focus may be changed on button 1 press.\n        \"\"\"\n        (maxcol, maxrow) = size\n        (htrim, ftrim), (hrows, frows) = self.frame_top_bottom((maxcol, maxrow), focus)\n\n        if row < htrim:  # within header\n            focus = focus and self.focus_part == \"header\"\n            if is_mouse_press(event) and button == 1 and self.header.selectable():\n                self.focus_position = \"header\"\n            if not hasattr(self.header, \"mouse_event\"):\n                return False\n            return self.header.mouse_event((maxcol,), event, button, col, row, focus)\n\n        if row >= maxrow - ftrim:  # within footer\n            focus = focus and self.focus_part == \"footer\"\n            if is_mouse_press(event) and button == 1 and self.footer.selectable():\n                self.focus_position = \"footer\"\n            if not hasattr(self.footer, \"mouse_event\"):\n                return False\n            return self.footer.mouse_event((maxcol,), event, button, col, row - maxrow + ftrim, focus)\n\n        # within body\n        focus = focus and self.focus_part == \"body\"\n        if is_mouse_press(event) and button == 1 and self.body.selectable():\n            self.focus_position = \"body\"\n\n        if not hasattr(self.body, \"mouse_event\"):\n            return False\n        return self.body.mouse_event((maxcol, maxrow - htrim - ftrim), event, button, col, row - htrim, focus)\n\n    def get_cursor_coords(self, size: tuple[int, int]) -> tuple[int, int] | None:\n        \"\"\"Return the cursor coordinates of the focus widget.\"\"\"\n        if not self.focus.selectable():\n            return None\n        if not hasattr(self.focus, \"get_cursor_coords\"):\n            return None\n\n        fp = self.focus_position\n        (maxcol, maxrow) = size\n        (hrows, frows), _ = self.frame_top_bottom(size, True)\n\n        if fp == \"header\":\n            row_adjust = 0\n            coords = self.header.get_cursor_coords((maxcol,))\n        elif fp == \"body\":\n            row_adjust = hrows\n            coords = self.body.get_cursor_coords((maxcol, maxrow - hrows - frows))\n        else:\n            row_adjust = maxrow - frows\n            coords = self.footer.get_cursor_coords((maxcol,))\n\n        if coords is None:\n            return None\n\n        x, y = coords\n        return x, y + row_adjust\n\n    def __iter__(self):\n        \"\"\"\n        Return an iterator over the positions in this Frame top to bottom.\n        \"\"\"\n        if self._header:\n            yield \"header\"\n        yield \"body\"\n        if self._footer:\n            yield \"footer\"\n\n    def __reversed__(self):\n        \"\"\"\n        Return an iterator over the positions in this Frame bottom to top.\n        \"\"\"\n        if self._footer:\n            yield \"footer\"\n        yield \"body\"\n        if self._header:\n            yield \"header\"",
  "def __getitem__(self, position) -> Widget:\n        \"\"\"\n        Container short-cut for self.contents[position][0].base_widget\n        which means \"give me the child widget at position without any\n        widget decorations\".\n\n        This allows for concise traversal of nested container widgets\n        such as:\n\n            my_widget[position0][position1][position2] ...\n        \"\"\"\n        return self.contents[position][0].base_widget",
  "def get_focus_path(self):\n        \"\"\"\n        Return the .focus_position values starting from this container\n        and proceeding along each child widget until reaching a leaf\n        (non-container) widget.\n        \"\"\"\n        out = []\n        w = self\n        while True:\n            try:\n                p = w.focus_position\n            except IndexError:\n                return out\n            out.append(p)\n            w = w.focus.base_widget",
  "def set_focus_path(self, positions):\n        \"\"\"\n        Set the .focus_position property starting from this container\n        widget and proceeding along newly focused child widgets.  Any\n        failed assignment due do incompatible position types or invalid\n        positions will raise an IndexError.\n\n        This method may be used to restore a particular widget to the\n        focus by passing in the value returned from an earlier call to\n        get_focus_path().\n\n        positions -- sequence of positions\n        \"\"\"\n        w = self\n        for p in positions:\n            if p != w.focus_position:\n                w.focus_position = p  # modifies w.focus\n            w = w.focus.base_widget",
  "def get_focus_widgets(self) -> list[Widget]:\n        \"\"\"\n        Return the .focus values starting from this container\n        and proceeding along each child widget until reaching a leaf\n        (non-container) widget.\n\n        Note that the list does not contain the topmost container widget\n        (i.e., on which this method is called), but does include the\n        lowest leaf widget.\n        \"\"\"\n        out = []\n        w = self\n        while True:\n            w = w.base_widget.focus\n            if w is None:\n                return out\n            out.append(w)",
  "def focus(self) -> Widget:\n        \"\"\"\n        Read-only property returning the child widget in focus for\n        container widgets.  This default implementation\n        always returns ``None``, indicating that this widget has no children.\n        \"\"\"",
  "def _get_focus(self) -> Widget:\n        warnings.warn(\n            f\"method `{self.__class__.__name__}._get_focus` is deprecated, \"\n            f\"please use `{self.__class__.__name__}.focus` property\",\n            DeprecationWarning,\n            stacklevel=3,\n        )\n        return self.focus",
  "def __iter__(self) -> Iterator[int]:\n        \"\"\"\n        Return an iterable of positions for this container from first\n        to last.\n        \"\"\"\n        return iter(range(len(self.contents)))",
  "def __reversed__(self) -> Iterator[int]:\n        \"\"\"\n        Return an iterable of positions for this container from last\n        to first.\n        \"\"\"\n        return iter(range(len(self.contents) - 1, -1, -1))",
  "def __len__(self) -> int:\n        return len(self.contents)",
  "def contents(self) -> list[tuple[Widget, typing.Any]]:\n        \"\"\"The contents of container as a list of (widget, options)\"\"\"",
  "def contents(self, new_contents: list[tuple[Widget, typing.Any]]) -> None:\n        \"\"\"The contents of container as a list of (widget, options)\"\"\"",
  "def _get_contents(self) -> list[tuple[Widget, typing.Any]]:\n        warnings.warn(\n            f\"method `{self.__class__.__name__}._get_contents` is deprecated, \"\n            f\"please use `{self.__class__.__name__}.contents` property\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        return self.contents",
  "def _set_contents(self, c: list[tuple[Widget, typing.Any]]) -> None:\n        warnings.warn(\n            f\"method `{self.__class__.__name__}._set_contents` is deprecated, \"\n            f\"please use `{self.__class__.__name__}.contents` property\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        self.contents = c",
  "def focus_position(self) -> int | None:\n        \"\"\"\n        index of child widget in focus.\n        \"\"\"",
  "def focus_position(self, position: int) -> None:\n        \"\"\"\n        index of child widget in focus.\n        \"\"\"",
  "def _get_focus_position(self) -> int | None:\n        warnings.warn(\n            f\"method `{self.__class__.__name__}._get_focus_position` is deprecated, \"\n            f\"please use `{self.__class__.__name__}.focus_position` property\",\n            DeprecationWarning,\n            stacklevel=3,\n        )\n        return self.focus_position",
  "def _set_focus_position(self, position: int) -> None:\n        \"\"\"\n        Set the widget in focus.\n\n        position -- index of child widget to be made focus\n        \"\"\"\n        warnings.warn(\n            f\"method `{self.__class__.__name__}._set_focus_position` is deprecated, \"\n            f\"please use `{self.__class__.__name__}.focus_position` property\",\n            DeprecationWarning,\n            stacklevel=3,\n        )\n        self.focus_position = position",
  "def __init__(\n        self,\n        body: Widget,\n        header: Widget | None = None,\n        footer: Widget | None = None,\n        focus_part: Literal[\"header\", \"footer\", \"body\"] = \"body\",\n    ):\n        \"\"\"\n        :param body: a box widget for the body of the frame\n        :type body: Widget\n        :param header: a flow widget for above the body (or None)\n        :type header: Widget\n        :param footer: a flow widget for below the body (or None)\n        :type footer: Widget\n        :param focus_part:  'header', 'footer' or 'body'\n        :type focus_part: str\n        \"\"\"\n        super().__init__()\n\n        self._header = header\n        self._body = body\n        self._footer = footer\n        self.focus_part = focus_part",
  "def header(self) -> Widget | None:\n        return self._header",
  "def header(self, header: Widget | None):\n        self._header = header\n        if header is None and self.focus_part == \"header\":\n            self.focus_part = \"body\"\n        self._invalidate()",
  "def get_header(self) -> Widget | None:\n        warnings.warn(\n            f\"method `{self.__class__.__name__}.get_header` is deprecated, \"\n            f\"standard property `{self.__class__.__name__}.header` should be used instead\",\n            PendingDeprecationWarning,\n            stacklevel=2,\n        )\n        return self.header",
  "def set_header(self, header: Widget | None):\n        warnings.warn(\n            f\"method `{self.__class__.__name__}.set_header` is deprecated, \"\n            f\"standard property `{self.__class__.__name__}.header` should be used instead\",\n            PendingDeprecationWarning,\n            stacklevel=2,\n        )\n        self.header = header",
  "def body(self) -> Widget:\n        return self._body",
  "def body(self, body: Widget) -> None:\n        self._body = body\n        self._invalidate()",
  "def get_body(self) -> Widget:\n        warnings.warn(\n            f\"method `{self.__class__.__name__}.get_body` is deprecated, \"\n            f\"standard property {self.__class__.__name__}.body should be used instead\",\n            PendingDeprecationWarning,\n            stacklevel=2,\n        )\n        return self.body",
  "def set_body(self, body: Widget) -> None:\n        warnings.warn(\n            f\"method `{self.__class__.__name__}.set_body` is deprecated, \"\n            f\"standard property `{self.__class__.__name__}.body` should be used instead\",\n            PendingDeprecationWarning,\n            stacklevel=2,\n        )\n        self.body = body",
  "def footer(self) -> Widget | None:\n        return self._footer",
  "def footer(self, footer: Widget | None) -> None:\n        self._footer = footer\n        if footer is None and self.focus_part == \"footer\":\n            self.focus_part = \"body\"\n        self._invalidate()",
  "def get_footer(self) -> Widget | None:\n        warnings.warn(\n            f\"method `{self.__class__.__name__}.get_footer` is deprecated, \"\n            f\"standard property `{self.__class__.__name__}.footer` should be used instead\",\n            PendingDeprecationWarning,\n            stacklevel=2,\n        )\n        return self.footer",
  "def set_footer(self, footer: Widget | None) -> None:\n        warnings.warn(\n            f\"method `{self.__class__.__name__}.set_footer` is deprecated, \"\n            f\"standard property `{self.__class__.__name__}.footer` should be used instead\",\n            PendingDeprecationWarning,\n            stacklevel=2,\n        )\n        self.footer = footer",
  "def focus_position(self) -> Literal[\"header\", \"footer\", \"body\"]:\n        \"\"\"\n        writeable property containing an indicator which part of the frame\n        that is in focus: `'body', 'header'` or `'footer'`.\n\n        :returns: one of 'header', 'footer' or 'body'.\n        :rtype: str\n        \"\"\"\n        return self.focus_part",
  "def focus_position(self, part: Literal[\"header\", \"footer\", \"body\"]) -> None:\n        \"\"\"\n        Determine which part of the frame is in focus.\n\n        :param part: 'header', 'footer' or 'body'\n        :type part: str\n        \"\"\"\n        if part not in (\"header\", \"footer\", \"body\"):\n            raise IndexError(f\"Invalid position for Frame: {part}\")\n        if (part == \"header\" and self._header is None) or (part == \"footer\" and self._footer is None):\n            raise IndexError(f\"This Frame has no {part}\")\n        self.focus_part = part\n        self._invalidate()",
  "def get_focus(self) -> Literal[\"header\", \"footer\", \"body\"]:\n        \"\"\"\n        writeable property containing an indicator which part of the frame\n        that is in focus: `'body', 'header'` or `'footer'`.\n\n        .. note:: included for backwards compatibility. You should rather use\n            the container property :attr:`.focus_position` to get this value.\n\n        :returns: one of 'header', 'footer' or 'body'.\n        :rtype: str\n        \"\"\"\n        warnings.warn(\n            \"included for backwards compatibility.\"\n            \"You should rather use the container property `.focus_position` to get this value.\",\n            PendingDeprecationWarning,\n            stacklevel=2,\n        )\n        return self.focus_position",
  "def set_focus(self, part: Literal[\"header\", \"footer\", \"body\"]) -> None:\n        warnings.warn(\n            \"included for backwards compatibility.\"\n            \"You should rather use the container property `.focus_position` to set this value.\",\n            PendingDeprecationWarning,\n            stacklevel=2,\n        )\n        self.focus_position = part",
  "def focus(self) -> Widget:\n        \"\"\"\n        child :class:`Widget` in focus: the body, header or footer widget.\n        This is a read-only property.\"\"\"\n        return {\"header\": self._header, \"footer\": self._footer, \"body\": self._body}[self.focus_part]",
  "def _get_focus(self) -> Widget:\n        warnings.warn(\n            f\"method `{self.__class__.__name__}._get_focus` is deprecated, \"\n            f\"please use `{self.__class__.__name__}.focus` property\",\n            DeprecationWarning,\n            stacklevel=3,\n        )\n        return {\"header\": self._header, \"footer\": self._footer, \"body\": self._body}[self.focus_part]",
  "def contents(self):\n        \"\"\"\n        a dict-like object similar to::\n\n            {\n                'body': (body_widget, None),\n                'header': (header_widget, None),  # if frame has a header\n                'footer': (footer_widget, None) # if frame has a footer\n            }\n\n        This object may be used to read or update the contents of the Frame.\n\n        The values are similar to the list-like .contents objects used\n        in other containers with (:class:`Widget`, options) tuples, but are\n        constrained to keys for each of the three usual parts of a Frame.\n        When other keys are used a :exc:`KeyError` will be raised.\n\n        Currently all options are `None`, but using the :meth:`options` method\n        to create the options value is recommended for forwards\n        compatibility.\n        \"\"\"\n\n        class FrameContents:\n            def __len__(inner_self):\n                return len(inner_self.keys())\n\n            def items(inner_self):\n                return [(k, inner_self[k]) for k in inner_self]\n\n            def values(inner_self):\n                return [inner_self[k] for k in inner_self]\n\n            def update(inner_self, E=None, **F):\n                if E:\n                    keys = getattr(E, \"keys\", None)\n                    if keys:\n                        for k in E:\n                            inner_self[k] = E[k]\n                    else:\n                        for k, v in E:\n                            inner_self[k] = v\n                for k in F:\n                    inner_self[k] = F[k]\n\n            keys = self._contents_keys\n            __getitem__ = self._contents__getitem__\n            __setitem__ = self._contents__setitem__\n            __delitem__ = self._contents__delitem__\n\n        return FrameContents()",
  "def _contents_keys(self) -> list[Literal[\"header\", \"footer\", \"body\"]]:\n        keys = [\"body\"]\n        if self._header:\n            keys.append(\"header\")\n        if self._footer:\n            keys.append(\"footer\")\n        return keys",
  "def _contents__getitem__(self, key: Literal[\"header\", \"footer\", \"body\"]):\n        if key == \"body\":\n            return (self._body, None)\n        if key == \"header\" and self._header:\n            return (self._header, None)\n        if key == \"footer\" and self._footer:\n            return (self._footer, None)\n        raise KeyError(f\"Frame.contents has no key: {key!r}\")",
  "def _contents__setitem__(self, key: Literal[\"header\", \"footer\", \"body\"], value):\n        if key not in (\"body\", \"header\", \"footer\"):\n            raise KeyError(f\"Frame.contents has no key: {key!r}\")\n        try:\n            value_w, value_options = value\n            if value_options is not None:\n                raise FrameError(f\"added content invalid: {value!r}\")\n        except (ValueError, TypeError) as exc:\n            raise FrameError(f\"added content invalid: {value!r}\").with_traceback(exc.__traceback__) from exc\n        if key == \"body\":\n            self.body = value_w\n        elif key == \"footer\":\n            self.footer = value_w\n        else:\n            self.header = value_w",
  "def _contents__delitem__(self, key: Literal[\"header\", \"footer\", \"body\"]):\n        if key not in (\"header\", \"footer\"):\n            raise KeyError(f\"Frame.contents can't remove key: {key!r}\")\n        if (key == \"header\" and self._header is None) or (key == \"footer\" and self._footer is None):\n            raise KeyError(f\"Frame.contents has no key: {key!r}\")\n        if key == \"header\":\n            self.header = None\n        else:\n            self.footer = None",
  "def _contents(self):\n        warnings.warn(\n            f\"method `{self.__class__.__name__}._contents` is deprecated, \"\n            f\"please use property `{self.__class__.__name__}.contents`\",\n            DeprecationWarning,\n            stacklevel=3,\n        )\n        return self.contents",
  "def options(self) -> None:\n        \"\"\"\n        There are currently no options for Frame contents.\n\n        Return None as a placeholder for future options.\n        \"\"\"\n        return",
  "def frame_top_bottom(self, size: tuple[int, int], focus: bool) -> tuple[tuple[int, int], tuple[int, int]]:\n        \"\"\"\n        Calculate the number of rows for the header and footer.\n\n        :param size: See :meth:`Widget.render` for details\n        :type size: widget size\n        :param focus: ``True`` if this widget is in focus\n        :type focus: bool\n        :returns: `(head rows, foot rows),(orig head, orig foot)`\n                  orig head/foot are from rows() calls.\n        :rtype: (int, int), (int, int)\n        \"\"\"\n        (maxcol, maxrow) = size\n        frows = hrows = 0\n\n        if self.header:\n            hrows = self.header.rows((maxcol,), self.focus_part == \"header\" and focus)\n\n        if self.footer:\n            frows = self.footer.rows((maxcol,), self.focus_part == \"footer\" and focus)\n\n        remaining = maxrow\n\n        if self.focus_part == \"footer\":\n            if frows >= remaining:\n                return (0, remaining), (hrows, frows)\n\n            remaining -= frows\n            if hrows >= remaining:\n                return (remaining, frows), (hrows, frows)\n\n        elif self.focus_part == \"header\":\n            if hrows >= maxrow:\n                return (remaining, 0), (hrows, frows)\n\n            remaining -= hrows\n            if frows >= remaining:\n                return (hrows, remaining), (hrows, frows)\n\n        elif hrows + frows >= remaining:\n            # self.focus_part == 'body'\n            rless1 = max(0, remaining - 1)\n            if frows >= remaining - 1:\n                return (0, rless1), (hrows, frows)\n\n            remaining -= frows\n            rless1 = max(0, remaining - 1)\n            return (rless1, frows), (hrows, frows)\n\n        return (hrows, frows), (hrows, frows)",
  "def render(self, size: tuple[int, int], focus: bool = False) -> CompositeCanvas:\n        (maxcol, maxrow) = size\n        (htrim, ftrim), (hrows, frows) = self.frame_top_bottom((maxcol, maxrow), focus)\n\n        combinelist = []\n        depends_on = []\n\n        head = None\n        if htrim and htrim < hrows:\n            head = Filler(self.header, \"top\").render((maxcol, htrim), focus and self.focus_part == \"header\")\n        elif htrim:\n            head = self.header.render((maxcol,), focus and self.focus_part == \"header\")\n            if head.rows() != hrows:\n                raise RuntimeError(\"rows, render mismatch\")\n        if head:\n            combinelist.append((head, \"header\", self.focus_part == \"header\"))\n            depends_on.append(self.header)\n\n        if ftrim + htrim < maxrow:\n            body = self.body.render((maxcol, maxrow - ftrim - htrim), focus and self.focus_part == \"body\")\n            combinelist.append((body, \"body\", self.focus_part == \"body\"))\n            depends_on.append(self.body)\n\n        foot = None\n        if ftrim and ftrim < frows:\n            foot = Filler(self.footer, \"bottom\").render((maxcol, ftrim), focus and self.focus_part == \"footer\")\n        elif ftrim:\n            foot = self.footer.render((maxcol,), focus and self.focus_part == \"footer\")\n            if foot.rows() != frows:\n                raise RuntimeError(\"rows, render mismatch\")\n        if foot:\n            combinelist.append((foot, \"footer\", self.focus_part == \"footer\"))\n            depends_on.append(self.footer)\n\n        return CanvasCombine(combinelist)",
  "def keypress(self, size: tuple[int, int], key: str) -> str | None:\n        \"\"\"Pass keypress to widget in focus.\"\"\"\n        (maxcol, maxrow) = size\n\n        if self.focus_part == \"header\" and self.header is not None:\n            if not self.header.selectable():\n                return key\n            return self.header.keypress((maxcol,), key)\n        if self.focus_part == \"footer\" and self.footer is not None:\n            if not self.footer.selectable():\n                return key\n            return self.footer.keypress((maxcol,), key)\n        if self.focus_part != \"body\":\n            return key\n        remaining = maxrow\n        if self.header is not None:\n            remaining -= self.header.rows((maxcol,))\n        if self.footer is not None:\n            remaining -= self.footer.rows((maxcol,))\n        if remaining <= 0:\n            return key\n\n        if not self.body.selectable():\n            return key\n        return self.body.keypress((maxcol, remaining), key)",
  "def mouse_event(self, size: tuple[int, int], event, button: int, col: int, row: int, focus: bool) -> bool | None:\n        \"\"\"\n        Pass mouse event to appropriate part of frame.\n        Focus may be changed on button 1 press.\n        \"\"\"\n        (maxcol, maxrow) = size\n        (htrim, ftrim), (hrows, frows) = self.frame_top_bottom((maxcol, maxrow), focus)\n\n        if row < htrim:  # within header\n            focus = focus and self.focus_part == \"header\"\n            if is_mouse_press(event) and button == 1 and self.header.selectable():\n                self.focus_position = \"header\"\n            if not hasattr(self.header, \"mouse_event\"):\n                return False\n            return self.header.mouse_event((maxcol,), event, button, col, row, focus)\n\n        if row >= maxrow - ftrim:  # within footer\n            focus = focus and self.focus_part == \"footer\"\n            if is_mouse_press(event) and button == 1 and self.footer.selectable():\n                self.focus_position = \"footer\"\n            if not hasattr(self.footer, \"mouse_event\"):\n                return False\n            return self.footer.mouse_event((maxcol,), event, button, col, row - maxrow + ftrim, focus)\n\n        # within body\n        focus = focus and self.focus_part == \"body\"\n        if is_mouse_press(event) and button == 1 and self.body.selectable():\n            self.focus_position = \"body\"\n\n        if not hasattr(self.body, \"mouse_event\"):\n            return False\n        return self.body.mouse_event((maxcol, maxrow - htrim - ftrim), event, button, col, row - htrim, focus)",
  "def get_cursor_coords(self, size: tuple[int, int]) -> tuple[int, int] | None:\n        \"\"\"Return the cursor coordinates of the focus widget.\"\"\"\n        if not self.focus.selectable():\n            return None\n        if not hasattr(self.focus, \"get_cursor_coords\"):\n            return None\n\n        fp = self.focus_position\n        (maxcol, maxrow) = size\n        (hrows, frows), _ = self.frame_top_bottom(size, True)\n\n        if fp == \"header\":\n            row_adjust = 0\n            coords = self.header.get_cursor_coords((maxcol,))\n        elif fp == \"body\":\n            row_adjust = hrows\n            coords = self.body.get_cursor_coords((maxcol, maxrow - hrows - frows))\n        else:\n            row_adjust = maxrow - frows\n            coords = self.footer.get_cursor_coords((maxcol,))\n\n        if coords is None:\n            return None\n\n        x, y = coords\n        return x, y + row_adjust",
  "def __iter__(self):\n        \"\"\"\n        Return an iterator over the positions in this Frame top to bottom.\n        \"\"\"\n        if self._header:\n            yield \"header\"\n        yield \"body\"\n        if self._footer:\n            yield \"footer\"",
  "def __reversed__(self):\n        \"\"\"\n        Return an iterator over the positions in this Frame bottom to top.\n        \"\"\"\n        if self._footer:\n            yield \"footer\"\n        yield \"body\"\n        if self._header:\n            yield \"header\"",
  "class FrameContents:\n            def __len__(inner_self):\n                return len(inner_self.keys())\n\n            def items(inner_self):\n                return [(k, inner_self[k]) for k in inner_self]\n\n            def values(inner_self):\n                return [inner_self[k] for k in inner_self]\n\n            def update(inner_self, E=None, **F):\n                if E:\n                    keys = getattr(E, \"keys\", None)\n                    if keys:\n                        for k in E:\n                            inner_self[k] = E[k]\n                    else:\n                        for k, v in E:\n                            inner_self[k] = v\n                for k in F:\n                    inner_self[k] = F[k]\n\n            keys = self._contents_keys\n            __getitem__ = self._contents__getitem__\n            __setitem__ = self._contents__setitem__\n            __delitem__ = self._contents__delitem__",
  "def __len__(inner_self):\n                return len(inner_self.keys())",
  "def items(inner_self):\n                return [(k, inner_self[k]) for k in inner_self]",
  "def values(inner_self):\n                return [inner_self[k] for k in inner_self]",
  "def update(inner_self, E=None, **F):\n                if E:\n                    keys = getattr(E, \"keys\", None)\n                    if keys:\n                        for k in E:\n                            inner_self[k] = E[k]\n                    else:\n                        for k, v in E:\n                            inner_self[k] = v\n                for k in F:\n                    inner_self[k] = F[k]",
  "class FillerError(Exception):\n    pass",
  "class Filler(WidgetDecoration):\n    def __init__(\n        self,\n        body: Widget,\n        valign: (\n            Literal[\"top\", \"middle\", \"bottom\"] | VAlign | tuple[Literal[\"relative\", WHSettings.RELATIVE], int]\n        ) = VAlign.MIDDLE,\n        height: int | Literal[\"pack\"] | tuple[Literal[\"relative\"], int] | None = WHSettings.PACK,\n        min_height: int | None = None,\n        top: int = 0,\n        bottom: int = 0,\n    ) -> None:\n        \"\"\"\n        :param body: a flow widget or box widget to be filled around (stored\n            as self.original_widget)\n        :type body: Widget\n\n        :param valign: one of:\n            ``'top'``, ``'middle'``, ``'bottom'``,\n            (``'relative'``, *percentage* 0=top 100=bottom)\n\n        :param height: one of:\n\n            ``'pack'``\n              if body is a flow widget\n\n            *given height*\n              integer number of rows for self.original_widget\n\n            (``'relative'``, *percentage of total height*)\n              make height depend on container's height\n\n        :param min_height: one of:\n\n            ``None``\n              if no minimum or if body is a flow widget\n\n            *minimum height*\n              integer number of rows for the widget when height not fixed\n\n        :param top: a fixed number of rows to fill at the top\n        :type top: int\n        :param bottom: a fixed number of rows to fill at the bottom\n        :type bottom: int\n\n        If body is a flow widget then height must be ``'flow'`` and\n        *min_height* will be ignored.\n\n        Filler widgets will try to satisfy height argument first by\n        reducing the valign amount when necessary.  If height still\n        cannot be satisfied it will also be reduced.\n        \"\"\"\n        super().__init__(body)\n\n        # convert old parameters to the new top/bottom values\n        if isinstance(height, tuple):\n            if height[0] == \"fixed top\":\n                if not isinstance(valign, tuple) or valign[0] != \"fixed bottom\":\n                    raise FillerError(\"fixed top height may only be used with fixed bottom valign\")\n                top = height[1]\n                height = RELATIVE_100\n            elif height[0] == \"fixed bottom\":\n                if not isinstance(valign, tuple) or valign[0] != \"fixed top\":\n                    raise FillerError(\"fixed bottom height may only be used with fixed top valign\")\n                bottom = height[1]\n                height = RELATIVE_100\n        if isinstance(valign, tuple):\n            if valign[0] == \"fixed top\":\n                top = valign[1]\n                valign = VAlign.TOP\n            elif valign[0] == \"fixed bottom\":\n                bottom = valign[1]\n                valign = VAlign.BOTTOM\n\n        # convert old flow mode parameter height=None to height='flow'\n        if height is None or height == Sizing.FLOW:\n            height = WHSettings.PACK\n\n        self.top = top\n        self.bottom = bottom\n        self.valign_type, self.valign_amount = normalize_valign(valign, FillerError)\n        self.height_type, self.height_amount = normalize_height(height, FillerError)\n\n        if self.height_type not in (WHSettings.GIVEN, WHSettings.PACK):\n            self.min_height = min_height\n        else:\n            self.min_height = None\n\n    def sizing(self):\n        return {Sizing.BOX}  # always a box widget\n\n    def _repr_attrs(self):\n        attrs = dict(\n            super()._repr_attrs(),\n            valign=simplify_valign(self.valign_type, self.valign_amount),\n            height=simplify_height(self.height_type, self.height_amount),\n            top=self.top,\n            bottom=self.bottom,\n            min_height=self.min_height,\n        )\n        return remove_defaults(attrs, Filler.__init__)\n\n    @property\n    def body(self):\n        \"\"\"backwards compatibility, widget used to be stored as body\"\"\"\n        warnings.warn(\n            \"backwards compatibility, widget used to be stored as body\",\n            PendingDeprecationWarning,\n            stacklevel=2,\n        )\n        return self.original_widget\n\n    @body.setter\n    def body(self, new_body):\n        warnings.warn(\n            \"backwards compatibility, widget used to be stored as body\",\n            PendingDeprecationWarning,\n            stacklevel=2,\n        )\n        self.original_widget = new_body\n\n    def get_body(self):\n        \"\"\"backwards compatibility, widget used to be stored as body\"\"\"\n        warnings.warn(\n            \"backwards compatibility, widget used to be stored as body\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        return self.original_widget\n\n    def set_body(self, new_body):\n        warnings.warn(\n            \"backwards compatibility, widget used to be stored as body\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        self.original_widget = new_body\n\n    def selectable(self) -> bool:\n        \"\"\"Return selectable from body.\"\"\"\n        return self._original_widget.selectable()\n\n    def filler_values(self, size: tuple[int, int], focus: bool) -> tuple[int, int]:\n        \"\"\"\n        Return the number of rows to pad on the top and bottom.\n\n        Override this method to define custom padding behaviour.\n        \"\"\"\n        (maxcol, maxrow) = size\n\n        if self.height_type == WHSettings.PACK:\n            height = self._original_widget.rows((maxcol,), focus=focus)\n            return calculate_top_bottom_filler(\n                maxrow, self.valign_type, self.valign_amount, WHSettings.GIVEN, height, None, self.top, self.bottom\n            )\n\n        return calculate_top_bottom_filler(\n            maxrow,\n            self.valign_type,\n            self.valign_amount,\n            self.height_type,\n            self.height_amount,\n            self.min_height,\n            self.top,\n            self.bottom,\n        )\n\n    def render(self, size: tuple[int, int], focus: bool = False) -> CompositeCanvas:\n        \"\"\"Render self.original_widget with space above and/or below.\"\"\"\n        (maxcol, maxrow) = size\n        top, bottom = self.filler_values(size, focus)\n\n        if self.height_type == WHSettings.PACK:\n            canv = self._original_widget.render((maxcol,), focus)\n        else:\n            canv = self._original_widget.render((maxcol, maxrow - top - bottom), focus)\n        canv = CompositeCanvas(canv)\n\n        if maxrow and canv.rows() > maxrow and canv.cursor is not None:\n            cx, cy = canv.cursor\n            if cy >= maxrow:\n                canv.trim(cy - maxrow + 1, maxrow - top - bottom)\n        if canv.rows() > maxrow:\n            canv.trim(0, maxrow)\n            return canv\n        canv.pad_trim_top_bottom(top, bottom)\n        return canv\n\n    def keypress(self, size: tuple[int, int], key: str) -> str | None:\n        \"\"\"Pass keypress to self.original_widget.\"\"\"\n        (maxcol, maxrow) = size\n        if self.height_type == WHSettings.PACK:\n            return self._original_widget.keypress((maxcol,), key)\n\n        top, bottom = self.filler_values((maxcol, maxrow), True)\n        return self._original_widget.keypress((maxcol, maxrow - top - bottom), key)\n\n    def get_cursor_coords(self, size: tuple[int, int]) -> tuple[int, int] | None:\n        \"\"\"Return cursor coords from self.original_widget if any.\"\"\"\n        (maxcol, maxrow) = size\n        if not hasattr(self._original_widget, \"get_cursor_coords\"):\n            return None\n\n        top, bottom = self.filler_values(size, True)\n        if self.height_type == WHSettings.PACK:\n            coords = self._original_widget.get_cursor_coords((maxcol,))\n        else:\n            coords = self._original_widget.get_cursor_coords((maxcol, maxrow - top - bottom))\n        if not coords:\n            return None\n        x, y = coords\n        if y >= maxrow:\n            y = maxrow - 1\n        return x, y + top\n\n    def get_pref_col(self, size: tuple[int, int]) -> int:\n        \"\"\"Return pref_col from self.original_widget if any.\"\"\"\n        (maxcol, maxrow) = size\n        if not hasattr(self._original_widget, \"get_pref_col\"):\n            return None\n\n        if self.height_type == WHSettings.PACK:\n            x = self._original_widget.get_pref_col((maxcol,))\n        else:\n            top, bottom = self.filler_values(size, True)\n            x = self._original_widget.get_pref_col((maxcol, maxrow - top - bottom))\n\n        return x\n\n    def move_cursor_to_coords(self, size: tuple[int, int], col: int, row: int) -> bool:\n        \"\"\"Pass to self.original_widget.\"\"\"\n        (maxcol, maxrow) = size\n        if not hasattr(self._original_widget, \"move_cursor_to_coords\"):\n            return True\n\n        top, bottom = self.filler_values(size, True)\n        if row < top or row >= maxcol - bottom:\n            return False\n\n        if self.height_type == WHSettings.PACK:\n            return self._original_widget.move_cursor_to_coords((maxcol,), col, row - top)\n        return self._original_widget.move_cursor_to_coords((maxcol, maxrow - top - bottom), col, row - top)\n\n    def mouse_event(\n        self,\n        size: tuple[int, int],\n        event,\n        button: int,\n        col: int,\n        row: int,\n        focus: bool,\n    ) -> bool:\n        \"\"\"Pass to self.original_widget.\"\"\"\n        (maxcol, maxrow) = size\n        if not hasattr(self._original_widget, \"mouse_event\"):\n            return False\n\n        top, bottom = self.filler_values(size, True)\n        if row < top or row >= maxrow - bottom:\n            return False\n\n        if self.height_type == WHSettings.PACK:\n            return self._original_widget.mouse_event((maxcol,), event, button, col, row - top, focus)\n        return self._original_widget.mouse_event((maxcol, maxrow - top - bottom), event, button, col, row - top, focus)",
  "def calculate_top_bottom_filler(\n    maxrow: int,\n    valign_type: Literal[\"top\", \"middle\", \"bottom\", \"relative\", WHSettings.RELATIVE] | VAlign,\n    valign_amount: int,\n    height_type: Literal[\"given\", \"relative\", \"clip\", WHSettings.GIVEN, WHSettings.RELATIVE, WHSettings.CLIP],\n    height_amount: int,\n    min_height: int | None,\n    top: int,\n    bottom: int,\n) -> tuple[int, int]:\n    \"\"\"\n    Return the amount of filler (or clipping) on the top and\n    bottom part of maxrow rows to satisfy the following:\n\n    valign_type -- 'top', 'middle', 'bottom', 'relative'\n    valign_amount -- a percentage when align_type=='relative'\n    height_type -- 'given', 'relative', 'clip'\n    height_amount -- a percentage when width_type=='relative'\n        otherwise equal to the height of the widget\n    min_height -- a desired minimum width for the widget or None\n    top -- a fixed number of rows to fill on the top\n    bottom -- a fixed number of rows to fill on the bottom\n\n    >>> ctbf = calculate_top_bottom_filler\n    >>> ctbf(15, 'top', 0, 'given', 10, None, 2, 0)\n    (2, 3)\n    >>> ctbf(15, 'relative', 0, 'given', 10, None, 2, 0)\n    (2, 3)\n    >>> ctbf(15, 'relative', 100, 'given', 10, None, 2, 0)\n    (5, 0)\n    >>> ctbf(15, 'middle', 0, 'given', 4, None, 2, 0)\n    (6, 5)\n    >>> ctbf(15, 'middle', 0, 'given', 18, None, 2, 0)\n    (0, 0)\n    >>> ctbf(20, 'top', 0, 'relative', 60, None, 0, 0)\n    (0, 8)\n    >>> ctbf(20, 'relative', 30, 'relative', 60, None, 0, 0)\n    (2, 6)\n    >>> ctbf(20, 'relative', 30, 'relative', 60, 14, 0, 0)\n    (2, 4)\n    \"\"\"\n    if height_type == WHSettings.RELATIVE:\n        maxheight = max(maxrow - top - bottom, 0)\n        height = int_scale(height_amount, 101, maxheight + 1)\n        if min_height is not None:\n            height = max(height, min_height)\n    else:\n        height = height_amount\n\n    standard_alignments = {VAlign.TOP: 0, VAlign.MIDDLE: 50, VAlign.BOTTOM: 100}\n    valign = standard_alignments.get(valign_type, valign_amount)\n\n    # add the remainder of top/bottom to the filler\n    filler = maxrow - height - top - bottom\n    bottom += int_scale(100 - valign, 101, filler + 1)\n    top = maxrow - height - bottom\n\n    # reduce filler if we are clipping an edge\n    if bottom < 0 < top:\n        shift = min(top, -bottom)\n        top -= shift\n        bottom += shift\n    elif top < 0 < bottom:\n        shift = min(bottom, -top)\n        bottom -= shift\n        top += shift\n\n    # no negative values for filler at the moment\n    top = max(top, 0)\n    bottom = max(bottom, 0)\n\n    return top, bottom",
  "def __init__(\n        self,\n        body: Widget,\n        valign: (\n            Literal[\"top\", \"middle\", \"bottom\"] | VAlign | tuple[Literal[\"relative\", WHSettings.RELATIVE], int]\n        ) = VAlign.MIDDLE,\n        height: int | Literal[\"pack\"] | tuple[Literal[\"relative\"], int] | None = WHSettings.PACK,\n        min_height: int | None = None,\n        top: int = 0,\n        bottom: int = 0,\n    ) -> None:\n        \"\"\"\n        :param body: a flow widget or box widget to be filled around (stored\n            as self.original_widget)\n        :type body: Widget\n\n        :param valign: one of:\n            ``'top'``, ``'middle'``, ``'bottom'``,\n            (``'relative'``, *percentage* 0=top 100=bottom)\n\n        :param height: one of:\n\n            ``'pack'``\n              if body is a flow widget\n\n            *given height*\n              integer number of rows for self.original_widget\n\n            (``'relative'``, *percentage of total height*)\n              make height depend on container's height\n\n        :param min_height: one of:\n\n            ``None``\n              if no minimum or if body is a flow widget\n\n            *minimum height*\n              integer number of rows for the widget when height not fixed\n\n        :param top: a fixed number of rows to fill at the top\n        :type top: int\n        :param bottom: a fixed number of rows to fill at the bottom\n        :type bottom: int\n\n        If body is a flow widget then height must be ``'flow'`` and\n        *min_height* will be ignored.\n\n        Filler widgets will try to satisfy height argument first by\n        reducing the valign amount when necessary.  If height still\n        cannot be satisfied it will also be reduced.\n        \"\"\"\n        super().__init__(body)\n\n        # convert old parameters to the new top/bottom values\n        if isinstance(height, tuple):\n            if height[0] == \"fixed top\":\n                if not isinstance(valign, tuple) or valign[0] != \"fixed bottom\":\n                    raise FillerError(\"fixed top height may only be used with fixed bottom valign\")\n                top = height[1]\n                height = RELATIVE_100\n            elif height[0] == \"fixed bottom\":\n                if not isinstance(valign, tuple) or valign[0] != \"fixed top\":\n                    raise FillerError(\"fixed bottom height may only be used with fixed top valign\")\n                bottom = height[1]\n                height = RELATIVE_100\n        if isinstance(valign, tuple):\n            if valign[0] == \"fixed top\":\n                top = valign[1]\n                valign = VAlign.TOP\n            elif valign[0] == \"fixed bottom\":\n                bottom = valign[1]\n                valign = VAlign.BOTTOM\n\n        # convert old flow mode parameter height=None to height='flow'\n        if height is None or height == Sizing.FLOW:\n            height = WHSettings.PACK\n\n        self.top = top\n        self.bottom = bottom\n        self.valign_type, self.valign_amount = normalize_valign(valign, FillerError)\n        self.height_type, self.height_amount = normalize_height(height, FillerError)\n\n        if self.height_type not in (WHSettings.GIVEN, WHSettings.PACK):\n            self.min_height = min_height\n        else:\n            self.min_height = None",
  "def sizing(self):\n        return {Sizing.BOX}",
  "def _repr_attrs(self):\n        attrs = dict(\n            super()._repr_attrs(),\n            valign=simplify_valign(self.valign_type, self.valign_amount),\n            height=simplify_height(self.height_type, self.height_amount),\n            top=self.top,\n            bottom=self.bottom,\n            min_height=self.min_height,\n        )\n        return remove_defaults(attrs, Filler.__init__)",
  "def body(self):\n        \"\"\"backwards compatibility, widget used to be stored as body\"\"\"\n        warnings.warn(\n            \"backwards compatibility, widget used to be stored as body\",\n            PendingDeprecationWarning,\n            stacklevel=2,\n        )\n        return self.original_widget",
  "def body(self, new_body):\n        warnings.warn(\n            \"backwards compatibility, widget used to be stored as body\",\n            PendingDeprecationWarning,\n            stacklevel=2,\n        )\n        self.original_widget = new_body",
  "def get_body(self):\n        \"\"\"backwards compatibility, widget used to be stored as body\"\"\"\n        warnings.warn(\n            \"backwards compatibility, widget used to be stored as body\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        return self.original_widget",
  "def set_body(self, new_body):\n        warnings.warn(\n            \"backwards compatibility, widget used to be stored as body\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        self.original_widget = new_body",
  "def selectable(self) -> bool:\n        \"\"\"Return selectable from body.\"\"\"\n        return self._original_widget.selectable()",
  "def filler_values(self, size: tuple[int, int], focus: bool) -> tuple[int, int]:\n        \"\"\"\n        Return the number of rows to pad on the top and bottom.\n\n        Override this method to define custom padding behaviour.\n        \"\"\"\n        (maxcol, maxrow) = size\n\n        if self.height_type == WHSettings.PACK:\n            height = self._original_widget.rows((maxcol,), focus=focus)\n            return calculate_top_bottom_filler(\n                maxrow, self.valign_type, self.valign_amount, WHSettings.GIVEN, height, None, self.top, self.bottom\n            )\n\n        return calculate_top_bottom_filler(\n            maxrow,\n            self.valign_type,\n            self.valign_amount,\n            self.height_type,\n            self.height_amount,\n            self.min_height,\n            self.top,\n            self.bottom,\n        )",
  "def render(self, size: tuple[int, int], focus: bool = False) -> CompositeCanvas:\n        \"\"\"Render self.original_widget with space above and/or below.\"\"\"\n        (maxcol, maxrow) = size\n        top, bottom = self.filler_values(size, focus)\n\n        if self.height_type == WHSettings.PACK:\n            canv = self._original_widget.render((maxcol,), focus)\n        else:\n            canv = self._original_widget.render((maxcol, maxrow - top - bottom), focus)\n        canv = CompositeCanvas(canv)\n\n        if maxrow and canv.rows() > maxrow and canv.cursor is not None:\n            cx, cy = canv.cursor\n            if cy >= maxrow:\n                canv.trim(cy - maxrow + 1, maxrow - top - bottom)\n        if canv.rows() > maxrow:\n            canv.trim(0, maxrow)\n            return canv\n        canv.pad_trim_top_bottom(top, bottom)\n        return canv",
  "def keypress(self, size: tuple[int, int], key: str) -> str | None:\n        \"\"\"Pass keypress to self.original_widget.\"\"\"\n        (maxcol, maxrow) = size\n        if self.height_type == WHSettings.PACK:\n            return self._original_widget.keypress((maxcol,), key)\n\n        top, bottom = self.filler_values((maxcol, maxrow), True)\n        return self._original_widget.keypress((maxcol, maxrow - top - bottom), key)",
  "def get_cursor_coords(self, size: tuple[int, int]) -> tuple[int, int] | None:\n        \"\"\"Return cursor coords from self.original_widget if any.\"\"\"\n        (maxcol, maxrow) = size\n        if not hasattr(self._original_widget, \"get_cursor_coords\"):\n            return None\n\n        top, bottom = self.filler_values(size, True)\n        if self.height_type == WHSettings.PACK:\n            coords = self._original_widget.get_cursor_coords((maxcol,))\n        else:\n            coords = self._original_widget.get_cursor_coords((maxcol, maxrow - top - bottom))\n        if not coords:\n            return None\n        x, y = coords\n        if y >= maxrow:\n            y = maxrow - 1\n        return x, y + top",
  "def get_pref_col(self, size: tuple[int, int]) -> int:\n        \"\"\"Return pref_col from self.original_widget if any.\"\"\"\n        (maxcol, maxrow) = size\n        if not hasattr(self._original_widget, \"get_pref_col\"):\n            return None\n\n        if self.height_type == WHSettings.PACK:\n            x = self._original_widget.get_pref_col((maxcol,))\n        else:\n            top, bottom = self.filler_values(size, True)\n            x = self._original_widget.get_pref_col((maxcol, maxrow - top - bottom))\n\n        return x",
  "def move_cursor_to_coords(self, size: tuple[int, int], col: int, row: int) -> bool:\n        \"\"\"Pass to self.original_widget.\"\"\"\n        (maxcol, maxrow) = size\n        if not hasattr(self._original_widget, \"move_cursor_to_coords\"):\n            return True\n\n        top, bottom = self.filler_values(size, True)\n        if row < top or row >= maxcol - bottom:\n            return False\n\n        if self.height_type == WHSettings.PACK:\n            return self._original_widget.move_cursor_to_coords((maxcol,), col, row - top)\n        return self._original_widget.move_cursor_to_coords((maxcol, maxrow - top - bottom), col, row - top)",
  "def mouse_event(\n        self,\n        size: tuple[int, int],\n        event,\n        button: int,\n        col: int,\n        row: int,\n        focus: bool,\n    ) -> bool:\n        \"\"\"Pass to self.original_widget.\"\"\"\n        (maxcol, maxrow) = size\n        if not hasattr(self._original_widget, \"mouse_event\"):\n            return False\n\n        top, bottom = self.filler_values(size, True)\n        if row < top or row >= maxrow - bottom:\n            return False\n\n        if self.height_type == WHSettings.PACK:\n            return self._original_widget.mouse_event((maxcol,), event, button, col, row - top, focus)\n        return self._original_widget.mouse_event((maxcol, maxrow - top - bottom), event, button, col, row - top, focus)",
  "class ColumnsError(Exception):\n    pass",
  "class Columns(Widget, WidgetContainerMixin, WidgetContainerListContentsMixin):\n    \"\"\"\n    Widgets arranged horizontally in columns from left to right\n    \"\"\"\n\n    _sizing = frozenset([Sizing.FLOW, Sizing.BOX])\n\n    def __init__(\n        self,\n        widget_list: Iterable[\n            Widget\n            | tuple[Literal[\"pack\", WHSettings.PACK], Widget]\n            | tuple[Literal[\"weight\", WHSettings.WEIGHT], int, Widget]\n        ],\n        dividechars: int = 0,\n        focus_column: int | None = None,\n        min_width: int = 1,\n        box_columns: Iterable[int] | None = None,\n    ):\n        \"\"\"\n        :param widget_list: iterable of flow or box widgets\n        :param dividechars: number of blank characters between columns\n        :param focus_column: index into widget_list of column in focus,\n            if ``None`` the first selectable widget will be chosen.\n        :param min_width: minimum width for each column which is not\n            calling widget.pack() in *widget_list*.\n        :param box_columns: a list of column indexes containing box widgets\n            whose height is set to the maximum of the rows\n            required by columns not listed in *box_columns*.\n\n        *widget_list* may also contain tuples such as:\n\n        (*given_width*, *widget*)\n            make this column *given_width* screen columns wide, where *given_width*\n            is an int\n        (``'pack'``, *widget*)\n            call :meth:`pack() <Widget.pack>` to calculate the width of this column\n        (``'weight'``, *weight*, *widget*)\n            give this column a relative *weight* (number) to calculate its width from the\n            screen columns remaining\n\n        Widgets not in a tuple are the same as (``'weight'``, ``1``, *widget*)\n\n        If the Columns widget is treated as a box widget then all children\n        are treated as box widgets, and *box_columns* is ignored.\n\n        If the Columns widget is treated as a flow widget then the rows\n        are calculated as the largest rows() returned from all columns\n        except the ones listed in *box_columns*.  The box widgets in\n        *box_columns* will be displayed with this calculated number of rows,\n        filling the full height.\n        \"\"\"\n        self._selectable = False\n        super().__init__()\n        self._contents = MonitoredFocusList()\n        self._contents.set_modified_callback(self._contents_modified)\n        self._contents.set_focus_changed_callback(lambda f: self._invalidate())\n        self._contents.set_validate_contents_modified(self._validate_contents_modified)\n\n        box_columns = set(box_columns or ())\n\n        for i, original in enumerate(widget_list):\n            w = original\n            if not isinstance(w, tuple):\n                self.contents.append((w, (WHSettings.WEIGHT, 1, i in box_columns)))\n            elif w[0] in (Sizing.FLOW, WHSettings.PACK):  # 'pack' used to be called 'flow'\n                f = WHSettings.PACK\n                _ignored, w = w\n                self.contents.append((w, (f, None, i in box_columns)))\n            elif len(w) == 2:\n                width, w = w\n                self.contents.append((w, (WHSettings.GIVEN, width, i in box_columns)))\n            elif w[0] == Sizing.FIXED:  # backwards compatibility\n                f = WHSettings.GIVEN\n                _ignored, width, w = w\n                self.contents.append((w, (WHSettings.GIVEN, width, i in box_columns)))\n            elif w[0] == WHSettings.WEIGHT:\n                f, width, w = w\n                self.contents.append((w, (f, width, i in box_columns)))\n            else:\n                raise ColumnsError(f\"initial widget list item invalid: {original!r}\")\n            if focus_column is None and w.selectable():\n                focus_column = i\n\n        self.dividechars = dividechars\n\n        if self.contents and focus_column is not None:\n            self.focus_position = focus_column\n        self.pref_col = None\n        self.min_width = min_width\n        self._cache_maxcol = None\n\n    def _contents_modified(self) -> None:\n        \"\"\"\n        Recalculate whether this widget should be selectable whenever the\n        contents has been changed.\n        \"\"\"\n        self._selectable = any(w.selectable() for w, o in self.contents)\n        self._invalidate()\n\n    def _validate_contents_modified(self, slc, new_items) -> None:\n        for item in new_items:\n            try:\n                w, (t, n, b) = item\n                if t not in (WHSettings.PACK, WHSettings.GIVEN, WHSettings.WEIGHT):\n                    raise ColumnsError(f\"added content invalid {item!r}\")\n            except (TypeError, ValueError) as exc:  # noqa: PERF203\n                raise ColumnsError(f\"added content invalid {item!r}\").with_traceback(exc.__traceback__) from exc\n\n    @property\n    def widget_list(self) -> MonitoredList:\n        \"\"\"\n        A list of the widgets in this Columns\n\n        .. note:: only for backwards compatibility. You should use the new\n            standard container property :attr:`contents`.\n        \"\"\"\n        warnings.warn(\n            \"only for backwards compatibility. You should use the new standard container `contents`\",\n            PendingDeprecationWarning,\n            stacklevel=2,\n        )\n        ml = MonitoredList(w for w, t in self.contents)\n\n        def user_modified():\n            self.widget_list = ml\n\n        ml.set_modified_callback(user_modified)\n        return ml\n\n    @widget_list.setter\n    def widget_list(self, widgets):\n        warnings.warn(\n            \"only for backwards compatibility. You should use the new standard container `contents`\",\n            PendingDeprecationWarning,\n            stacklevel=2,\n        )\n        focus_position = self.focus_position\n        self.contents = [\n            # need to grow contents list if widgets is longer\n            (new, options)\n            for (new, (w, options)) in zip(widgets, chain(self.contents, repeat((None, (WHSettings.WEIGHT, 1, False)))))\n        ]\n        if focus_position < len(widgets):\n            self.focus_position = focus_position\n\n    @property\n    def column_types(self) -> MonitoredList:\n        \"\"\"\n        A list of the old partial options values for widgets in this Pile,\n        for backwards compatibility only.  You should use the new standard\n        container property .contents to modify Pile contents.\n        \"\"\"\n        warnings.warn(\n            \"for backwards compatibility only.\"\n            \"You should use the new standard container property .contents to modify Pile contents.\",\n            PendingDeprecationWarning,\n            stacklevel=2,\n        )\n        ml = MonitoredList(\n            # return the old column type names\n            ({WHSettings.GIVEN: Sizing.FIXED, WHSettings.PACK: Sizing.FLOW}.get(t, t), n)\n            for w, (t, n, b) in self.contents\n        )\n\n        def user_modified():\n            self.column_types = ml\n\n        ml.set_modified_callback(user_modified)\n        return ml\n\n    @column_types.setter\n    def column_types(self, column_types):\n        warnings.warn(\n            \"for backwards compatibility only.\"\n            \"You should use the new standard container property .contents to modify Pile contents.\",\n            PendingDeprecationWarning,\n            stacklevel=2,\n        )\n        focus_position = self.focus_position\n        self.contents = [\n            (w, ({Sizing.FIXED: WHSettings.GIVEN, Sizing.FLOW: WHSettings.PACK}.get(new_t, new_t), new_n, b))\n            for ((new_t, new_n), (w, (t, n, b))) in zip(column_types, self.contents)\n        ]\n        if focus_position < len(column_types):\n            self.focus_position = focus_position\n\n    @property\n    def box_columns(self) -> MonitoredList:\n        \"\"\"\n        A list of the indexes of the columns that are to be treated as\n        box widgets when the Columns is treated as a flow widget.\n\n        .. note:: only for backwards compatibility. You should use the new\n            standard container property :attr:`contents`.\n        \"\"\"\n        warnings.warn(\n            \"only for backwards compatibility.You should use the new standard container property `contents`\",\n            PendingDeprecationWarning,\n            stacklevel=2,\n        )\n        ml = MonitoredList(i for i, (w, (t, n, b)) in enumerate(self.contents) if b)\n\n        def user_modified():\n            self.box_columns = ml\n\n        ml.set_modified_callback(user_modified)\n        return ml\n\n    @box_columns.setter\n    def box_columns(self, box_columns):\n        warnings.warn(\n            \"only for backwards compatibility.You should use the new standard container property `contents`\",\n            PendingDeprecationWarning,\n            stacklevel=2,\n        )\n        box_columns = set(box_columns)\n        self.contents = [(w, (t, n, i in box_columns)) for (i, (w, (t, n, b))) in enumerate(self.contents)]\n\n    @property\n    def has_flow_type(self) -> bool:\n        \"\"\"\n        .. deprecated:: 1.0 Read values from :attr:`contents` instead.\n        \"\"\"\n        warnings.warn(\n            \".has_flow_type is deprecated, read values from .contents instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        return WHSettings.PACK in self.column_types\n\n    @has_flow_type.setter\n    def has_flow_type(self, value):\n        warnings.warn(\n            \".has_flow_type is deprecated, read values from .contents instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n\n    @property\n    def contents(self):\n        \"\"\"\n        The contents of this Columns as a list of `(widget, options)` tuples.\n        This list may be modified like a normal list and the Columns\n        widget will update automatically.\n\n        .. seealso:: Create new options tuples with the :meth:`options` method\n        \"\"\"\n        return self._contents\n\n    @contents.setter\n    def contents(self, c):\n        self._contents[:] = c\n\n    @staticmethod\n    def options(\n        width_type: (\n            Literal[\"pack\", \"given\", \"weight\", WHSettings.PACK, WHSettings.GIVEN, WHSettings.WEIGHT]\n        ) = WHSettings.WEIGHT,\n        width_amount: int | None = 1,\n        box_widget: bool = False,\n    ) -> tuple[Literal[WHSettings.PACK], None, bool] | tuple[Literal[WHSettings.GIVEN, WHSettings.WEIGHT], int, bool]:\n        \"\"\"\n        Return a new options tuple for use in a Pile's .contents list.\n\n        This sets an entry's width type: one of the following:\n\n        ``'pack'``\n            Call the widget's :meth:`Widget.pack` method to determine how wide\n            this column should be. *width_amount* is ignored.\n        ``'given'``\n            Make column exactly width_amount screen-columns wide.\n        ``'weight'``\n            Allocate the remaining space to this column by using\n            *width_amount* as a weight value.\n\n        :param width_type: ``'pack'``, ``'given'`` or ``'weight'``\n        :param width_amount: ``None`` for ``'pack'``, a number of screen columns\n            for ``'given'`` or a weight value (number) for ``'weight'``\n        :param box_widget: set to `True` if this widget is to be treated as a box\n            widget when the Columns widget itself is treated as a flow widget.\n        :type box_widget: bool\n        \"\"\"\n        if width_type == WHSettings.PACK:\n            width_amount = None\n        if width_type not in (WHSettings.PACK, WHSettings.GIVEN, WHSettings.WEIGHT):\n            raise ColumnsError(f\"invalid width_type: {width_type!r}\")\n        return (WHSettings(width_type), width_amount, box_widget)\n\n    def _invalidate(self) -> None:\n        self._cache_maxcol = None\n        super()._invalidate()\n\n    def set_focus_column(self, num: int) -> None:\n        \"\"\"\n        Set the column in focus by its index in :attr:`widget_list`.\n\n        :param num: index of focus-to-be entry\n        :type num: int\n\n        .. note:: only for backwards compatibility. You may also use the new\n            standard container property :attr:`focus_position` to set the focus.\n        \"\"\"\n        warnings.warn(\n            \"only for backwards compatibility.You may also use the new standard container property `focus_position`\",\n            PendingDeprecationWarning,\n            stacklevel=2,\n        )\n        self.focus_position = num\n\n    def get_focus_column(self) -> int:\n        \"\"\"\n        Return the focus column index.\n\n        .. note:: only for backwards compatibility. You may also use the new\n            standard container property :attr:`focus_position` to get the focus.\n        \"\"\"\n        warnings.warn(\n            \"only for backwards compatibility.You may also use the new standard container property `focus_position`\",\n            PendingDeprecationWarning,\n            stacklevel=2,\n        )\n        return self.focus_position\n\n    def set_focus(self, item: Widget | int) -> None:\n        \"\"\"\n        Set the item in focus\n\n        .. note:: only for backwards compatibility. You may also use the new\n            standard container property :attr:`focus_position` to get the focus.\n\n        :param item: widget or integer index\"\"\"\n        warnings.warn(\n            \"only for backwards compatibility.\"\n            \"You may also use the new standard container property `focus_position` to get the focus.\",\n            PendingDeprecationWarning,\n            stacklevel=2,\n        )\n        if isinstance(item, int):\n            self.focus_position = item\n            return\n        for i, (w, _options) in enumerate(self.contents):\n            if item == w:\n                self.focus_position = i\n                return\n        raise ValueError(f\"Widget not found in Columns contents: {item!r}\")\n\n    @property\n    def focus(self) -> Widget | None:\n        \"\"\"\n        the child widget in focus or None when Columns is empty\n\n        Return the widget in focus, for backwards compatibility.  You may\n        also use the new standard container property .focus to get the\n        child widget in focus.\n        \"\"\"\n        if not self.contents:\n            return None\n        return self.contents[self.focus_position][0]\n\n    def _get_focus(self) -> Widget:\n        warnings.warn(\n            f\"method `{self.__class__.__name__}._get_focus` is deprecated, \"\n            f\"please use `{self.__class__.__name__}.focus` property\",\n            DeprecationWarning,\n            stacklevel=3,\n        )\n        if not self.contents:\n            return None\n        return self.contents[self.focus_position][0]\n\n    def get_focus(self):\n        \"\"\"\n        Return the widget in focus, for backwards compatibility.\n\n        .. note:: only for backwards compatibility. You may also use the new\n            standard container property :attr:`focus` to get the focus.\n        \"\"\"\n        warnings.warn(\n            \"only for backwards compatibility.\"\n            \"You may also use the new standard container property `focus` to get the focus.\",\n            PendingDeprecationWarning,\n            stacklevel=2,\n        )\n        if not self.contents:\n            return None\n        return self.contents[self.focus_position][0]\n\n    @property\n    def focus_position(self) -> int | None:\n        \"\"\"\n        index of child widget in focus.\n        Raises :exc:`IndexError` if read when Columns is empty, or when set to an invalid index.\n        \"\"\"\n        if not self.contents:\n            raise IndexError(\"No focus_position, Columns is empty\")\n        return self.contents.focus\n\n    @focus_position.setter\n    def focus_position(self, position: int) -> None:\n        \"\"\"\n        Set the widget in focus.\n\n        position -- index of child widget to be made focus\n        \"\"\"\n        try:\n            if position < 0 or position >= len(self.contents):\n                raise IndexError(f\"No Columns child widget at position {position}\")\n        except TypeError as exc:\n            raise IndexError(f\"No Columns child widget at position {position}\").with_traceback(\n                exc.__traceback__\n            ) from exc\n        self.contents.focus = position\n\n    def _get_focus_position(self) -> int | None:\n        warnings.warn(\n            f\"method `{self.__class__.__name__}._get_focus_position` is deprecated, \"\n            f\"please use `{self.__class__.__name__}.focus_position` property\",\n            DeprecationWarning,\n            stacklevel=3,\n        )\n        if not self.contents:\n            raise IndexError(\"No focus_position, Columns is empty\")\n        return self.contents.focus\n\n    def _set_focus_position(self, position: int) -> None:\n        \"\"\"\n        Set the widget in focus.\n\n        position -- index of child widget to be made focus\n        \"\"\"\n        warnings.warn(\n            f\"method `{self.__class__.__name__}._set_focus_position` is deprecated, \"\n            f\"please use `{self.__class__.__name__}.focus_position` property\",\n            DeprecationWarning,\n            stacklevel=3,\n        )\n        try:\n            if position < 0 or position >= len(self.contents):\n                raise IndexError(f\"No Columns child widget at position {position}\")\n        except TypeError as exc:\n            raise IndexError(f\"No Columns child widget at position {position}\").with_traceback(\n                exc.__traceback__\n            ) from exc\n        self.contents.focus = position\n\n    @property\n    def focus_col(self):\n        \"\"\"\n        A property for reading and setting the index of the column in\n        focus.\n\n        .. note:: only for backwards compatibility. You may also use the new\n            standard container property :attr:`focus_position` to get the focus.\n        \"\"\"\n        warnings.warn(\n            \"only for backwards compatibility.\"\n            \"You may also use the new standard container property `focus_position` to get the focus.\",\n            PendingDeprecationWarning,\n            stacklevel=2,\n        )\n        return self.focus_position\n\n    @focus_col.setter\n    def focus_col(self, new_position) -> None:\n        warnings.warn(\n            \"only for backwards compatibility.\"\n            \"You may also use the new standard container property `focus_position` to get the focus.\",\n            PendingDeprecationWarning,\n            stacklevel=2,\n        )\n        self.focus_position = new_position\n\n    def column_widths(self, size: tuple[int] | tuple[int, int], focus: bool = False) -> list[int]:\n        \"\"\"\n        Return a list of column widths.\n\n        0 values in the list mean hide corresponding column completely\n        \"\"\"\n        maxcol = size[0]\n        # FIXME: get rid of this check and recalculate only when\n        # a 'pack' widget has been modified.\n        if maxcol == self._cache_maxcol and not any(t == WHSettings.PACK for w, (t, n, b) in self.contents):\n            return self._cache_column_widths\n\n        widths = []\n\n        weighted = []\n        shared = maxcol + self.dividechars\n\n        for i, (w, (t, width, _b)) in enumerate(self.contents):\n            if t == WHSettings.GIVEN:\n                static_w = width\n            elif t == WHSettings.PACK:\n                # FIXME: should be able to pack with a different\n                # maxcol value\n                static_w = w.pack((maxcol,), focus and i == self.focus_position)[0]\n            else:\n                static_w = self.min_width\n\n            if shared < static_w + self.dividechars and i > self.focus_position:\n                break\n\n            widths.append(static_w)\n            shared -= static_w + self.dividechars\n            if t not in (WHSettings.GIVEN, WHSettings.PACK):\n                weighted.append((width, i))\n\n        # drop columns on the left until we fit\n        for i, _w in enumerate(widths):\n            if shared >= 0:\n                break\n            shared += widths[i] + self.dividechars\n            widths[i] = 0\n            if weighted and weighted[0][1] == i:\n                del weighted[0]\n\n        if shared:\n            # divide up the remaining space between weighted cols\n            weighted.sort()\n            wtotal = sum(weight for weight, i in weighted)\n            grow = shared + len(weighted) * self.min_width\n            for weight, i in weighted:\n                width = int(float(grow) * weight / wtotal + 0.5)\n                width = max(self.min_width, width)\n                widths[i] = width\n                grow -= width\n                wtotal -= weight\n\n        self._cache_maxcol = maxcol\n        self._cache_column_widths = widths\n        return widths\n\n    def render(self, size: tuple[int] | tuple[int, int], focus: bool = False) -> SolidCanvas | CompositeCanvas:\n        \"\"\"\n        Render columns and return canvas.\n\n        :param size: see :meth:`Widget.render` for details\n        :param focus: ``True`` if this widget is in focus\n        :type focus: bool\n        \"\"\"\n        widths = self.column_widths(size, focus)\n\n        box_maxrow = None\n        if len(size) == 1:\n            box_maxrow = 1\n            # two-pass mode to determine maxrow for box columns\n            for i, (mc, (w, (_t, _n, b))) in enumerate(zip(widths, self.contents)):\n                if b:\n                    continue\n                rows = w.rows((mc,), focus=focus and self.focus_position == i)\n                box_maxrow = max(box_maxrow, rows)\n\n        data = []\n        for i, (mc, (w, (_t, _n, b))) in enumerate(zip(widths, self.contents)):\n            # if the widget has a width of 0, hide it\n            if mc <= 0:\n                continue\n\n            if box_maxrow and b:\n                sub_size = (mc, box_maxrow)\n            else:\n                sub_size = (mc,) + size[1:]\n\n            canv = w.render(sub_size, focus=focus and self.focus_position == i)\n\n            if i < len(widths) - 1:\n                mc += self.dividechars  # noqa: PLW2901\n            data.append((canv, i, self.focus_position == i, mc))\n\n        if not data:\n            return SolidCanvas(\" \", size[0], (size[1:] + (1,))[0])\n\n        canv = CanvasJoin(data)\n        if canv.cols() < size[0]:\n            canv.pad_trim_left_right(0, size[0] - canv.cols())\n        return canv\n\n    def get_cursor_coords(self, size):\n        \"\"\"Return the cursor coordinates from the focus widget.\"\"\"\n        w, (t, n, b) = self.contents[self.focus_position]\n\n        if not w.selectable():\n            return None\n        if not hasattr(w, \"get_cursor_coords\"):\n            return None\n\n        widths = self.column_widths(size)\n        if len(widths) <= self.focus_position:\n            return None\n        colw = widths[self.focus_position]\n\n        if len(size) == 1 and b:\n            coords = w.get_cursor_coords((colw, self.rows(size)))\n        else:\n            coords = w.get_cursor_coords((colw,) + size[1:])\n        if coords is None:\n            return None\n        x, y = coords\n        x += sum([self.dividechars + wc for wc in widths[: self.focus_position] if wc > 0])\n        return x, y\n\n    def move_cursor_to_coords(self, size: tuple[int] | tuple[int, int], col: int, row: int) -> bool:\n        \"\"\"\n        Choose a selectable column to focus based on the coords.\n\n        see :meth:`Widget.move_cursor_coords` for details\n        \"\"\"\n        widths = self.column_widths(size)\n\n        best = None\n        x = 0\n        for i, (width, (w, options)) in enumerate(zip(widths, self.contents)):\n            end = x + width\n            if w.selectable():\n                if col != Align.RIGHT and (col == Align.LEFT or x > col) and best is None:\n                    # no other choice\n                    best = i, x, end, w, options\n                    break\n                if col != Align.RIGHT and x > col and col - best[2] < x - col:\n                    # choose one on left\n                    break\n                best = i, x, end, w, options\n                if col != Align.RIGHT and col < end:\n                    # choose this one\n                    break\n            x = end + self.dividechars\n\n        if best is None:\n            return False\n        i, x, end, w, (t, n, b) = best\n        if hasattr(w, \"move_cursor_to_coords\"):\n            if isinstance(col, int):\n                move_x = min(max(0, col - x), end - x - 1)\n            else:\n                move_x = col\n            if len(size) == 1 and b:\n                rval = w.move_cursor_to_coords((end - x, self.rows(size)), move_x, row)\n            else:\n                rval = w.move_cursor_to_coords((end - x,) + size[1:], move_x, row)\n            if rval is False:\n                return False\n\n        self.focus_position = i\n        self.pref_col = col\n        return True\n\n    def mouse_event(\n        self,\n        size: tuple[int] | tuple[int, int],\n        event,\n        button: int,\n        col: int,\n        row: int,\n        focus: bool,\n    ) -> bool | None:\n        \"\"\"\n        Send event to appropriate column.\n        May change focus on button 1 press.\n        \"\"\"\n        widths = self.column_widths(size)\n\n        x = 0\n        for i, (width, (w, (_t, _n, b))) in enumerate(zip(widths, self.contents)):\n            if col < x:\n                return False\n            w = self.contents[i][0]  # noqa: PLW2901\n            end = x + width\n\n            if col >= end:\n                x = end + self.dividechars\n                continue\n\n            focus = focus and self.focus_position == i\n            if is_mouse_press(event) and button == 1 and w.selectable():\n                self.focus_position = i\n\n            if not hasattr(w, \"mouse_event\"):\n                return False\n\n            if len(size) == 1 and b:\n                return w.mouse_event((end - x, self.rows(size)), event, button, col - x, row, focus)\n            return w.mouse_event((end - x,) + size[1:], event, button, col - x, row, focus)\n        return False\n\n    def get_pref_col(self, size: tuple[int] | tuple[int, int]) -> int:\n        \"\"\"Return the pref col from the column in focus.\"\"\"\n        widths = self.column_widths(size)\n\n        w, (t, n, b) = self.contents[self.focus_position]\n        if len(widths) <= self.focus_position:\n            return 0\n        col = None\n        cwidth = widths[self.focus_position]\n        if hasattr(w, \"get_pref_col\"):\n            if len(size) == 1 and b:\n                col = w.get_pref_col((cwidth, self.rows(size)))\n            else:\n                col = w.get_pref_col((cwidth,) + size[1:])\n            if isinstance(col, int):\n                col += self.focus_position * self.dividechars\n                col += sum(widths[: self.focus_position])\n        if col is None:\n            col = self.pref_col\n        if col is None and w.selectable():\n            col = cwidth // 2\n            col += self.focus_position * self.dividechars\n            col += sum(widths[: self.focus_position])\n        return col\n\n    def rows(self, size: tuple[int] | tuple[int, int], focus: bool = False) -> int:\n        \"\"\"\n        Return the number of rows required by the columns.\n        This only makes sense if :attr:`widget_list` contains flow widgets.\n\n        see :meth:`Widget.rows` for details\n        \"\"\"\n        widths = self.column_widths(size, focus)\n\n        rows = 1\n        for i, (mc, (w, (_t, _n, b))) in enumerate(zip(widths, self.contents)):\n            if b:\n                continue\n            rows = max(rows, w.rows((mc,), focus=focus and self.focus_position == i))\n        return rows\n\n    def keypress(self, size: tuple[int] | tuple[int, int], key: str) -> str | None:\n        \"\"\"\n        Pass keypress to the focus column.\n\n        :param size: `(maxcol,)` if :attr:`widget_list` contains flow widgets or\n            `(maxcol, maxrow)` if it contains box widgets.\n        :type size: int, int\n        \"\"\"\n        if self.focus_position is None:\n            return key\n\n        widths = self.column_widths(size)\n        if self.focus_position >= len(widths):\n            return key\n\n        i = self.focus_position\n        mc = widths[i]\n        w, (t, n, b) = self.contents[i]\n        if self._command_map[key] not in (\"cursor up\", \"cursor down\", \"cursor page up\", \"cursor page down\"):\n            self.pref_col = None\n        if w.selectable():\n            if len(size) == 1 and b:\n                key = w.keypress((mc, self.rows(size, True)), key)\n            else:\n                key = w.keypress((mc,) + size[1:], key)\n\n        if self._command_map[key] not in (\"cursor left\", \"cursor right\"):\n            return key\n\n        if self._command_map[key] == \"cursor left\":\n            candidates = list(range(i - 1, -1, -1))  # count backwards to 0\n        else:  # key == 'right'\n            candidates = list(range(i + 1, len(self.contents)))\n\n        for j in candidates:\n            if not self.contents[j][0].selectable():\n                continue\n\n            self.focus_position = j\n            return None\n        return key",
  "def __init__(\n        self,\n        widget_list: Iterable[\n            Widget\n            | tuple[Literal[\"pack\", WHSettings.PACK], Widget]\n            | tuple[Literal[\"weight\", WHSettings.WEIGHT], int, Widget]\n        ],\n        dividechars: int = 0,\n        focus_column: int | None = None,\n        min_width: int = 1,\n        box_columns: Iterable[int] | None = None,\n    ):\n        \"\"\"\n        :param widget_list: iterable of flow or box widgets\n        :param dividechars: number of blank characters between columns\n        :param focus_column: index into widget_list of column in focus,\n            if ``None`` the first selectable widget will be chosen.\n        :param min_width: minimum width for each column which is not\n            calling widget.pack() in *widget_list*.\n        :param box_columns: a list of column indexes containing box widgets\n            whose height is set to the maximum of the rows\n            required by columns not listed in *box_columns*.\n\n        *widget_list* may also contain tuples such as:\n\n        (*given_width*, *widget*)\n            make this column *given_width* screen columns wide, where *given_width*\n            is an int\n        (``'pack'``, *widget*)\n            call :meth:`pack() <Widget.pack>` to calculate the width of this column\n        (``'weight'``, *weight*, *widget*)\n            give this column a relative *weight* (number) to calculate its width from the\n            screen columns remaining\n\n        Widgets not in a tuple are the same as (``'weight'``, ``1``, *widget*)\n\n        If the Columns widget is treated as a box widget then all children\n        are treated as box widgets, and *box_columns* is ignored.\n\n        If the Columns widget is treated as a flow widget then the rows\n        are calculated as the largest rows() returned from all columns\n        except the ones listed in *box_columns*.  The box widgets in\n        *box_columns* will be displayed with this calculated number of rows,\n        filling the full height.\n        \"\"\"\n        self._selectable = False\n        super().__init__()\n        self._contents = MonitoredFocusList()\n        self._contents.set_modified_callback(self._contents_modified)\n        self._contents.set_focus_changed_callback(lambda f: self._invalidate())\n        self._contents.set_validate_contents_modified(self._validate_contents_modified)\n\n        box_columns = set(box_columns or ())\n\n        for i, original in enumerate(widget_list):\n            w = original\n            if not isinstance(w, tuple):\n                self.contents.append((w, (WHSettings.WEIGHT, 1, i in box_columns)))\n            elif w[0] in (Sizing.FLOW, WHSettings.PACK):  # 'pack' used to be called 'flow'\n                f = WHSettings.PACK\n                _ignored, w = w\n                self.contents.append((w, (f, None, i in box_columns)))\n            elif len(w) == 2:\n                width, w = w\n                self.contents.append((w, (WHSettings.GIVEN, width, i in box_columns)))\n            elif w[0] == Sizing.FIXED:  # backwards compatibility\n                f = WHSettings.GIVEN\n                _ignored, width, w = w\n                self.contents.append((w, (WHSettings.GIVEN, width, i in box_columns)))\n            elif w[0] == WHSettings.WEIGHT:\n                f, width, w = w\n                self.contents.append((w, (f, width, i in box_columns)))\n            else:\n                raise ColumnsError(f\"initial widget list item invalid: {original!r}\")\n            if focus_column is None and w.selectable():\n                focus_column = i\n\n        self.dividechars = dividechars\n\n        if self.contents and focus_column is not None:\n            self.focus_position = focus_column\n        self.pref_col = None\n        self.min_width = min_width\n        self._cache_maxcol = None",
  "def _contents_modified(self) -> None:\n        \"\"\"\n        Recalculate whether this widget should be selectable whenever the\n        contents has been changed.\n        \"\"\"\n        self._selectable = any(w.selectable() for w, o in self.contents)\n        self._invalidate()",
  "def _validate_contents_modified(self, slc, new_items) -> None:\n        for item in new_items:\n            try:\n                w, (t, n, b) = item\n                if t not in (WHSettings.PACK, WHSettings.GIVEN, WHSettings.WEIGHT):\n                    raise ColumnsError(f\"added content invalid {item!r}\")\n            except (TypeError, ValueError) as exc:  # noqa: PERF203\n                raise ColumnsError(f\"added content invalid {item!r}\").with_traceback(exc.__traceback__) from exc",
  "def widget_list(self) -> MonitoredList:\n        \"\"\"\n        A list of the widgets in this Columns\n\n        .. note:: only for backwards compatibility. You should use the new\n            standard container property :attr:`contents`.\n        \"\"\"\n        warnings.warn(\n            \"only for backwards compatibility. You should use the new standard container `contents`\",\n            PendingDeprecationWarning,\n            stacklevel=2,\n        )\n        ml = MonitoredList(w for w, t in self.contents)\n\n        def user_modified():\n            self.widget_list = ml\n\n        ml.set_modified_callback(user_modified)\n        return ml",
  "def widget_list(self, widgets):\n        warnings.warn(\n            \"only for backwards compatibility. You should use the new standard container `contents`\",\n            PendingDeprecationWarning,\n            stacklevel=2,\n        )\n        focus_position = self.focus_position\n        self.contents = [\n            # need to grow contents list if widgets is longer\n            (new, options)\n            for (new, (w, options)) in zip(widgets, chain(self.contents, repeat((None, (WHSettings.WEIGHT, 1, False)))))\n        ]\n        if focus_position < len(widgets):\n            self.focus_position = focus_position",
  "def column_types(self) -> MonitoredList:\n        \"\"\"\n        A list of the old partial options values for widgets in this Pile,\n        for backwards compatibility only.  You should use the new standard\n        container property .contents to modify Pile contents.\n        \"\"\"\n        warnings.warn(\n            \"for backwards compatibility only.\"\n            \"You should use the new standard container property .contents to modify Pile contents.\",\n            PendingDeprecationWarning,\n            stacklevel=2,\n        )\n        ml = MonitoredList(\n            # return the old column type names\n            ({WHSettings.GIVEN: Sizing.FIXED, WHSettings.PACK: Sizing.FLOW}.get(t, t), n)\n            for w, (t, n, b) in self.contents\n        )\n\n        def user_modified():\n            self.column_types = ml\n\n        ml.set_modified_callback(user_modified)\n        return ml",
  "def column_types(self, column_types):\n        warnings.warn(\n            \"for backwards compatibility only.\"\n            \"You should use the new standard container property .contents to modify Pile contents.\",\n            PendingDeprecationWarning,\n            stacklevel=2,\n        )\n        focus_position = self.focus_position\n        self.contents = [\n            (w, ({Sizing.FIXED: WHSettings.GIVEN, Sizing.FLOW: WHSettings.PACK}.get(new_t, new_t), new_n, b))\n            for ((new_t, new_n), (w, (t, n, b))) in zip(column_types, self.contents)\n        ]\n        if focus_position < len(column_types):\n            self.focus_position = focus_position",
  "def box_columns(self) -> MonitoredList:\n        \"\"\"\n        A list of the indexes of the columns that are to be treated as\n        box widgets when the Columns is treated as a flow widget.\n\n        .. note:: only for backwards compatibility. You should use the new\n            standard container property :attr:`contents`.\n        \"\"\"\n        warnings.warn(\n            \"only for backwards compatibility.You should use the new standard container property `contents`\",\n            PendingDeprecationWarning,\n            stacklevel=2,\n        )\n        ml = MonitoredList(i for i, (w, (t, n, b)) in enumerate(self.contents) if b)\n\n        def user_modified():\n            self.box_columns = ml\n\n        ml.set_modified_callback(user_modified)\n        return ml",
  "def box_columns(self, box_columns):\n        warnings.warn(\n            \"only for backwards compatibility.You should use the new standard container property `contents`\",\n            PendingDeprecationWarning,\n            stacklevel=2,\n        )\n        box_columns = set(box_columns)\n        self.contents = [(w, (t, n, i in box_columns)) for (i, (w, (t, n, b))) in enumerate(self.contents)]",
  "def has_flow_type(self) -> bool:\n        \"\"\"\n        .. deprecated:: 1.0 Read values from :attr:`contents` instead.\n        \"\"\"\n        warnings.warn(\n            \".has_flow_type is deprecated, read values from .contents instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        return WHSettings.PACK in self.column_types",
  "def has_flow_type(self, value):\n        warnings.warn(\n            \".has_flow_type is deprecated, read values from .contents instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )",
  "def contents(self):\n        \"\"\"\n        The contents of this Columns as a list of `(widget, options)` tuples.\n        This list may be modified like a normal list and the Columns\n        widget will update automatically.\n\n        .. seealso:: Create new options tuples with the :meth:`options` method\n        \"\"\"\n        return self._contents",
  "def contents(self, c):\n        self._contents[:] = c",
  "def options(\n        width_type: (\n            Literal[\"pack\", \"given\", \"weight\", WHSettings.PACK, WHSettings.GIVEN, WHSettings.WEIGHT]\n        ) = WHSettings.WEIGHT,\n        width_amount: int | None = 1,\n        box_widget: bool = False,\n    ) -> tuple[Literal[WHSettings.PACK], None, bool] | tuple[Literal[WHSettings.GIVEN, WHSettings.WEIGHT], int, bool]:\n        \"\"\"\n        Return a new options tuple for use in a Pile's .contents list.\n\n        This sets an entry's width type: one of the following:\n\n        ``'pack'``\n            Call the widget's :meth:`Widget.pack` method to determine how wide\n            this column should be. *width_amount* is ignored.\n        ``'given'``\n            Make column exactly width_amount screen-columns wide.\n        ``'weight'``\n            Allocate the remaining space to this column by using\n            *width_amount* as a weight value.\n\n        :param width_type: ``'pack'``, ``'given'`` or ``'weight'``\n        :param width_amount: ``None`` for ``'pack'``, a number of screen columns\n            for ``'given'`` or a weight value (number) for ``'weight'``\n        :param box_widget: set to `True` if this widget is to be treated as a box\n            widget when the Columns widget itself is treated as a flow widget.\n        :type box_widget: bool\n        \"\"\"\n        if width_type == WHSettings.PACK:\n            width_amount = None\n        if width_type not in (WHSettings.PACK, WHSettings.GIVEN, WHSettings.WEIGHT):\n            raise ColumnsError(f\"invalid width_type: {width_type!r}\")\n        return (WHSettings(width_type), width_amount, box_widget)",
  "def _invalidate(self) -> None:\n        self._cache_maxcol = None\n        super()._invalidate()",
  "def set_focus_column(self, num: int) -> None:\n        \"\"\"\n        Set the column in focus by its index in :attr:`widget_list`.\n\n        :param num: index of focus-to-be entry\n        :type num: int\n\n        .. note:: only for backwards compatibility. You may also use the new\n            standard container property :attr:`focus_position` to set the focus.\n        \"\"\"\n        warnings.warn(\n            \"only for backwards compatibility.You may also use the new standard container property `focus_position`\",\n            PendingDeprecationWarning,\n            stacklevel=2,\n        )\n        self.focus_position = num",
  "def get_focus_column(self) -> int:\n        \"\"\"\n        Return the focus column index.\n\n        .. note:: only for backwards compatibility. You may also use the new\n            standard container property :attr:`focus_position` to get the focus.\n        \"\"\"\n        warnings.warn(\n            \"only for backwards compatibility.You may also use the new standard container property `focus_position`\",\n            PendingDeprecationWarning,\n            stacklevel=2,\n        )\n        return self.focus_position",
  "def set_focus(self, item: Widget | int) -> None:\n        \"\"\"\n        Set the item in focus\n\n        .. note:: only for backwards compatibility. You may also use the new\n            standard container property :attr:`focus_position` to get the focus.\n\n        :param item: widget or integer index\"\"\"\n        warnings.warn(\n            \"only for backwards compatibility.\"\n            \"You may also use the new standard container property `focus_position` to get the focus.\",\n            PendingDeprecationWarning,\n            stacklevel=2,\n        )\n        if isinstance(item, int):\n            self.focus_position = item\n            return\n        for i, (w, _options) in enumerate(self.contents):\n            if item == w:\n                self.focus_position = i\n                return\n        raise ValueError(f\"Widget not found in Columns contents: {item!r}\")",
  "def focus(self) -> Widget | None:\n        \"\"\"\n        the child widget in focus or None when Columns is empty\n\n        Return the widget in focus, for backwards compatibility.  You may\n        also use the new standard container property .focus to get the\n        child widget in focus.\n        \"\"\"\n        if not self.contents:\n            return None\n        return self.contents[self.focus_position][0]",
  "def _get_focus(self) -> Widget:\n        warnings.warn(\n            f\"method `{self.__class__.__name__}._get_focus` is deprecated, \"\n            f\"please use `{self.__class__.__name__}.focus` property\",\n            DeprecationWarning,\n            stacklevel=3,\n        )\n        if not self.contents:\n            return None\n        return self.contents[self.focus_position][0]",
  "def get_focus(self):\n        \"\"\"\n        Return the widget in focus, for backwards compatibility.\n\n        .. note:: only for backwards compatibility. You may also use the new\n            standard container property :attr:`focus` to get the focus.\n        \"\"\"\n        warnings.warn(\n            \"only for backwards compatibility.\"\n            \"You may also use the new standard container property `focus` to get the focus.\",\n            PendingDeprecationWarning,\n            stacklevel=2,\n        )\n        if not self.contents:\n            return None\n        return self.contents[self.focus_position][0]",
  "def focus_position(self) -> int | None:\n        \"\"\"\n        index of child widget in focus.\n        Raises :exc:`IndexError` if read when Columns is empty, or when set to an invalid index.\n        \"\"\"\n        if not self.contents:\n            raise IndexError(\"No focus_position, Columns is empty\")\n        return self.contents.focus",
  "def focus_position(self, position: int) -> None:\n        \"\"\"\n        Set the widget in focus.\n\n        position -- index of child widget to be made focus\n        \"\"\"\n        try:\n            if position < 0 or position >= len(self.contents):\n                raise IndexError(f\"No Columns child widget at position {position}\")\n        except TypeError as exc:\n            raise IndexError(f\"No Columns child widget at position {position}\").with_traceback(\n                exc.__traceback__\n            ) from exc\n        self.contents.focus = position",
  "def _get_focus_position(self) -> int | None:\n        warnings.warn(\n            f\"method `{self.__class__.__name__}._get_focus_position` is deprecated, \"\n            f\"please use `{self.__class__.__name__}.focus_position` property\",\n            DeprecationWarning,\n            stacklevel=3,\n        )\n        if not self.contents:\n            raise IndexError(\"No focus_position, Columns is empty\")\n        return self.contents.focus",
  "def _set_focus_position(self, position: int) -> None:\n        \"\"\"\n        Set the widget in focus.\n\n        position -- index of child widget to be made focus\n        \"\"\"\n        warnings.warn(\n            f\"method `{self.__class__.__name__}._set_focus_position` is deprecated, \"\n            f\"please use `{self.__class__.__name__}.focus_position` property\",\n            DeprecationWarning,\n            stacklevel=3,\n        )\n        try:\n            if position < 0 or position >= len(self.contents):\n                raise IndexError(f\"No Columns child widget at position {position}\")\n        except TypeError as exc:\n            raise IndexError(f\"No Columns child widget at position {position}\").with_traceback(\n                exc.__traceback__\n            ) from exc\n        self.contents.focus = position",
  "def focus_col(self):\n        \"\"\"\n        A property for reading and setting the index of the column in\n        focus.\n\n        .. note:: only for backwards compatibility. You may also use the new\n            standard container property :attr:`focus_position` to get the focus.\n        \"\"\"\n        warnings.warn(\n            \"only for backwards compatibility.\"\n            \"You may also use the new standard container property `focus_position` to get the focus.\",\n            PendingDeprecationWarning,\n            stacklevel=2,\n        )\n        return self.focus_position",
  "def focus_col(self, new_position) -> None:\n        warnings.warn(\n            \"only for backwards compatibility.\"\n            \"You may also use the new standard container property `focus_position` to get the focus.\",\n            PendingDeprecationWarning,\n            stacklevel=2,\n        )\n        self.focus_position = new_position",
  "def column_widths(self, size: tuple[int] | tuple[int, int], focus: bool = False) -> list[int]:\n        \"\"\"\n        Return a list of column widths.\n\n        0 values in the list mean hide corresponding column completely\n        \"\"\"\n        maxcol = size[0]\n        # FIXME: get rid of this check and recalculate only when\n        # a 'pack' widget has been modified.\n        if maxcol == self._cache_maxcol and not any(t == WHSettings.PACK for w, (t, n, b) in self.contents):\n            return self._cache_column_widths\n\n        widths = []\n\n        weighted = []\n        shared = maxcol + self.dividechars\n\n        for i, (w, (t, width, _b)) in enumerate(self.contents):\n            if t == WHSettings.GIVEN:\n                static_w = width\n            elif t == WHSettings.PACK:\n                # FIXME: should be able to pack with a different\n                # maxcol value\n                static_w = w.pack((maxcol,), focus and i == self.focus_position)[0]\n            else:\n                static_w = self.min_width\n\n            if shared < static_w + self.dividechars and i > self.focus_position:\n                break\n\n            widths.append(static_w)\n            shared -= static_w + self.dividechars\n            if t not in (WHSettings.GIVEN, WHSettings.PACK):\n                weighted.append((width, i))\n\n        # drop columns on the left until we fit\n        for i, _w in enumerate(widths):\n            if shared >= 0:\n                break\n            shared += widths[i] + self.dividechars\n            widths[i] = 0\n            if weighted and weighted[0][1] == i:\n                del weighted[0]\n\n        if shared:\n            # divide up the remaining space between weighted cols\n            weighted.sort()\n            wtotal = sum(weight for weight, i in weighted)\n            grow = shared + len(weighted) * self.min_width\n            for weight, i in weighted:\n                width = int(float(grow) * weight / wtotal + 0.5)\n                width = max(self.min_width, width)\n                widths[i] = width\n                grow -= width\n                wtotal -= weight\n\n        self._cache_maxcol = maxcol\n        self._cache_column_widths = widths\n        return widths",
  "def render(self, size: tuple[int] | tuple[int, int], focus: bool = False) -> SolidCanvas | CompositeCanvas:\n        \"\"\"\n        Render columns and return canvas.\n\n        :param size: see :meth:`Widget.render` for details\n        :param focus: ``True`` if this widget is in focus\n        :type focus: bool\n        \"\"\"\n        widths = self.column_widths(size, focus)\n\n        box_maxrow = None\n        if len(size) == 1:\n            box_maxrow = 1\n            # two-pass mode to determine maxrow for box columns\n            for i, (mc, (w, (_t, _n, b))) in enumerate(zip(widths, self.contents)):\n                if b:\n                    continue\n                rows = w.rows((mc,), focus=focus and self.focus_position == i)\n                box_maxrow = max(box_maxrow, rows)\n\n        data = []\n        for i, (mc, (w, (_t, _n, b))) in enumerate(zip(widths, self.contents)):\n            # if the widget has a width of 0, hide it\n            if mc <= 0:\n                continue\n\n            if box_maxrow and b:\n                sub_size = (mc, box_maxrow)\n            else:\n                sub_size = (mc,) + size[1:]\n\n            canv = w.render(sub_size, focus=focus and self.focus_position == i)\n\n            if i < len(widths) - 1:\n                mc += self.dividechars  # noqa: PLW2901\n            data.append((canv, i, self.focus_position == i, mc))\n\n        if not data:\n            return SolidCanvas(\" \", size[0], (size[1:] + (1,))[0])\n\n        canv = CanvasJoin(data)\n        if canv.cols() < size[0]:\n            canv.pad_trim_left_right(0, size[0] - canv.cols())\n        return canv",
  "def get_cursor_coords(self, size):\n        \"\"\"Return the cursor coordinates from the focus widget.\"\"\"\n        w, (t, n, b) = self.contents[self.focus_position]\n\n        if not w.selectable():\n            return None\n        if not hasattr(w, \"get_cursor_coords\"):\n            return None\n\n        widths = self.column_widths(size)\n        if len(widths) <= self.focus_position:\n            return None\n        colw = widths[self.focus_position]\n\n        if len(size) == 1 and b:\n            coords = w.get_cursor_coords((colw, self.rows(size)))\n        else:\n            coords = w.get_cursor_coords((colw,) + size[1:])\n        if coords is None:\n            return None\n        x, y = coords\n        x += sum([self.dividechars + wc for wc in widths[: self.focus_position] if wc > 0])\n        return x, y",
  "def move_cursor_to_coords(self, size: tuple[int] | tuple[int, int], col: int, row: int) -> bool:\n        \"\"\"\n        Choose a selectable column to focus based on the coords.\n\n        see :meth:`Widget.move_cursor_coords` for details\n        \"\"\"\n        widths = self.column_widths(size)\n\n        best = None\n        x = 0\n        for i, (width, (w, options)) in enumerate(zip(widths, self.contents)):\n            end = x + width\n            if w.selectable():\n                if col != Align.RIGHT and (col == Align.LEFT or x > col) and best is None:\n                    # no other choice\n                    best = i, x, end, w, options\n                    break\n                if col != Align.RIGHT and x > col and col - best[2] < x - col:\n                    # choose one on left\n                    break\n                best = i, x, end, w, options\n                if col != Align.RIGHT and col < end:\n                    # choose this one\n                    break\n            x = end + self.dividechars\n\n        if best is None:\n            return False\n        i, x, end, w, (t, n, b) = best\n        if hasattr(w, \"move_cursor_to_coords\"):\n            if isinstance(col, int):\n                move_x = min(max(0, col - x), end - x - 1)\n            else:\n                move_x = col\n            if len(size) == 1 and b:\n                rval = w.move_cursor_to_coords((end - x, self.rows(size)), move_x, row)\n            else:\n                rval = w.move_cursor_to_coords((end - x,) + size[1:], move_x, row)\n            if rval is False:\n                return False\n\n        self.focus_position = i\n        self.pref_col = col\n        return True",
  "def mouse_event(\n        self,\n        size: tuple[int] | tuple[int, int],\n        event,\n        button: int,\n        col: int,\n        row: int,\n        focus: bool,\n    ) -> bool | None:\n        \"\"\"\n        Send event to appropriate column.\n        May change focus on button 1 press.\n        \"\"\"\n        widths = self.column_widths(size)\n\n        x = 0\n        for i, (width, (w, (_t, _n, b))) in enumerate(zip(widths, self.contents)):\n            if col < x:\n                return False\n            w = self.contents[i][0]  # noqa: PLW2901\n            end = x + width\n\n            if col >= end:\n                x = end + self.dividechars\n                continue\n\n            focus = focus and self.focus_position == i\n            if is_mouse_press(event) and button == 1 and w.selectable():\n                self.focus_position = i\n\n            if not hasattr(w, \"mouse_event\"):\n                return False\n\n            if len(size) == 1 and b:\n                return w.mouse_event((end - x, self.rows(size)), event, button, col - x, row, focus)\n            return w.mouse_event((end - x,) + size[1:], event, button, col - x, row, focus)\n        return False",
  "def get_pref_col(self, size: tuple[int] | tuple[int, int]) -> int:\n        \"\"\"Return the pref col from the column in focus.\"\"\"\n        widths = self.column_widths(size)\n\n        w, (t, n, b) = self.contents[self.focus_position]\n        if len(widths) <= self.focus_position:\n            return 0\n        col = None\n        cwidth = widths[self.focus_position]\n        if hasattr(w, \"get_pref_col\"):\n            if len(size) == 1 and b:\n                col = w.get_pref_col((cwidth, self.rows(size)))\n            else:\n                col = w.get_pref_col((cwidth,) + size[1:])\n            if isinstance(col, int):\n                col += self.focus_position * self.dividechars\n                col += sum(widths[: self.focus_position])\n        if col is None:\n            col = self.pref_col\n        if col is None and w.selectable():\n            col = cwidth // 2\n            col += self.focus_position * self.dividechars\n            col += sum(widths[: self.focus_position])\n        return col",
  "def rows(self, size: tuple[int] | tuple[int, int], focus: bool = False) -> int:\n        \"\"\"\n        Return the number of rows required by the columns.\n        This only makes sense if :attr:`widget_list` contains flow widgets.\n\n        see :meth:`Widget.rows` for details\n        \"\"\"\n        widths = self.column_widths(size, focus)\n\n        rows = 1\n        for i, (mc, (w, (_t, _n, b))) in enumerate(zip(widths, self.contents)):\n            if b:\n                continue\n            rows = max(rows, w.rows((mc,), focus=focus and self.focus_position == i))\n        return rows",
  "def keypress(self, size: tuple[int] | tuple[int, int], key: str) -> str | None:\n        \"\"\"\n        Pass keypress to the focus column.\n\n        :param size: `(maxcol,)` if :attr:`widget_list` contains flow widgets or\n            `(maxcol, maxrow)` if it contains box widgets.\n        :type size: int, int\n        \"\"\"\n        if self.focus_position is None:\n            return key\n\n        widths = self.column_widths(size)\n        if self.focus_position >= len(widths):\n            return key\n\n        i = self.focus_position\n        mc = widths[i]\n        w, (t, n, b) = self.contents[i]\n        if self._command_map[key] not in (\"cursor up\", \"cursor down\", \"cursor page up\", \"cursor page down\"):\n            self.pref_col = None\n        if w.selectable():\n            if len(size) == 1 and b:\n                key = w.keypress((mc, self.rows(size, True)), key)\n            else:\n                key = w.keypress((mc,) + size[1:], key)\n\n        if self._command_map[key] not in (\"cursor left\", \"cursor right\"):\n            return key\n\n        if self._command_map[key] == \"cursor left\":\n            candidates = list(range(i - 1, -1, -1))  # count backwards to 0\n        else:  # key == 'right'\n            candidates = list(range(i + 1, len(self.contents)))\n\n        for j in candidates:\n            if not self.contents[j][0].selectable():\n                continue\n\n            self.focus_position = j\n            return None\n        return key",
  "def user_modified():\n            self.widget_list = ml",
  "def user_modified():\n            self.column_types = ml",
  "def user_modified():\n            self.box_columns = ml",
  "class OverlayError(Exception):\n    pass",
  "class Overlay(Widget, WidgetContainerMixin, WidgetContainerListContentsMixin):\n    \"\"\"\n    Overlay contains two box widgets and renders one on top of the other\n    \"\"\"\n\n    _selectable = True\n    _sizing = frozenset([Sizing.BOX])\n\n    _DEFAULT_BOTTOM_OPTIONS = (\n        Align.LEFT,\n        None,\n        WHSettings.RELATIVE,\n        100,\n        None,\n        0,\n        0,\n        VAlign.TOP,\n        None,\n        WHSettings.RELATIVE,\n        100,\n        None,\n        0,\n        0,\n    )\n\n    def __init__(\n        self,\n        top_w: Widget,\n        bottom_w: Widget,\n        align: (\n            Literal[\"left\", \"center\", \"right\"]\n            | Align\n            | tuple[Literal[\"relative\", \"fixed left\", \"fixed right\", WHSettings.RELATIVE], int]\n        ),\n        width: Literal[\"pack\", WHSettings.PACK] | int | tuple[Literal[\"relative\", WHSettings.RELATIVE], int] | None,\n        valign: (\n            Literal[\"top\", \"middle\", \"bottom\"]\n            | VAlign\n            | tuple[Literal[\"relative\", \"fixed top\", \"fixed bottom\", WHSettings.RELATIVE], int]\n        ),\n        height: Literal[\"pack\", WHSettings.PACK] | int | tuple[Literal[\"relative\", WHSettings.RELATIVE], int] | None,\n        min_width: int | None = None,\n        min_height: int | None = None,\n        left: int = 0,\n        right: int = 0,\n        top: int = 0,\n        bottom: int = 0,\n    ) -> None:\n        \"\"\"\n        :param top_w: a flow, box or fixed widget to overlay \"on top\"\n        :type top_w: Widget\n        :param bottom_w: a box widget to appear \"below\" previous widget\n        :type bottom_w: Widget\n        :param align: alignment, one of ``'left'``, ``'center'``, ``'right'`` or\n            (``'relative'``, *percentage* 0=left 100=right)\n        :type align: str\n        :param width: width type, one of:\n\n            ``'pack'``\n              if *top_w* is a fixed widget\n            *given width*\n              integer number of columns wide\n            (``'relative'``, *percentage of total width*)\n              make *top_w* width related to container width\n\n        :param valign: alignment mode, one of ``'top'``, ``'middle'``, ``'bottom'`` or\n            (``'relative'``, *percentage* 0=top 100=bottom)\n        :param height: one of:\n\n            ``'pack'``\n              if *top_w* is a flow or fixed widget\n            *given height*\n              integer number of rows high\n            (``'relative'``, *percentage of total height*)\n              make *top_w* height related to container height\n        :param min_width: the minimum number of columns for *top_w* when width\n            is not fixed\n        :type min_width: int\n        :param min_height: minimum number of rows for *top_w* when height\n            is not fixed\n        :type min_height: int\n        :param left: a fixed number of columns to add on the left\n        :type left: int\n        :param right: a fixed number of columns to add on the right\n        :type right: int\n        :param top: a fixed number of rows to add on the top\n        :type top: int\n        :param bottom: a fixed number of rows to add on the bottom\n        :type bottom: int\n\n        Overlay widgets behave similarly to :class:`Padding` and :class:`Filler`\n        widgets when determining the size and position of *top_w*. *bottom_w* is\n        always rendered the full size available \"below\" *top_w*.\n        \"\"\"\n        super().__init__()\n\n        self.top_w = top_w\n        self.bottom_w = bottom_w\n\n        self.set_overlay_parameters(align, width, valign, height, min_width, min_height, left, right, top, bottom)\n\n    @staticmethod\n    def options(\n        align_type: Literal[\"left\", \"center\", \"right\", \"relative\"] | Align,\n        align_amount: int | None,\n        width_type: Literal[\"clip\", \"pack\", \"relative\", \"given\"] | WHSettings,\n        width_amount: int | None,\n        valign_type: Literal[\"top\", \"middle\", \"bottom\", \"relative\"] | VAlign,\n        valign_amount: int | None,\n        height_type: Literal[\"flow\", \"pack\", \"relative\", \"given\"] | WHSettings,\n        height_amount: int | None,\n        min_width: int | None = None,\n        min_height: int | None = None,\n        left: int = 0,\n        right: int = 0,\n        top: int = 0,\n        bottom: int = 0,\n    ):\n        \"\"\"\n        Return a new options tuple for use in this Overlay's .contents mapping.\n\n        This is the common container API to create options for replacing the\n        top widget of this Overlay.  It is provided for completeness\n        but is not necessarily the easiest way to change the overlay parameters.\n        See also :meth:`.set_overlay_parameters`\n        \"\"\"\n\n        return (\n            align_type,\n            align_amount,\n            width_type,\n            width_amount,\n            min_width,\n            left,\n            right,\n            valign_type,\n            valign_amount,\n            height_type,\n            height_amount,\n            min_height,\n            top,\n            bottom,\n        )\n\n    def set_overlay_parameters(\n        self,\n        align: (\n            Literal[\"left\", \"center\", \"right\"] | Align | tuple[Literal[\"relative\", \"fixed left\", \"fixed right\"], int]\n        ),\n        width: int | None,\n        valign: (\n            Literal[\"top\", \"middle\", \"bottom\"] | VAlign | tuple[Literal[\"relative\", \"fixed top\", \"fixed bottom\"], int]\n        ),\n        height: int | None,\n        min_width: int | None = None,\n        min_height: int | None = None,\n        left: int = 0,\n        right: int = 0,\n        top: int = 0,\n        bottom: int = 0,\n    ):\n        \"\"\"\n        Adjust the overlay size and position parameters.\n\n        See :class:`__init__() <Overlay>` for a description of the parameters.\n        \"\"\"\n\n        # convert obsolete parameters 'fixed ...':\n        if isinstance(align, tuple):\n            if align[0] == \"fixed left\":\n                left = align[1]\n                align = Align.LEFT\n            elif align[0] == \"fixed right\":\n                right = align[1]\n                align = Align.RIGHT\n        if isinstance(width, tuple):\n            if width[0] == \"fixed left\":\n                left = width[1]\n                width = RELATIVE_100\n            elif width[0] == \"fixed right\":\n                right = width[1]\n                width = RELATIVE_100\n        if isinstance(valign, tuple):\n            if valign[0] == \"fixed top\":\n                top = valign[1]\n                valign = VAlign.TOP\n            elif valign[0] == \"fixed bottom\":\n                bottom = valign[1]\n                valign = VAlign.BOTTOM\n        if isinstance(height, tuple):\n            if height[0] == \"fixed bottom\":\n                bottom = height[1]\n                height = RELATIVE_100\n            elif height[0] == \"fixed top\":\n                top = height[1]\n                height = RELATIVE_100\n\n        if width is None:  # more obsolete values accepted\n            width = WHSettings.PACK\n        if height is None:\n            height = WHSettings.PACK\n\n        align_type, align_amount = normalize_align(align, OverlayError)\n        width_type, width_amount = normalize_width(width, OverlayError)\n        valign_type, valign_amount = normalize_valign(valign, OverlayError)\n        height_type, height_amount = normalize_height(height, OverlayError)\n\n        if height_type in (WHSettings.GIVEN, WHSettings.PACK):\n            min_height = None\n\n        # use container API to set the parameters\n        self.contents[1] = (\n            self.top_w,\n            self.options(\n                align_type,\n                align_amount,\n                width_type,\n                width_amount,\n                valign_type,\n                valign_amount,\n                height_type,\n                height_amount,\n                min_width,\n                min_height,\n                left,\n                right,\n                top,\n                bottom,\n            ),\n        )\n\n    def selectable(self) -> bool:\n        \"\"\"Return selectable from top_w.\"\"\"\n        return self.top_w.selectable()\n\n    def keypress(self, size: tuple[int, int], key: str) -> str | None:\n        \"\"\"Pass keypress to top_w.\"\"\"\n        return self.top_w.keypress(self.top_w_size(size, *self.calculate_padding_filler(size, True)), key)\n\n    @property\n    def focus(self) -> Widget:\n        \"\"\"\n        Read-only property returning the child widget in focus for\n        container widgets.  This default implementation\n        always returns ``None``, indicating that this widget has no children.\n        \"\"\"\n        return self.top_w\n\n    def _get_focus(self) -> Widget:\n        warnings.warn(\n            f\"method `{self.__class__.__name__}._get_focus` is deprecated, \"\n            f\"please use `{self.__class__.__name__}.focus` property\",\n            DeprecationWarning,\n            stacklevel=3,\n        )\n        return self.top_w\n\n    @property\n    def focus_position(self) -> Literal[1]:\n        \"\"\"\n        Return the top widget position (currently always 1).\n        \"\"\"\n        return 1\n\n    @focus_position.setter\n    def focus_position(self, position: int) -> None:\n        \"\"\"\n        Set the widget in focus.  Currently only position 0 is accepted.\n\n        position -- index of child widget to be made focus\n        \"\"\"\n        if position != 1:\n            raise IndexError(f\"Overlay widget focus_position currently must always be set to 1, not {position}\")\n\n    def _get_focus_position(self) -> int | None:\n        warnings.warn(\n            f\"method `{self.__class__.__name__}._get_focus_position` is deprecated, \"\n            f\"please use `{self.__class__.__name__}.focus_position` property\",\n            DeprecationWarning,\n            stacklevel=3,\n        )\n        return 1\n\n    def _set_focus_position(self, position: int) -> None:\n        \"\"\"\n        Set the widget in focus.\n\n        position -- index of child widget to be made focus\n        \"\"\"\n        warnings.warn(\n            f\"method `{self.__class__.__name__}._set_focus_position` is deprecated, \"\n            f\"please use `{self.__class__.__name__}.focus_position` property\",\n            DeprecationWarning,\n            stacklevel=3,\n        )\n        if position != 1:\n            raise IndexError(f\"Overlay widget focus_position currently must always be set to 1, not {position}\")\n\n    @property\n    def contents(self):\n        \"\"\"\n        a list-like object similar to::\n\n            [(bottom_w, bottom_options)),\n             (top_w, top_options)]\n\n        This object may be used to read or update top and bottom widgets and\n        top widgets's options, but no widgets may be added or removed.\n\n        `top_options` takes the form\n        `(align_type, align_amount, width_type, width_amount, min_width, left,\n        right, valign_type, valign_amount, height_type, height_amount,\n        min_height, top, bottom)`\n\n        bottom_options is always\n        `('left', None, 'relative', 100, None, 0, 0,\n        'top', None, 'relative', 100, None, 0, 0)`\n        which means that bottom widget always covers the full area of the Overlay.\n        writing a different value for `bottom_options` raises an\n        :exc:`OverlayError`.\n        \"\"\"\n\n        class OverlayContents:\n            def __len__(inner_self):\n                return 2\n\n            __getitem__ = self._contents__getitem__\n            __setitem__ = self._contents__setitem__\n\n        return OverlayContents()\n\n    @contents.setter\n    def contents(self, new_contents):\n        if len(new_contents) != 2:\n            raise ValueError(\"Contents length for overlay should be only 2\")\n        self.contents[0] = new_contents[0]\n        self.contents[1] = new_contents[1]\n\n    def _contents__getitem__(self, index: Literal[0, 1]):\n        if index == 0:\n            return (self.bottom_w, self._DEFAULT_BOTTOM_OPTIONS)\n        if index == 1:\n            return (\n                self.top_w,\n                (\n                    self.align_type,\n                    self.align_amount,\n                    self.width_type,\n                    self.width_amount,\n                    self.min_width,\n                    self.left,\n                    self.right,\n                    self.valign_type,\n                    self.valign_amount,\n                    self.height_type,\n                    self.height_amount,\n                    self.min_height,\n                    self.top,\n                    self.bottom,\n                ),\n            )\n        raise IndexError(f\"Overlay.contents has no position {index!r}\")\n\n    def _contents__setitem__(self, index: Literal[0, 1], value):\n        try:\n            value_w, value_options = value\n        except (ValueError, TypeError) as exc:\n            raise OverlayError(f\"added content invalid: {value!r}\").with_traceback(exc.__traceback__) from exc\n        if index == 0:\n            if value_options != self._DEFAULT_BOTTOM_OPTIONS:\n                raise OverlayError(f\"bottom_options must be set to {self._DEFAULT_BOTTOM_OPTIONS!r}\")\n            self.bottom_w = value_w\n        elif index == 1:\n            try:\n                (\n                    align_type,\n                    align_amount,\n                    width_type,\n                    width_amount,\n                    min_width,\n                    left,\n                    right,\n                    valign_type,\n                    valign_amount,\n                    height_type,\n                    height_amount,\n                    min_height,\n                    top,\n                    bottom,\n                ) = value_options\n            except (ValueError, TypeError) as exc:\n                raise OverlayError(f\"top_options is invalid: {value_options!r}\").with_traceback(\n                    exc.__traceback__\n                ) from exc\n            # normalize first, this is where errors are raised\n            align_type, align_amount = normalize_align(simplify_align(align_type, align_amount), OverlayError)\n            width_type, width_amount = normalize_width(simplify_width(width_type, width_amount), OverlayError)\n            valign_type, valign_amoun = normalize_valign(simplify_valign(valign_type, valign_amount), OverlayError)\n            height_type, height_amount = normalize_height(simplify_height(height_type, height_amount), OverlayError)\n            self.align_type = align_type\n            self.align_amount = align_amount\n            self.width_type = width_type\n            self.width_amount = width_amount\n            self.valign_type = valign_type\n            self.valign_amount = valign_amount\n            self.height_type = height_type\n            self.height_amount = height_amount\n            self.left = left\n            self.right = right\n            self.top = top\n            self.bottom = bottom\n            self.min_width = min_width\n            self.min_height = min_height\n        else:\n            raise IndexError(f\"Overlay.contents has no position {index!r}\")\n        self._invalidate()\n\n    def get_cursor_coords(self, size: tuple[int, int]) -> tuple[int, int] | None:\n        \"\"\"Return cursor coords from top_w, if any.\"\"\"\n        if not hasattr(self.top_w, \"get_cursor_coords\"):\n            return None\n        (maxcol, maxrow) = size\n        left, right, top, bottom = self.calculate_padding_filler(size, True)\n        x, y = self.top_w.get_cursor_coords((maxcol - left - right, maxrow - top - bottom))\n        if y >= maxrow:  # required??\n            y = maxrow - 1\n        return x + left, y + top\n\n    def calculate_padding_filler(self, size: tuple[int, int], focus: bool) -> tuple[int, int, int, int]:\n        \"\"\"Return (padding left, right, filler top, bottom).\"\"\"\n        (maxcol, maxrow) = size\n        height = None\n        if self.width_type == WHSettings.PACK:\n            width, height = self.top_w.pack((), focus=focus)\n            if not height:\n                raise OverlayError(\"fixed widget must have a height\")\n            left, right = calculate_left_right_padding(\n                maxcol,\n                self.align_type,\n                self.align_amount,\n                WrapMode.CLIP,\n                width,\n                None,\n                self.left,\n                self.right,\n            )\n        else:\n            left, right = calculate_left_right_padding(\n                maxcol,\n                self.align_type,\n                self.align_amount,\n                self.width_type,\n                self.width_amount,\n                self.min_width,\n                self.left,\n                self.right,\n            )\n\n        if height:\n            # top_w is a fixed widget\n            top, bottom = calculate_top_bottom_filler(\n                maxrow,\n                self.valign_type,\n                self.valign_amount,\n                WHSettings.GIVEN,\n                height,\n                None,\n                self.top,\n                self.bottom,\n            )\n            if maxrow - top - bottom < height:\n                bottom = maxrow - top - height\n        elif self.height_type == WHSettings.PACK:\n            # top_w is a flow widget\n            height = self.top_w.rows((maxcol,), focus=focus)\n            top, bottom = calculate_top_bottom_filler(\n                maxrow,\n                self.valign_type,\n                self.valign_amount,\n                WHSettings.GIVEN,\n                height,\n                None,\n                self.top,\n                self.bottom,\n            )\n            if height > maxrow:  # flow widget rendered too large\n                bottom = maxrow - height\n        else:\n            top, bottom = calculate_top_bottom_filler(\n                maxrow,\n                self.valign_type,\n                self.valign_amount,\n                self.height_type,\n                self.height_amount,\n                self.min_height,\n                self.top,\n                self.bottom,\n            )\n        return left, right, top, bottom\n\n    def top_w_size(self, size, left, right, top, bottom):\n        \"\"\"Return the size to pass to top_w.\"\"\"\n        if self.width_type == WHSettings.PACK:\n            # top_w is a fixed widget\n            return ()\n        maxcol, maxrow = size\n        if self.width_type != WHSettings.PACK and self.height_type == WHSettings.PACK:\n            # top_w is a flow widget\n            return (maxcol - left - right,)\n        return (maxcol - left - right, maxrow - top - bottom)\n\n    def render(self, size: tuple[int, int], focus: bool = False) -> CompositeCanvas:\n        \"\"\"Render top_w overlayed on bottom_w.\"\"\"\n        left, right, top, bottom = self.calculate_padding_filler(size, focus)\n        bottom_c = self.bottom_w.render(size)\n        if not bottom_c.cols() or not bottom_c.rows():\n            return CompositeCanvas(bottom_c)\n\n        top_c = self.top_w.render(self.top_w_size(size, left, right, top, bottom), focus)\n        top_c = CompositeCanvas(top_c)\n        if left < 0 or right < 0:\n            top_c.pad_trim_left_right(min(0, left), min(0, right))\n        if top < 0 or bottom < 0:\n            top_c.pad_trim_top_bottom(min(0, top), min(0, bottom))\n\n        return CanvasOverlay(top_c, bottom_c, left, top)\n\n    def mouse_event(self, size: tuple[int, int], event, button: int, col: int, row: int, focus: bool) -> bool | None:\n        \"\"\"Pass event to top_w, ignore if outside of top_w.\"\"\"\n        if not hasattr(self.top_w, \"mouse_event\"):\n            return False\n\n        left, right, top, bottom = self.calculate_padding_filler(size, focus)\n        maxcol, maxrow = size\n        if col < left or col >= maxcol - right or row < top or row >= maxrow - bottom:\n            return False\n\n        return self.top_w.mouse_event(\n            self.top_w_size(size, left, right, top, bottom), event, button, col - left, row - top, focus\n        )",
  "def __init__(\n        self,\n        top_w: Widget,\n        bottom_w: Widget,\n        align: (\n            Literal[\"left\", \"center\", \"right\"]\n            | Align\n            | tuple[Literal[\"relative\", \"fixed left\", \"fixed right\", WHSettings.RELATIVE], int]\n        ),\n        width: Literal[\"pack\", WHSettings.PACK] | int | tuple[Literal[\"relative\", WHSettings.RELATIVE], int] | None,\n        valign: (\n            Literal[\"top\", \"middle\", \"bottom\"]\n            | VAlign\n            | tuple[Literal[\"relative\", \"fixed top\", \"fixed bottom\", WHSettings.RELATIVE], int]\n        ),\n        height: Literal[\"pack\", WHSettings.PACK] | int | tuple[Literal[\"relative\", WHSettings.RELATIVE], int] | None,\n        min_width: int | None = None,\n        min_height: int | None = None,\n        left: int = 0,\n        right: int = 0,\n        top: int = 0,\n        bottom: int = 0,\n    ) -> None:\n        \"\"\"\n        :param top_w: a flow, box or fixed widget to overlay \"on top\"\n        :type top_w: Widget\n        :param bottom_w: a box widget to appear \"below\" previous widget\n        :type bottom_w: Widget\n        :param align: alignment, one of ``'left'``, ``'center'``, ``'right'`` or\n            (``'relative'``, *percentage* 0=left 100=right)\n        :type align: str\n        :param width: width type, one of:\n\n            ``'pack'``\n              if *top_w* is a fixed widget\n            *given width*\n              integer number of columns wide\n            (``'relative'``, *percentage of total width*)\n              make *top_w* width related to container width\n\n        :param valign: alignment mode, one of ``'top'``, ``'middle'``, ``'bottom'`` or\n            (``'relative'``, *percentage* 0=top 100=bottom)\n        :param height: one of:\n\n            ``'pack'``\n              if *top_w* is a flow or fixed widget\n            *given height*\n              integer number of rows high\n            (``'relative'``, *percentage of total height*)\n              make *top_w* height related to container height\n        :param min_width: the minimum number of columns for *top_w* when width\n            is not fixed\n        :type min_width: int\n        :param min_height: minimum number of rows for *top_w* when height\n            is not fixed\n        :type min_height: int\n        :param left: a fixed number of columns to add on the left\n        :type left: int\n        :param right: a fixed number of columns to add on the right\n        :type right: int\n        :param top: a fixed number of rows to add on the top\n        :type top: int\n        :param bottom: a fixed number of rows to add on the bottom\n        :type bottom: int\n\n        Overlay widgets behave similarly to :class:`Padding` and :class:`Filler`\n        widgets when determining the size and position of *top_w*. *bottom_w* is\n        always rendered the full size available \"below\" *top_w*.\n        \"\"\"\n        super().__init__()\n\n        self.top_w = top_w\n        self.bottom_w = bottom_w\n\n        self.set_overlay_parameters(align, width, valign, height, min_width, min_height, left, right, top, bottom)",
  "def options(\n        align_type: Literal[\"left\", \"center\", \"right\", \"relative\"] | Align,\n        align_amount: int | None,\n        width_type: Literal[\"clip\", \"pack\", \"relative\", \"given\"] | WHSettings,\n        width_amount: int | None,\n        valign_type: Literal[\"top\", \"middle\", \"bottom\", \"relative\"] | VAlign,\n        valign_amount: int | None,\n        height_type: Literal[\"flow\", \"pack\", \"relative\", \"given\"] | WHSettings,\n        height_amount: int | None,\n        min_width: int | None = None,\n        min_height: int | None = None,\n        left: int = 0,\n        right: int = 0,\n        top: int = 0,\n        bottom: int = 0,\n    ):\n        \"\"\"\n        Return a new options tuple for use in this Overlay's .contents mapping.\n\n        This is the common container API to create options for replacing the\n        top widget of this Overlay.  It is provided for completeness\n        but is not necessarily the easiest way to change the overlay parameters.\n        See also :meth:`.set_overlay_parameters`\n        \"\"\"\n\n        return (\n            align_type,\n            align_amount,\n            width_type,\n            width_amount,\n            min_width,\n            left,\n            right,\n            valign_type,\n            valign_amount,\n            height_type,\n            height_amount,\n            min_height,\n            top,\n            bottom,\n        )",
  "def set_overlay_parameters(\n        self,\n        align: (\n            Literal[\"left\", \"center\", \"right\"] | Align | tuple[Literal[\"relative\", \"fixed left\", \"fixed right\"], int]\n        ),\n        width: int | None,\n        valign: (\n            Literal[\"top\", \"middle\", \"bottom\"] | VAlign | tuple[Literal[\"relative\", \"fixed top\", \"fixed bottom\"], int]\n        ),\n        height: int | None,\n        min_width: int | None = None,\n        min_height: int | None = None,\n        left: int = 0,\n        right: int = 0,\n        top: int = 0,\n        bottom: int = 0,\n    ):\n        \"\"\"\n        Adjust the overlay size and position parameters.\n\n        See :class:`__init__() <Overlay>` for a description of the parameters.\n        \"\"\"\n\n        # convert obsolete parameters 'fixed ...':\n        if isinstance(align, tuple):\n            if align[0] == \"fixed left\":\n                left = align[1]\n                align = Align.LEFT\n            elif align[0] == \"fixed right\":\n                right = align[1]\n                align = Align.RIGHT\n        if isinstance(width, tuple):\n            if width[0] == \"fixed left\":\n                left = width[1]\n                width = RELATIVE_100\n            elif width[0] == \"fixed right\":\n                right = width[1]\n                width = RELATIVE_100\n        if isinstance(valign, tuple):\n            if valign[0] == \"fixed top\":\n                top = valign[1]\n                valign = VAlign.TOP\n            elif valign[0] == \"fixed bottom\":\n                bottom = valign[1]\n                valign = VAlign.BOTTOM\n        if isinstance(height, tuple):\n            if height[0] == \"fixed bottom\":\n                bottom = height[1]\n                height = RELATIVE_100\n            elif height[0] == \"fixed top\":\n                top = height[1]\n                height = RELATIVE_100\n\n        if width is None:  # more obsolete values accepted\n            width = WHSettings.PACK\n        if height is None:\n            height = WHSettings.PACK\n\n        align_type, align_amount = normalize_align(align, OverlayError)\n        width_type, width_amount = normalize_width(width, OverlayError)\n        valign_type, valign_amount = normalize_valign(valign, OverlayError)\n        height_type, height_amount = normalize_height(height, OverlayError)\n\n        if height_type in (WHSettings.GIVEN, WHSettings.PACK):\n            min_height = None\n\n        # use container API to set the parameters\n        self.contents[1] = (\n            self.top_w,\n            self.options(\n                align_type,\n                align_amount,\n                width_type,\n                width_amount,\n                valign_type,\n                valign_amount,\n                height_type,\n                height_amount,\n                min_width,\n                min_height,\n                left,\n                right,\n                top,\n                bottom,\n            ),\n        )",
  "def selectable(self) -> bool:\n        \"\"\"Return selectable from top_w.\"\"\"\n        return self.top_w.selectable()",
  "def keypress(self, size: tuple[int, int], key: str) -> str | None:\n        \"\"\"Pass keypress to top_w.\"\"\"\n        return self.top_w.keypress(self.top_w_size(size, *self.calculate_padding_filler(size, True)), key)",
  "def focus(self) -> Widget:\n        \"\"\"\n        Read-only property returning the child widget in focus for\n        container widgets.  This default implementation\n        always returns ``None``, indicating that this widget has no children.\n        \"\"\"\n        return self.top_w",
  "def _get_focus(self) -> Widget:\n        warnings.warn(\n            f\"method `{self.__class__.__name__}._get_focus` is deprecated, \"\n            f\"please use `{self.__class__.__name__}.focus` property\",\n            DeprecationWarning,\n            stacklevel=3,\n        )\n        return self.top_w",
  "def focus_position(self) -> Literal[1]:\n        \"\"\"\n        Return the top widget position (currently always 1).\n        \"\"\"\n        return 1",
  "def focus_position(self, position: int) -> None:\n        \"\"\"\n        Set the widget in focus.  Currently only position 0 is accepted.\n\n        position -- index of child widget to be made focus\n        \"\"\"\n        if position != 1:\n            raise IndexError(f\"Overlay widget focus_position currently must always be set to 1, not {position}\")",
  "def _get_focus_position(self) -> int | None:\n        warnings.warn(\n            f\"method `{self.__class__.__name__}._get_focus_position` is deprecated, \"\n            f\"please use `{self.__class__.__name__}.focus_position` property\",\n            DeprecationWarning,\n            stacklevel=3,\n        )\n        return 1",
  "def _set_focus_position(self, position: int) -> None:\n        \"\"\"\n        Set the widget in focus.\n\n        position -- index of child widget to be made focus\n        \"\"\"\n        warnings.warn(\n            f\"method `{self.__class__.__name__}._set_focus_position` is deprecated, \"\n            f\"please use `{self.__class__.__name__}.focus_position` property\",\n            DeprecationWarning,\n            stacklevel=3,\n        )\n        if position != 1:\n            raise IndexError(f\"Overlay widget focus_position currently must always be set to 1, not {position}\")",
  "def contents(self):\n        \"\"\"\n        a list-like object similar to::\n\n            [(bottom_w, bottom_options)),\n             (top_w, top_options)]\n\n        This object may be used to read or update top and bottom widgets and\n        top widgets's options, but no widgets may be added or removed.\n\n        `top_options` takes the form\n        `(align_type, align_amount, width_type, width_amount, min_width, left,\n        right, valign_type, valign_amount, height_type, height_amount,\n        min_height, top, bottom)`\n\n        bottom_options is always\n        `('left', None, 'relative', 100, None, 0, 0,\n        'top', None, 'relative', 100, None, 0, 0)`\n        which means that bottom widget always covers the full area of the Overlay.\n        writing a different value for `bottom_options` raises an\n        :exc:`OverlayError`.\n        \"\"\"\n\n        class OverlayContents:\n            def __len__(inner_self):\n                return 2\n\n            __getitem__ = self._contents__getitem__\n            __setitem__ = self._contents__setitem__\n\n        return OverlayContents()",
  "def contents(self, new_contents):\n        if len(new_contents) != 2:\n            raise ValueError(\"Contents length for overlay should be only 2\")\n        self.contents[0] = new_contents[0]\n        self.contents[1] = new_contents[1]",
  "def _contents__getitem__(self, index: Literal[0, 1]):\n        if index == 0:\n            return (self.bottom_w, self._DEFAULT_BOTTOM_OPTIONS)\n        if index == 1:\n            return (\n                self.top_w,\n                (\n                    self.align_type,\n                    self.align_amount,\n                    self.width_type,\n                    self.width_amount,\n                    self.min_width,\n                    self.left,\n                    self.right,\n                    self.valign_type,\n                    self.valign_amount,\n                    self.height_type,\n                    self.height_amount,\n                    self.min_height,\n                    self.top,\n                    self.bottom,\n                ),\n            )\n        raise IndexError(f\"Overlay.contents has no position {index!r}\")",
  "def _contents__setitem__(self, index: Literal[0, 1], value):\n        try:\n            value_w, value_options = value\n        except (ValueError, TypeError) as exc:\n            raise OverlayError(f\"added content invalid: {value!r}\").with_traceback(exc.__traceback__) from exc\n        if index == 0:\n            if value_options != self._DEFAULT_BOTTOM_OPTIONS:\n                raise OverlayError(f\"bottom_options must be set to {self._DEFAULT_BOTTOM_OPTIONS!r}\")\n            self.bottom_w = value_w\n        elif index == 1:\n            try:\n                (\n                    align_type,\n                    align_amount,\n                    width_type,\n                    width_amount,\n                    min_width,\n                    left,\n                    right,\n                    valign_type,\n                    valign_amount,\n                    height_type,\n                    height_amount,\n                    min_height,\n                    top,\n                    bottom,\n                ) = value_options\n            except (ValueError, TypeError) as exc:\n                raise OverlayError(f\"top_options is invalid: {value_options!r}\").with_traceback(\n                    exc.__traceback__\n                ) from exc\n            # normalize first, this is where errors are raised\n            align_type, align_amount = normalize_align(simplify_align(align_type, align_amount), OverlayError)\n            width_type, width_amount = normalize_width(simplify_width(width_type, width_amount), OverlayError)\n            valign_type, valign_amoun = normalize_valign(simplify_valign(valign_type, valign_amount), OverlayError)\n            height_type, height_amount = normalize_height(simplify_height(height_type, height_amount), OverlayError)\n            self.align_type = align_type\n            self.align_amount = align_amount\n            self.width_type = width_type\n            self.width_amount = width_amount\n            self.valign_type = valign_type\n            self.valign_amount = valign_amount\n            self.height_type = height_type\n            self.height_amount = height_amount\n            self.left = left\n            self.right = right\n            self.top = top\n            self.bottom = bottom\n            self.min_width = min_width\n            self.min_height = min_height\n        else:\n            raise IndexError(f\"Overlay.contents has no position {index!r}\")\n        self._invalidate()",
  "def get_cursor_coords(self, size: tuple[int, int]) -> tuple[int, int] | None:\n        \"\"\"Return cursor coords from top_w, if any.\"\"\"\n        if not hasattr(self.top_w, \"get_cursor_coords\"):\n            return None\n        (maxcol, maxrow) = size\n        left, right, top, bottom = self.calculate_padding_filler(size, True)\n        x, y = self.top_w.get_cursor_coords((maxcol - left - right, maxrow - top - bottom))\n        if y >= maxrow:  # required??\n            y = maxrow - 1\n        return x + left, y + top",
  "def calculate_padding_filler(self, size: tuple[int, int], focus: bool) -> tuple[int, int, int, int]:\n        \"\"\"Return (padding left, right, filler top, bottom).\"\"\"\n        (maxcol, maxrow) = size\n        height = None\n        if self.width_type == WHSettings.PACK:\n            width, height = self.top_w.pack((), focus=focus)\n            if not height:\n                raise OverlayError(\"fixed widget must have a height\")\n            left, right = calculate_left_right_padding(\n                maxcol,\n                self.align_type,\n                self.align_amount,\n                WrapMode.CLIP,\n                width,\n                None,\n                self.left,\n                self.right,\n            )\n        else:\n            left, right = calculate_left_right_padding(\n                maxcol,\n                self.align_type,\n                self.align_amount,\n                self.width_type,\n                self.width_amount,\n                self.min_width,\n                self.left,\n                self.right,\n            )\n\n        if height:\n            # top_w is a fixed widget\n            top, bottom = calculate_top_bottom_filler(\n                maxrow,\n                self.valign_type,\n                self.valign_amount,\n                WHSettings.GIVEN,\n                height,\n                None,\n                self.top,\n                self.bottom,\n            )\n            if maxrow - top - bottom < height:\n                bottom = maxrow - top - height\n        elif self.height_type == WHSettings.PACK:\n            # top_w is a flow widget\n            height = self.top_w.rows((maxcol,), focus=focus)\n            top, bottom = calculate_top_bottom_filler(\n                maxrow,\n                self.valign_type,\n                self.valign_amount,\n                WHSettings.GIVEN,\n                height,\n                None,\n                self.top,\n                self.bottom,\n            )\n            if height > maxrow:  # flow widget rendered too large\n                bottom = maxrow - height\n        else:\n            top, bottom = calculate_top_bottom_filler(\n                maxrow,\n                self.valign_type,\n                self.valign_amount,\n                self.height_type,\n                self.height_amount,\n                self.min_height,\n                self.top,\n                self.bottom,\n            )\n        return left, right, top, bottom",
  "def top_w_size(self, size, left, right, top, bottom):\n        \"\"\"Return the size to pass to top_w.\"\"\"\n        if self.width_type == WHSettings.PACK:\n            # top_w is a fixed widget\n            return ()\n        maxcol, maxrow = size\n        if self.width_type != WHSettings.PACK and self.height_type == WHSettings.PACK:\n            # top_w is a flow widget\n            return (maxcol - left - right,)\n        return (maxcol - left - right, maxrow - top - bottom)",
  "def render(self, size: tuple[int, int], focus: bool = False) -> CompositeCanvas:\n        \"\"\"Render top_w overlayed on bottom_w.\"\"\"\n        left, right, top, bottom = self.calculate_padding_filler(size, focus)\n        bottom_c = self.bottom_w.render(size)\n        if not bottom_c.cols() or not bottom_c.rows():\n            return CompositeCanvas(bottom_c)\n\n        top_c = self.top_w.render(self.top_w_size(size, left, right, top, bottom), focus)\n        top_c = CompositeCanvas(top_c)\n        if left < 0 or right < 0:\n            top_c.pad_trim_left_right(min(0, left), min(0, right))\n        if top < 0 or bottom < 0:\n            top_c.pad_trim_top_bottom(min(0, top), min(0, bottom))\n\n        return CanvasOverlay(top_c, bottom_c, left, top)",
  "def mouse_event(self, size: tuple[int, int], event, button: int, col: int, row: int, focus: bool) -> bool | None:\n        \"\"\"Pass event to top_w, ignore if outside of top_w.\"\"\"\n        if not hasattr(self.top_w, \"mouse_event\"):\n            return False\n\n        left, right, top, bottom = self.calculate_padding_filler(size, focus)\n        maxcol, maxrow = size\n        if col < left or col >= maxcol - right or row < top or row >= maxrow - bottom:\n            return False\n\n        return self.top_w.mouse_event(\n            self.top_w_size(size, left, right, top, bottom), event, button, col - left, row - top, focus\n        )",
  "class OverlayContents:\n            def __len__(inner_self):\n                return 2\n\n            __getitem__ = self._contents__getitem__\n            __setitem__ = self._contents__setitem__",
  "def __len__(inner_self):\n                return 2",
  "class SolidFill(Widget):\n    \"\"\"\n    A box widget that fills an area with a single character\n    \"\"\"\n\n    _selectable = False\n    ignore_focus = True\n    _sizing = frozenset([Sizing.BOX])\n\n    def __init__(self, fill_char: str = \" \") -> None:\n        \"\"\"\n        :param fill_char: character to fill area with\n        :type fill_char: bytes or unicode\n\n        >>> SolidFill(u'8')\n        <SolidFill box widget '8'>\n        \"\"\"\n        super().__init__()\n        self.fill_char = fill_char\n\n    def _repr_words(self) -> list[str]:\n        return [*super()._repr_words(), repr(self.fill_char)]\n\n    def render(self, size: tuple[int, int], focus: bool = False) -> SolidCanvas:\n        \"\"\"\n        Render the Fill as a canvas and return it.\n\n        >>> SolidFill().render((4,2)).text # ... = b in Python 3\n        [...'    ', ...'    ']\n        >>> SolidFill('#').render((5,3)).text\n        [...'#####', ...'#####', ...'#####']\n        \"\"\"\n        maxcol, maxrow = size\n        return SolidCanvas(self.fill_char, maxcol, maxrow)",
  "def __init__(self, fill_char: str = \" \") -> None:\n        \"\"\"\n        :param fill_char: character to fill area with\n        :type fill_char: bytes or unicode\n\n        >>> SolidFill(u'8')\n        <SolidFill box widget '8'>\n        \"\"\"\n        super().__init__()\n        self.fill_char = fill_char",
  "def _repr_words(self) -> list[str]:\n        return [*super()._repr_words(), repr(self.fill_char)]",
  "def render(self, size: tuple[int, int], focus: bool = False) -> SolidCanvas:\n        \"\"\"\n        Render the Fill as a canvas and return it.\n\n        >>> SolidFill().render((4,2)).text # ... = b in Python 3\n        [...'    ', ...'    ']\n        >>> SolidFill('#').render((5,3)).text\n        [...'#####', ...'#####', ...'#####']\n        \"\"\"\n        maxcol, maxrow = size\n        return SolidCanvas(self.fill_char, maxcol, maxrow)",
  "class WidgetDecoration(Widget):  # \"decorator\" was already taken\n    \"\"\"\n    original_widget -- the widget being decorated\n\n    This is a base class for decoration widgets, widgets\n    that contain one or more widgets and only ever have\n    a single focus.  This type of widget will affect the\n    display or behaviour of the original_widget but it is\n    not part of determining a chain of focus.\n\n    Don't actually do this -- use a WidgetDecoration subclass\n    instead, these are not real widgets:\n\n    >>> from urwid import Text\n    >>> WidgetDecoration(Text(u\"hi\"))\n    <WidgetDecoration flow widget <Text flow widget 'hi'>>\n    \"\"\"\n\n    def __init__(self, original_widget: Widget) -> None:\n        self._original_widget = original_widget\n\n    def _repr_words(self):\n        return [*super()._repr_words(), repr(self._original_widget)]\n\n    @property\n    def original_widget(self) -> Widget:\n        return self._original_widget\n\n    @original_widget.setter\n    def original_widget(self, original_widget: Widget) -> None:\n        self._original_widget = original_widget\n        self._invalidate()\n\n    def _get_original_widget(self) -> Widget:\n        warnings.warn(\n            f\"Method `{self.__class__.__name__}._get_original_widget` is deprecated, \"\n            f\"please use property `{self.__class__.__name__}.original_widget`\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        return self.original_widget\n\n    def _set_original_widget(self, original_widget):\n        warnings.warn(\n            f\"Method `{self.__class__.__name__}._set_original_widget` is deprecated, \"\n            f\"please use property `{self.__class__.__name__}.original_widget`\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        self.original_widget = original_widget\n\n    @property\n    def base_widget(self) -> Widget:\n        \"\"\"\n        Return the widget without decorations.  If there is only one\n        Decoration then this is the same as original_widget.\n\n        >>> from urwid import Text\n        >>> t = Text('hello')\n        >>> wd1 = WidgetDecoration(t)\n        >>> wd2 = WidgetDecoration(wd1)\n        >>> wd3 = WidgetDecoration(wd2)\n        >>> wd3.original_widget is wd2\n        True\n        >>> wd3.base_widget is t\n        True\n        \"\"\"\n        w = self\n        while hasattr(w, \"_original_widget\"):\n            w = w._original_widget\n        return w\n\n    def _get_base_widget(self):\n        warnings.warn(\n            f\"Method `{self.__class__.__name__}._get_base_widget` is deprecated, \"\n            f\"please use property `{self.__class__.__name__}.base_widget`\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        return self.base_widget\n\n    def selectable(self) -> bool:\n        return self._original_widget.selectable()\n\n    def sizing(self):\n        return self._original_widget.sizing()",
  "class WidgetPlaceholder(delegate_to_widget_mixin(\"_original_widget\"), WidgetDecoration):\n    \"\"\"\n    This is a do-nothing decoration widget that can be used for swapping\n    between widgets without modifying the container of this widget.\n\n    This can be useful for making an interface with a number of distinct\n    pages or for showing and hiding menu or status bars.\n\n    The widget displayed is stored as the self.original_widget property and\n    can be changed by assigning a new widget to it.\n    \"\"\"\n\n    pass",
  "class WidgetDisable(WidgetDecoration):\n    \"\"\"\n    A decoration widget that disables interaction with the widget it\n    wraps.  This widget always passes focus=False to the wrapped widget,\n    even if it somehow does become the focus.\n    \"\"\"\n\n    no_cache: typing.ClassVar[list[str]] = [\"rows\"]\n    ignore_focus = True\n\n    def selectable(self) -> Literal[False]:\n        return False\n\n    def rows(self, size, focus: bool = False) -> int:\n        return self._original_widget.rows(size, False)\n\n    def sizing(self):\n        return self._original_widget.sizing()\n\n    def pack(self, size, focus: bool = False) -> tuple[int, int]:\n        return self._original_widget.pack(size, False)\n\n    def render(self, size, focus: bool = False) -> CompositeCanvas:\n        canv = self._original_widget.render(size, False)\n        return CompositeCanvas(canv)",
  "def __init__(self, original_widget: Widget) -> None:\n        self._original_widget = original_widget",
  "def _repr_words(self):\n        return [*super()._repr_words(), repr(self._original_widget)]",
  "def original_widget(self) -> Widget:\n        return self._original_widget",
  "def original_widget(self, original_widget: Widget) -> None:\n        self._original_widget = original_widget\n        self._invalidate()",
  "def _get_original_widget(self) -> Widget:\n        warnings.warn(\n            f\"Method `{self.__class__.__name__}._get_original_widget` is deprecated, \"\n            f\"please use property `{self.__class__.__name__}.original_widget`\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        return self.original_widget",
  "def _set_original_widget(self, original_widget):\n        warnings.warn(\n            f\"Method `{self.__class__.__name__}._set_original_widget` is deprecated, \"\n            f\"please use property `{self.__class__.__name__}.original_widget`\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        self.original_widget = original_widget",
  "def base_widget(self) -> Widget:\n        \"\"\"\n        Return the widget without decorations.  If there is only one\n        Decoration then this is the same as original_widget.\n\n        >>> from urwid import Text\n        >>> t = Text('hello')\n        >>> wd1 = WidgetDecoration(t)\n        >>> wd2 = WidgetDecoration(wd1)\n        >>> wd3 = WidgetDecoration(wd2)\n        >>> wd3.original_widget is wd2\n        True\n        >>> wd3.base_widget is t\n        True\n        \"\"\"\n        w = self\n        while hasattr(w, \"_original_widget\"):\n            w = w._original_widget\n        return w",
  "def _get_base_widget(self):\n        warnings.warn(\n            f\"Method `{self.__class__.__name__}._get_base_widget` is deprecated, \"\n            f\"please use property `{self.__class__.__name__}.base_widget`\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        return self.base_widget",
  "def selectable(self) -> bool:\n        return self._original_widget.selectable()",
  "def sizing(self):\n        return self._original_widget.sizing()",
  "def selectable(self) -> Literal[False]:\n        return False",
  "def rows(self, size, focus: bool = False) -> int:\n        return self._original_widget.rows(size, False)",
  "def sizing(self):\n        return self._original_widget.sizing()",
  "def pack(self, size, focus: bool = False) -> tuple[int, int]:\n        return self._original_widget.pack(size, False)",
  "def render(self, size, focus: bool = False) -> CompositeCanvas:\n        canv = self._original_widget.render(size, False)\n        return CompositeCanvas(canv)",
  "class WidgetContainerMixin:\n    \"\"\"\n    Mixin class for widget containers implementing common container methods\n    \"\"\"\n\n    def __getitem__(self, position) -> Widget:\n        \"\"\"\n        Container short-cut for self.contents[position][0].base_widget\n        which means \"give me the child widget at position without any\n        widget decorations\".\n\n        This allows for concise traversal of nested container widgets\n        such as:\n\n            my_widget[position0][position1][position2] ...\n        \"\"\"\n        return self.contents[position][0].base_widget\n\n    def get_focus_path(self):\n        \"\"\"\n        Return the .focus_position values starting from this container\n        and proceeding along each child widget until reaching a leaf\n        (non-container) widget.\n        \"\"\"\n        out = []\n        w = self\n        while True:\n            try:\n                p = w.focus_position\n            except IndexError:\n                return out\n            out.append(p)\n            w = w.focus.base_widget\n\n    def set_focus_path(self, positions):\n        \"\"\"\n        Set the .focus_position property starting from this container\n        widget and proceeding along newly focused child widgets.  Any\n        failed assignment due do incompatible position types or invalid\n        positions will raise an IndexError.\n\n        This method may be used to restore a particular widget to the\n        focus by passing in the value returned from an earlier call to\n        get_focus_path().\n\n        positions -- sequence of positions\n        \"\"\"\n        w = self\n        for p in positions:\n            if p != w.focus_position:\n                w.focus_position = p  # modifies w.focus\n            w = w.focus.base_widget\n\n    def get_focus_widgets(self) -> list[Widget]:\n        \"\"\"\n        Return the .focus values starting from this container\n        and proceeding along each child widget until reaching a leaf\n        (non-container) widget.\n\n        Note that the list does not contain the topmost container widget\n        (i.e., on which this method is called), but does include the\n        lowest leaf widget.\n        \"\"\"\n        out = []\n        w = self\n        while True:\n            w = w.base_widget.focus\n            if w is None:\n                return out\n            out.append(w)\n\n    @property\n    @abc.abstractmethod\n    def focus(self) -> Widget:\n        \"\"\"\n        Read-only property returning the child widget in focus for\n        container widgets.  This default implementation\n        always returns ``None``, indicating that this widget has no children.\n        \"\"\"\n\n    def _get_focus(self) -> Widget:\n        warnings.warn(\n            f\"method `{self.__class__.__name__}._get_focus` is deprecated, \"\n            f\"please use `{self.__class__.__name__}.focus` property\",\n            DeprecationWarning,\n            stacklevel=3,\n        )\n        return self.focus",
  "class WidgetContainerListContentsMixin:\n    \"\"\"\n    Mixin class for widget containers whose positions are indexes into\n    a list available as self.contents.\n    \"\"\"\n\n    def __iter__(self) -> Iterator[int]:\n        \"\"\"\n        Return an iterable of positions for this container from first\n        to last.\n        \"\"\"\n        return iter(range(len(self.contents)))\n\n    def __reversed__(self) -> Iterator[int]:\n        \"\"\"\n        Return an iterable of positions for this container from last\n        to first.\n        \"\"\"\n        return iter(range(len(self.contents) - 1, -1, -1))\n\n    def __len__(self) -> int:\n        return len(self.contents)\n\n    @property\n    @abc.abstractmethod\n    def contents(self) -> list[tuple[Widget, typing.Any]]:\n        \"\"\"The contents of container as a list of (widget, options)\"\"\"\n\n    @contents.setter\n    def contents(self, new_contents: list[tuple[Widget, typing.Any]]) -> None:\n        \"\"\"The contents of container as a list of (widget, options)\"\"\"\n\n    def _get_contents(self) -> list[tuple[Widget, typing.Any]]:\n        warnings.warn(\n            f\"method `{self.__class__.__name__}._get_contents` is deprecated, \"\n            f\"please use `{self.__class__.__name__}.contents` property\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        return self.contents\n\n    def _set_contents(self, c: list[tuple[Widget, typing.Any]]) -> None:\n        warnings.warn(\n            f\"method `{self.__class__.__name__}._set_contents` is deprecated, \"\n            f\"please use `{self.__class__.__name__}.contents` property\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        self.contents = c\n\n    @property\n    @abc.abstractmethod\n    def focus_position(self) -> int | None:\n        \"\"\"\n        index of child widget in focus.\n        \"\"\"\n\n    @focus_position.setter\n    def focus_position(self, position: int) -> None:\n        \"\"\"\n        index of child widget in focus.\n        \"\"\"\n\n    def _get_focus_position(self) -> int | None:\n        warnings.warn(\n            f\"method `{self.__class__.__name__}._get_focus_position` is deprecated, \"\n            f\"please use `{self.__class__.__name__}.focus_position` property\",\n            DeprecationWarning,\n            stacklevel=3,\n        )\n        return self.focus_position\n\n    def _set_focus_position(self, position: int) -> None:\n        \"\"\"\n        Set the widget in focus.\n\n        position -- index of child widget to be made focus\n        \"\"\"\n        warnings.warn(\n            f\"method `{self.__class__.__name__}._set_focus_position` is deprecated, \"\n            f\"please use `{self.__class__.__name__}.focus_position` property\",\n            DeprecationWarning,\n            stacklevel=3,\n        )\n        self.focus_position = position",
  "def __getitem__(self, position) -> Widget:\n        \"\"\"\n        Container short-cut for self.contents[position][0].base_widget\n        which means \"give me the child widget at position without any\n        widget decorations\".\n\n        This allows for concise traversal of nested container widgets\n        such as:\n\n            my_widget[position0][position1][position2] ...\n        \"\"\"\n        return self.contents[position][0].base_widget",
  "def get_focus_path(self):\n        \"\"\"\n        Return the .focus_position values starting from this container\n        and proceeding along each child widget until reaching a leaf\n        (non-container) widget.\n        \"\"\"\n        out = []\n        w = self\n        while True:\n            try:\n                p = w.focus_position\n            except IndexError:\n                return out\n            out.append(p)\n            w = w.focus.base_widget",
  "def set_focus_path(self, positions):\n        \"\"\"\n        Set the .focus_position property starting from this container\n        widget and proceeding along newly focused child widgets.  Any\n        failed assignment due do incompatible position types or invalid\n        positions will raise an IndexError.\n\n        This method may be used to restore a particular widget to the\n        focus by passing in the value returned from an earlier call to\n        get_focus_path().\n\n        positions -- sequence of positions\n        \"\"\"\n        w = self\n        for p in positions:\n            if p != w.focus_position:\n                w.focus_position = p  # modifies w.focus\n            w = w.focus.base_widget",
  "def get_focus_widgets(self) -> list[Widget]:\n        \"\"\"\n        Return the .focus values starting from this container\n        and proceeding along each child widget until reaching a leaf\n        (non-container) widget.\n\n        Note that the list does not contain the topmost container widget\n        (i.e., on which this method is called), but does include the\n        lowest leaf widget.\n        \"\"\"\n        out = []\n        w = self\n        while True:\n            w = w.base_widget.focus\n            if w is None:\n                return out\n            out.append(w)",
  "def focus(self) -> Widget:\n        \"\"\"\n        Read-only property returning the child widget in focus for\n        container widgets.  This default implementation\n        always returns ``None``, indicating that this widget has no children.\n        \"\"\"",
  "def _get_focus(self) -> Widget:\n        warnings.warn(\n            f\"method `{self.__class__.__name__}._get_focus` is deprecated, \"\n            f\"please use `{self.__class__.__name__}.focus` property\",\n            DeprecationWarning,\n            stacklevel=3,\n        )\n        return self.focus",
  "def __iter__(self) -> Iterator[int]:\n        \"\"\"\n        Return an iterable of positions for this container from first\n        to last.\n        \"\"\"\n        return iter(range(len(self.contents)))",
  "def __reversed__(self) -> Iterator[int]:\n        \"\"\"\n        Return an iterable of positions for this container from last\n        to first.\n        \"\"\"\n        return iter(range(len(self.contents) - 1, -1, -1))",
  "def __len__(self) -> int:\n        return len(self.contents)",
  "def contents(self) -> list[tuple[Widget, typing.Any]]:\n        \"\"\"The contents of container as a list of (widget, options)\"\"\"",
  "def contents(self, new_contents: list[tuple[Widget, typing.Any]]) -> None:\n        \"\"\"The contents of container as a list of (widget, options)\"\"\"",
  "def _get_contents(self) -> list[tuple[Widget, typing.Any]]:\n        warnings.warn(\n            f\"method `{self.__class__.__name__}._get_contents` is deprecated, \"\n            f\"please use `{self.__class__.__name__}.contents` property\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        return self.contents",
  "def _set_contents(self, c: list[tuple[Widget, typing.Any]]) -> None:\n        warnings.warn(\n            f\"method `{self.__class__.__name__}._set_contents` is deprecated, \"\n            f\"please use `{self.__class__.__name__}.contents` property\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        self.contents = c",
  "def focus_position(self) -> int | None:\n        \"\"\"\n        index of child widget in focus.\n        \"\"\"",
  "def focus_position(self, position: int) -> None:\n        \"\"\"\n        index of child widget in focus.\n        \"\"\"",
  "def _get_focus_position(self) -> int | None:\n        warnings.warn(\n            f\"method `{self.__class__.__name__}._get_focus_position` is deprecated, \"\n            f\"please use `{self.__class__.__name__}.focus_position` property\",\n            DeprecationWarning,\n            stacklevel=3,\n        )\n        return self.focus_position",
  "def _set_focus_position(self, position: int) -> None:\n        \"\"\"\n        Set the widget in focus.\n\n        position -- index of child widget to be made focus\n        \"\"\"\n        warnings.warn(\n            f\"method `{self.__class__.__name__}._set_focus_position` is deprecated, \"\n            f\"please use `{self.__class__.__name__}.focus_position` property\",\n            DeprecationWarning,\n            stacklevel=3,\n        )\n        self.focus_position = position",
  "class BigText(Widget):\n    _sizing = frozenset([Sizing.FIXED])\n\n    def __init__(self, markup, font: Font) -> None:\n        \"\"\"\n        markup -- same as Text widget markup\n        font -- instance of a Font class\n        \"\"\"\n        self.set_font(font)\n        self.set_text(markup)\n\n    def set_text(self, markup):\n        self.text, self.attrib = decompose_tagmarkup(markup)\n        self._invalidate()\n\n    def get_text(self):\n        \"\"\"\n        Returns (text, attributes).\n        \"\"\"\n        return self.text, self.attrib\n\n    def set_font(self, font: Font) -> None:\n        self.font = font\n        self._invalidate()\n\n    def pack(self, size: tuple[()] | None = None, focus: bool = False) -> tuple[int, int]:\n        rows = self.font.height\n        cols = 0\n        for c in self.text:\n            cols += self.font.char_width(c)\n        return cols, rows\n\n    def render(self, size: tuple[()], focus: bool = False) -> CanvasJoin | CompositeCanvas:\n        fixed_size(size)  # complain if parameter is wrong\n        a = None\n        ai = ak = 0\n        o = []\n        rows = self.font.height\n        attrib = [*self.attrib, (None, len(self.text))]\n        for ch in self.text:\n            if not ak:\n                a, ak = attrib[ai]\n                ai += 1\n            ak -= 1\n            width = self.font.char_width(ch)\n            if not width:\n                # ignore invalid characters\n                continue\n            c = self.font.render(ch)\n            if a is not None:\n                c = CompositeCanvas(c)\n                c.fill_attr(a)\n            o.append((c, None, False, width))\n        if o:\n            canv = CanvasJoin(o)\n        else:\n            canv = CompositeCanvas(TextCanvas([\"\"] * rows, maxcol=0, check_width=False))\n        canv.set_depends([])\n        return canv",
  "def __init__(self, markup, font: Font) -> None:\n        \"\"\"\n        markup -- same as Text widget markup\n        font -- instance of a Font class\n        \"\"\"\n        self.set_font(font)\n        self.set_text(markup)",
  "def set_text(self, markup):\n        self.text, self.attrib = decompose_tagmarkup(markup)\n        self._invalidate()",
  "def get_text(self):\n        \"\"\"\n        Returns (text, attributes).\n        \"\"\"\n        return self.text, self.attrib",
  "def set_font(self, font: Font) -> None:\n        self.font = font\n        self._invalidate()",
  "def pack(self, size: tuple[()] | None = None, focus: bool = False) -> tuple[int, int]:\n        rows = self.font.height\n        cols = 0\n        for c in self.text:\n            cols += self.font.char_width(c)\n        return cols, rows",
  "def render(self, size: tuple[()], focus: bool = False) -> CanvasJoin | CompositeCanvas:\n        fixed_size(size)  # complain if parameter is wrong\n        a = None\n        ai = ak = 0\n        o = []\n        rows = self.font.height\n        attrib = [*self.attrib, (None, len(self.text))]\n        for ch in self.text:\n            if not ak:\n                a, ak = attrib[ai]\n                ai += 1\n            ak -= 1\n            width = self.font.char_width(ch)\n            if not width:\n                # ignore invalid characters\n                continue\n            c = self.font.render(ch)\n            if a is not None:\n                c = CompositeCanvas(c)\n                c.fill_attr(a)\n            o.append((c, None, False, width))\n        if o:\n            canv = CanvasJoin(o)\n        else:\n            canv = CompositeCanvas(TextCanvas([\"\"] * rows, maxcol=0, check_width=False))\n        canv.set_depends([])\n        return canv",
  "class PaddingError(Exception):\n    pass",
  "class Padding(WidgetDecoration):\n    def __init__(\n        self,\n        w: Widget,\n        align: (\n            Literal[\"left\", \"center\", \"right\"] | Align | tuple[Literal[\"relative\", WHSettings.RELATIVE], int]\n        ) = Align.LEFT,\n        width: (\n            int\n            | Literal[\"pack\", \"clip\", WHSettings.PACK, WHSettings.CLIP]\n            | tuple[Literal[\"relative\", WHSettings.RELATIVE], int]\n        ) = RELATIVE_100,\n        min_width: int | None = None,\n        left: int = 0,\n        right: int = 0,\n    ):\n        \"\"\"\n        :param w: a box, flow or fixed widget to pad on the left and/or right\n            this widget is stored as self.original_widget\n        :type w: Widget\n\n        :param align: one of: ``'left'``, ``'center'``, ``'right'``\n            (``'relative'``, *percentage* 0=left 100=right)\n\n        :param width: one of:\n\n            *given width*\n              integer number of columns for self.original_widget\n\n            ``'pack'``\n              try to pack self.original_widget to its ideal size\n\n            (``'relative'``, *percentage of total width*)\n              make width depend on the container's width\n\n            ``'clip'``\n              to enable clipping mode for a fixed widget\n\n        :param min_width: the minimum number of columns for\n            self.original_widget or ``None``\n        :type min_width: int\n\n        :param left: a fixed number of columns to pad on the left\n        :type left: int\n\n        :param right: a fixed number of columns to pad on the right\n        :type right: int\n\n        Clipping Mode: (width= ``'clip'``)\n        In clipping mode this padding widget will behave as a flow\n        widget and self.original_widget will be treated as a fixed\n        widget.  self.original_widget will will be clipped to fit\n        the available number of columns.  For example if align is\n        ``'left'`` then self.original_widget may be clipped on the right.\n\n        >>> from urwid import Divider, Text\n        >>> size = (7,)\n        >>> def pr(w):\n        ...     for t in w.render(size).text:\n        ...         print(f\"|{t.decode('ascii')}|\" )\n        >>> pr(Padding(Text(u\"Head\"), ('relative', 20), 'pack'))\n        | Head  |\n        >>> pr(Padding(Divider(u\"-\"), left=2, right=1))\n        |  ---- |\n        >>> pr(Padding(Divider(u\"*\"), 'center', 3))\n        |  ***  |\n        >>> p=Padding(Text(u\"1234\"), 'left', 2, None, 1, 1)\n        >>> p\n        <Padding flow widget <Text flow widget '1234'> left=1 right=1 width=2>\n        >>> pr(p)   # align against left\n        | 12    |\n        | 34    |\n        >>> p.align = 'right'\n        >>> pr(p)   # align against right\n        |    12 |\n        |    34 |\n        >>> pr(Padding(Text(u\"hi\\\\nthere\"), 'right', 'pack')) # pack text first\n        |  hi   |\n        |  there|\n        \"\"\"\n        super().__init__(w)\n\n        # convert obsolete parameters 'fixed left' and 'fixed right':\n        if isinstance(align, tuple) and align[0] in (\"fixed left\", \"fixed right\"):\n            if align[0] == \"fixed left\":\n                left = align[1]\n                align = Align.LEFT\n            else:\n                right = align[1]\n                align = Align.RIGHT\n        if isinstance(width, tuple) and width[0] in (\"fixed left\", \"fixed right\"):\n            if width[0] == \"fixed left\":\n                left = width[1]\n            else:\n                right = width[1]\n            width = RELATIVE_100\n\n        # convert old clipping mode width=None to width='clip'\n        if width is None:\n            width = WrapMode.CLIP\n\n        self.left = left\n        self.right = right\n        self._align_type, self._align_amount = normalize_align(align, PaddingError)\n        self._width_type, self._width_amount = normalize_width(width, PaddingError)\n        self.min_width = min_width\n\n    def sizing(self):\n        if self._width_type == WrapMode.CLIP:\n            return {Sizing.FLOW}\n        return self.original_widget.sizing()\n\n    def _repr_attrs(self):\n        attrs = dict(\n            super()._repr_attrs(),\n            align=self.align,\n            width=self.width,\n            left=self.left,\n            right=self.right,\n            min_width=self.min_width,\n        )\n        return remove_defaults(attrs, Padding.__init__)\n\n    @property\n    def align(self) -> Literal[\"left\", \"center\", \"right\"] | tuple[Literal[\"relative\"], int]:\n        \"\"\"\n        Return the padding alignment setting.\n        \"\"\"\n        return simplify_align(self._align_type, self._align_amount)\n\n    @align.setter\n    def align(self, align: Literal[\"left\", \"center\", \"right\"] | tuple[Literal[\"relative\"], int]) -> None:\n        \"\"\"\n        Set the padding alignment.\n        \"\"\"\n        self._align_type, self._align_amount = normalize_align(align, PaddingError)\n        self._invalidate()\n\n    def _get_align(self) -> Literal[\"left\", \"center\", \"right\"] | tuple[Literal[\"relative\"], int]:\n        warnings.warn(\n            f\"Method `{self.__class__.__name__}._get_align` is deprecated, \"\n            f\"please use property `{self.__class__.__name__}.align`\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        return self.align\n\n    def _set_align(self, align: Literal[\"left\", \"center\", \"right\"] | tuple[Literal[\"relative\"], int]) -> None:\n        warnings.warn(\n            f\"Method `{self.__class__.__name__}._set_align` is deprecated, \"\n            f\"please use property `{self.__class__.__name__}.align`\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        self.align = align\n\n    @property\n    def width(self) -> Literal[\"clip\", \"pack\"] | int | tuple[Literal[\"relative\"], int]:\n        \"\"\"\n        Return the padding width.\n        \"\"\"\n        return simplify_width(self._width_type, self._width_amount)\n\n    @width.setter\n    def width(self, width: Literal[\"clip\", \"pack\"] | int | tuple[Literal[\"relative\"], int]) -> None:\n        \"\"\"\n        Set the padding width.\n        \"\"\"\n        self._width_type, self._width_amount = normalize_width(width, PaddingError)\n        self._invalidate()\n\n    def _get_width(self) -> Literal[\"clip\", \"pack\"] | int | tuple[Literal[\"relative\"], int]:\n        warnings.warn(\n            f\"Method `{self.__class__.__name__}._get_width` is deprecated, \"\n            f\"please use property `{self.__class__.__name__}.width`\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        return self.width\n\n    def _set_width(self, width: Literal[\"clip\", \"pack\"] | int | tuple[Literal[\"relative\"], int]) -> None:\n        warnings.warn(\n            f\"Method `{self.__class__.__name__}._set_width` is deprecated, \"\n            f\"please use property `{self.__class__.__name__}.width`\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        self.width = width\n\n    def render(\n        self,\n        size: tuple[int] | tuple[int, int],\n        focus: bool = False,\n    ) -> CompositeCanvas:\n        left, right = self.padding_values(size, focus)\n\n        maxcol = size[0]\n        maxcol -= left + right\n\n        if self._width_type == WrapMode.CLIP:\n            canv = self._original_widget.render((), focus)\n        else:\n            canv = self._original_widget.render((maxcol,) + size[1:], focus)\n        if canv.cols() == 0:\n            canv = SolidCanvas(\" \", size[0], canv.rows())\n            canv = CompositeCanvas(canv)\n            canv.set_depends([self._original_widget])\n            return canv\n        canv = CompositeCanvas(canv)\n        canv.set_depends([self._original_widget])\n        if left != 0 or right != 0:\n            canv.pad_trim_left_right(left, right)\n\n        return canv\n\n    def padding_values(self, size: tuple[int] | tuple[int, int], focus: bool) -> tuple[int, int]:\n        \"\"\"Return the number of columns to pad on the left and right.\n\n        Override this method to define custom padding behaviour.\"\"\"\n        maxcol = size[0]\n        if self._width_type == WrapMode.CLIP:\n            width, ignore = self._original_widget.pack((), focus=focus)\n            return calculate_left_right_padding(\n                maxcol,\n                self._align_type,\n                self._align_amount,\n                WrapMode.CLIP,\n                width,\n                None,\n                self.left,\n                self.right,\n            )\n        if self._width_type == WHSettings.PACK:\n            maxwidth = max(maxcol - self.left - self.right, self.min_width or 0)\n            (width, ignore) = self._original_widget.pack((maxwidth,), focus=focus)\n            return calculate_left_right_padding(\n                maxcol,\n                self._align_type,\n                self._align_amount,\n                WHSettings.GIVEN,\n                width,\n                self.min_width,\n                self.left,\n                self.right,\n            )\n        return calculate_left_right_padding(\n            maxcol,\n            self._align_type,\n            self._align_amount,\n            self._width_type,\n            self._width_amount,\n            self.min_width,\n            self.left,\n            self.right,\n        )\n\n    def rows(self, size, focus=False):\n        \"\"\"Return the rows needed for self.original_widget.\"\"\"\n        (maxcol,) = size\n        left, right = self.padding_values(size, focus)\n        if self._width_type == WHSettings.PACK:\n            pcols, prows = self._original_widget.pack((maxcol - left - right,), focus)\n            return prows\n        if self._width_type == WrapMode.CLIP:\n            fcols, frows = self._original_widget.pack((), focus)\n            return frows\n        return self._original_widget.rows((maxcol - left - right,), focus=focus)\n\n    def keypress(self, size: tuple[int] | tuple[int, int], key: str) -> str | None:\n        \"\"\"Pass keypress to self._original_widget.\"\"\"\n        maxcol = size[0]\n        left, right = self.padding_values(size, True)\n        maxvals = (maxcol - left - right,) + size[1:]\n        return self._original_widget.keypress(maxvals, key)\n\n    def get_cursor_coords(self, size: tuple[int] | tuple[int, int]) -> tuple[int, int] | None:\n        \"\"\"Return the (x,y) coordinates of cursor within self._original_widget.\"\"\"\n        if not hasattr(self._original_widget, \"get_cursor_coords\"):\n            return None\n        left, right = self.padding_values(size, True)\n        maxcol = size[0]\n        maxvals = (maxcol - left - right,) + size[1:]\n        if maxvals[0] == 0:\n            return None\n        coords = self._original_widget.get_cursor_coords(maxvals)\n        if coords is None:\n            return None\n        x, y = coords\n        return x + left, y\n\n    def move_cursor_to_coords(\n        self,\n        size: tuple[int] | tuple[int, int],\n        x: int,\n        y: int,\n    ) -> bool:\n        \"\"\"Set the cursor position with (x,y) coordinates of self._original_widget.\n\n        Returns True if move succeeded, False otherwise.\n        \"\"\"\n        if not hasattr(self._original_widget, \"move_cursor_to_coords\"):\n            return True\n        left, right = self.padding_values(size, True)\n        maxcol = size[0]\n        maxvals = (maxcol - left - right,) + size[1:]\n        if isinstance(x, int):\n            if x < left:\n                x = left\n            elif x >= maxcol - right:\n                x = maxcol - right - 1\n            x -= left\n        return self._original_widget.move_cursor_to_coords(maxvals, x, y)\n\n    def mouse_event(\n        self,\n        size: tuple[int] | tuple[int, int],\n        event,\n        button: int,\n        x: int,\n        y: int,\n        focus: bool,\n    ):\n        \"\"\"Send mouse event if position is within self._original_widget.\"\"\"\n        if not hasattr(self._original_widget, \"mouse_event\"):\n            return False\n\n        left, right = self.padding_values(size, focus)\n        maxcol = size[0]\n        if x < left or x >= maxcol - right:\n            return False\n        maxvals = (maxcol - left - right,) + size[1:]\n        return self._original_widget.mouse_event(maxvals, event, button, x - left, y, focus)\n\n    def get_pref_col(self, size: tuple[int] | tuple[int, int]) -> int | None:\n        \"\"\"Return the preferred column from self._original_widget, or None.\"\"\"\n        if not hasattr(self._original_widget, \"get_pref_col\"):\n            return None\n\n        left, right = self.padding_values(size, True)\n        maxcol = size[0]\n        maxvals = (maxcol - left - right,) + size[1:]\n        x = self._original_widget.get_pref_col(maxvals)\n        if isinstance(x, int):\n            return x + left\n        return x",
  "def calculate_left_right_padding(\n    maxcol: int,\n    align_type: Literal[\"left\", \"center\", \"right\"] | Align,\n    align_amount: int,\n    width_type: Literal[\"fixed\", \"relative\", \"clip\"],\n    width_amount: int,\n    min_width: int | None,\n    left: int,\n    right: int,\n) -> tuple[int, int]:\n    \"\"\"\n    Return the amount of padding (or clipping) on the left and\n    right part of maxcol columns to satisfy the following:\n\n    align_type -- 'left', 'center', 'right', 'relative'\n    align_amount -- a percentage when align_type=='relative'\n    width_type -- 'fixed', 'relative', 'clip'\n    width_amount -- a percentage when width_type=='relative'\n        otherwise equal to the width of the widget\n    min_width -- a desired minimum width for the widget or None\n    left -- a fixed number of columns to pad on the left\n    right -- a fixed number of columns to pad on the right\n\n    >>> clrp = calculate_left_right_padding\n    >>> clrp(15, 'left', 0, 'given', 10, None, 2, 0)\n    (2, 3)\n    >>> clrp(15, 'relative', 0, 'given', 10, None, 2, 0)\n    (2, 3)\n    >>> clrp(15, 'relative', 100, 'given', 10, None, 2, 0)\n    (5, 0)\n    >>> clrp(15, 'center', 0, 'given', 4, None, 2, 0)\n    (6, 5)\n    >>> clrp(15, 'left', 0, 'clip', 18, None, 0, 0)\n    (0, -3)\n    >>> clrp(15, 'right', 0, 'clip', 18, None, 0, -1)\n    (-2, -1)\n    >>> clrp(15, 'center', 0, 'given', 18, None, 2, 0)\n    (0, 0)\n    >>> clrp(20, 'left', 0, 'relative', 60, None, 0, 0)\n    (0, 8)\n    >>> clrp(20, 'relative', 30, 'relative', 60, None, 0, 0)\n    (2, 6)\n    >>> clrp(20, 'relative', 30, 'relative', 60, 14, 0, 0)\n    (2, 4)\n    \"\"\"\n    if width_type == WHSettings.RELATIVE:\n        maxwidth = max(maxcol - left - right, 0)\n        width = int_scale(width_amount, 101, maxwidth + 1)\n        if min_width is not None:\n            width = max(width, min_width)\n    else:\n        width = width_amount\n\n    standard_alignments = {Align.LEFT: 0, Align.CENTER: 50, Align.RIGHT: 100}\n    align = standard_alignments.get(align_type, align_amount)\n\n    # add the remainder of left/right the padding\n    padding = maxcol - width - left - right\n    right += int_scale(100 - align, 101, padding + 1)\n    left = maxcol - width - right\n\n    # reduce padding if we are clipping an edge\n    if right < 0 < left:\n        shift = min(left, -right)\n        left -= shift\n        right += shift\n    elif left < 0 < right:\n        shift = min(right, -left)\n        right -= shift\n        left += shift\n\n    # only clip if width_type == 'clip'\n    if width_type != WrapMode.CLIP and (left < 0 or right < 0):\n        left = max(left, 0)\n        right = max(right, 0)\n\n    return left, right",
  "def __init__(\n        self,\n        w: Widget,\n        align: (\n            Literal[\"left\", \"center\", \"right\"] | Align | tuple[Literal[\"relative\", WHSettings.RELATIVE], int]\n        ) = Align.LEFT,\n        width: (\n            int\n            | Literal[\"pack\", \"clip\", WHSettings.PACK, WHSettings.CLIP]\n            | tuple[Literal[\"relative\", WHSettings.RELATIVE], int]\n        ) = RELATIVE_100,\n        min_width: int | None = None,\n        left: int = 0,\n        right: int = 0,\n    ):\n        \"\"\"\n        :param w: a box, flow or fixed widget to pad on the left and/or right\n            this widget is stored as self.original_widget\n        :type w: Widget\n\n        :param align: one of: ``'left'``, ``'center'``, ``'right'``\n            (``'relative'``, *percentage* 0=left 100=right)\n\n        :param width: one of:\n\n            *given width*\n              integer number of columns for self.original_widget\n\n            ``'pack'``\n              try to pack self.original_widget to its ideal size\n\n            (``'relative'``, *percentage of total width*)\n              make width depend on the container's width\n\n            ``'clip'``\n              to enable clipping mode for a fixed widget\n\n        :param min_width: the minimum number of columns for\n            self.original_widget or ``None``\n        :type min_width: int\n\n        :param left: a fixed number of columns to pad on the left\n        :type left: int\n\n        :param right: a fixed number of columns to pad on the right\n        :type right: int\n\n        Clipping Mode: (width= ``'clip'``)\n        In clipping mode this padding widget will behave as a flow\n        widget and self.original_widget will be treated as a fixed\n        widget.  self.original_widget will will be clipped to fit\n        the available number of columns.  For example if align is\n        ``'left'`` then self.original_widget may be clipped on the right.\n\n        >>> from urwid import Divider, Text\n        >>> size = (7,)\n        >>> def pr(w):\n        ...     for t in w.render(size).text:\n        ...         print(f\"|{t.decode('ascii')}|\" )\n        >>> pr(Padding(Text(u\"Head\"), ('relative', 20), 'pack'))\n        | Head  |\n        >>> pr(Padding(Divider(u\"-\"), left=2, right=1))\n        |  ---- |\n        >>> pr(Padding(Divider(u\"*\"), 'center', 3))\n        |  ***  |\n        >>> p=Padding(Text(u\"1234\"), 'left', 2, None, 1, 1)\n        >>> p\n        <Padding flow widget <Text flow widget '1234'> left=1 right=1 width=2>\n        >>> pr(p)   # align against left\n        | 12    |\n        | 34    |\n        >>> p.align = 'right'\n        >>> pr(p)   # align against right\n        |    12 |\n        |    34 |\n        >>> pr(Padding(Text(u\"hi\\\\nthere\"), 'right', 'pack')) # pack text first\n        |  hi   |\n        |  there|\n        \"\"\"\n        super().__init__(w)\n\n        # convert obsolete parameters 'fixed left' and 'fixed right':\n        if isinstance(align, tuple) and align[0] in (\"fixed left\", \"fixed right\"):\n            if align[0] == \"fixed left\":\n                left = align[1]\n                align = Align.LEFT\n            else:\n                right = align[1]\n                align = Align.RIGHT\n        if isinstance(width, tuple) and width[0] in (\"fixed left\", \"fixed right\"):\n            if width[0] == \"fixed left\":\n                left = width[1]\n            else:\n                right = width[1]\n            width = RELATIVE_100\n\n        # convert old clipping mode width=None to width='clip'\n        if width is None:\n            width = WrapMode.CLIP\n\n        self.left = left\n        self.right = right\n        self._align_type, self._align_amount = normalize_align(align, PaddingError)\n        self._width_type, self._width_amount = normalize_width(width, PaddingError)\n        self.min_width = min_width",
  "def sizing(self):\n        if self._width_type == WrapMode.CLIP:\n            return {Sizing.FLOW}\n        return self.original_widget.sizing()",
  "def _repr_attrs(self):\n        attrs = dict(\n            super()._repr_attrs(),\n            align=self.align,\n            width=self.width,\n            left=self.left,\n            right=self.right,\n            min_width=self.min_width,\n        )\n        return remove_defaults(attrs, Padding.__init__)",
  "def align(self) -> Literal[\"left\", \"center\", \"right\"] | tuple[Literal[\"relative\"], int]:\n        \"\"\"\n        Return the padding alignment setting.\n        \"\"\"\n        return simplify_align(self._align_type, self._align_amount)",
  "def align(self, align: Literal[\"left\", \"center\", \"right\"] | tuple[Literal[\"relative\"], int]) -> None:\n        \"\"\"\n        Set the padding alignment.\n        \"\"\"\n        self._align_type, self._align_amount = normalize_align(align, PaddingError)\n        self._invalidate()",
  "def _get_align(self) -> Literal[\"left\", \"center\", \"right\"] | tuple[Literal[\"relative\"], int]:\n        warnings.warn(\n            f\"Method `{self.__class__.__name__}._get_align` is deprecated, \"\n            f\"please use property `{self.__class__.__name__}.align`\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        return self.align",
  "def _set_align(self, align: Literal[\"left\", \"center\", \"right\"] | tuple[Literal[\"relative\"], int]) -> None:\n        warnings.warn(\n            f\"Method `{self.__class__.__name__}._set_align` is deprecated, \"\n            f\"please use property `{self.__class__.__name__}.align`\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        self.align = align",
  "def width(self) -> Literal[\"clip\", \"pack\"] | int | tuple[Literal[\"relative\"], int]:\n        \"\"\"\n        Return the padding width.\n        \"\"\"\n        return simplify_width(self._width_type, self._width_amount)",
  "def width(self, width: Literal[\"clip\", \"pack\"] | int | tuple[Literal[\"relative\"], int]) -> None:\n        \"\"\"\n        Set the padding width.\n        \"\"\"\n        self._width_type, self._width_amount = normalize_width(width, PaddingError)\n        self._invalidate()",
  "def _get_width(self) -> Literal[\"clip\", \"pack\"] | int | tuple[Literal[\"relative\"], int]:\n        warnings.warn(\n            f\"Method `{self.__class__.__name__}._get_width` is deprecated, \"\n            f\"please use property `{self.__class__.__name__}.width`\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        return self.width",
  "def _set_width(self, width: Literal[\"clip\", \"pack\"] | int | tuple[Literal[\"relative\"], int]) -> None:\n        warnings.warn(\n            f\"Method `{self.__class__.__name__}._set_width` is deprecated, \"\n            f\"please use property `{self.__class__.__name__}.width`\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        self.width = width",
  "def render(\n        self,\n        size: tuple[int] | tuple[int, int],\n        focus: bool = False,\n    ) -> CompositeCanvas:\n        left, right = self.padding_values(size, focus)\n\n        maxcol = size[0]\n        maxcol -= left + right\n\n        if self._width_type == WrapMode.CLIP:\n            canv = self._original_widget.render((), focus)\n        else:\n            canv = self._original_widget.render((maxcol,) + size[1:], focus)\n        if canv.cols() == 0:\n            canv = SolidCanvas(\" \", size[0], canv.rows())\n            canv = CompositeCanvas(canv)\n            canv.set_depends([self._original_widget])\n            return canv\n        canv = CompositeCanvas(canv)\n        canv.set_depends([self._original_widget])\n        if left != 0 or right != 0:\n            canv.pad_trim_left_right(left, right)\n\n        return canv",
  "def padding_values(self, size: tuple[int] | tuple[int, int], focus: bool) -> tuple[int, int]:\n        \"\"\"Return the number of columns to pad on the left and right.\n\n        Override this method to define custom padding behaviour.\"\"\"\n        maxcol = size[0]\n        if self._width_type == WrapMode.CLIP:\n            width, ignore = self._original_widget.pack((), focus=focus)\n            return calculate_left_right_padding(\n                maxcol,\n                self._align_type,\n                self._align_amount,\n                WrapMode.CLIP,\n                width,\n                None,\n                self.left,\n                self.right,\n            )\n        if self._width_type == WHSettings.PACK:\n            maxwidth = max(maxcol - self.left - self.right, self.min_width or 0)\n            (width, ignore) = self._original_widget.pack((maxwidth,), focus=focus)\n            return calculate_left_right_padding(\n                maxcol,\n                self._align_type,\n                self._align_amount,\n                WHSettings.GIVEN,\n                width,\n                self.min_width,\n                self.left,\n                self.right,\n            )\n        return calculate_left_right_padding(\n            maxcol,\n            self._align_type,\n            self._align_amount,\n            self._width_type,\n            self._width_amount,\n            self.min_width,\n            self.left,\n            self.right,\n        )",
  "def rows(self, size, focus=False):\n        \"\"\"Return the rows needed for self.original_widget.\"\"\"\n        (maxcol,) = size\n        left, right = self.padding_values(size, focus)\n        if self._width_type == WHSettings.PACK:\n            pcols, prows = self._original_widget.pack((maxcol - left - right,), focus)\n            return prows\n        if self._width_type == WrapMode.CLIP:\n            fcols, frows = self._original_widget.pack((), focus)\n            return frows\n        return self._original_widget.rows((maxcol - left - right,), focus=focus)",
  "def keypress(self, size: tuple[int] | tuple[int, int], key: str) -> str | None:\n        \"\"\"Pass keypress to self._original_widget.\"\"\"\n        maxcol = size[0]\n        left, right = self.padding_values(size, True)\n        maxvals = (maxcol - left - right,) + size[1:]\n        return self._original_widget.keypress(maxvals, key)",
  "def get_cursor_coords(self, size: tuple[int] | tuple[int, int]) -> tuple[int, int] | None:\n        \"\"\"Return the (x,y) coordinates of cursor within self._original_widget.\"\"\"\n        if not hasattr(self._original_widget, \"get_cursor_coords\"):\n            return None\n        left, right = self.padding_values(size, True)\n        maxcol = size[0]\n        maxvals = (maxcol - left - right,) + size[1:]\n        if maxvals[0] == 0:\n            return None\n        coords = self._original_widget.get_cursor_coords(maxvals)\n        if coords is None:\n            return None\n        x, y = coords\n        return x + left, y",
  "def move_cursor_to_coords(\n        self,\n        size: tuple[int] | tuple[int, int],\n        x: int,\n        y: int,\n    ) -> bool:\n        \"\"\"Set the cursor position with (x,y) coordinates of self._original_widget.\n\n        Returns True if move succeeded, False otherwise.\n        \"\"\"\n        if not hasattr(self._original_widget, \"move_cursor_to_coords\"):\n            return True\n        left, right = self.padding_values(size, True)\n        maxcol = size[0]\n        maxvals = (maxcol - left - right,) + size[1:]\n        if isinstance(x, int):\n            if x < left:\n                x = left\n            elif x >= maxcol - right:\n                x = maxcol - right - 1\n            x -= left\n        return self._original_widget.move_cursor_to_coords(maxvals, x, y)",
  "def mouse_event(\n        self,\n        size: tuple[int] | tuple[int, int],\n        event,\n        button: int,\n        x: int,\n        y: int,\n        focus: bool,\n    ):\n        \"\"\"Send mouse event if position is within self._original_widget.\"\"\"\n        if not hasattr(self._original_widget, \"mouse_event\"):\n            return False\n\n        left, right = self.padding_values(size, focus)\n        maxcol = size[0]\n        if x < left or x >= maxcol - right:\n            return False\n        maxvals = (maxcol - left - right,) + size[1:]\n        return self._original_widget.mouse_event(maxvals, event, button, x - left, y, focus)",
  "def get_pref_col(self, size: tuple[int] | tuple[int, int]) -> int | None:\n        \"\"\"Return the preferred column from self._original_widget, or None.\"\"\"\n        if not hasattr(self._original_widget, \"get_pref_col\"):\n            return None\n\n        left, right = self.padding_values(size, True)\n        maxcol = size[0]\n        maxvals = (maxcol - left - right,) + size[1:]\n        x = self._original_widget.get_pref_col(maxvals)\n        if isinstance(x, int):\n            return x + left\n        return x",
  "class GridFlowError(Exception):\n    pass",
  "class GridFlow(WidgetWrap, WidgetContainerMixin, WidgetContainerListContentsMixin):\n    \"\"\"\n    The GridFlow widget is a flow widget that renders all the widgets it\n    contains the same width and it arranges them from left to right and top to\n    bottom.\n    \"\"\"\n\n    def sizing(self):\n        return frozenset([Sizing.FLOW])\n\n    def __init__(\n        self,\n        cells: Iterable[Widget],\n        cell_width: int,\n        h_sep: int,\n        v_sep: int,\n        align: Literal[\"left\", \"center\", \"right\"] | Align | tuple[Literal[\"relative\", WHSettings.RELATIVE], int],\n    ):\n        \"\"\"\n        :param cells: iterable of flow widgets to display\n        :param cell_width: column width for each cell\n        :param h_sep: blank columns between each cell horizontally\n        :param v_sep: blank rows between cells vertically\n            (if more than one row is required to display all the cells)\n        :param align: horizontal alignment of cells, one of:\n            'left', 'center', 'right', ('relative', percentage 0=left 100=right)\n        \"\"\"\n        self._contents = MonitoredFocusList([(w, (WHSettings.GIVEN, cell_width)) for w in cells])\n        self._contents.set_modified_callback(self._invalidate)\n        self._contents.set_focus_changed_callback(lambda f: self._invalidate())\n        self._contents.set_validate_contents_modified(self._contents_modified)\n        self._cell_width = cell_width\n        self.h_sep = h_sep\n        self.v_sep = v_sep\n        self.align = align\n        self._cache_maxcol = None\n        super().__init__(None)\n        # set self._w to something other than None\n        self.get_display_widget(((h_sep + cell_width) * len(self._contents),))\n\n    def _invalidate(self) -> None:\n        self._cache_maxcol = None\n        super()._invalidate()\n\n    def _contents_modified(\n        self, slc, new_items: Iterable[tuple[Widget, tuple[Literal[\"given\", WHSettings.GIVEN], int]]]\n    ):\n        for item in new_items:\n            try:\n                w, (t, n) = item\n                if t != WHSettings.GIVEN:\n                    raise GridFlowError(f\"added content invalid {item!r}\")\n            except (TypeError, ValueError) as exc:  # noqa: PERF203\n                raise GridFlowError(f\"added content invalid {item!r}\").with_traceback(exc.__traceback__) from exc\n\n    @property\n    def cells(self):\n        \"\"\"\n        A list of the widgets in this GridFlow\n\n        .. note:: only for backwards compatibility. You should use the new\n            standard container property :attr:`contents` to modify GridFlow\n            contents.\n        \"\"\"\n        warnings.warn(\n            \"only for backwards compatibility.\"\n            \"You should use the new standard container property `contents` to modify GridFlow\",\n            PendingDeprecationWarning,\n            stacklevel=2,\n        )\n        ml = MonitoredList(w for w, t in self.contents)\n\n        def user_modified():\n            self.cells = ml\n\n        ml.set_modified_callback(user_modified)\n        return ml\n\n    @cells.setter\n    def cells(self, widgets: Sequence[Widget]):\n        warnings.warn(\n            \"only for backwards compatibility.\"\n            \"You should use the new standard container property `contents` to modify GridFlow\",\n            PendingDeprecationWarning,\n            stacklevel=2,\n        )\n        focus_position = self.focus_position\n        self.contents = [(new, (WHSettings.GIVEN, self._cell_width)) for new in widgets]\n        if focus_position < len(widgets):\n            self.focus_position = focus_position\n\n    def _get_cells(self):\n        warnings.warn(\n            \"only for backwards compatibility.\"\n            \"You should use the new standard container property `contents` to modify GridFlow\",\n            DeprecationWarning,\n            stacklevel=3,\n        )\n        return self.cells\n\n    def _set_cells(self, widgets: Sequence[Widget]):\n        warnings.warn(\n            \"only for backwards compatibility.\"\n            \"You should use the new standard container property `contents` to modify GridFlow\",\n            DeprecationWarning,\n            stacklevel=3,\n        )\n        self.cells = widgets\n\n    @property\n    def cell_width(self) -> int:\n        \"\"\"\n        The width of each cell in the GridFlow. Setting this value affects\n        all cells.\n        \"\"\"\n        return self._cell_width\n\n    @cell_width.setter\n    def cell_width(self, width: int) -> None:\n        focus_position = self.focus_position\n        self.contents = [(w, (WHSettings.GIVEN, width)) for (w, options) in self.contents]\n        self.focus_position = focus_position\n        self._cell_width = width\n\n    def _get_cell_width(self) -> int:\n        warnings.warn(\n            f\"Method `{self.__class__.__name__}._get_cell_width` is deprecated, \"\n            f\"please use property `{self.__class__.__name__}.cell_width`\",\n            DeprecationWarning,\n            stacklevel=3,\n        )\n        return self.cell_width\n\n    def _set_cell_width(self, width: int) -> None:\n        warnings.warn(\n            f\"Method `{self.__class__.__name__}._set_cell_width` is deprecated, \"\n            f\"please use property `{self.__class__.__name__}.cell_width`\",\n            DeprecationWarning,\n            stacklevel=3,\n        )\n        self.cell_width = width\n\n    @property\n    def contents(self):\n        \"\"\"\n        The contents of this GridFlow as a list of (widget, options)\n        tuples.\n\n        options is currently a tuple in the form `('fixed', number)`.\n        number is the number of screen columns to allocate to this cell.\n        'fixed' is the only type accepted at this time.\n\n        This list may be modified like a normal list and the GridFlow\n        widget will update automatically.\n\n        .. seealso:: Create new options tuples with the :meth:`options` method.\n        \"\"\"\n        return self._contents\n\n    @contents.setter\n    def contents(self, c):\n        self._contents[:] = c\n\n    def options(\n        self,\n        width_type: Literal[\"given\", WHSettings.GIVEN] = WHSettings.GIVEN,\n        width_amount: int | None = None,\n    ) -> tuple[Literal[WHSettings.GIVEN], int]:\n        \"\"\"\n        Return a new options tuple for use in a GridFlow's .contents list.\n\n        width_type -- 'given' is the only value accepted\n        width_amount -- None to use the default cell_width for this GridFlow\n        \"\"\"\n        if width_type != WHSettings.GIVEN:\n            raise GridFlowError(f\"invalid width_type: {width_type!r}\")\n        if width_amount is None:\n            width_amount = self._cell_width\n        return (WHSettings(width_type), width_amount)\n\n    def set_focus(self, cell: Widget | int) -> None:\n        \"\"\"\n        Set the cell in focus, for backwards compatibility.\n\n        .. note:: only for backwards compatibility. You may also use the new\n            standard container property :attr:`focus_position` to get the focus.\n\n        :param cell: contained element to focus\n        :type cell: Widget or int\n        \"\"\"\n        warnings.warn(\n            \"only for backwards compatibility.\"\n            \"You may also use the new standard container property `focus_position` to set the focus.\",\n            PendingDeprecationWarning,\n            stacklevel=2,\n        )\n        if isinstance(cell, int):\n            try:\n                if cell < 0 or cell >= len(self.contents):\n                    raise IndexError(f\"No GridFlow child widget at position {cell}\")\n            except TypeError as exc:\n                raise IndexError(f\"No GridFlow child widget at position {cell}\").with_traceback(\n                    exc.__traceback__\n                ) from exc\n            self.contents.focus = cell\n            return\n\n        for i, (w, _options) in enumerate(self.contents):\n            if cell == w:\n                self.focus_position = i\n                return\n        raise ValueError(f\"Widget not found in GridFlow contents: {cell!r}\")\n\n    @property\n    def focus(self) -> Widget | None:\n        \"\"\"the child widget in focus or None when GridFlow is empty\"\"\"\n        if not self.contents:\n            return None\n        return self.contents[self.focus_position][0]\n\n    def _get_focus(self) -> Widget:\n        warnings.warn(\n            f\"method `{self.__class__.__name__}._get_focus` is deprecated, \"\n            f\"please use `{self.__class__.__name__}.focus` property\",\n            DeprecationWarning,\n            stacklevel=3,\n        )\n        if not self.contents:\n            return None\n        return self.contents[self.focus_position][0]\n\n    def get_focus(self):\n        \"\"\"\n        Return the widget in focus, for backwards compatibility.\n\n        .. note:: only for backwards compatibility. You may also use the new\n            standard container property :attr:`focus` to get the focus.\n        \"\"\"\n        warnings.warn(\n            \"only for backwards compatibility.\"\n            \"You may also use the new standard container property `focus` to get the focus.\",\n            PendingDeprecationWarning,\n            stacklevel=2,\n        )\n        if not self.contents:\n            return None\n        return self.contents[self.focus_position][0]\n\n    @property\n    def focus_cell(self):\n        warnings.warn(\n            \"only for backwards compatibility.\"\n            \"You may also use the new standard container property\"\n            \"`focus` to get the focus and `focus_position` to get/set the cell in focus by index\",\n            PendingDeprecationWarning,\n            stacklevel=2,\n        )\n        return self.focus\n\n    @focus_cell.setter\n    def focus_cell(self, cell: Widget) -> None:\n        warnings.warn(\n            \"only for backwards compatibility.\"\n            \"You may also use the new standard container property\"\n            \"`focus` to get the focus and `focus_position` to get/set the cell in focus by index\",\n            PendingDeprecationWarning,\n            stacklevel=2,\n        )\n        for i, (w, _options) in enumerate(self.contents):\n            if cell == w:\n                self.focus_position = i\n                return\n        raise ValueError(f\"Widget not found in GridFlow contents: {cell!r}\")\n\n    def _set_focus_cell(self, cell: Widget) -> None:\n        warnings.warn(\n            \"only for backwards compatibility.\"\n            \"You may also use the new standard container property\"\n            \"`focus` to get the focus and `focus_position` to get/set the cell in focus by index\",\n            DeprecationWarning,\n            stacklevel=3,\n        )\n        for i, (w, _options) in enumerate(self.contents):\n            if cell == w:\n                self.focus_position = i\n                return\n        raise ValueError(f\"Widget not found in GridFlow contents: {cell!r}\")\n\n    @property\n    def focus_position(self) -> int | None:\n        \"\"\"\n        index of child widget in focus.\n        Raises :exc:`IndexError` if read when GridFlow is empty, or when set to an invalid index.\n        \"\"\"\n        if not self.contents:\n            raise IndexError(\"No focus_position, GridFlow is empty\")\n        return self.contents.focus\n\n    @focus_position.setter\n    def focus_position(self, position: int) -> None:\n        \"\"\"\n        Set the widget in focus.\n\n        position -- index of child widget to be made focus\n        \"\"\"\n        try:\n            if position < 0 or position >= len(self.contents):\n                raise IndexError(f\"No GridFlow child widget at position {position}\")\n        except TypeError as exc:\n            raise IndexError(f\"No GridFlow child widget at position {position}\").with_traceback(\n                exc.__traceback__\n            ) from exc\n        self.contents.focus = position\n\n    def _get_focus_position(self) -> int | None:\n        warnings.warn(\n            f\"method `{self.__class__.__name__}._get_focus_position` is deprecated, \"\n            f\"please use `{self.__class__.__name__}.focus_position` property\",\n            DeprecationWarning,\n            stacklevel=3,\n        )\n        if not self.contents:\n            raise IndexError(\"No focus_position, GridFlow is empty\")\n        return self.contents.focus\n\n    def _set_focus_position(self, position: int) -> None:\n        \"\"\"\n        Set the widget in focus.\n\n        position -- index of child widget to be made focus\n        \"\"\"\n        warnings.warn(\n            f\"method `{self.__class__.__name__}._set_focus_position` is deprecated, \"\n            f\"please use `{self.__class__.__name__}.focus_position` property\",\n            DeprecationWarning,\n            stacklevel=3,\n        )\n        try:\n            if position < 0 or position >= len(self.contents):\n                raise IndexError(f\"No GridFlow child widget at position {position}\")\n        except TypeError as exc:\n            raise IndexError(f\"No GridFlow child widget at position {position}\").with_traceback(\n                exc.__traceback__\n            ) from exc\n        self.contents.focus = position\n\n    def get_display_widget(self, size: tuple[int]) -> Divider | Pile:\n        \"\"\"\n        Arrange the cells into columns (and possibly a pile) for\n        display, input or to calculate rows, and update the display\n        widget.\n        \"\"\"\n        (maxcol,) = size\n        # use cache if possible\n        if self._cache_maxcol == maxcol:\n            return self._w\n\n        self._cache_maxcol = maxcol\n        self._w = self.generate_display_widget(size)\n\n        return self._w\n\n    def generate_display_widget(self, size: tuple[int]) -> Divider | Pile:\n        \"\"\"\n        Actually generate display widget (ignoring cache)\n        \"\"\"\n        (maxcol,) = size\n        divider = Divider()\n        if not self.contents:\n            return divider\n\n        if self.v_sep > 1:\n            # increase size of divider\n            divider.top = self.v_sep - 1\n\n        c = None\n        p = Pile([])\n        used_space = 0\n\n        for i, (w, (_width_type, width_amount)) in enumerate(self.contents):\n            if c is None or maxcol - used_space < width_amount:\n                # starting a new row\n                if self.v_sep:\n                    p.contents.append((divider, p.options()))\n                c = Columns([], self.h_sep)\n                column_focused = False\n                pad = Padding(c, self.align)\n                # extra attribute to reference contents position\n                pad.first_position = i\n                p.contents.append((pad, p.options()))\n\n            c.contents.append((w, c.options(WHSettings.GIVEN, width_amount)))\n            if (i == self.focus_position) or (not column_focused and w.selectable()):\n                c.focus_position = len(c.contents) - 1\n                column_focused = True\n            if i == self.focus_position:\n                p.focus_position = len(p.contents) - 1\n            used_space = sum(x[1][1] for x in c.contents) + self.h_sep * len(c.contents)\n            if width_amount > maxcol:\n                # special case: display is too narrow for the given\n                # width so we remove the Columns for better behaviour\n                # FIXME: determine why this is necessary\n                pad.original_widget = w\n            pad.width = used_space - self.h_sep\n\n        if self.v_sep:\n            # remove first divider\n            del p.contents[:1]\n        else:\n            # Ensure p __selectable is updated\n            p._contents_modified()\n\n        return p\n\n    def _set_focus_from_display_widget(self) -> None:\n        \"\"\"\n        Set the focus to the item in focus in the display widget.\n        \"\"\"\n        # display widget (self._w) is always built as:\n        #\n        # Pile([\n        #     Padding(\n        #         Columns([ # possibly\n        #         cell, ...])),\n        #     Divider(), # possibly\n        #     ...])\n\n        pile_focus = self._w.focus\n        if not pile_focus:\n            return\n        c = pile_focus.base_widget\n        if c.focus:\n            col_focus_position = c.focus_position\n        else:\n            col_focus_position = 0\n        # pad.first_position was set by generate_display_widget() above\n        self.focus_position = pile_focus.first_position + col_focus_position\n\n    def keypress(self, size: tuple[int], key: str) -> str | None:\n        \"\"\"\n        Pass keypress to display widget for handling.\n        Captures focus changes.\n        \"\"\"\n        self.get_display_widget(size)\n        key = super().keypress(size, key)\n        if key is None:\n            self._set_focus_from_display_widget()\n        return key\n\n    def rows(self, size: tuple[int], focus: bool = False) -> int:\n        self.get_display_widget(size)\n        return super().rows(size, focus=focus)\n\n    def render(self, size: tuple[int], focus: bool = False):\n        self.get_display_widget(size)\n        return super().render(size, focus)\n\n    def get_cursor_coords(self, size: tuple[int]) -> tuple[int, int]:\n        \"\"\"Get cursor from display widget.\"\"\"\n        self.get_display_widget(size)\n        return super().get_cursor_coords(size)\n\n    def move_cursor_to_coords(self, size: tuple[int], col: int, row: int):\n        \"\"\"Set the widget in focus based on the col + row.\"\"\"\n        self.get_display_widget(size)\n        rval = super().move_cursor_to_coords(size, col, row)\n        self._set_focus_from_display_widget()\n        return rval\n\n    def mouse_event(self, size: tuple[int], event, button: int, col: int, row: int, focus: bool) -> Literal[True]:\n        self.get_display_widget(size)\n        super().mouse_event(size, event, button, col, row, focus)\n        self._set_focus_from_display_widget()\n        return True  # at a minimum we adjusted our focus\n\n    def get_pref_col(self, size: tuple[int]):\n        \"\"\"Return pref col from display widget.\"\"\"\n        self.get_display_widget(size)\n        return super().get_pref_col(size)",
  "def sizing(self):\n        return frozenset([Sizing.FLOW])",
  "def __init__(\n        self,\n        cells: Iterable[Widget],\n        cell_width: int,\n        h_sep: int,\n        v_sep: int,\n        align: Literal[\"left\", \"center\", \"right\"] | Align | tuple[Literal[\"relative\", WHSettings.RELATIVE], int],\n    ):\n        \"\"\"\n        :param cells: iterable of flow widgets to display\n        :param cell_width: column width for each cell\n        :param h_sep: blank columns between each cell horizontally\n        :param v_sep: blank rows between cells vertically\n            (if more than one row is required to display all the cells)\n        :param align: horizontal alignment of cells, one of:\n            'left', 'center', 'right', ('relative', percentage 0=left 100=right)\n        \"\"\"\n        self._contents = MonitoredFocusList([(w, (WHSettings.GIVEN, cell_width)) for w in cells])\n        self._contents.set_modified_callback(self._invalidate)\n        self._contents.set_focus_changed_callback(lambda f: self._invalidate())\n        self._contents.set_validate_contents_modified(self._contents_modified)\n        self._cell_width = cell_width\n        self.h_sep = h_sep\n        self.v_sep = v_sep\n        self.align = align\n        self._cache_maxcol = None\n        super().__init__(None)\n        # set self._w to something other than None\n        self.get_display_widget(((h_sep + cell_width) * len(self._contents),))",
  "def _invalidate(self) -> None:\n        self._cache_maxcol = None\n        super()._invalidate()",
  "def _contents_modified(\n        self, slc, new_items: Iterable[tuple[Widget, tuple[Literal[\"given\", WHSettings.GIVEN], int]]]\n    ):\n        for item in new_items:\n            try:\n                w, (t, n) = item\n                if t != WHSettings.GIVEN:\n                    raise GridFlowError(f\"added content invalid {item!r}\")\n            except (TypeError, ValueError) as exc:  # noqa: PERF203\n                raise GridFlowError(f\"added content invalid {item!r}\").with_traceback(exc.__traceback__) from exc",
  "def cells(self):\n        \"\"\"\n        A list of the widgets in this GridFlow\n\n        .. note:: only for backwards compatibility. You should use the new\n            standard container property :attr:`contents` to modify GridFlow\n            contents.\n        \"\"\"\n        warnings.warn(\n            \"only for backwards compatibility.\"\n            \"You should use the new standard container property `contents` to modify GridFlow\",\n            PendingDeprecationWarning,\n            stacklevel=2,\n        )\n        ml = MonitoredList(w for w, t in self.contents)\n\n        def user_modified():\n            self.cells = ml\n\n        ml.set_modified_callback(user_modified)\n        return ml",
  "def cells(self, widgets: Sequence[Widget]):\n        warnings.warn(\n            \"only for backwards compatibility.\"\n            \"You should use the new standard container property `contents` to modify GridFlow\",\n            PendingDeprecationWarning,\n            stacklevel=2,\n        )\n        focus_position = self.focus_position\n        self.contents = [(new, (WHSettings.GIVEN, self._cell_width)) for new in widgets]\n        if focus_position < len(widgets):\n            self.focus_position = focus_position",
  "def _get_cells(self):\n        warnings.warn(\n            \"only for backwards compatibility.\"\n            \"You should use the new standard container property `contents` to modify GridFlow\",\n            DeprecationWarning,\n            stacklevel=3,\n        )\n        return self.cells",
  "def _set_cells(self, widgets: Sequence[Widget]):\n        warnings.warn(\n            \"only for backwards compatibility.\"\n            \"You should use the new standard container property `contents` to modify GridFlow\",\n            DeprecationWarning,\n            stacklevel=3,\n        )\n        self.cells = widgets",
  "def cell_width(self) -> int:\n        \"\"\"\n        The width of each cell in the GridFlow. Setting this value affects\n        all cells.\n        \"\"\"\n        return self._cell_width",
  "def cell_width(self, width: int) -> None:\n        focus_position = self.focus_position\n        self.contents = [(w, (WHSettings.GIVEN, width)) for (w, options) in self.contents]\n        self.focus_position = focus_position\n        self._cell_width = width",
  "def _get_cell_width(self) -> int:\n        warnings.warn(\n            f\"Method `{self.__class__.__name__}._get_cell_width` is deprecated, \"\n            f\"please use property `{self.__class__.__name__}.cell_width`\",\n            DeprecationWarning,\n            stacklevel=3,\n        )\n        return self.cell_width",
  "def _set_cell_width(self, width: int) -> None:\n        warnings.warn(\n            f\"Method `{self.__class__.__name__}._set_cell_width` is deprecated, \"\n            f\"please use property `{self.__class__.__name__}.cell_width`\",\n            DeprecationWarning,\n            stacklevel=3,\n        )\n        self.cell_width = width",
  "def contents(self):\n        \"\"\"\n        The contents of this GridFlow as a list of (widget, options)\n        tuples.\n\n        options is currently a tuple in the form `('fixed', number)`.\n        number is the number of screen columns to allocate to this cell.\n        'fixed' is the only type accepted at this time.\n\n        This list may be modified like a normal list and the GridFlow\n        widget will update automatically.\n\n        .. seealso:: Create new options tuples with the :meth:`options` method.\n        \"\"\"\n        return self._contents",
  "def contents(self, c):\n        self._contents[:] = c",
  "def options(\n        self,\n        width_type: Literal[\"given\", WHSettings.GIVEN] = WHSettings.GIVEN,\n        width_amount: int | None = None,\n    ) -> tuple[Literal[WHSettings.GIVEN], int]:\n        \"\"\"\n        Return a new options tuple for use in a GridFlow's .contents list.\n\n        width_type -- 'given' is the only value accepted\n        width_amount -- None to use the default cell_width for this GridFlow\n        \"\"\"\n        if width_type != WHSettings.GIVEN:\n            raise GridFlowError(f\"invalid width_type: {width_type!r}\")\n        if width_amount is None:\n            width_amount = self._cell_width\n        return (WHSettings(width_type), width_amount)",
  "def set_focus(self, cell: Widget | int) -> None:\n        \"\"\"\n        Set the cell in focus, for backwards compatibility.\n\n        .. note:: only for backwards compatibility. You may also use the new\n            standard container property :attr:`focus_position` to get the focus.\n\n        :param cell: contained element to focus\n        :type cell: Widget or int\n        \"\"\"\n        warnings.warn(\n            \"only for backwards compatibility.\"\n            \"You may also use the new standard container property `focus_position` to set the focus.\",\n            PendingDeprecationWarning,\n            stacklevel=2,\n        )\n        if isinstance(cell, int):\n            try:\n                if cell < 0 or cell >= len(self.contents):\n                    raise IndexError(f\"No GridFlow child widget at position {cell}\")\n            except TypeError as exc:\n                raise IndexError(f\"No GridFlow child widget at position {cell}\").with_traceback(\n                    exc.__traceback__\n                ) from exc\n            self.contents.focus = cell\n            return\n\n        for i, (w, _options) in enumerate(self.contents):\n            if cell == w:\n                self.focus_position = i\n                return\n        raise ValueError(f\"Widget not found in GridFlow contents: {cell!r}\")",
  "def focus(self) -> Widget | None:\n        \"\"\"the child widget in focus or None when GridFlow is empty\"\"\"\n        if not self.contents:\n            return None\n        return self.contents[self.focus_position][0]",
  "def _get_focus(self) -> Widget:\n        warnings.warn(\n            f\"method `{self.__class__.__name__}._get_focus` is deprecated, \"\n            f\"please use `{self.__class__.__name__}.focus` property\",\n            DeprecationWarning,\n            stacklevel=3,\n        )\n        if not self.contents:\n            return None\n        return self.contents[self.focus_position][0]",
  "def get_focus(self):\n        \"\"\"\n        Return the widget in focus, for backwards compatibility.\n\n        .. note:: only for backwards compatibility. You may also use the new\n            standard container property :attr:`focus` to get the focus.\n        \"\"\"\n        warnings.warn(\n            \"only for backwards compatibility.\"\n            \"You may also use the new standard container property `focus` to get the focus.\",\n            PendingDeprecationWarning,\n            stacklevel=2,\n        )\n        if not self.contents:\n            return None\n        return self.contents[self.focus_position][0]",
  "def focus_cell(self):\n        warnings.warn(\n            \"only for backwards compatibility.\"\n            \"You may also use the new standard container property\"\n            \"`focus` to get the focus and `focus_position` to get/set the cell in focus by index\",\n            PendingDeprecationWarning,\n            stacklevel=2,\n        )\n        return self.focus",
  "def focus_cell(self, cell: Widget) -> None:\n        warnings.warn(\n            \"only for backwards compatibility.\"\n            \"You may also use the new standard container property\"\n            \"`focus` to get the focus and `focus_position` to get/set the cell in focus by index\",\n            PendingDeprecationWarning,\n            stacklevel=2,\n        )\n        for i, (w, _options) in enumerate(self.contents):\n            if cell == w:\n                self.focus_position = i\n                return\n        raise ValueError(f\"Widget not found in GridFlow contents: {cell!r}\")",
  "def _set_focus_cell(self, cell: Widget) -> None:\n        warnings.warn(\n            \"only for backwards compatibility.\"\n            \"You may also use the new standard container property\"\n            \"`focus` to get the focus and `focus_position` to get/set the cell in focus by index\",\n            DeprecationWarning,\n            stacklevel=3,\n        )\n        for i, (w, _options) in enumerate(self.contents):\n            if cell == w:\n                self.focus_position = i\n                return\n        raise ValueError(f\"Widget not found in GridFlow contents: {cell!r}\")",
  "def focus_position(self) -> int | None:\n        \"\"\"\n        index of child widget in focus.\n        Raises :exc:`IndexError` if read when GridFlow is empty, or when set to an invalid index.\n        \"\"\"\n        if not self.contents:\n            raise IndexError(\"No focus_position, GridFlow is empty\")\n        return self.contents.focus",
  "def focus_position(self, position: int) -> None:\n        \"\"\"\n        Set the widget in focus.\n\n        position -- index of child widget to be made focus\n        \"\"\"\n        try:\n            if position < 0 or position >= len(self.contents):\n                raise IndexError(f\"No GridFlow child widget at position {position}\")\n        except TypeError as exc:\n            raise IndexError(f\"No GridFlow child widget at position {position}\").with_traceback(\n                exc.__traceback__\n            ) from exc\n        self.contents.focus = position",
  "def _get_focus_position(self) -> int | None:\n        warnings.warn(\n            f\"method `{self.__class__.__name__}._get_focus_position` is deprecated, \"\n            f\"please use `{self.__class__.__name__}.focus_position` property\",\n            DeprecationWarning,\n            stacklevel=3,\n        )\n        if not self.contents:\n            raise IndexError(\"No focus_position, GridFlow is empty\")\n        return self.contents.focus",
  "def _set_focus_position(self, position: int) -> None:\n        \"\"\"\n        Set the widget in focus.\n\n        position -- index of child widget to be made focus\n        \"\"\"\n        warnings.warn(\n            f\"method `{self.__class__.__name__}._set_focus_position` is deprecated, \"\n            f\"please use `{self.__class__.__name__}.focus_position` property\",\n            DeprecationWarning,\n            stacklevel=3,\n        )\n        try:\n            if position < 0 or position >= len(self.contents):\n                raise IndexError(f\"No GridFlow child widget at position {position}\")\n        except TypeError as exc:\n            raise IndexError(f\"No GridFlow child widget at position {position}\").with_traceback(\n                exc.__traceback__\n            ) from exc\n        self.contents.focus = position",
  "def get_display_widget(self, size: tuple[int]) -> Divider | Pile:\n        \"\"\"\n        Arrange the cells into columns (and possibly a pile) for\n        display, input or to calculate rows, and update the display\n        widget.\n        \"\"\"\n        (maxcol,) = size\n        # use cache if possible\n        if self._cache_maxcol == maxcol:\n            return self._w\n\n        self._cache_maxcol = maxcol\n        self._w = self.generate_display_widget(size)\n\n        return self._w",
  "def generate_display_widget(self, size: tuple[int]) -> Divider | Pile:\n        \"\"\"\n        Actually generate display widget (ignoring cache)\n        \"\"\"\n        (maxcol,) = size\n        divider = Divider()\n        if not self.contents:\n            return divider\n\n        if self.v_sep > 1:\n            # increase size of divider\n            divider.top = self.v_sep - 1\n\n        c = None\n        p = Pile([])\n        used_space = 0\n\n        for i, (w, (_width_type, width_amount)) in enumerate(self.contents):\n            if c is None or maxcol - used_space < width_amount:\n                # starting a new row\n                if self.v_sep:\n                    p.contents.append((divider, p.options()))\n                c = Columns([], self.h_sep)\n                column_focused = False\n                pad = Padding(c, self.align)\n                # extra attribute to reference contents position\n                pad.first_position = i\n                p.contents.append((pad, p.options()))\n\n            c.contents.append((w, c.options(WHSettings.GIVEN, width_amount)))\n            if (i == self.focus_position) or (not column_focused and w.selectable()):\n                c.focus_position = len(c.contents) - 1\n                column_focused = True\n            if i == self.focus_position:\n                p.focus_position = len(p.contents) - 1\n            used_space = sum(x[1][1] for x in c.contents) + self.h_sep * len(c.contents)\n            if width_amount > maxcol:\n                # special case: display is too narrow for the given\n                # width so we remove the Columns for better behaviour\n                # FIXME: determine why this is necessary\n                pad.original_widget = w\n            pad.width = used_space - self.h_sep\n\n        if self.v_sep:\n            # remove first divider\n            del p.contents[:1]\n        else:\n            # Ensure p __selectable is updated\n            p._contents_modified()\n\n        return p",
  "def _set_focus_from_display_widget(self) -> None:\n        \"\"\"\n        Set the focus to the item in focus in the display widget.\n        \"\"\"\n        # display widget (self._w) is always built as:\n        #\n        # Pile([\n        #     Padding(\n        #         Columns([ # possibly\n        #         cell, ...])),\n        #     Divider(), # possibly\n        #     ...])\n\n        pile_focus = self._w.focus\n        if not pile_focus:\n            return\n        c = pile_focus.base_widget\n        if c.focus:\n            col_focus_position = c.focus_position\n        else:\n            col_focus_position = 0\n        # pad.first_position was set by generate_display_widget() above\n        self.focus_position = pile_focus.first_position + col_focus_position",
  "def keypress(self, size: tuple[int], key: str) -> str | None:\n        \"\"\"\n        Pass keypress to display widget for handling.\n        Captures focus changes.\n        \"\"\"\n        self.get_display_widget(size)\n        key = super().keypress(size, key)\n        if key is None:\n            self._set_focus_from_display_widget()\n        return key",
  "def rows(self, size: tuple[int], focus: bool = False) -> int:\n        self.get_display_widget(size)\n        return super().rows(size, focus=focus)",
  "def render(self, size: tuple[int], focus: bool = False):\n        self.get_display_widget(size)\n        return super().render(size, focus)",
  "def get_cursor_coords(self, size: tuple[int]) -> tuple[int, int]:\n        \"\"\"Get cursor from display widget.\"\"\"\n        self.get_display_widget(size)\n        return super().get_cursor_coords(size)",
  "def move_cursor_to_coords(self, size: tuple[int], col: int, row: int):\n        \"\"\"Set the widget in focus based on the col + row.\"\"\"\n        self.get_display_widget(size)\n        rval = super().move_cursor_to_coords(size, col, row)\n        self._set_focus_from_display_widget()\n        return rval",
  "def mouse_event(self, size: tuple[int], event, button: int, col: int, row: int, focus: bool) -> Literal[True]:\n        self.get_display_widget(size)\n        super().mouse_event(size, event, button, col, row, focus)\n        self._set_focus_from_display_widget()\n        return True",
  "def get_pref_col(self, size: tuple[int]):\n        \"\"\"Return pref col from display widget.\"\"\"\n        self.get_display_widget(size)\n        return super().get_pref_col(size)",
  "def user_modified():\n            self.cells = ml",
  "class Divider(Widget):\n    \"\"\"\n    Horizontal divider widget\n    \"\"\"\n\n    _sizing = frozenset([Sizing.FLOW])\n\n    ignore_focus = True\n\n    def __init__(\n        self,\n        div_char: str | bytes = \" \",\n        top: int = 0,\n        bottom: int = 0,\n    ) -> None:\n        \"\"\"\n        :param div_char: character to repeat across line\n        :type div_char: bytes or unicode\n\n        :param top: number of blank lines above\n        :type top: int\n\n        :param bottom: number of blank lines below\n        :type bottom: int\n\n        >>> Divider()\n        <Divider flow widget>\n        >>> Divider(u'-')\n        <Divider flow widget '-'>\n        >>> Divider(u'x', 1, 2)\n        <Divider flow widget 'x' bottom=2 top=1>\n        \"\"\"\n        super().__init__()\n        self.div_char = div_char\n        self.top = top\n        self.bottom = bottom\n\n    def _repr_words(self):\n        return super()._repr_words() + [repr(self.div_char)] * (self.div_char != \" \")\n\n    def _repr_attrs(self):\n        attrs = dict(super()._repr_attrs())\n        if self.top:\n            attrs[\"top\"] = self.top\n        if self.bottom:\n            attrs[\"bottom\"] = self.bottom\n        return attrs\n\n    def rows(self, size: tuple[int], focus: bool = False) -> int:\n        \"\"\"\n        Return the number of lines that will be rendered.\n\n        >>> Divider().rows((10,))\n        1\n        >>> Divider(u'x', 1, 2).rows((10,))\n        4\n        \"\"\"\n        (maxcol,) = size\n        return self.top + 1 + self.bottom\n\n    def render(self, size: tuple[int], focus: bool = False):\n        \"\"\"\n        Render the divider as a canvas and return it.\n\n        >>> Divider().render((10,)).text # ... = b in Python 3\n        [...'          ']\n        >>> Divider(u'-', top=1).render((10,)).text\n        [...'          ', ...'----------']\n        >>> Divider(u'x', bottom=2).render((5,)).text\n        [...'xxxxx', ...'     ', ...'     ']\n        \"\"\"\n        (maxcol,) = size\n        canv = CompositeCanvas(SolidCanvas(self.div_char, maxcol, 1))\n        if self.top or self.bottom:\n            canv.pad_trim_top_bottom(self.top, self.bottom)\n        return canv",
  "def __init__(\n        self,\n        div_char: str | bytes = \" \",\n        top: int = 0,\n        bottom: int = 0,\n    ) -> None:\n        \"\"\"\n        :param div_char: character to repeat across line\n        :type div_char: bytes or unicode\n\n        :param top: number of blank lines above\n        :type top: int\n\n        :param bottom: number of blank lines below\n        :type bottom: int\n\n        >>> Divider()\n        <Divider flow widget>\n        >>> Divider(u'-')\n        <Divider flow widget '-'>\n        >>> Divider(u'x', 1, 2)\n        <Divider flow widget 'x' bottom=2 top=1>\n        \"\"\"\n        super().__init__()\n        self.div_char = div_char\n        self.top = top\n        self.bottom = bottom",
  "def _repr_words(self):\n        return super()._repr_words() + [repr(self.div_char)] * (self.div_char != \" \")",
  "def _repr_attrs(self):\n        attrs = dict(super()._repr_attrs())\n        if self.top:\n            attrs[\"top\"] = self.top\n        if self.bottom:\n            attrs[\"bottom\"] = self.bottom\n        return attrs",
  "def rows(self, size: tuple[int], focus: bool = False) -> int:\n        \"\"\"\n        Return the number of lines that will be rendered.\n\n        >>> Divider().rows((10,))\n        1\n        >>> Divider(u'x', 1, 2).rows((10,))\n        4\n        \"\"\"\n        (maxcol,) = size\n        return self.top + 1 + self.bottom",
  "def render(self, size: tuple[int], focus: bool = False):\n        \"\"\"\n        Render the divider as a canvas and return it.\n\n        >>> Divider().render((10,)).text # ... = b in Python 3\n        [...'          ']\n        >>> Divider(u'-', top=1).render((10,)).text\n        [...'          ', ...'----------']\n        >>> Divider(u'x', bottom=2).render((5,)).text\n        [...'xxxxx', ...'     ', ...'     ']\n        \"\"\"\n        (maxcol,) = size\n        canv = CompositeCanvas(SolidCanvas(self.div_char, maxcol, 1))\n        if self.top or self.bottom:\n            canv.pad_trim_top_bottom(self.top, self.bottom)\n        return canv",
  "class TextError(Exception):\n    pass",
  "class Text(Widget):\n    \"\"\"\n    a horizontally resizeable text widget\n    \"\"\"\n\n    _sizing = frozenset([Sizing.FLOW])\n\n    ignore_focus = True\n    _repr_content_length_max = 140\n\n    def __init__(\n        self,\n        markup,\n        align: Literal[\"left\", \"center\", \"right\"] | Align = Align.LEFT,\n        wrap: Literal[\"space\", \"any\", \"clip\", \"ellipsis\"] | WrapMode = WrapMode.SPACE,\n        layout: text_layout.TextLayout | None = None,\n    ) -> None:\n        \"\"\"\n        :param markup: content of text widget, one of:\n\n            bytes or unicode\n              text to be displayed\n\n            (*display attribute*, *text markup*)\n              *text markup* with *display attribute* applied to all parts\n              of *text markup* with no display attribute already applied\n\n            [*text markup*, *text markup*, ... ]\n              all *text markup* in the list joined together\n\n        :type markup: :ref:`text-markup`\n        :param align: typically ``'left'``, ``'center'`` or ``'right'``\n        :type align: text alignment mode\n        :param wrap: typically ``'space'``, ``'any'``, ``'clip'`` or ``'ellipsis'``\n        :type wrap: text wrapping mode\n        :param layout: defaults to a shared :class:`StandardTextLayout` instance\n        :type layout: text layout instance\n\n        >>> Text(u\"Hello\")\n        <Text flow widget 'Hello'>\n        >>> t = Text(('bold', u\"stuff\"), 'right', 'any')\n        >>> t\n        <Text flow widget 'stuff' align='right' wrap='any'>\n        >>> print(t.text)\n        stuff\n        >>> t.attrib\n        [('bold', 5)]\n        \"\"\"\n        super().__init__()\n        self._cache_maxcol = None\n        self.set_text(markup)\n        self.set_layout(align, wrap, layout)\n\n    def _repr_words(self) -> list[str]:\n        \"\"\"\n        Show the text in the repr in python3 format (b prefix for byte strings) and truncate if it's too long\n        \"\"\"\n        first = super()._repr_words()\n        text = self.get_text()[0]\n        rest = repr(text)\n        if len(rest) > self._repr_content_length_max:\n            rest = (\n                rest[: self._repr_content_length_max * 2 // 3 - 3] + \"...\" + rest[-self._repr_content_length_max // 3 :]\n            )\n        return [*first, rest]\n\n    def _repr_attrs(self):\n        attrs = dict(\n            super()._repr_attrs(),\n            align=self._align_mode,\n            wrap=self._wrap_mode,\n        )\n        return remove_defaults(attrs, Text.__init__)\n\n    def _invalidate(self) -> None:\n        self._cache_maxcol = None\n        super()._invalidate()\n\n    def set_text(self, markup):\n        \"\"\"\n        Set content of text widget.\n\n        :param markup: see :class:`Text` for description.\n        :type markup: text markup\n\n        >>> t = Text(u\"foo\")\n        >>> print(t.text)\n        foo\n        >>> t.set_text(u\"bar\")\n        >>> print(t.text)\n        bar\n        >>> t.text = u\"baz\"  # not supported because text stores text but set_text() takes markup\n        Traceback (most recent call last):\n        AttributeError: can't set attribute\n        \"\"\"\n        self._text, self._attrib = decompose_tagmarkup(markup)\n        self._invalidate()\n\n    def get_text(self):\n        \"\"\"\n        :returns: (*text*, *display attributes*)\n\n            *text*\n              complete bytes/unicode content of text widget\n\n            *display attributes*\n              run length encoded display attributes for *text*, eg.\n              ``[('attr1', 10), ('attr2', 5)]``\n\n        >>> Text(u\"Hello\").get_text() # ... = u in Python 2\n        (...'Hello', [])\n        >>> Text(('bright', u\"Headline\")).get_text()\n        (...'Headline', [('bright', 8)])\n        >>> Text([('a', u\"one\"), u\"two\", ('b', u\"three\")]).get_text()\n        (...'onetwothree', [('a', 3), (None, 3), ('b', 5)])\n        \"\"\"\n        return self._text, self._attrib\n\n    @property\n    def text(self) -> str:\n        \"\"\"\n        Read-only property returning the complete bytes/unicode content\n        of this widget\n        \"\"\"\n        return self.get_text()[0]\n\n    @property\n    def attrib(self):\n        \"\"\"\n        Read-only property returning the run-length encoded display\n        attributes of this widget\n        \"\"\"\n        return self.get_text()[1]\n\n    def set_align_mode(self, mode: Literal[\"left\", \"center\", \"right\"] | Align) -> None:\n        \"\"\"\n        Set text alignment mode. Supported modes depend on text layout\n        object in use but defaults to a :class:`StandardTextLayout` instance\n\n        :param mode: typically ``'left'``, ``'center'`` or ``'right'``\n        :type mode: text alignment mode\n\n        >>> t = Text(u\"word\")\n        >>> t.set_align_mode('right')\n        >>> t.align\n        'right'\n        >>> t.render((10,)).text # ... = b in Python 3\n        [...'      word']\n        >>> t.align = 'center'\n        >>> t.render((10,)).text\n        [...'   word   ']\n        >>> t.align = 'somewhere'\n        Traceback (most recent call last):\n        TextError: Alignment mode 'somewhere' not supported.\n        \"\"\"\n        if not self.layout.supports_align_mode(mode):\n            raise TextError(f\"Alignment mode {mode!r} not supported.\")\n        self._align_mode = mode\n        self._invalidate()\n\n    def set_wrap_mode(self, mode: Literal[\"space\", \"any\", \"clip\", \"ellipsis\"] | WrapMode) -> None:\n        \"\"\"\n        Set text wrapping mode. Supported modes depend on text layout\n        object in use but defaults to a :class:`StandardTextLayout` instance\n\n        :param mode: typically ``'space'``, ``'any'``, ``'clip'`` or ``'ellipsis'``\n        :type mode: text wrapping mode\n\n        >>> t = Text(u\"some words\")\n        >>> t.render((6,)).text # ... = b in Python 3\n        [...'some  ', ...'words ']\n        >>> t.set_wrap_mode('clip')\n        >>> t.wrap\n        'clip'\n        >>> t.render((6,)).text\n        [...'some w']\n        >>> t.wrap = 'any'  # Urwid 0.9.9 or later\n        >>> t.render((6,)).text\n        [...'some w', ...'ords  ']\n        >>> t.wrap = 'somehow'\n        Traceback (most recent call last):\n        TextError: Wrap mode 'somehow' not supported.\n        \"\"\"\n        if not self.layout.supports_wrap_mode(mode):\n            raise TextError(f\"Wrap mode {mode!r} not supported.\")\n        self._wrap_mode = mode\n        self._invalidate()\n\n    def set_layout(\n        self,\n        align: Literal[\"left\", \"center\", \"right\"] | Align,\n        wrap: Literal[\"space\", \"any\", \"clip\", \"ellipsis\"] | WrapMode,\n        layout=None,\n    ) -> None:\n        \"\"\"\n        Set the text layout object, alignment and wrapping modes at\n        the same time.\n\n        :type align: text alignment mode\n        :param wrap: typically 'space', 'any', 'clip' or 'ellipsis'\n        :type wrap: text wrapping mode\n        :param layout: defaults to a shared :class:`StandardTextLayout` instance\n        :type layout: text layout instance\n\n        >>> t = Text(u\"hi\")\n        >>> t.set_layout('right', 'clip')\n        >>> t\n        <Text flow widget 'hi' align='right' wrap='clip'>\n        \"\"\"\n        if layout is None:\n            layout = text_layout.default_layout\n        self._layout = layout\n        self.set_align_mode(align)\n        self.set_wrap_mode(wrap)\n\n    align = property(lambda self: self._align_mode, set_align_mode)\n    wrap = property(lambda self: self._wrap_mode, set_wrap_mode)\n\n    @property\n    def layout(self):\n        return self._layout\n\n    def render(self, size: tuple[int], focus: bool = False) -> TextCanvas:\n        \"\"\"\n        Render contents with wrapping and alignment.  Return canvas.\n\n        See :meth:`Widget.render` for parameter details.\n\n        >>> Text(u\"important things\").render((18,)).text # ... = b in Python 3\n        [...'important things  ']\n        >>> Text(u\"important things\").render((11,)).text\n        [...'important  ', ...'things     ']\n        \"\"\"\n        (maxcol,) = size\n        text, attr = self.get_text()\n        # assert isinstance(text, unicode)\n        trans = self.get_line_translation(maxcol, (text, attr))\n        return apply_text_layout(text, attr, trans, maxcol)\n\n    def rows(self, size: tuple[int], focus: bool = False) -> int:\n        \"\"\"\n        Return the number of rows the rendered text requires.\n\n        See :meth:`Widget.rows` for parameter details.\n\n        >>> Text(u\"important things\").rows((18,))\n        1\n        >>> Text(u\"important things\").rows((11,))\n        2\n        \"\"\"\n        (maxcol,) = size\n        return len(self.get_line_translation(maxcol))\n\n    def get_line_translation(self, maxcol: int, ta=None):\n        \"\"\"\n        Return layout structure used to map self.text to a canvas.\n        This method is used internally, but may be useful for\n        debugging custom layout classes.\n\n        :param maxcol: columns available for display\n        :type maxcol: int\n        :param ta: ``None`` or the (*text*, *display attributes*) tuple\n                   returned from :meth:`.get_text`\n        :type ta: text and display attributes\n        \"\"\"\n        if not self._cache_maxcol or self._cache_maxcol != maxcol:\n            self._update_cache_translation(maxcol, ta)\n        return self._cache_translation\n\n    def _update_cache_translation(self, maxcol: int, ta):\n        if ta:\n            text, attr = ta\n        else:\n            text, attr = self.get_text()\n        self._cache_maxcol = maxcol\n        self._cache_translation = self.layout.layout(text, maxcol, self._align_mode, self._wrap_mode)\n\n    def pack(self, size: tuple[int] | None = None, focus: bool = False) -> tuple[int, int]:\n        \"\"\"\n        Return the number of screen columns and rows required for\n        this Text widget to be displayed without wrapping or\n        clipping, as a single element tuple.\n\n        :param size: ``None`` for unlimited screen columns or (*maxcol*,) to\n                     specify a maximum column size\n        :type size: widget size\n\n        >>> Text(u\"important things\").pack()\n        (16, 1)\n        >>> Text(u\"important things\").pack((15,))\n        (9, 2)\n        >>> Text(u\"important things\").pack((8,))\n        (8, 2)\n        \"\"\"\n        text, attr = self.get_text()\n\n        if size is not None:\n            (maxcol,) = size\n            if not hasattr(self.layout, \"pack\"):\n                return size\n            trans = self.get_line_translation(maxcol, (text, attr))\n            cols = self.layout.pack(maxcol, trans)\n            return (cols, len(trans))\n\n        i = 0\n        cols = 0\n        while i < len(text):\n            j = text.find(\"\\n\", i)\n            if j == -1:\n                j = len(text)\n            c = calc_width(text, i, j)\n            if c > cols:\n                cols = c\n            i = j + 1\n        return (cols, text.count(\"\\n\") + 1)",
  "def __init__(\n        self,\n        markup,\n        align: Literal[\"left\", \"center\", \"right\"] | Align = Align.LEFT,\n        wrap: Literal[\"space\", \"any\", \"clip\", \"ellipsis\"] | WrapMode = WrapMode.SPACE,\n        layout: text_layout.TextLayout | None = None,\n    ) -> None:\n        \"\"\"\n        :param markup: content of text widget, one of:\n\n            bytes or unicode\n              text to be displayed\n\n            (*display attribute*, *text markup*)\n              *text markup* with *display attribute* applied to all parts\n              of *text markup* with no display attribute already applied\n\n            [*text markup*, *text markup*, ... ]\n              all *text markup* in the list joined together\n\n        :type markup: :ref:`text-markup`\n        :param align: typically ``'left'``, ``'center'`` or ``'right'``\n        :type align: text alignment mode\n        :param wrap: typically ``'space'``, ``'any'``, ``'clip'`` or ``'ellipsis'``\n        :type wrap: text wrapping mode\n        :param layout: defaults to a shared :class:`StandardTextLayout` instance\n        :type layout: text layout instance\n\n        >>> Text(u\"Hello\")\n        <Text flow widget 'Hello'>\n        >>> t = Text(('bold', u\"stuff\"), 'right', 'any')\n        >>> t\n        <Text flow widget 'stuff' align='right' wrap='any'>\n        >>> print(t.text)\n        stuff\n        >>> t.attrib\n        [('bold', 5)]\n        \"\"\"\n        super().__init__()\n        self._cache_maxcol = None\n        self.set_text(markup)\n        self.set_layout(align, wrap, layout)",
  "def _repr_words(self) -> list[str]:\n        \"\"\"\n        Show the text in the repr in python3 format (b prefix for byte strings) and truncate if it's too long\n        \"\"\"\n        first = super()._repr_words()\n        text = self.get_text()[0]\n        rest = repr(text)\n        if len(rest) > self._repr_content_length_max:\n            rest = (\n                rest[: self._repr_content_length_max * 2 // 3 - 3] + \"...\" + rest[-self._repr_content_length_max // 3 :]\n            )\n        return [*first, rest]",
  "def _repr_attrs(self):\n        attrs = dict(\n            super()._repr_attrs(),\n            align=self._align_mode,\n            wrap=self._wrap_mode,\n        )\n        return remove_defaults(attrs, Text.__init__)",
  "def _invalidate(self) -> None:\n        self._cache_maxcol = None\n        super()._invalidate()",
  "def set_text(self, markup):\n        \"\"\"\n        Set content of text widget.\n\n        :param markup: see :class:`Text` for description.\n        :type markup: text markup\n\n        >>> t = Text(u\"foo\")\n        >>> print(t.text)\n        foo\n        >>> t.set_text(u\"bar\")\n        >>> print(t.text)\n        bar\n        >>> t.text = u\"baz\"  # not supported because text stores text but set_text() takes markup\n        Traceback (most recent call last):\n        AttributeError: can't set attribute\n        \"\"\"\n        self._text, self._attrib = decompose_tagmarkup(markup)\n        self._invalidate()",
  "def get_text(self):\n        \"\"\"\n        :returns: (*text*, *display attributes*)\n\n            *text*\n              complete bytes/unicode content of text widget\n\n            *display attributes*\n              run length encoded display attributes for *text*, eg.\n              ``[('attr1', 10), ('attr2', 5)]``\n\n        >>> Text(u\"Hello\").get_text() # ... = u in Python 2\n        (...'Hello', [])\n        >>> Text(('bright', u\"Headline\")).get_text()\n        (...'Headline', [('bright', 8)])\n        >>> Text([('a', u\"one\"), u\"two\", ('b', u\"three\")]).get_text()\n        (...'onetwothree', [('a', 3), (None, 3), ('b', 5)])\n        \"\"\"\n        return self._text, self._attrib",
  "def text(self) -> str:\n        \"\"\"\n        Read-only property returning the complete bytes/unicode content\n        of this widget\n        \"\"\"\n        return self.get_text()[0]",
  "def attrib(self):\n        \"\"\"\n        Read-only property returning the run-length encoded display\n        attributes of this widget\n        \"\"\"\n        return self.get_text()[1]",
  "def set_align_mode(self, mode: Literal[\"left\", \"center\", \"right\"] | Align) -> None:\n        \"\"\"\n        Set text alignment mode. Supported modes depend on text layout\n        object in use but defaults to a :class:`StandardTextLayout` instance\n\n        :param mode: typically ``'left'``, ``'center'`` or ``'right'``\n        :type mode: text alignment mode\n\n        >>> t = Text(u\"word\")\n        >>> t.set_align_mode('right')\n        >>> t.align\n        'right'\n        >>> t.render((10,)).text # ... = b in Python 3\n        [...'      word']\n        >>> t.align = 'center'\n        >>> t.render((10,)).text\n        [...'   word   ']\n        >>> t.align = 'somewhere'\n        Traceback (most recent call last):\n        TextError: Alignment mode 'somewhere' not supported.\n        \"\"\"\n        if not self.layout.supports_align_mode(mode):\n            raise TextError(f\"Alignment mode {mode!r} not supported.\")\n        self._align_mode = mode\n        self._invalidate()",
  "def set_wrap_mode(self, mode: Literal[\"space\", \"any\", \"clip\", \"ellipsis\"] | WrapMode) -> None:\n        \"\"\"\n        Set text wrapping mode. Supported modes depend on text layout\n        object in use but defaults to a :class:`StandardTextLayout` instance\n\n        :param mode: typically ``'space'``, ``'any'``, ``'clip'`` or ``'ellipsis'``\n        :type mode: text wrapping mode\n\n        >>> t = Text(u\"some words\")\n        >>> t.render((6,)).text # ... = b in Python 3\n        [...'some  ', ...'words ']\n        >>> t.set_wrap_mode('clip')\n        >>> t.wrap\n        'clip'\n        >>> t.render((6,)).text\n        [...'some w']\n        >>> t.wrap = 'any'  # Urwid 0.9.9 or later\n        >>> t.render((6,)).text\n        [...'some w', ...'ords  ']\n        >>> t.wrap = 'somehow'\n        Traceback (most recent call last):\n        TextError: Wrap mode 'somehow' not supported.\n        \"\"\"\n        if not self.layout.supports_wrap_mode(mode):\n            raise TextError(f\"Wrap mode {mode!r} not supported.\")\n        self._wrap_mode = mode\n        self._invalidate()",
  "def set_layout(\n        self,\n        align: Literal[\"left\", \"center\", \"right\"] | Align,\n        wrap: Literal[\"space\", \"any\", \"clip\", \"ellipsis\"] | WrapMode,\n        layout=None,\n    ) -> None:\n        \"\"\"\n        Set the text layout object, alignment and wrapping modes at\n        the same time.\n\n        :type align: text alignment mode\n        :param wrap: typically 'space', 'any', 'clip' or 'ellipsis'\n        :type wrap: text wrapping mode\n        :param layout: defaults to a shared :class:`StandardTextLayout` instance\n        :type layout: text layout instance\n\n        >>> t = Text(u\"hi\")\n        >>> t.set_layout('right', 'clip')\n        >>> t\n        <Text flow widget 'hi' align='right' wrap='clip'>\n        \"\"\"\n        if layout is None:\n            layout = text_layout.default_layout\n        self._layout = layout\n        self.set_align_mode(align)\n        self.set_wrap_mode(wrap)",
  "def layout(self):\n        return self._layout",
  "def render(self, size: tuple[int], focus: bool = False) -> TextCanvas:\n        \"\"\"\n        Render contents with wrapping and alignment.  Return canvas.\n\n        See :meth:`Widget.render` for parameter details.\n\n        >>> Text(u\"important things\").render((18,)).text # ... = b in Python 3\n        [...'important things  ']\n        >>> Text(u\"important things\").render((11,)).text\n        [...'important  ', ...'things     ']\n        \"\"\"\n        (maxcol,) = size\n        text, attr = self.get_text()\n        # assert isinstance(text, unicode)\n        trans = self.get_line_translation(maxcol, (text, attr))\n        return apply_text_layout(text, attr, trans, maxcol)",
  "def rows(self, size: tuple[int], focus: bool = False) -> int:\n        \"\"\"\n        Return the number of rows the rendered text requires.\n\n        See :meth:`Widget.rows` for parameter details.\n\n        >>> Text(u\"important things\").rows((18,))\n        1\n        >>> Text(u\"important things\").rows((11,))\n        2\n        \"\"\"\n        (maxcol,) = size\n        return len(self.get_line_translation(maxcol))",
  "def get_line_translation(self, maxcol: int, ta=None):\n        \"\"\"\n        Return layout structure used to map self.text to a canvas.\n        This method is used internally, but may be useful for\n        debugging custom layout classes.\n\n        :param maxcol: columns available for display\n        :type maxcol: int\n        :param ta: ``None`` or the (*text*, *display attributes*) tuple\n                   returned from :meth:`.get_text`\n        :type ta: text and display attributes\n        \"\"\"\n        if not self._cache_maxcol or self._cache_maxcol != maxcol:\n            self._update_cache_translation(maxcol, ta)\n        return self._cache_translation",
  "def _update_cache_translation(self, maxcol: int, ta):\n        if ta:\n            text, attr = ta\n        else:\n            text, attr = self.get_text()\n        self._cache_maxcol = maxcol\n        self._cache_translation = self.layout.layout(text, maxcol, self._align_mode, self._wrap_mode)",
  "def pack(self, size: tuple[int] | None = None, focus: bool = False) -> tuple[int, int]:\n        \"\"\"\n        Return the number of screen columns and rows required for\n        this Text widget to be displayed without wrapping or\n        clipping, as a single element tuple.\n\n        :param size: ``None`` for unlimited screen columns or (*maxcol*,) to\n                     specify a maximum column size\n        :type size: widget size\n\n        >>> Text(u\"important things\").pack()\n        (16, 1)\n        >>> Text(u\"important things\").pack((15,))\n        (9, 2)\n        >>> Text(u\"important things\").pack((8,))\n        (8, 2)\n        \"\"\"\n        text, attr = self.get_text()\n\n        if size is not None:\n            (maxcol,) = size\n            if not hasattr(self.layout, \"pack\"):\n                return size\n            trans = self.get_line_translation(maxcol, (text, attr))\n            cols = self.layout.pack(maxcol, trans)\n            return (cols, len(trans))\n\n        i = 0\n        cols = 0\n        while i < len(text):\n            j = text.find(\"\\n\", i)\n            if j == -1:\n                j = len(text)\n            c = calc_width(text, i, j)\n            if c > cols:\n                cols = c\n            i = j + 1\n        return (cols, text.count(\"\\n\") + 1)",
  "class CantUseExternalLoop(Exception):\n    pass",
  "class MainLoop:\n    \"\"\"\n    This is the standard main loop implementation for a single interactive\n    session.\n\n    :param widget: the topmost widget used for painting the screen, stored as\n                   :attr:`widget` and may be modified. Must be a box widget.\n    :type widget: widget instance\n\n    :param palette: initial palette for screen\n    :type palette: iterable of palette entries\n\n    :param screen: screen to use, default is a new :class:`raw_display.Screen`\n                   instance; stored as :attr:`screen`\n    :type screen: display module screen instance\n\n    :param handle_mouse: ``True`` to ask :attr:`.screen` to process mouse events\n    :type handle_mouse: bool\n\n    :param input_filter: a function to filter input before sending it to\n                   :attr:`.widget`, called from :meth:`.input_filter`\n    :type input_filter: callable\n\n    :param unhandled_input: a function called when input is not handled by\n                            :attr:`.widget`, called from :meth:`.unhandled_input`\n    :type unhandled_input: callable\n\n    :param event_loop: if :attr:`.screen` supports external an event loop it may be\n                       given here, default is a new :class:`SelectEventLoop` instance;\n                       stored as :attr:`.event_loop`\n    :type event_loop: event loop instance\n\n    :param pop_ups: `True` to wrap :attr:`.widget` with a :class:`PopUpTarget`\n                    instance to allow any widget to open a pop-up anywhere on the screen\n    :type pop_ups: boolean\n\n\n    .. attribute:: screen\n\n        The screen object this main loop uses for screen updates and reading input\n\n    .. attribute:: event_loop\n\n        The event loop object this main loop uses for waiting on alarms and IO\n    \"\"\"\n\n    def __init__(\n        self,\n        widget: Widget,\n        palette=(),\n        screen: BaseScreen | None = None,\n        handle_mouse: bool = True,\n        input_filter: Callable[[list[str], list[int]], list[str]] | None = None,\n        unhandled_input: Callable[[str | tuple[str, int, int, int]], bool] | None = None,\n        event_loop=None,\n        pop_ups: bool = False,\n    ):\n        self._widget = widget\n        self.handle_mouse = handle_mouse\n        self.pop_ups = pop_ups  # triggers property setting side-effect\n\n        if not screen:\n            screen = raw_display.Screen()\n\n        if palette:\n            screen.register_palette(palette)\n\n        self.screen = screen\n        self.screen_size = None\n\n        self._unhandled_input = unhandled_input\n        self._input_filter = input_filter\n\n        if not hasattr(screen, \"hook_event_loop\") and event_loop is not None:\n            raise NotImplementedError(f\"screen object passed {screen!r} does not support external event loops\")\n        if event_loop is None:\n            event_loop = SelectEventLoop()\n        self.event_loop = event_loop\n\n        if hasattr(self.screen, \"signal_handler_setter\"):\n            # Tell the screen what function it must use to set\n            # signal handlers\n            self.screen.signal_handler_setter = self.event_loop.set_signal_handler\n\n        self._watch_pipes: dict[int, tuple[Callable[[], typing.Any], int]] = {}\n\n    @property\n    def widget(self) -> Widget:\n        \"\"\"\n        Property for the topmost widget used to draw the screen.\n        This must be a box widget.\n        \"\"\"\n        return self._widget\n\n    @widget.setter\n    def widget(self, widget: Widget) -> None:\n        self._widget = widget\n        if self.pop_ups:\n            self._topmost_widget.original_widget = self._widget\n        else:\n            self._topmost_widget = self._widget\n\n    def _set_widget(self, widget: Widget) -> None:\n        warnings.warn(\n            f\"method `{self.__class__.__name__}._set_widget` is deprecated, \"\n            f\"please use `{self.__class__.__name__}.widget` property\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        self.widget = widget\n\n    @property\n    def pop_ups(self):\n        return self._pop_ups\n\n    @pop_ups.setter\n    def pop_ups(self, pop_ups) -> None:\n        self._pop_ups = pop_ups\n        if pop_ups:\n            self._topmost_widget = PopUpTarget(self._widget)\n        else:\n            self._topmost_widget = self._widget\n\n    def _set_pop_ups(self, pop_ups) -> None:\n        warnings.warn(\n            f\"method `{self.__class__.__name__}._set_pop_ups` is deprecated, \"\n            f\"please use `{self.__class__.__name__}.pop_ups` property\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        self.pop_ups = pop_ups\n\n    def set_alarm_in(self, sec, callback, user_data=None):\n        \"\"\"\n        Schedule an alarm in *sec* seconds that will call *callback* from the\n        within the :meth:`run` method.\n\n        :param sec: seconds until alarm\n        :type sec: float\n        :param callback: function to call with two parameters: this main loop\n                         object and *user_data*\n        :type callback: callable\n        \"\"\"\n\n        def cb():\n            callback(self, user_data)\n\n        return self.event_loop.alarm(sec, cb)\n\n    def set_alarm_at(self, tm, callback, user_data=None):\n        \"\"\"\n        Schedule an alarm at *tm* time that will call *callback* from the\n        within the :meth:`run` function. Returns a handle that may be passed to\n        :meth:`remove_alarm`.\n\n        :param tm: time to call callback e.g. ``time.time() + 5``\n        :type tm: float\n        :param callback: function to call with two parameters: this main loop\n                         object and *user_data*\n        :type callback: callable\n        \"\"\"\n\n        def cb():\n            callback(self, user_data)\n\n        return self.event_loop.alarm(tm - time.time(), cb)\n\n    def remove_alarm(self, handle):\n        \"\"\"\n        Remove an alarm. Return ``True`` if *handle* was found, ``False``\n        otherwise.\n        \"\"\"\n        return self.event_loop.remove_alarm(handle)\n\n    def watch_pipe(self, callback):\n        \"\"\"\n        Create a pipe for use by a subprocess or thread to trigger a callback\n        in the process/thread running the main loop.\n\n        :param callback: function taking one parameter to call from within\n                         the process/thread running the main loop\n        :type callback: callable\n\n        This method returns a file descriptor attached to the write end of a\n        pipe. The read end of the pipe is added to the list of files\n        :attr:`event_loop` is watching. When data is written to the pipe the\n        callback function will be called and passed a single value containing\n        data read from the pipe.\n\n        This method may be used any time you want to update widgets from\n        another thread or subprocess.\n\n        Data may be written to the returned file descriptor with\n        ``os.write(fd, data)``. Ensure that data is less than 512 bytes (or 4K\n        on Linux) so that the callback will be triggered just once with the\n        complete value of data passed in.\n\n        If the callback returns ``False`` then the watch will be removed from\n        :attr:`event_loop` and the read end of the pipe will be closed. You\n        are responsible for closing the write end of the pipe with\n        ``os.close(fd)``.\n        \"\"\"\n        pipe_rd, pipe_wr = os.pipe()\n        fcntl.fcntl(pipe_rd, fcntl.F_SETFL, os.O_NONBLOCK)\n        watch_handle = None\n\n        def cb() -> None:\n            data = os.read(pipe_rd, PIPE_BUFFER_READ_SIZE)\n            rval = callback(data)\n            if rval is False:\n                self.event_loop.remove_watch_file(watch_handle)\n                os.close(pipe_rd)\n\n        watch_handle = self.event_loop.watch_file(pipe_rd, cb)\n        self._watch_pipes[pipe_wr] = (watch_handle, pipe_rd)\n        return pipe_wr\n\n    def remove_watch_pipe(self, write_fd):\n        \"\"\"\n        Close the read end of the pipe and remove the watch created by\n        :meth:`watch_pipe`. You are responsible for closing the write end of\n        the pipe.\n\n        Returns ``True`` if the watch pipe exists, ``False`` otherwise\n        \"\"\"\n        try:\n            watch_handle, pipe_rd = self._watch_pipes.pop(write_fd)\n        except KeyError:\n            return False\n\n        if not self.event_loop.remove_watch_file(watch_handle):\n            return False\n        os.close(pipe_rd)\n        return True\n\n    def watch_file(self, fd, callback):\n        \"\"\"\n        Call *callback* when *fd* has some data to read. No parameters are\n        passed to callback.\n\n        Returns a handle that may be passed to :meth:`remove_watch_file`.\n        \"\"\"\n        return self.event_loop.watch_file(fd, callback)\n\n    def remove_watch_file(self, handle):\n        \"\"\"\n        Remove a watch file. Returns ``True`` if the watch file\n        exists, ``False`` otherwise.\n        \"\"\"\n        return self.event_loop.remove_watch_file(handle)\n\n    def run(self):\n        \"\"\"\n        Start the main loop handling input events and updating the screen. The\n        loop will continue until an :exc:`ExitMainLoop` exception is raised.\n\n        If you would prefer to manage the event loop yourself, don't use this\n        method.  Instead, call :meth:`start` before starting the event loop,\n        and :meth:`stop` once it's finished.\n        \"\"\"\n        with contextlib.suppress(ExitMainLoop):\n            self._run()\n\n    def _test_run(self):\n        \"\"\"\n        >>> w = _refl(\"widget\")   # _refl prints out function calls\n        >>> w.render_rval = \"fake canvas\"  # *_rval is used for return values\n        >>> scr = _refl(\"screen\")\n        >>> scr.get_input_descriptors_rval = [42]\n        >>> scr.get_cols_rows_rval = (20, 10)\n        >>> scr.started = True\n        >>> scr._urwid_signals = {}\n        >>> evl = _refl(\"event_loop\")\n        >>> evl.enter_idle_rval = 1\n        >>> evl.watch_file_rval = 2\n        >>> ml = MainLoop(w, [], scr, event_loop=evl)\n        >>> ml.run()    # doctest:+ELLIPSIS\n        screen.start()\n        screen.set_mouse_tracking()\n        screen.unhook_event_loop(...)\n        screen.hook_event_loop(...)\n        event_loop.enter_idle(<bound method MainLoop.entering_idle...>)\n        event_loop.run()\n        event_loop.remove_enter_idle(1)\n        screen.unhook_event_loop(...)\n        screen.stop()\n        >>> ml.draw_screen()    # doctest:+ELLIPSIS\n        screen.get_cols_rows()\n        widget.render((20, 10), focus=True)\n        screen.draw_screen((20, 10), 'fake canvas')\n        \"\"\"\n\n    def start(self):\n        \"\"\"\n        Sets up the main loop, hooking into the event loop where necessary.\n        Starts the :attr:`screen` if it hasn't already been started.\n\n        If you want to control starting and stopping the event loop yourself,\n        you should call this method before starting, and call `stop` once the\n        loop has finished.  You may also use this method as a context manager,\n        which will stop the loop automatically at the end of the block:\n\n            with main_loop.start():\n                ...\n\n        Note that some event loop implementations don't handle exceptions\n        specially if you manage the event loop yourself.  In particular, the\n        Twisted and asyncio loops won't stop automatically when\n        :exc:`ExitMainLoop` (or anything else) is raised.\n        \"\"\"\n\n        self.screen.start()\n\n        if self.handle_mouse:\n            self.screen.set_mouse_tracking()\n\n        if not hasattr(self.screen, \"hook_event_loop\"):\n            raise CantUseExternalLoop(\"Screen {0!r} doesn't support external event loops\")\n\n        with contextlib.suppress(NameError):\n            signals.connect_signal(self.screen, INPUT_DESCRIPTORS_CHANGED, self._reset_input_descriptors)\n\n        # watch our input descriptors\n        self._reset_input_descriptors()\n        self.idle_handle = self.event_loop.enter_idle(self.entering_idle)\n\n        # the screen is redrawn automatically after input and alarms,\n        # however, there can be none of those at the start,\n        # so draw the initial screen here unconditionally\n        self.event_loop.alarm(0, self.entering_idle)\n\n        return StoppingContext(self)\n\n    def stop(self) -> None:\n        \"\"\"\n        Cleans up any hooks added to the event loop.  Only call this if you're\n        managing the event loop yourself, after the loop stops.\n        \"\"\"\n\n        self.event_loop.remove_enter_idle(self.idle_handle)\n        del self.idle_handle\n        signals.disconnect_signal(self.screen, INPUT_DESCRIPTORS_CHANGED, self._reset_input_descriptors)\n        self.screen.unhook_event_loop(self.event_loop)\n\n        self.screen.stop()\n\n    def _reset_input_descriptors(self) -> None:\n        self.screen.unhook_event_loop(self.event_loop)\n        self.screen.hook_event_loop(self.event_loop, self._update)\n\n    def _run(self) -> None:\n        try:\n            self.start()\n        except CantUseExternalLoop:\n            try:\n                self._run_screen_event_loop()\n                return\n            finally:\n                self.screen.stop()\n\n        try:\n            self.event_loop.run()\n        except:\n            self.screen.stop()  # clean up screen control\n            raise\n        self.stop()\n\n    def _update(self, keys: list[str], raw: list[int]) -> None:\n        \"\"\"\n        >>> w = _refl(\"widget\")\n        >>> w.selectable_rval = True\n        >>> w.mouse_event_rval = True\n        >>> scr = _refl(\"screen\")\n        >>> scr.get_cols_rows_rval = (15, 5)\n        >>> evl = _refl(\"event_loop\")\n        >>> ml = MainLoop(w, [], scr, event_loop=evl)\n        >>> ml._input_timeout = \"old timeout\"\n        >>> ml._update(['y'], [121])    # doctest:+ELLIPSIS\n        screen.get_cols_rows()\n        widget.selectable()\n        widget.keypress((15, 5), 'y')\n        >>> ml._update([(\"mouse press\", 1, 5, 4)], [])\n        widget.mouse_event((15, 5), 'mouse press', 1, 5, 4, focus=True)\n        >>> ml._update([], [])\n        \"\"\"\n        keys = self.input_filter(keys, raw)\n\n        if keys:\n            self.process_input(keys)\n            if \"window resize\" in keys:\n                self.screen_size = None\n\n    def _run_screen_event_loop(self) -> None:\n        \"\"\"\n        This method is used when the screen does not support using\n        external event loops.\n\n        The alarms stored in the SelectEventLoop in :attr:`event_loop`\n        are modified by this method.\n        \"\"\"\n        next_alarm = None\n\n        while True:\n            self.draw_screen()\n\n            if not next_alarm and self.event_loop._alarms:\n                next_alarm = heapq.heappop(self.event_loop._alarms)\n\n            keys: list[str] = []\n            raw: list[int] = []\n            while not keys:\n                if next_alarm:\n                    sec = max(0, next_alarm[0] - time.time())\n                    self.screen.set_input_timeouts(sec)\n                else:\n                    self.screen.set_input_timeouts(None)\n                keys, raw = self.screen.get_input(True)\n                if not keys and next_alarm:\n                    sec = next_alarm[0] - time.time()\n                    if sec <= 0:\n                        break\n\n            keys = self.input_filter(keys, raw)\n\n            if keys:\n                self.process_input(keys)\n\n            while next_alarm:\n                sec = next_alarm[0] - time.time()\n                if sec > 0:\n                    break\n                tm, tie_break, callback = next_alarm\n                callback()\n\n                if self.event_loop._alarms:\n                    next_alarm = heapq.heappop(self.event_loop._alarms)\n                else:\n                    next_alarm = None\n\n            if \"window resize\" in keys:\n                self.screen_size = None\n\n    def _test_run_screen_event_loop(self):\n        \"\"\"\n        >>> w = _refl(\"widget\")\n        >>> scr = _refl(\"screen\")\n        >>> scr.get_cols_rows_rval = (10, 5)\n        >>> scr.get_input_rval = [], []\n        >>> ml = MainLoop(w, screen=scr)\n        >>> def stop_now(loop, data):\n        ...     raise ExitMainLoop()\n        >>> handle = ml.set_alarm_in(0, stop_now)\n        >>> try:\n        ...     ml._run_screen_event_loop()\n        ... except ExitMainLoop:\n        ...     pass\n        screen.get_cols_rows()\n        widget.render((10, 5), focus=True)\n        screen.draw_screen((10, 5), None)\n        screen.set_input_timeouts(0)\n        screen.get_input(True)\n        \"\"\"\n\n    def process_input(self, keys: Iterable[str | tuple[str, int, int, int]]) -> bool:\n        \"\"\"\n        This method will pass keyboard input and mouse events to :attr:`widget`.\n        This method is called automatically from the :meth:`run` method when\n        there is input, but may also be called to simulate input from the user.\n\n        *keys* is a list of input returned from :attr:`screen`'s get_input()\n        or get_input_nonblocking() methods.\n\n        Returns ``True`` if any key was handled by a widget or the\n        :meth:`unhandled_input` method.\n        \"\"\"\n        if not self.screen_size:\n            self.screen_size = self.screen.get_cols_rows()\n\n        something_handled = False\n\n        for k in keys:\n            if k == \"window resize\":\n                continue\n\n            if isinstance(k, str):\n                if self._topmost_widget.selectable():\n                    k = self._topmost_widget.keypress(self.screen_size, k)  # noqa: PLW2901\n\n            elif isinstance(k, tuple):\n                if is_mouse_event(k):\n                    event, button, col, row = k\n                    if hasattr(self._topmost_widget, \"mouse_event\") and self._topmost_widget.mouse_event(\n                        self.screen_size,\n                        event,\n                        button,\n                        col,\n                        row,\n                        focus=True,\n                    ):\n                        k = None  # noqa: PLW2901\n\n            else:\n                raise TypeError(f\"{k!r} is not str | tuple[str, int, int, int]\")\n\n            if k:\n                if command_map[k] == Command.REDRAW_SCREEN:\n                    self.screen.clear()\n                    something_handled = True\n                else:\n                    something_handled |= bool(self.unhandled_input(k))\n            else:\n                something_handled = True\n\n        return something_handled\n\n    def _test_process_input(self):\n        \"\"\"\n        >>> w = _refl(\"widget\")\n        >>> w.selectable_rval = True\n        >>> scr = _refl(\"screen\")\n        >>> scr.get_cols_rows_rval = (10, 5)\n        >>> ml = MainLoop(w, [], scr)\n        >>> ml.process_input(['enter', ('mouse drag', 1, 14, 20)])\n        screen.get_cols_rows()\n        widget.selectable()\n        widget.keypress((10, 5), 'enter')\n        widget.mouse_event((10, 5), 'mouse drag', 1, 14, 20, focus=True)\n        True\n        \"\"\"\n\n    def input_filter(self, keys: list[str], raw: list[int]) -> list[str]:\n        \"\"\"\n        This function is passed each all the input events and raw keystroke\n        values. These values are passed to the *input_filter* function\n        passed to the constructor. That function must return a list of keys to\n        be passed to the widgets to handle. If no *input_filter* was\n        defined this implementation will return all the input events.\n        \"\"\"\n        if self._input_filter:\n            return self._input_filter(keys, raw)\n        return keys\n\n    def unhandled_input(self, data: str | tuple[str, int, int, int]) -> bool:\n        \"\"\"\n        This function is called with any input that was not handled by the\n        widgets, and calls the *unhandled_input* function passed to the\n        constructor. If no *unhandled_input* was defined then the input\n        will be ignored.\n\n        *input* is the keyboard or mouse input.\n\n        The *unhandled_input* function should return ``True`` if it handled\n        the input.\n        \"\"\"\n        if self._unhandled_input:\n            return self._unhandled_input(data)\n        return False\n\n    def entering_idle(self):\n        \"\"\"\n        This method is called whenever the event loop is about to enter the\n        idle state. :meth:`draw_screen` is called here to update the\n        screen when anything has changed.\n        \"\"\"\n        if self.screen.started:\n            self.draw_screen()\n\n    def draw_screen(self):\n        \"\"\"\n        Render the widgets and paint the screen. This method is called\n        automatically from :meth:`entering_idle`.\n\n        If you modify the widgets displayed outside of handling input or\n        responding to an alarm you will need to call this method yourself\n        to repaint the screen.\n        \"\"\"\n        if not self.screen_size:\n            self.screen_size = self.screen.get_cols_rows()\n\n        canvas = self._topmost_widget.render(self.screen_size, focus=True)\n        self.screen.draw_screen(self.screen_size, canvas)",
  "def _refl(name: str, rval=None, loop_exit=False):\n    \"\"\"\n    This function is used to test the main loop classes.\n\n    >>> scr = _refl(\"screen\")\n    >>> scr.function(\"argument\")\n    screen.function('argument')\n    >>> scr.callme(when=\"now\")\n    screen.callme(when='now')\n    >>> scr.want_something_rval = 42\n    >>> x = scr.want_something()\n    screen.want_something()\n    >>> x\n    42\n\n    \"\"\"\n\n    class Reflect:\n        def __init__(self, name: str, rval=None):\n            self._name = name\n            self._rval = rval\n\n        def __call__(self, *argl, **argd):\n            args = \", \".join([repr(a) for a in argl])\n            if args and argd:\n                args = f\"{args}, \"\n            args += \", \".join([f\"{k}={v!r}\" for k, v in argd.items()])\n            print(f\"{self._name}({args})\")\n            if loop_exit:\n                raise ExitMainLoop()\n            return self._rval\n\n        def __getattr__(self, attr):\n            if attr.endswith(\"_rval\"):\n                raise AttributeError()\n            # print(self._name+\".\"+attr)\n            if hasattr(self, f\"{attr}_rval\"):\n                return Reflect(f\"{self._name}.{attr}\", getattr(self, f\"{attr}_rval\"))\n            return Reflect(f\"{self._name}.{attr}\")\n\n    return Reflect(name)",
  "def _test():\n    import doctest\n\n    doctest.testmod()",
  "def __init__(\n        self,\n        widget: Widget,\n        palette=(),\n        screen: BaseScreen | None = None,\n        handle_mouse: bool = True,\n        input_filter: Callable[[list[str], list[int]], list[str]] | None = None,\n        unhandled_input: Callable[[str | tuple[str, int, int, int]], bool] | None = None,\n        event_loop=None,\n        pop_ups: bool = False,\n    ):\n        self._widget = widget\n        self.handle_mouse = handle_mouse\n        self.pop_ups = pop_ups  # triggers property setting side-effect\n\n        if not screen:\n            screen = raw_display.Screen()\n\n        if palette:\n            screen.register_palette(palette)\n\n        self.screen = screen\n        self.screen_size = None\n\n        self._unhandled_input = unhandled_input\n        self._input_filter = input_filter\n\n        if not hasattr(screen, \"hook_event_loop\") and event_loop is not None:\n            raise NotImplementedError(f\"screen object passed {screen!r} does not support external event loops\")\n        if event_loop is None:\n            event_loop = SelectEventLoop()\n        self.event_loop = event_loop\n\n        if hasattr(self.screen, \"signal_handler_setter\"):\n            # Tell the screen what function it must use to set\n            # signal handlers\n            self.screen.signal_handler_setter = self.event_loop.set_signal_handler\n\n        self._watch_pipes: dict[int, tuple[Callable[[], typing.Any], int]] = {}",
  "def widget(self) -> Widget:\n        \"\"\"\n        Property for the topmost widget used to draw the screen.\n        This must be a box widget.\n        \"\"\"\n        return self._widget",
  "def widget(self, widget: Widget) -> None:\n        self._widget = widget\n        if self.pop_ups:\n            self._topmost_widget.original_widget = self._widget\n        else:\n            self._topmost_widget = self._widget",
  "def _set_widget(self, widget: Widget) -> None:\n        warnings.warn(\n            f\"method `{self.__class__.__name__}._set_widget` is deprecated, \"\n            f\"please use `{self.__class__.__name__}.widget` property\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        self.widget = widget",
  "def pop_ups(self):\n        return self._pop_ups",
  "def pop_ups(self, pop_ups) -> None:\n        self._pop_ups = pop_ups\n        if pop_ups:\n            self._topmost_widget = PopUpTarget(self._widget)\n        else:\n            self._topmost_widget = self._widget",
  "def _set_pop_ups(self, pop_ups) -> None:\n        warnings.warn(\n            f\"method `{self.__class__.__name__}._set_pop_ups` is deprecated, \"\n            f\"please use `{self.__class__.__name__}.pop_ups` property\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        self.pop_ups = pop_ups",
  "def set_alarm_in(self, sec, callback, user_data=None):\n        \"\"\"\n        Schedule an alarm in *sec* seconds that will call *callback* from the\n        within the :meth:`run` method.\n\n        :param sec: seconds until alarm\n        :type sec: float\n        :param callback: function to call with two parameters: this main loop\n                         object and *user_data*\n        :type callback: callable\n        \"\"\"\n\n        def cb():\n            callback(self, user_data)\n\n        return self.event_loop.alarm(sec, cb)",
  "def set_alarm_at(self, tm, callback, user_data=None):\n        \"\"\"\n        Schedule an alarm at *tm* time that will call *callback* from the\n        within the :meth:`run` function. Returns a handle that may be passed to\n        :meth:`remove_alarm`.\n\n        :param tm: time to call callback e.g. ``time.time() + 5``\n        :type tm: float\n        :param callback: function to call with two parameters: this main loop\n                         object and *user_data*\n        :type callback: callable\n        \"\"\"\n\n        def cb():\n            callback(self, user_data)\n\n        return self.event_loop.alarm(tm - time.time(), cb)",
  "def remove_alarm(self, handle):\n        \"\"\"\n        Remove an alarm. Return ``True`` if *handle* was found, ``False``\n        otherwise.\n        \"\"\"\n        return self.event_loop.remove_alarm(handle)",
  "def watch_pipe(self, callback):\n        \"\"\"\n        Create a pipe for use by a subprocess or thread to trigger a callback\n        in the process/thread running the main loop.\n\n        :param callback: function taking one parameter to call from within\n                         the process/thread running the main loop\n        :type callback: callable\n\n        This method returns a file descriptor attached to the write end of a\n        pipe. The read end of the pipe is added to the list of files\n        :attr:`event_loop` is watching. When data is written to the pipe the\n        callback function will be called and passed a single value containing\n        data read from the pipe.\n\n        This method may be used any time you want to update widgets from\n        another thread or subprocess.\n\n        Data may be written to the returned file descriptor with\n        ``os.write(fd, data)``. Ensure that data is less than 512 bytes (or 4K\n        on Linux) so that the callback will be triggered just once with the\n        complete value of data passed in.\n\n        If the callback returns ``False`` then the watch will be removed from\n        :attr:`event_loop` and the read end of the pipe will be closed. You\n        are responsible for closing the write end of the pipe with\n        ``os.close(fd)``.\n        \"\"\"\n        pipe_rd, pipe_wr = os.pipe()\n        fcntl.fcntl(pipe_rd, fcntl.F_SETFL, os.O_NONBLOCK)\n        watch_handle = None\n\n        def cb() -> None:\n            data = os.read(pipe_rd, PIPE_BUFFER_READ_SIZE)\n            rval = callback(data)\n            if rval is False:\n                self.event_loop.remove_watch_file(watch_handle)\n                os.close(pipe_rd)\n\n        watch_handle = self.event_loop.watch_file(pipe_rd, cb)\n        self._watch_pipes[pipe_wr] = (watch_handle, pipe_rd)\n        return pipe_wr",
  "def remove_watch_pipe(self, write_fd):\n        \"\"\"\n        Close the read end of the pipe and remove the watch created by\n        :meth:`watch_pipe`. You are responsible for closing the write end of\n        the pipe.\n\n        Returns ``True`` if the watch pipe exists, ``False`` otherwise\n        \"\"\"\n        try:\n            watch_handle, pipe_rd = self._watch_pipes.pop(write_fd)\n        except KeyError:\n            return False\n\n        if not self.event_loop.remove_watch_file(watch_handle):\n            return False\n        os.close(pipe_rd)\n        return True",
  "def watch_file(self, fd, callback):\n        \"\"\"\n        Call *callback* when *fd* has some data to read. No parameters are\n        passed to callback.\n\n        Returns a handle that may be passed to :meth:`remove_watch_file`.\n        \"\"\"\n        return self.event_loop.watch_file(fd, callback)",
  "def remove_watch_file(self, handle):\n        \"\"\"\n        Remove a watch file. Returns ``True`` if the watch file\n        exists, ``False`` otherwise.\n        \"\"\"\n        return self.event_loop.remove_watch_file(handle)",
  "def run(self):\n        \"\"\"\n        Start the main loop handling input events and updating the screen. The\n        loop will continue until an :exc:`ExitMainLoop` exception is raised.\n\n        If you would prefer to manage the event loop yourself, don't use this\n        method.  Instead, call :meth:`start` before starting the event loop,\n        and :meth:`stop` once it's finished.\n        \"\"\"\n        with contextlib.suppress(ExitMainLoop):\n            self._run()",
  "def _test_run(self):\n        \"\"\"\n        >>> w = _refl(\"widget\")   # _refl prints out function calls\n        >>> w.render_rval = \"fake canvas\"  # *_rval is used for return values\n        >>> scr = _refl(\"screen\")\n        >>> scr.get_input_descriptors_rval = [42]\n        >>> scr.get_cols_rows_rval = (20, 10)\n        >>> scr.started = True\n        >>> scr._urwid_signals = {}\n        >>> evl = _refl(\"event_loop\")\n        >>> evl.enter_idle_rval = 1\n        >>> evl.watch_file_rval = 2\n        >>> ml = MainLoop(w, [], scr, event_loop=evl)\n        >>> ml.run()    # doctest:+ELLIPSIS\n        screen.start()\n        screen.set_mouse_tracking()\n        screen.unhook_event_loop(...)\n        screen.hook_event_loop(...)\n        event_loop.enter_idle(<bound method MainLoop.entering_idle...>)\n        event_loop.run()\n        event_loop.remove_enter_idle(1)\n        screen.unhook_event_loop(...)\n        screen.stop()\n        >>> ml.draw_screen()    # doctest:+ELLIPSIS\n        screen.get_cols_rows()\n        widget.render((20, 10), focus=True)\n        screen.draw_screen((20, 10), 'fake canvas')\n        \"\"\"",
  "def start(self):\n        \"\"\"\n        Sets up the main loop, hooking into the event loop where necessary.\n        Starts the :attr:`screen` if it hasn't already been started.\n\n        If you want to control starting and stopping the event loop yourself,\n        you should call this method before starting, and call `stop` once the\n        loop has finished.  You may also use this method as a context manager,\n        which will stop the loop automatically at the end of the block:\n\n            with main_loop.start():\n                ...\n\n        Note that some event loop implementations don't handle exceptions\n        specially if you manage the event loop yourself.  In particular, the\n        Twisted and asyncio loops won't stop automatically when\n        :exc:`ExitMainLoop` (or anything else) is raised.\n        \"\"\"\n\n        self.screen.start()\n\n        if self.handle_mouse:\n            self.screen.set_mouse_tracking()\n\n        if not hasattr(self.screen, \"hook_event_loop\"):\n            raise CantUseExternalLoop(\"Screen {0!r} doesn't support external event loops\")\n\n        with contextlib.suppress(NameError):\n            signals.connect_signal(self.screen, INPUT_DESCRIPTORS_CHANGED, self._reset_input_descriptors)\n\n        # watch our input descriptors\n        self._reset_input_descriptors()\n        self.idle_handle = self.event_loop.enter_idle(self.entering_idle)\n\n        # the screen is redrawn automatically after input and alarms,\n        # however, there can be none of those at the start,\n        # so draw the initial screen here unconditionally\n        self.event_loop.alarm(0, self.entering_idle)\n\n        return StoppingContext(self)",
  "def stop(self) -> None:\n        \"\"\"\n        Cleans up any hooks added to the event loop.  Only call this if you're\n        managing the event loop yourself, after the loop stops.\n        \"\"\"\n\n        self.event_loop.remove_enter_idle(self.idle_handle)\n        del self.idle_handle\n        signals.disconnect_signal(self.screen, INPUT_DESCRIPTORS_CHANGED, self._reset_input_descriptors)\n        self.screen.unhook_event_loop(self.event_loop)\n\n        self.screen.stop()",
  "def _reset_input_descriptors(self) -> None:\n        self.screen.unhook_event_loop(self.event_loop)\n        self.screen.hook_event_loop(self.event_loop, self._update)",
  "def _run(self) -> None:\n        try:\n            self.start()\n        except CantUseExternalLoop:\n            try:\n                self._run_screen_event_loop()\n                return\n            finally:\n                self.screen.stop()\n\n        try:\n            self.event_loop.run()\n        except:\n            self.screen.stop()  # clean up screen control\n            raise\n        self.stop()",
  "def _update(self, keys: list[str], raw: list[int]) -> None:\n        \"\"\"\n        >>> w = _refl(\"widget\")\n        >>> w.selectable_rval = True\n        >>> w.mouse_event_rval = True\n        >>> scr = _refl(\"screen\")\n        >>> scr.get_cols_rows_rval = (15, 5)\n        >>> evl = _refl(\"event_loop\")\n        >>> ml = MainLoop(w, [], scr, event_loop=evl)\n        >>> ml._input_timeout = \"old timeout\"\n        >>> ml._update(['y'], [121])    # doctest:+ELLIPSIS\n        screen.get_cols_rows()\n        widget.selectable()\n        widget.keypress((15, 5), 'y')\n        >>> ml._update([(\"mouse press\", 1, 5, 4)], [])\n        widget.mouse_event((15, 5), 'mouse press', 1, 5, 4, focus=True)\n        >>> ml._update([], [])\n        \"\"\"\n        keys = self.input_filter(keys, raw)\n\n        if keys:\n            self.process_input(keys)\n            if \"window resize\" in keys:\n                self.screen_size = None",
  "def _run_screen_event_loop(self) -> None:\n        \"\"\"\n        This method is used when the screen does not support using\n        external event loops.\n\n        The alarms stored in the SelectEventLoop in :attr:`event_loop`\n        are modified by this method.\n        \"\"\"\n        next_alarm = None\n\n        while True:\n            self.draw_screen()\n\n            if not next_alarm and self.event_loop._alarms:\n                next_alarm = heapq.heappop(self.event_loop._alarms)\n\n            keys: list[str] = []\n            raw: list[int] = []\n            while not keys:\n                if next_alarm:\n                    sec = max(0, next_alarm[0] - time.time())\n                    self.screen.set_input_timeouts(sec)\n                else:\n                    self.screen.set_input_timeouts(None)\n                keys, raw = self.screen.get_input(True)\n                if not keys and next_alarm:\n                    sec = next_alarm[0] - time.time()\n                    if sec <= 0:\n                        break\n\n            keys = self.input_filter(keys, raw)\n\n            if keys:\n                self.process_input(keys)\n\n            while next_alarm:\n                sec = next_alarm[0] - time.time()\n                if sec > 0:\n                    break\n                tm, tie_break, callback = next_alarm\n                callback()\n\n                if self.event_loop._alarms:\n                    next_alarm = heapq.heappop(self.event_loop._alarms)\n                else:\n                    next_alarm = None\n\n            if \"window resize\" in keys:\n                self.screen_size = None",
  "def _test_run_screen_event_loop(self):\n        \"\"\"\n        >>> w = _refl(\"widget\")\n        >>> scr = _refl(\"screen\")\n        >>> scr.get_cols_rows_rval = (10, 5)\n        >>> scr.get_input_rval = [], []\n        >>> ml = MainLoop(w, screen=scr)\n        >>> def stop_now(loop, data):\n        ...     raise ExitMainLoop()\n        >>> handle = ml.set_alarm_in(0, stop_now)\n        >>> try:\n        ...     ml._run_screen_event_loop()\n        ... except ExitMainLoop:\n        ...     pass\n        screen.get_cols_rows()\n        widget.render((10, 5), focus=True)\n        screen.draw_screen((10, 5), None)\n        screen.set_input_timeouts(0)\n        screen.get_input(True)\n        \"\"\"",
  "def process_input(self, keys: Iterable[str | tuple[str, int, int, int]]) -> bool:\n        \"\"\"\n        This method will pass keyboard input and mouse events to :attr:`widget`.\n        This method is called automatically from the :meth:`run` method when\n        there is input, but may also be called to simulate input from the user.\n\n        *keys* is a list of input returned from :attr:`screen`'s get_input()\n        or get_input_nonblocking() methods.\n\n        Returns ``True`` if any key was handled by a widget or the\n        :meth:`unhandled_input` method.\n        \"\"\"\n        if not self.screen_size:\n            self.screen_size = self.screen.get_cols_rows()\n\n        something_handled = False\n\n        for k in keys:\n            if k == \"window resize\":\n                continue\n\n            if isinstance(k, str):\n                if self._topmost_widget.selectable():\n                    k = self._topmost_widget.keypress(self.screen_size, k)  # noqa: PLW2901\n\n            elif isinstance(k, tuple):\n                if is_mouse_event(k):\n                    event, button, col, row = k\n                    if hasattr(self._topmost_widget, \"mouse_event\") and self._topmost_widget.mouse_event(\n                        self.screen_size,\n                        event,\n                        button,\n                        col,\n                        row,\n                        focus=True,\n                    ):\n                        k = None  # noqa: PLW2901\n\n            else:\n                raise TypeError(f\"{k!r} is not str | tuple[str, int, int, int]\")\n\n            if k:\n                if command_map[k] == Command.REDRAW_SCREEN:\n                    self.screen.clear()\n                    something_handled = True\n                else:\n                    something_handled |= bool(self.unhandled_input(k))\n            else:\n                something_handled = True\n\n        return something_handled",
  "def _test_process_input(self):\n        \"\"\"\n        >>> w = _refl(\"widget\")\n        >>> w.selectable_rval = True\n        >>> scr = _refl(\"screen\")\n        >>> scr.get_cols_rows_rval = (10, 5)\n        >>> ml = MainLoop(w, [], scr)\n        >>> ml.process_input(['enter', ('mouse drag', 1, 14, 20)])\n        screen.get_cols_rows()\n        widget.selectable()\n        widget.keypress((10, 5), 'enter')\n        widget.mouse_event((10, 5), 'mouse drag', 1, 14, 20, focus=True)\n        True\n        \"\"\"",
  "def input_filter(self, keys: list[str], raw: list[int]) -> list[str]:\n        \"\"\"\n        This function is passed each all the input events and raw keystroke\n        values. These values are passed to the *input_filter* function\n        passed to the constructor. That function must return a list of keys to\n        be passed to the widgets to handle. If no *input_filter* was\n        defined this implementation will return all the input events.\n        \"\"\"\n        if self._input_filter:\n            return self._input_filter(keys, raw)\n        return keys",
  "def unhandled_input(self, data: str | tuple[str, int, int, int]) -> bool:\n        \"\"\"\n        This function is called with any input that was not handled by the\n        widgets, and calls the *unhandled_input* function passed to the\n        constructor. If no *unhandled_input* was defined then the input\n        will be ignored.\n\n        *input* is the keyboard or mouse input.\n\n        The *unhandled_input* function should return ``True`` if it handled\n        the input.\n        \"\"\"\n        if self._unhandled_input:\n            return self._unhandled_input(data)\n        return False",
  "def entering_idle(self):\n        \"\"\"\n        This method is called whenever the event loop is about to enter the\n        idle state. :meth:`draw_screen` is called here to update the\n        screen when anything has changed.\n        \"\"\"\n        if self.screen.started:\n            self.draw_screen()",
  "def draw_screen(self):\n        \"\"\"\n        Render the widgets and paint the screen. This method is called\n        automatically from :meth:`entering_idle`.\n\n        If you modify the widgets displayed outside of handling input or\n        responding to an alarm you will need to call this method yourself\n        to repaint the screen.\n        \"\"\"\n        if not self.screen_size:\n            self.screen_size = self.screen.get_cols_rows()\n\n        canvas = self._topmost_widget.render(self.screen_size, focus=True)\n        self.screen.draw_screen(self.screen_size, canvas)",
  "class Reflect:\n        def __init__(self, name: str, rval=None):\n            self._name = name\n            self._rval = rval\n\n        def __call__(self, *argl, **argd):\n            args = \", \".join([repr(a) for a in argl])\n            if args and argd:\n                args = f\"{args}, \"\n            args += \", \".join([f\"{k}={v!r}\" for k, v in argd.items()])\n            print(f\"{self._name}({args})\")\n            if loop_exit:\n                raise ExitMainLoop()\n            return self._rval\n\n        def __getattr__(self, attr):\n            if attr.endswith(\"_rval\"):\n                raise AttributeError()\n            # print(self._name+\".\"+attr)\n            if hasattr(self, f\"{attr}_rval\"):\n                return Reflect(f\"{self._name}.{attr}\", getattr(self, f\"{attr}_rval\"))\n            return Reflect(f\"{self._name}.{attr}\")",
  "def cb():\n            callback(self, user_data)",
  "def cb():\n            callback(self, user_data)",
  "def cb() -> None:\n            data = os.read(pipe_rd, PIPE_BUFFER_READ_SIZE)\n            rval = callback(data)\n            if rval is False:\n                self.event_loop.remove_watch_file(watch_handle)\n                os.close(pipe_rd)",
  "def __init__(self, name: str, rval=None):\n            self._name = name\n            self._rval = rval",
  "def __call__(self, *argl, **argd):\n            args = \", \".join([repr(a) for a in argl])\n            if args and argd:\n                args = f\"{args}, \"\n            args += \", \".join([f\"{k}={v!r}\" for k, v in argd.items()])\n            print(f\"{self._name}({args})\")\n            if loop_exit:\n                raise ExitMainLoop()\n            return self._rval",
  "def __getattr__(self, attr):\n            if attr.endswith(\"_rval\"):\n                raise AttributeError()\n            # print(self._name+\".\"+attr)\n            if hasattr(self, f\"{attr}_rval\"):\n                return Reflect(f\"{self._name}.{attr}\", getattr(self, f\"{attr}_rval\"))\n            return Reflect(f\"{self._name}.{attr}\")",
  "class SelectEventLoop(EventLoop):\n    \"\"\"\n    Event loop based on :func:`select.select`\n    \"\"\"\n\n    def __init__(self) -> None:\n        self._alarms: list[tuple[float, int, Callable[[], typing.Any]]] = []\n        self._watch_files: dict[int, Callable[[], typing.Any]] = {}\n        self._idle_handle: int = 0\n        self._idle_callbacks: dict[int, Callable[[], typing.Any]] = {}\n        self._tie_break: Iterator[int] = count()\n        self._did_something: bool = False\n\n    def alarm(\n        self,\n        seconds: float,\n        callback: Callable[[], typing.Any],\n    ) -> tuple[float, int, Callable[[], typing.Any]]:\n        \"\"\"\n        Call callback() a given time from now.  No parameters are\n        passed to callback.\n\n        Returns a handle that may be passed to remove_alarm()\n\n        seconds -- floating point time to wait before calling callback\n        callback -- function to call from event loop\n        \"\"\"\n        tm = time.time() + seconds\n        handle = (tm, next(self._tie_break), callback)\n        heapq.heappush(self._alarms, handle)\n        return handle\n\n    def remove_alarm(self, handle: tuple[float, int, Callable[[], typing.Any]]) -> bool:\n        \"\"\"\n        Remove an alarm.\n\n        Returns True if the alarm exists, False otherwise\n        \"\"\"\n        try:\n            self._alarms.remove(handle)\n            heapq.heapify(self._alarms)\n\n        except ValueError:\n            return False\n\n        return True\n\n    def watch_file(self, fd: int, callback: Callable[[], typing.Any]) -> int:\n        \"\"\"\n        Call callback() when fd has some data to read.  No parameters\n        are passed to callback.\n\n        Returns a handle that may be passed to remove_watch_file()\n\n        fd -- file descriptor to watch for input\n        callback -- function to call when input is available\n        \"\"\"\n        self._watch_files[fd] = callback\n        return fd\n\n    def remove_watch_file(self, handle: int) -> bool:\n        \"\"\"\n        Remove an input file.\n\n        Returns True if the input file exists, False otherwise\n        \"\"\"\n        if handle in self._watch_files:\n            del self._watch_files[handle]\n            return True\n        return False\n\n    def enter_idle(self, callback: Callable[[], typing.Any]) -> int:\n        \"\"\"\n        Add a callback for entering idle.\n\n        Returns a handle that may be passed to remove_idle()\n        \"\"\"\n        self._idle_handle += 1\n        self._idle_callbacks[self._idle_handle] = callback\n        return self._idle_handle\n\n    def remove_enter_idle(self, handle: int) -> bool:\n        \"\"\"\n        Remove an idle callback.\n\n        Returns True if the handle was removed.\n        \"\"\"\n        try:\n            del self._idle_callbacks[handle]\n        except KeyError:\n            return False\n        return True\n\n    def _entering_idle(self) -> None:\n        \"\"\"\n        Call all the registered idle callbacks.\n        \"\"\"\n        for callback in self._idle_callbacks.values():\n            callback()\n\n    def run(self) -> None:\n        \"\"\"\n        Start the event loop.  Exit the loop when any callback raises\n        an exception.  If ExitMainLoop is raised, exit cleanly.\n        \"\"\"\n        try:\n            self._did_something = True\n            while True:\n                with contextlib.suppress(InterruptedError):\n                    self._loop()\n\n        except ExitMainLoop:\n            pass\n\n    def _loop(self) -> None:\n        \"\"\"\n        A single iteration of the event loop\n        \"\"\"\n        fds = list(self._watch_files)\n        if self._alarms or self._did_something:\n            timeout = 0.0\n            tm: float | Literal[\"idle\"] | None = None\n\n            if self._alarms:\n                timeout_ = self._alarms[0][0]\n                tm = timeout_\n                timeout = max(timeout, timeout_ - time.time())\n\n            if self._did_something and (not self._alarms or (self._alarms and timeout > 0)):\n                timeout = 0.0\n                tm = \"idle\"\n\n            ready, w, err = select.select(fds, [], fds, timeout)\n\n        else:\n            tm = None\n            ready, w, err = select.select(fds, [], fds)\n\n        if not ready:\n            if tm == \"idle\":\n                self._entering_idle()\n                self._did_something = False\n            elif tm is not None:\n                # must have been a timeout\n                tm, tie_break, alarm_callback = heapq.heappop(self._alarms)\n                alarm_callback()\n                self._did_something = True\n\n        for fd in ready:\n            self._watch_files[fd]()\n            self._did_something = True",
  "def __init__(self) -> None:\n        self._alarms: list[tuple[float, int, Callable[[], typing.Any]]] = []\n        self._watch_files: dict[int, Callable[[], typing.Any]] = {}\n        self._idle_handle: int = 0\n        self._idle_callbacks: dict[int, Callable[[], typing.Any]] = {}\n        self._tie_break: Iterator[int] = count()\n        self._did_something: bool = False",
  "def alarm(\n        self,\n        seconds: float,\n        callback: Callable[[], typing.Any],\n    ) -> tuple[float, int, Callable[[], typing.Any]]:\n        \"\"\"\n        Call callback() a given time from now.  No parameters are\n        passed to callback.\n\n        Returns a handle that may be passed to remove_alarm()\n\n        seconds -- floating point time to wait before calling callback\n        callback -- function to call from event loop\n        \"\"\"\n        tm = time.time() + seconds\n        handle = (tm, next(self._tie_break), callback)\n        heapq.heappush(self._alarms, handle)\n        return handle",
  "def remove_alarm(self, handle: tuple[float, int, Callable[[], typing.Any]]) -> bool:\n        \"\"\"\n        Remove an alarm.\n\n        Returns True if the alarm exists, False otherwise\n        \"\"\"\n        try:\n            self._alarms.remove(handle)\n            heapq.heapify(self._alarms)\n\n        except ValueError:\n            return False\n\n        return True",
  "def watch_file(self, fd: int, callback: Callable[[], typing.Any]) -> int:\n        \"\"\"\n        Call callback() when fd has some data to read.  No parameters\n        are passed to callback.\n\n        Returns a handle that may be passed to remove_watch_file()\n\n        fd -- file descriptor to watch for input\n        callback -- function to call when input is available\n        \"\"\"\n        self._watch_files[fd] = callback\n        return fd",
  "def remove_watch_file(self, handle: int) -> bool:\n        \"\"\"\n        Remove an input file.\n\n        Returns True if the input file exists, False otherwise\n        \"\"\"\n        if handle in self._watch_files:\n            del self._watch_files[handle]\n            return True\n        return False",
  "def enter_idle(self, callback: Callable[[], typing.Any]) -> int:\n        \"\"\"\n        Add a callback for entering idle.\n\n        Returns a handle that may be passed to remove_idle()\n        \"\"\"\n        self._idle_handle += 1\n        self._idle_callbacks[self._idle_handle] = callback\n        return self._idle_handle",
  "def remove_enter_idle(self, handle: int) -> bool:\n        \"\"\"\n        Remove an idle callback.\n\n        Returns True if the handle was removed.\n        \"\"\"\n        try:\n            del self._idle_callbacks[handle]\n        except KeyError:\n            return False\n        return True",
  "def _entering_idle(self) -> None:\n        \"\"\"\n        Call all the registered idle callbacks.\n        \"\"\"\n        for callback in self._idle_callbacks.values():\n            callback()",
  "def run(self) -> None:\n        \"\"\"\n        Start the event loop.  Exit the loop when any callback raises\n        an exception.  If ExitMainLoop is raised, exit cleanly.\n        \"\"\"\n        try:\n            self._did_something = True\n            while True:\n                with contextlib.suppress(InterruptedError):\n                    self._loop()\n\n        except ExitMainLoop:\n            pass",
  "def _loop(self) -> None:\n        \"\"\"\n        A single iteration of the event loop\n        \"\"\"\n        fds = list(self._watch_files)\n        if self._alarms or self._did_something:\n            timeout = 0.0\n            tm: float | Literal[\"idle\"] | None = None\n\n            if self._alarms:\n                timeout_ = self._alarms[0][0]\n                tm = timeout_\n                timeout = max(timeout, timeout_ - time.time())\n\n            if self._did_something and (not self._alarms or (self._alarms and timeout > 0)):\n                timeout = 0.0\n                tm = \"idle\"\n\n            ready, w, err = select.select(fds, [], fds, timeout)\n\n        else:\n            tm = None\n            ready, w, err = select.select(fds, [], fds)\n\n        if not ready:\n            if tm == \"idle\":\n                self._entering_idle()\n                self._did_something = False\n            elif tm is not None:\n                # must have been a timeout\n                tm, tie_break, alarm_callback = heapq.heappop(self._alarms)\n                alarm_callback()\n                self._did_something = True\n\n        for fd in ready:\n            self._watch_files[fd]()\n            self._did_something = True",
  "class ExitMainLoop(Exception):\n    \"\"\"\n    When this exception is raised within a main loop the main loop\n    will exit cleanly.\n    \"\"\"",
  "class EventLoop(abc.ABC):\n    \"\"\"\n    Abstract class representing an event loop to be used by :class:`MainLoop`.\n    \"\"\"\n\n    @abc.abstractmethod\n    def alarm(self, seconds: float, callback: Callable[[], typing.Any]) -> typing.Any:\n        \"\"\"\n        Call callback() a given time from now.  No parameters are\n        passed to callback.\n\n        This method has no default implementation.\n\n        Returns a handle that may be passed to remove_alarm()\n\n        seconds -- floating point time to wait before calling callback\n        callback -- function to call from event loop\n        \"\"\"\n\n    @abc.abstractmethod\n    def enter_idle(self, callback):\n        \"\"\"\n        Add a callback for entering idle.\n\n        This method has no default implementation.\n\n        Returns a handle that may be passed to remove_idle()\n        \"\"\"\n\n    @abc.abstractmethod\n    def remove_alarm(self, handle) -> bool:\n        \"\"\"\n        Remove an alarm.\n\n        This method has no default implementation.\n\n        Returns True if the alarm exists, False otherwise\n        \"\"\"\n\n    @abc.abstractmethod\n    def remove_enter_idle(self, handle) -> bool:\n        \"\"\"\n        Remove an idle callback.\n\n        This method has no default implementation.\n\n        Returns True if the handle was removed.\n        \"\"\"\n\n    @abc.abstractmethod\n    def remove_watch_file(self, handle) -> bool:\n        \"\"\"\n        Remove an input file.\n\n        This method has no default implementation.\n\n        Returns True if the input file exists, False otherwise\n        \"\"\"\n\n    @abc.abstractmethod\n    def run(self) -> None:\n        \"\"\"\n        Start the event loop.  Exit the loop when any callback raises\n        an exception.  If ExitMainLoop is raised, exit cleanly.\n\n        This method has no default implementation.\n        \"\"\"\n\n    @abc.abstractmethod\n    def watch_file(self, fd: int, callback: Callable[[], typing.Any]):\n        \"\"\"\n        Call callback() when fd has some data to read.  No parameters\n        are passed to callback.\n\n        This method has no default implementation.\n\n        Returns a handle that may be passed to remove_watch_file()\n\n        fd -- file descriptor to watch for input\n        callback -- function to call when input is available\n        \"\"\"\n\n    def set_signal_handler(\n        self,\n        signum: int,\n        handler: Callable[[int, FrameType | None], typing.Any] | int | signal.Handlers,\n    ) -> Callable[[int, FrameType | None], typing.Any] | int | signal.Handlers | None:\n        \"\"\"\n        Sets the signal handler for signal signum.\n\n        The default implementation of :meth:`set_signal_handler`\n        is simply a proxy function that calls :func:`signal.signal()`\n        and returns the resulting value.\n\n        signum -- signal number\n        handler -- function (taking signum as its single argument),\n        or `signal.SIG_IGN`, or `signal.SIG_DFL`\n        \"\"\"\n        return signal.signal(signum, handler)",
  "def alarm(self, seconds: float, callback: Callable[[], typing.Any]) -> typing.Any:\n        \"\"\"\n        Call callback() a given time from now.  No parameters are\n        passed to callback.\n\n        This method has no default implementation.\n\n        Returns a handle that may be passed to remove_alarm()\n\n        seconds -- floating point time to wait before calling callback\n        callback -- function to call from event loop\n        \"\"\"",
  "def enter_idle(self, callback):\n        \"\"\"\n        Add a callback for entering idle.\n\n        This method has no default implementation.\n\n        Returns a handle that may be passed to remove_idle()\n        \"\"\"",
  "def remove_alarm(self, handle) -> bool:\n        \"\"\"\n        Remove an alarm.\n\n        This method has no default implementation.\n\n        Returns True if the alarm exists, False otherwise\n        \"\"\"",
  "def remove_enter_idle(self, handle) -> bool:\n        \"\"\"\n        Remove an idle callback.\n\n        This method has no default implementation.\n\n        Returns True if the handle was removed.\n        \"\"\"",
  "def remove_watch_file(self, handle) -> bool:\n        \"\"\"\n        Remove an input file.\n\n        This method has no default implementation.\n\n        Returns True if the input file exists, False otherwise\n        \"\"\"",
  "def run(self) -> None:\n        \"\"\"\n        Start the event loop.  Exit the loop when any callback raises\n        an exception.  If ExitMainLoop is raised, exit cleanly.\n\n        This method has no default implementation.\n        \"\"\"",
  "def watch_file(self, fd: int, callback: Callable[[], typing.Any]):\n        \"\"\"\n        Call callback() when fd has some data to read.  No parameters\n        are passed to callback.\n\n        This method has no default implementation.\n\n        Returns a handle that may be passed to remove_watch_file()\n\n        fd -- file descriptor to watch for input\n        callback -- function to call when input is available\n        \"\"\"",
  "def set_signal_handler(\n        self,\n        signum: int,\n        handler: Callable[[int, FrameType | None], typing.Any] | int | signal.Handlers,\n    ) -> Callable[[int, FrameType | None], typing.Any] | int | signal.Handlers | None:\n        \"\"\"\n        Sets the signal handler for signal signum.\n\n        The default implementation of :meth:`set_signal_handler`\n        is simply a proxy function that calls :func:`signal.signal()`\n        and returns the resulting value.\n\n        signum -- signal number\n        handler -- function (taking signum as its single argument),\n        or `signal.SIG_IGN`, or `signal.SIG_DFL`\n        \"\"\"\n        return signal.signal(signum, handler)",
  "class AsyncioEventLoop(EventLoop):\n    \"\"\"\n    Event loop based on the standard library ``asyncio`` module.\n\n    .. note::\n        If you make any changes to the urwid state outside of it\n        handling input or responding to alarms (for example, from asyncio.Task\n        running in background), and wish the screen to be\n        redrawn, you must call :meth:`MainLoop.draw_screen` method of the\n        main loop manually.\n        A good way to do this::\n            asyncio.get_event_loop().call_soon(main_loop.draw_screen)\n    \"\"\"\n\n    _we_started_event_loop = False\n\n    def __init__(self, *, loop: asyncio.AbstractEventLoop | None = None, **kwargs) -> None:\n        if loop:\n            self._loop: asyncio.AbstractEventLoop = loop\n        else:\n            self._loop = asyncio.get_event_loop()\n\n        self._exc: BaseException | None = None\n\n        self._idle_asyncio_handle: asyncio.TimerHandle | None = None\n        self._idle_handle: int = 0\n        self._idle_callbacks: dict[int, Callable[[], typing.Any]] = {}\n\n    def _also_call_idle(self, callback: Callable[_Spec, _T]) -> Callable[_Spec, _T]:\n        \"\"\"\n        Wrap the callback to also call _entering_idle.\n        \"\"\"\n\n        @functools.wraps(callback)\n        def wrapper(*args: _Spec.args, **kwargs: _Spec.kwargs) -> _T:\n            if not self._idle_asyncio_handle:\n                self._idle_asyncio_handle = self._loop.call_later(0, self._entering_idle)\n            return callback(*args, **kwargs)\n\n        return wrapper\n\n    def _entering_idle(self) -> None:\n        \"\"\"\n        Call all the registered idle callbacks.\n        \"\"\"\n        try:\n            for callback in self._idle_callbacks.values():\n                callback()\n        finally:\n            self._idle_asyncio_handle = None\n\n    def alarm(self, seconds: float, callback: Callable[[], typing.Any]) -> asyncio.TimerHandle:\n        \"\"\"\n        Call callback() a given time from now.  No parameters are\n        passed to callback.\n\n        Returns a handle that may be passed to remove_alarm()\n\n        seconds -- time in seconds to wait before calling callback\n        callback -- function to call from event loop\n        \"\"\"\n        return self._loop.call_later(seconds, self._also_call_idle(callback))\n\n    def remove_alarm(self, handle) -> bool:\n        \"\"\"\n        Remove an alarm.\n\n        Returns True if the alarm exists, False otherwise\n        \"\"\"\n        cancelled = handle.cancelled() if getattr(handle, \"cancelled\", None) else handle._cancelled\n        existed = not cancelled\n        handle.cancel()\n        return existed\n\n    def watch_file(self, fd: int, callback: Callable[[], typing.Any]) -> int:\n        \"\"\"\n        Call callback() when fd has some data to read.  No parameters\n        are passed to callback.\n\n        Returns a handle that may be passed to remove_watch_file()\n\n        fd -- file descriptor to watch for input\n        callback -- function to call when input is available\n        \"\"\"\n        self._loop.add_reader(fd, self._also_call_idle(callback))\n        return fd\n\n    def remove_watch_file(self, handle: int) -> bool:\n        \"\"\"\n        Remove an input file.\n\n        Returns True if the input file exists, False otherwise\n        \"\"\"\n        return self._loop.remove_reader(handle)\n\n    def enter_idle(self, callback: Callable[[], typing.Any]) -> int:\n        \"\"\"\n        Add a callback for entering idle.\n\n        Returns a handle that may be passed to remove_enter_idle()\n        \"\"\"\n        # XXX there's no such thing as \"idle\" in most event loops; this fakes\n        # it by adding extra callback to the timer and file watch callbacks.\n        self._idle_handle += 1\n        self._idle_callbacks[self._idle_handle] = callback\n        return self._idle_handle\n\n    def remove_enter_idle(self, handle: int) -> bool:\n        \"\"\"\n        Remove an idle callback.\n\n        Returns True if the handle was removed.\n        \"\"\"\n        try:\n            del self._idle_callbacks[handle]\n        except KeyError:\n            return False\n        return True\n\n    def _exception_handler(self, loop: asyncio.AbstractEventLoop, context):\n        exc = context.get(\"exception\")\n        if exc:\n            loop.stop()\n\n            if self._idle_asyncio_handle:\n                # clean it up to prevent old callbacks\n                # from messing things up if loop is restarted\n                self._idle_asyncio_handle.cancel()\n                self._idle_asyncio_handle = None\n\n            if not isinstance(exc, ExitMainLoop):\n                # Store the exc_info so we can re-raise after the loop stops\n                self._exc = exc\n        else:\n            loop.default_exception_handler(context)\n\n    def run(self) -> None:\n        \"\"\"\n        Start the event loop.  Exit the loop when any callback raises\n        an exception.  If ExitMainLoop is raised, exit cleanly.\n        \"\"\"\n        self._loop.set_exception_handler(self._exception_handler)\n        self._loop.run_forever()\n        if self._exc:\n            exc = self._exc\n            self._exc = None\n            raise exc.with_traceback(exc.__traceback__)",
  "def __init__(self, *, loop: asyncio.AbstractEventLoop | None = None, **kwargs) -> None:\n        if loop:\n            self._loop: asyncio.AbstractEventLoop = loop\n        else:\n            self._loop = asyncio.get_event_loop()\n\n        self._exc: BaseException | None = None\n\n        self._idle_asyncio_handle: asyncio.TimerHandle | None = None\n        self._idle_handle: int = 0\n        self._idle_callbacks: dict[int, Callable[[], typing.Any]] = {}",
  "def _also_call_idle(self, callback: Callable[_Spec, _T]) -> Callable[_Spec, _T]:\n        \"\"\"\n        Wrap the callback to also call _entering_idle.\n        \"\"\"\n\n        @functools.wraps(callback)\n        def wrapper(*args: _Spec.args, **kwargs: _Spec.kwargs) -> _T:\n            if not self._idle_asyncio_handle:\n                self._idle_asyncio_handle = self._loop.call_later(0, self._entering_idle)\n            return callback(*args, **kwargs)\n\n        return wrapper",
  "def _entering_idle(self) -> None:\n        \"\"\"\n        Call all the registered idle callbacks.\n        \"\"\"\n        try:\n            for callback in self._idle_callbacks.values():\n                callback()\n        finally:\n            self._idle_asyncio_handle = None",
  "def alarm(self, seconds: float, callback: Callable[[], typing.Any]) -> asyncio.TimerHandle:\n        \"\"\"\n        Call callback() a given time from now.  No parameters are\n        passed to callback.\n\n        Returns a handle that may be passed to remove_alarm()\n\n        seconds -- time in seconds to wait before calling callback\n        callback -- function to call from event loop\n        \"\"\"\n        return self._loop.call_later(seconds, self._also_call_idle(callback))",
  "def remove_alarm(self, handle) -> bool:\n        \"\"\"\n        Remove an alarm.\n\n        Returns True if the alarm exists, False otherwise\n        \"\"\"\n        cancelled = handle.cancelled() if getattr(handle, \"cancelled\", None) else handle._cancelled\n        existed = not cancelled\n        handle.cancel()\n        return existed",
  "def watch_file(self, fd: int, callback: Callable[[], typing.Any]) -> int:\n        \"\"\"\n        Call callback() when fd has some data to read.  No parameters\n        are passed to callback.\n\n        Returns a handle that may be passed to remove_watch_file()\n\n        fd -- file descriptor to watch for input\n        callback -- function to call when input is available\n        \"\"\"\n        self._loop.add_reader(fd, self._also_call_idle(callback))\n        return fd",
  "def remove_watch_file(self, handle: int) -> bool:\n        \"\"\"\n        Remove an input file.\n\n        Returns True if the input file exists, False otherwise\n        \"\"\"\n        return self._loop.remove_reader(handle)",
  "def enter_idle(self, callback: Callable[[], typing.Any]) -> int:\n        \"\"\"\n        Add a callback for entering idle.\n\n        Returns a handle that may be passed to remove_enter_idle()\n        \"\"\"\n        # XXX there's no such thing as \"idle\" in most event loops; this fakes\n        # it by adding extra callback to the timer and file watch callbacks.\n        self._idle_handle += 1\n        self._idle_callbacks[self._idle_handle] = callback\n        return self._idle_handle",
  "def remove_enter_idle(self, handle: int) -> bool:\n        \"\"\"\n        Remove an idle callback.\n\n        Returns True if the handle was removed.\n        \"\"\"\n        try:\n            del self._idle_callbacks[handle]\n        except KeyError:\n            return False\n        return True",
  "def _exception_handler(self, loop: asyncio.AbstractEventLoop, context):\n        exc = context.get(\"exception\")\n        if exc:\n            loop.stop()\n\n            if self._idle_asyncio_handle:\n                # clean it up to prevent old callbacks\n                # from messing things up if loop is restarted\n                self._idle_asyncio_handle.cancel()\n                self._idle_asyncio_handle = None\n\n            if not isinstance(exc, ExitMainLoop):\n                # Store the exc_info so we can re-raise after the loop stops\n                self._exc = exc\n        else:\n            loop.default_exception_handler(context)",
  "def run(self) -> None:\n        \"\"\"\n        Start the event loop.  Exit the loop when any callback raises\n        an exception.  If ExitMainLoop is raised, exit cleanly.\n        \"\"\"\n        self._loop.set_exception_handler(self._exception_handler)\n        self._loop.run_forever()\n        if self._exc:\n            exc = self._exc\n            self._exc = None\n            raise exc.with_traceback(exc.__traceback__)",
  "def wrapper(*args: _Spec.args, **kwargs: _Spec.kwargs) -> _T:\n            if not self._idle_asyncio_handle:\n                self._idle_asyncio_handle = self._loop.call_later(0, self._entering_idle)\n            return callback(*args, **kwargs)",
  "class ZMQEventLoop(EventLoop):\n    \"\"\"\n    This class is an urwid event loop for `ZeroMQ`_ applications. It is very\n    similar to :class:`SelectEventLoop`, supporting the usual :meth:`alarm`\n    events and file watching (:meth:`watch_file`) capabilities, but also\n    incorporates the ability to watch zmq queues for events\n    (:meth:`watch_queue`).\n\n    .. _ZeroMQ: https://zeromq.org/\n    \"\"\"\n\n    _alarm_break = count()\n\n    def __init__(self):\n        self._did_something = True\n        self._alarms = []\n        self._poller = zmq.Poller()\n        self._queue_callbacks = {}\n        self._idle_handle = 0\n        self._idle_callbacks = {}\n\n    def alarm(self, seconds: float, callback: Callable[[], typing.Any]) -> ZMQAlarmHandle:\n        \"\"\"\n        Call *callback* a given time from now. No parameters are passed to\n        callback. Returns a handle that may be passed to :meth:`remove_alarm`.\n\n        :param float seconds:\n            floating point time to wait before calling callback.\n\n        :param callback:\n            function to call from event loop.\n        \"\"\"\n        handle = (time.time() + seconds, next(self._alarm_break), callback)\n        heapq.heappush(self._alarms, handle)\n        return handle\n\n    def remove_alarm(self, handle: ZMQAlarmHandle) -> bool:\n        \"\"\"\n        Remove an alarm. Returns ``True`` if the alarm exists, ``False``\n        otherwise.\n        \"\"\"\n        try:\n            self._alarms.remove(handle)\n            heapq.heapify(self._alarms)\n\n        except ValueError:\n            return False\n\n        return True\n\n    def watch_queue(\n        self,\n        queue: zmq.Socket,\n        callback: Callable[[], typing.Any],\n        flags: int = zmq.POLLIN,\n    ) -> ZMQQueueHandle:\n        \"\"\"\n        Call *callback* when zmq *queue* has something to read (when *flags* is\n        set to ``POLLIN``, the default) or is available to write (when *flags*\n        is set to ``POLLOUT``). No parameters are passed to the callback.\n        Returns a handle that may be passed to :meth:`remove_watch_queue`.\n\n        :param queue:\n            The zmq queue to poll.\n\n        :param callback:\n            The function to call when the poll is successful.\n\n        :param int flags:\n            The condition to monitor on the queue (defaults to ``POLLIN``).\n        \"\"\"\n        if queue in self._queue_callbacks:\n            raise ValueError(f\"already watching {queue!r}\")\n        self._poller.register(queue, flags)\n        self._queue_callbacks[queue] = callback\n        return queue\n\n    def watch_file(\n        self,\n        fd: int,\n        callback: Callable[[], typing.Any],\n        flags: int = zmq.POLLIN,\n    ) -> ZMQFileHandle:\n        \"\"\"\n        Call *callback* when *fd* has some data to read. No parameters are\n        passed to the callback. The *flags* are as for :meth:`watch_queue`.\n        Returns a handle that may be passed to :meth:`remove_watch_file`.\n\n        :param fd:\n            The file-like object, or fileno to monitor.\n\n        :param callback:\n            The function to call when the file has data available.\n\n        :param int flags:\n            The condition to monitor on the file (defaults to ``POLLIN``).\n        \"\"\"\n        if isinstance(fd, int):\n            fd = os.fdopen(fd)\n        self._poller.register(fd, flags)\n        self._queue_callbacks[fd.fileno()] = callback\n        return fd\n\n    def remove_watch_queue(self, handle: ZMQQueueHandle) -> bool:\n        \"\"\"\n        Remove a queue from background polling. Returns ``True`` if the queue\n        was being monitored, ``False`` otherwise.\n        \"\"\"\n        try:\n            try:\n                self._poller.unregister(handle)\n            finally:\n                self._queue_callbacks.pop(handle, None)\n\n        except KeyError:\n            return False\n\n        return True\n\n    def remove_watch_file(self, handle: ZMQFileHandle) -> bool:\n        \"\"\"\n        Remove a file from background polling. Returns ``True`` if the file was\n        being monitored, ``False`` otherwise.\n        \"\"\"\n        try:\n            try:\n                self._poller.unregister(handle)\n            finally:\n                self._queue_callbacks.pop(handle.fileno(), None)\n\n        except KeyError:\n            return False\n\n        return True\n\n    def enter_idle(self, callback: Callable[[], typing.Any]) -> ZMQIdleHandle:\n        \"\"\"\n        Add a *callback* to be executed when the event loop detects it is idle.\n        Returns a handle that may be passed to :meth:`remove_enter_idle`.\n        \"\"\"\n        self._idle_handle += 1\n        self._idle_callbacks[self._idle_handle] = callback\n        return self._idle_handle\n\n    def remove_enter_idle(self, handle: ZMQIdleHandle) -> bool:\n        \"\"\"\n        Remove an idle callback. Returns ``True`` if *handle* was removed,\n        ``False`` otherwise.\n        \"\"\"\n        try:\n            del self._idle_callbacks[handle]\n        except KeyError:\n            return False\n\n        return True\n\n    def _entering_idle(self) -> None:\n        for callback in list(self._idle_callbacks.values()):\n            callback()\n\n    def run(self) -> None:\n        \"\"\"\n        Start the event loop. Exit the loop when any callback raises an\n        exception. If :exc:`ExitMainLoop` is raised, exit cleanly.\n        \"\"\"\n        try:\n            while True:\n                try:\n                    self._loop()\n                except zmq.error.ZMQError as exc:  # noqa: PERF203\n                    if exc.errno != errno.EINTR:\n                        raise\n        except ExitMainLoop:\n            pass\n\n    def _loop(self) -> None:\n        \"\"\"\n        A single iteration of the event loop.\n        \"\"\"\n        if self._alarms or self._did_something:\n            if self._alarms:\n                state = \"alarm\"\n                timeout = max(0, self._alarms[0][0] - time.time())\n            if self._did_something and (not self._alarms or (self._alarms and timeout > 0)):\n                state = \"idle\"\n                timeout = 0\n            ready = dict(self._poller.poll(timeout * 1000))\n        else:\n            state = \"wait\"\n            ready = dict(self._poller.poll())\n\n        if not ready:\n            if state == \"idle\":\n                self._entering_idle()\n                self._did_something = False\n            elif state == \"alarm\":\n                due, tie_break, callback = heapq.heappop(self._alarms)\n                callback()\n                self._did_something = True\n\n        for queue in ready:\n            self._queue_callbacks[queue]()\n            self._did_something = True",
  "def __init__(self):\n        self._did_something = True\n        self._alarms = []\n        self._poller = zmq.Poller()\n        self._queue_callbacks = {}\n        self._idle_handle = 0\n        self._idle_callbacks = {}",
  "def alarm(self, seconds: float, callback: Callable[[], typing.Any]) -> ZMQAlarmHandle:\n        \"\"\"\n        Call *callback* a given time from now. No parameters are passed to\n        callback. Returns a handle that may be passed to :meth:`remove_alarm`.\n\n        :param float seconds:\n            floating point time to wait before calling callback.\n\n        :param callback:\n            function to call from event loop.\n        \"\"\"\n        handle = (time.time() + seconds, next(self._alarm_break), callback)\n        heapq.heappush(self._alarms, handle)\n        return handle",
  "def remove_alarm(self, handle: ZMQAlarmHandle) -> bool:\n        \"\"\"\n        Remove an alarm. Returns ``True`` if the alarm exists, ``False``\n        otherwise.\n        \"\"\"\n        try:\n            self._alarms.remove(handle)\n            heapq.heapify(self._alarms)\n\n        except ValueError:\n            return False\n\n        return True",
  "def watch_queue(\n        self,\n        queue: zmq.Socket,\n        callback: Callable[[], typing.Any],\n        flags: int = zmq.POLLIN,\n    ) -> ZMQQueueHandle:\n        \"\"\"\n        Call *callback* when zmq *queue* has something to read (when *flags* is\n        set to ``POLLIN``, the default) or is available to write (when *flags*\n        is set to ``POLLOUT``). No parameters are passed to the callback.\n        Returns a handle that may be passed to :meth:`remove_watch_queue`.\n\n        :param queue:\n            The zmq queue to poll.\n\n        :param callback:\n            The function to call when the poll is successful.\n\n        :param int flags:\n            The condition to monitor on the queue (defaults to ``POLLIN``).\n        \"\"\"\n        if queue in self._queue_callbacks:\n            raise ValueError(f\"already watching {queue!r}\")\n        self._poller.register(queue, flags)\n        self._queue_callbacks[queue] = callback\n        return queue",
  "def watch_file(\n        self,\n        fd: int,\n        callback: Callable[[], typing.Any],\n        flags: int = zmq.POLLIN,\n    ) -> ZMQFileHandle:\n        \"\"\"\n        Call *callback* when *fd* has some data to read. No parameters are\n        passed to the callback. The *flags* are as for :meth:`watch_queue`.\n        Returns a handle that may be passed to :meth:`remove_watch_file`.\n\n        :param fd:\n            The file-like object, or fileno to monitor.\n\n        :param callback:\n            The function to call when the file has data available.\n\n        :param int flags:\n            The condition to monitor on the file (defaults to ``POLLIN``).\n        \"\"\"\n        if isinstance(fd, int):\n            fd = os.fdopen(fd)\n        self._poller.register(fd, flags)\n        self._queue_callbacks[fd.fileno()] = callback\n        return fd",
  "def remove_watch_queue(self, handle: ZMQQueueHandle) -> bool:\n        \"\"\"\n        Remove a queue from background polling. Returns ``True`` if the queue\n        was being monitored, ``False`` otherwise.\n        \"\"\"\n        try:\n            try:\n                self._poller.unregister(handle)\n            finally:\n                self._queue_callbacks.pop(handle, None)\n\n        except KeyError:\n            return False\n\n        return True",
  "def remove_watch_file(self, handle: ZMQFileHandle) -> bool:\n        \"\"\"\n        Remove a file from background polling. Returns ``True`` if the file was\n        being monitored, ``False`` otherwise.\n        \"\"\"\n        try:\n            try:\n                self._poller.unregister(handle)\n            finally:\n                self._queue_callbacks.pop(handle.fileno(), None)\n\n        except KeyError:\n            return False\n\n        return True",
  "def enter_idle(self, callback: Callable[[], typing.Any]) -> ZMQIdleHandle:\n        \"\"\"\n        Add a *callback* to be executed when the event loop detects it is idle.\n        Returns a handle that may be passed to :meth:`remove_enter_idle`.\n        \"\"\"\n        self._idle_handle += 1\n        self._idle_callbacks[self._idle_handle] = callback\n        return self._idle_handle",
  "def remove_enter_idle(self, handle: ZMQIdleHandle) -> bool:\n        \"\"\"\n        Remove an idle callback. Returns ``True`` if *handle* was removed,\n        ``False`` otherwise.\n        \"\"\"\n        try:\n            del self._idle_callbacks[handle]\n        except KeyError:\n            return False\n\n        return True",
  "def _entering_idle(self) -> None:\n        for callback in list(self._idle_callbacks.values()):\n            callback()",
  "def run(self) -> None:\n        \"\"\"\n        Start the event loop. Exit the loop when any callback raises an\n        exception. If :exc:`ExitMainLoop` is raised, exit cleanly.\n        \"\"\"\n        try:\n            while True:\n                try:\n                    self._loop()\n                except zmq.error.ZMQError as exc:  # noqa: PERF203\n                    if exc.errno != errno.EINTR:\n                        raise\n        except ExitMainLoop:\n            pass",
  "def _loop(self) -> None:\n        \"\"\"\n        A single iteration of the event loop.\n        \"\"\"\n        if self._alarms or self._did_something:\n            if self._alarms:\n                state = \"alarm\"\n                timeout = max(0, self._alarms[0][0] - time.time())\n            if self._did_something and (not self._alarms or (self._alarms and timeout > 0)):\n                state = \"idle\"\n                timeout = 0\n            ready = dict(self._poller.poll(timeout * 1000))\n        else:\n            state = \"wait\"\n            ready = dict(self._poller.poll())\n\n        if not ready:\n            if state == \"idle\":\n                self._entering_idle()\n                self._did_something = False\n            elif state == \"alarm\":\n                due, tie_break, callback = heapq.heappop(self._alarms)\n                callback()\n                self._did_something = True\n\n        for queue in ready:\n            self._queue_callbacks[queue]()\n            self._did_something = True",
  "class _TwistedInputDescriptor(FileDescriptor):\n    def __init__(self, reactor: IReactorFDSet, fd: int, cb: Callable[[], typing.Any]) -> None:\n        self._fileno = fd\n        self.cb = cb\n        super().__init__(reactor)\n\n    def fileno(self) -> int:\n        return self._fileno\n\n    def doRead(self):\n        return self.cb()",
  "class TwistedEventLoop(EventLoop):\n    \"\"\"\n    Event loop based on Twisted_\n    \"\"\"\n\n    _idle_emulation_delay = 1.0 / 256  # a short time (in seconds)\n\n    def __init__(self, reactor=None, manage_reactor: bool = True) -> None:\n        \"\"\"\n        :param reactor: reactor to use\n        :type reactor: :class:`twisted.internet.reactor`.\n        :param: manage_reactor: `True` if you want this event loop to run\n                                and stop the reactor.\n        :type manage_reactor: boolean\n\n        .. WARNING::\n           Twisted's reactor doesn't like to be stopped and run again.  If you\n           need to stop and run your :class:`MainLoop`, consider setting\n           ``manage_reactor=False`` and take care of running/stopping the reactor\n           at the beginning/ending of your program yourself.\n\n           You can also forego using :class:`MainLoop`'s run() entirely, and\n           instead call start() and stop() before and after starting the\n           reactor.\n\n        .. _Twisted: https://twisted.org/\n        \"\"\"\n        if reactor is None:\n            import twisted.internet.reactor\n\n            reactor = twisted.internet.reactor\n        self.reactor = reactor\n        self._watch_files: dict[int, _TwistedInputDescriptor] = {}\n        self._idle_handle: int = 0\n        self._twisted_idle_enabled = False\n        self._idle_callbacks: dict[int, Callable[[], typing.Any]] = {}\n        self._exc: BaseException | None = None\n        self.manage_reactor = manage_reactor\n        self._enable_twisted_idle()\n\n    def alarm(self, seconds: float, callback: Callable[[], typing.Any]):\n        \"\"\"\n        Call callback() a given time from now.  No parameters are\n        passed to callback.\n\n        Returns a handle that may be passed to remove_alarm()\n\n        seconds -- floating point time to wait before calling callback\n        callback -- function to call from event loop\n        \"\"\"\n        handle = self.reactor.callLater(seconds, self.handle_exit(callback))\n        return handle\n\n    def remove_alarm(self, handle) -> bool:\n        \"\"\"\n        Remove an alarm.\n\n        Returns True if the alarm exists, False otherwise\n        \"\"\"\n        try:\n            handle.cancel()\n\n        except (AlreadyCancelled, AlreadyCalled):\n            return False\n\n        return True\n\n    def watch_file(self, fd: int, callback: Callable[[], typing.Any]) -> int:\n        \"\"\"\n        Call callback() when fd has some data to read.  No parameters\n        are passed to callback.\n\n        Returns a handle that may be passed to remove_watch_file()\n\n        fd -- file descriptor to watch for input\n        callback -- function to call when input is available\n        \"\"\"\n        ind = _TwistedInputDescriptor(self.reactor, fd, self.handle_exit(callback))\n        self._watch_files[fd] = ind\n        self.reactor.addReader(ind)\n        return fd\n\n    def remove_watch_file(self, handle: int) -> bool:\n        \"\"\"\n        Remove an input file.\n\n        Returns True if the input file exists, False otherwise\n        \"\"\"\n        if handle in self._watch_files:\n            self.reactor.removeReader(self._watch_files[handle])\n            del self._watch_files[handle]\n            return True\n        return False\n\n    def enter_idle(self, callback: Callable[[], typing.Any]) -> int:\n        \"\"\"\n        Add a callback for entering idle.\n\n        Returns a handle that may be passed to remove_enter_idle()\n        \"\"\"\n        self._idle_handle += 1\n        self._idle_callbacks[self._idle_handle] = callback\n        return self._idle_handle\n\n    def _enable_twisted_idle(self) -> None:\n        \"\"\"\n        Twisted's reactors don't have an idle or enter-idle callback\n        so the best we can do for now is to set a timer event in a very\n        short time to approximate an enter-idle callback.\n\n        .. WARNING::\n           This will perform worse than the other event loops until we can find a\n           fix or workaround\n        \"\"\"\n        if self._twisted_idle_enabled:\n            return\n        self.reactor.callLater(\n            self._idle_emulation_delay,\n            self.handle_exit(self._twisted_idle_callback, enable_idle=False),\n        )\n        self._twisted_idle_enabled = True\n\n    def _twisted_idle_callback(self) -> None:\n        for callback in self._idle_callbacks.values():\n            callback()\n        self._twisted_idle_enabled = False\n\n    def remove_enter_idle(self, handle) -> bool:\n        \"\"\"\n        Remove an idle callback.\n\n        Returns True if the handle was removed.\n        \"\"\"\n        try:\n            del self._idle_callbacks[handle]\n        except KeyError:\n            return False\n        return True\n\n    def run(self) -> None:\n        \"\"\"\n        Start the event loop.  Exit the loop when any callback raises\n        an exception.  If ExitMainLoop is raised, exit cleanly.\n        \"\"\"\n        if not self.manage_reactor:\n            return\n        self.reactor.run()\n        if self._exc:\n            # An exception caused us to exit, raise it now\n            exc = self._exc\n            self._exc = None\n            raise exc.with_traceback(exc.__traceback__)\n\n    def handle_exit(self, f: Callable[_Spec, _T], enable_idle: bool = True) -> Callable[_Spec, _T | None]:\n        \"\"\"\n        Decorator that cleanly exits the :class:`TwistedEventLoop` if\n        :class:`ExitMainLoop` is thrown inside of the wrapped function. Store the\n        exception info if some other exception occurs, it will be reraised after\n        the loop quits.\n\n        *f* -- function to be wrapped\n        \"\"\"\n\n        def wrapper(*args: _Spec.args, **kwargs: _Spec.kwargs) -> _T | None:\n            rval = None\n            try:\n                rval = f(*args, **kwargs)\n            except ExitMainLoop:\n                if self.manage_reactor:\n                    self.reactor.stop()\n            except BaseException as exc:\n                print(sys.exc_info())\n                self._exc = exc\n                if self.manage_reactor:\n                    self.reactor.crash()\n            if enable_idle:\n                self._enable_twisted_idle()\n            return rval\n\n        return wrapper",
  "def __init__(self, reactor: IReactorFDSet, fd: int, cb: Callable[[], typing.Any]) -> None:\n        self._fileno = fd\n        self.cb = cb\n        super().__init__(reactor)",
  "def fileno(self) -> int:\n        return self._fileno",
  "def doRead(self):\n        return self.cb()",
  "def __init__(self, reactor=None, manage_reactor: bool = True) -> None:\n        \"\"\"\n        :param reactor: reactor to use\n        :type reactor: :class:`twisted.internet.reactor`.\n        :param: manage_reactor: `True` if you want this event loop to run\n                                and stop the reactor.\n        :type manage_reactor: boolean\n\n        .. WARNING::\n           Twisted's reactor doesn't like to be stopped and run again.  If you\n           need to stop and run your :class:`MainLoop`, consider setting\n           ``manage_reactor=False`` and take care of running/stopping the reactor\n           at the beginning/ending of your program yourself.\n\n           You can also forego using :class:`MainLoop`'s run() entirely, and\n           instead call start() and stop() before and after starting the\n           reactor.\n\n        .. _Twisted: https://twisted.org/\n        \"\"\"\n        if reactor is None:\n            import twisted.internet.reactor\n\n            reactor = twisted.internet.reactor\n        self.reactor = reactor\n        self._watch_files: dict[int, _TwistedInputDescriptor] = {}\n        self._idle_handle: int = 0\n        self._twisted_idle_enabled = False\n        self._idle_callbacks: dict[int, Callable[[], typing.Any]] = {}\n        self._exc: BaseException | None = None\n        self.manage_reactor = manage_reactor\n        self._enable_twisted_idle()",
  "def alarm(self, seconds: float, callback: Callable[[], typing.Any]):\n        \"\"\"\n        Call callback() a given time from now.  No parameters are\n        passed to callback.\n\n        Returns a handle that may be passed to remove_alarm()\n\n        seconds -- floating point time to wait before calling callback\n        callback -- function to call from event loop\n        \"\"\"\n        handle = self.reactor.callLater(seconds, self.handle_exit(callback))\n        return handle",
  "def remove_alarm(self, handle) -> bool:\n        \"\"\"\n        Remove an alarm.\n\n        Returns True if the alarm exists, False otherwise\n        \"\"\"\n        try:\n            handle.cancel()\n\n        except (AlreadyCancelled, AlreadyCalled):\n            return False\n\n        return True",
  "def watch_file(self, fd: int, callback: Callable[[], typing.Any]) -> int:\n        \"\"\"\n        Call callback() when fd has some data to read.  No parameters\n        are passed to callback.\n\n        Returns a handle that may be passed to remove_watch_file()\n\n        fd -- file descriptor to watch for input\n        callback -- function to call when input is available\n        \"\"\"\n        ind = _TwistedInputDescriptor(self.reactor, fd, self.handle_exit(callback))\n        self._watch_files[fd] = ind\n        self.reactor.addReader(ind)\n        return fd",
  "def remove_watch_file(self, handle: int) -> bool:\n        \"\"\"\n        Remove an input file.\n\n        Returns True if the input file exists, False otherwise\n        \"\"\"\n        if handle in self._watch_files:\n            self.reactor.removeReader(self._watch_files[handle])\n            del self._watch_files[handle]\n            return True\n        return False",
  "def enter_idle(self, callback: Callable[[], typing.Any]) -> int:\n        \"\"\"\n        Add a callback for entering idle.\n\n        Returns a handle that may be passed to remove_enter_idle()\n        \"\"\"\n        self._idle_handle += 1\n        self._idle_callbacks[self._idle_handle] = callback\n        return self._idle_handle",
  "def _enable_twisted_idle(self) -> None:\n        \"\"\"\n        Twisted's reactors don't have an idle or enter-idle callback\n        so the best we can do for now is to set a timer event in a very\n        short time to approximate an enter-idle callback.\n\n        .. WARNING::\n           This will perform worse than the other event loops until we can find a\n           fix or workaround\n        \"\"\"\n        if self._twisted_idle_enabled:\n            return\n        self.reactor.callLater(\n            self._idle_emulation_delay,\n            self.handle_exit(self._twisted_idle_callback, enable_idle=False),\n        )\n        self._twisted_idle_enabled = True",
  "def _twisted_idle_callback(self) -> None:\n        for callback in self._idle_callbacks.values():\n            callback()\n        self._twisted_idle_enabled = False",
  "def remove_enter_idle(self, handle) -> bool:\n        \"\"\"\n        Remove an idle callback.\n\n        Returns True if the handle was removed.\n        \"\"\"\n        try:\n            del self._idle_callbacks[handle]\n        except KeyError:\n            return False\n        return True",
  "def run(self) -> None:\n        \"\"\"\n        Start the event loop.  Exit the loop when any callback raises\n        an exception.  If ExitMainLoop is raised, exit cleanly.\n        \"\"\"\n        if not self.manage_reactor:\n            return\n        self.reactor.run()\n        if self._exc:\n            # An exception caused us to exit, raise it now\n            exc = self._exc\n            self._exc = None\n            raise exc.with_traceback(exc.__traceback__)",
  "def handle_exit(self, f: Callable[_Spec, _T], enable_idle: bool = True) -> Callable[_Spec, _T | None]:\n        \"\"\"\n        Decorator that cleanly exits the :class:`TwistedEventLoop` if\n        :class:`ExitMainLoop` is thrown inside of the wrapped function. Store the\n        exception info if some other exception occurs, it will be reraised after\n        the loop quits.\n\n        *f* -- function to be wrapped\n        \"\"\"\n\n        def wrapper(*args: _Spec.args, **kwargs: _Spec.kwargs) -> _T | None:\n            rval = None\n            try:\n                rval = f(*args, **kwargs)\n            except ExitMainLoop:\n                if self.manage_reactor:\n                    self.reactor.stop()\n            except BaseException as exc:\n                print(sys.exc_info())\n                self._exc = exc\n                if self.manage_reactor:\n                    self.reactor.crash()\n            if enable_idle:\n                self._enable_twisted_idle()\n            return rval\n\n        return wrapper",
  "def wrapper(*args: _Spec.args, **kwargs: _Spec.kwargs) -> _T | None:\n            rval = None\n            try:\n                rval = f(*args, **kwargs)\n            except ExitMainLoop:\n                if self.manage_reactor:\n                    self.reactor.stop()\n            except BaseException as exc:\n                print(sys.exc_info())\n                self._exc = exc\n                if self.manage_reactor:\n                    self.reactor.crash()\n            if enable_idle:\n                self._enable_twisted_idle()\n            return rval",
  "class _TrioIdleCallbackInstrument(trio.abc.Instrument):\n    \"\"\"IDLE callbacks emulation helper.\"\"\"\n\n    __slots__ = (\"idle_callbacks\",)\n\n    def __init__(self, idle_callbacks):\n        self.idle_callbacks = idle_callbacks\n\n    def before_io_wait(self, timeout):\n        if timeout > 0:\n            for idle_callback in self.idle_callbacks.values():\n                idle_callback()",
  "class TrioEventLoop(EventLoop):\n    \"\"\"\n    Event loop based on the ``trio`` module.\n\n    ``trio`` is an async library for Python 3.5 and later.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Constructor.\"\"\"\n\n        self._idle_handle = 0\n        self._idle_callbacks = {}\n        self._pending_tasks = []\n\n        self._nursery = None\n\n        self._sleep = trio.sleep\n        self._wait_readable = trio.lowlevel.wait_readable\n\n    def alarm(self, seconds: float, callback: Callable[[], typing.Any]):\n        \"\"\"Calls `callback()` a given time from now.  No parameters are passed\n        to the callback.\n\n        Parameters:\n            seconds: time in seconds to wait before calling the callback\n            callback: function to call from the event loop\n\n        Returns:\n            a handle that may be passed to `remove_alarm()`\n        \"\"\"\n        return self._start_task(self._alarm_task, seconds, callback)\n\n    def enter_idle(self, callback: Callable[[], typing.Any]) -> int:\n        \"\"\"Calls `callback()` when the event loop enters the idle state.\n\n        There is no such thing as being idle in a Trio event loop so we\n        simulate it by repeatedly calling `callback()` with a short delay.\n        \"\"\"\n        self._idle_handle += 1\n        self._idle_callbacks[self._idle_handle] = callback\n        return self._idle_handle\n\n    def remove_alarm(self, handle):\n        \"\"\"Removes an alarm.\n\n        Parameters:\n            handle: the handle of the alarm to remove\n        \"\"\"\n        return self._cancel_scope(handle)\n\n    def remove_enter_idle(self, handle) -> bool:\n        \"\"\"Removes an idle callback.\n\n        Parameters:\n            handle: the handle of the idle callback to remove\n        \"\"\"\n        try:\n            del self._idle_callbacks[handle]\n        except KeyError:\n            return False\n        return True\n\n    def remove_watch_file(self, handle: trio.CancelScope) -> bool:\n        \"\"\"Removes a file descriptor being watched for input.\n\n        Parameters:\n            handle: the handle of the file descriptor callback to remove\n\n        Returns:\n            True if the file descriptor was watched, False otherwise\n        \"\"\"\n        return self._cancel_scope(handle)\n\n    def _cancel_scope(self, scope: trio.CancelScope) -> bool:\n        \"\"\"Cancels the given Trio cancellation scope.\n\n        Returns:\n            True if the scope was cancelled, False if it was cancelled already\n            before invoking this function\n        \"\"\"\n        existed = not scope.cancel_called\n        scope.cancel()\n        return existed\n\n    def run(self) -> None:\n        \"\"\"Starts the event loop. Exits the loop when any callback raises an\n        exception. If ExitMainLoop is raised, exits cleanly.\n        \"\"\"\n\n        emulate_idle_callbacks = _TrioIdleCallbackInstrument(self._idle_callbacks)\n\n        # TODO(Aleksei): trio.MultiError is deprecated in favor of exceptiongroup package usage and `Except *`\n        with trio.MultiError.catch(self._handle_main_loop_exception):\n            trio.run(self._main_task, instruments=[emulate_idle_callbacks])\n\n    async def run_async(self):\n        \"\"\"Starts the main loop and blocks asynchronously until the main loop\n        exits. This allows one to embed an urwid app in a Trio app even if the\n        Trio event loop is already running. Example::\n\n            with trio.open_nursery() as nursery:\n                event_loop = urwid.TrioEventLoop()\n\n                # [...launch other async tasks in the nursery...]\n\n                loop = urwid.MainLoop(widget, event_loop=event_loop)\n                with loop.start():\n                    await event_loop.run_async()\n\n                nursery.cancel_scope.cancel()\n        \"\"\"\n\n        emulate_idle_callbacks = _TrioIdleCallbackInstrument(self._idle_callbacks)\n\n        with trio.MultiError.catch(self._handle_main_loop_exception):\n            trio.lowlevel.add_instrument(emulate_idle_callbacks)\n            try:\n                await self._main_task()\n            finally:\n                trio.lowlevel.remove_instrument(emulate_idle_callbacks)\n\n    def watch_file(self, fd: int, callback: Callable[[], typing.Any]) -> trio.CancelScope:\n        \"\"\"Calls `callback()` when the given file descriptor has some data\n        to read. No parameters are passed to the callback.\n\n        Parameters:\n            fd: file descriptor to watch for input\n            callback: function to call when some input is available\n\n        Returns:\n            a handle that may be passed to `remove_watch_file()`\n        \"\"\"\n        return self._start_task(self._watch_task, fd, callback)\n\n    async def _alarm_task(\n        self,\n        scope: trio.CancelScope,\n        seconds: float,\n        callback: Callable[[], typing.Any],\n    ) -> None:\n        \"\"\"Asynchronous task that sleeps for a given number of seconds and then\n        calls the given callback.\n\n        Parameters:\n            scope: the cancellation scope that can be used to cancel the task\n            seconds: the number of seconds to wait\n            callback: the callback to call\n        \"\"\"\n        with scope:\n            await self._sleep(seconds)\n            callback()\n\n    def _handle_main_loop_exception(self, exc: BaseException) -> BaseException | None:\n        \"\"\"Handles exceptions raised from the main loop, catching ExitMainLoop\n        instead of letting it propagate through.\n\n        Note that since Trio may collect multiple exceptions from tasks into a\n        Trio MultiError, we cannot simply use a try..catch clause, we need a\n        helper function like this.\n        \"\"\"\n        self._idle_callbacks.clear()\n        if isinstance(exc, ExitMainLoop):\n            return None\n\n        return exc\n\n    async def _main_task(self):\n        \"\"\"Main Trio task that opens a nursery and then sleeps until the user\n        exits the app by raising ExitMainLoop.\n        \"\"\"\n        try:\n            async with trio.open_nursery() as self._nursery:\n                self._schedule_pending_tasks()\n                await trio.sleep_forever()\n        finally:\n            self._nursery = None\n\n    def _schedule_pending_tasks(self):\n        \"\"\"Schedules all pending asynchronous tasks that were created before\n        the nursery to be executed on the nursery soon.\n        \"\"\"\n        for task, scope, args in self._pending_tasks:\n            self._nursery.start_soon(task, scope, *args)\n        del self._pending_tasks[:]\n\n    def _start_task(self, task, *args):\n        \"\"\"Starts an asynchronous task in the Trio nursery managed by the\n        main loop. If the nursery has not started yet, store a reference to\n        the task and the arguments so we can start the task when the nursery\n        is open.\n\n        Parameters:\n            task: a Trio task to run\n\n        Returns:\n            a cancellation scope for the Trio task\n        \"\"\"\n        scope = trio.CancelScope()\n        if self._nursery:\n            self._nursery.start_soon(task, scope, *args)\n        else:\n            self._pending_tasks.append((task, scope, args))\n        return scope\n\n    async def _watch_task(self, scope, fd, callback):\n        \"\"\"Asynchronous task that watches the given file descriptor and calls\n        the given callback whenever the file descriptor becomes readable.\n\n        Parameters:\n            scope: the cancellation scope that can be used to cancel the task\n            fd: the file descriptor to watch\n            callback: the callback to call\n        \"\"\"\n        with scope:\n            # We check for the scope being cancelled before calling\n            # wait_readable because if callback cancels the scope, fd might be\n            # closed and calling wait_readable with a closed fd does not work.\n            while not scope.cancel_called:\n                await self._wait_readable(fd)\n                callback()",
  "def __init__(self, idle_callbacks):\n        self.idle_callbacks = idle_callbacks",
  "def before_io_wait(self, timeout):\n        if timeout > 0:\n            for idle_callback in self.idle_callbacks.values():\n                idle_callback()",
  "def __init__(self):\n        \"\"\"Constructor.\"\"\"\n\n        self._idle_handle = 0\n        self._idle_callbacks = {}\n        self._pending_tasks = []\n\n        self._nursery = None\n\n        self._sleep = trio.sleep\n        self._wait_readable = trio.lowlevel.wait_readable",
  "def alarm(self, seconds: float, callback: Callable[[], typing.Any]):\n        \"\"\"Calls `callback()` a given time from now.  No parameters are passed\n        to the callback.\n\n        Parameters:\n            seconds: time in seconds to wait before calling the callback\n            callback: function to call from the event loop\n\n        Returns:\n            a handle that may be passed to `remove_alarm()`\n        \"\"\"\n        return self._start_task(self._alarm_task, seconds, callback)",
  "def enter_idle(self, callback: Callable[[], typing.Any]) -> int:\n        \"\"\"Calls `callback()` when the event loop enters the idle state.\n\n        There is no such thing as being idle in a Trio event loop so we\n        simulate it by repeatedly calling `callback()` with a short delay.\n        \"\"\"\n        self._idle_handle += 1\n        self._idle_callbacks[self._idle_handle] = callback\n        return self._idle_handle",
  "def remove_alarm(self, handle):\n        \"\"\"Removes an alarm.\n\n        Parameters:\n            handle: the handle of the alarm to remove\n        \"\"\"\n        return self._cancel_scope(handle)",
  "def remove_enter_idle(self, handle) -> bool:\n        \"\"\"Removes an idle callback.\n\n        Parameters:\n            handle: the handle of the idle callback to remove\n        \"\"\"\n        try:\n            del self._idle_callbacks[handle]\n        except KeyError:\n            return False\n        return True",
  "def remove_watch_file(self, handle: trio.CancelScope) -> bool:\n        \"\"\"Removes a file descriptor being watched for input.\n\n        Parameters:\n            handle: the handle of the file descriptor callback to remove\n\n        Returns:\n            True if the file descriptor was watched, False otherwise\n        \"\"\"\n        return self._cancel_scope(handle)",
  "def _cancel_scope(self, scope: trio.CancelScope) -> bool:\n        \"\"\"Cancels the given Trio cancellation scope.\n\n        Returns:\n            True if the scope was cancelled, False if it was cancelled already\n            before invoking this function\n        \"\"\"\n        existed = not scope.cancel_called\n        scope.cancel()\n        return existed",
  "def run(self) -> None:\n        \"\"\"Starts the event loop. Exits the loop when any callback raises an\n        exception. If ExitMainLoop is raised, exits cleanly.\n        \"\"\"\n\n        emulate_idle_callbacks = _TrioIdleCallbackInstrument(self._idle_callbacks)\n\n        # TODO(Aleksei): trio.MultiError is deprecated in favor of exceptiongroup package usage and `Except *`\n        with trio.MultiError.catch(self._handle_main_loop_exception):\n            trio.run(self._main_task, instruments=[emulate_idle_callbacks])",
  "async def run_async(self):\n        \"\"\"Starts the main loop and blocks asynchronously until the main loop\n        exits. This allows one to embed an urwid app in a Trio app even if the\n        Trio event loop is already running. Example::\n\n            with trio.open_nursery() as nursery:\n                event_loop = urwid.TrioEventLoop()\n\n                # [...launch other async tasks in the nursery...]\n\n                loop = urwid.MainLoop(widget, event_loop=event_loop)\n                with loop.start():\n                    await event_loop.run_async()\n\n                nursery.cancel_scope.cancel()\n        \"\"\"\n\n        emulate_idle_callbacks = _TrioIdleCallbackInstrument(self._idle_callbacks)\n\n        with trio.MultiError.catch(self._handle_main_loop_exception):\n            trio.lowlevel.add_instrument(emulate_idle_callbacks)\n            try:\n                await self._main_task()\n            finally:\n                trio.lowlevel.remove_instrument(emulate_idle_callbacks)",
  "def watch_file(self, fd: int, callback: Callable[[], typing.Any]) -> trio.CancelScope:\n        \"\"\"Calls `callback()` when the given file descriptor has some data\n        to read. No parameters are passed to the callback.\n\n        Parameters:\n            fd: file descriptor to watch for input\n            callback: function to call when some input is available\n\n        Returns:\n            a handle that may be passed to `remove_watch_file()`\n        \"\"\"\n        return self._start_task(self._watch_task, fd, callback)",
  "async def _alarm_task(\n        self,\n        scope: trio.CancelScope,\n        seconds: float,\n        callback: Callable[[], typing.Any],\n    ) -> None:\n        \"\"\"Asynchronous task that sleeps for a given number of seconds and then\n        calls the given callback.\n\n        Parameters:\n            scope: the cancellation scope that can be used to cancel the task\n            seconds: the number of seconds to wait\n            callback: the callback to call\n        \"\"\"\n        with scope:\n            await self._sleep(seconds)\n            callback()",
  "def _handle_main_loop_exception(self, exc: BaseException) -> BaseException | None:\n        \"\"\"Handles exceptions raised from the main loop, catching ExitMainLoop\n        instead of letting it propagate through.\n\n        Note that since Trio may collect multiple exceptions from tasks into a\n        Trio MultiError, we cannot simply use a try..catch clause, we need a\n        helper function like this.\n        \"\"\"\n        self._idle_callbacks.clear()\n        if isinstance(exc, ExitMainLoop):\n            return None\n\n        return exc",
  "async def _main_task(self):\n        \"\"\"Main Trio task that opens a nursery and then sleeps until the user\n        exits the app by raising ExitMainLoop.\n        \"\"\"\n        try:\n            async with trio.open_nursery() as self._nursery:\n                self._schedule_pending_tasks()\n                await trio.sleep_forever()\n        finally:\n            self._nursery = None",
  "def _schedule_pending_tasks(self):\n        \"\"\"Schedules all pending asynchronous tasks that were created before\n        the nursery to be executed on the nursery soon.\n        \"\"\"\n        for task, scope, args in self._pending_tasks:\n            self._nursery.start_soon(task, scope, *args)\n        del self._pending_tasks[:]",
  "def _start_task(self, task, *args):\n        \"\"\"Starts an asynchronous task in the Trio nursery managed by the\n        main loop. If the nursery has not started yet, store a reference to\n        the task and the arguments so we can start the task when the nursery\n        is open.\n\n        Parameters:\n            task: a Trio task to run\n\n        Returns:\n            a cancellation scope for the Trio task\n        \"\"\"\n        scope = trio.CancelScope()\n        if self._nursery:\n            self._nursery.start_soon(task, scope, *args)\n        else:\n            self._pending_tasks.append((task, scope, args))\n        return scope",
  "async def _watch_task(self, scope, fd, callback):\n        \"\"\"Asynchronous task that watches the given file descriptor and calls\n        the given callback whenever the file descriptor becomes readable.\n\n        Parameters:\n            scope: the cancellation scope that can be used to cancel the task\n            fd: the file descriptor to watch\n            callback: the callback to call\n        \"\"\"\n        with scope:\n            # We check for the scope being cancelled before calling\n            # wait_readable because if callback cancels the scope, fd might be\n            # closed and calling wait_readable with a closed fd does not work.\n            while not scope.cancel_called:\n                await self._wait_readable(fd)\n                callback()",
  "class TornadoEventLoop(EventLoop):\n    \"\"\"This is an Urwid-specific event loop to plug into its MainLoop.\n    It acts as an adaptor for Tornado's IOLoop which does all\n    heavy lifting except idle-callbacks.\n    \"\"\"\n\n    def __init__(self, loop: ioloop.IOLoop | None = None) -> None:\n        if loop:\n            self._loop: ioloop.IOLoop = loop\n        else:\n            self._loop = ioloop.IOLoop.current()  # TODO(Aleksei): Switch to the syncio.EventLoop as tornado >= 6.0 !\n\n        self._pending_alarms: dict[object, int] = {}\n        self._watch_handles: dict[int, int] = {}  # {<watch_handle> : <file_descriptor>}\n        self._max_watch_handle: int = 0\n        self._exc: BaseException | None = None\n\n        self._idle_asyncio_handle: object | None = None\n        self._idle_handle: int = 0\n        self._idle_callbacks: dict[int, Callable[[], typing.Any]] = {}\n\n    def _also_call_idle(self, callback: Callable[_Spec, _T]) -> Callable[_Spec, _T]:\n        \"\"\"\n        Wrap the callback to also call _entering_idle.\n        \"\"\"\n\n        @functools.wraps(callback)\n        def wrapper(*args: _Spec.args, **kwargs: _Spec.kwargs) -> _T:\n            if not self._idle_asyncio_handle:\n                self._idle_asyncio_handle = self._loop.call_later(0, self._entering_idle)\n            return callback(*args, **kwargs)\n\n        return wrapper\n\n    def _entering_idle(self) -> None:\n        \"\"\"\n        Call all the registered idle callbacks.\n        \"\"\"\n        try:\n            for callback in self._idle_callbacks.values():\n                callback()\n        finally:\n            self._idle_asyncio_handle = None\n\n    def alarm(self, seconds: float, callback: Callable[[], typing.Any]):\n        @self._also_call_idle\n        @functools.wraps(callback)\n        def wrapped() -> None:\n            with contextlib.suppress(KeyError):\n                del self._pending_alarms[handle]\n\n            self.handle_exit(callback)()\n\n        handle = self._loop.add_timeout(self._loop.time() + seconds, wrapped)\n        self._pending_alarms[handle] = 1\n        return handle\n\n    def remove_alarm(self, handle: object) -> bool:\n        self._loop.remove_timeout(handle)\n        try:\n            del self._pending_alarms[handle]\n        except KeyError:\n            return False\n        else:\n            return True\n\n    def watch_file(self, fd: int, callback: Callable[[], _T]) -> int:\n        @self._also_call_idle\n        def handler(_fd: int, _events: int) -> None:\n            self.handle_exit(callback)()\n\n        self._loop.add_handler(fd, handler, ioloop.IOLoop.READ)\n        self._max_watch_handle += 1\n        handle = self._max_watch_handle\n        self._watch_handles[handle] = fd\n        return handle\n\n    def remove_watch_file(self, handle: int) -> bool:\n        fd = self._watch_handles.pop(handle, None)\n        if fd is None:\n            return False\n\n        self._loop.remove_handler(fd)\n        return True\n\n    def enter_idle(self, callback: Callable[[], typing.Any]) -> int:\n        \"\"\"\n        Add a callback for entering idle.\n\n        Returns a handle that may be passed to remove_idle()\n        \"\"\"\n        # XXX there's no such thing as \"idle\" in most event loops; this fakes\n        # it by adding extra callback to the timer and file watch callbacks.\n        self._idle_handle += 1\n        self._idle_callbacks[self._idle_handle] = callback\n        return self._idle_handle\n\n    def remove_enter_idle(self, handle: int) -> bool:\n        \"\"\"\n        Remove an idle callback.\n\n        Returns True if the handle was removed.\n        \"\"\"\n        try:\n            del self._idle_callbacks[handle]\n        except KeyError:\n            return False\n        return True\n\n    def handle_exit(self, f: Callable[_Spec, _T]) -> Callable[_Spec, _T | Literal[False]]:\n        @functools.wraps(f)\n        def wrapper(*args: _Spec.args, **kwargs: _Spec.kwargs) -> _T | Literal[False]:\n            try:\n                return f(*args, **kwargs)\n            except ExitMainLoop:\n                pass  # handled later\n            except Exception as exc:\n                self._exc = exc\n\n            if self._idle_asyncio_handle:\n                # clean it up to prevent old callbacks\n                # from messing things up if loop is restarted\n                self._loop.remove_timeout(self._idle_asyncio_handle)\n                self._idle_asyncio_handle = None\n\n            self._loop.stop()\n            return False\n\n        return wrapper\n\n    def run(self) -> None:\n        self._loop.start()\n        if self._exc:\n            exc, self._exc = self._exc, None\n            raise exc.with_traceback(exc.__traceback__)",
  "def __init__(self, loop: ioloop.IOLoop | None = None) -> None:\n        if loop:\n            self._loop: ioloop.IOLoop = loop\n        else:\n            self._loop = ioloop.IOLoop.current()  # TODO(Aleksei): Switch to the syncio.EventLoop as tornado >= 6.0 !\n\n        self._pending_alarms: dict[object, int] = {}\n        self._watch_handles: dict[int, int] = {}  # {<watch_handle> : <file_descriptor>}\n        self._max_watch_handle: int = 0\n        self._exc: BaseException | None = None\n\n        self._idle_asyncio_handle: object | None = None\n        self._idle_handle: int = 0\n        self._idle_callbacks: dict[int, Callable[[], typing.Any]] = {}",
  "def _also_call_idle(self, callback: Callable[_Spec, _T]) -> Callable[_Spec, _T]:\n        \"\"\"\n        Wrap the callback to also call _entering_idle.\n        \"\"\"\n\n        @functools.wraps(callback)\n        def wrapper(*args: _Spec.args, **kwargs: _Spec.kwargs) -> _T:\n            if not self._idle_asyncio_handle:\n                self._idle_asyncio_handle = self._loop.call_later(0, self._entering_idle)\n            return callback(*args, **kwargs)\n\n        return wrapper",
  "def _entering_idle(self) -> None:\n        \"\"\"\n        Call all the registered idle callbacks.\n        \"\"\"\n        try:\n            for callback in self._idle_callbacks.values():\n                callback()\n        finally:\n            self._idle_asyncio_handle = None",
  "def alarm(self, seconds: float, callback: Callable[[], typing.Any]):\n        @self._also_call_idle\n        @functools.wraps(callback)\n        def wrapped() -> None:\n            with contextlib.suppress(KeyError):\n                del self._pending_alarms[handle]\n\n            self.handle_exit(callback)()\n\n        handle = self._loop.add_timeout(self._loop.time() + seconds, wrapped)\n        self._pending_alarms[handle] = 1\n        return handle",
  "def remove_alarm(self, handle: object) -> bool:\n        self._loop.remove_timeout(handle)\n        try:\n            del self._pending_alarms[handle]\n        except KeyError:\n            return False\n        else:\n            return True",
  "def watch_file(self, fd: int, callback: Callable[[], _T]) -> int:\n        @self._also_call_idle\n        def handler(_fd: int, _events: int) -> None:\n            self.handle_exit(callback)()\n\n        self._loop.add_handler(fd, handler, ioloop.IOLoop.READ)\n        self._max_watch_handle += 1\n        handle = self._max_watch_handle\n        self._watch_handles[handle] = fd\n        return handle",
  "def remove_watch_file(self, handle: int) -> bool:\n        fd = self._watch_handles.pop(handle, None)\n        if fd is None:\n            return False\n\n        self._loop.remove_handler(fd)\n        return True",
  "def enter_idle(self, callback: Callable[[], typing.Any]) -> int:\n        \"\"\"\n        Add a callback for entering idle.\n\n        Returns a handle that may be passed to remove_idle()\n        \"\"\"\n        # XXX there's no such thing as \"idle\" in most event loops; this fakes\n        # it by adding extra callback to the timer and file watch callbacks.\n        self._idle_handle += 1\n        self._idle_callbacks[self._idle_handle] = callback\n        return self._idle_handle",
  "def remove_enter_idle(self, handle: int) -> bool:\n        \"\"\"\n        Remove an idle callback.\n\n        Returns True if the handle was removed.\n        \"\"\"\n        try:\n            del self._idle_callbacks[handle]\n        except KeyError:\n            return False\n        return True",
  "def handle_exit(self, f: Callable[_Spec, _T]) -> Callable[_Spec, _T | Literal[False]]:\n        @functools.wraps(f)\n        def wrapper(*args: _Spec.args, **kwargs: _Spec.kwargs) -> _T | Literal[False]:\n            try:\n                return f(*args, **kwargs)\n            except ExitMainLoop:\n                pass  # handled later\n            except Exception as exc:\n                self._exc = exc\n\n            if self._idle_asyncio_handle:\n                # clean it up to prevent old callbacks\n                # from messing things up if loop is restarted\n                self._loop.remove_timeout(self._idle_asyncio_handle)\n                self._idle_asyncio_handle = None\n\n            self._loop.stop()\n            return False\n\n        return wrapper",
  "def run(self) -> None:\n        self._loop.start()\n        if self._exc:\n            exc, self._exc = self._exc, None\n            raise exc.with_traceback(exc.__traceback__)",
  "def wrapper(*args: _Spec.args, **kwargs: _Spec.kwargs) -> _T:\n            if not self._idle_asyncio_handle:\n                self._idle_asyncio_handle = self._loop.call_later(0, self._entering_idle)\n            return callback(*args, **kwargs)",
  "def wrapped() -> None:\n            with contextlib.suppress(KeyError):\n                del self._pending_alarms[handle]\n\n            self.handle_exit(callback)()",
  "def handler(_fd: int, _events: int) -> None:\n            self.handle_exit(callback)()",
  "def wrapper(*args: _Spec.args, **kwargs: _Spec.kwargs) -> _T | Literal[False]:\n            try:\n                return f(*args, **kwargs)\n            except ExitMainLoop:\n                pass  # handled later\n            except Exception as exc:\n                self._exc = exc\n\n            if self._idle_asyncio_handle:\n                # clean it up to prevent old callbacks\n                # from messing things up if loop is restarted\n                self._loop.remove_timeout(self._idle_asyncio_handle)\n                self._idle_asyncio_handle = None\n\n            self._loop.stop()\n            return False",
  "def _ignore_handler(_sig: int, _frame: FrameType | None = None) -> None:\n    return None",
  "class GLibEventLoop(EventLoop):\n    \"\"\"\n    Event loop based on GLib.MainLoop\n    \"\"\"\n\n    def __init__(self) -> None:\n        self._alarms: list[int] = []\n        self._watch_files: dict[int, int] = {}\n        self._idle_handle: int = 0\n        self._glib_idle_enabled = False  # have we called glib.idle_add?\n        self._idle_callbacks: dict[int, Callable[[], typing.Any]] = {}\n        self._loop = GLib.MainLoop()\n        self._exc: BaseException | None = None\n        self._enable_glib_idle()\n        self._signal_handlers: dict[int, int] = {}\n\n    def alarm(\n        self,\n        seconds: float,\n        callback: Callable[[], typing.Any],\n    ) -> tuple[int, Callable[[], typing.Any]]:\n        \"\"\"\n        Call callback() a given time from now.  No parameters are\n        passed to callback.\n\n        Returns a handle that may be passed to remove_alarm()\n\n        seconds -- floating point time to wait before calling callback\n        callback -- function to call from event loop\n        \"\"\"\n\n        @self.handle_exit\n        def ret_false() -> Literal[False]:\n            callback()\n            self._enable_glib_idle()\n            return False\n\n        fd = GLib.timeout_add(int(seconds * 1000), ret_false)\n        self._alarms.append(fd)\n        return (fd, callback)\n\n    def set_signal_handler(\n        self,\n        signum: int,\n        handler: Callable[[int, FrameType | None], typing.Any] | int | signal.Handlers,\n    ) -> None:\n        \"\"\"\n        Sets the signal handler for signal signum.\n\n        .. WARNING::\n            Because this method uses the `GLib`-specific `unix_signal_add`\n            function, its behaviour is different than `signal.signal().`\n\n            If `signum` is not `SIGHUP`, `SIGINT`, `SIGTERM`, `SIGUSR1`,\n            `SIGUSR2` or `SIGWINCH`, this method performs no actions and\n            immediately returns None.\n\n            Returns None in all cases (unlike :func:`signal.signal()`).\n        ..\n\n        signum -- signal number\n        handler -- function (taking signum as its single argument),\n        or `signal.SIG_IGN`, or `signal.SIG_DFL`\n        \"\"\"\n        glib_signals = [\n            signal.SIGHUP,\n            signal.SIGINT,\n            signal.SIGTERM,\n            signal.SIGUSR1,\n            signal.SIGUSR2,\n        ]\n\n        # GLib supports SIGWINCH as of version 2.54.\n        if not GLib.check_version(2, 54, 0):\n            glib_signals.append(signal.SIGWINCH)\n\n        if signum not in glib_signals:\n            # The GLib event loop supports only the signals listed above\n            return\n\n        if signum in self._signal_handlers:\n            GLib.source_remove(self._signal_handlers.pop(signum))\n\n        if handler == signal.Handlers.SIG_IGN:\n            handler = _ignore_handler\n        elif handler == signal.Handlers.SIG_DFL:\n            return\n\n        def final_handler(signal_number: int):\n            # MyPy False-negative: signal.Handlers casted\n            handler(signal_number, None)  # type: ignore[operator]\n            return GLib.SOURCE_CONTINUE\n\n        source = GLib.unix_signal_add(GLib.PRIORITY_DEFAULT, signum, final_handler, signum)\n        self._signal_handlers[signum] = source\n\n    def remove_alarm(self, handle) -> bool:\n        \"\"\"\n        Remove an alarm.\n\n        Returns True if the alarm exists, False otherwise\n        \"\"\"\n        try:\n            self._alarms.remove(handle[0])\n            GLib.source_remove(handle[0])\n\n        except ValueError:\n            return False\n\n        return True\n\n    def watch_file(self, fd: int, callback: Callable[[], typing.Any]) -> int:\n        \"\"\"\n        Call callback() when fd has some data to read.  No parameters\n        are passed to callback.\n\n        Returns a handle that may be passed to remove_watch_file()\n\n        fd -- file descriptor to watch for input\n        callback -- function to call when input is available\n        \"\"\"\n\n        @self.handle_exit\n        def io_callback(source, cb_condition) -> Literal[True]:\n            callback()\n            self._enable_glib_idle()\n            return True\n\n        self._watch_files[fd] = GLib.io_add_watch(fd, GLib.IO_IN, io_callback)\n        return fd\n\n    def remove_watch_file(self, handle: int) -> bool:\n        \"\"\"\n        Remove an input file.\n\n        Returns True if the input file exists, False otherwise\n        \"\"\"\n        if handle in self._watch_files:\n            GLib.source_remove(self._watch_files[handle])\n            del self._watch_files[handle]\n            return True\n        return False\n\n    def enter_idle(self, callback: Callable[[], typing.Any]) -> int:\n        \"\"\"\n        Add a callback for entering idle.\n\n        Returns a handle that may be passed to remove_enter_idle()\n        \"\"\"\n        self._idle_handle += 1\n        self._idle_callbacks[self._idle_handle] = callback\n        return self._idle_handle\n\n    def _enable_glib_idle(self) -> None:\n        if self._glib_idle_enabled:\n            return\n        GLib.idle_add(self._glib_idle_callback)\n        self._glib_idle_enabled = True\n\n    def _glib_idle_callback(self):\n        for callback in self._idle_callbacks.values():\n            callback()\n        self._glib_idle_enabled = False\n        return False  # ask glib not to call again (or we would be called\n\n    def remove_enter_idle(self, handle) -> bool:\n        \"\"\"\n        Remove an idle callback.\n\n        Returns True if the handle was removed.\n        \"\"\"\n        try:\n            del self._idle_callbacks[handle]\n        except KeyError:\n            return False\n        return True\n\n    def run(self) -> None:\n        \"\"\"\n        Start the event loop.  Exit the loop when any callback raises\n        an exception.  If ExitMainLoop is raised, exit cleanly.\n        \"\"\"\n        try:\n            self._loop.run()\n        finally:\n            if self._loop.is_running():\n                self._loop.quit()\n        if self._exc:\n            # An exception caused us to exit, raise it now\n            exc = self._exc\n            self._exc = None\n            raise exc.with_traceback(exc.__traceback__)\n\n    def handle_exit(self, f: Callable[_Spec, _T]) -> Callable[_Spec, _T | Literal[False]]:\n        \"\"\"\n        Decorator that cleanly exits the :class:`GLibEventLoop` if\n        :exc:`ExitMainLoop` is thrown inside of the wrapped function. Store the\n        exception info if some other exception occurs, it will be reraised after\n        the loop quits.\n\n        *f* -- function to be wrapped\n        \"\"\"\n\n        @functools.wraps(f)\n        def wrapper(*args: _Spec.args, **kwargs: _Spec.kwargs) -> _T | Literal[False]:\n            try:\n                return f(*args, **kwargs)\n            except ExitMainLoop:\n                self._loop.quit()\n            except BaseException as exc:\n                self._exc = exc\n                if self._loop.is_running():\n                    self._loop.quit()\n            return False\n\n        return wrapper",
  "def __init__(self) -> None:\n        self._alarms: list[int] = []\n        self._watch_files: dict[int, int] = {}\n        self._idle_handle: int = 0\n        self._glib_idle_enabled = False  # have we called glib.idle_add?\n        self._idle_callbacks: dict[int, Callable[[], typing.Any]] = {}\n        self._loop = GLib.MainLoop()\n        self._exc: BaseException | None = None\n        self._enable_glib_idle()\n        self._signal_handlers: dict[int, int] = {}",
  "def alarm(\n        self,\n        seconds: float,\n        callback: Callable[[], typing.Any],\n    ) -> tuple[int, Callable[[], typing.Any]]:\n        \"\"\"\n        Call callback() a given time from now.  No parameters are\n        passed to callback.\n\n        Returns a handle that may be passed to remove_alarm()\n\n        seconds -- floating point time to wait before calling callback\n        callback -- function to call from event loop\n        \"\"\"\n\n        @self.handle_exit\n        def ret_false() -> Literal[False]:\n            callback()\n            self._enable_glib_idle()\n            return False\n\n        fd = GLib.timeout_add(int(seconds * 1000), ret_false)\n        self._alarms.append(fd)\n        return (fd, callback)",
  "def set_signal_handler(\n        self,\n        signum: int,\n        handler: Callable[[int, FrameType | None], typing.Any] | int | signal.Handlers,\n    ) -> None:\n        \"\"\"\n        Sets the signal handler for signal signum.\n\n        .. WARNING::\n            Because this method uses the `GLib`-specific `unix_signal_add`\n            function, its behaviour is different than `signal.signal().`\n\n            If `signum` is not `SIGHUP`, `SIGINT`, `SIGTERM`, `SIGUSR1`,\n            `SIGUSR2` or `SIGWINCH`, this method performs no actions and\n            immediately returns None.\n\n            Returns None in all cases (unlike :func:`signal.signal()`).\n        ..\n\n        signum -- signal number\n        handler -- function (taking signum as its single argument),\n        or `signal.SIG_IGN`, or `signal.SIG_DFL`\n        \"\"\"\n        glib_signals = [\n            signal.SIGHUP,\n            signal.SIGINT,\n            signal.SIGTERM,\n            signal.SIGUSR1,\n            signal.SIGUSR2,\n        ]\n\n        # GLib supports SIGWINCH as of version 2.54.\n        if not GLib.check_version(2, 54, 0):\n            glib_signals.append(signal.SIGWINCH)\n\n        if signum not in glib_signals:\n            # The GLib event loop supports only the signals listed above\n            return\n\n        if signum in self._signal_handlers:\n            GLib.source_remove(self._signal_handlers.pop(signum))\n\n        if handler == signal.Handlers.SIG_IGN:\n            handler = _ignore_handler\n        elif handler == signal.Handlers.SIG_DFL:\n            return\n\n        def final_handler(signal_number: int):\n            # MyPy False-negative: signal.Handlers casted\n            handler(signal_number, None)  # type: ignore[operator]\n            return GLib.SOURCE_CONTINUE\n\n        source = GLib.unix_signal_add(GLib.PRIORITY_DEFAULT, signum, final_handler, signum)\n        self._signal_handlers[signum] = source",
  "def remove_alarm(self, handle) -> bool:\n        \"\"\"\n        Remove an alarm.\n\n        Returns True if the alarm exists, False otherwise\n        \"\"\"\n        try:\n            self._alarms.remove(handle[0])\n            GLib.source_remove(handle[0])\n\n        except ValueError:\n            return False\n\n        return True",
  "def watch_file(self, fd: int, callback: Callable[[], typing.Any]) -> int:\n        \"\"\"\n        Call callback() when fd has some data to read.  No parameters\n        are passed to callback.\n\n        Returns a handle that may be passed to remove_watch_file()\n\n        fd -- file descriptor to watch for input\n        callback -- function to call when input is available\n        \"\"\"\n\n        @self.handle_exit\n        def io_callback(source, cb_condition) -> Literal[True]:\n            callback()\n            self._enable_glib_idle()\n            return True\n\n        self._watch_files[fd] = GLib.io_add_watch(fd, GLib.IO_IN, io_callback)\n        return fd",
  "def remove_watch_file(self, handle: int) -> bool:\n        \"\"\"\n        Remove an input file.\n\n        Returns True if the input file exists, False otherwise\n        \"\"\"\n        if handle in self._watch_files:\n            GLib.source_remove(self._watch_files[handle])\n            del self._watch_files[handle]\n            return True\n        return False",
  "def enter_idle(self, callback: Callable[[], typing.Any]) -> int:\n        \"\"\"\n        Add a callback for entering idle.\n\n        Returns a handle that may be passed to remove_enter_idle()\n        \"\"\"\n        self._idle_handle += 1\n        self._idle_callbacks[self._idle_handle] = callback\n        return self._idle_handle",
  "def _enable_glib_idle(self) -> None:\n        if self._glib_idle_enabled:\n            return\n        GLib.idle_add(self._glib_idle_callback)\n        self._glib_idle_enabled = True",
  "def _glib_idle_callback(self):\n        for callback in self._idle_callbacks.values():\n            callback()\n        self._glib_idle_enabled = False\n        return False",
  "def remove_enter_idle(self, handle) -> bool:\n        \"\"\"\n        Remove an idle callback.\n\n        Returns True if the handle was removed.\n        \"\"\"\n        try:\n            del self._idle_callbacks[handle]\n        except KeyError:\n            return False\n        return True",
  "def run(self) -> None:\n        \"\"\"\n        Start the event loop.  Exit the loop when any callback raises\n        an exception.  If ExitMainLoop is raised, exit cleanly.\n        \"\"\"\n        try:\n            self._loop.run()\n        finally:\n            if self._loop.is_running():\n                self._loop.quit()\n        if self._exc:\n            # An exception caused us to exit, raise it now\n            exc = self._exc\n            self._exc = None\n            raise exc.with_traceback(exc.__traceback__)",
  "def handle_exit(self, f: Callable[_Spec, _T]) -> Callable[_Spec, _T | Literal[False]]:\n        \"\"\"\n        Decorator that cleanly exits the :class:`GLibEventLoop` if\n        :exc:`ExitMainLoop` is thrown inside of the wrapped function. Store the\n        exception info if some other exception occurs, it will be reraised after\n        the loop quits.\n\n        *f* -- function to be wrapped\n        \"\"\"\n\n        @functools.wraps(f)\n        def wrapper(*args: _Spec.args, **kwargs: _Spec.kwargs) -> _T | Literal[False]:\n            try:\n                return f(*args, **kwargs)\n            except ExitMainLoop:\n                self._loop.quit()\n            except BaseException as exc:\n                self._exc = exc\n                if self._loop.is_running():\n                    self._loop.quit()\n            return False\n\n        return wrapper",
  "def ret_false() -> Literal[False]:\n            callback()\n            self._enable_glib_idle()\n            return False",
  "def final_handler(signal_number: int):\n            # MyPy False-negative: signal.Handlers casted\n            handler(signal_number, None)  # type: ignore[operator]\n            return GLib.SOURCE_CONTINUE",
  "def io_callback(source, cb_condition) -> Literal[True]:\n            callback()\n            self._enable_glib_idle()\n            return True",
  "def wrapper(*args: _Spec.args, **kwargs: _Spec.kwargs) -> _T | Literal[False]:\n            try:\n                return f(*args, **kwargs)\n            except ExitMainLoop:\n                self._loop.quit()\n            except BaseException as exc:\n                self._exc = exc\n                if self._loop.is_running():\n                    self._loop.quit()\n            return False"
]