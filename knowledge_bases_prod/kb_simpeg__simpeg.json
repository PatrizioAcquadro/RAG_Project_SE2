[
  "class BaseInversion(object):\n    \"\"\"\n\n        Inversion Class.\n\n    \"\"\"\n\n    __metaclass__ = Utils.SimPEGMetaClass\n\n    name = 'BaseInversion'\n\n    debug   = False    #: Print debugging information\n\n    counter = None     #: Set this to a SimPEG.Utils.Counter() if you want to count things\n\n    @property\n    def directiveList(self):\n        if getattr(self,'_directiveList', None) is None:\n            self._directiveList = Directives.DirectiveList(inversion=self)\n        return self._directiveList\n\n    @directiveList.setter\n    def directiveList(self, value):\n        if type(value) is list:\n            value = Directives.DirectiveList(*value)\n        assert isinstance(value, Directives.DirectiveList), 'Must be a DirectiveList'\n        self._directiveList = value\n        self._directiveList.inversion = self\n\n    def __init__(self, invProb, directiveList=[], **kwargs):\n        self.directiveList = directiveList\n        Utils.setKwargs(self, **kwargs)\n\n        self.invProb = invProb\n\n        self.opt = invProb.opt\n        self.opt.callback = self._optCallback\n\n        self.stoppers = [StoppingCriteria.iteration]\n\n        # Check if we have inserted printers into the optimization\n        if IterationPrinters.phi_d not in self.opt.printers:\n            self.opt.printers.insert(1,IterationPrinters.beta)\n            self.opt.printers.insert(2,IterationPrinters.phi_d)\n            self.opt.printers.insert(3,IterationPrinters.phi_m)\n\n    @Utils.timeIt\n    def run(self, m0):\n        \"\"\"run(m0)\n\n            Runs the inversion!\n\n        \"\"\"\n        self.invProb.startup(m0)\n        self.directiveList.call('initialize')\n        self.m = self.opt.minimize(self.invProb.evalFunction, self.invProb.curModel)\n        self.directiveList.call('finish')\n\n        return self.m\n\n    def _optCallback(self, xt):\n        self.directiveList.call('endIter')",
  "def directiveList(self):\n        if getattr(self,'_directiveList', None) is None:\n            self._directiveList = Directives.DirectiveList(inversion=self)\n        return self._directiveList",
  "def directiveList(self, value):\n        if type(value) is list:\n            value = Directives.DirectiveList(*value)\n        assert isinstance(value, Directives.DirectiveList), 'Must be a DirectiveList'\n        self._directiveList = value\n        self._directiveList.inversion = self",
  "def __init__(self, invProb, directiveList=[], **kwargs):\n        self.directiveList = directiveList\n        Utils.setKwargs(self, **kwargs)\n\n        self.invProb = invProb\n\n        self.opt = invProb.opt\n        self.opt.callback = self._optCallback\n\n        self.stoppers = [StoppingCriteria.iteration]\n\n        # Check if we have inserted printers into the optimization\n        if IterationPrinters.phi_d not in self.opt.printers:\n            self.opt.printers.insert(1,IterationPrinters.beta)\n            self.opt.printers.insert(2,IterationPrinters.phi_d)\n            self.opt.printers.insert(3,IterationPrinters.phi_m)",
  "def run(self, m0):\n        \"\"\"run(m0)\n\n            Runs the inversion!\n\n        \"\"\"\n        self.invProb.startup(m0)\n        self.directiveList.call('initialize')\n        self.m = self.opt.minimize(self.invProb.evalFunction, self.invProb.curModel)\n        self.directiveList.call('finish')\n\n        return self.m",
  "def _optCallback(self, xt):\n        self.directiveList.call('endIter')",
  "class BaseProblem(object):\n    \"\"\"\n        Problem is the base class for all geophysical forward problems in SimPEG.\n    \"\"\"\n\n    __metaclass__ = Utils.SimPEGMetaClass\n\n    counter = None   #: A SimPEG.Utils.Counter object\n\n    surveyPair = Survey.BaseSurvey   #: A SimPEG.Survey Class\n    mapPair    = Maps.IdentityMap    #: A SimPEG.Map Class\n\n    Solver = Solver   #: A SimPEG Solver class.\n    solverOpts = {}   #: Sovler options as a kwarg dict\n\n    mesh    = None    #: A SimPEG.Mesh instance.\n\n    PropMap = None    #: A SimPEG PropertyMap class.\n\n    @property\n    def mapping(self):\n        \"A SimPEG.Map instance or a property map is PropMap is not None\"\n        return getattr(self, '_mapping', None)\n    @mapping.setter\n    def mapping(self, val):\n        if self.PropMap is None:\n            val._assertMatchesPair(self.mapPair)\n            self._mapping = val\n        else:\n            self._mapping = self.PropMap(val) \n    \n    def __init__(self, mesh, mapping=None, **kwargs):\n        Utils.setKwargs(self, **kwargs)\n        assert isinstance(mesh, Mesh.BaseMesh), \"mesh must be a SimPEG.Mesh object.\"\n        self.mesh = mesh\n        self.mapping = mapping or Maps.IdentityMap(mesh)\n\n    @property\n    def survey(self):\n        \"\"\"\n        The survey object for this problem.\n        \"\"\"\n        return getattr(self, '_survey', None)\n\n    def pair(self, d):\n        \"\"\"Bind a survey to this problem instance using pointers.\"\"\"\n        assert isinstance(d, self.surveyPair), \"Data object must be an instance of a %s class.\"%(self.surveyPair.__name__)\n        if d.ispaired:\n            raise Exception(\"The survey object is already paired to a problem. Use survey.unpair()\")\n        self._survey = d\n        d._prob = self\n\n    def unpair(self):\n        \"\"\"Unbind a survey from this problem instance.\"\"\"\n        if not self.ispaired: return\n        self.survey._prob = None\n        self._survey = None\n\n\n    deleteTheseOnModelUpdate = [] # List of strings, e.g. ['_MeSigma', '_MeSigmaI']\n\n    @property\n    def curModel(self):\n        \"\"\"\n            Sets the current model, and removes dependent mass matrices.\n        \"\"\"\n        return getattr(self, '_curModel', None)\n    @curModel.setter\n    def curModel(self, value):\n        if value is self.curModel:\n            return # it is the same!\n        if self.PropMap is not None:\n            self._curModel = self.mapping(value)\n        else:\n            self._curModel = Models.Model(value, self.mapping)\n        for prop in self.deleteTheseOnModelUpdate:\n            if hasattr(self, prop):\n                delattr(self, prop)\n\n    @property\n    def ispaired(self):\n        \"\"\"True if the problem is paired to a survey.\"\"\"\n        return self.survey is not None\n\n    @Utils.timeIt\n    def Jvec(self, m, v, u=None):\n        \"\"\"Jvec(m, v, u=None)\n\n            Effect of J(m) on a vector v.\n\n            :param numpy.array m: model\n            :param numpy.array v: vector to multiply\n            :param numpy.array u: fields\n            :rtype: numpy.array\n            :return: Jv\n        \"\"\"\n        raise NotImplementedError('J is not yet implemented.')\n\n    @Utils.timeIt\n    def Jtvec(self, m, v, u=None):\n        \"\"\"Jtvec(m, v, u=None)\n\n            Effect of transpose of J(m) on a vector v.\n\n            :param numpy.array m: model\n            :param numpy.array v: vector to multiply\n            :param numpy.array u: fields\n            :rtype: numpy.array\n            :return: JTv\n        \"\"\"\n        raise NotImplementedError('Jt is not yet implemented.')\n\n\n    @Utils.timeIt\n    def Jvec_approx(self, m, v, u=None):\n        \"\"\"Jvec_approx(m, v, u=None)\n\n            Approximate effect of J(m) on a vector v\n\n            :param numpy.array m: model\n            :param numpy.array v: vector to multiply\n            :param numpy.array u: fields\n            :rtype: numpy.array\n            :return: approxJv\n        \"\"\"\n        return self.Jvec(m, v, u)\n\n    @Utils.timeIt\n    def Jtvec_approx(self, m, v, u=None):\n        \"\"\"Jtvec_approx(m, v, u=None)\n\n            Approximate effect of transpose of J(m) on a vector v.\n\n            :param numpy.array m: model\n            :param numpy.array v: vector to multiply\n            :param numpy.array u: fields\n            :rtype: numpy.array\n            :return: JTv\n        \"\"\"\n        return self.Jtvec(m, v, u)\n\n    def fields(self, m):\n        \"\"\"\n            The field given the model.\n\n            :param numpy.array m: model\n            :rtype: numpy.array\n            :return: u, the fields\n\n        \"\"\"\n        raise NotImplementedError('fields is not yet implemented.')",
  "class BaseTimeProblem(BaseProblem):\n    \"\"\"Sets up that basic needs of a time domain problem.\"\"\"\n\n    @property\n    def timeSteps(self):\n        \"\"\"Sets/gets the timeSteps for the time domain problem.\n\n        You can set as an array of dt's or as a list of tuples/floats.\n        Tuples must be length two with [..., (dt, repeat), ...]\n\n        For example, the following setters are the same::\n\n            prob.timeSteps = [(1e-6, 3), 1e-5, (1e-4, 2)]\n            prob.timeSteps = np.r_[1e-6,1e-6,1e-6,1e-5,1e-4,1e-4]\n\n        \"\"\"\n        return getattr(self, '_timeSteps', None)\n\n    @timeSteps.setter\n    def timeSteps(self, value):\n        if isinstance(value, np.ndarray):\n            self._timeSteps = value\n            del self.timeMesh\n            return\n\n        self._timeSteps = Utils.meshTensor(value)\n        del self.timeMesh\n\n    @property\n    def nT(self):\n        \"Number of time steps.\"\n        return self.timeMesh.nC\n\n    @property\n    def t0(self):\n        return getattr(self, '_t0', 0.0)\n    @t0.setter\n    def t0(self, value):\n        assert Utils.isScalar(value), 't0 must be a scalar'\n        del self.timeMesh\n        self._t0 = float(value)\n\n    @property\n    def times(self):\n        \"Modeling times\"\n        return self.timeMesh.vectorNx\n\n    @property\n    def timeMesh(self):\n        if getattr(self, '_timeMesh', None) is None:\n            self._timeMesh = Mesh.TensorMesh([self.timeSteps], x0=[self.t0])\n        return self._timeMesh\n    @timeMesh.deleter\n    def timeMesh(self):\n        if hasattr(self, '_timeMesh'):\n            del self._timeMesh",
  "def mapping(self):\n        \"A SimPEG.Map instance or a property map is PropMap is not None\"\n        return getattr(self, '_mapping', None)",
  "def mapping(self, val):\n        if self.PropMap is None:\n            val._assertMatchesPair(self.mapPair)\n            self._mapping = val\n        else:\n            self._mapping = self.PropMap(val)",
  "def __init__(self, mesh, mapping=None, **kwargs):\n        Utils.setKwargs(self, **kwargs)\n        assert isinstance(mesh, Mesh.BaseMesh), \"mesh must be a SimPEG.Mesh object.\"\n        self.mesh = mesh\n        self.mapping = mapping or Maps.IdentityMap(mesh)",
  "def survey(self):\n        \"\"\"\n        The survey object for this problem.\n        \"\"\"\n        return getattr(self, '_survey', None)",
  "def pair(self, d):\n        \"\"\"Bind a survey to this problem instance using pointers.\"\"\"\n        assert isinstance(d, self.surveyPair), \"Data object must be an instance of a %s class.\"%(self.surveyPair.__name__)\n        if d.ispaired:\n            raise Exception(\"The survey object is already paired to a problem. Use survey.unpair()\")\n        self._survey = d\n        d._prob = self",
  "def unpair(self):\n        \"\"\"Unbind a survey from this problem instance.\"\"\"\n        if not self.ispaired: return\n        self.survey._prob = None\n        self._survey = None",
  "def curModel(self):\n        \"\"\"\n            Sets the current model, and removes dependent mass matrices.\n        \"\"\"\n        return getattr(self, '_curModel', None)",
  "def curModel(self, value):\n        if value is self.curModel:\n            return # it is the same!\n        if self.PropMap is not None:\n            self._curModel = self.mapping(value)\n        else:\n            self._curModel = Models.Model(value, self.mapping)\n        for prop in self.deleteTheseOnModelUpdate:\n            if hasattr(self, prop):\n                delattr(self, prop)",
  "def ispaired(self):\n        \"\"\"True if the problem is paired to a survey.\"\"\"\n        return self.survey is not None",
  "def Jvec(self, m, v, u=None):\n        \"\"\"Jvec(m, v, u=None)\n\n            Effect of J(m) on a vector v.\n\n            :param numpy.array m: model\n            :param numpy.array v: vector to multiply\n            :param numpy.array u: fields\n            :rtype: numpy.array\n            :return: Jv\n        \"\"\"\n        raise NotImplementedError('J is not yet implemented.')",
  "def Jtvec(self, m, v, u=None):\n        \"\"\"Jtvec(m, v, u=None)\n\n            Effect of transpose of J(m) on a vector v.\n\n            :param numpy.array m: model\n            :param numpy.array v: vector to multiply\n            :param numpy.array u: fields\n            :rtype: numpy.array\n            :return: JTv\n        \"\"\"\n        raise NotImplementedError('Jt is not yet implemented.')",
  "def Jvec_approx(self, m, v, u=None):\n        \"\"\"Jvec_approx(m, v, u=None)\n\n            Approximate effect of J(m) on a vector v\n\n            :param numpy.array m: model\n            :param numpy.array v: vector to multiply\n            :param numpy.array u: fields\n            :rtype: numpy.array\n            :return: approxJv\n        \"\"\"\n        return self.Jvec(m, v, u)",
  "def Jtvec_approx(self, m, v, u=None):\n        \"\"\"Jtvec_approx(m, v, u=None)\n\n            Approximate effect of transpose of J(m) on a vector v.\n\n            :param numpy.array m: model\n            :param numpy.array v: vector to multiply\n            :param numpy.array u: fields\n            :rtype: numpy.array\n            :return: JTv\n        \"\"\"\n        return self.Jtvec(m, v, u)",
  "def fields(self, m):\n        \"\"\"\n            The field given the model.\n\n            :param numpy.array m: model\n            :rtype: numpy.array\n            :return: u, the fields\n\n        \"\"\"\n        raise NotImplementedError('fields is not yet implemented.')",
  "def timeSteps(self):\n        \"\"\"Sets/gets the timeSteps for the time domain problem.\n\n        You can set as an array of dt's or as a list of tuples/floats.\n        Tuples must be length two with [..., (dt, repeat), ...]\n\n        For example, the following setters are the same::\n\n            prob.timeSteps = [(1e-6, 3), 1e-5, (1e-4, 2)]\n            prob.timeSteps = np.r_[1e-6,1e-6,1e-6,1e-5,1e-4,1e-4]\n\n        \"\"\"\n        return getattr(self, '_timeSteps', None)",
  "def timeSteps(self, value):\n        if isinstance(value, np.ndarray):\n            self._timeSteps = value\n            del self.timeMesh\n            return\n\n        self._timeSteps = Utils.meshTensor(value)\n        del self.timeMesh",
  "def nT(self):\n        \"Number of time steps.\"\n        return self.timeMesh.nC",
  "def t0(self):\n        return getattr(self, '_t0', 0.0)",
  "def t0(self, value):\n        assert Utils.isScalar(value), 't0 must be a scalar'\n        del self.timeMesh\n        self._t0 = float(value)",
  "def times(self):\n        \"Modeling times\"\n        return self.timeMesh.vectorNx",
  "def timeMesh(self):\n        if getattr(self, '_timeMesh', None) is None:\n            self._timeMesh = Mesh.TensorMesh([self.timeSteps], x0=[self.t0])\n        return self._timeMesh",
  "def timeMesh(self):\n        if hasattr(self, '_timeMesh'):\n            del self._timeMesh",
  "class BaseRx(object):\n    \"\"\"SimPEG Receiver Object\"\"\"\n\n    locs = None   #: Locations (nRx x nDim)\n\n    knownRxTypes = None  #: Set this to a list of strings to ensure that srcType is known\n\n    projGLoc = 'CC'  #: Projection grid location, default is CC\n\n    storeProjections = True #: Store calls to getP (organized by mesh)\n\n    def __init__(self, locs, rxType, **kwargs):\n        self.uid = str(uuid.uuid4())\n        self.locs = locs\n        self.rxType = rxType\n        self._Ps = {}\n        Utils.setKwargs(self, **kwargs)\n\n    @property\n    def rxType(self):\n        \"\"\"Receiver Type\"\"\"\n        return getattr(self, '_rxType', None)\n    @rxType.setter\n    def rxType(self, value):\n        known = self.knownRxTypes\n        if known is not None:\n            assert value in known, \"rxType must be in ['%s']\" % (\"', '\".join(known))\n        self._rxType = value\n\n    @property\n    def nD(self):\n        \"\"\"Number of data in the receiver.\"\"\"\n        return self.locs.shape[0]\n\n    def getP(self, mesh):\n        \"\"\"\n            Returns the projection matrices as a\n            list for all components collected by\n            the receivers.\n\n            .. note::\n\n                Projection matrices are stored as a dictionary listed by meshes.\n        \"\"\"\n        if mesh in self._Ps:\n            return self._Ps[mesh]\n\n        P = mesh.getInterpolationMat(self.locs, self.projGLoc)\n        if self.storeProjections:\n            self._Ps[mesh] = P\n        return P",
  "class BaseTimeRx(BaseRx):\n    \"\"\"SimPEG Receiver Object\"\"\"\n\n    times = None   #: Times when the receivers were active.\n    projTLoc = 'N'\n\n    def __init__(self, locs, times, rxType, **kwargs):\n        self.times = times\n        BaseRx.__init__(self, locs, rxType, **kwargs)\n\n    @property\n    def nD(self):\n        \"\"\"Number of data in the receiver.\"\"\"\n        return self.locs.shape[0] * len(self.times)\n\n    def getSpatialP(self, mesh):\n        \"\"\"\n            Returns the spatial projection matrix.\n\n            .. note::\n\n                This is not stored in memory, but is created on demand.\n        \"\"\"\n        return mesh.getInterpolationMat(self.locs, self.projGLoc)\n\n    def getTimeP(self, timeMesh):\n        \"\"\"\n            Returns the time projection matrix.\n\n            .. note::\n\n                This is not stored in memory, but is created on demand.\n        \"\"\"\n        return timeMesh.getInterpolationMat(self.times, self.projTLoc)\n\n    def getP(self, mesh, timeMesh):\n        \"\"\"\n            Returns the projection matrices as a\n            list for all components collected by\n            the receivers.\n\n            .. note::\n\n                Projection matrices are stored as a dictionary (mesh, timeMesh) if storeProjections is True\n        \"\"\"\n        if (mesh, timeMesh) in self._Ps:\n            return self._Ps[(mesh, timeMesh)]\n\n        Ps = self.getSpatialP(mesh)\n        Pt = self.getTimeP(timeMesh)\n        P = sp.kron(Pt, Ps)\n\n        if self.storeProjections:\n            self._Ps[(mesh, timeMesh)] = P\n\n        return P",
  "class BaseSrc(object):\n    \"\"\"SimPEG Source Object\"\"\"\n\n    loc    = None #: Location [x,y,z]\n\n    rxList = None #: SimPEG Receiver List\n    rxPair = BaseRx\n\n    def __init__(self, rxList, **kwargs):\n        assert type(rxList) is list, 'rxList must be a list'\n        for rx in rxList:\n            assert isinstance(rx, self.rxPair), 'rxList must be a %s'%self.rxPair.__name__\n        assert len(set(rxList)) == len(rxList), 'The rxList must be unique'\n        self.uid = str(uuid.uuid4())\n        self.rxList = rxList\n        Utils.setKwargs(self, **kwargs)\n\n\n    @property\n    def nD(self):\n        \"\"\"Number of data\"\"\"\n        return self.vnD.sum()\n\n    @property\n    def vnD(self):\n        \"\"\"Vector number of data\"\"\"\n        return np.array([rx.nD for rx in self.rxList])",
  "class Data(object):\n    \"\"\"Fancy data storage by Src and Rx\"\"\"\n\n    def __init__(self, survey, v=None):\n        self.uid = str(uuid.uuid4())\n        self.survey = survey\n        self._dataDict = {}\n        for src in self.survey.srcList:\n            self._dataDict[src] = {}\n        if v is not None:\n            self.fromvec(v)\n\n    def _ensureCorrectKey(self, key):\n        if type(key) is tuple:\n            if len(key) is not 2:\n                raise KeyError('Key must be [Src, Rx]')\n            if key[0] not in self.survey.srcList:\n                raise KeyError('Src Key must be a source in the survey.')\n            if key[1] not in key[0].rxList:\n                raise KeyError('Rx Key must be a receiver for the source.')\n            return key\n        elif isinstance(key, self.survey.srcPair):\n            if key not in self.survey.srcList:\n                raise KeyError('Key must be a source in the survey.')\n            return key, None\n        else:\n            raise KeyError('Key must be [Src] or [Src,Rx]')\n\n    def __setitem__(self, key, value):\n        src, rx = self._ensureCorrectKey(key)\n        assert rx is not None, 'set data using [Src, Rx]'\n        assert isinstance(value, np.ndarray), 'value must by ndarray'\n        assert value.size == rx.nD, \"value must have the same number of data as the source.\"\n        self._dataDict[src][rx] = Utils.mkvc(value)\n\n    def __getitem__(self, key):\n        src, rx = self._ensureCorrectKey(key)\n        if rx is not None:\n            if rx not in self._dataDict[src]:\n                raise Exception('Data for receiver has not yet been set.')\n            return self._dataDict[src][rx]\n\n        return np.concatenate([self[src,rx] for rx in src.rxList])\n\n    def tovec(self):\n        return np.concatenate([self[src] for src in self.survey.srcList])\n\n    def fromvec(self, v):\n        v = Utils.mkvc(v)\n        assert v.size == self.survey.nD, 'v must have the correct number of data.'\n        indBot, indTop = 0, 0\n        for src in self.survey.srcList:\n            for rx in src.rxList:\n                indTop += rx.nD\n                self[src, rx] = v[indBot:indTop]\n                indBot += rx.nD",
  "class BaseSurvey(object):\n    \"\"\"Survey holds the observed data, and the standard deviations.\"\"\"\n\n    __metaclass__ = Utils.SimPEGMetaClass\n\n    std = None       #: Estimated Standard Deviations\n    dobs = None      #: Observed data\n    dtrue = None     #: True data, if data is synthetic\n    mtrue = None     #: True model, if data is synthetic\n\n    counter = None   #: A SimPEG.Utils.Counter object\n\n    def __init__(self, **kwargs):\n        Utils.setKwargs(self, **kwargs)\n\n    srcPair = BaseSrc  #: Source Pair\n\n    @property\n    def srcList(self):\n        \"\"\"Source List\"\"\"\n        return getattr(self, '_srcList', None)\n\n    @srcList.setter\n    def srcList(self, value):\n        assert type(value) is list, 'srcList must be a list'\n        assert np.all([isinstance(src, self.srcPair) for src in value]), 'All sources must be instances of %s' % self.srcPair.__name__\n        assert len(set(value)) == len(value), 'The srcList must be unique'\n        self._srcList = value\n        self._sourceOrder = dict()\n        [self._sourceOrder.setdefault(src.uid, ii) for ii, src in enumerate(self._srcList)]\n\n    def getSourceIndex(self, sources):\n        if type(sources) is not list:\n            sources = [sources]\n        for src in sources:\n            if getattr(src,'uid',None) is None:\n                raise KeyError('Source does not have a uid: %s'%str(src))\n        inds = map(lambda src: self._sourceOrder.get(src.uid, None), sources)\n        if None in inds:\n            raise KeyError('Some of the sources specified are not in this survey. %s'%str(inds))\n        return inds\n\n    @property\n    def prob(self):\n        \"\"\"\n        The geophysical problem that explains this survey, use::\n\n            survey.pair(prob)\n        \"\"\"\n        return getattr(self, '_prob', None)\n\n    @property\n    def mesh(self):\n        \"\"\"Mesh of the paired problem.\"\"\"\n        if self.ispaired:\n            return self.prob.mesh\n        raise Exception('Pair survey to a problem to access the problems mesh.')\n\n    def pair(self, p):\n        \"\"\"Bind a problem to this survey instance using pointers\"\"\"\n        assert hasattr(p, 'surveyPair'), \"Problem must have an attribute 'surveyPair'.\"\n        assert isinstance(self, p.surveyPair), \"Problem requires survey object must be an instance of a %s class.\"%(p.surveyPair.__name__)\n        if p.ispaired:\n            raise Exception(\"The problem object is already paired to a survey. Use prob.unpair()\")\n        self._prob = p\n        p._survey = self\n\n    def unpair(self):\n        \"\"\"Unbind a problem from this survey instance\"\"\"\n        if not self.ispaired: return\n        self.prob._survey = None\n        self._prob = None\n\n    @property\n    def ispaired(self): return self.prob is not None\n\n    @property\n    def nD(self):\n        \"\"\"Number of data\"\"\"\n        return self.vnD.sum()\n\n    @property\n    def vnD(self):\n        \"\"\"Vector number of data\"\"\"\n        return np.array([src.nD for src in self.srcList])\n\n    @property\n    def nSrc(self):\n        \"\"\"Number of Sources\"\"\"\n        return len(self.srcList)\n\n    @Utils.count\n    @Utils.requires('prob')\n    def dpred(self, m, u=None):\n        \"\"\"dpred(m, u=None)\n\n            Create the projected data from a model.\n            The field, u, (if provided) will be used for the predicted data\n            instead of recalculating the fields (which may be expensive!).\n\n            .. math::\n\n                d_\\\\text{pred} = P(u(m))\n\n            Where P is a projection of the fields onto the data space.\n        \"\"\"\n        if u is None: u = self.prob.fields(m)\n        return Utils.mkvc(self.projectFields(u))\n\n\n    @Utils.count\n    def projectFields(self, u):\n        \"\"\"projectFields(u)\n\n            This function projects the fields onto the data space.\n\n            .. math::\n\n                d_\\\\text{pred} = \\mathbf{P} u(m)\n        \"\"\"\n        raise NotImplemented('projectFields is not yet implemented.')\n\n    @Utils.count\n    def projectFieldsDeriv(self, u):\n        \"\"\"projectFieldsDeriv(u)\n\n            This function s the derivative of projects the fields onto the data space.\n\n            .. math::\n\n                \\\\frac{\\partial d_\\\\text{pred}}{\\partial u} = \\mathbf{P}\n        \"\"\"\n        raise NotImplemented('projectFields is not yet implemented.')\n\n    @Utils.count\n    def residual(self, m, u=None):\n        \"\"\"residual(m, u=None)\n\n            :param numpy.array m: geophysical model\n            :param numpy.array u: fields\n            :rtype: numpy.array\n            :return: data residual\n\n            The data residual:\n\n            .. math::\n\n                \\mu_\\\\text{data} = \\mathbf{d}_\\\\text{pred} - \\mathbf{d}_\\\\text{obs}\n\n        \"\"\"\n        return Utils.mkvc(self.dpred(m, u=u) - self.dobs)\n\n    @property\n    def isSynthetic(self):\n        \"Check if the data is synthetic.\"\n        return self.mtrue is not None\n\n    def makeSyntheticData(self, m, std=0.05, u=None, force=False):\n        \"\"\"\n            Make synthetic data given a model, and a standard deviation.\n\n            :param numpy.array m: geophysical model\n            :param numpy.array std: standard deviation\n            :param numpy.array u: fields for the given model (if pre-calculated)\n            :param bool force: force overwriting of dobs\n\n        \"\"\"\n        if getattr(self, 'dobs', None) is not None and not force:\n            raise Exception('Survey already has dobs. You can use force=True to override this exception.')\n        self.mtrue = m\n        self.dtrue = self.dpred(m, u=u)\n        noise = std*abs(self.dtrue)*np.random.randn(*self.dtrue.shape)\n        self.dobs = self.dtrue+noise\n        self.std = self.dobs*0 + std\n        return self.dobs",
  "def __init__(self, locs, rxType, **kwargs):\n        self.uid = str(uuid.uuid4())\n        self.locs = locs\n        self.rxType = rxType\n        self._Ps = {}\n        Utils.setKwargs(self, **kwargs)",
  "def rxType(self):\n        \"\"\"Receiver Type\"\"\"\n        return getattr(self, '_rxType', None)",
  "def rxType(self, value):\n        known = self.knownRxTypes\n        if known is not None:\n            assert value in known, \"rxType must be in ['%s']\" % (\"', '\".join(known))\n        self._rxType = value",
  "def nD(self):\n        \"\"\"Number of data in the receiver.\"\"\"\n        return self.locs.shape[0]",
  "def getP(self, mesh):\n        \"\"\"\n            Returns the projection matrices as a\n            list for all components collected by\n            the receivers.\n\n            .. note::\n\n                Projection matrices are stored as a dictionary listed by meshes.\n        \"\"\"\n        if mesh in self._Ps:\n            return self._Ps[mesh]\n\n        P = mesh.getInterpolationMat(self.locs, self.projGLoc)\n        if self.storeProjections:\n            self._Ps[mesh] = P\n        return P",
  "def __init__(self, locs, times, rxType, **kwargs):\n        self.times = times\n        BaseRx.__init__(self, locs, rxType, **kwargs)",
  "def nD(self):\n        \"\"\"Number of data in the receiver.\"\"\"\n        return self.locs.shape[0] * len(self.times)",
  "def getSpatialP(self, mesh):\n        \"\"\"\n            Returns the spatial projection matrix.\n\n            .. note::\n\n                This is not stored in memory, but is created on demand.\n        \"\"\"\n        return mesh.getInterpolationMat(self.locs, self.projGLoc)",
  "def getTimeP(self, timeMesh):\n        \"\"\"\n            Returns the time projection matrix.\n\n            .. note::\n\n                This is not stored in memory, but is created on demand.\n        \"\"\"\n        return timeMesh.getInterpolationMat(self.times, self.projTLoc)",
  "def getP(self, mesh, timeMesh):\n        \"\"\"\n            Returns the projection matrices as a\n            list for all components collected by\n            the receivers.\n\n            .. note::\n\n                Projection matrices are stored as a dictionary (mesh, timeMesh) if storeProjections is True\n        \"\"\"\n        if (mesh, timeMesh) in self._Ps:\n            return self._Ps[(mesh, timeMesh)]\n\n        Ps = self.getSpatialP(mesh)\n        Pt = self.getTimeP(timeMesh)\n        P = sp.kron(Pt, Ps)\n\n        if self.storeProjections:\n            self._Ps[(mesh, timeMesh)] = P\n\n        return P",
  "def __init__(self, rxList, **kwargs):\n        assert type(rxList) is list, 'rxList must be a list'\n        for rx in rxList:\n            assert isinstance(rx, self.rxPair), 'rxList must be a %s'%self.rxPair.__name__\n        assert len(set(rxList)) == len(rxList), 'The rxList must be unique'\n        self.uid = str(uuid.uuid4())\n        self.rxList = rxList\n        Utils.setKwargs(self, **kwargs)",
  "def nD(self):\n        \"\"\"Number of data\"\"\"\n        return self.vnD.sum()",
  "def vnD(self):\n        \"\"\"Vector number of data\"\"\"\n        return np.array([rx.nD for rx in self.rxList])",
  "def __init__(self, survey, v=None):\n        self.uid = str(uuid.uuid4())\n        self.survey = survey\n        self._dataDict = {}\n        for src in self.survey.srcList:\n            self._dataDict[src] = {}\n        if v is not None:\n            self.fromvec(v)",
  "def _ensureCorrectKey(self, key):\n        if type(key) is tuple:\n            if len(key) is not 2:\n                raise KeyError('Key must be [Src, Rx]')\n            if key[0] not in self.survey.srcList:\n                raise KeyError('Src Key must be a source in the survey.')\n            if key[1] not in key[0].rxList:\n                raise KeyError('Rx Key must be a receiver for the source.')\n            return key\n        elif isinstance(key, self.survey.srcPair):\n            if key not in self.survey.srcList:\n                raise KeyError('Key must be a source in the survey.')\n            return key, None\n        else:\n            raise KeyError('Key must be [Src] or [Src,Rx]')",
  "def __setitem__(self, key, value):\n        src, rx = self._ensureCorrectKey(key)\n        assert rx is not None, 'set data using [Src, Rx]'\n        assert isinstance(value, np.ndarray), 'value must by ndarray'\n        assert value.size == rx.nD, \"value must have the same number of data as the source.\"\n        self._dataDict[src][rx] = Utils.mkvc(value)",
  "def __getitem__(self, key):\n        src, rx = self._ensureCorrectKey(key)\n        if rx is not None:\n            if rx not in self._dataDict[src]:\n                raise Exception('Data for receiver has not yet been set.')\n            return self._dataDict[src][rx]\n\n        return np.concatenate([self[src,rx] for rx in src.rxList])",
  "def tovec(self):\n        return np.concatenate([self[src] for src in self.survey.srcList])",
  "def fromvec(self, v):\n        v = Utils.mkvc(v)\n        assert v.size == self.survey.nD, 'v must have the correct number of data.'\n        indBot, indTop = 0, 0\n        for src in self.survey.srcList:\n            for rx in src.rxList:\n                indTop += rx.nD\n                self[src, rx] = v[indBot:indTop]\n                indBot += rx.nD",
  "def __init__(self, **kwargs):\n        Utils.setKwargs(self, **kwargs)",
  "def srcList(self):\n        \"\"\"Source List\"\"\"\n        return getattr(self, '_srcList', None)",
  "def srcList(self, value):\n        assert type(value) is list, 'srcList must be a list'\n        assert np.all([isinstance(src, self.srcPair) for src in value]), 'All sources must be instances of %s' % self.srcPair.__name__\n        assert len(set(value)) == len(value), 'The srcList must be unique'\n        self._srcList = value\n        self._sourceOrder = dict()\n        [self._sourceOrder.setdefault(src.uid, ii) for ii, src in enumerate(self._srcList)]",
  "def getSourceIndex(self, sources):\n        if type(sources) is not list:\n            sources = [sources]\n        for src in sources:\n            if getattr(src,'uid',None) is None:\n                raise KeyError('Source does not have a uid: %s'%str(src))\n        inds = map(lambda src: self._sourceOrder.get(src.uid, None), sources)\n        if None in inds:\n            raise KeyError('Some of the sources specified are not in this survey. %s'%str(inds))\n        return inds",
  "def prob(self):\n        \"\"\"\n        The geophysical problem that explains this survey, use::\n\n            survey.pair(prob)\n        \"\"\"\n        return getattr(self, '_prob', None)",
  "def mesh(self):\n        \"\"\"Mesh of the paired problem.\"\"\"\n        if self.ispaired:\n            return self.prob.mesh\n        raise Exception('Pair survey to a problem to access the problems mesh.')",
  "def pair(self, p):\n        \"\"\"Bind a problem to this survey instance using pointers\"\"\"\n        assert hasattr(p, 'surveyPair'), \"Problem must have an attribute 'surveyPair'.\"\n        assert isinstance(self, p.surveyPair), \"Problem requires survey object must be an instance of a %s class.\"%(p.surveyPair.__name__)\n        if p.ispaired:\n            raise Exception(\"The problem object is already paired to a survey. Use prob.unpair()\")\n        self._prob = p\n        p._survey = self",
  "def unpair(self):\n        \"\"\"Unbind a problem from this survey instance\"\"\"\n        if not self.ispaired: return\n        self.prob._survey = None\n        self._prob = None",
  "def ispaired(self): return self.prob is not None",
  "def nD(self):\n        \"\"\"Number of data\"\"\"\n        return self.vnD.sum()",
  "def vnD(self):\n        \"\"\"Vector number of data\"\"\"\n        return np.array([src.nD for src in self.srcList])",
  "def nSrc(self):\n        \"\"\"Number of Sources\"\"\"\n        return len(self.srcList)",
  "def dpred(self, m, u=None):\n        \"\"\"dpred(m, u=None)\n\n            Create the projected data from a model.\n            The field, u, (if provided) will be used for the predicted data\n            instead of recalculating the fields (which may be expensive!).\n\n            .. math::\n\n                d_\\\\text{pred} = P(u(m))\n\n            Where P is a projection of the fields onto the data space.\n        \"\"\"\n        if u is None: u = self.prob.fields(m)\n        return Utils.mkvc(self.projectFields(u))",
  "def projectFields(self, u):\n        \"\"\"projectFields(u)\n\n            This function projects the fields onto the data space.\n\n            .. math::\n\n                d_\\\\text{pred} = \\mathbf{P} u(m)\n        \"\"\"\n        raise NotImplemented('projectFields is not yet implemented.')",
  "def projectFieldsDeriv(self, u):\n        \"\"\"projectFieldsDeriv(u)\n\n            This function s the derivative of projects the fields onto the data space.\n\n            .. math::\n\n                \\\\frac{\\partial d_\\\\text{pred}}{\\partial u} = \\mathbf{P}\n        \"\"\"\n        raise NotImplemented('projectFields is not yet implemented.')",
  "def residual(self, m, u=None):\n        \"\"\"residual(m, u=None)\n\n            :param numpy.array m: geophysical model\n            :param numpy.array u: fields\n            :rtype: numpy.array\n            :return: data residual\n\n            The data residual:\n\n            .. math::\n\n                \\mu_\\\\text{data} = \\mathbf{d}_\\\\text{pred} - \\mathbf{d}_\\\\text{obs}\n\n        \"\"\"\n        return Utils.mkvc(self.dpred(m, u=u) - self.dobs)",
  "def isSynthetic(self):\n        \"Check if the data is synthetic.\"\n        return self.mtrue is not None",
  "def makeSyntheticData(self, m, std=0.05, u=None, force=False):\n        \"\"\"\n            Make synthetic data given a model, and a standard deviation.\n\n            :param numpy.array m: geophysical model\n            :param numpy.array std: standard deviation\n            :param numpy.array u: fields for the given model (if pre-calculated)\n            :param bool force: force overwriting of dobs\n\n        \"\"\"\n        if getattr(self, 'dobs', None) is not None and not force:\n            raise Exception('Survey already has dobs. You can use force=True to override this exception.')\n        self.mtrue = m\n        self.dtrue = self.dpred(m, u=u)\n        noise = std*abs(self.dtrue)*np.random.randn(*self.dtrue.shape)\n        self.dobs = self.dtrue+noise\n        self.std = self.dobs*0 + std\n        return self.dobs",
  "class Property(object):\n\n    name           = ''\n    doc            = ''\n\n    defaultVal     = None\n    defaultInvProp = False\n\n    def __init__(self, doc, **kwargs):\n        # Set the default after all other params are set\n        self.doc = doc\n        Utils.setKwargs(self, **kwargs)\n\n    @property\n    def propertyLink(self):\n        \"Can be something like: ('sigma', Maps.ReciprocalMap)\"\n        return getattr(self, '_propertyLink', None)\n    @propertyLink.setter\n    def propertyLink(self, value):\n        assert type(value) is tuple and len(value) == 2 and type(value[0]) is str and issubclass(value[1], Maps.IdentityMap), 'Use format: (\"%s\", Maps.ReciprocalMap)'%self.name\n        self._propertyLink = value\n\n    def _getMapProperty(self):\n        prop = self\n        def fget(self):\n            return getattr(self, '_%sMap'%prop.name, None)\n        def fset(self, val):\n            if prop.propertyLink is not None:\n                linkName, linkMap = prop.propertyLink\n                assert getattr(self, '%sMap'%linkName, None) is None, 'Cannot set both sides of a linked property.'\n            # TODO: Check if the mapping can be correct\n            setattr(self, '_%sMap'%prop.name, val)\n        return property(fget=fget, fset=fset, doc=prop.doc)\n\n    def _getIndexProperty(self):\n        prop = self\n        def fget(self):\n            return getattr(self, '_%sIndex'%prop.name, slice(None))\n        def fset(self, val):\n            setattr(self, '_%sIndex'%prop.name, val)\n        return property(fget=fget, fset=fset, doc=prop.doc)\n\n    def _getProperty(self):\n        prop = self\n        def fget(self):\n            mapping = getattr(self, '%sMap'%prop.name)\n            if mapping is None and prop.propertyLink is None:\n                return prop.defaultVal\n\n            if mapping is None and prop.propertyLink is not None:\n                linkName, linkMapClass = prop.propertyLink\n                linkMap = linkMapClass(None)\n                if getattr(self, '%sMap'%linkName, None) is None:\n                    return prop.defaultVal\n                m = getattr(self, '%s'%linkName)\n                return linkMap * m\n\n            m = getattr(self, '%sModel'%prop.name)\n            return mapping * m\n        return property(fget=fget)\n\n    def _getModelDerivProperty(self):\n        prop = self\n        def fget(self):\n            mapping = getattr(self, '%sMap'%prop.name)\n            if mapping is None and prop.propertyLink is None:\n                return None\n\n            if mapping is None and prop.propertyLink is not None:\n                linkName, linkMapClass = prop.propertyLink\n                linkedMap = getattr(self, '%sMap'%linkName)\n                if linkedMap is None:\n                    return None\n                linkMap = linkMapClass(None) * linkedMap\n                m = getattr(self, '%s'%linkName)\n                return linkMap.deriv( m )\n\n            m = getattr(self, '%sModel'%prop.name)\n            return mapping.deriv( m )\n        return property(fget=fget)\n\n    def _getModelProperty(self):\n        prop = self\n        def fget(self):\n            mapping = getattr(self, '%sMap'%prop.name)\n            if mapping is None:\n                return None\n            index = getattr(self.propMap, '%sIndex'%prop.name)\n            return self.vector[index]\n        return property(fget=fget)\n\n    def _getModelProjProperty(self):\n        prop = self\n        def fget(self):\n            mapping = getattr(self, '%sMap'%prop.name)\n            if mapping is None:\n                return None\n            inds = getattr(self.propMap, '%sIndex'%prop.name)\n            if type(inds) is slice:\n                inds = range(*inds.indices(self.nP))\n            nI, nP = len(inds),self.nP\n            return sp.csr_matrix((np.ones(nI), (range(nI), inds) ), shape=(nI, nP))\n        return property(fget=fget)\n\n    def _getModelMapProperty(self):\n        prop = self\n        def fget(self):\n            return getattr(self.propMap, '_%sMap'%prop.name, None)\n        return property(fget=fget)",
  "class PropModel(object):\n    def __init__(self, propMap, vector):\n        self.propMap = propMap\n        self.vector  = vector\n        assert len(self.vector) == self.nP\n\n    @property\n    def nP(self):\n        inds = []\n        if getattr(self, '_nP', None) is None:\n            for name in self.propMap._properties:\n                index = getattr(self.propMap, '%sIndex'%name, None)\n                if index is not None:\n                    if type(index) is slice:\n                        inds += range(*index.indices(len(self.vector)))\n                    else:\n                        inds += list(index)\n            self._nP = len(set(inds))\n        return self._nP\n\n    def __contains__(self, val):\n        return val in self.propMap",
  "class _PropMapMetaClass(type):\n    def __new__(cls, name, bases, attrs):\n        assert name.endswith('PropMap'), 'Please use convention: ___PropMap, e.g. ElectromagneticPropMap'\n        _properties = {}\n        for base in bases:\n            for baseProp in getattr(base, '_properties', {}):\n                _properties[baseProp] = base._properties[baseProp]\n        keys = [key for key in attrs]\n        for attr in keys:\n            if isinstance(attrs[attr], Property):\n                attrs[attr].name = attr\n                attrs[attr + 'Map'  ] = attrs[attr]._getMapProperty()\n                attrs[attr + 'Index'] = attrs[attr]._getIndexProperty()\n                _properties[attr] = attrs[attr]\n                attrs.pop(attr)\n\n        attrs['_properties'] = _properties\n\n        defaultInvProps = []\n        for p in _properties:\n            prop = _properties[p]\n            if prop.defaultInvProp:\n                defaultInvProps += [p]\n            if prop.propertyLink is not None:\n                assert prop.propertyLink[0] in _properties, \"You can only link to things that exist: '%s' is trying to link to '%s'\"%(prop.name, prop.propertyLink[0])\n        if len(defaultInvProps) > 1:\n            raise Exception('You have more than one default inversion property: %s' % defaultInvProps)\n\n        newClass = super(_PropMapMetaClass, cls).__new__(cls, name, bases, attrs)\n\n        newClass.PropModel = cls.createPropModelClass(newClass, name, _properties)\n\n        _PROPMAPCLASSREGISTRY[name] = newClass\n        return newClass\n\n    def createPropModelClass(self, name, _properties):\n\n        attrs = dict()\n\n        for attr in _properties:\n            prop = _properties[attr]\n\n            attrs[attr          ] = prop._getProperty()\n            attrs[attr + 'Map'  ] = prop._getModelMapProperty()\n            attrs[attr + 'Proj' ] = prop._getModelProjProperty()\n            attrs[attr + 'Model'] = prop._getModelProperty()\n            attrs[attr + 'Deriv'] = prop._getModelDerivProperty()\n\n        return type(name.replace('PropMap', 'PropModel'), (PropModel, ), attrs)",
  "class PropMap(object):\n    __metaclass__ = _PropMapMetaClass\n\n    def __init__(self, mappings):\n        \"\"\"\n            PropMap takes a multi parameter model and maps it to the equivalent PropModel\n        \"\"\"\n        if type(mappings) is dict:\n            assert np.all([k in ['maps', 'slices'] for k in mappings]), 'Dict must only have properties \"maps\" and \"slices\"'\n            self.setup(mappings['maps'], slices=mappings['slices'])\n        elif type(mappings) is list:\n            self.setup(mappings)\n        elif isinstance(mappings, Maps.IdentityMap):\n            self.setup([(self.defaultInvProp, mappings)])\n        else:\n            raise Exception('mappings must be a dict, a mapping, or a list of tuples.')\n\n\n    def setup(self, maps, slices=None):\n        \"\"\"\n            Sets up the maps and slices for the PropertyMap\n\n\n            :param list maps: [('sigma', sigmaMap), ('mu', muMap), ...]\n            :param list slices: [('sigma', slice(0,nP)), ('mu', [1,2,5,6]), ...]\n\n        \"\"\"\n        assert np.all([\n                type(m) is tuple and\n                len(m)==2 and\n                type(m[0]) is str and\n                m[0] in self._properties and\n                isinstance(m[1], Maps.IdentityMap)\n                for m in maps]), \"Use signature: [%s]\" % (', '.join([\"('%s', %sMap)\"%(p,p) for p in self._properties]))\n        if slices is None:\n            slices = dict()\n        else:\n            assert np.all([\n                s in self._properties and\n                (type(slices[s]) in [slice, list] or isinstance(slices[s], np.ndarray))\n                for s in slices]), 'Slices must be for each property'\n\n        self.clearMaps()\n\n        nP = 0\n        for name, mapping in maps:\n            setattr(self, '%sMap'%name, mapping)\n            setattr(self, '%sIndex'%name, slices.get(name, slice(nP, nP + mapping.nP)))\n            nP += mapping.nP\n        self.nP = nP \n\n    @property\n    def defaultInvProp(self):\n        for name in self._properties:\n            p = self._properties[name]\n            if p.defaultInvProp:\n                return p.name\n\n    def clearMaps(self):\n        for name in self._properties:\n            setattr(self, '%sMap'%name, None)\n            setattr(self, '%sIndex'%name, None)\n\n    def __call__(self, vec):\n        return self.PropModel(self, vec)\n\n    def __contains__(self, val):\n        activeMaps = [name for name in self._properties if getattr(self, '%sMap'%name) is not None]\n        return val in activeMaps",
  "def __init__(self, doc, **kwargs):\n        # Set the default after all other params are set\n        self.doc = doc\n        Utils.setKwargs(self, **kwargs)",
  "def propertyLink(self):\n        \"Can be something like: ('sigma', Maps.ReciprocalMap)\"\n        return getattr(self, '_propertyLink', None)",
  "def propertyLink(self, value):\n        assert type(value) is tuple and len(value) == 2 and type(value[0]) is str and issubclass(value[1], Maps.IdentityMap), 'Use format: (\"%s\", Maps.ReciprocalMap)'%self.name\n        self._propertyLink = value",
  "def _getMapProperty(self):\n        prop = self\n        def fget(self):\n            return getattr(self, '_%sMap'%prop.name, None)\n        def fset(self, val):\n            if prop.propertyLink is not None:\n                linkName, linkMap = prop.propertyLink\n                assert getattr(self, '%sMap'%linkName, None) is None, 'Cannot set both sides of a linked property.'\n            # TODO: Check if the mapping can be correct\n            setattr(self, '_%sMap'%prop.name, val)\n        return property(fget=fget, fset=fset, doc=prop.doc)",
  "def _getIndexProperty(self):\n        prop = self\n        def fget(self):\n            return getattr(self, '_%sIndex'%prop.name, slice(None))\n        def fset(self, val):\n            setattr(self, '_%sIndex'%prop.name, val)\n        return property(fget=fget, fset=fset, doc=prop.doc)",
  "def _getProperty(self):\n        prop = self\n        def fget(self):\n            mapping = getattr(self, '%sMap'%prop.name)\n            if mapping is None and prop.propertyLink is None:\n                return prop.defaultVal\n\n            if mapping is None and prop.propertyLink is not None:\n                linkName, linkMapClass = prop.propertyLink\n                linkMap = linkMapClass(None)\n                if getattr(self, '%sMap'%linkName, None) is None:\n                    return prop.defaultVal\n                m = getattr(self, '%s'%linkName)\n                return linkMap * m\n\n            m = getattr(self, '%sModel'%prop.name)\n            return mapping * m\n        return property(fget=fget)",
  "def _getModelDerivProperty(self):\n        prop = self\n        def fget(self):\n            mapping = getattr(self, '%sMap'%prop.name)\n            if mapping is None and prop.propertyLink is None:\n                return None\n\n            if mapping is None and prop.propertyLink is not None:\n                linkName, linkMapClass = prop.propertyLink\n                linkedMap = getattr(self, '%sMap'%linkName)\n                if linkedMap is None:\n                    return None\n                linkMap = linkMapClass(None) * linkedMap\n                m = getattr(self, '%s'%linkName)\n                return linkMap.deriv( m )\n\n            m = getattr(self, '%sModel'%prop.name)\n            return mapping.deriv( m )\n        return property(fget=fget)",
  "def _getModelProperty(self):\n        prop = self\n        def fget(self):\n            mapping = getattr(self, '%sMap'%prop.name)\n            if mapping is None:\n                return None\n            index = getattr(self.propMap, '%sIndex'%prop.name)\n            return self.vector[index]\n        return property(fget=fget)",
  "def _getModelProjProperty(self):\n        prop = self\n        def fget(self):\n            mapping = getattr(self, '%sMap'%prop.name)\n            if mapping is None:\n                return None\n            inds = getattr(self.propMap, '%sIndex'%prop.name)\n            if type(inds) is slice:\n                inds = range(*inds.indices(self.nP))\n            nI, nP = len(inds),self.nP\n            return sp.csr_matrix((np.ones(nI), (range(nI), inds) ), shape=(nI, nP))\n        return property(fget=fget)",
  "def _getModelMapProperty(self):\n        prop = self\n        def fget(self):\n            return getattr(self.propMap, '_%sMap'%prop.name, None)\n        return property(fget=fget)",
  "def __init__(self, propMap, vector):\n        self.propMap = propMap\n        self.vector  = vector\n        assert len(self.vector) == self.nP",
  "def nP(self):\n        inds = []\n        if getattr(self, '_nP', None) is None:\n            for name in self.propMap._properties:\n                index = getattr(self.propMap, '%sIndex'%name, None)\n                if index is not None:\n                    if type(index) is slice:\n                        inds += range(*index.indices(len(self.vector)))\n                    else:\n                        inds += list(index)\n            self._nP = len(set(inds))\n        return self._nP",
  "def __contains__(self, val):\n        return val in self.propMap",
  "def __new__(cls, name, bases, attrs):\n        assert name.endswith('PropMap'), 'Please use convention: ___PropMap, e.g. ElectromagneticPropMap'\n        _properties = {}\n        for base in bases:\n            for baseProp in getattr(base, '_properties', {}):\n                _properties[baseProp] = base._properties[baseProp]\n        keys = [key for key in attrs]\n        for attr in keys:\n            if isinstance(attrs[attr], Property):\n                attrs[attr].name = attr\n                attrs[attr + 'Map'  ] = attrs[attr]._getMapProperty()\n                attrs[attr + 'Index'] = attrs[attr]._getIndexProperty()\n                _properties[attr] = attrs[attr]\n                attrs.pop(attr)\n\n        attrs['_properties'] = _properties\n\n        defaultInvProps = []\n        for p in _properties:\n            prop = _properties[p]\n            if prop.defaultInvProp:\n                defaultInvProps += [p]\n            if prop.propertyLink is not None:\n                assert prop.propertyLink[0] in _properties, \"You can only link to things that exist: '%s' is trying to link to '%s'\"%(prop.name, prop.propertyLink[0])\n        if len(defaultInvProps) > 1:\n            raise Exception('You have more than one default inversion property: %s' % defaultInvProps)\n\n        newClass = super(_PropMapMetaClass, cls).__new__(cls, name, bases, attrs)\n\n        newClass.PropModel = cls.createPropModelClass(newClass, name, _properties)\n\n        _PROPMAPCLASSREGISTRY[name] = newClass\n        return newClass",
  "def createPropModelClass(self, name, _properties):\n\n        attrs = dict()\n\n        for attr in _properties:\n            prop = _properties[attr]\n\n            attrs[attr          ] = prop._getProperty()\n            attrs[attr + 'Map'  ] = prop._getModelMapProperty()\n            attrs[attr + 'Proj' ] = prop._getModelProjProperty()\n            attrs[attr + 'Model'] = prop._getModelProperty()\n            attrs[attr + 'Deriv'] = prop._getModelDerivProperty()\n\n        return type(name.replace('PropMap', 'PropModel'), (PropModel, ), attrs)",
  "def __init__(self, mappings):\n        \"\"\"\n            PropMap takes a multi parameter model and maps it to the equivalent PropModel\n        \"\"\"\n        if type(mappings) is dict:\n            assert np.all([k in ['maps', 'slices'] for k in mappings]), 'Dict must only have properties \"maps\" and \"slices\"'\n            self.setup(mappings['maps'], slices=mappings['slices'])\n        elif type(mappings) is list:\n            self.setup(mappings)\n        elif isinstance(mappings, Maps.IdentityMap):\n            self.setup([(self.defaultInvProp, mappings)])\n        else:\n            raise Exception('mappings must be a dict, a mapping, or a list of tuples.')",
  "def setup(self, maps, slices=None):\n        \"\"\"\n            Sets up the maps and slices for the PropertyMap\n\n\n            :param list maps: [('sigma', sigmaMap), ('mu', muMap), ...]\n            :param list slices: [('sigma', slice(0,nP)), ('mu', [1,2,5,6]), ...]\n\n        \"\"\"\n        assert np.all([\n                type(m) is tuple and\n                len(m)==2 and\n                type(m[0]) is str and\n                m[0] in self._properties and\n                isinstance(m[1], Maps.IdentityMap)\n                for m in maps]), \"Use signature: [%s]\" % (', '.join([\"('%s', %sMap)\"%(p,p) for p in self._properties]))\n        if slices is None:\n            slices = dict()\n        else:\n            assert np.all([\n                s in self._properties and\n                (type(slices[s]) in [slice, list] or isinstance(slices[s], np.ndarray))\n                for s in slices]), 'Slices must be for each property'\n\n        self.clearMaps()\n\n        nP = 0\n        for name, mapping in maps:\n            setattr(self, '%sMap'%name, mapping)\n            setattr(self, '%sIndex'%name, slices.get(name, slice(nP, nP + mapping.nP)))\n            nP += mapping.nP\n        self.nP = nP",
  "def defaultInvProp(self):\n        for name in self._properties:\n            p = self._properties[name]\n            if p.defaultInvProp:\n                return p.name",
  "def clearMaps(self):\n        for name in self._properties:\n            setattr(self, '%sMap'%name, None)\n            setattr(self, '%sIndex'%name, None)",
  "def __call__(self, vec):\n        return self.PropModel(self, vec)",
  "def __contains__(self, val):\n        activeMaps = [name for name in self._properties if getattr(self, '%sMap'%name) is not None]\n        return val in activeMaps",
  "def fget(self):\n            return getattr(self, '_%sMap'%prop.name, None)",
  "def fset(self, val):\n            if prop.propertyLink is not None:\n                linkName, linkMap = prop.propertyLink\n                assert getattr(self, '%sMap'%linkName, None) is None, 'Cannot set both sides of a linked property.'\n            # TODO: Check if the mapping can be correct\n            setattr(self, '_%sMap'%prop.name, val)",
  "def fget(self):\n            return getattr(self, '_%sIndex'%prop.name, slice(None))",
  "def fset(self, val):\n            setattr(self, '_%sIndex'%prop.name, val)",
  "def fget(self):\n            mapping = getattr(self, '%sMap'%prop.name)\n            if mapping is None and prop.propertyLink is None:\n                return prop.defaultVal\n\n            if mapping is None and prop.propertyLink is not None:\n                linkName, linkMapClass = prop.propertyLink\n                linkMap = linkMapClass(None)\n                if getattr(self, '%sMap'%linkName, None) is None:\n                    return prop.defaultVal\n                m = getattr(self, '%s'%linkName)\n                return linkMap * m\n\n            m = getattr(self, '%sModel'%prop.name)\n            return mapping * m",
  "def fget(self):\n            mapping = getattr(self, '%sMap'%prop.name)\n            if mapping is None and prop.propertyLink is None:\n                return None\n\n            if mapping is None and prop.propertyLink is not None:\n                linkName, linkMapClass = prop.propertyLink\n                linkedMap = getattr(self, '%sMap'%linkName)\n                if linkedMap is None:\n                    return None\n                linkMap = linkMapClass(None) * linkedMap\n                m = getattr(self, '%s'%linkName)\n                return linkMap.deriv( m )\n\n            m = getattr(self, '%sModel'%prop.name)\n            return mapping.deriv( m )",
  "def fget(self):\n            mapping = getattr(self, '%sMap'%prop.name)\n            if mapping is None:\n                return None\n            index = getattr(self.propMap, '%sIndex'%prop.name)\n            return self.vector[index]",
  "def fget(self):\n            mapping = getattr(self, '%sMap'%prop.name)\n            if mapping is None:\n                return None\n            inds = getattr(self.propMap, '%sIndex'%prop.name)\n            if type(inds) is slice:\n                inds = range(*inds.indices(self.nP))\n            nI, nP = len(inds),self.nP\n            return sp.csr_matrix((np.ones(nI), (range(nI), inds) ), shape=(nI, nP))",
  "def fget(self):\n            return getattr(self.propMap, '_%sMap'%prop.name, None)",
  "class Fields(object):\n    \"\"\"Fancy Field Storage\n\n        u[:,'phi'] = phi\n        print u[src0,'phi']\n\n    \"\"\"\n\n    knownFields = None  #: Known fields,   a dict with locations,         e.g. {\"e\": \"E\", \"phi\": \"CC\"}\n    aliasFields = None  #: Aliased fields, a dict with [alias, location, function], e.g. {\"b\":[\"e\",\"F\",lambda(F,e,ind)]}\n    dtype = float       #: dtype is the type of the storage matrix. This can be a dictionary.\n\n    def __init__(self, mesh, survey, **kwargs):\n        self.survey = survey\n        self.mesh = mesh\n        Utils.setKwargs(self, **kwargs)\n        self._fields = {}\n\n        if self.knownFields is None:\n            raise Exception('knownFields cannot be set to None')\n        if self.aliasFields is None:\n            self.aliasFields = {}\n\n        allFields = [k for k in self.knownFields] + [a for a in self.aliasFields]\n        assert len(allFields) == len(set(allFields)), 'Aliased fields and Known Fields have overlapping definitions.'\n        self.startup()\n\n    def startup(self):\n        pass\n\n    @property\n    def approxSize(self):\n        \"\"\"The approximate cost to storing all of the known fields.\"\"\"\n        sz = 0.0\n        for f in self.knownFields:\n            loc =self.knownFields[f]\n            sz += np.array(self._storageShape(loc)).prod()*8.0/(1024**2)\n        return \"%e MB\"%sz\n\n    def _storageShape(self, loc):\n        nSrc = self.survey.nSrc\n\n        nP = {'CC': self.mesh.nC,\n              'N':  self.mesh.nN,\n              'F':  self.mesh.nF,\n              'E':  self.mesh.nE}[loc]\n\n        return (nP, nSrc)\n\n    def _initStore(self, name):\n        if name in self._fields:\n            return self._fields[name]\n\n        assert name in self.knownFields, 'field name is not known.'\n\n        loc = self.knownFields[name]\n\n        if type(self.dtype) is dict:\n            dtype = self.dtype[name]\n        else:\n            dtype = self.dtype\n        field = np.zeros(self._storageShape(loc), dtype=dtype)\n\n        self._fields[name] = field\n\n        return field\n\n    def _srcIndex(self, srcTestList):\n        if type(srcTestList) is slice:\n            ind = srcTestList\n        else:\n            ind = self.survey.getSourceIndex(srcTestList)\n        return ind\n\n    def _nameIndex(self, name, accessType):\n\n        if type(name) is slice:\n            assert name == slice(None,None,None), 'Fancy field name slicing is not supported... yet.'\n            name = None\n\n        if name is None:\n            return\n        if accessType=='set' and name not in self.knownFields:\n            if name in self.aliasFields:\n                raise KeyError(\"Invalid field name (%s) for setter, you can't set an aliased property\"%name)\n            else:\n                raise KeyError('Invalid field name (%s) for setter'%name)\n\n        elif accessType=='get' and (name not in self.knownFields and name not in self.aliasFields):\n            raise KeyError('Invalid field name (%s) for getter'%name)\n        return name\n\n    def _indexAndNameFromKey(self, key, accessType):\n        if type(key) is not tuple:\n            key = (key,)\n        if len(key) == 1:\n            key += (None,)\n\n        assert len(key) == 2, 'must be [Src, fieldName]'\n\n        srcTestList, name = key\n        name = self._nameIndex(name, accessType)\n        ind = self._srcIndex(srcTestList)\n        return ind, name\n\n    def __setitem__(self, key, value):\n        ind, name = self._indexAndNameFromKey(key, 'set')\n        if name is None:\n            freq = key\n            assert type(value) is dict, 'New fields must be a dictionary, if field is not specified.'\n            newFields = value\n        elif name in self.knownFields:\n            newFields = {name: value}\n        else:\n            raise Exception('Unknown setter')\n\n        for name in newFields:\n            field = self._initStore(name)\n            self._setField(field, newFields[name], name, ind)\n\n    def __getitem__(self, key):\n        ind, name = self._indexAndNameFromKey(key, 'get')\n        if name is None:\n            out = {}\n            for name in self._fields:\n                out[name] = self._getField(name, ind)\n            return out\n        return self._getField(name, ind)\n\n    def _setField(self, field, val, name, ind):\n        if isinstance(val, np.ndarray) and (field.shape[0] == field.size or val.ndim == 1):\n            val = Utils.mkvc(val,2)\n        field[:,ind] = val\n\n    def _getField(self, name, ind):\n        if name in self._fields:\n            out = self._fields[name][:,ind]\n        else:\n            # Aliased fields\n            alias, loc, func = self.aliasFields[name]\n\n            srcII = np.array(self.survey.srcList)[ind]\n            srcII = srcII.tolist()\n\n            if type(func) is str:\n                assert hasattr(self, func), 'The alias field function is a string, but it does not exist in the Fields class.'\n                func = getattr(self, func)\n            out = func(self._fields[alias][:,ind], srcII)\n        if out.shape[0] == out.size or out.ndim == 1:\n            out = Utils.mkvc(out,2)\n        return out\n\n    def __contains__(self, other):\n        if other in self.aliasFields:\n            other = self.aliasFields[other][0]\n        return self._fields.__contains__(other)",
  "class TimeFields(Fields):\n    \"\"\"Fancy Field Storage for time domain problems\n\n        u[:,'phi', timeInd] = phi\n        print u[src0,'phi']\n\n    \"\"\"\n\n    def _storageShape(self, loc):\n        nP = {'CC': self.mesh.nC,\n              'N':  self.mesh.nN,\n              'F':  self.mesh.nF,\n              'E':  self.mesh.nE}[loc]\n        nSrc = self.survey.nSrc\n        nT = self.survey.prob.nT + 1\n        return (nP, nSrc, nT)\n\n    def _indexAndNameFromKey(self, key, accessType):\n        if type(key) is not tuple:\n            key = (key,)\n        if len(key) == 1:\n            key += (None,)\n        if len(key) == 2:\n            key += (slice(None,None,None),)\n\n        assert len(key) == 3, 'must be [Src, fieldName, times]'\n\n        srcTestList, name, timeInd = key\n\n        name = self._nameIndex(name, accessType)\n        srcInd = self._srcIndex(srcTestList)\n\n        return (srcInd, timeInd), name\n\n    def _correctShape(self, name, ind, deflate=False):\n        srcInd, timeInd = ind\n        if name in self.knownFields:\n            loc = self.knownFields[name]\n        else:\n            loc = self.aliasFields[name][1]\n        nP, total_nSrc, total_nT = self._storageShape(loc)\n        nSrc = np.ones(total_nSrc, dtype=bool)[srcInd].sum()\n        nT  = np.ones(total_nT, dtype=bool)[timeInd].sum()\n        shape = nP, nSrc, nT\n        if deflate:\n             shape = tuple([s for s in shape if s > 1])\n        if len(shape) == 1:\n            shape = shape + (1,)\n        return shape\n\n    def _setField(self, field, val, name, ind):\n        srcInd, timeInd = ind\n        shape = self._correctShape(name, ind)\n        if Utils.isScalar(val):\n            field[:,srcInd,timeInd] = val\n            return\n        if val.size != np.array(shape).prod():\n            raise ValueError('Incorrect size for data.')\n        correctShape = field[:,srcInd,timeInd].shape\n        field[:,srcInd,timeInd] = val.reshape(correctShape, order='F')\n\n    def _getField(self, name, ind):\n        srcInd, timeInd = ind\n\n        if name in self._fields:\n            out = self._fields[name][:,srcInd,timeInd]\n        else:\n            # Aliased fields\n            alias, loc, func = self.aliasFields[name]\n            if type(func) is str:\n                assert hasattr(self, func), 'The alias field function is a string, but it does not exist in the Fields class.'\n                func = getattr(self, func)\n            pointerFields = self._fields[alias][:,srcInd,timeInd]\n            pointerShape = self._correctShape(alias, ind)\n            pointerFields = pointerFields.reshape(pointerShape, order='F')\n\n            timeII = np.arange(self.survey.prob.nT + 1)[timeInd]\n            srcII  = np.array(self.survey.srcList)[srcInd]\n            srcII  = srcII.tolist()\n\n            if timeII.size == 1:\n                pointerShapeDeflated = self._correctShape(alias, ind, deflate=True)\n                pointerFields = pointerFields.reshape(pointerShapeDeflated, order='F')\n                out = func(pointerFields, srcII, timeII)\n            else: #loop over the time steps\n                nT = pointerShape[2]\n                out = range(nT)\n                for i, TIND_i in enumerate(timeII):\n                    fieldI = pointerFields[:,:,i]\n                    if fieldI.shape[0] == fieldI.size:\n                        fieldI = Utils.mkvc(fieldI, 2)\n                    out[i] = func(fieldI, srcII, TIND_i)\n                    if out[i].ndim == 1:\n                        out[i] = out[i][:,np.newaxis,np.newaxis]\n                    elif out[i].ndim == 2:\n                        out[i] = out[i][:,:,np.newaxis]\n                out = np.concatenate(out, axis=2)\n\n        shape = self._correctShape(name, ind, deflate=True)\n        return out.reshape(shape, order='F')",
  "def __init__(self, mesh, survey, **kwargs):\n        self.survey = survey\n        self.mesh = mesh\n        Utils.setKwargs(self, **kwargs)\n        self._fields = {}\n\n        if self.knownFields is None:\n            raise Exception('knownFields cannot be set to None')\n        if self.aliasFields is None:\n            self.aliasFields = {}\n\n        allFields = [k for k in self.knownFields] + [a for a in self.aliasFields]\n        assert len(allFields) == len(set(allFields)), 'Aliased fields and Known Fields have overlapping definitions.'\n        self.startup()",
  "def startup(self):\n        pass",
  "def approxSize(self):\n        \"\"\"The approximate cost to storing all of the known fields.\"\"\"\n        sz = 0.0\n        for f in self.knownFields:\n            loc =self.knownFields[f]\n            sz += np.array(self._storageShape(loc)).prod()*8.0/(1024**2)\n        return \"%e MB\"%sz",
  "def _storageShape(self, loc):\n        nSrc = self.survey.nSrc\n\n        nP = {'CC': self.mesh.nC,\n              'N':  self.mesh.nN,\n              'F':  self.mesh.nF,\n              'E':  self.mesh.nE}[loc]\n\n        return (nP, nSrc)",
  "def _initStore(self, name):\n        if name in self._fields:\n            return self._fields[name]\n\n        assert name in self.knownFields, 'field name is not known.'\n\n        loc = self.knownFields[name]\n\n        if type(self.dtype) is dict:\n            dtype = self.dtype[name]\n        else:\n            dtype = self.dtype\n        field = np.zeros(self._storageShape(loc), dtype=dtype)\n\n        self._fields[name] = field\n\n        return field",
  "def _srcIndex(self, srcTestList):\n        if type(srcTestList) is slice:\n            ind = srcTestList\n        else:\n            ind = self.survey.getSourceIndex(srcTestList)\n        return ind",
  "def _nameIndex(self, name, accessType):\n\n        if type(name) is slice:\n            assert name == slice(None,None,None), 'Fancy field name slicing is not supported... yet.'\n            name = None\n\n        if name is None:\n            return\n        if accessType=='set' and name not in self.knownFields:\n            if name in self.aliasFields:\n                raise KeyError(\"Invalid field name (%s) for setter, you can't set an aliased property\"%name)\n            else:\n                raise KeyError('Invalid field name (%s) for setter'%name)\n\n        elif accessType=='get' and (name not in self.knownFields and name not in self.aliasFields):\n            raise KeyError('Invalid field name (%s) for getter'%name)\n        return name",
  "def _indexAndNameFromKey(self, key, accessType):\n        if type(key) is not tuple:\n            key = (key,)\n        if len(key) == 1:\n            key += (None,)\n\n        assert len(key) == 2, 'must be [Src, fieldName]'\n\n        srcTestList, name = key\n        name = self._nameIndex(name, accessType)\n        ind = self._srcIndex(srcTestList)\n        return ind, name",
  "def __setitem__(self, key, value):\n        ind, name = self._indexAndNameFromKey(key, 'set')\n        if name is None:\n            freq = key\n            assert type(value) is dict, 'New fields must be a dictionary, if field is not specified.'\n            newFields = value\n        elif name in self.knownFields:\n            newFields = {name: value}\n        else:\n            raise Exception('Unknown setter')\n\n        for name in newFields:\n            field = self._initStore(name)\n            self._setField(field, newFields[name], name, ind)",
  "def __getitem__(self, key):\n        ind, name = self._indexAndNameFromKey(key, 'get')\n        if name is None:\n            out = {}\n            for name in self._fields:\n                out[name] = self._getField(name, ind)\n            return out\n        return self._getField(name, ind)",
  "def _setField(self, field, val, name, ind):\n        if isinstance(val, np.ndarray) and (field.shape[0] == field.size or val.ndim == 1):\n            val = Utils.mkvc(val,2)\n        field[:,ind] = val",
  "def _getField(self, name, ind):\n        if name in self._fields:\n            out = self._fields[name][:,ind]\n        else:\n            # Aliased fields\n            alias, loc, func = self.aliasFields[name]\n\n            srcII = np.array(self.survey.srcList)[ind]\n            srcII = srcII.tolist()\n\n            if type(func) is str:\n                assert hasattr(self, func), 'The alias field function is a string, but it does not exist in the Fields class.'\n                func = getattr(self, func)\n            out = func(self._fields[alias][:,ind], srcII)\n        if out.shape[0] == out.size or out.ndim == 1:\n            out = Utils.mkvc(out,2)\n        return out",
  "def __contains__(self, other):\n        if other in self.aliasFields:\n            other = self.aliasFields[other][0]\n        return self._fields.__contains__(other)",
  "def _storageShape(self, loc):\n        nP = {'CC': self.mesh.nC,\n              'N':  self.mesh.nN,\n              'F':  self.mesh.nF,\n              'E':  self.mesh.nE}[loc]\n        nSrc = self.survey.nSrc\n        nT = self.survey.prob.nT + 1\n        return (nP, nSrc, nT)",
  "def _indexAndNameFromKey(self, key, accessType):\n        if type(key) is not tuple:\n            key = (key,)\n        if len(key) == 1:\n            key += (None,)\n        if len(key) == 2:\n            key += (slice(None,None,None),)\n\n        assert len(key) == 3, 'must be [Src, fieldName, times]'\n\n        srcTestList, name, timeInd = key\n\n        name = self._nameIndex(name, accessType)\n        srcInd = self._srcIndex(srcTestList)\n\n        return (srcInd, timeInd), name",
  "def _correctShape(self, name, ind, deflate=False):\n        srcInd, timeInd = ind\n        if name in self.knownFields:\n            loc = self.knownFields[name]\n        else:\n            loc = self.aliasFields[name][1]\n        nP, total_nSrc, total_nT = self._storageShape(loc)\n        nSrc = np.ones(total_nSrc, dtype=bool)[srcInd].sum()\n        nT  = np.ones(total_nT, dtype=bool)[timeInd].sum()\n        shape = nP, nSrc, nT\n        if deflate:\n             shape = tuple([s for s in shape if s > 1])\n        if len(shape) == 1:\n            shape = shape + (1,)\n        return shape",
  "def _setField(self, field, val, name, ind):\n        srcInd, timeInd = ind\n        shape = self._correctShape(name, ind)\n        if Utils.isScalar(val):\n            field[:,srcInd,timeInd] = val\n            return\n        if val.size != np.array(shape).prod():\n            raise ValueError('Incorrect size for data.')\n        correctShape = field[:,srcInd,timeInd].shape\n        field[:,srcInd,timeInd] = val.reshape(correctShape, order='F')",
  "def _getField(self, name, ind):\n        srcInd, timeInd = ind\n\n        if name in self._fields:\n            out = self._fields[name][:,srcInd,timeInd]\n        else:\n            # Aliased fields\n            alias, loc, func = self.aliasFields[name]\n            if type(func) is str:\n                assert hasattr(self, func), 'The alias field function is a string, but it does not exist in the Fields class.'\n                func = getattr(self, func)\n            pointerFields = self._fields[alias][:,srcInd,timeInd]\n            pointerShape = self._correctShape(alias, ind)\n            pointerFields = pointerFields.reshape(pointerShape, order='F')\n\n            timeII = np.arange(self.survey.prob.nT + 1)[timeInd]\n            srcII  = np.array(self.survey.srcList)[srcInd]\n            srcII  = srcII.tolist()\n\n            if timeII.size == 1:\n                pointerShapeDeflated = self._correctShape(alias, ind, deflate=True)\n                pointerFields = pointerFields.reshape(pointerShapeDeflated, order='F')\n                out = func(pointerFields, srcII, timeII)\n            else: #loop over the time steps\n                nT = pointerShape[2]\n                out = range(nT)\n                for i, TIND_i in enumerate(timeII):\n                    fieldI = pointerFields[:,:,i]\n                    if fieldI.shape[0] == fieldI.size:\n                        fieldI = Utils.mkvc(fieldI, 2)\n                    out[i] = func(fieldI, srcII, TIND_i)\n                    if out[i].ndim == 1:\n                        out[i] = out[i][:,np.newaxis,np.newaxis]\n                    elif out[i].ndim == 2:\n                        out[i] = out[i][:,:,np.newaxis]\n                out = np.concatenate(out, axis=2)\n\n        shape = self._correctShape(name, ind, deflate=True)\n        return out.reshape(shape, order='F')",
  "class Model(np.ndarray):\n\n    def __new__(cls, input_array, mapping=None):\n        assert isinstance(mapping, IdentityMap), 'mapping must be a SimPEG.Mapping'\n        assert isinstance(input_array, np.ndarray), 'input_array must be a numpy array'\n        assert len(input_array.shape) == 1, 'input_array must be a 1D vector'\n        obj = np.asarray(input_array).view(cls)\n        obj._mapping = mapping\n        if not obj.size == mapping.nP:\n            raise Exception('Incorrect size for array.')\n        return obj\n\n    def __array_finalize__(self, obj):\n        if obj is None: return\n        self._mapping = getattr(obj, '_mapping', None)\n\n    @property\n    def mapping(self):\n        return self._mapping\n\n    @property\n    def transform(self):\n        if getattr(self, '_transform', None) is None:\n            self._transform = self.mapping * self.view(np.ndarray)\n        return self._transform\n\n    @property\n    def transformDeriv(self):\n        if getattr(self, '_transformDeriv', None) is None:\n            self._transformDeriv = self.mapping.deriv(self.view(np.ndarray))\n        return self._transformDeriv",
  "def __new__(cls, input_array, mapping=None):\n        assert isinstance(mapping, IdentityMap), 'mapping must be a SimPEG.Mapping'\n        assert isinstance(input_array, np.ndarray), 'input_array must be a numpy array'\n        assert len(input_array.shape) == 1, 'input_array must be a 1D vector'\n        obj = np.asarray(input_array).view(cls)\n        obj._mapping = mapping\n        if not obj.size == mapping.nP:\n            raise Exception('Incorrect size for array.')\n        return obj",
  "def __array_finalize__(self, obj):\n        if obj is None: return\n        self._mapping = getattr(obj, '_mapping', None)",
  "def mapping(self):\n        return self._mapping",
  "def transform(self):\n        if getattr(self, '_transform', None) is None:\n            self._transform = self.mapping * self.view(np.ndarray)\n        return self._transform",
  "def transformDeriv(self):\n        if getattr(self, '_transformDeriv', None) is None:\n            self._transformDeriv = self.mapping.deriv(self.view(np.ndarray))\n        return self._transformDeriv",
  "class LinearSurvey(Survey.BaseSurvey):\n    def projectFields(self, u):\n        return u",
  "class LinearProblem(Problem.BaseProblem):\n    \"\"\"docstring for LinearProblem\"\"\"\n\n    surveyPair = LinearSurvey\n\n    def __init__(self, mesh, G, **kwargs):\n        Problem.BaseProblem.__init__(self, mesh, **kwargs)\n        self.G = G\n\n    def fields(self, m, u=None):\n        return self.G.dot(m)\n\n    def Jvec(self, m, v, u=None):\n        return self.G.dot(v)\n\n    def Jtvec(self, m, v, u=None):\n        return self.G.T.dot(v)",
  "def run(N, plotIt=True):\n    mesh = Mesh.TensorMesh([N])\n\n    nk = 20\n    jk = np.linspace(1.,20.,nk)\n    p = -0.25\n    q = 0.25\n\n    g = lambda k: np.exp(p*jk[k]*mesh.vectorCCx)*np.cos(2*np.pi*q*jk[k]*mesh.vectorCCx)\n\n    G = np.empty((nk, mesh.nC))\n\n    for i in range(nk):\n        G[i,:] = g(i)\n\n    mtrue = np.zeros(mesh.nC)\n    mtrue[mesh.vectorCCx > 0.3] = 1.\n    mtrue[mesh.vectorCCx > 0.45] = -0.5\n    mtrue[mesh.vectorCCx > 0.6] = 0\n\n    prob = LinearProblem(mesh, G)\n    survey = LinearSurvey()\n    survey.pair(prob)\n    survey.makeSyntheticData(mtrue, std=0.01)\n\n    M = prob.mesh\n\n    reg = Regularization.Tikhonov(mesh)\n    dmis = DataMisfit.l2_DataMisfit(survey)\n    opt = Optimization.InexactGaussNewton(maxIter=20)\n    invProb = InvProblem.BaseInvProblem(dmis, reg, opt)\n    beta = Directives.BetaSchedule()\n    betaest = Directives.BetaEstimate_ByEig()\n    inv = Inversion.BaseInversion(invProb, directiveList=[beta, betaest])\n    m0 = np.zeros_like(survey.mtrue)\n\n    mrec = inv.run(m0)\n\n    if plotIt:\n        import matplotlib.pyplot as plt\n        plt.figure(1)\n        for i in range(prob.G.shape[0]):\n            plt.plot(prob.G[i,:])\n\n        plt.figure(2)\n        plt.plot(M.vectorCCx, survey.mtrue, 'b-')\n        plt.plot(M.vectorCCx, mrec, 'r-')\n        plt.show()\n\n    return prob, survey, mesh, mrec",
  "def projectFields(self, u):\n        return u",
  "def __init__(self, mesh, G, **kwargs):\n        Problem.BaseProblem.__init__(self, mesh, **kwargs)\n        self.G = G",
  "def fields(self, m, u=None):\n        return self.G.dot(m)",
  "def Jvec(self, m, v, u=None):\n        return self.G.dot(v)",
  "def Jtvec(self, m, v, u=None):\n        return self.G.T.dot(v)",
  "def run(plotIt=True):\n    # Step1: Generate Tensor and Curvilinear Mesh\n    sz = [40,40]\n    # Tensor Mesh\n    tM = Mesh.TensorMesh(sz)\n    # Curvilinear Mesh\n    rM = Mesh.CurvilinearMesh(Utils.meshutils.exampleLrmGrid(sz,'rotate'))\n\n    # Step2: Direct Current (DC) operator\n    def DCfun(mesh, pts):\n        D = mesh.faceDiv\n        G = D.T\n        sigma = 1e-2*np.ones(mesh.nC)\n        Msigi = mesh.getFaceInnerProduct(1./sigma)\n        MsigI = Utils.sdInv(Msigi)\n        A = D*MsigI*G\n        A[-1,-1] /= mesh.vol[-1] # Remove null space\n        rhs = np.zeros(mesh.nC)\n        txind = Utils.meshutils.closestPoints(mesh, pts)\n        rhs[txind] = np.r_[1,-1]\n        return A, rhs\n\n    pts = np.vstack((np.r_[0.25, 0.5], np.r_[0.75, 0.5]))\n\n    #Step3: Solve DC problem (LU solver)\n    AtM, rhstM = DCfun(tM, pts)\n    AinvtM = SolverLU(AtM)\n    phitM = AinvtM*rhstM\n\n    ArM, rhsrM = DCfun(rM, pts)\n    AinvrM = SolverLU(ArM)\n    phirM = AinvrM*rhsrM\n\n    if not plotIt: return\n    #Step4: Making Figure\n    fig, axes = plt.subplots(1,2,figsize=(12*1.2,4*1.2))\n    label = [\"(a)\", \"(b)\"]\n    opts = {}\n    vmin, vmax = phitM.min(), phitM.max()\n    dat = tM.plotImage(phitM, ax=axes[0], clim=(vmin, vmax), grid=True)\n\n    #TODO: At the moment Curvilinear Mesh do not have plotimage\n\n    Xi = tM.gridCC[:,0].reshape(sz[0], sz[1], order='F')\n    Yi = tM.gridCC[:,1].reshape(sz[0], sz[1], order='F')\n    PHIrM = griddata(rM.gridCC[:,0], rM.gridCC[:,1], phirM, Xi, Yi, interp='linear')\n    axes[1].contourf(Xi, Yi, PHIrM, 100, vmin=vmin, vmax=vmax)\n\n    cb = plt.colorbar(dat[0], ax=axes[0]); cb.set_label(\"Voltage (V)\")\n    cb = plt.colorbar(dat[0], ax=axes[1]); cb.set_label(\"Voltage (V)\")\n\n    tM.plotGrid(ax=axes[0], **opts)\n    axes[0].set_title('TensorMesh')\n    rM.plotGrid(ax=axes[1], **opts)\n    axes[1].set_title('CurvilinearMesh')\n    for i in range(2):\n        axes[i].set_xlim(0.025, 0.975)\n        axes[i].set_ylim(0.025, 0.975)\n        axes[i].text(0., 1.0, label[i], fontsize=20)\n        if i==0:\n            axes[i].set_ylabel(\"y\")\n        else:\n            axes[i].set_ylabel(\" \")\n        axes[i].set_xlabel(\"x\")",
  "def DCfun(mesh, pts):\n        D = mesh.faceDiv\n        G = D.T\n        sigma = 1e-2*np.ones(mesh.nC)\n        Msigi = mesh.getFaceInnerProduct(1./sigma)\n        MsigI = Utils.sdInv(Msigi)\n        A = D*MsigI*G\n        A[-1,-1] /= mesh.vol[-1] # Remove null space\n        rhs = np.zeros(mesh.nC)\n        txind = Utils.meshutils.closestPoints(mesh, pts)\n        rhs[txind] = np.r_[1,-1]\n        return A, rhs",
  "def run(plotIt=True):\n    M = Mesh.TensorMesh([np.ones(40)])\n    M.setCellGradBC('dirichlet')\n    params = Richards.Empirical.HaverkampParams().celia1990\n    params['Ks'] = np.log(params['Ks'])\n    E = Richards.Empirical.Haverkamp(M, **params)\n\n    bc = np.array([-61.5,-20.7])\n    h = np.zeros(M.nC) + bc[0]\n\n\n    def getFields(timeStep,method):\n        timeSteps = np.ones(360/timeStep)*timeStep\n        prob = Richards.RichardsProblem(M, mapping=E, timeSteps=timeSteps,\n                                        boundaryConditions=bc, initialConditions=h,\n                                        doNewton=False, method=method)\n        return prob.fields(params['Ks'])\n\n    Hs_M10 = getFields(10., 'mixed')\n    Hs_M30 = getFields(30., 'mixed')\n    Hs_M120= getFields(120.,'mixed')\n    Hs_H10 = getFields(10., 'head')\n    Hs_H30 = getFields(30., 'head')\n    Hs_H120= getFields(120.,'head')\n\n    if not plotIt:return\n    plt.figure(figsize=(13,5))\n    plt.subplot(121)\n    plt.plot(40-M.gridCC, Hs_M10[-1],'b-')\n    plt.plot(40-M.gridCC, Hs_M30[-1],'r-')\n    plt.plot(40-M.gridCC, Hs_M120[-1],'k-')\n    plt.ylim([-70,-10])\n    plt.title('Mixed Method')\n    plt.xlabel('Depth, cm')\n    plt.ylabel('Pressure Head, cm')\n    plt.legend(('$\\Delta t$ = 10 sec','$\\Delta t$ = 30 sec','$\\Delta t$ = 120 sec'))\n    plt.subplot(122)\n    plt.plot(40-M.gridCC, Hs_H10[-1],'b-')\n    plt.plot(40-M.gridCC, Hs_H30[-1],'r-')\n    plt.plot(40-M.gridCC, Hs_H120[-1],'k-')\n    plt.ylim([-70,-10])\n    plt.title('Head-Based Method')\n    plt.xlabel('Depth, cm')\n    plt.ylabel('Pressure Head, cm')\n    plt.legend(('$\\Delta t$ = 10 sec','$\\Delta t$ = 30 sec','$\\Delta t$ = 120 sec'))",
  "def getFields(timeStep,method):\n        timeSteps = np.ones(360/timeStep)*timeStep\n        prob = Richards.RichardsProblem(M, mapping=E, timeSteps=timeSteps,\n                                        boundaryConditions=bc, initialConditions=h,\n                                        doNewton=False, method=method)\n        return prob.fields(params['Ks'])",
  "class NonLinearMap(object):\n    \"\"\"\n    SimPEG NonLinearMap\n\n    \"\"\"\n\n    __metaclass__ = Utils.SimPEGMetaClass\n\n    counter = None   #: A SimPEG.Utils.Counter object\n    mesh = None      #: A SimPEG Mesh\n\n    def __init__(self, mesh):\n        self.mesh = mesh\n\n    def _transform(self, u, m):\n        \"\"\"\n            :param numpy.array u: fields\n            :param numpy.array m: model\n            :rtype: numpy.array\n            :return: transformed model\n\n            The *transform* changes the model into the physical property.\n\n        \"\"\"\n        return m\n\n    def derivU(self, u, m):\n        \"\"\"\n            :param numpy.array u: fields\n            :param numpy.array m: model\n            :rtype: scipy.csr_matrix\n            :return: derivative of transformed model\n\n            The *transform* changes the model into the physical property.\n            The *transformDerivU* provides the derivative of the *transform* with respect to the fields.\n        \"\"\"\n        raise NotImplementedError('The transformDerivU is not implemented.')\n\n\n    def derivM(self, u, m):\n        \"\"\"\n            :param numpy.array u: fields\n            :param numpy.array m: model\n            :rtype: scipy.csr_matrix\n            :return: derivative of transformed model\n\n            The *transform* changes the model into the physical property.\n            The *transformDerivU* provides the derivative of the *transform* with respect to the model.\n        \"\"\"\n        raise NotImplementedError('The transformDerivM is not implemented.')\n\n    @property\n    def nP(self):\n        \"\"\"Number of parameters in the model.\"\"\"\n        return self.mesh.nC\n\n    def example(self):\n        raise NotImplementedError('The example is not implemented.')\n\n    def test(self, m=None):\n        raise NotImplementedError('The test is not implemented.')",
  "class RichardsMap(object):\n    \"\"\"docstring for RichardsMap\"\"\"\n\n    mesh       = None  #: SimPEG mesh\n\n    @property\n    def thetaModel(self):\n        \"\"\"Model for moisture content\"\"\"\n        return self._thetaModel\n\n    @property\n    def kModel(self):\n        \"\"\"Model for hydraulic conductivity\"\"\"\n        return self._kModel\n\n    def __init__(self, mesh, thetaModel, kModel):\n        self.mesh = mesh\n        assert isinstance(thetaModel, NonLinearMap)\n        assert isinstance(kModel, NonLinearMap)\n\n        self._thetaModel = thetaModel\n        self._kModel = kModel\n\n    def theta(self, u, m):\n        return self.thetaModel.transform(u, m)\n\n    def thetaDerivM(self, u, m):\n        return self.thetaModel.transformDerivM(u, m)\n\n    def thetaDerivU(self, u, m):\n        return self.thetaModel.transformDerivU(u, m)\n\n    def k(self, u, m):\n        return self.kModel.transform(u, m)\n\n    def kDerivM(self, u, m):\n        return self.kModel.transformDerivM(u, m)\n\n    def kDerivU(self, u, m):\n        return self.kModel.transformDerivU(u, m)\n\n    def plot(self, m):\n        import matplotlib.pyplot as plt\n\n        m = m[0]\n        h = np.linspace(-100, 20, 1000)\n        ax = plt.subplot(121)\n        ax.plot(self.theta(h, m), h)\n        ax = plt.subplot(122)\n        ax.semilogx(self.k(h, m), h)\n\n    def _assertMatchesPair(self, pair):\n        assert isinstance(self, pair), \"Mapping object must be an instance of a %s class.\"%(pair.__name__)",
  "def _ModelProperty(name, models, doc=None, default=None):\n\n    def fget(self):\n        model = models[0]\n        if getattr(self, model, None) is not None:\n            MOD = getattr(self, model)\n            return getattr(MOD, name, default)\n        return default\n\n    def fset(self, value):\n        for model in models:\n            if getattr(self, model, None) is not None:\n                MOD = getattr(self, model)\n                setattr(MOD, name, value)\n\n    return property(fget, fset=fset, doc=doc)",
  "class HaverkampParams(object):\n    \"\"\"Holds some default parameterizations for the Haverkamp model.\"\"\"\n    def __init__(self): pass\n    @property\n    def celia1990(self):\n        \"\"\"\n            Parameters used in:\n\n                Celia, Michael A., Efthimios T. Bouloutas, and Rebecca L. Zarba.\n                \"A general mass-conservative numerical solution for the unsaturated flow equation.\"\n                Water Resources Research 26.7 (1990): 1483-1496.\n\n        \"\"\"\n        return {'alpha':1.611e+06, 'beta':3.96,\n                'theta_r':0.075, 'theta_s':0.287,\n                'Ks':9.44e-03, 'A':1.175e+06,\n                'gamma':4.74}",
  "class _haverkamp_theta(NonLinearMap):\n\n    theta_s = 0.430\n    theta_r = 0.078\n    alpha   = 0.036\n    beta    = 3.960\n\n    def __init__(self, mesh, **kwargs):\n        NonLinearMap.__init__(self, mesh)\n        Utils.setKwargs(self, **kwargs)\n\n    def setModel(self, m):\n        self._currentModel = m\n\n    def transform(self, u, m):\n        self.setModel(m)\n        f = (self.alpha*(self.theta_s  -    self.theta_r  )/\n                        (self.alpha    + abs(u)**self.beta) + self.theta_r)\n        if Utils.isScalar(self.theta_s):\n            f[u >= 0] = self.theta_s\n        else:\n            f[u >= 0] = self.theta_s[u >= 0]\n        return f\n\n    def transformDerivM(self, u, m):\n        self.setModel(m)\n\n    def transformDerivU(self, u, m):\n        self.setModel(m)\n        g = (self.alpha*((self.theta_s - self.theta_r)/\n             (self.alpha + abs(u)**self.beta)**2)\n             *(-self.beta*abs(u)**(self.beta-1)*np.sign(u)))\n        g[u >= 0] = 0\n        g = Utils.sdiag(g)\n        return g",
  "class _haverkamp_k(NonLinearMap):\n\n    A       = 1.175e+06\n    gamma   = 4.74\n    Ks      = np.log(24.96)\n\n    def __init__(self, mesh, **kwargs):\n        NonLinearMap.__init__(self, mesh)\n        Utils.setKwargs(self, **kwargs)\n\n    def setModel(self, m):\n        self._currentModel = m\n        #TODO: Fix me!\n        self.Ks = m\n\n    def transform(self, u, m):\n        self.setModel(m)\n        f = np.exp(self.Ks)*self.A/(self.A+abs(u)**self.gamma)\n        if Utils.isScalar(self.Ks):\n            f[u >= 0] = np.exp(self.Ks)\n        else:\n            f[u >= 0] = np.exp(self.Ks[u >= 0])\n        return f\n\n    def transformDerivM(self, u, m):\n        self.setModel(m)\n        #A\n        # dA = np.exp(self.Ks)/(self.A+abs(u)**self.gamma) - np.exp(self.Ks)*self.A/(self.A+abs(u)**self.gamma)**2\n        #gamma\n        # dgamma = -(self.A*np.exp(self.Ks)*np.log(abs(u))*abs(u)**self.gamma)/(self.A + abs(u)**self.gamma)**2\n\n        # This assumes that the the model is Ks\n        return Utils.sdiag(self.transform(u, m))\n\n    def transformDerivU(self, u, m):\n        self.setModel(m)\n        g = -(np.exp(self.Ks)*self.A*self.gamma*abs(u)**(self.gamma-1)*np.sign(u))/((self.A+abs(u)**self.gamma)**2)\n        g[u >= 0] = 0\n        g = Utils.sdiag(g)\n        return g",
  "class Haverkamp(RichardsMap):\n    \"\"\"Haverkamp Model\"\"\"\n\n    alpha   = _ModelProperty('alpha',   ['thetaModel'], default=1.6110e+06)\n    beta    = _ModelProperty('beta',    ['thetaModel'], default=3.96)\n    theta_r = _ModelProperty('theta_r', ['thetaModel'], default=0.075)\n    theta_s = _ModelProperty('theta_s', ['thetaModel'], default=0.287)\n\n    Ks    = _ModelProperty('Ks',    ['kModel'], default=np.log(24.96))\n    A     = _ModelProperty('A',     ['kModel'], default=1.1750e+06)\n    gamma = _ModelProperty('gamma', ['kModel'], default=4.74)\n\n    def __init__(self, mesh, **kwargs):\n        RichardsMap.__init__(self, mesh,\n                               _haverkamp_theta(mesh),\n                               _haverkamp_k(mesh))\n        Utils.setKwargs(self, **kwargs)",
  "class _vangenuchten_theta(NonLinearMap):\n\n    theta_s = 0.430\n    theta_r = 0.078\n    alpha   = 0.036\n    n       = 1.560\n\n    def __init__(self, mesh, **kwargs):\n        NonLinearMap.__init__(self, mesh)\n        Utils.setKwargs(self, **kwargs)\n\n    def setModel(self, m):\n        self._currentModel = m\n\n    def transform(self, u, m):\n        self.setModel(m)\n        m = 1 - 1.0/self.n\n        f = ((  self.theta_s  -  self.theta_r  )/\n             ((1+abs(self.alpha*u)**self.n)**m)   +  self.theta_r)\n        if Utils.isScalar(self.theta_s):\n            f[u >= 0] = self.theta_s\n        else:\n            f[u >= 0] = self.theta_s[u >= 0]\n\n        return f\n\n    def transformDerivM(self, u, m):\n        self.setModel(m)\n\n    def transformDerivU(self, u, m):\n        g = -self.alpha*self.n*abs(self.alpha*u)**(self.n - 1)*np.sign(self.alpha*u)*(1./self.n - 1)*(self.theta_r - self.theta_s)*(abs(self.alpha*u)**self.n + 1)**(1./self.n - 2)\n        g[u >= 0] = 0\n        g = Utils.sdiag(g)\n        return g",
  "class _vangenuchten_k(NonLinearMap):\n\n    I       = 0.500\n    alpha   = 0.036\n    n       = 1.560\n    Ks      = np.log(24.96)\n\n    def __init__(self, mesh, **kwargs):\n        NonLinearMap.__init__(self, mesh)\n        Utils.setKwargs(self, **kwargs)\n\n    def setModel(self, m):\n        self._currentModel = m\n        #TODO: Fix me!\n        self.Ks = m\n\n    def transform(self, u, m):\n        self.setModel(m)\n\n        alpha = self.alpha\n        I = self.I\n        n = self.n\n        Ks = self.Ks\n        m = 1.0 - 1.0/n\n\n        theta_e = 1.0/((1.0+abs(alpha*u)**n)**m)\n        f = np.exp(Ks)*theta_e**I* ( ( 1.0 - ( 1.0 - theta_e**(1.0/m) )**m )**2 )\n        if Utils.isScalar(self.Ks):\n            f[u >= 0] = np.exp(self.Ks)\n        else:\n            f[u >= 0] = np.exp(self.Ks[u >= 0])\n        return f\n\n    def transformDerivM(self, u, m):\n        self.setModel(m)\n#         #alpha\n#         # dA = I*u*n*np.exp(Ks)*abs(alpha*u)**(n - 1)*np.sign(alpha*u)*(1.0/n - 1)*((abs(alpha*u)**n + 1)**(1.0/n - 1))**(I - 1)*((1 - 1.0/((abs(alpha*u)**n + 1)**(1.0/n - 1))**(1.0/(1.0/n - 1)))**(1 - 1.0/n) - 1)**2*(abs(alpha*u)**n + 1)**(1.0/n - 2) - (2*u*n*np.exp(Ks)*abs(alpha*u)**(n - 1)*np.sign(alpha*u)*(1.0/n - 1)*((abs(alpha*u)**n + 1)**(1.0/n - 1))**I*((1 - 1.0/((abs(alpha*u)**n + 1)**(1.0/n - 1))**(1.0/(1.0/n - 1)))**(1 - 1.0/n) - 1)*(abs(alpha*u)**n + 1)**(1.0/n - 2))/(((abs(alpha*u)**n + 1)**(1.0/n - 1))**(1.0/(1.0/n - 1) + 1)*(1 - 1.0/((abs(alpha*u)**n + 1)**(1.0/n - 1))**(1.0/(1.0/n - 1)))**(1.0/n));\n#         #n\n#         # dn = 2*np.exp(Ks)*((np.log(1 - 1.0/((abs(alpha*u)**n + 1)**(1.0/n - 1))**(1.0/(1.0/n - 1)))*(1 - 1.0/((abs(alpha*u)**n + 1)**(1.0/n - 1))**(1.0/(1.0/n - 1)))**(1 - 1.0/n))/n**2 + ((1.0/n - 1)*(((np.log(abs(alpha*u)**n + 1)*(abs(alpha*u)**n + 1)**(1.0/n - 1))/n**2 - abs(alpha*u)**n*np.log(abs(alpha*u))*(1.0/n - 1)*(abs(alpha*u)**n + 1)**(1.0/n - 2))/((1.0/n - 1)*((abs(alpha*u)**n + 1)**(1.0/n - 1))**(1.0/(1.0/n - 1) + 1)) - np.log((abs(alpha*u)**n + 1)**(1.0/n - 1))/(n**2*(1.0/n - 1)**2*((abs(alpha*u)**n + 1)**(1.0/n - 1))**(1.0/(1.0/n - 1)))))/(1 - 1.0/((abs(alpha*u)**n + 1)**(1.0/n - 1))**(1.0/(1.0/n - 1)))**(1.0/n))*((abs(alpha*u)**n + 1)**(1.0/n - 1))**I*((1 - 1.0/((abs(alpha*u)**n + 1)**(1.0/n - 1))**(1.0/(1.0/n - 1)))**(1 - 1.0/n) - 1) - I*np.exp(Ks)*((np.log(abs(alpha*u)**n + 1)*(abs(alpha*u)**n + 1)**(1.0/n - 1))/n**2 - abs(alpha*u)**n*np.log(abs(alpha*u))*(1.0/n - 1)*(abs(alpha*u)**n + 1)**(1.0/n - 2))*((abs(alpha*u)**n + 1)**(1.0/n - 1))**(I - 1)*((1 - 1.0/((abs(alpha*u)**n + 1)**(1.0/n - 1))**(1.0/(1.0/n - 1)))**(1 - 1.0/n) - 1)**2;\n#         #I\n#         # dI = np.exp(Ks)*np.log((abs(alpha*u)**n + 1)**(1.0/n - 1))*((abs(alpha*u)**n + 1)**(1.0/n - 1))**I*((1 - 1.0/((abs(alpha*u)**n + 1)**(1.0/n - 1))**(1.0/(1.0/n - 1)))**(1 - 1.0/n) - 1)**2;\n        return Utils.sdiag(self.transform(u, m)) # This assumes that the the model is Ks\n\n    def transformDerivU(self, u, m):\n        self.setModel(m)\n        alpha = self.alpha\n        I = self.I\n        n = self.n\n        Ks = self.Ks\n        m = 1.0 - 1.0/n\n\n        g = I*alpha*n*np.exp(Ks)*abs(alpha*u)**(n - 1.0)*np.sign(alpha*u)*(1.0/n - 1.0)*((abs(alpha*u)**n + 1)**(1.0/n - 1))**(I - 1)*((1 - 1.0/((abs(alpha*u)**n + 1)**(1.0/n - 1))**(1.0/(1.0/n - 1)))**(1 - 1.0/n) - 1)**2*(abs(alpha*u)**n + 1)**(1.0/n - 2) - (2*alpha*n*np.exp(Ks)*abs(alpha*u)**(n - 1)*np.sign(alpha*u)*(1.0/n - 1)*((abs(alpha*u)**n + 1)**(1.0/n - 1))**I*((1 - 1.0/((abs(alpha*u)**n + 1)**(1.0/n - 1))**(1.0/(1.0/n - 1)))**(1 - 1.0/n) - 1)*(abs(alpha*u)**n + 1)**(1.0/n - 2))/(((abs(alpha*u)**n + 1)**(1.0/n - 1))**(1.0/(1.0/n - 1) + 1)*(1 - 1.0/((abs(alpha*u)**n + 1)**(1.0/n - 1))**(1.0/(1.0/n - 1)))**(1.0/n))\n        g[u >= 0] = 0\n        g = Utils.sdiag(g)\n        return g",
  "class VanGenuchten(RichardsMap):\n    \"\"\"vanGenuchten Model\"\"\"\n\n    theta_r = _ModelProperty('theta_r', ['thetaModel'], default=0.075)\n    theta_s = _ModelProperty('theta_s', ['thetaModel'], default=0.287)\n\n    alpha   = _ModelProperty('alpha',   ['thetaModel', 'kModel'], default=0.036)\n    n       = _ModelProperty('n',       ['thetaModel', 'kModel'], default=1.560)\n\n    Ks    = _ModelProperty('Ks',    ['kModel'], default=np.log(24.96))\n    I     = _ModelProperty('I',     ['kModel'], default=0.500)\n\n    def __init__(self, mesh, **kwargs):\n        RichardsMap.__init__(self, mesh,\n                               _vangenuchten_theta(mesh),\n                               _vangenuchten_k(mesh))\n        Utils.setKwargs(self, **kwargs)",
  "class VanGenuchtenParams(object):\n    \"\"\"\n        The RETC code for quantifying the hydraulic functions of unsaturated soils,\n        Van Genuchten, M Th, Leij, F J, Yates, S R\n\n        Table 3: Average values for selected soil water retention and hydraulic\n        conductivity parameters for 11 major soil textural groups\n        according to Rawls et al. [1982]\n\n    \"\"\"\n    def __init__(self): pass\n    @property\n    def sand(self):\n        return {\"theta_r\": 0.020, \"theta_s\": 0.417, \"alpha\": 0.138*100., \"n\": 1.592, \"Ks\": 504.0/100./24./60./60.}\n    @property\n    def loamySand(self):\n        return {\"theta_r\": 0.035, \"theta_s\": 0.401, \"alpha\": 0.115*100., \"n\": 1.474, \"Ks\": 146.6/100./24./60./60.}\n    @property\n    def sandyLoam(self):\n        return {\"theta_r\": 0.041, \"theta_s\": 0.412, \"alpha\": 0.068*100., \"n\": 1.322, \"Ks\": 62.16/100./24./60./60.}\n    @property\n    def loam(self):\n        return {\"theta_r\": 0.027, \"theta_s\": 0.434, \"alpha\": 0.090*100., \"n\": 1.220, \"Ks\": 16.32/100./24./60./60.}\n    @property\n    def siltLoam(self):\n        return {\"theta_r\": 0.015, \"theta_s\": 0.486, \"alpha\": 0.048*100., \"n\": 1.211, \"Ks\": 31.68/100./24./60./60.}\n    @property\n    def sandyClayLoam(self):\n        return {\"theta_r\": 0.068, \"theta_s\": 0.330, \"alpha\": 0.036*100., \"n\": 1.250, \"Ks\": 10.32/100./24./60./60.}\n    @property\n    def clayLoam(self):\n        return {\"theta_r\": 0.075, \"theta_s\": 0.390, \"alpha\": 0.039*100., \"n\": 1.194, \"Ks\": 5.52/100./24./60./60.}\n    @property\n    def siltyClayLoam(self):\n        return {\"theta_r\": 0.040, \"theta_s\": 0.432, \"alpha\": 0.031*100., \"n\": 1.151, \"Ks\": 3.60/100./24./60./60.}\n    @property\n    def sandyClay(self):\n        return {\"theta_r\": 0.109, \"theta_s\": 0.321, \"alpha\": 0.034*100., \"n\": 1.168, \"Ks\": 2.88/100./24./60./60.}\n    @property\n    def siltyClay(self):\n        return {\"theta_r\": 0.056, \"theta_s\": 0.423, \"alpha\": 0.029*100., \"n\": 1.127, \"Ks\": 2.16/100./24./60./60.}\n    @property\n    def clay(self):\n        return {\"theta_r\": 0.090, \"theta_s\": 0.385, \"alpha\": 0.027*100., \"n\": 1.131, \"Ks\": 1.44/100./24./60./60.}",
  "def __init__(self, mesh):\n        self.mesh = mesh",
  "def _transform(self, u, m):\n        \"\"\"\n            :param numpy.array u: fields\n            :param numpy.array m: model\n            :rtype: numpy.array\n            :return: transformed model\n\n            The *transform* changes the model into the physical property.\n\n        \"\"\"\n        return m",
  "def derivU(self, u, m):\n        \"\"\"\n            :param numpy.array u: fields\n            :param numpy.array m: model\n            :rtype: scipy.csr_matrix\n            :return: derivative of transformed model\n\n            The *transform* changes the model into the physical property.\n            The *transformDerivU* provides the derivative of the *transform* with respect to the fields.\n        \"\"\"\n        raise NotImplementedError('The transformDerivU is not implemented.')",
  "def derivM(self, u, m):\n        \"\"\"\n            :param numpy.array u: fields\n            :param numpy.array m: model\n            :rtype: scipy.csr_matrix\n            :return: derivative of transformed model\n\n            The *transform* changes the model into the physical property.\n            The *transformDerivU* provides the derivative of the *transform* with respect to the model.\n        \"\"\"\n        raise NotImplementedError('The transformDerivM is not implemented.')",
  "def nP(self):\n        \"\"\"Number of parameters in the model.\"\"\"\n        return self.mesh.nC",
  "def example(self):\n        raise NotImplementedError('The example is not implemented.')",
  "def test(self, m=None):\n        raise NotImplementedError('The test is not implemented.')",
  "def thetaModel(self):\n        \"\"\"Model for moisture content\"\"\"\n        return self._thetaModel",
  "def kModel(self):\n        \"\"\"Model for hydraulic conductivity\"\"\"\n        return self._kModel",
  "def __init__(self, mesh, thetaModel, kModel):\n        self.mesh = mesh\n        assert isinstance(thetaModel, NonLinearMap)\n        assert isinstance(kModel, NonLinearMap)\n\n        self._thetaModel = thetaModel\n        self._kModel = kModel",
  "def theta(self, u, m):\n        return self.thetaModel.transform(u, m)",
  "def thetaDerivM(self, u, m):\n        return self.thetaModel.transformDerivM(u, m)",
  "def thetaDerivU(self, u, m):\n        return self.thetaModel.transformDerivU(u, m)",
  "def k(self, u, m):\n        return self.kModel.transform(u, m)",
  "def kDerivM(self, u, m):\n        return self.kModel.transformDerivM(u, m)",
  "def kDerivU(self, u, m):\n        return self.kModel.transformDerivU(u, m)",
  "def plot(self, m):\n        import matplotlib.pyplot as plt\n\n        m = m[0]\n        h = np.linspace(-100, 20, 1000)\n        ax = plt.subplot(121)\n        ax.plot(self.theta(h, m), h)\n        ax = plt.subplot(122)\n        ax.semilogx(self.k(h, m), h)",
  "def _assertMatchesPair(self, pair):\n        assert isinstance(self, pair), \"Mapping object must be an instance of a %s class.\"%(pair.__name__)",
  "def fget(self):\n        model = models[0]\n        if getattr(self, model, None) is not None:\n            MOD = getattr(self, model)\n            return getattr(MOD, name, default)\n        return default",
  "def fset(self, value):\n        for model in models:\n            if getattr(self, model, None) is not None:\n                MOD = getattr(self, model)\n                setattr(MOD, name, value)",
  "def __init__(self): pass",
  "def celia1990(self):\n        \"\"\"\n            Parameters used in:\n\n                Celia, Michael A., Efthimios T. Bouloutas, and Rebecca L. Zarba.\n                \"A general mass-conservative numerical solution for the unsaturated flow equation.\"\n                Water Resources Research 26.7 (1990): 1483-1496.\n\n        \"\"\"\n        return {'alpha':1.611e+06, 'beta':3.96,\n                'theta_r':0.075, 'theta_s':0.287,\n                'Ks':9.44e-03, 'A':1.175e+06,\n                'gamma':4.74}",
  "def __init__(self, mesh, **kwargs):\n        NonLinearMap.__init__(self, mesh)\n        Utils.setKwargs(self, **kwargs)",
  "def setModel(self, m):\n        self._currentModel = m",
  "def transform(self, u, m):\n        self.setModel(m)\n        f = (self.alpha*(self.theta_s  -    self.theta_r  )/\n                        (self.alpha    + abs(u)**self.beta) + self.theta_r)\n        if Utils.isScalar(self.theta_s):\n            f[u >= 0] = self.theta_s\n        else:\n            f[u >= 0] = self.theta_s[u >= 0]\n        return f",
  "def transformDerivM(self, u, m):\n        self.setModel(m)",
  "def transformDerivU(self, u, m):\n        self.setModel(m)\n        g = (self.alpha*((self.theta_s - self.theta_r)/\n             (self.alpha + abs(u)**self.beta)**2)\n             *(-self.beta*abs(u)**(self.beta-1)*np.sign(u)))\n        g[u >= 0] = 0\n        g = Utils.sdiag(g)\n        return g",
  "def __init__(self, mesh, **kwargs):\n        NonLinearMap.__init__(self, mesh)\n        Utils.setKwargs(self, **kwargs)",
  "def setModel(self, m):\n        self._currentModel = m\n        #TODO: Fix me!\n        self.Ks = m",
  "def transform(self, u, m):\n        self.setModel(m)\n        f = np.exp(self.Ks)*self.A/(self.A+abs(u)**self.gamma)\n        if Utils.isScalar(self.Ks):\n            f[u >= 0] = np.exp(self.Ks)\n        else:\n            f[u >= 0] = np.exp(self.Ks[u >= 0])\n        return f",
  "def transformDerivM(self, u, m):\n        self.setModel(m)\n        #A\n        # dA = np.exp(self.Ks)/(self.A+abs(u)**self.gamma) - np.exp(self.Ks)*self.A/(self.A+abs(u)**self.gamma)**2\n        #gamma\n        # dgamma = -(self.A*np.exp(self.Ks)*np.log(abs(u))*abs(u)**self.gamma)/(self.A + abs(u)**self.gamma)**2\n\n        # This assumes that the the model is Ks\n        return Utils.sdiag(self.transform(u, m))",
  "def transformDerivU(self, u, m):\n        self.setModel(m)\n        g = -(np.exp(self.Ks)*self.A*self.gamma*abs(u)**(self.gamma-1)*np.sign(u))/((self.A+abs(u)**self.gamma)**2)\n        g[u >= 0] = 0\n        g = Utils.sdiag(g)\n        return g",
  "def __init__(self, mesh, **kwargs):\n        RichardsMap.__init__(self, mesh,\n                               _haverkamp_theta(mesh),\n                               _haverkamp_k(mesh))\n        Utils.setKwargs(self, **kwargs)",
  "def __init__(self, mesh, **kwargs):\n        NonLinearMap.__init__(self, mesh)\n        Utils.setKwargs(self, **kwargs)",
  "def setModel(self, m):\n        self._currentModel = m",
  "def transform(self, u, m):\n        self.setModel(m)\n        m = 1 - 1.0/self.n\n        f = ((  self.theta_s  -  self.theta_r  )/\n             ((1+abs(self.alpha*u)**self.n)**m)   +  self.theta_r)\n        if Utils.isScalar(self.theta_s):\n            f[u >= 0] = self.theta_s\n        else:\n            f[u >= 0] = self.theta_s[u >= 0]\n\n        return f",
  "def transformDerivM(self, u, m):\n        self.setModel(m)",
  "def transformDerivU(self, u, m):\n        g = -self.alpha*self.n*abs(self.alpha*u)**(self.n - 1)*np.sign(self.alpha*u)*(1./self.n - 1)*(self.theta_r - self.theta_s)*(abs(self.alpha*u)**self.n + 1)**(1./self.n - 2)\n        g[u >= 0] = 0\n        g = Utils.sdiag(g)\n        return g",
  "def __init__(self, mesh, **kwargs):\n        NonLinearMap.__init__(self, mesh)\n        Utils.setKwargs(self, **kwargs)",
  "def setModel(self, m):\n        self._currentModel = m\n        #TODO: Fix me!\n        self.Ks = m",
  "def transform(self, u, m):\n        self.setModel(m)\n\n        alpha = self.alpha\n        I = self.I\n        n = self.n\n        Ks = self.Ks\n        m = 1.0 - 1.0/n\n\n        theta_e = 1.0/((1.0+abs(alpha*u)**n)**m)\n        f = np.exp(Ks)*theta_e**I* ( ( 1.0 - ( 1.0 - theta_e**(1.0/m) )**m )**2 )\n        if Utils.isScalar(self.Ks):\n            f[u >= 0] = np.exp(self.Ks)\n        else:\n            f[u >= 0] = np.exp(self.Ks[u >= 0])\n        return f",
  "def transformDerivM(self, u, m):\n        self.setModel(m)\n#         #alpha\n#         # dA = I*u*n*np.exp(Ks)*abs(alpha*u)**(n - 1)*np.sign(alpha*u)*(1.0/n - 1)*((abs(alpha*u)**n + 1)**(1.0/n - 1))**(I - 1)*((1 - 1.0/((abs(alpha*u)**n + 1)**(1.0/n - 1))**(1.0/(1.0/n - 1)))**(1 - 1.0/n) - 1)**2*(abs(alpha*u)**n + 1)**(1.0/n - 2) - (2*u*n*np.exp(Ks)*abs(alpha*u)**(n - 1)*np.sign(alpha*u)*(1.0/n - 1)*((abs(alpha*u)**n + 1)**(1.0/n - 1))**I*((1 - 1.0/((abs(alpha*u)**n + 1)**(1.0/n - 1))**(1.0/(1.0/n - 1)))**(1 - 1.0/n) - 1)*(abs(alpha*u)**n + 1)**(1.0/n - 2))/(((abs(alpha*u)**n + 1)**(1.0/n - 1))**(1.0/(1.0/n - 1) + 1)*(1 - 1.0/((abs(alpha*u)**n + 1)**(1.0/n - 1))**(1.0/(1.0/n - 1)))**(1.0/n));\n#         #n\n#         # dn = 2*np.exp(Ks)*((np.log(1 - 1.0/((abs(alpha*u)**n + 1)**(1.0/n - 1))**(1.0/(1.0/n - 1)))*(1 - 1.0/((abs(alpha*u)**n + 1)**(1.0/n - 1))**(1.0/(1.0/n - 1)))**(1 - 1.0/n))/n**2 + ((1.0/n - 1)*(((np.log(abs(alpha*u)**n + 1)*(abs(alpha*u)**n + 1)**(1.0/n - 1))/n**2 - abs(alpha*u)**n*np.log(abs(alpha*u))*(1.0/n - 1)*(abs(alpha*u)**n + 1)**(1.0/n - 2))/((1.0/n - 1)*((abs(alpha*u)**n + 1)**(1.0/n - 1))**(1.0/(1.0/n - 1) + 1)) - np.log((abs(alpha*u)**n + 1)**(1.0/n - 1))/(n**2*(1.0/n - 1)**2*((abs(alpha*u)**n + 1)**(1.0/n - 1))**(1.0/(1.0/n - 1)))))/(1 - 1.0/((abs(alpha*u)**n + 1)**(1.0/n - 1))**(1.0/(1.0/n - 1)))**(1.0/n))*((abs(alpha*u)**n + 1)**(1.0/n - 1))**I*((1 - 1.0/((abs(alpha*u)**n + 1)**(1.0/n - 1))**(1.0/(1.0/n - 1)))**(1 - 1.0/n) - 1) - I*np.exp(Ks)*((np.log(abs(alpha*u)**n + 1)*(abs(alpha*u)**n + 1)**(1.0/n - 1))/n**2 - abs(alpha*u)**n*np.log(abs(alpha*u))*(1.0/n - 1)*(abs(alpha*u)**n + 1)**(1.0/n - 2))*((abs(alpha*u)**n + 1)**(1.0/n - 1))**(I - 1)*((1 - 1.0/((abs(alpha*u)**n + 1)**(1.0/n - 1))**(1.0/(1.0/n - 1)))**(1 - 1.0/n) - 1)**2;\n#         #I\n#         # dI = np.exp(Ks)*np.log((abs(alpha*u)**n + 1)**(1.0/n - 1))*((abs(alpha*u)**n + 1)**(1.0/n - 1))**I*((1 - 1.0/((abs(alpha*u)**n + 1)**(1.0/n - 1))**(1.0/(1.0/n - 1)))**(1 - 1.0/n) - 1)**2;\n        return Utils.sdiag(self.transform(u, m))",
  "def transformDerivU(self, u, m):\n        self.setModel(m)\n        alpha = self.alpha\n        I = self.I\n        n = self.n\n        Ks = self.Ks\n        m = 1.0 - 1.0/n\n\n        g = I*alpha*n*np.exp(Ks)*abs(alpha*u)**(n - 1.0)*np.sign(alpha*u)*(1.0/n - 1.0)*((abs(alpha*u)**n + 1)**(1.0/n - 1))**(I - 1)*((1 - 1.0/((abs(alpha*u)**n + 1)**(1.0/n - 1))**(1.0/(1.0/n - 1)))**(1 - 1.0/n) - 1)**2*(abs(alpha*u)**n + 1)**(1.0/n - 2) - (2*alpha*n*np.exp(Ks)*abs(alpha*u)**(n - 1)*np.sign(alpha*u)*(1.0/n - 1)*((abs(alpha*u)**n + 1)**(1.0/n - 1))**I*((1 - 1.0/((abs(alpha*u)**n + 1)**(1.0/n - 1))**(1.0/(1.0/n - 1)))**(1 - 1.0/n) - 1)*(abs(alpha*u)**n + 1)**(1.0/n - 2))/(((abs(alpha*u)**n + 1)**(1.0/n - 1))**(1.0/(1.0/n - 1) + 1)*(1 - 1.0/((abs(alpha*u)**n + 1)**(1.0/n - 1))**(1.0/(1.0/n - 1)))**(1.0/n))\n        g[u >= 0] = 0\n        g = Utils.sdiag(g)\n        return g",
  "def __init__(self, mesh, **kwargs):\n        RichardsMap.__init__(self, mesh,\n                               _vangenuchten_theta(mesh),\n                               _vangenuchten_k(mesh))\n        Utils.setKwargs(self, **kwargs)",
  "def __init__(self): pass",
  "def sand(self):\n        return {\"theta_r\": 0.020, \"theta_s\": 0.417, \"alpha\": 0.138*100., \"n\": 1.592, \"Ks\": 504.0/100./24./60./60.}",
  "def loamySand(self):\n        return {\"theta_r\": 0.035, \"theta_s\": 0.401, \"alpha\": 0.115*100., \"n\": 1.474, \"Ks\": 146.6/100./24./60./60.}",
  "def sandyLoam(self):\n        return {\"theta_r\": 0.041, \"theta_s\": 0.412, \"alpha\": 0.068*100., \"n\": 1.322, \"Ks\": 62.16/100./24./60./60.}",
  "def loam(self):\n        return {\"theta_r\": 0.027, \"theta_s\": 0.434, \"alpha\": 0.090*100., \"n\": 1.220, \"Ks\": 16.32/100./24./60./60.}",
  "def siltLoam(self):\n        return {\"theta_r\": 0.015, \"theta_s\": 0.486, \"alpha\": 0.048*100., \"n\": 1.211, \"Ks\": 31.68/100./24./60./60.}",
  "def sandyClayLoam(self):\n        return {\"theta_r\": 0.068, \"theta_s\": 0.330, \"alpha\": 0.036*100., \"n\": 1.250, \"Ks\": 10.32/100./24./60./60.}",
  "def clayLoam(self):\n        return {\"theta_r\": 0.075, \"theta_s\": 0.390, \"alpha\": 0.039*100., \"n\": 1.194, \"Ks\": 5.52/100./24./60./60.}",
  "def siltyClayLoam(self):\n        return {\"theta_r\": 0.040, \"theta_s\": 0.432, \"alpha\": 0.031*100., \"n\": 1.151, \"Ks\": 3.60/100./24./60./60.}",
  "def sandyClay(self):\n        return {\"theta_r\": 0.109, \"theta_s\": 0.321, \"alpha\": 0.034*100., \"n\": 1.168, \"Ks\": 2.88/100./24./60./60.}",
  "def siltyClay(self):\n        return {\"theta_r\": 0.056, \"theta_s\": 0.423, \"alpha\": 0.029*100., \"n\": 1.127, \"Ks\": 2.16/100./24./60./60.}",
  "def clay(self):\n        return {\"theta_r\": 0.090, \"theta_s\": 0.385, \"alpha\": 0.027*100., \"n\": 1.131, \"Ks\": 1.44/100./24./60./60.}",
  "class InnerProducts(object):\n    \"\"\"\n        This is a base for the SimPEG.Mesh classes. This mixIn creates the all the inner product matrices that you need!\n    \"\"\"\n    def __init__(self):\n        raise Exception('InnerProducts is a base class providing inner product matrices for meshes and cannot run on its own. Inherit to your favorite Mesh class.')\n\n    def getFaceInnerProduct(self, prop=None, invProp=False, invMat=False, doFast=True):\n        \"\"\"\n            :param numpy.array prop: material property (tensor properties are possible) at each cell center (nC, (1, 3, or 6))\n            :param bool invProp: inverts the material property\n            :param bool invMat: inverts the matrix\n            :param bool doFast: do a faster implementation if available.\n            :rtype: scipy.csr_matrix\n            :return: M, the inner product matrix (nF, nF)\n        \"\"\"\n        return self._getInnerProduct('F', prop=prop, invProp=invProp, invMat=invMat, doFast=doFast)\n\n    def getEdgeInnerProduct(self, prop=None, invProp=False, invMat=False, doFast=True):\n        \"\"\"\n            :param numpy.array prop: material property (tensor properties are possible) at each cell center (nC, (1, 3, or 6))\n            :param bool invProp: inverts the material property\n            :param bool invMat: inverts the matrix\n            :param bool doFast: do a faster implementation if available.\n            :rtype: scipy.csr_matrix\n            :return: M, the inner product matrix (nE, nE)\n        \"\"\"\n        return self._getInnerProduct('E', prop=prop, invProp=invProp, invMat=invMat, doFast=doFast)\n\n    def _getInnerProduct(self, projType, prop=None, invProp=False, invMat=False, doFast=True):\n        \"\"\"\n            :param str projType: 'F' for faces 'E' for edges\n            :param numpy.array prop: material property (tensor properties are possible) at each cell center (nC, (1, 3, or 6))\n            :param bool invProp: inverts the material property\n            :param bool invMat: inverts the matrix\n            :param bool doFast: do a faster implementation if available.\n            :rtype: scipy.csr_matrix\n            :return: M, the inner product matrix (nE, nE)\n        \"\"\"\n        assert projType in ['F', 'E'], \"projType must be 'F' for faces or 'E' for edges\"\n\n        fast = None\n        if hasattr(self, '_fastInnerProduct') and doFast:\n            fast = self._fastInnerProduct(projType, prop=prop, invProp=invProp, invMat=invMat)\n        if fast is not None:\n            return fast\n\n        if invProp:\n            prop = invPropertyTensor(self, prop)\n\n        tensorType = TensorType(self, prop)\n\n        Mu = makePropertyTensor(self, prop)\n        Ps = self._getInnerProductProjectionMatrices(projType, tensorType)\n        A = np.sum([P.T * Mu * P for P in Ps])\n\n        if invMat and tensorType < 3:\n            A = sdInv(A)\n        elif invMat and tensorType == 3:\n            raise Exception('Solver needed to invert A.')\n\n        return A\n\n    def _getInnerProductProjectionMatrices(self, projType, tensorType):\n        \"\"\"\n            :param str projType: 'F' for faces 'E' for edges\n            :param TensorType tensorType: type of the tensor: TensorType(mesh, sigma)\n        \"\"\"\n        assert isinstance(tensorType, TensorType), 'tensorType must be an instance of TensorType.'\n        assert projType in ['F', 'E'], \"projType must be 'F' for faces or 'E' for edges\"\n\n        d = self.dim\n        # We will multiply by sqrt on each side to keep symmetry\n        V = sp.kron(sp.identity(d), sdiag(np.sqrt((2**(-d))*self.vol)))\n\n        nodes = ['000', '100', '010', '110', '001', '101', '011',  '111'][:2**d]\n\n        if projType == 'F':\n            locs = {\n                    '000': [('fXm',), ('fXm', 'fYm'), ('fXm', 'fYm', 'fZm')],\n                    '100': [('fXp',), ('fXp', 'fYm'), ('fXp', 'fYm', 'fZm')],\n                    '010': [  None  , ('fXm', 'fYp'), ('fXm', 'fYp', 'fZm')],\n                    '110': [  None  , ('fXp', 'fYp'), ('fXp', 'fYp', 'fZm')],\n                    '001': [  None  ,      None     , ('fXm', 'fYm', 'fZp')],\n                    '101': [  None  ,      None     , ('fXp', 'fYm', 'fZp')],\n                    '011': [  None  ,      None     , ('fXm', 'fYp', 'fZp')],\n                    '111': [  None  ,      None     , ('fXp', 'fYp', 'fZp')]\n                   }\n            proj = getattr(self, '_getFaceP' + ('x'*d))()\n\n        elif projType == 'E':\n            locs = {\n                    '000': [('eX0',), ('eX0', 'eY0'), ('eX0', 'eY0', 'eZ0')],\n                    '100': [('eX0',), ('eX0', 'eY1'), ('eX0', 'eY1', 'eZ1')],\n                    '010': [  None  , ('eX1', 'eY0'), ('eX1', 'eY0', 'eZ2')],\n                    '110': [  None  , ('eX1', 'eY1'), ('eX1', 'eY1', 'eZ3')],\n                    '001': [  None  ,      None     , ('eX2', 'eY2', 'eZ0')],\n                    '101': [  None  ,      None     , ('eX2', 'eY3', 'eZ1')],\n                    '011': [  None  ,      None     , ('eX3', 'eY2', 'eZ2')],\n                    '111': [  None  ,      None     , ('eX3', 'eY3', 'eZ3')]\n                   }\n            proj = getattr(self, '_getEdgeP' + ('x'*d))()\n\n        return [V*proj(*locs[node][d-1]) for node in nodes]\n\n\n    def getFaceInnerProductDeriv(self, prop, doFast=True, invProp=False, invMat=False):\n        \"\"\"\n            :param numpy.array prop: material property (tensor properties are possible) at each cell center (nC, (1, 3, or 6))\n            :param bool doFast: do a faster implementation if available.\n            :param bool invProp: inverts the material property\n            :param bool invMat: inverts the matrix\n            :rtype: function\n            :return: dMdmu(u), the derivative of the inner product matrix (u)\n\n            Given u, dMdmu returns (nF, nC*nA)\n\n            :param np.ndarray u: vector that multiplies dMdmu\n            :rtype: scipy.csr_matrix\n            :return: dMdmu, the derivative of the inner product matrix for a certain u\n        \"\"\"\n        return self._getInnerProductDeriv(prop, 'F', doFast=doFast, invProp=invProp, invMat=invMat)\n\n\n    def getEdgeInnerProductDeriv(self, prop, doFast=True, invProp=False, invMat=False):\n        \"\"\"\n            :param numpy.array prop: material property (tensor properties are possible) at each cell center (nC, (1, 3, or 6))\n            :param bool doFast: do a faster implementation if available.\n            :param bool invProp: inverts the material property\n            :param bool invMat: inverts the matrix\n            :rtype: scipy.csr_matrix\n            :return: dMdm, the derivative of the inner product matrix (nE, nC*nA)\n        \"\"\"\n        return self._getInnerProductDeriv(prop, 'E', doFast=doFast, invProp=invProp, invMat=invMat)\n\n    def _getInnerProductDeriv(self, prop, projType, doFast=True, invProp=False, invMat=False):\n        \"\"\"\n            :param numpy.array prop: material property (tensor properties are possible) at each cell center (nC, (1, 3, or 6))\n            :param str projType: 'F' for faces 'E' for edges\n            :param bool doFast: do a faster implementation if available.\n            :param bool invProp: inverts the material property\n            :param bool invMat: inverts the matrix\n            :rtype: scipy.csr_matrix\n            :return: dMdm, the derivative of the inner product matrix (nE, nC*nA)\n        \"\"\"\n        fast = None\n        if hasattr(self, '_fastInnerProductDeriv') and doFast:\n            fast = self._fastInnerProductDeriv(projType, prop, invProp=invProp, invMat=invMat)\n        if fast is not None:\n            return fast\n\n        if invProp or invMat:\n            raise NotImplementedError('inverting the property or the matrix is not yet implemented for this mesh/tensorType. You should write it!')\n\n        tensorType = TensorType(self, prop)\n        P = self._getInnerProductProjectionMatrices(projType, tensorType=tensorType)\n        def innerProductDeriv(v):\n            return self._getInnerProductDerivFunction(tensorType, P, projType, v)\n        return innerProductDeriv\n\n    def _getInnerProductDerivFunction(self, tensorType, P, projType, v):\n        \"\"\"\n            :param numpy.array prop: material property (tensor properties are possible) at each cell center (nC, (1, 3, or 6))\n            :param numpy.array v: vector to multiply (required in the general implementation)\n            :param list P: list of projection matrices\n            :param str projType: 'F' for faces 'E' for edges\n            :rtype: scipy.csr_matrix\n            :return: dMdm, the derivative of the inner product matrix (n, nC*nA)\n        \"\"\"\n        assert projType in ['F', 'E'], \"projType must be 'F' for faces or 'E' for edges\"\n        n = getattr(self,'n'+projType)\n\n        if tensorType == -1:\n            return None\n\n        if v is None:\n            raise Exception('v must be supplied for this implementation.')\n\n        d = self.dim\n        Z = spzeros(self.nC, self.nC)\n\n        if tensorType == 0:\n            dMdm = spzeros(n, 1)\n            for i, p in enumerate(P):\n                dMdm = dMdm + sp.csr_matrix((p.T * (p * v), (range(n), np.zeros(n))), shape=(n,1))\n        if d == 1:\n            if tensorType == 1:\n                dMdm = spzeros(n, self.nC)\n                for i, p in enumerate(P):\n                    dMdm = dMdm + p.T * sdiag( p * v )\n        elif d == 2:\n            if tensorType == 1:\n                dMdm = spzeros(n, self.nC)\n                for i, p in enumerate(P):\n                    Y = p * v\n                    y1 = Y[:self.nC]\n                    y2 = Y[self.nC:]\n                    dMdm = dMdm + p.T * sp.vstack((sdiag( y1 ), sdiag( y2 )))\n            elif tensorType == 2:\n                dMdms = [spzeros(n, self.nC) for _ in range(2)]\n                for i, p in enumerate(P):\n                    Y = p * v\n                    y1 = Y[:self.nC]\n                    y2 = Y[self.nC:]\n                    dMdms[0] = dMdms[0] + p.T * sp.vstack(( sdiag( y1 ), Z))\n                    dMdms[1] = dMdms[1] + p.T * sp.vstack(( Z, sdiag( y2 )))\n                dMdm = sp.hstack(dMdms)\n            elif tensorType == 3:\n                dMdms = [spzeros(n, self.nC) for _ in range(3)]\n                for i, p in enumerate(P):\n                    Y = p * v\n                    y1 = Y[:self.nC]\n                    y2 = Y[self.nC:]\n                    dMdms[0] = dMdms[0] + p.T * sp.vstack(( sdiag( y1 ), Z))\n                    dMdms[1] = dMdms[1] + p.T * sp.vstack(( Z, sdiag( y2 )))\n                    dMdms[2] = dMdms[2] + p.T * sp.vstack(( sdiag( y2 ), sdiag( y1 )))\n                dMdm = sp.hstack(dMdms)\n        elif d == 3:\n            if tensorType == 1:\n                dMdm = spzeros(n, self.nC)\n                for i, p in enumerate(P):\n                    Y = p * v\n                    y1 = Y[:self.nC]\n                    y2 = Y[self.nC:self.nC*2]\n                    y3 = Y[self.nC*2:]\n                    dMdm = dMdm + p.T * sp.vstack((sdiag( y1 ), sdiag( y2 ), sdiag( y3 )))\n            elif tensorType == 2:\n                dMdms = [spzeros(n, self.nC) for _ in range(3)]\n                for i, p in enumerate(P):\n                    Y = p * v\n                    y1 = Y[:self.nC]\n                    y2 = Y[self.nC:self.nC*2]\n                    y3 = Y[self.nC*2:]\n                    dMdms[0] = dMdms[0] + p.T * sp.vstack(( sdiag( y1 ), Z, Z))\n                    dMdms[1] = dMdms[1] + p.T * sp.vstack(( Z, sdiag( y2 ), Z))\n                    dMdms[2] = dMdms[2] + p.T * sp.vstack(( Z, Z, sdiag( y3 )))\n                dMdm = sp.hstack(dMdms)\n            elif tensorType == 3:\n                dMdms = [spzeros(n, self.nC) for _ in range(6)]\n                for i, p in enumerate(P):\n                    Y = p * v\n                    y1 = Y[:self.nC]\n                    y2 = Y[self.nC:self.nC*2]\n                    y3 = Y[self.nC*2:]\n                    dMdms[0] = dMdms[0] + p.T * sp.vstack(( sdiag( y1 ), Z, Z))\n                    dMdms[1] = dMdms[1] + p.T * sp.vstack(( Z, sdiag( y2 ), Z))\n                    dMdms[2] = dMdms[2] + p.T * sp.vstack(( Z, Z, sdiag( y3 )))\n                    dMdms[3] = dMdms[3] + p.T * sp.vstack(( sdiag( y2 ), sdiag( y1 ), Z))\n                    dMdms[4] = dMdms[4] + p.T * sp.vstack(( sdiag( y3 ), Z, sdiag( y1 )))\n                    dMdms[5] = dMdms[5] + p.T * sp.vstack(( Z, sdiag( y3 ), sdiag( y2 )))\n                dMdm = sp.hstack(dMdms)\n\n        return dMdm\n\n    # ------------------------ Geometries ------------------------------\n    #\n    #\n    #         node(i,j,k+1) ------ edge2(i,j,k+1) ----- node(i,j+1,k+1)\n    #              /                                    /\n    #             /                                    / |\n    #         edge3(i,j,k)     face1(i,j,k)        edge3(i,j+1,k)\n    #           /                                    /   |\n    #          /                                    /    |\n    #    node(i,j,k) ------ edge2(i,j,k) ----- node(i,j+1,k)\n    #         |                                     |    |\n    #         |                                     |   node(i+1,j+1,k+1)\n    #         |                                     |    /\n    #    edge1(i,j,k)      face3(i,j,k)        edge1(i,j+1,k)\n    #         |                                     |  /\n    #         |                                     | /\n    #         |                                     |/\n    #    node(i+1,j,k) ------ edge2(i+1,j,k) ----- node(i+1,j+1,k)\n\n\n    def _getFacePx(M):\n        \"\"\"Returns a function for creating projection matrices\n\n        \"\"\"\n        ii = np.arange(M.nCx)\n\n        def Px(xFace):\n            \"\"\"\n                xFace is 'fXp' or 'fXm'\n            \"\"\"\n            posFx = 0 if xFace == 'fXm' else 1\n            IND = ii + posFx\n            PX = sp.csr_matrix((np.ones(M.nC), (range(M.nC), IND)), shape=(M.nC, M.nF))\n            return PX\n\n        return Px\n\n    def _getFacePxx(M):\n        \"\"\"returns a function for creating projection matrices\n\n            Mats takes you from faces a subset of all faces on only the\n            faces that you ask for.\n\n            These are centered around a single nodes.\n\n            For example, if this was your entire mesh:\n\n                            f3(Yp)\n                      2_______________3\n                      |               |\n                      |               |\n                      |               |\n              f0(Xm)  |       x       |  f1(Xp)\n                      |               |\n                      |               |\n                      |_______________|\n                      0               1\n                            f2(Ym)\n\n            Pxx('fXm','fYm') = | 1, 0, 0, 0 |\n                               | 0, 0, 1, 0 |\n\n            Pxx('fXp','fYm') = | 0, 1, 0, 0 |\n                               | 0, 0, 1, 0 |\n\n            \"\"\"\n        i, j = np.arange(M.nCx), np.arange(M.nCy)\n\n        iijj = ndgrid(i, j)\n        ii, jj = iijj[:, 0], iijj[:, 1]\n\n        if M._meshType == 'Curv':\n            fN1 = M.r(M.normals, 'F', 'Fx', 'M')\n            fN2 = M.r(M.normals, 'F', 'Fy', 'M')\n\n        def Pxx(xFace, yFace):\n            \"\"\"\n                xFace is 'fXp' or 'fXm'\n                yFace is 'fYp' or 'fYm'\n            \"\"\"\n            # no | node      | f1     | f2\n            # 00 | i  ,j     | i  , j | i, j\n            # 10 | i+1,j     | i+1, j | i, j\n            # 01 | i  ,j+1   | i  , j | i, j+1\n            # 11 | i+1,j+1   | i+1, j | i, j+1\n\n            posFx = 0 if xFace == 'fXm' else 1\n            posFy = 0 if yFace == 'fYm' else 1\n\n            ind1 = sub2ind(M.vnFx, np.c_[ii + posFx, jj])\n            ind2 = sub2ind(M.vnFy, np.c_[ii, jj + posFy]) + M.nFx\n\n            IND = np.r_[ind1, ind2].flatten()\n\n            PXX = sp.csr_matrix((np.ones(2*M.nC), (range(2*M.nC), IND)), shape=(2*M.nC, M.nF))\n\n            if M._meshType == 'Curv':\n                I2x2 = inv2X2BlockDiagonal(getSubArray(fN1[0], [i + posFx, j]), getSubArray(fN1[1], [i + posFx, j]),\n                                           getSubArray(fN2[0], [i, j + posFy]), getSubArray(fN2[1], [i, j + posFy]))\n                PXX = I2x2 * PXX\n\n            return PXX\n\n        return Pxx\n\n    def _getFacePxxx(M):\n        \"\"\"returns a function for creating projection matrices\n\n            Mats takes you from faces a subset of all faces on only the\n            faces that you ask for.\n\n            These are centered around a single nodes.\n        \"\"\"\n\n        i, j, k = np.arange(M.nCx), np.arange(M.nCy), np.arange(M.nCz)\n\n        iijjkk = ndgrid(i, j, k)\n        ii, jj, kk = iijjkk[:, 0], iijjkk[:, 1], iijjkk[:, 2]\n\n        if M._meshType == 'Curv':\n            fN1 = M.r(M.normals, 'F', 'Fx', 'M')\n            fN2 = M.r(M.normals, 'F', 'Fy', 'M')\n            fN3 = M.r(M.normals, 'F', 'Fz', 'M')\n\n        def Pxxx(xFace, yFace, zFace):\n            \"\"\"\n                xFace is 'fXp' or 'fXm'\n                yFace is 'fYp' or 'fYm'\n                zFace is 'fZp' or 'fZm'\n            \"\"\"\n\n            # no  | node        | f1        | f2        | f3\n            # 000 | i  ,j  ,k   | i  , j, k | i, j  , k | i, j, k\n            # 100 | i+1,j  ,k   | i+1, j, k | i, j  , k | i, j, k\n            # 010 | i  ,j+1,k   | i  , j, k | i, j+1, k | i, j, k\n            # 110 | i+1,j+1,k   | i+1, j, k | i, j+1, k | i, j, k\n            # 001 | i  ,j  ,k+1 | i  , j, k | i, j  , k | i, j, k+1\n            # 101 | i+1,j  ,k+1 | i+1, j, k | i, j  , k | i, j, k+1\n            # 011 | i  ,j+1,k+1 | i  , j, k | i, j+1, k | i, j, k+1\n            # 111 | i+1,j+1,k+1 | i+1, j, k | i, j+1, k | i, j, k+1\n\n            posX = 0 if xFace == 'fXm' else 1\n            posY = 0 if yFace == 'fYm' else 1\n            posZ = 0 if zFace == 'fZm' else 1\n\n            ind1 = sub2ind(M.vnFx, np.c_[ii + posX, jj, kk])\n            ind2 = sub2ind(M.vnFy, np.c_[ii, jj + posY, kk]) + M.nFx\n            ind3 = sub2ind(M.vnFz, np.c_[ii, jj, kk + posZ]) + M.nFx + M.nFy\n\n            IND = np.r_[ind1, ind2, ind3].flatten()\n\n            PXXX = sp.coo_matrix((np.ones(3*M.nC), (range(3*M.nC), IND)), shape=(3*M.nC, M.nF)).tocsr()\n\n            if M._meshType == 'Curv':\n                I3x3 = inv3X3BlockDiagonal(getSubArray(fN1[0], [i + posX, j, k]), getSubArray(fN1[1], [i + posX, j, k]), getSubArray(fN1[2], [i + posX, j, k]),\n                                           getSubArray(fN2[0], [i, j + posY, k]), getSubArray(fN2[1], [i, j + posY, k]), getSubArray(fN2[2], [i, j + posY, k]),\n                                           getSubArray(fN3[0], [i, j, k + posZ]), getSubArray(fN3[1], [i, j, k + posZ]), getSubArray(fN3[2], [i, j, k + posZ]))\n                PXXX = I3x3 * PXXX\n\n            return PXXX\n        return Pxxx\n\n    def _getEdgePx(M):\n        \"\"\"Returns a function for creating projection matrices\"\"\"\n        def Px(xEdge):\n            assert xEdge == 'eX0', 'xEdge = %s, not eX0' % xEdge\n            return sp.identity(M.nC)\n        return Px\n\n    def _getEdgePxx(M):\n        i, j = np.arange(M.nCx), np.arange(M.nCy)\n\n        iijj = ndgrid(i, j)\n        ii, jj = iijj[:, 0], iijj[:, 1]\n\n        if M._meshType == 'Curv':\n            eT1 = M.r(M.tangents, 'E', 'Ex', 'M')\n            eT2 = M.r(M.tangents, 'E', 'Ey', 'M')\n\n        def Pxx(xEdge, yEdge):\n            # no | node      | e1      | e2\n            # 00 | i  ,j     | i  ,j   | i  ,j\n            # 10 | i+1,j     | i  ,j   | i+1,j\n            # 01 | i  ,j+1   | i  ,j+1 | i  ,j\n            # 11 | i+1,j+1   | i  ,j+1 | i+1,j\n            posX = 0 if xEdge == 'eX0' else 1\n            posY = 0 if yEdge == 'eY0' else 1\n\n            ind1 = sub2ind(M.vnEx, np.c_[ii, jj + posX])\n            ind2 = sub2ind(M.vnEy, np.c_[ii + posY, jj]) + M.nEx\n\n            IND = np.r_[ind1, ind2].flatten()\n\n            PXX = sp.coo_matrix((np.ones(2*M.nC), (range(2*M.nC), IND)), shape=(2*M.nC, M.nE)).tocsr()\n\n            if M._meshType == 'Curv':\n                I2x2 = inv2X2BlockDiagonal(getSubArray(eT1[0], [i, j + posX]), getSubArray(eT1[1], [i, j + posX]),\n                                           getSubArray(eT2[0], [i + posY, j]), getSubArray(eT2[1], [i + posY, j]))\n                PXX = I2x2 * PXX\n\n            return PXX\n        return Pxx\n\n    def _getEdgePxxx(M):\n        i, j, k = np.arange(M.nCx), np.arange(M.nCy), np.arange(M.nCz)\n\n        iijjkk = ndgrid(i, j, k)\n        ii, jj, kk = iijjkk[:, 0], iijjkk[:, 1], iijjkk[:, 2]\n\n        if M._meshType == 'Curv':\n            eT1 = M.r(M.tangents, 'E', 'Ex', 'M')\n            eT2 = M.r(M.tangents, 'E', 'Ey', 'M')\n            eT3 = M.r(M.tangents, 'E', 'Ez', 'M')\n\n        def Pxxx(xEdge, yEdge, zEdge):\n\n            # no  | node        | e1          | e2          | e3\n            # 000 | i  ,j  ,k   | i  ,j  ,k   | i  ,j  ,k   | i  ,j  ,k\n            # 100 | i+1,j  ,k   | i  ,j  ,k   | i+1,j  ,k   | i+1,j  ,k\n            # 010 | i  ,j+1,k   | i  ,j+1,k   | i  ,j  ,k   | i  ,j+1,k\n            # 110 | i+1,j+1,k   | i  ,j+1,k   | i+1,j  ,k   | i+1,j+1,k\n            # 001 | i  ,j  ,k+1 | i  ,j  ,k+1 | i  ,j  ,k+1 | i  ,j  ,k\n            # 101 | i+1,j  ,k+1 | i  ,j  ,k+1 | i+1,j  ,k+1 | i+1,j  ,k\n            # 011 | i  ,j+1,k+1 | i  ,j+1,k+1 | i  ,j  ,k+1 | i  ,j+1,k\n            # 111 | i+1,j+1,k+1 | i  ,j+1,k+1 | i+1,j  ,k+1 | i+1,j+1,k\n\n            posX = [0,0] if xEdge == 'eX0' else [1, 0] if xEdge == 'eX1' else [0,1] if xEdge == 'eX2' else [1,1]\n            posY = [0,0] if yEdge == 'eY0' else [1, 0] if yEdge == 'eY1' else [0,1] if yEdge == 'eY2' else [1,1]\n            posZ = [0,0] if zEdge == 'eZ0' else [1, 0] if zEdge == 'eZ1' else [0,1] if zEdge == 'eZ2' else [1,1]\n\n            ind1 = sub2ind(M.vnEx, np.c_[ii, jj + posX[0], kk + posX[1]])\n            ind2 = sub2ind(M.vnEy, np.c_[ii + posY[0], jj, kk + posY[1]]) + M.nEx\n            ind3 = sub2ind(M.vnEz, np.c_[ii + posZ[0], jj + posZ[1], kk]) + M.nEx + M.nEy\n\n            IND = np.r_[ind1, ind2, ind3].flatten()\n\n            PXXX = sp.coo_matrix((np.ones(3*M.nC), (range(3*M.nC), IND)), shape=(3*M.nC, M.nE)).tocsr()\n\n            if M._meshType == 'Curv':\n                I3x3 = inv3X3BlockDiagonal(getSubArray(eT1[0], [i, j + posX[0], k + posX[1]]), getSubArray(eT1[1], [i, j + posX[0], k + posX[1]]), getSubArray(eT1[2], [i, j + posX[0], k + posX[1]]),\n                                           getSubArray(eT2[0], [i + posY[0], j, k + posY[1]]), getSubArray(eT2[1], [i + posY[0], j, k + posY[1]]), getSubArray(eT2[2], [i + posY[0], j, k + posY[1]]),\n                                           getSubArray(eT3[0], [i + posZ[0], j + posZ[1], k]), getSubArray(eT3[1], [i + posZ[0], j + posZ[1], k]), getSubArray(eT3[2], [i + posZ[0], j + posZ[1], k]))\n                PXXX = I3x3 * PXXX\n\n            return PXXX\n        return Pxxx",
  "def __init__(self):\n        raise Exception('InnerProducts is a base class providing inner product matrices for meshes and cannot run on its own. Inherit to your favorite Mesh class.')",
  "def getFaceInnerProduct(self, prop=None, invProp=False, invMat=False, doFast=True):\n        \"\"\"\n            :param numpy.array prop: material property (tensor properties are possible) at each cell center (nC, (1, 3, or 6))\n            :param bool invProp: inverts the material property\n            :param bool invMat: inverts the matrix\n            :param bool doFast: do a faster implementation if available.\n            :rtype: scipy.csr_matrix\n            :return: M, the inner product matrix (nF, nF)\n        \"\"\"\n        return self._getInnerProduct('F', prop=prop, invProp=invProp, invMat=invMat, doFast=doFast)",
  "def getEdgeInnerProduct(self, prop=None, invProp=False, invMat=False, doFast=True):\n        \"\"\"\n            :param numpy.array prop: material property (tensor properties are possible) at each cell center (nC, (1, 3, or 6))\n            :param bool invProp: inverts the material property\n            :param bool invMat: inverts the matrix\n            :param bool doFast: do a faster implementation if available.\n            :rtype: scipy.csr_matrix\n            :return: M, the inner product matrix (nE, nE)\n        \"\"\"\n        return self._getInnerProduct('E', prop=prop, invProp=invProp, invMat=invMat, doFast=doFast)",
  "def _getInnerProduct(self, projType, prop=None, invProp=False, invMat=False, doFast=True):\n        \"\"\"\n            :param str projType: 'F' for faces 'E' for edges\n            :param numpy.array prop: material property (tensor properties are possible) at each cell center (nC, (1, 3, or 6))\n            :param bool invProp: inverts the material property\n            :param bool invMat: inverts the matrix\n            :param bool doFast: do a faster implementation if available.\n            :rtype: scipy.csr_matrix\n            :return: M, the inner product matrix (nE, nE)\n        \"\"\"\n        assert projType in ['F', 'E'], \"projType must be 'F' for faces or 'E' for edges\"\n\n        fast = None\n        if hasattr(self, '_fastInnerProduct') and doFast:\n            fast = self._fastInnerProduct(projType, prop=prop, invProp=invProp, invMat=invMat)\n        if fast is not None:\n            return fast\n\n        if invProp:\n            prop = invPropertyTensor(self, prop)\n\n        tensorType = TensorType(self, prop)\n\n        Mu = makePropertyTensor(self, prop)\n        Ps = self._getInnerProductProjectionMatrices(projType, tensorType)\n        A = np.sum([P.T * Mu * P for P in Ps])\n\n        if invMat and tensorType < 3:\n            A = sdInv(A)\n        elif invMat and tensorType == 3:\n            raise Exception('Solver needed to invert A.')\n\n        return A",
  "def _getInnerProductProjectionMatrices(self, projType, tensorType):\n        \"\"\"\n            :param str projType: 'F' for faces 'E' for edges\n            :param TensorType tensorType: type of the tensor: TensorType(mesh, sigma)\n        \"\"\"\n        assert isinstance(tensorType, TensorType), 'tensorType must be an instance of TensorType.'\n        assert projType in ['F', 'E'], \"projType must be 'F' for faces or 'E' for edges\"\n\n        d = self.dim\n        # We will multiply by sqrt on each side to keep symmetry\n        V = sp.kron(sp.identity(d), sdiag(np.sqrt((2**(-d))*self.vol)))\n\n        nodes = ['000', '100', '010', '110', '001', '101', '011',  '111'][:2**d]\n\n        if projType == 'F':\n            locs = {\n                    '000': [('fXm',), ('fXm', 'fYm'), ('fXm', 'fYm', 'fZm')],\n                    '100': [('fXp',), ('fXp', 'fYm'), ('fXp', 'fYm', 'fZm')],\n                    '010': [  None  , ('fXm', 'fYp'), ('fXm', 'fYp', 'fZm')],\n                    '110': [  None  , ('fXp', 'fYp'), ('fXp', 'fYp', 'fZm')],\n                    '001': [  None  ,      None     , ('fXm', 'fYm', 'fZp')],\n                    '101': [  None  ,      None     , ('fXp', 'fYm', 'fZp')],\n                    '011': [  None  ,      None     , ('fXm', 'fYp', 'fZp')],\n                    '111': [  None  ,      None     , ('fXp', 'fYp', 'fZp')]\n                   }\n            proj = getattr(self, '_getFaceP' + ('x'*d))()\n\n        elif projType == 'E':\n            locs = {\n                    '000': [('eX0',), ('eX0', 'eY0'), ('eX0', 'eY0', 'eZ0')],\n                    '100': [('eX0',), ('eX0', 'eY1'), ('eX0', 'eY1', 'eZ1')],\n                    '010': [  None  , ('eX1', 'eY0'), ('eX1', 'eY0', 'eZ2')],\n                    '110': [  None  , ('eX1', 'eY1'), ('eX1', 'eY1', 'eZ3')],\n                    '001': [  None  ,      None     , ('eX2', 'eY2', 'eZ0')],\n                    '101': [  None  ,      None     , ('eX2', 'eY3', 'eZ1')],\n                    '011': [  None  ,      None     , ('eX3', 'eY2', 'eZ2')],\n                    '111': [  None  ,      None     , ('eX3', 'eY3', 'eZ3')]\n                   }\n            proj = getattr(self, '_getEdgeP' + ('x'*d))()\n\n        return [V*proj(*locs[node][d-1]) for node in nodes]",
  "def getFaceInnerProductDeriv(self, prop, doFast=True, invProp=False, invMat=False):\n        \"\"\"\n            :param numpy.array prop: material property (tensor properties are possible) at each cell center (nC, (1, 3, or 6))\n            :param bool doFast: do a faster implementation if available.\n            :param bool invProp: inverts the material property\n            :param bool invMat: inverts the matrix\n            :rtype: function\n            :return: dMdmu(u), the derivative of the inner product matrix (u)\n\n            Given u, dMdmu returns (nF, nC*nA)\n\n            :param np.ndarray u: vector that multiplies dMdmu\n            :rtype: scipy.csr_matrix\n            :return: dMdmu, the derivative of the inner product matrix for a certain u\n        \"\"\"\n        return self._getInnerProductDeriv(prop, 'F', doFast=doFast, invProp=invProp, invMat=invMat)",
  "def getEdgeInnerProductDeriv(self, prop, doFast=True, invProp=False, invMat=False):\n        \"\"\"\n            :param numpy.array prop: material property (tensor properties are possible) at each cell center (nC, (1, 3, or 6))\n            :param bool doFast: do a faster implementation if available.\n            :param bool invProp: inverts the material property\n            :param bool invMat: inverts the matrix\n            :rtype: scipy.csr_matrix\n            :return: dMdm, the derivative of the inner product matrix (nE, nC*nA)\n        \"\"\"\n        return self._getInnerProductDeriv(prop, 'E', doFast=doFast, invProp=invProp, invMat=invMat)",
  "def _getInnerProductDeriv(self, prop, projType, doFast=True, invProp=False, invMat=False):\n        \"\"\"\n            :param numpy.array prop: material property (tensor properties are possible) at each cell center (nC, (1, 3, or 6))\n            :param str projType: 'F' for faces 'E' for edges\n            :param bool doFast: do a faster implementation if available.\n            :param bool invProp: inverts the material property\n            :param bool invMat: inverts the matrix\n            :rtype: scipy.csr_matrix\n            :return: dMdm, the derivative of the inner product matrix (nE, nC*nA)\n        \"\"\"\n        fast = None\n        if hasattr(self, '_fastInnerProductDeriv') and doFast:\n            fast = self._fastInnerProductDeriv(projType, prop, invProp=invProp, invMat=invMat)\n        if fast is not None:\n            return fast\n\n        if invProp or invMat:\n            raise NotImplementedError('inverting the property or the matrix is not yet implemented for this mesh/tensorType. You should write it!')\n\n        tensorType = TensorType(self, prop)\n        P = self._getInnerProductProjectionMatrices(projType, tensorType=tensorType)\n        def innerProductDeriv(v):\n            return self._getInnerProductDerivFunction(tensorType, P, projType, v)\n        return innerProductDeriv",
  "def _getInnerProductDerivFunction(self, tensorType, P, projType, v):\n        \"\"\"\n            :param numpy.array prop: material property (tensor properties are possible) at each cell center (nC, (1, 3, or 6))\n            :param numpy.array v: vector to multiply (required in the general implementation)\n            :param list P: list of projection matrices\n            :param str projType: 'F' for faces 'E' for edges\n            :rtype: scipy.csr_matrix\n            :return: dMdm, the derivative of the inner product matrix (n, nC*nA)\n        \"\"\"\n        assert projType in ['F', 'E'], \"projType must be 'F' for faces or 'E' for edges\"\n        n = getattr(self,'n'+projType)\n\n        if tensorType == -1:\n            return None\n\n        if v is None:\n            raise Exception('v must be supplied for this implementation.')\n\n        d = self.dim\n        Z = spzeros(self.nC, self.nC)\n\n        if tensorType == 0:\n            dMdm = spzeros(n, 1)\n            for i, p in enumerate(P):\n                dMdm = dMdm + sp.csr_matrix((p.T * (p * v), (range(n), np.zeros(n))), shape=(n,1))\n        if d == 1:\n            if tensorType == 1:\n                dMdm = spzeros(n, self.nC)\n                for i, p in enumerate(P):\n                    dMdm = dMdm + p.T * sdiag( p * v )\n        elif d == 2:\n            if tensorType == 1:\n                dMdm = spzeros(n, self.nC)\n                for i, p in enumerate(P):\n                    Y = p * v\n                    y1 = Y[:self.nC]\n                    y2 = Y[self.nC:]\n                    dMdm = dMdm + p.T * sp.vstack((sdiag( y1 ), sdiag( y2 )))\n            elif tensorType == 2:\n                dMdms = [spzeros(n, self.nC) for _ in range(2)]\n                for i, p in enumerate(P):\n                    Y = p * v\n                    y1 = Y[:self.nC]\n                    y2 = Y[self.nC:]\n                    dMdms[0] = dMdms[0] + p.T * sp.vstack(( sdiag( y1 ), Z))\n                    dMdms[1] = dMdms[1] + p.T * sp.vstack(( Z, sdiag( y2 )))\n                dMdm = sp.hstack(dMdms)\n            elif tensorType == 3:\n                dMdms = [spzeros(n, self.nC) for _ in range(3)]\n                for i, p in enumerate(P):\n                    Y = p * v\n                    y1 = Y[:self.nC]\n                    y2 = Y[self.nC:]\n                    dMdms[0] = dMdms[0] + p.T * sp.vstack(( sdiag( y1 ), Z))\n                    dMdms[1] = dMdms[1] + p.T * sp.vstack(( Z, sdiag( y2 )))\n                    dMdms[2] = dMdms[2] + p.T * sp.vstack(( sdiag( y2 ), sdiag( y1 )))\n                dMdm = sp.hstack(dMdms)\n        elif d == 3:\n            if tensorType == 1:\n                dMdm = spzeros(n, self.nC)\n                for i, p in enumerate(P):\n                    Y = p * v\n                    y1 = Y[:self.nC]\n                    y2 = Y[self.nC:self.nC*2]\n                    y3 = Y[self.nC*2:]\n                    dMdm = dMdm + p.T * sp.vstack((sdiag( y1 ), sdiag( y2 ), sdiag( y3 )))\n            elif tensorType == 2:\n                dMdms = [spzeros(n, self.nC) for _ in range(3)]\n                for i, p in enumerate(P):\n                    Y = p * v\n                    y1 = Y[:self.nC]\n                    y2 = Y[self.nC:self.nC*2]\n                    y3 = Y[self.nC*2:]\n                    dMdms[0] = dMdms[0] + p.T * sp.vstack(( sdiag( y1 ), Z, Z))\n                    dMdms[1] = dMdms[1] + p.T * sp.vstack(( Z, sdiag( y2 ), Z))\n                    dMdms[2] = dMdms[2] + p.T * sp.vstack(( Z, Z, sdiag( y3 )))\n                dMdm = sp.hstack(dMdms)\n            elif tensorType == 3:\n                dMdms = [spzeros(n, self.nC) for _ in range(6)]\n                for i, p in enumerate(P):\n                    Y = p * v\n                    y1 = Y[:self.nC]\n                    y2 = Y[self.nC:self.nC*2]\n                    y3 = Y[self.nC*2:]\n                    dMdms[0] = dMdms[0] + p.T * sp.vstack(( sdiag( y1 ), Z, Z))\n                    dMdms[1] = dMdms[1] + p.T * sp.vstack(( Z, sdiag( y2 ), Z))\n                    dMdms[2] = dMdms[2] + p.T * sp.vstack(( Z, Z, sdiag( y3 )))\n                    dMdms[3] = dMdms[3] + p.T * sp.vstack(( sdiag( y2 ), sdiag( y1 ), Z))\n                    dMdms[4] = dMdms[4] + p.T * sp.vstack(( sdiag( y3 ), Z, sdiag( y1 )))\n                    dMdms[5] = dMdms[5] + p.T * sp.vstack(( Z, sdiag( y3 ), sdiag( y2 )))\n                dMdm = sp.hstack(dMdms)\n\n        return dMdm",
  "def _getFacePx(M):\n        \"\"\"Returns a function for creating projection matrices\n\n        \"\"\"\n        ii = np.arange(M.nCx)\n\n        def Px(xFace):\n            \"\"\"\n                xFace is 'fXp' or 'fXm'\n            \"\"\"\n            posFx = 0 if xFace == 'fXm' else 1\n            IND = ii + posFx\n            PX = sp.csr_matrix((np.ones(M.nC), (range(M.nC), IND)), shape=(M.nC, M.nF))\n            return PX\n\n        return Px",
  "def _getFacePxx(M):\n        \"\"\"returns a function for creating projection matrices\n\n            Mats takes you from faces a subset of all faces on only the\n            faces that you ask for.\n\n            These are centered around a single nodes.\n\n            For example, if this was your entire mesh:\n\n                            f3(Yp)\n                      2_______________3\n                      |               |\n                      |               |\n                      |               |\n              f0(Xm)  |       x       |  f1(Xp)\n                      |               |\n                      |               |\n                      |_______________|\n                      0               1\n                            f2(Ym)\n\n            Pxx('fXm','fYm') = | 1, 0, 0, 0 |\n                               | 0, 0, 1, 0 |\n\n            Pxx('fXp','fYm') = | 0, 1, 0, 0 |\n                               | 0, 0, 1, 0 |\n\n            \"\"\"\n        i, j = np.arange(M.nCx), np.arange(M.nCy)\n\n        iijj = ndgrid(i, j)\n        ii, jj = iijj[:, 0], iijj[:, 1]\n\n        if M._meshType == 'Curv':\n            fN1 = M.r(M.normals, 'F', 'Fx', 'M')\n            fN2 = M.r(M.normals, 'F', 'Fy', 'M')\n\n        def Pxx(xFace, yFace):\n            \"\"\"\n                xFace is 'fXp' or 'fXm'\n                yFace is 'fYp' or 'fYm'\n            \"\"\"\n            # no | node      | f1     | f2\n            # 00 | i  ,j     | i  , j | i, j\n            # 10 | i+1,j     | i+1, j | i, j\n            # 01 | i  ,j+1   | i  , j | i, j+1\n            # 11 | i+1,j+1   | i+1, j | i, j+1\n\n            posFx = 0 if xFace == 'fXm' else 1\n            posFy = 0 if yFace == 'fYm' else 1\n\n            ind1 = sub2ind(M.vnFx, np.c_[ii + posFx, jj])\n            ind2 = sub2ind(M.vnFy, np.c_[ii, jj + posFy]) + M.nFx\n\n            IND = np.r_[ind1, ind2].flatten()\n\n            PXX = sp.csr_matrix((np.ones(2*M.nC), (range(2*M.nC), IND)), shape=(2*M.nC, M.nF))\n\n            if M._meshType == 'Curv':\n                I2x2 = inv2X2BlockDiagonal(getSubArray(fN1[0], [i + posFx, j]), getSubArray(fN1[1], [i + posFx, j]),\n                                           getSubArray(fN2[0], [i, j + posFy]), getSubArray(fN2[1], [i, j + posFy]))\n                PXX = I2x2 * PXX\n\n            return PXX\n\n        return Pxx",
  "def _getFacePxxx(M):\n        \"\"\"returns a function for creating projection matrices\n\n            Mats takes you from faces a subset of all faces on only the\n            faces that you ask for.\n\n            These are centered around a single nodes.\n        \"\"\"\n\n        i, j, k = np.arange(M.nCx), np.arange(M.nCy), np.arange(M.nCz)\n\n        iijjkk = ndgrid(i, j, k)\n        ii, jj, kk = iijjkk[:, 0], iijjkk[:, 1], iijjkk[:, 2]\n\n        if M._meshType == 'Curv':\n            fN1 = M.r(M.normals, 'F', 'Fx', 'M')\n            fN2 = M.r(M.normals, 'F', 'Fy', 'M')\n            fN3 = M.r(M.normals, 'F', 'Fz', 'M')\n\n        def Pxxx(xFace, yFace, zFace):\n            \"\"\"\n                xFace is 'fXp' or 'fXm'\n                yFace is 'fYp' or 'fYm'\n                zFace is 'fZp' or 'fZm'\n            \"\"\"\n\n            # no  | node        | f1        | f2        | f3\n            # 000 | i  ,j  ,k   | i  , j, k | i, j  , k | i, j, k\n            # 100 | i+1,j  ,k   | i+1, j, k | i, j  , k | i, j, k\n            # 010 | i  ,j+1,k   | i  , j, k | i, j+1, k | i, j, k\n            # 110 | i+1,j+1,k   | i+1, j, k | i, j+1, k | i, j, k\n            # 001 | i  ,j  ,k+1 | i  , j, k | i, j  , k | i, j, k+1\n            # 101 | i+1,j  ,k+1 | i+1, j, k | i, j  , k | i, j, k+1\n            # 011 | i  ,j+1,k+1 | i  , j, k | i, j+1, k | i, j, k+1\n            # 111 | i+1,j+1,k+1 | i+1, j, k | i, j+1, k | i, j, k+1\n\n            posX = 0 if xFace == 'fXm' else 1\n            posY = 0 if yFace == 'fYm' else 1\n            posZ = 0 if zFace == 'fZm' else 1\n\n            ind1 = sub2ind(M.vnFx, np.c_[ii + posX, jj, kk])\n            ind2 = sub2ind(M.vnFy, np.c_[ii, jj + posY, kk]) + M.nFx\n            ind3 = sub2ind(M.vnFz, np.c_[ii, jj, kk + posZ]) + M.nFx + M.nFy\n\n            IND = np.r_[ind1, ind2, ind3].flatten()\n\n            PXXX = sp.coo_matrix((np.ones(3*M.nC), (range(3*M.nC), IND)), shape=(3*M.nC, M.nF)).tocsr()\n\n            if M._meshType == 'Curv':\n                I3x3 = inv3X3BlockDiagonal(getSubArray(fN1[0], [i + posX, j, k]), getSubArray(fN1[1], [i + posX, j, k]), getSubArray(fN1[2], [i + posX, j, k]),\n                                           getSubArray(fN2[0], [i, j + posY, k]), getSubArray(fN2[1], [i, j + posY, k]), getSubArray(fN2[2], [i, j + posY, k]),\n                                           getSubArray(fN3[0], [i, j, k + posZ]), getSubArray(fN3[1], [i, j, k + posZ]), getSubArray(fN3[2], [i, j, k + posZ]))\n                PXXX = I3x3 * PXXX\n\n            return PXXX\n        return Pxxx",
  "def _getEdgePx(M):\n        \"\"\"Returns a function for creating projection matrices\"\"\"\n        def Px(xEdge):\n            assert xEdge == 'eX0', 'xEdge = %s, not eX0' % xEdge\n            return sp.identity(M.nC)\n        return Px",
  "def _getEdgePxx(M):\n        i, j = np.arange(M.nCx), np.arange(M.nCy)\n\n        iijj = ndgrid(i, j)\n        ii, jj = iijj[:, 0], iijj[:, 1]\n\n        if M._meshType == 'Curv':\n            eT1 = M.r(M.tangents, 'E', 'Ex', 'M')\n            eT2 = M.r(M.tangents, 'E', 'Ey', 'M')\n\n        def Pxx(xEdge, yEdge):\n            # no | node      | e1      | e2\n            # 00 | i  ,j     | i  ,j   | i  ,j\n            # 10 | i+1,j     | i  ,j   | i+1,j\n            # 01 | i  ,j+1   | i  ,j+1 | i  ,j\n            # 11 | i+1,j+1   | i  ,j+1 | i+1,j\n            posX = 0 if xEdge == 'eX0' else 1\n            posY = 0 if yEdge == 'eY0' else 1\n\n            ind1 = sub2ind(M.vnEx, np.c_[ii, jj + posX])\n            ind2 = sub2ind(M.vnEy, np.c_[ii + posY, jj]) + M.nEx\n\n            IND = np.r_[ind1, ind2].flatten()\n\n            PXX = sp.coo_matrix((np.ones(2*M.nC), (range(2*M.nC), IND)), shape=(2*M.nC, M.nE)).tocsr()\n\n            if M._meshType == 'Curv':\n                I2x2 = inv2X2BlockDiagonal(getSubArray(eT1[0], [i, j + posX]), getSubArray(eT1[1], [i, j + posX]),\n                                           getSubArray(eT2[0], [i + posY, j]), getSubArray(eT2[1], [i + posY, j]))\n                PXX = I2x2 * PXX\n\n            return PXX\n        return Pxx",
  "def _getEdgePxxx(M):\n        i, j, k = np.arange(M.nCx), np.arange(M.nCy), np.arange(M.nCz)\n\n        iijjkk = ndgrid(i, j, k)\n        ii, jj, kk = iijjkk[:, 0], iijjkk[:, 1], iijjkk[:, 2]\n\n        if M._meshType == 'Curv':\n            eT1 = M.r(M.tangents, 'E', 'Ex', 'M')\n            eT2 = M.r(M.tangents, 'E', 'Ey', 'M')\n            eT3 = M.r(M.tangents, 'E', 'Ez', 'M')\n\n        def Pxxx(xEdge, yEdge, zEdge):\n\n            # no  | node        | e1          | e2          | e3\n            # 000 | i  ,j  ,k   | i  ,j  ,k   | i  ,j  ,k   | i  ,j  ,k\n            # 100 | i+1,j  ,k   | i  ,j  ,k   | i+1,j  ,k   | i+1,j  ,k\n            # 010 | i  ,j+1,k   | i  ,j+1,k   | i  ,j  ,k   | i  ,j+1,k\n            # 110 | i+1,j+1,k   | i  ,j+1,k   | i+1,j  ,k   | i+1,j+1,k\n            # 001 | i  ,j  ,k+1 | i  ,j  ,k+1 | i  ,j  ,k+1 | i  ,j  ,k\n            # 101 | i+1,j  ,k+1 | i  ,j  ,k+1 | i+1,j  ,k+1 | i+1,j  ,k\n            # 011 | i  ,j+1,k+1 | i  ,j+1,k+1 | i  ,j  ,k+1 | i  ,j+1,k\n            # 111 | i+1,j+1,k+1 | i  ,j+1,k+1 | i+1,j  ,k+1 | i+1,j+1,k\n\n            posX = [0,0] if xEdge == 'eX0' else [1, 0] if xEdge == 'eX1' else [0,1] if xEdge == 'eX2' else [1,1]\n            posY = [0,0] if yEdge == 'eY0' else [1, 0] if yEdge == 'eY1' else [0,1] if yEdge == 'eY2' else [1,1]\n            posZ = [0,0] if zEdge == 'eZ0' else [1, 0] if zEdge == 'eZ1' else [0,1] if zEdge == 'eZ2' else [1,1]\n\n            ind1 = sub2ind(M.vnEx, np.c_[ii, jj + posX[0], kk + posX[1]])\n            ind2 = sub2ind(M.vnEy, np.c_[ii + posY[0], jj, kk + posY[1]]) + M.nEx\n            ind3 = sub2ind(M.vnEz, np.c_[ii + posZ[0], jj + posZ[1], kk]) + M.nEx + M.nEy\n\n            IND = np.r_[ind1, ind2, ind3].flatten()\n\n            PXXX = sp.coo_matrix((np.ones(3*M.nC), (range(3*M.nC), IND)), shape=(3*M.nC, M.nE)).tocsr()\n\n            if M._meshType == 'Curv':\n                I3x3 = inv3X3BlockDiagonal(getSubArray(eT1[0], [i, j + posX[0], k + posX[1]]), getSubArray(eT1[1], [i, j + posX[0], k + posX[1]]), getSubArray(eT1[2], [i, j + posX[0], k + posX[1]]),\n                                           getSubArray(eT2[0], [i + posY[0], j, k + posY[1]]), getSubArray(eT2[1], [i + posY[0], j, k + posY[1]]), getSubArray(eT2[2], [i + posY[0], j, k + posY[1]]),\n                                           getSubArray(eT3[0], [i + posZ[0], j + posZ[1], k]), getSubArray(eT3[1], [i + posZ[0], j + posZ[1], k]), getSubArray(eT3[2], [i + posZ[0], j + posZ[1], k]))\n                PXXX = I3x3 * PXXX\n\n            return PXXX\n        return Pxxx",
  "def innerProductDeriv(v):\n            return self._getInnerProductDerivFunction(tensorType, P, projType, v)",
  "def Px(xFace):\n            \"\"\"\n                xFace is 'fXp' or 'fXm'\n            \"\"\"\n            posFx = 0 if xFace == 'fXm' else 1\n            IND = ii + posFx\n            PX = sp.csr_matrix((np.ones(M.nC), (range(M.nC), IND)), shape=(M.nC, M.nF))\n            return PX",
  "def Pxx(xFace, yFace):\n            \"\"\"\n                xFace is 'fXp' or 'fXm'\n                yFace is 'fYp' or 'fYm'\n            \"\"\"\n            # no | node      | f1     | f2\n            # 00 | i  ,j     | i  , j | i, j\n            # 10 | i+1,j     | i+1, j | i, j\n            # 01 | i  ,j+1   | i  , j | i, j+1\n            # 11 | i+1,j+1   | i+1, j | i, j+1\n\n            posFx = 0 if xFace == 'fXm' else 1\n            posFy = 0 if yFace == 'fYm' else 1\n\n            ind1 = sub2ind(M.vnFx, np.c_[ii + posFx, jj])\n            ind2 = sub2ind(M.vnFy, np.c_[ii, jj + posFy]) + M.nFx\n\n            IND = np.r_[ind1, ind2].flatten()\n\n            PXX = sp.csr_matrix((np.ones(2*M.nC), (range(2*M.nC), IND)), shape=(2*M.nC, M.nF))\n\n            if M._meshType == 'Curv':\n                I2x2 = inv2X2BlockDiagonal(getSubArray(fN1[0], [i + posFx, j]), getSubArray(fN1[1], [i + posFx, j]),\n                                           getSubArray(fN2[0], [i, j + posFy]), getSubArray(fN2[1], [i, j + posFy]))\n                PXX = I2x2 * PXX\n\n            return PXX",
  "def Pxxx(xFace, yFace, zFace):\n            \"\"\"\n                xFace is 'fXp' or 'fXm'\n                yFace is 'fYp' or 'fYm'\n                zFace is 'fZp' or 'fZm'\n            \"\"\"\n\n            # no  | node        | f1        | f2        | f3\n            # 000 | i  ,j  ,k   | i  , j, k | i, j  , k | i, j, k\n            # 100 | i+1,j  ,k   | i+1, j, k | i, j  , k | i, j, k\n            # 010 | i  ,j+1,k   | i  , j, k | i, j+1, k | i, j, k\n            # 110 | i+1,j+1,k   | i+1, j, k | i, j+1, k | i, j, k\n            # 001 | i  ,j  ,k+1 | i  , j, k | i, j  , k | i, j, k+1\n            # 101 | i+1,j  ,k+1 | i+1, j, k | i, j  , k | i, j, k+1\n            # 011 | i  ,j+1,k+1 | i  , j, k | i, j+1, k | i, j, k+1\n            # 111 | i+1,j+1,k+1 | i+1, j, k | i, j+1, k | i, j, k+1\n\n            posX = 0 if xFace == 'fXm' else 1\n            posY = 0 if yFace == 'fYm' else 1\n            posZ = 0 if zFace == 'fZm' else 1\n\n            ind1 = sub2ind(M.vnFx, np.c_[ii + posX, jj, kk])\n            ind2 = sub2ind(M.vnFy, np.c_[ii, jj + posY, kk]) + M.nFx\n            ind3 = sub2ind(M.vnFz, np.c_[ii, jj, kk + posZ]) + M.nFx + M.nFy\n\n            IND = np.r_[ind1, ind2, ind3].flatten()\n\n            PXXX = sp.coo_matrix((np.ones(3*M.nC), (range(3*M.nC), IND)), shape=(3*M.nC, M.nF)).tocsr()\n\n            if M._meshType == 'Curv':\n                I3x3 = inv3X3BlockDiagonal(getSubArray(fN1[0], [i + posX, j, k]), getSubArray(fN1[1], [i + posX, j, k]), getSubArray(fN1[2], [i + posX, j, k]),\n                                           getSubArray(fN2[0], [i, j + posY, k]), getSubArray(fN2[1], [i, j + posY, k]), getSubArray(fN2[2], [i, j + posY, k]),\n                                           getSubArray(fN3[0], [i, j, k + posZ]), getSubArray(fN3[1], [i, j, k + posZ]), getSubArray(fN3[2], [i, j, k + posZ]))\n                PXXX = I3x3 * PXXX\n\n            return PXXX",
  "def Px(xEdge):\n            assert xEdge == 'eX0', 'xEdge = %s, not eX0' % xEdge\n            return sp.identity(M.nC)",
  "def Pxx(xEdge, yEdge):\n            # no | node      | e1      | e2\n            # 00 | i  ,j     | i  ,j   | i  ,j\n            # 10 | i+1,j     | i  ,j   | i+1,j\n            # 01 | i  ,j+1   | i  ,j+1 | i  ,j\n            # 11 | i+1,j+1   | i  ,j+1 | i+1,j\n            posX = 0 if xEdge == 'eX0' else 1\n            posY = 0 if yEdge == 'eY0' else 1\n\n            ind1 = sub2ind(M.vnEx, np.c_[ii, jj + posX])\n            ind2 = sub2ind(M.vnEy, np.c_[ii + posY, jj]) + M.nEx\n\n            IND = np.r_[ind1, ind2].flatten()\n\n            PXX = sp.coo_matrix((np.ones(2*M.nC), (range(2*M.nC), IND)), shape=(2*M.nC, M.nE)).tocsr()\n\n            if M._meshType == 'Curv':\n                I2x2 = inv2X2BlockDiagonal(getSubArray(eT1[0], [i, j + posX]), getSubArray(eT1[1], [i, j + posX]),\n                                           getSubArray(eT2[0], [i + posY, j]), getSubArray(eT2[1], [i + posY, j]))\n                PXX = I2x2 * PXX\n\n            return PXX",
  "def Pxxx(xEdge, yEdge, zEdge):\n\n            # no  | node        | e1          | e2          | e3\n            # 000 | i  ,j  ,k   | i  ,j  ,k   | i  ,j  ,k   | i  ,j  ,k\n            # 100 | i+1,j  ,k   | i  ,j  ,k   | i+1,j  ,k   | i+1,j  ,k\n            # 010 | i  ,j+1,k   | i  ,j+1,k   | i  ,j  ,k   | i  ,j+1,k\n            # 110 | i+1,j+1,k   | i  ,j+1,k   | i+1,j  ,k   | i+1,j+1,k\n            # 001 | i  ,j  ,k+1 | i  ,j  ,k+1 | i  ,j  ,k+1 | i  ,j  ,k\n            # 101 | i+1,j  ,k+1 | i  ,j  ,k+1 | i+1,j  ,k+1 | i+1,j  ,k\n            # 011 | i  ,j+1,k+1 | i  ,j+1,k+1 | i  ,j  ,k+1 | i  ,j+1,k\n            # 111 | i+1,j+1,k+1 | i  ,j+1,k+1 | i+1,j  ,k+1 | i+1,j+1,k\n\n            posX = [0,0] if xEdge == 'eX0' else [1, 0] if xEdge == 'eX1' else [0,1] if xEdge == 'eX2' else [1,1]\n            posY = [0,0] if yEdge == 'eY0' else [1, 0] if yEdge == 'eY1' else [0,1] if yEdge == 'eY2' else [1,1]\n            posZ = [0,0] if zEdge == 'eZ0' else [1, 0] if zEdge == 'eZ1' else [0,1] if zEdge == 'eZ2' else [1,1]\n\n            ind1 = sub2ind(M.vnEx, np.c_[ii, jj + posX[0], kk + posX[1]])\n            ind2 = sub2ind(M.vnEy, np.c_[ii + posY[0], jj, kk + posY[1]]) + M.nEx\n            ind3 = sub2ind(M.vnEz, np.c_[ii + posZ[0], jj + posZ[1], kk]) + M.nEx + M.nEy\n\n            IND = np.r_[ind1, ind2, ind3].flatten()\n\n            PXXX = sp.coo_matrix((np.ones(3*M.nC), (range(3*M.nC), IND)), shape=(3*M.nC, M.nE)).tocsr()\n\n            if M._meshType == 'Curv':\n                I3x3 = inv3X3BlockDiagonal(getSubArray(eT1[0], [i, j + posX[0], k + posX[1]]), getSubArray(eT1[1], [i, j + posX[0], k + posX[1]]), getSubArray(eT1[2], [i, j + posX[0], k + posX[1]]),\n                                           getSubArray(eT2[0], [i + posY[0], j, k + posY[1]]), getSubArray(eT2[1], [i + posY[0], j, k + posY[1]]), getSubArray(eT2[2], [i + posY[0], j, k + posY[1]]),\n                                           getSubArray(eT3[0], [i + posZ[0], j + posZ[1], k]), getSubArray(eT3[1], [i + posZ[0], j + posZ[1], k]), getSubArray(eT3[2], [i + posZ[0], j + posZ[1], k]))\n                PXXX = I3x3 * PXXX\n\n            return PXXX",
  "class BaseMesh(object):\n    \"\"\"\n    BaseMesh does all the counting you don't want to do.\n    BaseMesh should be inherited by meshes with a regular structure.\n\n    :param numpy.array,list n: number of cells in each direction (dim, )\n    :param numpy.array,list x0: Origin of the mesh (dim, )\n\n    \"\"\"\n\n    def __init__(self, n, x0=None):\n\n        # Check inputs\n        if x0 is None:\n            x0 = np.zeros(len(n))\n\n        if not len(n) == len(x0):\n            raise Exception(\"Dimension mismatch. x0 != len(n)\")\n\n        if len(n) > 3:\n            raise Exception(\"Dimensions higher than 3 are not supported.\")\n\n        # Ensure x0 & n are 1D vectors\n        self._n = np.array(n, dtype=int).ravel()\n        self._x0 = np.array(x0, dtype=float).ravel()\n        self._dim = len(self._x0)\n\n    @property\n    def x0(self):\n        \"\"\"\n        Origin of the mesh\n\n        :rtype: numpy.array (dim, )\n        :return: x0\n        \"\"\"\n        return self._x0\n\n    @property\n    def dim(self):\n        \"\"\"\n        The dimension of the mesh (1, 2, or 3).\n\n        :rtype: int\n        :return: dim\n        \"\"\"\n        return self._dim\n\n    @property\n    def nC(self):\n        \"\"\"\n        Total number of cells in the mesh.\n\n        :rtype: int\n        :return: nC\n\n        .. plot::\n            :include-source:\n\n            from SimPEG import Mesh, np\n            Mesh.TensorMesh([np.ones(n) for n in [2,3]]).plotGrid(centers=True,showIt=True)\n        \"\"\"\n        return self._n.prod()\n\n    @property\n    def nN(self):\n        \"\"\"\n        Total number of nodes\n\n        :rtype: int\n        :return: nN\n\n        .. plot::\n            :include-source:\n\n            from SimPEG import Mesh, np\n            Mesh.TensorMesh([np.ones(n) for n in [2,3]]).plotGrid(nodes=True,showIt=True)\n        \"\"\"\n        return (self._n+1).prod()\n\n    @property\n    def nEx(self):\n        \"\"\"\n        Number of x-edges\n\n        :rtype: int\n        :return: nEx\n        \"\"\"\n        return (self._n + np.r_[0,1,1][:self.dim]).prod()\n\n    @property\n    def nEy(self):\n        \"\"\"\n        Number of y-edges\n\n        :rtype: int\n        :return: nEy\n        \"\"\"\n        return None if self.dim < 2 else (self._n + np.r_[1,0,1][:self.dim]).prod()\n\n    @property\n    def nEz(self):\n        \"\"\"\n        Number of z-edges\n\n        :rtype: int\n        :return: nEz\n        \"\"\"\n        return None if self.dim < 3 else (self._n + np.r_[1,1,0][:self.dim]).prod()\n\n    @property\n    def vnE(self):\n        \"\"\"\n        Total number of edges in each direction\n\n        :rtype: numpy.array (dim, )\n        :return: [nEx, nEy, nEz]\n\n        .. plot::\n            :include-source:\n\n            from SimPEG import Mesh, np\n            Mesh.TensorMesh([np.ones(n) for n in [2,3]]).plotGrid(edges=True,showIt=True)\n        \"\"\"\n        return np.array([x for x in [self.nEx, self.nEy, self.nEz] if not x is None])\n\n    @property\n    def nE(self):\n        \"\"\"\n        Total number of edges.\n\n        :rtype: int\n        :return: sum([nEx, nEy, nEz])\n\n        \"\"\"\n        return self.vnE.sum()\n\n    @property\n    def nFx(self):\n        \"\"\"\n        Number of x-faces\n\n        :rtype: int\n        :return: nFx\n        \"\"\"\n        return (self._n + np.r_[1,0,0][:self.dim]).prod()\n\n    @property\n    def nFy(self):\n        \"\"\"\n        Number of y-faces\n\n        :rtype: int\n        :return: nFy\n        \"\"\"\n        return None if self.dim < 2 else (self._n + np.r_[0,1,0][:self.dim]).prod()\n\n    @property\n    def nFz(self):\n        \"\"\"\n        Number of z-faces\n\n        :rtype: int\n        :return: nFz\n        \"\"\"\n        return None if self.dim < 3 else (self._n + np.r_[0,0,1][:self.dim]).prod()\n\n    @property\n    def vnF(self):\n        \"\"\"\n        Total number of faces in each direction\n\n        :rtype: numpy.array (dim, )\n        :return: [nFx, nFy, nFz]\n\n        .. plot::\n            :include-source:\n\n            from SimPEG import Mesh, np\n            Mesh.TensorMesh([np.ones(n) for n in [2,3]]).plotGrid(faces=True,showIt=True)\n        \"\"\"\n        return np.array([x for x in [self.nFx, self.nFy, self.nFz] if not x is None])\n\n    @property\n    def nF(self):\n        \"\"\"\n        Total number of faces.\n\n        :rtype: int\n        :return: sum([nFx, nFy, nFz])\n\n        \"\"\"\n        return self.vnF.sum()\n\n    @property\n    def normals(self):\n        \"\"\"\n        Face Normals\n\n        :rtype: numpy.array (sum(nF), dim)\n        :return: normals\n        \"\"\"\n        if self.dim == 2:\n            nX = np.c_[np.ones(self.nFx), np.zeros(self.nFx)]\n            nY = np.c_[np.zeros(self.nFy), np.ones(self.nFy)]\n            return np.r_[nX, nY]\n        elif self.dim == 3:\n            nX = np.c_[np.ones(self.nFx), np.zeros(self.nFx), np.zeros(self.nFx)]\n            nY = np.c_[np.zeros(self.nFy), np.ones(self.nFy), np.zeros(self.nFy)]\n            nZ = np.c_[np.zeros(self.nFz), np.zeros(self.nFz), np.ones(self.nFz)]\n            return np.r_[nX, nY, nZ]\n\n    @property\n    def tangents(self):\n        \"\"\"\n        Edge Tangents\n\n        :rtype: numpy.array (sum(nE), dim)\n        :return: normals\n        \"\"\"\n        if self.dim == 2:\n            tX = np.c_[np.ones(self.nEx), np.zeros(self.nEx)]\n            tY = np.c_[np.zeros(self.nEy), np.ones(self.nEy)]\n            return np.r_[tX, tY]\n        elif self.dim == 3:\n            tX = np.c_[np.ones(self.nEx), np.zeros(self.nEx), np.zeros(self.nEx)]\n            tY = np.c_[np.zeros(self.nEy), np.ones(self.nEy), np.zeros(self.nEy)]\n            tZ = np.c_[np.zeros(self.nEz), np.zeros(self.nEz), np.ones(self.nEz)]\n            return np.r_[tX, tY, tZ]\n\n    def projectFaceVector(self, fV):\n        \"\"\"\n        Given a vector, fV, in cartesian coordinates, this will project it onto the mesh using the normals\n\n        :param numpy.array fV: face vector with shape (nF, dim)\n        :rtype: numpy.array with shape (nF, )\n        :return: projected face vector\n        \"\"\"\n        assert isinstance(fV, np.ndarray), 'fV must be an ndarray'\n        assert len(fV.shape) == 2 and fV.shape[0] == self.nF and fV.shape[1] == self.dim, 'fV must be an ndarray of shape (nF x dim)'\n        return np.sum(fV*self.normals, 1)\n\n    def projectEdgeVector(self, eV):\n        \"\"\"\n        Given a vector, eV, in cartesian coordinates, this will project it onto the mesh using the tangents\n\n        :param numpy.array eV: edge vector with shape (nE, dim)\n        :rtype: numpy.array with shape (nE, )\n        :return: projected edge vector\n        \"\"\"\n        assert isinstance(eV, np.ndarray), 'eV must be an ndarray'\n        assert len(eV.shape) == 2 and eV.shape[0] == self.nE and eV.shape[1] == self.dim, 'eV must be an ndarray of shape (nE x dim)'\n        return np.sum(eV*self.tangents, 1)",
  "class BaseRectangularMesh(BaseMesh):\n    \"\"\"BaseRectangularMesh\"\"\"\n    def __init__(self, n, x0=None):\n        BaseMesh.__init__(self, n, x0)\n\n    @property\n    def nCx(self):\n        \"\"\"\n        Number of cells in the x direction\n\n        :rtype: int\n        :return: nCx\n        \"\"\"\n        return self._n[0]\n\n    @property\n    def nCy(self):\n        \"\"\"\n        Number of cells in the y direction\n\n        :rtype: int\n        :return: nCy or None if dim < 2\n        \"\"\"\n        return None if self.dim < 2 else self._n[1]\n\n    @property\n    def nCz(self):\n        \"\"\"Number of cells in the z direction\n\n        :rtype: int\n        :return: nCz or None if dim < 3\n        \"\"\"\n        return None if self.dim < 3 else self._n[2]\n\n    @property\n    def vnC(self):\n        \"\"\"\n        Total number of cells in each direction\n\n        :rtype: numpy.array (dim, )\n        :return: [nCx, nCy, nCz]\n        \"\"\"\n        return np.array([x for x in [self.nCx, self.nCy, self.nCz] if not x is None])\n\n    @property\n    def nNx(self):\n        \"\"\"\n        Number of nodes in the x-direction\n\n        :rtype: int\n        :return: nNx\n        \"\"\"\n        return self.nCx + 1\n\n    @property\n    def nNy(self):\n        \"\"\"\n        Number of nodes in the y-direction\n\n        :rtype: int\n        :return: nNy or None if dim < 2\n        \"\"\"\n        return None if self.dim < 2 else self.nCy + 1\n\n    @property\n    def nNz(self):\n        \"\"\"\n        Number of nodes in the z-direction\n\n        :rtype: int\n        :return: nNz or None if dim < 3\n        \"\"\"\n        return None if self.dim < 3 else self.nCz + 1\n\n    @property\n    def vnN(self):\n        \"\"\"\n        Total number of nodes in each direction\n\n        :rtype: numpy.array (dim, )\n        :return: [nNx, nNy, nNz]\n        \"\"\"\n        return np.array([x for x in [self.nNx, self.nNy, self.nNz] if not x is None])\n\n    @property\n    def vnEx(self):\n        \"\"\"\n        Number of x-edges in each direction\n\n        :rtype: numpy.array (dim, )\n        :return: vnEx\n        \"\"\"\n        return np.array([x for x in [self.nCx, self.nNy, self.nNz] if not x is None])\n\n    @property\n    def vnEy(self):\n        \"\"\"\n        Number of y-edges in each direction\n\n        :rtype: numpy.array (dim, )\n        :return: vnEy or None if dim < 2\n        \"\"\"\n        return None if self.dim < 2 else np.array([x for x in [self.nNx, self.nCy, self.nNz] if not x is None])\n\n    @property\n    def vnEz(self):\n        \"\"\"\n        Number of z-edges in each direction\n\n        :rtype: numpy.array (dim, )\n        :return: vnEz or None if dim < 3\n        \"\"\"\n        return None if self.dim < 3 else np.array([x for x in [self.nNx, self.nNy, self.nCz] if not x is None])\n\n    @property\n    def vnFx(self):\n        \"\"\"\n        Number of x-faces in each direction\n\n        :rtype: numpy.array (dim, )\n        :return: vnFx\n        \"\"\"\n        return np.array([x for x in [self.nNx, self.nCy, self.nCz] if not x is None])\n\n    @property\n    def vnFy(self):\n        \"\"\"\n        Number of y-faces in each direction\n\n        :rtype: numpy.array (dim, )\n        :return: vnFy or None if dim < 2\n        \"\"\"\n        return None if self.dim < 2 else np.array([x for x in [self.nCx, self.nNy, self.nCz] if not x is None])\n\n    @property\n    def vnFz(self):\n        \"\"\"\n        Number of z-faces in each direction\n\n        :rtype: numpy.array (dim, )\n        :return: vnFz or None if dim < 3\n        \"\"\"\n        return None if self.dim < 3 else np.array([x for x in [self.nCx, self.nCy, self.nNz] if not x is None])\n\n    ##################################\n    # Redo the numbering so they are dependent of the vector numbers\n    ##################################\n\n    @property\n    def nC(self):\n        \"\"\"\n        Total number of cells\n\n        :rtype: int\n        :return: nC\n        \"\"\"\n        return self.vnC.prod()\n\n    @property\n    def nN(self):\n        \"\"\"\n        Total number of nodes\n\n        :rtype: int\n        :return: nN\n        \"\"\"\n        return self.vnN.prod()\n\n    @property\n    def nEx(self):\n        \"\"\"\n        Number of x-edges\n\n        :rtype: int\n        :return: nEx\n        \"\"\"\n        return self.vnEx.prod()\n\n    @property\n    def nEy(self):\n        \"\"\"\n        Number of y-edges\n\n        :rtype: int\n        :return: nEy\n        \"\"\"\n        if self.dim < 2: return\n        return self.vnEy.prod()\n\n    @property\n    def nEz(self):\n        \"\"\"\n        Number of z-edges\n\n        :rtype: int\n        :return: nEz\n        \"\"\"\n        if self.dim < 3: return\n        return self.vnEz.prod()\n\n    @property\n    def nFx(self):\n        \"\"\"\n        Number of x-faces\n\n        :rtype: int\n        :return: nFx\n        \"\"\"\n        return self.vnFx.prod()\n\n    @property\n    def nFy(self):\n        \"\"\"\n        Number of y-faces\n\n        :rtype: int\n        :return: nFy\n        \"\"\"\n        if self.dim < 2: return\n        return self.vnFy.prod()\n\n    @property\n    def nFz(self):\n        \"\"\"\n        Number of z-faces\n\n        :rtype: int\n        :return: nFz\n        \"\"\"\n        if self.dim < 3: return\n        return self.vnFz.prod()\n\n    def r(self, x, xType='CC', outType='CC', format='V'):\n        \"\"\"\n        Mesh.r is a quick reshape command that will do the best it can at giving you what you want.\n\n        For example, you have a face variable, and you want the x component of it reshaped to a 3D matrix.\n\n        Mesh.r can fulfil your dreams::\n\n            mesh.r(V, 'F', 'Fx', 'M')\n                   |   |     |    { How: 'M' or ['V'] for a matrix (ndgrid style) or a vector (n x dim) }\n                   |   |     { What you want: ['CC'], 'N', 'F', 'Fx', 'Fy', 'Fz', 'E', 'Ex', 'Ey', or 'Ez' }\n                   |   { What is it: ['CC'], 'N', 'F', 'Fx', 'Fy', 'Fz', 'E', 'Ex', 'Ey', or 'Ez' }\n                   { The input: as a list or ndarray }\n\n\n        For example::\n\n            Xex, Yex, Zex = r(mesh.gridEx, 'Ex', 'Ex', 'M')  # Separates each component of the Ex grid into 3 matrices\n\n            XedgeVector = r(edgeVector, 'E', 'Ex', 'V')  # Given an edge vector, this will return just the part on the x edges as a vector\n\n            eX, eY, eZ = r(edgeVector, 'E', 'E', 'V')  # Separates each component of the edgeVector into 3 vectors\n        \"\"\"\n\n        assert (type(x) == list or isinstance(x, np.ndarray)), \"x must be either a list or a ndarray\"\n        assert xType in ['CC', 'N', 'F', 'Fx', 'Fy', 'Fz', 'E', 'Ex', 'Ey', 'Ez'], \"xType must be either 'CC', 'N', 'F', 'Fx', 'Fy', 'Fz', 'E', 'Ex', 'Ey', or 'Ez'\"\n        assert outType in ['CC', 'N', 'F', 'Fx', 'Fy', 'Fz', 'E', 'Ex', 'Ey', 'Ez'], \"outType must be either 'CC', 'N', 'F', Fx', 'Fy', 'Fz', 'E', 'Ex', 'Ey', or 'Ez'\"\n        assert format in ['M', 'V'], \"format must be either 'M' or 'V'\"\n        assert outType[:len(xType)] == xType, \"You cannot change types when reshaping.\"\n        assert xType in outType, 'You cannot change type of components.'\n        if type(x) == list:\n            for i, xi in enumerate(x):\n                assert isinstance(x, np.ndarray), \"x[%i] must be a numpy array\" % i\n                assert xi.size == x[0].size, \"Number of elements in list must not change.\"\n\n            x_array = np.ones((x.size, len(x)))\n            # Unwrap it and put it in a np array\n            for i, xi in enumerate(x):\n                x_array[:, i] = Utils.mkvc(xi)\n            x = x_array\n\n        assert isinstance(x, np.ndarray), \"x must be a numpy array\"\n\n        x = x[:]  # make a copy.\n        xTypeIsFExyz = len(xType) > 1 and xType[0] in ['F', 'E'] and xType[1] in ['x', 'y', 'z']\n\n        def outKernal(xx, nn):\n            \"\"\"Returns xx as either a matrix (shape == nn) or a vector.\"\"\"\n            if format == 'M':\n                return xx.reshape(nn, order='F')\n            elif format == 'V':\n                return Utils.mkvc(xx)\n\n        def switchKernal(xx):\n            \"\"\"Switches over the different options.\"\"\"\n            if xType in ['CC', 'N']:\n                nn = (self._n) if xType == 'CC' else (self._n+1)\n                assert xx.size == np.prod(nn), \"Number of elements must not change.\"\n                return outKernal(xx, nn)\n            elif xType in ['F', 'E']:\n                # This will only deal with components of fields, not full 'F' or 'E'\n                xx = Utils.mkvc(xx)  # unwrap it in case it is a matrix\n                nn = self.vnF if xType == 'F' else self.vnE\n                nn = np.r_[0, nn]\n\n                nx = [0, 0, 0]\n                nx[0] = self.vnFx if xType == 'F' else self.vnEx\n                nx[1] = self.vnFy if xType == 'F' else self.vnEy\n                nx[2] = self.vnFz if xType == 'F' else self.vnEz\n\n                for dim, dimName in enumerate(['x', 'y', 'z']):\n                    if dimName in outType:\n                        assert self.dim > dim, (\"Dimensions of mesh not great enough for %s%s\", (xType, dimName))\n                        assert xx.size == np.sum(nn), 'Vector is not the right size.'\n                        start = np.sum(nn[:dim+1])\n                        end = np.sum(nn[:dim+2])\n                        return outKernal(xx[start:end], nx[dim])\n            elif xTypeIsFExyz:\n                # This will deal with partial components (x, y or z) lying on edges or faces\n                if 'x' in xType:\n                    nn = self.vnFx if 'F' in xType else self.vnEx\n                elif 'y' in xType:\n                    nn = self.vnFy if 'F' in xType else self.vnEy\n                elif 'z' in xType:\n                    nn = self.vnFz if 'F' in xType else self.vnEz\n                assert xx.size == np.prod(nn), 'Vector is not the right size.'\n                return outKernal(xx, nn)\n\n        # Check if we are dealing with a vector quantity\n        isVectorQuantity = len(x.shape) == 2 and x.shape[1] == self.dim\n\n        if outType in ['F', 'E']:\n            assert ~isVectorQuantity, 'Not sure what to do with a vector vector quantity..'\n            outTypeCopy = outType\n            out = ()\n            for ii, dirName in enumerate(['x', 'y', 'z'][:self.dim]):\n                outType = outTypeCopy + dirName\n                out += (switchKernal(x),)\n            return out\n        elif isVectorQuantity:\n            out = ()\n            for ii in range(x.shape[1]):\n                out += (switchKernal(x[:, ii]),)\n            return out\n        else:\n            return switchKernal(x)",
  "def __init__(self, n, x0=None):\n\n        # Check inputs\n        if x0 is None:\n            x0 = np.zeros(len(n))\n\n        if not len(n) == len(x0):\n            raise Exception(\"Dimension mismatch. x0 != len(n)\")\n\n        if len(n) > 3:\n            raise Exception(\"Dimensions higher than 3 are not supported.\")\n\n        # Ensure x0 & n are 1D vectors\n        self._n = np.array(n, dtype=int).ravel()\n        self._x0 = np.array(x0, dtype=float).ravel()\n        self._dim = len(self._x0)",
  "def x0(self):\n        \"\"\"\n        Origin of the mesh\n\n        :rtype: numpy.array (dim, )\n        :return: x0\n        \"\"\"\n        return self._x0",
  "def dim(self):\n        \"\"\"\n        The dimension of the mesh (1, 2, or 3).\n\n        :rtype: int\n        :return: dim\n        \"\"\"\n        return self._dim",
  "def nC(self):\n        \"\"\"\n        Total number of cells in the mesh.\n\n        :rtype: int\n        :return: nC\n\n        .. plot::\n            :include-source:\n\n            from SimPEG import Mesh, np\n            Mesh.TensorMesh([np.ones(n) for n in [2,3]]).plotGrid(centers=True,showIt=True)\n        \"\"\"\n        return self._n.prod()",
  "def nN(self):\n        \"\"\"\n        Total number of nodes\n\n        :rtype: int\n        :return: nN\n\n        .. plot::\n            :include-source:\n\n            from SimPEG import Mesh, np\n            Mesh.TensorMesh([np.ones(n) for n in [2,3]]).plotGrid(nodes=True,showIt=True)\n        \"\"\"\n        return (self._n+1).prod()",
  "def nEx(self):\n        \"\"\"\n        Number of x-edges\n\n        :rtype: int\n        :return: nEx\n        \"\"\"\n        return (self._n + np.r_[0,1,1][:self.dim]).prod()",
  "def nEy(self):\n        \"\"\"\n        Number of y-edges\n\n        :rtype: int\n        :return: nEy\n        \"\"\"\n        return None if self.dim < 2 else (self._n + np.r_[1,0,1][:self.dim]).prod()",
  "def nEz(self):\n        \"\"\"\n        Number of z-edges\n\n        :rtype: int\n        :return: nEz\n        \"\"\"\n        return None if self.dim < 3 else (self._n + np.r_[1,1,0][:self.dim]).prod()",
  "def vnE(self):\n        \"\"\"\n        Total number of edges in each direction\n\n        :rtype: numpy.array (dim, )\n        :return: [nEx, nEy, nEz]\n\n        .. plot::\n            :include-source:\n\n            from SimPEG import Mesh, np\n            Mesh.TensorMesh([np.ones(n) for n in [2,3]]).plotGrid(edges=True,showIt=True)\n        \"\"\"\n        return np.array([x for x in [self.nEx, self.nEy, self.nEz] if not x is None])",
  "def nE(self):\n        \"\"\"\n        Total number of edges.\n\n        :rtype: int\n        :return: sum([nEx, nEy, nEz])\n\n        \"\"\"\n        return self.vnE.sum()",
  "def nFx(self):\n        \"\"\"\n        Number of x-faces\n\n        :rtype: int\n        :return: nFx\n        \"\"\"\n        return (self._n + np.r_[1,0,0][:self.dim]).prod()",
  "def nFy(self):\n        \"\"\"\n        Number of y-faces\n\n        :rtype: int\n        :return: nFy\n        \"\"\"\n        return None if self.dim < 2 else (self._n + np.r_[0,1,0][:self.dim]).prod()",
  "def nFz(self):\n        \"\"\"\n        Number of z-faces\n\n        :rtype: int\n        :return: nFz\n        \"\"\"\n        return None if self.dim < 3 else (self._n + np.r_[0,0,1][:self.dim]).prod()",
  "def vnF(self):\n        \"\"\"\n        Total number of faces in each direction\n\n        :rtype: numpy.array (dim, )\n        :return: [nFx, nFy, nFz]\n\n        .. plot::\n            :include-source:\n\n            from SimPEG import Mesh, np\n            Mesh.TensorMesh([np.ones(n) for n in [2,3]]).plotGrid(faces=True,showIt=True)\n        \"\"\"\n        return np.array([x for x in [self.nFx, self.nFy, self.nFz] if not x is None])",
  "def nF(self):\n        \"\"\"\n        Total number of faces.\n\n        :rtype: int\n        :return: sum([nFx, nFy, nFz])\n\n        \"\"\"\n        return self.vnF.sum()",
  "def normals(self):\n        \"\"\"\n        Face Normals\n\n        :rtype: numpy.array (sum(nF), dim)\n        :return: normals\n        \"\"\"\n        if self.dim == 2:\n            nX = np.c_[np.ones(self.nFx), np.zeros(self.nFx)]\n            nY = np.c_[np.zeros(self.nFy), np.ones(self.nFy)]\n            return np.r_[nX, nY]\n        elif self.dim == 3:\n            nX = np.c_[np.ones(self.nFx), np.zeros(self.nFx), np.zeros(self.nFx)]\n            nY = np.c_[np.zeros(self.nFy), np.ones(self.nFy), np.zeros(self.nFy)]\n            nZ = np.c_[np.zeros(self.nFz), np.zeros(self.nFz), np.ones(self.nFz)]\n            return np.r_[nX, nY, nZ]",
  "def tangents(self):\n        \"\"\"\n        Edge Tangents\n\n        :rtype: numpy.array (sum(nE), dim)\n        :return: normals\n        \"\"\"\n        if self.dim == 2:\n            tX = np.c_[np.ones(self.nEx), np.zeros(self.nEx)]\n            tY = np.c_[np.zeros(self.nEy), np.ones(self.nEy)]\n            return np.r_[tX, tY]\n        elif self.dim == 3:\n            tX = np.c_[np.ones(self.nEx), np.zeros(self.nEx), np.zeros(self.nEx)]\n            tY = np.c_[np.zeros(self.nEy), np.ones(self.nEy), np.zeros(self.nEy)]\n            tZ = np.c_[np.zeros(self.nEz), np.zeros(self.nEz), np.ones(self.nEz)]\n            return np.r_[tX, tY, tZ]",
  "def projectFaceVector(self, fV):\n        \"\"\"\n        Given a vector, fV, in cartesian coordinates, this will project it onto the mesh using the normals\n\n        :param numpy.array fV: face vector with shape (nF, dim)\n        :rtype: numpy.array with shape (nF, )\n        :return: projected face vector\n        \"\"\"\n        assert isinstance(fV, np.ndarray), 'fV must be an ndarray'\n        assert len(fV.shape) == 2 and fV.shape[0] == self.nF and fV.shape[1] == self.dim, 'fV must be an ndarray of shape (nF x dim)'\n        return np.sum(fV*self.normals, 1)",
  "def projectEdgeVector(self, eV):\n        \"\"\"\n        Given a vector, eV, in cartesian coordinates, this will project it onto the mesh using the tangents\n\n        :param numpy.array eV: edge vector with shape (nE, dim)\n        :rtype: numpy.array with shape (nE, )\n        :return: projected edge vector\n        \"\"\"\n        assert isinstance(eV, np.ndarray), 'eV must be an ndarray'\n        assert len(eV.shape) == 2 and eV.shape[0] == self.nE and eV.shape[1] == self.dim, 'eV must be an ndarray of shape (nE x dim)'\n        return np.sum(eV*self.tangents, 1)",
  "def __init__(self, n, x0=None):\n        BaseMesh.__init__(self, n, x0)",
  "def nCx(self):\n        \"\"\"\n        Number of cells in the x direction\n\n        :rtype: int\n        :return: nCx\n        \"\"\"\n        return self._n[0]",
  "def nCy(self):\n        \"\"\"\n        Number of cells in the y direction\n\n        :rtype: int\n        :return: nCy or None if dim < 2\n        \"\"\"\n        return None if self.dim < 2 else self._n[1]",
  "def nCz(self):\n        \"\"\"Number of cells in the z direction\n\n        :rtype: int\n        :return: nCz or None if dim < 3\n        \"\"\"\n        return None if self.dim < 3 else self._n[2]",
  "def vnC(self):\n        \"\"\"\n        Total number of cells in each direction\n\n        :rtype: numpy.array (dim, )\n        :return: [nCx, nCy, nCz]\n        \"\"\"\n        return np.array([x for x in [self.nCx, self.nCy, self.nCz] if not x is None])",
  "def nNx(self):\n        \"\"\"\n        Number of nodes in the x-direction\n\n        :rtype: int\n        :return: nNx\n        \"\"\"\n        return self.nCx + 1",
  "def nNy(self):\n        \"\"\"\n        Number of nodes in the y-direction\n\n        :rtype: int\n        :return: nNy or None if dim < 2\n        \"\"\"\n        return None if self.dim < 2 else self.nCy + 1",
  "def nNz(self):\n        \"\"\"\n        Number of nodes in the z-direction\n\n        :rtype: int\n        :return: nNz or None if dim < 3\n        \"\"\"\n        return None if self.dim < 3 else self.nCz + 1",
  "def vnN(self):\n        \"\"\"\n        Total number of nodes in each direction\n\n        :rtype: numpy.array (dim, )\n        :return: [nNx, nNy, nNz]\n        \"\"\"\n        return np.array([x for x in [self.nNx, self.nNy, self.nNz] if not x is None])",
  "def vnEx(self):\n        \"\"\"\n        Number of x-edges in each direction\n\n        :rtype: numpy.array (dim, )\n        :return: vnEx\n        \"\"\"\n        return np.array([x for x in [self.nCx, self.nNy, self.nNz] if not x is None])",
  "def vnEy(self):\n        \"\"\"\n        Number of y-edges in each direction\n\n        :rtype: numpy.array (dim, )\n        :return: vnEy or None if dim < 2\n        \"\"\"\n        return None if self.dim < 2 else np.array([x for x in [self.nNx, self.nCy, self.nNz] if not x is None])",
  "def vnEz(self):\n        \"\"\"\n        Number of z-edges in each direction\n\n        :rtype: numpy.array (dim, )\n        :return: vnEz or None if dim < 3\n        \"\"\"\n        return None if self.dim < 3 else np.array([x for x in [self.nNx, self.nNy, self.nCz] if not x is None])",
  "def vnFx(self):\n        \"\"\"\n        Number of x-faces in each direction\n\n        :rtype: numpy.array (dim, )\n        :return: vnFx\n        \"\"\"\n        return np.array([x for x in [self.nNx, self.nCy, self.nCz] if not x is None])",
  "def vnFy(self):\n        \"\"\"\n        Number of y-faces in each direction\n\n        :rtype: numpy.array (dim, )\n        :return: vnFy or None if dim < 2\n        \"\"\"\n        return None if self.dim < 2 else np.array([x for x in [self.nCx, self.nNy, self.nCz] if not x is None])",
  "def vnFz(self):\n        \"\"\"\n        Number of z-faces in each direction\n\n        :rtype: numpy.array (dim, )\n        :return: vnFz or None if dim < 3\n        \"\"\"\n        return None if self.dim < 3 else np.array([x for x in [self.nCx, self.nCy, self.nNz] if not x is None])",
  "def nC(self):\n        \"\"\"\n        Total number of cells\n\n        :rtype: int\n        :return: nC\n        \"\"\"\n        return self.vnC.prod()",
  "def nN(self):\n        \"\"\"\n        Total number of nodes\n\n        :rtype: int\n        :return: nN\n        \"\"\"\n        return self.vnN.prod()",
  "def nEx(self):\n        \"\"\"\n        Number of x-edges\n\n        :rtype: int\n        :return: nEx\n        \"\"\"\n        return self.vnEx.prod()",
  "def nEy(self):\n        \"\"\"\n        Number of y-edges\n\n        :rtype: int\n        :return: nEy\n        \"\"\"\n        if self.dim < 2: return\n        return self.vnEy.prod()",
  "def nEz(self):\n        \"\"\"\n        Number of z-edges\n\n        :rtype: int\n        :return: nEz\n        \"\"\"\n        if self.dim < 3: return\n        return self.vnEz.prod()",
  "def nFx(self):\n        \"\"\"\n        Number of x-faces\n\n        :rtype: int\n        :return: nFx\n        \"\"\"\n        return self.vnFx.prod()",
  "def nFy(self):\n        \"\"\"\n        Number of y-faces\n\n        :rtype: int\n        :return: nFy\n        \"\"\"\n        if self.dim < 2: return\n        return self.vnFy.prod()",
  "def nFz(self):\n        \"\"\"\n        Number of z-faces\n\n        :rtype: int\n        :return: nFz\n        \"\"\"\n        if self.dim < 3: return\n        return self.vnFz.prod()",
  "def r(self, x, xType='CC', outType='CC', format='V'):\n        \"\"\"\n        Mesh.r is a quick reshape command that will do the best it can at giving you what you want.\n\n        For example, you have a face variable, and you want the x component of it reshaped to a 3D matrix.\n\n        Mesh.r can fulfil your dreams::\n\n            mesh.r(V, 'F', 'Fx', 'M')\n                   |   |     |    { How: 'M' or ['V'] for a matrix (ndgrid style) or a vector (n x dim) }\n                   |   |     { What you want: ['CC'], 'N', 'F', 'Fx', 'Fy', 'Fz', 'E', 'Ex', 'Ey', or 'Ez' }\n                   |   { What is it: ['CC'], 'N', 'F', 'Fx', 'Fy', 'Fz', 'E', 'Ex', 'Ey', or 'Ez' }\n                   { The input: as a list or ndarray }\n\n\n        For example::\n\n            Xex, Yex, Zex = r(mesh.gridEx, 'Ex', 'Ex', 'M')  # Separates each component of the Ex grid into 3 matrices\n\n            XedgeVector = r(edgeVector, 'E', 'Ex', 'V')  # Given an edge vector, this will return just the part on the x edges as a vector\n\n            eX, eY, eZ = r(edgeVector, 'E', 'E', 'V')  # Separates each component of the edgeVector into 3 vectors\n        \"\"\"\n\n        assert (type(x) == list or isinstance(x, np.ndarray)), \"x must be either a list or a ndarray\"\n        assert xType in ['CC', 'N', 'F', 'Fx', 'Fy', 'Fz', 'E', 'Ex', 'Ey', 'Ez'], \"xType must be either 'CC', 'N', 'F', 'Fx', 'Fy', 'Fz', 'E', 'Ex', 'Ey', or 'Ez'\"\n        assert outType in ['CC', 'N', 'F', 'Fx', 'Fy', 'Fz', 'E', 'Ex', 'Ey', 'Ez'], \"outType must be either 'CC', 'N', 'F', Fx', 'Fy', 'Fz', 'E', 'Ex', 'Ey', or 'Ez'\"\n        assert format in ['M', 'V'], \"format must be either 'M' or 'V'\"\n        assert outType[:len(xType)] == xType, \"You cannot change types when reshaping.\"\n        assert xType in outType, 'You cannot change type of components.'\n        if type(x) == list:\n            for i, xi in enumerate(x):\n                assert isinstance(x, np.ndarray), \"x[%i] must be a numpy array\" % i\n                assert xi.size == x[0].size, \"Number of elements in list must not change.\"\n\n            x_array = np.ones((x.size, len(x)))\n            # Unwrap it and put it in a np array\n            for i, xi in enumerate(x):\n                x_array[:, i] = Utils.mkvc(xi)\n            x = x_array\n\n        assert isinstance(x, np.ndarray), \"x must be a numpy array\"\n\n        x = x[:]  # make a copy.\n        xTypeIsFExyz = len(xType) > 1 and xType[0] in ['F', 'E'] and xType[1] in ['x', 'y', 'z']\n\n        def outKernal(xx, nn):\n            \"\"\"Returns xx as either a matrix (shape == nn) or a vector.\"\"\"\n            if format == 'M':\n                return xx.reshape(nn, order='F')\n            elif format == 'V':\n                return Utils.mkvc(xx)\n\n        def switchKernal(xx):\n            \"\"\"Switches over the different options.\"\"\"\n            if xType in ['CC', 'N']:\n                nn = (self._n) if xType == 'CC' else (self._n+1)\n                assert xx.size == np.prod(nn), \"Number of elements must not change.\"\n                return outKernal(xx, nn)\n            elif xType in ['F', 'E']:\n                # This will only deal with components of fields, not full 'F' or 'E'\n                xx = Utils.mkvc(xx)  # unwrap it in case it is a matrix\n                nn = self.vnF if xType == 'F' else self.vnE\n                nn = np.r_[0, nn]\n\n                nx = [0, 0, 0]\n                nx[0] = self.vnFx if xType == 'F' else self.vnEx\n                nx[1] = self.vnFy if xType == 'F' else self.vnEy\n                nx[2] = self.vnFz if xType == 'F' else self.vnEz\n\n                for dim, dimName in enumerate(['x', 'y', 'z']):\n                    if dimName in outType:\n                        assert self.dim > dim, (\"Dimensions of mesh not great enough for %s%s\", (xType, dimName))\n                        assert xx.size == np.sum(nn), 'Vector is not the right size.'\n                        start = np.sum(nn[:dim+1])\n                        end = np.sum(nn[:dim+2])\n                        return outKernal(xx[start:end], nx[dim])\n            elif xTypeIsFExyz:\n                # This will deal with partial components (x, y or z) lying on edges or faces\n                if 'x' in xType:\n                    nn = self.vnFx if 'F' in xType else self.vnEx\n                elif 'y' in xType:\n                    nn = self.vnFy if 'F' in xType else self.vnEy\n                elif 'z' in xType:\n                    nn = self.vnFz if 'F' in xType else self.vnEz\n                assert xx.size == np.prod(nn), 'Vector is not the right size.'\n                return outKernal(xx, nn)\n\n        # Check if we are dealing with a vector quantity\n        isVectorQuantity = len(x.shape) == 2 and x.shape[1] == self.dim\n\n        if outType in ['F', 'E']:\n            assert ~isVectorQuantity, 'Not sure what to do with a vector vector quantity..'\n            outTypeCopy = outType\n            out = ()\n            for ii, dirName in enumerate(['x', 'y', 'z'][:self.dim]):\n                outType = outTypeCopy + dirName\n                out += (switchKernal(x),)\n            return out\n        elif isVectorQuantity:\n            out = ()\n            for ii in range(x.shape[1]):\n                out += (switchKernal(x[:, ii]),)\n            return out\n        else:\n            return switchKernal(x)",
  "def outKernal(xx, nn):\n            \"\"\"Returns xx as either a matrix (shape == nn) or a vector.\"\"\"\n            if format == 'M':\n                return xx.reshape(nn, order='F')\n            elif format == 'V':\n                return Utils.mkvc(xx)",
  "def switchKernal(xx):\n            \"\"\"Switches over the different options.\"\"\"\n            if xType in ['CC', 'N']:\n                nn = (self._n) if xType == 'CC' else (self._n+1)\n                assert xx.size == np.prod(nn), \"Number of elements must not change.\"\n                return outKernal(xx, nn)\n            elif xType in ['F', 'E']:\n                # This will only deal with components of fields, not full 'F' or 'E'\n                xx = Utils.mkvc(xx)  # unwrap it in case it is a matrix\n                nn = self.vnF if xType == 'F' else self.vnE\n                nn = np.r_[0, nn]\n\n                nx = [0, 0, 0]\n                nx[0] = self.vnFx if xType == 'F' else self.vnEx\n                nx[1] = self.vnFy if xType == 'F' else self.vnEy\n                nx[2] = self.vnFz if xType == 'F' else self.vnEz\n\n                for dim, dimName in enumerate(['x', 'y', 'z']):\n                    if dimName in outType:\n                        assert self.dim > dim, (\"Dimensions of mesh not great enough for %s%s\", (xType, dimName))\n                        assert xx.size == np.sum(nn), 'Vector is not the right size.'\n                        start = np.sum(nn[:dim+1])\n                        end = np.sum(nn[:dim+2])\n                        return outKernal(xx[start:end], nx[dim])\n            elif xTypeIsFExyz:\n                # This will deal with partial components (x, y or z) lying on edges or faces\n                if 'x' in xType:\n                    nn = self.vnFx if 'F' in xType else self.vnEx\n                elif 'y' in xType:\n                    nn = self.vnFy if 'F' in xType else self.vnEy\n                elif 'z' in xType:\n                    nn = self.vnFz if 'F' in xType else self.vnEz\n                assert xx.size == np.prod(nn), 'Vector is not the right size.'\n                return outKernal(xx, nn)",
  "class TensorView(object):\n    \"\"\"\n    Provides viewing functions for TensorMesh\n\n    This class is inherited by TensorMesh\n    \"\"\"\n    def __init__(self):\n        pass\n\n    # def components(self):\n\n    #     plotAll = len(imageType) == 1\n    #     options = {\"direction\":direction,\"numbering\":numbering,\"annotationColor\":annotationColor,\"showIt\":False}\n    #     fig = plt.figure(figNum)\n    #     # Determine the subplot number: 131, 121\n    #     numPlots = 130 if plotAll else len(imageType)/2*10+100\n    #     pltNum = 1\n    #     fxyz = self.r(I,'F','F','M')\n    #     if plotAll or 'Fx' in imageType:\n    #         ax_x = plt.subplot(numPlots+pltNum)\n    #         self.plotImage(fxyz[0], imageType='Fx', ax=ax_x, **options)\n    #         pltNum +=1\n    #     if plotAll or 'Fy' in imageType:\n    #         ax_y = plt.subplot(numPlots+pltNum)\n    #         self.plotImage(fxyz[1], imageType='Fy', ax=ax_y, **options)\n    #         pltNum +=1\n    #     if plotAll or 'Fz' in imageType:\n    #         ax_z = plt.subplot(numPlots+pltNum)\n    #         self.plotImage(fxyz[2], imageType='Fz', ax=ax_z, **options)\n    #         pltNum +=1\n    #     if showIt: plt.show()\n\n    def plotImage(self, v, vType='CC', grid=False, view='real',\n              ax=None, clim=None, showIt=False,\n              pcolorOpts={},\n              streamOpts={'color':'k'},\n              gridOpts={'color':'k'},\n              numbering=True, annotationColor='w'\n              ):\n        \"\"\"\n        Mesh.plotImage(v)\n\n        Plots scalar fields on the given mesh.\n\n        Input:\n\n        :param numpy.array v: vector\n\n        Optional Inputs:\n\n        :param str vType: type of vector ('CC','N','F','Fx','Fy','Fz','E','Ex','Ey','Ez')\n        :param matplotlib.axes.Axes ax: axis to plot to\n        :param bool showIt: call plt.show()\n\n        3D Inputs:\n\n        :param bool numbering: show numbering of slices, 3D only\n        :param str annotationColor: color of annotation, e.g. 'w', 'k', 'b'\n\n        .. plot::\n            :include-source:\n\n            from SimPEG import Mesh, np\n            M = Mesh.TensorMesh([20, 20])\n            v = np.sin(M.gridCC[:,0]*2*np.pi)*np.sin(M.gridCC[:,1]*2*np.pi)\n            M.plotImage(v, showIt=True)\n\n        .. plot::\n            :include-source:\n\n            from SimPEG import Mesh, np\n            M = Mesh.TensorMesh([20,20,20])\n            v = np.sin(M.gridCC[:,0]*2*np.pi)*np.sin(M.gridCC[:,1]*2*np.pi)*np.sin(M.gridCC[:,2]*2*np.pi)\n            M.plotImage(v, annotationColor='k', showIt=True)\n\n        \"\"\"\n\n        if ax is None:\n            fig = plt.figure()\n            ax = plt.subplot(111)\n        else:\n            assert isinstance(ax,matplotlib.axes.Axes), \"ax must be an Axes!\"\n            fig = ax.figure\n\n        if self.dim == 1:\n            if vType == 'CC':\n                ph = ax.plot(self.vectorCCx, v, '-ro')\n            elif vType == 'N':\n                ph = ax.plot(self.vectorNx, v, '-bs')\n            ax.set_xlabel(\"x\")\n            ax.axis('tight')\n        elif self.dim == 2:\n            return self._plotImage2D(v, vType=vType, grid=grid, view=view,\n                                     ax=ax, clim=clim, showIt=showIt,\n                                     pcolorOpts=pcolorOpts, streamOpts=streamOpts,\n                                     gridOpts=gridOpts)\n        elif self.dim == 3:\n            # get copy of image and average to cell-centers is necessary\n            if vType == 'CC':\n                vc = v.reshape(self.vnC, order='F')\n            elif vType == 'N':\n                vc = (self.aveN2CC*v).reshape(self.vnC, order='F')\n            elif vType in ['Fx', 'Fy', 'Fz', 'Ex', 'Ey', 'Ez']:\n                aveOp = 'ave' + vType[0] + '2CCV'\n                # n = getattr(self,'vn'+vType[0])\n                # if 'x' in vType: v = np.r_[v,np.zeros(n[1]),np.zeros(n[2])]\n                # if 'y' in vType: v = np.r_[np.zeros(n[0]),v,np.zeros(n[2])]\n                # if 'z' in vType: v = np.r_[np.zeros(n[0]),np.zeros(n[1]),v]\n                v = getattr(self,aveOp)*v # average to cell centers\n                ind_xyz = {'x':0,'y':1,'z':2}[vType[1]]\n                vc = self.r(v.reshape((self.nC,-1),order='F'), 'CC','CC','M')[ind_xyz]\n\n            # determine number oE slices in x and y dimension\n            nX = np.ceil(np.sqrt(self.nCz))\n            nY = np.ceil(self.nCz/nX)\n\n            #  allocate space for montage\n            nCx = self.nCx\n            nCy = self.nCy\n\n            C = np.zeros((nX*nCx,nY*nCy))\n\n            for iy in range(int(nY)):\n                for ix in range(int(nX)):\n                    iz = ix + iy*nX\n                    if iz < self.nCz:\n                        C[ix*nCx:(ix+1)*nCx, iy*nCy:(iy+1)*nCy] = vc[:, :, iz]\n                    else:\n                        C[ix*nCx:(ix+1)*nCx, iy*nCy:(iy+1)*nCy] = np.nan\n\n            C = np.ma.masked_where(np.isnan(C), C)\n            xx = np.r_[0, np.cumsum(np.kron(np.ones((nX, 1)), self.hx).ravel())]\n            yy = np.r_[0, np.cumsum(np.kron(np.ones((nY, 1)), self.hy).ravel())]\n            # Plot the mesh\n\n            if clim is None:\n                clim = [C.min(),C.max()]\n            ph = ax.pcolormesh(xx, yy, C.T, vmin=clim[0], vmax=clim[1])\n            # Plot the lines\n            gx =  np.arange(nX+1)*(self.vectorNx[-1]-self.x0[0])\n            gy =  np.arange(nY+1)*(self.vectorNy[-1]-self.x0[1])\n            # Repeat and seperate with NaN\n            gxX = np.c_[gx, gx, gx+np.nan].ravel()\n            gxY = np.kron(np.ones((nX+1, 1)), np.array([0, sum(self.hy)*nY, np.nan])).ravel()\n            gyX = np.kron(np.ones((nY+1, 1)), np.array([0, sum(self.hx)*nX, np.nan])).ravel()\n            gyY = np.c_[gy, gy, gy+np.nan].ravel()\n            ax.plot(gxX, gxY, annotationColor+'-', linewidth=2)\n            ax.plot(gyX, gyY, annotationColor+'-', linewidth=2)\n            ax.axis('tight')\n\n            if numbering:\n                pad = np.sum(self.hx)*0.04\n                for iy in range(int(nY)):\n                    for ix in range(int(nX)):\n                        iz = ix + iy*nX\n                        if iz < self.nCz:\n                            ax.text((ix+1)*(self.vectorNx[-1]-self.x0[0])-pad,(iy)*(self.vectorNy[-1]-self.x0[1])+pad,\n                                     '#%i'%iz,color=annotationColor,verticalalignment='bottom',horizontalalignment='right',size='x-large')\n\n        ax.set_title(vType)\n        if showIt: plt.show()\n        return ph\n\n    def plotSlice(self, v, vType='CC',\n                  normal='Z', ind=None, grid=False, view='real',\n                  ax=None, clim=None, showIt=False,\n                  pcolorOpts={},\n                  streamOpts={'color':'k'},\n                  gridOpts={'color':'k', 'alpha':0.5}\n                  ):\n\n        \"\"\"\n        Plots a slice of a 3D mesh.\n\n        .. plot::\n\n            from SimPEG import *\n            hx = [(5,2,-1.3),(2,4),(5,2,1.3)]\n            hy = [(2,2,-1.3),(2,6),(2,2,1.3)]\n            hz = [(2,2,-1.3),(2,6),(2,2,1.3)]\n            M = Mesh.TensorMesh([hx,hy,hz])\n            q = np.zeros(M.vnC)\n            q[[4,4],[4,4],[2,6]]=[-1,1]\n            q = Utils.mkvc(q)\n            A = M.faceDiv*M.cellGrad\n            b = Solver(A) * (q)\n            M.plotSlice(M.cellGrad*b, 'F', view='vec', grid=True, showIt=True, pcolorOpts={'alpha':0.8})\n\n        \"\"\"\n        if type(vType) in [list, tuple]:\n            assert ax is None, \"cannot specify an axis to plot on with this function.\"\n            fig, axs = plt.subplots(1,len(vType))\n            out = []\n            for vTypeI, ax in zip(vType, axs):\n                out += [self.plotSlice(v,vType=vTypeI, normal=normal, ind=ind, grid=grid, view=view, ax=ax, clim=clim, showIt=False, pcolorOpts=pcolorOpts, streamOpts=streamOpts, gridOpts=gridOpts)]\n            return out\n        viewOpts = ['real','imag','abs','vec']\n        normalOpts = ['X', 'Y', 'Z']\n        vTypeOpts = ['CC', 'CCv','F','E','Fx','Fy','Fz','E','Ex','Ey','Ez']\n\n        # Some user error checking\n        assert vType in vTypeOpts, \"vType must be in ['%s']\" % \"','\".join(vTypeOpts)\n        assert self.dim == 3, 'Must be a 3D mesh. Use plotImage.'\n        assert view in viewOpts, \"view must be in ['%s']\" % \"','\".join(viewOpts)\n        assert normal in normalOpts, \"normal must be in ['%s']\" % \"','\".join(normalOpts)\n        assert type(grid) is bool, 'grid must be a boolean'\n\n        szSliceDim = getattr(self, 'nC'+normal.lower()) #: Size of the sliced dimension\n        if ind is None: ind = int(szSliceDim/2)\n        assert type(ind) in [int, long], 'ind must be an integer'\n\n        assert not (v.dtype == complex and view == 'vec'), 'Can not plot a complex vector.'\n        # The slicing and plotting code!!\n\n        def getIndSlice(v):\n            if   normal == 'X': v = v[ind,:,:]\n            elif normal == 'Y': v = v[:,ind,:]\n            elif normal == 'Z': v = v[:,:,ind]\n            return v\n\n        def doSlice(v):\n            if vType == 'CC':\n                return getIndSlice(self.r(v,'CC','CC','M'))\n            elif vType == 'CCv':\n                assert view == 'vec', 'Other types for CCv not supported'\n            else:\n                # Now just deal with 'F' and 'E' (x,y,z, maybe...)\n                aveOp = 'ave' + vType + ('2CCV' if view == 'vec' else '2CC')\n                Av = getattr(self,aveOp)\n                if v.size == Av.shape[1]:\n                    v = Av * v\n                else:\n                    v = self.r(v,vType[0],vType) # get specific component\n                    v = Av * v\n                # we should now be averaged to cell centers (might be a vector)\n            v = self.r(v.reshape((self.nC,-1),order='F'),'CC','CC','M')\n            if view == 'vec':\n                outSlice = []\n                if 'X' not in normal: outSlice.append(getIndSlice(v[0]))\n                if 'Y' not in normal: outSlice.append(getIndSlice(v[1]))\n                if 'Z' not in normal: outSlice.append(getIndSlice(v[2]))\n                return np.r_[mkvc(outSlice[0]), mkvc(outSlice[1])]\n            else:\n                return getIndSlice(self.r(v,'CC','CC','M'))\n\n        h2d = []\n        x2d = []\n        if 'X' not in normal:\n            h2d.append(self.hx)\n            x2d.append(self.x0[0])\n        if 'Y' not in normal:\n            h2d.append(self.hy)\n            x2d.append(self.x0[1])\n        if 'Z' not in normal:\n            h2d.append(self.hz)\n            x2d.append(self.x0[2])\n        tM = self.__class__(h2d, x2d) #: Temp Mesh\n        v2d = doSlice(v)\n\n\n        if ax is None:\n            fig = plt.figure()\n            ax = plt.subplot(111)\n        else:\n            assert isinstance(ax, matplotlib.axes.Axes), \"ax must be an matplotlib.axes.Axes\"\n            fig = ax.figure\n\n        out = tM._plotImage2D(v2d, vType=('CCv' if view == 'vec' else 'CC'), grid=grid, view=view,\n                        ax=ax, clim=clim, showIt=showIt,\n                        pcolorOpts=pcolorOpts, streamOpts=streamOpts,\n                        gridOpts=gridOpts)\n\n\n        ax.set_xlabel('y' if normal == 'X' else 'x')\n        ax.set_ylabel('y' if normal == 'Z' else 'z')\n        ax.set_title('Slice %d' % ind)\n        return out\n\n\n    def _plotImage2D(self, v, vType='CC', grid=False, view='real',\n              ax=None, clim=None, showIt=False,\n              pcolorOpts={},\n              streamOpts={'color':'k'},\n              gridOpts={'color':'k'}\n              ):\n\n        vTypeOptsCC = ['N','CC','Fx','Fy','Ex','Ey']\n        vTypeOptsV = ['CCv','F','E']\n        vTypeOpts = vTypeOptsCC + vTypeOptsV\n        if view == 'vec':\n            assert vType in vTypeOptsV, \"vType must be in ['%s'] when view='vec'\" % \"','\".join(vTypeOptsV)\n        assert vType in vTypeOpts, \"vType must be in ['%s']\" % \"','\".join(vTypeOpts)\n\n        viewOpts = ['real','imag','abs','vec']\n        assert view in viewOpts, \"view must be in ['%s']\" % \"','\".join(viewOpts)\n\n\n        if ax is None:\n            fig = plt.figure()\n            ax = plt.subplot(111)\n        else:\n            assert isinstance(ax, matplotlib.axes.Axes), \"ax must be an matplotlib.axes.Axes\"\n            fig = ax.figure\n\n        # Reshape to a cell centered variable\n        if vType == 'CC':\n            pass\n        elif vType == 'CCv':\n            assert view == 'vec', 'Other types for CCv not supported'\n        elif vType in ['F', 'E', 'N']:\n            aveOp = 'ave' + vType + ('2CCV' if view == 'vec' else '2CC')\n            v = getattr(self,aveOp)*v # average to cell centers (might be a vector)\n        elif vType in ['Fx','Fy','Ex','Ey']:\n            aveOp = 'ave' + vType[0] + '2CCV'\n            v = getattr(self,aveOp)*v # average to cell centers (might be a vector)\n            xORy = {'x':0,'y':1}[vType[1]]\n            v = v.reshape((self.nC,-1), order='F')[:,xORy]\n\n        out = ()\n        if view in ['real','imag','abs']:\n            v = self.r(v, 'CC', 'CC', 'M')\n            v = getattr(np,view)(v) # e.g. np.real(v)\n            if clim is None:\n                clim = [v.min(),v.max()]\n            v = np.ma.masked_where(np.isnan(v), v)\n            out += (ax.pcolormesh(self.vectorNx, self.vectorNy, v.T, vmin=clim[0], vmax=clim[1], **pcolorOpts),)\n        elif view in ['vec']:\n            U, V = self.r(v.reshape((self.nC,-1), order='F'), 'CC', 'CC', 'M')\n            if clim is None:\n                uv = np.sqrt(U**2 + V**2)\n                clim = [uv.min(),uv.max()]\n\n            # Matplotlib seems to not support irregular\n            # spaced vectors at the moment. So we will\n            # Interpolate down to a regular mesh at the\n            # smallest mesh size in this 2D slice.\n            nxi = int(self.hx.sum()/self.hx.min())\n            nyi = int(self.hy.sum()/self.hy.min())\n            tMi = self.__class__([np.ones(nxi)*self.hx.sum()/nxi,\n                                  np.ones(nyi)*self.hy.sum()/nyi], self.x0)\n            P = self.getInterpolationMat(tMi.gridCC,'CC',zerosOutside=True)\n            Ui = tMi.r(P*mkvc(U), 'CC', 'CC', 'M')\n            Vi = tMi.r(P*mkvc(V), 'CC', 'CC', 'M')\n            # End Interpolation\n\n            out += (ax.pcolormesh(self.vectorNx, self.vectorNy, np.sqrt(U**2+V**2).T, vmin=clim[0], vmax=clim[1], **pcolorOpts),)\n            out += (ax.streamplot(tMi.vectorCCx, tMi.vectorCCy, Ui.T, Vi.T, **streamOpts),)\n\n        if grid:\n            xXGrid = np.c_[self.vectorNx,self.vectorNx,np.nan*np.ones(self.nNx)].flatten()\n            xYGrid = np.c_[self.vectorNy[0]*np.ones(self.nNx),self.vectorNy[-1]*np.ones(self.nNx),np.nan*np.ones(self.nNx)].flatten()\n            yXGrid = np.c_[self.vectorNx[0]*np.ones(self.nNy),self.vectorNx[-1]*np.ones(self.nNy),np.nan*np.ones(self.nNy)].flatten()\n            yYGrid = np.c_[self.vectorNy,self.vectorNy,np.nan*np.ones(self.nNy)].flatten()\n            out += (ax.plot(np.r_[xXGrid,yXGrid],np.r_[xYGrid,yYGrid],**gridOpts)[0],)\n\n\n        ax.set_xlabel('x')\n        ax.set_ylabel('y')\n        ax.set_xlim(*self.vectorNx[[0,-1]])\n        ax.set_ylim(*self.vectorNy[[0,-1]])\n\n        if showIt: plt.show()\n        return out\n\n\n    def plotGrid(self, ax=None, nodes=False, faces=False, centers=False, edges=False, lines=True, showIt=False):\n        \"\"\"Plot the nodal, cell-centered and staggered grids for 1,2 and 3 dimensions.\n\n        :param bool nodes: plot nodes\n        :param bool faces: plot faces\n        :param bool centers: plot centers\n        :param bool edges: plot edges\n        :param bool lines: plot lines connecting nodes\n        :param bool showIt: call plt.show()\n\n        .. plot::\n           :include-source:\n\n           from SimPEG import Mesh, np\n           h1 = np.linspace(.1,.5,3)\n           h2 = np.linspace(.1,.5,5)\n           mesh = Mesh.TensorMesh([h1, h2])\n           mesh.plotGrid(nodes=True, faces=True, centers=True, lines=True, showIt=True)\n\n        .. plot::\n           :include-source:\n\n           from SimPEG import Mesh, np\n           h1 = np.linspace(.1,.5,3)\n           h2 = np.linspace(.1,.5,5)\n           h3 = np.linspace(.1,.5,3)\n           mesh = Mesh.TensorMesh([h1,h2,h3])\n           mesh.plotGrid(nodes=True, faces=True, centers=True, lines=True, showIt=True)\n\n        \"\"\"\n\n        axOpts = {'projection':'3d'} if self.dim == 3 else {}\n        if ax is None:\n            fig = plt.figure()\n            ax = plt.subplot(111, **axOpts)\n        else:\n            assert isinstance(ax, matplotlib.axes.Axes), \"ax must be an matplotlib.axes.Axes\"\n            fig = ax.figure\n\n        if self.dim == 1:\n            if nodes:\n                ax.plot(self.gridN, np.ones(self.nN), 'bs')\n            if centers:\n                ax.plot(self.gridCC, np.ones(self.nC), 'ro')\n            if lines:\n                ax.plot(self.gridN, np.ones(self.nN), 'b.-')\n            ax.set_xlabel('x1')\n        elif self.dim == 2:\n            if nodes:\n                ax.plot(self.gridN[:, 0], self.gridN[:, 1], 'bs')\n            if centers:\n                ax.plot(self.gridCC[:, 0], self.gridCC[:, 1], 'ro')\n            if faces:\n                ax.plot(self.gridFx[:, 0], self.gridFx[:, 1], 'g>')\n                ax.plot(self.gridFy[:, 0], self.gridFy[:, 1], 'g^')\n            if edges:\n                ax.plot(self.gridEx[:, 0], self.gridEx[:, 1], 'c>')\n                ax.plot(self.gridEy[:, 0], self.gridEy[:, 1], 'c^')\n\n            # Plot the grid lines\n            if lines:\n                NN = self.r(self.gridN, 'N', 'N', 'M')\n                X1 = np.c_[mkvc(NN[0][0, :]), mkvc(NN[0][self.nCx, :]), mkvc(NN[0][0, :])*np.nan].flatten()\n                Y1 = np.c_[mkvc(NN[1][0, :]), mkvc(NN[1][self.nCx, :]), mkvc(NN[1][0, :])*np.nan].flatten()\n                X2 = np.c_[mkvc(NN[0][:, 0]), mkvc(NN[0][:, self.nCy]), mkvc(NN[0][:, 0])*np.nan].flatten()\n                Y2 = np.c_[mkvc(NN[1][:, 0]), mkvc(NN[1][:, self.nCy]), mkvc(NN[1][:, 0])*np.nan].flatten()\n                X = np.r_[X1, X2]\n                Y = np.r_[Y1, Y2]\n                ax.plot(X, Y, 'b-')\n\n            ax.set_xlabel('x1')\n            ax.set_ylabel('x2')\n        elif self.dim == 3:\n            if nodes:\n                ax.plot(self.gridN[:, 0], self.gridN[:, 1], 'bs', zs=self.gridN[:, 2])\n            if centers:\n                ax.plot(self.gridCC[:, 0], self.gridCC[:, 1], 'ro', zs=self.gridCC[:, 2])\n            if faces:\n                ax.plot(self.gridFx[:, 0], self.gridFx[:, 1], 'g>', zs=self.gridFx[:, 2])\n                ax.plot(self.gridFy[:, 0], self.gridFy[:, 1], 'g<', zs=self.gridFy[:, 2])\n                ax.plot(self.gridFz[:, 0], self.gridFz[:, 1], 'g^', zs=self.gridFz[:, 2])\n            if edges:\n                ax.plot(self.gridEx[:, 0], self.gridEx[:, 1], 'k>', zs=self.gridEx[:, 2])\n                ax.plot(self.gridEy[:, 0], self.gridEy[:, 1], 'k<', zs=self.gridEy[:, 2])\n                ax.plot(self.gridEz[:, 0], self.gridEz[:, 1], 'k^', zs=self.gridEz[:, 2])\n\n            # Plot the grid lines\n            if lines:\n                NN = self.r(self.gridN, 'N', 'N', 'M')\n                X1 = np.c_[mkvc(NN[0][0, :, :]), mkvc(NN[0][self.nCx, :, :]), mkvc(NN[0][0, :, :])*np.nan].flatten()\n                Y1 = np.c_[mkvc(NN[1][0, :, :]), mkvc(NN[1][self.nCx, :, :]), mkvc(NN[1][0, :, :])*np.nan].flatten()\n                Z1 = np.c_[mkvc(NN[2][0, :, :]), mkvc(NN[2][self.nCx, :, :]), mkvc(NN[2][0, :, :])*np.nan].flatten()\n                X2 = np.c_[mkvc(NN[0][:, 0, :]), mkvc(NN[0][:, self.nCy, :]), mkvc(NN[0][:, 0, :])*np.nan].flatten()\n                Y2 = np.c_[mkvc(NN[1][:, 0, :]), mkvc(NN[1][:, self.nCy, :]), mkvc(NN[1][:, 0, :])*np.nan].flatten()\n                Z2 = np.c_[mkvc(NN[2][:, 0, :]), mkvc(NN[2][:, self.nCy, :]), mkvc(NN[2][:, 0, :])*np.nan].flatten()\n                X3 = np.c_[mkvc(NN[0][:, :, 0]), mkvc(NN[0][:, :, self.nCz]), mkvc(NN[0][:, :, 0])*np.nan].flatten()\n                Y3 = np.c_[mkvc(NN[1][:, :, 0]), mkvc(NN[1][:, :, self.nCz]), mkvc(NN[1][:, :, 0])*np.nan].flatten()\n                Z3 = np.c_[mkvc(NN[2][:, :, 0]), mkvc(NN[2][:, :, self.nCz]), mkvc(NN[2][:, :, 0])*np.nan].flatten()\n                X = np.r_[X1, X2, X3]\n                Y = np.r_[Y1, Y2, Y3]\n                Z = np.r_[Z1, Z2, Z3]\n                ax.plot(X, Y, 'b-', zs=Z)\n            ax.set_xlabel('x1')\n            ax.set_ylabel('x2')\n            ax.set_zlabel('x3')\n\n        ax.grid(True)\n        if showIt: plt.show()\n\n    def slicer(mesh, var, imageType='CC', normal='z', index=0, ax=None, clim=None):\n        assert normal in 'xyz', 'normal must be x, y, or z'\n        if ax is None: ax = plt.subplot(111)\n        I = mesh.r(var,'CC','CC','M')\n        axes = [p for p in 'xyz' if p not in normal.lower()]\n        if normal is 'x': I = I[index,:,:]\n        if normal is 'y': I = I[:,index,:]\n        if normal is 'z': I = I[:,:,index]\n        if clim is None: clim = [I.min(),I.max()]\n        p = ax.pcolormesh(getattr(mesh,'vectorN'+axes[0]),getattr(mesh,'vectorN'+axes[1]),I.T,vmin=clim[0],vmax=clim[1])\n        ax.axis('tight')\n        ax.set_xlabel(axes[0])\n        ax.set_ylabel(axes[1])\n        return p\n\n    def videoSlicer(mesh,var,imageType='CC',normal='z',figsize=(10,8)):\n        assert mesh.dim > 2, 'This is for 3D meshes only.'\n        # First set up the figure, the axis, and the plot element we want to animate\n        fig = plt.figure(figsize=figsize)\n        ax = plt.axes()\n        clim = [var.min(),var.max()]\n        plt.colorbar(mesh.slicer(var, imageType=imageType, normal=normal, index=0, ax=ax, clim=clim))\n        tlt = plt.title(normal)\n\n        def animateFrame(i):\n            mesh.slicer(var, imageType=imageType, normal=normal, index=i, ax=ax, clim=clim)\n            tlt.set_text(normal.upper()+('-Slice: %d, %4.4f' % (i,getattr(mesh,'vectorCC'+normal)[i])))\n\n        return animate(fig, animateFrame, frames=mesh.vnC['xyz'.index(normal)])\n\n    def video(mesh, var, function, figsize=(10, 8), colorbar=True, skip=1):\n        \"\"\"\n        Call a function for a list of models to create a video.\n\n        ::\n\n            def function(var, ax, clim, tlt, i):\n                tlt.set_text('%d'%i)\n                return mesh.plotImage(var, imageType='CC', ax=ax, clim=clim)\n\n            mesh.video([model1, model2, ..., modeln],function)\n        \"\"\"\n        # First set up the figure, the axis, and the plot element we want to animate\n        fig = plt.figure(figsize=figsize)\n        ax = plt.axes()\n        VAR = np.concatenate(var)\n        clim = [VAR.min(),VAR.max()]\n        tlt = plt.title('')\n        if colorbar:\n            plt.colorbar(function(var[0],ax,clim,tlt,0))\n\n        frames = np.arange(0,len(var),skip)\n        def animateFrame(j):\n            i = frames[j]\n            function(var[i],ax,clim,tlt,i)\n\n        return animate(fig, animateFrame, frames=len(frames))",
  "class CylView(object):\n\n    def _plotCylTensorMesh(self, plotType, *args, **kwargs):\n\n        if not self.isSymmetric:\n            raise Exception('We have not yet implemented this type of view.')\n        assert plotType in ['plotImage', 'plotGrid']\n        # Hackity Hack:\n        # Just create a TM and use its view.\n        from SimPEG.Mesh import TensorMesh\n        M = TensorMesh([self.hx, self.hz], x0=[self.x0[0], self.x0[2]])\n\n        ax = kwargs.get('ax', None)\n        if ax is None:\n            fig = plt.figure()\n            ax = plt.subplot(111)\n            kwargs['ax'] = ax\n        else:\n            assert isinstance(ax, matplotlib.axes.Axes), \"ax must be an matplotlib.axes.Axes\"\n            fig = ax.figure\n\n        # Don't show things in the TM.plotImage\n        showIt = kwargs.get('showIt', False)\n        kwargs['showIt'] = False\n\n        out = getattr(M, plotType)(*args, **kwargs)\n\n        ax.set_xlabel('x')\n        ax.set_ylabel('z')\n\n        if showIt: plt.show()\n\n        return out\n\n\n    def plotGrid(self, *args, **kwargs):\n        return self._plotCylTensorMesh('plotGrid', *args, **kwargs)\n\n    def plotImage(self, *args, **kwargs):\n        return self._plotCylTensorMesh('plotImage', *args, **kwargs)",
  "class CurvView(object):\n    \"\"\"\n    Provides viewing functions for CurvilinearMesh\n\n    This class is inherited by CurvilinearMesh\n\n    \"\"\"\n    def __init__(self):\n        pass\n\n    def plotGrid(self, length=0.05, showIt=False):\n        \"\"\"Plot the nodal, cell-centered and staggered grids for 1,2 and 3 dimensions.\n\n\n        .. plot::\n            :include-source:\n\n            from SimPEG import Mesh, Utils\n            X, Y = Utils.exampleCurvGird([3,3],'rotate')\n            M = Mesh.CurvilinearMesh([X, Y])\n            M.plotGrid(showIt=True)\n\n        \"\"\"\n        NN = self.r(self.gridN, 'N', 'N', 'M')\n        if self.dim == 2:\n            fig = plt.figure(2)\n            fig.clf()\n            ax = plt.subplot(111)\n            X1 = np.c_[mkvc(NN[0][:-1, :]), mkvc(NN[0][1:, :]), mkvc(NN[0][:-1, :])*np.nan].flatten()\n            Y1 = np.c_[mkvc(NN[1][:-1, :]), mkvc(NN[1][1:, :]), mkvc(NN[1][:-1, :])*np.nan].flatten()\n\n            X2 = np.c_[mkvc(NN[0][:, :-1]), mkvc(NN[0][:, 1:]), mkvc(NN[0][:, :-1])*np.nan].flatten()\n            Y2 = np.c_[mkvc(NN[1][:, :-1]), mkvc(NN[1][:, 1:]), mkvc(NN[1][:, :-1])*np.nan].flatten()\n\n            X = np.r_[X1, X2]\n            Y = np.r_[Y1, Y2]\n\n            plt.plot(X, Y)\n\n            plt.hold(True)\n            Nx = self.r(self.normals, 'F', 'Fx', 'V')\n            Ny = self.r(self.normals, 'F', 'Fy', 'V')\n            Tx = self.r(self.tangents, 'E', 'Ex', 'V')\n            Ty = self.r(self.tangents, 'E', 'Ey', 'V')\n\n            plt.plot(self.gridN[:, 0], self.gridN[:, 1], 'bo')\n\n            nX = np.c_[self.gridFx[:, 0], self.gridFx[:, 0] + Nx[0]*length, self.gridFx[:, 0]*np.nan].flatten()\n            nY = np.c_[self.gridFx[:, 1], self.gridFx[:, 1] + Nx[1]*length, self.gridFx[:, 1]*np.nan].flatten()\n            plt.plot(self.gridFx[:, 0], self.gridFx[:, 1], 'rs')\n            plt.plot(nX, nY, 'r-')\n\n            nX = np.c_[self.gridFy[:, 0], self.gridFy[:, 0] + Ny[0]*length, self.gridFy[:, 0]*np.nan].flatten()\n            nY = np.c_[self.gridFy[:, 1], self.gridFy[:, 1] + Ny[1]*length, self.gridFy[:, 1]*np.nan].flatten()\n            #plt.plot(self.gridFy[:, 0], self.gridFy[:, 1], 'gs')\n            plt.plot(nX, nY, 'g-')\n\n            tX = np.c_[self.gridEx[:, 0], self.gridEx[:, 0] + Tx[0]*length, self.gridEx[:, 0]*np.nan].flatten()\n            tY = np.c_[self.gridEx[:, 1], self.gridEx[:, 1] + Tx[1]*length, self.gridEx[:, 1]*np.nan].flatten()\n            plt.plot(self.gridEx[:, 0], self.gridEx[:, 1], 'r^')\n            plt.plot(tX, tY, 'r-')\n\n            nX = np.c_[self.gridEy[:, 0], self.gridEy[:, 0] + Ty[0]*length, self.gridEy[:, 0]*np.nan].flatten()\n            nY = np.c_[self.gridEy[:, 1], self.gridEy[:, 1] + Ty[1]*length, self.gridEy[:, 1]*np.nan].flatten()\n            #plt.plot(self.gridEy[:, 0], self.gridEy[:, 1], 'g^')\n            plt.plot(nX, nY, 'g-')\n            plt.axis('equal')\n\n        elif self.dim == 3:\n            fig = plt.figure(3)\n            fig.clf()\n            ax = fig.add_subplot(111, projection='3d')\n            X1 = np.c_[mkvc(NN[0][:-1, :, :]), mkvc(NN[0][1:, :, :]), mkvc(NN[0][:-1, :, :])*np.nan].flatten()\n            Y1 = np.c_[mkvc(NN[1][:-1, :, :]), mkvc(NN[1][1:, :, :]), mkvc(NN[1][:-1, :, :])*np.nan].flatten()\n            Z1 = np.c_[mkvc(NN[2][:-1, :, :]), mkvc(NN[2][1:, :, :]), mkvc(NN[2][:-1, :, :])*np.nan].flatten()\n\n            X2 = np.c_[mkvc(NN[0][:, :-1, :]), mkvc(NN[0][:, 1:, :]), mkvc(NN[0][:, :-1, :])*np.nan].flatten()\n            Y2 = np.c_[mkvc(NN[1][:, :-1, :]), mkvc(NN[1][:, 1:, :]), mkvc(NN[1][:, :-1, :])*np.nan].flatten()\n            Z2 = np.c_[mkvc(NN[2][:, :-1, :]), mkvc(NN[2][:, 1:, :]), mkvc(NN[2][:, :-1, :])*np.nan].flatten()\n\n            X3 = np.c_[mkvc(NN[0][:, :, :-1]), mkvc(NN[0][:, :, 1:]), mkvc(NN[0][:, :, :-1])*np.nan].flatten()\n            Y3 = np.c_[mkvc(NN[1][:, :, :-1]), mkvc(NN[1][:, :, 1:]), mkvc(NN[1][:, :, :-1])*np.nan].flatten()\n            Z3 = np.c_[mkvc(NN[2][:, :, :-1]), mkvc(NN[2][:, :, 1:]), mkvc(NN[2][:, :, :-1])*np.nan].flatten()\n\n            X = np.r_[X1, X2, X3]\n            Y = np.r_[Y1, Y2, Y3]\n            Z = np.r_[Z1, Z2, Z3]\n\n            plt.plot(X, Y, 'b', zs=Z)\n            ax.set_zlabel('x3')\n\n        ax.grid(True)\n        ax.hold(False)\n        ax.set_xlabel('x1')\n        ax.set_ylabel('x2')\n\n        if showIt: plt.show()",
  "def __init__(self):\n        pass",
  "def plotImage(self, v, vType='CC', grid=False, view='real',\n              ax=None, clim=None, showIt=False,\n              pcolorOpts={},\n              streamOpts={'color':'k'},\n              gridOpts={'color':'k'},\n              numbering=True, annotationColor='w'\n              ):\n        \"\"\"\n        Mesh.plotImage(v)\n\n        Plots scalar fields on the given mesh.\n\n        Input:\n\n        :param numpy.array v: vector\n\n        Optional Inputs:\n\n        :param str vType: type of vector ('CC','N','F','Fx','Fy','Fz','E','Ex','Ey','Ez')\n        :param matplotlib.axes.Axes ax: axis to plot to\n        :param bool showIt: call plt.show()\n\n        3D Inputs:\n\n        :param bool numbering: show numbering of slices, 3D only\n        :param str annotationColor: color of annotation, e.g. 'w', 'k', 'b'\n\n        .. plot::\n            :include-source:\n\n            from SimPEG import Mesh, np\n            M = Mesh.TensorMesh([20, 20])\n            v = np.sin(M.gridCC[:,0]*2*np.pi)*np.sin(M.gridCC[:,1]*2*np.pi)\n            M.plotImage(v, showIt=True)\n\n        .. plot::\n            :include-source:\n\n            from SimPEG import Mesh, np\n            M = Mesh.TensorMesh([20,20,20])\n            v = np.sin(M.gridCC[:,0]*2*np.pi)*np.sin(M.gridCC[:,1]*2*np.pi)*np.sin(M.gridCC[:,2]*2*np.pi)\n            M.plotImage(v, annotationColor='k', showIt=True)\n\n        \"\"\"\n\n        if ax is None:\n            fig = plt.figure()\n            ax = plt.subplot(111)\n        else:\n            assert isinstance(ax,matplotlib.axes.Axes), \"ax must be an Axes!\"\n            fig = ax.figure\n\n        if self.dim == 1:\n            if vType == 'CC':\n                ph = ax.plot(self.vectorCCx, v, '-ro')\n            elif vType == 'N':\n                ph = ax.plot(self.vectorNx, v, '-bs')\n            ax.set_xlabel(\"x\")\n            ax.axis('tight')\n        elif self.dim == 2:\n            return self._plotImage2D(v, vType=vType, grid=grid, view=view,\n                                     ax=ax, clim=clim, showIt=showIt,\n                                     pcolorOpts=pcolorOpts, streamOpts=streamOpts,\n                                     gridOpts=gridOpts)\n        elif self.dim == 3:\n            # get copy of image and average to cell-centers is necessary\n            if vType == 'CC':\n                vc = v.reshape(self.vnC, order='F')\n            elif vType == 'N':\n                vc = (self.aveN2CC*v).reshape(self.vnC, order='F')\n            elif vType in ['Fx', 'Fy', 'Fz', 'Ex', 'Ey', 'Ez']:\n                aveOp = 'ave' + vType[0] + '2CCV'\n                # n = getattr(self,'vn'+vType[0])\n                # if 'x' in vType: v = np.r_[v,np.zeros(n[1]),np.zeros(n[2])]\n                # if 'y' in vType: v = np.r_[np.zeros(n[0]),v,np.zeros(n[2])]\n                # if 'z' in vType: v = np.r_[np.zeros(n[0]),np.zeros(n[1]),v]\n                v = getattr(self,aveOp)*v # average to cell centers\n                ind_xyz = {'x':0,'y':1,'z':2}[vType[1]]\n                vc = self.r(v.reshape((self.nC,-1),order='F'), 'CC','CC','M')[ind_xyz]\n\n            # determine number oE slices in x and y dimension\n            nX = np.ceil(np.sqrt(self.nCz))\n            nY = np.ceil(self.nCz/nX)\n\n            #  allocate space for montage\n            nCx = self.nCx\n            nCy = self.nCy\n\n            C = np.zeros((nX*nCx,nY*nCy))\n\n            for iy in range(int(nY)):\n                for ix in range(int(nX)):\n                    iz = ix + iy*nX\n                    if iz < self.nCz:\n                        C[ix*nCx:(ix+1)*nCx, iy*nCy:(iy+1)*nCy] = vc[:, :, iz]\n                    else:\n                        C[ix*nCx:(ix+1)*nCx, iy*nCy:(iy+1)*nCy] = np.nan\n\n            C = np.ma.masked_where(np.isnan(C), C)\n            xx = np.r_[0, np.cumsum(np.kron(np.ones((nX, 1)), self.hx).ravel())]\n            yy = np.r_[0, np.cumsum(np.kron(np.ones((nY, 1)), self.hy).ravel())]\n            # Plot the mesh\n\n            if clim is None:\n                clim = [C.min(),C.max()]\n            ph = ax.pcolormesh(xx, yy, C.T, vmin=clim[0], vmax=clim[1])\n            # Plot the lines\n            gx =  np.arange(nX+1)*(self.vectorNx[-1]-self.x0[0])\n            gy =  np.arange(nY+1)*(self.vectorNy[-1]-self.x0[1])\n            # Repeat and seperate with NaN\n            gxX = np.c_[gx, gx, gx+np.nan].ravel()\n            gxY = np.kron(np.ones((nX+1, 1)), np.array([0, sum(self.hy)*nY, np.nan])).ravel()\n            gyX = np.kron(np.ones((nY+1, 1)), np.array([0, sum(self.hx)*nX, np.nan])).ravel()\n            gyY = np.c_[gy, gy, gy+np.nan].ravel()\n            ax.plot(gxX, gxY, annotationColor+'-', linewidth=2)\n            ax.plot(gyX, gyY, annotationColor+'-', linewidth=2)\n            ax.axis('tight')\n\n            if numbering:\n                pad = np.sum(self.hx)*0.04\n                for iy in range(int(nY)):\n                    for ix in range(int(nX)):\n                        iz = ix + iy*nX\n                        if iz < self.nCz:\n                            ax.text((ix+1)*(self.vectorNx[-1]-self.x0[0])-pad,(iy)*(self.vectorNy[-1]-self.x0[1])+pad,\n                                     '#%i'%iz,color=annotationColor,verticalalignment='bottom',horizontalalignment='right',size='x-large')\n\n        ax.set_title(vType)\n        if showIt: plt.show()\n        return ph",
  "def plotSlice(self, v, vType='CC',\n                  normal='Z', ind=None, grid=False, view='real',\n                  ax=None, clim=None, showIt=False,\n                  pcolorOpts={},\n                  streamOpts={'color':'k'},\n                  gridOpts={'color':'k', 'alpha':0.5}\n                  ):\n\n        \"\"\"\n        Plots a slice of a 3D mesh.\n\n        .. plot::\n\n            from SimPEG import *\n            hx = [(5,2,-1.3),(2,4),(5,2,1.3)]\n            hy = [(2,2,-1.3),(2,6),(2,2,1.3)]\n            hz = [(2,2,-1.3),(2,6),(2,2,1.3)]\n            M = Mesh.TensorMesh([hx,hy,hz])\n            q = np.zeros(M.vnC)\n            q[[4,4],[4,4],[2,6]]=[-1,1]\n            q = Utils.mkvc(q)\n            A = M.faceDiv*M.cellGrad\n            b = Solver(A) * (q)\n            M.plotSlice(M.cellGrad*b, 'F', view='vec', grid=True, showIt=True, pcolorOpts={'alpha':0.8})\n\n        \"\"\"\n        if type(vType) in [list, tuple]:\n            assert ax is None, \"cannot specify an axis to plot on with this function.\"\n            fig, axs = plt.subplots(1,len(vType))\n            out = []\n            for vTypeI, ax in zip(vType, axs):\n                out += [self.plotSlice(v,vType=vTypeI, normal=normal, ind=ind, grid=grid, view=view, ax=ax, clim=clim, showIt=False, pcolorOpts=pcolorOpts, streamOpts=streamOpts, gridOpts=gridOpts)]\n            return out\n        viewOpts = ['real','imag','abs','vec']\n        normalOpts = ['X', 'Y', 'Z']\n        vTypeOpts = ['CC', 'CCv','F','E','Fx','Fy','Fz','E','Ex','Ey','Ez']\n\n        # Some user error checking\n        assert vType in vTypeOpts, \"vType must be in ['%s']\" % \"','\".join(vTypeOpts)\n        assert self.dim == 3, 'Must be a 3D mesh. Use plotImage.'\n        assert view in viewOpts, \"view must be in ['%s']\" % \"','\".join(viewOpts)\n        assert normal in normalOpts, \"normal must be in ['%s']\" % \"','\".join(normalOpts)\n        assert type(grid) is bool, 'grid must be a boolean'\n\n        szSliceDim = getattr(self, 'nC'+normal.lower()) #: Size of the sliced dimension\n        if ind is None: ind = int(szSliceDim/2)\n        assert type(ind) in [int, long], 'ind must be an integer'\n\n        assert not (v.dtype == complex and view == 'vec'), 'Can not plot a complex vector.'\n        # The slicing and plotting code!!\n\n        def getIndSlice(v):\n            if   normal == 'X': v = v[ind,:,:]\n            elif normal == 'Y': v = v[:,ind,:]\n            elif normal == 'Z': v = v[:,:,ind]\n            return v\n\n        def doSlice(v):\n            if vType == 'CC':\n                return getIndSlice(self.r(v,'CC','CC','M'))\n            elif vType == 'CCv':\n                assert view == 'vec', 'Other types for CCv not supported'\n            else:\n                # Now just deal with 'F' and 'E' (x,y,z, maybe...)\n                aveOp = 'ave' + vType + ('2CCV' if view == 'vec' else '2CC')\n                Av = getattr(self,aveOp)\n                if v.size == Av.shape[1]:\n                    v = Av * v\n                else:\n                    v = self.r(v,vType[0],vType) # get specific component\n                    v = Av * v\n                # we should now be averaged to cell centers (might be a vector)\n            v = self.r(v.reshape((self.nC,-1),order='F'),'CC','CC','M')\n            if view == 'vec':\n                outSlice = []\n                if 'X' not in normal: outSlice.append(getIndSlice(v[0]))\n                if 'Y' not in normal: outSlice.append(getIndSlice(v[1]))\n                if 'Z' not in normal: outSlice.append(getIndSlice(v[2]))\n                return np.r_[mkvc(outSlice[0]), mkvc(outSlice[1])]\n            else:\n                return getIndSlice(self.r(v,'CC','CC','M'))\n\n        h2d = []\n        x2d = []\n        if 'X' not in normal:\n            h2d.append(self.hx)\n            x2d.append(self.x0[0])\n        if 'Y' not in normal:\n            h2d.append(self.hy)\n            x2d.append(self.x0[1])\n        if 'Z' not in normal:\n            h2d.append(self.hz)\n            x2d.append(self.x0[2])\n        tM = self.__class__(h2d, x2d) #: Temp Mesh\n        v2d = doSlice(v)\n\n\n        if ax is None:\n            fig = plt.figure()\n            ax = plt.subplot(111)\n        else:\n            assert isinstance(ax, matplotlib.axes.Axes), \"ax must be an matplotlib.axes.Axes\"\n            fig = ax.figure\n\n        out = tM._plotImage2D(v2d, vType=('CCv' if view == 'vec' else 'CC'), grid=grid, view=view,\n                        ax=ax, clim=clim, showIt=showIt,\n                        pcolorOpts=pcolorOpts, streamOpts=streamOpts,\n                        gridOpts=gridOpts)\n\n\n        ax.set_xlabel('y' if normal == 'X' else 'x')\n        ax.set_ylabel('y' if normal == 'Z' else 'z')\n        ax.set_title('Slice %d' % ind)\n        return out",
  "def _plotImage2D(self, v, vType='CC', grid=False, view='real',\n              ax=None, clim=None, showIt=False,\n              pcolorOpts={},\n              streamOpts={'color':'k'},\n              gridOpts={'color':'k'}\n              ):\n\n        vTypeOptsCC = ['N','CC','Fx','Fy','Ex','Ey']\n        vTypeOptsV = ['CCv','F','E']\n        vTypeOpts = vTypeOptsCC + vTypeOptsV\n        if view == 'vec':\n            assert vType in vTypeOptsV, \"vType must be in ['%s'] when view='vec'\" % \"','\".join(vTypeOptsV)\n        assert vType in vTypeOpts, \"vType must be in ['%s']\" % \"','\".join(vTypeOpts)\n\n        viewOpts = ['real','imag','abs','vec']\n        assert view in viewOpts, \"view must be in ['%s']\" % \"','\".join(viewOpts)\n\n\n        if ax is None:\n            fig = plt.figure()\n            ax = plt.subplot(111)\n        else:\n            assert isinstance(ax, matplotlib.axes.Axes), \"ax must be an matplotlib.axes.Axes\"\n            fig = ax.figure\n\n        # Reshape to a cell centered variable\n        if vType == 'CC':\n            pass\n        elif vType == 'CCv':\n            assert view == 'vec', 'Other types for CCv not supported'\n        elif vType in ['F', 'E', 'N']:\n            aveOp = 'ave' + vType + ('2CCV' if view == 'vec' else '2CC')\n            v = getattr(self,aveOp)*v # average to cell centers (might be a vector)\n        elif vType in ['Fx','Fy','Ex','Ey']:\n            aveOp = 'ave' + vType[0] + '2CCV'\n            v = getattr(self,aveOp)*v # average to cell centers (might be a vector)\n            xORy = {'x':0,'y':1}[vType[1]]\n            v = v.reshape((self.nC,-1), order='F')[:,xORy]\n\n        out = ()\n        if view in ['real','imag','abs']:\n            v = self.r(v, 'CC', 'CC', 'M')\n            v = getattr(np,view)(v) # e.g. np.real(v)\n            if clim is None:\n                clim = [v.min(),v.max()]\n            v = np.ma.masked_where(np.isnan(v), v)\n            out += (ax.pcolormesh(self.vectorNx, self.vectorNy, v.T, vmin=clim[0], vmax=clim[1], **pcolorOpts),)\n        elif view in ['vec']:\n            U, V = self.r(v.reshape((self.nC,-1), order='F'), 'CC', 'CC', 'M')\n            if clim is None:\n                uv = np.sqrt(U**2 + V**2)\n                clim = [uv.min(),uv.max()]\n\n            # Matplotlib seems to not support irregular\n            # spaced vectors at the moment. So we will\n            # Interpolate down to a regular mesh at the\n            # smallest mesh size in this 2D slice.\n            nxi = int(self.hx.sum()/self.hx.min())\n            nyi = int(self.hy.sum()/self.hy.min())\n            tMi = self.__class__([np.ones(nxi)*self.hx.sum()/nxi,\n                                  np.ones(nyi)*self.hy.sum()/nyi], self.x0)\n            P = self.getInterpolationMat(tMi.gridCC,'CC',zerosOutside=True)\n            Ui = tMi.r(P*mkvc(U), 'CC', 'CC', 'M')\n            Vi = tMi.r(P*mkvc(V), 'CC', 'CC', 'M')\n            # End Interpolation\n\n            out += (ax.pcolormesh(self.vectorNx, self.vectorNy, np.sqrt(U**2+V**2).T, vmin=clim[0], vmax=clim[1], **pcolorOpts),)\n            out += (ax.streamplot(tMi.vectorCCx, tMi.vectorCCy, Ui.T, Vi.T, **streamOpts),)\n\n        if grid:\n            xXGrid = np.c_[self.vectorNx,self.vectorNx,np.nan*np.ones(self.nNx)].flatten()\n            xYGrid = np.c_[self.vectorNy[0]*np.ones(self.nNx),self.vectorNy[-1]*np.ones(self.nNx),np.nan*np.ones(self.nNx)].flatten()\n            yXGrid = np.c_[self.vectorNx[0]*np.ones(self.nNy),self.vectorNx[-1]*np.ones(self.nNy),np.nan*np.ones(self.nNy)].flatten()\n            yYGrid = np.c_[self.vectorNy,self.vectorNy,np.nan*np.ones(self.nNy)].flatten()\n            out += (ax.plot(np.r_[xXGrid,yXGrid],np.r_[xYGrid,yYGrid],**gridOpts)[0],)\n\n\n        ax.set_xlabel('x')\n        ax.set_ylabel('y')\n        ax.set_xlim(*self.vectorNx[[0,-1]])\n        ax.set_ylim(*self.vectorNy[[0,-1]])\n\n        if showIt: plt.show()\n        return out",
  "def plotGrid(self, ax=None, nodes=False, faces=False, centers=False, edges=False, lines=True, showIt=False):\n        \"\"\"Plot the nodal, cell-centered and staggered grids for 1,2 and 3 dimensions.\n\n        :param bool nodes: plot nodes\n        :param bool faces: plot faces\n        :param bool centers: plot centers\n        :param bool edges: plot edges\n        :param bool lines: plot lines connecting nodes\n        :param bool showIt: call plt.show()\n\n        .. plot::\n           :include-source:\n\n           from SimPEG import Mesh, np\n           h1 = np.linspace(.1,.5,3)\n           h2 = np.linspace(.1,.5,5)\n           mesh = Mesh.TensorMesh([h1, h2])\n           mesh.plotGrid(nodes=True, faces=True, centers=True, lines=True, showIt=True)\n\n        .. plot::\n           :include-source:\n\n           from SimPEG import Mesh, np\n           h1 = np.linspace(.1,.5,3)\n           h2 = np.linspace(.1,.5,5)\n           h3 = np.linspace(.1,.5,3)\n           mesh = Mesh.TensorMesh([h1,h2,h3])\n           mesh.plotGrid(nodes=True, faces=True, centers=True, lines=True, showIt=True)\n\n        \"\"\"\n\n        axOpts = {'projection':'3d'} if self.dim == 3 else {}\n        if ax is None:\n            fig = plt.figure()\n            ax = plt.subplot(111, **axOpts)\n        else:\n            assert isinstance(ax, matplotlib.axes.Axes), \"ax must be an matplotlib.axes.Axes\"\n            fig = ax.figure\n\n        if self.dim == 1:\n            if nodes:\n                ax.plot(self.gridN, np.ones(self.nN), 'bs')\n            if centers:\n                ax.plot(self.gridCC, np.ones(self.nC), 'ro')\n            if lines:\n                ax.plot(self.gridN, np.ones(self.nN), 'b.-')\n            ax.set_xlabel('x1')\n        elif self.dim == 2:\n            if nodes:\n                ax.plot(self.gridN[:, 0], self.gridN[:, 1], 'bs')\n            if centers:\n                ax.plot(self.gridCC[:, 0], self.gridCC[:, 1], 'ro')\n            if faces:\n                ax.plot(self.gridFx[:, 0], self.gridFx[:, 1], 'g>')\n                ax.plot(self.gridFy[:, 0], self.gridFy[:, 1], 'g^')\n            if edges:\n                ax.plot(self.gridEx[:, 0], self.gridEx[:, 1], 'c>')\n                ax.plot(self.gridEy[:, 0], self.gridEy[:, 1], 'c^')\n\n            # Plot the grid lines\n            if lines:\n                NN = self.r(self.gridN, 'N', 'N', 'M')\n                X1 = np.c_[mkvc(NN[0][0, :]), mkvc(NN[0][self.nCx, :]), mkvc(NN[0][0, :])*np.nan].flatten()\n                Y1 = np.c_[mkvc(NN[1][0, :]), mkvc(NN[1][self.nCx, :]), mkvc(NN[1][0, :])*np.nan].flatten()\n                X2 = np.c_[mkvc(NN[0][:, 0]), mkvc(NN[0][:, self.nCy]), mkvc(NN[0][:, 0])*np.nan].flatten()\n                Y2 = np.c_[mkvc(NN[1][:, 0]), mkvc(NN[1][:, self.nCy]), mkvc(NN[1][:, 0])*np.nan].flatten()\n                X = np.r_[X1, X2]\n                Y = np.r_[Y1, Y2]\n                ax.plot(X, Y, 'b-')\n\n            ax.set_xlabel('x1')\n            ax.set_ylabel('x2')\n        elif self.dim == 3:\n            if nodes:\n                ax.plot(self.gridN[:, 0], self.gridN[:, 1], 'bs', zs=self.gridN[:, 2])\n            if centers:\n                ax.plot(self.gridCC[:, 0], self.gridCC[:, 1], 'ro', zs=self.gridCC[:, 2])\n            if faces:\n                ax.plot(self.gridFx[:, 0], self.gridFx[:, 1], 'g>', zs=self.gridFx[:, 2])\n                ax.plot(self.gridFy[:, 0], self.gridFy[:, 1], 'g<', zs=self.gridFy[:, 2])\n                ax.plot(self.gridFz[:, 0], self.gridFz[:, 1], 'g^', zs=self.gridFz[:, 2])\n            if edges:\n                ax.plot(self.gridEx[:, 0], self.gridEx[:, 1], 'k>', zs=self.gridEx[:, 2])\n                ax.plot(self.gridEy[:, 0], self.gridEy[:, 1], 'k<', zs=self.gridEy[:, 2])\n                ax.plot(self.gridEz[:, 0], self.gridEz[:, 1], 'k^', zs=self.gridEz[:, 2])\n\n            # Plot the grid lines\n            if lines:\n                NN = self.r(self.gridN, 'N', 'N', 'M')\n                X1 = np.c_[mkvc(NN[0][0, :, :]), mkvc(NN[0][self.nCx, :, :]), mkvc(NN[0][0, :, :])*np.nan].flatten()\n                Y1 = np.c_[mkvc(NN[1][0, :, :]), mkvc(NN[1][self.nCx, :, :]), mkvc(NN[1][0, :, :])*np.nan].flatten()\n                Z1 = np.c_[mkvc(NN[2][0, :, :]), mkvc(NN[2][self.nCx, :, :]), mkvc(NN[2][0, :, :])*np.nan].flatten()\n                X2 = np.c_[mkvc(NN[0][:, 0, :]), mkvc(NN[0][:, self.nCy, :]), mkvc(NN[0][:, 0, :])*np.nan].flatten()\n                Y2 = np.c_[mkvc(NN[1][:, 0, :]), mkvc(NN[1][:, self.nCy, :]), mkvc(NN[1][:, 0, :])*np.nan].flatten()\n                Z2 = np.c_[mkvc(NN[2][:, 0, :]), mkvc(NN[2][:, self.nCy, :]), mkvc(NN[2][:, 0, :])*np.nan].flatten()\n                X3 = np.c_[mkvc(NN[0][:, :, 0]), mkvc(NN[0][:, :, self.nCz]), mkvc(NN[0][:, :, 0])*np.nan].flatten()\n                Y3 = np.c_[mkvc(NN[1][:, :, 0]), mkvc(NN[1][:, :, self.nCz]), mkvc(NN[1][:, :, 0])*np.nan].flatten()\n                Z3 = np.c_[mkvc(NN[2][:, :, 0]), mkvc(NN[2][:, :, self.nCz]), mkvc(NN[2][:, :, 0])*np.nan].flatten()\n                X = np.r_[X1, X2, X3]\n                Y = np.r_[Y1, Y2, Y3]\n                Z = np.r_[Z1, Z2, Z3]\n                ax.plot(X, Y, 'b-', zs=Z)\n            ax.set_xlabel('x1')\n            ax.set_ylabel('x2')\n            ax.set_zlabel('x3')\n\n        ax.grid(True)\n        if showIt: plt.show()",
  "def slicer(mesh, var, imageType='CC', normal='z', index=0, ax=None, clim=None):\n        assert normal in 'xyz', 'normal must be x, y, or z'\n        if ax is None: ax = plt.subplot(111)\n        I = mesh.r(var,'CC','CC','M')\n        axes = [p for p in 'xyz' if p not in normal.lower()]\n        if normal is 'x': I = I[index,:,:]\n        if normal is 'y': I = I[:,index,:]\n        if normal is 'z': I = I[:,:,index]\n        if clim is None: clim = [I.min(),I.max()]\n        p = ax.pcolormesh(getattr(mesh,'vectorN'+axes[0]),getattr(mesh,'vectorN'+axes[1]),I.T,vmin=clim[0],vmax=clim[1])\n        ax.axis('tight')\n        ax.set_xlabel(axes[0])\n        ax.set_ylabel(axes[1])\n        return p",
  "def videoSlicer(mesh,var,imageType='CC',normal='z',figsize=(10,8)):\n        assert mesh.dim > 2, 'This is for 3D meshes only.'\n        # First set up the figure, the axis, and the plot element we want to animate\n        fig = plt.figure(figsize=figsize)\n        ax = plt.axes()\n        clim = [var.min(),var.max()]\n        plt.colorbar(mesh.slicer(var, imageType=imageType, normal=normal, index=0, ax=ax, clim=clim))\n        tlt = plt.title(normal)\n\n        def animateFrame(i):\n            mesh.slicer(var, imageType=imageType, normal=normal, index=i, ax=ax, clim=clim)\n            tlt.set_text(normal.upper()+('-Slice: %d, %4.4f' % (i,getattr(mesh,'vectorCC'+normal)[i])))\n\n        return animate(fig, animateFrame, frames=mesh.vnC['xyz'.index(normal)])",
  "def video(mesh, var, function, figsize=(10, 8), colorbar=True, skip=1):\n        \"\"\"\n        Call a function for a list of models to create a video.\n\n        ::\n\n            def function(var, ax, clim, tlt, i):\n                tlt.set_text('%d'%i)\n                return mesh.plotImage(var, imageType='CC', ax=ax, clim=clim)\n\n            mesh.video([model1, model2, ..., modeln],function)\n        \"\"\"\n        # First set up the figure, the axis, and the plot element we want to animate\n        fig = plt.figure(figsize=figsize)\n        ax = plt.axes()\n        VAR = np.concatenate(var)\n        clim = [VAR.min(),VAR.max()]\n        tlt = plt.title('')\n        if colorbar:\n            plt.colorbar(function(var[0],ax,clim,tlt,0))\n\n        frames = np.arange(0,len(var),skip)\n        def animateFrame(j):\n            i = frames[j]\n            function(var[i],ax,clim,tlt,i)\n\n        return animate(fig, animateFrame, frames=len(frames))",
  "def _plotCylTensorMesh(self, plotType, *args, **kwargs):\n\n        if not self.isSymmetric:\n            raise Exception('We have not yet implemented this type of view.')\n        assert plotType in ['plotImage', 'plotGrid']\n        # Hackity Hack:\n        # Just create a TM and use its view.\n        from SimPEG.Mesh import TensorMesh\n        M = TensorMesh([self.hx, self.hz], x0=[self.x0[0], self.x0[2]])\n\n        ax = kwargs.get('ax', None)\n        if ax is None:\n            fig = plt.figure()\n            ax = plt.subplot(111)\n            kwargs['ax'] = ax\n        else:\n            assert isinstance(ax, matplotlib.axes.Axes), \"ax must be an matplotlib.axes.Axes\"\n            fig = ax.figure\n\n        # Don't show things in the TM.plotImage\n        showIt = kwargs.get('showIt', False)\n        kwargs['showIt'] = False\n\n        out = getattr(M, plotType)(*args, **kwargs)\n\n        ax.set_xlabel('x')\n        ax.set_ylabel('z')\n\n        if showIt: plt.show()\n\n        return out",
  "def plotGrid(self, *args, **kwargs):\n        return self._plotCylTensorMesh('plotGrid', *args, **kwargs)",
  "def plotImage(self, *args, **kwargs):\n        return self._plotCylTensorMesh('plotImage', *args, **kwargs)",
  "def __init__(self):\n        pass",
  "def plotGrid(self, length=0.05, showIt=False):\n        \"\"\"Plot the nodal, cell-centered and staggered grids for 1,2 and 3 dimensions.\n\n\n        .. plot::\n            :include-source:\n\n            from SimPEG import Mesh, Utils\n            X, Y = Utils.exampleCurvGird([3,3],'rotate')\n            M = Mesh.CurvilinearMesh([X, Y])\n            M.plotGrid(showIt=True)\n\n        \"\"\"\n        NN = self.r(self.gridN, 'N', 'N', 'M')\n        if self.dim == 2:\n            fig = plt.figure(2)\n            fig.clf()\n            ax = plt.subplot(111)\n            X1 = np.c_[mkvc(NN[0][:-1, :]), mkvc(NN[0][1:, :]), mkvc(NN[0][:-1, :])*np.nan].flatten()\n            Y1 = np.c_[mkvc(NN[1][:-1, :]), mkvc(NN[1][1:, :]), mkvc(NN[1][:-1, :])*np.nan].flatten()\n\n            X2 = np.c_[mkvc(NN[0][:, :-1]), mkvc(NN[0][:, 1:]), mkvc(NN[0][:, :-1])*np.nan].flatten()\n            Y2 = np.c_[mkvc(NN[1][:, :-1]), mkvc(NN[1][:, 1:]), mkvc(NN[1][:, :-1])*np.nan].flatten()\n\n            X = np.r_[X1, X2]\n            Y = np.r_[Y1, Y2]\n\n            plt.plot(X, Y)\n\n            plt.hold(True)\n            Nx = self.r(self.normals, 'F', 'Fx', 'V')\n            Ny = self.r(self.normals, 'F', 'Fy', 'V')\n            Tx = self.r(self.tangents, 'E', 'Ex', 'V')\n            Ty = self.r(self.tangents, 'E', 'Ey', 'V')\n\n            plt.plot(self.gridN[:, 0], self.gridN[:, 1], 'bo')\n\n            nX = np.c_[self.gridFx[:, 0], self.gridFx[:, 0] + Nx[0]*length, self.gridFx[:, 0]*np.nan].flatten()\n            nY = np.c_[self.gridFx[:, 1], self.gridFx[:, 1] + Nx[1]*length, self.gridFx[:, 1]*np.nan].flatten()\n            plt.plot(self.gridFx[:, 0], self.gridFx[:, 1], 'rs')\n            plt.plot(nX, nY, 'r-')\n\n            nX = np.c_[self.gridFy[:, 0], self.gridFy[:, 0] + Ny[0]*length, self.gridFy[:, 0]*np.nan].flatten()\n            nY = np.c_[self.gridFy[:, 1], self.gridFy[:, 1] + Ny[1]*length, self.gridFy[:, 1]*np.nan].flatten()\n            #plt.plot(self.gridFy[:, 0], self.gridFy[:, 1], 'gs')\n            plt.plot(nX, nY, 'g-')\n\n            tX = np.c_[self.gridEx[:, 0], self.gridEx[:, 0] + Tx[0]*length, self.gridEx[:, 0]*np.nan].flatten()\n            tY = np.c_[self.gridEx[:, 1], self.gridEx[:, 1] + Tx[1]*length, self.gridEx[:, 1]*np.nan].flatten()\n            plt.plot(self.gridEx[:, 0], self.gridEx[:, 1], 'r^')\n            plt.plot(tX, tY, 'r-')\n\n            nX = np.c_[self.gridEy[:, 0], self.gridEy[:, 0] + Ty[0]*length, self.gridEy[:, 0]*np.nan].flatten()\n            nY = np.c_[self.gridEy[:, 1], self.gridEy[:, 1] + Ty[1]*length, self.gridEy[:, 1]*np.nan].flatten()\n            #plt.plot(self.gridEy[:, 0], self.gridEy[:, 1], 'g^')\n            plt.plot(nX, nY, 'g-')\n            plt.axis('equal')\n\n        elif self.dim == 3:\n            fig = plt.figure(3)\n            fig.clf()\n            ax = fig.add_subplot(111, projection='3d')\n            X1 = np.c_[mkvc(NN[0][:-1, :, :]), mkvc(NN[0][1:, :, :]), mkvc(NN[0][:-1, :, :])*np.nan].flatten()\n            Y1 = np.c_[mkvc(NN[1][:-1, :, :]), mkvc(NN[1][1:, :, :]), mkvc(NN[1][:-1, :, :])*np.nan].flatten()\n            Z1 = np.c_[mkvc(NN[2][:-1, :, :]), mkvc(NN[2][1:, :, :]), mkvc(NN[2][:-1, :, :])*np.nan].flatten()\n\n            X2 = np.c_[mkvc(NN[0][:, :-1, :]), mkvc(NN[0][:, 1:, :]), mkvc(NN[0][:, :-1, :])*np.nan].flatten()\n            Y2 = np.c_[mkvc(NN[1][:, :-1, :]), mkvc(NN[1][:, 1:, :]), mkvc(NN[1][:, :-1, :])*np.nan].flatten()\n            Z2 = np.c_[mkvc(NN[2][:, :-1, :]), mkvc(NN[2][:, 1:, :]), mkvc(NN[2][:, :-1, :])*np.nan].flatten()\n\n            X3 = np.c_[mkvc(NN[0][:, :, :-1]), mkvc(NN[0][:, :, 1:]), mkvc(NN[0][:, :, :-1])*np.nan].flatten()\n            Y3 = np.c_[mkvc(NN[1][:, :, :-1]), mkvc(NN[1][:, :, 1:]), mkvc(NN[1][:, :, :-1])*np.nan].flatten()\n            Z3 = np.c_[mkvc(NN[2][:, :, :-1]), mkvc(NN[2][:, :, 1:]), mkvc(NN[2][:, :, :-1])*np.nan].flatten()\n\n            X = np.r_[X1, X2, X3]\n            Y = np.r_[Y1, Y2, Y3]\n            Z = np.r_[Z1, Z2, Z3]\n\n            plt.plot(X, Y, 'b', zs=Z)\n            ax.set_zlabel('x3')\n\n        ax.grid(True)\n        ax.hold(False)\n        ax.set_xlabel('x1')\n        ax.set_ylabel('x2')\n\n        if showIt: plt.show()",
  "def getIndSlice(v):\n            if   normal == 'X': v = v[ind,:,:]\n            elif normal == 'Y': v = v[:,ind,:]\n            elif normal == 'Z': v = v[:,:,ind]\n            return v",
  "def doSlice(v):\n            if vType == 'CC':\n                return getIndSlice(self.r(v,'CC','CC','M'))\n            elif vType == 'CCv':\n                assert view == 'vec', 'Other types for CCv not supported'\n            else:\n                # Now just deal with 'F' and 'E' (x,y,z, maybe...)\n                aveOp = 'ave' + vType + ('2CCV' if view == 'vec' else '2CC')\n                Av = getattr(self,aveOp)\n                if v.size == Av.shape[1]:\n                    v = Av * v\n                else:\n                    v = self.r(v,vType[0],vType) # get specific component\n                    v = Av * v\n                # we should now be averaged to cell centers (might be a vector)\n            v = self.r(v.reshape((self.nC,-1),order='F'),'CC','CC','M')\n            if view == 'vec':\n                outSlice = []\n                if 'X' not in normal: outSlice.append(getIndSlice(v[0]))\n                if 'Y' not in normal: outSlice.append(getIndSlice(v[1]))\n                if 'Z' not in normal: outSlice.append(getIndSlice(v[2]))\n                return np.r_[mkvc(outSlice[0]), mkvc(outSlice[1])]\n            else:\n                return getIndSlice(self.r(v,'CC','CC','M'))",
  "def animateFrame(i):\n            mesh.slicer(var, imageType=imageType, normal=normal, index=i, ax=ax, clim=clim)\n            tlt.set_text(normal.upper()+('-Slice: %d, %4.4f' % (i,getattr(mesh,'vectorCC'+normal)[i])))",
  "def animateFrame(j):\n            i = frames[j]\n            function(var[i],ax,clim,tlt,i)",
  "class EMPropMap(Maps.PropMap):\n    \"\"\" \n        Property Map for EM Problems. The electrical conductivity (\\\\(\\\\sigma\\\\)) is the default inversion property, and the default value of the magnetic permeability is that of free space (\\\\(\\\\mu = 4\\\\pi\\\\times 10^{-7} \\\\) H/m)\n    \"\"\"\n\n    sigma = Maps.Property(\"Electrical Conductivity\", defaultInvProp = True, propertyLink=('rho',Maps.ReciprocalMap))\n    mu = Maps.Property(\"Inverse Magnetic Permeability\", defaultVal = mu_0, propertyLink=('mui',Maps.ReciprocalMap))\n\n    rho = Maps.Property(\"Electrical Resistivity\", propertyLink=('sigma', Maps.ReciprocalMap)) \n    mui = Maps.Property(\"Inverse Magnetic Permeability\", defaultVal = 1./mu_0, propertyLink=('mu', Maps.ReciprocalMap))",
  "class BaseEMProblem(Problem.BaseProblem):\n\n    def __init__(self, mesh, **kwargs):\n        Problem.BaseProblem.__init__(self, mesh, **kwargs)\n\n\n    surveyPair = Survey.BaseSurvey\n    dataPair = Survey.Data\n    \n    PropMap = EMPropMap\n\n    Solver = SimpegSolver\n    solverOpts = {}\n\n    verbose = False\n\n    ####################################################\n    # Make A Symmetric\n    ####################################################\n    @property\n    def _makeASymmetric(self):\n        if getattr(self, '__makeASymmetric', None) is None:\n            self.__makeASymmetric = True\n        return self.__makeASymmetric\n\n\n    ####################################################\n    # Mass Matrices\n    ####################################################\n\n    @property\n    def deleteTheseOnModelUpdate(self):\n        toDelete = []\n        if self.mapping.sigmaMap is not None or self.mapping.rhoMap is not None:\n            toDelete += ['_MeSigma', '_MeSigmaI','_MfRho','_MfRhoI']\n        if self.mapping.muMap is not None or self.mapping.muiMap is not None:\n            toDelete += ['_MeMu', '_MeMuI','_MfMui','_MfMuiI']\n        return toDelete\n    \n    @property\n    def Me(self):\n        \"\"\"\n            Edge inner product matrix\n        \"\"\"\n        if getattr(self, '_Me', None) is None:\n            self._Me = self.mesh.getEdgeInnerProduct()\n        return self._Me\n\n    @property\n    def Mf(self):\n        \"\"\"\n            Face inner product matrix\n        \"\"\"\n        if getattr(self, '_Mf', None) is None:\n            self._Mf = self.mesh.getFaceInnerProduct()\n        return self._Mf\n\n\n    # ----- Magnetic Permeability ----- # \n    @property\n    def MfMui(self):\n        \"\"\"\n            Face inner product matrix for \\\\(\\\\mu^{-1}\\\\). Used in the E-B formulation\n        \"\"\"\n        if getattr(self, '_MfMui', None) is None:\n            self._MfMui = self.mesh.getFaceInnerProduct(self.curModel.mui)\n        return self._MfMui\n\n    @property\n    def MfMuiI(self):\n        \"\"\"\n            Inverse of :code:`MfMui`.\n        \"\"\"\n        if getattr(self, '_MfMuiI', None) is None:\n            self._MfMuiI = self.mesh.getFaceInnerProduct(self.curModel.mui, invMat=True)\n        return self._MfMuiI\n\n    @property\n    def MeMu(self):\n        \"\"\"\n            Edge inner product matrix for \\\\(\\\\mu\\\\). Used in the H-J formulation\n        \"\"\"\n        if getattr(self, '_MeMu', None) is None:\n            self._MeMu = self.mesh.getEdgeInnerProduct(self.curModel.mu)\n        return self._MeMu\n\n    @property\n    def MeMuI(self):\n        \"\"\"\n            Inverse of :code:`MeMu`\n        \"\"\"\n        if getattr(self, '_MeMuI', None) is None:\n            self._MeMuI = self.mesh.getEdgeInnerProduct(self.curModel.mu, invMat=True)\n        return self._MeMuI\n\n\n    # ----- Electrical Conductivity ----- # \n    #TODO: hardcoded to sigma as the model\n    @property\n    def MeSigma(self):\n        \"\"\"\n            Edge inner product matrix for \\\\(\\\\sigma\\\\). Used in the E-B formulation\n        \"\"\"\n        if getattr(self, '_MeSigma', None) is None:\n            self._MeSigma = self.mesh.getEdgeInnerProduct(self.curModel.sigma)\n        return self._MeSigma\n\n    # TODO: This should take a vector \n    def MeSigmaDeriv(self, u):\n        \"\"\"\n            Derivative of MeSigma with respect to the model\n        \"\"\" \n        return self.mesh.getEdgeInnerProductDeriv(self.curModel.sigma)(u) * self.curModel.sigmaDeriv\n    \n\n    @property\n    def MeSigmaI(self):\n        \"\"\"\n            Inverse of the edge inner product matrix for \\\\(\\\\sigma\\\\). \n        \"\"\"\n        if getattr(self, '_MeSigmaI', None) is None:\n            self._MeSigmaI = self.mesh.getEdgeInnerProduct(self.curModel.sigma, invMat=True)\n        return self._MeSigmaI\n\n    # TODO: This should take a vector\n    def MeSigmaIDeriv(self, u):\n        \"\"\"\n            Derivative of :code:`MeSigma` with respect to the model \n        \"\"\" \n        # TODO: only works for diagonal tensors. getEdgeInnerProductDeriv, invMat=True should be implemented in SimPEG\n\n        dMeSigmaI_dI = -self.MeSigmaI**2\n        dMe_dsig = self.mesh.getEdgeInnerProductDeriv(self.curModel.sigma)(u)\n        dsig_dm = self.curModel.sigmaDeriv\n        return dMeSigmaI_dI * ( dMe_dsig * ( dsig_dm))\n        # return self.mesh.getEdgeInnerProductDeriv(self.curModel.sigma, invMat=True)(u)\n\n\n    @property\n    def MfRho(self):\n        \"\"\"\n            Face inner product matrix for \\\\(\\\\rho\\\\). Used in the H-J formulation\n        \"\"\"\n        if getattr(self, '_MfRho', None) is None:\n            self._MfRho = self.mesh.getFaceInnerProduct(self.curModel.rho)\n        return self._MfRho\n\n    # TODO: This should take a vector\n    def MfRhoDeriv(self,u):\n        \"\"\"\n            Derivative of :code:`MfRho` with respect to the model. \n        \"\"\"\n        return self.mesh.getFaceInnerProductDeriv(self.curModel.rho)(u) * (-Utils.sdiag(self.curModel.rho**2) * self.curModel.sigmaDeriv)\n        # self.curModel.rhoDeriv\n\n    @property\n    def MfRhoI(self):\n        \"\"\"\n            Inverse of :code:`MfRho`\n        \"\"\"\n        if getattr(self, '_MfRhoI', None) is None:\n            self._MfRhoI = self.mesh.getFaceInnerProduct(self.curModel.rho, invMat=True)\n        return self._MfRhoI\n\n    # TODO: This isn't going to work yet\n    # TODO: This should take a vector\n    def MfRhoIDeriv(self,u):\n        \"\"\"\n            Derivative of :code:`MfRhoI` with respect to the model. \n        \"\"\"\n        return self.mesh.getFaceInnerProductDeriv(self.curModel.rho, invMat=True)(u) * self.curModel.rhoDeriv",
  "def __init__(self, mesh, **kwargs):\n        Problem.BaseProblem.__init__(self, mesh, **kwargs)",
  "def _makeASymmetric(self):\n        if getattr(self, '__makeASymmetric', None) is None:\n            self.__makeASymmetric = True\n        return self.__makeASymmetric",
  "def deleteTheseOnModelUpdate(self):\n        toDelete = []\n        if self.mapping.sigmaMap is not None or self.mapping.rhoMap is not None:\n            toDelete += ['_MeSigma', '_MeSigmaI','_MfRho','_MfRhoI']\n        if self.mapping.muMap is not None or self.mapping.muiMap is not None:\n            toDelete += ['_MeMu', '_MeMuI','_MfMui','_MfMuiI']\n        return toDelete",
  "def Me(self):\n        \"\"\"\n            Edge inner product matrix\n        \"\"\"\n        if getattr(self, '_Me', None) is None:\n            self._Me = self.mesh.getEdgeInnerProduct()\n        return self._Me",
  "def Mf(self):\n        \"\"\"\n            Face inner product matrix\n        \"\"\"\n        if getattr(self, '_Mf', None) is None:\n            self._Mf = self.mesh.getFaceInnerProduct()\n        return self._Mf",
  "def MfMui(self):\n        \"\"\"\n            Face inner product matrix for \\\\(\\\\mu^{-1}\\\\). Used in the E-B formulation\n        \"\"\"\n        if getattr(self, '_MfMui', None) is None:\n            self._MfMui = self.mesh.getFaceInnerProduct(self.curModel.mui)\n        return self._MfMui",
  "def MfMuiI(self):\n        \"\"\"\n            Inverse of :code:`MfMui`.\n        \"\"\"\n        if getattr(self, '_MfMuiI', None) is None:\n            self._MfMuiI = self.mesh.getFaceInnerProduct(self.curModel.mui, invMat=True)\n        return self._MfMuiI",
  "def MeMu(self):\n        \"\"\"\n            Edge inner product matrix for \\\\(\\\\mu\\\\). Used in the H-J formulation\n        \"\"\"\n        if getattr(self, '_MeMu', None) is None:\n            self._MeMu = self.mesh.getEdgeInnerProduct(self.curModel.mu)\n        return self._MeMu",
  "def MeMuI(self):\n        \"\"\"\n            Inverse of :code:`MeMu`\n        \"\"\"\n        if getattr(self, '_MeMuI', None) is None:\n            self._MeMuI = self.mesh.getEdgeInnerProduct(self.curModel.mu, invMat=True)\n        return self._MeMuI",
  "def MeSigma(self):\n        \"\"\"\n            Edge inner product matrix for \\\\(\\\\sigma\\\\). Used in the E-B formulation\n        \"\"\"\n        if getattr(self, '_MeSigma', None) is None:\n            self._MeSigma = self.mesh.getEdgeInnerProduct(self.curModel.sigma)\n        return self._MeSigma",
  "def MeSigmaDeriv(self, u):\n        \"\"\"\n            Derivative of MeSigma with respect to the model\n        \"\"\" \n        return self.mesh.getEdgeInnerProductDeriv(self.curModel.sigma)(u) * self.curModel.sigmaDeriv",
  "def MeSigmaI(self):\n        \"\"\"\n            Inverse of the edge inner product matrix for \\\\(\\\\sigma\\\\). \n        \"\"\"\n        if getattr(self, '_MeSigmaI', None) is None:\n            self._MeSigmaI = self.mesh.getEdgeInnerProduct(self.curModel.sigma, invMat=True)\n        return self._MeSigmaI",
  "def MeSigmaIDeriv(self, u):\n        \"\"\"\n            Derivative of :code:`MeSigma` with respect to the model \n        \"\"\" \n        # TODO: only works for diagonal tensors. getEdgeInnerProductDeriv, invMat=True should be implemented in SimPEG\n\n        dMeSigmaI_dI = -self.MeSigmaI**2\n        dMe_dsig = self.mesh.getEdgeInnerProductDeriv(self.curModel.sigma)(u)\n        dsig_dm = self.curModel.sigmaDeriv\n        return dMeSigmaI_dI * ( dMe_dsig * ( dsig_dm))",
  "def MfRho(self):\n        \"\"\"\n            Face inner product matrix for \\\\(\\\\rho\\\\). Used in the H-J formulation\n        \"\"\"\n        if getattr(self, '_MfRho', None) is None:\n            self._MfRho = self.mesh.getFaceInnerProduct(self.curModel.rho)\n        return self._MfRho",
  "def MfRhoDeriv(self,u):\n        \"\"\"\n            Derivative of :code:`MfRho` with respect to the model. \n        \"\"\"\n        return self.mesh.getFaceInnerProductDeriv(self.curModel.rho)(u) * (-Utils.sdiag(self.curModel.rho**2) * self.curModel.sigmaDeriv)",
  "def MfRhoI(self):\n        \"\"\"\n            Inverse of :code:`MfRho`\n        \"\"\"\n        if getattr(self, '_MfRhoI', None) is None:\n            self._MfRhoI = self.mesh.getFaceInnerProduct(self.curModel.rho, invMat=True)\n        return self._MfRhoI",
  "def MfRhoIDeriv(self,u):\n        \"\"\"\n            Derivative of :code:`MfRhoI` with respect to the model. \n        \"\"\"\n        return self.mesh.getFaceInnerProductDeriv(self.curModel.rho, invMat=True)(u) * self.curModel.rhoDeriv",
  "class Rx(SimPEG.Survey.BaseRx):\n\n    knownRxTypes = {\n                    'exr':['e', 'Ex', 'real'],\n                    'eyr':['e', 'Ey', 'real'],\n                    'ezr':['e', 'Ez', 'real'],\n                    'exi':['e', 'Ex', 'imag'],\n                    'eyi':['e', 'Ey', 'imag'],\n                    'ezi':['e', 'Ez', 'imag'],\n\n                    'bxr':['b', 'Fx', 'real'],\n                    'byr':['b', 'Fy', 'real'],\n                    'bzr':['b', 'Fz', 'real'],\n                    'bxi':['b', 'Fx', 'imag'],\n                    'byi':['b', 'Fy', 'imag'],\n                    'bzi':['b', 'Fz', 'imag'],\n\n                    'jxr':['j', 'Fx', 'real'],\n                    'jyr':['j', 'Fy', 'real'],\n                    'jzr':['j', 'Fz', 'real'],\n                    'jxi':['j', 'Fx', 'imag'],\n                    'jyi':['j', 'Fy', 'imag'],\n                    'jzi':['j', 'Fz', 'imag'],\n\n                    'hxr':['h', 'Ex', 'real'],\n                    'hyr':['h', 'Ey', 'real'],\n                    'hzr':['h', 'Ez', 'real'],\n                    'hxi':['h', 'Ex', 'imag'],\n                    'hyi':['h', 'Ey', 'imag'],\n                    'hzi':['h', 'Ez', 'imag'],\n                   }\n    radius = None\n\n    def __init__(self, locs, rxType):\n        SimPEG.Survey.BaseRx.__init__(self, locs, rxType)\n\n    @property\n    def projField(self):\n        \"\"\"Field Type projection (e.g. e b ...)\"\"\"\n        return self.knownRxTypes[self.rxType][0]\n\n    @property\n    def projGLoc(self):\n        \"\"\"Grid Location projection (e.g. Ex Fy ...)\"\"\"\n        return self.knownRxTypes[self.rxType][1]\n\n    @property\n    def projComp(self):\n        \"\"\"Component projection (real/imag)\"\"\"\n        return self.knownRxTypes[self.rxType][2]\n\n    def projectFields(self, src, mesh, u):\n        P = self.getP(mesh)\n        u_part_complex = u[src, self.projField]\n        # get the real or imag component\n        real_or_imag = self.projComp\n        u_part = getattr(u_part_complex, real_or_imag)\n        return P*u_part\n\n    def projectFieldsDeriv(self, src, mesh, u, v, adjoint=False):\n        P = self.getP(mesh)\n\n        if not adjoint:\n            Pv_complex = P * v\n            real_or_imag = self.projComp\n            Pv = getattr(Pv_complex, real_or_imag)\n        elif adjoint:\n            Pv_real = P.T * v\n\n            real_or_imag = self.projComp\n            if real_or_imag == 'imag':\n                Pv = 1j*Pv_real\n            elif real_or_imag == 'real':\n                Pv = Pv_real.astype(complex)\n            else:\n                raise NotImplementedError('must be real or imag')\n\n        return Pv",
  "class Survey(SimPEG.Survey.BaseSurvey):\n    \"\"\"\n        docstring for SurveyFDEM\n    \"\"\"\n\n    srcPair = Src.BaseSrc\n\n    def __init__(self, srcList, **kwargs):\n        # Sort these by frequency\n        self.srcList = srcList\n        SimPEG.Survey.BaseSurvey.__init__(self, **kwargs)\n\n        _freqDict = {}\n        for src in srcList:\n            if src.freq not in _freqDict:\n                _freqDict[src.freq] = []\n            _freqDict[src.freq] += [src]\n\n        self._freqDict = _freqDict\n        self._freqs = sorted([f for f in self._freqDict])\n\n    @property\n    def freqs(self):\n        \"\"\"Frequencies\"\"\"\n        return self._freqs\n\n    @property\n    def nFreq(self):\n        \"\"\"Number of frequencies\"\"\"\n        return len(self._freqDict)\n\n    @property\n    def nSrcByFreq(self):\n        if getattr(self, '_nSrcByFreq', None) is None:\n            self._nSrcByFreq = {}\n            for freq in self.freqs:\n                self._nSrcByFreq[freq] = len(self.getSrcByFreq(freq))\n        return self._nSrcByFreq\n\n    def getSrcByFreq(self, freq):\n        \"\"\"Returns the sources associated with a specific frequency.\"\"\"\n        assert freq in self._freqDict, \"The requested frequency is not in this survey.\"\n        return self._freqDict[freq]\n\n    def projectFields(self, u):\n        data = SimPEG.Survey.Data(self)\n        for src in self.srcList:\n            for rx in src.rxList:\n                data[src, rx] = rx.projectFields(src, self.mesh, u)\n        return data\n\n    def projectFieldsDeriv(self, u):\n        raise Exception('Use Sources to project fields deriv.')",
  "def __init__(self, locs, rxType):\n        SimPEG.Survey.BaseRx.__init__(self, locs, rxType)",
  "def projField(self):\n        \"\"\"Field Type projection (e.g. e b ...)\"\"\"\n        return self.knownRxTypes[self.rxType][0]",
  "def projGLoc(self):\n        \"\"\"Grid Location projection (e.g. Ex Fy ...)\"\"\"\n        return self.knownRxTypes[self.rxType][1]",
  "def projComp(self):\n        \"\"\"Component projection (real/imag)\"\"\"\n        return self.knownRxTypes[self.rxType][2]",
  "def projectFields(self, src, mesh, u):\n        P = self.getP(mesh)\n        u_part_complex = u[src, self.projField]\n        # get the real or imag component\n        real_or_imag = self.projComp\n        u_part = getattr(u_part_complex, real_or_imag)\n        return P*u_part",
  "def projectFieldsDeriv(self, src, mesh, u, v, adjoint=False):\n        P = self.getP(mesh)\n\n        if not adjoint:\n            Pv_complex = P * v\n            real_or_imag = self.projComp\n            Pv = getattr(Pv_complex, real_or_imag)\n        elif adjoint:\n            Pv_real = P.T * v\n\n            real_or_imag = self.projComp\n            if real_or_imag == 'imag':\n                Pv = 1j*Pv_real\n            elif real_or_imag == 'real':\n                Pv = Pv_real.astype(complex)\n            else:\n                raise NotImplementedError('must be real or imag')\n\n        return Pv",
  "def __init__(self, srcList, **kwargs):\n        # Sort these by frequency\n        self.srcList = srcList\n        SimPEG.Survey.BaseSurvey.__init__(self, **kwargs)\n\n        _freqDict = {}\n        for src in srcList:\n            if src.freq not in _freqDict:\n                _freqDict[src.freq] = []\n            _freqDict[src.freq] += [src]\n\n        self._freqDict = _freqDict\n        self._freqs = sorted([f for f in self._freqDict])",
  "def freqs(self):\n        \"\"\"Frequencies\"\"\"\n        return self._freqs",
  "def nFreq(self):\n        \"\"\"Number of frequencies\"\"\"\n        return len(self._freqDict)",
  "def nSrcByFreq(self):\n        if getattr(self, '_nSrcByFreq', None) is None:\n            self._nSrcByFreq = {}\n            for freq in self.freqs:\n                self._nSrcByFreq[freq] = len(self.getSrcByFreq(freq))\n        return self._nSrcByFreq",
  "def getSrcByFreq(self, freq):\n        \"\"\"Returns the sources associated with a specific frequency.\"\"\"\n        assert freq in self._freqDict, \"The requested frequency is not in this survey.\"\n        return self._freqDict[freq]",
  "def projectFields(self, u):\n        data = SimPEG.Survey.Data(self)\n        for src in self.srcList:\n            for rx in src.rxList:\n                data[src, rx] = rx.projectFields(src, self.mesh, u)\n        return data",
  "def projectFieldsDeriv(self, u):\n        raise Exception('Use Sources to project fields deriv.')",
  "class BaseSrc(Survey.BaseSrc):\n    freq = None\n    # rxPair = Rx\n    integrate = True\n\n    def eval(self, prob):\n        S_m = self.S_m(prob)\n        S_e = self.S_e(prob)\n        return S_m, S_e\n\n    def evalDeriv(self, prob, v, adjoint=False):\n        return lambda v: self.S_mDeriv(prob,v,adjoint), lambda v: self.S_eDeriv(prob,v,adjoint)\n\n    def bPrimary(self, prob):\n        return None\n\n    def hPrimary(self, prob):\n        return None\n\n    def ePrimary(self, prob):\n        return None\n\n    def jPrimary(self, prob):\n        return None\n\n    def S_m(self, prob):\n        return None\n\n    def S_e(self, prob):\n        return None\n\n    def S_mDeriv(self, prob, v, adjoint = False):\n        return None\n\n    def S_eDeriv(self, prob, v, adjoint = False):\n        return None",
  "class RawVec_e(BaseSrc):\n    \"\"\"\n        RawVec electric source. It is defined by the user provided vector S_e\n\n        :param numpy.array S_e: electric source term\n        :param float freq: frequency\n        :param rxList: receiver list\n    \"\"\"\n\n    def __init__(self, rxList, freq, S_e, ePrimary=None, bPrimary=None, hPrimary=None, jPrimary=None):\n        self._S_e = np.array(S_e,dtype=complex)\n        self._ePrimary = ePrimary\n        self._bPrimary = bPrimary\n        self._hPrimary = hPrimary\n        self._jPrimary = jPrimary\n        self.freq = float(freq)\n        BaseSrc.__init__(self, rxList)\n\n    def S_e(self, prob):\n        return self._S_e\n\n    def ePrimary(self, prob):\n        return self._ePrimary\n\n    def bPrimary(self, prob):\n        return self._bPrimary\n\n    def hPrimary(self, prob):\n        return self._hPrimary\n\n    def jPrimary(self, prob):\n        return self._jPrimary",
  "class RawVec_m(BaseSrc):\n    \"\"\"\n        RawVec magnetic source. It is defined by the user provided vector S_m\n\n        :param numpy.array S_m: magnetic source term\n        :param float freq: frequency\n        :param rxList: receiver list\n    \"\"\"\n\n    def __init__(self, rxList, freq, S_m, integrate = True, ePrimary=None, bPrimary=None, hPrimary=None, jPrimary=None):\n        self._S_m = np.array(S_m,dtype=complex)\n        self.freq = float(freq)\n        self.integrate = integrate\n        self._ePrimary = np.array(ePrimary,dtype=complex)\n        self._bPrimary = np.array(bPrimary,dtype=complex)\n        self._hPrimary = np.array(hPrimary,dtype=complex)\n        self._jPrimary = np.array(jPrimary,dtype=complex)\n\n        BaseSrc.__init__(self, rxList)\n\n    def S_m(self, prob):\n        return self._S_m\n\n    def ePrimary(self, prob):\n        return self._ePrimary\n\n    def bPrimary(self, prob):\n        return self._bPrimary\n\n    def hPrimary(self, prob):\n        return self._hPrimary\n\n    def jPrimary(self, prob):\n        return self._jPrimary",
  "class RawVec(BaseSrc):\n    \"\"\"\n        RawVec source. It is defined by the user provided vectors S_m, S_e\n\n        :param numpy.array S_m: magnetic source term\n        :param numpy.array S_e: electric source term\n        :param float freq: frequency\n        :param rxList: receiver list\n    \"\"\"\n    def __init__(self, rxList, freq, S_m, S_e, integrate = True):\n        self._S_m = np.array(S_m,dtype=complex)\n        self._S_e = np.array(S_e,dtype=complex)\n        self.freq = float(freq)\n        self.integrate = integrate\n        BaseSrc.__init__(self, rxList)\n\n    def S_m(self, prob):\n        if prob._eqLocs is 'EF' and self.integrate is True:\n            return prob.Me * self._S_m\n        return self._S_m\n\n    def S_e(self, prob):\n        if prob._eqLocs is 'FE' and self.integrate is True:\n            return prob.Me * self._S_e\n        return self._S_e",
  "class MagDipole(BaseSrc):\n\n    #TODO: right now, orientation doesn't actually do anything! The methods in SrcUtils should take care of that\n    def __init__(self, rxList, freq, loc, orientation='Z', moment=1., mu = mu_0):\n        self.freq = float(freq)\n        self.loc = loc\n        self.orientation = orientation\n        self.moment = moment\n        self.mu = mu\n        self.integrate = False\n        BaseSrc.__init__(self, rxList)\n\n    def bPrimary(self, prob):\n        eqLocs = prob._eqLocs\n\n        if eqLocs is 'FE':\n            gridX = prob.mesh.gridEx\n            gridY = prob.mesh.gridEy\n            gridZ = prob.mesh.gridEz\n            C = prob.mesh.edgeCurl\n\n        elif eqLocs is 'EF':\n            gridX = prob.mesh.gridFx\n            gridY = prob.mesh.gridFy\n            gridZ = prob.mesh.gridFz\n            C = prob.mesh.edgeCurl.T\n\n\n        if prob.mesh._meshType is 'CYL':\n            if not prob.mesh.isSymmetric:\n                # TODO ?\n                raise NotImplementedError('Non-symmetric cyl mesh not implemented yet!')\n            a = MagneticDipoleVectorPotential(self.loc, gridY, 'y', mu=self.mu, moment=self.moment)\n\n        else:\n            srcfct = MagneticDipoleVectorPotential\n            ax = srcfct(self.loc, gridX, 'x', mu=self.mu, moment=self.moment)\n            ay = srcfct(self.loc, gridY, 'y', mu=self.mu, moment=self.moment)\n            az = srcfct(self.loc, gridZ, 'z', mu=self.mu, moment=self.moment)\n            a = np.concatenate((ax, ay, az))\n\n        return C*a\n\n    def hPrimary(self, prob):\n        b = self.bPrimary(prob)\n        return h_from_b(prob,b)\n\n    def S_m(self, prob):\n        b_p = self.bPrimary(prob)\n        return -1j*omega(self.freq)*b_p\n\n    def S_e(self, prob):\n        if all(np.r_[self.mu] == np.r_[prob.curModel.mu]):\n            return None\n        else:\n            eqLocs = prob._eqLocs\n\n            if eqLocs is 'FE':\n                mui_s = prob.curModel.mui - 1./self.mu\n                MMui_s = prob.mesh.getFaceInnerProduct(mui_s)\n                C = prob.mesh.edgeCurl\n            elif eqLocs is 'EF':\n                mu_s = prob.curModel.mu - self.mu\n                MMui_s = prob.mesh.getEdgeInnerProduct(mu_s,invMat=True)\n                C = prob.mesh.edgeCurl.T\n\n            return -C.T * (MMui_s * self.bPrimary(prob))",
  "class MagDipole_Bfield(BaseSrc):\n\n    #TODO: right now, orientation doesn't actually do anything! The methods in SrcUtils should take care of that\n    #TODO: neither does moment\n    def __init__(self, rxList, freq, loc, orientation='Z', moment=1., mu = mu_0):\n        self.freq = float(freq)\n        self.loc = loc\n        self.orientation = orientation\n        self.moment = moment\n        self.mu = mu\n        BaseSrc.__init__(self, rxList)\n\n    def bPrimary(self, prob):\n        eqLocs = prob._eqLocs\n\n        if eqLocs is 'FE':\n            gridX = prob.mesh.gridFx\n            gridY = prob.mesh.gridFy\n            gridZ = prob.mesh.gridFz\n            C = prob.mesh.edgeCurl\n\n        elif eqLocs is 'EF':\n            gridX = prob.mesh.gridEx\n            gridY = prob.mesh.gridEy\n            gridZ = prob.mesh.gridEz\n            C = prob.mesh.edgeCurl.T\n\n        srcfct = MagneticDipoleFields\n        if prob.mesh._meshType is 'CYL':\n            if not prob.mesh.isSymmetric:\n                # TODO ?\n                raise NotImplementedError('Non-symmetric cyl mesh not implemented yet!')\n            bx = srcfct(self.loc, gridX, 'x', mu=self.mu, moment=self.moment)\n            bz = srcfct(self.loc, gridZ, 'z', mu=self.mu, moment=self.moment)\n            b = np.concatenate((bx,bz))\n        else:\n            bx = srcfct(self.loc, gridX, 'x', mu=self.mu, moment=self.moment)\n            by = srcfct(self.loc, gridY, 'y', mu=self.mu, moment=self.moment)\n            bz = srcfct(self.loc, gridZ, 'z', mu=self.mu, moment=self.moment)\n            b = np.concatenate((bx,by,bz))\n\n        return b\n\n    def hPrimary(self, prob):\n        b = self.bPrimary(prob)\n        return h_from_b(prob, b)\n\n    def S_m(self, prob):\n        b = self.bPrimary(prob)\n        return -1j*omega(self.freq)*b\n\n    def S_e(self, prob):\n        if all(np.r_[self.mu] == np.r_[prob.curModel.mu]):\n            return None\n        else:\n            eqLocs = prob._eqLocs\n\n            if eqLocs is 'FE':\n                mui_s = prob.curModel.mui - 1./self.mu\n                MMui_s = prob.mesh.getFaceInnerProduct(mui_s)\n                C = prob.mesh.edgeCurl\n            elif eqLocs is 'EF':\n                mu_s = prob.curModel.mu - self.mu\n                MMui_s = prob.mesh.getEdgeInnerProduct(mu_s,invMat=True)\n                C = prob.mesh.edgeCurl.T\n\n            return -C.T * (MMui_s * self.bPrimary(prob))",
  "class CircularLoop(BaseSrc):\n\n    #TODO: right now, orientation doesn't actually do anything! The methods in SrcUtils should take care of that\n    def __init__(self, rxList, freq, loc, orientation='Z', radius = 1., mu=mu_0):\n        self.freq = float(freq)\n        self.orientation = orientation\n        self.radius = radius\n        self.mu = mu\n        self.loc = loc\n        self.integrate = False\n        BaseSrc.__init__(self, rxList)\n\n    def bPrimary(self, prob):\n        eqLocs = prob._eqLocs\n\n        if eqLocs is 'FE':\n            gridX = prob.mesh.gridEx\n            gridY = prob.mesh.gridEy\n            gridZ = prob.mesh.gridEz\n            C = prob.mesh.edgeCurl\n\n        elif eqLocs is 'EF':\n            gridX = prob.mesh.gridFx\n            gridY = prob.mesh.gridFy\n            gridZ = prob.mesh.gridFz\n            C = prob.mesh.edgeCurl.T\n\n        if prob.mesh._meshType is 'CYL':\n            if not prob.mesh.isSymmetric:\n                # TODO ?\n                raise NotImplementedError('Non-symmetric cyl mesh not implemented yet!')\n            a = MagneticDipoleVectorPotential(self.loc, gridY, 'y', moment=self.radius, mu=self.mu)\n\n        else:\n            srcfct = MagneticDipoleVectorPotential\n            ax = srcfct(self.loc, gridX, 'x', self.radius, mu=self.mu)\n            ay = srcfct(self.loc, gridY, 'y', self.radius, mu=self.mu)\n            az = srcfct(self.loc, gridZ, 'z', self.radius, mu=self.mu)\n            a = np.concatenate((ax, ay, az))\n\n        return C*a\n\n    def hPrimary(self, prob):\n        b = self.bPrimary(prob)\n        return 1./self.mu*b\n\n    def S_m(self, prob):\n        b = self.bPrimary(prob)\n        return -1j*omega(self.freq)*b\n\n    def S_e(self, prob):\n        if all(np.r_[self.mu] == np.r_[prob.curModel.mu]):\n            return None\n        else:\n            eqLocs = prob._eqLocs\n\n            if eqLocs is 'FE':\n                mui_s = prob.curModel.mui - 1./self.mu\n                MMui_s = prob.mesh.getFaceInnerProduct(mui_s)\n                C = prob.mesh.edgeCurl\n            elif eqLocs is 'EF':\n                mu_s = prob.curModel.mu - self.mu\n                MMui_s = prob.mesh.getEdgeInnerProduct(mu_s,invMat=True)\n                C = prob.mesh.edgeCurl.T\n\n            return -C.T * (MMui_s * self.bPrimary(prob))",
  "def eval(self, prob):\n        S_m = self.S_m(prob)\n        S_e = self.S_e(prob)\n        return S_m, S_e",
  "def evalDeriv(self, prob, v, adjoint=False):\n        return lambda v: self.S_mDeriv(prob,v,adjoint), lambda v: self.S_eDeriv(prob,v,adjoint)",
  "def bPrimary(self, prob):\n        return None",
  "def hPrimary(self, prob):\n        return None",
  "def ePrimary(self, prob):\n        return None",
  "def jPrimary(self, prob):\n        return None",
  "def S_m(self, prob):\n        return None",
  "def S_e(self, prob):\n        return None",
  "def S_mDeriv(self, prob, v, adjoint = False):\n        return None",
  "def S_eDeriv(self, prob, v, adjoint = False):\n        return None",
  "def __init__(self, rxList, freq, S_e, ePrimary=None, bPrimary=None, hPrimary=None, jPrimary=None):\n        self._S_e = np.array(S_e,dtype=complex)\n        self._ePrimary = ePrimary\n        self._bPrimary = bPrimary\n        self._hPrimary = hPrimary\n        self._jPrimary = jPrimary\n        self.freq = float(freq)\n        BaseSrc.__init__(self, rxList)",
  "def S_e(self, prob):\n        return self._S_e",
  "def ePrimary(self, prob):\n        return self._ePrimary",
  "def bPrimary(self, prob):\n        return self._bPrimary",
  "def hPrimary(self, prob):\n        return self._hPrimary",
  "def jPrimary(self, prob):\n        return self._jPrimary",
  "def __init__(self, rxList, freq, S_m, integrate = True, ePrimary=None, bPrimary=None, hPrimary=None, jPrimary=None):\n        self._S_m = np.array(S_m,dtype=complex)\n        self.freq = float(freq)\n        self.integrate = integrate\n        self._ePrimary = np.array(ePrimary,dtype=complex)\n        self._bPrimary = np.array(bPrimary,dtype=complex)\n        self._hPrimary = np.array(hPrimary,dtype=complex)\n        self._jPrimary = np.array(jPrimary,dtype=complex)\n\n        BaseSrc.__init__(self, rxList)",
  "def S_m(self, prob):\n        return self._S_m",
  "def ePrimary(self, prob):\n        return self._ePrimary",
  "def bPrimary(self, prob):\n        return self._bPrimary",
  "def hPrimary(self, prob):\n        return self._hPrimary",
  "def jPrimary(self, prob):\n        return self._jPrimary",
  "def __init__(self, rxList, freq, S_m, S_e, integrate = True):\n        self._S_m = np.array(S_m,dtype=complex)\n        self._S_e = np.array(S_e,dtype=complex)\n        self.freq = float(freq)\n        self.integrate = integrate\n        BaseSrc.__init__(self, rxList)",
  "def S_m(self, prob):\n        if prob._eqLocs is 'EF' and self.integrate is True:\n            return prob.Me * self._S_m\n        return self._S_m",
  "def S_e(self, prob):\n        if prob._eqLocs is 'FE' and self.integrate is True:\n            return prob.Me * self._S_e\n        return self._S_e",
  "def __init__(self, rxList, freq, loc, orientation='Z', moment=1., mu = mu_0):\n        self.freq = float(freq)\n        self.loc = loc\n        self.orientation = orientation\n        self.moment = moment\n        self.mu = mu\n        self.integrate = False\n        BaseSrc.__init__(self, rxList)",
  "def bPrimary(self, prob):\n        eqLocs = prob._eqLocs\n\n        if eqLocs is 'FE':\n            gridX = prob.mesh.gridEx\n            gridY = prob.mesh.gridEy\n            gridZ = prob.mesh.gridEz\n            C = prob.mesh.edgeCurl\n\n        elif eqLocs is 'EF':\n            gridX = prob.mesh.gridFx\n            gridY = prob.mesh.gridFy\n            gridZ = prob.mesh.gridFz\n            C = prob.mesh.edgeCurl.T\n\n\n        if prob.mesh._meshType is 'CYL':\n            if not prob.mesh.isSymmetric:\n                # TODO ?\n                raise NotImplementedError('Non-symmetric cyl mesh not implemented yet!')\n            a = MagneticDipoleVectorPotential(self.loc, gridY, 'y', mu=self.mu, moment=self.moment)\n\n        else:\n            srcfct = MagneticDipoleVectorPotential\n            ax = srcfct(self.loc, gridX, 'x', mu=self.mu, moment=self.moment)\n            ay = srcfct(self.loc, gridY, 'y', mu=self.mu, moment=self.moment)\n            az = srcfct(self.loc, gridZ, 'z', mu=self.mu, moment=self.moment)\n            a = np.concatenate((ax, ay, az))\n\n        return C*a",
  "def hPrimary(self, prob):\n        b = self.bPrimary(prob)\n        return h_from_b(prob,b)",
  "def S_m(self, prob):\n        b_p = self.bPrimary(prob)\n        return -1j*omega(self.freq)*b_p",
  "def S_e(self, prob):\n        if all(np.r_[self.mu] == np.r_[prob.curModel.mu]):\n            return None\n        else:\n            eqLocs = prob._eqLocs\n\n            if eqLocs is 'FE':\n                mui_s = prob.curModel.mui - 1./self.mu\n                MMui_s = prob.mesh.getFaceInnerProduct(mui_s)\n                C = prob.mesh.edgeCurl\n            elif eqLocs is 'EF':\n                mu_s = prob.curModel.mu - self.mu\n                MMui_s = prob.mesh.getEdgeInnerProduct(mu_s,invMat=True)\n                C = prob.mesh.edgeCurl.T\n\n            return -C.T * (MMui_s * self.bPrimary(prob))",
  "def __init__(self, rxList, freq, loc, orientation='Z', moment=1., mu = mu_0):\n        self.freq = float(freq)\n        self.loc = loc\n        self.orientation = orientation\n        self.moment = moment\n        self.mu = mu\n        BaseSrc.__init__(self, rxList)",
  "def bPrimary(self, prob):\n        eqLocs = prob._eqLocs\n\n        if eqLocs is 'FE':\n            gridX = prob.mesh.gridFx\n            gridY = prob.mesh.gridFy\n            gridZ = prob.mesh.gridFz\n            C = prob.mesh.edgeCurl\n\n        elif eqLocs is 'EF':\n            gridX = prob.mesh.gridEx\n            gridY = prob.mesh.gridEy\n            gridZ = prob.mesh.gridEz\n            C = prob.mesh.edgeCurl.T\n\n        srcfct = MagneticDipoleFields\n        if prob.mesh._meshType is 'CYL':\n            if not prob.mesh.isSymmetric:\n                # TODO ?\n                raise NotImplementedError('Non-symmetric cyl mesh not implemented yet!')\n            bx = srcfct(self.loc, gridX, 'x', mu=self.mu, moment=self.moment)\n            bz = srcfct(self.loc, gridZ, 'z', mu=self.mu, moment=self.moment)\n            b = np.concatenate((bx,bz))\n        else:\n            bx = srcfct(self.loc, gridX, 'x', mu=self.mu, moment=self.moment)\n            by = srcfct(self.loc, gridY, 'y', mu=self.mu, moment=self.moment)\n            bz = srcfct(self.loc, gridZ, 'z', mu=self.mu, moment=self.moment)\n            b = np.concatenate((bx,by,bz))\n\n        return b",
  "def hPrimary(self, prob):\n        b = self.bPrimary(prob)\n        return h_from_b(prob, b)",
  "def S_m(self, prob):\n        b = self.bPrimary(prob)\n        return -1j*omega(self.freq)*b",
  "def S_e(self, prob):\n        if all(np.r_[self.mu] == np.r_[prob.curModel.mu]):\n            return None\n        else:\n            eqLocs = prob._eqLocs\n\n            if eqLocs is 'FE':\n                mui_s = prob.curModel.mui - 1./self.mu\n                MMui_s = prob.mesh.getFaceInnerProduct(mui_s)\n                C = prob.mesh.edgeCurl\n            elif eqLocs is 'EF':\n                mu_s = prob.curModel.mu - self.mu\n                MMui_s = prob.mesh.getEdgeInnerProduct(mu_s,invMat=True)\n                C = prob.mesh.edgeCurl.T\n\n            return -C.T * (MMui_s * self.bPrimary(prob))",
  "def __init__(self, rxList, freq, loc, orientation='Z', radius = 1., mu=mu_0):\n        self.freq = float(freq)\n        self.orientation = orientation\n        self.radius = radius\n        self.mu = mu\n        self.loc = loc\n        self.integrate = False\n        BaseSrc.__init__(self, rxList)",
  "def bPrimary(self, prob):\n        eqLocs = prob._eqLocs\n\n        if eqLocs is 'FE':\n            gridX = prob.mesh.gridEx\n            gridY = prob.mesh.gridEy\n            gridZ = prob.mesh.gridEz\n            C = prob.mesh.edgeCurl\n\n        elif eqLocs is 'EF':\n            gridX = prob.mesh.gridFx\n            gridY = prob.mesh.gridFy\n            gridZ = prob.mesh.gridFz\n            C = prob.mesh.edgeCurl.T\n\n        if prob.mesh._meshType is 'CYL':\n            if not prob.mesh.isSymmetric:\n                # TODO ?\n                raise NotImplementedError('Non-symmetric cyl mesh not implemented yet!')\n            a = MagneticDipoleVectorPotential(self.loc, gridY, 'y', moment=self.radius, mu=self.mu)\n\n        else:\n            srcfct = MagneticDipoleVectorPotential\n            ax = srcfct(self.loc, gridX, 'x', self.radius, mu=self.mu)\n            ay = srcfct(self.loc, gridY, 'y', self.radius, mu=self.mu)\n            az = srcfct(self.loc, gridZ, 'z', self.radius, mu=self.mu)\n            a = np.concatenate((ax, ay, az))\n\n        return C*a",
  "def hPrimary(self, prob):\n        b = self.bPrimary(prob)\n        return 1./self.mu*b",
  "def S_m(self, prob):\n        b = self.bPrimary(prob)\n        return -1j*omega(self.freq)*b",
  "def S_e(self, prob):\n        if all(np.r_[self.mu] == np.r_[prob.curModel.mu]):\n            return None\n        else:\n            eqLocs = prob._eqLocs\n\n            if eqLocs is 'FE':\n                mui_s = prob.curModel.mui - 1./self.mu\n                MMui_s = prob.mesh.getFaceInnerProduct(mui_s)\n                C = prob.mesh.edgeCurl\n            elif eqLocs is 'EF':\n                mu_s = prob.curModel.mu - self.mu\n                MMui_s = prob.mesh.getEdgeInnerProduct(mu_s,invMat=True)\n                C = prob.mesh.edgeCurl.T\n\n            return -C.T * (MMui_s * self.bPrimary(prob))",
  "class Fields(SimPEG.Problem.Fields):\n    \"\"\"Fancy Field Storage for a FDEM survey.\"\"\"\n    knownFields = {}\n    dtype = complex",
  "class Fields_e(Fields):\n    knownFields = {'eSolution':'E'}\n    aliasFields = {\n                    'e' : ['eSolution','E','_e'],\n                    'ePrimary' : ['eSolution','E','_ePrimary'],\n                    'eSecondary' : ['eSolution','E','_eSecondary'],\n                    'b' : ['eSolution','F','_b'],\n                    'bPrimary' : ['eSolution','F','_bPrimary'],\n                    'bSecondary' : ['eSolution','F','_bSecondary']\n                  }\n\n    def __init__(self,mesh,survey,**kwargs):\n        Fields.__init__(self,mesh,survey,**kwargs)\n\n    def startup(self):\n        self.prob = self.survey.prob\n        self._edgeCurl = self.survey.prob.mesh.edgeCurl\n\n    def _ePrimary(self, eSolution, srcList):\n        ePrimary = np.zeros_like(eSolution)\n        for i, src in enumerate(srcList):\n            ep = src.ePrimary(self.prob)\n            if ep is not None:\n                ePrimary[:,i] = ep\n        return ePrimary\n\n    def _eSecondary(self, eSolution, srcList):\n        return eSolution\n\n    def _e(self, eSolution, srcList):\n        return self._ePrimary(eSolution,srcList) + self._eSecondary(eSolution,srcList)\n\n    def _eDeriv_u(self, src, v, adjoint = False):\n        return None\n\n    def _eDeriv_m(self, src, v, adjoint = False):\n        # assuming primary does not depend on the model\n        return None\n\n    def _bPrimary(self, eSolution, srcList):\n        bPrimary = np.zeros([self._edgeCurl.shape[0],eSolution.shape[1]],dtype = complex)\n        for i, src in enumerate(srcList):\n            bp = src.bPrimary(self.prob)\n            if bp is not None:\n                bPrimary[:,i] += bp\n        return bPrimary\n\n    def _bSecondary(self, eSolution, srcList):\n        C = self._edgeCurl\n        b = (C * eSolution)\n        for i, src in enumerate(srcList):\n            b[:,i] *= - 1./(1j*omega(src.freq))\n            S_m, _ = src.eval(self.prob)\n            if S_m is not None:\n                b[:,i] += 1./(1j*omega(src.freq)) * S_m\n        return b\n\n    def _bSecondaryDeriv_u(self, src, v, adjoint = False):\n        C = self._edgeCurl\n        if adjoint:\n            return - 1./(1j*omega(src.freq)) * (C.T * v)\n        return - 1./(1j*omega(src.freq)) * (C * v)\n\n    def _bSecondaryDeriv_m(self, src, v, adjoint = False):\n        S_mDeriv, _ = src.evalDeriv(self.prob, adjoint)\n        S_mDeriv = S_mDeriv(v)\n        if S_mDeriv is not None:\n            return 1./(1j * omega(src.freq)) * S_mDeriv\n        return None\n\n    def _b(self, eSolution, srcList):\n        return self._bPrimary(eSolution, srcList) + self._bSecondary(eSolution, srcList)\n\n    def _bDeriv_u(self, src, v, adjoint=False):\n        # Primary does not depend on u\n        return self._bSecondaryDeriv_u(src, v, adjoint)\n\n    def _bDeriv_m(self, src, v, adjoint=False):\n        # Assuming the primary does not depend on the model\n        return self._bSecondaryDeriv_m(src, v, adjoint)",
  "class Fields_b(Fields):\n    knownFields = {'bSolution':'F'}\n    aliasFields = {\n                    'b' : ['bSolution','F','_b'],\n                    'bPrimary' : ['bSolution','F','_bPrimary'],\n                    'bSecondary' : ['bSolution','F','_bSecondary'],\n                    'e' : ['bSolution','E','_e'],\n                    'ePrimary' : ['bSolution','E','_ePrimary'],\n                    'eSecondary' : ['bSolution','E','_eSecondary'],\n                  }\n\n    def __init__(self,mesh,survey,**kwargs):\n        Fields.__init__(self,mesh,survey,**kwargs)\n\n    def startup(self):\n        self.prob = self.survey.prob\n        self._edgeCurl = self.survey.prob.mesh.edgeCurl\n        self._MeSigmaI = self.survey.prob.MeSigmaI\n        self._MfMui = self.survey.prob.MfMui\n        self._MeSigmaIDeriv = self.survey.prob.MeSigmaIDeriv\n        self._Me = self.survey.prob.Me\n\n    def _bPrimary(self, bSolution, srcList):\n        bPrimary = np.zeros_like(bSolution)\n        for i, src in enumerate(srcList):\n            bp = src.bPrimary(self.prob)\n            if bp is not None:\n                bPrimary[:,i] = bp\n        return bPrimary\n\n    def _bSecondary(self, bSolution, srcList):\n        return bSolution\n\n    def _b(self, bSolution, srcList):\n        return self._bPrimary(bSolution, srcList) + self._bSecondary(bSolution, srcList)\n\n    def _bDeriv_u(self, src, v, adjoint=False):\n        return None\n\n    def _bDeriv_m(self, src, v, adjoint=False):\n        # assuming primary does not depend on the model\n        return None\n\n    def _ePrimary(self, bSolution, srcList):\n        ePrimary = np.zeros([self._edgeCurl.shape[1],bSolution.shape[1]],dtype = complex)\n        for i,src in enumerate(srcList):\n            ep = src.ePrimary(self.prob)\n            if ep is not None:\n                ePrimary[:,i] = ep\n        return ePrimary\n\n    def _eSecondary(self, bSolution, srcList):\n        e = self._MeSigmaI * ( self._edgeCurl.T * ( self._MfMui * bSolution))\n        for i,src in enumerate(srcList):\n            _,S_e = src.eval(self.prob)\n            if S_e is not None:\n                e[:,i] += -self._MeSigmaI * S_e\n        return e\n\n    def _eSecondaryDeriv_u(self, src, v, adjoint=False):\n        if not adjoint:\n            return self._MeSigmaI * ( self._edgeCurl.T * ( self._MfMui * v) )\n        else:\n            return self._MfMui.T * (self._edgeCurl * (self._MeSigmaI.T * v))\n\n    def _eSecondaryDeriv_m(self, src, v, adjoint=False):\n        bSolution = self[[src],'bSolution']\n        _,S_e = src.eval(self.prob)\n        Me = self._Me\n\n        if adjoint:\n            Me = Me.T\n\n        w = self._edgeCurl.T * (self._MfMui * bSolution)\n        if S_e is not None:\n            w += -Utils.mkvc(Me * S_e,2)\n\n        if not adjoint:\n            de_dm = self._MeSigmaIDeriv(w) * v\n        elif adjoint:\n            de_dm = self._MeSigmaIDeriv(w).T * v\n\n        _, S_eDeriv = src.evalDeriv(self.prob, adjoint)\n        Se_Deriv = S_eDeriv(v)\n\n        if Se_Deriv is not None:\n            de_dm += -self._MeSigmaI * Se_Deriv\n\n        return de_dm\n\n    def _e(self, bSolution, srcList):\n        return self._ePrimary(bSolution, srcList) + self._eSecondary(bSolution, srcList)\n\n    def _eDeriv_u(self, src, v, adjoint=False):\n        return self._eSecondaryDeriv_u(src, v, adjoint)\n\n    def _eDeriv_m(self, src, v, adjoint=False):\n        # assuming primary doesn't depend on model\n        return self._eSecondaryDeriv_m(src, v, adjoint)",
  "class Fields_j(Fields):\n    knownFields = {'jSolution':'F'}\n    aliasFields = {\n                    'j' : ['jSolution','F','_j'],\n                    'jPrimary' : ['jSolution','F','_jPrimary'],\n                    'jSecondary' : ['jSolution','F','_jSecondary'],\n                    'h' : ['jSolution','E','_h'],\n                    'hPrimary' : ['jSolution','E','_hPrimary'],\n                    'hSecondary' : ['jSolution','E','_hSecondary'],\n                  }\n\n    def __init__(self,mesh,survey,**kwargs):\n        Fields.__init__(self,mesh,survey,**kwargs)\n\n    def startup(self):\n        self.prob = self.survey.prob\n        self._edgeCurl = self.survey.prob.mesh.edgeCurl\n        self._MeMuI = self.survey.prob.MeMuI\n        self._MfRho = self.survey.prob.MfRho\n        self._MfRhoDeriv = self.survey.prob.MfRhoDeriv\n        self._Me = self.survey.prob.Me\n\n    def _jPrimary(self, jSolution, srcList):\n        jPrimary = np.zeros_like(jSolution,dtype = complex)\n        for i, src in enumerate(srcList):\n            jp = src.jPrimary(self.prob)\n            if jp is not None:\n                jPrimary[:,i] += jp\n        return jPrimary\n\n    def _jSecondary(self, jSolution, srcList):\n        return jSolution\n\n    def _j(self, jSolution, srcList):\n        return self._jPrimary(jSolution, srcList) + self._jSecondary(jSolution, srcList)\n\n    def _jDeriv_u(self, src, v, adjoint=False):\n        return None\n\n    def _jDeriv_m(self, src, v, adjoint=False):\n        # assuming primary does not depend on the model\n        return None\n\n    def _hPrimary(self, jSolution, srcList):\n        hPrimary = np.zeros([self._edgeCurl.shape[1],jSolution.shape[1]],dtype = complex)\n        for i, src in enumerate(srcList):\n            hp = src.hPrimary(self.prob)\n            if hp is not None:\n                hPrimary[:,i] = hp\n        return hPrimary\n\n    def _hSecondary(self, jSolution, srcList):\n        h =  self._MeMuI * (self._edgeCurl.T * (self._MfRho * jSolution) )\n        for i, src in enumerate(srcList):\n            h[:,i] *= -1./(1j*omega(src.freq))\n            S_m,_ = src.eval(self.prob)\n            if S_m is not None:\n                h[:,i] += 1./(1j*omega(src.freq)) * self._MeMuI * (S_m)\n        return h\n\n    def _hSecondaryDeriv_u(self, src, v, adjoint=False):\n        if not adjoint:\n            return  -1./(1j*omega(src.freq)) * self._MeMuI * (self._edgeCurl.T * (self._MfRho * v) )\n        elif adjoint:\n            return  -1./(1j*omega(src.freq)) * self._MfRho.T * (self._edgeCurl * ( self._MeMuI.T * v))\n\n    def _hSecondaryDeriv_m(self, src, v, adjoint=False):\n        jSolution = self[[src],'jSolution']\n        MeMuI = self._MeMuI\n        C = self._edgeCurl\n        MfRho = self._MfRho\n        MfRhoDeriv = self._MfRhoDeriv\n        Me = self._Me\n\n        if not adjoint:\n            hDeriv_m =  -1./(1j*omega(src.freq)) * MeMuI * (C.T * (MfRhoDeriv(jSolution)*v ) )\n        elif adjoint:\n            hDeriv_m =  -1./(1j*omega(src.freq)) * MfRhoDeriv(jSolution).T * ( C * (MeMuI.T * v ) )\n\n        S_mDeriv,_ = src.evalDeriv(self.prob, adjoint)\n\n        if not adjoint:\n            S_mDeriv = S_mDeriv(v)\n            if S_mDeriv is not None:\n                hDeriv_m += 1./(1j*omega(src.freq)) * MeMuI * (Me * S_mDeriv)\n        elif adjoint:\n            S_mDeriv = S_mDeriv(Me.T * (MeMuI.T * v))\n            if S_mDeriv is not None:\n                hDeriv_m += 1./(1j*omega(src.freq)) * S_mDeriv\n        return hDeriv_m\n\n\n    def _h(self, jSolution, srcList):\n        return self._hPrimary(jSolution, srcList) + self._hSecondary(jSolution, srcList)\n\n    def _hDeriv_u(self, src, v, adjoint=False):\n        return self._hSecondaryDeriv_u(src, v, adjoint)\n\n    def _hDeriv_m(self, src, v, adjoint=False):\n        # assuming the primary doesn't depend on the model\n        return self._hSecondaryDeriv_m(src, v, adjoint)",
  "class Fields_h(Fields):\n    knownFields = {'hSolution':'E'}\n    aliasFields = {\n                    'h' : ['hSolution','E','_h'],\n                    'hPrimary' : ['hSolution','E','_hPrimary'],\n                    'hSecondary' : ['hSolution','E','_hSecondary'],\n                    'j' : ['hSolution','F','_j'],\n                    'jPrimary' : ['hSolution','F','_jPrimary'],\n                    'jSecondary' : ['hSolution','F','_jSecondary']\n                  }\n\n    def __init__(self,mesh,survey,**kwargs):\n        Fields.__init__(self,mesh,survey,**kwargs)\n\n    def startup(self):\n        self.prob = self.survey.prob\n        self._edgeCurl = self.survey.prob.mesh.edgeCurl\n        self._MeMuI = self.survey.prob.MeMuI\n        self._MfRho = self.survey.prob.MfRho\n\n    def _hPrimary(self, hSolution, srcList):\n        hPrimary = np.zeros_like(hSolution,dtype = complex)\n        for i, src in enumerate(srcList):\n            hp = src.hPrimary(self.prob)\n            if hp is not None:\n                hPrimary[:,i] += hp\n            return hPrimary\n\n    def _hSecondary(self, hSolution, srcList):\n        return hSolution\n\n    def _h(self, hSolution, srcList):\n        return self._hPrimary(hSolution, srcList) + self._hSecondary(hSolution, srcList)\n\n    def _hDeriv_u(self, src, v, adjoint=False):\n        return None\n\n    def _hDeriv_m(self, src, v, adjoint=False):\n        # assuming primary does not depend on the model\n        return None\n\n    def _jPrimary(self, hSolution, srcList):\n        jPrimary = np.zeros([self._edgeCurl.shape[0], hSolution.shape[1]], dtype = complex)\n        for i, src in enumerate(srcList):\n            jp = src.jPrimary(self.prob)\n            if jp is not None:\n                jPrimary[:,i] = jp\n        return jPrimary\n\n    def _jSecondary(self, hSolution, srcList):\n        j = self._edgeCurl*hSolution\n        for i, src in enumerate(srcList):\n            _,S_e = src.eval(self.prob)\n            if S_e is not None:\n                j[:,i] += -S_e\n        return j\n\n    def _jSecondaryDeriv_u(self, src, v, adjoint=False):\n        if not adjoint:\n            return self._edgeCurl*v\n        elif adjoint:\n            return self._edgeCurl.T*v\n\n    def _jSecondaryDeriv_m(self, src, v, adjoint=False):\n        _,S_eDeriv = src.evalDeriv(self.prob, adjoint)\n        S_eDeriv = S_eDeriv(v)\n        if S_eDeriv is not None:\n            return -S_eDeriv\n        return None\n\n    def _j(self, hSolution, srcList):\n        return self._jPrimary(hSolution, srcList) + self._jSecondary(hSolution, srcList)\n\n    def _jDeriv_u(self, src, v, adjoint=False):\n        return self._jSecondaryDeriv_u(src,v,adjoint)\n\n    def _jDeriv_m(self, src, v, adjoint=False):\n        # assuming the primary does not depend on the model\n        return self._jSecondaryDeriv_m(src,v,adjoint)",
  "def __init__(self,mesh,survey,**kwargs):\n        Fields.__init__(self,mesh,survey,**kwargs)",
  "def startup(self):\n        self.prob = self.survey.prob\n        self._edgeCurl = self.survey.prob.mesh.edgeCurl",
  "def _ePrimary(self, eSolution, srcList):\n        ePrimary = np.zeros_like(eSolution)\n        for i, src in enumerate(srcList):\n            ep = src.ePrimary(self.prob)\n            if ep is not None:\n                ePrimary[:,i] = ep\n        return ePrimary",
  "def _eSecondary(self, eSolution, srcList):\n        return eSolution",
  "def _e(self, eSolution, srcList):\n        return self._ePrimary(eSolution,srcList) + self._eSecondary(eSolution,srcList)",
  "def _eDeriv_u(self, src, v, adjoint = False):\n        return None",
  "def _eDeriv_m(self, src, v, adjoint = False):\n        # assuming primary does not depend on the model\n        return None",
  "def _bPrimary(self, eSolution, srcList):\n        bPrimary = np.zeros([self._edgeCurl.shape[0],eSolution.shape[1]],dtype = complex)\n        for i, src in enumerate(srcList):\n            bp = src.bPrimary(self.prob)\n            if bp is not None:\n                bPrimary[:,i] += bp\n        return bPrimary",
  "def _bSecondary(self, eSolution, srcList):\n        C = self._edgeCurl\n        b = (C * eSolution)\n        for i, src in enumerate(srcList):\n            b[:,i] *= - 1./(1j*omega(src.freq))\n            S_m, _ = src.eval(self.prob)\n            if S_m is not None:\n                b[:,i] += 1./(1j*omega(src.freq)) * S_m\n        return b",
  "def _bSecondaryDeriv_u(self, src, v, adjoint = False):\n        C = self._edgeCurl\n        if adjoint:\n            return - 1./(1j*omega(src.freq)) * (C.T * v)\n        return - 1./(1j*omega(src.freq)) * (C * v)",
  "def _bSecondaryDeriv_m(self, src, v, adjoint = False):\n        S_mDeriv, _ = src.evalDeriv(self.prob, adjoint)\n        S_mDeriv = S_mDeriv(v)\n        if S_mDeriv is not None:\n            return 1./(1j * omega(src.freq)) * S_mDeriv\n        return None",
  "def _b(self, eSolution, srcList):\n        return self._bPrimary(eSolution, srcList) + self._bSecondary(eSolution, srcList)",
  "def _bDeriv_u(self, src, v, adjoint=False):\n        # Primary does not depend on u\n        return self._bSecondaryDeriv_u(src, v, adjoint)",
  "def _bDeriv_m(self, src, v, adjoint=False):\n        # Assuming the primary does not depend on the model\n        return self._bSecondaryDeriv_m(src, v, adjoint)",
  "def __init__(self,mesh,survey,**kwargs):\n        Fields.__init__(self,mesh,survey,**kwargs)",
  "def startup(self):\n        self.prob = self.survey.prob\n        self._edgeCurl = self.survey.prob.mesh.edgeCurl\n        self._MeSigmaI = self.survey.prob.MeSigmaI\n        self._MfMui = self.survey.prob.MfMui\n        self._MeSigmaIDeriv = self.survey.prob.MeSigmaIDeriv\n        self._Me = self.survey.prob.Me",
  "def _bPrimary(self, bSolution, srcList):\n        bPrimary = np.zeros_like(bSolution)\n        for i, src in enumerate(srcList):\n            bp = src.bPrimary(self.prob)\n            if bp is not None:\n                bPrimary[:,i] = bp\n        return bPrimary",
  "def _bSecondary(self, bSolution, srcList):\n        return bSolution",
  "def _b(self, bSolution, srcList):\n        return self._bPrimary(bSolution, srcList) + self._bSecondary(bSolution, srcList)",
  "def _bDeriv_u(self, src, v, adjoint=False):\n        return None",
  "def _bDeriv_m(self, src, v, adjoint=False):\n        # assuming primary does not depend on the model\n        return None",
  "def _ePrimary(self, bSolution, srcList):\n        ePrimary = np.zeros([self._edgeCurl.shape[1],bSolution.shape[1]],dtype = complex)\n        for i,src in enumerate(srcList):\n            ep = src.ePrimary(self.prob)\n            if ep is not None:\n                ePrimary[:,i] = ep\n        return ePrimary",
  "def _eSecondary(self, bSolution, srcList):\n        e = self._MeSigmaI * ( self._edgeCurl.T * ( self._MfMui * bSolution))\n        for i,src in enumerate(srcList):\n            _,S_e = src.eval(self.prob)\n            if S_e is not None:\n                e[:,i] += -self._MeSigmaI * S_e\n        return e",
  "def _eSecondaryDeriv_u(self, src, v, adjoint=False):\n        if not adjoint:\n            return self._MeSigmaI * ( self._edgeCurl.T * ( self._MfMui * v) )\n        else:\n            return self._MfMui.T * (self._edgeCurl * (self._MeSigmaI.T * v))",
  "def _eSecondaryDeriv_m(self, src, v, adjoint=False):\n        bSolution = self[[src],'bSolution']\n        _,S_e = src.eval(self.prob)\n        Me = self._Me\n\n        if adjoint:\n            Me = Me.T\n\n        w = self._edgeCurl.T * (self._MfMui * bSolution)\n        if S_e is not None:\n            w += -Utils.mkvc(Me * S_e,2)\n\n        if not adjoint:\n            de_dm = self._MeSigmaIDeriv(w) * v\n        elif adjoint:\n            de_dm = self._MeSigmaIDeriv(w).T * v\n\n        _, S_eDeriv = src.evalDeriv(self.prob, adjoint)\n        Se_Deriv = S_eDeriv(v)\n\n        if Se_Deriv is not None:\n            de_dm += -self._MeSigmaI * Se_Deriv\n\n        return de_dm",
  "def _e(self, bSolution, srcList):\n        return self._ePrimary(bSolution, srcList) + self._eSecondary(bSolution, srcList)",
  "def _eDeriv_u(self, src, v, adjoint=False):\n        return self._eSecondaryDeriv_u(src, v, adjoint)",
  "def _eDeriv_m(self, src, v, adjoint=False):\n        # assuming primary doesn't depend on model\n        return self._eSecondaryDeriv_m(src, v, adjoint)",
  "def __init__(self,mesh,survey,**kwargs):\n        Fields.__init__(self,mesh,survey,**kwargs)",
  "def startup(self):\n        self.prob = self.survey.prob\n        self._edgeCurl = self.survey.prob.mesh.edgeCurl\n        self._MeMuI = self.survey.prob.MeMuI\n        self._MfRho = self.survey.prob.MfRho\n        self._MfRhoDeriv = self.survey.prob.MfRhoDeriv\n        self._Me = self.survey.prob.Me",
  "def _jPrimary(self, jSolution, srcList):\n        jPrimary = np.zeros_like(jSolution,dtype = complex)\n        for i, src in enumerate(srcList):\n            jp = src.jPrimary(self.prob)\n            if jp is not None:\n                jPrimary[:,i] += jp\n        return jPrimary",
  "def _jSecondary(self, jSolution, srcList):\n        return jSolution",
  "def _j(self, jSolution, srcList):\n        return self._jPrimary(jSolution, srcList) + self._jSecondary(jSolution, srcList)",
  "def _jDeriv_u(self, src, v, adjoint=False):\n        return None",
  "def _jDeriv_m(self, src, v, adjoint=False):\n        # assuming primary does not depend on the model\n        return None",
  "def _hPrimary(self, jSolution, srcList):\n        hPrimary = np.zeros([self._edgeCurl.shape[1],jSolution.shape[1]],dtype = complex)\n        for i, src in enumerate(srcList):\n            hp = src.hPrimary(self.prob)\n            if hp is not None:\n                hPrimary[:,i] = hp\n        return hPrimary",
  "def _hSecondary(self, jSolution, srcList):\n        h =  self._MeMuI * (self._edgeCurl.T * (self._MfRho * jSolution) )\n        for i, src in enumerate(srcList):\n            h[:,i] *= -1./(1j*omega(src.freq))\n            S_m,_ = src.eval(self.prob)\n            if S_m is not None:\n                h[:,i] += 1./(1j*omega(src.freq)) * self._MeMuI * (S_m)\n        return h",
  "def _hSecondaryDeriv_u(self, src, v, adjoint=False):\n        if not adjoint:\n            return  -1./(1j*omega(src.freq)) * self._MeMuI * (self._edgeCurl.T * (self._MfRho * v) )\n        elif adjoint:\n            return  -1./(1j*omega(src.freq)) * self._MfRho.T * (self._edgeCurl * ( self._MeMuI.T * v))",
  "def _hSecondaryDeriv_m(self, src, v, adjoint=False):\n        jSolution = self[[src],'jSolution']\n        MeMuI = self._MeMuI\n        C = self._edgeCurl\n        MfRho = self._MfRho\n        MfRhoDeriv = self._MfRhoDeriv\n        Me = self._Me\n\n        if not adjoint:\n            hDeriv_m =  -1./(1j*omega(src.freq)) * MeMuI * (C.T * (MfRhoDeriv(jSolution)*v ) )\n        elif adjoint:\n            hDeriv_m =  -1./(1j*omega(src.freq)) * MfRhoDeriv(jSolution).T * ( C * (MeMuI.T * v ) )\n\n        S_mDeriv,_ = src.evalDeriv(self.prob, adjoint)\n\n        if not adjoint:\n            S_mDeriv = S_mDeriv(v)\n            if S_mDeriv is not None:\n                hDeriv_m += 1./(1j*omega(src.freq)) * MeMuI * (Me * S_mDeriv)\n        elif adjoint:\n            S_mDeriv = S_mDeriv(Me.T * (MeMuI.T * v))\n            if S_mDeriv is not None:\n                hDeriv_m += 1./(1j*omega(src.freq)) * S_mDeriv\n        return hDeriv_m",
  "def _h(self, jSolution, srcList):\n        return self._hPrimary(jSolution, srcList) + self._hSecondary(jSolution, srcList)",
  "def _hDeriv_u(self, src, v, adjoint=False):\n        return self._hSecondaryDeriv_u(src, v, adjoint)",
  "def _hDeriv_m(self, src, v, adjoint=False):\n        # assuming the primary doesn't depend on the model\n        return self._hSecondaryDeriv_m(src, v, adjoint)",
  "def __init__(self,mesh,survey,**kwargs):\n        Fields.__init__(self,mesh,survey,**kwargs)",
  "def startup(self):\n        self.prob = self.survey.prob\n        self._edgeCurl = self.survey.prob.mesh.edgeCurl\n        self._MeMuI = self.survey.prob.MeMuI\n        self._MfRho = self.survey.prob.MfRho",
  "def _hPrimary(self, hSolution, srcList):\n        hPrimary = np.zeros_like(hSolution,dtype = complex)\n        for i, src in enumerate(srcList):\n            hp = src.hPrimary(self.prob)\n            if hp is not None:\n                hPrimary[:,i] += hp\n            return hPrimary",
  "def _hSecondary(self, hSolution, srcList):\n        return hSolution",
  "def _h(self, hSolution, srcList):\n        return self._hPrimary(hSolution, srcList) + self._hSecondary(hSolution, srcList)",
  "def _hDeriv_u(self, src, v, adjoint=False):\n        return None",
  "def _hDeriv_m(self, src, v, adjoint=False):\n        # assuming primary does not depend on the model\n        return None",
  "def _jPrimary(self, hSolution, srcList):\n        jPrimary = np.zeros([self._edgeCurl.shape[0], hSolution.shape[1]], dtype = complex)\n        for i, src in enumerate(srcList):\n            jp = src.jPrimary(self.prob)\n            if jp is not None:\n                jPrimary[:,i] = jp\n        return jPrimary",
  "def _jSecondary(self, hSolution, srcList):\n        j = self._edgeCurl*hSolution\n        for i, src in enumerate(srcList):\n            _,S_e = src.eval(self.prob)\n            if S_e is not None:\n                j[:,i] += -S_e\n        return j",
  "def _jSecondaryDeriv_u(self, src, v, adjoint=False):\n        if not adjoint:\n            return self._edgeCurl*v\n        elif adjoint:\n            return self._edgeCurl.T*v",
  "def _jSecondaryDeriv_m(self, src, v, adjoint=False):\n        _,S_eDeriv = src.evalDeriv(self.prob, adjoint)\n        S_eDeriv = S_eDeriv(v)\n        if S_eDeriv is not None:\n            return -S_eDeriv\n        return None",
  "def _j(self, hSolution, srcList):\n        return self._jPrimary(hSolution, srcList) + self._jSecondary(hSolution, srcList)",
  "def _jDeriv_u(self, src, v, adjoint=False):\n        return self._jSecondaryDeriv_u(src,v,adjoint)",
  "def _jDeriv_m(self, src, v, adjoint=False):\n        # assuming the primary does not depend on the model\n        return self._jSecondaryDeriv_m(src,v,adjoint)",
  "class BaseFDEMProblem(BaseEMProblem):\n    \"\"\"\n        We start by looking at Maxwell's equations in the electric\n        field \\\\\\(\\\\\\mathbf{e}\\\\\\) and the magnetic flux\n        density \\\\\\(\\\\\\mathbf{b}\\\\\\)\n\n        .. math ::\n\n            \\mathbf{C} \\mathbf{e} + i \\omega \\mathbf{b} = \\mathbf{s_m} \\\\\\\\\n            {\\mathbf{C}^T \\mathbf{M_{\\mu^{-1}}^f} \\mathbf{b} - \\mathbf{M_{\\sigma}^e} \\mathbf{e} = \\mathbf{M^e} \\mathbf{s_e}}\n\n        if using the E-B formulation (:code:`Problem_e`\n        or :code:`Problem_b`) or the magnetic field\n        \\\\\\(\\\\\\mathbf{h}\\\\\\) and current density \\\\\\(\\\\\\mathbf{j}\\\\\\)\n\n        .. math ::\n\n            \\mathbf{C}^T \\mathbf{M_{\\\\rho}^f} \\mathbf{j} + i \\omega \\mathbf{M_{\\mu}^e} \\mathbf{h} = \\mathbf{M^e} \\mathbf{s_m} \\\\\\\\\n            \\mathbf{C} \\mathbf{h} - \\mathbf{j} = \\mathbf{s_e}\n\n        if using the H-J formulation (:code:`Problem_j` or :code:`Problem_h`).\n\n        The problem performs the elimination so that we are solving the system for \\\\\\(\\\\\\mathbf{e},\\\\\\mathbf{b},\\\\\\mathbf{j} \\\\\\) or \\\\\\(\\\\\\mathbf{h}\\\\\\)\n    \"\"\"\n\n    surveyPair = SurveyFDEM\n    fieldsPair = Fields\n\n    def fields(self, m=None):\n        \"\"\"\n            Solve the forward problem for the fields.\n        \"\"\"\n\n        self.curModel = m\n        F = self.fieldsPair(self.mesh, self.survey)\n\n        for freq in self.survey.freqs:\n            A = self.getA(freq)\n            rhs = self.getRHS(freq)\n            Ainv = self.Solver(A, **self.solverOpts)\n            sol = Ainv * rhs\n            Srcs = self.survey.getSrcByFreq(freq)\n            ftype = self._fieldType + 'Solution'\n            F[Srcs, ftype] = sol\n\n        return F\n\n    def Jvec(self, m, v, f=None):\n        \"\"\"\n            Sensitivity times a vector\n        \"\"\"\n\n        if f is None:\n           f = self.fields(m)\n\n        self.curModel = m\n\n        Jv = self.dataPair(self.survey)\n\n        for freq in self.survey.freqs:\n            dA_du = self.getA(freq) #\n            dA_duI = self.Solver(dA_du, **self.solverOpts)\n\n            for src in self.survey.getSrcByFreq(freq):\n                ftype = self._fieldType + 'Solution'\n                u_src = f[src, ftype]\n                dA_dm = self.getADeriv_m(freq, u_src, v)\n                dRHS_dm = self.getRHSDeriv_m(src, v)\n                if dRHS_dm is None:\n                    du_dm = dA_duI * ( - dA_dm )\n                else:\n                    du_dm = dA_duI * ( - dA_dm + dRHS_dm )\n                for rx in src.rxList:\n                    # df_duFun = u.deriv_u(rx.fieldsUsed, m)\n                    df_duFun = getattr(f, '_%sDeriv_u'%rx.projField, None)\n                    df_du = df_duFun(src, du_dm, adjoint=False)\n                    if df_du is not None:\n                        du_dm = df_du\n\n                    df_dmFun = getattr(f, '_%sDeriv_m'%rx.projField, None)\n                    df_dm = df_dmFun(src, v, adjoint=False)\n                    if df_dm is not None:\n                        du_dm += df_dm\n\n                    P = lambda v: rx.projectFieldsDeriv(src, self.mesh, f, v) # wrt u, also have wrt m\n\n\n                    Jv[src, rx] = P(du_dm)\n\n        return Utils.mkvc(Jv)\n\n    def Jtvec(self, m, v, f=None):\n        \"\"\"\n            Sensitivity transpose times a vector\n        \"\"\"\n\n        if f is None:\n            f = self.fields(m)\n\n        self.curModel = m\n\n        # Ensure v is a data object.\n        if not isinstance(v, self.dataPair):\n            v = self.dataPair(self.survey, v)\n\n        Jtv = np.zeros(m.size)\n\n        for freq in self.survey.freqs:\n            AT = self.getA(freq).T\n            ATinv = self.Solver(AT, **self.solverOpts)\n\n            for src in self.survey.getSrcByFreq(freq):\n                ftype = self._fieldType + 'Solution'\n                u_src = f[src, ftype]\n\n                for rx in src.rxList:\n                    PTv = rx.projectFieldsDeriv(src, self.mesh, f, v[src, rx], adjoint=True) # wrt u, need possibility wrt m\n\n                    df_duTFun = getattr(f, '_%sDeriv_u'%rx.projField, None)\n                    df_duT = df_duTFun(src, PTv, adjoint=True)\n                    if df_duT is not None:\n                        dA_duIT = ATinv * df_duT\n                    else:\n                        dA_duIT = ATinv * PTv\n\n                    dA_dmT = self.getADeriv_m(freq, u_src, dA_duIT, adjoint=True)\n\n                    dRHS_dmT = self.getRHSDeriv_m(src, dA_duIT, adjoint=True)\n\n                    if dRHS_dmT is None:\n                        du_dmT = - dA_dmT\n                    else:\n                        du_dmT = -dA_dmT + dRHS_dmT\n\n                    df_dmFun = getattr(f, '_%sDeriv_m'%rx.projField, None)\n                    dfT_dm = df_dmFun(src, PTv, adjoint=True)\n                    if dfT_dm is not None:\n                        du_dmT += dfT_dm\n\n                    real_or_imag = rx.projComp\n                    if real_or_imag == 'real':\n                        Jtv +=   du_dmT.real\n                    elif real_or_imag == 'imag':\n                        Jtv += - du_dmT.real\n                    else:\n                        raise Exception('Must be real or imag')\n\n        return Jtv\n\n    def getSourceTerm(self, freq):\n        \"\"\"\n            Evaluates the sources for a given frequency and puts them in matrix form\n\n            :param float freq: Frequency\n            :rtype: numpy.ndarray (nE or nF, nSrc)\n            :return: S_m, S_e\n        \"\"\"\n        Srcs = self.survey.getSrcByFreq(freq)\n        if self._eqLocs is 'FE':\n            S_m = np.zeros((self.mesh.nF,len(Srcs)), dtype=complex)\n            S_e = np.zeros((self.mesh.nE,len(Srcs)), dtype=complex)\n        elif self._eqLocs is 'EF':\n            S_m = np.zeros((self.mesh.nE,len(Srcs)), dtype=complex)\n            S_e = np.zeros((self.mesh.nF,len(Srcs)), dtype=complex)\n\n        for i, src in enumerate(Srcs):\n            smi, sei = src.eval(self)\n            if smi is not None:\n                S_m[:,i] = Utils.mkvc(smi)\n            if sei is not None:\n                S_e[:,i] = Utils.mkvc(sei)\n\n        return S_m, S_e",
  "class Problem_e(BaseFDEMProblem):\n    \"\"\"\n        By eliminating the magnetic flux density using\n\n            .. math ::\n\n                \\mathbf{b} = \\\\frac{1}{i \\omega}\\\\left(-\\mathbf{C} \\mathbf{e} + \\mathbf{s_m}\\\\right)\n\n\n        we can write Maxwell's equations as a second order system in \\\\\\(\\\\\\mathbf{e}\\\\\\) only:\n\n        .. math ::\n\n            \\\\left(\\mathbf{C}^T \\mathbf{M_{\\mu^{-1}}^f} \\mathbf{C}+ i \\omega \\mathbf{M^e_{\\sigma}} \\\\right)\\mathbf{e} = \\mathbf{C}^T \\mathbf{M_{\\mu^{-1}}^f}\\mathbf{s_m} -i\\omega\\mathbf{M^e}\\mathbf{s_e}\n\n        which we solve for \\\\\\(\\\\\\mathbf{e}\\\\\\).\n    \"\"\"\n\n    _fieldType = 'e'\n    _eqLocs    = 'FE'\n    fieldsPair = Fields_e\n\n    def __init__(self, mesh, **kwargs):\n        BaseFDEMProblem.__init__(self, mesh, **kwargs)\n\n    def getA(self, freq):\n        \"\"\"\n            .. math ::\n                \\mathbf{A} = \\mathbf{C}^T \\mathbf{M_{\\mu^{-1}}^f} \\mathbf{C} + i \\omega \\mathbf{M^e_{\\sigma}}\n\n            :param float freq: Frequency\n            :rtype: scipy.sparse.csr_matrix\n            :return: A\n        \"\"\"\n        MfMui = self.MfMui\n        MeSigma = self.MeSigma\n        C = self.mesh.edgeCurl\n\n        return C.T*MfMui*C + 1j*omega(freq)*MeSigma\n\n\n    def getADeriv_m(self, freq, u, v, adjoint=False):\n        dsig_dm = self.curModel.sigmaDeriv\n        dMe_dsig = self.MeSigmaDeriv(u)\n\n        if adjoint:\n            return 1j * omega(freq) * ( dMe_dsig.T * v )\n\n        return 1j * omega(freq) * ( dMe_dsig * v )\n\n    def getRHS(self, freq):\n        \"\"\"\n            .. math ::\n                \\mathbf{RHS} = \\mathbf{C}^T \\mathbf{M_{\\mu^{-1}}^f}\\mathbf{s_m} -i\\omega\\mathbf{M_e}\\mathbf{s_e}\n\n            :param float freq: Frequency\n            :rtype: numpy.ndarray (nE, nSrc)\n            :return: RHS\n        \"\"\"\n\n        S_m, S_e = self.getSourceTerm(freq)\n        C = self.mesh.edgeCurl\n        MfMui = self.MfMui\n\n        # RHS = C.T * (MfMui * S_m) -1j * omega(freq) * Me * S_e\n        RHS = C.T * (MfMui * S_m) -1j * omega(freq) * S_e\n\n        return RHS\n\n    def getRHSDeriv_m(self, src, v, adjoint=False):\n        C = self.mesh.edgeCurl\n        MfMui = self.MfMui\n        S_mDeriv, S_eDeriv = src.evalDeriv(self, adjoint)\n\n        if adjoint:\n            dRHS = MfMui * (C * v)\n            S_mDerivv = S_mDeriv(dRHS)\n            S_eDerivv = S_eDeriv(v)\n            if S_mDerivv is not None and S_eDerivv is not None:\n                return S_mDerivv - 1j * omega(freq) * S_eDerivv\n            elif S_mDerivv is not None:\n                return S_mDerivv\n            elif S_eDerivv is not None:\n                return - 1j * omega(freq) * S_eDerivv\n            else:\n                return None\n        else:\n            S_mDerivv, S_eDerivv = S_mDeriv(v), S_eDeriv(v)\n\n            if S_mDerivv is not None and S_eDerivv is not None:\n                return C.T * (MfMui * S_mDerivv) -1j * omega(freq) * S_eDerivv\n            elif S_mDerivv is not None:\n                return C.T * (MfMui * S_mDerivv)\n            elif S_eDerivv is not None:\n                return -1j * omega(freq) * S_eDerivv\n            else:\n                return None",
  "class Problem_b(BaseFDEMProblem):\n    \"\"\"\n        We eliminate \\\\\\(\\\\\\mathbf{e}\\\\\\) using\n\n        .. math ::\n\n             \\mathbf{e} = \\mathbf{M^e_{\\sigma}}^{-1} \\\\left(\\mathbf{C}^T \\mathbf{M_{\\mu^{-1}}^f} \\mathbf{b} - \\mathbf{s_e}\\\\right)\n\n        and solve for \\\\\\(\\\\\\mathbf{b}\\\\\\) using:\n\n        .. math ::\n\n            \\\\left(\\mathbf{C} \\mathbf{M^e_{\\sigma}}^{-1} \\mathbf{C}^T \\mathbf{M_{\\mu^{-1}}^f}  + i \\omega \\\\right)\\mathbf{b} = \\mathbf{s_m} + \\mathbf{M^e_{\\sigma}}^{-1}\\mathbf{M^e}\\mathbf{s_e}\n\n        .. note ::\n            The inverse problem will not work with full anisotropy\n    \"\"\"\n\n    _fieldType = 'b'\n    _eqLocs    = 'FE'\n    fieldsPair = Fields_b\n\n    def __init__(self, mesh, **kwargs):\n        BaseFDEMProblem.__init__(self, mesh, **kwargs)\n\n    def getA(self, freq):\n        \"\"\"\n            .. math ::\n                \\mathbf{A} = \\mathbf{C} \\mathbf{M^e_{\\sigma}}^{-1} \\mathbf{C}^T \\mathbf{M_{\\mu^{-1}}^f}  + i \\omega\n\n            :param float freq: Frequency\n            :rtype: scipy.sparse.csr_matrix\n            :return: A\n        \"\"\"\n\n        MfMui = self.MfMui\n        MeSigmaI = self.MeSigmaI\n        C = self.mesh.edgeCurl\n        iomega = 1j * omega(freq) * sp.eye(self.mesh.nF)\n\n        A = C * (MeSigmaI * (C.T * MfMui)) + iomega\n\n        if self._makeASymmetric is True:\n            return MfMui.T*A\n        return A\n\n    def getADeriv_m(self, freq, u, v, adjoint=False):\n\n        MfMui = self.MfMui\n        C = self.mesh.edgeCurl\n        MeSigmaIDeriv = self.MeSigmaIDeriv\n        vec = C.T * (MfMui * u)\n\n        MeSigmaIDeriv = MeSigmaIDeriv(vec)\n\n        if adjoint:\n            if self._makeASymmetric is True:\n                v = MfMui * v\n            return MeSigmaIDeriv.T * (C.T * v)\n\n        if self._makeASymmetric is True:\n            return MfMui.T * ( C * ( MeSigmaIDeriv * v ) )\n        return C * ( MeSigmaIDeriv * v )\n\n\n    def getRHS(self, freq):\n        \"\"\"\n            .. math ::\n                \\mathbf{RHS} = \\mathbf{s_m} + \\mathbf{M^e_{\\sigma}}^{-1}\\mathbf{s_e}\n\n            :param float freq: Frequency\n            :rtype: numpy.ndarray (nE, nSrc)\n            :return: RHS\n        \"\"\"\n\n        S_m, S_e = self.getSourceTerm(freq)\n        C = self.mesh.edgeCurl\n        MeSigmaI = self.MeSigmaI\n        # Me = self.Me\n\n        RHS = S_m + C * ( MeSigmaI * S_e )\n\n        if self._makeASymmetric is True:\n            MfMui = self.MfMui\n            return MfMui.T * RHS\n\n        return RHS\n\n    def getRHSDeriv_m(self, src, v, adjoint=False):\n        C = self.mesh.edgeCurl\n        S_m, S_e = src.eval(self)\n        MfMui = self.MfMui\n        # Me = self.Me\n\n        if self._makeASymmetric and adjoint:\n            v = self.MfMui * v\n\n        if S_e is not None:\n            MeSigmaIDeriv = self.MeSigmaIDeriv(S_e)\n            if not adjoint:\n                RHSderiv = C * (MeSigmaIDeriv * v)\n            elif adjoint:\n                RHSderiv = MeSigmaIDeriv.T * (C.T * v)\n        else:\n            RHSderiv = None\n\n        S_mDeriv, S_eDeriv = src.evalDeriv(self, adjoint)\n        S_mDeriv, S_eDeriv = S_mDeriv(v), S_eDeriv(v)\n        if S_mDeriv is not None and S_eDeriv is not None:\n            if not adjoint:\n                SrcDeriv = S_mDeriv + C * (self.MeSigmaI * S_eDeriv)\n            elif adjoint:\n                SrcDeriv = S_mDeriv + Self.MeSigmaI.T * ( C.T * S_eDeriv)\n        elif S_mDeriv is not None:\n            SrcDeriv = S_mDeriv\n        elif S_eDeriv is not None:\n            if not adjoint:\n                SrcDeriv = C * (self.MeSigmaI * S_eDeriv)\n            elif adjoint:\n                SrcDeriv = self.MeSigmaI.T * ( C.T * S_eDeriv)\n        else:\n            SrcDeriv = None\n\n        if RHSderiv is not None and SrcDeriv is not None:\n            RHSderiv += SrcDeriv\n        elif SrcDeriv is not None:\n            RHSderiv = SrcDeriv\n\n        if RHSderiv is not None:\n            if self._makeASymmetric is True and not adjoint:\n                return MfMui.T * RHSderiv\n\n        return RHSderiv",
  "class Problem_j(BaseFDEMProblem):\n    \"\"\"\n        We eliminate \\\\\\(\\\\\\mathbf{h}\\\\\\) using\n\n        .. math ::\n\n            \\mathbf{h} = \\\\frac{1}{i \\omega} \\mathbf{M_{\\mu}^e}^{-1} \\\\left(-\\mathbf{C}^T \\mathbf{M_{\\\\rho}^f} \\mathbf{j}  + \\mathbf{M^e} \\mathbf{s_m} \\\\right)\n\n        and solve for \\\\\\(\\\\\\mathbf{j}\\\\\\) using\n\n        .. math ::\n\n            \\\\left(\\mathbf{C} \\mathbf{M_{\\mu}^e}^{-1} \\mathbf{C}^T \\mathbf{M_{\\\\rho}^f} + i \\omega\\\\right)\\mathbf{j} = \\mathbf{C} \\mathbf{M_{\\mu}^e}^{-1} \\mathbf{M^e} \\mathbf{s_m} -i\\omega\\mathbf{s_e}\n\n        .. note::\n            This implementation does not yet work with full anisotropy!!\n\n    \"\"\"\n\n    _fieldType = 'j'\n    _eqLocs    = 'EF'\n    fieldsPair = Fields_j\n\n    def __init__(self, mesh, **kwargs):\n        BaseFDEMProblem.__init__(self, mesh, **kwargs)\n\n    def getA(self, freq):\n        \"\"\"\n            .. math ::\n                    \\\\mathbf{A} = \\\\mathbf{C}  \\\\mathbf{M^e_{mu^{-1}}} \\\\mathbf{C}^T \\\\mathbf{M^f_{\\\\sigma^{-1}}}  + i\\\\omega\n\n            :param float freq: Frequency\n            :rtype: scipy.sparse.csr_matrix\n            :return: A\n        \"\"\"\n\n        MeMuI = self.MeMuI\n        MfRho = self.MfRho\n        C = self.mesh.edgeCurl\n        iomega = 1j * omega(freq) * sp.eye(self.mesh.nF)\n\n        A = C * MeMuI * C.T * MfRho + iomega\n\n        if self._makeASymmetric is True:\n            return MfRho.T*A\n        return A\n\n\n    def getADeriv_m(self, freq, u, v, adjoint=False):\n        \"\"\"\n            In this case, we assume that electrical conductivity, \\\\\\(\\\\\\sigma\\\\\\) is the physical property of interest (i.e. \\\\\\(\\\\\\sigma\\\\\\) = model.transform). Then we want\n\n            .. math ::\n\n                \\\\frac{\\mathbf{A(\\sigma)} \\mathbf{v}}{d \\\\mathbf{m}} &= \\\\mathbf{C}  \\\\mathbf{M^e_{mu^{-1}}} \\\\mathbf{C^T} \\\\frac{d \\\\mathbf{M^f_{\\\\sigma^{-1}}}}{d \\\\mathbf{m}}\n                &= \\\\mathbf{C}  \\\\mathbf{M^e_{mu}^{-1}} \\\\mathbf{C^T} \\\\frac{d \\\\mathbf{M^f_{\\\\sigma^{-1}}}}{d \\\\mathbf{\\\\sigma^{-1}}} \\\\frac{d \\\\mathbf{\\\\sigma^{-1}}}{d \\\\mathbf{\\\\sigma}} \\\\frac{d \\\\mathbf{\\\\sigma}}{d \\\\mathbf{m}}\n        \"\"\"\n\n        MeMuI = self.MeMuI\n        MfRho = self.MfRho\n        C = self.mesh.edgeCurl\n        MfRhoDeriv_m = self.MfRhoDeriv(u)\n\n        if adjoint:\n            if self._makeASymmetric is True:\n                v = MfRho * v\n            return MfRhoDeriv_m.T * (C * (MeMuI.T * (C.T * v)))\n\n        if self._makeASymmetric is True:\n            return MfRho.T * (C * ( MeMuI * (C.T * (MfRhoDeriv_m * v) )))\n        return C * (MeMuI * (C.T * (MfRhoDeriv_m * v)))\n\n\n    def getRHS(self, freq):\n        \"\"\"\n            .. math ::\n\n                \\mathbf{RHS} = \\mathbf{C} \\mathbf{M_{\\mu}^e}^{-1}\\mathbf{s_m} -i\\omega \\mathbf{s_e}\n            :param float freq: Frequency\n            :rtype: numpy.ndarray (nE, nSrc)\n            :return: RHS\n        \"\"\"\n\n        S_m, S_e = self.getSourceTerm(freq)\n        C = self.mesh.edgeCurl\n        MeMuI = self.MeMuI\n\n        RHS = C * (MeMuI * S_m) - 1j * omega(freq) * S_e\n        if self._makeASymmetric is True:\n            MfRho = self.MfRho\n            return MfRho.T*RHS\n\n        return RHS\n\n    def getRHSDeriv_m(self, src, v, adjoint=False):\n        C = self.mesh.edgeCurl\n        MeMuI = self.MeMuI\n        S_mDeriv, S_eDeriv = src.evalDeriv(self, adjoint)\n\n        if adjoint:\n            if self._makeASymmetric:\n                MfRho = self.MfRho\n                v = MfRho*v\n            S_mDerivv = S_mDeriv(MeMuI.T * (C.T * v))\n            S_eDerivv = S_eDeriv(v)\n            if S_mDerivv is not None and S_eDerivv is not None:\n                return S_mDerivv - 1j * omega(freq) * S_eDerivv\n            elif S_mDerivv is not None:\n                return S_mDerivv\n            elif S_eDerivv is not None:\n                return - 1j * omega(freq) * S_eDerivv\n            else:\n                return None\n        else:\n            S_mDerivv, S_eDerivv = S_mDeriv(v), S_eDeriv(v)\n\n            if S_mDerivv is not None and S_eDerivv is not None:\n                RHSDeriv = C * (MeMuI * S_mDerivv) - 1j * omega(freq) * S_eDerivv\n            elif S_mDerivv is not None:\n                RHSDeriv = C * (MeMuI * S_mDerivv)\n            elif S_eDerivv is not None:\n                RHSDeriv = - 1j * omega(freq) * S_eDerivv\n            else:\n                return None\n\n            if self._makeASymmetric:\n                MfRho = self.MfRho\n                return MfRho.T * RHSDeriv\n            return RHSDeriv",
  "class Problem_h(BaseFDEMProblem):\n    \"\"\"\n        We eliminate \\\\\\(\\\\\\mathbf{j}\\\\\\) using\n\n        .. math ::\n\n            \\mathbf{j} = \\mathbf{C} \\mathbf{h} - \\mathbf{s_e}\n\n        and solve for \\\\\\(\\\\\\mathbf{h}\\\\\\) using\n\n        .. math ::\n\n            \\\\left(\\mathbf{C}^T \\mathbf{M_{\\\\rho}^f} \\mathbf{C} + i \\omega \\mathbf{M_{\\mu}^e}\\\\right) \\mathbf{h} = \\mathbf{M^e} \\mathbf{s_m} + \\mathbf{C}^T \\mathbf{M_{\\\\rho}^f} \\mathbf{s_e}\n\n    \"\"\"\n\n    _fieldType = 'h'\n    _eqLocs    = 'EF'\n    fieldsPair = Fields_h\n\n    def __init__(self, mesh, **kwargs):\n        BaseFDEMProblem.__init__(self, mesh, **kwargs)\n\n    def getA(self, freq):\n        \"\"\"\n            .. math ::\n\n                \\mathbf{A} = \\mathbf{C}^T \\mathbf{M_{\\\\rho}^f} \\mathbf{C} + i \\omega \\mathbf{M_{\\mu}^e}\n\n            :param float freq: Frequency\n            :rtype: scipy.sparse.csr_matrix\n            :return: A\n        \"\"\"\n\n        MeMu = self.MeMu\n        MfRho = self.MfRho\n        C = self.mesh.edgeCurl\n\n        return C.T * (MfRho * C) + 1j*omega(freq)*MeMu\n\n    def getADeriv_m(self, freq, u, v, adjoint=False):\n\n        MeMu = self.MeMu\n        C = self.mesh.edgeCurl\n        MfRhoDeriv_m = self.MfRhoDeriv(C*u)\n\n        if adjoint:\n            return MfRhoDeriv_m.T * (C * v)\n        return C.T * (MfRhoDeriv_m * v)\n\n    def getRHS(self, freq):\n        \"\"\"\n            .. math ::\n\n                \\mathbf{RHS} = \\mathbf{M^e} \\mathbf{s_m} + \\mathbf{C}^T \\mathbf{M_{\\\\rho}^f} \\mathbf{s_e}\n\n            :param float freq: Frequency\n            :rtype: numpy.ndarray (nE, nSrc)\n            :return: RHS\n        \"\"\"\n\n        S_m, S_e = self.getSourceTerm(freq)\n        C = self.mesh.edgeCurl\n        MfRho  = self.MfRho\n\n        RHS = S_m + C.T * ( MfRho * S_e )\n\n        return RHS\n\n    def getRHSDeriv_m(self, src, v, adjoint=False):\n        _, S_e = src.eval(self)\n        C = self.mesh.edgeCurl\n        MfRho  = self.MfRho\n\n        RHSDeriv = None\n\n        if S_e is not None:\n            MfRhoDeriv = self.MfRhoDeriv(S_e)\n            if not adjoint:\n                RHSDeriv = C.T * (MfRhoDeriv * v)\n            elif adjoint:\n                RHSDeriv = MfRhoDeriv.T * (C * v)\n\n        S_mDeriv, S_eDeriv = src.evalDeriv(self, adjoint)\n\n        S_mDeriv = S_mDeriv(v)\n        S_eDeriv = S_eDeriv(v)\n\n        if S_mDeriv is not None:\n            if RHSDeriv is not None:\n                RHSDeriv += S_mDeriv(v)\n            else:\n                RHSDeriv =  S_mDeriv(v)\n        if S_eDeriv is not None:\n            if RHSDeriv is not None:\n                RHSDeriv += C.T * (MfRho * S_e)\n            else:\n                RHSDeriv = C.T * (MfRho * S_e)\n\n        return RHSDeriv",
  "def fields(self, m=None):\n        \"\"\"\n            Solve the forward problem for the fields.\n        \"\"\"\n\n        self.curModel = m\n        F = self.fieldsPair(self.mesh, self.survey)\n\n        for freq in self.survey.freqs:\n            A = self.getA(freq)\n            rhs = self.getRHS(freq)\n            Ainv = self.Solver(A, **self.solverOpts)\n            sol = Ainv * rhs\n            Srcs = self.survey.getSrcByFreq(freq)\n            ftype = self._fieldType + 'Solution'\n            F[Srcs, ftype] = sol\n\n        return F",
  "def Jvec(self, m, v, f=None):\n        \"\"\"\n            Sensitivity times a vector\n        \"\"\"\n\n        if f is None:\n           f = self.fields(m)\n\n        self.curModel = m\n\n        Jv = self.dataPair(self.survey)\n\n        for freq in self.survey.freqs:\n            dA_du = self.getA(freq) #\n            dA_duI = self.Solver(dA_du, **self.solverOpts)\n\n            for src in self.survey.getSrcByFreq(freq):\n                ftype = self._fieldType + 'Solution'\n                u_src = f[src, ftype]\n                dA_dm = self.getADeriv_m(freq, u_src, v)\n                dRHS_dm = self.getRHSDeriv_m(src, v)\n                if dRHS_dm is None:\n                    du_dm = dA_duI * ( - dA_dm )\n                else:\n                    du_dm = dA_duI * ( - dA_dm + dRHS_dm )\n                for rx in src.rxList:\n                    # df_duFun = u.deriv_u(rx.fieldsUsed, m)\n                    df_duFun = getattr(f, '_%sDeriv_u'%rx.projField, None)\n                    df_du = df_duFun(src, du_dm, adjoint=False)\n                    if df_du is not None:\n                        du_dm = df_du\n\n                    df_dmFun = getattr(f, '_%sDeriv_m'%rx.projField, None)\n                    df_dm = df_dmFun(src, v, adjoint=False)\n                    if df_dm is not None:\n                        du_dm += df_dm\n\n                    P = lambda v: rx.projectFieldsDeriv(src, self.mesh, f, v) # wrt u, also have wrt m\n\n\n                    Jv[src, rx] = P(du_dm)\n\n        return Utils.mkvc(Jv)",
  "def Jtvec(self, m, v, f=None):\n        \"\"\"\n            Sensitivity transpose times a vector\n        \"\"\"\n\n        if f is None:\n            f = self.fields(m)\n\n        self.curModel = m\n\n        # Ensure v is a data object.\n        if not isinstance(v, self.dataPair):\n            v = self.dataPair(self.survey, v)\n\n        Jtv = np.zeros(m.size)\n\n        for freq in self.survey.freqs:\n            AT = self.getA(freq).T\n            ATinv = self.Solver(AT, **self.solverOpts)\n\n            for src in self.survey.getSrcByFreq(freq):\n                ftype = self._fieldType + 'Solution'\n                u_src = f[src, ftype]\n\n                for rx in src.rxList:\n                    PTv = rx.projectFieldsDeriv(src, self.mesh, f, v[src, rx], adjoint=True) # wrt u, need possibility wrt m\n\n                    df_duTFun = getattr(f, '_%sDeriv_u'%rx.projField, None)\n                    df_duT = df_duTFun(src, PTv, adjoint=True)\n                    if df_duT is not None:\n                        dA_duIT = ATinv * df_duT\n                    else:\n                        dA_duIT = ATinv * PTv\n\n                    dA_dmT = self.getADeriv_m(freq, u_src, dA_duIT, adjoint=True)\n\n                    dRHS_dmT = self.getRHSDeriv_m(src, dA_duIT, adjoint=True)\n\n                    if dRHS_dmT is None:\n                        du_dmT = - dA_dmT\n                    else:\n                        du_dmT = -dA_dmT + dRHS_dmT\n\n                    df_dmFun = getattr(f, '_%sDeriv_m'%rx.projField, None)\n                    dfT_dm = df_dmFun(src, PTv, adjoint=True)\n                    if dfT_dm is not None:\n                        du_dmT += dfT_dm\n\n                    real_or_imag = rx.projComp\n                    if real_or_imag == 'real':\n                        Jtv +=   du_dmT.real\n                    elif real_or_imag == 'imag':\n                        Jtv += - du_dmT.real\n                    else:\n                        raise Exception('Must be real or imag')\n\n        return Jtv",
  "def getSourceTerm(self, freq):\n        \"\"\"\n            Evaluates the sources for a given frequency and puts them in matrix form\n\n            :param float freq: Frequency\n            :rtype: numpy.ndarray (nE or nF, nSrc)\n            :return: S_m, S_e\n        \"\"\"\n        Srcs = self.survey.getSrcByFreq(freq)\n        if self._eqLocs is 'FE':\n            S_m = np.zeros((self.mesh.nF,len(Srcs)), dtype=complex)\n            S_e = np.zeros((self.mesh.nE,len(Srcs)), dtype=complex)\n        elif self._eqLocs is 'EF':\n            S_m = np.zeros((self.mesh.nE,len(Srcs)), dtype=complex)\n            S_e = np.zeros((self.mesh.nF,len(Srcs)), dtype=complex)\n\n        for i, src in enumerate(Srcs):\n            smi, sei = src.eval(self)\n            if smi is not None:\n                S_m[:,i] = Utils.mkvc(smi)\n            if sei is not None:\n                S_e[:,i] = Utils.mkvc(sei)\n\n        return S_m, S_e",
  "def __init__(self, mesh, **kwargs):\n        BaseFDEMProblem.__init__(self, mesh, **kwargs)",
  "def getA(self, freq):\n        \"\"\"\n            .. math ::\n                \\mathbf{A} = \\mathbf{C}^T \\mathbf{M_{\\mu^{-1}}^f} \\mathbf{C} + i \\omega \\mathbf{M^e_{\\sigma}}\n\n            :param float freq: Frequency\n            :rtype: scipy.sparse.csr_matrix\n            :return: A\n        \"\"\"\n        MfMui = self.MfMui\n        MeSigma = self.MeSigma\n        C = self.mesh.edgeCurl\n\n        return C.T*MfMui*C + 1j*omega(freq)*MeSigma",
  "def getADeriv_m(self, freq, u, v, adjoint=False):\n        dsig_dm = self.curModel.sigmaDeriv\n        dMe_dsig = self.MeSigmaDeriv(u)\n\n        if adjoint:\n            return 1j * omega(freq) * ( dMe_dsig.T * v )\n\n        return 1j * omega(freq) * ( dMe_dsig * v )",
  "def getRHS(self, freq):\n        \"\"\"\n            .. math ::\n                \\mathbf{RHS} = \\mathbf{C}^T \\mathbf{M_{\\mu^{-1}}^f}\\mathbf{s_m} -i\\omega\\mathbf{M_e}\\mathbf{s_e}\n\n            :param float freq: Frequency\n            :rtype: numpy.ndarray (nE, nSrc)\n            :return: RHS\n        \"\"\"\n\n        S_m, S_e = self.getSourceTerm(freq)\n        C = self.mesh.edgeCurl\n        MfMui = self.MfMui\n\n        # RHS = C.T * (MfMui * S_m) -1j * omega(freq) * Me * S_e\n        RHS = C.T * (MfMui * S_m) -1j * omega(freq) * S_e\n\n        return RHS",
  "def getRHSDeriv_m(self, src, v, adjoint=False):\n        C = self.mesh.edgeCurl\n        MfMui = self.MfMui\n        S_mDeriv, S_eDeriv = src.evalDeriv(self, adjoint)\n\n        if adjoint:\n            dRHS = MfMui * (C * v)\n            S_mDerivv = S_mDeriv(dRHS)\n            S_eDerivv = S_eDeriv(v)\n            if S_mDerivv is not None and S_eDerivv is not None:\n                return S_mDerivv - 1j * omega(freq) * S_eDerivv\n            elif S_mDerivv is not None:\n                return S_mDerivv\n            elif S_eDerivv is not None:\n                return - 1j * omega(freq) * S_eDerivv\n            else:\n                return None\n        else:\n            S_mDerivv, S_eDerivv = S_mDeriv(v), S_eDeriv(v)\n\n            if S_mDerivv is not None and S_eDerivv is not None:\n                return C.T * (MfMui * S_mDerivv) -1j * omega(freq) * S_eDerivv\n            elif S_mDerivv is not None:\n                return C.T * (MfMui * S_mDerivv)\n            elif S_eDerivv is not None:\n                return -1j * omega(freq) * S_eDerivv\n            else:\n                return None",
  "def __init__(self, mesh, **kwargs):\n        BaseFDEMProblem.__init__(self, mesh, **kwargs)",
  "def getA(self, freq):\n        \"\"\"\n            .. math ::\n                \\mathbf{A} = \\mathbf{C} \\mathbf{M^e_{\\sigma}}^{-1} \\mathbf{C}^T \\mathbf{M_{\\mu^{-1}}^f}  + i \\omega\n\n            :param float freq: Frequency\n            :rtype: scipy.sparse.csr_matrix\n            :return: A\n        \"\"\"\n\n        MfMui = self.MfMui\n        MeSigmaI = self.MeSigmaI\n        C = self.mesh.edgeCurl\n        iomega = 1j * omega(freq) * sp.eye(self.mesh.nF)\n\n        A = C * (MeSigmaI * (C.T * MfMui)) + iomega\n\n        if self._makeASymmetric is True:\n            return MfMui.T*A\n        return A",
  "def getADeriv_m(self, freq, u, v, adjoint=False):\n\n        MfMui = self.MfMui\n        C = self.mesh.edgeCurl\n        MeSigmaIDeriv = self.MeSigmaIDeriv\n        vec = C.T * (MfMui * u)\n\n        MeSigmaIDeriv = MeSigmaIDeriv(vec)\n\n        if adjoint:\n            if self._makeASymmetric is True:\n                v = MfMui * v\n            return MeSigmaIDeriv.T * (C.T * v)\n\n        if self._makeASymmetric is True:\n            return MfMui.T * ( C * ( MeSigmaIDeriv * v ) )\n        return C * ( MeSigmaIDeriv * v )",
  "def getRHS(self, freq):\n        \"\"\"\n            .. math ::\n                \\mathbf{RHS} = \\mathbf{s_m} + \\mathbf{M^e_{\\sigma}}^{-1}\\mathbf{s_e}\n\n            :param float freq: Frequency\n            :rtype: numpy.ndarray (nE, nSrc)\n            :return: RHS\n        \"\"\"\n\n        S_m, S_e = self.getSourceTerm(freq)\n        C = self.mesh.edgeCurl\n        MeSigmaI = self.MeSigmaI\n        # Me = self.Me\n\n        RHS = S_m + C * ( MeSigmaI * S_e )\n\n        if self._makeASymmetric is True:\n            MfMui = self.MfMui\n            return MfMui.T * RHS\n\n        return RHS",
  "def getRHSDeriv_m(self, src, v, adjoint=False):\n        C = self.mesh.edgeCurl\n        S_m, S_e = src.eval(self)\n        MfMui = self.MfMui\n        # Me = self.Me\n\n        if self._makeASymmetric and adjoint:\n            v = self.MfMui * v\n\n        if S_e is not None:\n            MeSigmaIDeriv = self.MeSigmaIDeriv(S_e)\n            if not adjoint:\n                RHSderiv = C * (MeSigmaIDeriv * v)\n            elif adjoint:\n                RHSderiv = MeSigmaIDeriv.T * (C.T * v)\n        else:\n            RHSderiv = None\n\n        S_mDeriv, S_eDeriv = src.evalDeriv(self, adjoint)\n        S_mDeriv, S_eDeriv = S_mDeriv(v), S_eDeriv(v)\n        if S_mDeriv is not None and S_eDeriv is not None:\n            if not adjoint:\n                SrcDeriv = S_mDeriv + C * (self.MeSigmaI * S_eDeriv)\n            elif adjoint:\n                SrcDeriv = S_mDeriv + Self.MeSigmaI.T * ( C.T * S_eDeriv)\n        elif S_mDeriv is not None:\n            SrcDeriv = S_mDeriv\n        elif S_eDeriv is not None:\n            if not adjoint:\n                SrcDeriv = C * (self.MeSigmaI * S_eDeriv)\n            elif adjoint:\n                SrcDeriv = self.MeSigmaI.T * ( C.T * S_eDeriv)\n        else:\n            SrcDeriv = None\n\n        if RHSderiv is not None and SrcDeriv is not None:\n            RHSderiv += SrcDeriv\n        elif SrcDeriv is not None:\n            RHSderiv = SrcDeriv\n\n        if RHSderiv is not None:\n            if self._makeASymmetric is True and not adjoint:\n                return MfMui.T * RHSderiv\n\n        return RHSderiv",
  "def __init__(self, mesh, **kwargs):\n        BaseFDEMProblem.__init__(self, mesh, **kwargs)",
  "def getA(self, freq):\n        \"\"\"\n            .. math ::\n                    \\\\mathbf{A} = \\\\mathbf{C}  \\\\mathbf{M^e_{mu^{-1}}} \\\\mathbf{C}^T \\\\mathbf{M^f_{\\\\sigma^{-1}}}  + i\\\\omega\n\n            :param float freq: Frequency\n            :rtype: scipy.sparse.csr_matrix\n            :return: A\n        \"\"\"\n\n        MeMuI = self.MeMuI\n        MfRho = self.MfRho\n        C = self.mesh.edgeCurl\n        iomega = 1j * omega(freq) * sp.eye(self.mesh.nF)\n\n        A = C * MeMuI * C.T * MfRho + iomega\n\n        if self._makeASymmetric is True:\n            return MfRho.T*A\n        return A",
  "def getADeriv_m(self, freq, u, v, adjoint=False):\n        \"\"\"\n            In this case, we assume that electrical conductivity, \\\\\\(\\\\\\sigma\\\\\\) is the physical property of interest (i.e. \\\\\\(\\\\\\sigma\\\\\\) = model.transform). Then we want\n\n            .. math ::\n\n                \\\\frac{\\mathbf{A(\\sigma)} \\mathbf{v}}{d \\\\mathbf{m}} &= \\\\mathbf{C}  \\\\mathbf{M^e_{mu^{-1}}} \\\\mathbf{C^T} \\\\frac{d \\\\mathbf{M^f_{\\\\sigma^{-1}}}}{d \\\\mathbf{m}}\n                &= \\\\mathbf{C}  \\\\mathbf{M^e_{mu}^{-1}} \\\\mathbf{C^T} \\\\frac{d \\\\mathbf{M^f_{\\\\sigma^{-1}}}}{d \\\\mathbf{\\\\sigma^{-1}}} \\\\frac{d \\\\mathbf{\\\\sigma^{-1}}}{d \\\\mathbf{\\\\sigma}} \\\\frac{d \\\\mathbf{\\\\sigma}}{d \\\\mathbf{m}}\n        \"\"\"\n\n        MeMuI = self.MeMuI\n        MfRho = self.MfRho\n        C = self.mesh.edgeCurl\n        MfRhoDeriv_m = self.MfRhoDeriv(u)\n\n        if adjoint:\n            if self._makeASymmetric is True:\n                v = MfRho * v\n            return MfRhoDeriv_m.T * (C * (MeMuI.T * (C.T * v)))\n\n        if self._makeASymmetric is True:\n            return MfRho.T * (C * ( MeMuI * (C.T * (MfRhoDeriv_m * v) )))\n        return C * (MeMuI * (C.T * (MfRhoDeriv_m * v)))",
  "def getRHS(self, freq):\n        \"\"\"\n            .. math ::\n\n                \\mathbf{RHS} = \\mathbf{C} \\mathbf{M_{\\mu}^e}^{-1}\\mathbf{s_m} -i\\omega \\mathbf{s_e}\n            :param float freq: Frequency\n            :rtype: numpy.ndarray (nE, nSrc)\n            :return: RHS\n        \"\"\"\n\n        S_m, S_e = self.getSourceTerm(freq)\n        C = self.mesh.edgeCurl\n        MeMuI = self.MeMuI\n\n        RHS = C * (MeMuI * S_m) - 1j * omega(freq) * S_e\n        if self._makeASymmetric is True:\n            MfRho = self.MfRho\n            return MfRho.T*RHS\n\n        return RHS",
  "def getRHSDeriv_m(self, src, v, adjoint=False):\n        C = self.mesh.edgeCurl\n        MeMuI = self.MeMuI\n        S_mDeriv, S_eDeriv = src.evalDeriv(self, adjoint)\n\n        if adjoint:\n            if self._makeASymmetric:\n                MfRho = self.MfRho\n                v = MfRho*v\n            S_mDerivv = S_mDeriv(MeMuI.T * (C.T * v))\n            S_eDerivv = S_eDeriv(v)\n            if S_mDerivv is not None and S_eDerivv is not None:\n                return S_mDerivv - 1j * omega(freq) * S_eDerivv\n            elif S_mDerivv is not None:\n                return S_mDerivv\n            elif S_eDerivv is not None:\n                return - 1j * omega(freq) * S_eDerivv\n            else:\n                return None\n        else:\n            S_mDerivv, S_eDerivv = S_mDeriv(v), S_eDeriv(v)\n\n            if S_mDerivv is not None and S_eDerivv is not None:\n                RHSDeriv = C * (MeMuI * S_mDerivv) - 1j * omega(freq) * S_eDerivv\n            elif S_mDerivv is not None:\n                RHSDeriv = C * (MeMuI * S_mDerivv)\n            elif S_eDerivv is not None:\n                RHSDeriv = - 1j * omega(freq) * S_eDerivv\n            else:\n                return None\n\n            if self._makeASymmetric:\n                MfRho = self.MfRho\n                return MfRho.T * RHSDeriv\n            return RHSDeriv",
  "def __init__(self, mesh, **kwargs):\n        BaseFDEMProblem.__init__(self, mesh, **kwargs)",
  "def getA(self, freq):\n        \"\"\"\n            .. math ::\n\n                \\mathbf{A} = \\mathbf{C}^T \\mathbf{M_{\\\\rho}^f} \\mathbf{C} + i \\omega \\mathbf{M_{\\mu}^e}\n\n            :param float freq: Frequency\n            :rtype: scipy.sparse.csr_matrix\n            :return: A\n        \"\"\"\n\n        MeMu = self.MeMu\n        MfRho = self.MfRho\n        C = self.mesh.edgeCurl\n\n        return C.T * (MfRho * C) + 1j*omega(freq)*MeMu",
  "def getADeriv_m(self, freq, u, v, adjoint=False):\n\n        MeMu = self.MeMu\n        C = self.mesh.edgeCurl\n        MfRhoDeriv_m = self.MfRhoDeriv(C*u)\n\n        if adjoint:\n            return MfRhoDeriv_m.T * (C * v)\n        return C.T * (MfRhoDeriv_m * v)",
  "def getRHS(self, freq):\n        \"\"\"\n            .. math ::\n\n                \\mathbf{RHS} = \\mathbf{M^e} \\mathbf{s_m} + \\mathbf{C}^T \\mathbf{M_{\\\\rho}^f} \\mathbf{s_e}\n\n            :param float freq: Frequency\n            :rtype: numpy.ndarray (nE, nSrc)\n            :return: RHS\n        \"\"\"\n\n        S_m, S_e = self.getSourceTerm(freq)\n        C = self.mesh.edgeCurl\n        MfRho  = self.MfRho\n\n        RHS = S_m + C.T * ( MfRho * S_e )\n\n        return RHS",
  "def getRHSDeriv_m(self, src, v, adjoint=False):\n        _, S_e = src.eval(self)\n        C = self.mesh.edgeCurl\n        MfRho  = self.MfRho\n\n        RHSDeriv = None\n\n        if S_e is not None:\n            MfRhoDeriv = self.MfRhoDeriv(S_e)\n            if not adjoint:\n                RHSDeriv = C.T * (MfRhoDeriv * v)\n            elif adjoint:\n                RHSDeriv = MfRhoDeriv.T * (C * v)\n\n        S_mDeriv, S_eDeriv = src.evalDeriv(self, adjoint)\n\n        S_mDeriv = S_mDeriv(v)\n        S_eDeriv = S_eDeriv(v)\n\n        if S_mDeriv is not None:\n            if RHSDeriv is not None:\n                RHSDeriv += S_mDeriv(v)\n            else:\n                RHSDeriv =  S_mDeriv(v)\n        if S_eDeriv is not None:\n            if RHSDeriv is not None:\n                RHSDeriv += C.T * (MfRho * S_e)\n            else:\n                RHSDeriv = C.T * (MfRho * S_e)\n\n        return RHSDeriv",
  "def run(plotIt=True):\n\n    cs, ncx, ncz, npad = 5., 25, 15, 15\n    hx = [(cs,ncx), (cs,npad,1.3)]\n    hz = [(cs,npad,-1.3), (cs,ncz), (cs,npad,1.3)]\n    mesh = Mesh.CylMesh([hx,1,hz], '00C')\n\n    active = mesh.vectorCCz<0.\n    layer = (mesh.vectorCCz<0.) & (mesh.vectorCCz>=-100.)\n    actMap = Maps.ActiveCells(mesh, active, np.log(1e-8), nC=mesh.nCz)\n    mapping = Maps.ExpMap(mesh) * Maps.Vertical1DMap(mesh) * actMap\n    sig_half = 2e-3\n    sig_air = 1e-8\n    sig_layer = 1e-3\n    sigma = np.ones(mesh.nCz)*sig_air\n    sigma[active] = sig_half\n    sigma[layer] = sig_layer\n    mtrue = np.log(sigma[active])\n\n\n    if plotIt:\n        fig, ax = plt.subplots(1,1, figsize = (3, 6))\n        plt.semilogx(sigma[active], mesh.vectorCCz[active])\n        ax.set_ylim(-600, 0)\n        ax.set_xlim(1e-4, 1e-2)\n        ax.set_xlabel('Conductivity (S/m)', fontsize = 14)\n        ax.set_ylabel('Depth (m)', fontsize = 14)\n        ax.grid(color='k', alpha=0.5, linestyle='dashed', linewidth=0.5)\n\n\n    rxOffset=1e-3\n    rx = EM.TDEM.RxTDEM(np.array([[rxOffset, 0., 30]]), np.logspace(-5,-3, 31), 'bz')\n    src = EM.TDEM.SrcTDEM_VMD_MVP([rx], np.array([0., 0., 80]))\n    survey = EM.TDEM.SurveyTDEM([src])\n    prb = EM.TDEM.ProblemTDEM_b(mesh, mapping=mapping)\n\n    prb.Solver = SolverLU\n    prb.timeSteps = [(1e-06, 20),(1e-05, 20), (0.0001, 20)]\n    prb.pair(survey)\n    dtrue = survey.dpred(mtrue)\n\n\n    survey.dtrue = dtrue\n    std = 0.05\n    noise = std*abs(survey.dtrue)*np.random.randn(*survey.dtrue.shape)\n    survey.dobs = survey.dtrue+noise\n    survey.std = survey.dobs*0 + std\n    survey.Wd = 1/(abs(survey.dobs)*std)\n\n    if plotIt:\n        fig, ax = plt.subplots(1,1, figsize = (10, 6))\n        ax.loglog(rx.times, dtrue, 'b.-')\n        ax.loglog(rx.times, survey.dobs, 'r.-')\n        ax.legend(('Noisefree', '$d^{obs}$'), fontsize = 16)\n        ax.set_xlabel('Time (s)', fontsize = 14)\n        ax.set_ylabel('$B_z$ (T)', fontsize = 16)\n        ax.set_xlabel('Time (s)', fontsize = 14)\n        ax.grid(color='k', alpha=0.5, linestyle='dashed', linewidth=0.5)\n\n    dmisfit = DataMisfit.l2_DataMisfit(survey)\n    regMesh = Mesh.TensorMesh([mesh.hz[mapping.maps[-1].indActive]])\n    reg = Regularization.Tikhonov(regMesh)\n    opt = Optimization.InexactGaussNewton(maxIter = 5)\n    invProb = InvProblem.BaseInvProblem(dmisfit, reg, opt)\n    # Create an inversion object\n    beta = Directives.BetaSchedule(coolingFactor=5, coolingRate=2)\n    betaest = Directives.BetaEstimate_ByEig(beta0_ratio=1e0)\n    inv = Inversion.BaseInversion(invProb, directiveList=[beta,betaest])\n    m0 = np.log(np.ones(mtrue.size)*sig_half)\n    reg.alpha_s = 1e-2\n    reg.alpha_x = 1.\n    prb.counter = opt.counter = Utils.Counter()\n    opt.LSshorten = 0.5\n    opt.remember('xc')\n\n    mopt = inv.run(m0)\n\n    if plotIt:\n        fig, ax = plt.subplots(1,1, figsize = (3, 6))\n        plt.semilogx(sigma[active], mesh.vectorCCz[active])\n        plt.semilogx(np.exp(mopt), mesh.vectorCCz[active])\n        ax.set_ylim(-600, 0)\n        ax.set_xlim(1e-4, 1e-2)\n        ax.set_xlabel('Conductivity (S/m)', fontsize = 14)\n        ax.set_ylabel('Depth (m)', fontsize = 14)\n        ax.grid(color='k', alpha=0.5, linestyle='dashed', linewidth=0.5)\n        plt.legend(['$\\sigma_{true}$', '$\\sigma_{pred}$'])\n        plt.show()",
  "def hzAnalyticDipoleT(r, t, sigma):\n    theta = np.sqrt((sigma*mu_0)/(4*t))\n    tr = theta*r\n    etr = erf(tr)\n    t1 = (9/(2*tr**2) - 1)*etr\n    t2 = (1/np.sqrt(pi))*(9/tr + 4*tr)*np.exp(-tr**2)\n    hz = (t1 - t2)/(4*pi*r**3)\n    return hz",
  "def getKc(freq,sigma,a,b,mu=mu_0,eps=epsilon_0):\n    a = float(a)\n    b = float(b)\n    # return 1./(2*np.pi) * np.sqrt(b / a) * np.exp(-1j*k(freq,sigma,mu,eps)*(b-a))\n    return np.sqrt(b / a) * np.exp(-1j*k(freq,sigma,mu,eps)*(b-a))",
  "def _r2(xyz):\n    return np.sum(xyz**2,1)",
  "def _getCasingHertzMagDipole(srcloc,obsloc,freq,sigma,a,b,mu=mu_0*np.ones(3),eps=epsilon_0,moment=1.):\n    Kc1 = getKc(freq,sigma[1],a,b,mu[1],eps)\n\n    nobs = obsloc.shape[0]\n    dxyz = obsloc - np.c_[np.ones(nobs)]*np.r_[srcloc]\n\n    r2 = _r2(dxyz[:,:2])\n    sqrtr2z2 = np.sqrt(r2 + dxyz[:,2]**2)\n    k2 = k(freq,sigma[2],mu[2],eps)\n\n    return Kc1 * moment / (4.*np.pi) *np.exp(-1j*k2*sqrtr2z2) / sqrtr2z2",
  "def _getCasingHertzMagDipoleDeriv_r(srcloc,obsloc,freq,sigma,a,b,mu=mu_0*np.ones(3),eps=epsilon_0,moment=1.):\n    HertzZ = _getCasingHertzMagDipole(srcloc,obsloc,freq,sigma,a,b,mu,eps,moment)\n\n    nobs = obsloc.shape[0]\n    dxyz = obsloc - np.c_[np.ones(nobs)]*np.r_[srcloc]\n\n    r2 = _r2(dxyz[:,:2])\n    sqrtr2z2 = np.sqrt(r2 + dxyz[:,2]**2)\n    k2 = k(freq,sigma[2],mu[2],eps)\n\n    return -HertzZ * np.sqrt(r2) / sqrtr2z2 * (1j*k2 + 1./ sqrtr2z2)",
  "def _getCasingHertzMagDipoleDeriv_z(srcloc,obsloc,freq,sigma,a,b,mu=mu_0*np.ones(3),eps=epsilon_0,moment=1.):\n    HertzZ = _getCasingHertzMagDipole(srcloc,obsloc,freq,sigma,a,b,mu,eps,moment)\n\n    nobs = obsloc.shape[0]\n    dxyz = obsloc - np.c_[np.ones(nobs)]*np.r_[srcloc]\n\n    r2z2 = _r2(dxyz)\n    sqrtr2z2 = np.sqrt(r2z2)\n    k2 = k(freq,sigma[2],mu[2],eps)\n\n    return -HertzZ*dxyz[:,2] /sqrtr2z2 * (1j*k2 + 1./sqrtr2z2)",
  "def _getCasingHertzMagDipole2Deriv_z_r(srcloc,obsloc,freq,sigma,a,b,mu=mu_0*np.ones(3),eps=epsilon_0,moment=1.):\n    HertzZ = _getCasingHertzMagDipole(srcloc,obsloc,freq,sigma,a,b,mu,eps,moment)\n    dHertzZdr = _getCasingHertzMagDipoleDeriv_r(srcloc,obsloc,freq,sigma,a,b,mu,eps,moment)\n\n    nobs = obsloc.shape[0]\n    dxyz = obsloc - np.c_[np.ones(nobs)]*np.r_[srcloc]\n\n    r2 = _r2(dxyz[:,:2])\n    r = np.sqrt(r2)\n    z = dxyz[:,2]\n    sqrtr2z2 = np.sqrt(r2 + z**2)\n    k2 = k(freq,sigma[2],mu[2],eps)\n\n    return dHertzZdr*(-z/sqrtr2z2)*(1j*k2+1./sqrtr2z2) + HertzZ*(z*r/sqrtr2z2**3)*(1j*k2 + 2./sqrtr2z2)",
  "def _getCasingHertzMagDipole2Deriv_z_z(srcloc,obsloc,freq,sigma,a,b,mu=mu_0*np.ones(3),eps=epsilon_0,moment=1.):\n    HertzZ = _getCasingHertzMagDipole(srcloc,obsloc,freq,sigma,a,b,mu,eps,moment)\n    dHertzZdz = _getCasingHertzMagDipoleDeriv_z(srcloc,obsloc,freq,sigma,a,b,mu,eps,moment)\n\n    nobs = obsloc.shape[0]\n    dxyz = obsloc - np.c_[np.ones(nobs)]*np.r_[srcloc]\n\n    r2 = _r2(dxyz[:,:2])\n    r = np.sqrt(r2)\n    z = dxyz[:,2]\n    sqrtr2z2 = np.sqrt(r2 + z**2)\n    k2 = k(freq,sigma[2],mu[2],eps)\n\n    return (dHertzZdz*z + HertzZ)/sqrtr2z2*(-1j*k2 - 1./sqrtr2z2) + HertzZ*z/sqrtr2z2**3*(1j*k2*z + 2.*z/sqrtr2z2)",
  "def getCasingEphiMagDipole(srcloc,obsloc,freq,sigma,a,b,mu=mu_0*np.ones(3),eps=epsilon_0,moment=1.):\n    return 1j * omega(freq) * mu * _getCasingHertzMagDipoleDeriv_r(srcloc,obsloc,freq,sigma,a,b,mu,eps,moment)",
  "def getCasingHrMagDipole(srcloc,obsloc,freq,sigma,a,b,mu=mu_0*np.ones(3),eps=epsilon_0,moment=1.):\n    return _getCasingHertzMagDipole2Deriv_z_r(srcloc,obsloc,freq,sigma,a,b,mu,eps,moment)",
  "def getCasingHzMagDipole(srcloc,obsloc,freq,sigma,a,b,mu=mu_0*np.ones(3),eps=epsilon_0,moment=1.):\n    d2HertzZdz2 = _getCasingHertzMagDipole2Deriv_z_z(srcloc,obsloc,freq,sigma,a,b,mu,eps,moment)\n    k2 = k(freq,sigma[2],mu[2],eps)\n    HertzZ = _getCasingHertzMagDipole(srcloc,obsloc,freq,sigma,a,b,mu,eps,moment)\n    return d2HertzZdz2 + k2**2 * HertzZ",
  "def getCasingBrMagDipole(srcloc,obsloc,freq,sigma,a,b,mu=mu_0*np.ones(3),eps=epsilon_0,moment=1.):\n    return mu_0 * getCasingHrMagDipole(srcloc,obsloc,freq,sigma,a,b,mu,eps,moment)",
  "def getCasingBzMagDipole(srcloc,obsloc,freq,sigma,a,b,mu=mu_0*np.ones(3),eps=epsilon_0,moment=1.):\n    return mu_0 * getCasingHzMagDipole(srcloc,obsloc,freq,sigma,a,b,mu,eps,moment)",
  "def hzAnalyticDipoleF(r, freq, sigma, secondary=True, mu=mu_0):\n    \"\"\"\n    4.56 in Ward and Hohmann\n\n    .. plot::\n\n        import matplotlib.pyplot as plt\n        from SimPEG import EM\n        freq = np.logspace(-1, 6, 61)\n        test = EM.Analytics.FDEM.hzAnalyticDipoleF(100, freq, 0.001, secondary=False)\n        plt.loglog(freq, abs(test.real))\n        plt.loglog(freq, abs(test.imag))\n        plt.title('Response at $r$=100m')\n        plt.xlabel('Frequency')\n        plt.ylabel('Response')\n        plt.legend(('real','imag'))\n        plt.show()\n\n    \"\"\"\n    r = np.abs(r)\n    k = np.sqrt(-1j*2.*np.pi*freq*mu*sigma)\n\n    m = 1\n    front = m / (2. * np.pi * (k**2) * (r**5) )\n    back = 9 - ( 9 + 9j * k * r - 4 * (k**2) * (r**2) - 1j * (k**3) * (r**3)) * np.exp(-1j*k*r)\n    hz = front*back\n\n    if secondary:\n        hp =-1/(4*np.pi*r**3)\n        hz = hz-hp\n\n    if hz.ndim == 1:\n        hz = Utils.mkvc(hz,2)\n\n    return hz",
  "def MagneticDipoleWholeSpace(XYZ, srcLoc, sig, f, moment=1., orientation='X', mu = mu_0):\n    \"\"\"\n    Analytical solution for a dipole in a whole-space.\n\n    Equation 2.57 of Ward and Hohmann\n\n    TODOs:\n        - set it up to instead take a mesh & survey\n        - add E-fields\n        - handle multiple frequencies\n        - add divide by zero safety\n\n\n    .. plot::\n\n        from SimPEG import EM\n        import matplotlib.pyplot as plt\n        freqs = np.logspace(-2,5,100)\n        Bx, By, Bz = EM.Analytics.FDEM.AnalyticMagDipoleWholeSpace([0,100,0], [0,0,0], 1e-2, freqs, m=1, orientation='Z')\n        plt.loglog(freqs, np.abs(Bz.real)/mu_0, 'b')\n        plt.loglog(freqs, np.abs(Bz.imag)/mu_0, 'r')\n        plt.legend(('real','imag'))\n        plt.show()\n\n\n    \"\"\"\n\n    XYZ = Utils.asArray_N_x_Dim(XYZ, 3)\n\n    dx = XYZ[:,0]-srcLoc[0]\n    dy = XYZ[:,1]-srcLoc[1]\n    dz = XYZ[:,2]-srcLoc[2]\n\n    r  = np.sqrt( dx**2. + dy**2. + dz**2.)\n    k  = np.sqrt( -1j*2.*np.pi*f*mu*sig )\n    kr = k*r\n\n    front = moment / (4.*pi * r**3.) * np.exp(-1j*kr)\n    mid   = -kr**2. + 3.*1j*kr + 3.\n\n    if orientation.upper() == 'X':\n        Hx = front*( (dx/r)**2. * mid + (kr**2. - 1j*kr - 1.) )\n        Hy = front*( (dx*dy/r**2.) * mid )\n        Hz = front*( (dx*dz/r**2.) * mid )\n\n    elif orientation.upper() == 'Y':\n        Hx = front*( (dy*dx/r**2.) * mid )\n        Hy = front*( (dy/r)**2. * mid + (kr**2. - 1j*kr - 1.) )\n        Hz = front*( (dy*dz/r**2.) * mid )\n\n    elif orientation.upper() == 'Z':\n        Hx = front*( (dx*dz/r**2.) * mid )\n        Hy = front*( (dy*dz/r**2.) * mid )\n        Hz = front*( (dz/r)**2. * mid + (kr**2. - 1j*kr - 1.) )\n\n    Bx = mu*Hx\n    By = mu*Hy\n    Bz = mu*Hz\n\n    if Bx.ndim is 1:\n        Bx = Utils.mkvc(Bx,2)\n\n    if By.ndim is 1:\n        By = Utils.mkvc(By,2)\n\n    if Bz.ndim is 1:\n        Bz = Utils.mkvc(Bz,2)\n\n    return Bx, By, Bz",
  "def ElectricDipoleWholeSpace(XYZ, srcLoc, sig, f, current=1., length=1., orientation='X', mu=mu_0):\n    XYZ = Utils.asArray_N_x_Dim(XYZ, 3)\n\n    dx = XYZ[:,0]-srcLoc[0]\n    dy = XYZ[:,1]-srcLoc[1]\n    dz = XYZ[:,2]-srcLoc[2]\n\n    r  = np.sqrt( dx**2. + dy**2. + dz**2.)\n    k  = np.sqrt( -1j*2.*np.pi*f*mu*sig )\n    kr = k*r\n\n    front = current * length / (4. * np.pi * sig * r**3) * np.exp(-1j*k*r)\n    mid   = -k**2 * r**2 + 3*1j*k*r + 3\n\n    # Ex = front*((dx**2 / r**2)*mid + (k**2 * r**2 -1j*k*r))\n    # Ey = front*(dx*dy  / r**2)*mid\n    # Ez = front*(dx*dz  / r**2)*mid\n\n    if orientation.upper() == 'X':\n        Ex = front*((dx**2 / r**2)*mid + (k**2 * r**2 -1j*k*r-1.))\n        Ey = front*(dx*dy  / r**2)*mid\n        Ez = front*(dx*dz  / r**2)*mid\n        return Ex, Ey, Ez\n\n    elif orientation.upper() == 'Y':\n        #  x--> y, y--> z, z-->x\n        Ey = front*((dy**2 / r**2)*mid + (k**2 * r**2 -1j*k*r-1.))\n        Ez = front*(dy*dz  / r**2)*mid\n        Ex = front*(dy*dx  / r**2)*mid\n        return Ex, Ey, Ez\n\n    elif orientation.upper() == 'Z':\n        # x --> z, y --> x, z --> y\n        Ez = front*((dz**2 / r**2)*mid + (k**2 * r**2 -1j*k*r-1.))\n        Ex = front*(dz*dx  / r**2)*mid\n        Ey = front*(dz*dy  / r**2)*mid\n        return Ex, Ey, Ez",
  "def MagneticDipoleVectorPotential(srcLoc, obsLoc, component, moment=1., dipoleMoment=(0., 0., 1.), mu = mu_0):\n    \"\"\"\n        Calculate the vector potential of a set of magnetic dipoles\n        at given locations 'ref. <http://en.wikipedia.org/wiki/Dipole#Magnetic_vector_potential>'\n\n        :param numpy.ndarray srcLoc: Location of the source(s) (x, y, z)\n        :param numpy.ndarray,SimPEG.Mesh obsLoc: Where the potentials will be calculated (x, y, z) or a SimPEG Mesh\n        :param str,list component: The component to calculate - 'x', 'y', or 'z' if an array, or grid type if mesh, can be a list\n        :param numpy.ndarray dipoleMoment: The vector dipole moment\n        :rtype: numpy.ndarray\n        :return: The vector potential each dipole at each observation location\n    \"\"\"\n    #TODO: break this out!\n\n    if type(component) in [list, tuple]:\n        out = range(len(component))\n        for i, comp in enumerate(component):\n            out[i] = MagneticDipoleVectorPotential(srcLoc, obsLoc, comp, dipoleMoment=dipoleMoment)\n        return np.concatenate(out)\n\n    if isinstance(obsLoc, Mesh.BaseMesh):\n        mesh = obsLoc\n        assert component in ['Ex','Ey','Ez','Fx','Fy','Fz'], \"Components must be in: ['Ex','Ey','Ez','Fx','Fy','Fz']\"\n        return MagneticDipoleVectorPotential(srcLoc, getattr(mesh,'grid'+component), component[1], dipoleMoment=dipoleMoment)\n\n    if component == 'x':\n        dimInd = 0\n    elif component == 'y':\n        dimInd = 1\n    elif component == 'z':\n        dimInd = 2\n    else:\n        raise ValueError('Invalid component')\n\n    srcLoc = np.atleast_2d(srcLoc)\n    obsLoc = np.atleast_2d(obsLoc)\n    dipoleMoment = np.atleast_2d(dipoleMoment)\n\n    nEdges = obsLoc.shape[0]\n    nSrc = srcLoc.shape[0]\n\n    m = np.array(dipoleMoment).repeat(nEdges, axis=0)\n    A = np.empty((nEdges, nSrc))\n    for i in range(nSrc):\n        dR = obsLoc - srcLoc[i, np.newaxis].repeat(nEdges, axis=0)\n        mCr = np.cross(m, dR)\n        r = np.sqrt((dR**2).sum(axis=1))\n        A[:, i] = +(mu/(4*pi)) * mCr[:,dimInd]/(r**3)\n    if nSrc == 1:\n        return A.flatten()\n    return A",
  "def MagneticDipoleFields(srcLoc, obsLoc, component, moment=1., mu = mu_0):\n    \"\"\"\n        Calculate the vector potential of a set of magnetic dipoles\n        at given locations 'ref. <http://en.wikipedia.org/wiki/Dipole#Magnetic_vector_potential>'\n\n        :param numpy.ndarray srcLoc: Location of the source(s) (x, y, z)\n        :param numpy.ndarray obsLoc: Where the potentials will be calculated (x, y, z)\n        :param str component: The component to calculate - 'x', 'y', or 'z'\n        :param numpy.ndarray moment: The vector dipole moment (vertical)\n        :rtype: numpy.ndarray\n        :return: The vector potential each dipole at each observation location\n    \"\"\"\n\n    if component=='x':\n        dimInd = 0\n    elif component=='y':\n        dimInd = 1\n    elif component=='z':\n        dimInd = 2\n    else:\n        raise ValueError('Invalid component')\n\n    srcLoc = np.atleast_2d(srcLoc)\n    obsLoc = np.atleast_2d(obsLoc)\n    moment = np.atleast_2d(moment)\n\n    nFaces = obsLoc.shape[0]\n    nSrc = srcLoc.shape[0]\n\n    m = np.array(moment).repeat(nFaces, axis=0)\n    B = np.empty((nFaces, nSrc))\n    for i in range(nSrc):\n        dR = obsLoc - srcLoc[i, np.newaxis].repeat(nFaces, axis=0)\n        r = np.sqrt((dR**2).sum(axis=1))\n        if dimInd == 0:\n            B[:, i] = +(mu/(4*pi)) /(r**3) * (3*dR[:,2]*dR[:,0]/r**2)\n        elif dimInd == 1:\n            B[:, i] = +(mu/(4*pi)) /(r**3) * (3*dR[:,2]*dR[:,1]/r**2)\n        elif dimInd == 2:\n            B[:, i] = +(mu/(4*pi)) /(r**3) * (3*dR[:,2]**2/r**2-1)\n        else:\n            raise Exception(\"Not Implemented\")\n    if nSrc == 1:\n        return B.flatten()\n    return B",
  "def MagneticLoopVectorPotential(srcLoc, obsLoc, component, radius, mu=mu_0):\n    \"\"\"\n        Calculate the vector potential of horizontal circular loop\n        at given locations\n\n        :param numpy.ndarray srcLoc: Location of the source(s) (x, y, z)\n        :param numpy.ndarray,SimPEG.Mesh obsLoc: Where the potentials will be calculated (x, y, z) or a SimPEG Mesh\n        :param str,list component: The component to calculate - 'x', 'y', or 'z' if an array, or grid type if mesh, can be a list\n        :param numpy.ndarray I: Input current of the loop\n        :param numpy.ndarray radius: radius of the loop\n        :rtype: numpy.ndarray\n        :return: The vector potential each dipole at each observation location\n    \"\"\"\n\n    if type(component) in [list, tuple]:\n        out = range(len(component))\n        for i, comp in enumerate(component):\n            out[i] = MagneticLoopVectorPotential(srcLoc, obsLoc, comp, radius, mu)\n        return np.concatenate(out)\n\n    if isinstance(obsLoc, Mesh.BaseMesh):\n        mesh = obsLoc\n        assert component in ['Ex','Ey','Ez','Fx','Fy','Fz'], \"Components must be in: ['Ex','Ey','Ez','Fx','Fy','Fz']\"\n        return MagneticLoopVectorPotential(srcLoc, getattr(mesh,'grid'+component), component[1], radius, mu)\n\n    srcLoc = np.atleast_2d(srcLoc)\n    obsLoc = np.atleast_2d(obsLoc)\n\n    n = obsLoc.shape[0]\n    nSrc = srcLoc.shape[0]\n\n    if component=='z':\n        A = np.zeros((n, nSrc))\n        if nSrc ==1:\n            return A.flatten()\n        return A\n\n    else:\n\n        A = np.zeros((n, nSrc))\n        for i in range (nSrc):\n            x = obsLoc[:, 0] - srcLoc[i, 0]\n            y = obsLoc[:, 1] - srcLoc[i, 1]\n            z = obsLoc[:, 2] - srcLoc[i, 2]\n            r = np.sqrt(x**2 + y**2)\n            m = (4 * radius * r) / ((radius + r)**2 + z**2)\n            m[m > 1.] = 1.\n            # m might be slightly larger than 1 due to rounding errors\n            # but ellipke requires 0 <= m <= 1\n            K = ellipk(m)\n            E = ellipe(m)\n            ind = (r > 0) & (m < 1)\n            # % 1/r singular at r = 0 and K(m) singular at m = 1\n            Aphi = np.zeros(n)\n            # % Common factor is (mu * I) / pi with I = 1 and mu = 4e-7 * pi.\n            Aphi[ind] = 4e-7 / np.sqrt(m[ind])  * np.sqrt(radius / r[ind]) *((1. - m[ind] / 2.) * K[ind] - E[ind])\n            if component == 'x':\n                A[ind, i] = Aphi[ind] * (-y[ind] / r[ind] )\n            elif component == 'y':\n                A[ind, i] = Aphi[ind] * ( x[ind] / r[ind] )\n            else:\n                raise ValueError('Invalid component')\n\n        if nSrc == 1:\n            return A.flatten()\n        return A",
  "def omega(freq):\n    \"\"\"Angular frequency, omega\"\"\"\n    return 2.*np.pi*freq",
  "def k(freq, sigma, mu=mu_0, eps=epsilon_0):\n    \"\"\" Eq 1.47 - 1.49 in Ward and Hohmann \"\"\"\n    w = omega(freq)\n    alp  = w * np.sqrt( mu*eps/2 * ( np.sqrt(1. + (sigma / (eps*w))**2 ) + 1) ) \n    beta = w * np.sqrt( mu*eps/2 * ( np.sqrt(1. + (sigma / (eps*w))**2 ) - 1) ) \n    return alp - 1j*beta",
  "def e_from_j(prob,j):\n    eqLocs = prob._eqLocs\n    if eqLocs is 'FE':\n        MSigmaI = prob.MeSigmaI\n    elif eqLocs is 'EF':\n        MSigmaI = prob.MfRho\n    return MSigmaI*j",
  "def j_from_e(prob,e):\n    eqLocs = prob._eqLocs\n    if eqLocs is 'FE':\n        MSigma = prob.MeSigma\n    elif eqLocs is 'EF':\n        MSigma = prob.MfRhoI\n    return MSigma*e",
  "def b_from_h(prob,h):\n    eqLocs = prob._eqLocs\n    if eqLocs is 'FE':\n        MMu = prob.MfMuiI\n    elif eqLocs is 'EF':\n        MMu = prob.MeMu\n    return MMu*h",
  "def h_from_b(prob,b):\n    eqLocs = prob._eqLocs\n    if eqLocs is 'FE':\n        MMuI = prob.MfMui\n    elif eqLocs is 'EF':\n        MMuI = prob.MeMuI\n    return MMuI*b",
  "class RxTDEM(Survey.BaseTimeRx):\n\n    knownRxTypes = {\n                    'ex':['e', 'Ex', 'N'],\n                    'ey':['e', 'Ey', 'N'],\n                    'ez':['e', 'Ez', 'N'],\n\n                    'bx':['b', 'Fx', 'N'],\n                    'by':['b', 'Fy', 'N'],\n                    'bz':['b', 'Fz', 'N'],\n\n                    'dbxdt':['b', 'Fx', 'CC'],\n                    'dbydt':['b', 'Fy', 'CC'],\n                    'dbzdt':['b', 'Fz', 'CC'],\n                   }\n\n    def __init__(self, locs, times, rxType):\n        Survey.BaseTimeRx.__init__(self, locs, times, rxType)\n\n    @property\n    def projField(self):\n        \"\"\"Field Type projection (e.g. e b ...)\"\"\"\n        return self.knownRxTypes[self.rxType][0]\n\n    @property\n    def projGLoc(self):\n        \"\"\"Grid Location projection (e.g. Ex Fy ...)\"\"\"\n        return self.knownRxTypes[self.rxType][1]\n\n    @property\n    def projTLoc(self):\n        \"\"\"Time Location projection (e.g. CC N)\"\"\"\n        return self.knownRxTypes[self.rxType][2]\n\n    def getTimeP(self, timeMesh):\n        \"\"\"\n            Returns the time projection matrix.\n\n            .. note::\n\n                This is not stored in memory, but is created on demand.\n        \"\"\"\n        if self.rxType in ['dbxdt','dbydt','dbzdt']:\n            return timeMesh.getInterpolationMat(self.times, self.projTLoc)*timeMesh.faceDiv\n        else:\n            return timeMesh.getInterpolationMat(self.times, self.projTLoc)\n\n    def projectFields(self, src, mesh, timeMesh, u):\n        P = self.getP(mesh, timeMesh)\n        u_part = Utils.mkvc(u[src, self.projField, :])\n        return P*u_part\n\n    def projectFieldsDeriv(self, src, mesh, timeMesh, u, v, adjoint=False):\n        P = self.getP(mesh, timeMesh)\n\n        if not adjoint:\n            return P * Utils.mkvc(v[src, self.projField, :])\n        elif adjoint:\n            return P.T * v[src, self]",
  "class SrcTDEM(Survey.BaseSrc):\n    rxPair = RxTDEM\n    radius = None\n\n    def getInitialFields(self, mesh):\n        F0 = getattr(self, '_getInitialFields_' + self.srcType)(mesh)\n        return F0\n\n    def getJs(self, mesh, time):\n        return None",
  "class SrcTDEM_VMD_MVP(SrcTDEM):\n\n    def __init__(self,rxList,loc):\n        self.loc = loc\n        SrcTDEM.__init__(self,rxList)\n\n    def getInitialFields(self, mesh):\n        \"\"\"Vertical magnetic dipole, magnetic vector potential\"\"\"\n        if mesh._meshType is 'CYL':\n            if mesh.isSymmetric:\n                MVP = MagneticDipoleVectorPotential(self.loc, mesh, 'Ey')\n            else:\n                raise NotImplementedError('Non-symmetric cyl mesh not implemented yet!')\n        elif mesh._meshType is 'TENSOR':\n            MVP = MagneticDipoleVectorPotential(self.loc, mesh, ['Ex','Ey','Ez'])\n        else:\n            raise Exception('Unknown mesh for VMD')\n\n        return {\"b\": mesh.edgeCurl*MVP}",
  "class SrcTDEM_CircularLoop_MVP(SrcTDEM):\n\n    def __init__(self,rxList,loc,radius):\n        self.loc = loc\n        self.radius = radius\n        SrcTDEM.__init__(self,rxList)\n\n    def getInitialFields(self, mesh):\n        \"\"\"Circular Loop, magnetic vector potential\"\"\"\n        if mesh._meshType is 'CYL':\n            if mesh.isSymmetric:\n                MVP = MagneticLoopVectorPotential(self.loc, mesh, 'Ey', self.radius)\n            else:\n                raise NotImplementedError('Non-symmetric cyl mesh not implemented yet!')\n        elif mesh._meshType is 'TENSOR':\n            MVP = MagneticLoopVectorPotential(self.loc, mesh, ['Ex','Ey','Ez'], self.radius)\n        else:\n            raise Exception('Unknown mesh for CircularLoop')\n\n        return {\"b\": mesh.edgeCurl*MVP}",
  "class SurveyTDEM(Survey.BaseSurvey):\n    \"\"\"\n        docstring for SurveyTDEM\n    \"\"\"\n    srcPair = SrcTDEM\n\n    def __init__(self, srcList, **kwargs):\n        # Sort these by frequency\n        self.srcList = srcList\n        Survey.BaseSurvey.__init__(self, **kwargs)\n\n    def projectFields(self, u):\n        data = Survey.Data(self)\n        for src in self.srcList:\n            for rx in src.rxList:\n                data[src, rx] = rx.projectFields(src, self.mesh, self.prob.timeMesh, u)\n        return data\n\n    def projectFieldsDeriv(self, u, v=None, adjoint=False):\n        assert v is not None, 'v to multiply must be provided.'\n\n        if not adjoint:\n            data = Survey.Data(self)\n            for src in self.srcList:\n                for rx in src.rxList:\n                    data[src, rx] = rx.projectFieldsDeriv(src, self.mesh, self.prob.timeMesh, u, v)\n            return data\n        else:\n            f = FieldsTDEM(self.mesh, self)\n            for src in self.srcList:\n                for rx in src.rxList:\n                    Ptv = rx.projectFieldsDeriv(src, self.mesh, self.prob.timeMesh, u, v, adjoint=True)\n                    Ptv = Ptv.reshape((-1, self.prob.timeMesh.nN), order='F')\n                    if rx.projField not in f: # first time we are projecting\n                        f[src, rx.projField, :] = Ptv\n                    else: # there are already fields, so let's add to them!\n                        f[src, rx.projField, :] += Ptv\n            return f",
  "def __init__(self, locs, times, rxType):\n        Survey.BaseTimeRx.__init__(self, locs, times, rxType)",
  "def projField(self):\n        \"\"\"Field Type projection (e.g. e b ...)\"\"\"\n        return self.knownRxTypes[self.rxType][0]",
  "def projGLoc(self):\n        \"\"\"Grid Location projection (e.g. Ex Fy ...)\"\"\"\n        return self.knownRxTypes[self.rxType][1]",
  "def projTLoc(self):\n        \"\"\"Time Location projection (e.g. CC N)\"\"\"\n        return self.knownRxTypes[self.rxType][2]",
  "def getTimeP(self, timeMesh):\n        \"\"\"\n            Returns the time projection matrix.\n\n            .. note::\n\n                This is not stored in memory, but is created on demand.\n        \"\"\"\n        if self.rxType in ['dbxdt','dbydt','dbzdt']:\n            return timeMesh.getInterpolationMat(self.times, self.projTLoc)*timeMesh.faceDiv\n        else:\n            return timeMesh.getInterpolationMat(self.times, self.projTLoc)",
  "def projectFields(self, src, mesh, timeMesh, u):\n        P = self.getP(mesh, timeMesh)\n        u_part = Utils.mkvc(u[src, self.projField, :])\n        return P*u_part",
  "def projectFieldsDeriv(self, src, mesh, timeMesh, u, v, adjoint=False):\n        P = self.getP(mesh, timeMesh)\n\n        if not adjoint:\n            return P * Utils.mkvc(v[src, self.projField, :])\n        elif adjoint:\n            return P.T * v[src, self]",
  "def getInitialFields(self, mesh):\n        F0 = getattr(self, '_getInitialFields_' + self.srcType)(mesh)\n        return F0",
  "def getJs(self, mesh, time):\n        return None",
  "def __init__(self,rxList,loc):\n        self.loc = loc\n        SrcTDEM.__init__(self,rxList)",
  "def getInitialFields(self, mesh):\n        \"\"\"Vertical magnetic dipole, magnetic vector potential\"\"\"\n        if mesh._meshType is 'CYL':\n            if mesh.isSymmetric:\n                MVP = MagneticDipoleVectorPotential(self.loc, mesh, 'Ey')\n            else:\n                raise NotImplementedError('Non-symmetric cyl mesh not implemented yet!')\n        elif mesh._meshType is 'TENSOR':\n            MVP = MagneticDipoleVectorPotential(self.loc, mesh, ['Ex','Ey','Ez'])\n        else:\n            raise Exception('Unknown mesh for VMD')\n\n        return {\"b\": mesh.edgeCurl*MVP}",
  "def __init__(self,rxList,loc,radius):\n        self.loc = loc\n        self.radius = radius\n        SrcTDEM.__init__(self,rxList)",
  "def getInitialFields(self, mesh):\n        \"\"\"Circular Loop, magnetic vector potential\"\"\"\n        if mesh._meshType is 'CYL':\n            if mesh.isSymmetric:\n                MVP = MagneticLoopVectorPotential(self.loc, mesh, 'Ey', self.radius)\n            else:\n                raise NotImplementedError('Non-symmetric cyl mesh not implemented yet!')\n        elif mesh._meshType is 'TENSOR':\n            MVP = MagneticLoopVectorPotential(self.loc, mesh, ['Ex','Ey','Ez'], self.radius)\n        else:\n            raise Exception('Unknown mesh for CircularLoop')\n\n        return {\"b\": mesh.edgeCurl*MVP}",
  "def __init__(self, srcList, **kwargs):\n        # Sort these by frequency\n        self.srcList = srcList\n        Survey.BaseSurvey.__init__(self, **kwargs)",
  "def projectFields(self, u):\n        data = Survey.Data(self)\n        for src in self.srcList:\n            for rx in src.rxList:\n                data[src, rx] = rx.projectFields(src, self.mesh, self.prob.timeMesh, u)\n        return data",
  "def projectFieldsDeriv(self, u, v=None, adjoint=False):\n        assert v is not None, 'v to multiply must be provided.'\n\n        if not adjoint:\n            data = Survey.Data(self)\n            for src in self.srcList:\n                for rx in src.rxList:\n                    data[src, rx] = rx.projectFieldsDeriv(src, self.mesh, self.prob.timeMesh, u, v)\n            return data\n        else:\n            f = FieldsTDEM(self.mesh, self)\n            for src in self.srcList:\n                for rx in src.rxList:\n                    Ptv = rx.projectFieldsDeriv(src, self.mesh, self.prob.timeMesh, u, v, adjoint=True)\n                    Ptv = Ptv.reshape((-1, self.prob.timeMesh.nN), order='F')\n                    if rx.projField not in f: # first time we are projecting\n                        f[src, rx.projField, :] = Ptv\n                    else: # there are already fields, so let's add to them!\n                        f[src, rx.projField, :] += Ptv\n            return f",
  "class FieldsTDEM_e_from_b(FieldsTDEM):\n    \"\"\"Fancy Field Storage for a TDEM survey.\"\"\"\n    knownFields = {'b': 'F'}\n    aliasFields = {'e': ['b','E','e_from_b']}\n\n    def startup(self):\n        self.MeSigmaI  = self.survey.prob.MeSigmaI\n        self.edgeCurlT = self.survey.prob.mesh.edgeCurl.T\n        self.MfMui     = self.survey.prob.MfMui\n\n    def e_from_b(self, b, srcInd, timeInd):\n        # TODO: implement non-zero js\n        return self.MeSigmaI*(self.edgeCurlT*(self.MfMui*b))",
  "class FieldsTDEM_e_from_b_Ah(FieldsTDEM):\n    \"\"\"Fancy Field Storage for a TDEM survey.\n\n        This is used when solving Ahat and AhatT\n    \"\"\"\n    knownFields = {'b': 'F'}\n    aliasFields = {'e': ['b','E','e_from_b']}\n    p = None\n\n    def startup(self):\n        self.MeSigmaI  = self.survey.prob.MeSigmaI\n        self.edgeCurlT = self.survey.prob.mesh.edgeCurl.T\n        self.MfMui     = self.survey.prob.MfMui\n\n    def e_from_b(self, y_b, srcInd, tInd):\n        y_e = self.MeSigmaI*(self.edgeCurlT*(self.MfMui*y_b))\n        if 'e' in self.p:\n            y_e = y_e - self.MeSigmaI*self.p[srcInd,'e',tInd]\n        return y_e",
  "class ProblemTDEM_b(BaseTDEMProblem):\n    \"\"\"\n        Time-Domain EM problem - B-formulation\n\n        TDEM_b treats the following discretization of Maxwell's equations\n\n        .. math::\n            \\dcurl \\e^{(t+1)} + \\\\frac{\\\\b^{(t+1)} - \\\\b^{(t)}}{\\delta t} = 0 \\\\\\\\\n            \\dcurl^\\\\top \\MfMui \\\\b^{(t+1)} - \\MeSig \\e^{(t+1)} = \\Me \\j_s^{(t+1)}\n\n        with \\\\\\(\\\\b\\\\\\) defined on cell faces and \\\\\\(\\e\\\\\\) defined on edges.\n    \"\"\"\n    def __init__(self, mesh, mapping=None, **kwargs):\n        BaseTDEMProblem.__init__(self, mesh, mapping=mapping, **kwargs)\n\n    solType = 'b' #: Type of the solution, in this case the 'b' field\n\n    surveyPair = SurveyTDEM\n    _FieldsForward_pair = FieldsTDEM_e_from_b     #: used for the forward calculation only\n\n    ####################################################\n    # Internal Methods\n    ####################################################\n\n    def getA(self, tInd):\n        \"\"\"\n            :param int tInd: Time index\n            :rtype: scipy.sparse.csr_matrix\n            :return: A\n        \"\"\"\n        dt = self.timeSteps[tInd]\n        return self.MfMui*self.mesh.edgeCurl*self.MeSigmaI*self.mesh.edgeCurl.T*self.MfMui + (1.0/dt)*self.MfMui\n\n    def getRHS(self, tInd, F):\n        dt = self.timeSteps[tInd]\n        B_n = np.c_[[F[src,'b',tInd] for src in self.survey.srcList]].T\n        if B_n.shape[0] is not 1:\n            raise NotImplementedError('getRHS not implemented for this shape of B_n')\n        RHS = (1.0/dt)*self.MfMui*B_n[0,:,:] #TODO: This is a hack\n        return RHS\n\n    ####################################################\n    # Derivatives\n    ####################################################\n\n    def Gvec(self, m, vec, u=None):\n        \"\"\"\n            :param numpy.array m: Conductivity model\n            :param numpy.array vec: vector (like a model)\n            :param simpegEM.TDEM.FieldsTDEM u: Fields resulting from m\n            :rtype: simpegEM.TDEM.FieldsTDEM\n            :return: f\n\n            Multiply G by a vector\n        \"\"\"\n        if u is None:\n            u = self.fields(m)\n        self.curModel = m\n\n        # Note: Fields has shape (nF/E, nSrc, nT+1)\n        #       However, p will only really fill (:,:,1:nT+1)\n        #       meaning the 'initial fields' are zero (:,:,0)\n        p = FieldsTDEM(self.mesh, self.survey)\n        # 'b' at all times is zero.\n        #       However, to save memory we will **not** do:\n        #\n        #               p[:, 'b', :] = 0.0\n\n        # fake initial 'e' fields\n        p[:, 'e', 0] = 0.0\n        dMdsig = self.MeSigmaDeriv\n        # self.mesh.getEdgeInnerProductDeriv(self.curModel.transform)\n        # dsigdm_x_v = self.curModel.sigmaDeriv*vec\n        # dsigdm_x_v = self.curModel.transformDeriv*vec\n        for i in range(1,self.nT+1):\n            # TODO: G[1] may be dependent on the model\n            #       for a galvanic source (deriv of the dc problem)\n            #\n            # Do multiplication for all src in self.survey.srcList\n            for src in self.survey.srcList:\n                p[src, 'e', i] = - dMdsig(u[src,'e',i]) *  vec\n        return p\n\n    def Gtvec(self, m, vec, u=None):\n        \"\"\"\n            :param numpy.array m: Conductivity model\n            :param numpy.array vec: vector (like a fields)\n            :param simpegEM.TDEM.FieldsTDEM u: Fields resulting from m\n            :rtype: np.ndarray (like a model)\n            :return: p\n\n            Multiply G.T by a vector\n        \"\"\"\n        if u is None:\n            u = self.fields(m)\n        self.curModel = m\n        # dMdsig = self.mesh.getEdgeInnerProductDeriv(self.curModel.transform)\n        # dsigdm = self.curModel.transformDeriv\n        MeSigmaDeriv = self.MeSigmaDeriv\n\n        nSrc = self.survey.nSrc\n        VUs = None\n        # Here we can do internal multiplications of Gt*v and then multiply by MsigDeriv.T in one go.\n        for i in range(1,self.nT+1):\n            vu = None\n            for src in self.survey.srcList:\n                vusrc = MeSigmaDeriv(u[src,'e',i]).T * vec[src,'e',i]\n                vu = vusrc if vu is None else vu + vusrc\n            VUs = vu if VUs is None else VUs + vu\n        # p = -dsigdm.T*VUs\n        return -VUs\n\n    def solveAh(self, m, p):\n        \"\"\"\n            :param numpy.array m: Conductivity model\n            :param simpegEM.TDEM.FieldsTDEM p: Fields object\n            :rtype: simpegEM.TDEM.FieldsTDEM\n            :return: y\n\n            Solve the block-matrix system \\\\\\(\\\\\\hat{A} \\\\\\hat{y} = \\\\\\hat{p}\\\\\\):\n\n            .. math::\n                \\mathbf{\\hat{A}} = \\left[\n                    \\\\begin{array}{cccc}\n                        A & 0 & & \\\\\\\\\n                        B & A & & \\\\\\\\\n                        & \\ddots & \\ddots & \\\\\\\\\n                        & & B & A\n                    \\end{array}\n                \\\\right] \\\\\\\\\n                \\mathbf{A} =\n                \\left[\n                    \\\\begin{array}{cc}\n                        \\\\frac{1}{\\delta t} \\MfMui & \\MfMui\\dcurl \\\\\\\\\n                        \\dcurl^\\\\top \\MfMui & -\\MeSig\n                    \\end{array}\n                \\\\right] \\\\\\\\\n                \\mathbf{B} =\n                \\left[\n                    \\\\begin{array}{cc}\n                        -\\\\frac{1}{\\delta t} \\MfMui & 0 \\\\\\\\\n                        0 & 0\n                    \\end{array}\n                \\\\right] \\\\\\\\\n        \"\"\"\n\n        def AhRHS(tInd, y):\n            rhs = self.MfMui*(self.mesh.edgeCurl*(self.MeSigmaI*p[:,'e',tInd+1]))\n            if 'b' in p:\n                rhs = rhs + p[:,'b',tInd+1]\n            if tInd == 0:\n                return rhs\n            dt = self.timeSteps[tInd]\n            return rhs + 1.0/dt*self.MfMui*y[:,'b',tInd]\n\n        F = FieldsTDEM_e_from_b_Ah(self.mesh, self.survey, p=p)\n\n        return self.forward(m, AhRHS, F)\n\n    def solveAht(self, m, p):\n        \"\"\"\n            :param numpy.array m: Conductivity model\n            :param simpegEM.TDEM.FieldsTDEM p: Fields object\n            :rtype: simpegEM.TDEM.FieldsTDEM\n            :return: y\n\n            Solve the block-matrix system \\\\\\(\\\\\\hat{A}^\\\\\\\\top \\\\\\hat{y} = \\\\\\hat{p}\\\\\\):\n\n            .. math::\n                \\mathbf{\\hat{A}}^\\\\top = \\left[\n                    \\\\begin{array}{cccc}\n                        A & B & & \\\\\\\\\n                          & \\ddots & \\ddots & \\\\\\\\\n                          & & A & B \\\\\\\\\n                          & & 0 & A\n                    \\end{array}\n                \\\\right] \\\\\\\\\n                \\mathbf{A} =\n                \\left[\n                    \\\\begin{array}{cc}\n                        \\\\frac{1}{\\delta t} \\MfMui & \\MfMui\\dcurl \\\\\\\\\n                        \\dcurl^\\\\top \\MfMui & -\\MeSig\n                    \\end{array}\n                \\\\right] \\\\\\\\\n                \\mathbf{B} =\n                \\left[\n                    \\\\begin{array}{cc}\n                        -\\\\frac{1}{\\delta t} \\MfMui & 0 \\\\\\\\\n                        0 & 0\n                    \\end{array}\n                \\\\right] \\\\\\\\\n        \"\"\"\n\n        #  Mini Example:\n        #\n        #       nT = 3, len(times) == 4, fields stored in F[:,:,1:4]\n        #\n        #       0 is held for initial conditions (this shifts the storage by +1)\n        #       ^\n        #  fLoc 0     1     2     3\n        #       |-----|-----|-----|\n        #  tInd    0     1     2\n        #                        / ___/\n        #                      2          (tInd=2 uses fields 3 and would use 4 but it doesn't exist)\n        #                 / ___/\n        #                1                (tInd=1 uses fields 2 and 3)\n\n        def AhtRHS(tInd, y):\n            nSrc, nF = self.survey.nSrc, self.mesh.nF\n            rhs = np.zeros((nF,1) if nSrc == 1 else (nF, nSrc))\n\n            if 'e' in p:\n                rhs += self.MfMui*(self.mesh.edgeCurl*(self.MeSigmaI*p[:,'e',tInd+1]))\n            if 'b' in p:\n                rhs += p[:,'b',tInd+1]\n\n            if tInd == self.nT-1:\n                return rhs\n            dt = self.timeSteps[tInd+1]\n            return rhs + 1.0/dt*self.MfMui*y[:,'b',tInd+2]\n\n        F = FieldsTDEM_e_from_b_Ah(self.mesh, self.survey, p=p)\n\n        return self.adjoint(m, AhtRHS, F)\n\n    ####################################################\n    # Functions for tests\n    ####################################################\n\n    def _AhVec(self, m, vec):\n        \"\"\"\n            :param numpy.array m: Conductivity model\n            :param simpegEM.TDEM.FieldsTDEM vec: Fields object\n            :rtype: simpegEM.TDEM.FieldsTDEM\n            :return: f\n\n            Multiply the matrix \\\\\\(\\\\\\hat{A}\\\\\\) by a fields vector where\n\n            .. math::\n                \\mathbf{\\hat{A}} = \\left[\n                    \\\\begin{array}{cccc}\n                        A & 0 & & \\\\\\\\\n                        B & A & & \\\\\\\\\n                        & \\ddots & \\ddots & \\\\\\\\\n                        & & B & A\n                    \\end{array}\n                \\\\right] \\\\\\\\\n                \\mathbf{A} =\n                \\left[\n                    \\\\begin{array}{cc}\n                        \\\\frac{1}{\\delta t} \\MfMui & \\MfMui\\dcurl \\\\\\\\\n                        \\dcurl^\\\\top \\MfMui & -\\MeSig\n                    \\end{array}\n                \\\\right] \\\\\\\\\n                \\mathbf{B} =\n                \\left[\n                    \\\\begin{array}{cc}\n                        -\\\\frac{1}{\\delta t} \\MfMui & 0 \\\\\\\\\n                        0 & 0\n                    \\end{array}\n                \\\\right] \\\\\\\\\n        \"\"\"\n\n        self.curModel = m\n        f = FieldsTDEM(self.mesh, self.survey)\n        for i in range(1,self.nT+1):\n            dt = self.timeSteps[i-1]\n            b = 1.0/dt*self.MfMui*vec[:,'b',i] + self.MfMui*(self.mesh.edgeCurl*vec[:,'e',i])\n            if i > 1:\n                b = b - 1.0/dt*self.MfMui*vec[:,'b',i-1]\n            f[:,'b',i] = b\n            f[:,'e',i] = self.mesh.edgeCurl.T*(self.MfMui*vec[:,'b',i]) - self.MeSigma*vec[:,'e',i]\n        return f\n\n    def _AhtVec(self, m, vec):\n        \"\"\"\n            :param numpy.array m: Conductivity model\n            :param simpegEM.TDEM.FieldsTDEM vec: Fields object\n            :rtype: simpegEM.TDEM.FieldsTDEM\n            :return: f\n\n            Multiply the matrix \\\\\\(\\\\\\hat{A}\\\\\\) by a fields vector where\n\n            .. math::\n                \\mathbf{\\hat{A}}^\\\\top = \\left[\n                    \\\\begin{array}{cccc}\n                        A & B & & \\\\\\\\\n                          & \\ddots & \\ddots & \\\\\\\\\n                          & & A & B \\\\\\\\\n                          & & 0 & A\n                    \\end{array}\n                \\\\right] \\\\\\\\\n                \\mathbf{A} =\n                \\left[\n                    \\\\begin{array}{cc}\n                        \\\\frac{1}{\\delta t} \\MfMui & \\MfMui\\dcurl \\\\\\\\\n                        \\dcurl^\\\\top \\MfMui & -\\MeSig\n                    \\end{array}\n                \\\\right] \\\\\\\\\n                \\mathbf{B} =\n                \\left[\n                    \\\\begin{array}{cc}\n                        -\\\\frac{1}{\\delta t} \\MfMui & 0 \\\\\\\\\n                        0 & 0\n                    \\end{array}\n                \\\\right] \\\\\\\\\n        \"\"\"\n        self.curModel = m\n        f = FieldsTDEM(self.mesh, self.survey)\n        for i in range(self.nT):\n            b = 1.0/self.timeSteps[i]*self.MfMui*vec[:,'b',i+1] + self.MfMui*(self.mesh.edgeCurl*vec[:,'e',i+1])\n            if i < self.nT-1:\n                b = b - 1.0/self.timeSteps[i+1]*self.MfMui*vec[:,'b',i+2]\n            f[:,'b', i+1] = b\n            f[:,'e', i+1] = self.mesh.edgeCurl.T*(self.MfMui*vec[:,'b',i+1]) - self.MeSigma*vec[:,'e',i+1]\n        return f",
  "def startup(self):\n        self.MeSigmaI  = self.survey.prob.MeSigmaI\n        self.edgeCurlT = self.survey.prob.mesh.edgeCurl.T\n        self.MfMui     = self.survey.prob.MfMui",
  "def e_from_b(self, b, srcInd, timeInd):\n        # TODO: implement non-zero js\n        return self.MeSigmaI*(self.edgeCurlT*(self.MfMui*b))",
  "def startup(self):\n        self.MeSigmaI  = self.survey.prob.MeSigmaI\n        self.edgeCurlT = self.survey.prob.mesh.edgeCurl.T\n        self.MfMui     = self.survey.prob.MfMui",
  "def e_from_b(self, y_b, srcInd, tInd):\n        y_e = self.MeSigmaI*(self.edgeCurlT*(self.MfMui*y_b))\n        if 'e' in self.p:\n            y_e = y_e - self.MeSigmaI*self.p[srcInd,'e',tInd]\n        return y_e",
  "def __init__(self, mesh, mapping=None, **kwargs):\n        BaseTDEMProblem.__init__(self, mesh, mapping=mapping, **kwargs)",
  "def getA(self, tInd):\n        \"\"\"\n            :param int tInd: Time index\n            :rtype: scipy.sparse.csr_matrix\n            :return: A\n        \"\"\"\n        dt = self.timeSteps[tInd]\n        return self.MfMui*self.mesh.edgeCurl*self.MeSigmaI*self.mesh.edgeCurl.T*self.MfMui + (1.0/dt)*self.MfMui",
  "def getRHS(self, tInd, F):\n        dt = self.timeSteps[tInd]\n        B_n = np.c_[[F[src,'b',tInd] for src in self.survey.srcList]].T\n        if B_n.shape[0] is not 1:\n            raise NotImplementedError('getRHS not implemented for this shape of B_n')\n        RHS = (1.0/dt)*self.MfMui*B_n[0,:,:] #TODO: This is a hack\n        return RHS",
  "def Gvec(self, m, vec, u=None):\n        \"\"\"\n            :param numpy.array m: Conductivity model\n            :param numpy.array vec: vector (like a model)\n            :param simpegEM.TDEM.FieldsTDEM u: Fields resulting from m\n            :rtype: simpegEM.TDEM.FieldsTDEM\n            :return: f\n\n            Multiply G by a vector\n        \"\"\"\n        if u is None:\n            u = self.fields(m)\n        self.curModel = m\n\n        # Note: Fields has shape (nF/E, nSrc, nT+1)\n        #       However, p will only really fill (:,:,1:nT+1)\n        #       meaning the 'initial fields' are zero (:,:,0)\n        p = FieldsTDEM(self.mesh, self.survey)\n        # 'b' at all times is zero.\n        #       However, to save memory we will **not** do:\n        #\n        #               p[:, 'b', :] = 0.0\n\n        # fake initial 'e' fields\n        p[:, 'e', 0] = 0.0\n        dMdsig = self.MeSigmaDeriv\n        # self.mesh.getEdgeInnerProductDeriv(self.curModel.transform)\n        # dsigdm_x_v = self.curModel.sigmaDeriv*vec\n        # dsigdm_x_v = self.curModel.transformDeriv*vec\n        for i in range(1,self.nT+1):\n            # TODO: G[1] may be dependent on the model\n            #       for a galvanic source (deriv of the dc problem)\n            #\n            # Do multiplication for all src in self.survey.srcList\n            for src in self.survey.srcList:\n                p[src, 'e', i] = - dMdsig(u[src,'e',i]) *  vec\n        return p",
  "def Gtvec(self, m, vec, u=None):\n        \"\"\"\n            :param numpy.array m: Conductivity model\n            :param numpy.array vec: vector (like a fields)\n            :param simpegEM.TDEM.FieldsTDEM u: Fields resulting from m\n            :rtype: np.ndarray (like a model)\n            :return: p\n\n            Multiply G.T by a vector\n        \"\"\"\n        if u is None:\n            u = self.fields(m)\n        self.curModel = m\n        # dMdsig = self.mesh.getEdgeInnerProductDeriv(self.curModel.transform)\n        # dsigdm = self.curModel.transformDeriv\n        MeSigmaDeriv = self.MeSigmaDeriv\n\n        nSrc = self.survey.nSrc\n        VUs = None\n        # Here we can do internal multiplications of Gt*v and then multiply by MsigDeriv.T in one go.\n        for i in range(1,self.nT+1):\n            vu = None\n            for src in self.survey.srcList:\n                vusrc = MeSigmaDeriv(u[src,'e',i]).T * vec[src,'e',i]\n                vu = vusrc if vu is None else vu + vusrc\n            VUs = vu if VUs is None else VUs + vu\n        # p = -dsigdm.T*VUs\n        return -VUs",
  "def solveAh(self, m, p):\n        \"\"\"\n            :param numpy.array m: Conductivity model\n            :param simpegEM.TDEM.FieldsTDEM p: Fields object\n            :rtype: simpegEM.TDEM.FieldsTDEM\n            :return: y\n\n            Solve the block-matrix system \\\\\\(\\\\\\hat{A} \\\\\\hat{y} = \\\\\\hat{p}\\\\\\):\n\n            .. math::\n                \\mathbf{\\hat{A}} = \\left[\n                    \\\\begin{array}{cccc}\n                        A & 0 & & \\\\\\\\\n                        B & A & & \\\\\\\\\n                        & \\ddots & \\ddots & \\\\\\\\\n                        & & B & A\n                    \\end{array}\n                \\\\right] \\\\\\\\\n                \\mathbf{A} =\n                \\left[\n                    \\\\begin{array}{cc}\n                        \\\\frac{1}{\\delta t} \\MfMui & \\MfMui\\dcurl \\\\\\\\\n                        \\dcurl^\\\\top \\MfMui & -\\MeSig\n                    \\end{array}\n                \\\\right] \\\\\\\\\n                \\mathbf{B} =\n                \\left[\n                    \\\\begin{array}{cc}\n                        -\\\\frac{1}{\\delta t} \\MfMui & 0 \\\\\\\\\n                        0 & 0\n                    \\end{array}\n                \\\\right] \\\\\\\\\n        \"\"\"\n\n        def AhRHS(tInd, y):\n            rhs = self.MfMui*(self.mesh.edgeCurl*(self.MeSigmaI*p[:,'e',tInd+1]))\n            if 'b' in p:\n                rhs = rhs + p[:,'b',tInd+1]\n            if tInd == 0:\n                return rhs\n            dt = self.timeSteps[tInd]\n            return rhs + 1.0/dt*self.MfMui*y[:,'b',tInd]\n\n        F = FieldsTDEM_e_from_b_Ah(self.mesh, self.survey, p=p)\n\n        return self.forward(m, AhRHS, F)",
  "def solveAht(self, m, p):\n        \"\"\"\n            :param numpy.array m: Conductivity model\n            :param simpegEM.TDEM.FieldsTDEM p: Fields object\n            :rtype: simpegEM.TDEM.FieldsTDEM\n            :return: y\n\n            Solve the block-matrix system \\\\\\(\\\\\\hat{A}^\\\\\\\\top \\\\\\hat{y} = \\\\\\hat{p}\\\\\\):\n\n            .. math::\n                \\mathbf{\\hat{A}}^\\\\top = \\left[\n                    \\\\begin{array}{cccc}\n                        A & B & & \\\\\\\\\n                          & \\ddots & \\ddots & \\\\\\\\\n                          & & A & B \\\\\\\\\n                          & & 0 & A\n                    \\end{array}\n                \\\\right] \\\\\\\\\n                \\mathbf{A} =\n                \\left[\n                    \\\\begin{array}{cc}\n                        \\\\frac{1}{\\delta t} \\MfMui & \\MfMui\\dcurl \\\\\\\\\n                        \\dcurl^\\\\top \\MfMui & -\\MeSig\n                    \\end{array}\n                \\\\right] \\\\\\\\\n                \\mathbf{B} =\n                \\left[\n                    \\\\begin{array}{cc}\n                        -\\\\frac{1}{\\delta t} \\MfMui & 0 \\\\\\\\\n                        0 & 0\n                    \\end{array}\n                \\\\right] \\\\\\\\\n        \"\"\"\n\n        #  Mini Example:\n        #\n        #       nT = 3, len(times) == 4, fields stored in F[:,:,1:4]\n        #\n        #       0 is held for initial conditions (this shifts the storage by +1)\n        #       ^\n        #  fLoc 0     1     2     3\n        #       |-----|-----|-----|\n        #  tInd    0     1     2\n        #                        / ___/\n        #                      2          (tInd=2 uses fields 3 and would use 4 but it doesn't exist)\n        #                 / ___/\n        #                1                (tInd=1 uses fields 2 and 3)\n\n        def AhtRHS(tInd, y):\n            nSrc, nF = self.survey.nSrc, self.mesh.nF\n            rhs = np.zeros((nF,1) if nSrc == 1 else (nF, nSrc))\n\n            if 'e' in p:\n                rhs += self.MfMui*(self.mesh.edgeCurl*(self.MeSigmaI*p[:,'e',tInd+1]))\n            if 'b' in p:\n                rhs += p[:,'b',tInd+1]\n\n            if tInd == self.nT-1:\n                return rhs\n            dt = self.timeSteps[tInd+1]\n            return rhs + 1.0/dt*self.MfMui*y[:,'b',tInd+2]\n\n        F = FieldsTDEM_e_from_b_Ah(self.mesh, self.survey, p=p)\n\n        return self.adjoint(m, AhtRHS, F)",
  "def _AhVec(self, m, vec):\n        \"\"\"\n            :param numpy.array m: Conductivity model\n            :param simpegEM.TDEM.FieldsTDEM vec: Fields object\n            :rtype: simpegEM.TDEM.FieldsTDEM\n            :return: f\n\n            Multiply the matrix \\\\\\(\\\\\\hat{A}\\\\\\) by a fields vector where\n\n            .. math::\n                \\mathbf{\\hat{A}} = \\left[\n                    \\\\begin{array}{cccc}\n                        A & 0 & & \\\\\\\\\n                        B & A & & \\\\\\\\\n                        & \\ddots & \\ddots & \\\\\\\\\n                        & & B & A\n                    \\end{array}\n                \\\\right] \\\\\\\\\n                \\mathbf{A} =\n                \\left[\n                    \\\\begin{array}{cc}\n                        \\\\frac{1}{\\delta t} \\MfMui & \\MfMui\\dcurl \\\\\\\\\n                        \\dcurl^\\\\top \\MfMui & -\\MeSig\n                    \\end{array}\n                \\\\right] \\\\\\\\\n                \\mathbf{B} =\n                \\left[\n                    \\\\begin{array}{cc}\n                        -\\\\frac{1}{\\delta t} \\MfMui & 0 \\\\\\\\\n                        0 & 0\n                    \\end{array}\n                \\\\right] \\\\\\\\\n        \"\"\"\n\n        self.curModel = m\n        f = FieldsTDEM(self.mesh, self.survey)\n        for i in range(1,self.nT+1):\n            dt = self.timeSteps[i-1]\n            b = 1.0/dt*self.MfMui*vec[:,'b',i] + self.MfMui*(self.mesh.edgeCurl*vec[:,'e',i])\n            if i > 1:\n                b = b - 1.0/dt*self.MfMui*vec[:,'b',i-1]\n            f[:,'b',i] = b\n            f[:,'e',i] = self.mesh.edgeCurl.T*(self.MfMui*vec[:,'b',i]) - self.MeSigma*vec[:,'e',i]\n        return f",
  "def _AhtVec(self, m, vec):\n        \"\"\"\n            :param numpy.array m: Conductivity model\n            :param simpegEM.TDEM.FieldsTDEM vec: Fields object\n            :rtype: simpegEM.TDEM.FieldsTDEM\n            :return: f\n\n            Multiply the matrix \\\\\\(\\\\\\hat{A}\\\\\\) by a fields vector where\n\n            .. math::\n                \\mathbf{\\hat{A}}^\\\\top = \\left[\n                    \\\\begin{array}{cccc}\n                        A & B & & \\\\\\\\\n                          & \\ddots & \\ddots & \\\\\\\\\n                          & & A & B \\\\\\\\\n                          & & 0 & A\n                    \\end{array}\n                \\\\right] \\\\\\\\\n                \\mathbf{A} =\n                \\left[\n                    \\\\begin{array}{cc}\n                        \\\\frac{1}{\\delta t} \\MfMui & \\MfMui\\dcurl \\\\\\\\\n                        \\dcurl^\\\\top \\MfMui & -\\MeSig\n                    \\end{array}\n                \\\\right] \\\\\\\\\n                \\mathbf{B} =\n                \\left[\n                    \\\\begin{array}{cc}\n                        -\\\\frac{1}{\\delta t} \\MfMui & 0 \\\\\\\\\n                        0 & 0\n                    \\end{array}\n                \\\\right] \\\\\\\\\n        \"\"\"\n        self.curModel = m\n        f = FieldsTDEM(self.mesh, self.survey)\n        for i in range(self.nT):\n            b = 1.0/self.timeSteps[i]*self.MfMui*vec[:,'b',i+1] + self.MfMui*(self.mesh.edgeCurl*vec[:,'e',i+1])\n            if i < self.nT-1:\n                b = b - 1.0/self.timeSteps[i+1]*self.MfMui*vec[:,'b',i+2]\n            f[:,'b', i+1] = b\n            f[:,'e', i+1] = self.mesh.edgeCurl.T*(self.MfMui*vec[:,'b',i+1]) - self.MeSigma*vec[:,'e',i+1]\n        return f",
  "def AhRHS(tInd, y):\n            rhs = self.MfMui*(self.mesh.edgeCurl*(self.MeSigmaI*p[:,'e',tInd+1]))\n            if 'b' in p:\n                rhs = rhs + p[:,'b',tInd+1]\n            if tInd == 0:\n                return rhs\n            dt = self.timeSteps[tInd]\n            return rhs + 1.0/dt*self.MfMui*y[:,'b',tInd]",
  "def AhtRHS(tInd, y):\n            nSrc, nF = self.survey.nSrc, self.mesh.nF\n            rhs = np.zeros((nF,1) if nSrc == 1 else (nF, nSrc))\n\n            if 'e' in p:\n                rhs += self.MfMui*(self.mesh.edgeCurl*(self.MeSigmaI*p[:,'e',tInd+1]))\n            if 'b' in p:\n                rhs += p[:,'b',tInd+1]\n\n            if tInd == self.nT-1:\n                return rhs\n            dt = self.timeSteps[tInd+1]\n            return rhs + 1.0/dt*self.MfMui*y[:,'b',tInd+2]",
  "def mkvc(x, numDims=1):\n    \"\"\"Creates a vector with the number of dimension specified\n\n    e.g.::\n\n        a = np.array([1, 2, 3])\n\n        mkvc(a, 1).shape\n            > (3, )\n\n        mkvc(a, 2).shape\n            > (3, 1)\n\n        mkvc(a, 3).shape\n            > (3, 1, 1)\n\n    \"\"\"\n    if type(x) == np.matrix:\n        x = np.array(x)\n\n    if hasattr(x, 'tovec'):\n        x = x.tovec()\n\n    assert isinstance(x, np.ndarray), \"Vector must be a numpy array\"\n\n    if numDims == 1:\n        return x.flatten(order='F')\n    elif numDims == 2:\n        return x.flatten(order='F')[:, np.newaxis]\n    elif numDims == 3:\n        return x.flatten(order='F')[:, np.newaxis, np.newaxis]",
  "def sdiag(h):\n    \"\"\"Sparse diagonal matrix\"\"\"\n    return sp.spdiags(mkvc(h), 0, h.size, h.size, format=\"csr\")",
  "def sdInv(M):\n    \"Inverse of a sparse diagonal matrix\"\n    return sdiag(1/M.diagonal())",
  "def speye(n):\n    \"\"\"Sparse identity\"\"\"\n    return sp.identity(n, format=\"csr\")",
  "def kron3(A, B, C):\n    \"\"\"Three kron prods\"\"\"\n    return sp.kron(sp.kron(A, B), C, format=\"csr\")",
  "def spzeros(n1, n2):\n    \"\"\"spzeros\"\"\"\n    return sp.csr_matrix((n1, n2))",
  "def ddx(n):\n    \"\"\"Define 1D derivatives, inner, this means we go from n+1 to n\"\"\"\n    return sp.spdiags((np.ones((n+1, 1))*[-1, 1]).T, [0, 1], n, n+1, format=\"csr\")",
  "def av(n):\n    \"\"\"Define 1D averaging operator from nodes to cell-centers.\"\"\"\n    return sp.spdiags((0.5*np.ones((n+1, 1))*[1, 1]).T, [0, 1], n, n+1, format=\"csr\")",
  "def avExtrap(n):\n    \"\"\"Define 1D averaging operator from cell-centers to nodes.\"\"\"\n    Av = sp.spdiags((0.5*np.ones((n, 1))*[1, 1]).T, [-1, 0], n+1, n, format=\"csr\") + sp.csr_matrix(([0.5,0.5],([0,n],[0,n-1])),shape=(n+1,n))\n    return Av",
  "def ndgrid(*args, **kwargs):\n    \"\"\"\n    Form tensorial grid for 1, 2, or 3 dimensions.\n\n    Returns as column vectors by default.\n\n    To return as matrix input:\n\n        ndgrid(..., vector=False)\n\n    The inputs can be a list or separate arguments.\n\n    e.g.::\n\n        a = np.array([1, 2, 3])\n        b = np.array([1, 2])\n\n        XY = ndgrid(a, b)\n            > [[1 1]\n               [2 1]\n               [3 1]\n               [1 2]\n               [2 2]\n               [3 2]]\n\n        X, Y = ndgrid(a, b, vector=False)\n            > X = [[1 1]\n                   [2 2]\n                   [3 3]]\n            > Y = [[1 2]\n                   [1 2]\n                   [1 2]]\n\n    \"\"\"\n\n    # Read the keyword arguments, and only accept a vector=True/False\n    vector = kwargs.pop('vector', True)\n    assert type(vector) == bool, \"'vector' keyword must be a bool\"\n    assert len(kwargs) == 0, \"Only 'vector' keyword accepted\"\n\n    # you can either pass a list [x1, x2, x3] or each seperately\n    if type(args[0]) == list:\n        xin = args[0]\n    else:\n        xin = args\n\n    # Each vector needs to be a numpy array\n    assert np.all([isinstance(x, np.ndarray) for x in xin]), \"All vectors must be numpy arrays.\"\n\n    if len(xin) == 1:\n        return xin[0]\n    elif len(xin) == 2:\n        XY = np.broadcast_arrays(mkvc(xin[1], 1), mkvc(xin[0], 2))\n        if vector:\n            X2, X1 = [mkvc(x) for x in XY]\n            return np.c_[X1, X2]\n        else:\n            return XY[1], XY[0]\n    elif len(xin) == 3:\n        XYZ = np.broadcast_arrays(mkvc(xin[2], 1), mkvc(xin[1], 2), mkvc(xin[0], 3))\n        if vector:\n            X3, X2, X1 = [mkvc(x) for x in XYZ]\n            return np.c_[X1, X2, X3]\n        else:\n            return XYZ[2], XYZ[1], XYZ[0]",
  "def ind2sub(shape, inds):\n    \"\"\"From the given shape, returns the subscripts of the given index\"\"\"\n    if type(inds) is not np.ndarray:\n        inds = np.array(inds)\n    assert len(inds.shape) == 1, 'Indexing must be done as a 1D row vector, e.g. [3,6,6,...]'\n    return np.unravel_index(inds, shape, order='F')",
  "def sub2ind(shape, subs):\n    \"\"\"From the given shape, returns the index of the given subscript\"\"\"\n    if len(shape) == 1:\n        return subs\n    if type(subs) is not np.ndarray:\n        subs = np.array(subs)\n    if len(subs.shape) == 1:\n        subs = subs[np.newaxis,:]\n    assert subs.shape[1] == len(shape), 'Indexing must be done as a column vectors. e.g. [[3,6],[6,2],...]'\n    inds = np.ravel_multi_index(subs.T, shape, order='F')\n    return mkvc(inds)",
  "def getSubArray(A, ind):\n    \"\"\"subArray\"\"\"\n    assert type(ind) == list, \"ind must be a list of vectors\"\n    assert len(A.shape) == len(ind), \"ind must have the same length as the dimension of A\"\n\n    if len(A.shape) == 2:\n        return A[ind[0], :][:, ind[1]]\n    elif len(A.shape) == 3:\n        return A[ind[0], :, :][:, ind[1], :][:, :, ind[2]]\n    else:\n        raise Exception(\"getSubArray does not support dimension asked.\")",
  "def inv3X3BlockDiagonal(a11, a12, a13, a21, a22, a23, a31, a32, a33, returnMatrix=True):\n    \"\"\" B = inv3X3BlockDiagonal(a11, a12, a13, a21, a22, a23, a31, a32, a33)\n\n    inverts a stack of 3x3 matrices\n\n    Input:\n     A   - a11, a12, a13, a21, a22, a23, a31, a32, a33\n\n    Output:\n     B   - inverse\n     \"\"\"\n\n    a11 = mkvc(a11)\n    a12 = mkvc(a12)\n    a13 = mkvc(a13)\n    a21 = mkvc(a21)\n    a22 = mkvc(a22)\n    a23 = mkvc(a23)\n    a31 = mkvc(a31)\n    a32 = mkvc(a32)\n    a33 = mkvc(a33)\n\n    detA = a31*a12*a23 - a31*a13*a22 - a21*a12*a33 + a21*a13*a32 + a11*a22*a33 - a11*a23*a32\n\n    b11 = +(a22*a33 - a23*a32)/detA\n    b12 = -(a12*a33 - a13*a32)/detA\n    b13 = +(a12*a23 - a13*a22)/detA\n\n    b21 = +(a31*a23 - a21*a33)/detA\n    b22 = -(a31*a13 - a11*a33)/detA\n    b23 = +(a21*a13 - a11*a23)/detA\n\n    b31 = -(a31*a22 - a21*a32)/detA\n    b32 = +(a31*a12 - a11*a32)/detA\n    b33 = -(a21*a12 - a11*a22)/detA\n\n    if not returnMatrix:\n        return b11, b12, b13, b21, b22, b23, b31, b32, b33\n\n    return sp.vstack((sp.hstack((sdiag(b11), sdiag(b12),  sdiag(b13))),\n                      sp.hstack((sdiag(b21), sdiag(b22),  sdiag(b23))),\n                      sp.hstack((sdiag(b31), sdiag(b32),  sdiag(b33)))))",
  "def inv2X2BlockDiagonal(a11, a12, a21, a22, returnMatrix=True):\n    \"\"\" B = inv2X2BlockDiagonal(a11, a12, a21, a22)\n\n    Inverts a stack of 2x2 matrices by using the inversion formula\n\n    inv(A) = (1/det(A)) * cof(A)^T\n\n    Input:\n    A   - a11, a12, a21, a22\n\n    Output:\n    B   - inverse\n    \"\"\"\n\n    a11 = mkvc(a11)\n    a12 = mkvc(a12)\n    a21 = mkvc(a21)\n    a22 = mkvc(a22)\n\n    # compute inverse of the determinant.\n    detAinv = 1./(a11*a22 - a21*a12)\n\n    b11 = +detAinv*a22\n    b12 = -detAinv*a12\n    b21 = -detAinv*a21\n    b22 = +detAinv*a11\n\n    if not returnMatrix:\n        return b11, b12, b21, b22\n\n    return sp.vstack((sp.hstack((sdiag(b11), sdiag(b12))),\n                      sp.hstack((sdiag(b21), sdiag(b22)))))",
  "class TensorType(object):\n    def __init__(self, M, tensor):\n        if tensor is None:  # default is ones\n            self._tt  = -1\n            self._tts = 'none'\n        elif isScalar(tensor):\n            self._tt  = 0\n            self._tts = 'scalar'\n        elif tensor.size == M.nC:\n            self._tt  = 1\n            self._tts = 'isotropic'\n        elif ((M.dim == 2 and tensor.size == M.nC*2) or\n            (M.dim == 3 and tensor.size == M.nC*3)):\n            self._tt  = 2\n            self._tts = 'anisotropic'\n        elif ((M.dim == 2 and tensor.size == M.nC*3) or\n            (M.dim == 3 and tensor.size == M.nC*6)):\n            self._tt  = 3\n            self._tts = 'tensor'\n        else:\n            raise Exception('Unexpected shape of tensor')\n    def __str__(self):\n        return 'TensorType[%i]: %s' % (self._tt, self._tts)\n    def __eq__(self, v): return self._tt == v\n    def __le__(self, v): return self._tt <= v\n    def __ge__(self, v): return self._tt >= v\n    def __lt__(self, v): return self._tt < v\n    def __gt__(self, v): return self._tt > v",
  "def makePropertyTensor(M, tensor):\n    if tensor is None:  # default is ones\n        tensor = np.ones(M.nC)\n\n    if isScalar(tensor):\n        tensor = tensor * np.ones(M.nC)\n\n    propType = TensorType(M, tensor)\n    if propType == 1: # Isotropic!\n        Sigma = sp.kron(sp.identity(M.dim), sdiag(mkvc(tensor)))\n    elif propType == 2: # Diagonal tensor\n        Sigma = sdiag(mkvc(tensor))\n    elif M.dim == 2 and tensor.size == M.nC*3:  # Fully anisotropic, 2D\n        tensor = tensor.reshape((M.nC,3), order='F')\n        row1 = sp.hstack((sdiag(tensor[:, 0]), sdiag(tensor[:, 2])))\n        row2 = sp.hstack((sdiag(tensor[:, 2]), sdiag(tensor[:, 1])))\n        Sigma = sp.vstack((row1, row2))\n    elif M.dim == 3 and tensor.size == M.nC*6:  # Fully anisotropic, 3D\n        tensor = tensor.reshape((M.nC,6), order='F')\n        row1 = sp.hstack((sdiag(tensor[:, 0]), sdiag(tensor[:, 3]), sdiag(tensor[:, 4])))\n        row2 = sp.hstack((sdiag(tensor[:, 3]), sdiag(tensor[:, 1]), sdiag(tensor[:, 5])))\n        row3 = sp.hstack((sdiag(tensor[:, 4]), sdiag(tensor[:, 5]), sdiag(tensor[:, 2])))\n        Sigma = sp.vstack((row1, row2, row3))\n    else:\n        raise Exception('Unexpected shape of tensor')\n\n    return Sigma",
  "def invPropertyTensor(M, tensor, returnMatrix=False):\n\n    propType = TensorType(M, tensor)\n\n    if isScalar(tensor):\n        T = 1./tensor\n    elif propType < 3:  # Isotropic or Diagonal\n        T = 1./mkvc(tensor)  # ensure it is a vector.\n    elif M.dim == 2 and tensor.size == M.nC*3:  # Fully anisotropic, 2D\n        tensor = tensor.reshape((M.nC,3), order='F')\n        B = inv2X2BlockDiagonal(tensor[:,0], tensor[:,2],\n                                tensor[:,2], tensor[:,1],\n                                returnMatrix=False)\n        b11, b12, b21, b22 = B\n        T = np.r_[b11, b22, b12]\n    elif M.dim == 3 and tensor.size == M.nC*6:  # Fully anisotropic, 3D\n        tensor = tensor.reshape((M.nC,6), order='F')\n        B = inv3X3BlockDiagonal(tensor[:,0], tensor[:,3], tensor[:,4],\n                                tensor[:,3], tensor[:,1], tensor[:,5],\n                                tensor[:,4], tensor[:,5], tensor[:,2],\n                                returnMatrix=False)\n        b11, b12, b13, b21, b22, b23, b31, b32, b33 = B\n        T = np.r_[b11, b22, b33, b12, b13, b23]\n    else:\n        raise Exception('Unexpected shape of tensor')\n\n    if returnMatrix:\n        return makePropertyTensor(M, T)\n\n    return T",
  "def diagEst(matFun, n, k=None, approach='Probing'):\n    \"\"\"\n    Estimate the diagonal of a matrix, A. Note that the matrix may be a function which returns A times a vector.\n\n    Three different approaches have been implemented,\n        1. Probing : uses cyclic permutations of vectors with ones and zeros (default)\n        2. Ones : random +/- 1 entries\n        3. Random : random vectors\n\n    :param lambda (numpy.array) matFun: matrix to estimate the diagonal of\n    :param int64 n: size of the vector that should be used to compute matFun(v)\n    :param int64 k: number of vectors to be used to estimate the diagonal\n    :param str approach: approach to be used for getting vectors\n    :rtype: numpy.array\n    :return: est_diag(A)\n\n    Based on Saad http://www-users.cs.umn.edu/~saad/PDF/umsi-2005-082.pdf, and http://www.cita.utoronto.ca/~niels/diagonal.pdf\n    \"\"\"\n\n    if type(matFun).__name__=='ndarray':\n        A = matFun\n        matFun = lambda v: A.dot(v)\n\n    if k is None:\n        k = np.floor(n/10.)\n\n    if approach =='Ones':\n        def getv(n,i=None):\n            v = np.random.randn(n)\n            v[v<0]  = -1.\n            v[v>=0] = 1.\n            return v\n\n    elif approach == 'Random':\n        def getv(n,i=None):\n            return np.random.randn(n)\n\n    else: #if approach == 'Probing':\n        def getv(n,i):\n            v = np.zeros(n)\n            v[i:n:k] = 1.\n            return v\n\n    Mv = np.zeros(n)\n    vv = np.zeros(n)\n\n    for i in range(0,k):\n        vk = getv(n,i)\n        Mv += matFun(vk)*vk\n        vv += vk*vk\n\n    d   = Mv/vv\n\n    return d",
  "class Zero(object):\n    def __add__(self, v):return v\n    def __radd__(self, v):return v\n    def __sub__(self, v):return -v\n    def __rsub__(self, v):return v\n    def __mul__(self, v):return self\n    def __rmul__(self, v):return self\n    def __div__(self, v): return self\n    def __truediv__(self, v): return self\n    def __rdiv__(self, v): raise ZeroDivisionError('Cannot divide by zero.')\n    def __pos__(self):return self\n    def __neg__(self):return self\n    def __lt__(self, v):return 0 < v\n    def __le__(self, v):return 0 <= v\n    def __eq__(self, v):return v == 0\n    def __ne__(self, v):return not (0 == v)\n    def __ge__(self, v):return 0 >= v\n    def __gt__(self, v):return 0 > v",
  "class Identity(object):\n    _positive = True\n    def __init__(self, positive=True):\n        self._positive = positive is True\n\n    def __pos__(self):return self\n    def __neg__(self):return Identity(not self._positive)\n\n    def __add__(self, v):\n        if sp.issparse(v):\n            return v + speye(v.shape[0]) if self._positive else v - speye(v.shape[0])\n        return v + 1 if self._positive else v - 1\n    def __radd__(self, v):\n        return self.__add__(v)\n\n    def __sub__(self, v): return self+-v\n    def __rsub__(self, v):return -self+v\n\n    def __mul__(self, v): return v if self._positive else -v\n    def __rmul__(self, v):return v if self._positive else -v\n\n    def __div__(self, v):\n        if sp.issparse(v): raise NotImplementedError('Sparse arrays not divisibile.')\n        return 1/v if self._positive else -1/v\n    def __truediv__(self, v):\n        if sp.issparse(v): raise NotImplementedError('Sparse arrays not divisibile.')\n        return 1.0/v if self._positive else -1.0/v\n    def __rdiv__(self, v):\n        return v if self._positive else -v\n\n    def __lt__(self, v):return 1 <  v if self._positive else -1 <  v\n    def __le__(self, v):return 1 <= v if self._positive else -1 <= v\n    def __eq__(self, v):return v == 1 if self._positive else v == -1\n    def __ne__(self, v):return (not (1 == v))if self._positive else (not (-1 == v))\n    def __ge__(self, v):return 1 >= v if self._positive else -1 >= v\n    def __gt__(self, v):return 1 >  v if self._positive else -1 >  v",
  "def __init__(self, M, tensor):\n        if tensor is None:  # default is ones\n            self._tt  = -1\n            self._tts = 'none'\n        elif isScalar(tensor):\n            self._tt  = 0\n            self._tts = 'scalar'\n        elif tensor.size == M.nC:\n            self._tt  = 1\n            self._tts = 'isotropic'\n        elif ((M.dim == 2 and tensor.size == M.nC*2) or\n            (M.dim == 3 and tensor.size == M.nC*3)):\n            self._tt  = 2\n            self._tts = 'anisotropic'\n        elif ((M.dim == 2 and tensor.size == M.nC*3) or\n            (M.dim == 3 and tensor.size == M.nC*6)):\n            self._tt  = 3\n            self._tts = 'tensor'\n        else:\n            raise Exception('Unexpected shape of tensor')",
  "def __str__(self):\n        return 'TensorType[%i]: %s' % (self._tt, self._tts)",
  "def __eq__(self, v): return self._tt == v",
  "def __le__(self, v): return self._tt <= v",
  "def __ge__(self, v): return self._tt >= v",
  "def __lt__(self, v): return self._tt < v",
  "def __gt__(self, v): return self._tt > v",
  "def __add__(self, v):return v",
  "def __radd__(self, v):return v",
  "def __sub__(self, v):return -v",
  "def __rsub__(self, v):return v",
  "def __mul__(self, v):return self",
  "def __rmul__(self, v):return self",
  "def __div__(self, v): return self",
  "def __truediv__(self, v): return self",
  "def __rdiv__(self, v): raise ZeroDivisionError('Cannot divide by zero.')",
  "def __pos__(self):return self",
  "def __neg__(self):return self",
  "def __lt__(self, v):return 0 < v",
  "def __le__(self, v):return 0 <= v",
  "def __eq__(self, v):return v == 0",
  "def __ne__(self, v):return not (0 == v)",
  "def __ge__(self, v):return 0 >= v",
  "def __gt__(self, v):return 0 > v",
  "def __init__(self, positive=True):\n        self._positive = positive is True",
  "def __pos__(self):return self",
  "def __neg__(self):return Identity(not self._positive)",
  "def __add__(self, v):\n        if sp.issparse(v):\n            return v + speye(v.shape[0]) if self._positive else v - speye(v.shape[0])\n        return v + 1 if self._positive else v - 1",
  "def __radd__(self, v):\n        return self.__add__(v)",
  "def __sub__(self, v): return self+-v",
  "def __rsub__(self, v):return -self+v",
  "def __mul__(self, v): return v if self._positive else -v",
  "def __rmul__(self, v):return v if self._positive else -v",
  "def __div__(self, v):\n        if sp.issparse(v): raise NotImplementedError('Sparse arrays not divisibile.')\n        return 1/v if self._positive else -1/v",
  "def __truediv__(self, v):\n        if sp.issparse(v): raise NotImplementedError('Sparse arrays not divisibile.')\n        return 1.0/v if self._positive else -1.0/v",
  "def __rdiv__(self, v):\n        return v if self._positive else -v",
  "def __lt__(self, v):return 1 <  v if self._positive else -1 <  v",
  "def __le__(self, v):return 1 <= v if self._positive else -1 <= v",
  "def __eq__(self, v):return v == 1 if self._positive else v == -1",
  "def __ne__(self, v):return (not (1 == v))if self._positive else (not (-1 == v))",
  "def __ge__(self, v):return 1 >= v if self._positive else -1 >= v",
  "def __gt__(self, v):return 1 >  v if self._positive else -1 >  v",
  "def getv(n,i=None):\n            v = np.random.randn(n)\n            v[v<0]  = -1.\n            v[v>=0] = 1.\n            return v",
  "def getv(n,i=None):\n            return np.random.randn(n)",
  "def getv(n,i):\n            v = np.zeros(n)\n            v[i:n:k] = 1.\n            return v",
  "def rotationMatrixFromNormals(v0,v1,tol=1e-20):\n    \"\"\"\n        Performs the minimum number of rotations to define a rotation from the direction indicated by the vector n0 to the direction indicated by n1.\n        The axis of rotation is n0 x n1\n        https://en.wikipedia.org/wiki/Rodrigues%27_rotation_formula\n\n        :param numpy.array v0: vector of length 3\n        :param numpy.array v1: vector of length 3\n        :param tol = 1e-20: tolerance. If the norm of the cross product between the two vectors is below this, no rotation is performed\n        :rtype: numpy.array, 3x3\n        :return: rotation matrix which rotates the frame so that n0 is aligned with n1\n\n    \"\"\"\n\n    # ensure both n0, n1 are vectors of length 1\n    assert len(v0) == 3, \"Length of n0 should be 3\"\n    assert len(v1) == 3, \"Length of n1 should be 3\"\n\n    # ensure both are true normals\n    n0 = v0*1./np.linalg.norm(v0)\n    n1 = v1*1./np.linalg.norm(v1)\n\n    n0dotn1 = n0.dot(n1) \n\n    # define the rotation axis, which is the cross product of the two vectors\n    rotAx = np.cross(n0,n1)\n\n    if np.linalg.norm(rotAx) < tol:\n        return np.eye(3,dtype=float)\n\n    rotAx *= 1./np.linalg.norm(rotAx)\n\n    cosT = n0dotn1/(np.linalg.norm(n0)*np.linalg.norm(n1))\n    sinT = np.sqrt(1.-n0dotn1**2)\n\n    ux = np.array([[0., -rotAx[2], rotAx[1]], [rotAx[2], 0., -rotAx[0]], [-rotAx[1], rotAx[0], 0.]],dtype=float)\n\n    return np.eye(3,dtype=float) + sinT*ux + (1.-cosT)*(ux.dot(ux))",
  "def rotatePointsFromNormals(XYZ,n0,n1,x0=np.r_[0.,0.,0.]):\n    \"\"\"\n        rotates a grid so that the vector n0 is aligned with the vector n1\n\n        :param numpy.array n0: vector of length 3, should have norm 1\n        :param numpy.array n1: vector of length 3, should have norm 1\n        :param numpy.array x0: vector of length 3, point about which we perform the rotation \n        :rtype: numpy.array, 3x3\n        :return: rotation matrix which rotates the frame so that n0 is aligned with n1\n    \"\"\"\n\n    R = rotationMatrixFromNormals(n0, n1)\n\n    assert XYZ.shape[1] == 3, \"Grid XYZ should be 3 wide\"\n    assert len(x0) == 3, \"x0 should have length 3\"\n\n    X0 = np.ones([XYZ.shape[0],1])*mkvc(x0)\n\n    return (XYZ - X0).dot(R.T) + X0",
  "def anim_to_html(anim):\n    if not hasattr(anim, '_encoded_video'):\n        with NamedTemporaryFile(suffix='.mp4') as f:\n            anim.save(f.name, fps=20, extra_args=['-vcodec', 'libx264', '-pix_fmt', 'yuv420p'])\n            video = open(f.name, \"rb\").read()\n        anim._encoded_video = video.encode(\"base64\")\n\n    return VIDEO_TAG.format(anim._encoded_video)",
  "def display_animation(anim):\n    plt.close(anim._fig)\n    return anim_to_html(anim)",
  "def exampleLrmGrid(nC, exType):\n    assert type(nC) == list, \"nC must be a list containing the number of nodes\"\n    assert len(nC) == 2 or len(nC) == 3, \"nC must either two or three dimensions\"\n    exType = exType.lower()\n\n    possibleTypes = ['rect', 'rotate']\n    assert exType in possibleTypes, \"Not a possible example type.\"\n\n    if exType == 'rect':\n        return list(ndgrid([np.cumsum(np.r_[0, np.ones(nx)/nx]) for nx in nC], vector=False))\n    elif exType == 'rotate':\n        if len(nC) == 2:\n            X, Y = ndgrid([np.cumsum(np.r_[0, np.ones(nx)/nx]) for nx in nC], vector=False)\n            amt = 0.5-np.sqrt((X - 0.5)**2 + (Y - 0.5)**2)\n            amt[amt < 0] = 0\n            return [X + (-(Y - 0.5))*amt, Y + (+(X - 0.5))*amt]\n        elif len(nC) == 3:\n            X, Y, Z = ndgrid([np.cumsum(np.r_[0, np.ones(nx)/nx]) for nx in nC], vector=False)\n            amt = 0.5-np.sqrt((X - 0.5)**2 + (Y - 0.5)**2 + (Z - 0.5)**2)\n            amt[amt < 0] = 0\n            return [X + (-(Y - 0.5))*amt, Y + (-(Z - 0.5))*amt, Z + (-(X - 0.5))*amt]",
  "def meshTensor(value):\n    \"\"\"\n        **meshTensor** takes a list of numbers and tuples that have the form::\n\n            mT = [ float, (cellSize, numCell), (cellSize, numCell, factor) ]\n\n        For example, a time domain mesh code needs\n        many time steps at one time::\n\n            [(1e-5, 30), (1e-4, 30), 1e-3]\n\n        Means take 30 steps at 1e-5 and then 30 more at 1e-4,\n        and then one step of 1e-3.\n\n        Tensor meshes can also be created by increase factors::\n\n            [(10.0, 5, -1.3), (10.0, 50), (10.0, 5, 1.3)]\n\n        When there is a third number in the tuple, it\n        refers to the increase factor, if this number\n        is negative this section of the tensor is flipped right-to-left.\n\n        .. plot::\n\n            from SimPEG import Mesh\n            tx = [(10.0,10,-1.3),(10.0,40),(10.0,10,1.3)]\n            ty = [(10.0,10,-1.3),(10.0,40)]\n            M = Mesh.TensorMesh([tx, ty])\n            M.plotGrid(showIt=True)\n\n    \"\"\"\n    if type(value) is not list:\n        raise Exception('meshTensor must be a list of scalars and tuples.')\n\n    proposed = []\n    for v in value:\n        if isScalar(v):\n            proposed += [float(v)]\n        elif type(v) is tuple and len(v) == 2:\n            proposed += [float(v[0])]*int(v[1])\n        elif type(v) is tuple and len(v) == 3:\n            start = float(v[0])\n            num = int(v[1])\n            factor = float(v[2])\n            pad = ((np.ones(num)*np.abs(factor))**(np.arange(num)+1))*start\n            if factor < 0: pad = pad[::-1]\n            proposed += pad.tolist()\n        else:\n            raise Exception('meshTensor must contain only scalars and len(2) or len(3) tuples.')\n\n    return np.array(proposed)",
  "def closestPoints(mesh, pts, gridLoc='CC'):\n    \"\"\"\n        Move a list of points to the closest points on a grid.\n\n        :param simpeg.Mesh.BaseMesh mesh: The mesh\n        :param numpy.ndarray pts: Points to move\n        :param string gridLoc: ['CC', 'N', 'Fx', 'Fy', 'Fz', 'Ex', 'Ex', 'Ey', 'Ez']\n        :rtype: numpy.ndarray\n        :return: nodeInds\n    \"\"\"\n\n    pts = asArray_N_x_Dim(pts, mesh.dim)\n    grid = getattr(mesh, 'grid' + gridLoc)\n    nodeInds = np.empty(pts.shape[0], dtype=int)\n\n    for i, pt in enumerate(pts):\n        if mesh.dim == 1:\n            nodeInds[i] = ((pt - grid)**2).argmin()\n        else:\n            nodeInds[i] = ((np.tile(pt, (grid.shape[0],1)) - grid)**2).sum(axis=1).argmin()\n\n    return nodeInds",
  "def readUBCTensorMesh(fileName):\n    \"\"\"\n        Read UBC GIF 3DTensor mesh and generate 3D Tensor mesh in simpegTD\n\n        Input:\n        :param fileName, path to the UBC GIF mesh file\n\n        Output:\n        :param SimPEG TensorMesh object\n        :return\n    \"\"\"\n\n    # Interal function to read cell size lines for the UBC mesh files.\n    def readCellLine(line):\n        for seg in line.split():\n            if '*' in seg:\n                st = seg\n                sp = seg.split('*')\n                re = np.array(sp[0],dtype=int)*(' ' + sp[1])\n                line = line.replace(st,re.strip())\n        return np.array(line.split(),dtype=float)\n\n    # Read the file as line strings, remove lines with comment = !\n    msh = np.genfromtxt(fileName,delimiter='\\n',dtype=np.str,comments='!')\n\n    # Fist line is the size of the model\n    sizeM = np.array(msh[0].split(),dtype=float)\n    # Second line is the South-West-Top corner coordinates.\n    x0 = np.array(msh[1].split(),dtype=float)\n    # Read the cell sizes\n    h1 = readCellLine(msh[2])\n    h2 = readCellLine(msh[3])\n    h3temp = readCellLine(msh[4])\n    h3 = h3temp[::-1] # Invert the indexing of the vector to start from the bottom.\n    # Adjust the reference point to the bottom south west corner\n    x0[2] = x0[2] - np.sum(h3)\n    # Make the mesh\n    from SimPEG import Mesh\n    tensMsh = Mesh.TensorMesh([h1,h2,h3],x0)\n    return tensMsh",
  "def readUBCTensorModel(fileName, mesh):\n    \"\"\"\n        Read UBC 3DTensor mesh model and generate 3D Tensor mesh model in simpeg\n\n        Input:\n        :param fileName, path to the UBC GIF mesh file to read\n        :param mesh, TensorMesh object, mesh that coresponds to the model\n\n        Output:\n        :return numpy array, model with TensorMesh ordered\n    \"\"\"\n    f = open(fileName, 'r')\n    model = np.array(map(float, f.readlines()))\n    f.close()\n    model = np.reshape(model, (mesh.nCz, mesh.nCx, mesh.nCy), order = 'F')\n    model = model[::-1,:,:]\n    model = np.transpose(model, (1, 2, 0))\n    model = mkvc(model)\n\n    return model",
  "def writeUBCTensorMesh(fileName, mesh):\n    \"\"\"\n        Writes a SimPEG TensorMesh to a UBC-GIF format mesh file.\n\n        :param str fileName: File to write to\n        :param simpeg.Mesh.TensorMesh mesh: The mesh\n\n    \"\"\"\n    assert mesh.dim == 3\n    s = ''\n    s += '%i %i %i\\n' %tuple(mesh.vnC)\n    origin = mesh.x0 + np.array([0,0,mesh.hz.sum()]) # Have to it in the same operation or use mesh.x0.copy(), otherwise the mesh.x0 is updated.\n    origin.dtype = float\n\n    s += '%.2f %.2f %.2f\\n' %tuple(origin)\n    s += ('%.2f '*mesh.nCx+'\\n')%tuple(mesh.hx)\n    s += ('%.2f '*mesh.nCy+'\\n')%tuple(mesh.hy)\n    s += ('%.2f '*mesh.nCz+'\\n')%tuple(mesh.hz[::-1])\n    f = open(fileName, 'w')\n    f.write(s)\n    f.close()",
  "def writeUBCTensorModel(fileName, mesh, model):\n    \"\"\"\n        Writes a model associated with a SimPEG TensorMesh\n        to a UBC-GIF format model file.\n\n        :param str fileName: File to write to\n        :param simpeg.Mesh.TensorMesh mesh: The mesh\n        :param numpy.ndarray model: The model\n    \"\"\"\n\n    # Reshape model to a matrix\n    modelMat = mesh.r(model,'CC','CC','M')\n    # Transpose the axes\n    modelMatT = modelMat.transpose((2,0,1))\n    # Flip z to positive down\n    modelMatTR = mkvc(modelMatT[::-1,:,:])\n\n    np.savetxt(fileName, modelMatTR.ravel())",
  "def readVTRFile(fileName):\n    \"\"\"\n        Read VTK Rectilinear (vtr xml file) and return SimPEG Tensor mesh and model\n\n        Input:\n        :param vtrFileName, path to the vtr model file to write to\n\n        Output:\n        :return SimPEG TensorMesh object\n        :return SimPEG model dictionary\n\n    \"\"\"\n    # Import\n    from vtk import vtkXMLRectilinearGridReader as vtrFileReader\n    from vtk.util.numpy_support import vtk_to_numpy\n\n    # Read the file\n    vtrReader = vtrFileReader()\n    vtrReader.SetFileName(fileName)\n    vtrReader.Update()\n    vtrGrid = vtrReader.GetOutput()\n    # Sort information\n    hx = np.abs(np.diff(vtk_to_numpy(vtrGrid.GetXCoordinates())))\n    xR = vtk_to_numpy(vtrGrid.GetXCoordinates())[0]\n    hy = np.abs(np.diff(vtk_to_numpy(vtrGrid.GetYCoordinates())))\n    yR = vtk_to_numpy(vtrGrid.GetYCoordinates())[0]\n    zD = np.diff(vtk_to_numpy(vtrGrid.GetZCoordinates()))\n    # Check the direction of hz\n    if np.all(zD < 0):\n        hz = np.abs(zD[::-1])\n        zR = vtk_to_numpy(vtrGrid.GetZCoordinates())[-1]\n    else:\n        hz = np.abs(zD)\n        zR = vtk_to_numpy(vtrGrid.GetZCoordinates())[0]\n    x0 = np.array([xR,yR,zR])\n\n    # Make the SimPEG object\n    from SimPEG import Mesh\n    tensMsh = Mesh.TensorMesh([hx,hy,hz],x0)\n\n    # Grap the models\n    modelDict = {}\n    for i in np.arange(vtrGrid.GetCellData().GetNumberOfArrays()):\n        modelName = vtrGrid.GetCellData().GetArrayName(i)\n        if np.all(zD < 0):\n            modFlip = vtk_to_numpy(vtrGrid.GetCellData().GetArray(i))\n            tM = tensMsh.r(modFlip,'CC','CC','M')\n            modArr = tensMsh.r(tM[:,:,::-1],'CC','CC','V')\n        else:\n            modArr = vtk_to_numpy(vtrGrid.GetCellData().GetArray(i))\n        modelDict[modelName] = modArr\n\n    # Return the data\n    return tensMsh, modelDict",
  "def writeVTRFile(fileName,mesh,model=None):\n    \"\"\"\n    Makes and saves a VTK rectilinear file (vtr) for a simpeg Tensor mesh and model.\n\n    Input:\n    :param str, path to the output vtk file\n    :param mesh, SimPEG TensorMesh object - mesh to be transfer to VTK\n    :param model, dictionary of numpy.array - Name('s) and array('s). Match number of cells\n\n    \"\"\"\n    # Import\n    from vtk import vtkRectilinearGrid as rectGrid, vtkXMLRectilinearGridWriter as rectWriter\n    from vtk.util.numpy_support import numpy_to_vtk\n\n    # Deal with dimensionalities\n    if mesh.dim >= 1:\n        vX = mesh.vectorNx\n        xD = mesh.nNx\n        yD,zD = 1,1\n        vY, vZ = np.array([0,0])\n    if mesh.dim >= 2:\n        vY = mesh.vectorNy\n        yD = mesh.nNy\n    if mesh.dim == 3:\n        vZ = mesh.vectorNz\n        zD = mesh.nNz\n    # Use rectilinear VTK grid.\n    # Assign the spatial information.\n    vtkObj = rectGrid()\n    vtkObj.SetDimensions(xD,yD,zD)\n    vtkObj.SetXCoordinates(numpy_to_vtk(vX,deep=1))\n    vtkObj.SetYCoordinates(numpy_to_vtk(vY,deep=1))\n    vtkObj.SetZCoordinates(numpy_to_vtk(vZ,deep=1))\n\n    # Assign the model('s) to the object\n    for item in model.iteritems():\n        # Convert numpy array\n        vtkDoubleArr = numpy_to_vtk(item[1],deep=1)\n        vtkDoubleArr.SetName(item[0])\n        vtkObj.GetCellData().AddArray(vtkDoubleArr)\n    # Set the active scalar\n    vtkObj.GetCellData().SetActiveScalars(model.keys()[0])\n    vtkObj.Update()\n\n\n    # Check the extension of the fileName\n    ext = os.path.splitext(fileName)[1]\n    if ext is '':\n        fileName = fileName + '.vtr'\n    elif ext not in '.vtr':\n        raise IOError('{:s} is an incorrect extension, has to be .vtr')\n    # Write the file.\n    vtrWriteFilter = rectWriter()\n    vtrWriteFilter.SetInput(vtkObj)\n    vtrWriteFilter.SetFileName(fileName)\n    vtrWriteFilter.Update()",
  "def ExtractCoreMesh(xyzlim, mesh, meshType='tensor'):\n    \"\"\"\n        Extracts Core Mesh from Global mesh\n        xyzlim: 2D array [ndim x 2]\n        mesh: SimPEG mesh\n        This function ouputs:\n            - actind: corresponding boolean index from global to core\n            - meshcore: core SimPEG mesh\n        Warning: 1D and 2D has not been tested\n    \"\"\"\n    from SimPEG import Mesh\n    if mesh.dim ==1:\n        xyzlim = xyzlim.flatten()\n        xmin, xmax = xyzlim[0], xyzlim[1]\n\n        xind = np.logical_and(mesh.vectorCCx>xmin, mesh.vectorCCx<xmax)\n\n        xc = mesh.vectorCCx[xind]\n\n        hx = mesh.hx[xind]\n\n        x0 = [xc[0]-hx[0]*0.5, yc[0]-hy[0]*0.5]\n\n        meshCore = Mesh.TensorMesh([hx, hy] ,x0=x0)\n\n        actind = (mesh.gridCC[:,0]>xmin) & (mesh.gridCC[:,0]<xmax)\n\n    elif mesh.dim ==2:\n        xmin, xmax = xyzlim[0,0], xyzlim[0,1]\n        ymin, ymax = xyzlim[1,0], xyzlim[1,1]\n\n        yind = np.logical_and(mesh.vectorCCy>ymin, mesh.vectorCCy<ymax)\n        zind = np.logical_and(mesh.vectorCCz>zmin, mesh.vectorCCz<zmax)\n\n        xc = mesh.vectorCCx[xind]\n        yc = mesh.vectorCCy[yind]\n\n        hx = mesh.hx[xind]\n        hy = mesh.hy[yind]\n\n        x0 = [xc[0]-hx[0]*0.5, yc[0]-hy[0]*0.5]\n\n        meshCore = Mesh.TensorMesh([hx, hy] ,x0=x0)\n\n        actind = (mesh.gridCC[:,0]>xmin) & (mesh.gridCC[:,0]<xmax) \\\n               & (mesh.gridCC[:,1]>ymin) & (mesh.gridCC[:,1]<ymax) \\\n\n    elif mesh.dim==3:\n        xmin, xmax = xyzlim[0,0], xyzlim[0,1]\n        ymin, ymax = xyzlim[1,0], xyzlim[1,1]\n        zmin, zmax = xyzlim[2,0], xyzlim[2,1]\n\n        xind = np.logical_and(mesh.vectorCCx>xmin, mesh.vectorCCx<xmax)\n        yind = np.logical_and(mesh.vectorCCy>ymin, mesh.vectorCCy<ymax)\n        zind = np.logical_and(mesh.vectorCCz>zmin, mesh.vectorCCz<zmax)\n\n        xc = mesh.vectorCCx[xind]\n        yc = mesh.vectorCCy[yind]\n        zc = mesh.vectorCCz[zind]\n\n        hx = mesh.hx[xind]\n        hy = mesh.hy[yind]\n        hz = mesh.hz[zind]\n\n        x0 = [xc[0]-hx[0]*0.5, yc[0]-hy[0]*0.5, zc[0]-hz[0]*0.5]\n\n        meshCore = Mesh.TensorMesh([hx, hy, hz] ,x0=x0)\n\n        actind = (mesh.gridCC[:,0]>xmin) & (mesh.gridCC[:,0]<xmax) \\\n               & (mesh.gridCC[:,1]>ymin) & (mesh.gridCC[:,1]<ymax) \\\n               & (mesh.gridCC[:,2]>zmin) & (mesh.gridCC[:,2]<zmax)\n\n    else:\n        raise(Exception(\"Not implemented!\"))\n\n\n    return actind, meshCore",
  "def readCellLine(line):\n        for seg in line.split():\n            if '*' in seg:\n                st = seg\n                sp = seg.split('*')\n                re = np.array(sp[0],dtype=int)*(' ' + sp[1])\n                line = line.replace(st,re.strip())\n        return np.array(line.split(),dtype=float)",
  "def volTetra(xyz, A, B, C, D):\n    \"\"\"\n    Returns the volume for tetrahedras volume specified by the indexes A to D.\n\n    :param numpy.array xyz: X,Y,Z vertex vector\n    :param numpy.array A,B,C,D: vert index of the tetrahedra\n    :rtype: numpy.array\n    :return: V, volume of the tetrahedra\n\n    Algorithm http://en.wikipedia.org/wiki/Tetrahedron#Volume\n\n    .. math::\n\n       V = {1 \\over 3} A  h\n\n       V = {1 \\over 6} | ( a - d ) \\cdot ( ( b - d )  ( c - d ) ) |\n\n    \"\"\"\n\n    AD = xyz[A, :] - xyz[D, :]\n    BD = xyz[B, :] - xyz[D, :]\n    CD = xyz[C, :] - xyz[D, :]\n\n    V = (BD[:, 0]*CD[:, 1] - BD[:, 1]*CD[:, 0])*AD[:, 2] - (BD[:, 0]*CD[:, 2] - BD[:, 2]*CD[:, 0])*AD[:, 1] + (BD[:, 1]*CD[:, 2] - BD[:, 2]*CD[:, 1])*AD[:, 0]\n    return V/6",
  "def indexCube(nodes, gridSize, n=None):\n    \"\"\"\n    Returns the index of nodes on the mesh.\n\n\n    Input:\n       nodes     - string of which nodes to return. e.g. 'ABCD'\n       gridSize  - size of the nodal grid\n       n         - number of nodes each i,j,k direction: [ni,nj,nk]\n\n\n    Output:\n       index  - index in the order asked e.g. 'ABCD' --> (A,B,C,D)\n\n    TWO DIMENSIONS::\n\n      node(i,j)          node(i,j+1)\n           A -------------- B\n           |                |\n           |    cell(i,j)   |\n           |        I       |\n           |                |\n          D -------------- C\n      node(i+1,j)        node(i+1,j+1)\n\n\n    THREE DIMENSIONS::\n\n            node(i,j,k+1)       node(i,j+1,k+1)\n                E --------------- F\n               /|               / |\n              / |              /  |\n             /  |             /   |\n      node(i,j,k)         node(i,j+1,k)\n           A -------------- B     |\n           |    H ----------|---- G\n           |   /cell(i,j)   |   /\n           |  /     I       |  /\n           | /              | /\n           D -------------- C\n      node(i+1,j,k)      node(i+1,j+1,k)\n\n    \"\"\"\n\n    assert type(nodes) == str, \"Nodes must be a str variable: e.g. 'ABCD'\"\n    assert isinstance(gridSize, np.ndarray), \"Number of nodes must be an ndarray\"\n    nodes = nodes.upper()\n    # Make sure that we choose from the possible nodes.\n    possibleNodes = 'ABCD' if gridSize.size == 2 else 'ABCDEFGH'\n    for node in nodes:\n        assert node in possibleNodes, \"Nodes must be chosen from: '%s'\" % possibleNodes\n    dim = gridSize.size\n    if n is None:\n        n = gridSize - 1\n\n    if dim == 2:\n        ij = ndgrid(np.arange(n[0]), np.arange(n[1]))\n        i, j = ij[:, 0], ij[:, 1]\n    elif dim == 3:\n        ijk = ndgrid(np.arange(n[0]), np.arange(n[1]), np.arange(n[2]))\n        i, j, k = ijk[:, 0], ijk[:, 1], ijk[:, 2]\n    else:\n        raise Exception('Only 2 and 3 dimensions supported.')\n\n    nodeMap = {'A': [0, 0, 0], 'B': [0, 1, 0], 'C': [1, 1, 0], 'D': [1, 0, 0],\n               'E': [0, 0, 1], 'F': [0, 1, 1], 'G': [1, 1, 1], 'H': [1, 0, 1]}\n    out = ()\n    for node in nodes:\n        shift = nodeMap[node]\n        if dim == 2:\n            out += (sub2ind(gridSize, np.c_[i+shift[0], j+shift[1]]).flatten(), )\n        elif dim == 3:\n            out += (sub2ind(gridSize, np.c_[i+shift[0], j+shift[1], k+shift[2]]).flatten(), )\n\n    return out",
  "def faceInfo(xyz, A, B, C, D, average=True, normalizeNormals=True):\n    \"\"\"\n    function [N] = faceInfo(y,A,B,C,D)\n\n       Returns the averaged normal, area, and edge lengths for a given set of faces.\n\n       If average option is FALSE then N is a cell array {nA,nB,nC,nD}\n\n\n    Input:\n       xyz          - X,Y,Z vertex vector\n       A,B,C,D      - vert index of the face (counter clockwize)\n\n    Options:\n       average      - [true]/false, toggles returning all normals or the average\n\n    Output:\n       N            - average face normal or {nA,nB,nC,nD} if average = false\n       area         - average face area\n       edgeLengths  - exact edge Lengths, 4 column vector [AB, BC, CD, DA]\n\n    see also testFaceNormal testFaceArea\n\n    @author Rowan Cockett\n\n    Last modified on: 2013/07/26\n\n    \"\"\"\n    assert type(average) is bool, 'average must be a boolean'\n    assert type(normalizeNormals) is bool, 'normalizeNormals must be a boolean'\n    # compute normal that is pointing away from you.\n    #\n    #    A -------A-B------- B\n    #    |                   |\n    #    |                   |\n    #   D-A       (X)       B-C\n    #    |                   |\n    #    |                   |\n    #    D -------C-D------- C\n\n    AB = xyz[B, :] - xyz[A, :]\n    BC = xyz[C, :] - xyz[B, :]\n    CD = xyz[D, :] - xyz[C, :]\n    DA = xyz[A, :] - xyz[D, :]\n\n    def cross(X, Y):\n        return np.c_[X[:, 1]*Y[:, 2] - X[:, 2]*Y[:, 1],\n                     X[:, 2]*Y[:, 0] - X[:, 0]*Y[:, 2],\n                     X[:, 0]*Y[:, 1] - X[:, 1]*Y[:, 0]]\n\n    nA = cross(AB, DA)\n    nB = cross(BC, AB)\n    nC = cross(CD, BC)\n    nD = cross(DA, CD)\n\n    length = lambda x: np.sqrt(x[:, 0]**2 + x[:, 1]**2 + x[:, 2]**2)\n    normalize = lambda x: x/np.kron(np.ones((1, x.shape[1])), mkvc(length(x), 2))\n    if average:\n        # average the normals at each vertex.\n        N = (nA + nB + nC + nD)/4  # this is intrinsically weighted by area\n        # normalize\n        N = normalize(N)\n    else:\n        if normalizeNormals:\n            N = [normalize(nA), normalize(nB), normalize(nC), normalize(nD)]\n        else:\n            N = [nA, nB, nC, nD]\n\n    # Area calculation\n    #\n    # Approximate by 4 different triangles, and divide by 2.\n    # Each triangle is one half of the length of the cross product\n    #\n    # So also could be viewed as the average parallelogram.\n    #\n    # TODO: This does not compute correctly for concave quadrilaterals\n    area = (length(nA)+length(nB)+length(nC)+length(nD))/4\n\n    return N, area",
  "def cross(X, Y):\n        return np.c_[X[:, 1]*Y[:, 2] - X[:, 2]*Y[:, 1],\n                     X[:, 2]*Y[:, 0] - X[:, 0]*Y[:, 2],\n                     X[:, 0]*Y[:, 1] - X[:, 1]*Y[:, 0]]"
]