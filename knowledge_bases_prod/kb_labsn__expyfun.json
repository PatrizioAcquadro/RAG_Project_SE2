[
  "def git_version():\n    \"\"\"Helper adapted from Numpy\"\"\"\n    def _minimal_ext_cmd(cmd):\n        # minimal env; LANGUAGE is used on win32\n        env = dict(LANGUAGE='C', LANG='C', LC_ALL='C')\n        for k in ['SYSTEMROOT', 'PATH']:\n            v = os.environ.get(k)\n            if v is not None:\n                env[k] = v\n        return subprocess.Popen(cmd, stdout=subprocess.PIPE,\n                                env=env).communicate()[0]\n    if os.path.exists('.git'):\n        try:\n            out = _minimal_ext_cmd(['git', 'rev-parse', 'HEAD'])\n            GIT_REVISION = out.decode('utf-8').strip()\n        except OSError:\n            GIT_REVISION = \"Unknown\"\n    else:\n        GIT_REVISION = \"Unknown\"\n    return GIT_REVISION[:7]",
  "def write_version(version):\n    with open(version_file, 'w') as fid:\n        fid.write('__version__ = \\'{0}\\'\\n'.format(version))",
  "def setup_package(script_args=None):\n    \"\"\"Actually invoke the setup call\"\"\"\n    if os.path.exists('MANIFEST'):\n        os.remove('MANIFEST')\n    with open('README.rst') as fid:\n        long_description = fid.read()\n    kwargs = dict(\n        name=DISTNAME,\n        maintainer=MAINTAINER,\n        include_package_data=True,\n        maintainer_email=MAINTAINER_EMAIL,\n        description=DESCRIPTION,\n        license=LICENSE,\n        url=URL,\n        version=FULL_VERSION,\n        download_url=DOWNLOAD_URL,\n        long_description=long_description,\n        zip_safe=False,  # the package can run out of an .egg file\n        classifiers=['Intended Audience :: Science/Research',\n                     'Intended Audience :: Developers',\n                     'License :: OSI Approved',\n                     'Programming Language :: Python',\n                     'Topic :: Software Development',\n                     'Topic :: Scientific/Engineering',\n                     'Operating System :: Microsoft :: Windows',\n                     'Operating System :: POSIX',\n                     'Operating System :: Unix',\n                     'Operating System :: MacOS'],\n        platforms='any',\n        packages=['expyfun', 'expyfun.tests',\n                  'expyfun.analyze', 'expyfun.analyze.tests',\n                  'expyfun.codeblocks',\n                  'expyfun._externals',\n                  'expyfun.io', 'expyfun.io.tests',\n                  'expyfun.stimuli', 'expyfun.stimuli.tests',\n                  'expyfun.visual', 'expyfun.visual.tests'],\n        package_data={'expyfun': [os.path.join('data', '*')]},\n        scripts=[])\n    if script_args is not None:\n        kwargs['script_args'] = script_args\n    try:\n        write_version(FULL_VERSION)\n        setup(**kwargs)\n    finally:\n        write_version(VERSION)",
  "def _minimal_ext_cmd(cmd):\n        # minimal env; LANGUAGE is used on win32\n        env = dict(LANGUAGE='C', LANG='C', LC_ALL='C')\n        for k in ['SYSTEMROOT', 'PATH']:\n            v = os.environ.get(k)\n            if v is not None:\n                env[k] = v\n        return subprocess.Popen(cmd, stdout=subprocess.PIPE,\n                                env=env).communicate()[0]",
  "class IPythonConsoleLexer(Lexer):\n    \"\"\"\n    For IPython console output or doctests, such as:\n\n    .. sourcecode:: ipython\n\n      In [1]: a = 'foo'\n\n      In [2]: a\n      Out[2]: 'foo'\n\n      In [3]: print a\n      foo\n\n      In [4]: 1 / 0\n\n    Notes:\n\n      - Tracebacks are not currently supported.\n\n      - It assumes the default IPython prompts, not customized ones.\n    \"\"\"\n\n    name = 'IPython console session'\n    aliases = ['ipython']\n    mimetypes = ['text/x-ipython-console']\n    input_prompt = re.compile(\"(In \\[[0-9]+\\]: )|(   \\.\\.\\.+:)\")\n    output_prompt = re.compile(\"(Out\\[[0-9]+\\]: )|(   \\.\\.\\.+:)\")\n    continue_prompt = re.compile(\"   \\.\\.\\.+:\")\n    tb_start = re.compile(\"\\-+\")\n\n    def get_tokens_unprocessed(self, text):\n        pylexer = PythonLexer(**self.options)\n        tblexer = PythonTracebackLexer(**self.options)\n\n        curcode = ''\n        insertions = []\n        for match in line_re.finditer(text):\n            line = match.group()\n            input_prompt = self.input_prompt.match(line)\n            continue_prompt = self.continue_prompt.match(line.rstrip())\n            output_prompt = self.output_prompt.match(line)\n            if line.startswith(\"#\"):\n                insertions.append((len(curcode),\n                                   [(0, Comment, line)]))\n            elif input_prompt is not None:\n                insertions.append((len(curcode),\n                                   [(0, Generic.Prompt, input_prompt.group())]))\n                curcode += line[input_prompt.end():]\n            elif continue_prompt is not None:\n                insertions.append((len(curcode),\n                                   [(0, Generic.Prompt, continue_prompt.group())]))\n                curcode += line[continue_prompt.end():]\n            elif output_prompt is not None:\n                insertions.append((len(curcode),\n                                   [(0, Generic.Output, output_prompt.group())]))\n                curcode += line[output_prompt.end():]\n            else:\n                if curcode:\n                    for item in do_insertions(insertions,\n                                              pylexer.get_tokens_unprocessed(curcode)):\n                        yield item\n                        curcode = ''\n                        insertions = []\n                yield match.start(), Generic.Output, line\n        if curcode:\n            for item in do_insertions(insertions,\n                                      pylexer.get_tokens_unprocessed(curcode)):\n                yield item",
  "def get_tokens_unprocessed(self, text):\n        pylexer = PythonLexer(**self.options)\n        tblexer = PythonTracebackLexer(**self.options)\n\n        curcode = ''\n        insertions = []\n        for match in line_re.finditer(text):\n            line = match.group()\n            input_prompt = self.input_prompt.match(line)\n            continue_prompt = self.continue_prompt.match(line.rstrip())\n            output_prompt = self.output_prompt.match(line)\n            if line.startswith(\"#\"):\n                insertions.append((len(curcode),\n                                   [(0, Comment, line)]))\n            elif input_prompt is not None:\n                insertions.append((len(curcode),\n                                   [(0, Generic.Prompt, input_prompt.group())]))\n                curcode += line[input_prompt.end():]\n            elif continue_prompt is not None:\n                insertions.append((len(curcode),\n                                   [(0, Generic.Prompt, continue_prompt.group())]))\n                curcode += line[continue_prompt.end():]\n            elif output_prompt is not None:\n                insertions.append((len(curcode),\n                                   [(0, Generic.Output, output_prompt.group())]))\n                curcode += line[output_prompt.end():]\n            else:\n                if curcode:\n                    for item in do_insertions(insertions,\n                                              pylexer.get_tokens_unprocessed(curcode)):\n                        yield item\n                        curcode = ''\n                        insertions = []\n                yield match.start(), Generic.Output, line\n        if curcode:\n            for item in do_insertions(insertions,\n                                      pylexer.get_tokens_unprocessed(curcode)):\n                yield item",
  "class only_base(Body, Element):\n    def dont_traverse(self, *args, **kwargs):\n        return []",
  "class html_only(only_base):\n    pass",
  "class latex_only(only_base):\n    pass",
  "def run(content, node_class, state, content_offset):\n    text = '\\n'.join(content)\n    node = node_class(text)\n    state.nested_parse(content, content_offset, node)\n    return [node]",
  "def html_only_directive(name, arguments, options, content, lineno,\n                        content_offset, block_text, state, state_machine):\n    return run(content, html_only, state, content_offset)",
  "def latex_only_directive(name, arguments, options, content, lineno,\n                         content_offset, block_text, state, state_machine):\n    return run(content, latex_only, state, content_offset)",
  "def builder_inited(app):\n    if app.builder.name == 'html':\n        latex_only.traverse = only_base.dont_traverse\n    else:\n        html_only.traverse = only_base.dont_traverse",
  "def setup(app):\n    app.add_directive('htmlonly', html_only_directive, True, (0, 0, 0))\n    app.add_directive('latexonly', latex_only_directive, True, (0, 0, 0))\n    app.add_node(html_only)\n    app.add_node(latex_only)\n\n    # This will *really* never see the light of day As it turns out,\n    # this results in \"broken\" image nodes since they never get\n    # processed, so best not to do this.\n    # app.connect('builder-inited', builder_inited)\n\n    # Add visit/depart methods to HTML-Translator:\n    def visit_perform(self, node):\n        pass\n    def depart_perform(self, node):\n        pass\n    def visit_ignore(self, node):\n        node.children = []\n    def depart_ignore(self, node):\n        node.children = []\n\n    app.add_node(html_only, html=(visit_perform, depart_perform))\n    app.add_node(html_only, latex=(visit_ignore, depart_ignore))\n    app.add_node(latex_only, latex=(visit_perform, depart_perform))\n    app.add_node(latex_only, html=(visit_ignore, depart_ignore))",
  "def dont_traverse(self, *args, **kwargs):\n        return []",
  "def visit_perform(self, node):\n        pass",
  "def depart_perform(self, node):\n        pass",
  "def visit_ignore(self, node):\n        node.children = []",
  "def depart_ignore(self, node):\n        node.children = []",
  "class Tee(object):\n\n    def __init__(self, file1, file2):\n        self.file1 = file1\n        self.file2 = file2\n\n    def write(self, data):\n        self.file1.write(data)\n        self.file2.write(data)\n\n    def flush(self):\n        self.file1.flush()\n        self.file2.flush()",
  "def _get_data(url):\n    \"\"\"Helper function to get data over http or from a local file\"\"\"\n    if url.startswith('http://'):\n        # Try Python 2, use Python 3 on exception\n        try:\n            resp = urllib.urlopen(url)\n            encoding = resp.headers.dict.get('content-encoding', 'plain')\n        except AttributeError:\n            resp = urllib.request.urlopen(url)\n            encoding = resp.headers.get('content-encoding', 'plain')\n        data = resp.read()\n        if encoding == 'plain':\n            pass\n        elif encoding == 'gzip':\n            data = StringIO(data)\n            data = gzip.GzipFile(fileobj=data).read()\n        else:\n            raise RuntimeError('unknown encoding')\n    else:\n        with open(url, 'r') as fid:\n            data = fid.read()\n        fid.close()\n\n    return data",
  "def parse_sphinx_searchindex(searchindex):\n    \"\"\"Parse a Sphinx search index\n\n    Parameters\n    ----------\n    searchindex : str\n        The Sphinx search index (contents of searchindex.js)\n\n    Returns\n    -------\n    filenames : list of str\n        The file names parsed from the search index.\n    objects : dict\n        The objects parsed from the search index.\n    \"\"\"\n    def _select_block(str_in, start_tag, end_tag):\n        \"\"\"Select first block delimited by start_tag and end_tag\"\"\"\n        start_pos = str_in.find(start_tag)\n        if start_pos < 0:\n            raise ValueError('start_tag not found')\n        depth = 0\n        for pos in range(start_pos, len(str_in)):\n            if str_in[pos] == start_tag:\n                depth += 1\n            elif str_in[pos] == end_tag:\n                depth -= 1\n\n            if depth == 0:\n                break\n        sel = str_in[start_pos + 1:pos]\n        return sel\n\n    def _parse_dict_recursive(dict_str):\n        \"\"\"Parse a dictionary from the search index\"\"\"\n        dict_out = dict()\n        pos_last = 0\n        pos = dict_str.find(':')\n        while pos >= 0:\n            key = dict_str[pos_last:pos]\n            if dict_str[pos + 1] == '[':\n                # value is a list\n                pos_tmp = dict_str.find(']', pos + 1)\n                if pos_tmp < 0:\n                    raise RuntimeError('error when parsing dict')\n                value = dict_str[pos + 2: pos_tmp].split(',')\n                # try to convert elements to int\n                for i in range(len(value)):\n                    try:\n                        value[i] = int(value[i])\n                    except ValueError:\n                        pass\n            elif dict_str[pos + 1] == '{':\n                # value is another dictionary\n                subdict_str = _select_block(dict_str[pos:], '{', '}')\n                value = _parse_dict_recursive(subdict_str)\n                pos_tmp = pos + len(subdict_str)\n            else:\n                raise ValueError('error when parsing dict: unknown elem')\n\n            key = key.strip('\"')\n            if len(key) > 0:\n                dict_out[key] = value\n\n            pos_last = dict_str.find(',', pos_tmp)\n            if pos_last < 0:\n                break\n            pos_last += 1\n            pos = dict_str.find(':', pos_last)\n\n        return dict_out\n\n    # Make sure searchindex uses UTF-8 encoding\n    if hasattr(searchindex, 'decode'):\n        searchindex = searchindex.decode('UTF-8')\n\n    # parse objects\n    query = 'objects:'\n    pos = searchindex.find(query)\n    if pos < 0:\n        raise ValueError('\"objects:\" not found in search index')\n\n    sel = _select_block(searchindex[pos:], '{', '}')\n    objects = _parse_dict_recursive(sel)\n\n    # parse filenames\n    query = 'filenames:'\n    pos = searchindex.find(query)\n    if pos < 0:\n        raise ValueError('\"filenames:\" not found in search index')\n    filenames = searchindex[pos + len(query) + 1:]\n    filenames = filenames[:filenames.find(']')]\n    filenames = [f.strip('\"') for f in filenames.split(',')]\n\n    return filenames, objects",
  "class SphinxDocLinkResolver(object):\n    \"\"\" Resolve documentation links using searchindex.js generated by Sphinx\n\n    Parameters\n    ----------\n    doc_url : str\n        The base URL of the project website.\n    searchindex : str\n        Filename of searchindex, relative to doc_url.\n    extra_modules_test : list of str\n        List of extra module names to test.\n    relative : bool\n        Return relative links (only useful for links to documentation of this\n        package).\n    \"\"\"\n\n    def __init__(self, doc_url, searchindex='searchindex.js',\n                 extra_modules_test=None, relative=False):\n        self.doc_url = doc_url\n        self.relative = relative\n        self._link_cache = {}\n\n        self.extra_modules_test = extra_modules_test\n        self._page_cache = {}\n        if doc_url.startswith('http://'):\n            if relative:\n                raise ValueError('Relative links are only supported for local '\n                                 'URLs (doc_url cannot start with \"http://)\"')\n            searchindex_url = doc_url + '/' + searchindex\n        else:\n            searchindex_url = os.path.join(doc_url, searchindex)\n\n        # detect if we are using relative links on a Windows system\n        if os.name.lower() == 'nt' and not doc_url.startswith('http://'):\n            if not relative:\n                raise ValueError('You have to use relative=True for the local'\n                                 ' package on a Windows system.')\n            self._is_windows = True\n        else:\n            self._is_windows = False\n\n        # download and initialize the search index\n        sindex = get_data(searchindex_url)\n        filenames, objects = parse_sphinx_searchindex(sindex)\n\n        self._searchindex = dict(filenames=filenames, objects=objects)\n\n    def _get_link(self, cobj):\n        \"\"\"Get a valid link, False if not found\"\"\"\n\n        fname_idx = None\n        full_name = cobj['module_short'] + '.' + cobj['name']\n        if full_name in self._searchindex['objects']:\n            value = self._searchindex['objects'][full_name]\n            if isinstance(value, dict):\n                value = value[next(iter(value.keys()))]\n            fname_idx = value[0]\n        elif cobj['module_short'] in self._searchindex['objects']:\n            value = self._searchindex['objects'][cobj['module_short']]\n            if cobj['name'] in value.keys():\n                fname_idx = value[cobj['name']][0]\n\n        if fname_idx is not None:\n            fname = self._searchindex['filenames'][fname_idx] + '.html'\n\n            if self._is_windows:\n                fname = fname.replace('/', '\\\\')\n                link = os.path.join(self.doc_url, fname)\n            else:\n                link = posixpath.join(self.doc_url, fname)\n\n            if hasattr(link, 'decode'):\n                link = link.decode('utf-8', 'replace')\n\n            if link in self._page_cache:\n                html = self._page_cache[link]\n            else:\n                html = get_data(link)\n                self._page_cache[link] = html\n\n            # test if cobj appears in page\n            comb_names = [cobj['module_short'] + '.' + cobj['name']]\n            if self.extra_modules_test is not None:\n                for mod in self.extra_modules_test:\n                    comb_names.append(mod + '.' + cobj['name'])\n            url = False\n            if hasattr(html, 'decode'):\n                # Decode bytes under Python 3\n                html = html.decode('utf-8', 'replace')\n\n            for comb_name in comb_names:\n                if hasattr(comb_name, 'decode'):\n                    # Decode bytes under Python 3\n                    comb_name = comb_name.decode('utf-8', 'replace')\n                if comb_name in html:\n                    url = link + u'#' + comb_name\n            link = url\n        else:\n            link = False\n\n        return link\n\n    def resolve(self, cobj, this_url):\n        \"\"\"Resolve the link to the documentation, returns None if not found\n\n        Parameters\n        ----------\n        cobj : dict\n            Dict with information about the \"code object\" for which we are\n            resolving a link.\n            cobi['name'] : function or class name (str)\n            cobj['module_short'] : shortened module name (str)\n            cobj['module'] : module name (str)\n        this_url: str\n            URL of the current page. Needed to construct relative URLs\n            (only used if relative=True in constructor).\n\n        Returns\n        -------\n        link : str | None\n            The link (URL) to the documentation.\n        \"\"\"\n        full_name = cobj['module_short'] + '.' + cobj['name']\n        link = self._link_cache.get(full_name, None)\n        if link is None:\n            # we don't have it cached\n            link = self._get_link(cobj)\n            # cache it for the future\n            self._link_cache[full_name] = link\n\n        if link is False or link is None:\n            # failed to resolve\n            return None\n\n        if self.relative:\n            link = os.path.relpath(link, start=this_url)\n            if self._is_windows:\n                # replace '\\' with '/' so it on the web\n                link = link.replace('\\\\', '/')\n\n            # for some reason, the relative link goes one directory too high up\n            link = link[3:]\n\n        return link",
  "def extract_docstring(filename, ignore_heading=False):\n    \"\"\" Extract a module-level docstring, if any\n    \"\"\"\n    with open(filename) as fid:\n        lines = fid.readlines()\n    start_row = 0\n    if lines[0].startswith('#!'):\n        lines.pop(0)\n        start_row = 1\n    docstring = ''\n    first_par = ''\n    line_iterator = iter(lines)\n    tokens = tokenize.generate_tokens(lambda: next(line_iterator))\n    for tok_type, tok_content, _, (erow, _), _ in tokens:\n        tok_type = token.tok_name[tok_type]\n        if tok_type in ('NEWLINE', 'COMMENT', 'NL', 'INDENT', 'DEDENT'):\n            continue\n        elif tok_type == 'STRING':\n            docstring = eval(tok_content)\n            # If the docstring is formatted with several paragraphs, extract\n            # the first one:\n            paragraphs = '\\n'.join(\n                line.rstrip() for line\n                in docstring.split('\\n')).split('\\n\\n')\n            if paragraphs:\n                if ignore_heading:\n                    if len(paragraphs) > 1:\n                        first_par = re.sub('\\n', ' ', paragraphs[1])\n                        first_par = ((first_par[:95] + '...')\n                                     if len(first_par) > 95 else first_par)\n                    else:\n                        raise ValueError(\"Docstring not found by gallery.\\n\"\n                                         \"Please check the layout of your\"\n                                         \" example file:\\n {}\\n and make sure\"\n                                         \" it's correct\".format(filename))\n                else:\n                    first_par = paragraphs[0]\n\n        break\n    return docstring, first_par, erow + 1 + start_row",
  "def generate_example_rst(app):\n    \"\"\" Generate the list of examples, as well as the contents of\n        examples.\n    \"\"\"\n    root_dir = os.path.join(app.builder.srcdir, 'auto_examples')\n    example_dir = os.path.abspath(os.path.join(app.builder.srcdir,'..', '..',\n                                               'examples'))\n    generated_dir = os.path.abspath(os.path.join(app.builder.srcdir,\n                                                 'modules', 'generated'))\n\n    plot_gallery = app.builder.config.plot_gallery\n    if isinstance(plot_gallery, (int, bool)):\n        plot_gallery = bool(plot_gallery)\n    if not os.path.exists(example_dir):\n        os.makedirs(example_dir)\n    if not os.path.exists(root_dir):\n        os.makedirs(root_dir)\n    if not os.path.exists(generated_dir):\n        os.makedirs(generated_dir)\n\n    # we create an index.rst with all examples\n    with open(os.path.join(root_dir, 'index.rst'), 'w') as fhindex:\n        # Note: The sidebar button has been removed from the examples page\n        #       for now due to how it messes up the layout. Will be fixed\n        #       at a later point\n        fhindex.write(\"\"\"\\\n\n\n\n.. raw:: html\n\n\n    <style type=\"text/css\">\n    div#sidebarbutton {\n        /* hide the sidebar collapser, while ensuring vertical arrangement */\n        display: none;\n    }\n\n    .figure {\n        float: left;\n        margin: 10px;\n        width: auto;\n        height: 200px;\n        width: 180px;\n    }\n\n    .figure img {\n        display: inline;\n        }\n\n    .figure .caption {\n        width: 180px;\n        text-align: center !important;\n    }\n    </style>\n\n.. _examples-index:\n\nExamples\n========\n\n\"\"\")\n        # Here we don't use an os.walk, but we recurse only twice: flat is\n        # better than nested.\n        seen_backrefs = set()\n        generate_dir_rst('.', fhindex, example_dir, root_dir, plot_gallery,\n                         seen_backrefs)\n        for directory in sorted(os.listdir(example_dir)):\n            if os.path.isdir(os.path.join(example_dir, directory)):\n                generate_dir_rst(directory, fhindex, example_dir, root_dir,\n                                 plot_gallery, seen_backrefs)",
  "def extract_line_count(filename, target_dir):\n    # Extract the line count of a file\n    example_file = os.path.join(target_dir, filename)\n    with open(example_file) as fid:\n        lines = fid.readlines()\n    start_row = 0\n    if lines and lines[0].startswith('#!'):\n        lines.pop(0)\n        start_row = 1\n    line_iterator = iter(lines)\n    tokens = tokenize.generate_tokens(lambda: next(line_iterator))\n    check_docstring = True\n    erow_docstring = 0\n    for tok_type, _, _, (erow, _), _ in tokens:\n        tok_type = token.tok_name[tok_type]\n        if tok_type in ('NEWLINE', 'COMMENT', 'NL', 'INDENT', 'DEDENT'):\n            continue\n        elif (tok_type == 'STRING') and check_docstring:\n            erow_docstring = erow\n            check_docstring = False\n    return erow_docstring+1+start_row, erow+1+start_row",
  "def line_count_sort(file_list, target_dir):\n    # Sort the list of examples by line-count\n    new_list = [x for x in file_list if x.endswith('.py')]\n    unsorted = np.zeros(shape=(len(new_list), 2))\n    unsorted = unsorted.astype(np.object)\n    for count, exmpl in enumerate(new_list):\n        docstr_lines, total_lines = extract_line_count(exmpl, target_dir)\n        unsorted[count][1] = total_lines - docstr_lines\n        unsorted[count][0] = exmpl\n    index = np.lexsort((unsorted[:, 0].astype(np.str),\n                        unsorted[:, 1].astype(np.float)))\n    if not len(unsorted):\n        return []\n    return np.array(unsorted[index][:, 0]).tolist()",
  "def _thumbnail_div(subdir, full_dir, fname, snippet):\n    \"\"\"Generates RST to place a thumbnail in a gallery\"\"\"\n    thumb = os.path.join(full_dir, 'images', 'thumb', fname[:-3] + '.png')\n    link_name = os.path.join(full_dir, fname).replace(os.path.sep, '_')\n    ref_name = os.path.join(subdir, fname).replace(os.path.sep, '_')\n    if ref_name.startswith('._'):\n        ref_name = ref_name[2:]\n    out = []\n    out.append(\"\"\"\n\n.. raw:: html\n\n\n    <div class=\"thumbnailContainer\" tooltip=\"{}\">\n\n\"\"\".format(snippet))\n\n    out.append('.. figure:: %s\\n' % thumb)\n    if link_name.startswith('._'):\n        link_name = link_name[2:]\n    if full_dir != '.':\n        out.append('   :target: ./%s/%s.html\\n\\n' % (full_dir, fname[:-3]))\n    else:\n        out.append('   :target: ./%s.html\\n\\n' % link_name[:-3])\n    out.append(\"\"\"   :ref:`example_%s`\n\n\n.. raw:: html\n\n    </div>\n\n\"\"\" % (ref_name))\n    return ''.join(out)",
  "def generate_dir_rst(directory, fhindex, example_dir, root_dir, plot_gallery,\n                     seen_backrefs):\n    \"\"\" Generate the rst file for an example directory.\n    \"\"\"\n    if not directory == '.':\n        target_dir = os.path.join(root_dir, directory)\n        src_dir = os.path.join(example_dir, directory)\n    else:\n        target_dir = root_dir\n        src_dir = example_dir\n    if not os.path.exists(os.path.join(src_dir, 'README.txt')):\n        print(80 * '_')\n        print('Example directory %s does not have a README.txt file'\n              % src_dir)\n        print('Skipping this directory')\n        print(80 * '_')\n        return\n    with open(os.path.join(src_dir, 'README.txt')) as fid:\n        readme = fid.read()\n    fhindex.write(\"\"\"\n\n\n%s\n\n\n\"\"\" % readme)\n    if not os.path.exists(target_dir):\n        os.makedirs(target_dir)\n    sorted_listdir = line_count_sort(os.listdir(src_dir),\n                                     src_dir)\n    if not os.path.exists(os.path.join(directory, 'images', 'thumb')):\n        os.makedirs(os.path.join(directory, 'images', 'thumb'))\n    for fname in sorted_listdir:\n        if fname.endswith('py'):\n            backrefs = generate_file_rst(fname, target_dir, src_dir, root_dir,\n                                         plot_gallery)\n            new_fname = os.path.join(src_dir, fname)\n            _, snippet, _ = extract_docstring(new_fname, True)\n            fhindex.write(_thumbnail_div(directory, directory, fname, snippet))\n            fhindex.write(\"\"\"\n\n.. toctree::\n   :hidden:\n\n   %s/%s\n\n\"\"\" % (directory, fname[:-3]))\n            for backref in backrefs:\n                include_path = os.path.join(root_dir, '../modules/generated/%s.examples' % backref)\n                seen = backref in seen_backrefs\n                with open(include_path, 'a' if seen else 'w') as ex_file:\n                    if not seen:\n                        # heading\n                        print(file=ex_file)\n                        print('Examples using ``%s``' % backref, file=ex_file)\n                        print('-----------------%s--' % ('-' * len(backref)),\n                              file=ex_file)\n                        print(file=ex_file)\n                    rel_dir = os.path.join('../../auto_examples', directory)\n                    ex_file.write(_thumbnail_div(directory, rel_dir, fname, snippet))\n                    seen_backrefs.add(backref)\n    fhindex.write(\"\"\"\n.. raw:: html\n\n    <div class=\"clearer\"></div>\n    \"\"\")",
  "def make_thumbnail(in_fname, out_fname, width, height):\n    \"\"\"Make a thumbnail with the same aspect ratio centered in an\n       image with a given width and height\n    \"\"\"\n    # local import to avoid testing dependency on PIL:\n    try:\n        from PIL import Image\n    except ImportError:\n        import Image\n    img = Image.open(in_fname)\n    width_in, height_in = img.size\n    scale_w = width / float(width_in)\n    scale_h = height / float(height_in)\n\n    if height_in * scale_w <= height:\n        scale = scale_w\n    else:\n        scale = scale_h\n\n    width_sc = int(round(scale * width_in))\n    height_sc = int(round(scale * height_in))\n\n    # resize the image\n    img.thumbnail((width_sc, height_sc), Image.ANTIALIAS)\n\n    # insert centered\n    thumb = Image.new('RGB', (width, height), (255, 255, 255))\n    pos_insert = ((width - width_sc) // 2, (height - height_sc) // 2)\n    thumb.paste(img, pos_insert)\n\n    with warnings.catch_warnings(record=True):  # PIL ResourceWarning\n        thumb.save(out_fname)\n    # Use optipng to perform lossless compression on the resized image if\n    # software is installed\n    if os.environ.get('SKLEARN_DOC_OPTIPNG', False):\n        try:\n            subprocess.call([\"optipng\", \"-quiet\", \"-o\", \"9\", out_fname])\n        except Exception:\n            warnings.warn('Install optipng to reduce the size of the generated images')",
  "def scale_image(in_fname, max_width):\n    \"\"\"Scale image such that width <= max_width\n    \"\"\"\n    try:\n        from PIL import Image\n    except ImportError:\n        import Image\n    img = Image.open(in_fname)\n    width_in, height_in = img.size\n\n    if width_in <= max_width:\n        return\n\n    scale = max_width / float(width_in)\n\n    width_sc = int(round(scale * width_in))\n    height_sc = int(round(scale * height_in))\n\n    # resize the image\n    img.thumbnail((width_sc, height_sc), Image.ANTIALIAS)\n\n    # overwrite the image\n    with warnings.catch_warnings(record=True):  # PIL ResourceWarning\n        img.save(in_fname)",
  "def get_short_module_name(module_name, obj_name):\n    \"\"\" Get the shortest possible module name \"\"\"\n    parts = module_name.split('.')\n    short_name = module_name\n    for i in range(len(parts) - 1, 0, -1):\n        short_name = '.'.join(parts[:i])\n        try:\n            exec('from %s import %s' % (short_name, obj_name))\n        # we actually want to catch SystemExit as well b/c mayavi can\n        # throw it via wx, so don't except Exception here :(\n        except:\n            # get the last working module name\n            short_name = '.'.join(parts[:(i + 1)])\n            break\n    return short_name",
  "class NameFinder(ast.NodeVisitor):\n    \"\"\"Finds the longest form of variable names and their imports in code\n\n    Only retains names from imported modules.\n    \"\"\"\n\n    def __init__(self):\n        super(NameFinder, self).__init__()\n        self.imported_names = {}\n        self.accessed_names = set()\n\n    def visit_Import(self, node, prefix=''):\n        for alias in node.names:\n            local_name = alias.asname or alias.name\n            self.imported_names[local_name] = prefix + alias.name\n\n    def visit_ImportFrom(self, node):\n        self.visit_Import(node, node.module + '.')\n\n    def visit_Name(self, node):\n        self.accessed_names.add(node.id)\n\n    def visit_Attribute(self, node):\n        attrs = []\n        while isinstance(node, ast.Attribute):\n            attrs.append(node.attr)\n            node = node.value\n\n        if isinstance(node, ast.Name):\n            # This is a.b, not e.g. a().b\n            attrs.append(node.id)\n            self.accessed_names.add('.'.join(reversed(attrs)))\n        else:\n            # need to get a in a().b\n            self.visit(node)\n\n    def get_mapping(self):\n        for name in self.accessed_names:\n            local_name = name.split('.', 1)[0]\n            remainder = name[len(local_name):]\n            if local_name in self.imported_names:\n                # Join import path to relative path\n                full_name = self.imported_names[local_name] + remainder\n                yield name, full_name",
  "def identify_names(code):\n    \"\"\"Builds a codeobj summary by identifying and resovles used names\n\n    >>> code = '''\n    ... from a.b import c\n    ... import d as e\n    ... print(c)\n    ... e.HelloWorld().f.g\n    ... '''\n    >>> for name, o in sorted(identify_names(code).items()):\n    ...     print(name, o['name'], o['module'], o['module_short'])\n    c c a.b a.b\n    e.HelloWorld HelloWorld d d\n    \"\"\"\n    finder = NameFinder()\n    finder.visit(ast.parse(code))\n\n    example_code_obj = {}\n    for name, full_name in finder.get_mapping():\n        # name is as written in file (e.g. np.asarray)\n        # full_name includes resolved import path (e.g. numpy.asarray)\n        module, attribute = full_name.rsplit('.', 1)\n        # get shortened module name\n        module_short = get_short_module_name(module, attribute)\n        cobj = {'name': attribute, 'module': module,\n                'module_short': module_short}\n        example_code_obj[name] = cobj\n    return example_code_obj",
  "def generate_file_rst(fname, target_dir, src_dir, root_dir, plot_gallery):\n    \"\"\" Generate the rst file for a given example.\n\n    Returns the set of expyfun functions/classes imported in the example.\n    \"\"\"\n    base_image_name = os.path.splitext(fname)[0]\n    image_fname = '%s_%%03d.png' % base_image_name\n\n    this_template = rst_template\n    last_dir = os.path.split(src_dir)[-1]\n    # to avoid leading . in file names, and wrong names in links\n    if last_dir == '.' or last_dir == 'examples':\n        last_dir = ''\n    else:\n        last_dir += '_'\n    short_fname = last_dir + fname\n    src_file = os.path.join(src_dir, fname)\n    example_file = os.path.join(target_dir, fname)\n    shutil.copyfile(src_file, example_file)\n\n    # The following is a list containing all the figure names\n    figure_list = []\n\n    image_dir = os.path.join(target_dir, 'images')\n    thumb_dir = os.path.join(image_dir, 'thumb')\n    if not os.path.exists(image_dir):\n        os.makedirs(image_dir)\n    if not os.path.exists(thumb_dir):\n        os.makedirs(thumb_dir)\n    image_path = os.path.join(image_dir, image_fname)\n    stdout_path = os.path.join(image_dir,\n                               'stdout_%s.txt' % base_image_name)\n    time_path = os.path.join(image_dir,\n                             'time_%s.txt' % base_image_name)\n    thumb_file = os.path.join(thumb_dir, base_image_name + '.png')\n    time_elapsed = 0\n    if plot_gallery:\n        # generate the plot as png image if file name\n        # starts with plot and if it is more recent than an\n        # existing image.\n        first_image_file = image_path % 1\n        if os.path.exists(stdout_path):\n            with open(stdout_path) as fid:\n                stdout = fid.read()\n        else:\n            stdout = ''\n        if os.path.exists(time_path):\n            with open(time_path) as fid:\n                time_elapsed = float(fid.read())\n\n        if not os.path.exists(first_image_file) or \\\n           os.stat(first_image_file).st_mtime <= os.stat(src_file).st_mtime:\n            # We need to execute the code\n            print('plotting %s' % fname)\n            t0 = time()\n            import matplotlib.pyplot as plt\n            plt.close('all')\n\n            cwd = os.getcwd()\n            try:\n                # First CD in the original example dir, so that any file\n                # created by the example get created in this directory\n                orig_stdout = sys.stdout\n                os.chdir(os.path.dirname(src_file))\n                my_buffer = StringIO()\n                my_stdout = Tee(sys.stdout, my_buffer)\n                sys.stdout = my_stdout\n                my_globals = {'pl': plt}\n                execfile(os.path.basename(src_file), my_globals)\n                time_elapsed = time() - t0\n                sys.stdout = orig_stdout\n                my_stdout = my_buffer.getvalue()\n\n                if '__doc__' in my_globals:\n                    # The __doc__ is often printed in the example, we\n                    # don't with to echo it\n                    my_stdout = my_stdout.replace(\n                        my_globals['__doc__'],\n                        '')\n                my_stdout = my_stdout.strip().expandtabs()\n                if my_stdout:\n                    output_lines = my_stdout.split('\\n')\n                    if len(output_lines) > MAX_NB_LINES_STDOUT:\n                        output_lines = output_lines[:MAX_NB_LINES_STDOUT]\n                        output_lines.append('...')\n                    stdout = '**Script output**::\\n\\n  %s\\n\\n' % (\n                        '\\n  '.join(output_lines))\n                with open(stdout_path, 'w') as fid:\n                    fid.write(stdout)\n                with open(time_path, 'w') as fid:\n                    fid.write('%f' % time_elapsed)\n                os.chdir(cwd)\n\n                # In order to save every figure we have two solutions :\n                # * iterate from 1 to infinity and call plt.fignum_exists(n)\n                #   (this requires the figures to be numbered\n                #    incrementally: 1, 2, 3 and not 1, 2, 5)\n                # * iterate over [fig_mngr.num for fig_mngr in\n                #   matplotlib._pylab_helpers.Gcf.get_all_fig_managers()]\n                last_fig_num = 0\n                fig_managers = matplotlib._pylab_helpers.Gcf.get_all_fig_managers()\n                for fig_mngr in fig_managers:\n                    # Set the fig_num figure as the current figure as we can't\n                    # save a figure that's not the current figure.\n                    fig = plt.figure(fig_mngr.num)\n                    kwargs = {}\n                    to_rgba = matplotlib.colors.colorConverter.to_rgba\n                    for attr in ['facecolor', 'edgecolor']:\n                        fig_attr = getattr(fig, 'get_' + attr)()\n                        default_attr = matplotlib.rcParams['figure.' + attr]\n                        if to_rgba(fig_attr) != to_rgba(default_attr):\n                            kwargs[attr] = fig_attr\n\n                    fig.savefig(image_path % fig_mngr.num, **kwargs)\n                    # make sure the image is not too large\n                    scale_image(image_path % fig_mngr.num, 850)\n                    figure_list.append(image_fname % fig_mngr.num)\n                    last_fig_num = fig_mngr.num\n                plt.close('all')\n\n            except Exception:\n                print(80 * '_')\n                print('%s is not compiling:' % fname)\n                traceback.print_exc()\n                print(80 * '_')\n            finally:\n                os.chdir(cwd)\n                sys.stdout = orig_stdout\n\n            print(\" - time elapsed : %.2f sec\" % time_elapsed)\n        else:\n            figure_list = [f[len(image_dir):]\n                           for f in glob.glob(image_path.replace(\"%03d\",\n                                                '[0-9][0-9][0-9]'))]\n        figure_list.sort()\n\n        # generate thumb file\n        this_template = plot_rst_template\n        car_thumb_path = os.path.join(os.path.split(root_dir)[0], 'build/html/stable/_images/')\n        # Note: normaly, make_thumbnail is used to write to the path contained in `thumb_file`\n        # which is within `auto_examples/../images/thumbs` depending on the example.\n        # Because the carousel has different dimensions than those of the examples gallery,\n        # I did not simply reuse them all as some contained whitespace due to their default gallery\n        # thumbnail size. Below, for a few cases, seperate thumbnails are created (the originals can't\n        # just be overwritten with the carousel dimensions as it messes up the examples gallery layout).\n        # The special carousel thumbnails are written directly to build/html/stable/_images/,\n        # as for some reason unknown to me, Sphinx refuses to copy my 'extra' thumbnails from the\n        # auto examples gallery to the build folder. This works fine as is, but it would be cleaner to\n        # have it happen with the rest. Ideally the should be written to 'thumb_file' as well, and then\n        # copied to the _images folder during the `Copying Downloadable Files` step like the rest.\n        if not os.path.exists(car_thumb_path):\n            os.makedirs(car_thumb_path)\n        if os.path.exists(first_image_file):\n            # We generate extra special thumbnails for the carousel\n            carousel_tfile = os.path.join(car_thumb_path, base_image_name + '_carousel.png')\n            first_img = image_fname % 1\n            if first_img in carousel_thumbs:\n                make_thumbnail((image_path % carousel_thumbs[first_img][0]),\n                               carousel_tfile, carousel_thumbs[first_img][1], 190)\n            make_thumbnail(first_image_file, thumb_file, 180, 120)\n\n    if not os.path.exists(thumb_file):\n        # create something to replace the thumbnail\n        make_thumbnail('source/_images/labsn.png', thumb_file, 180, 120)\n\n    docstring, short_desc, end_row = extract_docstring(example_file)\n\n    # Depending on whether we have one or more figures, we're using a\n    # horizontal list or a single rst call to 'image'.\n    if len(figure_list) == 1:\n        figure_name = figure_list[0]\n        image_list = SINGLE_IMAGE % figure_name.lstrip('/')\n    else:\n        image_list = HLIST_HEADER\n        for figure_name in figure_list:\n            image_list += HLIST_IMAGE_TEMPLATE % figure_name.lstrip('/')\n\n    time_m, time_s = divmod(time_elapsed, 60)\n    with open(os.path.join(target_dir, base_image_name + '.rst'), 'w') as f:\n        f.write(this_template % locals())\n\n    # save variables so we can later add links to the documentation\n    with open(example_file) as fid:\n        example_code_obj = identify_names(fid.read())\n    if example_code_obj:\n        codeobj_fname = example_file[:-3] + '_codeobj.pickle'\n        with open(codeobj_fname, 'wb') as fid:\n            pickle.dump(example_code_obj, fid, pickle.HIGHEST_PROTOCOL)\n\n    backrefs = set('{module_short}.{name}'.format(**entry)\n                   for entry in example_code_obj.values()\n                   if entry['module'].startswith('sklearn'))\n    return backrefs",
  "def embed_code_links(app, exception):\n    \"\"\"Embed hyperlinks to documentation into example code\"\"\"\n    if exception is not None:\n        return\n    print('Embedding documentation hyperlinks in examples..')\n\n    if app.builder.name == 'latex':\n        # Don't embed hyperlinks when a latex builder is used.\n        return\n\n    # Add resolvers for the packages for which we want to show links\n    doc_resolvers = {}\n    doc_resolvers['expyfun'] = SphinxDocLinkResolver(app.builder.outdir,\n                                                 relative=True)\n\n    doc_resolvers['matplotlib'] = SphinxDocLinkResolver(\n        'http://matplotlib.org')\n\n    doc_resolvers['numpy'] = SphinxDocLinkResolver(\n        'http://docs.scipy.org/doc/numpy-1.6.0')\n\n    doc_resolvers['scipy'] = SphinxDocLinkResolver(\n        'http://docs.scipy.org/doc/scipy-0.11.0/reference')\n\n    example_dir = os.path.join(app.builder.srcdir, 'auto_examples')\n    html_example_dir = os.path.abspath(os.path.join(app.builder.outdir,\n                                                    'auto_examples'))\n\n    # patterns for replacement\n    link_pattern = '<a href=\"%s\">%s</a>'\n    orig_pattern = '<span class=\"n\">%s</span>'\n    period = '<span class=\"o\">.</span>'\n\n    for dirpath, _, filenames in os.walk(html_example_dir):\n        for fname in filenames:\n            print('\\tprocessing: %s' % fname)\n            full_fname = os.path.join(html_example_dir, dirpath, fname)\n            subpath = dirpath[len(html_example_dir) + 1:]\n            pickle_fname = os.path.join(example_dir, subpath,\n                                        fname[:-5] + '_codeobj.pickle')\n\n            if os.path.exists(pickle_fname):\n                # we have a pickle file with the objects to embed links for\n                with open(pickle_fname, 'rb') as fid:\n                    example_code_obj = pickle.load(fid)\n                fid.close()\n                str_repl = {}\n                # generate replacement strings with the links\n                for name, cobj in example_code_obj.items():\n                    this_module = cobj['module'].split('.')[0]\n\n                    if this_module not in doc_resolvers:\n                        continue\n\n                    try:\n                        link = doc_resolvers[this_module].resolve(cobj,\n                                                                  full_fname)\n                    except (HTTPError, URLError) as e:\n                        print(\"The following error has occurred:\\n\")\n                        print(repr(e))\n                        continue\n\n                    if link is not None:\n                        parts = name.split('.')\n                        name_html = period.join(orig_pattern % part\n                                                for part in parts)\n                        str_repl[name_html] = link_pattern % (link, name_html)\n                # do the replacement in the html file\n\n                # ensure greediness\n                names = sorted(str_repl, key=len, reverse=True)\n                expr = re.compile(r'(?<!\\.)\\b' +  # don't follow . or word\n                                  '|'.join(re.escape(name)\n                                           for name in names))\n\n                def substitute_link(match):\n                    return str_repl[match.group()]\n\n                if len(str_repl) > 0:\n                    with open(full_fname, 'rb') as fid:\n                        lines_in = fid.readlines()\n                    with open(full_fname, 'wb') as fid:\n                        for line in lines_in:\n                            line = line.decode('utf-8')\n                            line = expr.sub(substitute_link, line)\n                            fid.write(line.encode('utf-8'))\n    print('[done]')",
  "def setup(app):\n    app.connect('builder-inited', generate_example_rst)\n    app.add_config_value('plot_gallery', True, 'html')\n\n    # embed links after build is finished\n    app.connect('build-finished', embed_code_links)\n\n    # Sphinx hack: sphinx copies generated images to the build directory\n    #  each time the docs are made.  If the desired image name already\n    #  exists, it appends a digit to prevent overwrites.  The problem is,\n    #  the directory is never cleared.  This means that each time you build\n    #  the docs, the number of images in the directory grows.\n    #\n    # This question has been asked on the sphinx development list, but there\n    #  was no response: http://osdir.com/ml/sphinx-dev/2011-02/msg00123.html\n    #\n    # The following is a hack that prevents this behavior by clearing the\n    #  image build directory each time the docs are built.  If sphinx\n    #  changes their layout between versions, this will not work (though\n    #  it should probably not cause a crash).  Tested successfully\n    #  on Sphinx 1.0.7\n    build_image_dir = 'build/html/_images'\n    if os.path.exists(build_image_dir):\n        filelist = os.listdir(build_image_dir)\n        for filename in filelist:\n            if filename.endswith('png'):\n                os.remove(os.path.join(build_image_dir, filename))",
  "def setup_module():\n    # HACK: Stop nosetests running setup() above\n    pass",
  "def __init__(self, file1, file2):\n        self.file1 = file1\n        self.file2 = file2",
  "def write(self, data):\n        self.file1.write(data)\n        self.file2.write(data)",
  "def flush(self):\n        self.file1.flush()\n        self.file2.flush()",
  "def _select_block(str_in, start_tag, end_tag):\n        \"\"\"Select first block delimited by start_tag and end_tag\"\"\"\n        start_pos = str_in.find(start_tag)\n        if start_pos < 0:\n            raise ValueError('start_tag not found')\n        depth = 0\n        for pos in range(start_pos, len(str_in)):\n            if str_in[pos] == start_tag:\n                depth += 1\n            elif str_in[pos] == end_tag:\n                depth -= 1\n\n            if depth == 0:\n                break\n        sel = str_in[start_pos + 1:pos]\n        return sel",
  "def _parse_dict_recursive(dict_str):\n        \"\"\"Parse a dictionary from the search index\"\"\"\n        dict_out = dict()\n        pos_last = 0\n        pos = dict_str.find(':')\n        while pos >= 0:\n            key = dict_str[pos_last:pos]\n            if dict_str[pos + 1] == '[':\n                # value is a list\n                pos_tmp = dict_str.find(']', pos + 1)\n                if pos_tmp < 0:\n                    raise RuntimeError('error when parsing dict')\n                value = dict_str[pos + 2: pos_tmp].split(',')\n                # try to convert elements to int\n                for i in range(len(value)):\n                    try:\n                        value[i] = int(value[i])\n                    except ValueError:\n                        pass\n            elif dict_str[pos + 1] == '{':\n                # value is another dictionary\n                subdict_str = _select_block(dict_str[pos:], '{', '}')\n                value = _parse_dict_recursive(subdict_str)\n                pos_tmp = pos + len(subdict_str)\n            else:\n                raise ValueError('error when parsing dict: unknown elem')\n\n            key = key.strip('\"')\n            if len(key) > 0:\n                dict_out[key] = value\n\n            pos_last = dict_str.find(',', pos_tmp)\n            if pos_last < 0:\n                break\n            pos_last += 1\n            pos = dict_str.find(':', pos_last)\n\n        return dict_out",
  "def __init__(self, doc_url, searchindex='searchindex.js',\n                 extra_modules_test=None, relative=False):\n        self.doc_url = doc_url\n        self.relative = relative\n        self._link_cache = {}\n\n        self.extra_modules_test = extra_modules_test\n        self._page_cache = {}\n        if doc_url.startswith('http://'):\n            if relative:\n                raise ValueError('Relative links are only supported for local '\n                                 'URLs (doc_url cannot start with \"http://)\"')\n            searchindex_url = doc_url + '/' + searchindex\n        else:\n            searchindex_url = os.path.join(doc_url, searchindex)\n\n        # detect if we are using relative links on a Windows system\n        if os.name.lower() == 'nt' and not doc_url.startswith('http://'):\n            if not relative:\n                raise ValueError('You have to use relative=True for the local'\n                                 ' package on a Windows system.')\n            self._is_windows = True\n        else:\n            self._is_windows = False\n\n        # download and initialize the search index\n        sindex = get_data(searchindex_url)\n        filenames, objects = parse_sphinx_searchindex(sindex)\n\n        self._searchindex = dict(filenames=filenames, objects=objects)",
  "def _get_link(self, cobj):\n        \"\"\"Get a valid link, False if not found\"\"\"\n\n        fname_idx = None\n        full_name = cobj['module_short'] + '.' + cobj['name']\n        if full_name in self._searchindex['objects']:\n            value = self._searchindex['objects'][full_name]\n            if isinstance(value, dict):\n                value = value[next(iter(value.keys()))]\n            fname_idx = value[0]\n        elif cobj['module_short'] in self._searchindex['objects']:\n            value = self._searchindex['objects'][cobj['module_short']]\n            if cobj['name'] in value.keys():\n                fname_idx = value[cobj['name']][0]\n\n        if fname_idx is not None:\n            fname = self._searchindex['filenames'][fname_idx] + '.html'\n\n            if self._is_windows:\n                fname = fname.replace('/', '\\\\')\n                link = os.path.join(self.doc_url, fname)\n            else:\n                link = posixpath.join(self.doc_url, fname)\n\n            if hasattr(link, 'decode'):\n                link = link.decode('utf-8', 'replace')\n\n            if link in self._page_cache:\n                html = self._page_cache[link]\n            else:\n                html = get_data(link)\n                self._page_cache[link] = html\n\n            # test if cobj appears in page\n            comb_names = [cobj['module_short'] + '.' + cobj['name']]\n            if self.extra_modules_test is not None:\n                for mod in self.extra_modules_test:\n                    comb_names.append(mod + '.' + cobj['name'])\n            url = False\n            if hasattr(html, 'decode'):\n                # Decode bytes under Python 3\n                html = html.decode('utf-8', 'replace')\n\n            for comb_name in comb_names:\n                if hasattr(comb_name, 'decode'):\n                    # Decode bytes under Python 3\n                    comb_name = comb_name.decode('utf-8', 'replace')\n                if comb_name in html:\n                    url = link + u'#' + comb_name\n            link = url\n        else:\n            link = False\n\n        return link",
  "def resolve(self, cobj, this_url):\n        \"\"\"Resolve the link to the documentation, returns None if not found\n\n        Parameters\n        ----------\n        cobj : dict\n            Dict with information about the \"code object\" for which we are\n            resolving a link.\n            cobi['name'] : function or class name (str)\n            cobj['module_short'] : shortened module name (str)\n            cobj['module'] : module name (str)\n        this_url: str\n            URL of the current page. Needed to construct relative URLs\n            (only used if relative=True in constructor).\n\n        Returns\n        -------\n        link : str | None\n            The link (URL) to the documentation.\n        \"\"\"\n        full_name = cobj['module_short'] + '.' + cobj['name']\n        link = self._link_cache.get(full_name, None)\n        if link is None:\n            # we don't have it cached\n            link = self._get_link(cobj)\n            # cache it for the future\n            self._link_cache[full_name] = link\n\n        if link is False or link is None:\n            # failed to resolve\n            return None\n\n        if self.relative:\n            link = os.path.relpath(link, start=this_url)\n            if self._is_windows:\n                # replace '\\' with '/' so it on the web\n                link = link.replace('\\\\', '/')\n\n            # for some reason, the relative link goes one directory too high up\n            link = link[3:]\n\n        return link",
  "def __init__(self):\n        super(NameFinder, self).__init__()\n        self.imported_names = {}\n        self.accessed_names = set()",
  "def visit_Import(self, node, prefix=''):\n        for alias in node.names:\n            local_name = alias.asname or alias.name\n            self.imported_names[local_name] = prefix + alias.name",
  "def visit_ImportFrom(self, node):\n        self.visit_Import(node, node.module + '.')",
  "def visit_Name(self, node):\n        self.accessed_names.add(node.id)",
  "def visit_Attribute(self, node):\n        attrs = []\n        while isinstance(node, ast.Attribute):\n            attrs.append(node.attr)\n            node = node.value\n\n        if isinstance(node, ast.Name):\n            # This is a.b, not e.g. a().b\n            attrs.append(node.id)\n            self.accessed_names.add('.'.join(reversed(attrs)))\n        else:\n            # need to get a in a().b\n            self.visit(node)",
  "def get_mapping(self):\n        for name in self.accessed_names:\n            local_name = name.split('.', 1)[0]\n            remainder = name[len(local_name):]\n            if local_name in self.imported_names:\n                # Join import path to relative path\n                full_name = self.imported_names[local_name] + remainder\n                yield name, full_name",
  "def execfile(filename, global_vars=None, local_vars=None):\n        with open(filename) as f:\n            code = compile(f.read(), filename, 'exec')\n            exec(code, global_vars, local_vars)",
  "def substitute_link(match):\n                    return str_repl[match.group()]",
  "def mangle_docstrings(app, what, name, obj, options, lines,\n                      reference_offset=[0]):\n\n    cfg = dict(use_plots=app.config.numpydoc_use_plots,\n               show_class_members=app.config.numpydoc_show_class_members)\n\n    if what == 'module':\n        # Strip top title\n        title_re = re.compile(r'^\\s*[#*=]{4,}\\n[a-z0-9 -]+\\n[#*=]{4,}\\s*',\n                              re.I | re.S)\n        lines[:] = title_re.sub('', \"\\n\".join(lines)).split(\"\\n\")\n    else:\n        doc = get_doc_object(obj, what, \"\\n\".join(lines), config=cfg)\n        if sys.version_info[0] < 3:\n            lines[:] = unicode(doc).splitlines()\n        else:\n            lines[:] = str(doc).splitlines()\n\n    if app.config.numpydoc_edit_link and hasattr(obj, '__name__') and \\\n           obj.__name__:\n        if hasattr(obj, '__module__'):\n            v = dict(full_name=\"%s.%s\" % (obj.__module__, obj.__name__))\n        else:\n            v = dict(full_name=obj.__name__)\n        lines += [u'', u'.. htmlonly::', '']\n        lines += [u'    %s' % x for x in\n                  (app.config.numpydoc_edit_link % v).split(\"\\n\")]\n\n    # replace reference numbers so that there are no duplicates\n    references = []\n    for line in lines:\n        line = line.strip()\n        m = re.match(r'^.. \\[([a-z0-9_.-])\\]', line, re.I)\n        if m:\n            references.append(m.group(1))\n\n    # start renaming from the longest string, to avoid overwriting parts\n    references.sort(key=lambda x: -len(x))\n    if references:\n        for i, line in enumerate(lines):\n            for r in references:\n                if re.match(r'^\\d+$', r):\n                    new_r = \"R%d\" % (reference_offset[0] + int(r))\n                else:\n                    new_r = u\"%s%d\" % (r, reference_offset[0])\n                lines[i] = lines[i].replace(u'[%s]_' % r,\n                                            u'[%s]_' % new_r)\n                lines[i] = lines[i].replace(u'.. [%s]' % r,\n                                            u'.. [%s]' % new_r)\n\n    reference_offset[0] += len(references)",
  "def mangle_signature(app, what, name, obj,\n                     options, sig, retann):\n    # Do not try to inspect classes that don't define `__init__`\n    if (inspect.isclass(obj) and\n        (not hasattr(obj, '__init__') or\n        'initializes x; see ' in pydoc.getdoc(obj.__init__))):\n        return '', ''\n\n    if not (callable(obj) or hasattr(obj, '__argspec_is_invalid_')):\n        return\n    if not hasattr(obj, '__doc__'):\n        return\n\n    doc = SphinxDocString(pydoc.getdoc(obj))\n    if doc['Signature']:\n        sig = re.sub(\"^[^(]*\", \"\", doc['Signature'])\n        return sig, ''",
  "def setup(app, get_doc_object_=get_doc_object):\n    global get_doc_object\n    get_doc_object = get_doc_object_\n\n    if sys.version_info[0] < 3:\n        app.connect(b'autodoc-process-docstring', mangle_docstrings)\n        app.connect(b'autodoc-process-signature', mangle_signature)\n    else:\n        app.connect('autodoc-process-docstring', mangle_docstrings)\n        app.connect('autodoc-process-signature', mangle_signature)\n    app.add_config_value('numpydoc_edit_link', None, False)\n    app.add_config_value('numpydoc_use_plots', None, False)\n    app.add_config_value('numpydoc_show_class_members', True, True)\n\n    # Extra mangling domains\n    app.add_domain(NumpyPythonDomain)\n    app.add_domain(NumpyCDomain)",
  "class ManglingDomainBase(object):\n    directive_mangling_map = {}\n\n    def __init__(self, *a, **kw):\n        super(ManglingDomainBase, self).__init__(*a, **kw)\n        self.wrap_mangling_directives()\n\n    def wrap_mangling_directives(self):\n        for name, objtype in self.directive_mangling_map.items():\n            self.directives[name] = wrap_mangling_directive(\n                self.directives[name], objtype)",
  "class NumpyPythonDomain(ManglingDomainBase, PythonDomain):\n    name = 'np'\n    directive_mangling_map = {\n        'function': 'function',\n        'class': 'class',\n        'exception': 'class',\n        'method': 'function',\n        'classmethod': 'function',\n        'staticmethod': 'function',\n        'attribute': 'attribute',\n    }",
  "class NumpyCDomain(ManglingDomainBase, CDomain):\n    name = 'np-c'\n    directive_mangling_map = {\n        'function': 'function',\n        'member': 'attribute',\n        'macro': 'function',\n        'type': 'class',\n        'var': 'object',\n    }",
  "def wrap_mangling_directive(base_directive, objtype):\n    class directive(base_directive):\n        def run(self):\n            env = self.state.document.settings.env\n\n            name = None\n            if self.arguments:\n                m = re.match(r'^(.*\\s+)?(.*?)(\\(.*)?', self.arguments[0])\n                name = m.group(2).strip()\n\n            if not name:\n                name = self.arguments[0]\n\n            lines = list(self.content)\n            mangle_docstrings(env.app, objtype, name, None, None, lines)\n            # local import to avoid testing dependency\n            from docutils.statemachine import ViewList\n            self.content = ViewList(lines, self.content.parent)\n\n            return base_directive.run(self)\n\n    return directive",
  "def __init__(self, *a, **kw):\n        super(ManglingDomainBase, self).__init__(*a, **kw)\n        self.wrap_mangling_directives()",
  "def wrap_mangling_directives(self):\n        for name, objtype in self.directive_mangling_map.items():\n            self.directives[name] = wrap_mangling_directive(\n                self.directives[name], objtype)",
  "class directive(base_directive):\n        def run(self):\n            env = self.state.document.settings.env\n\n            name = None\n            if self.arguments:\n                m = re.match(r'^(.*\\s+)?(.*?)(\\(.*)?', self.arguments[0])\n                name = m.group(2).strip()\n\n            if not name:\n                name = self.arguments[0]\n\n            lines = list(self.content)\n            mangle_docstrings(env.app, objtype, name, None, None, lines)\n            # local import to avoid testing dependency\n            from docutils.statemachine import ViewList\n            self.content = ViewList(lines, self.content.parent)\n\n            return base_directive.run(self)",
  "def run(self):\n            env = self.state.document.settings.env\n\n            name = None\n            if self.arguments:\n                m = re.match(r'^(.*\\s+)?(.*?)(\\(.*)?', self.arguments[0])\n                name = m.group(2).strip()\n\n            if not name:\n                name = self.arguments[0]\n\n            lines = list(self.content)\n            mangle_docstrings(env.app, objtype, name, None, None, lines)\n            # local import to avoid testing dependency\n            from docutils.statemachine import ViewList\n            self.content = ViewList(lines, self.content.parent)\n\n            return base_directive.run(self)",
  "class SphinxDocString(NumpyDocString):\n    def __init__(self, docstring, config=None):\n        config = {} if config is None else config\n        self.use_plots = config.get('use_plots', False)\n        NumpyDocString.__init__(self, docstring, config=config)\n\n    # string conversion routines\n    def _str_header(self, name, symbol='`'):\n        return ['.. rubric:: ' + name, '']\n\n    def _str_field_list(self, name):\n        return [':' + name + ':']\n\n    def _str_indent(self, doc, indent=4):\n        out = []\n        for line in doc:\n            out += [' ' * indent + line]\n        return out\n\n    def _str_signature(self):\n        return ['']\n        if self['Signature']:\n            return ['``%s``' % self['Signature']] + ['']\n        else:\n            return ['']\n\n    def _str_summary(self):\n        return self['Summary'] + ['']\n\n    def _str_extended_summary(self):\n        return self['Extended Summary'] + ['']\n\n    def _str_param_list(self, name):\n        out = []\n        if self[name]:\n            out += self._str_field_list(name)\n            out += ['']\n            for param, param_type, desc in self[name]:\n                out += self._str_indent(['**%s** : %s' % (param.strip(),\n                                                          param_type)])\n                out += ['']\n                out += self._str_indent(desc, 8)\n                out += ['']\n        return out\n\n    @property\n    def _obj(self):\n        if hasattr(self, '_cls'):\n            return self._cls\n        elif hasattr(self, '_f'):\n            return self._f\n        return None\n\n    def _str_member_list(self, name):\n        \"\"\"\n        Generate a member listing, autosummary:: table where possible,\n        and a table where not.\n\n        \"\"\"\n        out = []\n        if self[name]:\n            out += ['.. rubric:: %s' % name, '']\n            prefix = getattr(self, '_name', '')\n\n            if prefix:\n                prefix = '~%s.' % prefix\n\n            autosum = []\n            others = []\n            for param, param_type, desc in self[name]:\n                param = param.strip()\n                if not self._obj or hasattr(self._obj, param):\n                    autosum += [\"   %s%s\" % (prefix, param)]\n                else:\n                    others.append((param, param_type, desc))\n\n            if autosum:\n                # GAEL: Toctree commented out below because it creates\n                # hundreds of sphinx warnings\n                # out += ['.. autosummary::', '   :toctree:', '']\n                out += ['.. autosummary::', '']\n                out += autosum\n\n            if others:\n                maxlen_0 = max([len(x[0]) for x in others])\n                maxlen_1 = max([len(x[1]) for x in others])\n                hdr = \"=\" * maxlen_0 + \"  \" + \"=\" * maxlen_1 + \"  \" + \"=\" * 10\n                fmt = '%%%ds  %%%ds  ' % (maxlen_0, maxlen_1)\n                n_indent = maxlen_0 + maxlen_1 + 4\n                out += [hdr]\n                for param, param_type, desc in others:\n                    out += [fmt % (param.strip(), param_type)]\n                    out += self._str_indent(desc, n_indent)\n                out += [hdr]\n            out += ['']\n        return out\n\n    def _str_section(self, name):\n        out = []\n        if self[name]:\n            out += self._str_header(name)\n            out += ['']\n            content = textwrap.dedent(\"\\n\".join(self[name])).split(\"\\n\")\n            out += content\n            out += ['']\n        return out\n\n    def _str_see_also(self, func_role):\n        out = []\n        if self['See Also']:\n            see_also = super(SphinxDocString, self)._str_see_also(func_role)\n            out = ['.. seealso::', '']\n            out += self._str_indent(see_also[2:])\n        return out\n\n    def _str_warnings(self):\n        out = []\n        if self['Warnings']:\n            out = ['.. warning::', '']\n            out += self._str_indent(self['Warnings'])\n        return out\n\n    def _str_index(self):\n        idx = self['index']\n        out = []\n        if len(idx) == 0:\n            return out\n\n        out += ['.. index:: %s' % idx.get('default', '')]\n        for section, references in idx.iteritems():\n            if section == 'default':\n                continue\n            elif section == 'refguide':\n                out += ['   single: %s' % (', '.join(references))]\n            else:\n                out += ['   %s: %s' % (section, ','.join(references))]\n        return out\n\n    def _str_references(self):\n        out = []\n        if self['References']:\n            out += self._str_header('References')\n            if isinstance(self['References'], str):\n                self['References'] = [self['References']]\n            out.extend(self['References'])\n            out += ['']\n            # Latex collects all references to a separate bibliography,\n            # so we need to insert links to it\n            import sphinx  # local import to avoid test dependency\n            if sphinx.__version__ >= \"0.6\":\n                out += ['.. only:: latex', '']\n            else:\n                out += ['.. latexonly::', '']\n            items = []\n            for line in self['References']:\n                m = re.match(r'.. \\[([a-z0-9._-]+)\\]', line, re.I)\n                if m:\n                    items.append(m.group(1))\n            out += ['   ' + \", \".join([\"[%s]_\" % item for item in items]), '']\n        return out\n\n    def _str_examples(self):\n        examples_str = \"\\n\".join(self['Examples'])\n\n        if (self.use_plots and 'import matplotlib' in examples_str\n                and 'plot::' not in examples_str):\n            out = []\n            out += self._str_header('Examples')\n            out += ['.. plot::', '']\n            out += self._str_indent(self['Examples'])\n            out += ['']\n            return out\n        else:\n            return self._str_section('Examples')\n\n    def __str__(self, indent=0, func_role=\"obj\"):\n        out = []\n        out += self._str_signature()\n        out += self._str_index() + ['']\n        out += self._str_summary()\n        out += self._str_extended_summary()\n        for param_list in ('Parameters', 'Returns', 'Raises', 'Attributes'):\n            out += self._str_param_list(param_list)\n        out += self._str_warnings()\n        out += self._str_see_also(func_role)\n        out += self._str_section('Notes')\n        out += self._str_references()\n        out += self._str_examples()\n        for param_list in ('Methods',):\n            out += self._str_member_list(param_list)\n        out = self._str_indent(out, indent)\n        return '\\n'.join(out)",
  "class SphinxFunctionDoc(SphinxDocString, FunctionDoc):\n    def __init__(self, obj, doc=None, config={}):\n        self.use_plots = config.get('use_plots', False)\n        FunctionDoc.__init__(self, obj, doc=doc, config=config)",
  "class SphinxClassDoc(SphinxDocString, ClassDoc):\n    def __init__(self, obj, doc=None, func_doc=None, config={}):\n        self.use_plots = config.get('use_plots', False)\n        ClassDoc.__init__(self, obj, doc=doc, func_doc=None, config=config)",
  "class SphinxObjDoc(SphinxDocString):\n    def __init__(self, obj, doc=None, config=None):\n        self._f = obj\n        SphinxDocString.__init__(self, doc, config=config)",
  "def get_doc_object(obj, what=None, doc=None, config={}):\n    if what is None:\n        if inspect.isclass(obj):\n            what = 'class'\n        elif inspect.ismodule(obj):\n            what = 'module'\n        elif callable(obj):\n            what = 'function'\n        else:\n            what = 'object'\n    if what == 'class':\n        return SphinxClassDoc(obj, func_doc=SphinxFunctionDoc, doc=doc,\n                              config=config)\n    elif what in ('function', 'method'):\n        return SphinxFunctionDoc(obj, doc=doc, config=config)\n    else:\n        if doc is None:\n            doc = pydoc.getdoc(obj)\n        return SphinxObjDoc(obj, doc, config=config)",
  "def __init__(self, docstring, config=None):\n        config = {} if config is None else config\n        self.use_plots = config.get('use_plots', False)\n        NumpyDocString.__init__(self, docstring, config=config)",
  "def _str_header(self, name, symbol='`'):\n        return ['.. rubric:: ' + name, '']",
  "def _str_field_list(self, name):\n        return [':' + name + ':']",
  "def _str_indent(self, doc, indent=4):\n        out = []\n        for line in doc:\n            out += [' ' * indent + line]\n        return out",
  "def _str_signature(self):\n        return ['']\n        if self['Signature']:\n            return ['``%s``' % self['Signature']] + ['']\n        else:\n            return ['']",
  "def _str_summary(self):\n        return self['Summary'] + ['']",
  "def _str_extended_summary(self):\n        return self['Extended Summary'] + ['']",
  "def _str_param_list(self, name):\n        out = []\n        if self[name]:\n            out += self._str_field_list(name)\n            out += ['']\n            for param, param_type, desc in self[name]:\n                out += self._str_indent(['**%s** : %s' % (param.strip(),\n                                                          param_type)])\n                out += ['']\n                out += self._str_indent(desc, 8)\n                out += ['']\n        return out",
  "def _obj(self):\n        if hasattr(self, '_cls'):\n            return self._cls\n        elif hasattr(self, '_f'):\n            return self._f\n        return None",
  "def _str_member_list(self, name):\n        \"\"\"\n        Generate a member listing, autosummary:: table where possible,\n        and a table where not.\n\n        \"\"\"\n        out = []\n        if self[name]:\n            out += ['.. rubric:: %s' % name, '']\n            prefix = getattr(self, '_name', '')\n\n            if prefix:\n                prefix = '~%s.' % prefix\n\n            autosum = []\n            others = []\n            for param, param_type, desc in self[name]:\n                param = param.strip()\n                if not self._obj or hasattr(self._obj, param):\n                    autosum += [\"   %s%s\" % (prefix, param)]\n                else:\n                    others.append((param, param_type, desc))\n\n            if autosum:\n                # GAEL: Toctree commented out below because it creates\n                # hundreds of sphinx warnings\n                # out += ['.. autosummary::', '   :toctree:', '']\n                out += ['.. autosummary::', '']\n                out += autosum\n\n            if others:\n                maxlen_0 = max([len(x[0]) for x in others])\n                maxlen_1 = max([len(x[1]) for x in others])\n                hdr = \"=\" * maxlen_0 + \"  \" + \"=\" * maxlen_1 + \"  \" + \"=\" * 10\n                fmt = '%%%ds  %%%ds  ' % (maxlen_0, maxlen_1)\n                n_indent = maxlen_0 + maxlen_1 + 4\n                out += [hdr]\n                for param, param_type, desc in others:\n                    out += [fmt % (param.strip(), param_type)]\n                    out += self._str_indent(desc, n_indent)\n                out += [hdr]\n            out += ['']\n        return out",
  "def _str_section(self, name):\n        out = []\n        if self[name]:\n            out += self._str_header(name)\n            out += ['']\n            content = textwrap.dedent(\"\\n\".join(self[name])).split(\"\\n\")\n            out += content\n            out += ['']\n        return out",
  "def _str_see_also(self, func_role):\n        out = []\n        if self['See Also']:\n            see_also = super(SphinxDocString, self)._str_see_also(func_role)\n            out = ['.. seealso::', '']\n            out += self._str_indent(see_also[2:])\n        return out",
  "def _str_warnings(self):\n        out = []\n        if self['Warnings']:\n            out = ['.. warning::', '']\n            out += self._str_indent(self['Warnings'])\n        return out",
  "def _str_index(self):\n        idx = self['index']\n        out = []\n        if len(idx) == 0:\n            return out\n\n        out += ['.. index:: %s' % idx.get('default', '')]\n        for section, references in idx.iteritems():\n            if section == 'default':\n                continue\n            elif section == 'refguide':\n                out += ['   single: %s' % (', '.join(references))]\n            else:\n                out += ['   %s: %s' % (section, ','.join(references))]\n        return out",
  "def _str_references(self):\n        out = []\n        if self['References']:\n            out += self._str_header('References')\n            if isinstance(self['References'], str):\n                self['References'] = [self['References']]\n            out.extend(self['References'])\n            out += ['']\n            # Latex collects all references to a separate bibliography,\n            # so we need to insert links to it\n            import sphinx  # local import to avoid test dependency\n            if sphinx.__version__ >= \"0.6\":\n                out += ['.. only:: latex', '']\n            else:\n                out += ['.. latexonly::', '']\n            items = []\n            for line in self['References']:\n                m = re.match(r'.. \\[([a-z0-9._-]+)\\]', line, re.I)\n                if m:\n                    items.append(m.group(1))\n            out += ['   ' + \", \".join([\"[%s]_\" % item for item in items]), '']\n        return out",
  "def _str_examples(self):\n        examples_str = \"\\n\".join(self['Examples'])\n\n        if (self.use_plots and 'import matplotlib' in examples_str\n                and 'plot::' not in examples_str):\n            out = []\n            out += self._str_header('Examples')\n            out += ['.. plot::', '']\n            out += self._str_indent(self['Examples'])\n            out += ['']\n            return out\n        else:\n            return self._str_section('Examples')",
  "def __str__(self, indent=0, func_role=\"obj\"):\n        out = []\n        out += self._str_signature()\n        out += self._str_index() + ['']\n        out += self._str_summary()\n        out += self._str_extended_summary()\n        for param_list in ('Parameters', 'Returns', 'Raises', 'Attributes'):\n            out += self._str_param_list(param_list)\n        out += self._str_warnings()\n        out += self._str_see_also(func_role)\n        out += self._str_section('Notes')\n        out += self._str_references()\n        out += self._str_examples()\n        for param_list in ('Methods',):\n            out += self._str_member_list(param_list)\n        out = self._str_indent(out, indent)\n        return '\\n'.join(out)",
  "def __init__(self, obj, doc=None, config={}):\n        self.use_plots = config.get('use_plots', False)\n        FunctionDoc.__init__(self, obj, doc=doc, config=config)",
  "def __init__(self, obj, doc=None, func_doc=None, config={}):\n        self.use_plots = config.get('use_plots', False)\n        ClassDoc.__init__(self, obj, doc=doc, func_doc=None, config=config)",
  "def __init__(self, obj, doc=None, config=None):\n        self._f = obj\n        SphinxDocString.__init__(self, doc, config=config)",
  "class Reader(object):\n    \"\"\"A line-based string reader.\n\n    \"\"\"\n    def __init__(self, data):\n        \"\"\"\n        Parameters\n        ----------\n        data : str\n           String with lines separated by '\\n'.\n\n        \"\"\"\n        if isinstance(data, list):\n            self._str = data\n        else:\n            self._str = data.split('\\n')  # store string as list of lines\n\n        self.reset()\n\n    def __getitem__(self, n):\n        return self._str[n]\n\n    def reset(self):\n        self._l = 0  # current line nr\n\n    def read(self):\n        if not self.eof():\n            out = self[self._l]\n            self._l += 1\n            return out\n        else:\n            return ''\n\n    def seek_next_non_empty_line(self):\n        for l in self[self._l:]:\n            if l.strip():\n                break\n            else:\n                self._l += 1\n\n    def eof(self):\n        return self._l >= len(self._str)\n\n    def read_to_condition(self, condition_func):\n        start = self._l\n        for line in self[start:]:\n            if condition_func(line):\n                return self[start:self._l]\n            self._l += 1\n            if self.eof():\n                return self[start:self._l + 1]\n        return []\n\n    def read_to_next_empty_line(self):\n        self.seek_next_non_empty_line()\n\n        def is_empty(line):\n            return not line.strip()\n        return self.read_to_condition(is_empty)\n\n    def read_to_next_unindented_line(self):\n        def is_unindented(line):\n            return (line.strip() and (len(line.lstrip()) == len(line)))\n        return self.read_to_condition(is_unindented)\n\n    def peek(self, n=0):\n        if self._l + n < len(self._str):\n            return self[self._l + n]\n        else:\n            return ''\n\n    def is_empty(self):\n        return not ''.join(self._str).strip()",
  "class NumpyDocString(object):\n    def __init__(self, docstring, config={}):\n        docstring = textwrap.dedent(docstring).split('\\n')\n\n        self._doc = Reader(docstring)\n        self._parsed_data = {\n            'Signature': '',\n            'Summary': [''],\n            'Extended Summary': [],\n            'Parameters': [],\n            'Returns': [],\n            'Raises': [],\n            'Warns': [],\n            'Other Parameters': [],\n            'Attributes': [],\n            'Methods': [],\n            'See Also': [],\n            'Notes': [],\n            'Warnings': [],\n            'References': '',\n            'Examples': '',\n            'index': {}\n            }\n\n        self._parse()\n\n    def __getitem__(self, key):\n        return self._parsed_data[key]\n\n    def __setitem__(self, key, val):\n        if key not in self._parsed_data:\n            warn(\"Unknown section %s\" % key)\n        else:\n            self._parsed_data[key] = val\n\n    def _is_at_section(self):\n        self._doc.seek_next_non_empty_line()\n\n        if self._doc.eof():\n            return False\n\n        l1 = self._doc.peek().strip()  # e.g. Parameters\n\n        if l1.startswith('.. index::'):\n            return True\n\n        l2 = self._doc.peek(1).strip()   # ---------- or ==========\n        return l2.startswith('-' * len(l1)) or l2.startswith('=' * len(l1))\n\n    def _strip(self, doc):\n        i = 0\n        j = 0\n        for i, line in enumerate(doc):\n            if line.strip():\n                break\n\n        for j, line in enumerate(doc[::-1]):\n            if line.strip():\n                break\n\n        return doc[i:len(doc) - j]\n\n    def _read_to_next_section(self):\n        section = self._doc.read_to_next_empty_line()\n\n        while not self._is_at_section() and not self._doc.eof():\n            if not self._doc.peek(-1).strip():  # previous line was empty\n                section += ['']\n\n            section += self._doc.read_to_next_empty_line()\n\n        return section\n\n    def _read_sections(self):\n        while not self._doc.eof():\n            data = self._read_to_next_section()\n            name = data[0].strip()\n\n            if name.startswith('..'):  # index section\n                yield name, data[1:]\n            elif len(data) < 2:\n                yield StopIteration\n            else:\n                yield name, self._strip(data[2:])\n\n    def _parse_param_list(self, content):\n        r = Reader(content)\n        params = []\n        while not r.eof():\n            header = r.read().strip()\n            if ' : ' in header:\n                arg_name, arg_type = header.split(' : ')[:2]\n            else:\n                arg_name, arg_type = header, ''\n\n            desc = r.read_to_next_unindented_line()\n            desc = dedent_lines(desc)\n\n            params.append((arg_name, arg_type, desc))\n\n        return params\n\n    _name_rgx = re.compile(r\"^\\s*(:(?P<role>\\w+):`(?P<name>[a-zA-Z0-9_.-]+)`|\"\n                           r\" (?P<name2>[a-zA-Z0-9_.-]+))\\s*\", re.X)\n\n    def _parse_see_also(self, content):\n        \"\"\"\n        func_name : Descriptive text\n            continued text\n        another_func_name : Descriptive text\n        func_name1, func_name2, :meth:`func_name`, func_name3\n\n        \"\"\"\n        items = []\n\n        def parse_item_name(text):\n            \"\"\"Match ':role:`name`' or 'name'\"\"\"\n            m = self._name_rgx.match(text)\n            if m:\n                g = m.groups()\n                if g[1] is None:\n                    return g[3], None\n                else:\n                    return g[2], g[1]\n            raise ValueError(\"%s is not a item name\" % text)\n\n        def push_item(name, rest):\n            if not name:\n                return\n            name, role = parse_item_name(name)\n            items.append((name, list(rest), role))\n            del rest[:]\n\n        current_func = None\n        rest = []\n\n        for line in content:\n            if not line.strip():\n                continue\n\n            m = self._name_rgx.match(line)\n            if m and line[m.end():].strip().startswith(':'):\n                push_item(current_func, rest)\n                current_func, line = line[:m.end()], line[m.end():]\n                rest = [line.split(':', 1)[1].strip()]\n                if not rest[0]:\n                    rest = []\n            elif not line.startswith(' '):\n                push_item(current_func, rest)\n                current_func = None\n                if ',' in line:\n                    for func in line.split(','):\n                        push_item(func, [])\n                elif line.strip():\n                    current_func = line\n            elif current_func is not None:\n                rest.append(line.strip())\n        push_item(current_func, rest)\n        return items\n\n    def _parse_index(self, section, content):\n        \"\"\"\n        .. index: default\n           :refguide: something, else, and more\n\n        \"\"\"\n        def strip_each_in(lst):\n            return [s.strip() for s in lst]\n\n        out = {}\n        section = section.split('::')\n        if len(section) > 1:\n            out['default'] = strip_each_in(section[1].split(','))[0]\n        for line in content:\n            line = line.split(':')\n            if len(line) > 2:\n                out[line[1]] = strip_each_in(line[2].split(','))\n        return out\n\n    def _parse_summary(self):\n        \"\"\"Grab signature (if given) and summary\"\"\"\n        if self._is_at_section():\n            return\n\n        summary = self._doc.read_to_next_empty_line()\n        summary_str = \" \".join([s.strip() for s in summary]).strip()\n        if re.compile('^([\\w., ]+=)?\\s*[\\w\\.]+\\(.*\\)$').match(summary_str):\n            self['Signature'] = summary_str\n            if not self._is_at_section():\n                self['Summary'] = self._doc.read_to_next_empty_line()\n        else:\n            self['Summary'] = summary\n\n        if not self._is_at_section():\n            self['Extended Summary'] = self._read_to_next_section()\n\n    def _parse(self):\n        self._doc.reset()\n        self._parse_summary()\n\n        for (section, content) in self._read_sections():\n            if not section.startswith('..'):\n                section = ' '.join([s.capitalize()\n                                    for s in section.split(' ')])\n            if section in ('Parameters', 'Attributes', 'Methods',\n                           'Returns', 'Raises', 'Warns'):\n                self[section] = self._parse_param_list(content)\n            elif section.startswith('.. index::'):\n                self['index'] = self._parse_index(section, content)\n            elif section == 'See Also':\n                self['See Also'] = self._parse_see_also(content)\n            else:\n                self[section] = content\n\n    # string conversion routines\n\n    def _str_header(self, name, symbol='-'):\n        return [name, len(name) * symbol]\n\n    def _str_indent(self, doc, indent=4):\n        out = []\n        for line in doc:\n            out += [' ' * indent + line]\n        return out\n\n    def _str_signature(self):\n        if self['Signature']:\n            return [self['Signature'].replace('*', '\\*')] + ['']\n        else:\n            return ['']\n\n    def _str_summary(self):\n        if self['Summary']:\n            return self['Summary'] + ['']\n        else:\n            return []\n\n    def _str_extended_summary(self):\n        if self['Extended Summary']:\n            return self['Extended Summary'] + ['']\n        else:\n            return []\n\n    def _str_param_list(self, name):\n        out = []\n        if self[name]:\n            out += self._str_header(name)\n            for param, param_type, desc in self[name]:\n                out += ['%s : %s' % (param, param_type)]\n                out += self._str_indent(desc)\n            out += ['']\n        return out\n\n    def _str_section(self, name):\n        out = []\n        if self[name]:\n            out += self._str_header(name)\n            out += self[name]\n            out += ['']\n        return out\n\n    def _str_see_also(self, func_role):\n        if not self['See Also']:\n            return []\n        out = []\n        out += self._str_header(\"See Also\")\n        last_had_desc = True\n        for func, desc, role in self['See Also']:\n            if role:\n                link = ':%s:`%s`' % (role, func)\n            elif func_role:\n                link = ':%s:`%s`' % (func_role, func)\n            else:\n                link = \"`%s`_\" % func\n            if desc or last_had_desc:\n                out += ['']\n                out += [link]\n            else:\n                out[-1] += \", %s\" % link\n            if desc:\n                out += self._str_indent([' '.join(desc)])\n                last_had_desc = True\n            else:\n                last_had_desc = False\n        out += ['']\n        return out\n\n    def _str_index(self):\n        idx = self['index']\n        out = []\n        out += ['.. index:: %s' % idx.get('default', '')]\n        for section, references in idx.iteritems():\n            if section == 'default':\n                continue\n            out += ['   :%s: %s' % (section, ', '.join(references))]\n        return out\n\n    def __str__(self, func_role=''):\n        out = []\n        out += self._str_signature()\n        out += self._str_summary()\n        out += self._str_extended_summary()\n        for param_list in ('Parameters', 'Returns', 'Raises'):\n            out += self._str_param_list(param_list)\n        out += self._str_section('Warnings')\n        out += self._str_see_also(func_role)\n        for s in ('Notes', 'References', 'Examples'):\n            out += self._str_section(s)\n        for param_list in ('Attributes', 'Methods'):\n            out += self._str_param_list(param_list)\n        out += self._str_index()\n        return '\\n'.join(out)",
  "def indent(str, indent=4):\n    indent_str = ' ' * indent\n    if str is None:\n        return indent_str\n    lines = str.split('\\n')\n    return '\\n'.join(indent_str + l for l in lines)",
  "def dedent_lines(lines):\n    \"\"\"Deindent a list of lines maximally\"\"\"\n    return textwrap.dedent(\"\\n\".join(lines)).split(\"\\n\")",
  "def header(text, style='-'):\n    return text + '\\n' + style * len(text) + '\\n'",
  "class FunctionDoc(NumpyDocString):\n    def __init__(self, func, role='func', doc=None, config={}):\n        self._f = func\n        self._role = role  # e.g. \"func\" or \"meth\"\n\n        if doc is None:\n            if func is None:\n                raise ValueError(\"No function or docstring given\")\n            doc = inspect.getdoc(func) or ''\n        NumpyDocString.__init__(self, doc)\n\n        if not self['Signature'] and func is not None:\n            func, func_name = self.get_func()\n            try:\n                # try to read signature\n                argspec = inspect.getargspec(func)\n                argspec = inspect.formatargspec(*argspec)\n                argspec = argspec.replace('*', '\\*')\n                signature = '%s%s' % (func_name, argspec)\n            except TypeError as e:\n                signature = '%s()' % func_name\n            self['Signature'] = signature\n\n    def get_func(self):\n        func_name = getattr(self._f, '__name__', self.__class__.__name__)\n        if inspect.isclass(self._f):\n            func = getattr(self._f, '__call__', self._f.__init__)\n        else:\n            func = self._f\n        return func, func_name\n\n    def __str__(self):\n        out = ''\n\n        func, func_name = self.get_func()\n        signature = self['Signature'].replace('*', '\\*')\n\n        roles = {'func': 'function',\n                 'meth': 'method'}\n\n        if self._role:\n            if not roles.has_key(self._role):\n                print(\"Warning: invalid role %s\" % self._role)\n            out += '.. %s:: %s\\n    \\n\\n' % (roles.get(self._role, ''),\n                                             func_name)\n\n        out += super(FunctionDoc, self).__str__(func_role=self._role)\n        return out",
  "class ClassDoc(NumpyDocString):\n    def __init__(self, cls, doc=None, modulename='', func_doc=FunctionDoc,\n                 config=None):\n        if not inspect.isclass(cls) and cls is not None:\n            raise ValueError(\"Expected a class or None, but got %r\" % cls)\n        self._cls = cls\n\n        if modulename and not modulename.endswith('.'):\n            modulename += '.'\n        self._mod = modulename\n\n        if doc is None:\n            if cls is None:\n                raise ValueError(\"No class or documentation string given\")\n            doc = pydoc.getdoc(cls)\n\n        NumpyDocString.__init__(self, doc)\n\n        if config is not None and config.get('show_class_members', True):\n            if not self['Methods']:\n                self['Methods'] = [(name, '', '')\n                                   for name in sorted(self.methods)]\n            if not self['Attributes']:\n                self['Attributes'] = [(name, '', '')\n                                      for name in sorted(self.properties)]\n\n    @property\n    def methods(self):\n        if self._cls is None:\n            return []\n        return [name for name, func in inspect.getmembers(self._cls)\n                if not name.startswith('_') and callable(func)]\n\n    @property\n    def properties(self):\n        if self._cls is None:\n            return []\n        return [name for name, func in inspect.getmembers(self._cls)\n                if not name.startswith('_') and func is None]",
  "def __init__(self, data):\n        \"\"\"\n        Parameters\n        ----------\n        data : str\n           String with lines separated by '\\n'.\n\n        \"\"\"\n        if isinstance(data, list):\n            self._str = data\n        else:\n            self._str = data.split('\\n')  # store string as list of lines\n\n        self.reset()",
  "def __getitem__(self, n):\n        return self._str[n]",
  "def reset(self):\n        self._l = 0",
  "def read(self):\n        if not self.eof():\n            out = self[self._l]\n            self._l += 1\n            return out\n        else:\n            return ''",
  "def seek_next_non_empty_line(self):\n        for l in self[self._l:]:\n            if l.strip():\n                break\n            else:\n                self._l += 1",
  "def eof(self):\n        return self._l >= len(self._str)",
  "def read_to_condition(self, condition_func):\n        start = self._l\n        for line in self[start:]:\n            if condition_func(line):\n                return self[start:self._l]\n            self._l += 1\n            if self.eof():\n                return self[start:self._l + 1]\n        return []",
  "def read_to_next_empty_line(self):\n        self.seek_next_non_empty_line()\n\n        def is_empty(line):\n            return not line.strip()\n        return self.read_to_condition(is_empty)",
  "def read_to_next_unindented_line(self):\n        def is_unindented(line):\n            return (line.strip() and (len(line.lstrip()) == len(line)))\n        return self.read_to_condition(is_unindented)",
  "def peek(self, n=0):\n        if self._l + n < len(self._str):\n            return self[self._l + n]\n        else:\n            return ''",
  "def is_empty(self):\n        return not ''.join(self._str).strip()",
  "def __init__(self, docstring, config={}):\n        docstring = textwrap.dedent(docstring).split('\\n')\n\n        self._doc = Reader(docstring)\n        self._parsed_data = {\n            'Signature': '',\n            'Summary': [''],\n            'Extended Summary': [],\n            'Parameters': [],\n            'Returns': [],\n            'Raises': [],\n            'Warns': [],\n            'Other Parameters': [],\n            'Attributes': [],\n            'Methods': [],\n            'See Also': [],\n            'Notes': [],\n            'Warnings': [],\n            'References': '',\n            'Examples': '',\n            'index': {}\n            }\n\n        self._parse()",
  "def __getitem__(self, key):\n        return self._parsed_data[key]",
  "def __setitem__(self, key, val):\n        if key not in self._parsed_data:\n            warn(\"Unknown section %s\" % key)\n        else:\n            self._parsed_data[key] = val",
  "def _is_at_section(self):\n        self._doc.seek_next_non_empty_line()\n\n        if self._doc.eof():\n            return False\n\n        l1 = self._doc.peek().strip()  # e.g. Parameters\n\n        if l1.startswith('.. index::'):\n            return True\n\n        l2 = self._doc.peek(1).strip()   # ---------- or ==========\n        return l2.startswith('-' * len(l1)) or l2.startswith('=' * len(l1))",
  "def _strip(self, doc):\n        i = 0\n        j = 0\n        for i, line in enumerate(doc):\n            if line.strip():\n                break\n\n        for j, line in enumerate(doc[::-1]):\n            if line.strip():\n                break\n\n        return doc[i:len(doc) - j]",
  "def _read_to_next_section(self):\n        section = self._doc.read_to_next_empty_line()\n\n        while not self._is_at_section() and not self._doc.eof():\n            if not self._doc.peek(-1).strip():  # previous line was empty\n                section += ['']\n\n            section += self._doc.read_to_next_empty_line()\n\n        return section",
  "def _read_sections(self):\n        while not self._doc.eof():\n            data = self._read_to_next_section()\n            name = data[0].strip()\n\n            if name.startswith('..'):  # index section\n                yield name, data[1:]\n            elif len(data) < 2:\n                yield StopIteration\n            else:\n                yield name, self._strip(data[2:])",
  "def _parse_param_list(self, content):\n        r = Reader(content)\n        params = []\n        while not r.eof():\n            header = r.read().strip()\n            if ' : ' in header:\n                arg_name, arg_type = header.split(' : ')[:2]\n            else:\n                arg_name, arg_type = header, ''\n\n            desc = r.read_to_next_unindented_line()\n            desc = dedent_lines(desc)\n\n            params.append((arg_name, arg_type, desc))\n\n        return params",
  "def _parse_see_also(self, content):\n        \"\"\"\n        func_name : Descriptive text\n            continued text\n        another_func_name : Descriptive text\n        func_name1, func_name2, :meth:`func_name`, func_name3\n\n        \"\"\"\n        items = []\n\n        def parse_item_name(text):\n            \"\"\"Match ':role:`name`' or 'name'\"\"\"\n            m = self._name_rgx.match(text)\n            if m:\n                g = m.groups()\n                if g[1] is None:\n                    return g[3], None\n                else:\n                    return g[2], g[1]\n            raise ValueError(\"%s is not a item name\" % text)\n\n        def push_item(name, rest):\n            if not name:\n                return\n            name, role = parse_item_name(name)\n            items.append((name, list(rest), role))\n            del rest[:]\n\n        current_func = None\n        rest = []\n\n        for line in content:\n            if not line.strip():\n                continue\n\n            m = self._name_rgx.match(line)\n            if m and line[m.end():].strip().startswith(':'):\n                push_item(current_func, rest)\n                current_func, line = line[:m.end()], line[m.end():]\n                rest = [line.split(':', 1)[1].strip()]\n                if not rest[0]:\n                    rest = []\n            elif not line.startswith(' '):\n                push_item(current_func, rest)\n                current_func = None\n                if ',' in line:\n                    for func in line.split(','):\n                        push_item(func, [])\n                elif line.strip():\n                    current_func = line\n            elif current_func is not None:\n                rest.append(line.strip())\n        push_item(current_func, rest)\n        return items",
  "def _parse_index(self, section, content):\n        \"\"\"\n        .. index: default\n           :refguide: something, else, and more\n\n        \"\"\"\n        def strip_each_in(lst):\n            return [s.strip() for s in lst]\n\n        out = {}\n        section = section.split('::')\n        if len(section) > 1:\n            out['default'] = strip_each_in(section[1].split(','))[0]\n        for line in content:\n            line = line.split(':')\n            if len(line) > 2:\n                out[line[1]] = strip_each_in(line[2].split(','))\n        return out",
  "def _parse_summary(self):\n        \"\"\"Grab signature (if given) and summary\"\"\"\n        if self._is_at_section():\n            return\n\n        summary = self._doc.read_to_next_empty_line()\n        summary_str = \" \".join([s.strip() for s in summary]).strip()\n        if re.compile('^([\\w., ]+=)?\\s*[\\w\\.]+\\(.*\\)$').match(summary_str):\n            self['Signature'] = summary_str\n            if not self._is_at_section():\n                self['Summary'] = self._doc.read_to_next_empty_line()\n        else:\n            self['Summary'] = summary\n\n        if not self._is_at_section():\n            self['Extended Summary'] = self._read_to_next_section()",
  "def _parse(self):\n        self._doc.reset()\n        self._parse_summary()\n\n        for (section, content) in self._read_sections():\n            if not section.startswith('..'):\n                section = ' '.join([s.capitalize()\n                                    for s in section.split(' ')])\n            if section in ('Parameters', 'Attributes', 'Methods',\n                           'Returns', 'Raises', 'Warns'):\n                self[section] = self._parse_param_list(content)\n            elif section.startswith('.. index::'):\n                self['index'] = self._parse_index(section, content)\n            elif section == 'See Also':\n                self['See Also'] = self._parse_see_also(content)\n            else:\n                self[section] = content",
  "def _str_header(self, name, symbol='-'):\n        return [name, len(name) * symbol]",
  "def _str_indent(self, doc, indent=4):\n        out = []\n        for line in doc:\n            out += [' ' * indent + line]\n        return out",
  "def _str_signature(self):\n        if self['Signature']:\n            return [self['Signature'].replace('*', '\\*')] + ['']\n        else:\n            return ['']",
  "def _str_summary(self):\n        if self['Summary']:\n            return self['Summary'] + ['']\n        else:\n            return []",
  "def _str_extended_summary(self):\n        if self['Extended Summary']:\n            return self['Extended Summary'] + ['']\n        else:\n            return []",
  "def _str_param_list(self, name):\n        out = []\n        if self[name]:\n            out += self._str_header(name)\n            for param, param_type, desc in self[name]:\n                out += ['%s : %s' % (param, param_type)]\n                out += self._str_indent(desc)\n            out += ['']\n        return out",
  "def _str_section(self, name):\n        out = []\n        if self[name]:\n            out += self._str_header(name)\n            out += self[name]\n            out += ['']\n        return out",
  "def _str_see_also(self, func_role):\n        if not self['See Also']:\n            return []\n        out = []\n        out += self._str_header(\"See Also\")\n        last_had_desc = True\n        for func, desc, role in self['See Also']:\n            if role:\n                link = ':%s:`%s`' % (role, func)\n            elif func_role:\n                link = ':%s:`%s`' % (func_role, func)\n            else:\n                link = \"`%s`_\" % func\n            if desc or last_had_desc:\n                out += ['']\n                out += [link]\n            else:\n                out[-1] += \", %s\" % link\n            if desc:\n                out += self._str_indent([' '.join(desc)])\n                last_had_desc = True\n            else:\n                last_had_desc = False\n        out += ['']\n        return out",
  "def _str_index(self):\n        idx = self['index']\n        out = []\n        out += ['.. index:: %s' % idx.get('default', '')]\n        for section, references in idx.iteritems():\n            if section == 'default':\n                continue\n            out += ['   :%s: %s' % (section, ', '.join(references))]\n        return out",
  "def __str__(self, func_role=''):\n        out = []\n        out += self._str_signature()\n        out += self._str_summary()\n        out += self._str_extended_summary()\n        for param_list in ('Parameters', 'Returns', 'Raises'):\n            out += self._str_param_list(param_list)\n        out += self._str_section('Warnings')\n        out += self._str_see_also(func_role)\n        for s in ('Notes', 'References', 'Examples'):\n            out += self._str_section(s)\n        for param_list in ('Attributes', 'Methods'):\n            out += self._str_param_list(param_list)\n        out += self._str_index()\n        return '\\n'.join(out)",
  "def __init__(self, func, role='func', doc=None, config={}):\n        self._f = func\n        self._role = role  # e.g. \"func\" or \"meth\"\n\n        if doc is None:\n            if func is None:\n                raise ValueError(\"No function or docstring given\")\n            doc = inspect.getdoc(func) or ''\n        NumpyDocString.__init__(self, doc)\n\n        if not self['Signature'] and func is not None:\n            func, func_name = self.get_func()\n            try:\n                # try to read signature\n                argspec = inspect.getargspec(func)\n                argspec = inspect.formatargspec(*argspec)\n                argspec = argspec.replace('*', '\\*')\n                signature = '%s%s' % (func_name, argspec)\n            except TypeError as e:\n                signature = '%s()' % func_name\n            self['Signature'] = signature",
  "def get_func(self):\n        func_name = getattr(self._f, '__name__', self.__class__.__name__)\n        if inspect.isclass(self._f):\n            func = getattr(self._f, '__call__', self._f.__init__)\n        else:\n            func = self._f\n        return func, func_name",
  "def __str__(self):\n        out = ''\n\n        func, func_name = self.get_func()\n        signature = self['Signature'].replace('*', '\\*')\n\n        roles = {'func': 'function',\n                 'meth': 'method'}\n\n        if self._role:\n            if not roles.has_key(self._role):\n                print(\"Warning: invalid role %s\" % self._role)\n            out += '.. %s:: %s\\n    \\n\\n' % (roles.get(self._role, ''),\n                                             func_name)\n\n        out += super(FunctionDoc, self).__str__(func_role=self._role)\n        return out",
  "def __init__(self, cls, doc=None, modulename='', func_doc=FunctionDoc,\n                 config=None):\n        if not inspect.isclass(cls) and cls is not None:\n            raise ValueError(\"Expected a class or None, but got %r\" % cls)\n        self._cls = cls\n\n        if modulename and not modulename.endswith('.'):\n            modulename += '.'\n        self._mod = modulename\n\n        if doc is None:\n            if cls is None:\n                raise ValueError(\"No class or documentation string given\")\n            doc = pydoc.getdoc(cls)\n\n        NumpyDocString.__init__(self, doc)\n\n        if config is not None and config.get('show_class_members', True):\n            if not self['Methods']:\n                self['Methods'] = [(name, '', '')\n                                   for name in sorted(self.methods)]\n            if not self['Attributes']:\n                self['Attributes'] = [(name, '', '')\n                                      for name in sorted(self.properties)]",
  "def methods(self):\n        if self._cls is None:\n            return []\n        return [name for name, func in inspect.getmembers(self._cls)\n                if not name.startswith('_') and callable(func)]",
  "def properties(self):\n        if self._cls is None:\n            return []\n        return [name for name, func in inspect.getmembers(self._cls)\n                if not name.startswith('_') and func is None]",
  "def is_empty(line):\n            return not line.strip()",
  "def is_unindented(line):\n            return (line.strip() and (len(line.lstrip()) == len(line)))",
  "def parse_item_name(text):\n            \"\"\"Match ':role:`name`' or 'name'\"\"\"\n            m = self._name_rgx.match(text)\n            if m:\n                g = m.groups()\n                if g[1] is None:\n                    return g[3], None\n                else:\n                    return g[2], g[1]\n            raise ValueError(\"%s is not a item name\" % text)",
  "def push_item(name, rest):\n            if not name:\n                return\n            name, role = parse_item_name(name)\n            items.append((name, list(rest), role))\n            del rest[:]",
  "def strip_each_in(lst):\n            return [s.strip() for s in lst]",
  "class Keyboard(object):\n    \"\"\"Retrieve presses from various devices.\n\n    Public metohds:\n        __init__\n        listen_presses\n        get_presses\n        wait_one_press\n        wait_for_presses\n        check_force_quit\n\n    Methods to override by subclasses:\n        _get_timebase\n        _clear_events\n        _retrieve_events\n    \"\"\"\n\n    def __init__(self, ec, force_quit_keys):\n        self.master_clock = ec._master_clock\n        self.log_presses = ec._log_presses\n        self.force_quit_keys = force_quit_keys\n        self.listen_start = None\n        ec._time_correction_fxns['keypress'] = self._get_timebase\n        self.get_time_corr = partial(ec._get_time_correction, 'keypress')\n        self.time_correction = self.get_time_corr()\n        self.win = ec._win\n        # always init pyglet response handler for error (and non-error) keys\n        self.win.on_key_press = self._on_pyglet_keypress\n        self._keyboard_buffer = []\n\n    ###########################################################################\n    # Methods to be overridden by subclasses\n    def _clear_events(self):\n        self._clear_keyboard_events()\n\n    def _retrieve_events(self, live_keys):\n        return self._retrieve_keyboard_events(live_keys)\n\n    def _get_timebase(self):\n        \"\"\"Get keyboard time reference (in seconds)\n        \"\"\"\n        return clock()\n\n    def _clear_keyboard_events(self):\n        self.win.dispatch_events()\n        self._keyboard_buffer = []\n\n    def _retrieve_keyboard_events(self, live_keys):\n        # add escape keys\n        if live_keys is not None:\n            live_keys = [str(x) for x in live_keys]  # accept ints\n            live_keys.extend(self.force_quit_keys)\n        self.win.dispatch_events()  # pump events on pyglet windows\n        targets = []\n        for key in self._keyboard_buffer:\n            if live_keys is None or key[0] in live_keys:\n                targets.append(key)\n        return targets\n\n    def _on_pyglet_keypress(self, symbol, modifiers, emulated=False):\n        \"\"\"Handler for on_key_press pyglet events\"\"\"\n        key_time = clock()\n        if emulated:\n            this_key = str(symbol)\n        else:\n            from pyglet.window import key\n            this_key = key.symbol_string(symbol).lower()\n            this_key = this_key.lstrip('_').lstrip('NUM_')\n        self._keyboard_buffer.append((this_key, key_time))\n\n    def listen_presses(self):\n        \"\"\"Start listening for keypresses.\n        \"\"\"\n        self.time_correction = self.get_time_corr()\n        self.listen_start = self.master_clock()\n        self._clear_events()\n\n    def get_presses(self, live_keys, timestamp, relative_to):\n        \"\"\"Get the current entire keyboard / button box buffer.\n        \"\"\"\n        pressed = []\n        if timestamp and relative_to is None:\n            if self.listen_start is None:\n                raise ValueError('I cannot timestamp: relative_to is None and '\n                                 'you have not yet called listen_presses.')\n            else:\n                relative_to = self.listen_start\n        pressed = self._retrieve_events(live_keys)\n        return self._correct_presses(pressed, timestamp, relative_to)\n\n    def wait_one_press(self, max_wait, min_wait, live_keys,\n                       timestamp, relative_to):\n        \"\"\"Returns only the first button pressed after min_wait.\n        \"\"\"\n        relative_to, start_time = self._init_wait_press(max_wait, min_wait,\n                                                        live_keys, timestamp,\n                                                        relative_to)\n        pressed = []\n        while (not len(pressed) and\n               self.master_clock() - start_time < max_wait):\n            pressed = self._retrieve_events(live_keys)\n\n        # handle non-presses\n        if len(pressed):\n            pressed = self._correct_presses(pressed, timestamp, relative_to)[0]\n        elif timestamp:\n            pressed = (None, None)\n        else:\n            pressed = None\n        return pressed\n\n    def wait_for_presses(self, max_wait, min_wait, live_keys,\n                         timestamp, relative_to):\n        \"\"\"Returns all button presses between min_wait and max_wait.\n        \"\"\"\n        relative_to, start_time = self._init_wait_press(max_wait, min_wait,\n                                                        live_keys, timestamp,\n                                                        relative_to)\n        pressed = []\n        while (self.master_clock() - start_time < max_wait):\n            pressed = self._retrieve_events(live_keys)\n        return self._correct_presses(pressed, timestamp, relative_to)\n\n    def check_force_quit(self, keys=None):\n        \"\"\"Compare key buffer to list of force-quit keys and quit if matched.\n\n        This function always uses the keyboard, so is part of abstraction.\n        \"\"\"\n        if keys is None:\n            # only grab the force-quit keys\n            keys = self._retrieve_keyboard_events([])\n        else:\n            if isinstance(keys, string_types):\n                keys = [keys]\n            if isinstance(keys, list):\n                keys = [k for k in keys if k in self.force_quit_keys]\n            else:\n                raise TypeError('Force quit checking requires a string or '\n                                ' list of strings, not a {}.'\n                                ''.format(type(keys)))\n        if len(keys):\n            raise RuntimeError('Quit key pressed')\n\n    def _correct_presses(self, pressed, timestamp, relative_to):\n        \"\"\"Correct timing of presses and check for quit press\"\"\"\n        if len(pressed):\n            pressed = [(k, s + self.time_correction) for k, s in pressed]\n            self.log_presses(pressed)\n            keys = [k for k, _ in pressed]\n            self.check_force_quit(keys)\n            if timestamp:\n                pressed = [(k, s - relative_to) for k, s in pressed]\n            else:\n                pressed = keys\n        return pressed\n\n    def _init_wait_press(self, max_wait, min_wait, live_keys, timestamp,\n                         relative_to):\n        \"\"\"Actions common to ``wait_one_press`` and ``wait_for_presses``\n        \"\"\"\n        if np.isinf(max_wait) and live_keys == []:\n            raise ValueError('max_wait cannot be infinite if there are no live'\n                             ' keys.')\n        if not min_wait <= max_wait:\n            raise ValueError('min_wait must be less than max_wait')\n        start_time = self.master_clock()\n        if timestamp and relative_to is None:\n            relative_to = start_time\n        wait_secs(min_wait)\n        self.check_force_quit()\n        self._clear_events()\n        return relative_to, start_time",
  "class Mouse(object):\n    \"\"\"Class to track mouse properties and events\n\n    Parameters\n    ----------\n    ec : instance of ``ExperimentController``\n        The controller for the current experiment\n    visible : bool\n        Initial mouse visibility.\n\n    Public metohds:\n        __init__\n        set_visible\n        listen_clicks\n        get_clicks\n        wait_one_click\n        wait_for_clicks\n\n    Methods to override by subclasses:\n        _get_timebase\n        _clear_events\n        _retrieve_events\n    \"\"\"\n\n    def __init__(self, ec, visible=False):\n        from pyglet.window import mouse\n        self.win = ec._win\n        self.set_visible(visible)\n        self.master_clock = ec._master_clock\n        self.log_clicks = ec._log_clicks\n        self.listen_start = None\n        ec._time_correction_fxns['mouseclick'] = self._get_timebase\n        self.get_time_corr = partial(ec._get_time_correction, 'mouseclick')\n        self.time_correction = self.get_time_corr()\n        self.win = ec._win\n        self._check_force_quit = ec.check_force_quit\n        self.win.on_mouse_press = self._on_pyglet_mouse_click\n        self._mouse_buffer = []\n        self._button_names = {mouse.LEFT: 'left', mouse.MIDDLE: 'middle',\n                              mouse.RIGHT: 'right'}\n        self._button_ids = {'left': mouse.LEFT, 'middle': mouse.MIDDLE,\n                            'right': mouse.RIGHT}\n        self._legal_types = (Rectangle, Circle)\n\n    def set_visible(self, visible):\n        \"\"\"Sets the visibility of the mouse\n\n        Parameters\n        ----------\n        visible : bool\n            If True, make mouse visible.\n        \"\"\"\n        self.win.set_mouse_visible(visible)\n        self.win.set_mouse_platform_visible(visible)  # Pyglet workaround\n        self._visible = visible\n\n    @property\n    def visible(self):\n        \"\"\"Mouse visibility\"\"\"\n        return self._visible\n\n    @property\n    def pos(self):\n        \"\"\"The current position of the mouse in normalized units\"\"\"\n        x = (self.win._mouse_x - self.win.width / 2.) / (self.win.width / 2.)\n        y = (self.win._mouse_y - self.win.height / 2.) / (self.win.height / 2.)\n        return np.array([x, y])\n\n    ###########################################################################\n    # Methods to be overridden by subclasses\n    def _clear_events(self):\n        self._clear_mouse_events()\n\n    def _retrieve_events(self, live_buttons):\n        return self._retrieve_mouse_events(live_buttons)\n\n    def _get_timebase(self):\n        \"\"\"Get mouse time reference (in seconds)\n        \"\"\"\n        return clock()\n\n    def _clear_mouse_events(self):\n        self.win.dispatch_events()\n        self._mouse_buffer = []\n\n    def _retrieve_mouse_events(self, live_buttons):\n        self.win.dispatch_events()  # pump events on pyglet windows\n        targets = []\n        for button in self._mouse_buffer:\n            if live_buttons is None or button[0] in live_buttons:\n                targets.append(button)\n        return targets\n\n    def _on_pyglet_mouse_click(self, x, y, button, modifiers):\n        \"\"\"Handler for on_mouse_press pyglet events\"\"\"\n        button_time = clock()\n        this_button = self._button_names[button]\n        self._mouse_buffer.append((this_button, x, y, button_time))\n\n    def listen_clicks(self):\n        \"\"\"Start listening for mouse clicks.\n        \"\"\"\n        self.time_correction = self.get_time_corr()\n        self.listen_start = self.master_clock()\n        self._clear_events()\n\n    def get_clicks(self, live_buttons, timestamp, relative_to):\n        \"\"\"Get the current entire mouse buffer.\n        \"\"\"\n        clicked = []\n        if timestamp and relative_to is None:\n            if self.listen_start is None:\n                raise ValueError('I cannot timestamp: relative_to is None and '\n                                 'you have not yet called listen_clicks.')\n            else:\n                relative_to = self.listen_start\n        clicked = self._retrieve_events(live_buttons)\n        return self._correct_clicks(clicked, timestamp, relative_to)\n\n    def wait_one_click(self, max_wait, min_wait, live_buttons,\n                       timestamp, relative_to, visible):\n        \"\"\"Returns only the first button clicked after min_wait.\n        \"\"\"\n        relative_to, start_time, was_visible = self._init_wait_click(\n            max_wait, min_wait, live_buttons, timestamp, relative_to, visible)\n\n        clicked = []\n        while (not len(clicked) and\n               self.master_clock() - start_time < max_wait):\n            clicked = self._retrieve_events(live_buttons)\n\n        # handle non-clicks\n        if len(clicked):\n            clicked = self._correct_clicks(clicked, timestamp, relative_to)[0]\n        elif timestamp:\n            clicked = (None, None)\n        else:\n            clicked = None\n        return clicked\n\n    def wait_for_clicks(self, max_wait, min_wait, live_buttons,\n                        timestamp, relative_to, visible=None):\n        \"\"\"Returns all clicks between min_wait and max_wait.\n        \"\"\"\n        relative_to, start_time, was_visible = self._init_wait_click(\n            max_wait, min_wait, live_buttons, timestamp, relative_to, visible)\n\n        clicked = []\n        while (self.master_clock() - start_time < max_wait):\n            clicked = self._retrieve_events(live_buttons)\n        return self._correct_clicks(clicked, timestamp, relative_to)\n\n    def wait_for_click_on(self, objects, max_wait, min_wait,\n                          live_buttons, timestamp, relative_to):\n        \"\"\"Waits for a click on one of the supplied window objects\n        \"\"\"\n        relative_to, start_time, was_visible = self._init_wait_click(\n            max_wait, min_wait, live_buttons, timestamp, relative_to, True)\n\n        index = None\n        ci = 0\n        while (self.master_clock() - start_time < max_wait and\n               index is None):\n            clicked = self._retrieve_events(live_buttons)\n            while ci < len(clicked) and index is None:  # clicks first\n                oi = 0\n                while oi < len(objects) and index is None:  # then objects\n                    if self._point_in_object(clicked[ci][1:3], objects[oi]):\n                        index = oi\n                    oi += 1\n                ci += 1\n\n        # handle non-clicks\n        if index is not None:\n            clicked = self._correct_clicks(clicked, timestamp, relative_to)[0]\n        elif timestamp:\n            clicked = (None, None, None, None)\n        else:\n            clicked = None\n\n        # Since visibility was forced, set back to what it was before call\n        self.set_visible(was_visible)\n        return clicked, index\n\n    def _correct_clicks(self, clicked, timestamp, relative_to):\n        \"\"\"Correct timing of clicks\"\"\"\n        if len(clicked):\n            clicked = [(b, x, y, s + self.time_correction) for\n                       b, x, y, s in clicked]\n            self.log_clicks(clicked)\n            buttons = [(b, x, y) for b, x, y, _ in clicked]\n            self._check_force_quit()\n            if timestamp:\n                clicked = [(b, x, y, s - relative_to) for\n                           b, x, y, s in clicked]\n            else:\n                clicked = buttons\n        return clicked\n\n    def _init_wait_click(self, max_wait, min_wait, live_buttons, timestamp,\n                         relative_to, visible):\n        \"\"\"Actions common to ``wait_one_click`` and ``wait_for_clicks``\n        \"\"\"\n        if np.isinf(max_wait) and live_buttons == []:\n            raise ValueError('max_wait cannot be infinite if there are no live'\n                             ' mouse buttons.')\n        if not min_wait <= max_wait:\n            raise ValueError('min_wait must be less than max_wait')\n        if visible not in [True, False, None]:\n            raise ValueError('set_visible must be one of (True, False, None)')\n        start_time = self.master_clock()\n        if timestamp and relative_to is None:\n            relative_to = start_time\n        wait_secs(min_wait)\n        self._check_force_quit()\n        self._clear_events()\n        was_visible = self.visible\n        if visible is not None:\n            self.set_visible(visible)\n        return relative_to, start_time, was_visible\n\n    # Define some functions for determining if a click point is in an object\n    def _point_in_object(self, pos, obj):\n        \"\"\"Determine if a point is within a visual objec\n        \"\"\"\n        if isinstance(obj, (Rectangle, Circle, Diamond, Triangle)):\n            return self._point_in_tris(pos, obj)\n        elif isinstance(obj, (ConcentricCircles, FixationDot)):\n            return np.any([self._point_in_tris(pos, c) for c in obj._circles])\n\n    def _point_in_tris(self, pos, obj):\n        \"\"\"Check to see if a point is in any of the triangles\n        \"\"\"\n        found = False\n        index = 0\n        while index < len(obj._tris) and not found:\n            points = obj._tris[index:index + 3]\n            tri = np.array([[obj._points[2 * p], obj._points[2 * p + 1]] for\n                            p in points])\n            found = self._point_in_tri(pos, tri)\n            index += 3\n        return found\n\n    def _point_in_tri(self, pos, tri):\n        \"\"\"Check to see if a point is in a single triangle\n        \"\"\"\n        signs = np.sign([np.cross(tri[np.mod(i + 1, 3)] - tri[i],\n                                  pos - tri[i]) for i in range(3)])\n        if np.all(signs[1:] == signs[0]):\n            return True\n        else:\n            return False",
  "class CedrusBox(Keyboard):\n    \"\"\"Class for Cedrus response boxes\n\n    Note that experiments with Cedrus boxes are limited to ~4 hours due\n    to the data type of their counter (milliseconds since start as integers).\n    \"\"\"\n    def __init__(self, ec, force_quit_keys):\n        import pyxid\n        pyxid.use_response_pad_timer = True\n        dev = pyxid.get_xid_devices()[0]\n        dev.reset_base_timer()\n        assert dev.is_response_device()\n        self._dev = dev\n        self._keyboard_buffer = []\n        super(CedrusBox, self).__init__(ec, force_quit_keys)\n        ec._time_correction_maxs['keypress'] = 1e-3  # higher tolerance\n\n    def _get_timebase(self):\n        \"\"\"WARNING: For now this will clear the event queue!\"\"\"\n        self._retrieve_events(None)\n        self._dev.con.read_nonblocking(65536)\n        t = self._dev.query_base_timer()\n        # This drift correction has been empirically determined, see:\n        #  https://github.com/cedrus-opensource/pyxid/issues/2\n        #  https://gist.github.com/Eric89GXL/c245574a1eaea65348a3\n        t *= 0.00100064206973\n        return t\n\n    def _clear_events(self):\n        self._retrieve_events(None)\n        self._keyboard_buffer = []\n\n    def _retrieve_events(self, live_keys):\n        # add escape keys\n        if live_keys is not None:\n            live_keys = [str(x) for x in live_keys]  # accept ints\n            live_keys.extend(self.force_quit_keys)\n        # pump for events\n        self._dev.poll_for_response()\n        while self._dev.response_queue_size() > 0:\n            key = self._dev.get_next_response()\n            if key['pressed']:\n                key = [str(key['key'] + 1), key['time'] / 1000.]\n                self._keyboard_buffer.append(key)\n            self._dev.poll_for_response()\n        # check to see if we have matches\n        targets = []\n        for key in self._keyboard_buffer:\n            if live_keys is None or key[0] in live_keys:\n                targets.append(key)\n        return targets",
  "def __init__(self, ec, force_quit_keys):\n        self.master_clock = ec._master_clock\n        self.log_presses = ec._log_presses\n        self.force_quit_keys = force_quit_keys\n        self.listen_start = None\n        ec._time_correction_fxns['keypress'] = self._get_timebase\n        self.get_time_corr = partial(ec._get_time_correction, 'keypress')\n        self.time_correction = self.get_time_corr()\n        self.win = ec._win\n        # always init pyglet response handler for error (and non-error) keys\n        self.win.on_key_press = self._on_pyglet_keypress\n        self._keyboard_buffer = []",
  "def _clear_events(self):\n        self._clear_keyboard_events()",
  "def _retrieve_events(self, live_keys):\n        return self._retrieve_keyboard_events(live_keys)",
  "def _get_timebase(self):\n        \"\"\"Get keyboard time reference (in seconds)\n        \"\"\"\n        return clock()",
  "def _clear_keyboard_events(self):\n        self.win.dispatch_events()\n        self._keyboard_buffer = []",
  "def _retrieve_keyboard_events(self, live_keys):\n        # add escape keys\n        if live_keys is not None:\n            live_keys = [str(x) for x in live_keys]  # accept ints\n            live_keys.extend(self.force_quit_keys)\n        self.win.dispatch_events()  # pump events on pyglet windows\n        targets = []\n        for key in self._keyboard_buffer:\n            if live_keys is None or key[0] in live_keys:\n                targets.append(key)\n        return targets",
  "def _on_pyglet_keypress(self, symbol, modifiers, emulated=False):\n        \"\"\"Handler for on_key_press pyglet events\"\"\"\n        key_time = clock()\n        if emulated:\n            this_key = str(symbol)\n        else:\n            from pyglet.window import key\n            this_key = key.symbol_string(symbol).lower()\n            this_key = this_key.lstrip('_').lstrip('NUM_')\n        self._keyboard_buffer.append((this_key, key_time))",
  "def listen_presses(self):\n        \"\"\"Start listening for keypresses.\n        \"\"\"\n        self.time_correction = self.get_time_corr()\n        self.listen_start = self.master_clock()\n        self._clear_events()",
  "def get_presses(self, live_keys, timestamp, relative_to):\n        \"\"\"Get the current entire keyboard / button box buffer.\n        \"\"\"\n        pressed = []\n        if timestamp and relative_to is None:\n            if self.listen_start is None:\n                raise ValueError('I cannot timestamp: relative_to is None and '\n                                 'you have not yet called listen_presses.')\n            else:\n                relative_to = self.listen_start\n        pressed = self._retrieve_events(live_keys)\n        return self._correct_presses(pressed, timestamp, relative_to)",
  "def wait_one_press(self, max_wait, min_wait, live_keys,\n                       timestamp, relative_to):\n        \"\"\"Returns only the first button pressed after min_wait.\n        \"\"\"\n        relative_to, start_time = self._init_wait_press(max_wait, min_wait,\n                                                        live_keys, timestamp,\n                                                        relative_to)\n        pressed = []\n        while (not len(pressed) and\n               self.master_clock() - start_time < max_wait):\n            pressed = self._retrieve_events(live_keys)\n\n        # handle non-presses\n        if len(pressed):\n            pressed = self._correct_presses(pressed, timestamp, relative_to)[0]\n        elif timestamp:\n            pressed = (None, None)\n        else:\n            pressed = None\n        return pressed",
  "def wait_for_presses(self, max_wait, min_wait, live_keys,\n                         timestamp, relative_to):\n        \"\"\"Returns all button presses between min_wait and max_wait.\n        \"\"\"\n        relative_to, start_time = self._init_wait_press(max_wait, min_wait,\n                                                        live_keys, timestamp,\n                                                        relative_to)\n        pressed = []\n        while (self.master_clock() - start_time < max_wait):\n            pressed = self._retrieve_events(live_keys)\n        return self._correct_presses(pressed, timestamp, relative_to)",
  "def check_force_quit(self, keys=None):\n        \"\"\"Compare key buffer to list of force-quit keys and quit if matched.\n\n        This function always uses the keyboard, so is part of abstraction.\n        \"\"\"\n        if keys is None:\n            # only grab the force-quit keys\n            keys = self._retrieve_keyboard_events([])\n        else:\n            if isinstance(keys, string_types):\n                keys = [keys]\n            if isinstance(keys, list):\n                keys = [k for k in keys if k in self.force_quit_keys]\n            else:\n                raise TypeError('Force quit checking requires a string or '\n                                ' list of strings, not a {}.'\n                                ''.format(type(keys)))\n        if len(keys):\n            raise RuntimeError('Quit key pressed')",
  "def _correct_presses(self, pressed, timestamp, relative_to):\n        \"\"\"Correct timing of presses and check for quit press\"\"\"\n        if len(pressed):\n            pressed = [(k, s + self.time_correction) for k, s in pressed]\n            self.log_presses(pressed)\n            keys = [k for k, _ in pressed]\n            self.check_force_quit(keys)\n            if timestamp:\n                pressed = [(k, s - relative_to) for k, s in pressed]\n            else:\n                pressed = keys\n        return pressed",
  "def _init_wait_press(self, max_wait, min_wait, live_keys, timestamp,\n                         relative_to):\n        \"\"\"Actions common to ``wait_one_press`` and ``wait_for_presses``\n        \"\"\"\n        if np.isinf(max_wait) and live_keys == []:\n            raise ValueError('max_wait cannot be infinite if there are no live'\n                             ' keys.')\n        if not min_wait <= max_wait:\n            raise ValueError('min_wait must be less than max_wait')\n        start_time = self.master_clock()\n        if timestamp and relative_to is None:\n            relative_to = start_time\n        wait_secs(min_wait)\n        self.check_force_quit()\n        self._clear_events()\n        return relative_to, start_time",
  "def __init__(self, ec, visible=False):\n        from pyglet.window import mouse\n        self.win = ec._win\n        self.set_visible(visible)\n        self.master_clock = ec._master_clock\n        self.log_clicks = ec._log_clicks\n        self.listen_start = None\n        ec._time_correction_fxns['mouseclick'] = self._get_timebase\n        self.get_time_corr = partial(ec._get_time_correction, 'mouseclick')\n        self.time_correction = self.get_time_corr()\n        self.win = ec._win\n        self._check_force_quit = ec.check_force_quit\n        self.win.on_mouse_press = self._on_pyglet_mouse_click\n        self._mouse_buffer = []\n        self._button_names = {mouse.LEFT: 'left', mouse.MIDDLE: 'middle',\n                              mouse.RIGHT: 'right'}\n        self._button_ids = {'left': mouse.LEFT, 'middle': mouse.MIDDLE,\n                            'right': mouse.RIGHT}\n        self._legal_types = (Rectangle, Circle)",
  "def set_visible(self, visible):\n        \"\"\"Sets the visibility of the mouse\n\n        Parameters\n        ----------\n        visible : bool\n            If True, make mouse visible.\n        \"\"\"\n        self.win.set_mouse_visible(visible)\n        self.win.set_mouse_platform_visible(visible)  # Pyglet workaround\n        self._visible = visible",
  "def visible(self):\n        \"\"\"Mouse visibility\"\"\"\n        return self._visible",
  "def pos(self):\n        \"\"\"The current position of the mouse in normalized units\"\"\"\n        x = (self.win._mouse_x - self.win.width / 2.) / (self.win.width / 2.)\n        y = (self.win._mouse_y - self.win.height / 2.) / (self.win.height / 2.)\n        return np.array([x, y])",
  "def _clear_events(self):\n        self._clear_mouse_events()",
  "def _retrieve_events(self, live_buttons):\n        return self._retrieve_mouse_events(live_buttons)",
  "def _get_timebase(self):\n        \"\"\"Get mouse time reference (in seconds)\n        \"\"\"\n        return clock()",
  "def _clear_mouse_events(self):\n        self.win.dispatch_events()\n        self._mouse_buffer = []",
  "def _retrieve_mouse_events(self, live_buttons):\n        self.win.dispatch_events()  # pump events on pyglet windows\n        targets = []\n        for button in self._mouse_buffer:\n            if live_buttons is None or button[0] in live_buttons:\n                targets.append(button)\n        return targets",
  "def _on_pyglet_mouse_click(self, x, y, button, modifiers):\n        \"\"\"Handler for on_mouse_press pyglet events\"\"\"\n        button_time = clock()\n        this_button = self._button_names[button]\n        self._mouse_buffer.append((this_button, x, y, button_time))",
  "def listen_clicks(self):\n        \"\"\"Start listening for mouse clicks.\n        \"\"\"\n        self.time_correction = self.get_time_corr()\n        self.listen_start = self.master_clock()\n        self._clear_events()",
  "def get_clicks(self, live_buttons, timestamp, relative_to):\n        \"\"\"Get the current entire mouse buffer.\n        \"\"\"\n        clicked = []\n        if timestamp and relative_to is None:\n            if self.listen_start is None:\n                raise ValueError('I cannot timestamp: relative_to is None and '\n                                 'you have not yet called listen_clicks.')\n            else:\n                relative_to = self.listen_start\n        clicked = self._retrieve_events(live_buttons)\n        return self._correct_clicks(clicked, timestamp, relative_to)",
  "def wait_one_click(self, max_wait, min_wait, live_buttons,\n                       timestamp, relative_to, visible):\n        \"\"\"Returns only the first button clicked after min_wait.\n        \"\"\"\n        relative_to, start_time, was_visible = self._init_wait_click(\n            max_wait, min_wait, live_buttons, timestamp, relative_to, visible)\n\n        clicked = []\n        while (not len(clicked) and\n               self.master_clock() - start_time < max_wait):\n            clicked = self._retrieve_events(live_buttons)\n\n        # handle non-clicks\n        if len(clicked):\n            clicked = self._correct_clicks(clicked, timestamp, relative_to)[0]\n        elif timestamp:\n            clicked = (None, None)\n        else:\n            clicked = None\n        return clicked",
  "def wait_for_clicks(self, max_wait, min_wait, live_buttons,\n                        timestamp, relative_to, visible=None):\n        \"\"\"Returns all clicks between min_wait and max_wait.\n        \"\"\"\n        relative_to, start_time, was_visible = self._init_wait_click(\n            max_wait, min_wait, live_buttons, timestamp, relative_to, visible)\n\n        clicked = []\n        while (self.master_clock() - start_time < max_wait):\n            clicked = self._retrieve_events(live_buttons)\n        return self._correct_clicks(clicked, timestamp, relative_to)",
  "def wait_for_click_on(self, objects, max_wait, min_wait,\n                          live_buttons, timestamp, relative_to):\n        \"\"\"Waits for a click on one of the supplied window objects\n        \"\"\"\n        relative_to, start_time, was_visible = self._init_wait_click(\n            max_wait, min_wait, live_buttons, timestamp, relative_to, True)\n\n        index = None\n        ci = 0\n        while (self.master_clock() - start_time < max_wait and\n               index is None):\n            clicked = self._retrieve_events(live_buttons)\n            while ci < len(clicked) and index is None:  # clicks first\n                oi = 0\n                while oi < len(objects) and index is None:  # then objects\n                    if self._point_in_object(clicked[ci][1:3], objects[oi]):\n                        index = oi\n                    oi += 1\n                ci += 1\n\n        # handle non-clicks\n        if index is not None:\n            clicked = self._correct_clicks(clicked, timestamp, relative_to)[0]\n        elif timestamp:\n            clicked = (None, None, None, None)\n        else:\n            clicked = None\n\n        # Since visibility was forced, set back to what it was before call\n        self.set_visible(was_visible)\n        return clicked, index",
  "def _correct_clicks(self, clicked, timestamp, relative_to):\n        \"\"\"Correct timing of clicks\"\"\"\n        if len(clicked):\n            clicked = [(b, x, y, s + self.time_correction) for\n                       b, x, y, s in clicked]\n            self.log_clicks(clicked)\n            buttons = [(b, x, y) for b, x, y, _ in clicked]\n            self._check_force_quit()\n            if timestamp:\n                clicked = [(b, x, y, s - relative_to) for\n                           b, x, y, s in clicked]\n            else:\n                clicked = buttons\n        return clicked",
  "def _init_wait_click(self, max_wait, min_wait, live_buttons, timestamp,\n                         relative_to, visible):\n        \"\"\"Actions common to ``wait_one_click`` and ``wait_for_clicks``\n        \"\"\"\n        if np.isinf(max_wait) and live_buttons == []:\n            raise ValueError('max_wait cannot be infinite if there are no live'\n                             ' mouse buttons.')\n        if not min_wait <= max_wait:\n            raise ValueError('min_wait must be less than max_wait')\n        if visible not in [True, False, None]:\n            raise ValueError('set_visible must be one of (True, False, None)')\n        start_time = self.master_clock()\n        if timestamp and relative_to is None:\n            relative_to = start_time\n        wait_secs(min_wait)\n        self._check_force_quit()\n        self._clear_events()\n        was_visible = self.visible\n        if visible is not None:\n            self.set_visible(visible)\n        return relative_to, start_time, was_visible",
  "def _point_in_object(self, pos, obj):\n        \"\"\"Determine if a point is within a visual objec\n        \"\"\"\n        if isinstance(obj, (Rectangle, Circle, Diamond, Triangle)):\n            return self._point_in_tris(pos, obj)\n        elif isinstance(obj, (ConcentricCircles, FixationDot)):\n            return np.any([self._point_in_tris(pos, c) for c in obj._circles])",
  "def _point_in_tris(self, pos, obj):\n        \"\"\"Check to see if a point is in any of the triangles\n        \"\"\"\n        found = False\n        index = 0\n        while index < len(obj._tris) and not found:\n            points = obj._tris[index:index + 3]\n            tri = np.array([[obj._points[2 * p], obj._points[2 * p + 1]] for\n                            p in points])\n            found = self._point_in_tri(pos, tri)\n            index += 3\n        return found",
  "def _point_in_tri(self, pos, tri):\n        \"\"\"Check to see if a point is in a single triangle\n        \"\"\"\n        signs = np.sign([np.cross(tri[np.mod(i + 1, 3)] - tri[i],\n                                  pos - tri[i]) for i in range(3)])\n        if np.all(signs[1:] == signs[0]):\n            return True\n        else:\n            return False",
  "def __init__(self, ec, force_quit_keys):\n        import pyxid\n        pyxid.use_response_pad_timer = True\n        dev = pyxid.get_xid_devices()[0]\n        dev.reset_base_timer()\n        assert dev.is_response_device()\n        self._dev = dev\n        self._keyboard_buffer = []\n        super(CedrusBox, self).__init__(ec, force_quit_keys)\n        ec._time_correction_maxs['keypress'] = 1e-3",
  "def _get_timebase(self):\n        \"\"\"WARNING: For now this will clear the event queue!\"\"\"\n        self._retrieve_events(None)\n        self._dev.con.read_nonblocking(65536)\n        t = self._dev.query_base_timer()\n        # This drift correction has been empirically determined, see:\n        #  https://github.com/cedrus-opensource/pyxid/issues/2\n        #  https://gist.github.com/Eric89GXL/c245574a1eaea65348a3\n        t *= 0.00100064206973\n        return t",
  "def _clear_events(self):\n        self._retrieve_events(None)\n        self._keyboard_buffer = []",
  "def _retrieve_events(self, live_keys):\n        # add escape keys\n        if live_keys is not None:\n            live_keys = [str(x) for x in live_keys]  # accept ints\n            live_keys.extend(self.force_quit_keys)\n        # pump for events\n        self._dev.poll_for_response()\n        while self._dev.response_queue_size() > 0:\n            key = self._dev.get_next_response()\n            if key['pressed']:\n                key = [str(key['key'] + 1), key['time'] / 1000.]\n                self._keyboard_buffer.append(key)\n            self._dev.poll_for_response()\n        # check to see if we have matches\n        targets = []\n        for key in self._keyboard_buffer:\n            if live_keys is None or key[0] in live_keys:\n                targets.append(key)\n        return targets",
  "def _check_pyglet_audio():\n    if pyglet.media.get_audio_driver() is None:\n        raise SystemError('pyglet audio (\"%s\") could not be initialized'\n                          % pyglet.options['audio'][0])",
  "class SoundPlayer(Player):\n    def __init__(self, data, fs, loop=False):\n        assert AudioFormat is not None\n        super(SoundPlayer, self).__init__()\n        _check_pyglet_audio()\n        sms = _as_static(data, fs)\n        group = SourceGroup(sms.audio_format, None)\n        group.loop = bool(loop)\n        group.queue(sms)\n        self.queue(group)\n\n    def stop(self):\n        self.pause()\n        self.seek(0.)",
  "class PygletSoundController(object):\n    \"\"\"Use pyglet audio capabilities\"\"\"\n    def __init__(self, ec, stim_fs):\n        logger.info('Expyfun: Setting up Pyglet audio')\n        assert AudioFormat is not None\n        self.fs = stim_fs\n\n        # Need to generate at RMS=1 to match TDT circuit\n        noise = np.random.normal(0, 1.0, int(self.fs * 15.))  # 15 secs\n\n        # Low-pass if necessary\n        if stim_fs < self.fs:\n            # note we can use cheap DFT method here b/c\n            # circular convolution won't matter for AWGN (yay!)\n            freqs = fftpack.fftfreq(len(noise), 1. / self.fs)\n            noise = fftpack.fft(noise)\n            noise[np.abs(freqs) > stim_fs / 2.] = 0.0\n            noise = np.real(fftpack.ifft(noise))\n\n        # ensure true RMS of 1.0 (DFT method also lowers RMS, compensate here)\n        noise = noise / np.sqrt(np.mean(noise * noise))\n        self.noise_array = np.array((noise, -1.0 * noise))\n        self.noise = SoundPlayer(self.noise_array, self.fs, loop=True)\n        self._noise_playing = False\n        self.audio = SoundPlayer(np.zeros((2, 1)), self.fs)\n        self.ec = ec\n        flush_logger()\n\n    def start_noise(self):\n        if not self._noise_playing:\n            self.noise.play()\n            self._noise_playing = True\n\n    def stop_noise(self):\n        if self._noise_playing:\n            self.noise.stop()\n            self._noise_playing = False\n\n    def clear_buffer(self):\n        self.audio.delete()\n        self.audio = SoundPlayer(np.zeros((2, 1)), self.fs)\n\n    def load_buffer(self, samples):\n        self.audio.delete()\n        self.audio = SoundPlayer(samples.T, self.fs)\n\n    def play(self):\n        self.audio.play()\n        self.ec._stamp_ttl_triggers([1])\n\n    def stop(self):\n        self.audio.stop()\n\n    def set_noise_level(self, level):\n        new_noise = SoundPlayer(self.noise_array * level, self.fs, loop=True)\n        if self._noise_playing:\n            self.stop_noise()\n            self.noise.delete()\n            self.noise = new_noise\n            self.start_noise()\n        else:\n            self.noise = new_noise\n\n    def halt(self):\n        self.stop()\n        self.stop_noise()\n        # cleanup pyglet instances\n        self.audio.delete()\n        self.noise.delete()",
  "def _as_static(data, fs):\n    \"\"\"Helper to get data into the Pyglet audio format\"\"\"\n    fs = int(fs)\n    if data.ndim not in (1, 2):\n        raise ValueError('Data must have one or two dimensions')\n    n_ch = data.shape[0] if data.ndim == 2 else 1\n    audio_format = AudioFormat(channels=n_ch, sample_size=16,\n                               sample_rate=fs)\n    data = data.T.ravel('C')\n    data[data < -1] = -1\n    data[data > 1] = 1\n    data = (data * (2 ** 15)).astype('int16').tostring()\n    return StaticMemorySourceFixed(data, audio_format)",
  "class StaticMemorySourceFixed(StaticMemorySource):\n    \"\"\"Stupid class to fix old Pyglet bug\"\"\"\n    def _get_queue_source(self):\n        return self",
  "def __init__(self, data, fs, loop=False):\n        assert AudioFormat is not None\n        super(SoundPlayer, self).__init__()\n        _check_pyglet_audio()\n        sms = _as_static(data, fs)\n        group = SourceGroup(sms.audio_format, None)\n        group.loop = bool(loop)\n        group.queue(sms)\n        self.queue(group)",
  "def stop(self):\n        self.pause()\n        self.seek(0.)",
  "def __init__(self, ec, stim_fs):\n        logger.info('Expyfun: Setting up Pyglet audio')\n        assert AudioFormat is not None\n        self.fs = stim_fs\n\n        # Need to generate at RMS=1 to match TDT circuit\n        noise = np.random.normal(0, 1.0, int(self.fs * 15.))  # 15 secs\n\n        # Low-pass if necessary\n        if stim_fs < self.fs:\n            # note we can use cheap DFT method here b/c\n            # circular convolution won't matter for AWGN (yay!)\n            freqs = fftpack.fftfreq(len(noise), 1. / self.fs)\n            noise = fftpack.fft(noise)\n            noise[np.abs(freqs) > stim_fs / 2.] = 0.0\n            noise = np.real(fftpack.ifft(noise))\n\n        # ensure true RMS of 1.0 (DFT method also lowers RMS, compensate here)\n        noise = noise / np.sqrt(np.mean(noise * noise))\n        self.noise_array = np.array((noise, -1.0 * noise))\n        self.noise = SoundPlayer(self.noise_array, self.fs, loop=True)\n        self._noise_playing = False\n        self.audio = SoundPlayer(np.zeros((2, 1)), self.fs)\n        self.ec = ec\n        flush_logger()",
  "def start_noise(self):\n        if not self._noise_playing:\n            self.noise.play()\n            self._noise_playing = True",
  "def stop_noise(self):\n        if self._noise_playing:\n            self.noise.stop()\n            self._noise_playing = False",
  "def clear_buffer(self):\n        self.audio.delete()\n        self.audio = SoundPlayer(np.zeros((2, 1)), self.fs)",
  "def load_buffer(self, samples):\n        self.audio.delete()\n        self.audio = SoundPlayer(samples.T, self.fs)",
  "def play(self):\n        self.audio.play()\n        self.ec._stamp_ttl_triggers([1])",
  "def stop(self):\n        self.audio.stop()",
  "def set_noise_level(self, level):\n        new_noise = SoundPlayer(self.noise_array * level, self.fs, loop=True)\n        if self._noise_playing:\n            self.stop_noise()\n            self.noise.delete()\n            self.noise = new_noise\n            self.start_noise()\n        else:\n            self.noise = new_noise",
  "def halt(self):\n        self.stop()\n        self.stop_noise()\n        # cleanup pyglet instances\n        self.audio.delete()\n        self.noise.delete()",
  "def _get_queue_source(self):\n        return self",
  "def parallel_func(func, n_jobs):\n    \"\"\"Return parallel instance with delayed function\n\n    Util function to use joblib only if available\n\n    Parameters\n    ----------\n    func: callable\n        A function\n    n_jobs: int\n        Number of jobs to run in parallel\n\n    Returns\n    -------\n    parallel: instance of joblib.Parallel or list\n        The parallel object\n    my_func: callable\n        func if not parallel or delayed(func)\n    n_jobs: int\n        Number of jobs >= 0\n    \"\"\"\n    # for a single job, we don't need joblib\n    if n_jobs == 1:\n        n_jobs = 1\n        my_func = func\n        parallel = list\n        return parallel, my_func, n_jobs\n\n    # let it error out if the user tries to do parallel w/o joblib\n    from joblib import Parallel, delayed\n    # create keyword arguments for Parallel\n    n_jobs = _check_n_jobs(n_jobs)\n    parallel = Parallel(n_jobs, verbose=0)\n    my_func = delayed(func)\n    return parallel, my_func, n_jobs",
  "def _check_n_jobs(n_jobs):\n    \"\"\"Check n_jobs in particular for negative values\n\n    Parameters\n    ----------\n    n_jobs : int\n        The number of jobs.\n\n    Returns\n    -------\n    n_jobs : int\n        The checked number of jobs. Always positive.\n    \"\"\"\n    if not isinstance(n_jobs, int):\n        raise TypeError('n_jobs must be an integer')\n    if n_jobs <= 0:\n        import multiprocessing\n        n_cores = multiprocessing.cpu_count()\n        n_jobs = max(min(n_cores + n_jobs + 1, n_cores), 1)\n    return n_jobs",
  "def exp(self, message, *args, **kwargs):\n    self.log(EXP, message, *args, **kwargs)",
  "def flush_logger():\n    \"\"\"Flush expyfun logger\"\"\"\n    for handler in logger.handlers:\n        handler.flush()",
  "def set_log_level(verbose=None, return_old_level=False):\n    \"\"\"Convenience function for setting the logging level\n\n    Parameters\n    ----------\n    verbose : bool, str, int, or None\n        The verbosity of messages to print. If a str, it can be either DEBUG,\n        INFO, WARNING, ERROR, or CRITICAL. Note that these are for\n        convenience and are equivalent to passing in logging.DEBUG, etc.\n        For bool, True is the same as 'INFO', False is the same as 'WARNING'.\n        If None, the environment variable EXPYFUN_LOGGING_LEVEL is read, and if\n        it doesn't exist, defaults to INFO.\n    return_old_level : bool\n        If True, return the old verbosity level.\n    \"\"\"\n    if verbose is None:\n        verbose = get_config('EXPYFUN_LOGGING_LEVEL', 'INFO')\n    elif isinstance(verbose, bool):\n        verbose = 'INFO' if verbose is True else 'WARNING'\n    if isinstance(verbose, string_types):\n        verbose = verbose.upper()\n        logging_types = dict(DEBUG=logging.DEBUG, INFO=logging.INFO,\n                             WARNING=logging.WARNING, ERROR=logging.ERROR,\n                             CRITICAL=logging.CRITICAL)\n        if verbose not in logging_types:\n            raise ValueError('verbose must be of a valid type')\n        verbose = logging_types[verbose]\n\n    old_verbose = logger.level\n    logger.setLevel(verbose)\n    return (old_verbose if return_old_level else None)",
  "def set_log_file(fname=None,\n                 output_format='%(asctime)s - %(levelname)-5s - %(message)s',\n                 overwrite=None):\n    \"\"\"Convenience function for setting the log to print to a file\n\n    Parameters\n    ----------\n    fname : str, or None\n        Filename of the log to print to. If None, stdout is used.\n        To suppress log outputs, use set_log_level('WARN').\n    output_format : str\n        Format of the output messages. See the following for examples:\n            http://docs.python.org/dev/howto/logging.html\n        e.g., \"%(asctime)s - %(levelname)s - %(message)s\".\n    overwrite : bool, or None\n        Overwrite the log file (if it exists). Otherwise, statements\n        will be appended to the log (default). None is the same as False,\n        but additionally raises a warning to notify the user that log\n        entries will be appended.\n    \"\"\"\n    handlers = logger.handlers\n    for h in handlers:\n        if isinstance(h, logging.FileHandler):\n            h.close()\n        logger.removeHandler(h)\n    if fname is not None:\n        if op.isfile(fname) and overwrite is None:\n            warnings.warn('Log entries will be appended to the file. Use '\n                          'overwrite=False to avoid this message in the '\n                          'future.')\n        mode = 'w' if overwrite is True else 'a'\n        lh = logging.FileHandler(fname, mode=mode)\n    else:\n        \"\"\" we should just be able to do:\n                lh = logging.StreamHandler(sys.stdout)\n            but because doctests uses some magic on stdout, we have to do this:\n        \"\"\"\n        lh = logging.StreamHandler(WrapStdOut())\n\n    lh.setFormatter(logging.Formatter(output_format))\n    # actually add the stream handler\n    logger.addHandler(lh)",
  "def run_subprocess(command, **kwargs):\n    \"\"\"Run command using subprocess.Popen\n\n    Run command and wait for command to complete. If the return code was zero\n    then return, otherwise raise CalledProcessError.\n    By default, this will also add stdout= and stderr=subproces.PIPE\n    to the call to Popen to suppress printing to the terminal.\n\n    Parameters\n    ----------\n    command : list of str\n        Command to run as subprocess (see subprocess.Popen documentation).\n    **kwargs : objects\n        Keywoard arguments to pass to ``subprocess.Popen``.\n\n    Returns\n    -------\n    stdout : str\n        Stdout returned by the process.\n    stderr : str\n        Stderr returned by the process.\n    \"\"\"\n    # code adapted with permission from mne-python\n    kw = dict(stderr=subprocess.PIPE, stdout=subprocess.PIPE)\n    kw.update(kwargs)\n\n    p = subprocess.Popen(command, **kw)\n    stdout_, stderr = p.communicate()\n\n    output = (stdout_.decode(), stderr.decode())\n    if p.returncode:\n        err_fun = subprocess.CalledProcessError.__init__\n        if 'output' in inspect.getargspec(err_fun).args:\n            raise subprocess.CalledProcessError(p.returncode, command, output)\n        else:\n            raise subprocess.CalledProcessError(p.returncode, command)\n\n    return output",
  "class ZeroClock(object):\n    \"\"\"Clock that uses \"clock\" function but starts at zero on init\"\"\"\n    def __init__(self):\n        self._start_time = clock()\n\n    def get_time(self):\n        return clock() - self._start_time",
  "def date_str():\n    \"\"\"Produce a date string for the current date and time\n\n    Returns\n    -------\n    datestr : str\n        The date string.\n    \"\"\"\n    return str(datetime.datetime.today()).replace(':', '_')",
  "class WrapStdOut(object):\n    \"\"\"Ridiculous class to work around how doctest captures stdout\"\"\"\n    def __getattr__(self, name):\n        # Even more ridiculous than this class, this must be sys.stdout (not\n        # just stdout) in order for this to work (tested on OSX and Linux)\n        return getattr(sys.stdout, name)",
  "class _TempDir(str):\n    \"\"\"Class for creating and auto-destroying temp dir\n\n    This is designed to be used with testing modules.\n\n    We cannot simply use __del__() method for cleanup here because the rmtree\n    function may be cleaned up before this object, so we use the atexit module\n    instead. Passing del_after and print_del kwargs to the constructor are\n    helpful primarily for debugging purposes.\n    \"\"\"\n    def __new__(self, del_after=True, print_del=False):\n        new = str.__new__(self, tempfile.mkdtemp())\n        self._del_after = del_after\n        self._print_del = print_del\n        return new\n\n    def __init__(self):\n        self._path = self.__str__()\n        atexit.register(self.cleanup)\n\n    def cleanup(self):\n        if self._del_after is True:\n            if self._print_del is True:\n                print('Deleting {} ...'.format(self._path))\n            rmtree(self._path, ignore_errors=True)",
  "def check_units(units):\n    \"\"\"Ensure user passed valid units type\n\n    Parameters\n    ----------\n    units : str\n        Must be ``'norm'``, ``'deg'``, or ``'pix'``.\n    \"\"\"\n    good_units = ['norm', 'pix', 'deg']\n    if units not in good_units:\n        raise ValueError('\"units\" must be one of {}, not {}'\n                         ''.format(good_units, units))",
  "class deprecated(object):\n    \"\"\"Decorator to mark a function or class as deprecated.\n\n    Issue a warning when the function is called/the class is instantiated and\n    adds a warning to the docstring.\n\n    The optional extra argument will be appended to the deprecation message\n    and the docstring. Note: to use this with the default value for extra, put\n    in an empty of parentheses:\n\n    >>> from expyfun.utils import deprecated\n    >>> deprecated() # doctest: +ELLIPSIS\n    <expyfun.utils.deprecated object at ...>\n\n    >>> @deprecated()\n    ... def some_function(): pass\n    \"\"\"\n    # Adapted from http://wiki.python.org/moin/PythonDecoratorLibrary,\n    # but with many changes.\n\n    # scikit-learn will not import on all platforms b/c it can be\n    # sklearn or scikits.learn, so a self-contained example is used above\n\n    def __init__(self, extra=''):\n        \"\"\"\n        Parameters\n        ----------\n        extra: string\n          to be added to the deprecation messages\n\n        \"\"\"\n        self.extra = extra\n\n    def __call__(self, obj):\n        if isinstance(obj, type):\n            return self._decorate_class(obj)\n        else:\n            return self._decorate_fun(obj)\n\n    def _decorate_class(self, cls):\n        msg = \"Class %s is deprecated\" % cls.__name__\n        if self.extra:\n            msg += \"; %s\" % self.extra\n\n        # FIXME: we should probably reset __new__ for full generality\n        init = cls.__init__\n\n        def wrapped(*args, **kwargs):\n            warnings.warn(msg, category=DeprecationWarning)\n            return init(*args, **kwargs)\n        cls.__init__ = wrapped\n\n        wrapped.__name__ = '__init__'\n        wrapped.__doc__ = self._update_doc(init.__doc__)\n        wrapped.deprecated_original = init\n\n        return cls\n\n    def _decorate_fun(self, fun):\n        \"\"\"Decorate function fun\"\"\"\n\n        msg = \"Function %s is deprecated\" % fun.__name__\n        if self.extra:\n            msg += \"; %s\" % self.extra\n\n        def wrapped(*args, **kwargs):\n            warnings.warn(msg, category=DeprecationWarning)\n            return fun(*args, **kwargs)\n\n        wrapped.__name__ = fun.__name__\n        wrapped.__dict__ = fun.__dict__\n        wrapped.__doc__ = self._update_doc(fun.__doc__)\n\n        return wrapped\n\n    def _update_doc(self, olddoc):\n        newdoc = \"DEPRECATED\"\n        if self.extra:\n            newdoc = \"%s: %s\" % (newdoc, self.extra)\n        if olddoc:\n            newdoc = \"%s\\n\\n%s\" % (newdoc, olddoc)\n        return newdoc",
  "def verbose_dec(function, *args, **kwargs):\n    \"\"\"Improved verbose decorator to allow functions to override log-level\n\n    Do not call this directly to set global verbosrity level, instead use\n    set_log_level().\n\n    Parameters\n    ----------\n    function - function\n        Function to be decorated by setting the verbosity level.\n\n    Returns\n    -------\n    dec - function\n        The decorated function\n    \"\"\"\n    arg_names = inspect.getargspec(function).args\n\n    if len(arg_names) > 0 and arg_names[0] == 'self':\n        default_level = getattr(args[0], 'verbose', None)\n    else:\n        default_level = None\n\n    if('verbose' in arg_names):\n        verbose_level = args[arg_names.index('verbose')]\n    else:\n        verbose_level = default_level\n\n    if verbose_level is not None:\n        old_level = set_log_level(verbose_level, True)\n        # set it back if we get an exception\n        try:\n            ret = function(*args, **kwargs)\n        except:\n            set_log_level(old_level)\n            raise\n        set_log_level(old_level)\n        return ret\n    else:\n        ret = function(*args, **kwargs)\n        return ret",
  "def _has_scipy_version(version):\n    return (LooseVersion(sp.__version__) >= LooseVersion(version))",
  "def _hide_window(function):\n    \"\"\"Decorator to hide expyfun windows during testing\"\"\"\n    import nose\n\n    def dec(*args, **kwargs):\n        orig_val = os.getenv('_EXPYFUN_WIN_INVISIBLE')\n        try:\n            os.environ['_EXPYFUN_WIN_INVISIBLE'] = 'true'\n            out = function(*args, **kwargs)\n            return out\n        finally:\n            if orig_val is None:\n                del os.environ['_EXPYFUN_WIN_INVISIBLE']\n            else:\n                os.environ['_EXPYFUN_WIN_INVISIBLE'] = orig_val\n    return nose.tools.make_decorator(function)(dec)",
  "def _get_user_home_path():\n    \"\"\"Return standard preferences path\"\"\"\n    # this has been checked on OSX64, Linux64, and Win32\n    val = os.getenv('APPDATA' if 'nt' == os.name.lower() else 'HOME', None)\n    if val is None:\n        raise ValueError('expyfun config file path could '\n                         'not be determined, please report this '\n                         'error to expyfun developers')\n    return val",
  "def fetch_data_file(fname):\n    \"\"\"Fetch example remote file\n\n    Parameters\n    ----------\n    fname : str\n        The remote filename to get. If the filename already exists\n        on the local system, the file will not be fetched again.\n\n    Returns\n    -------\n    fname : str\n        The filename on the local system where the file was downloaded.\n    \"\"\"\n    path = get_config('EXPYFUN_DATA_PATH', op.join(_get_user_home_path(),\n                                                   '.expyfun', 'data'))\n    fname_out = op.join(path, fname)\n    if not op.isdir(op.dirname(fname_out)):\n        os.makedirs(op.dirname(fname_out))\n    fname_url = ('https://github.com/LABSN/expyfun-data/raw/master/{0}'\n                 ''.format(fname))\n    try:\n        # until we get proper certificates\n        context = ssl._create_unverified_context()\n        this_urlopen = partial(urlopen, context=context)\n    except AttributeError:\n        context = None\n        this_urlopen = urlopen\n    if not op.isfile(fname_out):\n        try:\n            with open(fname_out, 'wb') as fid:\n                www = this_urlopen(fname_url, timeout=10.0)\n                fid.write(www.read())\n                www.close()\n        except Exception:\n            os.remove(fname_out)\n            raise\n    return fname_out",
  "def get_config_path():\n    \"\"\"Get path to standard expyfun config file\n\n    Returns\n    -------\n    config_path : str\n        The path to the expyfun configuration file. On windows, this\n        will be '%APPDATA%\\.expyfun\\expyfun.json'. On every other\n        system, this will be $HOME/.expyfun/expyfun.json.\n    \"\"\"\n    val = op.join(_get_user_home_path(), '.expyfun', 'expyfun.json')\n    return val",
  "def get_config(key, default=None, raise_error=False):\n    \"\"\"Read expyfun preference from env, then expyfun config\n\n    Parameters\n    ----------\n    key : str\n        The preference key to look for. The os evironment is searched first,\n        then the expyfun config file is parsed.\n    default : str | None\n        Value to return if the key is not found.\n    raise_error : bool\n        If True, raise an error if the key is not found (instead of returning\n        default).\n\n    Returns\n    -------\n    value : str | None\n        The preference key value.\n    \"\"\"\n\n    if not isinstance(key, string_types):\n        raise ValueError('key must be a string')\n\n    # first, check to see if key is in env\n    if key in os.environ:\n        return os.environ[key]\n\n    # second, look for it in expyfun config file\n    config_path = get_config_path()\n    if not op.isfile(config_path):\n        key_found = False\n        val = default\n    else:\n        with open(config_path, 'r') as fid:\n            config = json.load(fid)\n        key_found = True if key in config else False\n        val = config.get(key, default)\n\n    if not key_found and raise_error is True:\n        meth_1 = 'os.environ[\"%s\"] = VALUE' % key\n        meth_2 = 'expyfun.utils.set_config(\"%s\", VALUE)' % key\n        raise KeyError('Key \"%s\" not found in environment or in the '\n                       'expyfun config file:\\n%s\\nTry either:\\n'\n                       '    %s\\nfor a temporary solution, or:\\n'\n                       '    %s\\nfor a permanent one. You can also '\n                       'set the environment variable before '\n                       'running python.'\n                       % (key, config_path, meth_1, meth_2))\n    return val",
  "def set_config(key, value):\n    \"\"\"Set expyfun preference in config\n\n    Parameters\n    ----------\n    key : str\n        The preference key to set.\n    value : str |  None\n        The value to assign to the preference key. If None, the key is\n        deleted.\n    \"\"\"\n\n    if not isinstance(key, string_types):\n        raise ValueError('key must be a string')\n    # While JSON allow non-string types, we allow users to override config\n    # settings using env, which are strings, so we enforce that here\n    if not isinstance(value, string_types) and value is not None:\n        raise ValueError('value must be a string or None')\n    if key not in known_config_types and not \\\n            any(k in key for k in known_config_wildcards):\n        warnings.warn('Setting non-standard config type: \"%s\"' % key)\n\n    # Read all previous values\n    config_path = get_config_path()\n    if op.isfile(config_path):\n        with open(config_path, 'r') as fid:\n            config = json.load(fid)\n    else:\n        config = dict()\n        logger.info('Attempting to create new expyfun configuration '\n                    'file:\\n%s' % config_path)\n    if value is None:\n        config.pop(key, None)\n    else:\n        config[key] = value\n\n    # Write all values\n    directory = op.split(config_path)[0]\n    if not op.isdir(directory):\n        os.mkdir(directory)\n    with open(config_path, 'w') as fid:\n        json.dump(config, fid, sort_keys=True, indent=0)",
  "def fake_button_press(ec, button='1', delay=0.):\n    \"\"\"Fake a button press after a delay\n\n    Notes\n    -----\n    This function only works with the keyboard controller (not TDT)!\n    It uses threads to ensure that control is passed back, so other commands\n    can be called (like wait_for_presses).\n    \"\"\"\n    def send():\n        ec._response_handler._on_pyglet_keypress(button, [], True)\n    Timer(delay, send).start() if delay > 0. else send()",
  "def fake_mouse_click(ec, pos, button='left', delay=0.):\n    \"\"\"Fake a mouse click after a delay\"\"\"\n    button = dict(left=1, middle=2, right=4)[button]  # trans to pyglet\n\n    def send():\n        ec._mouse_handler._on_pyglet_mouse_click(pos[0], pos[1], button, [])\n    Timer(delay, send).start() if delay > 0. else send()",
  "def _check_pyglet_version(raise_error=False):\n    \"\"\"Check pyglet version, return True if usable.\n    \"\"\"\n    import pyglet\n    is_usable = LooseVersion(pyglet.version) >= LooseVersion('1.2')\n    if raise_error is True and is_usable is False:\n        raise ImportError('On Linux, you must run at least Pyglet '\n                          'version 1.2, and you are running '\n                          '{0}'.format(pyglet.version))\n    return is_usable",
  "def wait_secs(secs, ec=None):\n    \"\"\"Wait a specified number of seconds.\n\n    Parameters\n    ----------\n    secs : float\n        Number of seconds to wait.\n\n    Notes\n    -----\n    This function uses a while loop. Although this slams the CPU, it will\n    guarantee that events (keypresses, etc.) are processed.\n    \"\"\"\n    # hog the cpu, checking time\n    import pyglet\n    t0 = clock()\n    wins = pyglet.window.get_platform().get_default_display().get_windows()\n    while (clock() - t0) < secs:\n        for win in wins:\n            win.dispatch_events()\n        if ec is not None:\n            ec.check_force_quit()",
  "def running_rms(signal, win_length):\n    \"\"\"RMS of ``signal`` with rectangular window ``win_length`` samples long.\n\n    Parameters\n    ----------\n    signal : array_like\n        The (1-dimesional) signal of interest.\n    win_length : int\n        Length (in samples) of the rectangular window\n    \"\"\"\n    return sqrt(convolve(signal ** 2, ones(win_length) / win_length, 'valid'))",
  "def _fix_audio_dims(signal, n_channels=None):\n    \"\"\"Make it so a valid audio buffer is in the standard dimensions\n\n    Parameters\n    ----------\n    signal : array_like\n        The signal whose dimensions should be checked and fixed.\n    n_channels : int or None\n        The number of channels that the output should have. If ``None``, don't\n        change the number of channels (and assume vectors have one channel).\n        Setting ``n_channels`` to 1 when the input is stereo will result in an\n        error, since stereo-mono conversion is non-trivial and beyond the\n        scope of this function.\n\n    Returns\n    -------\n    signal_fixed : array\n        The signal with standard dimensions.\n    \"\"\"\n    # Check requested channel output\n    if n_channels not in [None, 1, 2]:\n        raise ValueError('Number of channels out must be ``None``, ``1``, '\n                         'or ``2``.')\n\n    signal = np.asarray(signal)\n\n    # Check dimensionality\n    if signal.ndim > 2:\n        raise ValueError('Sound data has more than two dimensions.')\n    elif signal.ndim == 2:\n        if np.min(signal.shape) > 2:\n            raise ValueError('Sound data has more than two channels.')\n        if signal.shape[0] > 2:  # Needs to be correct for remainder of checks\n            signal = signal.T\n        if signal.shape[0] not in [1, 2]:\n            raise ValueError('Audio shape must be (N,), (1, N), or (2, N).')\n        if signal.shape[0] == 2 and n_channels == 1:\n            raise ValueError('Requested mono output but gave stereo input.')\n\n    # Return data with correct dimensions\n    if signal.ndim == 2:\n        if (n_channels is None) or (n_channels == signal.shape[0]):\n            return signal\n        else:  # n_channels == 2\n            return np.tile(signal, (2, 1))\n    else:  # signal.ndim == 1:\n        if n_channels is None:\n            n_channels = 1\n        return np.tile(signal[np.newaxis, :], (n_channels, 1))",
  "def _sanitize(text_like):\n    \"\"\"Cast as string, encode as UTF-8 and sanitize any escape characters.\n    \"\"\"\n    return text_type(text_like).encode('unicode_escape').decode('utf-8')",
  "def _sort_keys(x):\n    \"\"\"Sort and return keys of dict\"\"\"\n    keys = list(x.keys())  # note: not thread-safe\n    idx = np.argsort([str(k) for k in keys])\n    keys = [keys[ii] for ii in idx]\n    return keys",
  "def object_diff(a, b, pre=''):\n    \"\"\"Compute all differences between two python variables\n\n    Parameters\n    ----------\n    a : object\n        Currently supported: dict, list, tuple, ndarray, int, str, bytes,\n        float, StringIO, BytesIO.\n    b : object\n        Must be same type as ``a``.\n    pre : str\n        String to prepend to each line.\n\n    Returns\n    -------\n    diffs : str\n        A string representation of the differences.\n\n    Notes\n    -----\n    Taken from mne-python with permission.\n    \"\"\"\n    out = ''\n    if type(a) != type(b):\n        out += pre + ' type mismatch (%s, %s)\\n' % (type(a), type(b))\n    elif isinstance(a, dict):\n        k1s = _sort_keys(a)\n        k2s = _sort_keys(b)\n        m1 = set(k2s) - set(k1s)\n        if len(m1):\n            out += pre + ' x1 missing keys %s\\n' % (m1)\n        for key in k1s:\n            if key not in k2s:\n                out += pre + ' x2 missing key %s\\n' % key\n            else:\n                out += object_diff(a[key], b[key], pre + 'd1[%s]' % repr(key))\n    elif isinstance(a, (list, tuple)):\n        if len(a) != len(b):\n            out += pre + ' length mismatch (%s, %s)\\n' % (len(a), len(b))\n        else:\n            for xx1, xx2 in zip(a, b):\n                out += object_diff(xx1, xx2, pre='')\n    elif isinstance(a, (string_types, int, float, bytes)):\n        if a != b:\n            out += pre + ' value mismatch (%s, %s)\\n' % (a, b)\n    elif a is None:\n        if b is not None:\n            out += pre + ' a is None, b is not (%s)\\n' % (b)\n    elif isinstance(a, np.ndarray):\n        if not np.array_equal(a, b):\n            out += pre + ' array mismatch\\n'\n    else:\n        raise RuntimeError(pre + ': unsupported type %s (%s)' % (type(a), a))\n    return out",
  "def __init__(self):\n        self._start_time = clock()",
  "def get_time(self):\n        return clock() - self._start_time",
  "def __getattr__(self, name):\n        # Even more ridiculous than this class, this must be sys.stdout (not\n        # just stdout) in order for this to work (tested on OSX and Linux)\n        return getattr(sys.stdout, name)",
  "def __new__(self, del_after=True, print_del=False):\n        new = str.__new__(self, tempfile.mkdtemp())\n        self._del_after = del_after\n        self._print_del = print_del\n        return new",
  "def __init__(self):\n        self._path = self.__str__()\n        atexit.register(self.cleanup)",
  "def cleanup(self):\n        if self._del_after is True:\n            if self._print_del is True:\n                print('Deleting {} ...'.format(self._path))\n            rmtree(self._path, ignore_errors=True)",
  "def __init__(self, extra=''):\n        \"\"\"\n        Parameters\n        ----------\n        extra: string\n          to be added to the deprecation messages\n\n        \"\"\"\n        self.extra = extra",
  "def __call__(self, obj):\n        if isinstance(obj, type):\n            return self._decorate_class(obj)\n        else:\n            return self._decorate_fun(obj)",
  "def _decorate_class(self, cls):\n        msg = \"Class %s is deprecated\" % cls.__name__\n        if self.extra:\n            msg += \"; %s\" % self.extra\n\n        # FIXME: we should probably reset __new__ for full generality\n        init = cls.__init__\n\n        def wrapped(*args, **kwargs):\n            warnings.warn(msg, category=DeprecationWarning)\n            return init(*args, **kwargs)\n        cls.__init__ = wrapped\n\n        wrapped.__name__ = '__init__'\n        wrapped.__doc__ = self._update_doc(init.__doc__)\n        wrapped.deprecated_original = init\n\n        return cls",
  "def _decorate_fun(self, fun):\n        \"\"\"Decorate function fun\"\"\"\n\n        msg = \"Function %s is deprecated\" % fun.__name__\n        if self.extra:\n            msg += \"; %s\" % self.extra\n\n        def wrapped(*args, **kwargs):\n            warnings.warn(msg, category=DeprecationWarning)\n            return fun(*args, **kwargs)\n\n        wrapped.__name__ = fun.__name__\n        wrapped.__dict__ = fun.__dict__\n        wrapped.__doc__ = self._update_doc(fun.__doc__)\n\n        return wrapped",
  "def _update_doc(self, olddoc):\n        newdoc = \"DEPRECATED\"\n        if self.extra:\n            newdoc = \"%s: %s\" % (newdoc, self.extra)\n        if olddoc:\n            newdoc = \"%s\\n\\n%s\" % (newdoc, olddoc)\n        return newdoc",
  "def dec(*args, **kwargs):\n        orig_val = os.getenv('_EXPYFUN_WIN_INVISIBLE')\n        try:\n            os.environ['_EXPYFUN_WIN_INVISIBLE'] = 'true'\n            out = function(*args, **kwargs)\n            return out\n        finally:\n            if orig_val is None:\n                del os.environ['_EXPYFUN_WIN_INVISIBLE']\n            else:\n                os.environ['_EXPYFUN_WIN_INVISIBLE'] = orig_val",
  "def send():\n        ec._response_handler._on_pyglet_keypress(button, [], True)",
  "def send():\n        ec._mouse_handler._on_pyglet_mouse_click(pos[0], pos[1], button, [])",
  "def wrapped(*args, **kwargs):\n            warnings.warn(msg, category=DeprecationWarning)\n            return init(*args, **kwargs)",
  "def wrapped(*args, **kwargs):\n            warnings.warn(msg, category=DeprecationWarning)\n            return fun(*args, **kwargs)",
  "def dummy_fun(*args, **kwargs):\n    \"\"\"A dummy function used by EL dummy mode\"\"\"\n    return TRIAL_OK",
  "def _get_key_trans_dict():\n    \"\"\"Helper to translate pyglet keys to pylink codes\"\"\"\n    from pyglet.window import key\n    key_trans_dict = {str(key.F1): pylink.F1_KEY,\n                      str(key.F2): pylink.F2_KEY,\n                      str(key.F3): pylink.F3_KEY,\n                      str(key.F4): pylink.F4_KEY,\n                      str(key.F5): pylink.F5_KEY,\n                      str(key.F6): pylink.F6_KEY,\n                      str(key.F7): pylink.F7_KEY,\n                      str(key.F8): pylink.F8_KEY,\n                      str(key.F9): pylink.F9_KEY,\n                      str(key.F10): pylink.F10_KEY,\n                      str(key.PAGEUP): pylink.PAGE_UP,\n                      str(key.PAGEDOWN): pylink.PAGE_DOWN,\n                      str(key.UP): pylink.CURS_UP,\n                      str(key.DOWN): pylink.CURS_DOWN,\n                      str(key.LEFT): pylink.CURS_LEFT,\n                      str(key.RIGHT): pylink.CURS_RIGHT,\n                      str(key.BACKSPACE): '\\b',\n                      str(key.RETURN): pylink.ENTER_KEY,\n                      str(key.ESCAPE): pylink.ESC_KEY,\n                      str(key.NUM_ADD): key.PLUS,\n                      str(key.NUM_SUBTRACT): key.MINUS,\n                      }\n    return key_trans_dict",
  "def _get_color_dict():\n    \"\"\"Helper to translate pylink colors to pyglet\"\"\"\n    color_dict = {str(CR_HAIR_COLOR): (1.0, 1.0, 1.0),\n                  str(PUPIL_HAIR_COLOR): (1.0, 1.0, 1.0),\n                  str(PUPIL_BOX_COLOR): (0.0, 1.0, 0.0),\n                  str(SEARCH_LIMIT_BOX_COLOR): (1.0, 0.0, 0.0),\n                  str(MOUSE_CURSOR_COLOR): (1.0, 0.0, 0.0)}\n    return color_dict",
  "def _check(val, msg, out='error'):\n    \"\"\"Helper to check output\"\"\"\n    if val != TRIAL_OK:\n        msg = msg.format(val)\n        if out == 'warn':\n            logger.warn(msg)\n        else:\n            raise RuntimeError()",
  "class DummyEl(object):\n    def __init__(self):\n        for name in _dummy_names:\n            setattr(self, name, dummy_fun)\n        self.getTrackerVersion = lambda: 'Dummy'\n        self.getDummyMode = lambda: True\n        self.getCurrentMode = lambda: IN_RECORD_MODE\n        self.waitForBlockStart = lambda a, b, c: 1\n\n    def sendMessage(self, msg):\n        if not isinstance(msg, string_types):\n            raise TypeError('msg must be str')\n        return TRIAL_OK",
  "class EyelinkController(object):\n    \"\"\"Eyelink communication and control methods\n\n    Parameters\n    ----------\n    ec : instance of ExperimentController | None\n        ExperimentController instance to interface with. Necessary for\n        doing calibrations.\n    link : str | None\n        If 'default', the default value will be read from EXPYFUN_EYELINK.\n        If None, dummy (simulation) mode will be used. If str, should be\n        the network location of eyelink (e.g., \"100.1.1.1\").\n    fs : int\n        Sample rate to use. Must be one of [250, 500, 1000, 2000].\n    verbose : bool, str, int, or None\n        If not None, override default verbose level (see expyfun.verbose).\n\n    Notes\n    -----\n    The data will be saved to the ExperimentController ``output_dir``.\n    If this was `None`, data will be saved to the current working dir.\n    \"\"\"\n    @verbose_dec\n    def __init__(self, ec, link='default', fs=1000, verbose=None):\n        if link == 'default':\n            link = get_config('EXPYFUN_EYELINK', None)\n        if link is not None and pylink is None:\n            raise ImportError('Could not import pylink, please ensure it '\n                              'is installed correctly to use the EyeLink')\n        valid_fs = (250, 500, 1000, 2000)\n        if fs not in valid_fs:\n            raise ValueError('fs must be one of {0}'.format(list(valid_fs)))\n        output_dir = ec._output_dir\n        if output_dir is None:\n            output_dir = os.getcwd()\n        if not isinstance(output_dir, string_types):\n            raise TypeError('output_dir must be a string')\n        if not op.isdir(output_dir):\n            os.mkdir(output_dir)\n        self._output_dir = output_dir\n        self._ec = ec\n        if 'el_id' in self._ec._id_call_dict:\n            raise RuntimeError('Cannot use initialize EL twice')\n        logger.info('EyeLink: Initializing on {}'.format(link))\n        ec.flush()\n        if link is not None:\n            iswin = (sys.platform == 'win32')\n            cmd = 'ping -n 1 -w 100' if iswin else 'fping -c 1 -t100'\n            cmd = subprocess.Popen('%s %s' % (cmd, link),\n                                   stdout=subprocess.PIPE,\n                                   stderr=subprocess.PIPE)\n            if cmd.returncode:\n                raise RuntimeError('could not connect to Eyelink @ %s, '\n                                   'is it turned on?' % link)\n        self._eyelink = DummyEl() if link is None else pylink.EyeLink(link)\n        self._file_list = []\n        self._size = np.array(self._ec.window_size_pix)\n        self._ec._extra_cleanup_fun += [self._close]\n        self._ec.flush()\n        self._setup(fs)\n        self._ec._id_call_dict['el_id'] = self._stamp_trial_id\n        self._ec._ofp_critical_funs.append(self._stamp_trial_start)\n        self._ec._on_trial_ok.append(self._stamp_trial_ok)\n        self._fake_calibration = False  # Only used for testing\n        self._closed = False  # to prevent double-closing\n        self._current_open_file = None\n        logger.debug('EyeLink: Setup complete')\n        self._ec.flush()\n\n    def _setup(self, fs=1000):\n        \"\"\"Start up Eyelink\n\n        Executes automatically on init, and needs to be run after\n        el_save() if further eye tracking is desired.\n\n        Parameters\n        ----------\n        fs : int\n            The sample rate to use.\n        \"\"\"\n        # map the gaze positions from the tracker to screen pixel positions\n        res = self._size\n        res_str = '0 0 {0} {1}'.format(res[0] - 1, res[1] - 1)\n        logger.debug('EyeLink: Setting display coordinates and saccade levels')\n        self._command('screen_pixel_coords = ' + res_str)\n        self._message('DISPLAY_COORDS ' + res_str)\n\n        # set calibration parameters\n        self.custom_calibration()\n\n        # set parser (conservative saccade thresholds)\n        self._eyelink.setSaccadeVelocityThreshold(35)\n        self._eyelink.setAccelerationThreshold(9500)\n        self._eyelink.setUpdateInterval(50)\n        self._eyelink.setFixationUpdateAccumulate(50)\n        self._command('sample_rate = {0}'.format(fs))\n\n        # retrieve tracker version and tracker software version\n        v = str(self._eyelink.getTrackerVersion())\n        logger.info('Eyelink: Running experiment on a version ''{0}'' '\n                    'tracker.'.format(v))\n        v = LooseVersion(v).version\n\n        # set EDF file contents\n        logger.debug('EyeLink: Setting file and event filters')\n        fef = 'LEFT,RIGHT,FIXATION,SACCADE,BLINK,MESSAGE,BUTTON,INPUT'\n        self._eyelink.setFileEventFilter(fef)\n        lef = ('LEFT,RIGHT,FIXATION,SACCADE,BLINK,MESSAGE,'\n               'BUTTON,FIXUPDATE,INPUT')\n        self._eyelink.setLinkEventFilter(lef)\n        fsf = 'LEFT,RIGHT,GAZE,HREF,AREA,GAZERES,STATUS,INPUT'\n        lsf = 'LEFT,RIGHT,GAZE,GAZERES,AREA,STATUS,INPUT'\n        if len(v) > 1 and v[0] == 3 and v[1] == 4:\n            # remote mode possible add HTARGET ( head target)\n            fsf += ',HTARGET'\n            # set link data (used for gaze cursor)\n            lsf += ',HTARGET'\n        self._eyelink.setFileSampleFilter(fsf)\n        self._eyelink.setLinkSampleFilter(lsf)\n\n        # Ensure that we get areas\n        self._eyelink.setPupilSizeDiameter('NO')\n\n        # calibration/drift cordisp.rection target\n        self._eyelink.setAcceptTargetFixationButton(5)\n\n        # record a few samples before we actually start displaying\n        # otherwise you may lose a few msec of data\n        time.sleep(0.1)\n        self._file_list = []\n        self._fs = fs\n\n    @property\n    def dummy_mode(self):\n        return self._eyelink.getDummyMode()\n\n    @property\n    def fs(self):\n        return self._fs\n\n    @property\n    def _is_file_open(self):\n        return (self._current_open_file is not None)\n\n    def _open_file(self):\n        \"\"\"Opens a new file on the Eyelink\"\"\"\n        if self._is_file_open:\n            raise RuntimeError('Cannot start new file, old must be closed')\n        file_name = datetime.datetime.now().strftime('%H%M%S')\n        while file_name in self._file_list:\n            # This should succeed in under 1 second\n            file_name = datetime.datetime.now().strftime('%H%M%S')\n        # make absolutely sure we don't break this, but it shouldn't ever\n        # be wrong\n        assert len(file_name) <= 8\n        logger.info('Eyelink: Opening remote file with filename {}'\n                    ''.format(file_name))\n        _check(self._eyelink.openDataFile(file_name),\n               'Remote file \"' + file_name + '\" could not be opened: {0}')\n        self._current_open_file = file_name\n        self._file_list.append(file_name)\n        return self._current_open_file\n\n    def _start_recording(self):\n        \"\"\"Start Eyelink recording\"\"\"\n        if not self._is_file_open:\n            raise RuntimeError('cannot start recording without file open')\n        for ii in range(5):\n            self._ec.wait_secs(0.1)\n            out = 'check' if ii < 4 else 'error'\n            _check(self._eyelink.startRecording(1, 1, 1, 1),\n                   'Recording could not be started: {0}', out)\n        # self._eyelink.waitForModeReady(100)  # doesn't work\n        _check(not self._eyelink.waitForBlockStart(100, 1, 0),\n               'No link samples received: {0}')\n        if not self.recording:\n            raise RuntimeError('Eyelink is not recording')\n        # double-check\n        mode = self._eyelink.getCurrentMode()\n        if mode != IN_RECORD_MODE:\n            raise RuntimeError('Eyelink is not recording: {0}'.format(mode))\n        self._ec.flush()\n        self._toggle_dummy_cursor(True)\n\n    @property\n    def recording(self):\n        \"\"\"Returns boolean for whether or not the Eyelink is recording\"\"\"\n        return (self._eyelink.isRecording() == TRIAL_OK)\n\n    def stop(self):\n        \"\"\"Stop Eyelink recording and close current file\n\n        See Also\n        --------\n        EyelinkController.calibrate\n        EyelinkController.transfer_remote_file\n        \"\"\"\n        if not self.recording:\n            raise RuntimeError('Cannot stop, not currently recording')\n        logger.info('Eyelink: Stopping recording')\n        self._eyelink.stopRecording()\n        logger.info('Eyelink: Closing file')\n        _check(self._eyelink.closeDataFile(),\n               'File could not be closed: {0}', 'warn')\n        self._current_open_file = None\n        self._toggle_dummy_cursor(False)\n\n    def calibrate(self, beep=False, prompt=True):\n        \"\"\"Calibrate the eyetracker\n\n        Parameters\n        ----------\n        beep : bool\n            If True, beep for each calibration target.\n        prompt : bool\n            If True, a standard screen prompt will be shown.\n\n        Returns\n        -------\n        fname : str | None\n            Filename on the Eyelink of the started data file.\n            Will be None if start is None.\n\n        Notes\n        -----\n        At the start of this function, the previous Eyelink file will be\n        closed (if one is open), a new file will be opened, and recording\n        will be started.\n\n        See Also\n        --------\n        EyelinkController.custom_calibration\n        EyelinkController.stop\n        \"\"\"\n        # stop recording and close old file (if open), then start new one\n        if self.recording:\n            self.stop()\n        # open file to record *before* running calibration so it gets saved!\n        fname = self._open_file()\n        if prompt:\n            self._ec.screen_prompt('We will now perform a screen calibration.'\n                                   '\\n\\nPress a button to continue.')\n        fname = None\n        logger.info('EyeLink: Entering calibration')\n        self._ec.flush()\n        # enter Eyetracker camera setup mode, calibration and validation\n        self._ec.flip()\n        cal = _Calibrate(self._ec, beep)\n        openGraphicsEx(cal)\n        cal.setup_event_handlers()\n        cal.play_beep(0)\n        if not self._fake_calibration:\n            self._eyelink.doTrackerSetup()\n        cal.release_event_handlers()\n        self._ec.flip()\n        logger.info('EyeLink: Completed calibration')\n        self._ec.flush()\n        self._start_recording()\n        return fname\n\n    def _stamp_trial_id(self, ids):\n        \"\"\"Send trial id message\n\n        These will be stamped as \"TRIALID # # #\", the suggested format.\n        This should not be used for timing-critical operations; use\n        ``stamp_trial_start()`` instead.\n\n        Parameters\n        ----------\n        ids : list of int\n            The ids to stamp. Up to 12 integers may be used.\n        \"\"\"\n        # From the Pylink doc:\n        #    The message should contain numbers ant text separated by spaces,\n        #    with the first item containing up to 12 numbers and letters that\n        #    uniquely identify the trial for analysis. Other data may follow,\n        #    such as one number for each trial independent variable.\n        # Here we just force up to 12 integers for simplicity.\n        if not isinstance(ids, (list, tuple)):\n            raise TypeError('ids must be a list (or tuple)')\n        if not all([np.isscalar(x) for x in ids]):\n            raise ValueError('All ids must be numeric')\n        if len(ids) > 12:\n            raise ValueError('ids must not have more than 12 entries')\n        ids = ' '.join([str(int(ii)) for ii in ids])\n        msg = 'TRIALID {}'.format(ids)\n        self._message(msg)\n\n    def _stamp_trial_start(self):\n        \"\"\"Signal the start of a trial\n\n        This is a timing-critical operation used to synchronize the\n        recording to stimulus presentation.\n        \"\"\"\n        self._eyelink.sendMessage('SYNCTIME')\n\n    def _stamp_trial_ok(self):\n        \"\"\"Signal the end of a trial\n        \"\"\"\n        self._eyelink.sendMessage('TRIAL OK')\n\n    def _message(self, msg):\n        \"\"\"Send message to eyelink, must be a string\"\"\"\n        self._eyelink.sendMessage(msg)\n        self._command('record_status_message \"{0}\"'.format(msg))\n\n    def _command(self, cmd):\n        \"\"\"Send Eyelink a command, must be a string\"\"\"\n        return self._eyelink.sendCommand(cmd)\n\n    def transfer_remote_file(self, remote_name):\n        \"\"\"Pull remote file (from Eyelink) to local machine\n\n        Parameters\n        ----------\n        remote_name : str\n            The filename on the Eyelink.\n\n        Returns\n        -------\n        fname : str\n            The filename on the local machine following the transfer.\n\n        See Also\n        --------\n        EyelinkController.stop\n        \"\"\"\n        fname = op.join(self._output_dir, '{0}.edf'.format(remote_name))\n        logger.info('Eyelink: saving Eyelink file: {0} ...'\n                    ''.format(remote_name))\n        status = self._eyelink.receiveDataFile(remote_name, fname)\n        logger.info('Eyelink: transferred {0} bytes'.format(status))\n        return fname\n\n    def _close(self):\n        \"\"\"Shutdown Eyelink, stopping recording & closing file if necessary\"\"\"\n        fnames = list()\n        if not self._closed:\n            if self.recording:\n                self.stop()\n            # make sure files get transferred\n            fnames = [self.transfer_remote_file(remote_name)\n                      for remote_name in self._file_list]\n            self._file_list = list()\n            self._eyelink.close()\n            self._closed = True\n            assert 'el_id' in self._ec._id_call_dict\n            del self._ec._id_call_dict['el_id']\n            idx = self._ec._ofp_critical_funs.index(self._stamp_trial_start)\n            self._ec._ofp_critical_funs.pop(idx)\n            idx = self._ec._on_trial_ok.index(self._stamp_trial_ok)\n            self._ec._on_trial_ok.pop(idx)\n        return fnames\n\n    def wait_for_fix(self, fix_pos, fix_time=0., tol=100., max_wait=np.inf,\n                     check_interval=0.001, units='norm'):\n        \"\"\"Wait for gaze to settle within a defined region\n\n        Parameters\n        ----------\n        fix_pos : tuple (length 2)\n            The screen position (in pixels) required.\n        fix_time : float\n            Amount of time required to call a fixation.\n        tol : float\n            The tolerance (in pixels) to consider the target hit.\n        max_wait : float\n            Maximum time to wait (seconds) before returning.\n        check_interval : float\n            Time to use between position checks (seconds).\n        units : str\n            Units for `fix_pos`. See ``check_units`` for options.\n\n        Returns\n        -------\n        fix_success : bool\n            Whether or not the subject successfully fixated.\n\n        See Also\n        --------\n        EyelinkController.get_eye_position\n        \"\"\"\n        # initialize eye position to be outside of target\n        fix_success = False\n\n        # sample eye position for el.fix_hold seconds\n        time_in = time.time()\n        time_out = time_in + max_wait\n        fix_pos = np.array(fix_pos)\n        if not (fix_pos.ndim == 1 and fix_pos.size == 2):\n            raise ValueError('fix_pos must be a 2-element array-like vector')\n        fix_pos = self._ec._convert_units(fix_pos[:, np.newaxis], units, 'pix')\n        fix_pos = fix_pos[:, 0]\n        while (time.time() < time_out and not\n               (fix_success and time.time() - time_in >= fix_time)):\n            # sample eye position\n            eye_pos = self.get_eye_position()  # in pixels\n            if _within_distance(eye_pos, fix_pos, tol):\n                fix_success = True\n            else:\n                fix_success = False\n                time_in = time.time()\n            self._ec._response_handler.check_force_quit()\n            self._ec.wait_secs(check_interval)\n\n        return fix_success\n\n    def custom_calibration(self, ctype='HV5', horiz=2./3., vert=2./3.,\n                           units='norm'):\n        \"\"\"Set Eyetracker to use a custom calibration sequence\n\n        Parameters\n        ----------\n        ctype : str\n            Type of calibration. Currently only 'HV5' is supported.\n        horiz : float\n            Horizontal distance (left and right, each) to use.\n        vert : float\n            Vertical distance (up and down, each) to use.\n        units : str\n            Units to use. See ``check_units`` for options.\n\n        See Also\n        --------\n        EyelinkController.calibrate\n        \"\"\"\n        allowed_types = ['HV5']\n        if ctype not in allowed_types:\n            raise ValueError('ctype cannot be \"{0}\", but must be one of {1}'\n                             ''.format(ctype, allowed_types))\n        horiz, vert = float(horiz), float(vert)\n        xx = np.array(([0., horiz], [0., vert]))\n        h_pix, v_pix = np.diff(self._ec._convert_units(xx, units, 'pix'),\n                               axis=1)[:, 0]\n        h_max, v_max = self._size[0] / 2., self._size[1] / 2.\n        for p, m, s in zip((h_pix, v_pix), (h_max, v_max), ('horiz', 'vert')):\n            if p > m:\n                raise ValueError('{0} too large ({1} > {2})'\n                                 ''.format(s, p, m))\n        # make the locations\n        mat = np.array([[0, 0], [1, 0], [-1, 0], [0, 1], [0, -1]])\n        offsets = mat * np.array([h_pix, v_pix])\n        coords = (self._size / 2. + offsets)\n        n_samples = coords.shape[0]\n        targs = ' '.join(['{0},{1}'.format(*c) for c in coords])\n        seq = ','.join([str(x) for x in range(n_samples + 1)])\n        self._command('calibration_type = {0}'.format(ctype))\n        self._command('generate_default_targets = NO')\n        self._command('calibration_samples = {0}'.format(n_samples))\n        self._command('calibration_sequence = ' + seq)\n        self._command('calibration_targets = ' + targs)\n        self._command('validation_samples = {0}'.format(n_samples))\n        self._command('validation_sequence = ' + seq)\n        self._command('validation_targets = ' + targs)\n\n    def get_eye_position(self):\n        \"\"\"The current eye position in pixels\n\n        Returns\n        -------\n        eye_pos : array\n            The current eye position. Will be [np.inf, np.inf] if the\n            eye is lost.\n\n        See Also\n        --------\n        EyelinkController.wait_for_fix\n        \"\"\"\n        if not self.dummy_mode:\n            sample = self._eyelink.getNewestSample()\n            if sample is None:\n                raise RuntimeError('No sample data, consider starting a '\n                                   'recording using el.start()')\n            if sample.isBinocular():\n                eye_pos = (np.array(sample.getLeftEye().getGaze()) +\n                           np.array(sample.getRightEye().getGaze())) / 2.\n            elif sample.isLeftSample:\n                eye_pos = np.array(sample.getLeftEye().getGaze())\n            elif sample.isRightSample:\n                eye_pos = np.array(sample.getRightEye().getGaze())\n            else:\n                eye_pos = np.array([np.inf, np.inf])\n            eye_pos -= (self._size / 2.)\n        else:\n            # use mouse, already referenced to center\n            eye_pos = self._ec.get_mouse_position()\n        return eye_pos\n\n    def _toggle_dummy_cursor(self, visibility):\n        \"\"\"Show the cursor for dummy mode\"\"\"\n        if self.dummy_mode:\n            self._ec.toggle_cursor(visibility)\n\n    @property\n    def file_list(self):\n        \"\"\"The list of files started on the EyeLink\n        \"\"\"\n        return self._file_list\n\n    @property\n    def eye_used(self):\n        \"\"\"Return the eye used 'left' or 'right'\n\n        Returns\n        -------\n        eye : str\n            'left' or 'right'.\n        \"\"\"\n        eu = self._eyelink.eyeAvailable()\n        eu = eye_list[eu] if eu >= 0 else None\n        return eu",
  "class _Calibrate(cal_super_class):\n    \"\"\"Show and control calibration screen\"\"\"\n    def __init__(self, ec, beep=False):\n        cal_super_class.__init__(self)\n        self.__target_beep__ = None\n        self.__target_beep__done__ = None\n        self.__target_beep__error__ = None\n\n        # set some useful parameters\n        self.ec = ec\n        self.keys = []\n        ws = np.array(ec.window_size_pix)\n        self.img_span = 1.5 * np.array((float(ws[0]) / ws[1], 1.))\n\n        # set up reusable objects\n        self.targ_circ = FixationDot(self.ec)\n        self.loz_circ = Circle(self.ec, fill_color=None, line_width=2.0)\n        self.image_buffer = None\n\n        # deal with parent class\n        self.setup_cal_display = self.clear_display\n        self.exit_cal_display = self.clear_display\n        self.erase_cal_target = self.clear_display\n        self.clear_cal_display = self.clear_display\n        self.exit_image_display = self.clear_display\n        self.beep = beep\n        self.state = 0\n        self.mouse_pos = (0, 0)\n        self.img_size = (0, 0)\n\n    def setup_event_handlers(self):\n        self.label = Text(self.ec, 'Eye Label', units='norm',\n                          pos=(0, -self.img_span[1] / 2.),\n                          anchor_y='top', color='white')\n        self.img = RawImage(self.ec, np.zeros((1, 2, 3)),\n                            pos=(0, 0), units='norm')\n\n        def on_mouse_press(x, y, button, modifiers):\n            self.state = 1\n\n        def on_mouse_motion(x, y, dx, dy):\n            self.mouse_pos = (x, y)\n\n        def on_mouse_release(x, y, button, modifiers):\n            self.state = 0\n\n        def on_mouse_drag(x, y, dx, dy, buttons, modifiers):\n            self.mouse_pos = (x, y)\n\n        def on_key_press(symbol, modifiers):\n            key_trans_dict = _get_key_trans_dict()\n            key = key_trans_dict.get(str(symbol), symbol)\n            self.keys += [pylink.KeyInput(key, modifiers)]\n\n        # create new handler at top of handling stack\n        self.ec.window.push_handlers(on_key_press, on_mouse_press,\n                                     on_mouse_motion, on_mouse_release,\n                                     on_mouse_drag)\n\n    def release_event_handlers(self):\n        self.ec.window.pop_handlers()  # should detacch top-level handler\n        del self.label\n        del self.img\n\n    def clear_display(self):\n        self.ec.flip()\n\n    def record_abort_hide(self):\n        pass\n\n    def draw_cal_target(self, x, y):\n        self.targ_circ.set_pos((x, y), units='pix')\n        self.targ_circ.draw()\n        self.ec.flip()\n\n    def play_beep(self, eepid):\n        \"\"\"Play a sound during calibration/drift correct.\"\"\"\n        self.ec.system_beep() if self.beep else None\n\n    def get_input_key(self):\n        self.ec.window.dispatch_events()\n        if len(self.keys) == 0:\n            return None\n        k = self.keys\n        self.keys = []\n        return k\n\n    def get_mouse_state(self):\n        x, y = self._win2img(self.mouse_pos[0], self.mouse_pos[1])\n        return ((x, y), self.state)\n\n    def _win2img(self, x, y):\n        \"\"\"Convert window coordinates to img coordinates\"\"\"\n        bounds, scale = self.img.bounds, self.img.scale\n        x = min(max(int((x - bounds[0]) / scale), 0), self.img_size[0])\n        y = min(max(int((bounds[3] - y) / scale), 0), self.img_size[1])\n        return x, y\n\n    def _img2win(self, x, y):\n        \"\"\"Convert window coordinates to img coordinates\"\"\"\n        bounds, scale = self.img.bounds, self.img.scale\n        x = int(scale * x + bounds[0])\n        y = int(bounds[3] - scale * y)\n        return x, y\n\n    def alert_printf(self, msg):\n        logger.warn('EyeLink: alert_printf {}'.format(msg))\n\n    def setup_image_display(self, w, h):\n        # convert w, h from pixels to relative units\n        x = np.array([[0, 0], [0, self.img_span[1]]], float)\n        x = np.diff(self.ec._convert_units(x, 'norm', 'pix')[1]) / h\n        self.img.set_scale(x)\n        self.clear_display()\n\n    def image_title(self, text):\n        text = \"<center>{0}</center>\".format(text)\n        self.label = Text(self.ec, text, units='norm', anchor_y='top',\n                          color='white', pos=(0, -self.img_span[1] / 2.))\n\n    def set_image_palette(self, r, g, b):\n        self.palette = np.array([r, g, b], np.uint8).T\n\n    def draw_image_line(self, width, line, totlines, buff):\n        if self.image_buffer is None:\n            self.img_size = (width, totlines)\n            self.image_buffer = np.empty((totlines, width, 3), float)\n        self.image_buffer[line - 1, :, :] = self.palette[buff, :] / 255.\n        if line == totlines:\n            self.img.set_image(self.image_buffer)\n            self.img.draw()\n            self.label.draw()\n            self.draw_cross_hair()\n            self.ec.flip()\n\n    def draw_line(self, x1, y1, x2, y2, colorindex):\n        color = _get_color_dict()[str(colorindex)]\n        x1, y1 = self._img2win(x1, y1)\n        x2, y2 = self._img2win(x2, y2)\n        Line(self.ec, ((x1, x2), (y1, y2)), 'pix', color).draw()\n\n    def draw_lozenge(self, x, y, width, height, colorindex):\n        coords = self._img2win(x + width / 2., y + width / 2.)\n        width = width * self.img.scale / 2.\n        height = height * self.img.scale / 2.\n        self.loz_circ.set_line_color(_get_color_dict()[str(colorindex)])\n        self.loz_circ.set_pos(coords, units='pix')\n        self.loz_circ.set_radius((width, height), units='pix')\n        self.loz_circ.draw()",
  "def _within_distance(pos_1, pos_2, radius):\n    \"\"\"Helper for checking eye position\"\"\"\n    return np.sum((pos_1 - pos_2) ** 2) <= radius ** 2",
  "def __init__(self):\n        for name in _dummy_names:\n            setattr(self, name, dummy_fun)\n        self.getTrackerVersion = lambda: 'Dummy'\n        self.getDummyMode = lambda: True\n        self.getCurrentMode = lambda: IN_RECORD_MODE\n        self.waitForBlockStart = lambda a, b, c: 1",
  "def sendMessage(self, msg):\n        if not isinstance(msg, string_types):\n            raise TypeError('msg must be str')\n        return TRIAL_OK",
  "def __init__(self, ec, link='default', fs=1000, verbose=None):\n        if link == 'default':\n            link = get_config('EXPYFUN_EYELINK', None)\n        if link is not None and pylink is None:\n            raise ImportError('Could not import pylink, please ensure it '\n                              'is installed correctly to use the EyeLink')\n        valid_fs = (250, 500, 1000, 2000)\n        if fs not in valid_fs:\n            raise ValueError('fs must be one of {0}'.format(list(valid_fs)))\n        output_dir = ec._output_dir\n        if output_dir is None:\n            output_dir = os.getcwd()\n        if not isinstance(output_dir, string_types):\n            raise TypeError('output_dir must be a string')\n        if not op.isdir(output_dir):\n            os.mkdir(output_dir)\n        self._output_dir = output_dir\n        self._ec = ec\n        if 'el_id' in self._ec._id_call_dict:\n            raise RuntimeError('Cannot use initialize EL twice')\n        logger.info('EyeLink: Initializing on {}'.format(link))\n        ec.flush()\n        if link is not None:\n            iswin = (sys.platform == 'win32')\n            cmd = 'ping -n 1 -w 100' if iswin else 'fping -c 1 -t100'\n            cmd = subprocess.Popen('%s %s' % (cmd, link),\n                                   stdout=subprocess.PIPE,\n                                   stderr=subprocess.PIPE)\n            if cmd.returncode:\n                raise RuntimeError('could not connect to Eyelink @ %s, '\n                                   'is it turned on?' % link)\n        self._eyelink = DummyEl() if link is None else pylink.EyeLink(link)\n        self._file_list = []\n        self._size = np.array(self._ec.window_size_pix)\n        self._ec._extra_cleanup_fun += [self._close]\n        self._ec.flush()\n        self._setup(fs)\n        self._ec._id_call_dict['el_id'] = self._stamp_trial_id\n        self._ec._ofp_critical_funs.append(self._stamp_trial_start)\n        self._ec._on_trial_ok.append(self._stamp_trial_ok)\n        self._fake_calibration = False  # Only used for testing\n        self._closed = False  # to prevent double-closing\n        self._current_open_file = None\n        logger.debug('EyeLink: Setup complete')\n        self._ec.flush()",
  "def _setup(self, fs=1000):\n        \"\"\"Start up Eyelink\n\n        Executes automatically on init, and needs to be run after\n        el_save() if further eye tracking is desired.\n\n        Parameters\n        ----------\n        fs : int\n            The sample rate to use.\n        \"\"\"\n        # map the gaze positions from the tracker to screen pixel positions\n        res = self._size\n        res_str = '0 0 {0} {1}'.format(res[0] - 1, res[1] - 1)\n        logger.debug('EyeLink: Setting display coordinates and saccade levels')\n        self._command('screen_pixel_coords = ' + res_str)\n        self._message('DISPLAY_COORDS ' + res_str)\n\n        # set calibration parameters\n        self.custom_calibration()\n\n        # set parser (conservative saccade thresholds)\n        self._eyelink.setSaccadeVelocityThreshold(35)\n        self._eyelink.setAccelerationThreshold(9500)\n        self._eyelink.setUpdateInterval(50)\n        self._eyelink.setFixationUpdateAccumulate(50)\n        self._command('sample_rate = {0}'.format(fs))\n\n        # retrieve tracker version and tracker software version\n        v = str(self._eyelink.getTrackerVersion())\n        logger.info('Eyelink: Running experiment on a version ''{0}'' '\n                    'tracker.'.format(v))\n        v = LooseVersion(v).version\n\n        # set EDF file contents\n        logger.debug('EyeLink: Setting file and event filters')\n        fef = 'LEFT,RIGHT,FIXATION,SACCADE,BLINK,MESSAGE,BUTTON,INPUT'\n        self._eyelink.setFileEventFilter(fef)\n        lef = ('LEFT,RIGHT,FIXATION,SACCADE,BLINK,MESSAGE,'\n               'BUTTON,FIXUPDATE,INPUT')\n        self._eyelink.setLinkEventFilter(lef)\n        fsf = 'LEFT,RIGHT,GAZE,HREF,AREA,GAZERES,STATUS,INPUT'\n        lsf = 'LEFT,RIGHT,GAZE,GAZERES,AREA,STATUS,INPUT'\n        if len(v) > 1 and v[0] == 3 and v[1] == 4:\n            # remote mode possible add HTARGET ( head target)\n            fsf += ',HTARGET'\n            # set link data (used for gaze cursor)\n            lsf += ',HTARGET'\n        self._eyelink.setFileSampleFilter(fsf)\n        self._eyelink.setLinkSampleFilter(lsf)\n\n        # Ensure that we get areas\n        self._eyelink.setPupilSizeDiameter('NO')\n\n        # calibration/drift cordisp.rection target\n        self._eyelink.setAcceptTargetFixationButton(5)\n\n        # record a few samples before we actually start displaying\n        # otherwise you may lose a few msec of data\n        time.sleep(0.1)\n        self._file_list = []\n        self._fs = fs",
  "def dummy_mode(self):\n        return self._eyelink.getDummyMode()",
  "def fs(self):\n        return self._fs",
  "def _is_file_open(self):\n        return (self._current_open_file is not None)",
  "def _open_file(self):\n        \"\"\"Opens a new file on the Eyelink\"\"\"\n        if self._is_file_open:\n            raise RuntimeError('Cannot start new file, old must be closed')\n        file_name = datetime.datetime.now().strftime('%H%M%S')\n        while file_name in self._file_list:\n            # This should succeed in under 1 second\n            file_name = datetime.datetime.now().strftime('%H%M%S')\n        # make absolutely sure we don't break this, but it shouldn't ever\n        # be wrong\n        assert len(file_name) <= 8\n        logger.info('Eyelink: Opening remote file with filename {}'\n                    ''.format(file_name))\n        _check(self._eyelink.openDataFile(file_name),\n               'Remote file \"' + file_name + '\" could not be opened: {0}')\n        self._current_open_file = file_name\n        self._file_list.append(file_name)\n        return self._current_open_file",
  "def _start_recording(self):\n        \"\"\"Start Eyelink recording\"\"\"\n        if not self._is_file_open:\n            raise RuntimeError('cannot start recording without file open')\n        for ii in range(5):\n            self._ec.wait_secs(0.1)\n            out = 'check' if ii < 4 else 'error'\n            _check(self._eyelink.startRecording(1, 1, 1, 1),\n                   'Recording could not be started: {0}', out)\n        # self._eyelink.waitForModeReady(100)  # doesn't work\n        _check(not self._eyelink.waitForBlockStart(100, 1, 0),\n               'No link samples received: {0}')\n        if not self.recording:\n            raise RuntimeError('Eyelink is not recording')\n        # double-check\n        mode = self._eyelink.getCurrentMode()\n        if mode != IN_RECORD_MODE:\n            raise RuntimeError('Eyelink is not recording: {0}'.format(mode))\n        self._ec.flush()\n        self._toggle_dummy_cursor(True)",
  "def recording(self):\n        \"\"\"Returns boolean for whether or not the Eyelink is recording\"\"\"\n        return (self._eyelink.isRecording() == TRIAL_OK)",
  "def stop(self):\n        \"\"\"Stop Eyelink recording and close current file\n\n        See Also\n        --------\n        EyelinkController.calibrate\n        EyelinkController.transfer_remote_file\n        \"\"\"\n        if not self.recording:\n            raise RuntimeError('Cannot stop, not currently recording')\n        logger.info('Eyelink: Stopping recording')\n        self._eyelink.stopRecording()\n        logger.info('Eyelink: Closing file')\n        _check(self._eyelink.closeDataFile(),\n               'File could not be closed: {0}', 'warn')\n        self._current_open_file = None\n        self._toggle_dummy_cursor(False)",
  "def calibrate(self, beep=False, prompt=True):\n        \"\"\"Calibrate the eyetracker\n\n        Parameters\n        ----------\n        beep : bool\n            If True, beep for each calibration target.\n        prompt : bool\n            If True, a standard screen prompt will be shown.\n\n        Returns\n        -------\n        fname : str | None\n            Filename on the Eyelink of the started data file.\n            Will be None if start is None.\n\n        Notes\n        -----\n        At the start of this function, the previous Eyelink file will be\n        closed (if one is open), a new file will be opened, and recording\n        will be started.\n\n        See Also\n        --------\n        EyelinkController.custom_calibration\n        EyelinkController.stop\n        \"\"\"\n        # stop recording and close old file (if open), then start new one\n        if self.recording:\n            self.stop()\n        # open file to record *before* running calibration so it gets saved!\n        fname = self._open_file()\n        if prompt:\n            self._ec.screen_prompt('We will now perform a screen calibration.'\n                                   '\\n\\nPress a button to continue.')\n        fname = None\n        logger.info('EyeLink: Entering calibration')\n        self._ec.flush()\n        # enter Eyetracker camera setup mode, calibration and validation\n        self._ec.flip()\n        cal = _Calibrate(self._ec, beep)\n        openGraphicsEx(cal)\n        cal.setup_event_handlers()\n        cal.play_beep(0)\n        if not self._fake_calibration:\n            self._eyelink.doTrackerSetup()\n        cal.release_event_handlers()\n        self._ec.flip()\n        logger.info('EyeLink: Completed calibration')\n        self._ec.flush()\n        self._start_recording()\n        return fname",
  "def _stamp_trial_id(self, ids):\n        \"\"\"Send trial id message\n\n        These will be stamped as \"TRIALID # # #\", the suggested format.\n        This should not be used for timing-critical operations; use\n        ``stamp_trial_start()`` instead.\n\n        Parameters\n        ----------\n        ids : list of int\n            The ids to stamp. Up to 12 integers may be used.\n        \"\"\"\n        # From the Pylink doc:\n        #    The message should contain numbers ant text separated by spaces,\n        #    with the first item containing up to 12 numbers and letters that\n        #    uniquely identify the trial for analysis. Other data may follow,\n        #    such as one number for each trial independent variable.\n        # Here we just force up to 12 integers for simplicity.\n        if not isinstance(ids, (list, tuple)):\n            raise TypeError('ids must be a list (or tuple)')\n        if not all([np.isscalar(x) for x in ids]):\n            raise ValueError('All ids must be numeric')\n        if len(ids) > 12:\n            raise ValueError('ids must not have more than 12 entries')\n        ids = ' '.join([str(int(ii)) for ii in ids])\n        msg = 'TRIALID {}'.format(ids)\n        self._message(msg)",
  "def _stamp_trial_start(self):\n        \"\"\"Signal the start of a trial\n\n        This is a timing-critical operation used to synchronize the\n        recording to stimulus presentation.\n        \"\"\"\n        self._eyelink.sendMessage('SYNCTIME')",
  "def _stamp_trial_ok(self):\n        \"\"\"Signal the end of a trial\n        \"\"\"\n        self._eyelink.sendMessage('TRIAL OK')",
  "def _message(self, msg):\n        \"\"\"Send message to eyelink, must be a string\"\"\"\n        self._eyelink.sendMessage(msg)\n        self._command('record_status_message \"{0}\"'.format(msg))",
  "def _command(self, cmd):\n        \"\"\"Send Eyelink a command, must be a string\"\"\"\n        return self._eyelink.sendCommand(cmd)",
  "def transfer_remote_file(self, remote_name):\n        \"\"\"Pull remote file (from Eyelink) to local machine\n\n        Parameters\n        ----------\n        remote_name : str\n            The filename on the Eyelink.\n\n        Returns\n        -------\n        fname : str\n            The filename on the local machine following the transfer.\n\n        See Also\n        --------\n        EyelinkController.stop\n        \"\"\"\n        fname = op.join(self._output_dir, '{0}.edf'.format(remote_name))\n        logger.info('Eyelink: saving Eyelink file: {0} ...'\n                    ''.format(remote_name))\n        status = self._eyelink.receiveDataFile(remote_name, fname)\n        logger.info('Eyelink: transferred {0} bytes'.format(status))\n        return fname",
  "def _close(self):\n        \"\"\"Shutdown Eyelink, stopping recording & closing file if necessary\"\"\"\n        fnames = list()\n        if not self._closed:\n            if self.recording:\n                self.stop()\n            # make sure files get transferred\n            fnames = [self.transfer_remote_file(remote_name)\n                      for remote_name in self._file_list]\n            self._file_list = list()\n            self._eyelink.close()\n            self._closed = True\n            assert 'el_id' in self._ec._id_call_dict\n            del self._ec._id_call_dict['el_id']\n            idx = self._ec._ofp_critical_funs.index(self._stamp_trial_start)\n            self._ec._ofp_critical_funs.pop(idx)\n            idx = self._ec._on_trial_ok.index(self._stamp_trial_ok)\n            self._ec._on_trial_ok.pop(idx)\n        return fnames",
  "def wait_for_fix(self, fix_pos, fix_time=0., tol=100., max_wait=np.inf,\n                     check_interval=0.001, units='norm'):\n        \"\"\"Wait for gaze to settle within a defined region\n\n        Parameters\n        ----------\n        fix_pos : tuple (length 2)\n            The screen position (in pixels) required.\n        fix_time : float\n            Amount of time required to call a fixation.\n        tol : float\n            The tolerance (in pixels) to consider the target hit.\n        max_wait : float\n            Maximum time to wait (seconds) before returning.\n        check_interval : float\n            Time to use between position checks (seconds).\n        units : str\n            Units for `fix_pos`. See ``check_units`` for options.\n\n        Returns\n        -------\n        fix_success : bool\n            Whether or not the subject successfully fixated.\n\n        See Also\n        --------\n        EyelinkController.get_eye_position\n        \"\"\"\n        # initialize eye position to be outside of target\n        fix_success = False\n\n        # sample eye position for el.fix_hold seconds\n        time_in = time.time()\n        time_out = time_in + max_wait\n        fix_pos = np.array(fix_pos)\n        if not (fix_pos.ndim == 1 and fix_pos.size == 2):\n            raise ValueError('fix_pos must be a 2-element array-like vector')\n        fix_pos = self._ec._convert_units(fix_pos[:, np.newaxis], units, 'pix')\n        fix_pos = fix_pos[:, 0]\n        while (time.time() < time_out and not\n               (fix_success and time.time() - time_in >= fix_time)):\n            # sample eye position\n            eye_pos = self.get_eye_position()  # in pixels\n            if _within_distance(eye_pos, fix_pos, tol):\n                fix_success = True\n            else:\n                fix_success = False\n                time_in = time.time()\n            self._ec._response_handler.check_force_quit()\n            self._ec.wait_secs(check_interval)\n\n        return fix_success",
  "def custom_calibration(self, ctype='HV5', horiz=2./3., vert=2./3.,\n                           units='norm'):\n        \"\"\"Set Eyetracker to use a custom calibration sequence\n\n        Parameters\n        ----------\n        ctype : str\n            Type of calibration. Currently only 'HV5' is supported.\n        horiz : float\n            Horizontal distance (left and right, each) to use.\n        vert : float\n            Vertical distance (up and down, each) to use.\n        units : str\n            Units to use. See ``check_units`` for options.\n\n        See Also\n        --------\n        EyelinkController.calibrate\n        \"\"\"\n        allowed_types = ['HV5']\n        if ctype not in allowed_types:\n            raise ValueError('ctype cannot be \"{0}\", but must be one of {1}'\n                             ''.format(ctype, allowed_types))\n        horiz, vert = float(horiz), float(vert)\n        xx = np.array(([0., horiz], [0., vert]))\n        h_pix, v_pix = np.diff(self._ec._convert_units(xx, units, 'pix'),\n                               axis=1)[:, 0]\n        h_max, v_max = self._size[0] / 2., self._size[1] / 2.\n        for p, m, s in zip((h_pix, v_pix), (h_max, v_max), ('horiz', 'vert')):\n            if p > m:\n                raise ValueError('{0} too large ({1} > {2})'\n                                 ''.format(s, p, m))\n        # make the locations\n        mat = np.array([[0, 0], [1, 0], [-1, 0], [0, 1], [0, -1]])\n        offsets = mat * np.array([h_pix, v_pix])\n        coords = (self._size / 2. + offsets)\n        n_samples = coords.shape[0]\n        targs = ' '.join(['{0},{1}'.format(*c) for c in coords])\n        seq = ','.join([str(x) for x in range(n_samples + 1)])\n        self._command('calibration_type = {0}'.format(ctype))\n        self._command('generate_default_targets = NO')\n        self._command('calibration_samples = {0}'.format(n_samples))\n        self._command('calibration_sequence = ' + seq)\n        self._command('calibration_targets = ' + targs)\n        self._command('validation_samples = {0}'.format(n_samples))\n        self._command('validation_sequence = ' + seq)\n        self._command('validation_targets = ' + targs)",
  "def get_eye_position(self):\n        \"\"\"The current eye position in pixels\n\n        Returns\n        -------\n        eye_pos : array\n            The current eye position. Will be [np.inf, np.inf] if the\n            eye is lost.\n\n        See Also\n        --------\n        EyelinkController.wait_for_fix\n        \"\"\"\n        if not self.dummy_mode:\n            sample = self._eyelink.getNewestSample()\n            if sample is None:\n                raise RuntimeError('No sample data, consider starting a '\n                                   'recording using el.start()')\n            if sample.isBinocular():\n                eye_pos = (np.array(sample.getLeftEye().getGaze()) +\n                           np.array(sample.getRightEye().getGaze())) / 2.\n            elif sample.isLeftSample:\n                eye_pos = np.array(sample.getLeftEye().getGaze())\n            elif sample.isRightSample:\n                eye_pos = np.array(sample.getRightEye().getGaze())\n            else:\n                eye_pos = np.array([np.inf, np.inf])\n            eye_pos -= (self._size / 2.)\n        else:\n            # use mouse, already referenced to center\n            eye_pos = self._ec.get_mouse_position()\n        return eye_pos",
  "def _toggle_dummy_cursor(self, visibility):\n        \"\"\"Show the cursor for dummy mode\"\"\"\n        if self.dummy_mode:\n            self._ec.toggle_cursor(visibility)",
  "def file_list(self):\n        \"\"\"The list of files started on the EyeLink\n        \"\"\"\n        return self._file_list",
  "def eye_used(self):\n        \"\"\"Return the eye used 'left' or 'right'\n\n        Returns\n        -------\n        eye : str\n            'left' or 'right'.\n        \"\"\"\n        eu = self._eyelink.eyeAvailable()\n        eu = eye_list[eu] if eu >= 0 else None\n        return eu",
  "def __init__(self, ec, beep=False):\n        cal_super_class.__init__(self)\n        self.__target_beep__ = None\n        self.__target_beep__done__ = None\n        self.__target_beep__error__ = None\n\n        # set some useful parameters\n        self.ec = ec\n        self.keys = []\n        ws = np.array(ec.window_size_pix)\n        self.img_span = 1.5 * np.array((float(ws[0]) / ws[1], 1.))\n\n        # set up reusable objects\n        self.targ_circ = FixationDot(self.ec)\n        self.loz_circ = Circle(self.ec, fill_color=None, line_width=2.0)\n        self.image_buffer = None\n\n        # deal with parent class\n        self.setup_cal_display = self.clear_display\n        self.exit_cal_display = self.clear_display\n        self.erase_cal_target = self.clear_display\n        self.clear_cal_display = self.clear_display\n        self.exit_image_display = self.clear_display\n        self.beep = beep\n        self.state = 0\n        self.mouse_pos = (0, 0)\n        self.img_size = (0, 0)",
  "def setup_event_handlers(self):\n        self.label = Text(self.ec, 'Eye Label', units='norm',\n                          pos=(0, -self.img_span[1] / 2.),\n                          anchor_y='top', color='white')\n        self.img = RawImage(self.ec, np.zeros((1, 2, 3)),\n                            pos=(0, 0), units='norm')\n\n        def on_mouse_press(x, y, button, modifiers):\n            self.state = 1\n\n        def on_mouse_motion(x, y, dx, dy):\n            self.mouse_pos = (x, y)\n\n        def on_mouse_release(x, y, button, modifiers):\n            self.state = 0\n\n        def on_mouse_drag(x, y, dx, dy, buttons, modifiers):\n            self.mouse_pos = (x, y)\n\n        def on_key_press(symbol, modifiers):\n            key_trans_dict = _get_key_trans_dict()\n            key = key_trans_dict.get(str(symbol), symbol)\n            self.keys += [pylink.KeyInput(key, modifiers)]\n\n        # create new handler at top of handling stack\n        self.ec.window.push_handlers(on_key_press, on_mouse_press,\n                                     on_mouse_motion, on_mouse_release,\n                                     on_mouse_drag)",
  "def release_event_handlers(self):\n        self.ec.window.pop_handlers()  # should detacch top-level handler\n        del self.label\n        del self.img",
  "def clear_display(self):\n        self.ec.flip()",
  "def record_abort_hide(self):\n        pass",
  "def draw_cal_target(self, x, y):\n        self.targ_circ.set_pos((x, y), units='pix')\n        self.targ_circ.draw()\n        self.ec.flip()",
  "def play_beep(self, eepid):\n        \"\"\"Play a sound during calibration/drift correct.\"\"\"\n        self.ec.system_beep() if self.beep else None",
  "def get_input_key(self):\n        self.ec.window.dispatch_events()\n        if len(self.keys) == 0:\n            return None\n        k = self.keys\n        self.keys = []\n        return k",
  "def get_mouse_state(self):\n        x, y = self._win2img(self.mouse_pos[0], self.mouse_pos[1])\n        return ((x, y), self.state)",
  "def _win2img(self, x, y):\n        \"\"\"Convert window coordinates to img coordinates\"\"\"\n        bounds, scale = self.img.bounds, self.img.scale\n        x = min(max(int((x - bounds[0]) / scale), 0), self.img_size[0])\n        y = min(max(int((bounds[3] - y) / scale), 0), self.img_size[1])\n        return x, y",
  "def _img2win(self, x, y):\n        \"\"\"Convert window coordinates to img coordinates\"\"\"\n        bounds, scale = self.img.bounds, self.img.scale\n        x = int(scale * x + bounds[0])\n        y = int(bounds[3] - scale * y)\n        return x, y",
  "def alert_printf(self, msg):\n        logger.warn('EyeLink: alert_printf {}'.format(msg))",
  "def setup_image_display(self, w, h):\n        # convert w, h from pixels to relative units\n        x = np.array([[0, 0], [0, self.img_span[1]]], float)\n        x = np.diff(self.ec._convert_units(x, 'norm', 'pix')[1]) / h\n        self.img.set_scale(x)\n        self.clear_display()",
  "def image_title(self, text):\n        text = \"<center>{0}</center>\".format(text)\n        self.label = Text(self.ec, text, units='norm', anchor_y='top',\n                          color='white', pos=(0, -self.img_span[1] / 2.))",
  "def set_image_palette(self, r, g, b):\n        self.palette = np.array([r, g, b], np.uint8).T",
  "def draw_image_line(self, width, line, totlines, buff):\n        if self.image_buffer is None:\n            self.img_size = (width, totlines)\n            self.image_buffer = np.empty((totlines, width, 3), float)\n        self.image_buffer[line - 1, :, :] = self.palette[buff, :] / 255.\n        if line == totlines:\n            self.img.set_image(self.image_buffer)\n            self.img.draw()\n            self.label.draw()\n            self.draw_cross_hair()\n            self.ec.flip()",
  "def draw_line(self, x1, y1, x2, y2, colorindex):\n        color = _get_color_dict()[str(colorindex)]\n        x1, y1 = self._img2win(x1, y1)\n        x2, y2 = self._img2win(x2, y2)\n        Line(self.ec, ((x1, x2), (y1, y2)), 'pix', color).draw()",
  "def draw_lozenge(self, x, y, width, height, colorindex):\n        coords = self._img2win(x + width / 2., y + width / 2.)\n        width = width * self.img.scale / 2.\n        height = height * self.img.scale / 2.\n        self.loz_circ.set_line_color(_get_color_dict()[str(colorindex)])\n        self.loz_circ.set_pos(coords, units='pix')\n        self.loz_circ.set_radius((width, height), units='pix')\n        self.loz_circ.draw()",
  "def on_mouse_press(x, y, button, modifiers):\n            self.state = 1",
  "def on_mouse_motion(x, y, dx, dy):\n            self.mouse_pos = (x, y)",
  "def on_mouse_release(x, y, button, modifiers):\n            self.state = 0",
  "def on_mouse_drag(x, y, dx, dy, buttons, modifiers):\n            self.mouse_pos = (x, y)",
  "def on_key_press(symbol, modifiers):\n            key_trans_dict = _get_key_trans_dict()\n            key = key_trans_dict.get(str(symbol), symbol)\n            self.keys += [pylink.KeyInput(key, modifiers)]",
  "class ExperimentController(object):\n    \"\"\"Interface for hardware control (audio, buttonbox, eye tracker, etc.)\n\n    Parameters\n    ----------\n    exp_name : str\n        Name of the experiment.\n    audio_controller : str | dict | None\n        If audio_controller is None, the type will be read from the system\n        configuration file. If a string, can be 'pyglet' or 'tdt', and the\n        remaining audio parameters will be read from the machine configuration\n        file. If a dict, must include a key 'TYPE' that is either 'pyglet'\n        or 'tdt'; the dict can contain other parameters specific to the TDT\n        (see documentation for expyfun.TDTController).\n    response_device : str | None\n        Must be 'keyboard', 'cedrus', or 'tdt'.  If None, the type will be read\n        from the machine configuration file.\n    stim_rms : float\n        The RMS amplitude that the stimuli were generated at (strongly\n        recommended to be 0.01).\n    stim_fs : int | float\n        The sampling frequency that the stimuli were generated with (samples\n        per second).\n    stim_db : float\n        The desired dB SPL at which to play the stimuli.\n    noise_db : float\n        The desired dB SPL at which to play the dichotic noise.\n    output_dir : str | None\n        An absolute or relative path to a directory in which raw experiment\n        data will be stored. If output_folder does not exist, it will be\n        created. Data will be saved to ``output_dir/SUBJECT_DATE``.\n        If None, no output data or logs will be saved (ONLY FOR TESTING!).\n    window_size : list | array | None\n        Window size to use. If list or array, it must have two elements.\n        If None, the default will be read from the system config,\n        falling back to [1920, 1080] if no system config is found.\n    screen_num : int | None\n        Screen to use. If None, the default will be read from the system\n        config, falling back to 0 if no system config is found.\n    full_screen : bool\n        Should the experiment window be fullscreen?\n    force_quit : list\n        Keyboard key(s) to utilize as an experiment force-quit button. Can be\n        a zero-element list for no force quit support. If None, defaults to\n        ``['lctrl', 'rctrl']``.  Using ``['escape']`` is not recommended due to\n        default handling of 'escape' in pyglet.\n    participant : str | None\n        If ``None``, a GUI will be used to acquire this information.\n    session : str | None\n        If ``None``, a GUI will be used to acquire this information.\n    trigger_controller : str | None\n        If ``None``, the type will be read from the system configuration file.\n        If a string, must be 'dummy', 'parallel', or 'tdt'. Note that by\n        default the mode is 'dummy', since setting up the parallel port\n        can be a pain. Can also be a dict with entries 'type' ('parallel')\n        and 'address' (e.g., '/dev/parport0').\n    verbose : bool, str, int, or None\n        If not None, override default verbose level (see expyfun.verbose).\n    check_rms : str | None\n        Method to use in checking stimulus RMS to ensure appropriate levels.\n        Possible values are ``None``, ``wholefile``, and ``windowed`` (the\n        default); see `set_rms_checking` for details.\n    suppress_resamp : bool\n        If ``True``, will suppress resampling of stimuli to the sampling\n        frequency of the sound output device.\n\n    Returns\n    -------\n    exp_controller : instance of ExperimentController\n        The experiment control interface.\n\n    Notes\n    -----\n    When debugging, it's useful to use the flush_logs() method to get\n    information (based on the level of verbosity) printed to the console.\n    \"\"\"\n\n    @verbose_dec\n    def __init__(self, exp_name, audio_controller=None, response_device=None,\n                 stim_rms=0.01, stim_fs=24414, stim_db=65, noise_db=45,\n                 output_dir='data', window_size=None, screen_num=None,\n                 full_screen=True, force_quit=None, participant=None,\n                 monitor=None, trigger_controller=None, session=None,\n                 verbose=None, check_rms='windowed', suppress_resamp=False):\n        # initialize some values\n        self._stim_fs = stim_fs\n        self._stim_rms = stim_rms\n        self._stim_db = stim_db\n        self._noise_db = noise_db\n        self._stim_scaler = None\n        self._suppress_resamp = suppress_resamp\n        # placeholder for extra actions to do on flip-and-play\n        self._on_every_flip = []\n        self._on_next_flip = []\n        self._on_trial_ok = []\n        # placeholder for extra actions to run on close\n        self._extra_cleanup_fun = []\n        self._id_call_dict = dict(ec_id=self._stamp_ec_id)\n        self._ac = None\n        self._data_file = None\n        self._playing = False  # whether or not play() was called w/o a 'stop'\n        self._clock = ZeroClock()\n        self._master_clock = self._clock.get_time\n\n        # put anything that could fail in this block to ensure proper cleanup!\n        try:\n            self.set_rms_checking(check_rms)\n            # Check Pyglet version for safety\n            _check_pyglet_version(raise_error=True)\n            # assure proper formatting for force-quit keys\n            if force_quit is None:\n                force_quit = ['lctrl', 'rctrl']\n            elif isinstance(force_quit, (int, string_types)):\n                force_quit = [str(force_quit)]\n            if 'escape' in force_quit:\n                logger.warning('Expyfun: using \"escape\" as a force-quit key '\n                               'is not recommended because it has special '\n                               'status in pyglet.')\n\n            # set up timing\n            # Use ZeroClock, which uses the \"clock\" fn but starts at zero\n            self._time_corrections = dict()\n            self._time_correction_fxns = dict()\n            self._time_correction_maxs = dict()  # optional, defaults to 10e-6\n\n            # dictionary for experiment metadata\n            self._exp_info = {'participant': participant, 'session': session,\n                              'exp_name': exp_name, 'date': date_str()}\n\n            # session start dialog, if necessary\n            fixed_list = ['exp_name', 'date']  # things not editable in GUI\n            for key, value in self._exp_info.items():\n                if key not in fixed_list and value is not None:\n                    if not isinstance(value, string_types):\n                        raise TypeError('{} must be string or None'\n                                        ''.format(value))\n                    fixed_list.append(key)\n\n            if len(fixed_list) < len(self._exp_info):\n                _get_items(self._exp_info, fixed=fixed_list, title=exp_name)\n\n            #\n            # initialize log file\n            #\n            self._output_dir = None\n            set_log_file(None)\n            if output_dir is not None:\n                output_dir = op.abspath(output_dir)\n                if not op.isdir(output_dir):\n                    os.mkdir(output_dir)\n                basename = op.join(output_dir, '{}_{}'\n                                   ''.format(self._exp_info['participant'],\n                                             self._exp_info['date']))\n                self._output_dir = basename\n                self._log_file = self._output_dir + '.log'\n                set_log_file(self._log_file)\n                closer = partial(set_log_file, None)\n                self._extra_cleanup_fun.append(closer)\n                # initialize data file\n                self._data_file = open(self._output_dir + '.tab', 'a')\n                self._extra_cleanup_fun.append(self._data_file.close)\n                self._data_file.write('# ' + str(self._exp_info) + '\\n')\n                self.write_data_line('event', 'value', 'timestamp')\n\n            #\n            # set up monitor\n            #\n            if screen_num is None:\n                screen_num = int(get_config('SCREEN_NUM', '0'))\n            if monitor is None:\n                mon_size = pyglet.window.get_platform().get_default_display()\n                mon_size = mon_size.get_screens()[screen_num]\n                mon_size = [mon_size.width, mon_size.height]\n                mon_size = ','.join([str(d) for d in mon_size])\n                monitor = dict()\n                width = float(get_config('SCREEN_WIDTH', '51.0'))\n                dist = float(get_config('SCREEN_DISTANCE', '48.0'))\n                monitor['SCREEN_WIDTH'] = width\n                monitor['SCREEN_DISTANCE'] = dist\n                mon_size = get_config('SCREEN_SIZE_PIX', mon_size).split(',')\n                mon_size = [int(p) for p in mon_size]\n                monitor['SCREEN_SIZE_PIX'] = mon_size\n            if not isinstance(monitor, dict):\n                raise TypeError('monitor must be a dict')\n            req_mon_keys = ['SCREEN_WIDTH', 'SCREEN_DISTANCE',\n                            'SCREEN_SIZE_PIX']\n            if not all([key in monitor for key in req_mon_keys]):\n                raise KeyError('monitor must have keys {0}'\n                               ''.format(req_mon_keys))\n            mon_size = monitor['SCREEN_SIZE_PIX']\n            monitor['SCREEN_DPI'] = (monitor['SCREEN_SIZE_PIX'][0] /\n                                     (monitor['SCREEN_WIDTH'] * 0.393701))\n            monitor['SCREEN_HEIGHT'] = (monitor['SCREEN_WIDTH'] /\n                                        float(monitor['SCREEN_SIZE_PIX'][0]) *\n                                        float(monitor['SCREEN_SIZE_PIX'][1]))\n            self._monitor = monitor\n\n            #\n            # parse audio controller\n            #\n            if audio_controller is None:\n                audio_controller = {'TYPE': get_config('AUDIO_CONTROLLER',\n                                                       'pyglet')}\n            elif isinstance(audio_controller, string_types):\n                if audio_controller.lower() in ['pyglet', 'tdt']:\n                    audio_controller = {'TYPE': audio_controller.lower()}\n                else:\n                    raise ValueError('audio_controller must be \\'pyglet\\' or '\n                                     '\\'tdt\\' (or a dict including \\'TYPE\\':'\n                                     ' \\'pyglet\\' or \\'TYPE\\': \\'tdt\\').')\n            elif not isinstance(audio_controller, dict):\n                raise TypeError('audio_controller must be a str or dict.')\n            self._audio_type = audio_controller['TYPE'].lower()\n\n            #\n            # parse response device\n            #\n            if response_device is None:\n                response_device = get_config('RESPONSE_DEVICE', 'keyboard')\n            if response_device not in ['keyboard', 'tdt', 'cedrus']:\n                raise ValueError('response_device must be \"keyboard\", \"tdt\", '\n                                 '\"cedrus\", or None')\n            self._response_device = response_device\n\n            #\n            # Initialize devices\n            #\n\n            # Audio (and for TDT, potentially keyboard)\n            if self._audio_type == 'tdt':\n                logger.info('Expyfun: Setting up TDT')\n                self._ac = TDTController(audio_controller)\n                self._audio_type = self._ac.model\n            elif self._audio_type == 'pyglet':\n                self._ac = PygletSoundController(self, self.stim_fs)\n            else:\n                raise ValueError('audio_controller[\\'TYPE\\'] must be '\n                                 '\\'pyglet\\' or \\'tdt\\'.')\n            self._extra_cleanup_fun.append(self._ac.halt)\n            # audio scaling factor; ensure uniform intensity across devices\n            self.set_stim_db(self._stim_db)\n            self.set_noise_db(self._noise_db)\n\n            if self._fs_mismatch:\n                msg = ('Expyfun: Mismatch between reported stim sample '\n                       'rate ({0}) and device sample rate ({1}).'\n                       ''.format(self.stim_fs, self.fs))\n                if self._suppress_resamp:\n                    msg += ('Nothing will be done about this because '\n                            'suppress_resamp is \"True\"')\n                else:\n                    msg += ('Experiment Controller will resample for you, but '\n                            'this takes a non-trivial amount of processing '\n                            'time and may compromise your experimental '\n                            'timing and/or cause artifacts.')\n                logger.warning(msg)\n\n            #\n            # set up visual window (must be done before keyboard and mouse)\n            #\n            logger.info('Expyfun: Setting up screen')\n            if full_screen:\n                window_size = monitor['SCREEN_SIZE_PIX']\n            else:\n                if window_size is None:\n                    window_size = get_config('WINDOW_SIZE',\n                                             '800,600').split(',')\n                    window_size = [int(w) for w in window_size]\n            window_size = np.array(window_size)\n            if window_size.ndim != 1 or window_size.size != 2:\n                raise ValueError('window_size must be 2-element array-like or '\n                                 'None')\n\n            # open window and setup GL config\n            self._setup_window(window_size, exp_name, full_screen, screen_num)\n\n            # Keyboard\n            if response_device == 'keyboard':\n                self._response_handler = Keyboard(self, force_quit)\n            elif response_device == 'tdt':\n                if not isinstance(self._ac, TDTController):\n                    raise ValueError('response_device can only be \"tdt\" if '\n                                     'tdt is used for audio')\n                self._response_handler = self._ac\n                self._ac._add_keyboard_init(self, force_quit)\n            else:  # response_device == 'cedrus'\n                self._response_handler = CedrusBox(self, force_quit)\n\n            #\n            # set up trigger controller\n            #\n            if trigger_controller is None:\n                trigger_controller = get_config('TRIGGER_CONTROLLER', 'dummy')\n            if isinstance(trigger_controller, string_types):\n                trigger_controller = dict(type=trigger_controller)\n            logger.info('Expyfun: Initializing {} triggering mode'\n                        ''.format(trigger_controller['type']))\n            if trigger_controller['type'] == 'tdt':\n                if not isinstance(self._ac, TDTController):\n                    raise ValueError('trigger_controller can only be \"tdt\" if '\n                                     'tdt is used for audio')\n                self._stamp_ttl_triggers = self._ac.stamp_triggers\n            elif trigger_controller['type'] in ['parallel', 'dummy']:\n                if 'address' not in trigger_controller['type']:\n                    addr = get_config('TRIGGER_ADDRESS')\n                    trigger_controller['address'] = addr\n                out = ParallelTrigger(trigger_controller['type'],\n                                      trigger_controller.get('address'))\n                self._stamp_ttl_triggers = out.stamp_triggers\n                self._extra_cleanup_fun.append(out.close)\n            else:\n                raise ValueError('trigger_controller type must be '\n                                 '\"parallel\", \"dummy\", or \"tdt\", not '\n                                 '{0}'.format(trigger_controller['type']))\n            self._id_call_dict['ttl_id'] = self._stamp_binary_id\n\n            # other basic components\n            self._mouse_handler = Mouse(self)\n            t = np.arange(44100 // 3) / 44100.\n            car = sum([np.sin(2 * np.pi * f * t) for f in [800, 1000, 1200]])\n            self._beep = None\n            self._beep_data = np.tile(car * np.exp(-t * 10) / 4, (2, 3))\n\n            # finish initialization\n            logger.info('Expyfun: Initialization complete')\n            logger.exp('Expyfun: Subject: {0}'\n                       ''.format(self._exp_info['participant']))\n            logger.exp('Expyfun: Session: {0}'\n                       ''.format(self._exp_info['session']))\n            ok_log = partial(self.write_data_line, 'trial_ok', None)\n            self._on_trial_ok.append(ok_log)\n            self._on_trial_ok.append(self.flush)\n            self._trial_progress = 'stopped'\n            self._ofp_critical_funs = list()\n        except Exception:\n            self.close()\n            raise\n\n    def __repr__(self):\n        \"\"\"Return a useful string representation of the experiment\n        \"\"\"\n        string = ('<ExperimentController ({3}): \"{0}\" {1} ({2})>'\n                  ''.format(self._exp_info['exp_name'],\n                            self._exp_info['participant'],\n                            self._exp_info['session'],\n                            self._audio_type))\n        return string\n\n# ############################### SCREEN METHODS ##############################\n    def screen_text(self, text, pos=[0, 0], color='white', font_name='Arial',\n                    font_size=24, wrap=True, units='norm', attr=True):\n        \"\"\"Show some text on the screen.\n\n        Parameters\n        ----------\n        text : str\n            The text to be rendered.\n        pos : list | tuple\n            x, y position of the text. In the default units (-1 to 1, with\n            positive going up and right) the default is dead center (0, 0).\n        color : matplotlib color\n            The text color.\n        font_name : str\n            The name of the font to use.\n        font_size : float\n            The font size (in points) to use.\n        wrap : bool\n            Whether or not the text will wrap to fit in screen, appropriate\n            for multi-line text. Inappropriate for text requiring\n            precise positioning or centering.\n        units : str\n            Units for `pos`. See `check_units` for options. Applies to\n            `pos` but not `font_size`.\n        attr : bool\n            Should the text be interpreted with pyglet's ``decode_attributed``\n            method? This allows inline formatting for text color, e.g.,\n            ``'This is {color (255, 0, 0, 255)}red text'``.\n\n        Returns\n        -------\n        Instance of visual.Text\n\n        See Also\n        --------\n        ExperimentController.screen_prompt\n        \"\"\"\n        check_units(units)\n        scr_txt = Text(self, text, pos, color, font_name, font_size,\n                       wrap=wrap, units=units, attr=attr)\n        scr_txt.draw()\n        self.call_on_next_flip(self.write_data_line, 'screen_text', text)\n        return scr_txt\n\n    def screen_prompt(self, text, max_wait=np.inf, min_wait=0, live_keys=None,\n                      timestamp=False, clear_after=True, pos=[0, 0],\n                      color='white', font_name='Arial', font_size=24,\n                      wrap=True, units='norm', attr=True):\n        \"\"\"Display text and (optionally) wait for user continuation\n\n        Parameters\n        ----------\n        text : str | list\n            The text to display. It will automatically wrap lines.\n            If list, the prompts will be displayed sequentially.\n        max_wait : float\n            The maximum amount of time to wait before returning. Can be np.inf\n            to wait until the user responds.\n        min_wait : float\n            The minimum amount of time to wait before returning. Useful for\n            avoiding subjects missing instructions.\n        live_keys : list | None\n            The acceptable list of buttons or keys to use to advance the trial.\n            If None, all buttons / keys will be accepted.  If an empty list,\n            the prompt displays until max_wait seconds have passed.\n        clear_after : bool\n            If True, the screen will be cleared before returning.\n        pos : list | tuple\n            x, y position of the text. In the default units (-1 to 1, with\n            positive going up and right) the default is dead center (0, 0).\n        color : matplotlib color\n            The text color.\n        font_name : str\n            The name of the font to use.\n        font_size : float\n            The font size (in points) to use.\n        wrap : bool\n            Whether or not the text will wrap to fit in screen, appropriate\n            for multi-line text. Inappropriate for text requiring\n            precise positioning or centering.\n        units : str\n            Units for `pos`. See `check_units` for options. Applies to\n            `pos` but not `font_size`.\n        attr : bool\n            Should the text be interpreted with pyglet's ``decode_attributed``\n            method? This allows inline formatting for text color, e.g.,\n            ``'This is {color (255, 0, 0, 255)}red text'``.\n\n        Returns\n        -------\n        pressed : tuple | str | None\n            If ``timestamp==True``, returns a tuple ``(str, float)`` indicating\n            the first key pressed and its timestamp (or ``(None, None)`` if no\n            acceptable key was pressed between ``min_wait`` and ``max_wait``).\n            If ``timestamp==False``, returns a string indicating the first key\n            pressed (or ``None`` if no acceptable key was pressed).\n\n        See Also\n        --------\n        ExperimentController.screen_text\n        \"\"\"\n        if not isinstance(text, list):\n            text = [text]\n        if not all([isinstance(t, string_types) for t in text]):\n            raise TypeError('text must be a string or list of strings')\n        for t in text:\n            self.screen_text(t, pos=pos, color=color, font_name=font_name,\n                             font_size=font_size, wrap=wrap, units=units,\n                             attr=attr)\n            self.flip()\n            out = self.wait_one_press(max_wait, min_wait, live_keys,\n                                      timestamp)\n        if clear_after:\n            self.flip()\n        return out\n\n    def set_background_color(self, color='black'):\n        \"\"\"Set and draw a solid background color\n\n        Parameters\n        ----------\n        color : matplotlib color\n            The background color.\n\n        Notes\n        -----\n        This should be called before anything else is drawn to the buffer,\n        since it will draw a filled rectangle over everything. On subsequent\n        flips, the rectangle will automatically be \"drawn\" because\n        ``glClearColor`` will be set so the buffer starts out with the\n        appropriate backgound color.\n        \"\"\"\n        # we go a little over here to be safe from round-off errors\n        Rectangle(self, pos=[0, 0, 2.1, 2.1], fill_color=color).draw()\n        gl.glClearColor(*[c / 255. for c in _convert_color(color)])\n\n    def start_stimulus(self, start_of_trial=True, flip=True, when=None):\n        \"\"\"Play audio, (optionally) flip screen, run any \"on_flip\" functions.\n\n        Parameters\n        ----------\n        start_of_trial : bool\n            If True, it checks to make sure that the trial ID has been\n            stamped appropriately. Set to False only in cases where\n            ``flip_and_play`` is to be used mid-trial (should be rare!).\n        flip : bool\n            If False, don't flip the screen.\n        when : float | None\n            Time to start stimulus. If None, start immediately.\n            Note that due to flip timing limitations, this is only a\n            guaranteed *minimum* (not absolute) wait time before the\n            flip completes (if `flip` is ``True``). As a result, in some\n            cases `when` should be set to a value smaller than your true\n            intended flip time.\n\n        Returns\n        -------\n        flip_time : float\n            The timestamp of the screen flip.\n\n        See Also\n        --------\n        ExperimentController.identify_trial\n        ExperimentController.flip\n        ExperimentController.play\n        ExperimentController.stop\n        ExperimentController.trial_ok\n\n        Notes\n        -----\n        Order of operations is: screen flip (optional), audio start, then\n        (only if ``flip=True``) additional functions added with\n        `call_on_next_flip` and `call_on_every_flip`.\n        \"\"\"\n        if start_of_trial:\n            if self._trial_progress != 'identified':\n                raise RuntimeError('Trial ID must be stamped before starting '\n                                   'the trial')\n            self._trial_progress = 'started'\n        extra = 'flipping screen and ' if flip else ''\n        logger.exp('Expyfun: Starting stimuli: {0}playing audio'.format(extra))\n        # ensure self._play comes first in list, followed by other critical\n        # private functions (e.g., EL stamping), then user functions:\n        if flip:\n            self._on_next_flip = ([self._play] + self._ofp_critical_funs +\n                                  self._on_next_flip)\n            stimulus_time = self.flip(when)\n        else:\n            if when is not None:\n                self.wait_until(when)\n            funs = [self._play] + self._ofp_critical_funs\n            self._win.dispatch_events()\n            stimulus_time = self.get_time()\n            for fun in funs:\n                fun()\n        return stimulus_time\n\n    def call_on_next_flip(self, function, *args, **kwargs):\n        \"\"\"Add a function to be executed on next flip only.\n\n        Parameters\n        ----------\n        function : function | None\n            The function to call. If ``None``, all the \"on every flip\"\n            functions will be cleared.\n        *args, **kwargs : arguments and keyword arguments\n            Arguments to pass to the function when calling it.\n\n        See Also\n        --------\n        ExperimentController.call_on_every_flip\n\n        Notes\n        -----\n        See `flip_and_play` for order of operations. Can be called multiple\n        times to add multiple functions to the queue.\n        \"\"\"\n        if function is not None:\n            function = partial(function, *args, **kwargs)\n            self._on_next_flip.append(function)\n        else:\n            self._on_next_flip = []\n\n    def call_on_every_flip(self, function, *args, **kwargs):\n        \"\"\"Add a function to be executed on every flip.\n\n        Parameters\n        ----------\n        function : function | None\n            The function to call. If ``None``, all the \"on every flip\"\n            functions will be cleared.\n        *args, **kwargs : arguments and keyword arguments\n            Arguments to pass to the function when calling it.\n\n        See Also\n        --------\n        ExperimentController.call_on_next_flip\n\n        Notes\n        -----\n        See `flip_and_play` for order of operations. Can be called multiple\n        times to add multiple functions to the queue.\n        \"\"\"\n        if function is not None:\n            function = partial(function, *args, **kwargs)\n            self._on_every_flip.append(function)\n        else:\n            self._on_every_flip = []\n\n    def _convert_units(self, verts, fro, to):\n        \"\"\"Convert between different screen units\"\"\"\n        check_units(to)\n        check_units(fro)\n        verts = np.array(np.atleast_2d(verts), dtype=float)\n        if verts.shape[0] != 2:\n            raise RuntimeError('verts must have 2 rows')\n\n        if fro == to:\n            return verts\n\n        # simplify by using two if neither is in normalized (native) units\n        if 'norm' not in [to, fro]:\n            # convert to normal\n            verts = self._convert_units(verts, fro, 'norm')\n            # convert from normal to dest\n            verts = self._convert_units(verts, 'norm', to)\n            return verts\n\n        # figure out our actual transition, knowing one is 'norm'\n        w_pix = self.window_size_pix[0]\n        h_pix = self.window_size_pix[1]\n        d_cm = self._monitor['SCREEN_DISTANCE']\n        w_cm = self._monitor['SCREEN_WIDTH']\n        h_cm = self._monitor['SCREEN_HEIGHT']\n        w_prop = w_pix / float(self.monitor_size_pix[0])\n        h_prop = h_pix / float(self.monitor_size_pix[1])\n        if 'pix' in [to, fro]:\n            if 'pix' == to:\n                # norm to pixels\n                x = np.array([[w_pix / 2., 0, w_pix / 2.],\n                              [0, h_pix / 2., h_pix / 2.]])\n            else:\n                # pixels to norm\n                x = np.array([[2. / w_pix, 0, -1.],\n                              [0, 2. / h_pix, -1.]])\n            verts = np.dot(x, np.r_[verts, np.ones((1, verts.shape[1]))])\n        elif 'deg' in [to, fro]:\n            if 'deg' == to:\n                # norm (window) to norm (whole screen), then to deg\n                x = np.arctan2(verts[0] * w_prop * (w_cm / 2.), d_cm)\n                y = np.arctan2(verts[1] * h_prop * (h_cm / 2.), d_cm)\n                verts = np.array([x, y])\n                verts *= (180. / np.pi)\n            else:\n                # deg to norm (whole screen), to norm (window)\n                verts *= (np.pi / 180.)\n                x = (d_cm * np.tan(verts[0])) / (w_cm / 2.) / w_prop\n                y = (d_cm * np.tan(verts[1])) / (h_cm / 2.) / h_prop\n                verts = np.array([x, y])\n        else:\n            raise KeyError('unknown conversion \"{}\" to \"{}\"'.format(fro, to))\n        return verts\n\n    def screenshot(self):\n        \"\"\"Capture the current displayed buffer\n\n        This method must be called *before* flipping, because it captures\n        the back buffer.\n\n        Returns\n        -------\n        scr : array\n            N x M x 3 array of screen pixel colors.\n        \"\"\"\n        # next line must be done in order to instantiate image_buffer_manager\n        data = pyglet.image.get_buffer_manager().get_color_buffer()\n        data = self._win.context.image_buffer_manager.color_buffer.image_data\n        data = data.get_data(data.format, data.pitch)\n        data = np.fromstring(data, dtype=np.uint8)\n        data.shape = (self._win.height, self._win.width, 4)\n        data = np.flipud(data)\n        return data\n\n    @property\n    def on_next_flip_functions(self):\n        \"\"\"Current stack of functions to be called on next flip.\"\"\"\n        return self._on_next_flip\n\n    @property\n    def on_every_flip_functions(self):\n        \"\"\"Current stack of functions called on every flip.\"\"\"\n        return self._on_every_flip\n\n    @property\n    def window(self):\n        \"\"\"Pyglet visual window handle.\"\"\"\n        return self._win\n\n    @property\n    def dpi(self):\n        return self._monitor['SCREEN_DPI']\n\n    @property\n    def window_size_pix(self):\n        return np.array([self._win.width, self._win.height])\n\n    @property\n    def monitor_size_pix(self):\n        return np.array(self._monitor['SCREEN_SIZE_PIX'])\n\n# ############################### OPENGL METHODS ##############################\n    def _setup_window(self, window_size, exp_name, full_screen, screen_num):\n        # Use 16x sampling here\n        config_kwargs = dict(depth_size=8, double_buffer=True, stereo=False,\n                             stencil_size=0, samples=0, sample_buffers=0)\n        # Travis can't handle multi-sampling, but our production machines must\n        if os.getenv('TRAVIS') == 'true':\n            del config_kwargs['samples'], config_kwargs['sample_buffers']\n        win_kwargs = dict(width=window_size[0], height=window_size[1],\n                          caption=exp_name, fullscreen=full_screen,\n                          screen=screen_num, style='borderless', visible=False,\n                          config=pyglet.gl.Config(**config_kwargs))\n\n        max_try = 5  # sometimes it fails for unknown reasons\n        for ii in range(max_try):\n            try:\n                win = pyglet.window.Window(**win_kwargs)\n            except pyglet.gl.ContextException:\n                if ii == max_try - 1:\n                    raise\n                else:\n                    pass\n            else:\n                break\n        if not full_screen:\n            x = int(win.screen.width / 2. - win.width / 2.)\n            y = int(win.screen.height / 2. - win.height / 2.)\n            win.set_location(x, y)\n        self._win = win\n        # with the context set up, do basic GL initialization\n        gl.glClearColor(0.0, 0.0, 0.0, 1.0)  # set the color to clear to\n        gl.glClearDepth(1.0)  # clear value for the depth buffer\n        # set the viewport size\n        gl.glViewport(0, 0, int(self.window_size_pix[0]),\n                      int(self.window_size_pix[1]))\n        # set the projection matrix\n        gl.glMatrixMode(gl.GL_PROJECTION)\n        gl.glLoadIdentity()\n        gl.gluOrtho2D(-1, 1, -1, 1)\n        # set the model matrix\n        gl.glMatrixMode(gl.GL_MODELVIEW)\n        gl.glLoadIdentity()\n        # disable depth testing\n        gl.glDisable(gl.GL_DEPTH_TEST)\n        # enable blending\n        gl.glEnable(gl.GL_BLEND)\n        gl.glBlendFunc(gl.GL_SRC_ALPHA, gl.GL_ONE_MINUS_SRC_ALPHA)\n        gl.glShadeModel(gl.GL_SMOOTH)\n        gl.glClear(gl.GL_COLOR_BUFFER_BIT)\n        v_ = False if os.getenv('_EXPYFUN_WIN_INVISIBLE') == 'true' else True\n        self.set_visible(v_)\n        win.dispatch_events()\n\n    def flip(self, when=None):\n        \"\"\"Flip screen, then run any \"on-flip\" functions.\n\n        Parameters\n        ----------\n        when : float | None\n            Time to flip. If None, flip immediately. Note that due to flip\n            timing limitations, this is only a guaranteed *minimum* (not\n            absolute) wait time before the flip completes. As a result, in\n            some cases `when` should be set to a value smaller than your\n            true intended flip time.\n\n        Returns\n        -------\n        flip_time : float\n            The timestamp of the screen flip.\n\n        See Also\n        --------\n        ExperimentController.identify_trial\n        ExperimentController.play\n        ExperimentController.start_stimulus\n        ExperimentController.stop\n        ExperimentController.trial_ok\n\n        Notes\n        -----\n        Order of operations is: screen flip, functions added with\n        `call_on_next_flip`, followed by functions added with\n        `call_on_every_flip`.\n        \"\"\"\n        if when is not None:\n            self.wait_until(when)\n        call_list = self._on_next_flip + self._on_every_flip\n        self._win.dispatch_events()\n        self._win.switch_to()\n        gl.glFinish()\n        self._win.flip()\n        # this waits until everything is called, including last draw\n        gl.glClear(gl.GL_COLOR_BUFFER_BIT)\n        gl.glBegin(gl.GL_POINTS)\n        gl.glColor4f(0, 0, 0, 0)\n        gl.glVertex2i(10, 10)\n        gl.glEnd()\n        gl.glFinish()\n        flip_time = self.get_time()\n        for function in call_list:\n            function()\n        self.write_data_line('flip', flip_time)\n        self._on_next_flip = []\n        return flip_time\n\n    def estimate_screen_fs(self, n_rep=10):\n        \"\"\"Estimate screen refresh rate using repeated flip() calls\n\n        Useful for verifying that a system is operating at the proper\n        sample rate.\n\n        Parameters\n        ----------\n        n_rep : int\n            Number of flips to use. The higher the number, the more accurate\n            the estimate but the more time will be consumed.\n\n        Returns\n        -------\n        screen_fs : float\n            The screen refresh rate.\n        \"\"\"\n        n_rep = int(n_rep)\n        times = [self.flip() for _ in range(n_rep)]\n        return 1. / np.median(np.diff(times[1:]))\n\n    def set_visible(self, visible=True, flip=True):\n        \"\"\"Set the window visibility\n\n        Parameters\n        ----------\n        visible : bool\n            The visibility.\n        flip : bool\n            If `visible` is ``True``, call `flip` after setting visible.\n            This fixes an issue with the window background color not\n            being set properly for the first draw after setting visible;\n            by default (at least on Linux) the background is black when\n            the window is restored, regardless of what the glClearColor\n            had been set to.\n        \"\"\"\n        self._win.set_visible(visible)\n        logger.exp('Expyfun: Set screen visibility {0}'.format(visible))\n        if visible and flip:\n            self.flip()\n\n# ############################## KEYPRESS METHODS #############################\n    def listen_presses(self):\n        \"\"\"Start listening for keypresses.\n\n        See Also\n        --------\n        ExperimentController.get_presses\n        ExperimentController.wait_one_press\n        ExperimentController.wait_for_presses\n        \"\"\"\n        self._response_handler.listen_presses()\n\n    def get_presses(self, live_keys=None, timestamp=True, relative_to=None):\n        \"\"\"Get the entire keyboard / button box buffer.\n\n        Parameters\n        ----------\n        live_keys : list | None\n            List of strings indicating acceptable keys or buttons. Other data\n            types are cast as strings, so a list of ints will also work.\n            ``None`` accepts all keypresses.\n        timestamp : bool\n            Whether the keypress should be timestamped. If True, returns the\n            button press time relative to the value given in `relative_to`.\n        relative_to : None | float\n            A time relative to which timestamping is done. Ignored if\n            timestamp==False.  If ``None``, timestamps are relative to the time\n            `listen_presses` was last called.\n\n        Returns\n        -------\n        presses : list\n            If timestamp==False, returns a list of strings indicating which\n            keys were pressed. Otherwise, returns a list of tuples\n            (str, float) of keys and their timestamps.\n\n        See Also\n        --------\n        ExperimentController.listen_presses\n        ExperimentController.wait_one_press\n        ExperimentController.wait_for_presses\n        \"\"\"\n        return self._response_handler.get_presses(live_keys, timestamp,\n                                                  relative_to)\n\n    def wait_one_press(self, max_wait=np.inf, min_wait=0.0, live_keys=None,\n                       timestamp=True, relative_to=None):\n        \"\"\"Returns only the first button pressed after min_wait.\n\n        Parameters\n        ----------\n        max_wait : float\n            Duration after which control is returned if no key is pressed.\n        min_wait : float\n            Duration for which to ignore keypresses (force-quit keys will\n            still be checked at the end of the wait).\n        live_keys : list | None\n            List of strings indicating acceptable keys or buttons. Other data\n            types are cast as strings, so a list of ints will also work.\n            ``None`` accepts all keypresses.\n        timestamp : bool\n            Whether the keypress should be timestamped. If ``True``, returns\n            the button press time relative to the value given in\n            `relative_to`.\n        relative_to : None | float\n            A time relative to which timestamping is done. Ignored if\n            ``timestamp==False``.  If ``None``, timestamps are relative to the\n            time `wait_one_press` was called.\n\n        Returns\n        -------\n        pressed : tuple | str | None\n            If ``timestamp==True``, returns a tuple (str, float) indicating the\n            first key pressed and its timestamp (or ``(None, None)`` if no\n            acceptable key was pressed between `min_wait` and `max_wait`).\n            If ``timestamp==False``, returns a string indicating the first key\n            pressed (or ``None`` if no acceptable key was pressed).\n\n        See Also\n        --------\n        ExperimentController.listen_presses\n        ExperimentController.get_presses\n        ExperimentController.wait_for_presses\n        \"\"\"\n        return self._response_handler.wait_one_press(max_wait, min_wait,\n                                                     live_keys, timestamp,\n                                                     relative_to)\n\n    def wait_for_presses(self, max_wait, min_wait=0.0, live_keys=None,\n                         timestamp=True, relative_to=None):\n        \"\"\"Returns all button presses between min_wait and max_wait.\n\n        Parameters\n        ----------\n        max_wait : float\n            Duration after which control is returned.\n        min_wait : float\n            Duration for which to ignore keypresses (force-quit keys will\n            still be checked at the end of the wait).\n        live_keys : list | None\n            List of strings indicating acceptable keys or buttons. Other data\n            types are cast as strings, so a list of ints will also work.\n            ``None`` accepts all keypresses.\n        timestamp : bool\n            Whether the keypresses should be timestamped. If ``True``, returns\n            the button press time relative to the value given in\n            `relative_to`.\n        relative_to : None | float\n            A time relative to which timestamping is done. Ignored if\n            `timestamp` is ``False``.  If ``None``, timestamps are relative\n            to the time `wait_for_presses` was called.\n\n        Returns\n        -------\n        presses : list\n            If timestamp==False, returns a list of strings indicating which\n            keys were pressed. Otherwise, returns a list of tuples\n            (str, float) of keys and their timestamps.\n\n        See Also\n        --------\n        ExperimentController.listen_presses\n        ExperimentController.get_presses\n        ExperimentController.wait_one_press\n        \"\"\"\n        return self._response_handler.wait_for_presses(max_wait, min_wait,\n                                                       live_keys, timestamp,\n                                                       relative_to)\n\n    def _log_presses(self, pressed):\n        \"\"\"Write key presses to data file.\n        \"\"\"\n        # This function will typically be called by self._response_handler\n        # after it retrieves some button presses\n        for key, stamp in pressed:\n            self.write_data_line('keypress', key, stamp)\n\n    def check_force_quit(self):\n        \"\"\"Check to see if any force quit keys were pressed\n        \"\"\"\n        self._response_handler.check_force_quit()\n\n# ############################## MOUSE METHODS ################################\n    def listen_clicks(self):\n        \"\"\"Start listening for mouse clicks.\n\n        See Also\n        --------\n        ExperimentController.get_clicks\n        ExperimentController.get_mouse_position\n        ExperimentController.toggle_cursor\n        \"\"\"\n        self._mouse_handler.listen_clicks()\n\n    def get_clicks(self, live_buttons=None, timestamp=True, relative_to=None):\n        \"\"\"Get the entire keyboard / button box buffer.\n\n        Parameters\n        ----------\n        live_buttons : list | None\n            List of strings indicating acceptable buttons.\n            ``None`` accepts all mouse clicks.\n        timestamp : bool\n            Whether the mouse click should be timestamped. If True, returns the\n            button click time relative to the value given in `relative_to`.\n        relative_to : None | float\n            A time relative to which timestamping is done. Ignored if\n            timestamp==False.  If ``None``, timestamps are relative to the time\n            `listen_clicks` was last called.\n\n        Returns\n        -------\n        clicks : list of tuple\n            Returns a list of the clicks between min_wait and max_wait.\n            If ``timestamp==True``, each entry is a tuple (str, int, int,\n            float) indicating the button clicked and its timestamp.\n            If ``timestamp==False``, each entry is a tuple (str, int, int)\n            indicating the button clicked.\n\n        See Also\n        --------\n        ExperimentController.get_mouse_position\n        ExperimentController.listen_clicks\n        ExperimentController.toggle_cursor\n        ExperimentController.wait_one_click\n        ExperimentController.wait_for_clicks\n        \"\"\"\n        return self._mouse_handler.get_clicks(live_buttons, timestamp,\n                                              relative_to)\n\n    def get_mouse_position(self, units='pix'):\n        \"\"\"Mouse position in screen coordinates\n\n        Parameters\n        ----------\n        units : str\n            Units to return. See `check_units` for options.\n\n        Returns\n        -------\n        position : ndarray\n            The mouse position.\n\n        See Also\n        --------\n        ExperimentController.get_clicks\n        ExperimentController.listen_clicks\n        ExperimentController.toggle_cursor\n        ExperimentController.wait_one_click\n        ExperimentController.wait_for_clicks\n        \"\"\"\n        check_units(units)\n        pos = np.array(self._mouse_handler.pos)\n        pos = self._convert_units(pos[:, np.newaxis], 'norm', units)[:, 0]\n        return pos\n\n    def toggle_cursor(self, visibility, flip=False):\n        \"\"\"Show or hide the mouse\n\n        Parameters\n        ----------\n        visibility : bool\n            If True, show; if False, hide.\n\n        See Also\n        --------\n        ExperimentController.get_clicks\n        ExperimentController.get_mouse_position\n        ExperimentController.listen_clicks\n        ExperimentController.wait_one_click\n        ExperimentController.wait_for_clicks\n        \"\"\"\n        try:\n            self._mouse_handler.set_visible(visibility)\n            # TODO move mouse to lower right corner for windows no-hide bug\n        except Exception:\n            pass  # pyglet bug on Linux!\n        if flip:\n            self.flip()\n\n    def wait_one_click(self, max_wait=np.inf, min_wait=0.0, live_buttons=None,\n                       timestamp=True, relative_to=None, visible=None):\n        \"\"\"Returns only the first mouse button clicked after min_wait.\n\n        Parameters\n        ----------\n        max_wait : float\n            Duration after which control is returned if no button is clicked.\n        min_wait : float\n            Duration for which to ignore button clicks.\n        live_buttons : list | None\n            List of strings indicating acceptable buttons.\n            ``None`` accepts all mouse clicks.\n        timestamp : bool\n            Whether the mouse click should be timestamped. If ``True``, returns\n            the mouse click time relative to the value given in\n            ``relative_to``.\n        relative_to : None | float\n            A time relative to which timestamping is done. Ignored if\n            ``timestamp==False``.  If ``None``, timestamps are relative to the\n            time `wait_one_click` was called.\n        visible : None | bool\n            Whether to show the cursor while in the function. ``None`` has no\n            effect and is the default. A boolean will show it (or not) while\n            the function has control and then set visibility back to its\n            previous value afterwards.\n\n        Returns\n        -------\n        clicked : tuple | str | None\n            If ``timestamp==True``, returns a tuple (str, int, int, float)\n            indicating the first button clicked and its timestamp (or\n            ``(None, None, None, None)`` if no acceptable button was clicked\n            between `min_wait` and `max_wait`). If ``timestamp==False``,\n            returns a tuple (str, int, int) indicating the first button clicked\n            (or ``(None, None, None)`` if no acceptable key was clicked).\n\n        See Also\n        --------\n        ExperimentController.get_clicks\n        ExperimentController.get_mouse_position\n        ExperimentController.listen_clicks\n        ExperimentController.toggle_cursor\n        ExperimentController.wait_for_clicks\n        \"\"\"\n        return self._mouse_handler.wait_one_click(max_wait, min_wait,\n                                                  live_buttons, timestamp,\n                                                  relative_to, visible)\n\n    def wait_for_clicks(self, max_wait=np.inf, min_wait=0.0, live_buttons=None,\n                        timestamp=True, relative_to=None, visible=None):\n        \"\"\"Returns all clicks between min_wait and max_wait.\n\n        Parameters\n        ----------\n        max_wait : float\n            Duration after which control is returned if no button is clicked.\n        min_wait : float\n            Duration for which to ignore button clicks.\n        live_buttons : list | None\n            List of strings indicating acceptable buttons.\n            ``None`` accepts all mouse clicks.\n        timestamp : bool\n            Whether the mouse click should be timestamped. If ``True``, returns\n            the mouse click time relative to the value given in\n            ``relative_to``.\n        relative_to : None | float\n            A time relative to which timestamping is done. Ignored if\n            ``timestamp==False``.  If ``None``, timestamps are relative to the\n            time ``wait_one_click`` was called.\n        visible : None | bool\n            Whether to show the cursor while in the function. ``None`` has no\n            effect and is the default. A boolean will show it (or not) while\n            the function has control and then set visibility back to its\n            previous value afterwards.\n\n        Returns\n        -------\n        clicks : list of tuple\n            Returns a list of the clicks between min_wait and max_wait.\n            If ``timestamp==True``, each entry is a tuple (str, int, int,\n            float) indicating the button clicked and its timestamp.\n            If ``timestamp==False``, each entry is a tuple (str, int, int)\n            indicating the button clicked.\n\n        See Also\n        --------\n        ExperimentController.get_clicks\n        ExperimentController.get_mouse_position\n        ExperimentController.listen_clicks\n        ExperimentController.toggle_cursor\n        ExperimentController.wait_one_click\n        \"\"\"\n        return self._mouse_handler.wait_for_clicks(max_wait, min_wait,\n                                                   live_buttons, timestamp,\n                                                   relative_to, visible)\n\n    def wait_for_click_on(self, objects, max_wait=np.inf, min_wait=0.0,\n                          live_buttons=None, timestamp=True, relative_to=None):\n        \"\"\"Returns the first click after min_wait over a visual object.\n\n        Parameters\n        ----------\n        objects : list | Rectangle | Circle\n            A list of objects (or a single object) that the user may click on.\n            Supported types are: Rectangle, Circle\n        max_wait : float\n            Duration after which control is returned if no button is clicked.\n        min_wait : float\n            Duration for which to ignore button clicks.\n        live_buttons : list | None\n            List of strings indicating acceptable buttons.\n            ``None`` accepts all mouse clicks.\n        timestamp : bool\n            Whether the mouse click should be timestamped. If ``True``, returns\n            the mouse click time relative to the value given in\n            `relative_to`.\n        relative_to : None | float\n            A time relative to which timestamping is done. Ignored if\n            ``timestamp==False``.  If ``None``, timestamps are relative to the\n            time `wait_one_click` was called.\n\n        Returns\n        -------\n        clicked : tuple | str | None\n            If ``timestamp==True``, returns a tuple (str, int, int, float)\n            indicating the first valid button clicked and its timestamp (or\n            ``(None, None, None, None)`` if no acceptable button was clicked\n            between `min_wait` and `max_wait`). If ``timestamp==False``,\n            returns a tuple (str, int, int) indicating the first button clicked\n            (or ``(None, None, None)`` if no acceptable key was clicked).\n        index : the index of the object in the list of objects that was clicked\n            on. Returns None if time ran out before a valid click. If objects\n            were overlapping, it returns the index of the object that comes\n            first in the `objects` argument.\n        \"\"\"\n        legal_types = self._mouse_handler._legal_types\n        if isinstance(objects, legal_types):\n            objects = [objects]\n        elif not isinstance(objects, list):\n            raise TypeError('objects must be a list or one of: %s' %\n                            (legal_types,))\n        return self._mouse_handler.wait_for_click_on(\n            objects, max_wait, min_wait, live_buttons, timestamp, relative_to)\n\n    def _log_clicks(self, clicked):\n        \"\"\"Write mouse clicks to data file.\n        \"\"\"\n        # This function will typically be called by self._response_handler\n        # after it retrieves some mouse clicks\n        for button, x, y, stamp in clicked:\n            self.write_data_line('mouseclick', '%s,%i,%i' % (button, x, y),\n                                 stamp)\n\n# ############################## AUDIO METHODS ################################\n    def system_beep(self):\n        \"\"\"Play a system beep\n\n        This will play through the system audio, *not* through the\n        audio controller (unless that is set to be the system audio).\n        This is useful for e.g., notifying that it's time for an\n        eye-tracker calibration.\n        \"\"\"\n        if self._beep is not None:\n            self._beep.delete()\n        self._beep = SoundPlayer(self._beep_data, 44100)\n        self._beep.play()\n\n    def start_noise(self):\n        \"\"\"Start the background masker noise\n\n        See Also\n        --------\n        ExperimentController.set_noise_db\n        ExperimentController.stop_noise\n        \"\"\"\n        self._ac.start_noise()\n\n    def stop_noise(self):\n        \"\"\"Stop the background masker noise\n\n        See Also\n        --------\n        ExperimentControlller.set_noise_db\n        ExperimentController.start_noise\n        \"\"\"\n        if self._ac is not None:  # check b/c used by __exit__\n            self._ac.stop_noise()\n\n    def clear_buffer(self):\n        \"\"\"Clear audio data from the audio buffer\n\n        See Also\n        --------\n        ExperimentController.load_buffer\n        ExperimentController.set_stim_db\n        \"\"\"\n        self._ac.clear_buffer()\n        logger.exp('Expyfun: Buffer cleared')\n\n    def load_buffer(self, samples):\n        \"\"\"Load audio data into the audio buffer\n\n        Parameters\n        ----------\n        samples : np.array\n            Audio data as floats scaled to (-1,+1), formatted as numpy array\n            with shape (1, N), (2, N), or (N,) dtype float32.\n\n        See Also\n        --------\n        ExperimentController.clear_buffer\n        ExperimentController.play\n        ExperimentController.set_stim_db\n        ExperimentController.start_stimulus\n        ExperimentController.stop\n        \"\"\"\n        samples = self._validate_audio(samples) * self._stim_scaler\n        logger.exp('Expyfun: Loading {} samples to buffer'\n                   ''.format(samples.size))\n        self._ac.load_buffer(samples)\n\n    def play(self):\n        \"\"\"Start audio playback\n\n        Returns\n        -------\n        play_time : float\n            The timestamp of the audio playback.\n\n        See Also\n        --------\n        ExperimentController.clear_buffer\n        ExperimentController.load_buffer\n        ExperimentController.set_stim_db\n        ExperimentController.start_stimulus\n        ExperimentController.stop\n        \"\"\"\n        logger.exp('Expyfun: Playing audio')\n        # ensure self._play comes first in list:\n        self._play()\n        return self.get_time()\n\n    def _play(self):\n        \"\"\"Play the audio buffer.\n        \"\"\"\n        if self._playing:\n            raise RuntimeError('Previous audio must be stopped before playing')\n        self._ac.play()\n        logger.debug('Expyfun: started audio')\n        self._playing = True\n        self.write_data_line('play')\n\n    def stop(self):\n        \"\"\"Stop audio buffer playback and reset cursor to beginning of buffer\n\n        See Also\n        --------\n        ExperimentController.clear_buffer\n        ExperimentController.load_buffer\n        ExperimentController.play\n        ExperimentController.set_stim_db\n        ExperimentController.start_stimulus\n        \"\"\"\n        if self._ac is not None:  # need to check b/c used in __exit__\n            self._ac.stop()\n        self.write_data_line('stop')\n        self._playing = False\n        logger.exp('Expyfun: Audio stopped and reset.')\n\n    def set_noise_db(self, new_db):\n        \"\"\"Set the level of the background noise\n\n        See Also\n        --------\n        ExperimentController.start_noise\n        ExperimentController.stop_noise\n        \"\"\"\n        # Noise is always generated at an RMS of 1\n        self._ac.set_noise_level(self._update_sound_scaler(new_db, 1.0))\n        self._noise_db = new_db\n\n    def set_stim_db(self, new_db):\n        \"\"\"Set the level of the stimuli\n\n        See Also\n        --------\n        ExperimentController.clear_buffer\n        ExperimentController.load_buffer\n        ExperimentController.play\n        ExperimentController.start_stimulus\n        ExperimentController.stop\n        \"\"\"\n        self._stim_db = new_db\n        self._stim_scaler = self._update_sound_scaler(new_db, self._stim_rms)\n        # not immediate: new value is applied on the next load_buffer call\n\n    def _update_sound_scaler(self, desired_db, orig_rms):\n        \"\"\"Calcs coefficient ensuring stim ampl equivalence across devices.\n        \"\"\"\n        exponent = (-(_get_dev_db(self._audio_type) - desired_db) / 20.0)\n        return (10 ** exponent) / float(orig_rms)\n\n    def _validate_audio(self, samples):\n        \"\"\"Converts audio sample data to the required format.\n\n        Parameters\n        ----------\n        samples : list | array\n            The audio samples.  Mono sounds will be converted to stereo.\n\n        Returns\n        -------\n        samples : numpy.array(dtype='float32')\n            The correctly formatted audio samples.\n        \"\"\"\n        # check data type\n        if isinstance(samples, list):\n            samples = np.asarray(samples, dtype='float32')\n        elif samples.dtype != 'float32':\n            samples = np.float32(samples)\n\n        # check values\n        if np.max(np.abs(samples)) > 1:\n            raise ValueError('Sound data exceeds +/- 1.')\n            # samples /= np.max(np.abs(samples),axis=0)\n\n        # check shape and dimensions, make stereo\n        samples = _fix_audio_dims(samples, 2).T\n\n        # resample if needed\n        if self._fs_mismatch and not self._suppress_resamp:\n            logger.warning('Expyfun: Resampling {} seconds of audio'\n                           ''.format(round(len(samples) / self.stim_fs), 2))\n            samples = resample(samples, self.fs, self.stim_fs, axis=0)\n\n        # check RMS\n        if self._check_rms is not None:\n            chans = [samples[:, x] for x in range(samples.shape[1])]\n            if self._check_rms == 'wholefile':\n                chan_rms = [np.sqrt(np.mean(x ** 2)) for x in chans]\n                max_rms = max(chan_rms)\n            else:  # 'windowed'\n                win_length = int(self.fs * 0.01)  # 10ms running window\n                chan_rms = [running_rms(x, win_length) for x in chans]\n                max_rms = max([max(x) for x in chan_rms])\n            if max_rms > 2 * self._stim_rms:\n                warn_string = ('Expyfun: Stimulus max RMS ({}) exceeds stated '\n                               'RMS ({}) by more than 6 dB.'\n                               ''.format(max_rms, self._stim_rms))\n                logger.warning(warn_string)\n                warnings.warn(warn_string)\n            elif max_rms < 0.5 * self._stim_rms:\n                warn_string = ('Expyfun: Stimulus max RMS ({}) is less than '\n                               'stated RMS ({}) by more than 6 dB.'\n                               ''.format(max_rms, self._stim_rms))\n                logger.warning(warn_string)\n\n        # always prepend a zero to deal with TDT reset of buffer position\n        samples = np.r_[np.atleast_2d([0.0, 0.0]), samples]\n        return np.ascontiguousarray(samples)\n\n    def set_rms_checking(self, check_rms):\n        \"\"\"Set the RMS checking flag.\n\n        Parameters\n        ----------\n        check_rms : str | None\n            Method to use in checking stimulus RMS to ensure appropriate\n            levels. ``'windowed'`` uses a 10ms window to find the max RMS in\n            each channel and checks to see that it is within 6 dB of the stated\n            ``stim_rms``.  ``'wholefile'`` checks the RMS of the stimulus as a\n            whole, while ``None`` disables RMS checking.\n        \"\"\"\n        if check_rms not in [None, 'wholefile', 'windowed']:\n            raise ValueError('check_rms must be one of \"wholefile\", \"windowed\"'\n                             ', or None.')\n        self._check_rms = check_rms\n\n# ############################## OTHER METHODS ################################\n    @property\n    def participant(self):\n        return self._exp_info['participant']\n\n    @property\n    def session(self):\n        return self._exp_info['session']\n\n    @property\n    def exp_name(self):\n        return self._exp_info['exp_name']\n\n    @property\n    def data_fname(self):\n        \"\"\"Date filename\"\"\"\n        return self._data_file.name\n\n    def get_time(self):\n        \"\"\"Return current master clock time\n\n        Returns\n        -------\n        time : float\n            Time since ExperimentController was created.\n        \"\"\"\n        return self._clock.get_time()\n\n    def write_data_line(self, event_type, value=None, timestamp=None):\n        \"\"\"Add a line of data to the output CSV.\n\n        Parameters\n        ----------\n        event_type : str\n            Type of event (e.g., keypress, screen flip, etc.)\n        value : None | str\n            Anything that can be cast to a string is okay here.\n        timestamp : float | None\n            The timestamp when the event occurred.  If ``None``, will use the\n            time the data line was written from the master clock.\n\n        Notes\n        -----\n        Writing a data line does not cause the file to be flushed.\n        \"\"\"\n        if timestamp is None:\n            timestamp = self._master_clock()\n        ll = '\\t'.join(_sanitize(x) for x in [timestamp, event_type,\n                                              value]) + '\\n'\n        if self._data_file is not None and not self._data_file.closed:\n            self._data_file.write(ll)\n\n    def _get_time_correction(self, clock_type):\n        \"\"\"Clock correction (sec) for different devices (screen, bbox, etc.)\n        \"\"\"\n        time_correction = (self._master_clock() -\n                           self._time_correction_fxns[clock_type]())\n        if clock_type not in self._time_corrections:\n            self._time_corrections[clock_type] = time_correction\n\n        diff = time_correction - self._time_corrections[clock_type]\n        max_dt = self._time_correction_maxs.get(clock_type, 10e-6)\n        if np.abs(diff) > max_dt:\n            logger.warning('Expyfun: drift of > {} microseconds ({}) '\n                           'between {} clock and EC master clock.'\n                           ''.format(max_dt * 1e6, int(round(diff * 1e6)),\n                                     clock_type))\n        logger.debug('Expyfun: time correction between {} clock and EC '\n                     'master clock is {}. This is a change of {}.'\n                     ''.format(clock_type, time_correction, time_correction -\n                               self._time_corrections[clock_type]))\n        return time_correction\n\n    def wait_secs(self, secs):\n        \"\"\"Wait a specified number of seconds.\n\n        Parameters\n        ----------\n        secs : float\n            Number of seconds to wait.\n\n        See Also\n        --------\n        ExperimentController.wait_until\n        wait_secs\n        \"\"\"\n        wait_secs(secs, ec=self)\n\n    def wait_until(self, timestamp):\n        \"\"\"Wait until the given time is reached.\n\n        Parameters\n        ----------\n        timestamp : float\n            A time to wait until, evaluated against the experiment master\n            clock.\n\n        Returns\n        -------\n        remaining_time : float\n            The difference between ``timestamp`` and the time `wait_until`\n            was called.\n\n        See Also\n        --------\n        ExperimentController.wait_secs\n        wait_secs\n\n        Notes\n        -----\n        Unlike `wait_secs`, there is no guarantee of precise timing with this\n        function. It is the responsibility of the user to do choose a\n        reasonable timestamp (or equivalently, do a reasonably small amount of\n        processing prior to calling `wait_until`).\n        \"\"\"\n        time_left = timestamp - self._master_clock()\n        if time_left < 0:\n            logger.warning('Expyfun: wait_until was called with a timestamp '\n                           '({}) that had already passed {} seconds prior.'\n                           ''.format(timestamp, -time_left))\n        else:\n            wait_secs(time_left)\n        return time_left\n\n    def identify_trial(self, **ids):\n        \"\"\"Identify trial type before beginning the trial\n\n        Parameters\n        ----------\n        **ids : keyword arguments\n            Ids to stamp, e.g. ``ec_id='TL90,MR45'. Use `id_types`\n            to see valid options. Typical choices are ``ec_id``, ``el_id``,\n            and ``ttl_id`` for experiment controller, eyelink, and TDT\n            (or parallel port) respectively.\n\n        See Also\n        --------\n        ExperimentController.id_types\n        ExperimentController.stamp_triggers\n        ExperimentController.start_stimulus\n        ExperimentController.stop\n        ExperimentController.trial_ok\n        \"\"\"\n        if self._trial_progress != 'stopped':\n            raise RuntimeError('Cannot identify a trial twice')\n        call_set = set(self._id_call_dict.keys())\n        passed_set = set(ids.keys())\n        if not call_set == passed_set:\n            raise KeyError('All keys passed in {0} must match the set of '\n                           'keys required {1}'.format(passed_set, call_set))\n        ll = max([len(key) for key in ids.keys()])\n        for key, id_ in ids.items():\n            logger.exp('Expyfun: Stamp trial ID to {0} : {1}'\n                       ''.format(key.ljust(ll), str(id_)))\n            self._id_call_dict[key](id_)\n        self._trial_progress = 'identified'\n\n    def trial_ok(self):\n        \"\"\"Report that the trial was okay and do post-trial tasks.\n\n        For example, logs and data files can be flushed at the end of each\n        trial.\n\n        See Also\n        --------\n        ExperimentController.identify_trial\n        ExperimentController.start_stimulus\n        ExperimentController.stop\n        \"\"\"\n        if self._trial_progress != 'started':\n            raise RuntimeError('trial cannot be okay unless it was started, '\n                               'did you call ec.start_stimulus?')\n        for func in self._on_trial_ok:\n            func()\n        self._trial_progress = 'stopped'\n\n    def _stamp_ec_id(self, id_):\n        \"\"\"Stamp id -- currently anything allowed\"\"\"\n        self.write_data_line('trial_id', id_)\n\n    def _stamp_binary_id(self, id_, wait_for_last=True):\n        \"\"\"Helper for ec to stamp a set of IDs using binary controller\n\n        This makes TDT and parallel port give the same output. Eventually\n        we may want to customize it so that parallel could work differently,\n        but for now it's unified.\n        \"\"\"\n        if not isinstance(id_, (list, tuple, np.ndarray)):\n            raise TypeError('id must be array-like')\n        id_ = np.array(id_)\n        if not np.all(np.logical_or(id_ == 1, id_ == 0)):\n            raise ValueError('All values of id must be 0 or 1')\n        id_ = 2 ** (id_.astype(int) + 2)  # 4's and 8's\n        # Note: we no longer put 8, 8 on ends\n        self._stamp_ttl_triggers(id_, wait_for_last=wait_for_last)\n\n    def stamp_triggers(self, ids, check='binary', wait_for_last=True):\n        \"\"\"Stamp binary values\n\n        Parameters\n        ----------\n        ids : int | list of int\n            Value(s) to stamp.\n        check : str\n            If 'binary', enforce standard binary value stamping of only values\n            ``[1, 2, 4, 8]``. If 'int4', enforce values as integers between\n            1 and 15.\n        wait_for_last : bool\n            If True, wait for last trigger to be stamped before returning.\n\n        Notes\n        -----\n        This may be (nearly) instantaneous, or take a while, depending\n        on the type of triggering (TDT or parallel).\n\n        If absolute minimal latency is required, consider using the\n        private function _stamp_ttl_triggers (for advanced use only,\n        subject to change!).\n\n        See Also\n        --------\n        ExperimentController.identify_trial\n        \"\"\"\n        if check not in ('int4', 'binary'):\n            raise ValueError('Check must be either \"int4\" or \"binary\"')\n        ids = [ids] if not isinstance(ids, list) else ids\n        if not all(isinstance(id_, int) and 1 <= id_ <= 15 for id_ in ids):\n            raise ValueError('ids must all be integers between 1 and 15')\n        if check == 'binary':\n            _vals = [1, 2, 4, 8]\n            if not all(id_ in _vals for id_ in ids):\n                raise ValueError('with check=\"binary\", ids must all be '\n                                 '1, 2, 4, or 8: {0}'.format(ids))\n        self._stamp_ttl_triggers(ids, wait_for_last=wait_for_last)\n\n    def flush(self):\n        \"\"\"Flush logs and data files\n        \"\"\"\n        flush_logger()\n        if self._data_file is not None and not self._data_file.closed:\n            self._data_file.flush()\n\n    def close(self):\n        \"\"\"Close all connections in experiment controller.\n        \"\"\"\n        self.__exit__(None, None, None)\n\n    def __enter__(self):\n        logger.debug('Expyfun: Entering')\n        return self\n\n    def __exit__(self, err_type, value, traceback):\n        \"\"\"\n        Notes\n        -----\n        err_type, value and traceback will be None when called by self.close()\n        \"\"\"\n        logger.debug('Expyfun: Exiting cleanly')\n\n        # do external cleanups\n        cleanup_actions = [self.stop_noise, self.stop]\n        cleanup_actions.extend(self._extra_cleanup_fun)\n        if hasattr(self, '_win'):\n            cleanup_actions = [self._win.close] + cleanup_actions\n        for action in cleanup_actions:\n            try:\n                action()\n            except Exception:\n                tb.print_exc()\n                pass\n\n        # clean up our API\n        try:\n            self.flush()\n        except Exception:\n            tb.print_exc()\n            pass\n\n        if any([x is not None for x in (err_type, value, traceback)]):\n            return False\n        return True\n\n# ############################## READ-ONLY PROPERTIES #########################\n    @property\n    def id_types(self):\n        \"\"\"Trial ID types needed for each trial.\n        \"\"\"\n        return list(self._id_call_dict.keys())\n\n    @property\n    def fs(self):\n        \"\"\"Playback frequency of the audio controller (samples / second).\n        \"\"\"\n        return self._ac.fs  # not user-settable\n\n    @property\n    def stim_fs(self):\n        \"\"\"Sampling rate at which the stimuli were generated.\n        \"\"\"\n        return self._stim_fs  # not user-settable\n\n    @property\n    def stim_db(self):\n        \"\"\"Sound power in dB of the stimuli.\n        \"\"\"\n        return self._stim_db  # not user-settable\n\n    @property\n    def noise_db(self):\n        \"\"\"Sound power in dB of the background noise.\n        \"\"\"\n        return self._noise_db  # not user-settable\n\n    @property\n    def current_time(self):\n        \"\"\"Timestamp from the experiment master clock.\n        \"\"\"\n        return self._master_clock()\n\n    @property\n    def _fs_mismatch(self):\n        \"\"\"Quantify if sample rates substantively differ.\n        \"\"\"\n        return not np.allclose(self.stim_fs, self.fs, rtol=0, atol=0.5)",
  "def _get_items(d, fixed, title):\n    \"\"\"Helper to get items for an experiment\"\"\"\n    print(title)\n    for key, val in d.items():\n        if key in fixed:\n            print('{0}: {1}'.format(key, val))\n        else:\n            d[key] = get_keyboard_input('{0}: '.format(key))",
  "def get_keyboard_input(prompt, default=None, out_type=str, valid=None):\n    \"\"\"Get keyboard input of a specific type\n\n    Parameters\n    ----------\n    prompt : str\n        Prompt to use.\n    default : object | None\n        If user enters nothing, this will be used. If None, the user\n        will be repeatedly prompted until a valid response is found.\n    out_type : type\n        Type to coerce to. If coersion fails, the user will be prompted\n        again.\n    valid : list | None\n        An iterable that contains all the allowable inputs. Keeps asking until\n        it recceives a valid input. Does not check if None.\n\n    Returns\n    -------\n    response : of type `out_type`\n        The user response.\n    \"\"\"\n    # TODO: Let valid be an iterable OR a function handle, such that you could\n    # pass a lambda, e.g., that made sure a float was in a given range\n    # TODO: add tests\n    if not isinstance(out_type, type):\n        raise TypeError('out_type must be a type')\n    good = False\n    while not good:\n        response = input(prompt)\n        if response == '' and default is not None:\n            response = default\n        try:\n            response = out_type(response)\n        except ValueError:\n            pass\n        else:\n            if valid is None or response in valid:\n                good = True\n    assert isinstance(response, out_type)\n    return response",
  "def _get_dev_db(audio_controller):\n    \"\"\"Selects device-specific amplitude to ensure equivalence across devices.\n    \"\"\"\n    level = dict(\n        RM1=108.,  # this is approx w/ knob @ 12 o'clock (knob not detented)\n        RP2=108.,\n        RZ6=114.,\n        pyglet=100.,  # TODO: this value not yet calibrated, may vary by system\n        dummy=90.,  # only used for testing\n    ).get(audio_controller, None)\n    if level is None:\n        logger.warning('Expyfun: Unknown audio controller: stim scaler may '\n                       'not work correctly. You may want to remove your '\n                       'headphones if this is the first run of your '\n                       'experiment.')\n        level = 90  # for untested TDT models\n    return level",
  "def __init__(self, exp_name, audio_controller=None, response_device=None,\n                 stim_rms=0.01, stim_fs=24414, stim_db=65, noise_db=45,\n                 output_dir='data', window_size=None, screen_num=None,\n                 full_screen=True, force_quit=None, participant=None,\n                 monitor=None, trigger_controller=None, session=None,\n                 verbose=None, check_rms='windowed', suppress_resamp=False):\n        # initialize some values\n        self._stim_fs = stim_fs\n        self._stim_rms = stim_rms\n        self._stim_db = stim_db\n        self._noise_db = noise_db\n        self._stim_scaler = None\n        self._suppress_resamp = suppress_resamp\n        # placeholder for extra actions to do on flip-and-play\n        self._on_every_flip = []\n        self._on_next_flip = []\n        self._on_trial_ok = []\n        # placeholder for extra actions to run on close\n        self._extra_cleanup_fun = []\n        self._id_call_dict = dict(ec_id=self._stamp_ec_id)\n        self._ac = None\n        self._data_file = None\n        self._playing = False  # whether or not play() was called w/o a 'stop'\n        self._clock = ZeroClock()\n        self._master_clock = self._clock.get_time\n\n        # put anything that could fail in this block to ensure proper cleanup!\n        try:\n            self.set_rms_checking(check_rms)\n            # Check Pyglet version for safety\n            _check_pyglet_version(raise_error=True)\n            # assure proper formatting for force-quit keys\n            if force_quit is None:\n                force_quit = ['lctrl', 'rctrl']\n            elif isinstance(force_quit, (int, string_types)):\n                force_quit = [str(force_quit)]\n            if 'escape' in force_quit:\n                logger.warning('Expyfun: using \"escape\" as a force-quit key '\n                               'is not recommended because it has special '\n                               'status in pyglet.')\n\n            # set up timing\n            # Use ZeroClock, which uses the \"clock\" fn but starts at zero\n            self._time_corrections = dict()\n            self._time_correction_fxns = dict()\n            self._time_correction_maxs = dict()  # optional, defaults to 10e-6\n\n            # dictionary for experiment metadata\n            self._exp_info = {'participant': participant, 'session': session,\n                              'exp_name': exp_name, 'date': date_str()}\n\n            # session start dialog, if necessary\n            fixed_list = ['exp_name', 'date']  # things not editable in GUI\n            for key, value in self._exp_info.items():\n                if key not in fixed_list and value is not None:\n                    if not isinstance(value, string_types):\n                        raise TypeError('{} must be string or None'\n                                        ''.format(value))\n                    fixed_list.append(key)\n\n            if len(fixed_list) < len(self._exp_info):\n                _get_items(self._exp_info, fixed=fixed_list, title=exp_name)\n\n            #\n            # initialize log file\n            #\n            self._output_dir = None\n            set_log_file(None)\n            if output_dir is not None:\n                output_dir = op.abspath(output_dir)\n                if not op.isdir(output_dir):\n                    os.mkdir(output_dir)\n                basename = op.join(output_dir, '{}_{}'\n                                   ''.format(self._exp_info['participant'],\n                                             self._exp_info['date']))\n                self._output_dir = basename\n                self._log_file = self._output_dir + '.log'\n                set_log_file(self._log_file)\n                closer = partial(set_log_file, None)\n                self._extra_cleanup_fun.append(closer)\n                # initialize data file\n                self._data_file = open(self._output_dir + '.tab', 'a')\n                self._extra_cleanup_fun.append(self._data_file.close)\n                self._data_file.write('# ' + str(self._exp_info) + '\\n')\n                self.write_data_line('event', 'value', 'timestamp')\n\n            #\n            # set up monitor\n            #\n            if screen_num is None:\n                screen_num = int(get_config('SCREEN_NUM', '0'))\n            if monitor is None:\n                mon_size = pyglet.window.get_platform().get_default_display()\n                mon_size = mon_size.get_screens()[screen_num]\n                mon_size = [mon_size.width, mon_size.height]\n                mon_size = ','.join([str(d) for d in mon_size])\n                monitor = dict()\n                width = float(get_config('SCREEN_WIDTH', '51.0'))\n                dist = float(get_config('SCREEN_DISTANCE', '48.0'))\n                monitor['SCREEN_WIDTH'] = width\n                monitor['SCREEN_DISTANCE'] = dist\n                mon_size = get_config('SCREEN_SIZE_PIX', mon_size).split(',')\n                mon_size = [int(p) for p in mon_size]\n                monitor['SCREEN_SIZE_PIX'] = mon_size\n            if not isinstance(monitor, dict):\n                raise TypeError('monitor must be a dict')\n            req_mon_keys = ['SCREEN_WIDTH', 'SCREEN_DISTANCE',\n                            'SCREEN_SIZE_PIX']\n            if not all([key in monitor for key in req_mon_keys]):\n                raise KeyError('monitor must have keys {0}'\n                               ''.format(req_mon_keys))\n            mon_size = monitor['SCREEN_SIZE_PIX']\n            monitor['SCREEN_DPI'] = (monitor['SCREEN_SIZE_PIX'][0] /\n                                     (monitor['SCREEN_WIDTH'] * 0.393701))\n            monitor['SCREEN_HEIGHT'] = (monitor['SCREEN_WIDTH'] /\n                                        float(monitor['SCREEN_SIZE_PIX'][0]) *\n                                        float(monitor['SCREEN_SIZE_PIX'][1]))\n            self._monitor = monitor\n\n            #\n            # parse audio controller\n            #\n            if audio_controller is None:\n                audio_controller = {'TYPE': get_config('AUDIO_CONTROLLER',\n                                                       'pyglet')}\n            elif isinstance(audio_controller, string_types):\n                if audio_controller.lower() in ['pyglet', 'tdt']:\n                    audio_controller = {'TYPE': audio_controller.lower()}\n                else:\n                    raise ValueError('audio_controller must be \\'pyglet\\' or '\n                                     '\\'tdt\\' (or a dict including \\'TYPE\\':'\n                                     ' \\'pyglet\\' or \\'TYPE\\': \\'tdt\\').')\n            elif not isinstance(audio_controller, dict):\n                raise TypeError('audio_controller must be a str or dict.')\n            self._audio_type = audio_controller['TYPE'].lower()\n\n            #\n            # parse response device\n            #\n            if response_device is None:\n                response_device = get_config('RESPONSE_DEVICE', 'keyboard')\n            if response_device not in ['keyboard', 'tdt', 'cedrus']:\n                raise ValueError('response_device must be \"keyboard\", \"tdt\", '\n                                 '\"cedrus\", or None')\n            self._response_device = response_device\n\n            #\n            # Initialize devices\n            #\n\n            # Audio (and for TDT, potentially keyboard)\n            if self._audio_type == 'tdt':\n                logger.info('Expyfun: Setting up TDT')\n                self._ac = TDTController(audio_controller)\n                self._audio_type = self._ac.model\n            elif self._audio_type == 'pyglet':\n                self._ac = PygletSoundController(self, self.stim_fs)\n            else:\n                raise ValueError('audio_controller[\\'TYPE\\'] must be '\n                                 '\\'pyglet\\' or \\'tdt\\'.')\n            self._extra_cleanup_fun.append(self._ac.halt)\n            # audio scaling factor; ensure uniform intensity across devices\n            self.set_stim_db(self._stim_db)\n            self.set_noise_db(self._noise_db)\n\n            if self._fs_mismatch:\n                msg = ('Expyfun: Mismatch between reported stim sample '\n                       'rate ({0}) and device sample rate ({1}).'\n                       ''.format(self.stim_fs, self.fs))\n                if self._suppress_resamp:\n                    msg += ('Nothing will be done about this because '\n                            'suppress_resamp is \"True\"')\n                else:\n                    msg += ('Experiment Controller will resample for you, but '\n                            'this takes a non-trivial amount of processing '\n                            'time and may compromise your experimental '\n                            'timing and/or cause artifacts.')\n                logger.warning(msg)\n\n            #\n            # set up visual window (must be done before keyboard and mouse)\n            #\n            logger.info('Expyfun: Setting up screen')\n            if full_screen:\n                window_size = monitor['SCREEN_SIZE_PIX']\n            else:\n                if window_size is None:\n                    window_size = get_config('WINDOW_SIZE',\n                                             '800,600').split(',')\n                    window_size = [int(w) for w in window_size]\n            window_size = np.array(window_size)\n            if window_size.ndim != 1 or window_size.size != 2:\n                raise ValueError('window_size must be 2-element array-like or '\n                                 'None')\n\n            # open window and setup GL config\n            self._setup_window(window_size, exp_name, full_screen, screen_num)\n\n            # Keyboard\n            if response_device == 'keyboard':\n                self._response_handler = Keyboard(self, force_quit)\n            elif response_device == 'tdt':\n                if not isinstance(self._ac, TDTController):\n                    raise ValueError('response_device can only be \"tdt\" if '\n                                     'tdt is used for audio')\n                self._response_handler = self._ac\n                self._ac._add_keyboard_init(self, force_quit)\n            else:  # response_device == 'cedrus'\n                self._response_handler = CedrusBox(self, force_quit)\n\n            #\n            # set up trigger controller\n            #\n            if trigger_controller is None:\n                trigger_controller = get_config('TRIGGER_CONTROLLER', 'dummy')\n            if isinstance(trigger_controller, string_types):\n                trigger_controller = dict(type=trigger_controller)\n            logger.info('Expyfun: Initializing {} triggering mode'\n                        ''.format(trigger_controller['type']))\n            if trigger_controller['type'] == 'tdt':\n                if not isinstance(self._ac, TDTController):\n                    raise ValueError('trigger_controller can only be \"tdt\" if '\n                                     'tdt is used for audio')\n                self._stamp_ttl_triggers = self._ac.stamp_triggers\n            elif trigger_controller['type'] in ['parallel', 'dummy']:\n                if 'address' not in trigger_controller['type']:\n                    addr = get_config('TRIGGER_ADDRESS')\n                    trigger_controller['address'] = addr\n                out = ParallelTrigger(trigger_controller['type'],\n                                      trigger_controller.get('address'))\n                self._stamp_ttl_triggers = out.stamp_triggers\n                self._extra_cleanup_fun.append(out.close)\n            else:\n                raise ValueError('trigger_controller type must be '\n                                 '\"parallel\", \"dummy\", or \"tdt\", not '\n                                 '{0}'.format(trigger_controller['type']))\n            self._id_call_dict['ttl_id'] = self._stamp_binary_id\n\n            # other basic components\n            self._mouse_handler = Mouse(self)\n            t = np.arange(44100 // 3) / 44100.\n            car = sum([np.sin(2 * np.pi * f * t) for f in [800, 1000, 1200]])\n            self._beep = None\n            self._beep_data = np.tile(car * np.exp(-t * 10) / 4, (2, 3))\n\n            # finish initialization\n            logger.info('Expyfun: Initialization complete')\n            logger.exp('Expyfun: Subject: {0}'\n                       ''.format(self._exp_info['participant']))\n            logger.exp('Expyfun: Session: {0}'\n                       ''.format(self._exp_info['session']))\n            ok_log = partial(self.write_data_line, 'trial_ok', None)\n            self._on_trial_ok.append(ok_log)\n            self._on_trial_ok.append(self.flush)\n            self._trial_progress = 'stopped'\n            self._ofp_critical_funs = list()\n        except Exception:\n            self.close()\n            raise",
  "def __repr__(self):\n        \"\"\"Return a useful string representation of the experiment\n        \"\"\"\n        string = ('<ExperimentController ({3}): \"{0}\" {1} ({2})>'\n                  ''.format(self._exp_info['exp_name'],\n                            self._exp_info['participant'],\n                            self._exp_info['session'],\n                            self._audio_type))\n        return string",
  "def screen_text(self, text, pos=[0, 0], color='white', font_name='Arial',\n                    font_size=24, wrap=True, units='norm', attr=True):\n        \"\"\"Show some text on the screen.\n\n        Parameters\n        ----------\n        text : str\n            The text to be rendered.\n        pos : list | tuple\n            x, y position of the text. In the default units (-1 to 1, with\n            positive going up and right) the default is dead center (0, 0).\n        color : matplotlib color\n            The text color.\n        font_name : str\n            The name of the font to use.\n        font_size : float\n            The font size (in points) to use.\n        wrap : bool\n            Whether or not the text will wrap to fit in screen, appropriate\n            for multi-line text. Inappropriate for text requiring\n            precise positioning or centering.\n        units : str\n            Units for `pos`. See `check_units` for options. Applies to\n            `pos` but not `font_size`.\n        attr : bool\n            Should the text be interpreted with pyglet's ``decode_attributed``\n            method? This allows inline formatting for text color, e.g.,\n            ``'This is {color (255, 0, 0, 255)}red text'``.\n\n        Returns\n        -------\n        Instance of visual.Text\n\n        See Also\n        --------\n        ExperimentController.screen_prompt\n        \"\"\"\n        check_units(units)\n        scr_txt = Text(self, text, pos, color, font_name, font_size,\n                       wrap=wrap, units=units, attr=attr)\n        scr_txt.draw()\n        self.call_on_next_flip(self.write_data_line, 'screen_text', text)\n        return scr_txt",
  "def screen_prompt(self, text, max_wait=np.inf, min_wait=0, live_keys=None,\n                      timestamp=False, clear_after=True, pos=[0, 0],\n                      color='white', font_name='Arial', font_size=24,\n                      wrap=True, units='norm', attr=True):\n        \"\"\"Display text and (optionally) wait for user continuation\n\n        Parameters\n        ----------\n        text : str | list\n            The text to display. It will automatically wrap lines.\n            If list, the prompts will be displayed sequentially.\n        max_wait : float\n            The maximum amount of time to wait before returning. Can be np.inf\n            to wait until the user responds.\n        min_wait : float\n            The minimum amount of time to wait before returning. Useful for\n            avoiding subjects missing instructions.\n        live_keys : list | None\n            The acceptable list of buttons or keys to use to advance the trial.\n            If None, all buttons / keys will be accepted.  If an empty list,\n            the prompt displays until max_wait seconds have passed.\n        clear_after : bool\n            If True, the screen will be cleared before returning.\n        pos : list | tuple\n            x, y position of the text. In the default units (-1 to 1, with\n            positive going up and right) the default is dead center (0, 0).\n        color : matplotlib color\n            The text color.\n        font_name : str\n            The name of the font to use.\n        font_size : float\n            The font size (in points) to use.\n        wrap : bool\n            Whether or not the text will wrap to fit in screen, appropriate\n            for multi-line text. Inappropriate for text requiring\n            precise positioning or centering.\n        units : str\n            Units for `pos`. See `check_units` for options. Applies to\n            `pos` but not `font_size`.\n        attr : bool\n            Should the text be interpreted with pyglet's ``decode_attributed``\n            method? This allows inline formatting for text color, e.g.,\n            ``'This is {color (255, 0, 0, 255)}red text'``.\n\n        Returns\n        -------\n        pressed : tuple | str | None\n            If ``timestamp==True``, returns a tuple ``(str, float)`` indicating\n            the first key pressed and its timestamp (or ``(None, None)`` if no\n            acceptable key was pressed between ``min_wait`` and ``max_wait``).\n            If ``timestamp==False``, returns a string indicating the first key\n            pressed (or ``None`` if no acceptable key was pressed).\n\n        See Also\n        --------\n        ExperimentController.screen_text\n        \"\"\"\n        if not isinstance(text, list):\n            text = [text]\n        if not all([isinstance(t, string_types) for t in text]):\n            raise TypeError('text must be a string or list of strings')\n        for t in text:\n            self.screen_text(t, pos=pos, color=color, font_name=font_name,\n                             font_size=font_size, wrap=wrap, units=units,\n                             attr=attr)\n            self.flip()\n            out = self.wait_one_press(max_wait, min_wait, live_keys,\n                                      timestamp)\n        if clear_after:\n            self.flip()\n        return out",
  "def set_background_color(self, color='black'):\n        \"\"\"Set and draw a solid background color\n\n        Parameters\n        ----------\n        color : matplotlib color\n            The background color.\n\n        Notes\n        -----\n        This should be called before anything else is drawn to the buffer,\n        since it will draw a filled rectangle over everything. On subsequent\n        flips, the rectangle will automatically be \"drawn\" because\n        ``glClearColor`` will be set so the buffer starts out with the\n        appropriate backgound color.\n        \"\"\"\n        # we go a little over here to be safe from round-off errors\n        Rectangle(self, pos=[0, 0, 2.1, 2.1], fill_color=color).draw()\n        gl.glClearColor(*[c / 255. for c in _convert_color(color)])",
  "def start_stimulus(self, start_of_trial=True, flip=True, when=None):\n        \"\"\"Play audio, (optionally) flip screen, run any \"on_flip\" functions.\n\n        Parameters\n        ----------\n        start_of_trial : bool\n            If True, it checks to make sure that the trial ID has been\n            stamped appropriately. Set to False only in cases where\n            ``flip_and_play`` is to be used mid-trial (should be rare!).\n        flip : bool\n            If False, don't flip the screen.\n        when : float | None\n            Time to start stimulus. If None, start immediately.\n            Note that due to flip timing limitations, this is only a\n            guaranteed *minimum* (not absolute) wait time before the\n            flip completes (if `flip` is ``True``). As a result, in some\n            cases `when` should be set to a value smaller than your true\n            intended flip time.\n\n        Returns\n        -------\n        flip_time : float\n            The timestamp of the screen flip.\n\n        See Also\n        --------\n        ExperimentController.identify_trial\n        ExperimentController.flip\n        ExperimentController.play\n        ExperimentController.stop\n        ExperimentController.trial_ok\n\n        Notes\n        -----\n        Order of operations is: screen flip (optional), audio start, then\n        (only if ``flip=True``) additional functions added with\n        `call_on_next_flip` and `call_on_every_flip`.\n        \"\"\"\n        if start_of_trial:\n            if self._trial_progress != 'identified':\n                raise RuntimeError('Trial ID must be stamped before starting '\n                                   'the trial')\n            self._trial_progress = 'started'\n        extra = 'flipping screen and ' if flip else ''\n        logger.exp('Expyfun: Starting stimuli: {0}playing audio'.format(extra))\n        # ensure self._play comes first in list, followed by other critical\n        # private functions (e.g., EL stamping), then user functions:\n        if flip:\n            self._on_next_flip = ([self._play] + self._ofp_critical_funs +\n                                  self._on_next_flip)\n            stimulus_time = self.flip(when)\n        else:\n            if when is not None:\n                self.wait_until(when)\n            funs = [self._play] + self._ofp_critical_funs\n            self._win.dispatch_events()\n            stimulus_time = self.get_time()\n            for fun in funs:\n                fun()\n        return stimulus_time",
  "def call_on_next_flip(self, function, *args, **kwargs):\n        \"\"\"Add a function to be executed on next flip only.\n\n        Parameters\n        ----------\n        function : function | None\n            The function to call. If ``None``, all the \"on every flip\"\n            functions will be cleared.\n        *args, **kwargs : arguments and keyword arguments\n            Arguments to pass to the function when calling it.\n\n        See Also\n        --------\n        ExperimentController.call_on_every_flip\n\n        Notes\n        -----\n        See `flip_and_play` for order of operations. Can be called multiple\n        times to add multiple functions to the queue.\n        \"\"\"\n        if function is not None:\n            function = partial(function, *args, **kwargs)\n            self._on_next_flip.append(function)\n        else:\n            self._on_next_flip = []",
  "def call_on_every_flip(self, function, *args, **kwargs):\n        \"\"\"Add a function to be executed on every flip.\n\n        Parameters\n        ----------\n        function : function | None\n            The function to call. If ``None``, all the \"on every flip\"\n            functions will be cleared.\n        *args, **kwargs : arguments and keyword arguments\n            Arguments to pass to the function when calling it.\n\n        See Also\n        --------\n        ExperimentController.call_on_next_flip\n\n        Notes\n        -----\n        See `flip_and_play` for order of operations. Can be called multiple\n        times to add multiple functions to the queue.\n        \"\"\"\n        if function is not None:\n            function = partial(function, *args, **kwargs)\n            self._on_every_flip.append(function)\n        else:\n            self._on_every_flip = []",
  "def _convert_units(self, verts, fro, to):\n        \"\"\"Convert between different screen units\"\"\"\n        check_units(to)\n        check_units(fro)\n        verts = np.array(np.atleast_2d(verts), dtype=float)\n        if verts.shape[0] != 2:\n            raise RuntimeError('verts must have 2 rows')\n\n        if fro == to:\n            return verts\n\n        # simplify by using two if neither is in normalized (native) units\n        if 'norm' not in [to, fro]:\n            # convert to normal\n            verts = self._convert_units(verts, fro, 'norm')\n            # convert from normal to dest\n            verts = self._convert_units(verts, 'norm', to)\n            return verts\n\n        # figure out our actual transition, knowing one is 'norm'\n        w_pix = self.window_size_pix[0]\n        h_pix = self.window_size_pix[1]\n        d_cm = self._monitor['SCREEN_DISTANCE']\n        w_cm = self._monitor['SCREEN_WIDTH']\n        h_cm = self._monitor['SCREEN_HEIGHT']\n        w_prop = w_pix / float(self.monitor_size_pix[0])\n        h_prop = h_pix / float(self.monitor_size_pix[1])\n        if 'pix' in [to, fro]:\n            if 'pix' == to:\n                # norm to pixels\n                x = np.array([[w_pix / 2., 0, w_pix / 2.],\n                              [0, h_pix / 2., h_pix / 2.]])\n            else:\n                # pixels to norm\n                x = np.array([[2. / w_pix, 0, -1.],\n                              [0, 2. / h_pix, -1.]])\n            verts = np.dot(x, np.r_[verts, np.ones((1, verts.shape[1]))])\n        elif 'deg' in [to, fro]:\n            if 'deg' == to:\n                # norm (window) to norm (whole screen), then to deg\n                x = np.arctan2(verts[0] * w_prop * (w_cm / 2.), d_cm)\n                y = np.arctan2(verts[1] * h_prop * (h_cm / 2.), d_cm)\n                verts = np.array([x, y])\n                verts *= (180. / np.pi)\n            else:\n                # deg to norm (whole screen), to norm (window)\n                verts *= (np.pi / 180.)\n                x = (d_cm * np.tan(verts[0])) / (w_cm / 2.) / w_prop\n                y = (d_cm * np.tan(verts[1])) / (h_cm / 2.) / h_prop\n                verts = np.array([x, y])\n        else:\n            raise KeyError('unknown conversion \"{}\" to \"{}\"'.format(fro, to))\n        return verts",
  "def screenshot(self):\n        \"\"\"Capture the current displayed buffer\n\n        This method must be called *before* flipping, because it captures\n        the back buffer.\n\n        Returns\n        -------\n        scr : array\n            N x M x 3 array of screen pixel colors.\n        \"\"\"\n        # next line must be done in order to instantiate image_buffer_manager\n        data = pyglet.image.get_buffer_manager().get_color_buffer()\n        data = self._win.context.image_buffer_manager.color_buffer.image_data\n        data = data.get_data(data.format, data.pitch)\n        data = np.fromstring(data, dtype=np.uint8)\n        data.shape = (self._win.height, self._win.width, 4)\n        data = np.flipud(data)\n        return data",
  "def on_next_flip_functions(self):\n        \"\"\"Current stack of functions to be called on next flip.\"\"\"\n        return self._on_next_flip",
  "def on_every_flip_functions(self):\n        \"\"\"Current stack of functions called on every flip.\"\"\"\n        return self._on_every_flip",
  "def window(self):\n        \"\"\"Pyglet visual window handle.\"\"\"\n        return self._win",
  "def dpi(self):\n        return self._monitor['SCREEN_DPI']",
  "def window_size_pix(self):\n        return np.array([self._win.width, self._win.height])",
  "def monitor_size_pix(self):\n        return np.array(self._monitor['SCREEN_SIZE_PIX'])",
  "def _setup_window(self, window_size, exp_name, full_screen, screen_num):\n        # Use 16x sampling here\n        config_kwargs = dict(depth_size=8, double_buffer=True, stereo=False,\n                             stencil_size=0, samples=0, sample_buffers=0)\n        # Travis can't handle multi-sampling, but our production machines must\n        if os.getenv('TRAVIS') == 'true':\n            del config_kwargs['samples'], config_kwargs['sample_buffers']\n        win_kwargs = dict(width=window_size[0], height=window_size[1],\n                          caption=exp_name, fullscreen=full_screen,\n                          screen=screen_num, style='borderless', visible=False,\n                          config=pyglet.gl.Config(**config_kwargs))\n\n        max_try = 5  # sometimes it fails for unknown reasons\n        for ii in range(max_try):\n            try:\n                win = pyglet.window.Window(**win_kwargs)\n            except pyglet.gl.ContextException:\n                if ii == max_try - 1:\n                    raise\n                else:\n                    pass\n            else:\n                break\n        if not full_screen:\n            x = int(win.screen.width / 2. - win.width / 2.)\n            y = int(win.screen.height / 2. - win.height / 2.)\n            win.set_location(x, y)\n        self._win = win\n        # with the context set up, do basic GL initialization\n        gl.glClearColor(0.0, 0.0, 0.0, 1.0)  # set the color to clear to\n        gl.glClearDepth(1.0)  # clear value for the depth buffer\n        # set the viewport size\n        gl.glViewport(0, 0, int(self.window_size_pix[0]),\n                      int(self.window_size_pix[1]))\n        # set the projection matrix\n        gl.glMatrixMode(gl.GL_PROJECTION)\n        gl.glLoadIdentity()\n        gl.gluOrtho2D(-1, 1, -1, 1)\n        # set the model matrix\n        gl.glMatrixMode(gl.GL_MODELVIEW)\n        gl.glLoadIdentity()\n        # disable depth testing\n        gl.glDisable(gl.GL_DEPTH_TEST)\n        # enable blending\n        gl.glEnable(gl.GL_BLEND)\n        gl.glBlendFunc(gl.GL_SRC_ALPHA, gl.GL_ONE_MINUS_SRC_ALPHA)\n        gl.glShadeModel(gl.GL_SMOOTH)\n        gl.glClear(gl.GL_COLOR_BUFFER_BIT)\n        v_ = False if os.getenv('_EXPYFUN_WIN_INVISIBLE') == 'true' else True\n        self.set_visible(v_)\n        win.dispatch_events()",
  "def flip(self, when=None):\n        \"\"\"Flip screen, then run any \"on-flip\" functions.\n\n        Parameters\n        ----------\n        when : float | None\n            Time to flip. If None, flip immediately. Note that due to flip\n            timing limitations, this is only a guaranteed *minimum* (not\n            absolute) wait time before the flip completes. As a result, in\n            some cases `when` should be set to a value smaller than your\n            true intended flip time.\n\n        Returns\n        -------\n        flip_time : float\n            The timestamp of the screen flip.\n\n        See Also\n        --------\n        ExperimentController.identify_trial\n        ExperimentController.play\n        ExperimentController.start_stimulus\n        ExperimentController.stop\n        ExperimentController.trial_ok\n\n        Notes\n        -----\n        Order of operations is: screen flip, functions added with\n        `call_on_next_flip`, followed by functions added with\n        `call_on_every_flip`.\n        \"\"\"\n        if when is not None:\n            self.wait_until(when)\n        call_list = self._on_next_flip + self._on_every_flip\n        self._win.dispatch_events()\n        self._win.switch_to()\n        gl.glFinish()\n        self._win.flip()\n        # this waits until everything is called, including last draw\n        gl.glClear(gl.GL_COLOR_BUFFER_BIT)\n        gl.glBegin(gl.GL_POINTS)\n        gl.glColor4f(0, 0, 0, 0)\n        gl.glVertex2i(10, 10)\n        gl.glEnd()\n        gl.glFinish()\n        flip_time = self.get_time()\n        for function in call_list:\n            function()\n        self.write_data_line('flip', flip_time)\n        self._on_next_flip = []\n        return flip_time",
  "def estimate_screen_fs(self, n_rep=10):\n        \"\"\"Estimate screen refresh rate using repeated flip() calls\n\n        Useful for verifying that a system is operating at the proper\n        sample rate.\n\n        Parameters\n        ----------\n        n_rep : int\n            Number of flips to use. The higher the number, the more accurate\n            the estimate but the more time will be consumed.\n\n        Returns\n        -------\n        screen_fs : float\n            The screen refresh rate.\n        \"\"\"\n        n_rep = int(n_rep)\n        times = [self.flip() for _ in range(n_rep)]\n        return 1. / np.median(np.diff(times[1:]))",
  "def set_visible(self, visible=True, flip=True):\n        \"\"\"Set the window visibility\n\n        Parameters\n        ----------\n        visible : bool\n            The visibility.\n        flip : bool\n            If `visible` is ``True``, call `flip` after setting visible.\n            This fixes an issue with the window background color not\n            being set properly for the first draw after setting visible;\n            by default (at least on Linux) the background is black when\n            the window is restored, regardless of what the glClearColor\n            had been set to.\n        \"\"\"\n        self._win.set_visible(visible)\n        logger.exp('Expyfun: Set screen visibility {0}'.format(visible))\n        if visible and flip:\n            self.flip()",
  "def listen_presses(self):\n        \"\"\"Start listening for keypresses.\n\n        See Also\n        --------\n        ExperimentController.get_presses\n        ExperimentController.wait_one_press\n        ExperimentController.wait_for_presses\n        \"\"\"\n        self._response_handler.listen_presses()",
  "def get_presses(self, live_keys=None, timestamp=True, relative_to=None):\n        \"\"\"Get the entire keyboard / button box buffer.\n\n        Parameters\n        ----------\n        live_keys : list | None\n            List of strings indicating acceptable keys or buttons. Other data\n            types are cast as strings, so a list of ints will also work.\n            ``None`` accepts all keypresses.\n        timestamp : bool\n            Whether the keypress should be timestamped. If True, returns the\n            button press time relative to the value given in `relative_to`.\n        relative_to : None | float\n            A time relative to which timestamping is done. Ignored if\n            timestamp==False.  If ``None``, timestamps are relative to the time\n            `listen_presses` was last called.\n\n        Returns\n        -------\n        presses : list\n            If timestamp==False, returns a list of strings indicating which\n            keys were pressed. Otherwise, returns a list of tuples\n            (str, float) of keys and their timestamps.\n\n        See Also\n        --------\n        ExperimentController.listen_presses\n        ExperimentController.wait_one_press\n        ExperimentController.wait_for_presses\n        \"\"\"\n        return self._response_handler.get_presses(live_keys, timestamp,\n                                                  relative_to)",
  "def wait_one_press(self, max_wait=np.inf, min_wait=0.0, live_keys=None,\n                       timestamp=True, relative_to=None):\n        \"\"\"Returns only the first button pressed after min_wait.\n\n        Parameters\n        ----------\n        max_wait : float\n            Duration after which control is returned if no key is pressed.\n        min_wait : float\n            Duration for which to ignore keypresses (force-quit keys will\n            still be checked at the end of the wait).\n        live_keys : list | None\n            List of strings indicating acceptable keys or buttons. Other data\n            types are cast as strings, so a list of ints will also work.\n            ``None`` accepts all keypresses.\n        timestamp : bool\n            Whether the keypress should be timestamped. If ``True``, returns\n            the button press time relative to the value given in\n            `relative_to`.\n        relative_to : None | float\n            A time relative to which timestamping is done. Ignored if\n            ``timestamp==False``.  If ``None``, timestamps are relative to the\n            time `wait_one_press` was called.\n\n        Returns\n        -------\n        pressed : tuple | str | None\n            If ``timestamp==True``, returns a tuple (str, float) indicating the\n            first key pressed and its timestamp (or ``(None, None)`` if no\n            acceptable key was pressed between `min_wait` and `max_wait`).\n            If ``timestamp==False``, returns a string indicating the first key\n            pressed (or ``None`` if no acceptable key was pressed).\n\n        See Also\n        --------\n        ExperimentController.listen_presses\n        ExperimentController.get_presses\n        ExperimentController.wait_for_presses\n        \"\"\"\n        return self._response_handler.wait_one_press(max_wait, min_wait,\n                                                     live_keys, timestamp,\n                                                     relative_to)",
  "def wait_for_presses(self, max_wait, min_wait=0.0, live_keys=None,\n                         timestamp=True, relative_to=None):\n        \"\"\"Returns all button presses between min_wait and max_wait.\n\n        Parameters\n        ----------\n        max_wait : float\n            Duration after which control is returned.\n        min_wait : float\n            Duration for which to ignore keypresses (force-quit keys will\n            still be checked at the end of the wait).\n        live_keys : list | None\n            List of strings indicating acceptable keys or buttons. Other data\n            types are cast as strings, so a list of ints will also work.\n            ``None`` accepts all keypresses.\n        timestamp : bool\n            Whether the keypresses should be timestamped. If ``True``, returns\n            the button press time relative to the value given in\n            `relative_to`.\n        relative_to : None | float\n            A time relative to which timestamping is done. Ignored if\n            `timestamp` is ``False``.  If ``None``, timestamps are relative\n            to the time `wait_for_presses` was called.\n\n        Returns\n        -------\n        presses : list\n            If timestamp==False, returns a list of strings indicating which\n            keys were pressed. Otherwise, returns a list of tuples\n            (str, float) of keys and their timestamps.\n\n        See Also\n        --------\n        ExperimentController.listen_presses\n        ExperimentController.get_presses\n        ExperimentController.wait_one_press\n        \"\"\"\n        return self._response_handler.wait_for_presses(max_wait, min_wait,\n                                                       live_keys, timestamp,\n                                                       relative_to)",
  "def _log_presses(self, pressed):\n        \"\"\"Write key presses to data file.\n        \"\"\"\n        # This function will typically be called by self._response_handler\n        # after it retrieves some button presses\n        for key, stamp in pressed:\n            self.write_data_line('keypress', key, stamp)",
  "def check_force_quit(self):\n        \"\"\"Check to see if any force quit keys were pressed\n        \"\"\"\n        self._response_handler.check_force_quit()",
  "def listen_clicks(self):\n        \"\"\"Start listening for mouse clicks.\n\n        See Also\n        --------\n        ExperimentController.get_clicks\n        ExperimentController.get_mouse_position\n        ExperimentController.toggle_cursor\n        \"\"\"\n        self._mouse_handler.listen_clicks()",
  "def get_clicks(self, live_buttons=None, timestamp=True, relative_to=None):\n        \"\"\"Get the entire keyboard / button box buffer.\n\n        Parameters\n        ----------\n        live_buttons : list | None\n            List of strings indicating acceptable buttons.\n            ``None`` accepts all mouse clicks.\n        timestamp : bool\n            Whether the mouse click should be timestamped. If True, returns the\n            button click time relative to the value given in `relative_to`.\n        relative_to : None | float\n            A time relative to which timestamping is done. Ignored if\n            timestamp==False.  If ``None``, timestamps are relative to the time\n            `listen_clicks` was last called.\n\n        Returns\n        -------\n        clicks : list of tuple\n            Returns a list of the clicks between min_wait and max_wait.\n            If ``timestamp==True``, each entry is a tuple (str, int, int,\n            float) indicating the button clicked and its timestamp.\n            If ``timestamp==False``, each entry is a tuple (str, int, int)\n            indicating the button clicked.\n\n        See Also\n        --------\n        ExperimentController.get_mouse_position\n        ExperimentController.listen_clicks\n        ExperimentController.toggle_cursor\n        ExperimentController.wait_one_click\n        ExperimentController.wait_for_clicks\n        \"\"\"\n        return self._mouse_handler.get_clicks(live_buttons, timestamp,\n                                              relative_to)",
  "def get_mouse_position(self, units='pix'):\n        \"\"\"Mouse position in screen coordinates\n\n        Parameters\n        ----------\n        units : str\n            Units to return. See `check_units` for options.\n\n        Returns\n        -------\n        position : ndarray\n            The mouse position.\n\n        See Also\n        --------\n        ExperimentController.get_clicks\n        ExperimentController.listen_clicks\n        ExperimentController.toggle_cursor\n        ExperimentController.wait_one_click\n        ExperimentController.wait_for_clicks\n        \"\"\"\n        check_units(units)\n        pos = np.array(self._mouse_handler.pos)\n        pos = self._convert_units(pos[:, np.newaxis], 'norm', units)[:, 0]\n        return pos",
  "def toggle_cursor(self, visibility, flip=False):\n        \"\"\"Show or hide the mouse\n\n        Parameters\n        ----------\n        visibility : bool\n            If True, show; if False, hide.\n\n        See Also\n        --------\n        ExperimentController.get_clicks\n        ExperimentController.get_mouse_position\n        ExperimentController.listen_clicks\n        ExperimentController.wait_one_click\n        ExperimentController.wait_for_clicks\n        \"\"\"\n        try:\n            self._mouse_handler.set_visible(visibility)\n            # TODO move mouse to lower right corner for windows no-hide bug\n        except Exception:\n            pass  # pyglet bug on Linux!\n        if flip:\n            self.flip()",
  "def wait_one_click(self, max_wait=np.inf, min_wait=0.0, live_buttons=None,\n                       timestamp=True, relative_to=None, visible=None):\n        \"\"\"Returns only the first mouse button clicked after min_wait.\n\n        Parameters\n        ----------\n        max_wait : float\n            Duration after which control is returned if no button is clicked.\n        min_wait : float\n            Duration for which to ignore button clicks.\n        live_buttons : list | None\n            List of strings indicating acceptable buttons.\n            ``None`` accepts all mouse clicks.\n        timestamp : bool\n            Whether the mouse click should be timestamped. If ``True``, returns\n            the mouse click time relative to the value given in\n            ``relative_to``.\n        relative_to : None | float\n            A time relative to which timestamping is done. Ignored if\n            ``timestamp==False``.  If ``None``, timestamps are relative to the\n            time `wait_one_click` was called.\n        visible : None | bool\n            Whether to show the cursor while in the function. ``None`` has no\n            effect and is the default. A boolean will show it (or not) while\n            the function has control and then set visibility back to its\n            previous value afterwards.\n\n        Returns\n        -------\n        clicked : tuple | str | None\n            If ``timestamp==True``, returns a tuple (str, int, int, float)\n            indicating the first button clicked and its timestamp (or\n            ``(None, None, None, None)`` if no acceptable button was clicked\n            between `min_wait` and `max_wait`). If ``timestamp==False``,\n            returns a tuple (str, int, int) indicating the first button clicked\n            (or ``(None, None, None)`` if no acceptable key was clicked).\n\n        See Also\n        --------\n        ExperimentController.get_clicks\n        ExperimentController.get_mouse_position\n        ExperimentController.listen_clicks\n        ExperimentController.toggle_cursor\n        ExperimentController.wait_for_clicks\n        \"\"\"\n        return self._mouse_handler.wait_one_click(max_wait, min_wait,\n                                                  live_buttons, timestamp,\n                                                  relative_to, visible)",
  "def wait_for_clicks(self, max_wait=np.inf, min_wait=0.0, live_buttons=None,\n                        timestamp=True, relative_to=None, visible=None):\n        \"\"\"Returns all clicks between min_wait and max_wait.\n\n        Parameters\n        ----------\n        max_wait : float\n            Duration after which control is returned if no button is clicked.\n        min_wait : float\n            Duration for which to ignore button clicks.\n        live_buttons : list | None\n            List of strings indicating acceptable buttons.\n            ``None`` accepts all mouse clicks.\n        timestamp : bool\n            Whether the mouse click should be timestamped. If ``True``, returns\n            the mouse click time relative to the value given in\n            ``relative_to``.\n        relative_to : None | float\n            A time relative to which timestamping is done. Ignored if\n            ``timestamp==False``.  If ``None``, timestamps are relative to the\n            time ``wait_one_click`` was called.\n        visible : None | bool\n            Whether to show the cursor while in the function. ``None`` has no\n            effect and is the default. A boolean will show it (or not) while\n            the function has control and then set visibility back to its\n            previous value afterwards.\n\n        Returns\n        -------\n        clicks : list of tuple\n            Returns a list of the clicks between min_wait and max_wait.\n            If ``timestamp==True``, each entry is a tuple (str, int, int,\n            float) indicating the button clicked and its timestamp.\n            If ``timestamp==False``, each entry is a tuple (str, int, int)\n            indicating the button clicked.\n\n        See Also\n        --------\n        ExperimentController.get_clicks\n        ExperimentController.get_mouse_position\n        ExperimentController.listen_clicks\n        ExperimentController.toggle_cursor\n        ExperimentController.wait_one_click\n        \"\"\"\n        return self._mouse_handler.wait_for_clicks(max_wait, min_wait,\n                                                   live_buttons, timestamp,\n                                                   relative_to, visible)",
  "def wait_for_click_on(self, objects, max_wait=np.inf, min_wait=0.0,\n                          live_buttons=None, timestamp=True, relative_to=None):\n        \"\"\"Returns the first click after min_wait over a visual object.\n\n        Parameters\n        ----------\n        objects : list | Rectangle | Circle\n            A list of objects (or a single object) that the user may click on.\n            Supported types are: Rectangle, Circle\n        max_wait : float\n            Duration after which control is returned if no button is clicked.\n        min_wait : float\n            Duration for which to ignore button clicks.\n        live_buttons : list | None\n            List of strings indicating acceptable buttons.\n            ``None`` accepts all mouse clicks.\n        timestamp : bool\n            Whether the mouse click should be timestamped. If ``True``, returns\n            the mouse click time relative to the value given in\n            `relative_to`.\n        relative_to : None | float\n            A time relative to which timestamping is done. Ignored if\n            ``timestamp==False``.  If ``None``, timestamps are relative to the\n            time `wait_one_click` was called.\n\n        Returns\n        -------\n        clicked : tuple | str | None\n            If ``timestamp==True``, returns a tuple (str, int, int, float)\n            indicating the first valid button clicked and its timestamp (or\n            ``(None, None, None, None)`` if no acceptable button was clicked\n            between `min_wait` and `max_wait`). If ``timestamp==False``,\n            returns a tuple (str, int, int) indicating the first button clicked\n            (or ``(None, None, None)`` if no acceptable key was clicked).\n        index : the index of the object in the list of objects that was clicked\n            on. Returns None if time ran out before a valid click. If objects\n            were overlapping, it returns the index of the object that comes\n            first in the `objects` argument.\n        \"\"\"\n        legal_types = self._mouse_handler._legal_types\n        if isinstance(objects, legal_types):\n            objects = [objects]\n        elif not isinstance(objects, list):\n            raise TypeError('objects must be a list or one of: %s' %\n                            (legal_types,))\n        return self._mouse_handler.wait_for_click_on(\n            objects, max_wait, min_wait, live_buttons, timestamp, relative_to)",
  "def _log_clicks(self, clicked):\n        \"\"\"Write mouse clicks to data file.\n        \"\"\"\n        # This function will typically be called by self._response_handler\n        # after it retrieves some mouse clicks\n        for button, x, y, stamp in clicked:\n            self.write_data_line('mouseclick', '%s,%i,%i' % (button, x, y),\n                                 stamp)",
  "def system_beep(self):\n        \"\"\"Play a system beep\n\n        This will play through the system audio, *not* through the\n        audio controller (unless that is set to be the system audio).\n        This is useful for e.g., notifying that it's time for an\n        eye-tracker calibration.\n        \"\"\"\n        if self._beep is not None:\n            self._beep.delete()\n        self._beep = SoundPlayer(self._beep_data, 44100)\n        self._beep.play()",
  "def start_noise(self):\n        \"\"\"Start the background masker noise\n\n        See Also\n        --------\n        ExperimentController.set_noise_db\n        ExperimentController.stop_noise\n        \"\"\"\n        self._ac.start_noise()",
  "def stop_noise(self):\n        \"\"\"Stop the background masker noise\n\n        See Also\n        --------\n        ExperimentControlller.set_noise_db\n        ExperimentController.start_noise\n        \"\"\"\n        if self._ac is not None:  # check b/c used by __exit__\n            self._ac.stop_noise()",
  "def clear_buffer(self):\n        \"\"\"Clear audio data from the audio buffer\n\n        See Also\n        --------\n        ExperimentController.load_buffer\n        ExperimentController.set_stim_db\n        \"\"\"\n        self._ac.clear_buffer()\n        logger.exp('Expyfun: Buffer cleared')",
  "def load_buffer(self, samples):\n        \"\"\"Load audio data into the audio buffer\n\n        Parameters\n        ----------\n        samples : np.array\n            Audio data as floats scaled to (-1,+1), formatted as numpy array\n            with shape (1, N), (2, N), or (N,) dtype float32.\n\n        See Also\n        --------\n        ExperimentController.clear_buffer\n        ExperimentController.play\n        ExperimentController.set_stim_db\n        ExperimentController.start_stimulus\n        ExperimentController.stop\n        \"\"\"\n        samples = self._validate_audio(samples) * self._stim_scaler\n        logger.exp('Expyfun: Loading {} samples to buffer'\n                   ''.format(samples.size))\n        self._ac.load_buffer(samples)",
  "def play(self):\n        \"\"\"Start audio playback\n\n        Returns\n        -------\n        play_time : float\n            The timestamp of the audio playback.\n\n        See Also\n        --------\n        ExperimentController.clear_buffer\n        ExperimentController.load_buffer\n        ExperimentController.set_stim_db\n        ExperimentController.start_stimulus\n        ExperimentController.stop\n        \"\"\"\n        logger.exp('Expyfun: Playing audio')\n        # ensure self._play comes first in list:\n        self._play()\n        return self.get_time()",
  "def _play(self):\n        \"\"\"Play the audio buffer.\n        \"\"\"\n        if self._playing:\n            raise RuntimeError('Previous audio must be stopped before playing')\n        self._ac.play()\n        logger.debug('Expyfun: started audio')\n        self._playing = True\n        self.write_data_line('play')",
  "def stop(self):\n        \"\"\"Stop audio buffer playback and reset cursor to beginning of buffer\n\n        See Also\n        --------\n        ExperimentController.clear_buffer\n        ExperimentController.load_buffer\n        ExperimentController.play\n        ExperimentController.set_stim_db\n        ExperimentController.start_stimulus\n        \"\"\"\n        if self._ac is not None:  # need to check b/c used in __exit__\n            self._ac.stop()\n        self.write_data_line('stop')\n        self._playing = False\n        logger.exp('Expyfun: Audio stopped and reset.')",
  "def set_noise_db(self, new_db):\n        \"\"\"Set the level of the background noise\n\n        See Also\n        --------\n        ExperimentController.start_noise\n        ExperimentController.stop_noise\n        \"\"\"\n        # Noise is always generated at an RMS of 1\n        self._ac.set_noise_level(self._update_sound_scaler(new_db, 1.0))\n        self._noise_db = new_db",
  "def set_stim_db(self, new_db):\n        \"\"\"Set the level of the stimuli\n\n        See Also\n        --------\n        ExperimentController.clear_buffer\n        ExperimentController.load_buffer\n        ExperimentController.play\n        ExperimentController.start_stimulus\n        ExperimentController.stop\n        \"\"\"\n        self._stim_db = new_db\n        self._stim_scaler = self._update_sound_scaler(new_db, self._stim_rms)",
  "def _update_sound_scaler(self, desired_db, orig_rms):\n        \"\"\"Calcs coefficient ensuring stim ampl equivalence across devices.\n        \"\"\"\n        exponent = (-(_get_dev_db(self._audio_type) - desired_db) / 20.0)\n        return (10 ** exponent) / float(orig_rms)",
  "def _validate_audio(self, samples):\n        \"\"\"Converts audio sample data to the required format.\n\n        Parameters\n        ----------\n        samples : list | array\n            The audio samples.  Mono sounds will be converted to stereo.\n\n        Returns\n        -------\n        samples : numpy.array(dtype='float32')\n            The correctly formatted audio samples.\n        \"\"\"\n        # check data type\n        if isinstance(samples, list):\n            samples = np.asarray(samples, dtype='float32')\n        elif samples.dtype != 'float32':\n            samples = np.float32(samples)\n\n        # check values\n        if np.max(np.abs(samples)) > 1:\n            raise ValueError('Sound data exceeds +/- 1.')\n            # samples /= np.max(np.abs(samples),axis=0)\n\n        # check shape and dimensions, make stereo\n        samples = _fix_audio_dims(samples, 2).T\n\n        # resample if needed\n        if self._fs_mismatch and not self._suppress_resamp:\n            logger.warning('Expyfun: Resampling {} seconds of audio'\n                           ''.format(round(len(samples) / self.stim_fs), 2))\n            samples = resample(samples, self.fs, self.stim_fs, axis=0)\n\n        # check RMS\n        if self._check_rms is not None:\n            chans = [samples[:, x] for x in range(samples.shape[1])]\n            if self._check_rms == 'wholefile':\n                chan_rms = [np.sqrt(np.mean(x ** 2)) for x in chans]\n                max_rms = max(chan_rms)\n            else:  # 'windowed'\n                win_length = int(self.fs * 0.01)  # 10ms running window\n                chan_rms = [running_rms(x, win_length) for x in chans]\n                max_rms = max([max(x) for x in chan_rms])\n            if max_rms > 2 * self._stim_rms:\n                warn_string = ('Expyfun: Stimulus max RMS ({}) exceeds stated '\n                               'RMS ({}) by more than 6 dB.'\n                               ''.format(max_rms, self._stim_rms))\n                logger.warning(warn_string)\n                warnings.warn(warn_string)\n            elif max_rms < 0.5 * self._stim_rms:\n                warn_string = ('Expyfun: Stimulus max RMS ({}) is less than '\n                               'stated RMS ({}) by more than 6 dB.'\n                               ''.format(max_rms, self._stim_rms))\n                logger.warning(warn_string)\n\n        # always prepend a zero to deal with TDT reset of buffer position\n        samples = np.r_[np.atleast_2d([0.0, 0.0]), samples]\n        return np.ascontiguousarray(samples)",
  "def set_rms_checking(self, check_rms):\n        \"\"\"Set the RMS checking flag.\n\n        Parameters\n        ----------\n        check_rms : str | None\n            Method to use in checking stimulus RMS to ensure appropriate\n            levels. ``'windowed'`` uses a 10ms window to find the max RMS in\n            each channel and checks to see that it is within 6 dB of the stated\n            ``stim_rms``.  ``'wholefile'`` checks the RMS of the stimulus as a\n            whole, while ``None`` disables RMS checking.\n        \"\"\"\n        if check_rms not in [None, 'wholefile', 'windowed']:\n            raise ValueError('check_rms must be one of \"wholefile\", \"windowed\"'\n                             ', or None.')\n        self._check_rms = check_rms",
  "def participant(self):\n        return self._exp_info['participant']",
  "def session(self):\n        return self._exp_info['session']",
  "def exp_name(self):\n        return self._exp_info['exp_name']",
  "def data_fname(self):\n        \"\"\"Date filename\"\"\"\n        return self._data_file.name",
  "def get_time(self):\n        \"\"\"Return current master clock time\n\n        Returns\n        -------\n        time : float\n            Time since ExperimentController was created.\n        \"\"\"\n        return self._clock.get_time()",
  "def write_data_line(self, event_type, value=None, timestamp=None):\n        \"\"\"Add a line of data to the output CSV.\n\n        Parameters\n        ----------\n        event_type : str\n            Type of event (e.g., keypress, screen flip, etc.)\n        value : None | str\n            Anything that can be cast to a string is okay here.\n        timestamp : float | None\n            The timestamp when the event occurred.  If ``None``, will use the\n            time the data line was written from the master clock.\n\n        Notes\n        -----\n        Writing a data line does not cause the file to be flushed.\n        \"\"\"\n        if timestamp is None:\n            timestamp = self._master_clock()\n        ll = '\\t'.join(_sanitize(x) for x in [timestamp, event_type,\n                                              value]) + '\\n'\n        if self._data_file is not None and not self._data_file.closed:\n            self._data_file.write(ll)",
  "def _get_time_correction(self, clock_type):\n        \"\"\"Clock correction (sec) for different devices (screen, bbox, etc.)\n        \"\"\"\n        time_correction = (self._master_clock() -\n                           self._time_correction_fxns[clock_type]())\n        if clock_type not in self._time_corrections:\n            self._time_corrections[clock_type] = time_correction\n\n        diff = time_correction - self._time_corrections[clock_type]\n        max_dt = self._time_correction_maxs.get(clock_type, 10e-6)\n        if np.abs(diff) > max_dt:\n            logger.warning('Expyfun: drift of > {} microseconds ({}) '\n                           'between {} clock and EC master clock.'\n                           ''.format(max_dt * 1e6, int(round(diff * 1e6)),\n                                     clock_type))\n        logger.debug('Expyfun: time correction between {} clock and EC '\n                     'master clock is {}. This is a change of {}.'\n                     ''.format(clock_type, time_correction, time_correction -\n                               self._time_corrections[clock_type]))\n        return time_correction",
  "def wait_secs(self, secs):\n        \"\"\"Wait a specified number of seconds.\n\n        Parameters\n        ----------\n        secs : float\n            Number of seconds to wait.\n\n        See Also\n        --------\n        ExperimentController.wait_until\n        wait_secs\n        \"\"\"\n        wait_secs(secs, ec=self)",
  "def wait_until(self, timestamp):\n        \"\"\"Wait until the given time is reached.\n\n        Parameters\n        ----------\n        timestamp : float\n            A time to wait until, evaluated against the experiment master\n            clock.\n\n        Returns\n        -------\n        remaining_time : float\n            The difference between ``timestamp`` and the time `wait_until`\n            was called.\n\n        See Also\n        --------\n        ExperimentController.wait_secs\n        wait_secs\n\n        Notes\n        -----\n        Unlike `wait_secs`, there is no guarantee of precise timing with this\n        function. It is the responsibility of the user to do choose a\n        reasonable timestamp (or equivalently, do a reasonably small amount of\n        processing prior to calling `wait_until`).\n        \"\"\"\n        time_left = timestamp - self._master_clock()\n        if time_left < 0:\n            logger.warning('Expyfun: wait_until was called with a timestamp '\n                           '({}) that had already passed {} seconds prior.'\n                           ''.format(timestamp, -time_left))\n        else:\n            wait_secs(time_left)\n        return time_left",
  "def identify_trial(self, **ids):\n        \"\"\"Identify trial type before beginning the trial\n\n        Parameters\n        ----------\n        **ids : keyword arguments\n            Ids to stamp, e.g. ``ec_id='TL90,MR45'. Use `id_types`\n            to see valid options. Typical choices are ``ec_id``, ``el_id``,\n            and ``ttl_id`` for experiment controller, eyelink, and TDT\n            (or parallel port) respectively.\n\n        See Also\n        --------\n        ExperimentController.id_types\n        ExperimentController.stamp_triggers\n        ExperimentController.start_stimulus\n        ExperimentController.stop\n        ExperimentController.trial_ok\n        \"\"\"\n        if self._trial_progress != 'stopped':\n            raise RuntimeError('Cannot identify a trial twice')\n        call_set = set(self._id_call_dict.keys())\n        passed_set = set(ids.keys())\n        if not call_set == passed_set:\n            raise KeyError('All keys passed in {0} must match the set of '\n                           'keys required {1}'.format(passed_set, call_set))\n        ll = max([len(key) for key in ids.keys()])\n        for key, id_ in ids.items():\n            logger.exp('Expyfun: Stamp trial ID to {0} : {1}'\n                       ''.format(key.ljust(ll), str(id_)))\n            self._id_call_dict[key](id_)\n        self._trial_progress = 'identified'",
  "def trial_ok(self):\n        \"\"\"Report that the trial was okay and do post-trial tasks.\n\n        For example, logs and data files can be flushed at the end of each\n        trial.\n\n        See Also\n        --------\n        ExperimentController.identify_trial\n        ExperimentController.start_stimulus\n        ExperimentController.stop\n        \"\"\"\n        if self._trial_progress != 'started':\n            raise RuntimeError('trial cannot be okay unless it was started, '\n                               'did you call ec.start_stimulus?')\n        for func in self._on_trial_ok:\n            func()\n        self._trial_progress = 'stopped'",
  "def _stamp_ec_id(self, id_):\n        \"\"\"Stamp id -- currently anything allowed\"\"\"\n        self.write_data_line('trial_id', id_)",
  "def _stamp_binary_id(self, id_, wait_for_last=True):\n        \"\"\"Helper for ec to stamp a set of IDs using binary controller\n\n        This makes TDT and parallel port give the same output. Eventually\n        we may want to customize it so that parallel could work differently,\n        but for now it's unified.\n        \"\"\"\n        if not isinstance(id_, (list, tuple, np.ndarray)):\n            raise TypeError('id must be array-like')\n        id_ = np.array(id_)\n        if not np.all(np.logical_or(id_ == 1, id_ == 0)):\n            raise ValueError('All values of id must be 0 or 1')\n        id_ = 2 ** (id_.astype(int) + 2)  # 4's and 8's\n        # Note: we no longer put 8, 8 on ends\n        self._stamp_ttl_triggers(id_, wait_for_last=wait_for_last)",
  "def stamp_triggers(self, ids, check='binary', wait_for_last=True):\n        \"\"\"Stamp binary values\n\n        Parameters\n        ----------\n        ids : int | list of int\n            Value(s) to stamp.\n        check : str\n            If 'binary', enforce standard binary value stamping of only values\n            ``[1, 2, 4, 8]``. If 'int4', enforce values as integers between\n            1 and 15.\n        wait_for_last : bool\n            If True, wait for last trigger to be stamped before returning.\n\n        Notes\n        -----\n        This may be (nearly) instantaneous, or take a while, depending\n        on the type of triggering (TDT or parallel).\n\n        If absolute minimal latency is required, consider using the\n        private function _stamp_ttl_triggers (for advanced use only,\n        subject to change!).\n\n        See Also\n        --------\n        ExperimentController.identify_trial\n        \"\"\"\n        if check not in ('int4', 'binary'):\n            raise ValueError('Check must be either \"int4\" or \"binary\"')\n        ids = [ids] if not isinstance(ids, list) else ids\n        if not all(isinstance(id_, int) and 1 <= id_ <= 15 for id_ in ids):\n            raise ValueError('ids must all be integers between 1 and 15')\n        if check == 'binary':\n            _vals = [1, 2, 4, 8]\n            if not all(id_ in _vals for id_ in ids):\n                raise ValueError('with check=\"binary\", ids must all be '\n                                 '1, 2, 4, or 8: {0}'.format(ids))\n        self._stamp_ttl_triggers(ids, wait_for_last=wait_for_last)",
  "def flush(self):\n        \"\"\"Flush logs and data files\n        \"\"\"\n        flush_logger()\n        if self._data_file is not None and not self._data_file.closed:\n            self._data_file.flush()",
  "def close(self):\n        \"\"\"Close all connections in experiment controller.\n        \"\"\"\n        self.__exit__(None, None, None)",
  "def __enter__(self):\n        logger.debug('Expyfun: Entering')\n        return self",
  "def __exit__(self, err_type, value, traceback):\n        \"\"\"\n        Notes\n        -----\n        err_type, value and traceback will be None when called by self.close()\n        \"\"\"\n        logger.debug('Expyfun: Exiting cleanly')\n\n        # do external cleanups\n        cleanup_actions = [self.stop_noise, self.stop]\n        cleanup_actions.extend(self._extra_cleanup_fun)\n        if hasattr(self, '_win'):\n            cleanup_actions = [self._win.close] + cleanup_actions\n        for action in cleanup_actions:\n            try:\n                action()\n            except Exception:\n                tb.print_exc()\n                pass\n\n        # clean up our API\n        try:\n            self.flush()\n        except Exception:\n            tb.print_exc()\n            pass\n\n        if any([x is not None for x in (err_type, value, traceback)]):\n            return False\n        return True",
  "def id_types(self):\n        \"\"\"Trial ID types needed for each trial.\n        \"\"\"\n        return list(self._id_call_dict.keys())",
  "def fs(self):\n        \"\"\"Playback frequency of the audio controller (samples / second).\n        \"\"\"\n        return self._ac.fs",
  "def stim_fs(self):\n        \"\"\"Sampling rate at which the stimuli were generated.\n        \"\"\"\n        return self._stim_fs",
  "def stim_db(self):\n        \"\"\"Sound power in dB of the stimuli.\n        \"\"\"\n        return self._stim_db",
  "def noise_db(self):\n        \"\"\"Sound power in dB of the background noise.\n        \"\"\"\n        return self._noise_db",
  "def current_time(self):\n        \"\"\"Timestamp from the experiment master clock.\n        \"\"\"\n        return self._master_clock()",
  "def _fs_mismatch(self):\n        \"\"\"Quantify if sample rates substantively differ.\n        \"\"\"\n        return not np.allclose(self.stim_fs, self.fs, rtol=0, atol=0.5)",
  "class ParallelTrigger(object):\n    \"\"\"Parallel port and dummy triggering support\n\n    IMPORTANT: When using the parallel port, note that calling\n    ec.start_stimulus() will automatically invoke a stamping of\n    the 1 trigger, which will cause a delay equal to that of\n    high_duration.\n\n    Parameters\n    ----------\n    mode : str\n        'parallel' for real use. 'dummy', passes all calls.\n    address : str | None\n        The address to use. On Linux this should be a path like\n        '/dev/parport0', on Windows it should be an address like\n        888 (a.k.a. 0x0378).\n    high_duration : float\n        Amount of time (seconds) to leave the trigger high whenever\n        sending a trigger.\n    verbose : bool, str, int, or None\n        If not None, override default verbose level (see expyfun.verbose).\n\n    Notes\n    -----\n    On Linux, parallel port may require some combination of the following:\n\n        1. ``sudo modprobe ppdev``\n        2. Add user to ``lp`` group (``/etc/group``)\n        3. Run ``sudo rmmod lp`` (otherwise ``lp`` takes exclusive control)\n        4. Edit ``/etc/modprobe.d/blacklist.conf`` to add ``blacklist lp``\n\n    The ``parallel`` module must also be installed.\n\n    On Windows, you may need to download ``inpout32.dll`` from someplace\n    like:\n\n        http://logix4u.net/InpOutBinaries.zip\n    \"\"\"\n    @verbose_dec\n    def __init__(self, mode='dummy', address=None, high_duration=0.001,\n                 verbose=None):\n        if mode == 'parallel':\n            raise NotImplementedError('Parallel port triggering has not '\n                                      'been sufficiently tested')\n            #self._stamp_trigger = self._parallel_trigger\n            #if 'Linux' in platform.system():\n            #    address = '/dev/parport0' if address is None else address\n            #    import parallel as _p\n            #    self._port = _p.Parallel(address)\n            #    self._set_data = self._port.setData\n            #elif 'Windows' in platform.system():\n            #    from ctypes import windll\n            #    if not hasattr(windll, 'inpout32'):\n            #        raise SystemError('Must have inpout32 installed')\n\n            #    addr = 0x0378 if address is None else address\n            #    base = int(addr, 16) if addr[:2] == '0x' else addr\n            #    self._port = windll.inpout32\n            #    mask = np.uint8(1 << 5 | 1 << 6 | 1 << 7)\n            #    # Use ECP to put the port into byte mode\n            #    val = int((self._port.Inp32(base + 0x402) & ~mask) | (1 << 5))\n            #    self.port.Out32(base + 0x402, val)\n\n            #    # Now to make sure the port is in output mode we need to make\n            #    # sure that bit 5 of the control register is not set\n            #    val = int(self._port.Inp32(base + 2) & ~np.uint8(1 << 5))\n            #    self._port.Out32(base + 2, val)\n\n            #    def _set_data(data):\n            #        return self._port.Out32(base, data)\n            #    self._set_data = _set_data\n            #else:\n            #    raise NotImplementedError\n        else:  # mode == 'dummy':\n            self._stamp_trigger = self._dummy_trigger\n        self.high_duration = high_duration\n\n    def _dummy_trigger(self, trig):\n        \"\"\"Fake stamping\"\"\"\n        pass\n\n    #def _parallel_trigger(self, trig):\n    #    \"\"\"Stamp a single byte via parallel port\"\"\"\n    #    self._set_data(int(trig))\n    #    wait_secs(self.high_duration)\n    #    self._set_data(0)\n\n    def stamp_triggers(self, triggers, delay=0.03, wait_for_last=True):\n        \"\"\"Stamp a list of triggers with a given inter-trigger delay\n\n        Parameters\n        ----------\n        triggers : list\n            No input checking is done, so ensure triggers is a list,\n            with each entry an integer with fewer than 8 bits (max 255).\n        delay : float\n            The inter-trigger delay.\n        wait_for_last : bool\n            If True, wait for last trigger to be stamped before returning.\n        \"\"\"\n        for ti, trig in enumerate(triggers):\n            self._stamp_trigger(trig)\n            if ti < len(triggers) - 1 or wait_for_last:\n                wait_secs(delay - self.high_duration)\n\n    def close(self):\n        \"\"\"Release hardware interfaces\n        \"\"\"\n        if hasattr(self, '_port'):\n            del self._port",
  "def decimals_to_binary(decimals, n_bits):\n    \"\"\"Convert a sequence of decimal numbers to a sequence of binary numbers\n\n    Parameters\n    ----------\n    decimals : array-like\n        Array of integers to convert. Must all be >= 0.\n    n_bits : array-like\n        Array of the number of bits to use to represent each decimal number.\n\n    Returns\n    -------\n    binary : list\n        Binary representation.\n\n    Notes\n    -----\n    This function is useful for generating IDs to be stamped using the TDT.\n    \"\"\"\n    decimals = np.array(decimals, int)\n    if decimals.ndim != 1 or (decimals < 0).any():\n        raise ValueError('decimals must be 1D with all nonnegative values')\n    n_bits = np.array(n_bits, int)\n    if decimals.shape != n_bits.shape:\n        raise ValueError('n_bits must have same shape as decimals')\n    if (n_bits <= 0).any():\n        raise ValueError('all n_bits must be positive')\n    binary = list()\n    for d, b in zip(decimals, n_bits):\n        if d > 2 ** b - 1:\n            raise ValueError('cannot convert number {0} using {1} bits'\n                             ''.format(d, b))\n        binary.extend([int(bb) for bb in np.binary_repr(d, b)])\n    assert len(binary) == n_bits.sum()  # make sure we didn't do something dumb\n    return binary",
  "def binary_to_decimals(binary, n_bits):\n    \"\"\"Convert a sequence of binary numbers to a sequence of decimal numbers\n\n    Parameters\n    ----------\n    binary : array-like\n        Array of integers to convert. Must all be 0 or 1.\n    n_bits : array-like\n        Array of the number of bits used to represent each decimal number.\n\n    Returns\n    -------\n    decimals : array-like\n        Array of integers.\n    \"\"\"\n    if not np.array_equal(binary, np.array(binary, bool)):\n        raise ValueError('binary must only contain zeros and ones')\n    binary = np.array(binary, bool)\n    if binary.ndim != 1:\n        raise ValueError('binary must be 1 dimensional')\n    n_bits = np.atleast_1d(n_bits).astype(int)\n    if np.any(n_bits <= 0):\n        raise ValueError('n_bits must all be > 0')\n    if n_bits.sum() != len(binary):\n        raise ValueError('the sum of n_bits must be equal to the number of '\n                         'elements in binary')\n    offset = 0\n    outs = []\n    for nb in n_bits:\n        outs.append(np.sum(binary[offset:offset + nb] *\n                    (2 ** np.arange(nb - 1, -1, -1))))\n        offset += nb\n    assert offset == len(binary)\n    return np.array(outs)",
  "def __init__(self, mode='dummy', address=None, high_duration=0.001,\n                 verbose=None):\n        if mode == 'parallel':\n            raise NotImplementedError('Parallel port triggering has not '\n                                      'been sufficiently tested')\n            #self._stamp_trigger = self._parallel_trigger\n            #if 'Linux' in platform.system():\n            #    address = '/dev/parport0' if address is None else address\n            #    import parallel as _p\n            #    self._port = _p.Parallel(address)\n            #    self._set_data = self._port.setData\n            #elif 'Windows' in platform.system():\n            #    from ctypes import windll\n            #    if not hasattr(windll, 'inpout32'):\n            #        raise SystemError('Must have inpout32 installed')\n\n            #    addr = 0x0378 if address is None else address\n            #    base = int(addr, 16) if addr[:2] == '0x' else addr\n            #    self._port = windll.inpout32\n            #    mask = np.uint8(1 << 5 | 1 << 6 | 1 << 7)\n            #    # Use ECP to put the port into byte mode\n            #    val = int((self._port.Inp32(base + 0x402) & ~mask) | (1 << 5))\n            #    self.port.Out32(base + 0x402, val)\n\n            #    # Now to make sure the port is in output mode we need to make\n            #    # sure that bit 5 of the control register is not set\n            #    val = int(self._port.Inp32(base + 2) & ~np.uint8(1 << 5))\n            #    self._port.Out32(base + 2, val)\n\n            #    def _set_data(data):\n            #        return self._port.Out32(base, data)\n            #    self._set_data = _set_data\n            #else:\n            #    raise NotImplementedError\n        else:  # mode == 'dummy':\n            self._stamp_trigger = self._dummy_trigger\n        self.high_duration = high_duration",
  "def _dummy_trigger(self, trig):\n        \"\"\"Fake stamping\"\"\"\n        pass",
  "def stamp_triggers(self, triggers, delay=0.03, wait_for_last=True):\n        \"\"\"Stamp a list of triggers with a given inter-trigger delay\n\n        Parameters\n        ----------\n        triggers : list\n            No input checking is done, so ensure triggers is a list,\n            with each entry an integer with fewer than 8 bits (max 255).\n        delay : float\n            The inter-trigger delay.\n        wait_for_last : bool\n            If True, wait for last trigger to be stamped before returning.\n        \"\"\"\n        for ti, trig in enumerate(triggers):\n            self._stamp_trigger(trig)\n            if ti < len(triggers) - 1 or wait_for_last:\n                wait_secs(delay - self.high_duration)",
  "def close(self):\n        \"\"\"Release hardware interfaces\n        \"\"\"\n        if hasattr(self, '_port'):\n            del self._port",
  "def _dummy_fun(self, name, ret, *args, **kwargs):\n    logger.info('dummy-tdt: {0} {1}'.format(name, str(args)[:20] + ' ... ' +\n                                            str(kwargs)[:20] + ' ...'))\n    return ret",
  "class DummyRPcoX(object):\n    def __init__(self, model, interface):\n        self.model = model\n        self.interface = interface\n        names = ['LoadCOF', 'ClearCOF', 'Run', 'ZeroTag', 'SetTagVal',\n                 'GetSFreq', 'GetTagV', 'WriteTagV', 'Halt', 'SoftTrg']\n        returns = [True, True, True, True, True,\n                   24414.0125, 0.0, True, True, True]\n        for name, ret in zip(names, returns):\n            setattr(self, name, partial(_dummy_fun, self, name, ret))\n        self._clock = ZeroClock()\n\n    def GetTagVal(self, name):\n        if name == 'masterclock':\n            return self._clock.get_time()\n        elif name == 'npressabs':\n            return 0\n        else:\n            raise ValueError('unknown tag \"{0}\"'.format(name))",
  "class TDTController(Keyboard):\n    \"\"\"Interface for TDT audio output, stamping, and responses\n\n    Parameters\n    ----------\n    tdt_params : dict | None\n        A dictionary containing keys:\n        'TYPE' (this should always be 'tdt');\n        'TDT_MODEL' (String name of the TDT model ('RM1', 'RP2', etc));\n        'TDT_CIRCUIT_PATH' (Path to the TDT circuit); and\n        'TDT_INTERFACE' (Type of connection, either 'USB' or 'GB').\n\n    Returns\n    -------\n    tdt_obj : instance of a TDTObject.\n        The object containing all relevant info about the TDT in use.\n    \"\"\"\n    def __init__(self, tdt_params):\n        legal_keys = ['TYPE', 'TDT_MODEL', 'TDT_CIRCUIT_PATH', 'TDT_INTERFACE',\n                      'TDT_DELAY', 'TDT_TRIG_DELAY']\n        if tdt_params is None:\n            tdt_params = {'TYPE': 'tdt'}\n        tdt_params = deepcopy(tdt_params)\n        if not isinstance(tdt_params, dict):\n            raise TypeError('tdt_params must be a dictionary.')\n        for k in legal_keys:\n            if k not in tdt_params.keys() and k != 'TYPE':\n                tdt_params[k] = get_config(k, None)\n\n        # Fix a couple keys\n        if tdt_params['TDT_DELAY'] is None:\n            tdt_params['TDT_DELAY'] = '0'\n        if tdt_params['TDT_TRIG_DELAY'] is None:\n            tdt_params['TDT_TRIG_DELAY'] = '0'\n        tdt_params['TDT_DELAY'] = int(tdt_params['TDT_DELAY'])\n        tdt_params['TDT_TRIG_DELAY'] = int(tdt_params['TDT_TRIG_DELAY'])\n        if tdt_params['TDT_MODEL'] is None or connect_rpcox is None:\n            tdt_params['TDT_MODEL'] = 'dummy'\n\n        # Check keys\n        for k in tdt_params.keys():\n            if k not in legal_keys:\n                raise KeyError('Unrecognized key in tdt_params: {0}'.format(k))\n        self._model = tdt_params['TDT_MODEL']\n\n        if tdt_params['TDT_CIRCUIT_PATH'] is None and self._model != 'dummy':\n            cl = dict(RM1='RM1', RP2='RM1', RZ6='RZ6')\n            self._circuit = op.join(op.dirname(__file__), 'data',\n                                    'expCircuitF32_' + cl[self._model] +\n                                    '.rcx')\n        else:\n            self._circuit = tdt_params['TDT_CIRCUIT_PATH']\n        if self._model != 'dummy' and not op.isfile(self._circuit):\n            raise IOError('Could not find file {}'.format(self._circuit))\n        if tdt_params['TDT_INTERFACE'] is None:\n            tdt_params['TDT_INTERFACE'] = 'USB'\n        self._interface = tdt_params['TDT_INTERFACE']\n\n        # initialize RPcoX connection\n        \"\"\"\n        # HIGH-LEVEL APPROACH, fails possibly due to zBUS call in DSPCircuit\n        self.rpcox = tdt.DSPCircuit(circuit, tdt_type, interface=interface)\n        self.rpcox.start()\n\n        # LOW-LEVEL APPROACH (works reliably, but no device abstraction)\n        self.rpcox = tdt.actxobjects.RPcoX()\n        self.connection = self.rpcox.ConnectRM1(IntName=interface, DevNum=1)\n        \"\"\"\n        # MID-LEVEL APPROACH\n        if tdt_params['TDT_MODEL'] != 'dummy':\n            try:\n                self.rpcox = connect_rpcox(name=self.model,\n                                           interface=self.interface,\n                                           device_id=1, address=None)\n            except Exception as exp:\n                raise OSError('Could not connect to {}, is it turned on? '\n                              '(TDT message: \"{}\")'.format(self._model, exp))\n        else:\n            msg = ('TDT is in dummy mode. No sound or triggers will '\n                   'be produced. Check TDT configuration and TDTpy '\n                   'installation.')\n            logger.warning(msg)  # log it\n            warnings.warn(msg)  # make it red\n            self.rpcox = DummyRPcoX(self._model, self._interface)\n\n        if self.rpcox is not None:\n            logger.info('Expyfun: RPcoX connection established')\n        else:\n            raise IOError('Problem initializing RPcoX.')\n        \"\"\"\n        # start zBUS (may be needed for devices other than RM1)\n        self.zbus = connect_zbus(interface=interface)\n        if self.zbus is not None:\n            logger.info('Expyfun: zBUS connection established')\n        else:\n            raise ExperimentError('Problem initializing zBUS.')\n        \"\"\"\n        # load circuit\n        if not self.rpcox.LoadCOF(self.circuit):\n            logger.debug('Expyfun: Problem loading circuit. Clearing...')\n            try:\n                if self.rpcox.ClearCOF():\n                    logger.debug('Expyfun: TDT circuit cleared')\n                time.sleep(0.25)\n                if not self.rpcox.LoadCOF(self.circuit):\n                    raise RuntimeError('Second loading attempt failed')\n            except:\n                raise IOError('Expyfun: Problem loading circuit.')\n        logger.info('Expyfun: Circuit loaded to {1} via {2}:\\n{0}'\n                    ''.format(self.circuit, self.model, self.interface))\n        # run circuit\n        if self.rpcox.Run():\n            logger.info('Expyfun: TDT circuit running')\n        else:\n            raise SystemError('Expyfun: Problem starting TDT circuit.')\n        time.sleep(0.25)\n        self._set_noise_corr()\n        self.clear_buffer()\n        self._set_delay(tdt_params['TDT_DELAY'],\n                        tdt_params['TDT_TRIG_DELAY'])\n\n    def _add_keyboard_init(self, ec, force_quit_keys):\n        \"\"\"Helper to init as keyboard\"\"\"\n        # do BaseKeyboard init last, to make sure circuit is running\n        Keyboard.__init__(self, ec, force_quit_keys)\n\n# ############################### AUDIO METHODS ###############################\n    def _set_noise_corr(self, val=0):\n        \"\"\"Helper to set the noise correlation, only -1, 0, 1 supported\"\"\"\n        assert val in (-1, 0, 1)\n        self.rpcox.SetTagVal('noise_corr', int(val))\n\n    def load_buffer(self, data):\n        \"\"\"Load audio samples into TDT buffer.\n\n        Parameters\n        ----------\n        data : np.array\n            Audio data as floats scaled to (-1,+1), formatted as an Nx2 numpy\n            array with dtype 'float32'.\n        \"\"\"\n        self.rpcox.WriteTagV('datainleft', 0, data[:, 0])\n        self.rpcox.WriteTagV('datainright', 0, data[:, 1])\n\n    def clear_buffer(self):\n        \"\"\"Clear the TDT ring buffers.\n        \"\"\"\n        self.rpcox.ZeroTag('datainleft')\n        self.rpcox.ZeroTag('datainright')\n\n    def play(self):\n        \"\"\"Send the soft trigger to start the ring buffer playback.\n        \"\"\"\n        self.rpcox.SetTagVal('trgname', 1)\n        self._trigger(1)\n        logger.debug('Expyfun: Starting TDT ring buffer')\n\n    def stop(self):\n        \"\"\"Stop playback and reset the buffer position\"\"\"\n        self.pause()\n        self.reset()\n\n    def pause(self):\n        \"\"\"Send the soft trigger to stop the ring buffer playback.\n        \"\"\"\n        self._trigger(2)\n        logger.debug('Stopping TDT audio')\n\n    def start_noise(self):\n        \"\"\"Send the soft trigger to start the noise generator.\n        \"\"\"\n        self._trigger(3)\n        logger.debug('Expyfun: Starting TDT noise')\n\n    def stop_noise(self):\n        \"\"\"Send the soft trigger to stop the noise generator.\n        \"\"\"\n        self._trigger(4)\n        logger.debug('Expyfun: Stopping TDT noise')\n\n    def set_noise_level(self, new_level):\n        \"\"\"Set the amplitude of stationary background noise.\n        \"\"\"\n        self.rpcox.SetTagVal('noiselev', new_level)\n\n    def reset(self):\n        \"\"\"Send the soft trigger to reset the ring buffer to start position.\n        \"\"\"\n        self._trigger(5)\n        logger.debug('Expyfun: Resetting TDT ring buffer')\n\n    def _set_delay(self, delay, delay_trig):\n        \"\"\"Set the delay (in ms) of the system\n        \"\"\"\n        assert isinstance(delay, int)  # this should never happen\n        assert isinstance(delay_trig, int)\n        self.rpcox.SetTagVal('onsetdel', delay)\n        logger.info('Expyfun: Setting TDT delay to %s' % delay)\n        self.rpcox.SetTagVal('trigdel', delay_trig)\n        logger.info('Expyfun: Setting TDT trigger delay to %s' % delay_trig)\n\n# ############################### TRIGGER METHODS #############################\n    def stamp_triggers(self, triggers, delay=0.03, wait_for_last=True):\n        \"\"\"Stamp a list of triggers with a given inter-trigger delay\n\n        Parameters\n        ----------\n        triggers : list\n            No input checking is done, so ensure triggers is a list,\n            with each entry an integer with fewer than 8 bits (max 255).\n        delay : float\n            The inter-trigger delay.\n        wait_for_last : bool\n            If True, wait for last trigger to be stamped before returning.\n        \"\"\"\n        for ti, trig in enumerate(triggers):\n            self.rpcox.SetTagVal('trgname', trig)\n            self._trigger(6)\n            if ti < len(triggers) - 1 or wait_for_last:\n                wait_secs(delay)\n\n    def _trigger(self, trig):\n        \"\"\"Wrapper for tdt.util.RPcoX.SoftTrg()\n\n        Parameters\n        ----------\n        trigger_number : int\n            Trigger number to send to TDT.\n        \"\"\"\n        if not self.rpcox.SoftTrg(trig):\n            logger.warning('SoftTrg failure for trigger: {}'.format(trig))\n\n# ############################### KEYBOARD METHODS ############################\n\n    def _get_timebase(self):\n        \"\"\"Return time since circuit was started (in seconds).\n        \"\"\"\n        return self.rpcox.GetTagVal('masterclock') / float(self.fs)\n\n    def _clear_events(self):\n        \"\"\"Clear keyboard buffers.\n        \"\"\"\n        self._trigger(7)\n        self._clear_keyboard_events()\n\n    def _retrieve_events(self, live_keys):\n        \"\"\"Values and timestamps currently in keyboard buffer.\n        \"\"\"\n        # get values from the tdt\n        press_count = int(round(self.rpcox.GetTagVal('npressabs')))\n        if press_count > 0:\n            # this one is indexed from zero\n            press_times = self.rpcox.ReadTagVEX('presstimesabs', 0,\n                                                press_count, 'I32', 'I32', 1)\n            # this one is indexed from one (silly)\n            press_vals = self.rpcox.ReadTagVEX('pressvalsabs', 1, press_count,\n                                               'I32', 'I32', 1)\n            press_times = np.array(press_times[0], float) / self.fs\n            press_vals = np.log2(np.array(press_vals[0], float)) + 1\n            press_vals = [str(int(round(p))) for p in press_vals]\n            presses = [(v, t) for v, t in zip(press_vals, press_times)]\n        else:\n            presses = []\n        # adds force_quit presses\n        presses.extend(self._retrieve_keyboard_events([]))\n        return presses\n\n    def halt(self):\n        \"\"\"Wrapper for tdt.util.RPcoX.Halt().\"\"\"\n        self.rpcox.Halt()\n        logger.debug('Expyfun: Halting TDT circuit')\n\n# ############################ READ-ONLY PROPERTIES ###########################\n    @property\n    def fs(self):\n        \"\"\"Playback frequency of the audio (samples / second).\"\"\"\n        return np.float(self.rpcox.GetSFreq())\n\n    @property\n    def model(self):\n        \"\"\"String representation of TDT model name ('RM1', 'RP2', etc).\"\"\"\n        return self._model\n\n    @property\n    def circuit(self):\n        \"\"\"TDT circuit path.\"\"\"\n        return self._circuit\n\n    @property\n    def interface(self):\n        \"\"\"String representation of TDT interface ('USB' or 'GB').\"\"\"\n        return self._interface",
  "def get_tdt_rates():\n    return {'6k': 6103.515625, '12k': 12207.03125, '25k': 24414.0625,\n            '50k': 48828.125, '100k': 97656.25, '200k': 195312.5}",
  "def __init__(self, model, interface):\n        self.model = model\n        self.interface = interface\n        names = ['LoadCOF', 'ClearCOF', 'Run', 'ZeroTag', 'SetTagVal',\n                 'GetSFreq', 'GetTagV', 'WriteTagV', 'Halt', 'SoftTrg']\n        returns = [True, True, True, True, True,\n                   24414.0125, 0.0, True, True, True]\n        for name, ret in zip(names, returns):\n            setattr(self, name, partial(_dummy_fun, self, name, ret))\n        self._clock = ZeroClock()",
  "def GetTagVal(self, name):\n        if name == 'masterclock':\n            return self._clock.get_time()\n        elif name == 'npressabs':\n            return 0\n        else:\n            raise ValueError('unknown tag \"{0}\"'.format(name))",
  "def __init__(self, tdt_params):\n        legal_keys = ['TYPE', 'TDT_MODEL', 'TDT_CIRCUIT_PATH', 'TDT_INTERFACE',\n                      'TDT_DELAY', 'TDT_TRIG_DELAY']\n        if tdt_params is None:\n            tdt_params = {'TYPE': 'tdt'}\n        tdt_params = deepcopy(tdt_params)\n        if not isinstance(tdt_params, dict):\n            raise TypeError('tdt_params must be a dictionary.')\n        for k in legal_keys:\n            if k not in tdt_params.keys() and k != 'TYPE':\n                tdt_params[k] = get_config(k, None)\n\n        # Fix a couple keys\n        if tdt_params['TDT_DELAY'] is None:\n            tdt_params['TDT_DELAY'] = '0'\n        if tdt_params['TDT_TRIG_DELAY'] is None:\n            tdt_params['TDT_TRIG_DELAY'] = '0'\n        tdt_params['TDT_DELAY'] = int(tdt_params['TDT_DELAY'])\n        tdt_params['TDT_TRIG_DELAY'] = int(tdt_params['TDT_TRIG_DELAY'])\n        if tdt_params['TDT_MODEL'] is None or connect_rpcox is None:\n            tdt_params['TDT_MODEL'] = 'dummy'\n\n        # Check keys\n        for k in tdt_params.keys():\n            if k not in legal_keys:\n                raise KeyError('Unrecognized key in tdt_params: {0}'.format(k))\n        self._model = tdt_params['TDT_MODEL']\n\n        if tdt_params['TDT_CIRCUIT_PATH'] is None and self._model != 'dummy':\n            cl = dict(RM1='RM1', RP2='RM1', RZ6='RZ6')\n            self._circuit = op.join(op.dirname(__file__), 'data',\n                                    'expCircuitF32_' + cl[self._model] +\n                                    '.rcx')\n        else:\n            self._circuit = tdt_params['TDT_CIRCUIT_PATH']\n        if self._model != 'dummy' and not op.isfile(self._circuit):\n            raise IOError('Could not find file {}'.format(self._circuit))\n        if tdt_params['TDT_INTERFACE'] is None:\n            tdt_params['TDT_INTERFACE'] = 'USB'\n        self._interface = tdt_params['TDT_INTERFACE']\n\n        # initialize RPcoX connection\n        \"\"\"\n        # HIGH-LEVEL APPROACH, fails possibly due to zBUS call in DSPCircuit\n        self.rpcox = tdt.DSPCircuit(circuit, tdt_type, interface=interface)\n        self.rpcox.start()\n\n        # LOW-LEVEL APPROACH (works reliably, but no device abstraction)\n        self.rpcox = tdt.actxobjects.RPcoX()\n        self.connection = self.rpcox.ConnectRM1(IntName=interface, DevNum=1)\n        \"\"\"\n        # MID-LEVEL APPROACH\n        if tdt_params['TDT_MODEL'] != 'dummy':\n            try:\n                self.rpcox = connect_rpcox(name=self.model,\n                                           interface=self.interface,\n                                           device_id=1, address=None)\n            except Exception as exp:\n                raise OSError('Could not connect to {}, is it turned on? '\n                              '(TDT message: \"{}\")'.format(self._model, exp))\n        else:\n            msg = ('TDT is in dummy mode. No sound or triggers will '\n                   'be produced. Check TDT configuration and TDTpy '\n                   'installation.')\n            logger.warning(msg)  # log it\n            warnings.warn(msg)  # make it red\n            self.rpcox = DummyRPcoX(self._model, self._interface)\n\n        if self.rpcox is not None:\n            logger.info('Expyfun: RPcoX connection established')\n        else:\n            raise IOError('Problem initializing RPcoX.')\n        \"\"\"\n        # start zBUS (may be needed for devices other than RM1)\n        self.zbus = connect_zbus(interface=interface)\n        if self.zbus is not None:\n            logger.info('Expyfun: zBUS connection established')\n        else:\n            raise ExperimentError('Problem initializing zBUS.')\n        \"\"\"\n        # load circuit\n        if not self.rpcox.LoadCOF(self.circuit):\n            logger.debug('Expyfun: Problem loading circuit. Clearing...')\n            try:\n                if self.rpcox.ClearCOF():\n                    logger.debug('Expyfun: TDT circuit cleared')\n                time.sleep(0.25)\n                if not self.rpcox.LoadCOF(self.circuit):\n                    raise RuntimeError('Second loading attempt failed')\n            except:\n                raise IOError('Expyfun: Problem loading circuit.')\n        logger.info('Expyfun: Circuit loaded to {1} via {2}:\\n{0}'\n                    ''.format(self.circuit, self.model, self.interface))\n        # run circuit\n        if self.rpcox.Run():\n            logger.info('Expyfun: TDT circuit running')\n        else:\n            raise SystemError('Expyfun: Problem starting TDT circuit.')\n        time.sleep(0.25)\n        self._set_noise_corr()\n        self.clear_buffer()\n        self._set_delay(tdt_params['TDT_DELAY'],\n                        tdt_params['TDT_TRIG_DELAY'])",
  "def _add_keyboard_init(self, ec, force_quit_keys):\n        \"\"\"Helper to init as keyboard\"\"\"\n        # do BaseKeyboard init last, to make sure circuit is running\n        Keyboard.__init__(self, ec, force_quit_keys)",
  "def _set_noise_corr(self, val=0):\n        \"\"\"Helper to set the noise correlation, only -1, 0, 1 supported\"\"\"\n        assert val in (-1, 0, 1)\n        self.rpcox.SetTagVal('noise_corr', int(val))",
  "def load_buffer(self, data):\n        \"\"\"Load audio samples into TDT buffer.\n\n        Parameters\n        ----------\n        data : np.array\n            Audio data as floats scaled to (-1,+1), formatted as an Nx2 numpy\n            array with dtype 'float32'.\n        \"\"\"\n        self.rpcox.WriteTagV('datainleft', 0, data[:, 0])\n        self.rpcox.WriteTagV('datainright', 0, data[:, 1])",
  "def clear_buffer(self):\n        \"\"\"Clear the TDT ring buffers.\n        \"\"\"\n        self.rpcox.ZeroTag('datainleft')\n        self.rpcox.ZeroTag('datainright')",
  "def play(self):\n        \"\"\"Send the soft trigger to start the ring buffer playback.\n        \"\"\"\n        self.rpcox.SetTagVal('trgname', 1)\n        self._trigger(1)\n        logger.debug('Expyfun: Starting TDT ring buffer')",
  "def stop(self):\n        \"\"\"Stop playback and reset the buffer position\"\"\"\n        self.pause()\n        self.reset()",
  "def pause(self):\n        \"\"\"Send the soft trigger to stop the ring buffer playback.\n        \"\"\"\n        self._trigger(2)\n        logger.debug('Stopping TDT audio')",
  "def start_noise(self):\n        \"\"\"Send the soft trigger to start the noise generator.\n        \"\"\"\n        self._trigger(3)\n        logger.debug('Expyfun: Starting TDT noise')",
  "def stop_noise(self):\n        \"\"\"Send the soft trigger to stop the noise generator.\n        \"\"\"\n        self._trigger(4)\n        logger.debug('Expyfun: Stopping TDT noise')",
  "def set_noise_level(self, new_level):\n        \"\"\"Set the amplitude of stationary background noise.\n        \"\"\"\n        self.rpcox.SetTagVal('noiselev', new_level)",
  "def reset(self):\n        \"\"\"Send the soft trigger to reset the ring buffer to start position.\n        \"\"\"\n        self._trigger(5)\n        logger.debug('Expyfun: Resetting TDT ring buffer')",
  "def _set_delay(self, delay, delay_trig):\n        \"\"\"Set the delay (in ms) of the system\n        \"\"\"\n        assert isinstance(delay, int)  # this should never happen\n        assert isinstance(delay_trig, int)\n        self.rpcox.SetTagVal('onsetdel', delay)\n        logger.info('Expyfun: Setting TDT delay to %s' % delay)\n        self.rpcox.SetTagVal('trigdel', delay_trig)\n        logger.info('Expyfun: Setting TDT trigger delay to %s' % delay_trig)",
  "def stamp_triggers(self, triggers, delay=0.03, wait_for_last=True):\n        \"\"\"Stamp a list of triggers with a given inter-trigger delay\n\n        Parameters\n        ----------\n        triggers : list\n            No input checking is done, so ensure triggers is a list,\n            with each entry an integer with fewer than 8 bits (max 255).\n        delay : float\n            The inter-trigger delay.\n        wait_for_last : bool\n            If True, wait for last trigger to be stamped before returning.\n        \"\"\"\n        for ti, trig in enumerate(triggers):\n            self.rpcox.SetTagVal('trgname', trig)\n            self._trigger(6)\n            if ti < len(triggers) - 1 or wait_for_last:\n                wait_secs(delay)",
  "def _trigger(self, trig):\n        \"\"\"Wrapper for tdt.util.RPcoX.SoftTrg()\n\n        Parameters\n        ----------\n        trigger_number : int\n            Trigger number to send to TDT.\n        \"\"\"\n        if not self.rpcox.SoftTrg(trig):\n            logger.warning('SoftTrg failure for trigger: {}'.format(trig))",
  "def _get_timebase(self):\n        \"\"\"Return time since circuit was started (in seconds).\n        \"\"\"\n        return self.rpcox.GetTagVal('masterclock') / float(self.fs)",
  "def _clear_events(self):\n        \"\"\"Clear keyboard buffers.\n        \"\"\"\n        self._trigger(7)\n        self._clear_keyboard_events()",
  "def _retrieve_events(self, live_keys):\n        \"\"\"Values and timestamps currently in keyboard buffer.\n        \"\"\"\n        # get values from the tdt\n        press_count = int(round(self.rpcox.GetTagVal('npressabs')))\n        if press_count > 0:\n            # this one is indexed from zero\n            press_times = self.rpcox.ReadTagVEX('presstimesabs', 0,\n                                                press_count, 'I32', 'I32', 1)\n            # this one is indexed from one (silly)\n            press_vals = self.rpcox.ReadTagVEX('pressvalsabs', 1, press_count,\n                                               'I32', 'I32', 1)\n            press_times = np.array(press_times[0], float) / self.fs\n            press_vals = np.log2(np.array(press_vals[0], float)) + 1\n            press_vals = [str(int(round(p))) for p in press_vals]\n            presses = [(v, t) for v, t in zip(press_vals, press_times)]\n        else:\n            presses = []\n        # adds force_quit presses\n        presses.extend(self._retrieve_keyboard_events([]))\n        return presses",
  "def halt(self):\n        \"\"\"Wrapper for tdt.util.RPcoX.Halt().\"\"\"\n        self.rpcox.Halt()\n        logger.debug('Expyfun: Halting TDT circuit')",
  "def fs(self):\n        \"\"\"Playback frequency of the audio (samples / second).\"\"\"\n        return np.float(self.rpcox.GetSFreq())",
  "def model(self):\n        \"\"\"String representation of TDT model name ('RM1', 'RP2', etc).\"\"\"\n        return self._model",
  "def circuit(self):\n        \"\"\"TDT circuit path.\"\"\"\n        return self._circuit",
  "def interface(self):\n        \"\"\"String representation of TDT interface ('USB' or 'GB').\"\"\"\n        return self._interface",
  "def _check_git():\n    \"\"\"Helper to check the expyfun version\"\"\"\n    if not _has_git:\n        raise RuntimeError('git not found: {0}'.format(str(exp)))",
  "def _check_version_format(version):\n    \"\"\"Helper to ensure version is of proper format\"\"\"\n    if not isinstance(version, string_types) or len(version) != 7:\n        raise TypeError('version must be a string of length 7, got {0}'\n                        ''.format(version))",
  "def _active_version(wd):\n    \"\"\"Helper to get the currently active version\"\"\"\n    return run_subprocess(['git', 'rev-parse', 'HEAD'], cwd=wd)[0][:7]",
  "def download_version(version='current', dest_dir=None):\n    \"\"\"Download specific expyfun version\n\n    Parameters\n    ----------\n    version : str\n        Version to check out (7-character git commit number).\n        Can also be ``'current'`` (default) to download whatever the\n        latest ``upstream/master`` version is.\n    dest_dir : str | None\n        Destination directory. If None, the current working\n        directory is used.\n\n    Notes\n    -----\n    This function requires installation of ``gitpython``.\n    \"\"\"\n    _check_git()\n    _check_version_format(version)\n    if dest_dir is None:\n        dest_dir = os.getcwd()\n    if not isinstance(dest_dir, string_types) or not op.isdir(dest_dir):\n        raise IOError('Destination directory {0} does not exist'\n                      ''.format(dest_dir))\n    if op.isdir(op.join(dest_dir, 'expyfun')):\n        raise IOError('Destination directory {0} already has \"expyfun\" '\n                      'subdirectory'.format(dest_dir))\n\n    # fetch locally and get the proper version\n    tempdir = _TempDir()\n    expyfun_dir = op.join(tempdir, 'expyfun')  # git will auto-create this dir\n    repo_url = 'git://github.com/LABSN/expyfun.git'\n    run_subprocess(['git', 'clone', repo_url, expyfun_dir])\n    version = _active_version(expyfun_dir) if version == 'current' else version\n    try:\n        run_subprocess(['git', 'checkout', version], cwd=expyfun_dir)\n    except Exception as exp:\n        raise RuntimeError('Could not check out version {0}: {1}'\n                           ''.format(version, str(exp)))\n    assert _active_version(expyfun_dir) == version\n\n    # install\n    orig_dir = os.getcwd()\n    os.chdir(expyfun_dir)\n    sys.path.insert(0, expyfun_dir)  # ensure our new \"setup\" is imported\n    orig_stdout = sys.stdout\n    try:\n        from setup import git_version, setup_package\n        assert git_version().lower() == version[:7].lower()\n        sys.stdout = StringIO()\n        with warnings.catch_warnings(record=True):  # PEP440\n            setup_package(script_args=['build', '--build-purelib', dest_dir])\n    finally:\n        sys.stdout = orig_stdout\n        sys.path.pop(sys.path.index(expyfun_dir))\n        os.chdir(orig_dir)\n    print('Successfully checked out expyfun version:\\n\\n%s\\n\\ninto '\n          'destination directory:\\n\\n%s\\n' % (version, op.join(dest_dir)))",
  "def assert_version(version):\n    \"\"\"Assert that a specific version of expyfun is imported\n\n    Parameters\n    ----------\n    version : str\n        Version to check (7 characters).\n    \"\"\"\n    _check_version_format(version)\n    if this_version.lower() != version.lower():\n        raise AssertionError('Requested version {0} does not match current '\n                             'version {1}'.format(version, this_version))",
  "def _check_pyeparse():\n    \"\"\"Helper to ensure package is available\"\"\"\n    try:\n        import pyeparse  # noqa analysis:ignore\n    except ImportError:\n        raise ImportError('Cannot run, requires \"pyeparse\" package')",
  "def _load_raw(el, fname):\n    \"\"\"Helper to load some pupil data\"\"\"\n    import pyeparse\n    fname = el.transfer_remote_file(fname)\n    # Load and parse data\n    logger.info('Pupillometry: Parsing local file \"{0}\"'.format(fname))\n    raw = pyeparse.Raw(fname)\n    raw.remove_blink_artifacts()\n    events = raw.find_events('SYNCTIME', 1)\n    return raw, events",
  "def find_pupil_dynamic_range(ec, el, prompt=True, verbose=None):\n    \"\"\"Find pupil dynamic range\n\n    Parameters\n    ----------\n    ec : instance of ExperimentController\n        The experiment controller.\n    el : instance of EyelinkController\n        The Eyelink controller.\n    fname : str | None\n        If str, the filename will be used to process the data from the\n        eyelink. If None, a recording will be started.\n    prompt : bool\n        If True, a standard prompt message will be displayed.\n    verbose : bool, str, int, or None\n        If not None, override default verbose level (see expyfun.verbose).\n\n    Returns\n    -------\n    bgcolor : array\n        The background color that maximizes dynamic range.\n    fcolor : array\n        The corresponding fixation dot color.\n    levels : array\n        The levels shown.\n    responses : array\n        The average responses to each level.\n\n    Notes\n    -----\n    If ``el.dummy_mode`` is on, the test will run at around 10x the speed.\n    \"\"\"\n    _check_pyeparse()\n    import pyeparse\n    if el.recording:\n        el.stop()\n    el.calibrate()\n    if prompt:\n        ec.screen_prompt('We will now determine the dynamic '\n                         'range of your pupil.\\n\\n'\n                         'Press a button to continue.')\n    levels = np.concatenate(([0.], 2 ** np.arange(8) / 255.))\n    fixs = levels + 0.2\n    n_rep = 2\n    # inter-rep interval (allow system to reset)\n    iri = 10.0 if not el.dummy_mode else 1.0\n    # amount of time between levels\n    settle_time = 3.0 if not el.dummy_mode else 0.3\n    fix = FixationDot(ec)\n    fix.set_colors([fixs[0] * np.ones(3), 'k'])\n    ec.set_background_color('k')\n    fix.draw()\n    ec.flip()\n    ec.clear_buffer()\n    for ri in range(n_rep):\n        ec.wait_secs(iri)\n        for ii, (lev, fc) in enumerate(zip(levels, fixs)):\n            ec.identify_trial(ec_id='FPDR_%02i' % (ii + 1),\n                              el_id=[ii + 1], ttl_id=())\n            bgcolor = np.ones(3) * lev\n            fcolor = np.ones(3) * fc\n            ec.set_background_color(bgcolor)\n            fix.set_colors([fcolor, bgcolor])\n            fix.draw()\n            ec.start_stimulus()\n            ec.wait_secs(settle_time)\n            ec.check_force_quit()\n            ec.stop()\n            ec.trial_ok()\n        ec.set_background_color('k')\n        fix.set_colors([fixs[0] * np.ones(3), 'k'])\n        fix.draw()\n        ec.flip()\n    el.stop()  # stop the recording\n    ec.screen_prompt('Processing data, please wait...', max_wait=0,\n                     clear_after=False)\n\n    # now we need to parse the data\n    if el.dummy_mode:\n        resp = sigmoid(np.tile(levels, n_rep), 1000, 3000, 0.01, -100)\n        resp += np.random.rand(*resp.shape) * 500 - 250\n    else:\n        # Pull data locally\n        assert len(el.file_list) >= 1\n        raw, events = _load_raw(el, el.file_list[-1])\n        assert len(events) == len(levels) * n_rep\n        epochs = pyeparse.Epochs(raw, events, 1, -0.5, settle_time)\n        assert len(epochs) == len(levels) * n_rep\n        idx = epochs.n_times // 2\n        resp = np.median(epochs.get_data('ps')[:, idx:], 1)\n    bgcolor = np.mean(resp.reshape((n_rep, len(levels))), 0)\n    idx = np.argmin(np.diff(bgcolor)) + 1\n    bgcolor = levels[idx] * np.ones(3)\n    fcolor = fixs[idx] * np.ones(3)\n    logger.info('Pupillometry: optimal background color {0}'.format(bgcolor))\n    return bgcolor, fcolor, np.tile(levels, n_rep), resp",
  "def find_pupil_tone_impulse_response(ec, el, bgcolor, fcolor, prompt=True,\n                                     verbose=None):\n    \"\"\"Find pupil impulse response using responses to tones\n\n    Parameters\n    ----------\n    ec : instance of ExperimentController\n        The experiment controller.\n    el : instance of EyelinkController\n        The Eyelink controller.\n    bgcolor : color\n        Background color to use.\n    fcolor : color\n        Fixation dot color to use.\n    prompt : bool\n        If True, a standard prompt message will be displayed.\n    verbose : bool, str, int, or None\n        If not None, override default verbose level (see expyfun.verbose).\n\n    Returns\n    -------\n    srf : array\n        The pupil response function to sound.\n    t : array\n        The time points for the response function.\n    std_err : array\n        The standard error as a function of time.\n\n    Notes\n    -----\n    If ``el.dummy_mode`` is on, the test will run at around 10x the speed.\n    \"\"\"\n    _check_pyeparse()\n    import pyeparse\n    if el.recording:\n        el.stop()\n\n    #\n    # Determine parameters / randomization\n    #\n    n_stimuli = 300 if not el.dummy_mode else 10\n    cal_stim = [0, 75, 150, 225]  # when to offer the subject a break\n\n    delay_range = (3.0, 5.0) if not el.dummy_mode else (0.3, 0.5)\n    delay_range = np.array(delay_range)\n    targ_prop = 0.25\n    stim_dur = 100e-3\n    f0 = 1000.  # Hz\n\n    rng = np.random.RandomState(0)\n    isis = np.linspace(*delay_range, num=n_stimuli)\n    n_targs = int(targ_prop * n_stimuli)\n    targs = np.zeros(n_stimuli, bool)\n    targs[np.linspace(0, n_stimuli - 1, n_targs + 2)[1:-1].astype(int)] = True\n    while(True):  # ensure we randomize but don't start with a target\n        idx = rng.permutation(np.arange(n_stimuli))\n        isis = isis[idx]\n        targs = targs[idx]\n        if not targs[0]:\n            break\n\n    #\n    # Generate stimuli\n    #\n    fs = ec.stim_fs\n    n_samp = int(fs * stim_dur)\n    freqs = np.ones(n_samp) * f0\n    t = np.arange(n_samp).astype(float) / fs\n    tone_stim = np.sin(2 * np.pi * freqs * t)\n    freqs = 100 * np.sin(2 * np.pi * (1 / stim_dur) * t) + f0\n    sweep_stim = np.sin(2 * np.pi * np.cumsum(freqs) / fs)\n    tone_stim = window_edges(tone_stim * ec._stim_rms * np.sqrt(2), fs)\n    sweep_stim = window_edges(sweep_stim * ec._stim_rms * np.sqrt(2), fs)\n\n    #\n    # Subject \"Training\"\n    #\n    ec.stop()\n    ec.clear_buffer()\n    ec.set_background_color(bgcolor)\n    instr = ('Remember to press the button as quickly as possible following '\n             'each \"wobble\" sound.\\n\\nPress the response button to '\n             'continue.')\n    if prompt:\n        notes = [('We will now determine the response of your pupil to sound '\n                  'changes.\\n\\nYour job is to press the repsonse button '\n                  'as quickly as possible when you hear a \"wobble\" instead '\n                  'of a \"beep\".\\n\\nPress a button to hear the \"beep\".'),\n                 ('Now press a button to hear the \"wobble\".')]\n        for text, stim in zip(notes, (tone_stim, sweep_stim)):\n            ec.screen_prompt(text)\n            ec.load_buffer(stim)\n            ec.wait_secs(0.5)\n            ec.play()\n            ec.wait_secs(0.5)\n            ec.stop()\n        ec.screen_prompt(instr)\n\n    fix = FixationDot(ec, colors=[fcolor, bgcolor])\n    flip_times = list()\n    presses = list()\n    assert 0 in cal_stim\n    for ii, (isi, targ) in enumerate(zip(isis, targs)):\n        if ii in cal_stim:\n            if ii != 0:\n                el.stop()\n                perc = round((100. * ii) / n_stimuli)\n                ec.screen_prompt('Great work! You are {0}% done.\\n\\nFeel '\n                                 'free to take a break, then press the '\n                                 'button to continue.'.format(perc))\n            el.calibrate()\n            ec.screen_prompt(instr)\n            # let's put the initial color up to allow the system to settle\n            fix.draw()\n            ec.flip()\n            ec.wait_secs(10.0)  # let the pupil settle\n        fix.draw()\n        ec.load_buffer(sweep_stim if targ else tone_stim)\n        ec.identify_trial(ec_id='TONE_{0}'.format(int(targ)),\n                          el_id=[int(targ)], ttl_id=[int(targ)])\n        flip_times.append(ec.start_stimulus())\n        presses.append(ec.wait_for_presses(isi))\n        ec.stop()\n        ec.trial_ok()\n    el.stop()  # stop the recording\n    ec.screen_prompt('Processing data, please wait...', max_wait=0,\n                     clear_after=False)\n\n    flip_times = np.array(flip_times)\n    tmin = -0.5\n    if el.dummy_mode:\n        pk = pyeparse.utils.pupil_kernel(el.fs, 3.0 - tmin)\n        response = np.zeros(len(pk))\n        offset = int(el.fs * 0.5)\n        response[offset:] = pk[:-offset]\n        std_err = np.ones_like(response) * 0.1 * response.max()\n        std_err += np.random.rand(std_err.size) * 0.1 * response.max()\n    else:\n        raws = list()\n        events = list()\n        assert len(el.file_list) >= 4\n        for fname in el.file_list[-4:]:\n            raw, event = _load_raw(el, fname)\n            raws.append(raw)\n            events.append(event)\n        assert sum(len(event) for event in events) == n_stimuli\n        epochs = pyeparse.Epochs(raws, events, 1,\n                                 tmin=tmin, tmax=delay_range[0])\n        response = epochs.pupil_zscores()\n        assert response.shape[0] == n_stimuli\n        std_err = np.std(response[~targs], axis=0)\n        std_err /= np.sqrt(np.sum(~targs))\n        response = np.mean(response[~targs], axis=0)\n    t = np.arange(len(response)).astype(float) / el.fs + tmin\n    return response, t, std_err",
  "def format_pval(pval, latex=True, scheme='default'):\n    \"\"\"Format a p-value using one of several schemes.\n\n    Parameters\n    ----------\n    pval : float | array-like\n        The raw p-value(s).\n    latex : bool\n        Whether to use LaTeX wrappers suitable for use with matplotlib.\n    scheme : str\n        A keyword indicating the formatting scheme. Currently supports \"stars\",\n        \"ross\", and \"default\"; any other string will yield the same as\n        \"default\".\n\n    Returns\n    -------\n    pv : str | np.objectarray\n        A string or array of strings of formatted p-values. If a list output is\n        preferred, users may call ``.tolist()`` on the output of the function.\n    \"\"\"\n    single_value = False\n    if np.array(pval).shape == ():\n        single_value = True\n    pval = np.atleast_1d(np.asanyarray(pval))\n    # add a tiny amount to handle cases where p is exactly a power of ten\n    pval = pval + np.finfo(pval.dtype).eps\n    expon = np.trunc(np.log10(pval)).astype(int)  # exponents\n    pv = np.zeros_like(pval, dtype=object)\n    if latex:\n        wrap = '$'\n        brk_l = '{{'\n        brk_r = '}}'\n    else:\n        wrap = ''\n        brk_l = ''\n        brk_r = ''\n    if scheme == 'ross':  # (exact value up to 4 decimal places)\n        pv[pval >= 0.0001] = [wrap + 'p = {:.4f}'.format(x) + wrap\n                              for x in pval[pval > 0.0001]]\n        pv[pval < 0.0001] = [wrap + 'p < 10^' + brk_l + '{}'.format(x) +\n                             brk_r + wrap for x in expon[pval < 0.0001]]\n    elif scheme == 'stars':\n        star = '{*}' if latex else '*'\n        pv[pval >= 0.05] = wrap + '' + wrap\n        pv[pval < 0.05] = wrap + star + wrap\n        pv[pval < 0.01] = wrap + star * 2 + wrap\n        pv[pval < 0.001] = wrap + star * 3 + wrap\n    else:  # scheme == 'default'\n        pv[pval >= 0.05] = wrap + 'n.s.' + wrap\n        pv[pval < 0.05] = wrap + 'p < 0.05' + wrap\n        pv[pval < 0.01] = wrap + 'p < 0.01' + wrap\n        pv[pval < 0.001] = wrap + 'p < 0.001' + wrap\n        pv[pval < 0.0001] = [wrap + 'p < 10^' + brk_l + '{}'.format(x) +\n                             brk_r + wrap for x in expon[pval < 0.0001]]\n    if single_value:\n        pv = pv[0]\n    return(pv)",
  "def _instantiate(obj, typ):\n    \"\"\"Returns obj if obj is not None, else returns new instance of typ\n    obj : an object\n        An object (most likely one that a user passed into a function) that,\n        if ``None``, should be initiated as an empty object of some other type.\n    typ : an object type\n        Expected values are list, dict, int, bool, etc.\n    \"\"\"\n    return typ() if obj is None else obj",
  "def barplot(h, axis=-1, ylim=None, err_bars=None, lines=False,\n            groups=None, eq_group_widths=False, gap_size=0.2,\n            brackets=None, bracket_text=None, bracket_inline=False,\n            bracket_group_lines=False, bar_names=None, group_names=None,\n            bar_kwargs=None, err_kwargs=None, line_kwargs=None,\n            bracket_kwargs=None, pval_kwargs=None, figure_kwargs=None,\n            smart_defaults=True, fname=None, ax=None):\n    \"\"\"Makes barplots w/ optional line overlays, grouping, & signif. brackets.\n\n    Parameters\n    ----------\n    h : array-like\n        If `h` is 2-dimensional, heights will be calculated as means along\n        the axis given by `axis`. If `h` is of lower dimension, it is\n        treated as raw height values. If `h` is a `pandas.DataFrame` and\n        `bar_names` is ``None``, `bar_names` will be inferred from the\n        DataFrame's `column` labels (if ``axis=0``) or `index` labels.\n    axis : int\n        The axis along which to calculate mean values to determine bar heights.\n        Ignored if `h` is 0- or 1-dimensional.\n    ylim : tuple | None\n        y-axis limits passed to `matplotlib.pyplot.subplot.set_ylim`.\n    err_bars : str | array-like | None\n        Type of error bars to be added to the barplot. Possible values are\n        ``'sd'`` for sample standard deviation, ``'se'`` for standard error of\n        the mean, or ``'ci'`` for 95% confidence interval. If ``None``, no\n        error bars will be plotted. Custom error bar heights are possible by\n        passing an array-like object; in such cases `err_bars` must have the\n        same dimensionality and shape as `h`.\n    lines : bool\n        Whether to plot within-subject data as lines overlaid on the barplot.\n    groups : list | None\n        List of lists containing the integers in ``range(num_bars)``, with\n        sub-lists indicating the desired grouping. For example, if `h` has\n        has shape (10, 4) and ``axis = -1`` then \"num_bars\" is 4; if you want\n        the first bar isolated and the remaining three grouped, then specify\n        ``groups=[[0], [1, 2, 3]]``.\n    eq_group_widths : bool\n        Should all groups have the same width? If ``False``, all bars will have\n        the same width. Ignored if `groups` is ``None``, since the bar/group\n        distinction is meaningless in that case.\n    gap_size : float\n        Width of the gap between groups (if `eq_group_width` is ``True``) or\n        between bars, expressed as a proportion [0,1) of group or bar width.\n        Half the width of `gap_size` will be added between the outermost bars\n        and the plot edges.\n    brackets : list of tuples | None\n        Location of significance brackets. Scheme is similar to the\n        specification of `groups`; a bracket between the first and second bar\n        and another between the third and fourth bars would be specified as\n        ``brackets=[(0, 1), (2, 3)]``. Brackets between groups of bars instead\n        of individual bars are specified as lists within the tuple:\n        ``brackets=[([0, 1], [2, 3])]`` draws a single bracket between group\n        ``[0, 1]`` and group ``[2, 3]``. For best results, pairs of adjacent\n        bars should come earlier in the list than non-adjacent pairs.\n    bracket_text : str | list | None\n        Text to display above brackets.\n    bracket_inline : bool\n        If ``True``, bracket text will be vertically centered along a broken\n        bracket line. If ``False``, text will be above the line.\n    bracket_group_lines : bool\n        When drawing brackets between groups rather than single bars, should a\n        horizontal line be drawn at each foot of the bracket to indicate this?\n    bar_names : array-like | None\n        Optional axis labels for each bar.\n    group_names : array-like | None\n        Optional axis labels for each group.\n    bar_kwargs : dict\n        Arguments passed to ``matplotlib.pyplot.bar()`` (ex: color, linewidth).\n    err_kwargs : dict\n        Arguments passed to ``matplotlib.pyplot.bar(error_kw)`` (ex: ecolor,\n        capsize).\n    line_kwargs : dict\n        Arguments passed to ``matplotlib.pyplot.plot()`` (e.g., color, marker,\n        linestyle).\n    pval_kwargs : dict\n        Arguments passed to ``matplotlib.pyplot.annotate()`` when drawing\n        bracket labels.\n    bracket_kwargs : dict\n        arguments passed to ``matplotlib.pyplot.plot()`` (e.g., color, marker,\n        linestyle).\n    figure_kwargs : dict\n        arguments passed to ``matplotlib.pyplot.figure()`` (e.g., figsize, dpi,\n        frameon).\n    smart_defaults : bool\n        Whether to use pyplot default colors (``False``), or something more\n        pleasing to the eye (``True``).\n    fname : str | None\n        Path and name of output file. File type is inferred from the file\n        extension of `fname` and should work for any of the types supported by\n        pyplot (pdf, eps, svg, png, raw).\n    ax : matplotlib.pyplot.axes | None\n        A ``matplotlib.pyplot.axes`` instance.  If ``None``, a new figure with\n        a single subplot will be created.\n\n    Returns\n    -------\n    p : handle for the ``matplotlib.pyplot.subplot`` instance.\n    b : handle for the ``matplotlib.pyplot.bar`` instance.\n\n    Notes\n    -----\n    Known limitations:\n      1 Bracket heights don't get properly set when generating multiple\n        subplots with ``sharey=True`` (matplotlib seems to temporarily force\n        the ``ylim`` to +/- 0.6 in this case). Work around is to use\n        ``sharey=False`` and manually set ``ylim`` for each subplot.\n      2 Brackets that span groups cannot span partial groups. For example,\n        if ``groups=[[0, 1, 2], [3, 4]]`` it is impossible to have a bracket\n        at ``[(0, 1), (3, 4)]``...  it is only possible to do, e.g.,\n        ``[0, (3, 4)]`` (single bar vs group) or  ``[(0, 1, 2), (3, 4)]``\n        (full group vs full group).\n      3 Bracket drawing is much better when adjacent pairs of bars are\n        specified before non-adjacent pairs of bars.\n    Smart defaults sets the following parameters:\n        bar color: light gray (70%)\n        error bar color: black\n        line color: black\n        bracket color: dark gray (30%)\n\n    \"\"\"\n    # check matplotlib\n    if plt is None:\n        raise ImportError('Barplot requires matplotlib.pyplot.')\n    # be nice to pandas\n    if DataFrame is not None:\n        if isinstance(h, DataFrame) and bar_names is None:\n            bar_names = h.columns.tolist() if axis == 0 else h.index.tolist()\n    # check arg errors\n    if gap_size < 0 or gap_size >= 1:\n        raise ValueError('Barplot argument \"gap_size\" must be in the range '\n                         '[0, 1).')\n    if err_bars is not None:\n        if isinstance(err_bars, string_types) and \\\n                err_bars not in ['sd', 'se', 'ci']:\n            raise ValueError('err_bars must be \"sd\", \"se\", or \"ci\" (or an '\n                             'array of error bar magnitudes).')\n    if brackets is not None:\n        if any([len(x) != 2 for x in brackets]):\n            raise ValueError('Each top-level element of brackets must have '\n                             'length 2.')\n        if not len(brackets) == len(bracket_text):\n            raise ValueError('Mismatch between number of brackets and bracket '\n                             'labels.')\n    # handle single-element args\n    if isinstance(bracket_text, string_types):\n        bracket_text = [bracket_text]\n    if isinstance(group_names, string_types):\n        group_names = [group_names]\n    # arg defaults: if arg is None, instantiate as given type\n    brackets = _instantiate(brackets, list)\n    bar_kwargs = _instantiate(bar_kwargs, dict)\n    err_kwargs = _instantiate(err_kwargs, dict)\n    line_kwargs = _instantiate(line_kwargs, dict)\n    pval_kwargs = _instantiate(pval_kwargs, dict)\n    figure_kwargs = _instantiate(figure_kwargs, dict)\n    bracket_kwargs = _instantiate(bracket_kwargs, dict)\n    # user-supplied Axes\n    if ax is not None:\n        bar_kwargs['axes'] = ax\n    # smart defaults\n    if smart_defaults:\n        if 'color' not in bar_kwargs.keys():\n            bar_kwargs['color'] = '0.7'\n        if 'color' not in line_kwargs.keys():\n            line_kwargs['color'] = 'k'\n        if 'ecolor' not in err_kwargs.keys():\n            err_kwargs['ecolor'] = 'k'\n        if 'color' not in bracket_kwargs.keys():\n            bracket_kwargs['color'] = '0.3'\n    # parse heights\n    h = np.array(h)\n    if len(h.shape) > 2:\n        raise ValueError('Barplot \"h\" must have 2 or fewer dimensions.')\n    heights = np.atleast_1d(h) if h.ndim < 2 else h.mean(axis=axis)\n    # grouping\n    num_bars = len(heights)\n    if groups is None:\n        groups = [[x] for x in range(num_bars)]\n    groups = [list(x) for x in groups]  # forgive list/tuple mix-ups\n    # calculate bar positions\n    non_gap = 1 - gap_size\n    offset = gap_size / 2.\n    if eq_group_widths:\n        group_sizes = np.array([float(len(_grp)) for _grp in groups], int)\n        group_widths = [non_gap for _ in groups]\n        group_edges = [offset + _ix for _ix in range(len(groups))]\n        group_ixs = list(chain.from_iterable([range(x) for x in group_sizes]))\n        bar_widths = np.repeat(np.array(group_widths) / group_sizes,\n                               group_sizes).tolist()\n        bar_edges = (np.repeat(group_edges, group_sizes) +\n                     bar_widths * np.array(group_ixs)).tolist()\n    else:\n        bar_widths = [[non_gap for _ in _grp] for _grp in groups]\n        # next line: offset + cumul. gap widths + cumul. bar widths\n        bar_edges = [[offset + _ix * gap_size + _bar * non_gap\n                      for _bar in _grp] for _ix, _grp in enumerate(groups)]\n        group_widths = [np.sum(_width) for _width in bar_widths]\n        group_edges = [_edge[0] for _edge in bar_edges]\n        bar_edges = list(chain.from_iterable(bar_edges))\n        bar_widths = list(chain.from_iterable(bar_widths))\n    bar_centers = np.array(bar_edges) + np.array(bar_widths) / 2.\n    group_centers = np.array(group_edges) + np.array(group_widths) / 2.\n    # calculate error bars\n    err = np.zeros(num_bars)  # default if no err_bars\n    if err_bars is not None:\n        if h.ndim == 2:\n            if err_bars == 'sd':  # sample standard deviation\n                err = h.std(axis)\n            elif err_bars == 'se':  # standard error\n                err = h.std(axis) / np.sqrt(h.shape[axis])\n            else:  # 95% conf int\n                err = 1.96 * h.std(axis) / np.sqrt(h.shape[axis])\n        else:  # h.ndim == 1\n            if isinstance(err_bars, string_types):\n                raise ValueError('string arguments to \"err_bars\" ignored when '\n                                 '\"h\" has fewer than 2 dimensions.')\n            elif not h.shape == np.array(err_bars).shape:\n                raise ValueError('When \"err_bars\" is array-like it must have '\n                                 'the same shape as \"h\".')\n            err = np.atleast_1d(err_bars)\n        bar_kwargs['yerr'] = err\n    # plot (bars and error bars)\n    if ax is None:\n        plt.figure(**figure_kwargs)\n        p = plt.subplot(111)\n    else:\n        p = ax\n    b = p.bar(bar_edges, heights, bar_widths, error_kw=err_kwargs,\n              **bar_kwargs)\n    # plot within-subject lines\n    if lines:\n        _h = h if axis == 0 else h.T\n        xy = [(bar_centers, hts) for hts in _h]\n        for subj in xy:\n            p.plot(subj[0], subj[1], **line_kwargs)\n    # draw significance brackets\n    if len(brackets):\n        brackets = [tuple(x) for x in brackets]  # forgive list/tuple mix-ups\n        brk_offset = np.diff(p.get_ylim()) * 0.025\n        brk_min_h = np.diff(p.get_ylim()) * 0.05\n        # temporarily plot a textbox to get its height\n        t = plt.annotate(bracket_text[0], (0, 0), **pval_kwargs)\n        t.set_bbox(dict(boxstyle='round, pad=0.25'))\n        plt.draw()\n        bb = t.get_bbox_patch().get_window_extent()\n        txth = np.diff(p.transData.inverted().transform(bb),\n                       axis=0).ravel()[-1]\n        if bracket_inline:\n            txth = txth / 2.\n        t.remove()\n        # find highest points\n        if lines and h.ndim == 2:  # brackets must be above lines & error bars\n            apex = np.amax(np.r_[np.atleast_2d(heights + err),\n                                 np.atleast_2d(np.amax(h, axis))], axis=0)\n        else:\n            apex = np.atleast_1d(heights + err)\n        apex = np.maximum(apex, 0)  # for negative-going bars\n        apex = apex + brk_offset\n        gr_apex = np.array([np.amax(apex[_g]) for _g in groups])\n        # boolean for whether each half of a bracket is a group\n        is_group = [[hasattr(_b, 'append') for _b in _br] for _br in brackets]\n        # bracket left & right coords\n        brk_lr = [[group_centers[groups.index(_ix)] if _g\n                   else bar_centers[_ix] for _ix, _g in zip(_brk, _isg)]\n                  for _brk, _isg in zip(brackets, is_group)]\n        # bracket L/R midpoints (label position)\n        brk_c = [np.mean(_lr) for _lr in brk_lr]\n        # bracket bottom coords (first pass)\n        brk_b = [[gr_apex[groups.index(_ix)] if _g else apex[_ix]\n                  for _ix, _g in zip(_brk, _isg)]\n                 for _brk, _isg in zip(brackets, is_group)]\n        # main bracket positioning loop\n        brk_t = []\n        for _ix, (_brk, _isg) in enumerate(zip(brackets, is_group)):\n            # which bars does this bracket span?\n            spanned_bars = list(chain.from_iterable(\n                [_b if hasattr(_b, 'append') else [_b] for _b in _brk]))\n            spanned_bars = range(min(spanned_bars), max(spanned_bars) + 1)\n            # raise apex a bit extra if prev bracket label centered on bar\n            prev_label_pos = brk_c[_ix - 1] if _ix else -1\n            label_bar_ix = np.where(np.isclose(bar_centers, prev_label_pos))[0]\n            if any(np.array_equal(label_bar_ix, x) for x in _brk):\n                apex[label_bar_ix] += txth\n            elif any(_isg):\n                label_bar_less = np.where(bar_centers < prev_label_pos)[0]\n                label_bar_more = np.where(bar_centers > prev_label_pos)[0]\n                if len(label_bar_less) and len(label_bar_more):\n                    apex[label_bar_less] += txth\n                    apex[label_bar_more] += txth\n            gr_apex = np.array([np.amax(apex[_g]) for _g in groups])\n            # recalc lower tips of bracket: apex / gr_apex may have changed\n            brk_b[_ix] = [gr_apex[groups.index(_b)] if _g else apex[_b]\n                          for _b, _g in zip(_brk, _isg)]\n            # calculate top span position\n            _min_t = max(apex[spanned_bars]) + brk_min_h\n            brk_t.append(_min_t)\n            # raise apex on spanned bars to account for bracket\n            apex[spanned_bars] = np.maximum(apex[spanned_bars],\n                                            _min_t) + brk_offset\n            gr_apex = np.array([np.amax(apex[_g]) for _g in groups])\n        # draw horz line spanning groups if desired\n        if bracket_group_lines:\n            for _brk, _isg, _blr in zip(brackets, is_group, brk_b):\n                for _bk, _g, _b in zip(_brk, _isg, _blr):\n                    if _g:\n                        _lr = [bar_centers[_ix]\n                               for _ix in groups[groups.index(_bk)]]\n                        _lr = (min(_lr), max(_lr))\n                        p.plot(_lr, (_b, _b), **bracket_kwargs)\n        # draw (left, right, bottom-left, bottom-right, top, center, string)\n        for ((_l, _r), (_bl, _br), _t, _c, _s) in zip(brk_lr, brk_b, brk_t,\n                                                      brk_c, bracket_text):\n            # bracket text\n            defaults = dict(ha='center', annotation_clip=False,\n                            textcoords='offset points')\n            for k, v in defaults.items():\n                if k not in pval_kwargs.keys():\n                    pval_kwargs[k] = v\n            if 'va' not in pval_kwargs.keys():\n                pval_kwargs['va'] = 'center' if bracket_inline else 'baseline'\n            if 'xytext' not in pval_kwargs.keys():\n                pval_kwargs['xytext'] = (0, 0) if bracket_inline else (0, 2)\n            txt = p.annotate(_s, (_c, _t), **pval_kwargs)\n            txt.set_bbox(dict(facecolor='w', alpha=0,\n                              boxstyle='round, pad=0.2'))\n            plt.draw()\n            # bracket lines\n            lline = ((_l, _l), (_bl, _t))\n            rline = ((_r, _r), (_br, _t))\n            tline = ((_l, _r), (_t, _t))\n            if bracket_inline:\n                bb = txt.get_bbox_patch().get_window_extent()\n                txtw = np.diff(p.transData.inverted().transform(bb),\n                               axis=0).ravel()[0]\n                _m = _c - txtw / 2.\n                _n = _c + txtw / 2.\n                tline = [((_l, _m), (_t, _t)), ((_n, _r), (_t, _t))]\n            else:\n                tline = [((_l, _r), (_t, _t))]\n            for x, y in [lline, rline] + tline:\n                p.plot(x, y, **bracket_kwargs)\n            # boost ymax if needed\n            ybnd = p.get_ybound()\n            if ybnd[-1] < _t + txth:\n                p.set_ybound(ybnd[0], _t + txth)\n    # annotation\n    box_off(p)\n    p.tick_params(axis='x', length=0, pad=12)\n    p.xaxis.set_ticks(bar_centers)\n    if bar_names is not None:\n        p.xaxis.set_ticklabels(bar_names, va='baseline')\n    if group_names is not None:\n        ymin = ylim[0] if ylim is not None else p.get_ylim()[0]\n        yoffset = -2.5 * rcParams['font.size']\n        for gn, gp in zip(group_names, group_centers):\n            p.annotate(gn, xy=(gp, ymin), xytext=(0, yoffset),\n                       xycoords='data', textcoords='offset points',\n                       ha='center', va='baseline')\n    # axis limits\n    p.set_xlim(0, bar_edges[-1] + bar_widths[-1] + gap_size / 2)\n    if ylim is not None:\n        p.set_ylim(ylim)\n    # output file\n    if fname is not None:\n        from os.path import splitext\n        fmt = splitext(fname)[-1][1:]\n        plt.savefig(fname, format=fmt, transparent=True)\n    # return handles for subplot and barplot instances\n    plt.draw()\n    return (p, b)",
  "def box_off(ax):\n    \"\"\"Remove the top and right edges of a plot frame, and point ticks outward.\n    Parameter\n    ---------\n    ax : matplotlib.axes.Axes\n        A matplotlib plot or subplot object.\n    \"\"\"\n    ax.get_xaxis().tick_bottom()\n    ax.get_yaxis().tick_left()\n    ax.tick_params(axis='x', direction='out')\n    ax.tick_params(axis='y', direction='out')\n    ax.spines['right'].set_color('none')\n    ax.spines['top'].set_color('none')",
  "def plot_screen(screen, ax=None):\n    \"\"\"Plot a captured screenshot\n\n    Parameters\n    ----------\n    screen : array\n        The N x M x 3 (or 4) array of screen pixel values.\n    ax : matplotlib Axes | None\n        If provided, the axes will be plotted to and cleared of ticks.\n        If None, a figure will be created.\n\n    Retruns\n    -------\n    ax : matplotlib Axes\n        The axes used to plot the image.\n    \"\"\"\n    screen = np.array(screen)\n    if screen.ndim != 3 or screen.shape[2] not in [3, 4]:\n        raise ValueError('screen must be a 3D array with 3 or 4 channels')\n    if ax is None:\n        plt.figure()\n        ax = plt.axes([0, 0, 1, 1])\n    ax.imshow(screen)\n    ax.set_xticks([])\n    ax.set_yticks([])\n    plt.box('off')\n    return ax",
  "def press_times_to_hmfc(presses, targets, foils, tmin, tmax,\n                        return_type='counts'):\n    \"\"\"Convert press times to hits/misses/FA/CR\n\n    Parameters\n    ----------\n    presses : list\n        List of press times (in seconds).\n    targets : list\n        List of target times.\n    foils : list | None\n        List of foil (distractor) times.\n    tmin : float\n        Minimum time after a target/foil to consider a press.\n    tmax : float\n        Maximum time after a target/foil to consider a press.\n    return_type : str\n        Currently only ``'counts'`` is supported. Eventually we will\n        add rection-time support as well.\n\n    Returns\n    -------\n    hmfco : list\n        Hits, misses, false alarms, correct rejections, and other presses\n        (not within the window for a target or a masker).\n\n    Notes\n    -----\n    Multiple presses within a single \"target window\" (i.e., between ``tmin``\n    and ``tmax`` of a target) or \"masker window\" get treated as a single\n    press by this function. However, there is no such de-bouncing of responses\n    to \"other\" times.\n    \"\"\"\n    # Sanity check that targets and foils don't overlap (due to tmin/tmax)\n    targets = np.atleast_1d(targets) + tmin\n    foils = np.atleast_1d(foils) + tmin\n    dur = float(tmax - tmin)\n    assert dur > 0\n    presses = np.sort(np.atleast_1d(presses))\n    assert targets.ndim == foils.ndim == presses.ndim == 1\n    all_times = np.concatenate(([-np.inf], targets, foils, [np.inf]))\n    order = np.argsort(all_times)\n    inv_order = np.argsort(order)\n    all_times = all_times[order]\n    if not np.all(all_times[:-1] + dur <= all_times[1:]):\n        raise ValueError('Analysis windows for targets and foils overlap')\n    # Let's just loop (could probably be done with vector math, but it's\n    # too hard and unlikely to be correct)\n    locs = np.searchsorted(all_times, presses, 'right')\n    if len(locs) > 0:\n        assert locs.max() < len(all_times)  # should be True b/c of np.inf\n        assert locs.min() >= 1\n\n    # figure out which presses were to target or masker (valid_idx)\n    in_window = (presses <= all_times[locs - 1] + dur)\n    valid_idx = np.where(in_window)[0]\n    n_other = np.sum(~in_window)\n\n    # figure out which of valid presses were to target or masker\n    used = np.unique(locs[valid_idx])  # unique to remove double-presses\n    orig_places = (inv_order[used - 1] - 1)\n    n_hit = sum(orig_places < len(targets))\n    n_fa = len(used) - n_hit\n    n_miss = len(targets) - n_hit\n    n_cr = len(foils) - n_fa\n    return n_hit, n_miss, n_fa, n_cr, n_other",
  "def logit(prop, max_events=None):\n    \"\"\"Convert proportion (expressed in the range [0, 1]) to logit.\n\n    Parameters\n    ----------\n    prop : float | array-like\n        the occurrence proportion.\n    max_events : int | array-like | None\n        the number of events used to calculate ``prop``. Used in a correction\n        factor for cases when ``prop`` is 0 or 1, to prevent returning ``inf``.\n        If ``None``, no correction is done, and ``inf`` or ``-inf`` may result.\n\n    Returns\n    -------\n    lgt : ``numpy.ndarray``, with shape matching ``numpy.array(prop).shape``.\n    \"\"\"\n    prop = np.atleast_1d(prop).astype(float)\n    if np.any([prop > 1, prop < 0]):\n        raise ValueError('Proportions must be in the range [0, 1].')\n    if max_events is not None:\n        # add equivalent of half an event to 0s, and subtract same from 1s\n        max_events = np.atleast_1d(max_events) * np.ones_like(prop)\n        corr_factor = 0.5 / max_events\n        for loc in zip(*np.where(prop == 0)):\n            prop[loc] = corr_factor[loc]\n        for loc in zip(*np.where(prop == 1)):\n            prop[loc] = 1 - corr_factor[loc]\n    return np.log(prop / (np.ones_like(prop) - prop))",
  "def sigmoid(x, lower=0., upper=1., midpt=0., slope=1.):\n    \"\"\"Calculate sigmoidal values along the x-axis\n\n    Parameters\n    ----------\n    x : array-like\n        x-values to calculate the sigmoidal values from.\n    lower : float\n        The lower y-asymptote.\n    upper : float\n        The upper y-asymptote.\n    midpt : float\n        The x-value that obtains 50% between the lower and upper asymptote.\n    slope : float\n        The slope of the sigmoid.\n\n    Returns\n    -------\n    y : array\n        The y-values of the sigmoid evaluated at x.\n    \"\"\"\n    x = np.asarray(x)\n    lower = float(lower)\n    upper = float(upper)\n    midpt = float(midpt)\n    slope = float(slope)\n    y = (upper - lower) / (1 + np.exp(-slope * (x - midpt))) + lower\n    return y",
  "def fit_sigmoid(x, y, p0=None, fixed=()):\n    \"\"\"Fit a sigmoid to summary data\n\n    Given a set of average values ``y`` (e.g., response probabilities) as a\n    function of a variable ``x`` (e.g., presented target level), this\n    will estimate the underlying sigmoidal response. Note that the fitting\n    function can be sensitive to the shape of the data, so always inspect\n    your results.\n\n    Parameters\n    ----------\n    x : array-like\n        x-values along the sigmoid.\n    y : array-like\n        y-values at each location in the sigmoid.\n    p0 : array-like | None\n        Initial guesses for the fit. Can be None to estimate all parameters,\n        or members of the array can be None to have these automatically\n        estimated.\n    fixed : list of str\n        Which parameters should be fixed.\n\n    Returns\n    -------\n    lower, upper, midpt, slope : floats\n        See expyfun.analyze.sigmoid for descriptions.\n    \"\"\"\n    # Initial estimates\n    x = np.asarray(x)\n    y = np.asarray(y)\n    k = 2 * 4. / (np.max(x) - np.min(x))\n    if p0 is None:\n        p0 = [None] * 4\n    p0 = list(p0)\n    for ii, p in enumerate([np.min(y), np.max(y),\n                            np.mean([np.max(x), np.min(x)]), k]):\n        p0[ii] = p if p0[ii] is None else p0[ii]\n    p0 = np.array(p0, dtype=np.float64)\n    if p0.size != 4 or p0.ndim != 1:\n        raise ValueError('p0 must have 4 elements, or be None')\n\n    # Fixing values\n    p_types = ('lower', 'upper', 'midpt', 'slope')\n    for f in fixed:\n        if f not in p_types:\n            raise ValueError('fixed {0} not in parameter list {1}'\n                             ''.format(f, p_types))\n    fixed = np.array([(True if f in fixed else False) for f in p_types], bool)\n\n    kwargs = dict()\n    idx = list()\n    keys = list()\n    for ii, key in enumerate(p_types):\n        if fixed[ii]:\n            kwargs[key] = p0[ii]\n        else:\n            keys.append(key)\n            idx.append(ii)\n    p0 = p0[idx]\n    if len(idx) == 0:\n        raise RuntimeError('cannot fit with all fixed values')\n\n    def wrapper(*args):\n        assert len(args) == len(keys) + 1\n        for key, arg in zip(keys, args[1:]):\n            kwargs[key] = arg\n        return sigmoid(args[0], **kwargs)\n\n    out = curve_fit(wrapper, x, y, p0=p0)[0]\n    assert len(idx) == len(out)\n    for ii, o in zip(idx, out):\n        kwargs[p_types[ii]] = o\n    return namedtuple('params', p_types)(**kwargs)",
  "def rt_chisq(x, axis=None):\n    \"\"\"Chi square fit for reaction times (a better summary statistic than mean)\n\n    Parameters\n    ----------\n    x : array-like\n        Reaction time data to fit.\n\n    axis : int | None\n        The axis along which to calculate the chi-square fit. If none, ``x``\n        will be flattened before fitting.\n\n    Returns\n    -------\n    peak : float | array-like\n        The peak(s) of the fitted chi-square probability density function(s).\n\n    Notes\n    -----\n    Verify that it worked by plotting pdf vs hist (for 1-dimensional x)::\n\n        >>> import numpy as np\n        >>> from scipy import stats as ss\n        >>> import matplotlib.pyplot as plt\n        >>> plt.ion()\n        >>> x = np.abs(np.random.randn(10000) + 1)\n        >>> lsp = np.linspace(np.floor(np.amin(x)), np.ceil(np.amax(x)), 100)\n        >>> df, loc, scale = ss.chi2.fit(x, floc=0)\n        >>> pdf = ss.chi2.pdf(lsp, df, scale=scale)\n        >>> plt.plot(lsp, pdf)\n        >>> plt.hist(x, normed=True)\n    \"\"\"\n    x = np.asarray(x)\n    if np.any(np.less(x, 0)):  # save the user some pain\n        raise ValueError('x cannot have negative values')\n    if axis is None:\n        df, _, scale = ss.chi2.fit(x, floc=0)\n    else:\n        fit = partial(ss.chi2.fit, floc=0)\n        params = np.apply_along_axis(fit, axis=axis, arr=x)  # df, loc, scale\n        pmut = np.concatenate((np.atleast_1d(axis),\n                               np.delete(np.arange(x.ndim), axis)))\n        df = np.transpose(params, pmut)[0]\n        scale = np.transpose(params, pmut)[2]\n    quartiles = np.percentile(x, (25, 75))\n    whiskers = quartiles + np.array((-1.5, 1.5)) * np.diff(quartiles)\n    n_bad = np.sum(np.logical_or(np.less(x, whiskers[0]),\n                                 np.greater(x, whiskers[1])))\n    if n_bad > 0:\n        warnings.warn('{0} likely bad values in x (of {1})'\n                      ''.format(n_bad, x.size))\n    peak = np.maximum(0, (df - 2)) * scale\n    return peak",
  "def dprime(hmfc, zero_correction=True):\n    \"\"\"Estimates d-prime, with optional correction factor to avoid infinites.\n\n    Parameters\n    ----------\n    hmfc : array-like\n        Hits, misses, false-alarms, and correct-rejections, in that order, as\n        array-like data with last dimension having size 4.\n    zero_correction : bool\n        Whether to add a correction factor of 0.5 to each category to prevent\n        division-by-zero leading to infinite d-prime values.\n\n    Returns\n    -------\n    dp : array-like\n        Array of dprimes with shape ``hmfc.shape[:-1]``.\n\n    Notes\n    -----\n    For two-alternative forced-choice tasks, it is recommended to enter correct\n    trials as hits and incorrect trials as false alarms, and enter misses and\n    correct rejections as 0. An alternative is to use ``dprime_2afc()``, which\n    wraps to ``dprime()`` and does this assignment for you.\n    \"\"\"\n    hmfc = _check_dprime_inputs(hmfc)\n    a = 0.5 if zero_correction else 0.0\n    dp = ss.norm.ppf((hmfc[..., 0] + a) /\n                     (hmfc[..., 0] + hmfc[..., 1] + 2 * a)) - \\\n        ss.norm.ppf((hmfc[..., 2] + a) /\n                    (hmfc[..., 2] + hmfc[..., 3] + 2 * a))\n    return dp",
  "def dprime_2afc(hm, zero_correction=True):\n    \"\"\"Estimates d-prime for two-alternative forced-choice paradigms.\n\n    Parameters\n    ----------\n    hm : array-like\n        Correct trials (hits) and incorrect trials (misses), in that order, as\n        array-like data with last dimension having size 4.\n    zero_correction : bool\n        Whether to add a correction factor of 0.5 to each category to prevent\n        division-by-zero leading to infinite d-prime values.\n\n    Returns\n    -------\n    dp : array-like\n        Array of dprimes with shape ``hmfc.shape[:-1]``.\n    \"\"\"\n    hmfc = _check_dprime_inputs(hm, True)\n    return dprime(hmfc, zero_correction)",
  "def _check_dprime_inputs(hmfc, tafc=False):\n    \"\"\"Formats input to dprime() and dprime_2afc().\n\n    Parameters\n    ----------\n    hmfc : array-like\n        Hit, miss, false-alarm, correct-rejection; or hit, miss for 2AFC.\n    tafc : bool\n        Is this a 2AFC design?\n    \"\"\"\n    hmfc = np.asarray(hmfc)\n    if tafc:\n        if hmfc.shape[-1] != 2:\n            raise ValueError('Array must have last dimension 2.')\n    else:\n        if hmfc.shape[-1] != 4:\n            raise ValueError('Array must have last dimension 4')\n    if tafc:\n        z = np.zeros(hmfc.shape[:-1] + (4,), hmfc.dtype)\n        z[..., [0, 2]] = hmfc\n        hmfc = z\n    if hmfc.dtype not in (np.int64, np.int32):\n        warnings.warn('Argument (%s) to dprime() cast to np.int64; floating '\n                      'point values will have been truncated.' % hmfc.dtype)\n        hmfc = hmfc.astype(np.int64)\n    return hmfc",
  "def wrapper(*args):\n        assert len(args) == len(keys) + 1\n        for key, arg in zip(keys, args[1:]):\n            kwargs[key] = arg\n        return sigmoid(args[0], **kwargs)",
  "def restore_values(correct, other, idx):\n    \"\"\"Restore missing values from one sequence using another\n\n    Parameters\n    ----------\n    correct : array\n        1D array of correct values.\n    other : array\n        1D array of other values that have missing components.\n    idx : array\n        Indices of the values in correct that are missing from other.\n        If None, they will be estimated from the data.\n\n    Returns\n    -------\n    other : array\n        Array of other values, with interpolated values inserted.\n    idx : array\n        Array of indices that were interpolated.\n\n    Notes\n    -----\n    This function works even if ``correct`` and ``other`` have different\n    scales and shifts. Consider an experiment where the stimulus start\n    times were saved by ``ExperimentController`` but the Eyelink system\n    missed a ``SYNCTIME`` -- this function allows the proper sample numbers\n    to be accurately estimated.\n    \"\"\"\n    correct = np.array(correct, np.float64)\n    other = np.array(other, np.float64)\n    if correct.ndim != 1 or other.ndim != 1 or other.size > correct.size:\n        raise RuntimeError('correct and other must be 1D, and correct must '\n                           'be at least as long as other')\n    keep = np.ones(len(correct), bool)\n    for ii in idx:\n        keep[ii] = False\n    replace = np.where(~keep)[0]\n    keep = np.where(keep)[0]\n    use = correct[keep]\n\n    X = linalg.pinv(np.array((np.ones_like(use), use)).T)\n    X = np.dot(X, other)\n    test = np.dot(np.array((np.ones_like(use), use)).T, X)\n    if not np.allclose(other, test):  # validate fit\n        raise RuntimeError('data could not be fit')\n    miss = correct[replace]\n    vals = np.dot(np.array((np.ones_like(miss), miss)).T, X)\n    out = np.zeros(len(correct), np.float64)\n    out[keep] = other\n    out[replace] = vals\n    return out, replace",
  "def _convert_color(color):\n    \"\"\"Convert 3- or 4-element color into OpenGL usable color\"\"\"\n    color = (0., 0., 0., 0.) if color is None else color\n    color = 255 * np.array(colorConverter.to_rgba(color))\n    color = color.astype(np.uint8)\n    return tuple(color)",
  "def _replicate_color(color, pts):\n    \"\"\"Convert single color to color array for OpenGL trianglulations\"\"\"\n    return np.tile(color, len(pts) // 2)",
  "class Text(object):\n    \"\"\"A text object\n\n    Parameters\n    ----------\n    ec : instance of ExperimentController\n        Parent EC.\n    text : str\n        The text to display.\n    pos : array\n        2-element array consisting of X- and Y-position coordinates.\n    color : matplotlib Color\n        Color of the text.\n    font_name : str\n        Font to use.\n    font_size : float\n        Font size (points) to use.\n    height : float | None\n        Height of the text region. None will automatically allocate the\n        necessary size.\n    width : float | None | str\n        Width (in pixels) of the text region. `'auto'` will allocate 80% of\n        the screen width, useful for instructions. None will automatically\n        allocate sufficient space, but not that this disables text wrapping.\n    anchor_x : str\n        Horizontal text anchor (e.g., ``'center'``).\n    anchor_y : str\n        Vertical text anchor (e.g., ``'center'``).\n    units : str\n        Units to use. These will apply to all spatial aspects of the drawing.\n        shape e.g. size, position. See ``check_units`` for options.\n    wrap : bool\n        Whether or not the text will wrap to fit in screen, appropriate for\n        multiline text. Inappropriate for text requiring precise positioning.\n    attr : bool\n        Should the text be interpreted with pyglet's ``decode_attributed``\n        method? This allows inline formatting for text color, e.g.,\n        ``'This is {color (255, 0, 0, 255)}red text'``. If ``attr=True``, the\n        values of ``font_name``, ``font_size``, and ``color`` are automatically\n        prepended to ``text`` (though they will be overridden by any inline\n        formatting within ``text`` itself).\n\n    Returns\n    -------\n    text : instance of Text\n        The text object.\n    \"\"\"\n    def __init__(self, ec, text, pos=(0, 0), color='white',\n                 font_name='Arial', font_size=24, height=None,\n                 width='auto', anchor_x='center', anchor_y='center',\n                 units='norm', wrap=False, attr=True):\n        import pyglet\n        pos = np.array(pos)[:, np.newaxis]\n        pos = ec._convert_units(pos, units, 'pix')\n        if width == 'auto':\n            width = float(ec.window_size_pix[0]) * 0.8\n        elif isinstance(width, string_types):\n            raise ValueError('\"width\", if str, must be \"auto\"')\n        self._attr = attr\n        text = text + ' '  # pyglet bug workaround\n        if self._attr:\n            text = text.replace('\\n', '\\n ')  # pyglet bug workaround\n            preamble = ('{{font_name \\'{}\\'}}{{font_size {}}}{{color {}}}'\n                        '').format(font_name, font_size, _convert_color(color))\n            doc = pyglet.text.decode_attributed(preamble + text)\n            self._text = pyglet.text.layout.TextLayout(doc, width=width,\n                                                       height=height,\n                                                       multiline=wrap,\n                                                       dpi=int(ec.dpi))\n        else:\n            self._text = pyglet.text.Label(text, width=width, height=height,\n                                           multiline=wrap, dpi=int(ec.dpi))\n            self._text.color = _convert_color(color)\n            self._text.font_name = font_name\n            self._text.font_size = font_size\n        self._text.x = pos[0]\n        self._text.y = pos[1]\n        self._text.anchor_x = anchor_x\n        self._text.anchor_y = anchor_y\n\n    def set_color(self, color):\n        \"\"\"Set the text color\n\n        Parameters\n        ----------\n        color : matplotlib Color | None\n            The color. Use None for no color.\n        \"\"\"\n        if self._attr:\n            self._text.document.set_style(0, len(self._text.document.text),\n                                          {'color': _convert_color(color)})\n        else:\n            self._text.color = _convert_color(color)\n\n    def draw(self):\n        \"\"\"Draw the object to the display buffer\"\"\"\n        self._text.draw()",
  "class _Triangular(object):\n    \"\"\"Super class for objects that use trianglulations and/or lines\"\"\"\n    def __init__(self, ec, fill_color, line_color, line_width, line_loop):\n        self._ec = ec\n        self.set_fill_color(fill_color)\n        self.set_line_color(line_color)\n        self._line_width = line_width\n        self._line_loop = line_loop  # whether or not lines drawn are looped\n\n    def set_fill_color(self, fill_color):\n        \"\"\"Set the object color\n\n        Parameters\n        ----------\n        fill_color : matplotlib Color | None\n            The fill color. Use None for no fill.\n        \"\"\"\n        self._fill_color = _convert_color(fill_color)\n\n    def set_line_color(self, line_color):\n        \"\"\"Set the object color\n\n        Parameters\n        ----------\n        fill_color : matplotlib Color | None\n            The fill color. Use None for no fill.\n        \"\"\"\n        self._line_color = _convert_color(line_color)\n\n    def set_line_width(self, line_width):\n        \"\"\"Set the line width in pixels\n\n        Parameters\n        ----------\n        line_width : float\n            The line width. Must be given in pixels. Due to OpenGL\n            limitations, it must be `0.0 <= line_width <= 10.0`.\n        \"\"\"\n        line_width = float(line_width)\n        if not (0.0 <= line_width <= 10.0):\n            raise ValueError('line_width must be between 0 and 10')\n        self._line_width = line_width\n\n    def draw(self):\n        \"\"\"Draw the object to the display buffer\"\"\"\n        import pyglet\n        from pyglet import gl\n        if self._points is not None and self._fill_color is not None:\n            color = _replicate_color(self._fill_color, self._points)\n            pyglet.graphics.draw_indexed(len(self._points) // 2,\n                                         gl.GL_TRIANGLES,\n                                         self._tris,\n                                         ('v2f', self._points),\n                                         ('c4B', color))\n        if (self._line_points is not None and self._line_width > 0.0 and\n                self._line_color is not None):\n            color = _replicate_color(self._line_color, self._line_points)\n            gl.glLineWidth(self._line_width)\n            if self._line_loop:\n                gl_cmd = gl.GL_LINE_LOOP\n            else:\n                gl_cmd = gl.GL_LINE_STRIP\n            pyglet.graphics.draw(len(self._line_points) // 2,\n                                 gl_cmd,\n                                 ('v2f', self._line_points),\n                                 ('c4B', color))",
  "class Line(_Triangular):\n    \"\"\"A connected set of line segments\n\n    Parameters\n    ----------\n    ec : instance of ExperimentController\n        Parent EC.\n    coords : array-like\n        2 x N set of X, Y coordinates.\n    units : str\n        Units to use. These will apply to all spatial aspects of the drawing.\n        shape e.g. size, position. See ``check_units`` for options.\n    line_color : matplotlib Color\n        Color of the line.\n    line_width : float\n        Line width in pixels.\n    line_loop : bool\n        If True, the last point will be joined to the first in a loop.\n\n    Returns\n    -------\n    line : instance of Line\n        The line object.\n    \"\"\"\n    def __init__(self, ec, coords, units='norm', line_color='white',\n                 line_width=1.0, line_loop=False):\n        _Triangular.__init__(self, ec, fill_color=None, line_color=line_color,\n                             line_width=line_width, line_loop=line_loop)\n        self._points = None\n        self._tris = None\n        self.set_coords(coords, units)\n        self.set_line_color(line_color)\n\n    def set_coords(self, coords, units='norm'):\n        \"\"\"Set line coordinates\n\n        Parameters\n        ----------\n        coords : array-like\n            2 x N set of X, Y coordinates.\n        \"\"\"\n        check_units(units)\n        coords = np.array(coords, dtype=float)\n        if coords.ndim == 1:\n            coords = coords[:, np.newaxis]\n        if coords.ndim != 2 or coords.shape[0] != 2:\n            raise ValueError('coords must be a vector of length 2, or an '\n                             'array with 2 dimensions (with first dimension '\n                             'having length 2')\n        coords = self._ec._convert_units(coords, units, 'pix')\n        self._line_points = coords.T.flatten()",
  "class Triangle(_Triangular):\n    \"\"\"A triangle\n\n    Parameters\n    ----------\n    ec : instance of ExperimentController\n        Parent EC.\n    coords : array-like\n        2 x 3 set of X, Y coordinates.\n    units : str\n        Units to use. These will apply to all spatial aspects of the drawing.\n        shape e.g. size, position. See ``check_units`` for options.\n    fill_color : matplotlib Color\n        Color of the triangle.\n    line_color : matplotlib Color | None\n        Color of the border line. None is transparent.\n    line_width : float\n        Line width in pixels.\n\n    Returns\n    -------\n    line : instance of Triangle\n        The triangle object.\n    \"\"\"\n    def __init__(self, ec, coords, units='norm', fill_color='white',\n                 line_color=None, line_width=1.0):\n        _Triangular.__init__(self, ec, fill_color=fill_color,\n                             line_color=line_color, line_width=line_width,\n                             line_loop=True)\n        self.set_coords(coords, units)\n        self.set_fill_color(fill_color)\n\n    def set_coords(self, coords, units='norm'):\n        \"\"\"Set triangle coordinates\n\n        Parameters\n        ----------\n        coords : array-like\n            2 x 3 set of X, Y coordinates.\n        \"\"\"\n        check_units(units)\n        coords = np.array(coords, dtype=float)\n        if coords.shape != (2, 3):\n            raise ValueError('coords must be an array of size 2 x 3')\n        coords = self._ec._convert_units(coords, units, 'pix')\n        self._points = coords.T.flatten()\n        self._tris = np.array([0, 1, 2])\n        self._line_points = self._points",
  "class Rectangle(_Triangular):\n    \"\"\"A rectangle\n\n    Parameters\n    ----------\n    ec : instance of ExperimentController\n        Parent EC.\n    pos : array-like\n        4-element array-like with X, Y center and width, height.\n    units : str\n        Units to use. These will apply to all spatial aspects of the drawing.\n        shape e.g. size, position. See ``check_units`` for options.\n    fill_color : matplotlib Color | None\n        Color to fill with. None is transparent.\n    line_color : matplotlib Color | None\n        Color of the border line. None is transparent.\n    line_width : float\n        Line width in pixels.\n\n    Returns\n    -------\n    line : instance of Rectangle\n        The rectangle object.\n    \"\"\"\n    def __init__(self, ec, pos, units='norm', fill_color='white',\n                 line_color=None, line_width=1.0):\n        _Triangular.__init__(self, ec, fill_color=fill_color,\n                             line_color=line_color, line_width=line_width,\n                             line_loop=True)\n        self.set_pos(pos, units)\n\n    def set_pos(self, pos, units='norm'):\n        \"\"\"Set the position of the rectangle\n\n        Parameters\n        ----------\n        pos : array-like\n            X, Y, width, height of the rectangle.\n        units : str\n            Units to use. See ``check_units`` for options.\n        \"\"\"\n        check_units(units)\n        # do this in normalized units, then convert\n        pos = np.array(pos)\n        if not (pos.ndim == 1 and pos.size == 4):\n            raise ValueError('pos must be a 4-element array-like vector')\n        self._pos = pos\n        w = self._pos[2]\n        h = self._pos[3]\n        points = np.array([[-w / 2., -h / 2.],\n                           [-w / 2., h / 2.],\n                           [w / 2., h / 2.],\n                           [w / 2., -h / 2.]]).T\n        points += np.array(self._pos[:2])[:, np.newaxis]\n        points = self._ec._convert_units(points, units, 'pix')\n        self._points = points.T.flatten()\n        self._tris = np.array([0, 1, 2, 0, 2, 3])\n        self._line_points = self._points",
  "class Diamond(_Triangular):\n    \"\"\"A diamond\n\n    Parameters\n    ----------\n    ec : instance of ExperimentController\n        Parent EC.\n    pos : array-like\n        4-element array-like with X, Y center and width, height.\n    units : str\n        Units to use. These will apply to all spatial aspects of the drawing.\n        shape e.g. size, position. See ``check_units`` for options.\n    fill_color : matplotlib Color | None\n        Color to fill with. None is transparent.\n    line_color : matplotlib Color | None\n        Color of the border line. None is transparent.\n    line_width : float\n        Line width in pixels.\n\n    Returns\n    -------\n    line : instance of Rectangle\n        The rectangle object.\n    \"\"\"\n    def __init__(self, ec, pos, units='norm', fill_color='white',\n                 line_color=None, line_width=1.0):\n        _Triangular.__init__(self, ec, fill_color=fill_color,\n                             line_color=line_color, line_width=line_width,\n                             line_loop=True)\n        self.set_pos(pos, units)\n\n    def set_pos(self, pos, units='norm'):\n        \"\"\"Set the position of the rectangle\n\n        Parameters\n        ----------\n        pos : array-like\n            X, Y, width, height of the rectangle.\n        units : str\n            Units to use. See ``check_units`` for options.\n        \"\"\"\n        check_units(units)\n        # do this in normalized units, then convert\n        pos = np.array(pos)\n        if not (pos.ndim == 1 and pos.size == 4):\n            raise ValueError('pos must be a 4-element array-like vector')\n        self._pos = pos\n        w = self._pos[2]\n        h = self._pos[3]\n        points = np.array([[w / 2., 0.],\n                           [0., h / 2.],\n                           [-w / 2., 0.],\n                           [0., -h / 2.]]).T\n        points += np.array(self._pos[:2])[:, np.newaxis]\n        points = self._ec._convert_units(points, units, 'pix')\n        self._points = points.T.flatten()\n        self._tris = np.array([0, 1, 2, 0, 2, 3])\n        self._line_points = self._points",
  "class Circle(_Triangular):\n    \"\"\"A circle or ellipse\n\n    Parameters\n    ----------\n    ec : instance of ExperimentController\n        Parent EC.\n    radius : float | array-like\n        Radius of the circle. Can be array-like with two elements to\n        make an ellipse.\n    pos : array-like\n        2-element array-like with X, Y center positions.\n    units : str\n        Units to use. These will apply to all spatial aspects of the drawing.\n        shape e.g. size, position. See ``check_units`` for options.\n    n_edges : int\n        Number of edges to use (must be >= 4) to approximate a circle.\n    fill_color : matplotlib Color | None\n        Color to fill with. None is transparent.\n    line_color : matplotlib Color | None\n        Color of the border line. None is transparent.\n    line_width : float\n        Line width in pixels.\n\n    Returns\n    -------\n    circle : instance of Circle\n        The circle object.\n    \"\"\"\n    def __init__(self, ec, radius=1, pos=(0, 0), units='norm',\n                 n_edges=200, fill_color='white', line_color=None,\n                 line_width=1.0):\n        _Triangular.__init__(self, ec, fill_color=fill_color,\n                             line_color=line_color, line_width=line_width,\n                             line_loop=True)\n        if not isinstance(n_edges, int):\n            raise TypeError('n_edges must be an int')\n        if n_edges < 4:\n            raise ValueError('n_edges must be >= 4 for a reasonable circle')\n        self._n_edges = n_edges\n\n        # need to set a dummy value here so recalculation doesn't fail\n        self._radius = np.array([1., 1.])\n        self.set_pos(pos, units)\n        self.set_radius(radius, units)\n\n        # construct triangulation (never changes so long as n_edges is fixed)\n        tris = [[0, ii + 1, ii + 2] for ii in range(n_edges)]\n        tris = np.concatenate(tris)\n        tris[-1] = 1  # fix wrap for last triangle\n        self._tris = tris\n\n    def set_radius(self, radius, units='norm'):\n        \"\"\"Set the position and radius of the circle\n\n        Parameters\n        ----------\n        radius : array-like | float\n            X- and Y-direction extents (radii) of the circle / ellipse.\n            A single value (float) will be replicated for both directions.\n        units : str\n            Units to use. See ``check_units`` for options.\n        \"\"\"\n        check_units(units)\n        radius = np.atleast_1d(radius).astype(float)\n        if radius.ndim != 1 or radius.size > 2:\n            raise ValueError('radius must be a 1- or 2-element '\n                             'array-like vector')\n        if radius.size == 1:\n            radius = np.r_[radius, radius]\n        # convert to pixel (OpenGL) units\n        self._radius = self._ec._convert_units(radius[:, np.newaxis],\n                                               units, 'pix')[:, 0]\n        # need to subtract center position\n        ctr = self._ec._convert_units(np.zeros((2, 1)), units, 'pix')[:, 0]\n        self._radius -= ctr\n        self._recalculate()\n\n    def set_pos(self, pos, units='norm'):\n        \"\"\"Set the position and radius of the circle\n\n        Parameters\n        ----------\n        pos : array-like\n            X, Y center of the circle.\n        units : str\n            Units to use. See ``check_units`` for options.\n        \"\"\"\n        check_units(units)\n        pos = np.array(pos, dtype=float)\n        if not (pos.ndim == 1 and pos.size == 2):\n            raise ValueError('pos must be a 2-element array-like vector')\n        # convert to pixel (OpenGL) units\n        self._pos = self._ec._convert_units(pos[:, np.newaxis],\n                                            units, 'pix')[:, 0]\n        self._recalculate()\n\n    def _recalculate(self):\n        \"\"\"Helper to recalculate point coordinates\"\"\"\n        edges = self._n_edges\n        arg = 2 * np.pi * (np.arange(edges) / float(edges))\n        points = np.array([self._radius[0] * np.cos(arg),\n                           self._radius[1] * np.sin(arg)])\n        points = np.c_[np.zeros((2, 1)), points]  # prepend the center\n        points += np.array(self._pos[:2], dtype=float)[:, np.newaxis]\n        self._points = points.T.ravel()\n        self._line_points = self._points[2:]",
  "class ConcentricCircles(object):\n    \"\"\"A set of filled concentric circles drawn without edges\n\n    Parameters\n    ----------\n    ec : instance of ExperimentController\n        Parent EC.\n    radii : list of float\n        Radii of the circles. Note that circles will be drawn in order,\n        so using e.g., radii=[1., 2.] will cause the first circle to be\n        covered by the second.\n    pos : array-like\n        2-element array-like with the X, Y center position.\n    units : str\n        Units to use. These will apply to all spatial aspects of the drawing.\n        See ``check_units`` for options.\n    colors : list or tuple of matplotlib Colors\n        Color to fill each circle with.\n\n    Returns\n    -------\n    circle : instance of Circle\n        The circle object.\n    \"\"\"\n    def __init__(self, ec, radii=(0.2, 0.05), pos=(0, 0), units='norm',\n                 colors=('w', 'k')):\n        radii = np.array(radii, float)\n        if radii.ndim != 1:\n            raise ValueError('radii must be 1D')\n        if not isinstance(colors, (tuple, list)):\n            raise TypeError('colors must be a tuple, list, or array')\n        if len(colors) != len(radii):\n            raise ValueError('colors and radii must be the same length')\n        # need to set a dummy value here so recalculation doesn't fail\n        self._circles = [Circle(ec, r, pos, units, fill_color=c, line_width=0)\n                         for r, c in zip(radii, colors)]\n\n    def __len__(self):\n        return len(self._circles)\n\n    def set_pos(self, pos, units='norm'):\n        \"\"\"Set the position of the circles\n\n        Parameters\n        ----------\n        pos : array-like\n            X, Y center of the circle.\n        units : str\n            Units to use. See ``check_units`` for options.\n        \"\"\"\n        for circle in self._circles:\n            circle.set_pos(pos, units)\n\n    def set_radius(self, radius, idx, units='norm'):\n        \"\"\"Set the radius of one of the circles\n\n        Parameters\n        ----------\n        radius : float\n            Radius the circle.\n        idx : int\n            Index of the circle.\n        units : str\n            Units to use. See ``check_units`` for options.\n        \"\"\"\n        self._circles[idx].set_radius(radius, units)\n\n    def set_radii(self, radii, units='norm'):\n        \"\"\"Set the color of each circle\n\n        Parameters\n        ----------\n        radii : array-like\n            List of radii to assign to the circles. Must contain the same\n            number of radii as the number of circles.\n        units : str\n            Units to use. See ``check_units`` for options.\n        \"\"\"\n        radii = np.array(radii, float)\n        if radii.ndim != 1 or radii.size != len(self):\n            raise ValueError('radii must contain exactly {0} radii'\n                             ''.format(len(self)))\n        for idx, radius in enumerate(radii):\n            self.set_radius(radius, idx, units)\n\n    def set_color(self, color, idx):\n        \"\"\"Set the color of one of the circles\n\n        Parameters\n        ----------\n        color : matplotlib Color\n            Color of the circle.\n        idx : int\n            Index of the circle.\n        units : str\n            Units to use. See ``check_units`` for options.\n        \"\"\"\n        self._circles[idx].set_fill_color(color)\n\n    def set_colors(self, colors):\n        \"\"\"Set the color of each circle\n\n        Parameters\n        ----------\n        colors : list or tuple of matplotlib Colors\n            Must be of type list or tuple, and contain the same number of\n            colors as the number of circles.\n        \"\"\"\n        if not isinstance(colors, (tuple, list)) or len(colors) != len(self):\n            raise ValueError('colors must be a list or tuple with {0} colors'\n                             ''.format(len(self)))\n        for idx, color in enumerate(colors):\n            self.set_color(color, idx)\n\n    def draw(self):\n        \"\"\"Draw the fixation dot\n        \"\"\"\n        for circle in self._circles:\n            circle.draw()",
  "class FixationDot(ConcentricCircles):\n    \"\"\"A reasonable centered fixation dot\n\n    This uses concentric circles, the inner of which has a radius of one\n    pixel, to create a fixation dot. If finer-grained control is desired,\n    consider using ``ConcentricCircles``.\n\n    Parameters\n    ----------\n    ec : instance of ExperimentController\n        Parent EC.\n    colors : list of matplotlib Colors\n        Color to fill the outer and inner circle with, respectively.\n\n    Returns\n    -------\n    fix : instance of FixationDot\n        The fixation dot.\n    \"\"\"\n    def __init__(self, ec, colors=('w', 'k')):\n        if len(colors) != 2:\n            raise ValueError('colors must have length 2')\n        super(FixationDot, self).__init__(ec, radii=[0.2, 0.2],\n                                          pos=[0, 0], units='deg',\n                                          colors=colors)\n        self.set_radius(1, 1, units='pix')",
  "class RawImage(object):\n    \"\"\"Create image from array for on-screen display\n\n    Parameters\n    ----------\n    ec : instance of ExperimentController\n        Parent EC.\n    image_buffer : array\n        N x M x 3 (or 4) array. Color values should range between 0 and 1.\n    pos : array-like\n        2-element array-like with X, Y (center) arguments.\n    scale : float\n        The scale factor. 1 is native size (pixel-to-pixel), 2 is twice as\n        large, etc.\n    units : str\n        Units to use for the position. See ``check_units`` for options.\n\n    Returns\n    -------\n    img : instance of RawImage\n        The image object.\n    \"\"\"\n    def __init__(self, ec, image_buffer, pos=(0, 0), scale=1., units='norm'):\n        self._ec = ec\n        self._img = None\n        self.set_image(image_buffer)\n        self.set_pos(pos, units)\n        self.set_scale(scale)\n\n    def set_image(self, image_buffer):\n        \"\"\"Set image buffer data\n\n        Parameters\n        ----------\n        image_buffer : array\n            N x M x 3 (or 4) array. Can be type ``np.float64`` or ``np.uint8``.\n            If ``np.float64``, color values must range between 0 and 1.\n            ``np.uint8`` is slightly more efficient.\n        \"\"\"\n        from pyglet import image, sprite\n        image_buffer = np.ascontiguousarray(image_buffer)\n        if image_buffer.dtype not in (np.float64, np.uint8):\n            raise TypeError('image_buffer must be np.float64 or np.uint8')\n        if image_buffer.dtype == np.float64:\n            if image_buffer.max() > 1 or image_buffer.min() < 0:\n                raise ValueError('all float values must be between 0 and 1')\n            image_buffer = (image_buffer * 255).astype('uint8')\n        if not image_buffer.ndim == 3 or image_buffer.shape[2] not in [3, 4]:\n            raise RuntimeError('image_buffer incorrect size: {}'\n                               ''.format(image_buffer.shape))\n        # add alpha channel if necessary\n        dims = image_buffer.shape\n        fmt = 'RGB' if dims[2] == 3 else 'RGBA'\n        self._sprite = sprite.Sprite(image.ImageData(dims[1], dims[0], fmt,\n                                                     image_buffer.tostring(),\n                                                     -dims[1] * dims[2]))\n\n    def set_pos(self, pos, units='norm'):\n        \"\"\"Set image position\n\n        Parameters\n        ----------\n        ec : instance of ExperimentController\n            Parent EC.\n        pos : array-like\n            2-element array-like with X, Y (center) arguments.\n        units : str\n            Units to use. See ``check_units`` for options.\n        \"\"\"\n        pos = np.array(pos, float)\n        if pos.ndim != 1 or pos.size != 2:\n            raise ValueError('pos must be a 2-element array')\n        pos = np.reshape(pos, (2, 1))\n        self._pos = self._ec._convert_units(pos, units, 'pix').ravel()\n\n    @property\n    def bounds(self):\n        \"\"\"L, B, W, H (in pixels) of the image\"\"\"\n        pos = np.array(self._pos, float)\n        size = np.array([self._sprite.width,\n                         self._sprite.height], float)\n        bounds = np.concatenate((pos - size / 2., pos + size / 2.))\n        return bounds[[0, 2, 1, 3]]\n\n    @property\n    def scale(self):\n        return self._scale\n\n    def set_scale(self, scale):\n        \"\"\"Create image from array for on-screen display\n\n        Parameters\n        ----------\n        ec : instance of ExperimentController\n            Parent EC.\n        pos : array-like\n            2-element array-like with X, Y (center) arguments.\n        units : str\n            Units to use. See ``check_units`` for options.\n        \"\"\"\n        scale = float(scale)\n        self._scale = scale\n        self._sprite.scale = self._scale\n\n    def draw(self):\n        \"\"\"Draw the image to the buffer\"\"\"\n        self._sprite.scale = self._scale\n        pos = self._pos - [self._sprite.width / 2., self._sprite.height / 2.]\n        self._sprite.set_position(pos[0], pos[1])\n        self._sprite.draw()",
  "def __init__(self, ec, text, pos=(0, 0), color='white',\n                 font_name='Arial', font_size=24, height=None,\n                 width='auto', anchor_x='center', anchor_y='center',\n                 units='norm', wrap=False, attr=True):\n        import pyglet\n        pos = np.array(pos)[:, np.newaxis]\n        pos = ec._convert_units(pos, units, 'pix')\n        if width == 'auto':\n            width = float(ec.window_size_pix[0]) * 0.8\n        elif isinstance(width, string_types):\n            raise ValueError('\"width\", if str, must be \"auto\"')\n        self._attr = attr\n        text = text + ' '  # pyglet bug workaround\n        if self._attr:\n            text = text.replace('\\n', '\\n ')  # pyglet bug workaround\n            preamble = ('{{font_name \\'{}\\'}}{{font_size {}}}{{color {}}}'\n                        '').format(font_name, font_size, _convert_color(color))\n            doc = pyglet.text.decode_attributed(preamble + text)\n            self._text = pyglet.text.layout.TextLayout(doc, width=width,\n                                                       height=height,\n                                                       multiline=wrap,\n                                                       dpi=int(ec.dpi))\n        else:\n            self._text = pyglet.text.Label(text, width=width, height=height,\n                                           multiline=wrap, dpi=int(ec.dpi))\n            self._text.color = _convert_color(color)\n            self._text.font_name = font_name\n            self._text.font_size = font_size\n        self._text.x = pos[0]\n        self._text.y = pos[1]\n        self._text.anchor_x = anchor_x\n        self._text.anchor_y = anchor_y",
  "def set_color(self, color):\n        \"\"\"Set the text color\n\n        Parameters\n        ----------\n        color : matplotlib Color | None\n            The color. Use None for no color.\n        \"\"\"\n        if self._attr:\n            self._text.document.set_style(0, len(self._text.document.text),\n                                          {'color': _convert_color(color)})\n        else:\n            self._text.color = _convert_color(color)",
  "def draw(self):\n        \"\"\"Draw the object to the display buffer\"\"\"\n        self._text.draw()",
  "def __init__(self, ec, fill_color, line_color, line_width, line_loop):\n        self._ec = ec\n        self.set_fill_color(fill_color)\n        self.set_line_color(line_color)\n        self._line_width = line_width\n        self._line_loop = line_loop",
  "def set_fill_color(self, fill_color):\n        \"\"\"Set the object color\n\n        Parameters\n        ----------\n        fill_color : matplotlib Color | None\n            The fill color. Use None for no fill.\n        \"\"\"\n        self._fill_color = _convert_color(fill_color)",
  "def set_line_color(self, line_color):\n        \"\"\"Set the object color\n\n        Parameters\n        ----------\n        fill_color : matplotlib Color | None\n            The fill color. Use None for no fill.\n        \"\"\"\n        self._line_color = _convert_color(line_color)",
  "def set_line_width(self, line_width):\n        \"\"\"Set the line width in pixels\n\n        Parameters\n        ----------\n        line_width : float\n            The line width. Must be given in pixels. Due to OpenGL\n            limitations, it must be `0.0 <= line_width <= 10.0`.\n        \"\"\"\n        line_width = float(line_width)\n        if not (0.0 <= line_width <= 10.0):\n            raise ValueError('line_width must be between 0 and 10')\n        self._line_width = line_width",
  "def draw(self):\n        \"\"\"Draw the object to the display buffer\"\"\"\n        import pyglet\n        from pyglet import gl\n        if self._points is not None and self._fill_color is not None:\n            color = _replicate_color(self._fill_color, self._points)\n            pyglet.graphics.draw_indexed(len(self._points) // 2,\n                                         gl.GL_TRIANGLES,\n                                         self._tris,\n                                         ('v2f', self._points),\n                                         ('c4B', color))\n        if (self._line_points is not None and self._line_width > 0.0 and\n                self._line_color is not None):\n            color = _replicate_color(self._line_color, self._line_points)\n            gl.glLineWidth(self._line_width)\n            if self._line_loop:\n                gl_cmd = gl.GL_LINE_LOOP\n            else:\n                gl_cmd = gl.GL_LINE_STRIP\n            pyglet.graphics.draw(len(self._line_points) // 2,\n                                 gl_cmd,\n                                 ('v2f', self._line_points),\n                                 ('c4B', color))",
  "def __init__(self, ec, coords, units='norm', line_color='white',\n                 line_width=1.0, line_loop=False):\n        _Triangular.__init__(self, ec, fill_color=None, line_color=line_color,\n                             line_width=line_width, line_loop=line_loop)\n        self._points = None\n        self._tris = None\n        self.set_coords(coords, units)\n        self.set_line_color(line_color)",
  "def set_coords(self, coords, units='norm'):\n        \"\"\"Set line coordinates\n\n        Parameters\n        ----------\n        coords : array-like\n            2 x N set of X, Y coordinates.\n        \"\"\"\n        check_units(units)\n        coords = np.array(coords, dtype=float)\n        if coords.ndim == 1:\n            coords = coords[:, np.newaxis]\n        if coords.ndim != 2 or coords.shape[0] != 2:\n            raise ValueError('coords must be a vector of length 2, or an '\n                             'array with 2 dimensions (with first dimension '\n                             'having length 2')\n        coords = self._ec._convert_units(coords, units, 'pix')\n        self._line_points = coords.T.flatten()",
  "def __init__(self, ec, coords, units='norm', fill_color='white',\n                 line_color=None, line_width=1.0):\n        _Triangular.__init__(self, ec, fill_color=fill_color,\n                             line_color=line_color, line_width=line_width,\n                             line_loop=True)\n        self.set_coords(coords, units)\n        self.set_fill_color(fill_color)",
  "def set_coords(self, coords, units='norm'):\n        \"\"\"Set triangle coordinates\n\n        Parameters\n        ----------\n        coords : array-like\n            2 x 3 set of X, Y coordinates.\n        \"\"\"\n        check_units(units)\n        coords = np.array(coords, dtype=float)\n        if coords.shape != (2, 3):\n            raise ValueError('coords must be an array of size 2 x 3')\n        coords = self._ec._convert_units(coords, units, 'pix')\n        self._points = coords.T.flatten()\n        self._tris = np.array([0, 1, 2])\n        self._line_points = self._points",
  "def __init__(self, ec, pos, units='norm', fill_color='white',\n                 line_color=None, line_width=1.0):\n        _Triangular.__init__(self, ec, fill_color=fill_color,\n                             line_color=line_color, line_width=line_width,\n                             line_loop=True)\n        self.set_pos(pos, units)",
  "def set_pos(self, pos, units='norm'):\n        \"\"\"Set the position of the rectangle\n\n        Parameters\n        ----------\n        pos : array-like\n            X, Y, width, height of the rectangle.\n        units : str\n            Units to use. See ``check_units`` for options.\n        \"\"\"\n        check_units(units)\n        # do this in normalized units, then convert\n        pos = np.array(pos)\n        if not (pos.ndim == 1 and pos.size == 4):\n            raise ValueError('pos must be a 4-element array-like vector')\n        self._pos = pos\n        w = self._pos[2]\n        h = self._pos[3]\n        points = np.array([[-w / 2., -h / 2.],\n                           [-w / 2., h / 2.],\n                           [w / 2., h / 2.],\n                           [w / 2., -h / 2.]]).T\n        points += np.array(self._pos[:2])[:, np.newaxis]\n        points = self._ec._convert_units(points, units, 'pix')\n        self._points = points.T.flatten()\n        self._tris = np.array([0, 1, 2, 0, 2, 3])\n        self._line_points = self._points",
  "def __init__(self, ec, pos, units='norm', fill_color='white',\n                 line_color=None, line_width=1.0):\n        _Triangular.__init__(self, ec, fill_color=fill_color,\n                             line_color=line_color, line_width=line_width,\n                             line_loop=True)\n        self.set_pos(pos, units)",
  "def set_pos(self, pos, units='norm'):\n        \"\"\"Set the position of the rectangle\n\n        Parameters\n        ----------\n        pos : array-like\n            X, Y, width, height of the rectangle.\n        units : str\n            Units to use. See ``check_units`` for options.\n        \"\"\"\n        check_units(units)\n        # do this in normalized units, then convert\n        pos = np.array(pos)\n        if not (pos.ndim == 1 and pos.size == 4):\n            raise ValueError('pos must be a 4-element array-like vector')\n        self._pos = pos\n        w = self._pos[2]\n        h = self._pos[3]\n        points = np.array([[w / 2., 0.],\n                           [0., h / 2.],\n                           [-w / 2., 0.],\n                           [0., -h / 2.]]).T\n        points += np.array(self._pos[:2])[:, np.newaxis]\n        points = self._ec._convert_units(points, units, 'pix')\n        self._points = points.T.flatten()\n        self._tris = np.array([0, 1, 2, 0, 2, 3])\n        self._line_points = self._points",
  "def __init__(self, ec, radius=1, pos=(0, 0), units='norm',\n                 n_edges=200, fill_color='white', line_color=None,\n                 line_width=1.0):\n        _Triangular.__init__(self, ec, fill_color=fill_color,\n                             line_color=line_color, line_width=line_width,\n                             line_loop=True)\n        if not isinstance(n_edges, int):\n            raise TypeError('n_edges must be an int')\n        if n_edges < 4:\n            raise ValueError('n_edges must be >= 4 for a reasonable circle')\n        self._n_edges = n_edges\n\n        # need to set a dummy value here so recalculation doesn't fail\n        self._radius = np.array([1., 1.])\n        self.set_pos(pos, units)\n        self.set_radius(radius, units)\n\n        # construct triangulation (never changes so long as n_edges is fixed)\n        tris = [[0, ii + 1, ii + 2] for ii in range(n_edges)]\n        tris = np.concatenate(tris)\n        tris[-1] = 1  # fix wrap for last triangle\n        self._tris = tris",
  "def set_radius(self, radius, units='norm'):\n        \"\"\"Set the position and radius of the circle\n\n        Parameters\n        ----------\n        radius : array-like | float\n            X- and Y-direction extents (radii) of the circle / ellipse.\n            A single value (float) will be replicated for both directions.\n        units : str\n            Units to use. See ``check_units`` for options.\n        \"\"\"\n        check_units(units)\n        radius = np.atleast_1d(radius).astype(float)\n        if radius.ndim != 1 or radius.size > 2:\n            raise ValueError('radius must be a 1- or 2-element '\n                             'array-like vector')\n        if radius.size == 1:\n            radius = np.r_[radius, radius]\n        # convert to pixel (OpenGL) units\n        self._radius = self._ec._convert_units(radius[:, np.newaxis],\n                                               units, 'pix')[:, 0]\n        # need to subtract center position\n        ctr = self._ec._convert_units(np.zeros((2, 1)), units, 'pix')[:, 0]\n        self._radius -= ctr\n        self._recalculate()",
  "def set_pos(self, pos, units='norm'):\n        \"\"\"Set the position and radius of the circle\n\n        Parameters\n        ----------\n        pos : array-like\n            X, Y center of the circle.\n        units : str\n            Units to use. See ``check_units`` for options.\n        \"\"\"\n        check_units(units)\n        pos = np.array(pos, dtype=float)\n        if not (pos.ndim == 1 and pos.size == 2):\n            raise ValueError('pos must be a 2-element array-like vector')\n        # convert to pixel (OpenGL) units\n        self._pos = self._ec._convert_units(pos[:, np.newaxis],\n                                            units, 'pix')[:, 0]\n        self._recalculate()",
  "def _recalculate(self):\n        \"\"\"Helper to recalculate point coordinates\"\"\"\n        edges = self._n_edges\n        arg = 2 * np.pi * (np.arange(edges) / float(edges))\n        points = np.array([self._radius[0] * np.cos(arg),\n                           self._radius[1] * np.sin(arg)])\n        points = np.c_[np.zeros((2, 1)), points]  # prepend the center\n        points += np.array(self._pos[:2], dtype=float)[:, np.newaxis]\n        self._points = points.T.ravel()\n        self._line_points = self._points[2:]",
  "def __init__(self, ec, radii=(0.2, 0.05), pos=(0, 0), units='norm',\n                 colors=('w', 'k')):\n        radii = np.array(radii, float)\n        if radii.ndim != 1:\n            raise ValueError('radii must be 1D')\n        if not isinstance(colors, (tuple, list)):\n            raise TypeError('colors must be a tuple, list, or array')\n        if len(colors) != len(radii):\n            raise ValueError('colors and radii must be the same length')\n        # need to set a dummy value here so recalculation doesn't fail\n        self._circles = [Circle(ec, r, pos, units, fill_color=c, line_width=0)\n                         for r, c in zip(radii, colors)]",
  "def __len__(self):\n        return len(self._circles)",
  "def set_pos(self, pos, units='norm'):\n        \"\"\"Set the position of the circles\n\n        Parameters\n        ----------\n        pos : array-like\n            X, Y center of the circle.\n        units : str\n            Units to use. See ``check_units`` for options.\n        \"\"\"\n        for circle in self._circles:\n            circle.set_pos(pos, units)",
  "def set_radius(self, radius, idx, units='norm'):\n        \"\"\"Set the radius of one of the circles\n\n        Parameters\n        ----------\n        radius : float\n            Radius the circle.\n        idx : int\n            Index of the circle.\n        units : str\n            Units to use. See ``check_units`` for options.\n        \"\"\"\n        self._circles[idx].set_radius(radius, units)",
  "def set_radii(self, radii, units='norm'):\n        \"\"\"Set the color of each circle\n\n        Parameters\n        ----------\n        radii : array-like\n            List of radii to assign to the circles. Must contain the same\n            number of radii as the number of circles.\n        units : str\n            Units to use. See ``check_units`` for options.\n        \"\"\"\n        radii = np.array(radii, float)\n        if radii.ndim != 1 or radii.size != len(self):\n            raise ValueError('radii must contain exactly {0} radii'\n                             ''.format(len(self)))\n        for idx, radius in enumerate(radii):\n            self.set_radius(radius, idx, units)",
  "def set_color(self, color, idx):\n        \"\"\"Set the color of one of the circles\n\n        Parameters\n        ----------\n        color : matplotlib Color\n            Color of the circle.\n        idx : int\n            Index of the circle.\n        units : str\n            Units to use. See ``check_units`` for options.\n        \"\"\"\n        self._circles[idx].set_fill_color(color)",
  "def set_colors(self, colors):\n        \"\"\"Set the color of each circle\n\n        Parameters\n        ----------\n        colors : list or tuple of matplotlib Colors\n            Must be of type list or tuple, and contain the same number of\n            colors as the number of circles.\n        \"\"\"\n        if not isinstance(colors, (tuple, list)) or len(colors) != len(self):\n            raise ValueError('colors must be a list or tuple with {0} colors'\n                             ''.format(len(self)))\n        for idx, color in enumerate(colors):\n            self.set_color(color, idx)",
  "def draw(self):\n        \"\"\"Draw the fixation dot\n        \"\"\"\n        for circle in self._circles:\n            circle.draw()",
  "def __init__(self, ec, colors=('w', 'k')):\n        if len(colors) != 2:\n            raise ValueError('colors must have length 2')\n        super(FixationDot, self).__init__(ec, radii=[0.2, 0.2],\n                                          pos=[0, 0], units='deg',\n                                          colors=colors)\n        self.set_radius(1, 1, units='pix')",
  "def __init__(self, ec, image_buffer, pos=(0, 0), scale=1., units='norm'):\n        self._ec = ec\n        self._img = None\n        self.set_image(image_buffer)\n        self.set_pos(pos, units)\n        self.set_scale(scale)",
  "def set_image(self, image_buffer):\n        \"\"\"Set image buffer data\n\n        Parameters\n        ----------\n        image_buffer : array\n            N x M x 3 (or 4) array. Can be type ``np.float64`` or ``np.uint8``.\n            If ``np.float64``, color values must range between 0 and 1.\n            ``np.uint8`` is slightly more efficient.\n        \"\"\"\n        from pyglet import image, sprite\n        image_buffer = np.ascontiguousarray(image_buffer)\n        if image_buffer.dtype not in (np.float64, np.uint8):\n            raise TypeError('image_buffer must be np.float64 or np.uint8')\n        if image_buffer.dtype == np.float64:\n            if image_buffer.max() > 1 or image_buffer.min() < 0:\n                raise ValueError('all float values must be between 0 and 1')\n            image_buffer = (image_buffer * 255).astype('uint8')\n        if not image_buffer.ndim == 3 or image_buffer.shape[2] not in [3, 4]:\n            raise RuntimeError('image_buffer incorrect size: {}'\n                               ''.format(image_buffer.shape))\n        # add alpha channel if necessary\n        dims = image_buffer.shape\n        fmt = 'RGB' if dims[2] == 3 else 'RGBA'\n        self._sprite = sprite.Sprite(image.ImageData(dims[1], dims[0], fmt,\n                                                     image_buffer.tostring(),\n                                                     -dims[1] * dims[2]))",
  "def set_pos(self, pos, units='norm'):\n        \"\"\"Set image position\n\n        Parameters\n        ----------\n        ec : instance of ExperimentController\n            Parent EC.\n        pos : array-like\n            2-element array-like with X, Y (center) arguments.\n        units : str\n            Units to use. See ``check_units`` for options.\n        \"\"\"\n        pos = np.array(pos, float)\n        if pos.ndim != 1 or pos.size != 2:\n            raise ValueError('pos must be a 2-element array')\n        pos = np.reshape(pos, (2, 1))\n        self._pos = self._ec._convert_units(pos, units, 'pix').ravel()",
  "def bounds(self):\n        \"\"\"L, B, W, H (in pixels) of the image\"\"\"\n        pos = np.array(self._pos, float)\n        size = np.array([self._sprite.width,\n                         self._sprite.height], float)\n        bounds = np.concatenate((pos - size / 2., pos + size / 2.))\n        return bounds[[0, 2, 1, 3]]",
  "def scale(self):\n        return self._scale",
  "def set_scale(self, scale):\n        \"\"\"Create image from array for on-screen display\n\n        Parameters\n        ----------\n        ec : instance of ExperimentController\n            Parent EC.\n        pos : array-like\n            2-element array-like with X, Y (center) arguments.\n        units : str\n            Units to use. See ``check_units`` for options.\n        \"\"\"\n        scale = float(scale)\n        self._scale = scale\n        self._sprite.scale = self._scale",
  "def draw(self):\n        \"\"\"Draw the image to the buffer\"\"\"\n        self._sprite.scale = self._scale\n        pos = self._pos - [self._sprite.width / 2., self._sprite.height / 2.]\n        self._sprite.set_position(pos[0], pos[1])\n        self._sprite.draw()",
  "class FunctionMaker(object):\n    \"\"\"\n    An object with the ability to create functions with a given signature.\n    It has attributes name, doc, module, signature, defaults, dict and\n    methods update and make.\n    \"\"\"\n    def __init__(self, func=None, name=None, signature=None,\n                 defaults=None, doc=None, module=None, funcdict=None):\n        self.shortsignature = signature\n        if func:\n            # func can be a class or a callable, but not an instance method\n            self.name = func.__name__\n            if self.name == '<lambda>': # small hack for lambda functions\n                self.name = '_lambda_'\n            self.doc = func.__doc__\n            self.module = func.__module__\n            if inspect.isfunction(func):\n                argspec = getfullargspec(func)\n                self.annotations = getattr(func, '__annotations__', {})\n                for a in ('args', 'varargs', 'varkw', 'defaults', 'kwonlyargs',\n                          'kwonlydefaults'):\n                    setattr(self, a, getattr(argspec, a))\n                for i, arg in enumerate(self.args):\n                    setattr(self, 'arg%d' % i, arg)\n                if sys.version < '3': # easy way\n                    self.shortsignature = self.signature = \\\n                        inspect.formatargspec(\n                        formatvalue=lambda val: \"\", *argspec)[1:-1]\n                else: # Python 3 way\n                    allargs = list(self.args)\n                    allshortargs = list(self.args)\n                    if self.varargs:\n                        allargs.append('*' + self.varargs)\n                        allshortargs.append('*' + self.varargs)\n                    elif self.kwonlyargs:\n                        allargs.append('*') # single star syntax\n                    for a in self.kwonlyargs:\n                        allargs.append('%s=None' % a)\n                        allshortargs.append('%s=%s' % (a, a))\n                    if self.varkw:\n                        allargs.append('**' + self.varkw)\n                        allshortargs.append('**' + self.varkw)\n                    self.signature = ', '.join(allargs)\n                    self.shortsignature = ', '.join(allshortargs)\n                self.dict = func.__dict__.copy()\n        # func=None happens when decorating a caller\n        if name:\n            self.name = name\n        if signature is not None:\n            self.signature = signature\n        if defaults:\n            self.defaults = defaults\n        if doc:\n            self.doc = doc\n        if module:\n            self.module = module\n        if funcdict:\n            self.dict = funcdict\n        # check existence required attributes\n        assert hasattr(self, 'name')\n        if not hasattr(self, 'signature'):\n            raise TypeError('You are decorating a non function: %s' % func)\n\n    def update(self, func, **kw):\n        \"Update the signature of func with the data in self\"\n        func.__name__ = self.name\n        func.__doc__ = getattr(self, 'doc', None)\n        func.__dict__ = getattr(self, 'dict', {})\n        func.__defaults__ = getattr(self, 'defaults', ())\n        func.__kwdefaults__ = getattr(self, 'kwonlydefaults', None)\n        func.__annotations__ = getattr(self, 'annotations', None)\n        callermodule = sys._getframe(3).f_globals.get('__name__', '?')\n        func.__module__ = getattr(self, 'module', callermodule)\n        func.__dict__.update(kw)\n\n    def make(self, src_templ, evaldict=None, addsource=False, **attrs):\n        \"Make a new function from a given template and update the signature\"\n        src = src_templ % vars(self) # expand name and signature\n        evaldict = evaldict or {}\n        mo = DEF.match(src)\n        if mo is None:\n            raise SyntaxError('not a valid function template\\n%s' % src)\n        name = mo.group(1) # extract the function name\n        names = set([name] + [arg.strip(' *') for arg in\n                             self.shortsignature.split(',')])\n        for n in names:\n            if n in ('_func_', '_call_'):\n                raise NameError('%s is overridden in\\n%s' % (n, src))\n        if not src.endswith('\\n'): # add a newline just for safety\n            src += '\\n' # this is needed in old versions of Python\n        try:\n            code = compile(src, '<string>', 'single')\n            # print >> sys.stderr, 'Compiling %s' % src\n            exec(code, evaldict)\n        except:\n            print('Error in generated code:', file=sys.stderr)\n            print(src, file=sys.stderr)\n            raise\n        func = evaldict[name]\n        if addsource:\n            attrs['__source__'] = src\n        self.update(func, **attrs)\n        return func\n\n    @classmethod\n    def create(cls, obj, body, evaldict, defaults=None,\n               doc=None, module=None, addsource=True, **attrs):\n        \"\"\"\n        Create a function from the strings name, signature and body.\n        evaldict is the evaluation dictionary. If addsource is true an attribute\n        __source__ is added to the result. The attributes attrs are added,\n        if any.\n        \"\"\"\n        if isinstance(obj, str): # \"name(signature)\"\n            name, rest = obj.strip().split('(', 1)\n            signature = rest[:-1] #strip a right parens\n            func = None\n        else: # a function\n            name = None\n            signature = None\n            func = obj\n        self = cls(func, name, signature, defaults, doc, module)\n        ibody = '\\n'.join('    ' + line for line in body.splitlines())\n        return self.make('def %(name)s(%(signature)s):\\n' + ibody,\n                        evaldict, addsource, **attrs)",
  "def decorator(caller, func=None):\n    \"\"\"\n    decorator(caller) converts a caller function into a decorator;\n    decorator(caller, func) decorates a function using a caller.\n    \"\"\"\n    if func is not None: # returns a decorated function\n        evaldict = func.__globals__.copy()\n        evaldict['_call_'] = caller\n        evaldict['_func_'] = func\n        return FunctionMaker.create(\n            func, \"return _call_(_func_, %(shortsignature)s)\",\n            evaldict, undecorated=func, __wrapped__=func)\n    else: # returns a decorator\n        if inspect.isclass(caller):\n            name = caller.__name__.lower()\n            callerfunc = get_init(caller)\n            doc = 'decorator(%s) converts functions/generators into ' \\\n                'factories of %s objects' % (caller.__name__, caller.__name__)\n            fun = getfullargspec(callerfunc).args[1] # second arg\n        elif inspect.isfunction(caller):\n            name = '_lambda_' if caller.__name__ == '<lambda>' \\\n                else caller.__name__\n            callerfunc = caller\n            doc = caller.__doc__\n            fun = getfullargspec(callerfunc).args[0] # first arg\n        else: # assume caller is an object with a __call__ method\n            name = caller.__class__.__name__.lower()\n            callerfunc = caller.__call__.__func__\n            doc = caller.__call__.__doc__\n            fun = getfullargspec(callerfunc).args[1] # second arg\n        evaldict = callerfunc.__globals__.copy()\n        evaldict['_call_'] = caller\n        evaldict['decorator'] = decorator\n        return FunctionMaker.create(\n            '%s(%s)' % (name, fun),\n            'return decorator(_call_, %s)' % fun,\n            evaldict, undecorated=caller, __wrapped__=caller,\n            doc=doc, module=caller.__module__)",
  "def __call__(self, func):\n    'Context manager decorator'\n    return FunctionMaker.create(\n        func, \"with _self_: return _func_(%(shortsignature)s)\",\n        dict(_self_=self, _func_=func), __wrapped__=func)",
  "def get_init(cls):\n        return cls.__init__",
  "class getfullargspec(object):\n        \"A quick and dirty replacement for getfullargspec for Python 2.X\"\n        def __init__(self, f):\n            self.args, self.varargs, self.varkw, self.defaults = \\\n                inspect.getargspec(f)\n            self.kwonlyargs = []\n            self.kwonlydefaults = None\n        def __iter__(self):\n            yield self.args\n            yield self.varargs\n            yield self.varkw\n            yield self.defaults",
  "def get_init(cls):\n        return cls.__init__.__func__",
  "def __init__(self, func=None, name=None, signature=None,\n                 defaults=None, doc=None, module=None, funcdict=None):\n        self.shortsignature = signature\n        if func:\n            # func can be a class or a callable, but not an instance method\n            self.name = func.__name__\n            if self.name == '<lambda>': # small hack for lambda functions\n                self.name = '_lambda_'\n            self.doc = func.__doc__\n            self.module = func.__module__\n            if inspect.isfunction(func):\n                argspec = getfullargspec(func)\n                self.annotations = getattr(func, '__annotations__', {})\n                for a in ('args', 'varargs', 'varkw', 'defaults', 'kwonlyargs',\n                          'kwonlydefaults'):\n                    setattr(self, a, getattr(argspec, a))\n                for i, arg in enumerate(self.args):\n                    setattr(self, 'arg%d' % i, arg)\n                if sys.version < '3': # easy way\n                    self.shortsignature = self.signature = \\\n                        inspect.formatargspec(\n                        formatvalue=lambda val: \"\", *argspec)[1:-1]\n                else: # Python 3 way\n                    allargs = list(self.args)\n                    allshortargs = list(self.args)\n                    if self.varargs:\n                        allargs.append('*' + self.varargs)\n                        allshortargs.append('*' + self.varargs)\n                    elif self.kwonlyargs:\n                        allargs.append('*') # single star syntax\n                    for a in self.kwonlyargs:\n                        allargs.append('%s=None' % a)\n                        allshortargs.append('%s=%s' % (a, a))\n                    if self.varkw:\n                        allargs.append('**' + self.varkw)\n                        allshortargs.append('**' + self.varkw)\n                    self.signature = ', '.join(allargs)\n                    self.shortsignature = ', '.join(allshortargs)\n                self.dict = func.__dict__.copy()\n        # func=None happens when decorating a caller\n        if name:\n            self.name = name\n        if signature is not None:\n            self.signature = signature\n        if defaults:\n            self.defaults = defaults\n        if doc:\n            self.doc = doc\n        if module:\n            self.module = module\n        if funcdict:\n            self.dict = funcdict\n        # check existence required attributes\n        assert hasattr(self, 'name')\n        if not hasattr(self, 'signature'):\n            raise TypeError('You are decorating a non function: %s' % func)",
  "def update(self, func, **kw):\n        \"Update the signature of func with the data in self\"\n        func.__name__ = self.name\n        func.__doc__ = getattr(self, 'doc', None)\n        func.__dict__ = getattr(self, 'dict', {})\n        func.__defaults__ = getattr(self, 'defaults', ())\n        func.__kwdefaults__ = getattr(self, 'kwonlydefaults', None)\n        func.__annotations__ = getattr(self, 'annotations', None)\n        callermodule = sys._getframe(3).f_globals.get('__name__', '?')\n        func.__module__ = getattr(self, 'module', callermodule)\n        func.__dict__.update(kw)",
  "def make(self, src_templ, evaldict=None, addsource=False, **attrs):\n        \"Make a new function from a given template and update the signature\"\n        src = src_templ % vars(self) # expand name and signature\n        evaldict = evaldict or {}\n        mo = DEF.match(src)\n        if mo is None:\n            raise SyntaxError('not a valid function template\\n%s' % src)\n        name = mo.group(1) # extract the function name\n        names = set([name] + [arg.strip(' *') for arg in\n                             self.shortsignature.split(',')])\n        for n in names:\n            if n in ('_func_', '_call_'):\n                raise NameError('%s is overridden in\\n%s' % (n, src))\n        if not src.endswith('\\n'): # add a newline just for safety\n            src += '\\n' # this is needed in old versions of Python\n        try:\n            code = compile(src, '<string>', 'single')\n            # print >> sys.stderr, 'Compiling %s' % src\n            exec(code, evaldict)\n        except:\n            print('Error in generated code:', file=sys.stderr)\n            print(src, file=sys.stderr)\n            raise\n        func = evaldict[name]\n        if addsource:\n            attrs['__source__'] = src\n        self.update(func, **attrs)\n        return func",
  "def create(cls, obj, body, evaldict, defaults=None,\n               doc=None, module=None, addsource=True, **attrs):\n        \"\"\"\n        Create a function from the strings name, signature and body.\n        evaldict is the evaluation dictionary. If addsource is true an attribute\n        __source__ is added to the result. The attributes attrs are added,\n        if any.\n        \"\"\"\n        if isinstance(obj, str): # \"name(signature)\"\n            name, rest = obj.strip().split('(', 1)\n            signature = rest[:-1] #strip a right parens\n            func = None\n        else: # a function\n            name = None\n            signature = None\n            func = obj\n        self = cls(func, name, signature, defaults, doc, module)\n        ibody = '\\n'.join('    ' + line for line in body.splitlines())\n        return self.make('def %(name)s(%(signature)s):\\n' + ibody,\n                        evaldict, addsource, **attrs)",
  "def __init__(self, f):\n            self.args, self.varargs, self.varkw, self.defaults = \\\n                inspect.getargspec(f)\n            self.kwonlyargs = []\n            self.kwonlydefaults = None",
  "def __iter__(self):\n            yield self.args\n            yield self.varargs\n            yield self.varkw\n            yield self.defaults",
  "def __init__(self, f, *a, **k):\n        return GeneratorContextManager.__init__(self, f(*a, **k))",
  "def _check_h5py():\n    \"\"\"Helper to check if h5py is installed\"\"\"\n    try:\n        import h5py\n    except ImportError:\n        raise ImportError('the h5py module is required to use HDF5 I/O')\n    return h5py",
  "def _create_titled_group(root, key, title):\n    \"\"\"Helper to create a titled group in h5py\"\"\"\n    out = root.create_group(key)\n    out.attrs['TITLE'] = title\n    return out",
  "def _create_titled_dataset(root, key, title, data, comp_kw=None):\n    \"\"\"Helper to create a titled dataset in h5py\"\"\"\n    comp_kw = {} if comp_kw is None else comp_kw\n    out = root.create_dataset(key, data=data, **comp_kw)\n    out.attrs['TITLE'] = title\n    return out",
  "def write_hdf5(fname, data, overwrite=False, compression=4,\n               title='h5io'):\n    \"\"\"Write python object to HDF5 format using h5py\n\n    Parameters\n    ----------\n    fname : str\n        Filename to use.\n    data : object\n        Object to write. Can be of any of these types:\n            {ndarray, dict, list, tuple, int, float, str}\n        Note that dict objects must only have ``str`` keys.\n    overwrite : bool\n        If True, overwrite file (if it exists).\n    compression : int\n        Compression level to use (0-9) to compress data using gzip.\n    title : str\n        The top-level directory name to use. Typically it is useful to make\n        this your package name, e.g. ``'mnepython'``.\n    \"\"\"\n    h5py = _check_h5py()\n    if op.isfile(fname) and not overwrite:\n        raise IOError('file \"%s\" exists, use overwrite=True to overwrite'\n                      % fname)\n    if not isinstance(title, string_types):\n        raise ValueError('title must be a string')\n    comp_kw = dict()\n    if compression > 0:\n        comp_kw = dict(compression='gzip', compression_opts=compression)\n    with h5py.File(fname, mode='w') as fid:\n        _triage_write(title, data, fid, comp_kw, str(type(data)))",
  "def _triage_write(key, value, root, comp_kw, where):\n    if isinstance(value, dict):\n        sub_root = _create_titled_group(root, key, 'dict')\n        for key, sub_value in value.items():\n            if not isinstance(key, string_types):\n                raise TypeError('All dict keys must be strings')\n            _triage_write('key_{0}'.format(key), sub_value, sub_root, comp_kw,\n                          where + '[\"%s\"]' % key)\n    elif isinstance(value, (list, tuple)):\n        title = 'list' if isinstance(value, list) else 'tuple'\n        sub_root = _create_titled_group(root, key, title)\n        for vi, sub_value in enumerate(value):\n            _triage_write('idx_{0}'.format(vi), sub_value, sub_root, comp_kw,\n                          where + '[%s]' % vi)\n    elif isinstance(value, type(None)):\n        _create_titled_dataset(root, key, 'None', [False])\n    elif isinstance(value, (int, float)):\n        if isinstance(value, int):\n            title = 'int'\n        else:  # isinstance(value, float):\n            title = 'float'\n        _create_titled_dataset(root, key, title, np.atleast_1d(value))\n    elif isinstance(value, string_types):\n        if isinstance(value, text_type):  # unicode\n            value = np.fromstring(value.encode('utf-8'), np.uint8)\n            title = 'unicode'\n        else:\n            value = np.fromstring(value.encode('ASCII'), np.uint8)\n            title = 'ascii'\n        _create_titled_dataset(root, key, title, value, comp_kw)\n    elif isinstance(value, np.ndarray):\n        _create_titled_dataset(root, key, 'ndarray', value)\n    elif sparse is not None and isinstance(value, sparse.csc_matrix):\n        sub_root = _create_titled_group(root, key, 'csc_matrix')\n        _triage_write('data', value.data, sub_root, comp_kw,\n                      where + '.csc_matrix_data')\n        _triage_write('indices', value.indices, sub_root, comp_kw,\n                      where + '.csc_matrix_indices')\n        _triage_write('indptr', value.indptr, sub_root, comp_kw,\n                      where + '.csc_matrix_indptr')\n    else:\n        raise TypeError('unsupported type %s (in %s)' % (type(value), where))",
  "def read_hdf5(fname, title='h5io'):\n    \"\"\"Read python object from HDF5 format using h5py\n\n    Parameters\n    ----------\n    fname : str\n        File to load.\n    title : str\n        The top-level directory name to use. Typically it is useful to make\n        this your package name, e.g. ``'mnepython'``.\n\n    Returns\n    -------\n    data : object\n        The loaded data. Can be of any type supported by ``write_hdf5``.\n    \"\"\"\n    h5py = _check_h5py()\n    if not op.isfile(fname):\n        raise IOError('file \"%s\" not found' % fname)\n    if not isinstance(title, string_types):\n        raise ValueError('title must be a string')\n    with h5py.File(fname, mode='r') as fid:\n        if title not in fid.keys():\n            raise ValueError('no \"%s\" data found' % title)\n        data = _triage_read(fid[title])\n    return data",
  "def _triage_read(node):\n    h5py = _check_h5py()\n    type_str = node.attrs['TITLE']\n    if isinstance(type_str, bytes):\n        type_str = type_str.decode()\n    if isinstance(node, h5py.Group):\n        if type_str == 'dict':\n            data = dict()\n            for key, subnode in node.items():\n                data[key[4:]] = _triage_read(subnode)\n        elif type_str in ['list', 'tuple']:\n            data = list()\n            ii = 0\n            while True:\n                subnode = node.get('idx_{0}'.format(ii), None)\n                if subnode is None:\n                    break\n                data.append(_triage_read(subnode))\n                ii += 1\n            assert len(data) == ii\n            data = tuple(data) if type_str == 'tuple' else data\n            return data\n        elif type_str == 'csc_matrix':\n            if sparse is None:\n                raise RuntimeError('scipy must be installed to read this data')\n            data = sparse.csc_matrix((_triage_read(node['data']),\n                                      _triage_read(node['indices']),\n                                      _triage_read(node['indptr'])))\n        else:\n            raise NotImplementedError('Unknown group type: {0}'\n                                      ''.format(type_str))\n    elif type_str == 'ndarray':\n        data = np.array(node)\n    elif type_str in ('int', 'float'):\n        cast = int if type_str == 'int' else float\n        data = cast(np.array(node)[0])\n    elif type_str in ('unicode', 'ascii', 'str'):  # 'str' for backward compat\n        decoder = 'utf-8' if type_str == 'unicode' else 'ASCII'\n        cast = text_type if type_str == 'unicode' else str\n        data = cast(np.array(node).tostring().decode(decoder))\n    elif type_str == 'None':\n        data = None\n    else:\n        raise TypeError('Unknown node type: {0}'.format(type_str))\n    return data",
  "def _sort_keys(x):\n    \"\"\"Sort and return keys of dict\"\"\"\n    keys = list(x.keys())  # note: not thread-safe\n    idx = np.argsort([str(k) for k in keys])\n    keys = [keys[ii] for ii in idx]\n    return keys",
  "def object_diff(a, b, pre=''):\n    \"\"\"Compute all differences between two python variables\n\n    Parameters\n    ----------\n    a : object\n        Currently supported: dict, list, tuple, ndarray, int, str, bytes,\n        float.\n    b : object\n        Must be same type as x1.\n    pre : str\n        String to prepend to each line.\n\n    Returns\n    -------\n    diffs : str\n        A string representation of the differences.\n    \"\"\"\n    out = ''\n    if type(a) != type(b):\n        out += pre + ' type mismatch (%s, %s)\\n' % (type(a), type(b))\n    elif isinstance(a, dict):\n        k1s = _sort_keys(a)\n        k2s = _sort_keys(b)\n        m1 = set(k2s) - set(k1s)\n        if len(m1):\n            out += pre + ' x1 missing keys %s\\n' % (m1)\n        for key in k1s:\n            if key not in k2s:\n                out += pre + ' x2 missing key %s\\n' % key\n            else:\n                out += object_diff(a[key], b[key], pre + 'd1[%s]' % repr(key))\n    elif isinstance(a, (list, tuple)):\n        if len(a) != len(b):\n            out += pre + ' length mismatch (%s, %s)\\n' % (len(a), len(b))\n        else:\n            for xx1, xx2 in zip(a, b):\n                out += object_diff(xx1, xx2, pre='')\n    elif isinstance(a, (string_types, int, float, bytes)):\n        if a != b:\n            out += pre + ' value mismatch (%s, %s)\\n' % (a, b)\n    elif a is None:\n        pass  # b must be None due to our type checking\n    elif isinstance(a, np.ndarray):\n        if not np.array_equal(a, b):\n            out += pre + ' array mismatch\\n'\n    elif sparse is not None and sparse.isspmatrix(a):\n        # sparsity and sparse type of b vs a already checked above by type()\n        if b.shape != a.shape:\n            out += pre + (' sparse matrix a and b shape mismatch'\n                          '(%s vs %s)' % (a.shape, b.shape))\n        else:\n            c = a - b\n            c.eliminate_zeros()\n            if c.nnz > 0:\n                out += pre + (' sparse matrix a and b differ on %s '\n                              'elements' % c.nnz)\n    else:\n        raise RuntimeError(pre + ': unsupported type %s (%s)' % (type(a), a))\n    return out",
  "class _TempDir(str):\n    \"\"\"Class for creating and auto-destroying temp dir\n\n    This is designed to be used with testing modules. Instances should be\n    defined inside test functions. Instances defined at module level can not\n    guarantee proper destruction of the temporary directory.\n\n    When used at module level, the current use of the __del__() method for\n    cleanup can fail because the rmtree function may be cleaned up before this\n    object (an alternative could be using the atexit module instead).\n    \"\"\"\n    def __new__(self):\n        new = str.__new__(self, tempfile.mkdtemp())\n        return new\n\n    def __init__(self):\n        self._path = self.__str__()\n\n    def __del__(self):\n        rmtree(self._path, ignore_errors=True)",
  "def __new__(self):\n        new = str.__new__(self, tempfile.mkdtemp())\n        return new",
  "def __init__(self):\n        self._path = self.__str__()",
  "def __del__(self):\n        rmtree(self._path, ignore_errors=True)",
  "def read_wav(fname, verbose=None):\n    \"\"\"Read in a WAV file\n\n    Parameters\n    ----------\n    fname : str\n        Filename to load.\n\n    Returns\n    -------\n    data : array\n        The WAV file data. Will be of datatype np.float64. If the data\n        had been saved as integers (typical), this function will\n        automatically rescale the data to be between -1 and +1.\n        The result will have dimension n_channels x n_samples.\n    fs : int\n        The wav sample rate\n    \"\"\"\n    fs, data = wavfile.read(fname)\n    data = np.atleast_2d(data.T)\n    orig_dtype = data.dtype\n    max_val = _get_dtype_norm(orig_dtype)\n    data = np.ascontiguousarray(data.astype(np.float64) / max_val)\n    _print_wav_info('Read', data, orig_dtype)\n    return data, fs",
  "def write_wav(fname, data, fs, dtype=np.int16, overwrite=False, verbose=None):\n    \"\"\"Write a WAV file\n\n    Parameters\n    ----------\n    fname : str\n        Filename to save as.\n    data : array\n        The data to save.\n    fs : int\n        The sample rate of the data.\n    format : numpy dtype\n        The output format to use. np.int16 is standard for many wav files,\n        but np.float32 or np.float64 has higher dynamic range.\n    \"\"\"\n    if not overwrite and op.isfile(fname):\n        raise IOError('File {} exists, overwrite=True must be '\n                      'used'.format(op.basename(fname)))\n    if not np.dtype(type(fs)).kind == 'i':\n        fs = int(fs)\n        warnings.warn('Warning: sampling rate is being cast to integer and '\n                      'may be truncated.')\n    data = np.atleast_2d(data)\n    if np.dtype(dtype).kind not in ['i', 'f']:\n        raise TypeError('dtype must be integer or float')\n    if np.dtype(dtype).kind == 'f':\n        if not _has_scipy_version('0.13'):\n            raise RuntimeError('cannot write float datatype unless '\n                               'scipy >= 0.13 is installed')\n    elif np.dtype(dtype).itemsize == 8:\n        raise RuntimeError('Writing 64-bit integers is not supported')\n    if np.dtype(data.dtype).kind == 'f':\n        if np.dtype(dtype).kind == 'i' and np.max(np.abs(data)) > 1.:\n            raise ValueError('Data must be between -1 and +1 when saving '\n                             'with an integer dtype')\n    _print_wav_info('Writing', data, data.dtype)\n    max_val = _get_dtype_norm(dtype)\n    data = (data * max_val).astype(dtype)\n    wavfile.write(fname, fs, data.T)",
  "def _print_wav_info(pre, data, dtype):\n    \"\"\"Helper to print WAV info\"\"\"\n    logger.info('{0} WAV file with {1} channel{3} and {2} samples '\n                '(format {4})'.format(pre, data.shape[0], data.shape[1],\n                                      's' if data.shape[0] != 1 else '',\n                                      dtype))",
  "def _get_dtype_norm(dtype):\n    \"\"\"Helper to get normalization factor for a given datatype\"\"\"\n    if np.dtype(dtype).kind == 'i':\n        info = np.iinfo(dtype)\n        maxval = min(-info.min, info.max)\n    else:  # == 'f'\n        maxval = 1.0\n    return maxval",
  "def read_tab(fname, group_start='trial_id', group_end='trial_ok'):\n    \"\"\"Read .tab file from expyfun output\n\n    Parameters\n    ----------\n    fname : str\n        Input filename.\n    group_start : str\n        Key to use to start a trial/row.\n    group_end : str | None\n        Key to use to end a trial/row. If None, the next ``group_start``\n        will end the current group.\n\n    Returns\n    -------\n    data : list of dict\n        The data, with a dict for each trial. Each value in the dict\n        is a list of tuples (event, time) for each occurrence of that\n        key.\n    \"\"\"\n    # load everything into memory for ease of use\n    with open(fname, 'r') as f:\n        csvr = csv.reader(f, delimiter='\\t')\n        lines = [c for c in csvr]\n\n    # first two lines are headers\n    assert (len(lines[0]) == 1 and lines[0][0][0] == '#')\n    #metadata = ast.literal_eval(lines[0][0][2:])\n    assert lines[1] == ['timestamp', 'event', 'value']\n    lines = lines[2:]\n\n    # determine the event fields\n    header = list(set([l[1] for l in lines]))\n    header.sort()\n    if group_start not in header:\n        raise ValueError('group_start \"{0}\" not in header: {1}'\n                         ''.format(group_start, header))\n    if group_end == group_start:\n        raise ValueError('group_start cannot equal group_end, use '\n                         'group_end=None')\n    header = [header.pop(header.index(group_start))] + header\n    b1s = np.where([line[1] == group_start for line in lines])[0]\n    if group_end is None:\n        b2s = np.concatenate((b1s[1:], [len(lines)]))\n    else:  # group_end is not None\n        if group_end not in header:\n            raise ValueError('group_end \"{0}\" not in header ({1})'\n                             ''.format(group_end, header))\n        header.append(header.pop(header.index(group_end)))\n        b2s = np.where([line[1] == group_end for line in lines])[0]\n    if len(b1s) != len(b2s) or not np.all(b1s < b2s):\n        raise RuntimeError('bad bounds:\\n{0}\\n{1}'.format(b1s, b2s))\n    data = []\n    for b1, b2 in zip(b1s, b2s):\n        assert lines[b1][1] == group_start  # prevent stupidity\n        if group_end is not None:\n            b2 = b2 + 1  # include the end\n            assert lines[b2 - 1][1] == group_end\n        d = dict()\n        these_times = [float(line[0]) for line in lines[b1:b2]]\n        these_keys = [line[1] for line in lines[b1:b2]]\n        these_vals = [line[2] for line in lines[b1:b2]]\n        for ki, key in enumerate(header):\n            idx = np.where(key == np.array(these_keys))[0]\n            d[key] = [(these_vals[ii], these_times[ii]) for ii in idx]\n        data.append(d)\n    return data",
  "def read_hdf5(fname):\n    \"\"\"Read python object from HDF5 format using h5io/h5py\n\n    Parameters\n    ----------\n    fname : str\n        File to load.\n\n    Returns\n    -------\n    data : object\n        The loaded data. Can be of any type supported by ``write_hdf5``.\n    \"\"\"\n    return _read_hdf5(fname, title='expyfun')",
  "def write_hdf5(fname, data, overwrite=False, compression=4):\n    \"\"\"Write python object to HDF5 format using h5io/h5py\n\n    Parameters\n    ----------\n    fname : str\n        Filename to use.\n    data : object\n        Object to write. Can be of any of these types:\n            {ndarray, dict, list, tuple, int, float, str}\n        Note that dict objects must only have ``str`` keys.\n    overwrite : bool\n        If True, overwrite file (if it exists).\n    compression : int\n        Compression level to use (0-9) to compress data using gzip.\n    \"\"\"\n    return _write_hdf5(fname, data, overwrite, compression, title='expyfun')",
  "def _freq_to_erbn(f):\n    \"\"\"Convert frequency to ERB number\"\"\"\n    return 21.4 * np.log10(0.00437 * f + 1)",
  "def _erbn_to_freq(e):\n    \"\"\"Convert ERB number to frequency\"\"\"\n    return (10 ** (e / 21.4) - 1) / 0.00437",
  "def get_band_freqs(fs, n_bands=16, freq_lims=(200., 8000.), scale='erb'):\n    \"\"\"Calculate frequency band edges.\n\n    Parameters\n    ----------\n    fs : float\n        Sample rate.\n    n_bands : int\n        Number of bands to use.\n    freq_lims : tuple\n        2-element list of lower and upper frequency bounds (in Hz).\n    scale : str\n        Scale on which to equally space the bands. Possible values are \"erb\",\n        \"log\" (base-2), and \"hz\".\n\n    Returns\n    -------\n    edges : list of tuples\n        low- and high-cutoff frequencies for the bands.\n    \"\"\"\n    freq_lims = np.array(freq_lims, float)\n    fs = float(fs)\n    if np.any(freq_lims >= fs / 2.):\n        raise ValueError('frequency limits must not exceed Nyquist')\n    assert freq_lims.ndim == 1 and freq_lims.size == 2\n    if scale not in ('erb', 'log', 'hz'):\n        raise ValueError('Frequency scale must be \"erb\", \"hz\", or \"log\".')\n    if scale == 'erb':\n        freq_lims_erbn = _freq_to_erbn(freq_lims)\n        delta_erb = np.diff(freq_lims_erbn) / n_bands\n        cutoffs = _erbn_to_freq(freq_lims_erbn[0] +\n                                delta_erb * np.arange(n_bands + 1))\n        assert np.allclose(cutoffs[[0, -1]], freq_lims)  # should be\n    elif scale == 'log':\n        freq_lims_log = np.log2(freq_lims)\n        delta = np.diff(freq_lims_log) / n_bands\n        cutoffs = 2. ** (freq_lims_log[0] + delta * np.arange(n_bands + 1))\n        assert np.allclose(cutoffs[[0, -1]], freq_lims)  # should be\n    else:  # scale == 'hz'\n        delta = np.diff(freq_lims) / n_bands\n        cutoffs = freq_lims[0] + delta * np.arange(n_bands + 1)\n    edges = zip(cutoffs[:-1], cutoffs[1:])\n    return(edges)",
  "def get_bands(data, fs, edges, order=2, zero_phase=False, axis=-1):\n    \"\"\"Separate a signal into frequency bands\n\n    Parameters\n    ----------\n    data : array-like\n        Data array.\n    fs : float\n        Sample rate.\n    edges : list\n        List of tuples of band cutoff frequencies.\n    order : int\n        Order of analysis and synthesis.\n        NOTE: Using too high an order can cause instability,\n        always check outputs for order > 2!\n    zero_phase : bool\n        Use zero-phase forward-backward filtering.\n    axis : int\n        Axis to operate over.\n\n    Returns\n    -------\n    bands, filts : list of tuples\n        List of tuples (ndarray of bandpassed signal,\n                        (numerator, denominator coefficients of filter))\n    \"\"\"\n    data = np.atleast_1d(np.array(data, float))  # will make a copy\n    fs = float(fs)\n    bands = []\n    filts = []\n    for lf, hf in edges:\n        # band-pass\n        b, a = butter(order, [2 * lf / fs, 2 * hf / fs], 'bandpass')\n        filt = filtfilt if zero_phase else lfilter\n        band = filt(b, a, data, axis=axis)\n        bands.append(band)\n        filts.append((b, a))\n    return(bands, filts)",
  "def get_env(data, fs, lp_order=4, lp_cutoff=160., zero_phase=False, axis=-1):\n    \"\"\"Calculate a low-pass envelope of a signal\n\n    Parameters\n    ----------\n    data : array-like\n        Data array.\n    fs : float\n        Sample rate.\n    lp_order : int\n        Order of the envelope low-pass.\n    lp_cutoff : float\n        Cutoff frequency of the envelope low-pass.\n    zero_phase : bool\n        Use zero-phase forward-backward filtering.\n    axis : int\n        Axis to operate over.\n\n    Returns\n    -------\n    env : numpy.ndarray\n        The rectified and low-pass filtered envelope of ``data``.\n    filt : tuple\n        The filter coefficients (numerator, denominator).\n    \"\"\"\n    if lp_cutoff >= fs / 2.:\n        raise ValueError('frequency limits must not exceed Nyquist')\n    cutoff = 2 * lp_cutoff / float(fs)\n    data[data < 0] = 0.  # half-wave rectify\n    b, a = butter(lp_order, cutoff, 'lowpass')\n    filt = filtfilt if zero_phase else lfilter\n    env = filt(b, a, data, axis=axis)\n    return(env, (b, a))",
  "def get_carriers(data, fs, edges, order=2, axis=-1, mode='tone', rate=None,\n                 seed=None):\n    \"\"\"Generate carriers for frequency bands of a signal\n\n    Parameters\n    ----------\n    data : array-like\n        Data array.\n    fs : float\n        Sample rate.\n    edges : list\n        List of tuples of band cutoff frequencies.\n    order : int\n        Order of analysis and synthesis.\n        NOTE: Using too high an order can cause instability,\n        always check outputs for order > 2!\n    axis : int\n        Axis to operate over.\n    mode : str\n        The type of signal used to excite each band. Options are \"noise\" for\n        band-limited noise, \"tone\" for sinewave-at-center-frequency, or\n        \"poisson\" for a poisson process of band-limited clicks at the rate\n        given by ``rate``.\n    rate : int\n        The mean rate of stimulation when ``mode=='poisson'`` (in clicks per\n        second). Ignored when ``mode != 'poisson'``.\n    seed : np.random.RandomState | int | None\n        Random seed to use. If ``None``, no seeding is done.\n\n    Returns\n    -------\n    carrs : list of numpy.ndarrays\n        List of numpy ndarrays of the carrier signals.\n    \"\"\"\n    # check args\n    if mode not in ('noise', 'tone', 'poisson'):\n        raise ValueError('mode must be \"noise\", \"tone\", or \"poisson\", not {0}'\n                         ''.format(mode))\n    if isinstance(seed, np.random.RandomState):\n        rng = seed\n    elif seed is None:\n        rng = np.random\n    elif isinstance(seed, int):\n        rng = np.random.RandomState(seed)\n    else:\n        raise TypeError('\"seed\" must be an int, an instance of '\n                        'numpy.random.RandomState, or None.')\n    carrs = []\n    fs = float(fs)\n    n_samp = data.shape[axis]\n    for lf, hf in edges:\n        if mode == 'tone':\n            cf = (lf + hf) / 2.\n            carrier = np.sin(2 * np.pi * cf * np.arange(n_samp) / fs)\n            carrier *= np.sqrt(2)  # rms of 1\n            shape = np.ones_like(data.shape)\n            shape[axis] = n_samp\n            carrier.shape = shape\n        else:\n            if mode == 'noise':\n                carrier = rng.rand(*data.shape)\n            else:  # mode == 'poisson'\n                prob = rate / fs\n                with warnings.catch_warnings(record=True):  # numpy silliness\n                    carrier = rng.choice([0., 1.], n_samp, p=[1 - prob, prob])\n            b, a = butter(order, [2 * lf / fs, 2 * hf / fs], 'bandpass')\n            carrier = lfilter(b, a, carrier, axis=axis)\n            carrier /= np.sqrt(np.mean(carrier * carrier, axis=axis,\n                                       keepdims=True))  # rms of 1\n        carrs.append(carrier)\n    return(carrs)",
  "def vocode(data, fs, n_bands=16, freq_lims=(200., 8000.), scale='erb',\n           order=2, lp_cutoff=160., lp_order=4, mode='noise',\n           rate=200, seed=None, axis=-1, verbose=None):\n    \"\"\"Vocode stimuli using a variety of methods\n\n    Parameters\n    ----------\n    data : array-like\n        Data array.\n    fs : float\n        Sample rate.\n    n_bands : int\n        Number of bands to use.\n    freq_lims : tuple\n        2-element list of lower and upper frequency bounds.\n    scale : str\n        Scale on which to equally space the bands. Possible values are \"erb\",\n        \"log\" (base-2), and \"hz\".\n    order : int\n        Order of analysis and synthesis.\n        NOTE: Using too high an order can cause instability,\n        always check outputs for order > 2!\n    lp_cutoff : float\n        Frequency of the envelope low-pass.\n    lp_order : int\n        Order of the envelope low-pass.\n    mode : str\n        The type of signal used to excite each band. Options are \"noise\" for\n        band-limited noise, \"tone\" for sinewave-at-center-frequency, or\n        \"poisson\" for a poisson process of band-limited clicks at the rate\n        given by ``poisson_rate``.\n    rate : int\n        Average number of clicks per second for the poisson train used to\n        excite each band (when mode==\"poisson\").\n    seed : int | None\n        Random seed to use. If ``None``, no seeding is done.\n    axis : int\n        Axis to operate over.\n\n    Returns\n    -------\n    voc : array-like\n        Vocoded stimuli of the same shape as data.\n\n    Notes\n    -----\n    The default settings are adapted from a cochlear implant simulation\n    algorithm described by Zachary Smith (Cochlear Corp.).\n    \"\"\"\n    edges = get_band_freqs(fs, n_bands=n_bands, freq_lims=freq_lims,\n                           scale=scale)\n    bands, filts = get_bands(data, fs, edges, order=order, axis=axis)\n    envs, env_filts = zip(*[get_env(x, fs, lp_order=lp_order,\n                                    lp_cutoff=lp_cutoff, axis=axis)\n                            for x in bands])\n    carrs = get_carriers(data, fs, edges, order=order, axis=axis, mode=mode,\n                         rate=rate, seed=seed)\n    # reconstruct\n    voc = np.zeros_like(data)\n    for carr, env in zip(carrs, envs):\n        voc += carr * env\n    return voc",
  "def _check_n_bits(n_bits):\n    \"\"\"Helper to make sure we have a usable number of bits\"\"\"\n    if not isinstance(n_bits, int):\n        raise TypeError('n_bits must be an integer')\n    if n_bits < 2 or n_bits > _max_bits:\n        raise ValueError('n_bits must be between 2 and %s' % _max_bits)",
  "def _max_len_wrapper(n_bits):\n    \"\"\"Maximum Length Sequence (MLS) generator\n\n    Parameters\n    ----------\n    n_bits : int\n        Number of bits to use. Length of the resulting sequence will\n        be ``(2**n) - 1``. Only values between 2 and 15 supported.\n\n    Returns\n    -------\n    seq : array\n        Resulting MLS sequence of -1's and 1's.\n    \"\"\"\n    n_bits = int(n_bits)\n    _check_n_bits(n_bits)\n    # This was used to generate the sequences:\n    #from scipy.signal import max_len_seq\n    #_mlss = np.concatenate([max_len_seq(n) > 0\n    #                        for n in range(2, _max_bits + 1)])\n    #with open(_mls_file, 'wb') as fid:\n    #    fid.write(_mlss.tostring())\n    _lims = np.cumsum([0] + [2 ** n - 1 for n in range(2, 15)])\n    _mlss = np.fromfile(_mls_file, dtype=bool)\n    _mlss = [_mlss[l1:l2].copy() for l1, l2 in zip(_lims[:-1], _lims[1:])]\n    return _mlss[n_bits - 2] * 2. - 1",
  "def repeated_mls(n_samp, n_repeats):\n    \"\"\"Generate a repeated MLS 0/1 signal for finding an impulse response\n\n    Parameters\n    ----------\n    n_samp : int\n        The estimated maximum number of samples in the impulse response.\n    n_repeats : int\n        The number of repeats to use.\n    \"\"\"\n    if not isinstance(n_samp, int) or not isinstance(n_repeats, int):\n        raise TypeError('n_samp and n_repeats must both be integers')\n    n_bits = max(int(np.ceil(np.log2(n_samp + 1))), 2)\n    if n_bits > _max_bits:\n        raise ValueError('Only lengths up to %s supported'\n                         % (2 ** _max_bits - 1))\n    mls = 0.5 * _max_len_seq(n_bits) + 0.5\n    n_resp = len(mls) * (n_repeats + 1) - 1\n    mls = np.tile(mls, n_repeats)\n    return mls, n_resp",
  "def compute_mls_impulse_response(response, mls, n_repeats, verbose=None):\n    \"\"\"Compute the impulse response from data obtained using MLS\n\n    Parameters\n    ----------\n    response : array\n        Response of the system to the repeated MLS.\n    mls : array\n        The MLS presented to the system.\n    n_repeats : int\n        Number of repeats used.\n    \"\"\"\n    if mls.ndim != 1 or response.ndim != 1:\n        raise ValueError('response and mls must both be one-dimensional')\n    if not isinstance(n_repeats, int):\n        raise TypeError('n_repeats must be an integer')\n    if not np.array_equal(np.sort(np.unique(mls)), [0, 1]):\n        raise ValueError('MLS must be sequence of 0s and 1s')\n    if mls.size % n_repeats != 0:\n        raise ValueError('MLS length (%s) is not a multiple of the number '\n                         'of repeats (%s)' % (mls.size, n_repeats))\n    mls_len = mls.size // n_repeats\n    n_bits = int(np.round(np.log2(mls_len + 1)))\n    n_check = 2 ** n_bits\n    if n_check != mls_len + 1:\n        raise RuntimeError('length of MLS must be one shorter than a power '\n                           'of 2, got %s (close to %s)' % (mls_len, n_check))\n    logger.info('MLS using %s bits detected' % n_bits)\n    n_len = response.size + 1\n    if n_len % mls_len != 0:\n        n_rep = int(np.round(n_len / float(mls_len)))\n        n_len = mls_len * n_rep - 1\n        raise ValueError('length of data must be one shorter than a '\n                         'multiple of the MLS length (%s), found a length '\n                         'of %s which is close to %s (%s repeats)'\n                         % (mls_len, response.size, n_len, n_rep))\n    # Now that we know our signal, we can actually deconvolve.\n    # First, wrap the end back to the beginning\n    resp_wrap = response[:n_repeats * mls_len].copy()\n    resp_wrap[:mls_len - 1] += response[n_repeats * mls_len:]\n    # Compute the circular crosscorrelation, w/correction for MLS scaling\n    correction = np.empty(len(mls))\n    correction.fill(1. / (2 ** (n_bits - 2) * n_repeats))\n    correction[0] = 1. / ((4 ** (n_bits - 1)) * n_repeats)\n    y = np.real(ifft(correction * fft(resp_wrap) * fft(mls).conj()))\n    # Average out repeats\n    h_est = np.mean(np.reshape(y, (n_repeats, mls_len)), axis=0)\n    return h_est",
  "def window_edges(sig, fs, dur=0.01, axis=-1, window='hann', edges='both'):\n    \"\"\"Window the edges of a signal (e.g., to prevent \"pops\")\n\n    Parameters\n    ----------\n    sig : array-like\n        The array to window.\n    fs : float\n        The sample rate.\n    dur : float\n        The duration to window on each edge. The default is 0.01 (10 ms).\n    axis : int\n        The axis to operate over.\n    window : str\n        The window to use. For a list of valid options, see\n        ``scipy.signal.get_window()``.\n    edges : str\n        Can be ``'leading'``, ``'trailing'``, or ``'both'`` (default).\n\n    Returns\n    -------\n    windowed_sig : array-like\n        The modified array (float64).\n    \"\"\"\n    fs = float(fs)\n    sig = np.array(sig, dtype=np.float64)  # this will make a copy\n    sig_len = sig.shape[axis]\n    win_len = int(dur * fs)\n    if win_len > sig_len:\n        raise RuntimeError('cannot create window of size {0} samples (dur={1})'\n                           'for signal with length {2}'\n                           ''.format(win_len, dur, sig_len))\n    win = signal.windows.get_window(window, 2 * win_len)[:win_len]\n    valid_edges = ('leading', 'trailing', 'both')\n    if edges not in valid_edges:\n        raise ValueError('edges must be one of {0}, not \"{1}\"'\n                         ''.format(valid_edges, edges))\n    # now we can actually do the calculation\n    flattop = np.ones(sig_len, dtype=np.float64)\n    if edges in ('trailing', 'both'):  # eliminate trailing\n        flattop[-win_len:] *= win[::-1]\n    if edges in ('leading', 'both'):  # eliminate leading\n        flattop[:win_len] *= win\n    shape = np.ones_like(sig.shape)\n    shape[axis] = sig.shape[axis]\n    flattop.shape = shape\n    sig *= flattop\n    return sig",
  "def rms(data, axis=-1, keepdims=False):\n    \"\"\"Calculate the RMS of a signal\n\n    Parameters\n    ----------\n    data : array-like\n        Data to operate on.\n    axis : int | None\n        Axis to operate over. None will operate over the flattened array.\n    keepdims : bool\n        Keep dimension operated over.\n    \"\"\"\n    return np.sqrt(np.mean(data * data, axis=axis, keepdims=keepdims))",
  "def play_sound(sound, fs=None, norm=True, wait=False):\n    \"\"\"Play a sound\n\n    Parameters\n    ----------\n    sound : array\n        1D or 2D array of sound values.\n    fs : int | None\n        Sample rate. If None, the sample rate will be inferred from the sound\n        file (if sound is array, it is assumed to be 44100).\n    norm : bool\n        If True, normalize sound to between -1 and +1.\n    wait : bool\n        If True, wait until the sound completes to return control.\n\n    Returns\n    -------\n    snd : instance of SoundPlayer\n        The object playing sound. Can use \"stop\" to stop playback. Note that\n        the sound player will be cleared/deleted once the sound finishes\n        playing.\n    \"\"\"\n    sound = np.array(sound)\n    fs_in = 44100\n    if isinstance(sound, string_types):\n        sound, fs_in = read_wav(sound)\n    if fs is None:\n        fs = fs_in\n    if sound.ndim == 1:  # make it stereo\n        sound = np.array((sound, sound))\n    if sound.ndim != 2:\n        raise ValueError('sound must be 1- or 2-dimensional')\n    if norm:\n        m = np.abs(sound).max() * 1.000001\n        m = m if m != 0 else 1\n        sound /= m\n    if np.abs(sound).max() > 1.:\n        warnings.warn('Sound exceeds +/-1, will clip')\n    snd = SoundPlayer(sound, fs)\n    dur = sound.shape[1] / float(fs)\n    snd.play()  # will clip as necessary\n    del_wait = 0.5\n    if wait:\n        wait_secs(dur)\n    else:\n        del_wait += dur\n    if hasattr(snd, 'delete'):  # for backward compatibility\n        Timer(del_wait, snd.delete).start()\n    return snd",
  "def _resample_error(*args, **kwargs):\n    \"\"\"mne-python is required to use the resample function\n    \"\"\"\n    raise ImportError('mne-python is required to use the resample function')",
  "def _get_hrtf(angle, source, fs):\n    \"\"\"Helper to sub-select proper BRIR\n\n    HRTF files must be .hdf5 files written by ``write_hdf5``. The dict stored\n    in that file must contain the following: ``brir``: the BRIR data with shape\n    (n_angles, 2, n_time_points); ``angles``: the angles (all within [0, 180])\n    of the BRIRs; ``fs``: the sampling rate.\n\n    The amplitude should be normalized such that the sum of squares of the\n    0-degree BRIRs (mean of that across channels) is equal to 1. This will\n    ensure that the RMS of a white signal filtered with this signal is\n    unchanged.\n    \"\"\"\n    fname = fetch_data_file('hrtf/{0}_{1}.hdf5'.format(source, fs))\n    data = read_hdf5(fname)\n    angles = data['angles']\n    leftward = False\n    read_angle = angle\n    if angle < 0:\n        leftward = True\n        read_angle = -angle\n    if read_angle not in angles:\n        raise ValueError('angle \"{0}\" must be one of +/-{1}'\n                         ''.format(angle, list(angles)))\n    brir = data['brir']\n    idx = np.where(angles == read_angle)[0]\n    assert len(idx) == 1\n    brir = brir[idx[0]].copy()\n    return brir, data['fs'], leftward",
  "def convolve_hrtf(data, fs, angle, source='barb'):\n    \"\"\"Convolve a signal with a head-related transfer function\n\n    Technically we will be convolving with binaural room impluse\n    responses (BRIRs), but HRTFs (freq-domain equiv. representations)\n    are the common terminology.\n\n    Parameters\n    ----------\n    data : 1-dimensional or 1xN array-like\n        Data to operate on.\n    fs : float\n        The sample rate of the data. (HRTFs will be resampled if necessary.)\n    angle : float\n        The azimuthal angle of the HRTF.\n    source : str\n        Source to use for HRTFs. Currently `'barb'` and `'cipic'` are\n        supported. The former is default for legacy purpose. The latter is\n        recommended for new experiments.\n\n    Returns\n    -------\n    data_hrtf : array\n        A 2D array ``shape=(2, n_samples)`` containing the convolved data.\n\n    Notes\n    -----\n    CIPIC data downloaded from:\n\n        http://earlab.bu.edu/databases/collections/cipic/Default.aspx.\n\n    Additional documentation:\n\n        http://earlab.bu.edu/databases/collections/cipic/documentation/hrir_data_documentation.pdf  # noqa\n\n    The data were modified to suit our experimental needs. Below is the\n    liceneing information for the CIPIC data:\n\n    **Copyright**\n\n    Copyright (c) 2001 The Regents of the University of California. All Rights\n    Reserved.\n\n    **Disclaimer**\n\n    THE REGENTS OF THE UNIVERSITY OF CALIFORNIA MAKE NO REPRESENTATION OR\n    WARRANTIES WITH RESPECT TO THE CONTENTS HEREOF AND SPECIFICALLY DISCLAIM\n    ANY IMPLIED WARRANTIES OR MERCHANTABILITY OR FITNESS FOR ANY PARTICULAR\n    PURPOSE.\n\n    Further, the Regents of the University of California reserve the right to\n    revise this software and/or documentation and to make changes from time to\n    time in the content hereof without obligation of the Regents of the\n    University of California to notify any person of such revision or change.\n\n    Use of Materials\n    The Regents of the University of California hereby grant users permission\n    to reproduce and/or use materials available therein for any purpose-\n    educational, research or commercial. However, each reproduction of any part\n    of the materials must include the copyright notice, if it is present.\n\n    In addition, as a courtesy, if these materials are used in published\n    research, this use should be acknowledged in the publication. If these\n    materials are used in the development of commercial products, the Regents\n    of the University of California request that written acknowledgment of such\n    use be sent to:\n\n    CIPIC- Center for Image Processing and Integrated Computing University of\n    California 1 Shields Avenue Davis, CA 95616-8553\n    \"\"\"\n    fs = float(fs)\n    angle = float(angle)\n    known_sources = ['barb', 'cipic']\n    known_fs = [24414, 44100]  # must be sorted\n    if source not in known_sources:\n        raise ValueError('Source \"{0}\" unknown, must be one of {1}'\n                         ''.format(source, known_sources))\n    data = np.array(data, np.float64)\n    data = _fix_audio_dims(data, n_channels=1).ravel()\n\n    # Find out which sampling rate to get--first that is >= fs\n    # Use the last, highest one whether it is high enough or not\n    ge = [int(np.round(fs)) <= k for k in known_fs[:-1]] + [True]\n    brir_fs = known_fs[ge.index(True)]\n\n    brir, brir_fs, leftward = _get_hrtf(angle, source, brir_fs)\n    order = [1, 0] if leftward else [0, 1]\n    if not np.allclose(brir_fs, fs, rtol=0, atol=0.5):\n        brir = [resample(b, fs, brir_fs) for b in brir]\n    out = np.array([np.convolve(data, brir[o]) for o in order])\n    return out"
]